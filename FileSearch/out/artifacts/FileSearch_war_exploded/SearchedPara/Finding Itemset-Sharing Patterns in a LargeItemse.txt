 Since the origin of the field of data mining, frequent pattern mining has been one of the main topics of interests for rese archers in this field. These researchers initially worked on itemset patterns [1, 2] in the context of market basket anal-ysis; these studies were later extended to event sequence patterns [3]. Recently, graph-structured data have attracted considerable attention [4 X 6] because graph pattern mining can be applied to many interesting application areas such as bi-ological networks, social networks, a nd the Web. While itemset mining seeks frequent combinations of items in a set of tuples, graph mining seeks frequent subgraphs in a set of graphs. Most of the prior studies have addressed only one type of their patterns, and only a few st udies have consider ed combinatorial mining of two types of data structures [7 X 9].

In this paper, we consider a new combinatorial mining problem of itemsets and subgraphs, which we call the itemset-sharing subgraph (ISS) set enumeration prob-lem. Let us assume that we have a graph in which each vertex is associated with an itemset (Fig. 1(A)). We refer to this graph as an itemset-associated graph .Our task is to enumerate the patterns that we call the ISS set, which is a set of large subgraphs in which all vertices share a large common itemset. The ISS set shown in Fig. 1(B) consists of two subgraphs depicted by the bold lines. All vertices in the ISS set share the itemset { i 1 ,i 2 } . Although the subgraph consisting of only v 8 also shares the itemset, it is not included in the ISS set since it is quite small. Similarly, to be an ISS set since the shared itemse tisverysmall.TheISSsetenumeration problem differs from other graph mining problems in the sense that the subgraphs included in an ISS set need not be identical.

We now illustrate how ISS sets are used in drug discovery. Let us consider the metabolic pathway networks, which d escribe biochemical processes occurring within a cell. A pathway is represented a s a graph, where vertices denote genes and chemical compounds and edges denote chemical reactions among the genes and the compounds. The pathway networks play a considerably important role in drug discovery, because by finding a sub-pathway that is closely related to a disease, we can determine the target genes or chemical compounds on which the drug candidate should act. However, the drug candidate can affect several dif-ferent pathways simultaneously, which may lead to unexpected outcomes. Such phenomena are called side effects. We would like to not only find the drug targets but also predict the side effects that may be caused by the action of the drug on the targets. Taking the drugs into account, we considered a pathway network to be an itemset-associated graph (Fig. 1(A)), where each vertex (a gene or a chemical compound) is associated with an itemset that indicates the set of drugs activating the gene or the compound ( { i 1 ,i 2 ,...,i 5 } shown in Fig. 1(A)). In the above context, an ISS set (Fig. 1(B)) corresponds to a set of sub-pathways that share the common activation drug; this implies that there are hidden or unknown connections among the sub-pathways and that the drugs designed to target genes or compounds in one sub-pathway might also act on the other sub-pathways. In Fig. 1(B), the sub-pathway consisting of only v 8 is also activated by the drugs { i vation would result from accidental observations. Large sub-pathways are more reliable and indicate that the side effect s are more serious because these effects cover a wide range of pathway networks. Similarly, we expect that as the size of the set of common activation drugs increases, the possibility of the occurrence of side effects increases. Therefore, networks that consist of the large sub-pathways with a large set of activation drugs are important clues in predicting side effects for drug discovery and biol ogical experimental design.

Let us now consider a marketing scenario in social network analysis. In social networks, vertices are considered to be participants, and edges are considered to be the relationships between these participants (e.g., friendships). Let us as-sume that each participant (vertex) is associated with the items that he or she has bought. The network can be considered to be an itemset-associated graph, and the subgraphs with large common itemsets can be regarded as underlying communities. Further, in a social netw ork, common itemsets shared by many communities are considered as the (sets of) products that can be easily mar-keted through word-of-mouth communication; hence, the products with common features would be suitable for social marketing.

In order to solve the ISS set enumeration problem, one approach is to use an itemset mining technique [1, 2] to obtain all the frequent itemsets and then check-ing the connections between the itemsets i n the networks. However, the itemset mining in real dataset are very long computation time because the supports (frequencies) of the items included in t he ISS sets are usually low. To overcome the computation time problem, we pro pose an efficient algorithm called ROBIN . The ROBIN algorithm consists of two stages; it enumerates subgraphs that are larger than a specified threshold valu e at the first stage, and then it combines them at the second stage. By introducing effective pruning techniques in both the stages, we can enumerate the graphs very efficiently.

Finally, the efficiency of the proposed a lgorithm is shown in the experiments by using a synthetic dataset. ROBIN can solve problems with more than 100K vertices and 1 , 000K edges for about a half hour. In the experiments using a real biological network, we discover hidden connections in metabolic pathways; this suggests the practical utility of ROBIN in the context of drug discovery. Furthermore, by applying ROBIN to a citation network, we find interesting pat-terns indicating successful collaborative works containing well-known database research topics. In both of the real dataset experiments, we show that execution time of ROBIN are faster than that of the method which first enumerates the itemset and then checks their connectivity.

Our contributions are summarized as follows: 1. We introduce the ISS set enumeration problem, which has sound potential 2. We propose a very efficient algorithm called ROBIN to solve the ISS set 3. We conduct experiments using two real-world network data, a biological net-In this section, we introduce a novel data mining problem for analyzing itemset-associated graphs, which we refer to a s the ISS set enumeration problem.
Let G be an undirected 1 , unlabelled, and unweighted graph with an itemset on each vertex. We refer to this graph as an itemset-associated graph (IA graph) . Let V ( G ), E ( G )and I ( G ) respectively signify a set of the vertices in G ,asetof edges in G and a set of itemsets on vertices in G . Note that the size of graph G is given as the number of edges, i.e., | G | = | E ( G ) | .
 We next define subgraphs whose vertices share itemsets.
 Definition 1. (Shared Itemset) Let G be a connected subgraph of an IA graph G ,where G is also an IA graph. We define I ( G ) as I ( G )= and refer to I ( G ) as a shared itemset of G .
 Among the subgraphs having a shared itemset, we focus on an important subset, which cannot be expanded while retaining the currently shared itemsets. Definition 2. (Itemset-Sharing Subgraph (ISS)) We call G an itemset-sharing subgraph (ISS) with I ( G ) if I ( G ) =  X  and I ( v )  X  I ( G ) for any vertex v in the neighbor vertices of G .
 Note that the itemset shared by an ISS is defined without reference to its edges.
Now, we define the sets of ISSes that we want to enumerate in our task. As described in Section 1, sets of ISSes are useful in the context of drug discovery and marketing in social networks.
 Definition 3. (ISS Set) Let G = { G 1 ,G 2 ,...,G n } be a set of ISSes, where each G i is an ISS. Define I ( We call G an ISS set with I ( G ) , if all of the following conditions are satisfied: (1) V ( G i )  X  V ( G j )=  X  for any G i and G j ( i = j ) in G .(2) I ( v )  X  I ( G ) for any vertex v in the neighbor vertices of G  X  X  .(3) | G i | X   X  S ,where  X  S is a user-specified value. (4) No ISS G with I ( G ) exists except in G . The first two conditions are an extension of the definition of ISS for dealing with multiple ISSes. The third condition gives the minimum size of the obtained ISSes because larger ISSes are of greater interest to us. The last condition ensures the maximality of the found ISS sets. Let |G| indicate the number of disconnected components of G , and hence, |G| = n .

Finally, we define our new data mining problem where the task is to enumerate all ISS sets from a given IA graph. Definition 4. (ISS Set Enumeration Problem) Given an IA graph and user-specified values  X  S ,  X  I and  X  F , from the IA graph, enumerate all ISS sets G satisfying |G|  X   X  F , | I ( G ) | X   X  I for any ISS set G X  G ,and | G | X   X  S for any ISS G  X  X  in any ISS set G X  G . In this section, we propose an efficient algorithm called ROBIN (RelatiOn Be-tween Items and Networks) for solving t he ISS set enumeration problem. To solve the problem, one strategy first enumerates all the itemsets such as Apri-ori [1] and FP-trees [2], and then check th e connectivity between the itemsets. The other strategy first enumerates the subgraphs, and then check the condi-tions of the subgraphs. Here, we use the latter method. We will show that the computing time of the former method re quires longer than the latter method using real dataset in Section 4.

Robin consists of two stages. In the first stage, we enumerate all the ISSes efficiently by introducing DFS itemset tree and visited itemset table . Their de-tails are described in Section 3.1. In t he second stage, we generate ISS sets by combining the ISSes according to Section 3 .2. In order to enumerate the ISS sets efficiently, we introduce an ISS prefix tree that contains the prefix of itemsets and their associated ISSes. 3.1 ISS Enumeration In the first stage of the ROBIN, we enumerate ISSes from the given IA graph. We introduce efficient techniques for the enumeration of ISSes in this section. In the second stage of ROBIN, the obtained I SSes are combined with the generated ISS sets (Section 3.2).

We use a depth-first search (DFS) tree for enumerating ISSes G where | G | X   X  S and | I ( G ) | X   X  I for G  X  X  . Each node of the tree contains a vertex and an itemset related to the path from the root to the node. We denote the tree as a DFS itemset tree . On the DFS itemset tree, we do not need to maintain edges because I ( G ) can be computed from vert ices and their itemsets.

The generation of the subgraphs itself is considered to be a simplified version of the DFS lexicographic order used in the gSpan algorithm [6], and hence, this DFS itemset tree can avoid duplicate generation of identical graphs. Fig. 2 shows the DFS itemset tree for the IA graph in Fig. 1(A). Each node in the DFS itemset tree contains a vertex and an itemset. The vertices included in the path from the root to the tree node represent the vertices of the subgraph.

Thanks to the following monotonic property of ISS about itemset size, we can prune subtrees in the DFS itemset tree, which dramatically reduces the search space.
 Property 1. Let us denote two ISSes by G and G ,andlet V ( G )  X  V ( G ) . Then, I ( G )  X  I ( G ) holds.
 The tree nodes indicated by dotted boxes in Fig. 2 can be pruned by using this property when  X  I =2.

The next theorem allows us to avoid generating subgraphs that have the same vertices as those of already generated subgraphs and have itemsets that are subsets of itemsets associated wi th the already generated graphs. Theorem 1. Let n 1 and n 2 be a pair of nodes of the DFS itemset tree, where n 1 was generated before n 2 . If vertices associated with n 1 and n 2 are identical, and I ( n 1 )  X  I ( n 2 ) , no ISS exists in a descendant of n 2 .
 This theorem implies that if we visit one of already visited vertices and the common itemset of the current path is identical to or a subset of one of the itemsets of the previously visited vertices, we can prune the subtree rooted by the current node in the DFS itemset tree. Therefore, this property is useful for avoiding unnecessary exploration of subgraphs.

Theorem 1 prompts us to make the hash table from nodes to their related itemsets for efficient pruning of subgraphs. We call the hash table a visited item-set table and build it while constructing a DFS itemset tree.

Using the DFS itemset tree, we can gener ate all ISSes whose subgraph size is greater than  X  S and common itemset si ze is greater than  X  I . Fig. 3(A) illustrates the ISSes and their associated itemsets. We refer to this table as the ISS table . In the next section, in order to enumerate ISS sets efficiently, we introduce an efficient method of generatin g combinations of the ISSes. 3.2 ISS Set Combination In this section, we introduce an efficient method for enumerating ISS sets from the ISS table created in the previous section. One simple method for computing the ISS sets is to generate combinations of all the ISSes. However, this procedure is quite redundant because different combinations of ISSes may result in the same shared itemset. Our metho d generates ISS sets efficiently by grouping ISSes by shared itemsets. Once we fix one itemse t, an ISS set sharing the itemset is uniquely determined. Therefore, one approach to enumerating all ISS sets is to generate all itemsets that can be asso ciated with ISS sets. For the efficient generation of the itemsets, we use the depth first search.
 Definition 5. (ISS Tree) Let T I be a tree, each of whose node n contains itemset I ( n ) and a set of ISSes G ( n ) which shares I ( n ) . The root of T I contains an itemset including all items and a vacant set of ISSes. Let n 1 and n 2 be a pair of nodes of T I .When n 1 is an ascendant of n 2 , I ( n 1 )  X  I ( n 2 ) . We call the tree ISS tree . Nodes closer to the root contain larger itemset. A child of a node in the ISS tree can be generated by adding an ISS to a parent node X  X  ISSes, and its shared itemset can be computed. Thanks to the monotonic property of itemset size, we ca n prune subtrees in the ISS tree.

Although we can enumerate all the combinations of ISSes by the simple DFS method, the size of ISS tree may increase considerably especi ally when the num-ber of ISSes is large. In order to efficientl y generate the ISS tree, we add a group of ISSes sharing an itemset to ISSes in its parent node.

We here divide ISS sets into two types: explicit ISS sets and implicit ISS sets. Explicit ISS sets are associated with itemset appeared in an ISS table, while implicit ISS sets are associated with itemset which is a subset of itemsets appeared in the ISS table. We first generate explicit ISS sets quickly using prefix tree structure, and then produce implicit ISS sets by the combinations of explicit ISS sets.
 Definition 6. (Explicit and Implicit ISS Set) Let G be all the ISSes in an ISS table, and I ( G ) be itemsets associated with ISSes in G .Let G I be an ISS set with I .When I  X  X  ( G ) ,wecall G I an explicit ISS set; otherwise we call G I an implicit ISS set.
 Basis of the above definition, any ISS set can be classified as explicit or implicit.
For the efficient generation of all ISS set s, we first extract all of the explicit ISS sets, and then generate ISS sets by removing overlapping ISSes. The following theorem guarantees us to generate all the ISS sets.
 Theorem 2. Let G I be G C  X  X  G | G  X  G where G, G  X  X  c } .Then, G I is an ISS set with I .
 This theorem allows us to generate the explicit ISS sets with I . All the explicit ISS sets can be generated by computing G I for all the itemsets in the ISS table. However, the procedure requires many checks related to the inclusion relations among graphs. Here, we introduce an effic ient way to generate explicit ISS sets by using a prefix tree representing itemsets.
 Definition 7. (ISS Prefix Tree) Let T P be a tree, each of whose nodes n contains an item i n and an ISS set G ( n ) . Let denote two nodes in T P by n 1 and where n 1 is an ascendant of n 2 .Then, i n 1 &lt;i n 2 holds. Any itemset I in the ISS table is represented by a path in T P . The ISS set in node n in T P shares an itemset represented by a corresponding path from the root to n .
 We call the tree an ISS prefix tree . Using the ISS prefix tree, we represent all the associations between the itemsets contained in the ISS table and the ISSes. Fig. 3(B) represents the ISS prefix tree of Fig. 3(A). We put no ISSes to nodes whose depth is less than  X  I because none of the nodes generate ISS sets. Thanks to this prefix tree structure, we can accelerate the finding of the associations between itemsets and explicit ISS sets.
We here generate itemsets shared by implicit ISS sets by using the combination of two explicit ISS sets. From the items et, we generate ISS sets by using the ISS prefix tree. The following theorem guarantees that the combinations can enumerate all of the implicit ISS sets.
 Theorem 3. Any itemset shared by an implicit ISS set is represented by the intersection of the itemsets shared by some of the explicit ISS sets. On the basis of this theorem, we can gen erate implicit ISS sets by using com-binations of the itemsets shared by exp licit ISS sets. Therefore, we generate a DFS tree each of whose nodes contai ns an itemset and an ISS set. We can prune the branches in the ISS tree from the monotonic property in Definition 5. Furthermore, the following property substantially reduces the search space. Property 2. Let node n containanitemset I ( n ) and an ISS set G ( n ) .If I ( n ) and an itemset I of an existing node are identical, we need not traverse the branch rooted by n .
 To use these pruning techniques, we need not calculate inclusion relations be-tween graphs in ISSes. In this section, we present the results of our experiments using a synthetic dataset and two real-world datasets. 4.1 Results for a Synthetic Network We generated a synthetic network dataset in order to evaluate the performance of the ROBIN algorithm. The parameters for ROBIN and their default values are presented in Table 1. We generated synthetic datasets having | V | vertices and | E | edges. Each dataset includes P ISS sets whose shared itemset size is | I | and size of ISS set is F . Moreover, we add the fake itemsets whose size is 1 . 7  X | I | .The detail procedure is omitted due to the space limitation. All experiments were performed using a 3 . 2 GHz AMD R Opteron TM machine with 1 GB memory running on Linux kernel 2.6. We implemented ROBIN in Java TM 5.

We investigated the efficiency of the ROBIN algorithm by using the synthetic network data and varying the size of the network, the average size of itemsets, and the parameters for ROBIN.

In order to investigate the efficiency of enumerating combinations of the ISSes in ROBIN, we measured the execution times in the case of ROBIN (labeled as  X  X OBIN X ) and the times in the case of the algorithm in which we replace the ISS tree and the groups of ISSes generated by ISS prefix tree with the standard DFS tree by adding single ISS to its parent node to generate combinations of ISSes (labeled as  X  X FS tree X ). We also show the execution times required for enumerating ISSes (Section 3.1) because these times are independent of the approach we choose. The differences between the execution times of ROBIN and ISS enumeration and those of the DFS tree approach and ISS enumeration indicate the computing time required to enumerate the combinations of ISSes.
Fig. 4(A) presents the execution times by varying the number of nodes in the network. This figure depicts that our method is more scalable than the alter-native approach. The largest network in this experiment has 100K vertices and one million edges. The execution times increase quadratically with respect to the increase in the number of vertices. In par ticular, the larger the graph becomes, the larger is the execution time differenc e between the two approaches. Because the support (ratio of the number of vertices in ISS sets to the total number of vertices) was F  X  S/ | V | =0 . 0023, when the values were set to the default values, it is difficult to find itemset patterns using the Apriori algorithm [1] and the FP-trees [2]. In contrast , ROBIN can work with such a low support and can still find important itemsets because it uses subgraphs that connect the itemsets.
Fig. 4(B) shows the execution times by varying the number of degrees in the network. In general, the execution time increases rapidly according to the density of the graph, because we need to check m any neighbor vertices. However, our result demonstrates that the execution time of ROBIN increases rather gradually. We can observe that as the degree of the graph increases, the difference between the execution times of the two methods in creases. This observation verifies the computational efficiency of ROBIN.

Next,weinvestigatetheperformanceofROBINbyvaryingtheitemsetsize shared in ISSes. The dependence of the execution time on the itemset size is shown in Fig. 4(C). As shown in the figure, the average itemset size is not significant impact to ROBIN. Note that the algorithms succeeded in finding ISS sets with relatively large itemsets (more than 10 items). This result is in contrast to that of the existing studies on mining long patterns [10], in which finding low-frequency itemset pa tterns efficiently is difficult. 4.2 Results for a Biological Network We applied ROBIN to a real metabolic pathway dataset with 6 , 152 vertices and 3 , 318 edges; here, the vertices and edg es represent genes and chemical in-teractions, respectively. The dataset was obtained under 173 different stressed conditions [11] by using yeast microarrays. Each of the conditions causes stim-uli to cells, and finding stimuli associated with treatments of diseases is a good starting point for development of new dr ugs. Therefore, we used the set of the conditions as the items. In biological systems, highly expressed genes play an important role within the cells. Therefore, we converted the quantitative values into Boolean values using a threshold t . We set the parameters as t =1 . 5,  X  S =7,  X 
I =5and  X  F = 4. The average itemset size in the dataset was 4 . 78, and its exe-cution time was 35 . 9 seconds. We extracted eight ISS sets in total. One of the ISS sets depicted in Fig. 5 was associated with the conditions of 8 hours, 10 hours, 1 day, 2 days and 3 days grown under YPD condition at 30 degree Celsius; all of these conditions are high-nutrition and high-temperature conditions. Conse-quently, our algorithm could extract biologically consistent conditions automat-ically. The four connected graphs were a ssociated with four biological metabolic pathways. Some genes in Fig. 5(C) are known as the activator of the TCA cy-cle including Fig. 5(A). Also associated pathways with Fig 5(D) are related to TCA cycle, and hence, the relationship bet ween these two ISS sets is biologically reasonable. 4.3 Results for a Citation Network We applied ROBIN to a citation network consisting of academic papers to demonstrate that ROBIN ca n extract successful collabo rative researches auto-matically.

We create a citation network from the DBLP dataset [12], which is a snapshot of the DBLP as of April 12, 2006. Each vertex in the network corresponds to a paper and is associated with an itemset representing the author of the paper. Each edge indicates a citation. The DBLP network has 22 , 178 vertices (papers), 112 , 304 edges (citations), and 16 , 638 items (authors). All papers have at least one author and one reference. The average number of authors for a paper is 2 . 29. We set the parameters for ROBIN as  X  I =2,  X  S = 10, and  X  F =2.

Table 2 summarizes the six ISS sets found by ROBIN. The columns represent the ISS sets number, co-authors, number s of disconnected networks, number of references in the ISS set, and number of papers in the ISSes. For example, the ISS set No.1 consists of three different I SSes, and the ISS set contains 23 papers and 30 references.

The research topics corresponding to the three ISSes in the ISS set No.1 are multi-databases , video-on-demand storage ,and main memory databases .This result implies that Rajeev Rastogi and Abraham Silberschatz have successfully collaborated on three different research topics. In recent years, graph mining has received i ncreasing interest from researchers. Frequent subgraph discovery methods [4 X 6, 13] enable us to enumerate all fre-quent common-structured subgraphs in a graph database. In this study, we are not concerned about the structure of the subgraph, and the existing methods cannot handle itemsets on subgraphs, hence we cannot apply the existing meth-ods to our problem directly.

For the discovery of ISS sets, one straightforward approach might be to use the frequent pattern or closed itemse tminingmethods[1,2,14,15]andthen to check the connection among the found itemsets in the networks. However, in Section 4, we demonstrated that this a pproach is not efficient and requires huge amount of memory, which implies the effectiveness of ROBIN X  X  approach which enumerates all subgraphs first.

The combinatorial mining of networks with numerical vectors has been studied in constrained clustering [7, 9]. The studies attempt to find the simultaneous clustering of the vertices in a network an d the numerical vectors associated with the vertices. One significant difference b etween our problem and these problems is that the associated features on every ver tex are discrete values in our problem. This property makes it difficult to apply the constrained clustering methods to our problem. MATISSE [16] and CoPaM [17] study the combinatorial mining of networks with feature vectors. Both methods find dense subgraphs whose vertices having similar features. However, we are not concerned about the density of the subgraph, and our method can find the sparse hubnetworkshowninFig.5(A). Hashimoto et al. [8] proposed a combinatorial mining of sequence structured data and tree structured data. Their approach can be naturally extended to handle graph structured data, but the goal of our problem is not the enumeration of frequent subgraphs. Seki and Sese [18] introduced a problem to find the largest connected common pattern graph. However in the present paper, we focus on enumerating frequent disconnected graphs. In this paper, we introduced a novel problem called ISS set enumeration prob-lem , which enumerates a set of large disco nnected subgraphs in which all vertices share a large common itemset. The problem has wide application such as in side effect analysis for drug discovery and in viral-marketing effect investigations. However, it is difficult to find the graphs because of the difficulty of handling itemsets and a graph structure simultaneously. We designed a novel algorithm called ROBIN in order to solve this problem efficiently. Our demonstration with synthetic data showed that our algorithm is effective even in the case of a large and dense graph. Using our method, we found interesting graphs and itemsets from both a biological network and a citation network. From a biological net-work, we demonstrated the applicability in biological research and drug discov-ery. From a citation network, we found in teresting patterns indicating successful collaborative works.

The problem of finding ISS sets is quite general and applicable to other itemset-associated graphs, and we are going to extend the applications to the others such as marketing in social networks and text analyses with Web links. This work was partially supported by KAKENHI (Grant-in-Aid for Scientific Research) on Priority Areas  X  X ystems Genomics X  from the Ministry of Educa-tion, Culture, Sports, Science and Technology of Japan. We thank Dr. Tsuyoshi Kato for fruitful discussions.

