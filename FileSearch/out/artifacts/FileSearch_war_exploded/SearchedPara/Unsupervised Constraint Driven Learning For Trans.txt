 Named entity (NE) transliteration is the process of transcribing a NE from a source language to some target language while preserving its pronunciation in the original language. Automatic NE transliteration is an important component in many cross-language applications, such as Cross-Lingual Information Re-trieval (CLIR) and Machine Translation(MT) (Her-mjakob et al., 2008; Klementiev and Roth, 2006a; Meng et al., 2001; Knight and Graehl, 1998).
It might initially seem that transliteration is an easy task, requiring only finding a phonetic mapping between character sets. However simply matching every source language character to its target lan-guage counterpart is not likely to work well as in practice this mapping depends on the context the characters appear in and on transliteration conven-tions which may change across domains. As a result, current approaches employ machine learning meth-ods which, given enough labeled training data learn how to determine whether a pair of words consti-tute a transliteration pair. These methods typically require training data and language-specific expertise which may not exist for many languages. In this pa-per we try to overcome these difficulties and show that when the problem is modeled correctly, a sim-ple character level mapping is a sufficient resource.
In our experiments, English was used as the source language, allowing us to use romanization ta-bles, a resource commonly-available for many lan-guages 1 . These tables contain an incomplete map-ping between character sets, mapping every charac-ter to its most common counterpart.

Our transliteration model takes a discriminative approach. Given a word pair, the model determines if one word is a transliteration of the other. The features used by this model are character n-gram matches across the two strings. For example, Fig-ure 1 describes the decomposition of a word pair into unigram features as a bipartite graph in which each edge represents an active feature.

We enhance the initial model with constraints, by framing the feature extraction process as a struc-tured prediction problem -given a word pair, the set of possible active features is defined as a set of latent binary variables. The contextual dependency be-tween features is encoded as a set of constraints over these variables. Features are extracted by finding an assignment that maximizes the similarity score between the two strings and conforms to the con-straints. The model is bootstrapped using a roman-ization table and uses a discriminatively self-trained classifier as a way to improve over several training iterations. Furthermore, when specific knowledge about the source and target languages exists, it can be directly injected into the model as constraints.
We tested our approach on three very differ-ent languages -Russian, a Slavic language, He-brew a Semitic language, and Chinese, a Sino-Tibetan language. In all languages, using this sim-ple resource in conjunction with constraints pro-vided us with a robust transliteration system which significantly outperforms existing unsupervised ap-proaches and achieves comparable performance to supervised methods.
 The rest of the paper is organized as follows. Sec. 2 briefly examines more related work. Sec. 3 explains our model and Sec. 4 provide a linguistic intuition for it. Sec. 5 describes our experiments and evaluates our results followed by sec. 6 which con-cludes our paper. Transliteration methods typically fall into two cate-gories: generative approaches (Li et al., 2004; Jung et al., 2000; Knight and Graehl, 1998) that try to produce the target transliteration given a source lan-guage NE, and discriminative approaches (Gold-wasser and Roth, 2008b; Bergsma and Kondrak, 2007; Sproat et al., 2006; Klementiev and Roth, 2006a), that try to identify the correct translitera-tion for a word in the source language given several candidates in the target language. Generative meth-ods encounter the Out-Of-Vocabulary (OOV) prob-lem and require substantial amounts of training data and knowledge of the source and target languages. Discriminative approaches, when used to for dis-covering NE in a bilingual corpora avoid the OOV problem by choosing the transliteration candidates from the corpora. These methods typically make very little assumptions about the source and target languages and require considerably less data to con-verge. Training the transliteration model is typi-cally done under supervised settings (Bergsma and Kondrak, 2007; Goldwasser and Roth, 2008b), or weakly supervised settings with additional tempo-ral information (Sproat et al., 2006; Klementiev and Roth, 2006a). Our work differs from these works in that it is completely unsupervised and makes no assumptions about the training data.

Incorporating knowledge encoded as constraints into learning problems has attracted a lot of atten-tion in the NLP community recently. This has been shown both in supervised settings (Roth and Yih, 2004; Riedel and Clarke, 2006) and unsupervised settings (Haghighi and Klein, 2006; Chang et al., 2007) in which constraints are used to bootstrap the model. (Chang et al., 2007) describes an unsuper-vised training of a Constrained Conditional Model (CCM), a general framework for combining statisti-cal models with declarative constraints. We extend this work to include constraints over possible assign-ments to latent variables which, in turn, define the underlying representation for the learning problem.
In the transliteration community there are sev-eral works (Ristad and Yianilos, 1998; Bergsma and Kondrak, 2007; Goldwasser and Roth, 2008b) that show how the feature representation of a word pair can be restricted to facilitate learning a string sim-ilarity model. We follow the approach discussed in (Goldwasser and Roth, 2008b), which considers the feature representation as a structured prediction problem and finds the set of optimal assignments (or feature activations), under a set of legitimacy con-straints. This approach stresses the importance of interaction between learning and inference, as the model iteratively uses inference to improve the sam-ple representation for the learning problem and uses the learned model to improve the accuracy of the in-ference process. We adapt this approach to unsu-pervised settings, where iterating over the data im-proves the model in both of these dimensions. In this section we present our Unsupervised Con-straint Driven Learning ( UCDL ) model for discov-ering transliteration pairs. Our task is in essence a ranking task. Given a NE in the source language and a list of candidate transliterations in the target lan-guage, the model is supposed to rank the candidates and output the one with the highest score. The model is bootstrapped using two linguistic resources: a ro-manization table and a set of general and linguistic constraints. We use several iterations of self training to learn the model. The details of the procedure are explained in Algorithm 1.

In our model features are character pairs ( c s , c t ), where c s  X  C s is a source word character and c t  X  C t is a target word character. The feature representation of a word pair v s , v t is denoted by F ( v W ( c ize the weights vector using the romanization table.
Given a pair ( v s , v t ) , a feature extraction process is used to determine the feature based representation of the pair. Once features are extracted to represent a pair, the sum of the weights of the extracted fea-tures is the score assigned to the target translitera-tion candidate. Unlike traditional feature extraction approaches, our feature representation function does not produce a fixed feature representation. In step 2.1, we formalize the feature extraction process as a constrained optimization problem that captures the interdependencies between the features used to rep-resent the sample. That is, obtaining F ( v s , v t ) re-quires solving an optimization problem. The techni-cal details are described in Sec. 3.1. The constraints we use are described in Sec. 3.2.

In step 2.2 the different candidates for every source NE are ranked according to the similarity score associated with their chosen representation. This ranking is used to  X  X abel X  examples for a dis-criminative learning process that learns increasingly better weights, and thus improve the representation of the pair: each source NE paired with its top ranked transliteration is labeled as a positive exam-ples (step 2.3) and the rest of the samples are consid-ered as negative samples. In order to focus the learn-ing process, we removed from the training set all negative examples ruled-out by the constraints (step 2.4). As the learning process progresses, the initial weights are replaced by weights which are discrimi-natively learned (step 2.5). This process is repeated several times until the model converges, and repeats the same ranking over several iterations.
 Algorithm 1: UCDL Transliteration Framework.
In the rest of this section we explain this process in detail. We define the feature extraction inference process in Sec. 3.1, the constraints used in Sec. 3.2 and the inference algorithm in Sec. 3.3. The linguis-tic intuition for our model is described in Sec. 4. 3.1 Finding Feature Representation as We use the formulation of Constrainted Conditional Models (CCMs) (Roth and Yih, 2004; Roth and Yih, 2007; Chang et al., 2008). Previous work on CCM models dependencies between different decisions in structured prediction problems. Transliteration dis-covery is a binary classification problem, however, the underlying representation of each sample can be modeled as a CCM, defined as a set of latent vari-ables corresponding to the set of all possible features for a given sample. The dependencies between the features are captured using constraints.

Given a word pair, the set of all possible features consists of all character mappings from the source word to the target word. Since in many cases the size of the words differ we augment each of the words with a blank character (denoted as  X   X ). We model character omission by mapping the character to the blank character. This process is formally de-fined as an operator mapping a transliteration can-didate pair to a set of binary variables, denoted as All -Features ( AF ) .
 This representation is depicted at the top of Figure 1.
The initial sample representation ( AF ) gener-ates features by coupling substrings from the two terms without considering the dependencies be-tween the possible combinations. This representa-tion is clearly noisy and in order to improve it we select a subset F  X  AF of the possible features. The selection process is formulated as a linear op-timization problem over binary variables encoding feature activations in AF . Variables assigned 1 are selected to be in F , and those assigned 0 are not. The objective function maximized is a linear func-tion over the variables in AF , each with its weight as a coefficient, as in the left part of Equation 1 below. We seek to maximize this linear sum subject to a set of constraints. These represent the dependencies be-tween selections and prior knowledge about possible legitimate character mappings and correspond to the right side of Equation 1. In our settings only hard constraints are used and therefore the penalty (  X  ) for violating any of the constraints is set to  X  . The spe-cific constraints used are discussed in Sec. 3.2. The score of the mapping F ( v lows: We normalize this score by dividing it by the size of the target word, since the size of candidates varies, normalization improved the ranking of candidates.
The result of the optimization process is a set F of active features, defined in Equation 2. The result of this process is described at the bottom of Figure 1. The ranking process done by our model can now be naturally defined -given a source word v s , and a set of candidates target words v 0 candidate whose optimal representation maximizes Equation 1. This process is defined in Equation 3. 3.2 Incorporating Mapping Constraints We consider two types of constraints: language spe-cific and general constraints that apply to all lan-guages. Language specific constraints typically im-pose a local restriction such as individually forcing some of the possible character mapping decisions. The linguistic intuition behind these constraints is discussed in Section 4. General constraints encode global restrictions, capturing the dependencies be-tween different mapping decisions.
 General constraints: To facilitate readability we denote the feature mapping the i -th source word character to the j -th target word character as a Boolean variable a ij that is 1 if that feature is active and 0 otherwise.  X  Coverage -Every character must be mapped  X  No Crossing -Every character mapping, except Language specific constraints  X  Restricted Mapping : These constraints restrict  X  Length restriction : An additional constraint
In addition to biasing the model to choose the right candidate, the constraints also provide a com-putational advantage: a given a word pair is elimi-nated from consideration when the length restriction is not satisfied or there is no way to satisfy the re-stricted mapping constraints. 3.3 Inference The optimization problem defined in Equation 2 is an integer linear program (ILP). However, given the structure of the problem it is possible to de-velop an efficient dynamic programming algorithm for it, based on the algorithm for finding the mini-mal edit distance of two strings. The complexity of finding the optimal set of features is only quadratic in the size of the input pair, a clear improvement over the ILP exponential time algorithm. The al-gorithm minimizes the weighted edit distance be-tween the strings, and produces a character align-ment that satisfies the general constraints (Sec. 3.2). Our modifications are only concerned with incorpo-rating the language-specific constraints into the al-gorithm. This can be done simply by assigning a negative infinity score to any alignment decision not satisfying these constraints. Our model is bootstrapped using two resources -a romanization table and mapping constraints. Both resources capture the same information -character mapping between languages. The distinction be-tween the two represents the difference in the con-fidence we have in these resources -the romaniza-tion table is a noisy mapping covering the character set and is therefore better suited as a feature. Con-straints, represented by pervasive, correct character mapping, indicate the sound mapping tendency be-tween source and target languages. For example, certain n-gram phonemic mappings, such as r  X  l from English to Chinese, are language specific and can be captured by language specific sound change patterns.

These patterns have been used by other systems as features or pseudofeatures (Yoon et al., 2007). However, in our system these language specific rule-of-thumbs are systematically used as constraints to exclude impossible alignments and therefore gener-ate better features for learning. We listed in Table 1 all 20 language specific constraints we used for Chi-nese. There is a total of 24 constraints for Hebrew and 17 for Russian.

The constraints in Table 1 indicate a systematic sound mapping between English and Chinese un-igram character mappings. Arranged by manners of articulation each row of the table indicates the sound change tendency among vowels, nasals, ap-proximants (retroflex and glides), fricatives and plo-sives. For example, voiceless plosive sounds such as p, t in English, tend to map to both voiced (such as b, d ) and voiceless sounds in Chinese. However, if the sound is voiceless in Chinese, its backtrack English sound must be voiceless. This voice-voiceless sound change tendency is captured by our constraints such as p  X  b, p and p  X  p ; t  X  t . In this section, we demonstrate the effectiveness of constraint driven learning empirically. We start by describing the datasets and experimental settings and then proceed to describe the results. We eval-uated our method on three very different target lan-guages: Russian, Chinese, and Hebrew , and com-pared our results to previously published results. 5.1 Experimental Settings In our experiments the system is evaluated on its ability to correctly identify the gold transliteration for each source word. We evaluated the system X  X  performance using two measures adopted in many transliteration works. The first one is Mean Recip-rocal Rank (MRR), used in (Tao et al., 2006; Sproat et al., 2006), which is the average of the multiplica-tive inverse of the rank of the correct answer. For-mally, Let n be the number of source NEs. Let Gol-dRank(i) be the rank the algorithm assigns to the correct transliteration. Then, MRR is defined by: Another measure is Accuracy (ACC) used in (Kle-mentiev and Roth, 2006a; Goldwasser and Roth, 2008a), which is the percentage of the top rank can-didates being the gold transliteration. In our im-plementation we used the support vector machine (SVM) learning algorithm with linear kernel as our underlying learning algorithm (mentioned in part 2.5 of Algorithm 1) . We used the package LIB-LINEAR (Hsieh et al., 2008) in our experiments. Through all of our experiments, we used the 2-norm hinge loss as our loss function and fixed the regular-ization parameter C to be 0.5. 5.2 Datasets We experimented using three different target lan-guages Russian, Chinese, and Hebrew . We used En-glish as the source language in all these experiments.
The Russian data set 2 , originally introduced in (Klementiev and Roth, 2006b), is comprised of tem-porally aligned news articles. The dataset contains 727 single word English NEs with a correspond-ing set of 50,648 potential Russian candidate words which include not only name entities, but also other words appearing in the news articles.
 The Chinese dataset is taken directly from an English-Chinese transliteration dictionary, derived from LDC Gigaword corpus 3 . The entire dictionary consists of 74,396 pairs of English-Chinese NEs, where Chinese NEs are written in Pinyin , a roman-ized spelling system of Chinese. In (Tao et al., 2006) a dataset which contains about 600 English NEs and 700 Chinese candidates is used. Since the dataset is not publicly available, we created a dataset in a similar way. We randomly selected approximately 600 NE pairs and then added about 100 candidates which do not correspond to any of the English NE previously selected.

The Hebrew dataset, originally introduced in (Goldwasser and Roth, 2008a), consists of 300 English-Hebrew pairs extracted from Wikipedia. 5.3 Results We begin by comparing our model to previously published models tested over the same data, in two different languages, Russian and Hebrew. For Rus-sian, we compare to the model presented in (Kle-mentiev and Roth, 2006b), a weakly supervised al-gorithm that uses both phonetic information and temporal information. The model is bootstrapped using a set of 20 labeled examples. In their setting the candidates are ranked by combining two scores, one obtained using the transliteration model and a second by comparing the relative occurrence fre-quency of terms over time in both languages. Due to computational tractability reasons we slightly changed Algorithm 1 to use only a small subset of the possible negative examples.

For Hebrew, we compare to the model presented in (Goldwasser and Roth, 2008b), a supervised model trained using 250 labeled examples. This model uses a bigram model to represent the translit-eration samples (i.e., features are generated by pair-ing character unigrams and bigrams). The model also uses constraints to restrict the feature extrac-tion process, which are equivalent to the coverage constraint we described in Sec. 3.2.

The results of these experiments are reported us-ing the evaluation measures used in the original pa-pers and are summarized in Table 2. The results show a significant improvement over the Russian data set and comparable performance to the super-vised method used for Hebrew.

Figure 2 describes the learning curve of our method over the Russian dataset. We compared our algorithm to two models described in (Klementiev and Roth, 2006b) -one uses only phonetic simi-larity and the second also considers temporal co-occurrence similarity when ranking the translitera-tion candidates. Both models converge after 50 it-erations. When comparing our model to their mod-els, we found that even though our model ignores the temporal information it achieves better results and converges after fewer iterations. Their results report a significant improvement when using tempo-ral information -improving an ACC score of 41% without temporal information to 63% when using it. Since the temporal information is orthogonal to the transliteration model, our model should similarly benefit from incorporating the temporal information.
Figure 3 compares the learning curve of our method to an existing supervised method over the Hebrew data and shows we get comparable results.
Unfortunately, we could not find a published Chi-nese dataset. However, our system achieved similar results to other systems, over a different dataset with similar number of training examples. For example, (Sproat et al., 2006) presents a supervised system that achieves a MRR score of 0.89, when evaluated over a dataset consisting of 400 English NE and 627 Chinese words. Our results for a different dataset of similar size are reported in Table 3. 5.4 Analysis The resources used in our framework consist of -a romanization table, general and language spe-cific transliteration constraints. To reveal the impact of each component we experimented with different combination of the components, resulting in three different testing configurations.
 Romanization Table : We initialized the weight vector using a romanization table and did not use any constraints. To generate features we use a modified version of our AF operator (see Sec. 3), which gen-erates features by coupling characters in close posi-tions in the source and target words. This configura-tion is equivalent to the model used in (Klementiev and Roth, 2006b). +General Constraints : This configuration uses the romanization table for initializing the weight vector and general transliteration constraints (see Sec. 3.2) for feature extraction. +All Constraints : This configuration uses lan-guage specific constraints in addition to the gen-eral transliteration constraints to generate the feature representation. (see Sec. 4). +Learning : Indicates that after initializing the weight vector, we update the weight using Algo-rithm 1. In all of the experiments, we report the results after 20 training iterations.

The results are summarized in Table 3. Due to the size of the Russian dataset, we used a subset consist-ing of 300 English NEs and their matching Russian transliterations for the analysis presented here. Af-ter observing the results, we discovered the follow-ing regularities for all three languages. Using the romanization table directly without constraints re-sults in very poor performance, even after learning. This can be used as an indication of the difficulty of the transliteration problem and the difficulties ear-lier works have had when using only romanization tables, however, when used in conjunction with con-straints results improve dramatically. For example, in the English-Chinese data set, we improve MRR from 0.02 to 0.746 and for the English-Russian data set we improve 0.03 to 0.8. Interestingly, the results for the English-Hebrew data set are lower than for other languages -we achieve 0.53 MRR in this set-ting. We attribute the difference to the quality of the mapping in the romanization table for that lan-guage. Indeed, the weights learned after 20 train-ing iterations improve the results to 0.83. This im-provement is consistent across all languages, after learning we are able to achieve a MRR score of 0.87 for the English-Chinese data set and 0.91 for the English-Russian data set. These results show that romanization table contains enough information to bootstrap the model when used in conjunction with constraints. We are able to achieve results compa-rable to supervised methods that use a similar set of constraints and labeled examples.

Bootstrapping the weight vector using language specific constraints can further improve the results. They provide several advantages: a better starting point, an improved learning rate and a better final model. This is clear in all three languages, for exam-ple results for the Russian and Chinese bootstrapped models improve by 5%, and by over 20% for He-brew. After training the difference is smaller-only 3% for the first two and 6% for Hebrew. Figure 3 de-scribes the learning curve for models with and with-out language specific constraints for the English-Hebrew data set, it can be observed that using these constraints the model converges faster and achieves better results. In this paper we develop a constraints driven ap-proach to named entity transliteration. In doing it we show that romanization tables are a very useful resource for transliteration discovery if proper con-straints are included. Our framework does not need labeled data and does not assume that bilingual cor-pus are temporally aligned. Even without using any labeled data, our model is competitive to existing supervised models and outperforms existing weakly supervised models. We wish to thank the reviewers for their insightful comments. This work is partly supported by NSF grant SoD-HCER-0613885 and DARPA funding un-der the Bootstrap Learning Program.
