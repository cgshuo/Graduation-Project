 Several recent syntax-based models for machine translation (Chiang, 2005; Galle y et al., 2004) can be seen as instances of the general frame work of synchronous grammars and tree transducers. In this frame work, both alignment ( sync hronous par sing ) and decoding can be thought of as parsing problems, whose comple xity is in general exponential in the number of nonterminals on the right hand side of a grammar rule. To alle viate this problem, we investi-gate bilingual binarization to factor the synchronous grammar to a smaller branching factor , although it is not guaranteed to be successful for any synchronous rule with arbitrary permutation. In particular:  X  We develop a technique called sync hronous bi- X  We examine the effect of this binarization  X  We examine cases of non-binarizable rules in a
Melamed (2003) discusses binarization of multi-text grammars on a theoretical level, sho wing the importance and dif culty of binarization for efcient synchronous parsing. One way around this dif -culty is to stipulate that all rules must be binary from the outset, as in inversion-transduction gram-mar (ITG) (W u, 1997) and the binary synchronous conte xt-free grammar (SCFG) emplo yed by the Hi-ero system (Chiang, 2005) to model the hierarchical phrases. In contrast, the rule extraction method of Galle y et al. (2004) aims to incorporate more syn-tactic information by pro viding parse trees for the tar get language and extracting tree transducer rules that apply to the parses. This approach results in rules with man y nonterminals, making good bina-rization techniques critical.

Suppose we have the follo wing SCFG, where su-perscripts indicate reorderings (formal denitions of Figure 1: A pair of synchronous parse trees in the SCFG (1). The dashed curv es indicate pairs of syn-chronous nonterminals (and sub trees).
 SCFGs can be found in Section 2): (1) Decoding can be cast as a (monolingual) parsing problem since we only need to parse the source-language side of the SCFG, as if we were construct-ing a CFG projected on Chinese out of the SCFG. The only extra work we need to do for decoding is to build corresponding tar get-language (English) subtrees in parallel. In other words, we build syn-chronous trees when parsing the source-language in-put, as sho wn in Figure 1.

To efciently decode with CKY , we need to bi-narize the projected CFG grammar . 1 Rules can be binarized in dif ferent ways. For example, we could binarize the rst rule left to right or right to left: We call those intermediate symbols (e.g. V tual nonterminals and corresponding rules virtual rules , whose probabilities are all set to 1 .
These two binarizations are no dif ferent in the translation-model-only decoding described abo ve, just as in monolingual parsing. Ho we ver, in the source-channel approach to machine translation, we need to combine probabilities from the translation model (an SCFG) with the language model (an n -gram), which has been sho wn to be very impor -tant for translation quality (Chiang, 2005). To do bigram-inte grated decoding, we need to augment each chart item ( X , i, j ) with two tar get-language boundary wor ds u and v to produce a bigram-item ming algorithm of Wu (1996).

No w the two binarizations have very dif ferent ef-fects. In the rst case, we rst combine NP with PP: where p and q are the scores of antecedent items.
This situation is unpleasant because in the tar get-language NP and PP are not contiguous so we can-not apply language model scoring when we build the V boundary words (rather than two) and postpone the language model scoring till the next step where V We call this binarization method monolingual bina-rization since it works only on the source-language projection of the rule without respecting the con-straints from the other side.

This scheme generalizes to the case where we have n nonterminals in a SCFG rule, and the decoder conserv atively assumes nothing can be done on lan-guage model scoring (because tar get-language spans are non-contiguous in general) until the real nonter -minal has been recognized. In other words, tar get-language boundary words from each child nonter -minal of the rule will be cached in all virtual non-terminals deri ved from this rule. In the case of m -gram inte grated decoding, we have to maintain 2( m  X  1) boundary words for each child nontermi-nal, which leads to a prohibiti ve overall comple x-size (Huang et al., 2005). Aggressi ve pruning must be used to mak e it tractable in practice, which in general introduces man y search errors and adv ersely affects translation quality .

In the second case, howe ver:
Here since PP and VP are contiguous (but sw apped) in the tar get-language, we can include the Figure 2: The alignment pattern (left) and alignment matrix (right) of the synchronous production. language model score by adding Pr( with | meeting ) , and the resulting item again has two boundary words. Later we add Pr( held | Po well ) when the form an S item. As illustrated in Figure 2, V contiguous spans on both source and tar get sides, so that we can generate a binary-branching SCFG: (2)
In this case m -gram inte grated decoding can be done in O ( | w | 3+4( m  X  1) ) time which is much lower -order polynomial and no longer depends on rule size (W u, 1996), allo wing the search to be much faster and more accurate facing pruning, as is evidenced in the Hiero system of Chiang (2005) where he restricts the hierarchical phrases to be a binary SCFG. The benet of binary grammars also lies in synchronous parsing (alignment). Wu (1997) sho ws that parsing a binary SCFG is in O ( | w | 6 ) while parsing SCFG is NP-hard in general (Satta and Peserico, 2005).
The same reasoning applies to tree transducer rules. Suppose we have the follo wing tree-to-string rules, follo wing Galle y et al. (2004): (3) where the reorderings of nonterminals are denoted by variables x
Notice that the rst rule has a multi-le vel left-hand side subtree. This system can model non-isomorphic transformations on English parse trees to  X t X  another language, for example, learning that the ( S ( V O )) structure in English should be trans-formed into a ( V S O ) structure in Arabic, by look-ing at two-le vel tree fragments (Knight and Graehl, 2005). From a synchronous rewriting point of vie w, this is more akin to synchronous tree substitution grammar (STSG) (Eisner , 2003). This lar ger locality is linguistically moti vated and leads to a better pa-rameter estimation. By imagining the left-hand-side trees as special nonterminals, we can virtually cre-ate an SCFG with the same generati ve capacity . The technical details will be explained in Section 3.2.
In general, if we are given an arbitrary syn-chronous rule with man y nonterminals, what are the good decompositions that lead to a binary grammar? Figure 2 suggests that a binarization is good if ev-ery virtual nonterminal has contiguous spans on both sides. We formalize this idea in the next section. A synchr onous CFG (SCFG) is a conte xt-free rewriting system for generating string pairs. Each rule ( sync hronous production ) rewrites a nontermi-nal in two dimensions subject to the constraint that the sequence of nonterminal children on one side is a permutation of the nonterminal sequence on the other side. Each co-inde xed child nonterminal pair will be further rewritten as a unit. 2 We dene the language L ( G ) produced by an SCFG G as the pairs of terminal strings produced by rewriting exhaus-tively from the start symbol.

As sho wn in Section 3.2, terminals do not play an important role in binarization. So we now write rules in the follo wing notation: where each X terminals in the grammar and  X  is the permutation of the rule. We also dene an SCFG rule as n -ary if its permutation is of n and call an SCFG n -ary if its longest rule is n -ary . Our goal is to produce an equi valent binary SCFG for an input n -ary SCFG. Figure 3: (a) and (b): two binarization patterns for (2 , 3 , 5 , 4) . (c): alignment matrix for the non-binarizable permuted sequence (2 , 4 , 1 , 3)
Ho we ver, not every SCFG can be binarized. In fact, the binarizability of an n -ary rule is determined by the structure of its permutation, which can some-times be resistant to factorization (Aho and Ullman, 1972). So we now start to rigorously dene the bi-narizability of permutations. 2.1 Binarizable Permutations A permuted sequence is a permutation of consec-uti ve inte gers. For example, (3 , 5 , 4) is a permuted sequence while (2 , 5) is not. As special cases, single numbers are permuted sequences as well.

A sequence a is said to be binarizable if it is a permuted sequence and either 1. a is a singleton, i.e. a = ( a ) , or 2. a can be split into two sub sequences, i.e.
This is a recursi ve denition. Each binarizable permuted sequence has at least one hierarchical bi-narization pattern. For instance, the permuted se-quence (2 , 3 , 5 , 4) is binarizable (with two possible binarization patterns) while (2 , 4 , 1 , 3) is not (see Figure 3). 2.2 Binarizable SCFG An SCFG is said to be binarizable if the permu-tation of each synchronous production is binariz-able. We denote the class of binarizable SCFGs as bSCFG . This set represents an important subclass of SCFG that is easy to handle (parsable in O ( | w | 6 ) and covers man y interesting longer -than-tw o rules. 3 O ( | w | 6 ) parsable Figure 4: Subclasses of SCFG. The thick arro w de-notes the direction of synchronous binarization. For clarity reasons, binary SCFG is coded as SCFG-2. Theor em 1. For eac h grammar G in bSCFG, ther e exists a binary SCFG G 0 , suc h that L ( G 0 ) = L ( G ) Proof . Once we decompose the permutation of n in the original rule into binary permutations, all that remains is to decorate the skeleton binary parse with nonterminal symbols and attach terminals to the skeleton appropriately . We explain the technical details in the next section. We have reduced the problem of binarizing an SCFG rule into the problem of binarizing its permutation. This problem can be cast as an instance of syn-chronous ITG parsing (W u, 1997). Here the parallel string pair that we are parsing is the inte ger sequence (1 ...n ) and its permutation (  X  (1) ... X  ( n )) . The goal of the ITG parsing is to nd a synchronous tree that agrees with the alignment indicated by the permu-tation. In fact, as demonstrated pre viously , some permutations may have more than one binarization patterns among which we only need one. Wu (1997, Sec. 7) introduces a non-ambiguous ITG that prefers left-hea vy binary trees so that for each permutation there is a unique synchronous deri vation (binariza-tion pattern).

Ho we ver, this problem has more efcient solu-tions. Shapiro and Stephens (1991, p. 277) infor -mally present an iterati ve procedure where in each pass it scans the permuted sequence from left to right and combines two adjacent sub sequences whene ver possible. This procedure produces a left-hea vy bi-narization tree consistent with the unambiguous ITG and runs in O ( n 2 ) time since we need n passes in the worst case. We modify this procedure and impro ve Figure 5: Example of Algorithm 1 on the input (1 , 5 , 3 , 4 , 2) . The rightmost column sho ws the binarization-trees generated at each reduction step. it into a linear -time shift-reduce algorithm that only needs one pass through the sequence. 3.1 The linear -time skeleton algorithm The (unique) binarization tree bi ( a ) for a binariz-able permuted sequence a is recursi vely dened as follo ws:  X  if a = ( a ) , then bi ( a ) = a ;  X  otherwise let a = ( b ; c ) to be the rightmost
For example, the binarization tree for (2 , 3 , 5 , 4) is [[2 , 3] ,  X  5 , 4  X  ] , which corresponds to the binariza-tion pattern in Figure 3(a). We use [] and  X  X  for straight and inverted combinations respecti vely , fol-lowing the ITG notation (W u, 1997). The rightmost split ensures left-hea vy binary trees.

The skeleton binarization algorithm is an instance of the widely used left-to-right shift-reduce algo-rithm. It maintains a stack for contiguous subse-quences disco vered so far, lik e 2-5, 1. In each it-eration, it shifts the next number from the input and repeatedly tries to reduce the top two elements on the stack if the y are consecuti ve. See Algorithm 1 for details and Figure 5 for an example.
 Theor em 2. Algorithm 1 succeeds if and only if the input permuted sequence a is binarizable , and in case of success, the binarization pattern reco ver ed is the binarization tree of a .
 Proof .  X  : it is obvious that if the algorithm suc-ceeds then a is binarizable using the binarization pattern reco vered.  X  : by a complete induction on n , the length of a . Base case: n = 1 , trivial.
 Assume it holds for all n 0 &lt; n .

If a is binarizable, then let a = ( b ; c ) be its right-most binarizable split. By the induction hypothesis, the algorithm succeeds on the partial input b , reduc-ing it to the single element s [0] on the stack and re-covering its binarization tree bi ( b ) .

Let c = ( c gers our binarizer to mak e a straight combination of ( b ; c must be true that ( c nation. We claim that c situation. So, ( b , c right of the rightmost binarizable split ( b ; c ) , which is a contradiction. A similar contradiction will arise if b and c 1 can mak e an inverted concatenation.
Therefore, the algorithm will scan through the whole c as if from the empty stack. By the in-duction hypothesis again, it will reduce c into s [1] on the stack and reco ver its binarization tree bi ( c ) . Since b and c are combinable, the algorithm re-duces s [0] and s [1] in the last step, forming the bi-narization tree for a , which is either [ bi ( b ) , bi ( c )]  X  bi ( b ) , bi ( c )  X  .

The running time of Algorithm 1 is linear in n , the length of the input sequence. This is because there are exactly n shifts and at most n  X  1 reductions, and each shift or reduction tak es O (1) time. 3.2 Binarizing tree-to-string transducers Without loss of generality , we have discussed how to binarize synchronous productions involving only nonterminals through binarizing the corresponding skeleton permutations. We still need to tackle a few technical problems in the actual system.

First, we are dealing with tree-to-string trans-ducer rules. We vie w each left-hand side subtree as a monolithic nonterminal symbol and factor each transducer rule into two SCFG rules: one from the root nonterminal to the subtree, and the other from the subtree to the lea ves. In this way we can uniquely reconstruct the tree-to-string deri vation us-ing the two-step SCFG deri vation. For example, Algorithm 1 The Linear -time Binarization Algorithm consider the follo wing tree-to-string rule:
We create a specic nonterminal, say , T is a unique identier for the left-hand side subtree and generate the follo wing two SCFG rules:
Second, besides synchronous nonterminals, ter -minals in the two languages can also be present, as in the abo ve example. It turns out we can attach the terminals to the skeleton parse for the synchronous nonterminal strings quite freely as long as we can uniquely reconstruct the original rule from its binary parse tree. In order to do so we need to keep track of sub-alignments including both aligned nonterminals and neighboring terminals.

When binarizing the second rule abo ve, we rst run the skeleton algorithm to binarize the under -lying permutation (1 , 3 , 2) to its binarization tree [1 ,  X  3 , 2  X  ] . Then we do a post-order tra versal to the skeleton tree, combining Chinese terminals (one at a time) at the leaf nodes and mer ging English termi-nals greedily at internal nodes: A pre-order tra versal of the decorated binarization tree gives us the follo wing binary SCFG rules: where the virtual nonterminals are:
Analogous to the  X dotted rules X  in Earle y pars-ing for monolingual CFGs, the names we create for the virtual nonterminals reect the underlying sub-alignments, ensuring intermediate states can be shared across dif ferent tree-to-string rules without causing ambiguity .

The whole binarization algorithm still runs in time linear in the number of symbols in the rule (includ-ing both terminals and nonterminals). In this section, we answer two empirical questions. denotes that percentage among all permutations. 4.1 Ho w many rules are binarizable? It has been sho wn by Shapiro and Stephens (1991) and Wu (1997, Sec. 4) that the percentage of binariz-able cases over all permutations of length n quickly approaches 0 as n gro ws (see Figure 6). Ho we ver, for machine translation, it is more meaningful to compute the ratio of binarizable rules extracted from real text. Our rule set is obtained by rst doing word alignment using GIZA++ on a Chinese-English par -allel corpus containing 50 million words in English, then parsing the English sentences using a variant of Collins parser , and nally extracting rules using the graph-theoretic algorithm of Galle y et al. (2004). We did a  X spectrum analysis X  on the resulting rule set with 50,879,242 rules. Figure 6 sho ws how the rules are distrib uted against their lengths (number of nonterminals). We can see that the percentage of non-binarizable rules in each buck et of the same length does not exceed 25%. Ov erall, 99.7% of the rules are binarizable. Ev en for the 0.3% non-binarizable rules, human evaluations sho w that the majority of them are due to alignment errors. It is also interesting to kno w that 86.8% of the rules have monotonic permutations, i.e. either taking identical or totally inverted order . 4.2 Does synchr onous binarizer help decoding? We did experiments on our CKY -based decoder with two binarization methods. It is the responsibility of the binarizer to instruct the decoder how to compute the language model scores from children nontermi-nals in each rule. The baseline method is mono-lingual left-to-right binarization. As sho wn in Sec-tion 1, decoding comple xity with this method is ex-ponential in the size of the longest rule and since we postpone all the language model scorings, pruning in this case is also biased.
To mo ve on to synchronous binarization, we rst did an experiment using the abo ve baseline system without the 0 . 3% non-binarizable rules and did not observ e any dif ference in BLEU scores. So we safely mo ve a step further , focusing on the binariz-able rules only .

The decoder now works on the binary translation rules supplied by an external synchronous binarizer . As sho wn in Section 1, this results in a simplied de-coder with a polynomial time comple xity , allo wing less aggressi ve and more effecti ve pruning based on both translation model and language model scores.
We compare the two binarization schemes in terms of translation quality with various pruning thresholds. The rule set is that of the pre vious sec-tion. The test set has 116 Chinese sentences of no longer than 15 words. Both systems use trigram as the inte grated language model. Figure 7 demon-strates that decoding accurac y is signicantly im-pro ved after synchronous binarization. The number of edges proposed during decoding is used as a mea-sure of the size of search space, or time efcienc y. Our system is consistently faster and more accurate than the baseline system.

We also compare the top result of our syn-chronous binarization system with the state-of-the-art alignment-template approach (ATS) (Och and Ne y, 2004). The results are sho wn in Table 1. Our system has a promising impro vement over the ATS Figure 7: Comparing the two binarization methods in terms of translation quality against search effort. system which is trained on a lar ger data-set but tuned independently . Modeling reorderings between languages has been a major challenge for machine translation. This work sho ws that the majority of syntactic reorderings, at least between languages lik e English and Chinese, can be efciently decomposed into hierarchical bi-nary reorderings. From a modeling perspecti ve, on the other hand, it is benecial to start with a richer representation that has more transformational power than ITG or binary SCFG. Our work sho ws how to con vert it back to a computationally friendly form without harming much of its expressi veness. As a result, decoding with n -gram models can be fast and accurate, making it possible for our syntax-based system to overtak e a comparable phrase-based sys-tem in BLEU score. We belie ve that extensions of our technique to more powerful models such as syn-chronous tree-adjoining grammar (Shieber and Sch-abes, 1990) is an interesting area for further work. Ackno wledgments Much of this work was done when H. Zhang and L. Huang were visiting USC/ISI. The authors wish to thank Wei Wang, Jonathan Graehl and Ste ven DeNeefe for help with the experiments. We are also grateful to Daniel Marcu, Gior gio Satta, and Ara vind Joshi for discus-sions. This work was partially supported by NSF ITR IIS-09325646 and NSF ITR IIS-0428020.

