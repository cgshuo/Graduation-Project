 In this paper, we study a variant of reachability queries, called l abel-c onstraint r eachability (LCR) queries, specif-ically, given a label set S and two vertices u 1 and u 2 in a large directed graph G , we verify whether there exists a path from u 1 to u 2 under label constraint S . Like traditional reachability queries, LCR queries are very useful, such as pathway finding in biological networks, inferring over RDF ( r esource d escription f ramework) graphs, relationship find-ing in social networks. However, LCR queries are much more complicated than their traditional counterpart. Sev-eral techniques are proposed in this paper to minimize the search space in computing path-label transitive closure. Fur-thermore, we demonstrate the superiority of our method by extensive experiments.
 H.4 [ Information Systems Applications ]: Miscellaneous; H.2.8 [ Database Management ]: Database Applications X  Graph Database Algorithm corres ponding author: Lei Zou, zoulei@icst.pku.edu.cn  X 
Lei Zou and Dongyan Zhao were supported by NSFC under Grant No.61003009 and RFDP under Grant No. 20100001120029. Jeffrey Xu Yu was supported by RGC of the Hong Kong SAR under Grant No. 419008 and 419109. Lei Chen X  X  research is partially supported by HKUST SSRI11EG01 and NSFC No.60003074. Yanghua Xiao was supported by the NSFC under Grant No.61003001 and RFDP under Grant No. 20100071120032.

The growing popularity of graph databases has generated many interesting data management problems. One impor-tant type of queries over graphs are reachability queries [1, 2, 3, 4, 5, 6]. Specifically, given two vertices u 1 and u a directed graph G , we want to verify whether there ex-ists a directed path from u 1 to u 2 . There are many ap-plications of reachability queries, such as, pathway find-ing in biological networks [7], inferring over RDF ( r esource d escription f ramework) graphs [8], relationship finding in social networks [9]. There are two extreme solutions to an-swer reachability queries. One approach is to materialize the full transitive closures of G , enabling one to answer reacha-bility queries efficiently. In the other extreme, one can per-form DFS ( d epth-f irst s earch) or BFS ( b reath-f irst s earch) over graph G until reaching the target vertex, or the search process cannot be continued. Obviously, these two meth-ods cannot work in a large graph G , since the former needs O ( V 2 ) space to store the transitive closure (large index space cost), and the latter needs O ( V ) time in answering reach-ability queries (slow query response time). The key issue in reachability queries is how to find a good trade-off be-tween the two basic solutions. Therefore, many algorithms have been proposed, such as 2-hop [1, 10, 11], GRIPP [2], path-cover [5], tree-cover [2, 6], pathtree [3] and 3-hop [4], to address this issue.

In many real applications, edge labels are utilized to de-note different relationships between two vertices. For exam-ple, edge labels in RDF graphs denote different properties. We can also use edge labels to define different relationships in social networks. In this paper, we study a variant of reach-ability queries, called l abel-c onstraint r eachability (LCR) queries, which are originally proposed in [12]. Conceptually, LCR query verifies some specified type of relationships be-tween two vertices. Here, we give a motivation example to demonstrate the usefulness of LCR queries.

Let us consider an inference example in RDF Schema (RDFS for short) dataset in Figure 1. Assume that we want to verify whether  X  freshman  X  is a subclass of  X  people  X  . The traditional database system can simply answer no , since there exists no triple (  X  freshman  X  , rdfs:subclass ,  X  people  X  ). However, due to RDFS semantics,  X  X dfs:subclass X  is a tran-sitive property. Therefore, given two triples (  X  freshman  X  , we can infer that (  X  freshman  X  , rdfs: subclass ,  X  people  X  ). Therefore, the correct answer should be yes . This kind of queries are called inference queries . Obviously, it is pro-hibitive to materialize all inferred facts, according to RDFS reasoning rules, in a very large RDF dataset. Actually, some inference queries can be reduced into LCR queries over RDF graphs. For example, the above example can be transformed into the following LCR query: verifying whether there ex-ists a directed path from entry  X  freshman  X  to  X  people  X  in the RDF graph, where all edge labels along the path are  X  X dfs:subclass X .

Although LCR queries are quite useful, it is non-trivial to answer LCR queries over a large directed graph. Traditional indexing methods can only verify reachability without con-sidering how the connection is made between two vertices [12]. Furthermore, the traditional transitive closure does not contain path labels.

In order to address LCR queries efficiently, we make the following contributions in this work: 1) For LCR queries, we propose a method to transform an edge-labeled directed graph into an augmented DAG by representing the maximal strongly connected components as bipartite graphs . Then, based on the augmented DAG, we propose a method to compute transitive closure efficiently. 2) We re-define the  X  X istance X  of a path and propose a Dijkstra-like algorithm to compute single-source path-label transitive closure. We prove the optimality of our algorithm. 3) Extensive experiments confirm that our method is faster than the existing ones by orders of magnitude. For exam-ple, given a random network satisfying ER model with 100K vertices and 150K edges, the method in [12] consumes 277 hours for index building. However, given the same graph, our method only needs 0.5 hour for indexing building. Fur-thermore, our method can work well in a very large RDF graph (Yago dataset) having more than 2 million vertices and 6 million edges and 97 edge labels.
Definition 2.1. A directed edge-labeled graph G is de-noted as G = { V, E, and (2) E  X  V  X  V is a set of directed edges, and (3) a set of edge labels, and (4) the labeling function  X  defines the mapping E  X 
Given a path p from u 1 to u 2 in graph G , the path-label of p is denoted as L ( p ) = edge label.

Given a graph G in Figure 2, the numbers inside ver-tices are vertex IDs that we introduce to simplify descrip-tion of the graph; and the letters beside edges are edge la-bels . Considering path p 1 = (1 , 2 , 5), the path-label of p L ( p 1 ) = { ac } .
 Definition 2.2. Given two vertices u 1 and u 2 in graph G and a label constraint (set) S = { l 1 , ..., l n } , we say that u can reach u 2 under label constraint S (denoted as S u 1  X  u and only if there exists a path p from u 1 to u 2 and L ( p )  X  S .
Definition 2.3. (Problem Definition) Given two vertices u 1 and u 2 in graph G and a label set S = { l 1 , ..., l n l abel-c onstraint r eachability (LCR) query verifies whether u 1 can reach u 2 under the label constraint S , denoted as LCR ( u 1 , u 2 , S, G ) .

For example, given two vertices 1 and 6 in graph G in Fig-ure 2 and label constraint S = { ac } , it is easy to know that 1 can reach 6 under label constraint S , i.e., LCR (1 , 6 , S, G ) = true, since there exists path p 1 = { 1 , 2 , 5 , 6 } , where L ( p S . If S = { bc } , query LCR (1 , 6 , S, G ) returns false. Definition 2.4. Given two vertices u 1 and u 2 in graph G , P ( u 1 , u 2 ) denotes all paths from u 1 to u 2 . The path-P ( u 1 , u 2 ) } .
 5 , 6) can also satisfy S . Therefore, path (1 , 2 , 5 , 6) is redun-dant (Definition 2.5) for any LCR query.

Definition 2.5. Considering two paths p and p 0 from ver-L ( p 0 ) . In this case, p 0 is a redundant path, and L ( p redundant in the path-label set LS ( u 1 , u 2 ) .
Definition 2.6. The minimal path-label set from u 1 to u in graph G is defined as M G ( u 1 , u 2 ) , where 1) M G LS ( u 1 , u 2 ) ; and 2) there exists no redundant path-label in M labels in LS ( u 1 , u 2 ) .

Definition 2.7. Given two vertices u 1 and u 2 and a label constraint (set) S , we say M G ( u 1 , u 2 ) covers S if and only if there exists a path p from u 1 to u 2 , where S  X  L ( p ) and L ( p )  X  M G ( u 1 , u 2 ) .

Definition 2.8. Given a graph G , path-label transitive u , u 2  X  V ( G ) , and a single-source path-label transitive closure is a vector M G ( u,  X  ) = [ M G ( u, u i )] 1  X | V ( G ) | u  X  V ( G ) .

When the context is clear, we also say transitive closure in-stead of path-label transitive closure for short. Furthermore, for ease of presentation, we borrow two operator definitions ( Prune and  X  ) from reference [12].

Prune (  X  ) is defined as Prune ( LS ( u 1 , u 2 )) = M G which means removing all redundant paths. In Figure 2, Prune ( LS (1,6) = { a, ac } ) = M G (1 , 6) = { a } , since a  X  ab . (  X  )  X  (  X  ) is defined as follows:  X  (  X  X  X  X  u 1 u 2 )  X  M {  X  (  X  X  X  X  u 1 u 2 ) , u 3 ) and  X  ( It is easy to prove that M G ( u 1 , u 3 ) = Prune ( (  X  X  X  X  u 1 u 0 )  X  M G ( u 0 , u 3 ) } ). Analogously, we also define  X  ( M G ( u 2 ,  X  ).

An extreme approach to answering LCR queries is to ma-terialize transitive closure M G . At run time, given a query LCR ( u 1 , u 2 , S, G ), LCR queries can be answered by sim-ply checking M G ( u 1 , u 2 ). However, computing M G is much more complicated than traditional transitive closure. Be-fore the formal discussion, we introduce the following theo-rem, which forms the basis of our algorithm and performance analysis.

Theorem 2.1. (Apriori Property) Given one path p , if one of its subpaths is redundant, p must be redundant.
LCR queries are proposed in [12]. Generally speaking, the method in [12] employs a spanning tree T and a partial transitive closure NT to compress the full transitive clo-sure. Specifically, a spanning tree T is found in the graph G . Based on T , we partition all pairwise paths into three categories P n and P s and P e . All paths in P n contains all pairwise paths whose starting edges and end edges are both non-tree edges. All paths in P s (and P e ) contains all pair-wise paths whose starting (and ending) edges are tree-edges. In Figure 3, (4,5,6,1) is a path in P n , since  X  X  X  4 , 5 and non-tree edges. NT ( u, v ) contains all path labels between u and v in P n . We can re-construct M G ( u, v ) by Equation 1. Therefore, we can re-construct the full transitive clo-sure by the spanning tree T and partial transitive closure NT = { NT ( u, v ) , u, v  X  V ( G ) } .
 M G ( u, v ) = {{ L ( P T ( u, u 0 )) } X  NT ( u 0 , v 0 )  X { L ( P u 0  X  Succ ( u )and v 0  X  Pr ed ( v ) } where u 0 is reachable from u in the spanning tree T and L ( P T ( u, u 0 )) denotes the corresponding path label in T ; and v can reach v in the spanning tree T and L ( P T ( v 0 , v )) de-notes the corresponding path label in T . Obviously, different spanning trees will lead to different NT . In order to minimize the size of NT , authors introduce included in a spanning tree, the number of path-labels that can be removed from NT . Therefore, they propose to use the maximal spanning tree in G . However, it is quite expensive to assign exact edge weights w ( e ). Thus, they propose a sampling method. For each sampling seed (vertex), they compute single-source transitive closure, based on which, they propose some heuristic methods to define edge weights.
However, there are two limitations of their method in [12]. First, similar with the counterpart methods in tra-ditional reachability queries [6, 3], a single spanning tree cannot compress the transitive closure greatly, especially in dense graphs. Consequently, NT may be very large. Second, in order to find the optimal spanning tree T , authors pro-pose an algorithm to compute single-source transitive clo-sure for each sampling seed (vertex). However, the search space in their algorithm is not minimal, i.e., containing a large number of redundant paths, which affect the perfor-mance greatly. The above two problems (large index size and expensive index building process) affect the scalability of the method in [12].

Since computing single-source transitive closure is also a building block in our method, we argue that our method is optimal in terms of search space. In order to understand the superiority of our method, in the full version of this paper [13], we analyze the algorithm in [12]. Due to space limit, the details are omitted in this paper.

In [14], Fan et al. add regular expressions to graph reacha-bility queries. Specifically, given two vertices u 1 and u method in [14] verifies whether there exists a directed path P where all edge labels along the path satisfy the specified regular expression. Obviously, LCR query is a special case of the problem in [14]. Fan et al. propose a bi-directional BFS algorithm at runtime. We can utilize the method in [14] for LCR queries. Given two vertices u 1 and u 2 over a large graph G and a label set S , two sets are maintained for u 1 and u 2 , respectively. Each set records the vertices that are reachable from (resp. to) u 1 (resp. u 2 ) only via edges of labels in S . We expand the smaller set at a time until either the two sets intersect, or they cannot be further expanded (i.e., unreachable). The problem of this method lies in its large search space. The search strategy in [14] is different from traditional BFS algorithm, since one vertex may be visited multiple times in bi-directional BFS algorithm [14].
As mentioned earlier, compared with traditional transitive closure, it is much more challenging to compute path-label transitive closure (Definition 2.8). This section focuses com-puting path-label transitive closure efficiently. We first pro-pose a Dijkstra-like algorithm to compute single-source tran-sitive closure efficiently (Section 3.1). Obviously, it is very expensive to iterate single-source transitive closure compu-tation from each vertex in G to compute M G . In order to address this issue, we propose augmented DAG (aDAG for short) by representing all strongly connected components as bipartite graphs . The aDAG-based solution is discussed in Section 3.2.
This subsection discusses how to compute single-source transitive closure efficiently, since it is a building block in our aDAG-based solution. As discussed in Section 2.2, the method in [12] is not optimal. The key problem is that some redundant paths are visited before their corresponding non-redundant paths. In order to address this issue, we propose a Dijkstra-like algorithm. As we know, in each step of Di-jkstra X  X  algorithm, we always access one un-visited vertex that has the minimal distance from the origin vertex. In our algorithm, we redefine  X  X istance X . A distance of a path p is defined as the number of distinct edge labels in p instead of the sum of edge weights. Then, according to the distance definition, we adopt the Dijkstra-like algorithm to compute single-source transitive closure. This algorithm can guar-antee that all redundant paths must be visited after their corresponding non-redundant paths. Therefore, all redun-dant paths can be pruned from the search space (Theorem 3.1).

Given a graph G in Figure 2, Figure 4 demonstrates how to compute M G (1 ,  X  ) from vertex 1 in our algorithm (i.e., Algorithm 1). Initially, we set vertex 1 as the source. All vertex 1 X  X  neighbors are put into the heap H . Each neighbor is denoted as a neighbor triple [ L ( p ) , p, d ], where d denotes the neighbor X  X  ID, p specifies one path from source s to d , and L ( p ) is the path-label set of p . All neighbor triples are ranked according to the total order defined in Definition 3.1. Since [ { a } , (1 , 2) , 2] is the heap head (see Figure 4), it is moved to path set RS . When we move the heap head T 1 into path set RS , we check whether T 1 is covered (Definition 3.2) by some neighbor triple T 2 in RS (Line 5 in Algorithm 1). If so, we ignore T 1 (Lines 5-6); otherwise, we insert T into RS (Lines 7-8).

Definition 3.1. Given two neighbor triples T 1 = [ L ( p 1 p , d 1 ] and T 2 = [ L ( p 2 ) , p 2 , d 2 ] in the heap H , T and only if 1) | L ( p 1 ) | &lt; | L ( p 2 ) | ; or 2) | L ( p orders of T 1 and T 2 are arbitrarily defined.

Definition 3.2. Given one neighbor triple T 1 = [ L ( p 1 p , d 1 ] , T 1 is redundant if and only if there exists another neighbor triple T 2 = [ L ( p 2 ) , p 2 , d 2 ] , where L ( p d = d 2 . In this case, we say that T 1 is covered by T 2 .
Definition 3.3. Given two neighbor triple T 1 = [ L ( p 1 p child path) of p 2 , we say that T 1 (or T 2 ) is a parent neighbor triple (or a child neighbor triple ) of T 2 (or T 1 ).
Then, we put all child neighbor triples (Definition 3.3) of [ { a } , (1 , 2) , 2] into heap H . Considering one neighbor of ver-tex 2, such as vertex 3, we put neighbor triple [ { a } X  L ( When we insert some neighbor triple T 0 [ L ( p 0 ) , p 0 we first check whether p 0 is a non-simple path. If so, we ig-nore T 0 (Lines 10-11). Furthermore, we also check whether there exists another triple T 00 that has existed in H and T is covered by T 00 , or T 0 covers T 00 (Lines 12-15). If T covered by T 00 , we ignore T 0 ; otherwise, T 0 is inserted into H . If T 0 covers some triple T 00 in H , T 00 is deleted from H . At Step 2, the heap head is [ { a } , (1 , 3) , 3], which is moved to path set RS .
 5) , 5] from H . Figure 4 illustrates the whole process. All paths and path-labels in RS are non-redundant. Accord-ing to RS , it is straightforward to obtain M G (1 ,  X  ). Note that, our algorithm stops the infection from the redundant path to its child paths (Theorem 3.1). For example, path (1 , 2 , 5 , 6) is pruned from search space in our algorithm. Alg orithm 1 Single-Source Transitive Closure Computa-tion 2: Put all neighbor triples of u into H . 3: while H 6 =  X  do 6: Delete T 1 from H 7: else 11: continue 16: According to paths in RS to build C -PT ( u ).
Theor em 3.1. Given a vertex u in graph G , the following statements about Algorithm 1 hold: 1. (correctness) Any non-redundant path beginning from 2. (optimality) Given any redundant path p 0 , if one of p
Given a graph G , a straightforward method to compute transitive closure M G is to repeat Algorithm 1 from each ver-tex in G . Obviously, it is inefficient to do that. Intuitively, given two adjacent vertices u 1 and u 2 , most computations in Algorithm 1 for u 1 and u 2 are the same to each other. Therefore, an efficient algorithm should employ the prop-erty. Usually, a directed graph G is transformed into a DAG by coalescing each strongly connected component into a sin-gle vertex to compute transitive closure efficiently. However, this method cannot be used for LCR queries, since it may miss some edge labels. Instead, we propose an augmented DAG D by representing all strongly connected components as bipartite graphs. Then, we can compute single-source transitive closure M ( u,  X  ) according to the reverse order of D . During the computation, M ( u,  X  ) is always transmitted to its parent vertices in D . In this way, redundant compu-tation can be avoided.

Specifically, we first identify all maximal connected com-ponents in graph G , denoted as C 1 , ..., C m . For each C ( i = 1 , ..., m ), we compute local transitive closure in C noted as M C i ) by iterating Algorithm 1 for each vertex in C . For example, given a graph G in Figure 5(a), one max-imal connected component C 1 is identified in G . We com-pute M C 1 for C 1 . Then, we represent a maximal connected component C i as a bipartite graph B i = ( V i 1 , V i 2 ), where V 1 contains all in-portal vertices in C i and V i 2 contains all out-portal vertices in C i . A vertex u in C i is called as an in-portal if and only if it has at least one incoming edge from vertices out of C i . A vertex u in C i is called as an out-portal if and only if it has at least one outgoing edge to vertices out of C i . If one vertex u is both an in-portal and an out-portal, it has two instances u and u 0 that occur in V 1 and V i 2 , respectively. For any two vertices u 1  X  V i u 2  X  V i 2 , we introduce a directed edge u 1 to u 2 , whose edge label is M C i ( u 1 , u 2 ). For example, a bipartite graph B responding to C 1 is given in Figure 5(b). Finally, we replace all maximal connected components C i by the corresponding bipartite graph B i . In this way, we can get a graph D , as shown in Figure 5(b). We can prove that D must be a DAG. In this paper, we call it augmented DAG (aDAG for short). Note that, given a vertex u in C i , if u /  X  D , u is called an intra vertex , such as vertices 1,5 and 6 in Figure 5(a). Alg orithm 2 aDAG-Based Compute Local Transitive Clo-sure 1: Identify all maximal connected component C i . 2: Employ Algorithm 1 to compute local transitive closure M 4: Perform Topological Sorting Over D . Set M G ( u,  X  ) = 5: for each vertex u according to the reverse topological order 6: for each child c i of u do 8: for each maximal connect component C i do
Alg orithm 2 lists the pseudo code to compute transitive closure for aDAG D . First, we perform topological sorting over D . Initially, for all vertices u in G , we set M ( u,  X  ) = {  X , ...,  X  } . Then, we process each vertex according to the re-verse topological sort. If a vertex u has n children c i , for each c , we update M G ( u,  X  ) = Prune ( M G ( u,  X  ) M G ( c i ,  X  ))) iteratively. In this way, we can obtain M for each vertex u in aDAG D .

Now, we need to consider  X  X ntra vertices X  in each clus-ter C i , such as vertices 4 and 7 in Figure 5. Given an intra vertex u in C i , we initialize M G ( u,  X  ) = M C i Then, for each out-portal u i in V 2 i , we update M G ( u,  X  ) = Prune ( M G ( u,  X  ) tively.

Consider any one vertex u 0 /  X  C i . Given an intra ver-tex u in C i , we compute M G ( u 0 , u ) as follows: Initially, we set M G ( u 0 , u ) =  X  . For each in-portal u i in V 1 i date M G ( u 0 , u ) = Prune ( M G ( u 0 , u ) M C i ( u i , u ))) iteratively.

As we know, 2-hop labeling technique is proposed to com-press traditional transitive closure [1, 10]. We also extend the labeling technique to compress the path-label transitive closure.

Definition 3.4. A 2-label-hop coding over a graph G as-signs to each vertex u (  X  V ( G ) ) a code C ( u ) = ( C C out ( u )) , where the entries in C in ( u ) and C out ( u ) are in
Definition 3.5. A 2-label-hop coding over a graph G is called complete if and only if Equation 2 holds. where L ( p 1 ) denotes one path label-set from u 1 to w , and L ( p 2 ) denotes one path label-set from w to u 2 .
In this section, we evaluate our methods over both ran-dom networks and real datasets, and compare them with the existing solution the sampling-tree method in [12]. Specifi-cally, we experimentally study the performance of three ap-proaches: 1) the sampling-tree method proposed in [12]; 2) we compute path-label transitive closure method by Algo-rithm 2 and compress it by 2-label-hop technique. Then, based on 2-label-hop codes, we can answer LCR queries. This method is called transitive closure method ; 3) the bi-directional BFS proposed in [14]. Our methods are imple-mented using C++, and our experiments are conducted on a P4 3.0GHz machine with 2G RAM running Ubuntu Linux.
There are two types of synthetic datasets to be used in our experiments: Erdos Renyi Model (ER) and Scale-Free Model (SF). ER is a classical random graph model. It de-fines a random graph as | V | vertices connected by | E | edges, chosen randomly from the | V | ( | V | X  1) possible edges. In our experiments, we vary the density | E | | V | from 1 . 5 to 5 . 0, and vary | V | from 1K to 10K. SF defines a random network with | V | vertices satisfying power-law distribution in vertex degrees. In our implementations, we use the graph generator gengraphwin (http://fabien.viger.free.fr/liafa/generation/) to generate a large graph G satisfying power-law distribu-tion. Usually, the power-law distribution parameter  X  is between 2 . 0 and 3 . 0 to simulate real complex networks [15]. Thus, default value of parameter  X  is set to 2 . 5 in this work. In order to study the scalability, we also vary | V | in SF net-works from 1K to 10K. The number of edge labels ( |  X  | ) is 20. The distribution of labels is generated according to uniform distribution. Tabl e 2: Performance VS. Graph Density in ER Graphs We also employ two real graph datasets (Yeast, Small-Yago) in our experiments, which are provided by authors in [12]. More details about the two datasets and more experi-ments are given in the full version of this paper [13].
In this section, we use Algorithm 2 to compute transitive closure for a graph G . Then, we use 2-label-hop coding tech-nique to compress the transitive closure. We report index construction time (IT), index size (IS) and average query response time (QT) for the experiments on the synthetic datasets. Note that, the default query constraint size ( | S | ) is 30%  X | with the sampling tree method. Note that, in the following experiments, we always randomly generate 10000 queries to evaluate query performance. QT is reported as the aver-age response time for one query. In these experiments, we evaluate the performance with regard to graph size, graph density and label constraint size | S | . Furthermore, we also test the performance of bi-directional BFS in Table 1. Since bi-directional BFS does not need offline processing, thus, we only report QT in the following experiments.

Exp1. Varying Graph Size ( | V | ) on ER graphs . In this experiment, we fix the density | E | | V | =1.5 and label con-straint size | S | =6 and vary | V | from 1,000 to 10,000 to study the performance by varying graph sizes. Table 1 reports the detailed performance, such as, index sizes (IS), index build-ing times (IT) and average query response time (QT). From Table 1, we know that transitive closure method is faster than the sampling-tree method in offline processing by or-ders of magnitude. For example, when | V | =1K, transitive closure method only spends 15 seconds to build index, but the sampling-tree method needs 113 seconds. The index size of our method is much smaller than that in the sampling-tree method. Furthermore, our query performance are also bet-ter than the sampling tree method. From Table 1, we know that memory-based bi-directional BFS is also very fast for LCR queries. However, this method is not scalable with regard to graph size due to its exponential time complexity.
Exp2. Varying Density ( | E | | V | ) on ER graphs . In this experiment, we fix | V | =10,000 and vary the density from 2 to 5 to study the performance of our method in dense graphs. From Table 2, we know that the index building time and index size increase when varying | E | | V | from 2 to 5 in both methods. Furthermore, the sampling tree method cannot finish index building in 48 hours when | E | | V |  X  4. F rom Table 2, we know that transitive closure method has better scala-tree method. Actually, the two methods both need to com-pute M G ( u,  X  ) (i.e., single-source transitive closure). As proven in Theorem 3.1, our method has the minimal search space, but the search space in the sampling tree method is not minimal. Thus, large search space affects the salability of the sampling tree method.
In this paper, we address label-constraint reachability (LCR) queries over large graphs. Theoretically, we propose several methods to optimize path-label transitive closure comput-ing. We also demonstrate the superiority of our method by extensive experiments.
