 Join operation is an essential task in data cleaning. The quality of join results is usually hard to guarantee with machine alone since it is difficult for machine to correctly find out all records refer to the s ame entity from different databases. We leverage crowdsourcing to improve the quality of join. We generate a set of likely-matching pairs by machine, and then assign them on the crowdsourcing platforms, such as Crowdflower [1]. The financial cost of hiring workers to do join operation depends primarily on the quantities of generated pairs. A naive method to generate pairs is using pairwise comparison of the entire records, which generates O ( n 2 ) pairs for n records.

We can filter obviously non-matching pairs in order to save the cost. First, we apply category-based and sorting-based methods to generate pairs. Then we propose CSCER, a hybrid pairs generation approach, to reduce the number of generated pairs. CSCER combines category, sorting and clustering techniques for not only remaining true matching records but also filtering non-matching records as many as possible. We evaluate our approaches with two real data sets on a crowdsourcing platform. The experiments indicate that CSCER minimizes the number of generated pairs and join operation achieves high quality. Crowdsourcing-based Join. Given a set of tables. These tables consist of a set of Records: R = { R 1 ,R 2 ,... R n } . Crowdsourcing-based join is to find all matching records in these tables depending on workers.
 Attribute-based pairs generation. A record in the table is associated with a fixed number of attributes, denoted as A i . Attribute-based pairs generation utilizes attributes of records to prune non-matching records. 3.1 Category-Sorting Approach The records usually can be classified accord ing to a specific attribute. Records in the same bucket do pairwise comparison. The number of pairs generated using category-based is denoted by C i . However it still leads to cost problem with large records when records are classifie d in just a few category buckets.
Sorting-based approach is another method to filter the likely non-matching pairs. This approach have two steps: the first step is to sort records based on an appropriate attribute. The second step is to set a window with fixed size and generate pairs by sliding the window. The number of pairs generated by sorting is denoted by S i . However this approach may miss true matching records.
To overcome the limitations of category-based and sorting-based methods, we propose a hybrid method which combines category with sorting. Category is used first to obtain category bucket. Then sorting is applied for every bucket. 3.2 Category-Sorting Improvement We apply clustering to eliminate those pairs which are significantly dissimilar. We use distance measure to cluster records. First, attributes X  value need to be normalized. Then we calculate the dis tance between adjacent records. Given a distance threshold  X  , if the calculated distance is larger than  X  , the "larger" of two records leads to a new cluster. Finally , we generate pairs with the the sliding window technique for each cluster. 3.3 Adaptive Attribute Selection In general, category-attribute chosen principle is to choose attributes whose value is both unchangeable and enumerable. Sorting records by numeric is a appro-priate choice. However, we find that some attributes are appropriate for both approaches. Thus, we propose the strategy of adaptive attribute selection.
If there is an attribute A s suitable for category and sorting both, which method we choose for A s depends on the rest of attributes. If we can find an attribute A t which is suitable for sorting among the rest of attributes, then A s is used for category. Otherwise, we need to compare C i and S i . There are three possible cases for C i and S i : Case 1 : C i  X  S i . A i is chosen for category. Case 2 : C i &gt;S i and C i  X  S i &lt; threshold  X  . A i is selected for category. Case 3 : C i &gt;S i and C i A i is used for sorting. Otherwise, the pro cess is developed for this situation as follows. Each round leaves one attribute as a reference for comparison, and the rest of attributes are used for category. We calculate S i oftheleftattributeper round, then find the smallest S i by comparing them. For the attribute with the smallest S i , we compute C i  X  S i and estimate which case this attribute is. 3.4 CSCER Workflow According to the above approaches , we propose CSCER to generate pairs. Algo-rithm 1 illustrates the pseudo code of CSCER workflow. Let A c denote a set of attributes which is only suitable for category, and A s denote those only suitable for sorting and A t denote those suitable for both category and sorting. Algorithm 1. CSCER Datasets. Product denotes two datasets of electronic products, which has a total of 338 records. 177 records of them are taken from Suning 1 and the other 161 records are taken from Amazon 2 . Product generates 338  X  337 2 =56 , 953 pairs by using naive method. There are 63 pairs of them, which are true matching. 4.1 Pairs Generation Analysis First, we generate pairs by using category-based and sorting-based methods sep-arately. Sorting-base d method uses different w to generate pairs. Table 1 shows the number of pairs generated by these two methods. Recall is the percent-age of matching pairs found by these approaches on total matching pairs. We can observe that both methods greatly reduce the number of pairs. We also see that sorting-based filters some true matching pairs while category-based re-mains all true matching pairs. Then, we examine the number of pairs generated by CSCER. As shown in Table 2, CSCER reduces the number of pairs involv-ing less losses of Recall . It also can be observed that the larger the w is, the larger the Recall is. We can see that the larger  X  can further reduce the number of pairs with less impact on Recall . The above results indicate that CSCER method performed better than category-based and sorting-based methods. 4.2 Accuracy of Join We assign 163 pairs generated by CSCER with  X  =0 . 3 and w =4 on Crowd-flower. We infer the final results using Weighted MV and MV respecively. The weights reflect the quality of workers. Table 3 shows the comparison of join results. Weighted MV performed well with only one pair which was not be veri-fied correctly. We come to the conclusi on from Weighted MV that the inference method combining workers X  quality can improve the quality of final results. Some researches have integrated human intelligence to achieve join. Marcus et al.[2] proposed several different task forms to reduce the financial cost. CrowdER[3] proposed cluster-based task generation to reduce the number of tasks. Wang et al.[4] utilized transitive relations to devise a order of verifying pairs. We have studied the problem of leverage attributes and crowdsourcing for join. We proposed a hybrid approach with the aim of a significant reduction in number of generated pairs, which contained three steps: category step, sorting step and cluster step. We developed adaptive attribute-selection strategy to efficiently generate pairs based on attributes. Experimental results on Crowdflower using real-world datasets showed that our approach achieved good performance and high accuracy of join resluts at lower cost.

