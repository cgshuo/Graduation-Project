 A common problem many companies are facing is to establish new facilities in most suitable places. Take online shopping as an ex ample, to improve the shipping service and minimize storage cost, online sales giants such as Amazon and 360Buy have built numerous warehouses throughout the country. Since each warehouse is constrained by its designed capacity (e.g. storage ability or the number of employees), it is desired to choose good locations for new warehouses. The mobile service is another example showing the important application of this problem.
 The problem is based on bichromatic reverse nearest neighbor (BRNN) query [3]. Let W and R denote two sets of locations in th e same space. Given a location w  X  W , a BRNN query returns all locations r  X  R whose nearest neighbor is w . Those locations form the BRNN set of w , denoted by B ( w,W ) . In our problem, we denote the facility set as W and the customer set as R . In addition to the common BRNN query, the capacity constraint of facilities is considered. We use L 2 (Euclidean) distance metric and assume that: (1) a customer is served by the nearest facility and (2) service providers have the knowledge of customer distribution and can offer a serving order that determines the sequence of locations being served. Let c ( w ) denote the corresponding capacity of a facility and wt ( r ) denote the weight of a customer location r .A w is responsible to serve its reverse nearest neighbors. And a r that has w as its nearest facility is within w  X  X  capacity only if w provides service to some customers reside in r .
We use a running example for illustration throughout the paper. For presenting con-venience, we set all customer locations the same weight 1, although the proposed tech-niques can be applied to any weights. We also adopt the serving order that makes w serve its customers r in an increasing order of dist ( r, w ) for the same reason. Here we use dist ( r, w ) to denote the distance between r and w . In Fig.1 and 2, circles, small and big rectangles denote customer locations, facilities and BRNN sets respectively, and the number besides each r denotes the serving sequence. In Fig.1, w 2 serves 3 locations. Location 1 and 2 use up c ( w 2 ) , thus 3 is out of its capacity. Here black circles denote poorly served ones. After adding p 1 , as shown in Fig.2, three locations are well served by p 1 .Since p 1 shares the workload of w 2 , w 2 has the ability to satisfy previous black locations. The total weight of newly served parts is 3, so p 1 has an increment of 3. Our aim is finding top-k locations that have ma ximal increments from a candidate set P .We make the following contributions:  X  We formulate the problem of top-k most incremental location selection query.  X  We propose pruning techniques and an O ( n log n ) algorithm to reduce the com- X  We perform extensive experiments and the results confirm the effectiveness of the The rest of the paper is organized as follows. Section 2 reviews previous studies on related topics. Section 3 defines the problem and gives a baseline solution. Section 4 describes pruning techniques and the proposed algorithm. The empirical study is given in Section 5, followed by the conclusion in Section 6. The concept of reverse nearest neighbor (RNN) query [3] has been raised more than ten years. Korn et al.[3] first propose methods to solve RNN query. Paper [5] studies how to discover influence sets based on RNN in frequently updated databases and proposes an efficient algorithm to solve BRNN query. Since we focus on location selection, without proper modification, the proposed methods cannot be applied. Wong et al.[6] study the problem called MaxBRNN. It aims at finding an optimal region that maximizes the size of BRNN set. Zhou et al.[10] extend the problem to MaxBRkNN. Their problems are different from ours. First, their studies attempt to retrieve the optimal region with high-est influence, while ours focuses on selecting top-k ones from a candidate set. Second, capacity constraint is not considered in their studies.

Paper [9] and [2] propose and solve the min-dist optimal location query, which min-adding a new one. Some other papers [8,1] describe another BRNN related query, called maximal influence query. The influence of a facility is defined as the total weight of its BRNN members. Though these problems are similar to ours, they fail to consider the capacity of each facility. The authors of [7] and [4] study the capacity constrained assignment problem. Paper [7] proposes an algorithm that assigns each r i  X  R to a w for profile-matching applications which provide service using existing facilities. Our problem considers both existing and to-be built ones. 3.1 Definitions First, we give the definition of  X  -served location to indicate the percentage of customers who are under service in a customer location.
 Definition 1. An  X  -served location is a location r that has  X   X  wt ( r ) customers under service, noted as  X  ( r ) , 0  X   X   X  1 .
 Given the serving order, w serves its BRNN set members one by one, until some r uses up c ( w ) or all r are fully served. Hence the  X  factor of r can be calculated. Most r are 1 or 0-served. Only those use up c ( w ) , while still have unserved customers reside in are partly served.
 Definition 2. Given W and R , service quality noted as sq ( W ) equals to r  X  R  X  ( r ) wt ( r ) .
 sq ( W ) , new facilities should be built and loca tions are chosen from a candidate set. The concept of candidate increment indicates the increment of service quality when a new facility p is added. Let W denote W  X  X  p } in the following of this paper. Definition 3. Given a p , its increment denoted by inc ( p ) equals to sq ( W )  X  sq ( W ) . The larger increment, the better a candidate location is. Thus we formulate the proposed query as follows: given a constant k , 0  X  k  X | P | , it finds a set P  X  P ,sothat | P | = k and  X  p i  X  P ,p j  X  P \ P ,inc ( p i )  X  inc ( p j ) . Answering the query means finding k most promising candidates that maximize the increase of service quality. 3.2 Basic Solution The query definition gives a basic solution. It takes R, W, P as input and returns P , which also applies to other algorithms. It scans the candidate set, adds p to W , calculates the new service quality, gets inc ( p ) then removes p and tries next candidate. Finally it picks out those have top k increments as results. 4.1 Notation and Properties The challenge of the query are two folds. One is that the influence set is not only re-lated to customer locations, as addressed i n [8,1], but also related to facilities. When a new facility is added, it becomes the new nearest facility of some customers and their old facilities are also affected. Here we give the exact definition the influence set of a candidate location.
 Definition 4. The influence set of a p denoted by I ( p ) is B ( p, W )  X  X  r  X  B ( w,W ) | w is old nearest facility of r  X  B ( p, W ) } .
 The other challenge is to efficiently deal with large amounts of input data. Hence we introduce the concept of nearest facility circle [3] (NFC) of r , which is a circle denoted 4.2 Pruning Techniques So we have the following theorem (proof can be found in the full paper).
 Theorem 1. Given a p ,  X  w  X  W \ I ( p ) , we have B ( w,W )= B ( w,W ) .
 Hence, it is possible that we set aside those unaffected locations and focus on a candi-date X  X  influence set. This idea is supported by the following theorem.
 the new  X  factor of r after p is added.
 Maintaining the nn and rnn lists, we can easily calculate  X  new ( r ) for every r  X  I ( p ) , then get inc ( p ) according to theorem 2, which effectively bounds the search space. 4.3 Spatial Index We apply several spatial indices to further lower the time complexity. Two time-consuming parts are: (1) to find nearest facility for each r  X  R and (2) to get the influence set for each p  X  P . For the first part, we introduce a spatial structure s 1 that supports NN query to index W . Whereas there is no direct tool to handle the second part. We use NFC and a spatial index s 2 that supports point enclosure query to achieve our goal. The first part has assigned each r to a w , so we can build nfc ( r, w ) and insert it into s 2 . When considering p ,weforma p point enclosure query, search s 2 and process all NFCs returned by s 2 to get I ( p ) .
 Theorem 3. Given a structure s that indexes all nfc ( r, w ) ,r  X  R ,ifwesearch s with a p -enclosure query, then { nfc ( r, w ) | X  r  X  B ( p, W ) } = { all NFCs returned by s } . According to theorem 3 and definition 4, we can get the influence set of p efficiently. The detailed steps of the proposed algorithm are given as follows. And a formal anal-ysis shows the basic solution has a O ( n 3 ) time complexity. After applying pruning techniques, it reduces to O ( n 2 ) . When we introduce the spatial indices, the proposed algorithm has a O ( nlogn ) complexity.
 Algorithm 1. Index 5.1 Experimental Setup We use C++ to implement all algorithms and conduct all experiments on a PC with an Intel(R) Core 2 Duo 1.7 GHz processor, 2 GB memory and running Window XP plat-form. We use both real-world and synthetic datasets. Two real-world datasets NE and NA are downloaded from http://www.rtreeportal.org/spatial.html. NE contains 123,593 points in north east of USA. NA contains 24,493 locations in North America. When using NE or NA, we uniformly sample from it to get R , W and P . To simulate real-life scenarios, we generate R , W with Zipfian distribution and P with uniform distribution. The serving sequence we adopt is an increasing order of the distances between cus-tomer locations and facilities. The weight of each r in both real and synthetic datasets is set to 1, whose results are similar to those set to any positive integer. The capacity of w and p is generated with uniform distribution ranging [1,40]. Cardinalities are set to |
R | : | W | : | P | =20:2:1 in all experiments. We adopt kd-tree as the spatial index for the nearest neighbor query and R*-tree for the point enclosure query. 5.2 Comparisons We compare the proposed algorithm with the basic solution. Since the basic solution is not scalable for large data, we conduct this set of experiments with relative small datasets. Fig.3 shows the proposed algorithm performs nearly 4 orders of magnitude faster than the basic solution when | P | is 200. And the gap will be bigger with the growth of | P | . Only adopting the pruning techniques, the basic solution runs 10 2 times faster. Both real and synthetic datasets show similar results. 5.3 Scalability Then we study the scalability of the proposed algorithm. Apart from two real-world datasets, we synthesize R, W and P with cardinality of 200K, 20K and 10K respec-tively. Each dataset is used from a quarter to the whole of it. To get the influence of capacity, we sample 3 subsets from them and vary the range of distribution from [1,20] to [1,60]. Both the execution time and index size are evaluate. Fig.4 and Fig.5 show both the cpu time and index size linearly increase with the growth of input data. Fig.6 shows the influence of different capacities is minor. All datasets support the above ob-servations. So we conclude that the proposed algorithm has good scalability. In this paper, we formulate the top-k most incremental location selection query. Through analyzing the properties of the query, we propose pruning techniques and an O ( n log n ) algorithm to answer the query. The results of experiments confirm the effectiveness of the pruning techniques and the efficiency of the proposed algorithm.
 Acknowledgements. This work is supported by NSFC under the grant No. 61003085 and HGJ PROJECT 2010ZX01042-002-002-03.

