 1. Introduction
Temporal queries and version management for Web archives are important components of Web informa-tion systems. They are particularly important in applications such as document archives and digital libraries that must ensure the permanence of e-documents. Indeed, the very computing technology that makes digital repositories possible also makes it very easy to revise documents and publish the latest versions on the Web.
To avoid loss of critical information and achieve e-permanence, old versions must be preserved. We can expect
A first approach to preserve the content of successive document versions is storing each version as a sep-
Therefore, in this paper we propose XML-based techniques whereby a multi-version document is managed as figures , bibliography , etc.).

Similar problems and opportunities occur in data warehousing applications, where the need for temporal data warehouses is well established [48,59] . Furthermore, as we move from traditional intra-company ware-houses to inter-company warehouses, reliance on XML and Web-based environments is bound to grow. A supporting historical queries and trend analysis queries.

Thus, we focus on information systems, such as digital libraries and Web warehouses, that support sophis-ticated change management and temporal queries for focused application domains. This differentiates our
Web warehouses and digital archives from systems such as the Wayback machine that are primarily interested
We instead want to provide the technology whereby powerful historical queries can be supported along with sophisticated version-auditing techniques such as those supported by the Versioning Machine project [11] .
A key problem that will be addressed in this paper is how to represent a multi-version document as an XML document that (i) can be viewed by conventional XML browsers at remote sites and (ii) can also support com-plex queries, including temporal ones, expressed in standard XML query languages, such as XQuery [15] . Pre-vious work has focused on either problem rather than both: for instance, the reference-based representation approach proposed in [27] is not suitable for expressing temporal queries of any sophistication. In general, the question of which data representation should be used for modelling time-dependent information and facil-such temporal issues is vividly demonstrated by the number and diversity of approaches that were proposed were counted [60] ; each featured a different combination of temporal data model and query language. Although language exists that is generally accepted in the research community or supported by major vendors. Fortu-nately, the troublesome experience of relational systems with temporal information is in many ways due to
XML provides a richer data model, whose structured hierarchy can be used to support temporally-grouped data models that have long been recognized as the most natural and expressive for temporal information a relational database can be expressed more easily once this history is published (or viewed) in XML.
The use of standard XML in archiving also dovetails with the requirements imposed by more traditional applications of version management, such as software configuration and cooperative work [12,53] . As these applications migrate to a Web-based environment, they increasingly use XML for representing and exchang-ing information, often seeking standard vendor-supported tools for processing and exchanging their XML documents. The importance of version management has been fully recognized by XML standard groups current situation provides a window of opportunity to solve the technical challenges and lay the foundations for this important piece of Web information systems technology.

This paper is organized as follows. Section 2 reviews previous work. Section 3 proposes our new scheme to represent XML document changes, and Section 4 shows how complex temporal queries can be supported on this scheme. Section 5 discusses the general approach of ICAP [10] and two use cases. Section 6 discusses implementation techniques, and Section 7 concludes the paper. 2. Previous work
The problem of document history management combines issues from document version management and temporal databases, for which a large number of models and techniques have been proposed, but often for situations different from the one considered here. For instance, while the problem of preserving the history of an XML document is akin to that of transaction-time relational databases, much of the previous work on temporal queries has been developed in the framework of valid-time databases. Therefore, from this large on the representation of temporal XML documents. 2.1. Temporal XML representations
The problem of supporting valid time on the Web was studied in [40] by Grandi and Mandreoli who pro-posed a new &lt; valid &gt; markup tag for XML/HTML documents. Rather than temporal queries, the focus of their work was visualization for temporal information, which they showed can be achieved via browsers and
XSLT [16] . Likewise, the problem of supporting historical queries was not addressed in [39] , where a dimen-sion-based method for managing changes in XML documents was instead proposed. In most previous approaches, the introduction of a new temporal language (or at least of non-trivial time-oriented extensions) boni et al. focus on managing semi-structured temporal data and propose a new language to query documents containing such data [46] . For XML, several extensions have been proposed to the XML data model and its query languages to manage and query temporal information. For instance, extensions to XPath were proposed by Amagasa [18] , Dyerson [34] , and Mendelzon et al. [45] , whereas Gao and Snodgrass proposed the s XQuery language that adds various temporal constructs to XQuery [38] . In our approach, we will instead support tem-poral representations and queries without any extension to XML and its query languages. An XML-based representations for scientific data was presented in [21] . Our XML scheme presents several similarities with [21] , but we also provide full support for historical queries, a topic not discussed in [21] .
As discussed in [43,62] , maintenance of dynamic warehouses for XML data requires that the Web sites of discussed next. 2.2. Change detection
LaDiff [23] is a change detection algorithm for semi-structured information that approaches the problem by dividing it into: (i) the Good Matching problem and (ii) the Minimum Conforming Edit Script problem. The
XyDiff algorithm for XML documents was proposed in [43,35] . To match the largest identical parts of both documents, the algorithm uses ID attribute information, and a signature and a weight are computed for each node from bottom-up. X-Diff [58] detects changes in XML documents based on an unordered model that is find the minimum-cost matching. CX-DIFF [37] provides customized change detection of XML content. An interesting diff algorithm that uses relational databases was proposed in [63] .

Commercial change detection tools include DeltaXML [3] and Microsoft XMLDiff [5] ; these provide tools to generate XML diff and represent it in XML format.

Different approaches for supporting multi-version documents use different schemes for storing these deltas in 2.3. Managing the deltas
The RCS [52] scheme stores the most current version plus reverse-editing scripts to retrieve previous ver-sions. An improvement to RCS was proposed in [26] , where a temporal clustering scheme is introduced to improve the efficiency of retrieving past versions from secondary store. These approaches lack an XML-com-are needed for more complex queries [29,28] . Another scheme often used in the past for version control is
SCCS [49] . In SCCS, each text segment is clustered with all its successive changes; also pairs of timestamps are associated with the segments and their changes to specify their lifespans. Version retrieval is performed by scanning the file and retrieving valid segments according to timestamps. At the physical level, this is a which becomes large and larger as successive versions are added. The addition of indexes [49] only improves retrieving a version can require accessing a different page for each of its segments [26] . 2.4. Temporal databases
The management of multiple database versions has received much attention under the topic of transaction-time temporal databases [60] . A large number of temporal data models were studied, and the design space for non-first-normal-form model or attribute time stamping, in which the domain of each attribute is extended to include the temporal dimension. Although temporally-grouped models have long been known to be more expres-
SQL, and therefore they have not been actually implemented in temporal database projects and prototypes [47] . As we will see, temporal data models are instead supported well by XML and its query languages.
Object-oriented temporal models are compared in [50] , and a formal temporal object-oriented data model is proposed in [22] . The problem of version management in object-oriented and CAD databases has received a significant amount of attention [20,36] . However, support for temporal queries is not discussed, although query issues relating to time multigranularity were discussed in [24] . Schema versioning represents another important topic frequently discussed in the context of object-oriented databases [60] .

The work presented here represents a major extension of the work described in [56] . Thus, this paper pre-sents significant new results, including: (1) extension to arbitrary XML documents by properly handling mixed elements and text nodes, (2) detailed explanation of version interval nesting, (3) new discussion on change annotation and visualization, (4) generalized approach to arbitrary documents through significant new case studies, including the CIA World Factbook , (5) the development of the XChronicler tool to build an XML document that describes document revision history X  X alled V-Document X  X nd the algorithm it uses, (6) examples to demonstrate user-defined functions, (7) detailed storage efficiency analysis of the approach, and (8) XML schemas for sample versioned XML documents. 3. A logical model for versions
Although the SCCS scheme has many shortcomings at the physical level, we will show that it offers potential managed by SCCS are lines of text, and the multi-version document generated by SCCS lacks any obvious log-ical structure. However, when applied to the elements of a well-structured XML document, the basic SCCS scheme can be extended to produce a well-structured XML document that can be used to display the version history of the document on a Web browser, and also express complex queries on the document and its evolution.
We now discuss how to summarize and represent the successive versions of a document ( Fig. 2 ) as an XML document, called a V-Document ( Fig. 3 ), upon which complex queries and temporal queries can be specified using languages such as XPath or XQuery. In contrast to the relational model, XML provides the opportunity to annotate elements and also have a sequence of such version-annotated elements instead of single separate sion numbers or timestamps: vstart represents the initial version when the element is first added to the XML document, and vend represents the last version in which such an element is valid. After the vend version, the stamp value of the current version.

Thus, in our representation, we timestamp every element of our hierarchical structure, where the interval of support useful queries such as  X  X  X ow many sections did the first version of this document contain?  X  . There are significant advantages to our scheme, including the following:
There is no storage redundancy, since multiple identical nodes which do not change over time in successive versions of the same document are represented as a single node timestamped with its validity interval (an analysis on storage efficiency is discussed in Appendix 2 ).
 The document history is represented by a temporally-grouped model encoded as an XML document whose DTD (or XML Schema) is automatically generated from the DTD (the schema) of the original document.
Temporal queries and other complex queries can be easily expressed in V-Documents using standard XML query languages. 3.1. Change management We now consider a very simple document and its successive versions, as shown in Fig. 2 .
 For simplicity, the only primitive changes used in our V-Documents are DELETE, INSERT and
UPDATE. (Operations such as MOVE or COPY can be reduced to these.) These changes are detected by the XML-Diff algorithm and represented in the V-Document by using the vstart and vend attribute that denote the beginning and end timestamps of the version (or alternatively the version number).

UPDATE. When an element is updated, a new element with the same name will append immediately after ged. The change of an element is not viewed as a change of its ancestors, unless the ancestors themselves are are those of the changed elements.
 INSERT. When a new element is inserted, that element is inserted into the corresponding position in the V-Document ; the vstart attribute is set to the current timestamp (or version number), and vend is set to now .
DELETE. When an element is removed, the only information that must be changed is the vend attribute; this is set to the last timestamp (or version number) where the element was valid. 3.2. Annotating and visualizing changes
The XML-based representation proposed here supports well the version control and auditing applications annotations that explain the reasons and background for such changes, or to use color coding to visualize changes, possibly between non-successive versions. Now, the V-Document can be easily queried and processed with the XML stylesheet language XSLT [16] , to translate into other XML documents or HTML documents, shot versions, the XSLT stylesheet for snapshot versions can be reused for version display on the Web.
For example, to mark newly added nodes between Version 1 and Version 2, we can compare each node X  X  will be marked with a yellow background with the HTML tag span .

However, the most significant benefit achieved from the representation proposed here is that it provides powerful support of complex queries, particularly historical queries, which are discussed next. 4. Historical queries
Using our change representation scheme, complex queries can be expressed easily. The following is a com-plete list of temporal queries expressed in XQuery [15] .

QUERY 1. Snapshot: show Section 2 of Section 1 as it was on 2006-11-02. for $ e in doc(V-Document.xml)/document/section return ( $ e/subsection
Here, vstart( $ x) and vend( $ x) are two library functions that, respectively, return the start and end timestamps of the element $ x .

QUERY 2. Evolutionary History: show the history of the title of Section 1 . for $ title in doc(V-Document.xml)/document/section[no=1]/title return $ title
QUERY 3. Duration Query: show section numbers and durations for sections that were revised within six months (180 days). for $ title in doc(V-Document.xml)/document/section/title let $ duration :  X  substract-days(vend( $ title), vstart( $ title)) where duration &lt; = 180 return &lt; section &gt;{$ no, $ duration }&lt; /section &gt;
The subtract-days is a function that computes the differences between dates, recasting the result as days.

QUERY 4. A Since B: show the sections which have remained unchanged since 2006-11-01. for $ sec in doc(V-Document.xml)/document/section return $ sec
QUERY 5. A Until B: find the sections in which the title has remained unchanged until a new subsection  X  X  X otivation  X  was added. for $ sec1 in doc(V-Document.xml)/document/section where not empty( $ title) and not empty( $ sec) and return $ sec2
These examples shown above illustrate that the need for coalescing is often avoided or reduced by the use of our temporally-grouped [33] XML representation, on which powerful temporal queries can be conveniently expressed using XQuery. 4.1. Temporal functions Since XQuery supports user-defined functions, a small library of functions has been defined in our ICAP Project [10] to help users with temporal queries.

For instance, the functions vstart( $ e) and vend( $ e) used in the previous examples were introduced as a
Time-interval functions : voverlaps( $ a, $ b) , vprecedes( $ a, $ b) , vcontains( $ a, $ b) , vequal-s( $ a, $ b) , vmeets( $ a, $ b) will return true or false according to two interval positions; overlapin-terval( $ a, $ b) returns the overlapping interval.

Duration and date/time functions : vspan( $ e) returns the version span of a node, vstart( $ e) returns the start version time of a node, vend( $ e) returns the end version time of a node, and vinterval( $ e) returns the version interval of a node.

More complex user-defined functions were provided to address both the issues of expressive power and user convenience. For instance, we next describe a snapshot function that can be used to construct snapshots of V-Documents of arbitrary structure and nesting:
QUERY 6. Snapshot: retrieve the version of the document on 2006-11-03: for $ e in doc(V-Document.xml)/document return snapshot( $ e, 2002-01-03) ment and only returns the element and its descendants where vstart 6 versionTS 6 vend , defined as follows: define function snapshot( $ e, $ v) {
Our function defined above can be used to retrieve snapshots of any parts of the document. For instance, to retrieve the snapshot of the titles of Sections 1and2 on 2006-12-03, we can use this query: for $ d in doc(V-Document.xml)/document let $ sec :  X  $ d/section[no=1 or no=2 and return snapshot( $ /title, 2006-12-03)
Other useful functions in our temporal library include temporal aggregates discussed in the following section. 5. A general approach
The approach proposed in the previous sections is quite general and can be used to preserve (a) the version history of XML documents and (b) the transaction-time history of relational databases. These two application scenarios have been the focus of two UCLA research projects, the ICAP [10] described next and the ArchIS [1] project described in Section 5.4 . 5.1. The ICAP Project Nowadays, many Web documents of practical significance are managed using XML and revised frequently.
Thus, we did not have to stray very far to find our first case study: UCLA manages most of its catalogs and other Web documents in XML and updates them periodically. For instance, a new XML version of the UCLA course catalog is published every two years. In this semi-structured document, the courses offered by each the requisites enforced for each course. Along with this structure information, we find a textual description of the topics covered by the course, and other ad hoc annotations. In the ICAP project, we have used the
XChronicler tool, to build a V-document that captures the history of recent course catalogs. This V-document makes it possible to use XQuery to pose queries, such as: Find the new courses introduced by the UCLA CS department in the period 200-2004? and How long did it take for keywords such as  X  X anotechnology X  to migrate from graduate course syllabi to undergraduate syllabi?
The use of Web catalogs is ubiquitous in countless services and enterprizes of public and commercial inter-est and growing every day. Inasmuch as catalogs are frequently revised, the ICAP technology provides a sim-ple but effective approach for enhancing the information systems supporting such catalogs with historical queries and flashback capabilities.

Two other application testbeds studied in the ICAP project were (i) the CIA World Factbook that is revised every year [2] and (ii) the history of successive versions for the W3C XLink proposed standards [14] . 5.2. Case study: the CIA world factbook
The CIA World Factbook is published by the Central Intelligence Agency and has been used as a repository and handbook on population, government, military, and economic information for nations recognized by the
United States [2] . The report is updated annually and is made public on the Web. However, users can only access the snapshot versions of the Factbook from each year, and there is no clue on how the geopolitical by the Factbook Web site is very limited X  X nly keyword search is provided. 5.2.1. Structured content construction
The Factbook documents are currently stored in HTML form; however their regular structure makes it easy to convert them into XML documents. Thus, we built a tool that can effectively crawl the Factbook
Web pages, extract contents from the pages, and construct a hierarchical XML representation for such pages. Finally, the snapshots from recent years were assembled into a V-Document using the XChronicler described in the next section; the resulting V-Document supports interesting queries on the recent political and economic history of the world. Said V-Document, and the queries discussed next, are available at http://stromboli.cs.ucla.edu/icap /. 5.2.2. Temporal queries on the factbook The following XQuery examples demonstrate how we can specify structured temporal queries on the V-Document derived from the World Factbook .

QUERY FB1. Find the military expenditure history of the United States. for $ x in document(factbook04T.xml)/factbook/ return $ x/military/military _ expenditure _ dollar _ figure
QUERY FB2. Retrieve Canada X  X  GDP on 2002-03-24. for $ x in document(factbook04T.xml)/factbook/ return $ x/economy/GDP[vstart(.) &lt; = X 2002-03-24 X 
QUERY FB3. Find Italy X  X  exchange rate history from 2002-02-01 to 2003-04-16. for $ x in document(factbook04T.xml)/factbook/ return $ x/economy/exchange _ rates[vstart(.) &lt; = X 2003-04-16 X  5.3. Version History for W3C XLink Specs
The W3C XLink Specs [14] provide an excellent example of the many technical memos and specs that are now published in XML. These text-intensive documents are frequently revised, because of (i) editorial changes of the technology and systems that these documents are describing.

We have used the XChronicler tool to convert the three versions of XLink specs available to date into a V-document that is managed by the ICAP system. We obtained a simple environment that is supportive of audit-ing changes and exploring the reasons for such changes. Indeed, changes between successive versions of the documents, or even between non-successive versions of the same, can be easily visualized through colors. Fur-thermore, annotations can be easily attached to the changed elements in the document to explain the reasons mation such as: When were certain parts of the specs last revised? and When was the reference to a particular paper first introduced? We found that the most interesting answers are often returned when histories are que-ried for unexpected and improbable events. For instance, when we posed the query, Find authors who were to create an annotation that explains the background for such an unusual change and searched the Web for an explanation of why Ben Trafford was so unceremoniously dropped from the author list of XLink. Initially, we only found reasons for wanting to keep Ben Trafford as a document author: countless Google entries showed tronic books and related Web-technologies. But eventually, after visiting hundreds of links, we found: A bizarre little tale. ... A Dot-Com Saga ...

Then the Web page http://crism.maden.org/writing/exmu.html proceeds by humorously recounting how, in conviction for stock fraud (thus explaining why he was removed from the XLink author list). This amusing dis-informative than the status quo. Indeed, the ICAP approach combines the ability of flashing back to previous versions, with that or mining for significant patterns of changes, by using standard XML and its query languages. 5.4. Relational database history: the ArchIS project number of time-oriented database applications and because past research on temporal databases has revealed rather than restricting ourselves to the relational data model and query languages, we can pursue an approach similar to that we just used for the version history of XML documents. Thus, we can publish the transaction-time history of the relational database in XML and pose temporal queries on such history using standard
XQuery. This leads to using a temporally-grouped representation that has long been recognized as more nat-rigid structure of flat relational tables can now be supported quite naturally using XML.
While in a relational representation we will have to timestamp individual tuples as shown in Table 1 , under a temporally-grouped representation we timestamp columns as shown in Fig. 4 , where each attribute value is instead timestamped with its validity period.

The temporally-grouped information of Fig. 4 can be naturally represented using XML as shown in Fig. 5 , queries can then be naturally expressed against this representation using standard XQuery. No further discus-can then be stored and queried using a native XML database, as in the case of V-documents. Alternatively, such histories can be shredded back into relations, and implemented with the help of existing
DBMS. This second solution is investigated in [57] , where the V-documents were in fact shredded into H-tables, and queries expressed in XQueries which are then mapped into equivalent SQL/XML queries. This makes possible the use of temporal indexing and clustering techniques, that in combination with the support for query optimization of SQL/XML provided by commercial systems, achieves very good levels of perfor-mance and scalability [57] . 6. Implementation of an XML document versioning system In this section we discuss how V-Documents can be constructed from the successive versions of arbitrary
XML documents and stored for efficient support of temporal queries. 6.1. XChronicler: constructing V-Document from snapshot versions
As shown in Fig. 6 , we built a tool named XChronicler [10] to generate the V-Document from the struc-tured diffs taken between successive versions of an XML document (Algorithm 1).

First, the first snapshot version document is normalized as document X as subelements, and converting mixed text nodes into tagged nodes (discussed in Section 6.2 ). Document X then timestamped as document V 1 by adding two attributes vstart and vend . (Here, V version history V-Document from version 1 up to version i .)
Then, the second snapshot version document is normalized as document X between X 1 and X 2 is computed with Microsoft XMLDiff tool [5] . Diff in Microsoft XML Diff Language, an XML representation of updates. These updates in Diff applied on V 1 to generate the composed history until the timestamp of version 2.

The above process is then repeated until the whole history is composed as V-Document V rithm 1.

Algorithm 1 XChronicler Algorithm 6.2. Handling attributes and mixed content
In our algorithm, we have assumed that the elements of our documents contain no attributes. Elements containing attributes can also be supported in our V-Document by representing each attribute by a subelement denoted by the special tag isAttr . For instance, if the section elements contain the attribute no , then we represent them as follows: &lt; no isAttr=yes vstart=2002-01-01 vend=now &gt; 1 &lt; /no &gt;
This transformation, and also the inverse transformation from child elements to attributes, is simple and can be implemented in XQuery.
 Mixed content
We also need to generalize our algorithm to situations where an element can contain text nodes that are mixed with other elements. For example,
This is handled by transforming a text node to an element mixtext :
With this transformation, all nodes can be associated with version intervals, and similar to attributes, the reverse transformation can be done with XQuery.

With the two extensions discussed above, our approach becomes quite general and applicable to any XML document.
 6.3. Schema of the V-Document
One significant advantage of our scheme is that it preserves the hierarchical structure of original XML doc-uments, and it has a well-defined DTD for the V-Document .
 In particular, the DTD for the history of relations can be generated directly for their SQL schema. As shown in Fig. 7 , the DTD of the V-Document ( Fig. 8 ) can be automatically generated from the snapshot
DTD. Each element is added with two new attributes, vstart and vend ; an attribute of an element will be con-verted as a child element, and child elements are set as repeatable for different version intervals.
When a schema is available for the snapshot XML document, the XML schema for the V-Document can be derived in similar fashion, as shown in Appendix 1 . 6.4. Efficient storage and retrieval
An important advantage of our approach is that significant savings in storage is achieved because the approach eliminates the duplication of unchanged information that is caused by storing the different snap-shots. These savings are realized for both evolving databases and evolving documents. For the first case, we used a database containing the history of employees over 10 years, obtained by introducing regular increases of salaries along with changes of titles and changes of departments. The history is published as a in two ways: snapshots and the V-Document. At each version, we computed the total storage up to this ver-sion. Fig. 9 shows the comparison of storage between the V-Document and snapshots at different version numbers. As the number of versions increases, the efficiency of the V-Document is apparent. Furthermore, if we increase the number of snapshots, the storage used increases in proportion, while the storage used by the V-Document remains largely unaffected.

As a second example, we tested the version history of W3C XLink standards [14] : there are three versions, published respectively on 2000-07-03, 2000-12-20, and 2000-06-27. The storage is shown in Fig. 10 . Observe that the storage savings achieved by the V-Document grow with the number of successive versions. only current XML and XQuery standards. Thus, any native XML database [8,13] or any XML-extended com-mercial ORDBMS [6,44] can be used to archive the history of a relational database and a multi-version XML document X  X s demonstrated by our ICAP and ArchIS systems that are also accessible through the Web [10,1] . (However, for efficiency reasons, the XML database engine should be adapted to support one of the proposed limitations that current native XML databases and XML-extended commercial ORDBMS face X  X n particu-grows. Overcoming these limitations represents an important topic of research and the objective of much take us well beyond the scope of this paper. We will only briefly mention some of the specialized clustering and indexing techniques that have been proposed for improving the performance of temporal queries on multi-versioned documents, and also mention that, for relational table histories, the scalability and perfor-mance issues can be solved effectively by shredding the V-Documents back into relational tables. 6.4.1. Usefulness-based clustering
This is a powerful technique that can turn a clustering scheme for a single version into a temporal clus-tering scheme for the multi-version V-Document. For instance, say that we want to minimize the number of disk pages needed to retrieve data concerning all employees working in a given department. Thus, we can ing the changes in the document. A first possibility is to append them to this first version as shown in
Fig. 11 . As discussed in [28] , this organization presents some advantages but destroys the clustering of ary history of a given employee is stored sequentially; thus the deltas of each element are appended to the end of the element, rather than at the end of the whole document. However, as the history becomes longer, the initial clustering of employees (by department) will be lost and, as time goes by, more and more pages are needed to retrieve the employees working in a given department at a certain time (snapshot query). The usefulness-based scheme solves this problem by monitoring the usefulness of each page X  X hich is defined as the percentage of currently valid objects in the page. When the page falls below the specified threshold, the [29] . The scheme is efficient and robust [25,28] . The performance of snapshot queries on multi-version doc-uments is basically that of queries on a single version stored in smaller pages (i.e., pages whose size is reduced by the usefulness factor). 6.4.2. Shredding and relational databases
A frequently used technique consists in decomposing the documents into flat tables that can be more efficiently managed by current OR DBMS. This technique is particularly effective in the case where the V-Documents actually represent an XML view of the history of an underlying relational database [55] .
In [55,57] , the authors showed that the shredded V-Documents can be stored and managed efficiently as a set of relational tables, whereby a separate table is used for the history of each attribute (such as salary). The usefulness-based clustering scheme discussed above and standard relational indexing tech-niques are then all that is needed to manage the history of our database efficiently. Complex historical queries written in XQuery can then be implemented via their equivalent XML/SQL queries on such history relations [7,55] . Additional refinements, such as schema history management and compression, can also be used [57] .

We were able to solve the scalability problem for V-Documents representing the history of relational data-base tables, but the case of arbitrary XML documents is more complex and requires more sophisticated tech-niques, such as durable node numbers whereby information on the structure of the document is not lost upon shredding. 6.4.3. Durable node numbers
An XML document can be viewed as an ordered tree consisting of tree nodes (elements). A pre-order tra-versal number can be used to identify the elements of the XML tree [29,42,51,61] . The SPaR(Sparse Preoder and Range) numbering scheme [29] uses durable node numbers (DNN, range) that can sustain frequent element X , and we represent it as [ vstart, vend ] in the V-Document ( Fig. 5 ).
 6.4.4. Complex queries The use of DNN also facilitates the maintenance of indexes on multi-version documents. In fact, by using
DNNs, efficient indexing schemes [29] and query processing algorithms [30,28] can be used to support complex queries on multi-version documents. For instance, multi-version B-Trees (MVBT) [19] indexing is used to sup-port complex queries. The scheme [28] supports conventional and path expression queries.

To implement such clustering/indexing techniques for efficient storage and retrieval of multi-version XML documents, the XML database has to be adapted accordingly with additional effort. For example, the durable node numbers will be assigned and indexed for query processing where additional query optimization is needed.
Therefore, our general approach to supporting historical queries using XML and XQuery can be applied to both relational databases and XML documents. But for the first case, mature technology is at hand to assure generation XML extensions for ORDBMS were often based on character large objects (CLOBs), whereby updating any element would normally require the deletion and reinsertion of the whole document. However, the latest versions of commercial systems have addressed these problems, and thus can provide for efficient incremental updating of our V-Document. The testbed applications that we studied so far include W3C docu-tion of the good storage efficiency of V-Documents that follows from the simple analytical model presented in
Appendix 2 . For documents of this size, the performance of our historical queries on both native XML dat-abases and OR DBMS is quite satisfactory in practice. However, it is also clear that more research is needed to develop techniques whereby XML databases can achieve levels of performance comparable to relational dat-ongoing research endeavor. 7. Conclusions
Preserving Web information for future uses represents a critical requirement for the modern information databases also requires the ability of supporting queries on the archived documents. At the present, these requirements are not met and await for the development of new enabling technology. Therefore in this paper, we have proposed a novel approach to the management of Web document archives and data warehouses, tion of the documents and their contents. Therefore, we have presented simple techniques (based on the hier-archical timestamping of XML elements) and shown that said techniques can be used to represent and query temporal information in XML and that they are effective on a wide assortment of information sources ranging from textual documents to transaction-time relational databases.

The key features of the proposed approach are: (i) the evolution history of documents and databases is rep-resented in standard XML using a temporally-grouped representation and (ii) complex temporal queries are then expressed in XQuery, without requiring temporal extensions to the XML standards. Indeed, while we by users to their current XML/XQuery systems. Therefore, an interesting conclusion that follows from these results is that supporting temporal models and historical queries is significantly easier in an XML/XQuery-based approach than in the traditional framework of relational tables and SQL. (This observation holds even when SQL is enriched with temporal user-defined functions; in fact, even when enriched with special temporal extensions, SQL failed to gain much popularity as a temporal query language.)
After focusing on the problems of modeling and querying temporal information at the logical level, we briefly discussed various clustering and indexing approaches to achieve efficient execution of these queries.
The main issues regarding performance and scalability of (i) XML databases and (ii) temporal information and queries were identified and discussed. Efficient support for temporal queries in the XML/XQuery frame-work is thus emerging as an area of significant research opportunities and great importance for temporal applications [28] . Acknowledgements
The authors thank Shu-Yao Chien, Bertram Luda  X  scher, Richard Marchiano, and Vassilis Tsotras for many inspiring discussions. We also thank Emanuele Ottavi for his implementation of XChronicler. This research work was carried out as part of the ICAP (Incorporating Change Management into Archival Processes) pro-ject sponsored by the National Historical Publications and Records Commission. We also want to thank the reviewers for their insightful suggestions, which we were able to implement thoroughly, and which resulted in significant improvements to the quality of the paper.
 Appendix 1. XML schemas of the sample documents Appendix 2. Efficient storage
V -Documents also achieve efficient storage compared to snapshot-based versions, especially when the ratio of update on documents is small.

Suppose the deletion ratio, insertion ratio, and update ratio are R snapshot version n is S n , and the total size of versions up to version n is S assume that the update will not increase the size in a snapshot version; the size of additional timestamping attributes can be ignored.
 For the snapshot-based scheme, the size of S n is as follows: The total snapshot version size up to version n is When ( R ins R del  X  100 % , Eq. (2) is approximately equal to For V -Documents, we have Thus, where V 1 ! 1 is close to S 1 .
 When  X  R ins  X  R upd  X  100 % , Eq. (5) is approximately equal to When n 1, we have
Eqs. (3) and (7) clearly show that when the update ratio is small, the V-Document has a significant storage advantage.

References
