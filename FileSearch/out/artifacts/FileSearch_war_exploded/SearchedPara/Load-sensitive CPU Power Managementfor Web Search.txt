 Web search engine companies require power-hungry data cen-ters with thousands of servers to efficiently perform searches on a large scale. This permits the search engines to serve high arrival rates of user queries with low latency, but poses economical and environmental concerns due to the power consumption of the servers. Existing power saving techniques sacrifice the raw performance of a server for reduced power absorption, by scaling the frequency of the server X  X  CPU ac-cording to its utilization. For instance, current Linux kernels include frequency governors i.e., mechanisms designed to dy-namically throttle the CPU operational frequency. However, such general-domain techniques work at the operating system level and have no knowledge about the querying operations of the server. In this work, we propose to delegate CPU power management to search engine-specific governors. These can leverage knowledge coming from the querying operations, such as the query server utilization and load. By exploiting such additional knowledge, we can appropriately throttle the CPU frequency thereby reducing the query server power consumption. Experiments are conducted upon the TREC ClueWeb09 corpus and the query stream from the MSN 2006 query log. Results show that we can reduce up to  X  24% a server power consumption, with only limited drawbacks in effectiveness w.r.t. a system running at maximum CPU frequency to promote query processing quality.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Storage &amp; Retrieval]: Information Search &amp; Retrieval Keywords: Power Consumption, CPU Frequency Scaling, Search Engines Nowadays search engines are a fundamental part of the Web, due to its enormous size. In fact, most users turn to a search engine to look for the information they need, pro-ducing billions of searches every day. And yet, users want to quickly receive answers to their questions, and are not willing c  X  managed by the OS, their functionality can be (partially) controlled by application-level code [3]. We build upon this functionality to develop our proposed solution i.e., search engine-specific frequency governors which control the CPU frequency from within the query server. Indeed, knowledge of query server utilization and load facilitate a more refined control of the processor to achieve power savings. Recently, Lo et al. propose a centralized feedback-based DFS controller for search clusters [11]. Their approach achieves considerable power savings by trading off perfor-mance, so that latency constraints are barely met for any workload. However, the authors report several challenges in deploying their centralized solution on large clusters. On the other hand, our approach is decentralized as it works at the single query server level.

The contribution of this paper are as follows: (1) we pro-pose to exploit query servers X  knowledge (e.g., utilization, load) to throttle the CPU frequency via search engine-specific frequency governors (2) we experimentally demonstrate that our solutions can achieve significant power savings without markedly damaging the query processing quality w.r.t. stan-dard frequency governors.
We model a query server as a first-come first-served queue, where incoming queries wait to be processed upon arrival to the search engine. As soon as a processing thread is available, it picks the next query from the queue and starts processing it, in disjunctive mode. Queries arrive to the system with an arrival rate  X  and are processed at a processing rate  X  (both expressed in qps, i.e., queries per second). The query arrival rate can vary over time, due to fluctuations in the query load [16]. The query processing rate may change as well, because of the DFS mechanism: for lower CPU frequencies we expect lower power consumption but also lower  X  values, as the CPU speed is reduced and query processing takes longer.
Search engines users are impatient [15], so we assume that query servers must process queries within a short time threshold  X  since their arrival, e.g., 1 second. However, since a query can spend some time waiting in the queue, processing threads may actually have less than  X  seconds to solve certain queries. Additionally, execution times are variable and some queries may require more time than others to be processed [4]. If our system cannot complete a query processing within the time budget, the retrieval phase is terminated early and results computed so far are returned [10]. This partial processing will likely have a negative impact on the effectiveness of the returned results; however, they can benefit from subsequent effectiveness-improving processing stages, e.g., machine-learned ranking [19]. Conversely, when a query exceeds  X  seconds waiting in the queue, the server just drops it. In this case, the system returns no results.
The power consumed by a query server (measured in Watts) can be divided into two components: a static part which is continuously consumed to operate the hosting machine, and a dynamic (or operational) part which depends on the CPU usage to perform query processing activities. In this work, we propose to exploit DFS technology to dynamically change the query server CPU frequency to reduce the oper-ational power consumption. Indeed, as shown in Figure 1, the average operational power consumed by the query server is directly correlated to the CPU frequency. Of course, the operational power consumed by the server varies for differ-where k is the number of threads processing queries [7]. The idea behind this governor is to maintain an acceptable query server utilization (e.g., 0.7 [7]) so that incoming queries can be easily processed without consuming too much power. Peri-odically, se-conservative computes the query server utiliza-tion and adjusts the CPU frequency. Frequency throttling is performed if  X  is above (resp. below) the tunable threshold  X  (resp.  X  ). If an adjustment is required, se-conservative changes the processor frequency to obtain the desired uti-lization. The governor assumes that it will receive in the immediate future the same number of queries received during the last period. Using Equation (1) , it computes the query processing rate necessary to obtain the target utilization. Finally, this governor selects the lowest frequency capable of producing such query processing rate, assuming processing rate directly proportional to CPU speed.

Our second governor, se-load , bases its frequency scaling decisions upon the number of queries N populating the query server, i.e., the queries currently queued or being processed. Given N , we define the query server load ` as: Here, the principle is to reduce the query population in the server as fast as possible, when the query server load is too high (e.g. ` &gt; 0 . 7). Periodically, se-load observes the query server load and accordingly adjust the CPU frequency. If ` is greater than  X  , the processor is set to its maximum frequency. When ` is below  X  , the CPU frequency is stepped down from its current frequency to the next smaller one.

In the following section, we experiment in order to evaluate (a) how much power can be saved by using the search engine-specific frequency governors and (b) the corresponding impact on query processing quality.
Experiments are conducted using the Terrier IR plat-form [13]. The platform is hosted on a dedicated Ubuntu 14.04 server; Linux kernel version is 3.13.0-45-generic. The machine is equipped with 32GB RAM and an 8-core Intel i7-4770K processor, which exposes 16 operational frequencies ranging from 800 MHz to 3.5 GHz. The ClueWeb09 (Cat. B) document collection is indexed to represent the first tier of a Web search engine. Stopwords are removed and the Porter stemmer is applied to all terms. The index stores document identifiers and term frequencies. The index is compressed with Elias-Fano encoding [20], and is kept in memory, shared among 8 query processing threads.

Queries are taken from the MSN 2006 query log and are submitted in real time to our system, while halving their original interarrival time. Since we use the first day of the dataset, every experiment take 12 hours to run; the average query load in 11.28 qps instead of the original 5.14, with a peak of 44 qps instead of 28.

For each query, we use BM25 to retrieve the top 1000 doc-uments using WAND [2]. Upon arrival, queries are queued and have 1 second to be processed 1 . When this time expires before processing completion, query processing is early ter-minated and partial results are returned. If a query spends all its time in the queue, the system drops the query. The query is unanswered and an empty result list is returned.
Approximatively 7% of the queries take at least one second to be solved.
 Also, os-conservative drops less queries but provides a slightly worse relative recall.

Our first search engine-specific governor, se-conservative , leads to reduced power consumption if compared to os-conservative runs. In fact, our governor saves more than 6% in power consumption when relaxed thresholds are set (  X  = 0 . 8,  X  = 0 . 2); and more than 10% using tight thresh-olds (  X  = 0 . 8,  X  = 0 . 6). These power savings come at the price of small degradation in query processing quality: the percentage of unanswered queries increases by  X  6% while the relative recall decreases by almost 2%, if we compare se-conservative to os-conservative with tight thresholds. Under the relaxed threshold, se-conservative drops  X  24% more queries than os-conservative , while its relative recall diminishes of  X  3% in comparison. When compared to os-performance , se-conservative can help saving from  X  14% to  X  24% in power consumption. Relative recall decreases by slightly more than 2% when using relaxed thresholds, and by almost 3% with tight ones. The percentage of unanswered queries increases of  X  3% w.r.t. os-performance when se-conservative uses relaxed thresholds. However, dropped queries decrease by  X  8% when tight thresholds are set.
Our second governor, namely se-load , obtains power sav-ings similar to the se-conservative governor, but with a better query processing quality. Indeed, se-load saves more than 8% in power consumption when compared to os-conservative with relaxed thresholds. However, the relative recall detriment is less than 2% and the unanswered queries increment by just  X  10%. When the governors are configured with tight thresholds, se-load saves 7% in power consump-tion w.r.t. os-conservative . At the same time, relative recall is damaged for less than 2% and no additional queries are dropped. When compared to os-performance , se-load saves from  X  15% to  X  21% in power consumption. Relative re-call is damaged by  X  2% under both threshold configurations. Instead, the percentage of unanswered queries benefits from our governor. Under relaxed thresholds, se-load drops  X  9% less queries than os-performance and  X  15% less queries remain unanswered by using tight thresholds.

Overall, experiments confirm that our approach is suc-cessful, as the search engine-specific governors show reduced power consumption than the two baselines. In particular, se-conservative provides the highest power saving. Relative recall (RR) and percentage of unanswered queries (%UQ) are not markedly damaged, especially when se-load is used.
In this work, we advocate that search engines infrastruc-tures can save power at query server level, by leveraging knowledge on the server querying operations. We develop two search engine-specific frequency governors, se-conservative and se-load , which perform processor frequency throttling according to the query server utilization and load. By exten-sive experimentation, we evaluate the benefits and drawbacks of our approaches, compared to standard OS-level frequency governors. We find that se-conservative can help saving up to  X  24% power w.r.t. a system which operates at maxi-mum CPU frequency to promote query processing quality. Indeed, se-conservative damages by just  X  3% both rel-ative recall and percentage of unanswered queries. When compared to systems that use more energy efficient config-urations, we find that our governors can still save at least 7% in power consumption. This gain costs only a limited
