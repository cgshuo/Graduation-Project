 Data grid [1,2] is a distributed architecture for data management that provides the coordinated and collaborative means for integrating data across network and thus forms a single, virtual environment for data access. We consider the grid environment and focus our attention on the join operator that is a common as well as an important operation in database queries [3]. While large amounts of research efforts developing multiple join algorithms have been proven effective in traditional environments, when moving on data grid where queries are executed over remote sources in a dynamic environment, the situation becomes complex [4]. The existence of autonomous nodes, heterogeneous datasets and the different bandwidths offers new challenges. 
We assume a user query involves multiple join operations in it. Firstly we reduce the relations. Secondly grid execution nodes are selected for performing join opera-tions. The reduced data is then transferred to the execution nodes for subsequent proc-essing and ultimately result is propagated back to the user node. In this paper, we propose a new n -way relation-reduction algorithm for minimizing the size of data transferred; an innovative mechanism for estimating the join result cardinality and a new algorithm that keeps track of the subsequent join operation by partitioning previ-ous join results and shipping them to next execution node. The performance analysis of our proposed algorithm and the comparison with other methods are studied by experiments, showing the efficiency and usefulness of our work. 
The rest of the paper is organized as follows. Section 2 introduces n -way relation-reduction algorithm. In Section 3 we disc uss the method that can accurately estimate the cardinality of the join result. Section 4 explores the sort merge join algorithm at execution nodes. The performance analysis and experimental results are given in Section 5. Finally we conclude the paper in Section 6. We describe the problem of multiple join processing as follows: assume there exist n arbitrary node C issues a query that requires join of these n relations according to n-1 We propose an n -way relation-reduction algorithm to get efficient tuple sets R 1  X  , R  X  has two join attributes, we sort the tuples on the two join attributes by using multi-key sort method , according to the query plan, one join attribute is considered as primary key and the other join attribute is considered as secondary key. 
We create some temporary relations and called reducer . For each relation, its re-ducer is the projection of its join attributes. Fig 1(a) shows the relations R i (1  X  i  X  5) and Fig 1(b) shows their corresponding reducers . The process of getting efficient tuples for each relation by using of their reducers is composed of three phases: A . Get the projection of F-C 2 on T 2 called F-C 2 . P [ T 2 ] and ship F-C 2 . P [ T 2 ] from node A (3) We get efficient tuples satisfying the multiple join conditions in each relation R i according to its reduced reducer C i  X  for there is a correspondence between them. As Fig 1(a) shows the tuples marked by dark background are efficient tuples. R  X  , ... R n  X  that are subsets of R 1 , R 2 , ... R n respectively satisfying the join condition, R the first join attribute and T i+1 is called the second join attribute . 
Assume the set of different values on join attribute T i in R i  X  is denoted as R i  X  . P [ T i ], which describe the number of tuples whose values on T i equals to val j ;(3) S ( T k ), where T posed of the values in T k which each value in R i  X  . P [ T i ] corresponds to. 
Because R i  X  and R i+1  X  are reduced results by using relation-reduction algorithm, the R equals to val j is val 1  X  val 2 . So the cardinality of the join result can be computed by the formula  X 
According to R i  X  . table and R i+1  X  . table , we can construct the table of the join result, which will be used to control the join process at execution node as section 4.2 de-R R  X  R R  X  tively, so ( R 2  X  &gt;&lt; R 3  X  ). P [ T 3 ]. Num (3) equals to 3 (2 plus 1). R sponds to. Next, to the value val , we seek its corresponding sets in R i  X  .S( T i-1 ), fill these R  X  R  X  are {1,2} and {4} separately. So th e set value 3 corresponds to in ( R 2  X  &gt;&lt; R 3  X  ).S( T 1 ) is the union of {1,2} and {4 }, that is {1,2,4}. The main idea to resolve the problem of multiple join processing is described as fol-lows: before joining these n relations R 1 , R 2 , .... , R n , we firstly apply n -way relation-nodes as execution nodes. Reduced relations are shipped to these nodes for complet-ing the join operations in parallel fashion. Lastly join results are transferred to node C in pipeline mechanism. We describe the algorithm in detail as follows. 4.1 Selection of Execution Nodes Keeping in view the coordinate resource sharing in data grid environment and also the high accessibility of these resources to grid users, we assume nodes having tremen-dous processing capability, too much memory space and smaller network transfer rate, are execution nodes for performing join operations. After m nodes are selected as execution nodes to which m pairs of reduced results of R  X  of reduced relations should be shipped to is an issue of concern. Assume the consumed C =| R i  X  |  X  TR i,j and TR i,j is the network transfer rate between nodes A i and E j . We represent C i+1,j }. The optimal target is that the consumed time for shipping all pairs of reduced relations should be minimal, that is, minimizing the time for shipping. 
We model this problem as seeking an edge-weight-minimum-matching in weighted complete bigraph[5]. To get convenience in explanation, we assume that the pair of similarly R n-1  X  and R n  X  are shipped to node E m . 4.2 Join Operation at Execution Node For the sake of convenience, we consider the join process of two relations R i  X  and R named IR i , IR i+1 , OP . These memory parts can be resized dynamically according to their usage. Assume the OP can be divided into k partitions according to the first join R  X  ( R  X  &gt;&lt; R the transference of the tuples in each partition in OP and allocate space accordingly. node E j : (1) Insertion phase. When a tuple from R i  X  arrives at node E j , whose value on room in IR i . And the number of tuples inserted into IR i , whose value on T i equals to V , plus one. Similarly, a tuple from R i+1  X  is processed. (2) Probing phase . A tuple in IR i , whose value on join attribute T i equals to V , is probed with the tuples in IR i+1 . To each corresponding partitions OP ( Val ) according to Val , where Val is the value on the first R  X  &gt;&lt; R i+1  X  equals to Val adds one. Similarly, a tuple in IR i+1 is processed. 
When a join result whose value on T i+1 equals to Val is inserted into its correspond-ing partition OP ( Val ) and the number of tuples in this partition equals to the corre-sponding value ( R i  X  &gt;&lt; R i+1  X  ). Num ( Val ), we ship all the tuples in this partition to next execution node for next join processing and thus free memory space OP ( Val ) at E j . there is no room in memory space at E i , some tuple must be flushed into disk in order to free some memory space. For this, flushing policy may select one partition in OP randomly. If there are join results that will be generated, which belong to this selected partition, they are directly written to disk and hereafter shipped after the join results in OP are moved to next execution node for subsequent join operation. 5.1 Analysis on the Times for Various Number of Tuples Produced In this experiment, we use a 4-way join to study the effect of relation-reduction algo-rithm. Fig 3 shows that the time for the first 1% result tuples by hash based join algorithm is much smaller than by our proposed algorithm. This is because our algorithm spends enough time getting the efficient tuples. Once the join result is produced, much more results can be generated in unit time in our algorithm than in hash based algorithm. As Fig 3 depicts, when the number of result tuples becomes larger, the cost time by hash based algorithm is much more than by our proposed algorithm. Also, the total response time by hash based algorithm is much more than by our proposed algorithm. 5.2 The Effect of Left-Deep Tree and Bushy Tree In this experiment, we study the effect of left-deep and bushy query tree. As Fig 4 shows, the performance using bushy tree is better than using left-deep tree. This is because bushy tree can offer the best opportunity for allowing the implementation of parallel fashion. In left-deep query tree, much more intermediate join result should be shipped and sorted, R 3 and R 4 must wait for shipping or processing until its left opera-tion has finished, so the response time is higher than bushy tree. This paper has proposed a multiple join algorithm in data grid. To ease the data trans-ference among the grid nodes, n -way relation-reduction algorithm is used to get effi-cient tuples for each relation before join operation executes. Execution nodes can be selected by making use of matching theory. A new method is developed which can accurately estimate the cardinality of the join result. The analytical and experimental results demonstrate the effectiveness of the proposed multiple join algorithm for the management of data in data grid. 
