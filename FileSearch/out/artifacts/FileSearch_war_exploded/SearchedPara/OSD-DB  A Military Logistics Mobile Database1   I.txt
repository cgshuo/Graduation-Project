 Visualizing data in a tabular form is very convenient and natural for a wide range of people, including non-technical people, especially when multilevel headers are available. On the contrary, visualizing XML data as a tree is not natural and less compact than a table. Additionally, many people, especially non-technical people, find relational tables very limiting because of the necessity of having flat table headers. This is one of the reasons why many people still use spreadsheet software to manage their data [6]. Of cou rse spreadsheets are not sufficient for any significant size projects, but their ease of use is attractive to many people. According to [6], We decided, in this work, to start from a presentation data model (tabular with multilevel headers) that is already working very well, and find a way to make it work well at lower levels.

Many organizations like government agencies still have a lot of data on paper, often represented in tables with multilevel headers. One example is the Opera-tional Staff Data (OSD) binder used for logistics by the Department of National Defence (DND) in Canada. The data in this binder are used for logistics pur-poses, before, during, and after deployment of military personnel and equipment. Tables are categorized by a wide range of topics, such as simply Equipment data (general purpose vehicles, armoured fighting vehicles, ...) with table attributes such as empty and loaded weight ,moving range on the road or cross-country , maximum speed on the road and cross-country , fuel type and capacity (see Figure 2); and other categories such as  X  X eapons X  ,  X  X mmunition and Explo-sives X  ,  X  X uclear, Biological and Chemical Agent X  and many others. Another example table containing data about mines laying rates is shown in Figure 1. Note that the full schema and data are not shown due to lack of space and confidentiality of some parts of it.

Updating such binders is obviously time consuming and not practical. Some important considerations include not necessitating a database server, which de-mands more technical expertise to manage, and portability to devices such as Personal Digital Assistants (PDAs), surely influence design choices. Attempts have been made to use software such as MS Access, chosen by non-technical people because of their familiarity with it and its simplicity, have been unsatis-factory. It does satisfy the need to avoid managing a database server but is not well suited to the other needs of the project. Our solution is to use an embedded XML database, such as BerkeleyDB XML [2], as a basis and build a visualization layer on top to represent XML data as HTML tables with multilevel headers. Since the output of our visualization layer is HTML, the results can be viewed in any web browser. The tables can be dumped into files to be viewed statically on any system (including PDAs), or the results of XPath queries or other types of queries can be passed dynamically to the visualization layer to be viewed in a web browser. Since the data changes infrequently, there is no need to keep an on-line read-write version of the database. Updates are usually done in batches by a couple people, and distributed to other people whenever needed.
The rest of this paper in organized in the following way. After a brief overview of related work, common use cases for th e system are covered next in Section 3. The XML layer, including the XML schema and style sheet to produce an HTML table from the XML data, are covered in Section 4. Section 5 shows how to integrate the XML layer into a more complete application, and the conclusion follows. There is quite a lot of interest in the problem of extracting information from web pages in general, and more particularly extracting data from HTML tables with (possibly) multilevel headers and inserting it into database tables [1, 3, 5, 7], but not the reverse as we do in this paper. We focus on presenting data in an easy-to-read and easy-to-understand way, while they concentrate on extracting information from already published tables (or other structures like lists) and storing it somewhere.

In [9], the authors work on making large HTML tables easily viewable on small screens. Although we don X  X  cover this subject in this paper, being able to collapse columns and/or rows to make large tables readable on small screens would certainly be a useful feature in our project.
 The first motivation for tackling this project the way we did is the work of Jagadish et al [6], titled Making database systems usable . We thought about the presentation data model first to improve the database usability. An emphasis was put in this project on keeping the current display format (tables with multilevel headers, see Figures 1 and 2). This format works very well for current users of the data, and keeping it reduces the adaptation time to the new system. Certainly the familiarity and simplicity of the display format increases the system X  X  usability. The main goal was to find a way to easily support this format and the following use cases.

As pointed out in the introduction, most users of the data-base are read-only users. Either they are planning some mission or training, or executing it, or debriefing it, using the data without needing to modify it. To make changes, they need to contact the people in charge (the administrators of the database, probably officers located in some logistics department), and get an updated version later on. But this is done infrequently. A static version of the database, demanding less resources, can be kept on a PDA, or smart phone, or vehicle X  X  embedded information system, for easy access and use.

Another goal is to make the system simple enough to not require the admin-istrators to be technical people: keep the simplicity of a spreadsheet but make it more powerful and appropriate for the current project. The full administra-tor version requires full access (Read /Write) to the schema and the data, and we developed a version for PCs, with search function, queries, ..., and another version for use behind a web server (same search function and queries).
Regular (non-administrator) users can use a read-only version of the full ad-ministrator version, a trimmed down version to run on mobile phone or internet tablets (such as the Nokia N800 [8]), or a static HTML version to run on systems with limited resources. Sect ion 5 contains more details on the different versions, and discusses the implementation of the system. The XML layer of the project consists of an XML Schema, many XML documents containing the actual data and an XML Style Sheet that is applied on the XML documents to transform them into HTML tables with multilevel headers. 4.1 XML Schema The first step is to map the original tables to an XML Schema. Since many tables have the exact same attributes (like General Purpose Vehicles and Armoured Fighting Vehicles for example), we created XML Schema complex types and used some of them for many tables to avoid redundancy in the schema. Figure 3 shows the type definition for the Mines Laying Rates table (with the by machine element removed to save space).

Then follows in the schema all the allowable XML document roots, one for each of the tables. This implies that each table has its own XML document. One big XML document containing everything would be too big and inconvenient, so we choose this approach. Therefore we have a large number of relatively small XML documents, which is not a problem since they are stored in an XML database, and queries and updates are usually easier or at least not harder when using many smaller XML documents compared to one very big document. Refer to Figure 4 and 5 for examples.

To store and manage these XML documents, we could use any XML database or any database system supporting XML (like a relational database with XML extensions), but we choose an embedded XML database, namely BerkeleyDB XML, to satisfy the other requirements of the project. We could even use plain XML text files, without a database, but this would come with a big penalty since we would need to parse the full docume nts each time we need to access the data and we would not be able to use indexes to help answer queries. 4.2 XSL Style Sheet We decided to use XML style sheet (XSL) transformations to produce the mul-tilevel header tables from the XML data. The main challenge was to figure out a way to find the correct values for the column span ( colspan ) and row span ( rowspan ) attributes of the HTML table th tags, for cells in the HTML table header. For example, mine type in Figure 1 has a column span of 1 and a row span of 3, and by hand has a column span of 4 and a row span of 1. We wrote an XSL that is generic enough to pro duce a correct HTML table for any of the tables in our XML schema, for any depth or width of the table header, even if the schema is modified later on, with only a very small modification of the XSL. The only difference between the tab le transformations is that the main XSL template must match the table name (for example laying rates data )toget started. In our implementation, we do some string interpolation to insert the ta-ble name at the correct place before the actual transformation takes place. The other place we do this is in an h1 tag containing the table name in the output HTML. We do not include the full XSL here because it would require too much space, but excerpts are included and the algorithm is discussed next.
To be able to get the row span values right, we have to know the height of the tree making up the header. We also need to know the depth of each node as we process them. To get the depth of a node in XSL, we calculate how many ancestors it has. Figure 6 shows the template to compute the height of the header. What we do is sort all the nodes by their number of ancestors in descending order. Then we take the first node with the maximum depth and we return its depth. We need the +1 because ancestor::* does not include the root.
Similarly, to get the column span values right, we need to know the width of the tree below each node. So what we rea lly need to count is the number of leaf nodes under the given node. If the node itself is a leaf, then the column span will be 1. If not, we have to recursively count the number of leaves under the node, by repeating the process for each child node of the given node.
The header tree nodes are processed in a breadth-first manner. All the children nodes of the root are processed first, then the children nodes of these nodes, etc... Figure 7 shows the algorithm. When implementing this algorithm in an XML style sheet, the main difficulty is going through all the nodes in breadth-first order. The best way to do this is to start by matching all the nodes at a depth of 1, i.e. all the nodes under the root. Then match all the nodes one level deeper (depth of 2), then the nodes at depth 3, etc... All the programming, except at the XML layer, has been done with Python [4]. The first application developed was a script looping through all the tables, applying the XSL to the XML document containing the data, and dumping the results in HTML files. This export-to-HTML program is useful to produce a static HTML version of the database for u se on systems with limited resources, or on systems where the other applications, covered next, are not available.
An application with GUI to view and modify the database was developed, in two versions: the first using Python with the GTK library (see Figure 8), aimed at the Linux desktop (but can be ported to MS Windows and Apple Mac OS environments) and the second version to r un on the Nokia N800 internet tablet. The implementations are very similar, except that the N800 version doesn X  X  have the possibility to add, delete or modify rows of the tables. There are two main reasons we did that: first, based on the uses cases of the system, PDA or other portable device users should not have the option to modify the data; second, resources are limited and running the full application was very slow.
One big problem on systems with limited resources is applying the XSL to the XML documents to produce the HTML tables, more precisely generating the table headers can be a slow process. Since the schema is unlikely to change often, it is crucial to cache the table headers to avoid generating them all the time. A big performance improvement can be obtained by doing this. On powerful systems, we may save only 0.05 seconds, or even less, depending which table is processed and which XSLT processor is used, but on slower systems it can easily be several seconds lost every time.

We also developed a Web interface to the database. We wrote a stand-alone web server with the same functionality as the desktop version. We used the CherryPy Python package [10] to help in this task. The idea was to show yet another way to interact with the database, to show that many interfaces to the same database are possible. We certainly could have used some other technology to do this, for example use any full-fledged web server and run the application behind it, using any programming language. Our web application has two built-in modes, a read-only cached version, and a version with database modification power, aimed at administrators.

Since the core of the system is at the XML layer, implementing a full applica-tion is mostly a matter of building a GUI or web interface, except for the caching of table headers as discussed above. If a t a later time a new interface is needed, no problem since the data is completely separate from the interface. This will probably be obvious to most computer scientists or engineers, but apparently it is not so obvious in the military and government world. Many projects involve contractors who put the data into binary files in some undocumented propri-etary format, and the next contractor pr etty much has to reverse engineer the data files to figure out what X  X  going on before doing anything else. This problem cannot happen in our project. We developed our military logistics database from a usability-first point of view. We kept the paper-based presentation, w hich is still working very well, and found a good way to support it by using XML and XSL style sheets. Many interfaces are possible and we implemented a few, and we reached the project goals of having a version working on a portable device. Fo r the future, we need to perform a larger field study to get more feedback from users to improve the implementation of the system.

