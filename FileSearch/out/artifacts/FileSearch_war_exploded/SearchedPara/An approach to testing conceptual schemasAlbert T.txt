 1. Introduction idation, and we describe an approach to conceptual schema testing. opment, but, in professional practice, testing continues to be the dominant technique. their validation. by-construction, there is no need to test again the outputs from that transformation. to define.
 tual modeling methodology, similar to the popular test-driven development [32]. tions, and other test control and test reporting functions [35]. needed.
 related work. Finally, Section 8 summarizes the conclusions and suggests further work. 2. Basic concepts and notation of the conceptual schemas as invocations of system operations is straightforward [42]. ation. We define both the event constraints and the postcondition in OCL. ation cannot change the IB.
 3. Testing conceptual schemas In CSTL, the basic construct for testing conceptual schemas is a concrete test case .
Each concrete test case has a name and consists of a set of statements: t est testName { ... a ssert ... } modeler is to write test cases whose final verdict is Pass . semantics of the four kinds of statements related to testing conceptual schemas:  X  Statements that update the IB (Section 3.1).  X  Statements that assert the state of the IB (Sections 3.2, 3.3 and 3.6).  X  Statements that create domain events (Section 3.4).  X  Statement that assert the occurrence of domain events (Sections 3.4 and 3.5) 3.1. Updating the information base examples based on the schema fragment of Fig. 1 .
We define that entityID is a new instance of the entity types EntityType entityID :  X  n ew EntityType 1 , ... , EntityType n ; where entityID must be a new identifier. For example: cat1 :  X  n ew Category ; types not related by generalization/specialization relationships.
Entities can be deleted with the following statement: d elete entityExpr ; entityID.att :  X  val ; more entities given by the OCL expression participants we write: entityID.role :  X  participants ; pears is Error . For example: cat1.parent :  X  cat2 ;
EntityType 1 and the assignment of an initial value for its attributes att
The syntax is as follows: entityID :  X  n ew EntityType1 ( att 1 :  X  value 1 , ... , attn :  X  value where value i and participants i are OCL expressions. For example: cat3 :  X  n ew Category ( parent :  X  cat1 );
Instances of an n -ary UML association Assoc with roles r n ew Assoc ( r 1 :  X  entityExp 1 , ... , r n :  X  entityExp 3.2. Asserting the consistency of an IB state straints defined in the conceptual schema.
 a ssert consistency; low). In the latter, the corresponding constraint(s) must be corrected.
As an example, assume the schema shown in Fig. 1 and consider the following test case: t est CategoryCanBeInstantiated { } be corrected by changing the cardinality (multiplicity) of parent to 0..1. c ontext Category i nv thereMayNotBeCycles : 3.3. Asserting the inconsistency of an IB state statement: a ssert inconsistency; one language, then the IB state is inconsistent: t est CategoriesHaveANameInEachLanguage { } c ontext Category i nv CategoriesHaveANameInEachLanguage :
Now, the verdict of the above test case is Pass , as desired. 3.4. Asserting the occurrence of domain events
A domain event type is a complex schema element that may have several kinds of defects: 1. The constraints of the event type may not allow the occurrence of valid events. 2. The postconditions may not precisely define the intended effect of events. constraints.
 state, followed by an assertion of the (satisfactory) occurrence of that event. domain event type, then: eventId :  X  n ew EventType 1 ; domain event type EventType 1 and the assignment of the value for its attributes att r , ... , r m . The syntax is as follows: eventId :  X  n ew EventType 1 ( att 1 :  X  value 1 , ... , att the IB, the conceptual modeler writes the following sentence: a ssert occurrence eventId ;
The verdict of this assertion is determined as follows: not occur in inconsistent IB states). 3. Execute the method of the corresponding effect() operation. the verdict of the whole assertion is Pass.
 is associated with a manufacturer. Consider, now, the following test case: t est AManufacturerIsDeleted { } to make the test case Pass : c ontext DeleteManufacturer :: effect () m ethod DeleteManufacturer :: effect (){ } following event constraint: c ontext AddNewCategory i nv productHasNoCategories :
AddNewCategory is unsatisfiable. 3.5. Asserting the non-occurrence of domain events tion of the non-occurrence of that event.
 a ssert non-occurrence eventId ;
The verdict of this assertion is determined as follows: more event constraints are not satisfied.
 straint or refine an existing one in order to make it more constraining. then the following event constraint must be added: c ontext DeleteManufacturer i nv manufacturerHasNoProducts :
With the above event constraint, the following test case will pass (as expected): t est theManufacturerCannotBeDeleted { } 3.6. Asserting the contents of an IB state effect of one or more domain events implies an expected result in the IB. writes the following statement: assert true booleanExpression ; events specification.

A similar CSTL statement is as follows: a ssert false booleanExpression ;
Additionally, CSTL includes the following assertions: a ssert equals valueExpression1 valueExpression2 ; a ssert not equals valueExpression1 valueExpression2 ; is defined as follows: c ontext Category :: numberOfProducts : Natural t est NumberOfProductsInACategory { } will pass if the derivation rule is corrected as follows: c ontext Category :: numberOfP roducts:Natura l 4. Testing conceptual schemas with temporal constraints and derivation rules this section are based on the schema fragment shown in Fig. 4 . 4.1. Temporal constraints on the population of entity types previous consistent IB state.

For example, assume the following test case: t est DeletingAnOrder { } Pass .
 type, then the postcondition is as follows:
E . allInstances () = E . allInstances@pre () follows:
E . allInstances () -&gt; includesAll ( E . allInstances@pre ()) 4.2. Temporal constraints on the population of relationship types
R ( p : E 1 , ... , p n : E n ) is constant with respect to a participant p the same during the temporal interval in which e i exists. A relationship type R ( p participant p i if the instances of R in which an instance e one of their participants.
 participates never cease to exist during the temporal interval in which the customer exists. operation are as follows. If R ( p 1 : E 1 , ... , p 2 : E
E 1 . allInstances ()-&gt; intersection ( E 1 . allInstances@pre e 1 . p 2 = e 1 . p 2 @ pre )
If R ( p 1 : E 1 , ... , p 2 : E 2 ) is permanent with respect to a participant p
E 1 . allInstances ()-&gt; intersection ( E 1 . allInstances@pre e 1 . p 2 -&gt; includes ( e 1 . p 2 @ pre )) And if the maximum multiplicity is greater than 1, then:
E 1 . allInstances ()-&gt; intersection ( E 1 . allInstances@pre e 1 . p 2 -&gt; includesAll ( e 1 . p 2 @ pre ))
For example, assume the following test case: t est ChangingTheCustomerOfAShoppingCart { } dition that is not satisfied is as follows:
ShoppingCart.allInstances ()-&gt; intersection ( ShoppingCart.allInstances@pre tion to assert inconsistency in order to make the test Pass . 4.3. Creation-time constraints stereotyped  X  X  X niIC X  that must give a True result when the corresponding entity is created. ated. The formal specification in OCL is as follows: c ontext ShoppingCartItem :: productAttributesEnabled (): Boolean b ody: self.attribute.productAttribute -&gt; forAll ( status where the operation productAttributesEnabled has the stereotype  X  X  X niIC X . bute once it has been used in the creation of a shopping cart item: t est changeProductAttributeStatus { } tributesEnabled is only evaluated when shopping cart items are created. assertion.
 ing postcondition to our simulated operation: ( E . allInstances () -E . allInstances@pre ())
In the example, the postcondition becomes the following: (
ShoppingCartItem.allInstances () -ShoppingCartItem.allInstances@pre 4.4. Derived constant relationship types remain fixed during its lifetime [45].
 later on.

Consider as an example the following test case: t est priceDoesNotChange { } rived and constant.
 created since the execution of the previous assertion.
 5. The CSTL language of variables. If fc is a fixture component, then a test case may use the following statement: l oad fc ; cardinality constraints shown in Fig. 4 , it should have at least one. created is expectedTotal .
 of the one is Fail .
 from the verdicts of the test kinds defined in the previous section as follows: test case is Error .
 case is Fail .
 The verdict of a test case is Pass if the verdicts of all its assertions are Pass . dicts of its test cases as follows: 1. If the verdict of a test case is Error , then the verdict of the program is Error . 2. If the verdict of a test case is Fail , then the verdict of the program is Fail . 3. When the verdict of all test cases is Pass , the verdict of the program is Pass . 6. The test processor the execution of test programs is done by the test processor. temporal constraints and derivation rules described in Section 4. sions over the IB.

The assert statements described in Section 3 are executed as follows: verdict is Fail if the set is non-empty. computes the verdict from the results obtained.
 language. Many more examples can be found in [39].
 7. Related work final system or of any intermediate artifact.
 language (CSTL) for writing test cases of conceptual schemas. 11].
 opment environment. 8. Conclusions similarities and differences between testing conceptual schemas and testing programs. also be applied to schemas with temporal constraints and derivation rules. appreciate the complexity and the need for testing.
 needed (regression testing).
 [64].
 Acknowledgments
Appendix A. CSTL grammar testProgram : testprogram &lt; programID &gt;{ fixture fixtureComponent * testCase *} fixture : statement * fixtureComponent : fixturecomponent &lt; fixtureComponentID &gt;{ statement *} testCase : concreteTest j abstractTest j abstractTestInvocation concreteTest : test &lt; testID &gt;{ statement *} abstractTest : abstract test &lt; abstractTestID &gt; paramList {statement *} paramList : ( parameter [, parameter ]* ) parameter : parameterType &lt; parameterID &gt; type : &lt; oclPrimitiveType &gt; j &lt; entityTypeID &gt; parameterType : type j Fixture abstractTestInvocation : test &lt; abstractTestID &gt; parametersAssignment parametersAssignment : ( parameterAssignment [, parameterAssignment ]* ) parameterAssignment : &lt; parameterName &gt; :  X  expression expression : &lt; oclExpressionWithVariableIDs &gt; statement : stateStatement ; j variableStatement ; j assertion ; j controlFlowStatement stateStatement : entityCreation j entityDeletion j binaryPropertySetting j nAryRelationshipCreation j fixtureComponentLoading variableStatement : variableDeclaration j variableAssignment assertion : assertTrue j assertFalse j assertEquals j assertNotEquals j assertConsistency j assertInconsistency j assertDomainEventOccurrence j assertDomainEventNonOccurrence controlFlowStatement : conditional j whileLoop j forLoop j forEachLoop entityCreation : new &lt; entityTypeID &gt;[,&lt; entityTypeID &gt;] * propertiesAssignment ? propertiesAssignment : ( propertyAssignment [, propertyAssignment ]* ) propertyAssignment : &lt; propertyID &gt; :  X  expression entityDeletion : delete expression binaryPropertySetting : expression :  X  expression nAryRelationshipCreation : new &lt; assocID &gt; participantsAssignment participantsAssignment : ( participantAssignment [, participantAssignment ]+ ) prarticipantAssignment : &lt; roleID &gt; :  X  expression fixtureComponentLoading : load &lt;fixturecomponentID&gt; variableDeclaration : type &lt; varID &gt; variableAssignment : assertTrue : assert true expression assertFalse : assert false expression assertEquals : assert equals expression expression assertNotEquals : assert not equals expression expression assertConsistency : assert consistency
Appendix A ( continued )
References assertInconsistency : assert inconsistency assertDomainEventOccurrence : assert occurrence &lt; domainEventID &gt; assertDomainEventNonOccurrence : assert non-occurrence &lt; domainEventID &gt; assertDomainEventNonOccurrence : assert non-occurrence &lt; domainEventID &gt; condition : if expression then statement * [ else if expression then statement *]* [ else statement *]? endif whileLoop : while expression do statement * endwhile forLoop : for variableAssignment to expression step expression do statement * endfor forEachLoop : for each [ variableDeclaration j varID ] in expression do statement * endfor Appendix A ( continued )
