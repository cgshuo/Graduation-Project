 KSORD(Keyword Search Over Relational Databases) is an easy and effective way for casual users or Web users to acces s relational databases [1]. In re-cent years, much research on KSORD has been done, and many prototypes of KSORD have been developed. Accord ing to the query processing strategy KSORD systems adopted, they can be cate gorized into two types: offline systems and online systems. Offline systems retri eve results for a keyword query from an intermediate representation generated by  X  X rawling X  the database in advance, such as EKSO [2], or from some indexes created beforehand, such as Objec-tRank [3] and ITREKS [4]. Online systems convert a keyword query into many SQL queries to retrieve results from the database itself. Furthermore, online KSORD systems can be classified into two categories [1] acco rding to the data model they adopted, Schema-graph-based Online KSORD(S0-KSORD) systems like SEEKER [5], DBXplorer [6], DISCOVER [7] and IR-Style [8], and Data-graph-based Online KSORD(DO-KSORD) systems like BANKS [9], BANKS II [10] and DETECTOR [11, 12].

Offline KSORD Systems usually execute queries efficiently, but they can not query the up-to-date data in time, and also require a long preprocessing time and large storage space to generate and store the intermediate representation. On the contrary, online KSORD systems can retrieve the latest data from the database, but the execution is usually inefficient because the converted SQL queries often contain many join operators as for SO-KSORD systems and the data graph search algorithms can not scale to the number of query keywords and the size of data graph as for DO-KSORD systems.

Many prototype systems of KSORD have been developed. However, a KSORD system would not be put into practice if its efficiency or effectiveness is poor [1]. Fortunately, the effectiveness and effici ency of KSORD have attracted more and more attention recently. IR-Style [8] i mproved DISCOVER [7], BANKS II [10] improved BANKS [9], and Fang Liu et al. studied the effectiveness of KSORD. In this paper, we focus on the efficiency and effectiveness of online KSORD systems. We analyze the cause of the effi ciency and effectiveness problems in online KSORD systems, and introduce many optimization methods we have proposed in this area. Finally, we discuss some further research topics.
The rest of this paper is organized as fo llows. Section 2 analyzes the perfor-mance problems in KSORD in terms of e fficiency and effectiveness. Section 3 introduces the methods on improving t he efficiency of KSORD in detail, while the methods for effectiveness improveme nt are described in Section 4. Section 5 points out further research topics, and we conclude in Section 6. In this section, we presen t the architectures of online KSORD systems, and analyze the bottlenecks of their efficiency and effectiveness. 2.1 Efficiency of SO-KSORD The architecture of SO-KSORD systems is shown in Fig. 1. Once a SO-KSORD system starts up, the database schema g raph can be rapidly created. When a user query Q comes, tuple s et creator(TS Cr eator) creates tuple sets for each relation that has text attributes along with full-text indexes, and only those non-empty tuple sets are left. Then, Candidate Network Generator(CN Generator) outputs a complete and non-redundant se t of Candidate Networks(CNs) [7, 8] whose sizes are not greater than Maximum allowed CN size(MaxCNsize, the maximum allowed number of nodes in a CN) through a breadth-first traversal of tuple set graph G ts . CNs are join trees of tuple sets which will be used to produce potential answers to Q. G ts is generated by extending database schema graph G s . Finally, CN executor employs a certain strategy to run CNs to get results for Q.

The user query response time( T res ) of SO-KSORD systems is mainly composed of three parts. The first is T ts which denotes the time to create tu-ple sets(TSs). The second is T cn which denotes the time to generate CNs. The third is T sql which denotes the time to execu te converted SQL queries from CNs. T ts is usually small and determined by the Information Retrieval(IR) en-gine of RDBMS. T sql is the most significant part aff ecting the execution efficiency of SO-KSORD systems. Still, T cn also has an important effect on the efficiency of SO-KSORD systems.

In order to improve the efficiency of DISCOVER [7], IR-Style [8] only creates a single tuple set for each relation with text attributes so that G ts is much smaller than that in DISCOVER. Thus, CN generation is much faster in IR-Style. Unlike that DISCOVER executes all CNs and returns all results for a query Q, IR-Style runs a top-k algorithm, such as SParse algorithm(SP) or Global pipelined Algorithm(GA) [8], to execute CNs to get top-k results for Q. Then T sql can be greatly reduced. Therefore, IR-Style can perform much faster than DISCOVER. However, IR-Style still performs very po orly in some cases. In fact, the efficiency bottlenecks of SO-KSORD systems are as follows.
 Inefficiency of CN generation. As the number of query keywords or MaxC-Nsize increases, or the database schema becomes complicated, it will take much more time to generate CNs for a query Q. Currently, existing SO-KSORD sys-tems generate CNs temporarily through a breadth-first traversal of G ts for any user query. There can be two ways to reduce the time for the generation of CNs. One is to develop a more efficient CN generation algorithm, the other is to develop preprocessing techniques to generate CNs in advance.
 Inefficiency of CN Execution. On one hand, tens or hundreds of CNs may be generated for a query Q, while existing top-k algorithms are inefficient to execute so many CNs. On the other hand, the SQL queries converted from CNs may contain many JOIN operators, but, as we know, JOIN operation is an expensive operation in RDBMSs. 2.2 Efficiency of DO-KSORD The architecture of DO-KSORD systems is shown in Fig. 2. This figure looks like the architecture of SO-KSORD systems. H owever, they are essentially different. When a DO-KSORD system starts up, it cr eates data graph instead of schema graph. Similarly, when a user query Q c omes, tuple set crea tor(TS Creator) creates tuple sets for each relation that has text attributes along with full-text indexes, and only those non-empty tuple sets are left. Then, Keyword Node Identifier(KN identifier) identifies those data graph nodes which contain query keywords according to the tuple sets. And the key step is that Data Graph Searcher(DG Searcher) searches the data graph with a certain strategy to get Join Trees of Tuples(JTTs) as top-k results for Q. Finally, Result Assembler(RS Assembler) can retrieve the real information of each tuple in a JTT from the relational database to assemble complete results for end users.

Obviously, DG Searcher determines the efficiency of DO-KSORD systems. In other words, the efficiency bottleneck o f DO-KSORD systems lies in the efficiency of data graph search algorithm employed by DG Searcher. BANKS [9] employs a heuristic backward expanding search algorithm to produce JTTs as results for a query Q. But it may perform poorly if some keywords match many nodes, or some nodes have very large degrees [10]. In order to improve BANKS, bidi-rectional search algorithm wasproposedinBANKSII[10 ]. Bidirectional search improves backward expanding search by allowing forward search from potential roots towards leaves, and a novel search frontier prioritization technique based on spreading activation was devised to exploit this flexibility [10]. However, this data graph search algorithm still is not efficient enough. As the number of query keywords increases, or the data graph becomes larger, BANKS II [10] performs more poorly in terms of time complexity and space complexity.

In addition, all of existing DO-KSORD prototypes assume that data graph fits in memory. However, data graph for a large database can be too huge to be accommodated in limited main memory. To a certain extent, data graph is similar to Web graph [13], however, data graph, containing database schema information, is quite different from Web graph. So, it is possible to develop special techniques to compress data graph by exploiting the characteristics of data graph so that larger data graph can be loaded into memory.

Therefore, there are two ways that can be explored for improving the per-formance of DO-KSORD systems. One i s to develop more efficient data graph search algorithms which can scale to the number of query keywords and the size of data graph. The other is to develop data graph compression techniques. 2.3 Effectiveness of KSORD Fang Liu et al. are the first ones to study the effectiveness of KSORD in de-tail [14]. They found out that KSORD is different from keyword search over text databases in the following ways: (1) Answers for a query are JTTs. (2) A single score for each JTT is needed to es timate its relevance to a given query. (3) Relational databases have much rich er structures than text databases. As a result, existing IR strategies are inadequate in ranking relational outputs. So, they proposed a novel IR ranking str ategy for effective KSORD. Their main ideas are as follows. Firstly, four new normalization factors(tuple tree size, doc-ument length, document frequency and inter-document weight) are identified and used. Secondly, schema terms are identified and are processed differently from value terms. Finally, phrase-base d and concept-based models are used to further improve search effectiveness.
However, Fang Liu et al. also pointed out that the link structures (primary key to foreign key relationships as well as some hidden join conditions), and some non-text columns can be further u tilized to improve the effectiveness of KSORD [14].

The result presentation also affects the effectiveness of KSORD to a great extent [1, 11]. Firstly, the results need to be semantically meaningful to users. However, a result which is a tuple or a tuple connection tree is not so easy to understand for end users. Secondly, it is important to avoid overwhelming users with a huge number of trivial resul ts. However, lots of similar results are often produced, which makes users tired or confused. In KSORD research, many ways are used to present query resul ts. BANKS [9] shows the query results in a nested table and improves the answer format by addressing readability. DbSurfer [15] uses tree-like structures to display all trails, while DataSpot [16] uses a distinguished answer node to represent a result. However, their work does not solve the problem of lots of similar results.

Currently, KSORD systems are based on full-text indexes created by IR en-gine of RDBMS. In general, keyword search has inherent limitations. Keyword search is only based on keyword matching and does not exploit the semantic relationships between keywords such as hyponymy, meronymy, or antonymy, so the effectiveness is often dissatisfactory in terms of recall rate and precision rate. With the increasing research interest on ontology and semantic web, ontology-based semantic search over relational databases has become a  X  X ot X  research topic in database community [17, 18]. So, exploiting ontology to improve the effectiveness of KSORD recei ves increasing attention. In recent years, we have developed many techniques to optimize the efficiency of online KSORD systems. Aiming at improving SO-KSORD systems, we proposed a new preprocessing approach PreCN [21] to improve the generation efficiency of CN, and CLASCN [24] and QuickCN [26] methods to improve the execution effi-ciency of CN. As for DO-KSORD systems, a novel and efficient data graph search algorithm called DPBF [11, 12] was devel oped to improve the efficiency of DO-KSORD. CodCor [27] method was proposed to compress data graph by exploit-ing connection relations in relation databases. CodCor not only makes a large data graph fit in memory, but also improves the efficiency of existing data graph search algorithms, such as that in BANKS [9] and BANKS II [10]. Of course, CodCor is also helpful to improve the efficiency of QuickCN [26] and DPBF [12]. Based on the above methods, we implemented a new efficient and effective online KSORD system called QuicK 2 SORD . Fig. 3 shows the architecture of QuicK 2 SORD .We will discuss those methods in the following subsections. 3.1 Improving the Generation Efficiency of CN Since SO-KOSRD systems generate CNs for a query temporarily, we exploit pre-processing techniques to generate CNs in advance [22, 21]. Offline systems(such as EKSO [2]) usually preprocess the data and generate an intermediate represen-tation for the database. However, what is preprocessed in SO-KSORD systems is the database schema information, not the data. As we know, the schema in-formation is usually stable, but the data is changing dynamically.
As for boolean-AND semantic keyword queries in DISCOVER [7], a new pre-processing technology [22] was proposed to generate CN patterns in advance through a breadth-first traversal of G s and to store them in the database. When a user issues a keyword query, proper CN patterns are retrieved from the database and evaluated according to the specific tuple sets created temporarily for the query, thus CNs are generated for the query.

As for boolean-OR semantic keyword qu eries in IR-Style [8] and SEEKER [5], we find out that G ts patterns can be viewed as user keyword query patterns for a given G s . All CNs under the limitation of MaxCNsize and Maximum al-lowed Keyword Number(MaxKeywNum) ca n be generated in advance through a breadth-first traversal of the maximum G ts , and then stored in the database. When a user query arrives, its proper CNs are directly retrieved from the database. This method is called PreCN [21]. PeCN is simpler and more efficient than that in [22].

PreCN requires less physical storage space to store the p re-generated CNs, and can also search the up-to-date data in the database. 3.2 Improving the Execution Efficiency of CN We proposed two methods to improve t he execution efficiency of CN, one is CLASCN [24], the other is QuickCN [26].
 CLASCN: Select the most Promising CN to be executed. Although tens or hundreds of CNs can be generated for a keyword query in SO-KSORD systems, the top-k results only distribute in a few CNs. So, a novel approach CLASCN (Classification, Learning And Selection of Candidate Network) was proposed to improve the efficiency of SO -KSORD systems [24]. The main ideas of CLASCN are as follows. Each CN can be viewed as a database, and CN Language Models(CNLMs) can be constructed by performing trained keyword queries in advance and user queries dynamically. When a user query arrives, the similarities between the query and its CNs are computed by employing Vector Space Model (VSM) [25], and only the most promising CNs to produce top-k results are picked out and executed. CL ASCNcanbecombinedwithanyexact top-k algorithm to support efficient top-k keyword queries, and at the same time acceptable recall and pr ecision rates of top-k re sults can be achieved.
Currently, because CNLMs are constructed using query keywords, CLASCN is only applicable for previously executed queries and New All-keyword-Used queries(never executed before but all the keywords occurred in previous queries), which are frequently submitted. Our extensive experiments showed that the CLASCN approach was efficient and effective.
 QuickCN: Exploiting Data Graph to Execute CN. AnovelmethodQuickCN was proposed to quickly execute CNs on data graph [26]. The basic ideas are as follows. CNs are considered as join expressions , and also can be viewed as query patterns and result patterns. At the same time, the database can be modeled as a data graph [9, 10] which is actually a huge tuple-joined network generated in advance. So, the data graph can be searched with CN patterns to quickly produce JTTs as the final results. This is different from BANKS [9,10]. BANKS searches the data graph without knowing of result patterns. As a result, lots of intermediate results will be produced during the search process. In QuickCN, the data graph search process is schema-driven due to the search result patterns known in advance. The adjacent nodes of each node in the data graph can be classified by their relation names and Primary-Key-to-Foreign-Key relationship types, and the foreign-key nodes have n-to-1 map to their primary-key adjacent nodes. These properties can be exploited to reduce the search space in data graph. Our experiments showed that QuickCN was efficient. 3.3 Exploiting Connection Relation to Compress Data Graph For DO-KSORD systems, we proposed an approach CodCor(abbr. for Compress-ing Data graph by Connection Relations) to compress data graph by exploiting connection relations [27] . A connection relation R is a relation in the database that satisfies the following conditions: (i) there are exactly two foreign keys in re-lation R ; (ii) R  X  X  primary key consists of its foreign keys. (iii) R is not referenced by any relation. Many databases, such as DBLP or Northwind, have connection relations. The main ideas of CodCor are as follows. The nodes coming from con-nection relations are removed and the ed ges linked with each removed node are connected into one edge. In theory, Cod Cor can compress data graph by more than half of its storage if there are en ough tuples in conn ection relations.
CodCor can not only make a large data graph fit in memory, but also im-prove the efficiency of existing in-memory data graph search algorithms, such as BANKS [9] and DPBF [12]. Of course, CodCor can also improve the efficiency of QuickCN. For the future work, we consider the relaxation of connection rela-tion X  X  definition so that more kinds of databases can benefit from CodCor, and also try to combine CodCor with some compression techniques used for Web Graph [13] to further compress the data graph. 3.4 Developing Efficient Data Graph Search Algorithm An efficient data graph search algorithm named DPBF was proposed [11,12]. Like in BANKS [9, 10], we model a relational database as a weighted graph, G ( V, E ). Here V is a set of nodes representing tuples and E is a set of edges representing foreign-key references among tuples. An edge, ( u, v )  X  E , represents a foreign key reference between two tuples, u and v ,if u has a foreign key matching the primary key attributes of v ,or v has a foreign key referring to the primary key of u . The weights on nodes and edges are predetermined [9, 10].

Given a l keyword query, p 1 ,p 2 ,  X  X  X  ,p l , against a relational database or equiv-alently the corresponding graph G ( V, E ). Let V i  X  V be a set of nodes that contain the keyword p i . An answer to such a query is a weighted and connected tree containing at least one node from each V i . The problem we are targeting is how to find top-k minimum cost tuple connection trees.

A dynamic programming approach was proposed to find the optimal top-1 with the time complexity of O (3 L  X  N +2 L (( L +log N )  X  N + M )), where N and M are the numbers of nodes and edges in the graph G respectively. Because the number of keywords, L , is small in keyword queries, this solution can handle graphs with a large number of nodes efficiently. It is important to note that our solution can be easily extended to support top-k . That is, we compute top-k minimum cost tuple connection trees on e-by-one incremen tally, and do not need to compute or sort all results in order to find the top-k results. We have developed techniques to improve the effectiveness of online KSORD systems. For example, SemCN [19] was pro posed to improve the effectiveness of SO-KSORD systems, and a novel cluster ing method named TreeCluster [23, 11] was proposed to improve the effectiven ess of DO-KSORD systems. We discuss them in detail as follows. 4.1 Improving the Effectiveness of KSORD Based on Ontology We proposed a novel approach SemCN(semantic CN) in SO-KSORD systems to implement semantic search over relat ional databases, and developed a pro-totype Si-SEEKER [19] which extends SEEKER [5]. In Si-SEEKER, the data are annotated with the concepts in the ontology. Semantic indexes are created before query processing. A user keywor d query is transformed into a concept query in the same concept space of the ont ology, and the hierarchical structure of domain-specific ontology and generalized vector space model(GVSM) [20] are employed to compute semantic similari ty between the concept query and anno-tated data. As a result, semantic results will be returned in higher recall and precision rates than that in KSORD syst ems. We also combine semantic search with keyword search to tolerate the incompleteness of ontology and annotations of data. Our experiments show that the framework is effective. 4.2 Clustering and Presenting Search Results Organizing search results into clusters can facilitate users X  quick browsing through search results. Hunter [22] proposed a result classification method. In preprocess-ing, the system produces various pattern s, and in querying, users select a partic-ular pattern and the system searches the results matching the selected pattern. We proposed a novel approach for clustering results named TreeCluster [23,11]. Our approach can be implemented outside the system and applicable to various KSORD systems. Clustering results has b een widely applied in related research areas, such as in presenting Web search r esults, but those clustering methods are not applicable to KSORD results. Take into account the characteristics of KSORD search results, TreeCluster comb ines the structure and content infor-mation together and includes two steps of pattern clustering and keyword clus-tering. In the first step, we use labels to represent schema information of each result tree and cluster the trees into groups. The trees in each group are isomor-phic. In the second step, we rank user keywords according to their frequencies in the database, and further partition the large groups based on the content of the keyword nodes. Furthermore, we give each cluster a meaningful descrip-tion, and present the description and each result tree graphically to help users understand the results more easily. Experimental results verify our methods X  effectiveness and efficiency.This is the first proposal for clustering search results of KSORD. Current study on KSORD gener ally focuses on a single database, however, many practice settings require keyword search over multi-databases [28]. Exploiting ontology to do semantic search over relational databases has attracted more and more attention in database community. Above scenarios give birth to more challenges to improve the efficiency an d effectiveness of KSORD. In addition, up to now, there is not any standard testbed for KSORD yet. We discuss some topics worthy of further resea rch as follows in this section. 5.1 Keyword Search ov er Multi-databases M.Sayyadian et al. addressed the problem of keyword search over heteroge-neous relational databases, and proposed Kite algorithm which combines schema matching and structure discovery techniques to find approximate foreign-key joins across heterogeneous databases [28]. There will be more challenges to improve the performance of KSORD in multi-database setting than in single-database setting [28], such as exponential search space with the growing number of databases and their associated foreign-key joins, expensive foreign-key joins due to communication and data-transfer costs, and the difficulty to estimate accurate statistics(e.g., the estimated result size of a SQL query). Kite imple-mented keyword search over multi-dat abases, but the query efficiency can be further improved by takeing into account more factors, such as communication and data-transfer costs. 5.2 Ontology-Based KSORD Ontology has been widely studied in semantic Web and IR community. Due to great differences between re lational data and the documents residing in seman-tic Web and text databases [14], however, ontology-based semantic search over databases has many new challenges, such as efficient semantic indexes, semantic similarity computation, and so on. Ontology can be used to improve the effec-tiveness of KSORD, whereas it may impair the efficiency of KSORD. Efficient semantic indexes ought to be developed to improve the efficiency of ontology-based KSORD systems. In addition, ontology-based data graph search algorithm is also an interesting topic to study on. 5.3 Result Presentation Although some research has been done to improve result presentation of KSORD system, much work is still to be done. We only enumerate two cases here.
For one example, to improve the clustering effectiveness, we could try to employ more schema information in the search process of KSORD to facilitate clustering or classifying the results.

For another example, relevance feedback could be used to improve result pre-sentation [25]. In a relevance feedback cycle, the user is presented with a list of the retrieved results and, after examining them, marks those that are relevant. The main idea is to detect important chara cteristics of the results that have been identified as relevant by the user, and then enhance the importance of these char-acteristics in a new query formulation. The expected effect is that the new query will be moved towards the relevant results and away from the non-relevant ones. Early experiments in traditional IR have shown good improvements in preci-sion for small test collections when rele vance feedback is used. However, those feedback methods used in IR may not be applicable to KSORD because of the different characteristics of search results. Furthermore, in KSORD, there is also database schema information which could be used to assist the feedback. 5.4 Benchmark of KSORD Benchmark-based experimental results for all current KSORD systems are needed. There are many reference collections used to evaluate information retrieval sys-tems, such as the TREC collection [29 ]. It is necessary to build a reference database collectio n used for evaluating the performance of KSORD systems in terms of efficiency and effectiveness. It is a significant fundamental work and requires many efforts. Many approaches have been proposed to implement KSORD, however, the ef-ficiency and effectiveness of KSORD rema ins critical issues. We analyze the efficiency and effectiveness problems i n KSORD systems, and present several approaches that we proposed to improve the efficiency and effectiveness of on-line KSORD systems. In the end, some topics worthy of further research are discussed in this area.
 This work is supported by the National Natural Science Foundation of China (No.60473069 and 60496325), and China Grid(No.CNGI-04-15-7A).

