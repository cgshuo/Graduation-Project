 XUAN-HIEU PHAN, LE-MINH NGUYEN, YASUSHI INOGUCHI, and TU-BAO HO
Japan Advanced Institute of Science and Technology and SUSUMU HORIGUCHI Tohoku University 1. INTRODUCTION Discriminative models like Maximum Entropy (MaxEnt) [Berger et al. 1996], Discriminative HMMs [Collins 2002], Maximum Entropy Markov Models (MEMMs) [McCallum et al. 2000], and CRFs [Lafferty et al. 2001] have achieved significant success in many labeling and segmenting tasks for sequence data such as POS tagging [Ratnaparkhi 1996], text shallow parsing [Peng et al. 2004;
Sha and Pereira 2003], information extraction [Kristjansson et al. 2004; Pinto et al. 2003], object detection in computer vision [Torralba et al. 2004], image analysis and labeling [Kumar and Hebert 2003; He et al. 2004], and biological sequence modeling [Yeo and Burge 2003]. The noticeable advantage of these models is their flexibility in integrating a variety of arbitrary, overlapping, and nonindependent features at different levels of granularity from the observed data.

However, applications employing these models with fixed and hand-built fea-ture templates usually generate a huge number of features, up to millions, for example, in Sha and Pereira [2003]. This is because one usually utilizes com-plex templates, including conjunctions of atomic statistics, for instance, n-gram of words or POS tags, to cover as many combinations of statistics as possible without eliminating irrelevant ones. As a result, models using long and fixed conjunction templates are heavily overfitting and time consuming to train be-cause they contain many teacher-specific and redundant features. To reduce these drawbacks, McCallum [2003] proposed a likelihood-driven feature induc-tion for CRFs that is based on a famous-feature inducing strategy for exponen-tial models [Pietra et al. 1997]. This method iteratively adds the conjunctions of atomic observational tests that increase conditional log-likelihood into the model until some stopping criteria are reached. In spite of attaining a trade-off between the number of used features and model accuracy, this strategy may ignore rare but sensitive conjunctions with smaller likelihood gains that are still critical to model performance. Also, when the number of atomic statistics is large, the number of conjunctions becomes explosive, and thus ranking all conjunctions by likelihood gain is very expensive.

In this article, we propose a data-driven approach that can identify and em-phasize rare but important conjunctions or co-occurrences of statistics in training data in order to improve prediction accuracy for difficult data in-stances. The main motivation and the underlying idea of this approach are based on the fact that sequence data, such as natural language or biological in-formation, potentially contain the following phenomena that can be the major sources of prediction errors  X  Ambiguous data instances usually contain unclear contextual clues that may result in misleading predictions. For instance, it is quite difficult for a phrase-chunker to determine whether the word plans in the text the trip plans for
Japan is a singular verb or a plural noun.  X  Irregular instances are recognized as exceptions to the common statistics or decisions. For example, a POS tagger may mark walk as a noun in the sentence The disabled walk very slowly because of a regular sequential dependency that a noun should follow an adjective. However, the correct interpretation is that The disabled is the subject and walk is a plural verb rather than a noun.  X  Unbalanced data occurs when the distribution of classes in the training data is unbalanced. For example, the number of English noun phrases is much larger than that of other phrase types, for example, adjective phrases. This may lead to low prediction accuracy for minor classes due to the dominance of major ones.  X  Frequently vs. less-observed data , for instance, a named entity recognizer may identify New York University as a location, while it is in fact an organi-zation. This is because New York is observed more frequently than New York
University .  X  Long dependencies in sequence data . Several kinds of sequential training data contain long dependencies among observations at different positions in a sequence. The problem is that one can not always use a large sliding window to capture such useful clues because it would generate too many irrelevant features.

Data instances falling into the these situations should be difficult data ex-amples. Thus, the prediction of their labels does not usually obey the frequently observed statistics. In other words, the simple aggregation of singleton statis-tics may lead to misleading predictions because the common statistics always overwhelm uncommon ones. To overcome this pitfall, a model should rely on higher-order features that are based on special conjunctions of singleton statis-tics to win the dominance of common decisions. Although those conjunctions may only occur several times in a whole dataset, their appearance is an impor-tant source of evidence to deal with difficult data instances.

In spite of their benefit, searching such conjunctions from big datasets is chal-lenging because the number of candidates is prohibitively large. Fortunately, we find that recent association-rule mining techniques are very useful for discover-ing such patterns. In our method, those conjunctions belong to a subset of rare but highly confident association rules discovered from the training data. Se-lected conjunctions are then integrated into the discriminative models in three ways to improve their prediction accuracy: (a) conjunctions as normal features, (b) conjunctions as weighted features, and (c) conjunctions as constraints for the inference process.

The rest of this article is organized as follows. Section 2 briefly introduces linear-chain CRFs, a typical sequential learning model. Section 3 presents the framework for discovering important associations of statistics from training data. Section 4 describes how to learn sequential models with discovered associ-ations. Section 5 describes and discusses the experimental results. Section 6 re-views related work. Finally, conclusions and future work are given in Section 7. 2. DISCRIMINATIVE SEQUENTIAL LEARNING
The goal of labeling/tagging for sequence data is to learn to map observation sequences to their corresponding label sequences, for instance, the sequence of POS tags for words in a sentence. Discriminative HMMs [Collins 2002],
MEMMs [McCallum et al. 2000], and CRFs [Lafferty et al. 2001] were inten-tionally designed for such sequential learning applications. In contrast to gen-erative models like HMMs [Rabiner 1989], these models are discriminative, that is, trained to predict the most likely label sequence given the observation sequence. In this article, CRFs are referred to as the undirected linear-chain of model states, that is, conditionally-trained finite state machines (FSMs) that obey the first-order Markov independence assumption. The strength of CRFs is that they can combine both the sequential property of HMMs and the maximum entropy principle as well as global normalization that can avoid the label-bias problem. In our work, CRFs were used to conduct all experiments. 2.1 Conditional Random Fields
Let o = (o 1 ,o 2 , ... ,o T ) be some observed data sequence. Let S be a set of FSM states, each of which is associated with a label, l  X  L . Let s be some state sequence; Lafferty et al. [2001] define CRFs as the conditional probability of a state sequence given an observation sequence as over all label sequences. f k denotes a feature function in the language of max-imum entropy modeling and  X  k is a learned weight associated with feature f
Each f k is either a per-state or a transition feature: where  X  denotes the Kronecker- X  . A per-state feature (2) combines the label l of current state s t and a statistic or context predicate, that is, the binary function x ( o , t ) that captures a particular property of the observation sequence o at time position t . For example, the current label is JJ (adjective) and the current word is sequential. A transition feature (3) represents sequential dependencies by combining the label l of the previous state s t  X  1 and the label l of the current state s t , such as the previous label l = JJ and the current label l 2.2 Inference in Conditional Random Fields
Inference in CRFs is to find the most likely state sequence s * given the obser-vation sequence o ,
In order to find s *, one can apply a dynamic programming technique with a slightly modified version of the original Viterbi algorithm for HMMs [Rabiner 1989]. To avoid an exponential time search over all possible settings of s , Viterbi stores the probability of the most likely path up to time t , which accounts for the first t , observations and ends in state s i . We denote this probability to be  X  ( s i )(0  X  t  X  T-1)and  X  0 ( s i ) to be the probability of starting in each state s
The recursion is given by
The recursion terminates when t = T -1 and the biggest unnormalized prob-ability is p  X = arg max i [  X  T ( s i )]. At this time, we can backtrack through the stored information to find the most likely sequence s *. 2.3 Training Conditional Random Fields
CRFs are trained by setting the set of weights  X  ={  X  1 , log-likelihood, L , of a given training data set D ={ (o ( k ) where the second sum is a Gaussian prior over parameters with variance which provides smoothing to deal with sparsity in the data [Chen and Rosenfeld 1999].

When the labels make the state sequence unambiguous, the likelihood func-tion in exponential models such as CRFs is convex, thus searching the global optimum is guaranteed [McCallum 2003]. However, the optimum can not be found analytically. Parameter estimation for CRFs requires an iterative pro-cedure. It has been shown that quasi-Newton methods, such as L-BFGS [Liu and Nocedal 1989], are most efficient [Malouf 2002; Sha and Pereira 2003].
This method can avoid the explicit estimation of the Hessian matrix of the log-likelihood by building up an approximation of it using successive evaluations of the gradient.

L-BFGS is a limited memory quasi-Newton procedure for unconstrained op-timization that requires the value and gradient vector of the function to be optimized. Let s j denote the state path of training instance j in training set D , then the log-likelihood gradient component of  X  k is where C k ( s , o ) is the count of f k given s and o equal to
The first two terms show the difference between the empirical and the model prior.
 3. MINING IMPORTANT ASSOCIATIONS OF STATISTICS IN SEQUENCE DATA 3.1 The Need of Discovering Important Associations of Statistics
As stated earlier, sequence data, such as natural language or biological infor-mation, potentially contain difficult observations that might come from highly ambiguous and unbalanced data. These observations do not always obey fre-quent statistics and common sequential dependencies. Thus they are the main source of prediction errors. Furthermore, a prediction error made at a particu-lar position in a sequence can be propagated though the sequence and influence the other positions. Table I shows an example of unbalanced phenomenon in which the observation { and , CC } and the label { O } (of the first sequence) occur 2,472 times in the whole CoNLL2000 shared task corpus. However, the same observation was annotated with the label { I-ADVP } (in the second sequence) only 22 times in the same corpus.

It is common that one can rely on contextual information in the form of statis-tics around each data observation in order to make the prediction more discrim-inative. However, the singleton statistics are not discriminative and strong enough to recognize difficult data observations. Therefore, previous methods usually utilize higher-order or complex statistics, combining two or more sin-gleton statistics, using fixed templates [Sha and Pereira 2003]. This once again encounters the problem that long fixed templates would generate too many complex statistics (due to the combination explosion) and thus leading to the overfitting problem. Our solution is to use short fixed templates in order to keep the model as simple as possible. In addition, we discover important as-sociations/conjunctions of singleton statistics from sequential training data to deal with difficult data observations. Those associations are rare (i.e., occur only several times in the whole corpus) but confident enough to highlight diffi-cult observations. Recall the example in Table I about the imbalanced problem.
It is useful if we can discover and use the association {  X  t 1 :rb second sequence. This is because the previous above association is rare (occurs only 4 or 5 times) but highly confident (100%) to win the dominance of frequent statistics. The next two sections describe how to represent data and discover such important associations from sequential training data. 3.2 Data Representation for Discovering Important Associations of Statistics
D k th observation and label sequence. The top part of Table II shows an example of a training sequence for English phrase-chunking where each observation (in the observation sequence) consists of both a word and its part-of-speech tag, and a class label of each observation is B-NP, I-NP, etc. A the set of M statistic templates in which each template A type of contextual information about data observations. Applying all templates in A to each position (i.e., timestep) in every training sequence of the training set D , we obtain a transactional database T in which each transaction consists of a list of statistics and a particular class label.

Table II shows an example of a training data sequence. For instance, we set a sliding window of size 5 and move it along the sequence, and at each timestep, we choose the current word and its POS tag (w 0 the previous two positions (w  X  2 ,t  X  2 ,w  X  1 ,t  X  1 ) and next positions (w t ) as the set of statistic templates A . Scanning this set of statistic templates over all training sequences in D , we obtain the corresponding transactional database. Table III shows a part of a transactional database corresponding to the sequence in Table II in which each line is a transaction that includes a list of statistics and a particular label. For instance, the statistic  X  X  transaction (line) says that  X  X he next word is the  X  and the statistic  X  X  that  X  X he previous word is a noun X . The b-pp ( b egin of p repositional p )atthe end of the second line is the class label of the current observation. 3.3 Important Associations of Statistics: A Formal Definition
L be the set of all class labels in T . Our target is to examine every (predictive) association rule r [Agrawal and Srikant 1994] having the following form where the left-hand side (LHS) of r , X ={ x i 1  X  x i 2  X  ...  X  of p statistics in I , and the right-hand side (RHS) of r , l label. The support of r , denoted as supp( r ), is the number of transactions in T containing { l } X  X , and the confidence of r , denoted as conf( r ), is the conditional probability that a transaction in T has the label l given that it contains X , that associative classification rules in Li et al. [2001] and Liu et al. [1998].
Derived from the predictive association rules defined in (8) and the concepts of support and confidence factors, we present a descriptive definition of rare-but-confident associations .

Definition 1 . Let lsupp and usupp be two integers that are much smaller than the total number of transactions in T (i.e., lsupp  X  lconf be a real number that satisfies the condition 0  X  lconf
A predictive association rule r in (8) is called rare-but-confident if: All predictive association rules satisfying Definition 1 are rare-but-confident.
However, not all of them are important. This is based on the important observa-tion that if most statistics in the LHS of a rare-but-confident rule r individually tend to characterize label l , then the rule r is trival. In other words, if most statistics in the LHS of r largely support label l in a separated manner, there is no need to examine the co-occurrence of all statistics in the LHS. Based on this observation, we define the concept of important associations as follows.
Definition 2 . A rare-but-confident association rule r : X to be important if there exists at least another label l  X  support counts for the label l from the statistics in the LHS of r is larger than that for the label l , that is,
Why are predictive association rules satisfying Definition 2 important? In-tuitively, if such a rule, r , exists in the training data but is not discovered and emphasized, the model may predict the label l for any data transaction holding all statistics in LHS of r , when the correct label is l . This is because most sin-gleton statistics in the LHS of r tend to support l rather than l . This is why the appearance of predictive association rules satisfying Definition 2 is important.
There should be more sophisticated definitions and conditions of important as-sociations. However, we choose the previous definition because of the trade-off between the rigorousness and the simplicity of calculation.

Table IV shows some examples of important associations discovered from transactional database T (Table III), using association rule-mining techniques [Agrawal and Srikant 1994; Han et al. 2000] and two filtering criteria in Defi-nitions 1 and 2. The first column displays important associations in which the
LHSs are conjunctions of statistics and the RHSs are class labels ( l ). The sec-ond column shows the support and confidence factors and the last column is the label l that satisfy Definition 2.
 3.4 Important Associations of Statistics in the Context of Exception Rule Mining
Discovering exception rules is one of the important directions in association rule-mining. The target is to find out interesting exception rules/patterns that decision makers can use for advantageous actions. However, finding such rules is quite difficult because it is much harder to know which of the discovered rules are really interesting. Interestingness is a relative issue since it always depends on the user X  X  prior knowledge about the domain. Interestingness can be either user X  X  (biased) belief or estimated relative to the commonsense rules found in the data.

An interesting exception is something that contradicts the user X  X  common belief. Exceptions [Padmanabhan and Tuzhilin 1998; Silberchats and Tuzhilin 1996; Suzuki and Shimura 1996; Suzuki 1997] can play an important role in making critical decisions. Exceptions and commonsense rules point in oppo-site directions. Exceptions are usually minority, they are either not known or omitted from the normal discovery process. Intuitively, exceptions contradict the commonsense rules, and they have low support [Suzuki 1997]. Therefore, exception rules are weak in terms of support, but have high confidence similar to commonsense rules. A weak rule of low support may not be reliable. A user can specify minimum support for exceptions to ensure mining reliable excep-tion rules. In addition, exception rules are evaluated by several other criteria, such as generality, monotonicity, reliability, search range, interpretation of the evaluation measure, use of domain knowledge, and success in real applications.
Most of the previous studies discovered exception rules/patterns for sup-porting data analysis or decision making. Our work, on the other hand, focuses on searching important associations of statistics in linguistic data to improve prediction accuracy in natural language learning problems. Our important as-sociations of statistics, in a sense, follow some criteria of exception rules (e.g., low support, high confidence, contradicting commonsense rules, etc.). However, they are different in the discovery process, filtering criteria, and the reasons to discover them. 3.5 Discovering Important Associations of Statistics
To discover important associations of statistics, we first apply one of the asso-ciation mining techniques to discover normal associations (of statistics). Then, those associations are filtered using the conditions previously stated to obtain only the important ones. Mining normal associations includes two main steps: (1) discovering frequent patterns (i.e., frequent itemsets) and (2) generating associations from those frequent patterns. The first step is most challenging, while the second step, rule generation, is quite straightforward. Thus, almost all studies have focused on the first one to reduce the overall complexity of the mining process.

Frequent-pattern mining plays an essential role not only in mining asso-ciations, but also in discovering correlations, causality, sequential patterns, episodes, multidimensional patterns, partial periodicity, emerging patterns, and many other important data mining tasks [Han et al. 2004]. In principle, we can use any previous frequent-patterns mining technique to find frequent pat-terns for generating important associations of statistics in linguistic corpora.
However, due to the characteristics of this kind of rule, such as rare and highly confident, not all of them are efficient for this task. Here, we briefly introduce one of the most efficient techniques for discovering frequent patterns, which is particularly appropriate for mining important associations.

Most previous studies in mining frequent patterns adopt an Apriori -like ap-proach, which is based on the antimonotone Apriori heuristic [Agrawal and
Srikant 1994]: if any length k pattern is not frequent in the database, its length ( k + 1) superpattern can never be frequent. The essential idea is to iteratively generate the set of candidate patterns of length ( k + 1) from the set of frequent patterns of length k (for k  X  1), and check their corresponding occurrence fre-quencies in the database.

The Apriori-like heuristic achieves good performance gained by reducing the size of candidate sets. However, in situations with a large number of frequent patterns, long patterns, or quite low minimum support thresholds, an Apriori-like algorithm may suffer from the following nontrivial costs. ical because the number of combinations of statistics in linguistic data is extremely large due to the fact that natural language data is diverse and sparse. For instance, if we have 10 statistic templates and each generates 2,000 statistics on average, then the number of combinations is approxi-mately 10 33 . Frequent-pattern mining techniques can, of course, prune un-necessary candidates using the Apriori heuristic, however this explosion of candidates strongly degrades the performance of Apriori-like algorithms.  X  Important associations are rare, that is, their supports are very small in comparison with the database size (i.e., the total number of transactions
This is probably the biggest challenge for mining important associations. In fact, Apriori-like algorithms are infeasible for mining important associations from large linguistic corpora.

The previous challenges seem to prevent us from discovering all possible im-portant associations in linguistic corpora. Fortunately, FP-growth [Han et al. 2000, 2004], a frequent-pattern mining algorithm without candidate genera-tion, can discover such associations in an acceptable computational time. This is because FP-growth employs a FP-tree (an extended prefix tree structure) to store crucial, quantitative information about frequent patterns in such a way that more frequently occurring items will have better chances of shar-ing nodes than less frequently occurring ones. All mining operations are then performed on the FP-tree in a partitioning, recursive fashion without candi-date generation. See Han et al. [2000, 2004] for a complete description of this algorithm.

Table V shows the steps necessary for discovering important associations of statistics. The first thing we have to do is to convert the original sequence training data set into its transactional form as described earlier. Next, the FP-growth algorithm will be used to discover all frequent patterns/itemsets that satisfy the minimum support threshold lsupp. Then, normal associations are generated from those frequent patterns/itemsets. This step is quite straightfor-ward and much cheaper than the second one. See Agrawal and Srikant [1994] for a complete description of the rule generation algorithm. Finally, the result-ing normal associations will be filtered using the condition in Definition 2 to obtain important ones.

Because the first, third, and the last steps are much cheaper in comparison with the second step, the computational time of the discovery process depends on that of the FP-growth algorithm. As stated earlier, because the FP-growth can discover frequent patterns without candidate generation, it can avoid the problem of combination explosion. As proved in Han et al. [2000, 2004], this algorithm is much more efficient than Apriori-like algorithms, especially when the minimum threshold is much smaller than the database size. Our empirical study also shows that FP-growth is appropriate for mining patterns in linguistic corpora even though natural language is much more diverse and sparse in comparison to traditional numerical and categorical data. 4. LEARNING CRFS WITH IMPORTANT ASSOCIATIONS OF STATISTICS
This section presents three ways to incorporate the important associations dis-covered from the training data into CRFs: (1) associations as normal features, (2) associations as features with emphasized feature functions, and (3) associ-ations as constraints for the inference process. 4.1 Important Associations as Normal CRF Features
All important associations of statistics are in the form of X
X ={ x i 1  X  x i 2  X  ...  X  x ip } X  I is a conjunction of p statistics, and l particular label. These associations can be integrated into CRFs in terms of normal per-state features as follows.
These per-state features are similar to those in (2) except that they capture a co-occurrence of p singleton statistics rather than a single one. The features are treated as normal features of CRFs and are trained together. 4.2 Important Associations as Weighted CRF Features
It is noticeable that important features are infrequently observed in the train-ing data, and thus their learned weights should be small. This means that their contributions, in several cases, may not be sufficient to win the dominance of common statistics, that is, frequently observed singleton features. To overcome this drawback, we emphasize important features by assigning larger feature function values compared to normal features. where  X  ( s t , l ) are considered as logic expressions, and v is larger than 1 (the feature value of normal features). v should be large if the occurrence frequency of the feature (also the support of the important association) is small. Thus, for each feature generated from a important association r , v is equal to (usup supp( r ) + 2). This ensures that v is always bigger than 1 and inversely propor-tional to the support of r , that is, the occurrence frequency of the feature. 4.3 Important Associations as Constraints for Inference in CRFs
Constrained CRFs are extensions of CRFs in which useful constraints are in-corporated into the inference process (i.e., the Viterbi algorithm) to correct po-tential errors existing in the most likely output state sequence for each input observation sequence. Kristjansson et al. [2004] proposed this extension with the application to interactive form-filling in which users can examine the fill-ing process and make necessary corrections in terms of their own constraints. A recorrection applied at a particular position will propagate though the Viterbi sequence to make automatic updates for labels at other positions, that is, the correction propagation capability.

This section presents the integration of important associations with 100% confidence into the Viterbi algorithm in terms of data-driven constraints to make corrections directly to the inference process of CRFs. Unlike those used in Kristjansson et al. [2004], our constraints are 100% confidence associations and are automatically discovered from the training data.

Normally, CRFs use a variant of the traditional Viterbi algorithm to find the most likely state sequence given an input observation sequence. To avoid an exponential-time search over all possible settings of state sequence, this algorithm employs a dynamic programming technique with a forward variable  X  1 ( s i ) in Equation (5).

Let R ={ r 1 , r 2 , ... , r q } be a set of q important associations with 100%-confidence, and each r u (1  X  u  X  q ) has the form { x u 1
Each r u  X  R is considered to be a constraint for the inference process. At each time position in the testing data sequence, we check whether or not the set of active statistics at the current position holds the LHS of any rule r yes, the most likely state path must go though the current state with the label l (i.e., the RHS or rule r u ), and the possibility of passing though other labels equals zero. The constrained forward variable is redefined as follows.
The constraint applied at the time position t will propagate though the whole sequence and make some recorrections for labels at other positions (mostly around the position t ).

One problem is that when the number of constraints (i.e., the number of 100%-confidence important associations) is large, the time for examining the LHS of every rule at each position in the testing sequence also becomes large.
To overcome this obstacle, we propose the following algorithm for fast-checking constraints at a particular time position t in the testing sequence.
Let R ={ r 1 , r 2 , ... , r q } be the set of 100%-confidence rules, also known as con-the current position t . The target of the following algorithm is to check whether or not X holds the LHS of any constraint r u  X  R . If yes, choose the constraint with the longest LHS.
If this algorithm finds a constraint r j , then apply this constraint to the cur-rent position t with Equation (9), otherwise, apply the normal Viterbi recursion as in Equation (5).

For an efficient implementation, we maintain a map between statistics and the rules containing them. Each map component is a pair of statistics and a list of rule indexes that contain that statistic in their left-hand side. We can use a hash table or any indexing data structures for maintaining this map in the main memory. The initialization of this map is performed only once when loading the rules into the memory. The complexity of the previous algorithm is determined as follows. Let m be the average number of active statistics in X ; let l be the average length of the list of rule indexes in each map pair; let t be the average time for looking up a statistic in the map. The time complexity of the first step in the algorithm is O ( mt ). This is because we have to look up m statistics of X in the map. The second step scans over the all the lists of rule indexes returned in the first step to count the occurrence frequencies of those rules. Thus the complexity of this step is O ( ml ). The final step finds the pair &lt; r to the number of statistics in LHS of r j . The complexity of this step in the worst case is O ( ml ). Therefore, the overall complexity is O ( mt
As we will see later in the experiments, the average number of active statis-tics ( m ) is around 20 or 30. The number of rules is around ten thousand and thus the looking up time in the map is very fast. We observed that if the number of rules is not too large, the constrained Viterbi inference using this algorithm can be realtime. 5. EMPIRICAL EVALUATION 5.1 Experimental Settings All the experiments were performed with our C/C++ implementation of CRFs -FlexCRFs 2  X  X n a 3Gb RAM, Intel Core 2 desktop with Fedora Core 5. All
CRF models were trained using the limited memory quasi-Newton method for unconstrained optimization, L-BFGS [Liu and Nocedal 1989]. The variance the Gaussian prior for smoothing is 10. Unlike those used in Sha and Pereira [2003], our CRF models are simpler and easier to implement by obeying the first-order Markov property, that is, the label of the current state depends only on the label of the previous state. Training and testing data for phrase-chunking and named entity recognition can be found at the shared tasks of CoNLL2000 and CoNLL2003 4 , respectively. 5.2 Phrase Segmentation
Phrase-chunking, an intermediate step toward full parsing of natural language, identifies phrase types (e.g., noun phrase -NP, verb phrase -VP, PP -prepo-sitional phrase, etc.) in text sentences. Here is an example of a sentence with phrase marking: [NP He] [VP reckons] [NP the current account deficit] [VP will narrow] [PP to] [NP only # 1.8 billion] [PP in] [NP September].

Training and Testing Data. The training and testing data for this task is available at the shared task for CoNLL-2000. The data consist of the same partitions of the Wall Street Journal corpus (WSJ): sections 15-18 as training data (8,936 sentences, 211,727 tokens) and section 20 as testing data (2,012 sentences, 47,377 tokens). Each line in the annotated data is for a token and consists of three columns: the token (a word or a punctuation mark), the part-of-speech tag of the token, and the phrase type label (label for short) of the token. The label of each token indicates whether the token is outside a phrase For example, the label sequence of the previous sentence is B-NP B-VP B-NP
I-NP I-NP I-NP B-VP I-VP B-PP B-NP I-NP I-NP I-NP B-PP B-NP O. This dataset contains 11 phrase types as shown in the first column of Table VII. Two consecutive data sequences (sentences) are separated by a blank line. On the phrase-chunking dataset, we use feature templates as shown in
Table VI. All transition features obey the first-order Markov dependency that the label ( l ) of the current state depends on the label ( l ) of the previous state (e.g.,  X  l = I-NP X  and  X  l = B-NP X ). Each per-state feature expresses how much influence a statistic (x( o , i ) observed surrounding the current position i has on the label ( l ) of the current state. A statistic captures a particular property of the observation sequence. For instance, the per-state feature  X  l  X  X ord  X  1 is the  X  indicates that the label of the current state should be I-NP (i.e., continue a noun phrase) if the previous word is the . Table VI describes both transition and per-state feature templates. Statistics for per-state features are identities of words, POS tags surrounding the current position such as words and POS tags at  X  2,  X  1, 1, 2.

We also employ 2-order conjunctions of the current word with the previous (w  X  1  X  w 0 ) or the next word (w 0  X  w 1 ), and 2-order and 3-order conjunctions of two or three consecutive POS tags within the current window to make use of the mutual dependencies among singleton properties. With the feature templates shown in Table VI and the feature rare threshold of 1 (i.e., only features with occurrence frequency larger than 1 are included into the CRF model), 321,526 statistics and 152,856 CRF features were generated from 8,936 training sequences.

Mining Important Associations of Statistics. Let I be the itemset of 84,951 data items (only singleton statistics are used for mining), that is, the union set of 84,951 statistics and 22 phrase labels; T be the set of 211,727 data trans-actions corresponding to 211,727 tokens of the training data. Let the lower support (lsupp) threshold be 2 (usupp is 100%); let the lower confidence (lconf) threshold be 100%. We also confine the length of the LHS of all important asso-ciations to 2 or 3. There are several reasons why we confine the LHS length to 2 or 3. First, although simple rules (i.e., with shorter LHS length) are usually useful for generalization, we both examine both simple and complex rules pro-vided that they are rare and confident because our main target is to deal with hard data instances which are not frequently observed in the training data. We also observed that important associations with short LHS length are useful for reducing overfitting. Second, rules with LHS length more than 3 are usually too specific and most of them are covered by rules with LHS length of 2 and 3. Also, mining and generating all long rules is time-consuming.

The mining process for important associations took 2 hours, using the FP-growth algorithm and the filter criteria presented in Definitions 1 and 2. The output was a set of 494,881 important associations with an LHS length of 2 or 3, minimum support of 2, and confidence of 100%. This set of associations were integrated into the CRF model in terms of normal features and normal features with weighted feature values. We select 13,700 rules with support larger or equal to 20 to serve as constraints for the inference process to examine whether or not inference constraints as rare but important associations can improve the performance.

Results. Table VII shows the results for English phrase-chunking. The first column is the phrase type. The second column is the number of phrases. The next four columns display the F 1 scores of four cases: (A) without important associations, (B) important associations as normal CRF features, (C) impor-tant associations as weighted CRF features, and (D) important associations as constraints for Viterbi inference. The last two lines are the macro-average and micro-average of F 1 scores calculated in two ways: precision-recall-based and phrase-based. The former is based on the precision and recall values of separated phrase types, while the latter is based on the average numbers of human-annotated, model, and correct phrases. Intuitively, the macro-average of F 1 reflects the balance and the trade-off among per-label F average of F 1 reflects the total performance.

In the first case, we obtained the highest micro-average F the second case, we achieved the highest performance of 93.27% F higher than the original performance. In the third case, we obtained the micro-verage F 1 of 93.39%, i.e., 0.27% higher than the original result (i.e., 4% error reduction). And in the fourth case, we obtained the highest micro-average F score of 92.94 (i.e., 0.18% lower than the original result) when using important associations as constraints for inference.

Table VIII shows an accuracy comparison between ours and that of the other state-of-the-art chunking systems on the CoNLL-2000 dataset. Daum  X  e III and
Marcu [2005] proposed a LaSO (Learning as Search Optimization) framework that can accelerate both the training and decoding phases of structured classi-fication by relying on an approximate search strategy. They used a rich set of features as well as several external lists of names, locations, abbreviations, etc. and achieved the highest F 1 of 94.4 on chunking. Because their feature set is quite different from ours, it is not easy to compare the learning power between
LaSO and CRFs. Ando and Zhang [2005] proposed a nice semi-supervised learning framework that can extract additional information from thousands of auxiliary learning problems relevant to the main task. They used an extra 15 million words from the TREC corpus as unlabeled data to improve this task and obtained the highest F 1 scores of 94.39. Kudo and Matsumoto [2001] used a SVM combination for this task. They obtained F 1 scores of 93.85. Carreras and Marquez [2003] used two-layer Perceptron and achieved F et al. [2002] used generalized winnow and obtained F 1 score of 93.57. They exploited enhanced linguistic features from a full parser and got the highest F of 94.17.

Our three CRF models following three different experimental setups (a) first-order Markov dependency, (b) first-order Markov dependency plus important associations of statistics, and (c) second-order Markov dependency without im-portant associations of statistics) achieved F 1 scores of 93.12, 93.39, and 93.92, respectively. We observed that the F 1 of the first-order Markov CRF model with important associations, in this case, is smaller than that of the second-order Markov CRF model without important associations. However, the com-putational time is much different. The second-order CRF model needed more than 200 hours (estimated, i.e., more than 8 days) to train while the first-order
Markov model took only 4 hours for training and an additional 2 hours for dis-covering important associations of statistics. Training second-order Markov CRFs is very time-consuming due to the fact that their time complexity is
O ( | L | 3 ) rather than O ( | L | 2 ) like first-order Markov models, where L is the set of all class labels. In this case, | L | is 22, and the computational time is much different between the two cases. We had to use a parallel implementation of
CRFs on massively parallel computers to evaluate the second-order Markov configuration. 5.3 Named Entity Recognition
Named entity recognition (NER), a subtask of information extraction, identifies names of persons (PER), organizations (ORG), locations (LOC), times (TIME), and quantities (NUMBER, CURRENCY, PERCENTAGE) in natural language.
 Here is an example of an English sentence with named entities marked: [LOC
Germany]  X  X  representative to the [ORG European Union]  X  X  veterinary com-mittee [PER Werner Zwingmann] said on Wednesday...

Training and Testing Data. The training and testing data for English named entity recognition are provided at the shared task for CoNLL-2003.
The dataset is a collection of news wire articles from the Reuters Corpus. The training set consists of 14,041 sentences (20,3621 tokens), and the testing data contains two parts: the development test set (testa: 3,250 sentences, 51,362 tokens) and the final test set (testb: 3,453 sentences, 46,435 tokens). The data files contain four columns separated by a blank space. Each token (a word or a punctuation mark) has been put on a separate line, and there is an empty line after each sentence (sequence). The first item on each line is a token, the second is the part-of-speech tag of the token, the third is a phrase type tag (like the label in phrase chunking) of the token, and the fourth is the named entity label (label for short). The label of each token indicates whether the token is outside a named entity (O), or inside a named entity (I-&lt;NamedEntityType&gt;). If two named entities of the same type immediately follow each other, the first token of the second named entity will have tag B-&lt;NamedEntityType&gt;. For example, the named entity label sequence of the above sentence is I-LOC O O O O I-ORG I-OR GOOO I-PER I-PE ROOO.

Feature Generation. On the named entity recognition dataset, we used the feature templates shown in Table IX. All transition features also conform to the first Markov property. Each statistic for a per-state feature is one of the following types: (1) the identities of words (w  X  2 ,w  X  1 tags of words (t  X  2 ,t  X  1 ,t 0 ,t 1 ,t 2 ), (3) the phrase tags of words (c c ,c 2 ), and (4) several simple regular expressions or formats of words such as  X  X he first character of a word is capitalized X  (IsInitCap),  X  X ll chars of a word are capitalized X  (IsAllCap), etc. We also use the lengh-2 conjunctions of POS tags and chunk tags. Like the phrase-chunking task, all statistics are captured within a window with a size of 5. Our feature templates are much simpler than those used in the previous work presented at the CoNLL2003 shared task and in McCallum [2003] in two ways, that is, only five simple format properties were captured (compared to 16 regular expressions in McCallum [2003]), and no external dictionaries were used such as the lists of people names, organization names, countries, cities, etc. We only used the list of names generated from training data for look-up features.

Mining Important Associations of Statistics. Let I be the itemset of 124,919 data items, that is, the union set of 124,910 statistics and 9 named entity labels;
T be the set of 203,621 data transactions corresponding to 203,621 tokens of the training data. Let the lower support (lsupp) threshold be (usupp is 100%); let the lower confidence (lconf) threshold be 100%. We also examine rules with the LHS length of 2 or 3.
 The mining process for important associations took about 1.5 hours using the
FP-growth algorithm and the filter criteria described in Definitions 1 and 2. The output was a set of 391,376 rare-but-important associations with an LHS length of 2 or 3, support larger or equal to 2, and confidence of 100%. Table X shows several examples of important associations discovered from the CoNLL2003 training dataset for NER. This set of associations was integrated into the CRF model in terms of normal features and normal features with weighted feature values. We also selected 6,820 rules with support larger or equal to 20 to serve as constraints for the inference process to examine whether or not constraints as rare but important associations can improve the performance.

Results. Table XI shows the results of named entity recognition. The first column is named entity type. The second column is the number of named en-tities. The next four columns display the F 1 scores of four cases: (A) without important associations, (B) important associations as normal CRF features, (C) important associations as weighted CRF features, and (D) important asso-ciations as constraints for Viterbi inference. The last two lines are the macro-average and micro-average of F 1 scores.

In the first case, we obtained the highest micro-average F second case, we achieved the highest micro-average F 1 of 86.01% with 0.44% higher than the original performance. In the third case, we obtained the micro-average F 1 of 86.44%, that is, 0.87% (i.e., 6% error reduction) higher than the original result. And in the fourth case, we obtained the highest micro-average F score of 85.28% (i.e., 0.29% less than the original result) when using important associations as constraints for inference. Figure 1 graphically demonstrates the extent to which important associations can improve the prediction performance.
We also evaluate our methods on the final test set (testb) but the improvement is lower (F 1 score from 80.86 to 81.12).

Table XII shows the difference in performance improvement between our method and McCallum X  X  feature induction [McCallum 2003]. These results were obtained from the development test dataset (testa) but using different feature templates. Our feature templates are much simpler than those of McCallum, both in the number of regular expressions and external dictionaries. They used external information such as names of countries, publicly-traded companies, surnames, stop-words, universities, organizations, NGOs, and nationalities.
Also, our CRFs provide much higher baseline performance (85.57 compared to 73.30). That is why we cannot give a direct comparison between the two methods.

On the test set (testb), Ando and Zhang [2005] used their semi-supervised learning framework to improve this task using an additional 27 million unla-beled words from Reuters and ECI Multilingal Text Corpus. They achieved the highest F 1 of 89.31. Florian et al. [2003] combined classifiers, used gazetteers, and achieved F 1 of 88.76  X  0.7. Chieu and Ng [2003] used maximum entropy classifiers with carefully selected features plus gazetteers, and got F 88.31  X  0.7.
 5.4 Discussion
We can see that the integration of important associations into CRFs can im-prove the performance of both the phrase-chunking and named entity recog-nition tasks. The F 1 -score of phrase-chunking increases from 93.12 to 93.39.
Similarly, the F 1 -score of NER increases from 85.57 to 86.44%. These are not a big improvement in performance. 5 However, they show that our method can au-tomatically discover important associations from data to improve the accuracy for given a fixed set of feature templates.

Filtering association rules is probably the most important step in our method that strongly influences the prediction performance. In this work, we applied quite simple filtering criteria that might not completely reflect the nature/ properties of rare but important associations discovered from training data.
We observed that there are still a lot of redundant or meaningless associations in the selected rule sets. We believe that we can improve the prediction accu-racy more if we can filter more fine-grained and significant rare but important associations.

The experiments also show that rare but important associations do not im-prove the accuracy if they are used as constraints for inference. This is because a lot of important associations discovered from the training data no longer have 100%-confidence in the test dataset. Using them as constraints for inference is too risky even we select only rules with support greater than or equal to 20.
The experiments provided lower results in comparison with the baseline per-formance in both cases, phrase-chunking and NER 6 . Rules should be used as constraints for inference if we completely make sure that they are very reliable in any testing or future unseen data.

Using important associations as normal CRF features can significantly en-hance the total performance. However, treating important associations as nor-mal features might not fully utilizes their advantages. Treating important as-sociations as weighted features should be the favorable choice because they are neither too loosely nor too tightly integrated with the models. The experimental results show that this way achieved highest improvement in accuracy.
We also did the experiments with rare-but-confident rules. We observed two important points that (1) the numbers of rare-but-confident rules (both noun phrase-chunking and named entity recognition) were much larger than those of important ones; and (2) the experimental results were sometimes worse be-cause of the overfitting problem. This means that there is a large proportion of rare-but-confident rules that are unnecessary for capturing difficult data instances.

One of the important points in the proposed technique is how to determine the values for the parameters, such as lower bound (lsupp) and upper bound (usupp) of support factor of important associations of statistics, as well as the emphasized values for weighted features of CRFs. In both experimental tasks, we chose the lsupp of 2 is because we want to capture as many associations of statistics as possible. This helps us to capture more patterns in testing and future unseen data to reduce overfitting problem. We also tried larger lsupp values, such as 3 and 4, but they provided lower accuracy. We did not confine the upper support bound (usupp) because when the confidence bound is 100%, the number of rules with large support is very small. And after filtering us-ing Definition 2, selected rules tend to have small support values. In addition, choosing the length of the LHS of important associations is quite important for two main reasons, computational time and the overfitting problem. Generat-ing long associations is quite time-consuming since the number of associations exponentially increases according to their LHS length. Also, many of the long (and very confident) associations are covered by shorter ones, thus including them in the models is unnecessary. Determining values for weighted features of
CRFs in our method is quite heuristic but reasonable because we tend to high-light rare associations by pretending to increase their occurrence frequency in the training data.

Computational time in our method is also one of the important aspects. Be-cause important associations of statistics are discovered prior to training CRFs, the time complexity of discovering important associations and time complexity of training CRFs are independent. The former is proportional to the complexity of the FP-growth algorithm for mining frequent patterns from training data.
The authors of FP-growth only reported the frequent-pattern mining time and the comparison with the other mining algorithms (e.g., Apriori) rather than pointing out explicitly the time complexity of the algorithm. The comparison showed that the discovery time of FP-growth is very efficient in comparison with the Apriori and TreeProjection algorithm, especially when the support threshold is small. In our algorithm, we needed only 2 and 1.5 hours for discov-ering and filtering important associations of statistics from phrase-chunking and named entity recognition datasets, though these linguistic datasets are large enough and the support threshold is very small in comparison with the databases X  sizes. Time complexity of training CRFs is also large, but it is the common problem that our method and other methods incur. The time complexity of training first-order Markov CRFs is O ( ma | L | 2 NT e of training iterations, a is the average number of active context predicates, L is the set of class labels, N is the total of sequences in the training dataset, and T is the average length of each training sequence. Training a CRF model is very costly because we have to perform a very costly forward-backward computation on a series of matrices in order to evaluate the log-likelihood function of the
CRF model and its gradient vector at every training iteration. The complexity of the algorithm using important associations of statistics as constraints for the inference process of CRFs was reported in Section 4.3.

The experimental results reported in this article do not represent the best possible performances on phrase-chunking and named entity recognition be-cause (1) our feature templates are relatively simple to keep the set of features compact; this is convenient for mining associations, training again and again while conducting the experiments; (2) unlike the CRF model in Sha and Pereira [2003], all our CRF models obey the first-order Markov property to reduce the complexity. 6. RELATED WORK
Discriminative (sequential) learning models have been applied successfully in different natural language processing and information extraction tasks, such as POS tagging [Ratnaparkhi 1996], text-chunking [Peng et al. 2004; Sha and
Pereira 2003], information extraction [Kristjansson et al. 2004; Pinto et al. 2003], computer vision and image analysis [Kumar and Hebert 2003; He et al. 2004; Torralba et al. 2004], and biological modeling [Yeo and Bruge 2003]. Nor-mally, one can extract features from sequential data within a relatively large window size (i.e., the history size of contextual information) and make high-order combinations of atomic observational tests (e.g., the conjunctions of two or three consecutive words in a sentence) in the hope that they will capture as many useful predictive clues as possible. Unfortunately, such useful conjunc-tions are sparsely distributed in the feature space, and thus one unintentionally includes a large number of redundant conjunctions into the model. Inspired by this obstacle, our work aims at picking up useful conjunctions from a large array of conjunction candidates while keeping the set of features simple. The data-driven search with respect to support and confidence factors based on association rule mining techniques can discover desired conjunctions with an acceptable computational time.

There have been several previous studies about the discovery of interesting and/or exceptional patterns in databases [Liu et al. 1999; Padmanabhan and
Tuzhilin 1998; Silberchats and Tuzhilin 1996; Suzuki and Shimura 1996]. The concept of interesting patterns/rules varies in different papers but, in general, implies the associations of weak statistics that have small support but large confidence. However, most of the work focused on finding exception rules for data analysis purposes rather than using them for improving classification accuracy. Also, these studies worked with numerical data instead of linguistic data like ours. Discovering important associations of statistics in linguistic data for improving discriminative sequential learning was actually our original proposal.

McCallum [2003] proposed an automated feature induction for CRFs that can reduce the number of used features dramatically. This likelihood-driven approach repeatedly adds features with high-likelihood gains into the model.
The set of induced features contains both atomic observational tests and con-junctions of them. The main difference between this work and ours is that
McCallum focuses on features with high-likelihood gains in order to reduce the number of used features as much as possible, while the main target of our method is to discover important associations or co-occurrences of weak statistics from the training data to highlight difficult examples. Further, our method can examine any combination or conjunction of statistics because of the exhaustive working method of association rule mining techniques.

An error-driven method that combines boosting technique into the train-ing process of CRFs [Altun et al. 2003] minimizes an upper bound on the ranking loss that was adapted to label sequences. This method also focuses on hard observation sequences, but without integrating new useful conjunc-tions of basic features. Another boosting-like training for CRFs is based on the use of a gradient tree [Dietterich 2004] to learn many conjunctions of features.
One problem is that this method requires adding many trees for the training process. 7. CONCLUSIONS AND FUTURE WORK
In this article, we proposed a data-driven approach that can discover and high-light important associations or co-occurrences of singleton statistics from the sequential training data to deal with hard examples. Discovered associations are integrated into the exponentially-trained sequential learning models as normal features, features with weighted values, and constraints for the infer-ence process. The experimental results show that important associations can improve the model performance by fighting against the dominance of singleton but common statistics in the training data.

Though important associations can enhance the prediction accuracy for hard examples, our approach is currently based on the occurrence frequency of statis-tics and the existence of important associations in the training data. We believe that there is an indirect theoretical relation between the occurrence frequen-cies of statistics and the learned weights of the model X  X  features. Our future work will focus on this potential relation to estimate the extent to which useful patterns (e.g., important associations) discovered from the training data can improve the performance of discriminative (sequential) learning models. We would like to thank Dr. Bart Goethals, Department of Math and Computer
Science, Antwerpen University, for sharing his lightweight and efficient imple-mentation of the FP-growth algorithm. We would like to say thank you to Prof. Jorge Nocedal, Department of Electrical and Computer Engineering, School of Engineering and Applied Science, Northwestern University, the author of FOR-
TRAN implementation of the L-BFGS optimization procedure. We also would like to thank Prof. Sunita Sarawagi, KR School of Information Technology, IIT Bombay, the author of the Java CRFs package, which is the precursor of our C/C++ CRFs toolkit.

