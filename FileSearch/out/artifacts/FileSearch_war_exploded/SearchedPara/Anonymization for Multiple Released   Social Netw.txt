 Recently, people share their information and participate in various activities on the Internet via social platforms such as Google+, Facebook, and Twitter. The data in social networks are worth being analyzed in social science research since they can reflect the real social activities. Since the data in social networks include personal information and interactions, which can be private and sensitive, there is a need to anonymize the data to protect users X  privacy before their release for some analysis. 
A social network can be represented by a graph consisting of nodes and edges between the nodes. The nodes are used to represent users while the edges represent the interactions between the users. A trivial method for protecting users X  privacy in the released graph is to replace the identities of users (e.g. ID or user name) by random values. This is not enough since the privacy may still be revealed by malicious attackers [2]. Achieving complete privacy protection and at the same time offering high utility of the social network data are challenging [4][8][12]. The existing approaches on anonymizing a social networ k graph are categorizing into two types including nodes with attributes [1][3] and without attributes [6][10][11]. 
Consider a scenario as follows. A service provider, e.g. Facebook, has social network data since 2004 and wants to anonymize and release the corresponding social network graph from 2004 to 2006 to a data mining company to find interesting patterns from the evolution of the social network. Since the previous studies focus on anonymizing a single social network graph, we may consider applying the existing approaches to anonymize the social network graphs at different timestamps by considering the graph at each timestamp as a specific social network graph. However, to be detailed in Subsection 2.2, this may make the privacy of the social network data leaked. 
In this paper, we consider a privacy preserving problem on a time-series of social network graphs representing an evolution of a specific social network. A time-series of social network graphs are anonymized to a sequence of sanitized graphs to be released (called multiple releases in this paper). Based on [1], which groups nodes into classes for achieving the privacy purposes, we design a constraint in the grouping procedure, taking into account the effect of time to avoid revealing privacy with multiple releases. Rooted in this constraint, we propose an overall method to anonymize all these time-series social network graphs at distinct timestamps at one time. We use two real datasets to test our method and the experiment results demonstrate that our method is very effective in terms of data utility for query answering. 
The remainder of this paper is organized as follows. The preliminaries of this paper are introduced in Section 2. We describe the details on anonymizing a single social network graph proposed in [1] and point out that if we apply it to deal with the time-series social network graphs, the privacy guarantees may fail. Our approach is detailed in Section 3 and after that, the experiment results are presented in Section 4. Finally, Section 5 concludes this work We consider a privacy preserving problem on time-series social network graphs in represent the evolution of a specific social network. The social network graph at time labels, each of which is used to descript a specific user. We assume that g is incremental , i.e. the vertices and edges are only added to but not deleted from the snapshots of a time-serial social network graph at t = 0 and t = 1. The corresponding e.g. age, gender, and location, to descript the user. G each of which should follow the guarantees below: 1. For any edge e in an anonymized graph, an attacker who has no background knowledge about the original graph can correctly guess that a specific user u participates in e with a probability at most equal to 1/ k . 2. For any two users u x and u y , an attacker who has no background knowledge about the original graph can correctly guess that these users have interaction with a probability at most equal to 1/ k . 2.1 Single Graph Anonymization bipartite graph to represent the interaction among users in [1] as shown in Figure 2 (a) is easily transformed into a general social network graph as shown in Figure 2 (b). 
In order to achieve the above privacy objectives, a label list denoted l ( v ) is used in size equal to k . Nodes in the same class have the same label list. Accordingly, an equal to 2. We then get five classes including A = {1, 2}, B = {3, 4}, C = {5, 6}, D = corresponding class. Figure 3 shows the anonymized graph. 
Merely partitioning the nodes into classes cannot achieve the privacy objectives. If the links among nodes in a same class are dense, an attacker can imply with a high Figure 2( b ) are grouped in the same class at k = 2. Then, an attacker can be sure that nodes. Moreover, the links between two classes should not be dense. For example, the interaction between two classes is dense as shown in Figure 4, and an attacker can exactly know user 4 and user 7 have the same friends including user 8 and user 9. Bhagat et al. propose the class safety condition in [1], defined as follows, to avoid the above attacks. Definition 1. Class Safety Condition [1]: Division of nodes V into classes satisfies the Class Safety Condition if any node v  X  V and any class C  X  V follow 1)  X  (v, w) and (v, z)  X  E: if w  X  C  X  z  X  C  X  w = z and 2)  X  (v, w)  X  E: if v  X  C  X  w  X  C  X  v = w . A simple greedy approach for partitioning nodes into classes is proposed in [1]. To improve the utility of the anonymized graph, they consider sorting the attributes of nodes according to their importance to queries and then follow the sorted attribute are divided into the same or nearby classe s under the condition of observing the class safety condition. Following [1], we assume that the attribute priority list is given. 2.2 Privacy Revealed across Multiple Releases To solve the problem addressed in this paper, a na X ve solution based on [1] is descripted as follows. Na X ve Solution. G 0 , G 1 , ..., G T are individually anonymized using the approach proposed in [1]. Since the classes may be different at distinct timestamp, the label list of v may change at distinct timestamp. For example, given two snapshots of a time-serial social network graph, G 0 and G 1 , at attribute priority list &lt;location, gender, age&gt; as input of the approach proposed in [1], G ' and G 1 ' are generated as shown in Figure 5(b). Let us focus on the grey node v in G respectively. Since we assume the evolution of a specific social network graph is incremental and only the grey node links both to {1, 6} and {5, 10} in G 0 ' and G 1 ' , the true identity of v must be 7. Obviously, it violates the privacy purposes. generate G T ' and in the next step, we generate G t  X  1 ' by removing the edges and nodes revealed when the nodes are removed since the size of the label list containing the removed entities may be less than k . For example, given two snapshots of a time-serial social network graph, G 0 and G 1 , at anonymize G 1 to generate G 1 ' using the approach in [1] as shown in Figure 6( b ). Next, G ' is generated by deleting the edges and nodes arriving at t = 1 from G 1 '; furthermore, the corresponding labels of the removed nodes should be deleted from the label lists as shown in Figure 6( b ). Obviously, the identity of node e.g. user 1, is revealed. To solve the problem of revealing the identities of nodes, we may put the nodes arriving at the same timestamp into the same classes. Therefore, the nodes arriving at the same time and their corres ponding classes will be deleted together. The main idea of our solution extended from Observation 1 is detailed in the following section. Our solution to anonymizing a time-series of social network graphs is detailed in this section. The definition of the Time-Series Class Safety Condition (TSCSC) used in our solution is described in Subsection 3.1 and then, we present the main algorithm in Subsection 3.2 and discuss the security of our solution in Subsection 3.3. 3.1 Time-Series Class Safety Condition We modify the class safety condition in Definition 1 for the time-series social network graphs to obtain the Time-Series Class Safety Condition (TSCSC). Dividing nodes into classes that satisfy TSCSC can achieve the privacy objectives mentioned. How TSCSC to guarantee the privacy objectives will be discussed later. Definition 2. Time-Series Class Safety Condition: Division of nodes V t into classes satisfies the Time-Series Class Safety Condition if any node v  X  V t and any class C  X  V  X  w  X  C  X  v = w, and 3)  X  C a and C b  X  V t , n e is the number of edges between C a and C The second condition similar to Definition1 constraints that at each timestamp, no edges exist in a class. The third condition constraints the number of interaction between any pairs of classes at each timestamp. 3.2 The Anonymizing Method for Time-Series Social Network Graphs Our greedy algorithm name DMRA ( D ecreasing M ultiple R eleases A nonymization ) for anonymizing the time-series social network graphs is descripted in this subsection. constant k , and an attribute priority list denoted list ap : vertices, V list , in which the vertices with similar attributes are nearby. Then, we start to anonymize G T . class which contains the nodes with a number smaller than k and moreover, the insertion must satisfy the Time-Series Class Safety Condition. If we cannot find a class with a size smaller than k or observing TSCSC after considering v , a new class is created. Step 3. After Step 2, some classes may not have k nodes. To reduce the number of classes with a size smaller than k , the classes need refinement. Since this is a heuristic method, it is possible that partitioning nodes into classes fails while interaction is dense. However, the social network usually follows Power Law Distribution , making many nodes with low degrees. This can be effectively used to reduce the number of classes with a size smaller than k , also mentioned [1]. For each class with a size smaller than k , we check whether it can be merged with another class with a size smaller than k (observing TSCSC), if yes, we merge the two classes to reduce the number of classes with a size smaller than k . The attributes of a dummy node are decided by randomly picking from the attributes of the nodes of the class which it belongs to. For example, suppose Class A = {2, 7} and k = 3, user 2 is with attributes = {18, M, US} and user 7 is with attributes = {25, M, TW}. We add a dummy node corresponding to user 11 to Class A and its attributes assign the corresponding label list to each node according to its class to get G T '. vertices  X  V t \ V t  X  1 and all edges  X  E t \ E t  X  1 from G t ' for t = 1 to T . As shown in Figure 7, we sort all vertices in G 1 according to list ap = &lt;location, gender, age&gt; to generate V list . Following Steps 2 and 3, the nodes are divided into A = {5, 8}, B = {1, 10}, C = {6, 7}, D = {3, 4}, E = {2}, and F = {9}. Since Classes E and F are both with a size smaller than k , dummy nodes are added to them. E becomes {2, 11} and F becomes {9, 12}. Next, we assign the corresponding label list to each node according to its class to get G 1 '. Finally, we generate G 0 ' by removing the vertices and edges belong to V 1 \ V 0 and E 1 \ E 0 from G 1 ', respectively. 3.3 The Security of Time-Series Class Safety Condition Three conditions for ensuring the privacy objectives of our method on multiple releases for time-series social network graphs are descripted. The first condition (  X  v  X  V t and w  X  V t' : if v  X  C  X  w  X  C  X  t = t' ) indicates that nodes in the same class arrive at the same time in each anonymized graph. As a result, DMRA ensures that the deleted nodes are in the same classes, thus making each class to have k members. 
The second condition (  X  ( v , w )  X  E t : if v  X  C  X  w  X  C  X  v = w ) constraints no edges exist in a class at a timestamp. Accord ingly, if there is an edge between two nodes in the anonymized graph at timestamp t , the true labels of the two nodes must belong to different classes. Then, to an edge, there will be k candidate labels for both endpoints. The third condition (  X  C a and C b  X  V t , n e is the number of edges between C a and C timestamp to less than or equal to k . Given two classes C a and C b at the same timestamp, suppose that an entity u x is in C a and an entity u y is in C b , the probability of guessing these two entities u x and u y having interaction can be formulated as following: 1/ k , we can imply n e  X  k . How to evaluate the utility of the anonymized social network graphs is an important issue. Some researchers [1] [9] [11] cond uct aggregation queries on the anonymized social network graphs. In this paper, we use two kinds of queries including the single hop queries and two hops queries (also used in [1] [9] [11]) to evaluate the utility of the anonymized time-series graphs The formal description of the single hop queries is as follows: How much interaction between the user with one specific attribute and another user with another specific attribute at a time period. For example, how much friendship between the users located in Unite d States and the users located in Japan at the measurement period? The two hops queries involve three user attributes. For example, how much friendship satisfying that Americans have friendship with Japanese, who also have friendship with Chinese at the measurement period? We and on the anonymized graphs, respectively. Since we do not know the true label of each node in the anonymized graphs, how to perform the queries on the anonymized graphs is an issue. We use the Sampling Consistent Graphs method [1] to randomly sample a graph that is consistent with the anonymized graph. The query is performed on the sampled graph. 
Two real datasets Flickr [7] and Slashdot [5] with synthetic labels are used to test our solution. Flickr was daily crawled from the Flickr network between November 2nd, 2006 and December 3rd, 2006, and again between February 3rd, 2007 and May 18th, 2007. This dataset has a total number of nodes and edges about 1.8M and 10M, timestamps. Slashdot is a technology-related news website. The dataset was collected in November 6th, 2008 and February 1st, 2009, which consists of 79K nodes and 723K edges. We separate this dataset into two partitions to simulate two timestamps. Because the original datasets have no labels, we generate labels containing three attributes, age (10~60), gender (male/fe male) and location (50 countries) for each entity and all values are within the uniform distribution. Our algorithm is implemented in C++ and performed on a PC with the Intel Core 2 Quad 2.66GHz CPU, 8GB memory, and under the Ubuntu v11.04 64bits operating system. 
We consider 50 queries and three sorting methods including unsorted, list ap = The experiment results regarding single hop queries and two hops queries are shown in Figures 8 and 9, respectively. Obviously, since the larger k leads to the more possible labels for each entity, the average relative error rate increases as the are shown in Figures 8 and 9. As can be seen, the unsorted cases have the higher average relative error rates in either Figures 8 or 9. Usually, the results on single hop queries are better than those on two hops queries since the two hops queries involve much interaction. The degree distributions of the two datasets are shown in Figure 10, which indicate that the degree distributions of the two datasets follow the power law distribution. Accordingly, most of the nodes are quickly grouped together since there are many nodes with low degrees in the datasets and therefore, we only need to add few dummy nodes in most of the cases.
The running time of DMRA is shown in Figure 11, which decreases with the making the comparisons on checking Time-Series Class Safety Condition reduced. Either single hop queries or two hops queries only consider the interaction among entities with different user attributes. Since dummy nodes do not have any edges in the released graphs, adding dummy nodes does not change the total number of interactions and does not seriously affect the results of queries. In this paper, we address a new problem on privacy preserving for releasing multiple time-series social network graphs. Naively applying the existing approach to each time-series graph will break the privacy purposes. For achieving the privacy purposes, we propose Time-Series Class Safety Condition and DMRA for releasing multiple anonymized graphs at one time. The experiments demonstrate that DMRA is very effective in terms of data utility. Moreover, if we know which attributes are more important and often used in the queries in advance and follow the sorted vertex ordering in our anonymizing algorithm, the relative error rate will be reduced. 
