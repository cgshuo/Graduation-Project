 Universidade da Coru  X  na
In the last decade, various restricted classes of non-projective dependency trees have been pro-posed with the goal of achieving a good tradeoff between parsing efficiency and coverage of the syntactic structures found in natural languages. We perform an extensive study measuring the coverage of a wide range of such classes on corpora of 30 languages under two different syntactic the best tradeoff between coverage and computational complexity of exact parsing is achieved by either 1-endpoint-crossing trees or MH k trees, depending on the level of coverage desired. We also present some properties of the relation of MH k trees to other relevant classes of trees. 1. Introduction the sentence X  X r equivalently, if no dependencies cross when drawn above the words.
Projectivity is advantageous for efficient parsing: Exact inference for parsing models restricted to projective trees can be achieved in cubic time (Eisner 1996), and shift-reduce parsers can process them with very simple transitions in linear time (Nivre 2006). For this reason, and because crossing dependencies have traditionally been rare in corpora of languages like English, Chinese, or Japanese, many implementations of dependency parsers assume projectivity (Nivre 2006).
 ena like topicalization, scrambling, wh -movement, or extraposition, so it is necessary for natural language parsers to support non-projectivity, especially when working with languages with flexible word order. Unfortunately, exact inference is intractable for models that support arbitrary non-projective trees, except under strong independence assumptions (McDonald and Satta 2007). For this reason, researchers have proposed various classes of mildly non-projective trees: restricted classes of trees that allow a limited degree of non-projectivity, permitting crossing dependencies only under certain phenomena found in real sentences with efficient parsing. jectivity, with the goal of evaluating them in terms of the tradeoff between coverage and efficiency. For this purpose, we measure their coverage on a set of syntactic treebanks of 30 languages, analyzed under two different annotation criteria.
 ments of the coverage of a wide range of mildly non-projective classes of trees on a large collection of treebanks, relating them to their computational properties for parsing. To our knowledge, this is the first study providing an extensive comparison of such classes:
Although Havelka (2007) also measured the coverage of several restrictions on non-projectivity, little was known at the time about which restrictions could be exploited for efficient parsing, so only a few of the classes discussed there are relevant for parsing.
Furthermore, existing coverage data in the literature (both in that study and in the papers describing subsequently discovered classes of trees, cited herein) refer to small sets of treebanks that vary across reports, when reported at all.
 best coverage X  X fficiency tradeoff, with other classes of mildly non-projective trees. 2. Classes of Mildly Non-Projective Trees
We now list the classes of trees considered in this study, outlining them very briefly. A full description of each class, with all the required definitions, is outside the scope of this article. We refer the reader to the provided references for further information.
Projective. Projective dependency trees can be parsed in O ( n denote the set of projective trees by Pr .

Well-nested with Bounded Gap Degree. Well-nested trees (Bodirsky, Kuhlmann, and M  X  ohl 2005) are those that do not contain disjoint subtrees whose yields interleave (those that do are called ill-nested). Well-nested trees whose gap degree (the number of discontinuities X  X r gaps  X  X n a node X  X  yield) does not exceed a constant k can be parsed and Weir 2011); and we will call them WG k trees. WG constituent grammar formalisms, as tree-adjoining grammars induce WG coupled context-free grammars induce WG k trees (Kuhlmann 2010).

Mild+1-Inherit and Gap-Minding. Gap inheritance (Pitler, Kannan, and Marcus 2012) is a restriction on the number of children of a node that can have arcs that cross a gap in its yield. Imposing gap inheritance bounds as additional restrictions on WG relevant classes of trees are obtained: Mild+1-Inherit ( M1I ) trees can be parsed in O ( n and Mild+0-Inherit ( M0I ) trees, or gap-minding trees, in O ( n
Head-Split. The head-split property is a restriction that forbids trees where a node X  X  yield has a gap that includes its head, but not the gap in its head X  X  yield. This allows dynamic programming parsers to split subtrees into two at the position of their heads, reducing the complexity of parsing several subclasses of WG 1 trees: Satta and Kuhlmann (2013) 810 show how WG 1 trees with the head-split property ( WG whereas for M1I trees with the head-split property ( M1IS ) the complexity is O ( n
Mildly Ill-nested. A superset of WG k trees, mildly ill-nested trees of gap degree up to degree k . They can be parsed in time O ( n 4 + 3 k ) (G  X  omez-Rodr  X   X guez, Carroll, and Weir 2011). Note that this is the same complexity as for WG k for k = 1, but larger for k &gt; 1.
Attardi Degree 2. The set of trees that can be parsed with the transitions of degree up to 2 in the transition system of Attardi (2006) is also amenable to dynamic programming parsing, in time O ( n 7 ) (Cohen, G  X  omez-Rodr  X   X guez, and Satta 2011). This set, which we will call AD 2 , includes ill-nested trees and trees with unbounded gap degree. tabular algorithm obtained from the shift-reduce parser of Yamada and Matsumoto (2003), or from the arc-hybrid transition system (G  X  omez-Rodr  X   X guez, Carroll, and Weir 2008; Kuhlmann, G  X  omez-Rodr  X   X guez, and Satta 2011). This parser, called MH representing a span dominated by several head nodes (hence the acronym, for  X  X ulti-headed X ). It has complexity O ( n k ) and is projective for k = 3, but covers increasingly large sets of non-projective trees for values of k &gt; 3, which we will call MH 1-Endpoint-Crossing. Pitler, Kannan, and Marcus (2013) define 1-Endpoint-Crossing trees common vertex. This set of trees includes trees that are ill-nested and have unbounded gap degree, and can be parsed in O ( n 4 ) (Pitler, Kannan, and Marcus 2013; Pitler 2014). k-Planar. k -Planar trees ( k-P , equivalent to k -page book embeddings in graph theory) are those whose non-dummy arcs can be partitioned into k sets (called planes ), in such a way that arcs belonging to the same plane do not cross (Yli-Jyr  X  a 2003). No globally optimal parser is known for these trees, but they can be handled by a linear-time transition-based parser with k stacks (G  X  omez-Rodr  X   X guez and Nivre 2010, 2013). k-Crossing Interval. k -Crossing Interval trees ( k-C ) are defined by Pitler and McDonald (2015) with a restriction on intervals formed by crossing arcs. 2-C trees can be parsed ac-curately with a linear-time shift-reduce parser with two registers (Pitler and McDonald 2015). 2-C trees are a subset of 1EC trees, which in turn are a subset of 2-P trees. 3. Materials and Methods
Corpora. We evaluate the coverage of each class described in Section 2 on HamleDT 2.0 (Rosa et al. 2014), a collection of harmonized versions of existing treebanks of 30 diverse languages, under two different annotations: Prague and Universal Stanford dependencies. Both annotation styles are interesting for parsing: The former tends to be easier to learn for monolingual parsers, but the latter is advantageous in multilingual settings (see Rosa [2015] and references therein). Thus, apart from spanning a variety of languages, these data sets allow us to see the influence of annotation criteria on the coverage of different restrictions on non-projectivity.

Methodology. For the classes of trees that have a known characterization independent of their parsers (i.e., all except AD 2 and MH k ), we determine whether each tree in the treebanks belongs to the class by using scripts that check for the required conditions. In the case of AD 2 , we run an implementation of the oracle by Cohen, G  X  omez-Rodr  X   X guez, and Satta (2012) for the Attardi parser restricted to degree 2, which has been shown to recognize exactly the trees of AD 2 and its implementation checked against the dynamic programming algorithm of Cohen, G  X  omez-Rodr  X   X guez, and Satta (2011).
Finally, in the case of MH k , we run a dynamic programming implementation of the parser itself.
 from the literature, custom-built sets of cases, known relations between classes (MH 3 = Pr, 2-C  X  1EPC  X  2-P, WG k  X  MG k , etc.), runs on other treebanks to compare with previously reported coverages, and in some cases, comparison of more than one implementation. 4. Results
The results of the coverage analysis are shown in Tables 1 and 2. For space reasons, we omit some of the classes with less direct practical interest: 1-P (a very mild relax-ation of projectivity, of limited interest for expanding coverage), k-C and k-P for k &gt; 2 (transition systems for them are possible in theory, but likely impractical due to the extra transitions needed), and those whose best known parser is slower than O ( n for k &gt; 2.
 a diverse set of corpora with varying amounts of non-projectivity, ranging from the total projectivity of the Prague-style Romanian treebank to the very high non-projectivity in the corpora of classical languages X  X robably influenced by the presence of poetic texts in them X  X r in the Stanford-annotated Arabic data set.
 tions on non-projectivity. The Stanford treebanks not only tend to contain more non-projectivity than the Prague ones, but also more ill-nested trees and trees with higher gap degree. For example, the average proportion of trees that are not in WG than double on Stanford than on Prague treebanks, with huge differences in some cases (e.g., 14.84% vs. 0.20% on the Arabic corpora). The same trend appears in the other classes requiring well-nestedness and bounded gap degree. The finding that WG covers almost all phenomena found in treebanks, reported in smaller data sets in the past (Kuhlmann 2010; G  X  omez-Rodr  X   X guez, Carroll, and Weir 2011), is questionable for Stanford treebanks, as it excludes more than 5% of the trees in nine languages. mildly non-projective parsing in general, as the Attardi parser and the MH for k &gt; 4 have better coverage for the Stanford than for the Prague-annotated treebanks.
Thus, the lower coverage of the well-nested parsers on the Stanford treebanks does not exclusively owe to them having more non-projectivity in a general sense, but rather different kinds of non-projectivity that are better captured with different restrictions. parsers running in time O ( n 4 ) is 1EC, which even surpasses WG on the Stanford treebanks. But if we are willing to accept larger complexities, the best tradeoff is achieved with the MH k parsers. The average coverage is close to 99 . 5% for
MH 5 , and practically full for MH 7 , only excluding 177 trees out of the more than 800, 000 analyzed overall. MH 12 (not shown in the tables) has full coverage of the 60 treebanks. surprising, with similar coverage to that reported for smaller sets of treebanks in the respective papers (G  X  omez-Rodr  X   X guez and Nivre 2013; Pitler and McDonald 2015). Note 812 shown to have very good empirical accuracy, probably because it is an easier to learn model. 5. Discussion
We have measured the coverage of a wide range of classes of mildly non-projective dependency trees on a large collection of treebanks with two different annotation styles, providing valuable data to compare said classes in terms of balance between coverage and efficiency. The relative coverage of the different classes varies across languages and annotation criteria. Explaining the concrete factors affecting it for each individual language is outside the scope of this work, and an interesting subject for studies focused on particular languages and corpora. However, despite this variability, there are very clear trends in the results. A relevant one is that the best general tradeoff is achieved by 1-Endpoint-Crossing trees (for complexity O ( n 4 )) and MH complexities).
 aspects of mildly non-projective classes that one may wish to take into account, like their relation to constituency grammar formalisms (Kuhlmann 2010) or characterizability 814 (Pitler and McDonald 2015). In this sense, it is worth noting that no characterization independent of the parsing algorithm itself is known for the MH as happens with Attardi trees. In fact, MH k trees have been very little studied, and their empirical coverage was unknown prior to this work. Because it is notably high, finding a simple characterization of MH k trees is an interesting open problem, which may be solvable as MH k trees have some desirable formal properties that AD left-right symmetry (reversing the order of the words of an MH tree).
 that: (1) MH 4 contains ill-nested trees with unbounded gap degree (and therefore, the same can be said of MH k for k &gt; 4, as MH k  X  1  X  MH k of the proof for (2) follows: given the MH 4 parser (shown in Figure 2), we build a variant
MH 2 P 4 that associates each arc with a plane  X  X  P 0 , P do so, we annotate each index (node) on items with a forbidden plane, such that steps creating an arc h  X  d always do so on a plane not forbidden for h or d . If both planes are allowed, then if the item has a node x between h and d with a forbidden plane, the arc is created on that plane (to avoid forbidding both planes on x at the same time), otherwise an arbitrary plane is chosen. Initial items do not have any restrictions, but when we create a right arc A = h 1  X  h 3 with a Link step [ h plane P i , we forbid P i on node h 2 (located between h 1 cross A from being created on the same plane as A , and the symmetric is done for left arcs. Annotations are propagated across deductions together with their nodes. that is, it never reaches a situation where an arc cannot be created without violating 2-planarity because both planes are forbidden by the restrictions. This is shown by proving that each item has at most one node with a forbidden plane. To see this, note that the first and last nodes of an item cannot have any forbidden plane: by construction, restrictions always originate on the central node of a 3-node item, and no steps in the propagate to 4-node items, but these always come from applying a Combine step on a 3-and a 2-node item, so again at most one node (the central one in the 3-node item) can have a forbidden plane. Thus, we can always associate a plane to an arc without violating restrictions, as there can be only one restriction per item and therefore at least one plane is allowed.
 arc A , any subsequently built arcs crossing A must share an endpoint: for example, after located between h and d remaining available is x , so any subsequent arcs crossing A must be incident to x . This restriction is interestingly similar to the definition of 1EC trees, although weaker because it only affects arcs created after A .
 help obtain a characterization for the set of MH k trees. Their good balance between cov-erage and parsing efficiency makes this class, together with 1EC trees, very interesting for modeling the non-projectivity found in natural languages.
 Acknowledgments References 816
