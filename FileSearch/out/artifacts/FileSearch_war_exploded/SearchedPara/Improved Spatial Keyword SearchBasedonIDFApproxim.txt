 There has been a strong trend of incorporating spatial information into keyword-based search systems in recent years for t he support of geographic queries. It is driven mainly by two reasons: highly user demands and rapid advances in Geo-positioning and Geo-coding technologies. User interests include finding the nearby restaurants, tourist attractions, entertainment services, public transport and so on, which renders the spatial keyword queries important. Studies [13] have shown that about 20% of web search queries are geographical and exhibit local intent. In addition, both the various advanced Geo-positioning technologies such as GPS, Wi-Fi and cellular geo-locatio n services (offered by Google, Skyhook, and Spotigo), and different geo-coding technologies which enable annotating of web content with positions accelerate the evolution of spatial keyword search.
Spatial keyword queries take a set of keywords and a location as parameters and return the ranked documents that are most textually and spatially relevant to the query keywords and location. Usually, distance is used to measure spatial relevance and document similarity functions such as TF-IDF weighting [7] are used to measure textual relevance. A f air amount of investigations have been conducted aiming at this issue, such as the algorithm of solving kNNs (k-nearest neighbor queries) using R-tree [12], loose combinations of inverted file and R*-tree [2] [6] [15], and signature augmented IR -tree [4]. Whereas limitations exist in those works, they either cannot support pruning simultaneously according to both keyword similarity and spatial information, or become infeasible when it comes to handling ranked queries.
 One of the most promising and popular ones is IR-tree index based method. This particularly designed index structure enables simultaneous spatial pruning and textual filtering, and also an incremental searching and ranking process. Most importantly, it supports query sp ecific IDF(Inverse Document Frequency) values computation for determining doc ument textual scores, which is more rea-sonable than traditional IDF values used in purly textual search. Essentially, IDF value measures the selectivity(or ra rity) of a query keyword. In purly tex-tual search cases, for a word w , IDF w is computed as the logrithm of Collection Size ( | D | ) divided by Document Frequency of w ( DF w ). While in spatial key-word search cases, it is inappropriate to keep using this tranditional IDF values as the word distribution among documents within query spatial range might be completely different with word distribution in whole documents set. Therefore, the query specific IDF value used in spatial keyword search is computed as the logrithm of Total Number of Documents within Query Range ( D s )divided by Word DF within Query Range ( df w,D s ). However, in order to determine IDF value of each query keyword for later calculating textual score of each object, IR-tree based searching method suffer s from multiple times of accessing in-verted files attached with leaf nodes of the index tree, which det eriorates search-ing performance substantially, espectia lly when their inverted files are stored on disk.

Based on the above observation, in this paper, we propose a new searching al-gorithm which does not access inverted fi les when computing IDFs thus results in an IDF range for each query keyword, and then retrieve top-k documents based on range scores computed using IDF ranges. Our approximate IDF-based method reduces query search time consi derably to nearly half of the original search method while without compromising accuracy of final ranked results. We conduct a comprehensive set of experiments that clearly show the search perfor-mance gain of our proposed method in comparison with the original algorithm under a wide variation of various query or index parameters. Some essential pre-liminaries related to spatial keyword search are presented in Section 2. Section 3 details our proposed approximate IDF-based algorithm. Section 4 provides re-sults of experiments over a wide range of parameter settings and the last section concludes the work. 2.1 Problem Definition We consider a database consists of N documents, each associated with a spatial location. A query Q also consists of a set of keywords (denoted as W Q ), and a location (denoted as Q.loc ).

Given a query range S Q and a scoring function score ( Q, d ), a top-k spatial keyword search returns top k scoring documents from the database.

The scoring function should take into consideration both the textual rele-vance of the document to the query as well as the spatial proximity between the locations of the query and the document. Hence, the final function can be  X   X  [0 , 1] is a tuning parameter.
 Spatial Relevance. We only need to consider documents within the search range as specified by S Q (these doucments are also known as spatially qualified ). For spatially qualified documents, we give its proximity score based on the euclidean distance between its location and the query location, i.e., score spatial ( Q, d )= 1 query and any spatially qualified document.
 Textual Relevance. We adopt the popular Vector Space Model to measure the textual relevance between the document and the query. In this paper, we con-sider approaches using the query-specific IDF, which is defined as idf w,D,S Q = that of the entire collection of documents, and df w,D s refers to number of spa-tially qualified documents that contain w , therefore, idf w,D,S Q reveals query words distributions among spatially qualified documents rather than in the entire collection. Finally, the te xtual score is calculated as: score text ( Q, d )= query Q iff d contains at least one query keyword of Q .
 Notations. We use the following notations in the rest of the paper. The root of an IR-tree is r . The number of documents within S Q as D s . Number of documents within S Q that contain w as df w,D s and query specific idf value of w as idf w,D s . Similarly, for a tree node e , df w,D e refers to the number of spatially qualified doc-uments stored underneath e that contain w . In later sections, unless explictly stated, when saying df w or idf w , we refer to df w,D s and idf w,D s respectively. Finally, the candidate set produced from IDF calculation step as B . 2.2 IR-Tree Index Structure IR-tree [11] is one of the most effective a nd efficient query processing methods for top-k spatial keyword search. Its effectiv eness largely comes from the query-specific IDF. In order to facilitate query processing, a novel index, IR-tree, is proposed, which is essentially a clever combination of R-tree [5] and inverted files [16]. Document locations are indexed in an R-tree enhanced as follows:  X  each internal node of the R-tree is associated with textual summary informa-tion about documents in the subtree, including (1) the count of documents in the subtree, and (2) the max-TF and DF for each words appearing among documents in the sub-tree.  X  each leaf node is linked to an inverted file indexing all the documents belonging to the nodes.
 An example IR-tree is shown in Figure 1. 2.3 The Existing Search Algorithm for IR-Tree The query processing algorithm in [11] consists of two steps, IDF calculation and top-k document retrieval .

Algorithm 1. IDFCalculation ( r , W Q , S Q ) IDF Calculation. We show the pseudo-code of IDF calculation in Algorithm 1. It is basically a top-down traversal of the IR-tree, and accumulates D s and df w s during the process.
 Top-k Document Retrieval. This step performs best-first search on the IR-tree, anditterminatesassoonastop-k objects have been determined. Initially, all the entries in B and their estimated maxscores are pushed into max-heap H . The algorithm then iteratively pop an entry e in H until either H is empty or top-k results have been determined. If e is a document, it is added to R ;if e is a non-leaf node, it pushes all its children and their scores to H ;otherwise, e must be a leaf node, it pushes all its documents and their scores into H . Example 1. Consider the example IR-tree in Figure 1. Document statistics and spatial scores are given. Assume k =1,  X  =0 . 5, W Q =( w 1 ,w 2). The algorithm works as follows:  X  In the IDF calculation step, IR-tree is traversed from root, node N2 is con-tained in S Q , so it is added into candidate set B , D s is computed as 2, df w 1 =1 and df w 2 = 2. Nodes N1 and N3 are leaf nodes that partially overlap with
Q , therefore their associated inverted files are retrieved to calculate accu-rate df w 1 =2 ,df w 2 = 3, and d3 and d6 are found to be both spatially and textually qualified and are added to B . At the end of this step, we have
B = { N 2 ,d 3 ,d 6 } , idf w 1 =log 10 4 2 =0 . 301, and idf w 2 =log 10 4 3 =0 . 125.  X  In the TopKRetrieval step, H is initialized as { ( N 2 , 0 . 926) , ( d 3 , 0 . 326) , ( d 6 , 0 . 225) } by adding all entries in B and their scores(for nodes, the scores calculated are their estimated maxsc ore; for docs, they are accurate score) to H . Then, node N2, the head entry in H is popped and expanded so that its children d1 and d2 are added to H .Now H = { ( d 1 , 0 . 714) , ( d 2 , 0 . 425) , ( d 3 , 0 . 326) , ( d 6 , 0 . 225) } .  X  Since d1 X  X  score is higher than the next highest score, d1 is returned as the top-1 answer, and the algorithm stops. One performance issue with the above query processing algorithm on IR-tree is that generally more than 70% of the search time is used for IDF calculation. For example, the shaded bars in Figures 2 indicate the IDF calculation time.
After analyzing the IDF calculation algorithm, Lines 17-23 of Algorithm 1 are usually the most time-consuming part. This is because the algorithm needs to access inverted files for each intersectin g leaf node. These inverted files are typ-ically proportional to the total size of document collection, and are much larger than spatial information and other index overhead associated with each docu-ment. In addition, due to the sheer size of the inverted files, they are typically stored on the disk, and many random I/Os are needed to retrieve them.
Therefore, our goal is not to access all of the inverted fi les while still retrieving the top-k results. We instead approximate the IDF values by a range. We can find conditions that guarantee the correctness of top-k answersevenwithsuch approximate IDF values. 3.1 Framework Our idea is to leave out Lines 17-23 of Algorithm 1, and compute a DF range [ DF min w , DF max w ] for each query word w without traversing inverted lists.
Consider the previous example. When node N1 is traversed, we find it is an intersecting leaf node, instead of scanning its inverted files, we know that under N1, there are df w,D N 1 docs contain w , but not sure if all of them are spatially qualified. Thus, we can bound DF w as [ DF w , DF w + df w,D N 1 ]. Subsequently, we can bound the IDF values for each query keyword as [log D s DF
Once we have the IDF range for every query keyword, the min and max scores of an IR-tree node or a document can be computed using the IDF ranges and the scoring function presented in section 2. Note that spatial score of an IR-tree node can also be bounded by computing the min and max distance between the MBR of the node and the query location.

Denote minScore of d as  X  ( d )andmaxScoreof d as &amp; ( d ). It is obvious that if  X  ( d rank d 1 before d 2 . 3.2 IDF Range Computation The main difference of this algorithm with Algorithm 1 is the case when current entry e is a leaf node(line 12). Instead of retrieving the inverted file of e ,only locations of child objects stored in e are scanned so as to update D s (lines 14-15), then e is added into candidate set simply if it is textually qualified, and replace lines 17-23 by DF max w  X  DF max w + df w,D e to accumulate min and max DFs for each query keyword.

A subtlety here is to additionally record intersecting leaf node if it is textu-ally qualified, so that later when two obj ects have very similar score ranges and cannot be ordered exactly, we need to expa nd these unchecked intersecting leafs and update query word DFs to get tighter object score ranges (add a line under line 16: ILFs .add( e ), where ILFs denotes a list of inter secting leaf nodes). 3.3 Top-k Docs Retrieval After getting candidate set, IDFs ranges, top-k documents are retrieved. As there may be much more than k qualified documents in candidate set, we use the incremental search algorithm which stops as long as k docs are identified.
Algorithm 2. TopKRetrieval ( W Q ,S Q ,k, X ,B, ILFs ,minDFs,maxDFs )
Algorithm 3 outlines top-k document retrieval process. Firstly, for each entry max-heap H which sorts its entries in descending order of their maxScores. top-k documents until H is empty. If e is a node, expand this node by adding its children and their scores into H .Ifitisadocumentand H is not empty, the next top entry( n )in H needs to be examined and compared with e in order to deter-mine whether e can be added into R .This leads to two cases: 1) Scores of e and not determine directly whether e is the most relevant document in H ,thusextra process is required. If n is a node, push e back to H and expand node n ,whereas if n is also a document, which means the current DFs ranges are too rough to de-termine exact top-k documents, more int ersecting leaf nodes need to be expaned to update min and max DFs of query keywords, IDF values are recomputed and entry scores in H are also updated to a tighter bound for exact ranking.
ExpandTreeNode( n, H ) process examines all the child nodes ( cn ) of the node is an internal tree node. If n is a leaf node which is within query range, tex-tually qualified documents (d) which is implied by that they exist in at least one of the inverted lists of query keywords associated with n are examined node( n. MBR is interect with S Q ), not only documents stored underneath n have to be checked whether they are tex tually qualified, they also have to be checked if spatially qualified so that they can be added into H and minDFs and maxDFs are also updated accordingly.
 Lemma 1 (Correctness). Algorithm 2 correctly retrieves the top-k result. Example 2. Using the same example in Figure 1, the proposed algorithm works as below:  X  IDFRangeComputation procedure traverses IR-tree to find contained node N2, and intersecting leaf nodes N1 and N3, thus updates D s =4, ILFs =(N1,
N3), B =(N1, N2, N3), and df w 1 ,D s = [1, 3], df w 2 ,D s = [2, 3], and computes idf w 1 ,D s = [0.125, 0.602], idf w 2 ,D s = [0.125, 0.301].  X  TopKRetrieval first constructs initial H = { (N2, 1.403, 0.75)(N1, 0.501, 0.325) (N3, 0.476, 0.238) } . Then node N2 is expanded to get newH = { ( d 1 , 1.103, 0.538)( d 2 , 0.601, 0.425)(N1, 0.501, 0.325)(N3, 0.476, 0.238) }  X  Two documents are found at the top of heap, but with incomparable scores.
Therefore, more intersecting leaf n odes have to be expanded. Assume 50% of | ILFs | is expanded at one time, then in this case, node N1 is expanded. df is not changed, newdf w 2 ,D s = [3, 3], so newidf w 2 ,D s = [0.125, 0.125]. The new updated H = { ( d 1 , 1.015, 0.538)(N3, 0.476, 0.238)( d 2 , 0.425, 0.425)(N1, 0.325, 0.325) }  X  d 1 is returned as its  X  ( d 1 ) &gt; &amp; ( N 3). Search stops. 4.1 Experiments Setup We select two publicly available datasets.  X  X rec is from the TREC-9 Filtering Track 1 . We use TREC as text dataset.  X  X OI-Italy contains gas station and car parking locations of Italy 2 . for spatial data.
 There are totally 239580 documents in Trec dataset. We randomly combine two documents to form a longer document, and 100000 of these combined documents are selected as test data set. We assign ea ch combined document a unique spatial location selected randomly from POI-Italy dataset. All the x and y coordinates data in POI-Italy dataset are normalised into range [0 , 40000]. Correspondingly, we randomly select 1 to 8 words from the vocabulary of the documents to form textual part of queries and assign random rectangle as the spatial part. We show some statistics in Table 1.
In the experiments, we investigate performance gains of proposed search algo-rithms and influences of 5 factors on search performance shown below in table 2. The underlined values are default settings if not specified.  X  S Q Query Spatial Range.  X   X  Score ratio, which measures the relative importance of textual relevance to spatial relevance.  X  k The number of documents to be returned.  X  | W  X  | D | Test size, the total number of documents indexed.
 The index structure implemented is IR-tree Index demonstrated in Section 2.2 using the public R-Tree Library at http://jsi.sourceforge.net .Twosearch algorithms are implemented, which are denoted as IRTree (described in sec-tion 2.3) and ApproIDF (our proposed algorithm). 4.2 Search Performance In the experiments, we compare the searc h performance of two search algorithms over wide variation of different query and index factors.
 Vary Query Word Number | W Q | : In Figure 2(a), we compare the experi-mental results of the two search algorithms in terms of total query search time against query word numbers. The shaded area represents IDF computation time of the two algorithms. It is obvious that our proposed algorithm outperforms the original search algorithm, and consumes nearly half of the search time of original algorithm. This trend remains the same while the number of words are increasing. Another observation is that the IDF computation time of ApproIDF is reduced substantially as expected, whi ch becomes less than one thirds of that of original search algorithm. Finally, the obvious trend shows that total search time increases linearly as query word number increases. This is due to the in-crease of textually qualified documents since our implementation supports OR semantic keyword search, which means a document is qualified as long as it contains at least one of the query keywords.
 Vary Score Ratio  X  : Figure 2(c) presents search perfomance of varying weight ratio between textual and spatial relev ance. It can be seen that search time stays steadily for the two algorithms when  X  varies from 0 to 1 except that when  X  is set to 0(only consider spatial score), approIDF performs particularly good than any other cases. The reason is that when  X  is 0, the ordering of documents only depends on spatial score, which renders IDF values useless no matter they are exact or approximate. Therefore, top k do cuments can be selected directly and quickly using accurate spatial score. In addition, the overall trend is the same as above, ApproIDF performs much better than original search algorithm in all ratio settings. Here,pre-checking of  X  can be added before search process starts as an optimization to deal with special cases such as  X  is 0 or 1.
 Vary Top K k : Figure 2(d) demonstrates the impact of number of requested documents( k ). It is shown that search time of the two algorithms increase slighly as k increases. As both of the search proce sses are incremental, which means they stop as soon as top-k docs have been retrieved without having to go through all candidate set, when k becomes larger, mo re scores of documents need to be com-puted and ranked. Besides, our proposed algorithm is still more efficient than IR-tree search algorithm.
 Vary Query Range S Q : Next, effects of query spatial range on search perfor-mance are evaluated. The log scale search time is summarized in Figure 2(b). When query range is small(10-1000), total search time for both algorithm is less than 0.04 millisecond, whereas whe n search range increases to 10000, to-tal search time grows drastically to around 0.63ms for IR-tree and 0.33ms for ApproIDF. The is mainly due to increase of candidate size when query range grows. There are nearly 10% (9231) of documents are within query range when S
Q is set to 10000. Overall, ApproIDF outperforms IR-tree search algorithm, especially obvious when query range is large.
 Vary Test Size | D | : As shown in Figure 2(e), search time grows up linearly for both algorithms along the increasing of test size (number of documents indexed). It is mainly due to the increase of candidate size when test size becomes larger asshowninFigure2(f). Numerous works have been done in this field. Some works use inverted index for textual retrieval and separate index such as Quad-tree or Grid index for spatial filtering [2] [10]. Currently the most widely used index structure is hybrid index, and many variations exist besides the IR-tree structure [3] [11] we already men-tioned, such as Na  X   X veHybridIndex[9],R*-tree[1][8],KR*-tree[6],IR 2 -tree [4], and W-IR-tree [14].
 Na  X   X ve Hybrid Index [9] combines document location to every word in the document to be a new word, and build index on them. This method clearly wastes lots of space and does not support fl exible spatial relev ance computation. R*-tree based method use loose combinations of an inverted file and an R*-tree [6] [15]. These works usually suffer from the inability to prune search space simultaneously according to keyword similarity and spatial information. IR 2 -tree [4] augments the R-tree with signatures enables keyword search on spatial data objects that each have a limited number of keywords. This technique suffers from substantial I/O cost since the signature files of all words need to be loaded into memory when a node is visited. Also, signature approach is useless and infeasible when it comes to handling ranked quires. W-IR-tree [14] is essen-tially an IR-Tree combined with word partitioning technique, which partitions keywords before constructing IR-tree. W-IBR-tree is simply a variation of W-IR-Tree by replacing inverted files attached to each node by inverted bitmap, which reduces the storage space and also saves I/O during query processing. This tree structure combines both keyword and location information, better matches the semantics of top-k spatial keyword qu eries and performs better than IR-Tree. However, it does not consider textual similarity as a ranking factor as it treats an object as either textual relevant (containing all the keyword queries) or not. In this paper, we introduce a new approximate IDF-based searching algorithm to deal with top-k spatial keyword search problem based on IR-tree index struc-ture. We evaluate the performance of our proposed algorithm against the original one [11] via wide variation of experimen t factors, and the experimental results demonstrate that our proposed search algorithm performs nearly twice better than the original one. The only drawback of IR-tree index structure is that it consumes substantial amount of storage space whose improvement can be a promising work in the future.

