 It is not trivial work to discover useful and common information from a collec-tion of trees. With increasing demands, it is necessary to develop new or adjust existing extraction methods for tree data and various works have been proposed. The most common existing approaches to do are either Apriori -based [5,1,6,2,3] or frequent-pattern-growth(FP)-based [4,7]. However, Apriori-based algorithms suffer from two high computational costs: generating a huge number of candi-date sets and scanning the database repeatedly for the frequency counting of candidate sets. To solve those problems, FP-growth method is developed, which adopts a divide-and-conquer strategy. The FP-growth based algorithms avoid candidate sets generation. However, this approach still has a severe problem. In-stead of avoiding candidate subtrees generation, its goal is to discover all frequent subtrees which become infeasible for a large number of trees.

A more practical and scalable approach is to use maximal frequent subtrees, and handling the maximal frequent subtrees is an interesting challenge, and represents the core of this paper.
 In this section, we introduce a new pattern-growth method SEAMSON (Scalable and Efficient Algorithm for Maximal frequent Subtrees extractiON) appropriate for use as the core of discovering valuable information from a database of rooted labeled trees where data not only exhibit heterogeneity but also are distributed. 2.1 Problem Definition Embedded subtrees Given a tree T =( r, N, E, L ), we say that a labeled rooted tree S =( r ,N S ,E S , L ) is included as an embedded subtree of T , denoted S T , iff (1) N S  X  N , (2) for all edges ( u, v )  X  E S such that u is the parent of v , u is an ancestor of v in T , (3) the label of any node v  X  N S , L ( v )= L ( v ). The tree T must preserve ancestor rel ation but not necessarily parent relation for nodes in S . Support and frequent subtree Let D = { T 1 ,T 2 ,...,T i } be a set of trees and |D| be the number of trees in D ,where0 &lt;i  X |D| .Given D and a tree S , the frequency of S with respect to D , freq D ( S ), is defined as  X  T i  X  X  freq T i ( S ) where freq T i ( S )is1if S is a subtree of T i and 0 otherwise. The support of S with respect to D , sup D ( S ), is the fraction of the trees in D that have S as a is greater than or equal to a minimum value of support specified by users or applications. This user-specified minimum value is often called the minimum support ( minsup ).

The problem of mining frequent subtrees is defined as to uncover all pattern maximal frequent subtree is one of frequent subtrees which none of its proper su-pertrees are frequent. Thus, there are f ewer maximal frequen t subtrees compared to the total number of frequent subtrees. 2.2 Transformation Phase The process of transformation phase is initiated by scanning a trees database, D , and generating a label-driven compact database. We refer to this database label-dictionary , and denote L -dictionary . In this label-driven db, each label plays an important role, which is usually performed by tree indexes ot transaction indexes. After the in-memory L -dictionary is constructed our approach does not require further database scanning.

For each distinct label in trees, a list is generated and stores label itself, pre-order traversal node indexes, parent positions, and tree indexes. The list is divided into two parts: head and body, and is named as label-list , abbreviated -list .
 Definition 1 (head &amp; body). The part whose purpose is to clearly identify each -list is named as head of -list because its leads the whole list. The remained part concerns about how many times a label is occurred and hierarchy information of the label in original trees. Because this part directly follows its corresponding head part, it is called body of -list .
 Every head consists of a key field, satellite data of the key, and one link, which are a label, node indexes, and a link pointing to its body, respectively. Since -list is generated according to a label, labels place in key fields. The node indexes are those nodes whose labels are same as the label in the key field. The link field indicates a starting element of its corresponding body part.

Abodyof -list follows its head immediately. The main concerns of the body is to evaluate how many trees have the key and to find parents positions of the nodes in the head. The former is for dealing with frequencies of each label, while the latter is for handling hierarchical information of the label. To achieve such intentions the structure of body is a sequence of elements which is arranged in a linear order. Each element is an object with a tree index, one link field pointing to the next element, and one satellite data field.

Since only the trees which use the label in the corresponding head to their nodes should create elements, the total number of elements in a body indicates the number of trees that have the key of -list. This number of elements is used to get size of any -list, | -list | , and to determine if a given -listisfrequentor not.

Fig. 1 shows an depicted example of how L -dictionary and its -lists are con-structed and managed from the database D . For easy distinction between nodes in different trees, we assign unique consecu tive indexes in pre-order traversal. The bodies of -lists decide the frequencies of co rresponding labels. For instance, the label A does not satisfy the given minimum value which is set 2 3 because it has only 1 element in the body of A -list. 2.3 Refinement Phase The initially built L -dictionary contains at most same number of -lists as the number of labels, because the purpose of this L -dictionary is to store tree struc-tures as list structures according to dis tinct node labels. Therefore, the unit -list is generated without considering the frequency of a label. Hence, even the label is used in only one tree, the -list for the label is generated and inserted into L -dictionary .Some -lists satisfy the given minsup , but some do not. As in-frequent single-node trees are eliminated in conventional approaches, the -lists which do not confirm the condition also have to be removed from L -dictionary , because the initial L -dictionary is similar to the set of single-node trees.
A -list is said to have frequent-head iff its body contains more than or equal to the minimum number of elements. Having frequent-head technically means that the label of a current -list is frequently occurred among trees. The -lists do not have frequent-head cannot be further extended with other labels. Therefore, such -lists have to be filtered out from L -dictionary .

The label of parent node p has to be frequent in order that an extended subtree is qualified for being frequent. However , this is not guaranteed in the current L -dictionary because the filtration was performed on only the frequency of labels. Therefore, even if parent nodes are included in the -list which has frequent-head, it is not sure whether the labels of those parent nodes also correspond the -lists which have frequent-head. To res olve this problem we refine every parent node p in the filtered L -dictionary by following procedures: (1) a parent node in an element is verified by candidate hash table which was constructed with the -lists that had been filtered from L -dictionary , to detect if the node is assigned by unfrequent label or not. (2) If so, the node is marked  X  X eplace X  and its record is retrieved to search a node id assigned by frequent node labels. (3) Step (1) and (2) continues until the node id assigned by any frequent label is found. (4) The original parent node id is replaced by the found node which is actually an ancestor node of the original parent node. (5) Through step (1) to (3), if no any other nodes are frequent, the original parent node id is replaced by 0. After the replacement according to the procedure is done, the current L -dictionary is renamed as L + -dictionary to distinguish with the previous one.

Parent nodes in an element which are assigned by the same label are removed from the element except only one node. The outcome of the end of the refinement phase is shown in Fig. 2. Note that the dummy list / -list is inserted to L + -dictionary for later use in deriving a certain tree; this plays a root node of the tree. 2.4 Derivation Phase Definition 2 (label-extension). Extending an -list is to connect explicitly between a node having the label of -list. head and its parent node which is also labeled by one of labels of -lists, denoted -list + -list P .Theextensionis performed over the labels of -list not the nodes in L + -dictionary .Thus,wecall this extension as label-extension .
 While the label-extension is committe d to creating connection between -lists, one tree is constructed as a by product of the extension which has a root node corresponding to / -list. This tree is called P otentially M aximal P attern tree ( PMP-tree inshort),whereedgehasitsown count to keep how much often it is occurred in the tree (the tree header table supports to build the tree; the detailed explanation is omitted due to the space). Based on those counts, the edge whose count is less than the given minimum value is deleted from the tree. After deleting such edges and rearranging the tree, the goal of this paper is produced. The synthetic datasets are generated by the tree generation program whose un-derlying ideas are inspired by Termier [3] and Zaki [6]. The generator constructs a set of trees, D , based on some parameters supplied by the user: T :thenumber of trees in D , L : the set of labels, f : the maximum branching factor of a node, d : the maximum depth of a tree,  X  : the random probability of one node in the tree to generate children or not,  X  : the average number of nodes in each tree in D . We used the following default values for the parameters: the number of trees T =10 , 000, the number of labels L = 100, the maximal branch factor f =5, and the maximum depth d =5.

In our first experiment, we want to evaluate the scalability of our algorithm with varying minimum support and the number of trees T , while other para-meters are fixed as: L = 100 ,f =5 ,d =5 , X  = 20% , X  =13 . 8and20 . 5(when T =10 , 000 and 15,000, respectively). Fig. 3 shows the result, where the min-imum support is set from 10% to 0. 0001%. We can find that the running time increases when the number of trees T increases, however, both running times are rarely affected by the decrease of th e minimum support. With the threshold becoming smaller, there is no big differe nce in execution time for both datasets. This is because SEAMSON relies on the number of labels not the number of nodes. Thus it is very efficient for datasets with varying and growing tree sizes.
Fig. 3(b) shows the trends of memory usage at three phases. The transfor-mation phase consumes the most amount of memory along with the growing number of trees. However, the derivati on phase uses almost stabilized amount of memory during the experiments ranged from T =10 , 000 to T =15 , 000. Because the transformation phase is responsible for scanning an original trees dataset and converting them into list-based structures, the required memory size is getting larger along with the increasing of trees in a dataset ( T ).
