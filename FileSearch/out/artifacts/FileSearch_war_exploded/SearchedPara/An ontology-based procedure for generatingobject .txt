 REGULAR PAPER Waralak Vongdoiwang  X  Dencho N. Batanov Abstract The main objective of the procedure proposed in this paper is to use ontologies to convert a problem domain text description into an object model. The object model of a system consists of objects, identified from the text description and structural linkages corresponding to existing or established relationships. The ontologies provide metadata schemas, offering a controlled vocabulary of con-cepts. At the center of both object models and ontologies are objects within a given problem domain. The difference is that while the object model should contain explicitly shown structural dependencies between objects in a system, including their properties, relationships, events, and processes, the ontologies are based on related terms only. On the other hand, the object model refers to the collections of concepts used to describe the generic characteristics of objects in object-oriented languages. Because ontology is accepted as a formal, explicit specification of a shared conceptualization, we can naturally link ontologies with object models, which represent a system-oriented map of related objects, described as Abstract Data Types (ADTs). This paper addresses ontologies as a basis of a complete methodology for object modeling, including available tools, particularly CORPO-RUM OntoExtract and VisualText, which can help the conversion process. This paper describes how the developers can implement this methodology on the basis of an illustrative example.
 Keywords Object model  X  Ontologies  X  Ontology library  X  Abstract data types (ADTs)  X  CORPORUM 1 Introduction Ontology is a specification of a representational vocabulary for a shared domain of discourse: definitions of classes, relations, functions, and other objects [ 13 ]or, more generally, a specification of conceptualization [ 14 ]. To solve the problem of heterogeneity in developing software applications, there is a need for specific descriptions of all kinds of concepts, for example, classes (general things), the relationships that can exist among them, and their properties (or attributes) [ 16 ]. Ontologies described syntactically on the basis of languages such as extensible Markup Language (XML), XML Schema (XMLS), Resource Description Frame-work (RDF), and RDF Schema (RDFS) [ 3 ] can be successfully used for this pur-pose.
 for the last few decades. The motto of object-oriented software development may be formulated in different ways, but its essence can be stated simply:  X  X dentify and concentrate on objects in the problem domain description first. Think about the system function later. X  At the initial analysis phase, however, identifying the right objects, which are vital to the system X  X  functionality, seems to be the most difficult task in the whole development process, from both theoretical and practical point of view. Object-oriented software development is well supported by a huge number of working methods, techniques, and tools, except for this starting point X  X bject identification and building the related system object model [ 6 ]. Converting the text description of system problem domain and respective functional requirement specifications into an object model is usually left to the intuition and experience of developers (system analysts). One commonly accepted rule of thumb is,  X  X f an object fits within the context of the system X  X  responsibilities, then include it in the system. X  However, since the members of a development team are likely to have different views on many points, serious communication problems may occur during the later phases of the software development process. Recently there has been great research interest in applying ontologies for solving this  X  X anguage ambiguity problem X  [ 20 ] as either an ontology-driven or ontology-based approach [ 8 ].
 Abstract Data Types (ADTs) [ 4 ]. Any ADT is a named set of attributes, which show the characteristics of and formalize the relationships between objects, and methods (operations, functions) for putting into effect the behavior of objects, making the system functional enough to be of practical use [ 7 ]. Building an ac-curate, correct, and objectively well-defined object model containing objects, rep-resented as ADTs, is the basis for successful development of an object-oriented software system [ 21 , 24 ]. Objects are transformed during the software develop-ment process from  X  X eal things X  to concepts, and finally to ADTs, as shown in Fig. 1 .
 different models, only two of which, namely the Text description model (T-model) and Class (object) model (C-model), are included in the classical object-oriented software development process. The rest of the models represent specific analysis work, which the developers should do in order to get benefit from using ontologies for semiformal identification of objects, which are to be responsible for the system functionality. The paper is structured as follows: Section 2 introduces the models in general and describes the overall procedure for their transformation. Section 3 is dedicated to a more detailed description of the models as well as to discussion on the techniques and tools, which can be practically used for model transformation. An illustrative example of a part of the information system for the domain of academic management is used throughout the paper to support the explanations. Finally, Sect.4 summarizes the proposed procedure and highlights direction for future work. 2 Overview of the procedure Models are inseparable and one of the most significant parts of any methodology. They help developers to better understand complex tasks and represent in a sim-pler way the work they should do to solve those tasks. Object-oriented analysis of a system under development is a good example of such a complex task. The complexity stems from the fact that in object-oriented development everything is based on objects but their identification in a given problem domain is completely left to the intuition of the developer. All that he/she has as a starting point is the text description of the problem domain, which is itself an extended model of the usually very general and ambiguous initial user requirements. Following the ex-isting practice we accept this text description model (T-model) as the available model, which serves as a starting point of our transformation process. According to the object-oriented software development methodology the analysis work on the T-model leads to two major deliverables: functional specification of the sys-tem, expressed as either text or graphically as Use Case diagrams and the class (object) model (C-model).
 This is so because the objects included in the C-model should contain the com-plete information necessary for the next phases of design and implementation of the software system. In other words the objects should be represented as ADTs X  ready for design and implementation software modules [ 5 ]. It is clear now the already mentioned problem with  X  X anguage ambiguity X  X  X ifferent interpretations of the T-model, without any formal support of the choice of participating objects, would lead to creating C-models, which are quite probably inconsistent, incom-plete, or inefficient for the further steps of design and implementation. We believe that using ontology as a tool of conceptualization working on the T-model can make, if not fully formal at least semiformal, the process of creating the C-model and in this way help developers in this complex and imprecise task. This is the major motivation of our work described briefly in this paper.
 transformation process on them. The starting point of the transformation is the T-model, which represents a concise description of the problem domain, where the software system under development will work, written in a natural language, in our case English. If not available the T-model is a deliverable from a system analyst X  X  work on the general user requirements for the system functionality. The presumption is that this problem domain description contains the main objects, which will participate in ensuring that functionality. Of course, at this level the objects are represented by their natural names only and as such are very far from the form we need to reach X  X epresented as ADTs. To help this process we refer to a tool of conceptualization X  X n ontological engine, which applied on the T-model generates an ontological model (O-model) of the problem domain at hand. (objects) in a given domain of interest along with expressed relationships between all or part of them [ 15 ]. The O-model is a straightforward and practically useful source of information for identifying the participating objects. We use this infor-mation to build a so called Full Matrix model (MF-model), which represents in a simple form those objects as well as the linkages (relationships) between them. However, it is worth noting that the processing of the MF-model is semiformal in nature. This means that at this phase the developer should take important de-cisions about which objects could be considered as basic ADTs and which, and where, could play a role of attributes of other ADTs. The idea is simple but not very easy for implementation X  X o reduce the full object matrix to a matrix (we call this model Mr-model), which contains only the basic objects represented later as ADTs containing other ADTs as attributes. The implementation is not very easy because we need more information here, which relates to expected function-ality of participating objects. This information, however, is available or can be extracted from the Use Case model of the system under development. Note that at this phase we can also use the already generated problem domain ontology. Along with showing the concepts hierarchy (possible objects in the system) the ontolo-gies also analyze the verbs linking those concepts, which can be considered as functions (operations) belonging to respective objects.
 functionality of the system by the ontological engine and as a result we get the so called Use Case Ontological model (UO-model). The functionality, expressed by the UO-model, can be used successfully at this particular phase along with the ontological information about the objects in the MF-model to create the Data and Function model (DF-model). As a matter of principle DF-model can be used for each of the objects in the DF-model but this would lead to a high degree of redundancy and quite complicated matrix presentation even for relatively simple T-models. To avoid this, we propose using so called business object patterns. It is important to note that these patterns are not software patterns, they are ontology-based description patterns. The idea is to use ontological libraries existing recently for a great number of application domains and to rely on the ontological descrip-tion of the concepts (objects), which according to the developer X  X  decision have the highest degree of likelihood of being selected as basic objects in the system. This will allow for significant reduction of the number of possible objects in the DF-model, or we can transform it to the Mr-model.
 the C-model, which is actually the goal of this first phase of analysis. The rep-resentation of the C-model is significantly different from the Mr-model however, as far as the former shows not only the object hierarchy but the objects X  struc-ture as well. In other words, the C-model is a model representing ADTs. The last model, the XML-model is optional but can be very important in practice because it allows the C-model to be published on the Web in a unified (XML-based) for-mat supporting the collaborative work, which is a commonly accepted technology nowadays.
 in the transformation procedure replace or ignore the well-known and widely used models applied to the analysis of object-oriented systems? The answer is certainly not. All models, such as the information model, state model, process model, func-tional model, etc., along with their accompanying methods, techniques, and tools (for example, those included in Rational Rose CASE tools) remain absolutely necessary for completing the phase of object-oriented analysis. What we have proposed is a semiformal procedure for converting a text description of a given problem domain into an object model, which should be considered as a basis for further analysis work. 3 The models used In this section we will briefly show the foundation, role, and structure of the mod-els used in the transformation process, explained generally in Sect. 2. In addition, we will show some of the tools, mainly the ontological ones, which can be used for implementing the models. One and the same example X  X  part of a univer-sity information system regarding PhD students X  X s used as an illustration where needed. 3.1 T-model: text description model The T-model or text description of a problem domain model that we were working on is an English text description of a part of a specific problem domain, shown on the left side of Fig. 3 . This text is a natural language description of the system domain, which should include as nouns the major working objects of the system. The purpose of this description is to explain the context in which the problem is placed. This text description is a subject of transformation in the next phase of the procedure X  X enerating the ontological model. 3.2 O-model: ontological model CORPORUM OntoExtract [ 10 ] and more specifically its Web-based (online) ver-sion is a tool for extracting ontologies and representing them in XML/RDF/OIL (default is RDF schema X  X DFS) format [ 10 ]. We use this tool to interpret the text description as ontology described in RDFS format (O-model), which defines the names and relations of the extracted concepts (objects). The result of processing is shown in the right hand box of Fig. 3 .
 of resources to which developers may apply those properties [ 18 ]. Classes are specified with &lt; rdfs:class &gt; . Subclasses and subproperties are specified using &lt; rdfs:subClassOf &gt; and &lt; rdfs:subPropertyOf &gt; (the top class defined in the schema is  X  X esource X ), respectively. When a class is a subclass of several su-perclasses, this is interpreted as a conjunction of superclasses [ 12 ]. CORPORUM OntoExtract basically generates taxonomies that represent classes, subclasses, and instances [ 11 ]. A class described in the text may also be defined as a subclass of the universal  X  X df:resource X  if no more information about the class can be found. A class may also be defined as a subclass of other classes if evidence is found that the class is indeed a subclass. A subclass relationship found by this tool is based on information about the term [ 10 ].
 document-specific light-weight ontology from it. An important category that is exported by the OntoExtract engine is the cross-taxonomic relations expressed by &lt; and identifying the existing relations between objects [ 19 ]. For example, in the box on the right side of Fig. 3 , the class  X  X octoral student X  has certain relations with other classes such as  X  X hesis, X   X  X egree, X   X  X pplication, X  etc. 3.3 MF-model: full matrix model The O-model describes only the type (object) name and provides relations be-tween possible objects. However, this model is in a form difficult to understand and work with identified objects. That is why we use the RDFS description as input to create a simple matrix-based model, which can serve as an intermediate model. In this case the matrix is actually a simple tabular representation of the set of all identified objects approved by the developer.
 set out by rows and columns showing the relationships between objects in the system through simple mapping as shown in Fig. 4 . Generally speaking, we can always define two sets of k and n objects ( k = n in the common case) in a system between elements where relationships exist or can be established. If the objects are numbered differently each X in the table of Fig. 4 represents one of those relationships.
 picted in Fig. 5 to show every relationship that occurs between already identified objects.
 the weight of that particular object. It determines how many relationships one object has to other objects participating in this particular problem domain. One may infer that higher the weight the higher the relevance of that object in the domain or, in other words, the higher is the likelihood that this particular object can be considered as a separate ADT in the software system. Following heuristics from previous experience we can define here some quantitative characteristics of the weight as a parameter, for example, its minimum, from which an object may be considered as a separate one. This can significantly help the developer to identify the basic objects in the system, although his/her decision making is still necessary. This is actually the semiformal nature of the procedure proposed in this paper. 3.4 UO-model: use case ontological model It was mentioned already in the previous section that the information from the MF-model, although useful, is perhaps redundant and certainly far from complete. Thanks to the ontological analysis, the system analyst may have information about the possible objects in terms of names and partially about their attributes (other objects) but has no other information about the system behavior of objects. Obvi-ously, additional information is necessary related to system functionality, in which different objects are involved. Such information is of vital importance for identi-fying the complete contents of objects as data and behavior (objects X  functions, operations), which are fundamental elements of the object model [ 2 ].
 help the system analyst to define more precisely the basic objects in the system, to add new objects, or to remove/replace already identified objects, which are not important for any of the system functions. This is the place where we should turn our attention to the Use Case modeling.
 who/what initiates them, and how the system responds to them. Use cases capture requirements from the perspective of how the actor will actually use the system, in other words each of them describes a given functionality of the system [ 3 ]. The basic tasks the system is required to address are functional requirements, which at the top level of description should relate as closely as possible to valid and mea-surable user requirements. Any Use Case can be represented either graphically (as a Use Case diagram) or as a text description in two forms: concise Use Case de-scription and more detailed functionality description (see Fig. 6 for clarifying the difference between Use Case diagram, Use Case text description, and functional-ity text description). We use the functionality text description in order to apply the same ontology-based procedure for creating the O-model. In this case, however, another ontological engine, VisualText is used as a tool.
 tool for information extraction, natural language processing, and text analysis sys-tems. It makes possible to find out the function within an event or action assigned to particular actors and/or objects in the system. Thus, the goal of UO-model is to analyze the functionality description and as a result to add functions/operations to respective objects.
 well-defined functionality of the system. The ontological analysis of such a func-tionality description helps the system analyst to identify more precisely the real objects, which will play a substantial role in implementing the respective system functions. Obviously, if we have more than one functionality description to ana-lyze, respective objects will be defined for each of them. It becomes easier now for the developer to decide which object should be considered as a separate ADT and which as an element of another ADT. For example, if a new object appears as a result of the ontological analysis of a functionality description but is not identi-fied as a separate object from the O-model, it must be considered as an additional separate object now. Figure 7 illustrates how the two tools OntoExtract and Vi-sualText can help determine which functions are relevant to the working objects in our problem domain description. The figure also shows that it is possible for new relationships to appear between the objects generated by the two tools, which means that they should be formalized in respective new attributes. 3.5 DF-model: data and function model Data (attributes) and functions (methods, operations) are the two fundamental parts of any object, represented as ADT. Each of the models introduced already has its own contribution to creating one or another element of those two parts. However, because of the requirement for decision making this process can still be characterized as subjective or even intuitive. To avoid this situation we can recall the most powerful feature of both object and ontology orientation X  X hey allow for a high degree of reusability of their artifacts in different application domains. The idea is very simple X  X f something is defined already and checked successfully in practice, perhaps with some adjustments, it can be used for another developer X  X  needs. This idea is implemented and used broadly in object-oriented software en-gineering through business objects and related patterns, shown in more detail for example in [ 2 ]. We propose here an extension of this idea introducing the notion of Ontological Business Object Pattern (OBOP). An OBOP is an ontology-based description of a business object that presumably can be included as a working ob-ject in the object-oriented software system. We actually rely on the fact that there are a great number of ontological descriptions of concepts (objects) in different problem domains, existing already [ 17 ] and available from ontology library sys-tems such as WebOnto, Ontolingua, DARPA Agent Markup Language (DAML), SHOE (Simple HTML Ontology Extensions), etc.
 specifically their catalogs of ontologies, which are available in XML, HTML, and DAML formats. Classes are called categories and these categories constitute a simple  X  X s-a X  hierarchy. The relations between instances or between instances and data are allowed to have any number of arguments [ 22 ]. What the developer should do at this phase is to select the suitable ontology for the respective problem do-main. Figure 8 shows an example of how available ontological description for our particular problem domain can be considered as OBOP.
 ject description and this provides a great advantage for software developers. For example, the ontological description shown in the right hand box of Fig. 8 is found in the ontology library [ 23 ] and has a structure, which can be used by the devel-oper directly as not only class hierarchy but as a structured content of respective classes. Therefore, this description can be considered as OBOP. Within this pattern the concept (object)  X  X tudent X  possesses exactly the properties (attributes) neces-sary for the system under development. We can say the same for the root con-cept (object, class)  X  X erson. X  Moreover, in the ontology the attributes themselves are treated as concepts (objects) just like in object orientation, which means that we can use the description of all objects which we are interested in within the class hierarchy. More specifically, the relationships are formalized through the arguments (attributes), which are either types (Atomic ADTs) or categories (ob-jects, classes). If the argument is a category, any subcategory of that category is also valid in the ontology. In addition, the relationship between any two con-cepts (objects) is a commitment and all commitments are specific to objects and phenomena in one particular domain [ 5 ]. Figure 9 shows that if a relationship exists between two concepts (objects), they are both objects in our problem do-main (for example,  X  X akesCourse X  has a relationship with argument1  X  X tudent X  and argument2  X  X ourse, X  which should be considered as working objects). The phenomenon  X  X ge X  is related to argumentl  X  X erson X  and argument2  X  X UMBER X  (type or Atomic ADT), which is different from the first relation ( X  X akesCourse X ), so in this case, we should consider the  X  X ge X  only as an attribute of  X  X erson. X  It is clear, however, that this attribute  X  X ge X  will be valid also for objects  X  X tudent X  and  X  X raduateStudent X  because of the generalization/specialization relationship. 3.6 Mr-model: reduced matrix model In order to emphasize the necessity of this model we will review what information the developer has up to this point working with the models described above: 1. Set of objects in the problem domain PD ={ O 1 ,O 2 ,O 3 , ... ,O a } with their 2. Set of objects FOE ={ O 1 ,O 2 ,O 3 , ... ,O b } with their names and relationships 3. Set of objects FVT ={ O 1 ,O 2 ,O 3 , ... ,O c } with their names, relationships, and 4. Set of objects BOP ={ O 1 ,O 2 ,O 3 , ... ,O d } with their names, relationships Figure 10 shows in graphical form the existing situation. As we can see all objects are within the system problem domain but on one hand their number is still large (this is true even for relatively simple systems) and they are defined from different perspectives (different models are used).
 which will play a substantial role in ensuring the system functionality, will appear in all of the above models regardless of the perspective. This practically means that we can apply a simple integration procedure X  X ntersection of the above sets X  X o identify those objects In Fig. 10 the resulting area is X, or Applying the above procedure the developer has the opportunity to reduce the number of objects, which he/she is interested in, or to transform the MF-model to the reduced matrix model (Mr-model). Along with this, the developer can use another quantitative technique for reducing the number of objects using the al-ready mentioned parameter weight, assigned to each object during the process of creating the MF-model. This technique is based on a simple assumption, which is well supported by our experiments X  X n object with higher weight would play a significant role in the system and, therefore, can be identified as a separate ob-ject (ADT). At this stage of research, to determine the degree of weight as low or high we refer to our experiments, which qualitatively show that the low border is somewhere about 4 or 5 and a value above 10 should be definitely considered as high weight. For objects with low weight, there are two options, either to consider them as complementary objects, which means to be included as attributes or ref-erences in other objects, or to rename and consider them as separate objects. The final decision should be taken by the developer. The resulting Mr-model will look like the matrix shown in Fig. 11 . 3.7 C-model: class (object) model The C-model is the goal of preliminary analysis of object-oriented systems. This is the well-known class hierarchy representation, including some initial but signif-icant relationships for the system functionality contents of objects X  X ata and be-havior (functions, operations). We stress on the word initial here to emphasize the fact that the analysis is far from over yet. The developer should continue applying the conventional analysis models, methods, and techniques on the C-model, which can lead to substantial changes, including adding new objects, deleting some ob-jects, adding or removing some elements of the included objects, etc. The C-model can be represented graphically using different tools such as Rational Rose (class diagrams), textually using either some natural language or pseudo programming language, and finally using some highly structured tag-based language. 3.8 XML-model: XML object model This model is optional but extremely useful for exchanging analysis and design information through the Web for supporting collaborative work. It represents the C-model using the third option mentioned above and, more specifically XML as a language-specification for computer-readable documents or a metalanguage, which can be used as a mechanism for representing other languages in a stan-dardized way [ 18 ]. In our case we use W3C XML Schema, which allows highest flexibility in describing all necessary elements of any object hierarchy on one hand and the details of object model on the other. Figure 12 illustrates a part of the XML-based description of the object  X  X tudent X  or  X  X octoralStudent X  as an ADT. 4Conclusion We believe that merging ontologies with existing methods, techniques, and tools used during the analysis phase of complex object-oriented software systems can contribute significantly to reaching better decisions, with a positive effect on all the subsequent phases of the development process. This paper describes a pro-cedure for supporting the high-level analysis phase of object-oriented software engineering using ontologies for identification of system objects. The procedure transforms eight models, which are introduced and briefly described in the paper. We believe that these models and the process of their transformation can help developers of complex object-oriented software systems to: (a) transform user requirements (represented as text description) into an object model of the sys-tem under development based on the use of ontologies; (b) improve the existing methods and techniques for creating a specific ontology from a text description of the system problem domain, which would serve as a source for identifying the objects and their respective ADTs; (c) work out implementation techniques and tools for semiautomated or automated generating and editing of ADTs for object-oriented application software development, and (d) improve the effectiveness and efficiency of the existing methodology for high-level system analysis in object-oriented software engineering.
 and techniques introduced so far in order to make them a part of CASE. Iden-tification of objects and related ADTs is based on ontology analysis but if for a given problem domain such ontology still does not exist, the developers should be ready to create it themselves including a description of well-selected ontologi-cal business object patterns. In any case we strongly believe that using ontologies has a great potential for analysis and design of complex object-oriented software systems.
 References
