 A feature selection algorithm should ideally satisfy four con-ditions: reliably extract relevant features; be able to iden-tify non-linear feature interactions; scale linearly with the number of features and dimensions; allow the incorpora-tion of known sparsity structure. In this work we propose a novel feature selection algorithm, Gradient Boosted Feature Selection (GBFS), which satisfies all four of these require-ments. The algorithm is flexible, scalable, and surprisingly straight-forward to implement as it is based on a modifi-cation of Gradient Boosted Trees. We evaluate GBFS on several real world data sets and show that it matches or out-performs other state of the art feature selection algorithms. Yet it scales to larger data set sizes and naturally allows for domain-specific side information.
 H.3 [ Information Storage and Retrieval ]: Miscellaneous; I.5.2 [ Pattern Recognition ]: Design Methodology X  Fea-ture evaluation and selection Learning Feature selection; Large-scale; Gradient boosting  X  Work done while at Microsoft Research
Feature selection (FS) [8] is an important problems in ma-chine learning. In many applications, e.g. , bio-informatics [21] or neuroscience [12], researchers hope to gain insight by ana-lyzing how a classifier can predict a label and what features it uses. Moreover, effective feature selection leads to par-simonious classifiers that require less memory [25] and are faster to train and test [5]. It can also reduce feature extrac-tion costs [29, 30] and lead to better generalization [9].
Linear feature selection algorithms such as LARS [7] are highly effective at discovering linear dependencies between features and labels. However, they fail when features in-teract in nonlinear ways. Nonlinear feature selection algo-rithms, such as Random Forest [9] or recently introduced kernel methods [32, 23], can cope with nonlinear interac-tions. But their computational and memory complexity typ-ically grow super-linearly with the training set size. As data sets grow in size, this is increasingly problematic. Balancing the twin goals of scalability and nonlinear feature selection is still an open problem.

In this paper, we focus on the scenario where data sets contain a large number of samples. Specifically, we aim to perform efficient feature selection when the number of data points is much larger than the number of features ( n d ). We start with the (NP-Hard) feature selection problem that also motivated LARS [7] and LASSO [26]. But instead of using a linear classifier and approximating the feature selec-tion cost with an l 1 -norm, we follow [31] and use gradient boosted regression trees [7] for which greedy approximations exist [2].

The resulting algorithm is surprisingly simple yet very ef-fective. We refer to it as Gradient Boosted Feature Selection (GBFS). Following the gradient boosting framework, trees are built with the greedy CART algorithm [2]. Features are selected sparsely following an important change in the im-purity function: splitting on new features is penalized by a cost  X  &gt; 0, whereas re-use of previously selected features incurs no additional penalty.

GBFS has several compelling properties. 1. As it learns an ensemble of regression trees, it can naturally discover nonlinear interactions between features. 2. In contrast to, e.g. , FS with Random Forests, it unifies feature selection and classification into a single optimization. 3. In contrast to existing nonlinear FS algorithms, its time and memory complexity scales as O ( dn ), where d denotes the number of features dimensionality and n the number of data points 1 and is very fast in practice. 4. GBFS can naturally incorpo-rate pre-specified feature cost structures or side-information, e.g. , select bags of features or focus on regions of interest, similar to generalized lasso in linear FS [19].

We evaluate this algorithm on several real-world data sets of varying difficulty and size, and we demonstrate that GBFS tends to match or outperform the accuracy and feature se-lection trade-off of Random Forest Feature Selection, the current state-of-the-art in nonlinear feature selection.
We showcase the ability of GBFS to naturally incorporate side-information about inter-feature dependencies on a real world biological classification task [1]. Here, features are grouped into nine pre-specified bags with biological mean-ing. GBFS can easily adapt to this setting and select entire feature bags. The resulting classifier matches the best accu-racy of competing methods (trained on many features) with only a single bag of features.
One of the most widely used feature selection algorithms is Lasso [26]. It minimizes the squared loss with l larization on the coefficient vector, which encourages sparse solutions. Although scalable to very large data sets, Lasso models only linear correlations between features and labels and cannot discover non-linear feature dependencies. [17] propose the Minimum Redundancy Maximum Rel-evance (mRMR) algorithm, which selects a subset of the most responsive features that have high mutual information with labels. Their objective function also penalizes select-ing redundant features. Though elegant, computing mu-tual information when the number of instance is large is intractable, and thus the algorithm does not scale. HSIC Lasso [32], on the other hand, introduces non-linearity by combining multiple kernel functions that each uses a single feature. The resulting convex optimization problem aligns this kernel with a  X  X erfect X  label kernel. The algorithm re-quires constructing kernel matrices for all features, thus its time and memory complexity scale quadratically with input data set size. Moreover, both algorithms separate feature selection and classification, and require additional time and computation for training classifiers using the selected fea-tures.

Several other works avoid expensive kernel computation while maintaining non-linearity. Grafting [18] combines l and l 0 regularization with a non-linear classifier based on a non-convex variant of the multi-layer perceptron. Fea-ture Selection for Ranking using Boosted Trees [15] selects the top features with the highest relative importance scores. [27] and [9] use Random Forest. Finally, while not a fea-ture selection method, [31] employ Gradient Boosted Trees to learn cascades of classifiers to reduce test-time cost by incorporating feature extraction budgets into the classifier optimization.
Throughout this paper we type vectors in bold ( x i ), scalars in regular math type ( k or C ), sets in cursive ( S ) and ma-
In fact, if the storage of the input data is not counted, the memory complexity of GBFS scales as O ( n ). trices in capital bold ( F ) font. Specific entries in vectors or matrices are scalars and follow the corresponding conven-tion.

The data set consists of input vectors { x 1 ,..., x n }  X  R with corresponding labels { y 1 ,...,y n }  X  Y drawn from an unknown distribution. The labels can be binary, categor-ical (multi-class) or real-valued (regression). For the sake of clarity, we focus on binary classification Y  X  { X  1 , +1 } , although the algorithm can be extended to multi-class and regression as well.
Lasso [26] combines linear classification and l 1 regulariza-tion In its original formulation, ` (  X  ) is defined to be the squared feature selection, other loss functions are possible. In the bi-nary classification setting, where y i  X  X  X  1 , +1 } , we use the better suited log-loss, ` ( x i ,y i , w ) = log(1+exp( y l 1 regularization serves two purposes: It regularizes the classifier against overfitting, and it induces sparsity for fea-ture selection. Unfortunately, these two effects of the l norm are inherently tied and there is no way to regulate the impact of either one. [33] introduce the capped l 1 norm, defined by the element-wise operation Its advantage over the standard l 1 norm is that once a fea-ture is extracted, its use is not penalized further  X  i.e. , it penalizes using many features does not reward small weights. This is a much better approximation of the l 0 norm, which only penalizes feature use without interfering with the mag-nitude of the weights. When is small enough, i.e. ,  X  min i | w i | , we can compute the exact number of features ex-tracted with q ( w ) / . In other words, penalizing q ( w ) is a close proxy for penalizing the number of extracted features. However, the capped l 1 norm is not convex and therefore not easy to optimize.

The capped l 1 norm can be combined with a regular l 1 (or l ) norm, where one can control the trade-off between feature extraction and regularization by adjusting the corresponding regularization parameters,  X , X   X  0: Here q ( w ) denotes [ q ( w 1 ) ,...,q ( w d )].
The classifier in Eq. (3) is better suited for feature selec-tion than plain l 1 regularization. However, it is still linear , which limits the flexibility of the classifer. Standard ap-proaches for incorporating non-linearity include the kernel learning [22] and boosting [3]. HSIC Lasso [32] uses kernel learning to discover non-linear feature interactions at a price of quadratic memory and time complexity. Our method uses boosting, which is much more scalable.
Boosting assumes that one can pre-process the data with limited-depth regression trees. Let H be the set of all pos-sible regression trees. Taking into account limited precision and counting trees that obtain identical values on the entire training set as one and the same tree, one can assume |H| to be finite (albeit possibly large). Assuming that inputs are mapped into R |H| through  X  ( x ) = [ h 1 ( x ) ,...,h |H| propose to learn a linear classifier in this transformed space. Eq. (3) becomes Here,  X  is a sparse linear vector that selects trees. Although it is extremely high dimensional, the optimization in Eq. (4) is tractable because  X  is extremely sparse. Assuming, with-out loss of generalization, that the trees in H are sorted so that the first T entries of  X  are non-zero, we obtain a final classifier
Eq. (4) has two penalty terms: plain l 1 norm and capped l norm. The first penalty term reduces overfitting while the second selects features. However, in its current form, the capped l 1 norm selects trees rather than features. We therefore have to modify our setup to explicitly penalize the extraction of features.

To model the total number of features extracted by an ensemble of trees, we define a binary matrix F  X  X  0 , 1 } where an entry F ft = 1 if and only if the tree h t uses fea-ture f . With this notation, we can express the total weight assigned to trees that extract feature f as We modify q (  X  ) to instead penalize the actual weight as-signed to features . The final optimization becomes As before, if is sufficiently small (  X  min f | P T t =1 F we can set  X  = 1 / and the feature selection penalty coin-cides exactly with the number of features used.
The optimization problem in Eq. (7) is non-convex and non-differentiable. Nevertheless, we can minimize it effec-tively (up to a local fixed point) with gradient boosting [7]. Let L (  X  ) denote the loss function to be minimized and  X  X  (  X  ) the gradient w.r.t  X  t . Gradient boosting can be viewed as coordinate descent where we update the dimension with the steepest gradient at every step. We can assume that the set of all regression trees H is negation closed, i.e. , for each h  X  H , we also have  X  h  X  H . This allows us to only fol-low negative gradients and always increase  X  . Thus there is always a non-negative optimal  X  . The search for the dimen-sions t  X  with the steepest negative gradient can be formal-ized as In the remainder of this section we discuss approximate min-imization strategies that does not require iterating over all possible trees. l
Since each step of the optimization increases a single di-mension of  X  with a fixed step-size  X  &gt; 0, the l 1 norm of  X  can be written in closed form as |  X  | 1 =  X T after T iterations. This means that penalizing the l 1 norm of  X  is equivalent to early stopping after T iterations [7]. We therefore drop the  X  |  X  | 1 term and instead introduce T as an equivalent hyper-parameter.

To find the steepest descent direction at iteration T 0 +1, we decompose the (sub-)gradient into two parts, one for the loss function ` (), and one for the capped l 1 norm penalty (Hereafter we drop the absolute value around F ft  X  t , since both F ft and  X  t are non-negative.) The gradient of q ( P is not well-defined at the cusp when P t F ft  X  t = . But we can take the right-hand limit, since  X  t never decreases, If we set =  X  , where  X &gt; 0 is the step size, then P t F if and only if feature f has already been used in a tree from a previous iteration. Let  X  f = 1 indicate that feature f is still unused , and  X  f = 0 otherwise. With this notation we can combine the gradients from the two cases and replace Note that  X  f F ft = 1 if and only if feature f is extracted for the first time in tree t . In other words, the second term effectively penalizes trees that use many new (previously not selected) features.

With Eq. (11) we can compute the gradient with respect to any tree. But finding the optimal t  X  would still require searching all trees. In the remainder of this section, we transform the search for t  X  from a search over all possible dimensions t to a search for the best tree h t to minimize a pre-specified loss function. The new search can be approxi-mated with the CART algorithm [2].

To this end, we apply the chain rule and decompose  X  X   X  X  into the derivative of the loss ` w.r.t. the current prediction evaluated at each input H ( x i ) and the partial derivative Algorithm 1 GBFS in pseudo-code. 1: Input: data { x i ,y i } , learning rate , iterations T . 2: Initialize predictions H = 0 and selected feature set  X  = 3: for t = 1 to T do 4: Learn h t using greedy CART to minimize the impurity 5: Update H = H + h t . 6: For each feature f used in h t , set  X  f = 0 and  X  = 7: end for 8: Return H and  X . Note that H ( x i ) =  X  &gt; h ( x i ) is just a linear sum of all h the predictions over training data. Thus  X  X  ( x i )  X  X  we let g i denote the negative gradient g i =  X   X  X   X  X  ( x reformulate Eq. (12) as Similar to [3], we restrict H to only normalized trees (i.e. P
P i h 2 t ( x i ) and 1 2 P i g 2 i to eq. (13), and complete the bi-nomial equation. This is now a penalized squared loss X  X n impurity func-tion  X  X nd a good solutions can be found efficiently via the greedy CART algorithm for learning regression trees [7]. The first term in Eq. (14) encourages feature splits to best match the negative gradient of the loss function, and the sec-ond term rewards splitting on features which have already been used in previous iterations. Algorithm 1 summarizes the overall algorithm in pseudo-code.
In many feature selection applications, one may have addi-tional qualitative knowledge about acceptable sparsity pat-terns. Sometimes features can be grouped into bags and the goal is to select as few bags as possible. Prior work on handling structured sparsity include group lasso [10, 20] and generalized lasso [19]. Our framework can easily handle structured sparsity via the feature cost identity function  X  For example, we can define  X  f = 1 if and only if no fea-ture from the same bag as f has been used in the past, and  X  f = 0 otherwise. The moment a feature from a particular bag is used in a tree, all other features in the same bag be-come  X  X ree X  and the classifier is encouraged to use features from this bag exclusively until it starts to see diminishing returns.

In the most general setting, we can define  X  f :  X   X  X  + 0 as a function that maps from the set of previously extracted features to a cost. For example, one could imagine settings Figure 1: Feature selection and classification per-formance on a simulated data set. GBFS clearly out-performs the l 1 regularized logistic regression as it successfully captures the nonlinear relations be-tween labels and features. where feature extraction appears in stages. Extracting fea-ture f makes feature g cheaper, but not free. One such ap-plication might be that of classifying medical images (e.g., MRI scans) where the features are raw pixels and feature groups are local regions of interest. In this case,  X  f ( X ) may reduce the  X  X rice X  of pixels surrounding those in  X  to en-courage feature selection with local focus.
In this section, we evaluate GBFS against other state-of-the-art feature selection methods on synthetic as well as real-world benchmark data sets. We also examine at its capacity for dealing with known sparsity patterns in a bioinformatics application. All experiments were conducted on a desktop with dual 6-core Intel i7 cpus with 2.66GHz, 96 GB RAM, and Linux version 2.6.32.x86 64.
Figure 1 illustrates a synthetic binary classification data set with three features. The data is not linearly separable in either two dimensions or three dimensions. However, a good nonlinear classifier can easily separate the data using x and y . The z feature is simply a linear combination of x and y and thus redundant. We randomly select 90% of the instances for training and the rest for testing.

Figure 1 (left panel) illustrates results from l 1 -regularized logistic regression (L1-LR) [11, 16]. The regularization pa-rameter is tuned on a hold-out set. Although L1-LR suc-cessfully detects and ignores the redundant feature z , it also assigns zero weight to x and only selects a single feature y . Consequently, it has poor classification error rate on the test set (54 . 05%). In contrast, GBFS (Figure 1, right panel) not only identifies the redundant feature z , but also detects that the labels are related to a nonlinear combination of x,y . It selects both x and y and successfully separates the data, achieving 0% classification error.
In many applications there may be prior constraints on the sparsity patterns. Since GBFS can naturally incorpo-rate pre-specified feature structures, we use it to perform Figure 2: Feature selection on structured feature data set. Selected features are colored in green, and unselected are in blue. The bag is highlighted with a red/white box if at least one of its features is selected by the classifier. (Some bags may require zooming in to make the selected features visible.) structured feature selection on the Colon data set 2 . In this dataset, 40 tumor and 22 normal colon tissues for 6500 hu-man genes are measured using affymetrix gene chips. [1] select 2000 genes that have the highest minimal intensity across the samples. [13] further analyze these genes and cluster them into 9 clusters/bags by their biological mean-ing. The task is to classify whether a tissue is normal or tumor. We random split the 62 tissues into 80/20 training and testing datasets, repeated over 10 random splits. We use the feature-bag cost function  X  f mentioned in section 4.2 to incorporate this side-information (setting the cost of all fea-tures in a bag to zero once the first feature is extracted). Feature selection without considering these bag information
Available through the Princeton University gene expression project (http://microarray.princeton.edu/oncology/) not only performs and generalizes poorly, but are also diffi-cult to interpret and justify.

Figure 2 shows the selected features from one random split and classification results averaged over 10 splits. Selected features are colored in green, and unselected ones are in blue. A bag is highlighted with a red/white box if at least one of its features is selected by the classifier. We compare against l -regularized logistic regression (L1-LR) [11, 16], Random Forest feature selection (RF-FS) [9], HSIC Lasso [32] and Group Lasso [14].

As shown in Figure 2, because GBFS can incorporate the bag structures, it focusses on selecting features in one specific bag. Throughout training, it only selects features from bag 8 (highlighted with a red/white box). This con-veniently reveals the association between diseases and gene clusters/bags. Similar to GBFS, Group Lasso with logistic regression can also deal with structured features. However, its l 2 regularization has side effects on feature weights, and thus results in much higher classification error rate 36 . 15%. In contrast, l 1 -regularized logistic regression, Random For-est and HSIC Lasso do not take bag information into consid-eration. They select scattered features from different bags, making results difficult to interpret. In terms of classifi-cation accuracy, GBFS and Random Forest has the lowest test set error rate (15 . 38%), whereas l 1 -regularized logistic regression (L1-LR) and HSIC Lasso achieve error rates of 17 . 69% and 21 . 85%, respectively.

There are two reason why GBFS can be accurate with features from only a single bag. First, it is indeed the case that the genes in bag 8 are very predictive for the task of whether the tissue is malignant or benign (a result that may be of high biological value). Second, GBFS does not penalize further feature extraction inside bag 8 while other methods do; since bag 8 features are the most predictive, penalizing against them leads to a worse classifier.
We evaluate GBFS on real-world benchmark data sets of varying sizes, domains and levels of difficulty. Table 1 lists data set statistics ordered by increasing numbers of train-ing instances. We focus on data sets with a large number of training examples ( n d ). All tasks are binary classi-fication, though GBFS naturally extends to the regression setting, so long as the loss function is differentiable and con-tinuous. Multi-class classification problems can be reduced to binary ones, either by selecting the two classes that are most easily confused or (if those are not known) by grouping labels into two sets.
 The first baseline is l 1 -regularized logistic regression (L1-LR) [11, 16]. We vary the regularization parameter to se-lect different numbers of features and examine the test error rates under each setting.

We also compare against Random Forest feature selection (RF-FS) [9], a non-linear classification and feature selection algorithm. The learner builds many full decision trees by bagging training instances over random subsets of features. Features selection is done by ranking features based on their impurity improvement score, aggregated over all trees and all splits. Features with larger impurity improvements are to medium sized data sets. considered more important. For each data set, we train a Random Forest with 2000 trees and a maximum number of 20 elements per leaf node. After training all 2000 trees, we rank all features. Starting from top of the list, we re-train a random forest with only the top-k features and evaluate its accuracy on the test set. We increase the number of selected features until all features are included.
 The next state-of-the-art baseline is Minimum Redundancy Maximum Relevance (mRMR) [17], a non-linear feature se-lection algorithm that ranks features based on their mutual information with the labels. Again, we increase the selected feature set starting from the top of the list. At each stopping point, we train an RBF kernel SVM using only the features selected so far. The hyper-parameters are tuned on on 5 different random 80/20 splits of the training data. The final reported test error rates are based on the SVM trained on the full training set with the best hyper-parameter setting.
Finally, we compare against HSIC Lasso [32], a convex extension to Greedy HSIC [23]. HSIC Lasso builds a kernel matrix for each feature and combines them to best match an ideal kernel generated from the labels. It encourages feature sparsity via an l 1 penalty on the linear combination coeffi-cients. Similar to l 1 -regularized logistic regression, we eval-uate a wide range of l 1 regularization parameters to sweep out the entire feature selection curve. Since HSIC Lasso is a two steps algorithm, we train a kernel SVM with the selected features to perform classification. Similar to the mRMR ex-periment, we use cross-validation to select hyper-parameters and average over 5 runs.

To evaluate GBFS, we perform 5 random 80/20 train-ing/validation splits. We use the validation set to choose the depth of the regression trees and the number of itera-tions (maximum iterations is set to 2000). The learning rate is set to = 0 . 1 for all data sets. In order to show the whole error rates curve, we evaluate the algorithm at 10 values for the feature selection trade-off parameter  X  in Eq. (7) (i.e.,
Figure 3 shows the feature selection and classification per-formance of different algorithms on small and medium sized data sets. We select up to 100 features except for spam ( d = 57) and pcmac ( d = 3289). In general, l 1 -regularized logistic regression (L1-LR), Random Forest (RF-FS) and GBFS easily scale to all data sets. RF-FS and GBFS both clearly out perform L1-LR in accuracy on all data sets due to their ability to capture nonlinear feature-label relation-ships. HSIC Lasso is very sensitive to the data size (both the number of training instance and the number of features), and only scales to two small data sets ( uspst,spam ). mRMR is even more restrictive (more sensitive to the number of training instance) and thus only works for uspst . Both of them run out of memory on pcmac , which has the largest number of features. In terms of accuracy, GBFS clearly out-Figure 4: Feature selection and classification error rates (in %) for different algorithms on the large kddcup99 data set. Figure 5: Error rates (in %) of SVM-RBF trained on various feature subset obtained with different fea-tures selection algorithms. performs HSIC Lasso on spam but performs slightly worse on uspst . On all small and medium datasets, GBFS either out-performs RF-FS or matches its classification performance. However, very different from RF-FS, GBFS is a one step approach that selects features and learns a classifier at the same time, whereas RF-FS requires re-training a classifier af-ter feature selection. This means that GBFS is much faster to train than RF-FS.

The last dataset in Table 1 ( kddcup99 ) contains close to 5 million training instances. Training on such large data sets can be very time-consuming. We limit GBFS to T = 500 trees with the default hyper-parameters of tree depth = 4 and learning rate = 0.1. Training Random Forest with de-fault hyper-parameters would take more than a week. There-Figure 6: Classification error rates (in %) vs. feature selection performance for different algorithms on a high dimensional ( d n ) data set. fore, we limit the number of trees to 100 and the maximum number of instances per leaf node to 500. Feature selection and classification results are shown in Figure 4. For GBFS, instead of plotting the best performing results for each  X  , we plot the whole feature selection iteration curve for multiple values of  X  . GBFS obtains lower error rates than Random Forest (RF-FS) and l 1 regularized logistic regression (L1-LR) when few features are selected. (Note that due to the extremely large data set size, even improvements of &lt; 1% are considered significant.)
To evaluate the quality of the selected features, we sepa-rate the contribution of the feature selection from the effect of using different classifiers. We apply all algorithms on the smallest data set ( uspst ) to select a subset of the features and then train a SVM with RBF kernel on the respective feature subset. Figure 5 shows the error rates as a function of the number of selected features. GBFS obtains the lowest error rates in the (most interesting) regions of only few se-lected features. As more features are selected eventually all FS algorithms converge to similar values. It is worth noting that the linear classifier (L1-LR) slightly outperforms most nonlinear methods when given enough features, which sug-gests that the uspst digits data requires a nonlinear classifier for prediction but not for feature discovery. d n scenario.

While GBFS focusses on the scenario where the number of training data points is much larger than the number of features ( n d ), we also evaluate GBFS on a traditional feature selection benchmark data set SMK-CAN-187 [24], which is publicly available from [34]. This binary classifi-cation data set contains 187 data points and 19 , 993 fea-tures. We average results over 5 random 80 / 20 train-test splits. Figure 6 compares the results. GBFS out-performs l -regularized logistic regression (L1-LR), HSIC-Lasso and Random Forest feature selection (RF-FS), though by a small margin in some regions.
Not surprisingly, the linear method (L1-LR) is the fastest by far. Both mRMR and HSIC Lasso take significantly more time than Random Forest and GBFS because they involve either mutual information or kernel matrix computation, which scales as O ( d 2 ) or O ( n 2 ). Random Forest builds full trees, requiring a time complexity of O ( The dependency on of trees required for Random Forests is also dependent on the number of features and scales as O ( trast, GBFS only builds limited depth (depth = 4 , 5) trees, and the computation time complexity is O ( dn ). The num-ber of iterations T is independent of the number of input features d ; it is only a function of how the number of desired features. Empirically, we observe that the two algorithms are comparable in speed but GBFS is significantly faster on data sets with many instances (large n ). The training time ranged from several seconds to minutes on the small data sets to about one hour on the large data set kddcup99 (when Random Forest is trained with only 500 trees and large leaf sizes). Admittedly, the empirical comparison of training time is slightly problematic because our Random Forest implementation is based on highly optimized C++ code, whereas GBFS is implemented in Matlab TM . We ex-pect that GBFS could be made significantly faster if im-plemented in faster programming languages ( e.g. C++) with the incorporation of known parallelization techniques for limited depth trees [28].
This paper introduces GBFS, a novel algorithm for non-linear feature selection. The algorithm quickly train very accurate classifiers while selecting high quality features. In contrast to most prior work, GBFS is based on a variation of gradient boosting of limited depth trees [7]. This ap-proach has several advantages. It scales naturally to large data sets and it combines learning a powerful classifier and performing feature selection into a single step. It can easily incorporate known feature dependencies, a common setting in biomedical applications [1], medical imaging [6] and com-puter vision [4]. This has the potential to unlock interesting new discoveries in a variety of application domains. From a practitioners perspective, it is now worth investigating if a data set has inter-feature dependencies that could be pro-vided as additional side-information to the algorithm.
One bottleneck of GBFS is that it explores features us-ing the CART algorithm, which has a complexity of O ( dn ). This may become a problem in cases with millions of fea-tures. Although this paper primarily focusses on the n d scenario, as future work we plan to consider improving the scalability with respect to d . One promising approach is to restrict the search to a random subsets of new features, akin to Random Forest. However, in contrast to Random Forest, the iterative nature of GBFS allows us to bias the sampling probability of a feature by its splitting value from previous iterations X  X hus avoiding unnecessary selection of unimportant features.

We are excited by the promising results of GBFS and believe that the use of gradient boosted trees for feature se-lection will lead to many interesting follow-up results. This will hopefully spark new algorithmic developments and im-proved feature discovery across application domains. KQW was supported by NSF grants 1149882 and 1137211. KQW and ZEX were supported by NSF IIS-1149882 and IIS-1137211. Part of this work was done while ZEX was an intern at Microsoft Research, Redmond. [1] U. Alon, N. Barkai, D. A. Notterman, K. Gish, [2] L. Breiman. Classification and regression trees . [3] O. Chapelle, P. Shivaswamy, S. Vadrevu, [4] N. Dalal and B. Triggs. Histograms of oriented [5] J. Duchi, S. Shalev-Shwartz, Y. Singer, and [6] J. A. Etzel, V. Gazzola, and C. Keysers. An [7] J. Friedman. Greedy function approximation: A [8] I. Guyon and A. Elisseeff. An introduction to variable [9] T. Hastie, R. Tibshirani, and J. H. Friedman. The [10] J. Huang, T. Zhang, and D. Metaxas. Learning with [11] S. Lee, H. Lee, P. Abbeel, and A. Y. Ng. Efficient l1 [12] Y. Liu, M. Sharma, C. Gaona, J. Breshears, J. Roland, [13] S. Ma, X. Song, and J. Huang. Supervised group lasso [14] L. Meier, S. Van De Geer, and P. B  X  uhlmann. The [15] F. Pan, T. Converse, D. Ahn, F. Salvetti, and [16] M. Y. Park and T. Hastie. L1-regularization path [17] H. Peng, F. Long, and C. Ding. Feature selection [18] S. Perkins, K. Lacker, and J. Theiler. Grafting: Fast, [19] V. Roth. The generalized lasso. Neural Networks, [20] V. Roth and B. Fischer. The group-lasso for [21] Y. Saeys, I. Inza, and P. Larra  X naga. A review of [22] B. Sch  X  olkopf and A. Smola. Learning with kernels: [23] L. Song, A. Smola, A. Gretton, J. Bedo, and [24] A. Spira, J. E. Beane, V. Shah, K. Steiling, G. Liu, [25] S. Sra. Fast projections onto l 1, q -norm balls for [26] R. Tibshirani. Regression shrinkage and selection via [27] E. Tuv, A. Borisov, G. Runger, and K. Torkkola. [28] S. Tyree, K. Weinberger, K. Agrawal, and J. Paykin. [29] Z. Xu, M. K., M. Chen, and K. Q. Weinberger.
 [30] Z. Xu, M. Kusner, G. Huang, and K. Q. Weinberger. [31] Z. Xu, K. Weinberger, and O. Chapelle. The greedy [32] M. Yamada, W. Jitkrittum, L. Sigal, E. P. Xing, and [33] T. Zhang. Multi-stage convex relaxation for learning [34] Z. Zhao, F. Morstatter, S. Sharma, S. Alelyani,
We further extend our experimental results by incorpo-rating more one-vs-one pairs from MNIST data set. We randomly pick 6 one-vs-one pairs from MNIST and evaluate GBFS and other feature selection algorithms. The first base-line is l 1 -regularized logistic regression (L1-LR). We vary the regularization parameter to select different number of features and examine the error rates under these different settings. We also compare against Random Forest feature se-lection [9]. Same to the procedure described in section 5, we run Random Forest with 2000 trees and a maximum number of 20 elements per leaf node. After training all 2000 trees, we rank all features. Starting from the most important fea-ture, we re-train a random forest with only selected features and evaluate it on testing set. We gradually include less important features until we include all features. The other two baselines (include mRMR, HSIC-Lasso) do not scale on the MNIST data set.

Figure 7 indicates that GBFS consistently matches Ran-dom Forest FS, and clearly out-performs l 1 -regularized lo-gistic regression. chosen pairs of binary classification tasks from MNIST data set.
