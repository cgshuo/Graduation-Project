 The University Of Manchester, School Of Informatics, U.K. The University Of Manchester, School Of Informatics, U.K. Data mining and its capacity to d eal with large volumes of data and to uncover hidden patterns has been proposed as a means to support industrial scale software ma intenance and comprehension. This paper presents a methodology for knowledge acquisition from source code in order to comprehend an object-oriented system and evaluate its maintainability. We employ clustering in order to support semi-automated software maintenance and comprehension. A model and an associated process are provided, in order to extract elements from source code; K-Means clustering is then applied on these data, in order to produce system overviews and deductions. The methodology is evaluated on JBoss , a very large Open Source Application Server; results are discussed and conclusions are presented together with directions for future work . Code mining, clustering, soft ware maintenance, program comprehension, metrics, maintainability. Software maintenance is considered a very important and complex stage in software lifecycle typically consuming 50-70% of the total effort allocated to a software system [14], [17]. According to Sutherland [19], US companies spent more than $70 billion annually on software maintenance. There are several studies for evaluating a system X  X  maintainability and controlling the effort required to carry out maintenance activities [1], [3], [20]. Additionally program comprehension is an important part of this stage, especially when program structure is complex, modularity has deteriorated and the documentation is not up to date. 50-90% of maintainers X  time is reported to be spent on program comprehension [21] .
 The aim of this work is to f acilitate maintenance engineers to comprehend the structure of a software system and assess its maintainability. For this reason elements from source code are collected, including:  X  Attributes that describe the entities (such class name,  X  Metrics used as additional attribut es that facilitate the software Our research objectives include: the definition of an input data model, the population of a databa se containing data extracted from source code, the application of clustering on the database and the evaluation of results a nd the usefulness of mining data from source code. For this purpos e we used a large open source software system used in industr ial real life applications: the JBoss Open Source Application Server, version 4.0.3SP1 [24]. Results have shown that clustering data extracted from source code and software metrics can uncover a lo t of useful information about various aspects of software systems. The remaining of this paper is organized as follows: Section 2 reviews existing work in the area of data mining for program comprehension and maintainability evaluation. Section 3 outlines the proposed method for extracting metrics and elements from Java source code, the input data model and the clustering method. Section 4 assesses the accuracy of the output of the proposed framework, analyses its results and outlines deductions from its application. Finally, conclusions and directions for future work are presented in Section 5. Developing software systems of an y size which do not need to be changed is unattainable [17]. Such systems, once in use, need to their mission, as new require ments emerge. Consequently, software systems remain subject to changes and maintenance throughout their lifetime. Program comprehension is required by maintenance engineers in order to identify problematic files or modules; and to assess their maintainability [14]. Data mining and its ability to deal with vast amounts of data, has been considered a suitable solution in assisting software maintenance, often resulting in remarkable results [12], [22], [23], [24]. Data mining techniques have been used previously, for identification of subsystems based on associations (ISA methodology) [12]. This approach provides a system abstraction up to the program level as it produces a decomposition of a system into data cohesive subsys tems by detecting associations between programs sharing the same files. Clustering has also been used to support software maintenance and systems knowledge discovery . A method for grouping Java code elements together according to their similarity was proposed in [15]. It focuses on achieving a high level system understanding. The method derives system struct ure and interrelationships, as well as similarities among syst ems components, by applying cluster analysis on data extracted from source code. Hierarchical Agglomerative Clustering was employed to reveal similarities between classes and other code el ements thus facilitating software maintenance and Java program comprehension. An approach for the evaluation of dynamic clustering was presented in [23]. The scope of this solution was to evaluate the usefulness of providing dynami c dependencies as input to software clustering algorithms. This method was applied to Mozilla , a large open source software system with more than four million lines of C/C++. All these approaches employ data mining techniques only to recover the structure of a software system. On the other hand [24] is employing clustering for pred icting software modules X  fault proneness and potential noisy m odules. K-Means and Neural  X  Gas algorithms were employed in order to group together modules with similar software measurements. A software engineering expert inspected the derived clus ters and labelled them as fault prone or not. The value of our work that differentiates it from what presented above, is that we employ da ta mining techniques for both recovering the structure of a software artifact and assessing its maintainability. We do that by creating an input model which Chidamber and Kemerer metrics suite [5]) and elements from source code data (e.g. class name , method name, superclass etc.). This is presented in  X 3.2. This section presents the pr oposed framework for extracting metrics and elements from Java s ource code, the input data model and the clustering method. In order to evaluate if and how mining elements from source code can facilitate software system comprehension and maintainability evaluation, we required a softwa re system with the following required properties:  X  Its size must be considerable, in order for clustering to be  X  Its source code must be publicly available.  X  It should be Object Oriented as this paradigm is becoming  X  It should be used extensively. Many open source systems have mo st of these properties; fewer have the last one. We selected JBoss as a test bed for this research work, as it does have these properties [24]. Input model definition requires the specification of program entities and their attributes, which should be suitable for clustering. Clustering imposes requirements on the type and number of attributes, the lack of distinction between predictive and predicted attributes and so on [7], [9]. Moreover entities need to contain a common set of attributes in order to achieve homogeneity; this allows for entities X  comparison on the basis of their attributes, which is the main principle of clustering. The number of selected attributes needs also to be sufficient in order to avoid misl eading comparisons or discovering accidental similarities. Selected attributes are both binary and qualitative, as they are predominan t in a source code application domain [4]. The schema in Fig. 1 outlines the proposed input model in terms of entities and their respective attributes. Each entity is described by attributes thus formulating database tables. The proposed input m odel consists of:  X  Attributes that describe the selected entities (class name, Metrics which are considered as attributes that further describe an OO program X  X  entities. More specifically and as depicted in  X 3.4 we further describe the sel ected metrics and we justify why we think they are important in facilitating a maintenance engineer to comprehend and evaluate a system X  X  maintainability. Source code representation in an abstract way is a key research topic [2]. Representing source c ode in an xml format can be useful for the following reasons:  X  XML is a strict, well defined format that can be manipulated  X  An XML representation could al so be abstract, independent The scope of the proposed extraction process is to parse javaml xml files and extract elements and metrics from java code. The current version stores information like class name, package of the class, constructor names and th eir arguments, method names and arguments etc as depicted in Fig. 1. This information is subsequently stored in a relationa l database so that the Clustering Data Mining technique can be applied. According to Lehman [10] as software demonstrates regular behaviour and trends, these can be measured. Software evolution and maintenance require the collection of such metrics. This enables maintenance engineers to track status, control costs, and make decisions related to their maintenance tasks. These metrics maintainability and identifying potential problematic areas [13], [16]. We have to emphasise at this point that metrics can be used only as indicators for a system X  X  maintainability, as this is a complex and largely subjective software attribute. For this work we decided to employ the Chidamber and Kemerer metrics suite [5], as it can be applied to OO programs and can be used as a predictor and evaluator of maintenance effort according to [11]. More specifically we c hose the following subset of this metrics suite:  X  Weighted Methods per Class (WMC) , which is simply the sum  X  Coupling between Objects  X  Efferent Coupling (CBO) , which  X  Number of Children (NOC) , which measures the number of  X  Depth of Inheritance Tree (DIT) , which provides for each  X  Afferent (inward) Coupling (Ca) , which measures the number  X  Number of Public Methods (NPM) , which counts all the Those selected metrics are used as additional attributes in order to further describe the Classes entity. At first the maintenance engineer needs a quick and rough grasp of a software system in order to maintain it with a level of confidence as if he/she had this familiarity. Clustering is more suitable for this purpose as it pr oduces overviews of systems by creating mutually exclusive groups of classes, member data or methods, according to their similarities and hence reduces the time required to understand the overall system. Another contribution of this method is that it helps discovering programming patterns and  X  X nusual X  or outlier cases which may require attention. popularity is largely due to its simplicity and low-time complexity. The input parameters we used for this algorithm are presented in Table 1.
 Input Dataset [D] The dataset used.
 Max. No of Clusters [C] 
Similarity threshold [S] Accuracy Improvement [A] The proposed framework was evaluated in terms of ability to capture knowledge relevant to so ftware maintenance activities, using the JBoss Open Source Application Server. The following sub-sections discuss separately the outcomes of our empirical experimentation with this application. Before describing the experimental application of our framework experimental setup. The core idea was to extract elements and metrics from JBoss Open Source Application Server X  X  source code and store these data in a database. The outcome of this step gave us the ability to: 1. Apply K-Means Clustering to the classes of JBoss based on 2. Apply K-Means Clustering to the classes of JBoss based on 3. As soon as the clusters are fo rmed, the maintenance engineer 
Input Dataset [D] A flat file containing records describing 
Max. Passes [P] The chosen valu e is 2, as we wanted to Max. No of Clusters [C] 
Similarity threshold [S] Accuracy Improvement [A] JBoss is a free J2EE certified application server, and is one of the most widely used open source prof essional software [25]. Table 3 shows the statistics concerning its size. JBoss is built on a modular architecture on top of the JMX (Java Management Extension) infrastru cture, which is a reusable framework that can expose applications to remote or local management tools. The major JBoss modules are manageable MBeans connected by the MBean server and are illustrated in Fig. 2. One of the main goals of this work was to provide the maintenance engineer a quick and rough grasp of a software system in order to maintain it with a level of confidence as if he/she had this familiarity. That reduces the required time to comprehend a system X  X  structure. For this reason, we started our experiment by clustering JBoss X  classes based on attributes like the package they belong to and their respective superclasses. Fig. 3 depicts the formed clusters of the classes of JBoss based on these attributes. In the X axis are the ids of the formed clusters while on the Y axis highest population are 2, 3, 6, 7, 8 while 0, 4, 5 represent a small part of the system. Based on Fi g. 2 the parameter C (Maximum Number of Clusters) was set to 9 as we did not want to search for outliers but to give an overview of JBoss X  main structure. Table 4 presents the formed clusters, and the predominant packages they are included in each cluster. The first cluster (0) consists of packages defined by the JMX specification. javax.management and org.jboss.mx are related with MBeans which are Java objects that implement the standard MBean Interface. Another interesting cluster is the third one which consists of packages related to the Aspect Oriented Programming support that JBoss provides for AO middleware. Cluster 2 also consists of classe s belonging to packages that are related to the administration of entity bean classes. More specifically org.jboss.console provides a simple web org.jboss.ejb3 is the most basic package for an EJB (Enterprise Java Beans) implementation. Cluster Fig. 4 depicts clusters formed of JBoss classes, based on their complexity. By examining these clusters, a maintenance engineer can identify classes with excepti onal values and then examine them closely and consider refact oring to improve their design. More specifically, the X axis s hows the cluster IDs while the Y axis shows WMC attribute values. The 14th, 12th and 22nd clusters (7% of the whole populati on) are formed by classes that exhibit high WMC values. In pr actice, these classes may be org.jboss.axis.message.SOAPElementAxisImpl class, declares 141 methods in a 2100 lines java file. This class implements the base type of node s of a SOAP message parse tree. Although such a size would usually imply low maintainability of a class, the purpose of this specific class (to represent a soap message) could justify its size. The common characteristics of the classes that exhibit high WMC values are:  X  Their methods return types are not primitive. Most of them are  X  Most of them belong to the jboss.org.axis On the other hand there are clusters like 3, 8 and 20 (25% of the whole population) that are formed by classes with very low WMC value. The common characteristic between these classes is that most of their methods return types are primitives like Boolean, long, int or void. Another interes ting observation is that there are a significant number of classes having low WMC values that belong to the Aspect Oriented Programming package ( org.jboss.aop.deployment ). Fig. 5 depicts the formed clusters of the classes of JBoss based on their coupling. The 15th, 17th, 20th and 23rd (2.4% of the whole population) are formed by classes having high CBO values. In practice these classes may be difficult to maintain and reuse as a change in a class may affect the classes it is coupled to. Inspecting the code for these classes a maintenance engineer can find out more. For example there is on the 20th cluster a class named EJBQLToSQL92Compiler , which implements QLCompiler and JBossQLParserVisitor interfaces and compiles EJB-QL and JBossQL into SQL using OUTER and INNER joins. It is a class of 1546 lines of code; has 84 couplings, and there are tens of methods like the following: public Object visit(ASTStringLiteral node, Object data) { StringBuffer buf = (StringBuffer) data; buf.append(node.value); return data; } EJBQLToSQL92Compiler are:  X  Their methods return types are not primitive. Most of them are  X  Most of them belong to On the other hand there are clusters like 3 and 4, formed by classes with very low CBO value. Most of them belong to the org.jboss.aop.deployment, javax.management, org.jboss.mx and org.jboss.mq packages. Fig. 6 depicts the formed clusters of the classes of JBoss based on their number of children (NOC) a ttribute. Most of the classes (68.08% of the whole population) have no children, while another 30% have 1, 2 or 3 children. whole population) that contain cla sses with more than 8 children. In the 8 th cluster a class named ServiceMBeanSupport has 152 children was discovered. Th is class is a warning for a maintenance engineer to inspect for subclassing misuse as it has an abnormally number of children. The common characteristic of the methods that belong to the classe s of clusters 6, 7 and 8 is that their return types are not primitive. Most of them are loggers, nodes or vectors . Classes that belong to those clusters may also be fundamental elements in JBoss X  X  structure. Fig. 7 depicts the formed clusters of the classes of JBoss based on many object-oriented systems inheritance is not really used a lot [18]. In JBoss , classes (clusters 5 and 6) with the highest DIT value are subclasses of the org.jboss.axis.message and org.jboss.varia.scheduler packages. The tree of inheritance leading to these classes has a de pth of 6. A good example is class which has one of the deepest inheritance trees we found. Fig. 8 depicts the formed clusters of the classes of JBoss based on their inward coupling. We can see here that on the 11th cluster there is the Logger class that depends on 2 only other classes, while 1200 other depend on it. That is why the maintenance engineer has to be very cautious when changing its interface and behaviour. Fig. 9 depicts the formed clusters of the classes of JBoss based on their number of public methods. Exposing too much of the class logic through public methods can be a sign of poorly designed code as it may need to split the class into two. However, there are cases where this is inevitable. For org.jboss.resource.adapter.jdbc.WrappedResul tSet . This class implements a wrapper to access the results of a sql query using the java database connectivity API or two lines), but it provides many public methods to access the result of the query in many ways. JMX (Java Management Extensi on) infrastructure and supports also Aspect Oriented Programming middleware. We consider that packages which play the most significant role in formulating clusters would be the main packages of JBOSS. For example org.jboss.console which provides a simple web interface for managing the MBean server and org.jboss.ejb3 which is the most basic package for an EJB implementation. We also discovered a very interesting clus ter (Cluster 4) which comprises of packages that implement AOP (Aspect Oriented Programming)  X  based services. On the other hand most of the classes of JBoss have very low complexity values and they do not expose too excessive either afferent or efferent couplings. They also have no children and they do not use inheritance very much. An interesting observation was that classes related to th e implementation of (AOP) support have very low complexity (WMC) values. We also observed that most of the classes with hi gh WMC and CBO values have member methods that their return types are not primitives. The results presented in this s ection were derived without having prior knowledge of the JBoss OS Application Server. We would expect that domain experts coul d better support the evaluation of the proposed method. This section presents conclu sions drawn by evaluating the proposed framework and comparing it to similar ones. Directions for future work are also discussed. The aim of this work was to facilitate maintenance engineers to comprehend the structure of a software system and assess its maintainability. The first step towards that was to develop an extraction process that incorporates an xml representation of the code so that we can was accomplished by using the javaml representation. 1,615,289 LOC or 4,714 Java code files were parsed in less than an hour in order to extract elements and metrics from JBoss  X  source code. The application of this extracti on method differentiates this work from [12] which is designed for procedural languages like COBOL and C. The proposed solution is also semi automated unlike [4] as the parsing engine extracts the data from the source code and stores them on a database. The second step towards our goal to facilitate a maintenance engineer to comprehend a soft ware system and assess its maintainability was the application of clustering for both recovering the structure of a software artifact and assessing its maintainability. That makes our work more complete than [4], [9], [12], [15], [23], which use data mining techniques only for structure recovering and [24] whic h uses clustering for predicting a software modules X  fault proneness. On the other hand our method analyses only the static dependencies of system X  X  entities unlike [23] which uses Clustering in order to study the dynamic dependencies of a system under maintenance. We al so use the K-Means Clustering algorithm which has the drawback that the user has to define the number of the derived clusters. On the contrary [15] employs the Hierarchical Agglomerative Clustering (HAC) algorithm which automatically defines the number of the derived clusters. We consider the following various alternatives in order to enhance the proposed framework:  X  Systems X  components clustering based on their dynamic It would be of great interest to attempt to evaluate the usefulness of analysing the dynamic depende ncies of a software system X  X  artefacts.  X  Integration of more data mining algorithms The proposed framework integrates the K-Means algorithm. However it may be useful if more custom data mining algorithms were integrated in this framework. This would result in a complete system for automated program and system comprehension. An example is the integration of hierarchical number of the desired output clusters [8].  X  Enhance the Extraction Method The proposed method processes information derived only from Java source code files (*.java). It is of great interest to extract data from other OO languages like C++, C# and Borland Delphi. It can also be more flexible. For example, logic could be incorporated in java objects in order to comput e software engineering metrics directly from the javaml files. These metrics could later be stored information.  X  Enrich the Input Model with more metrics and meta-Based on this work we extracted elements and metrics from source code. The proposed Input Model can be enriched by employing more metrics except these in Chidamber and Kemerer Object Oriented suite [5]. We can also use meta-metrics in order to evaluate how accurate and right are the metrics we employ to assess a system X  X  maintainability. The authors would like to thank the anonymous reviewers for the constructive feedback on the original manuscript. [1] E. Arisholm, L.C. Briand, A. Foyen,  X  X ynamic Coupling [2] G.J. Badros,  X  X avaML: A Ma rkup Language for Java Source [3] R.K. Bandi, V.K. Vaishnavi , D.E. Turk,  X  X redicting [4] K. Chen, C. Tjortjis and P.J. Layzell,  X  X  Method for Legacy [5] S. R. Chidamber and C. F. Kemerer. A Metrics Suite for [6] Al-Ekram, R., Kontogiannis, K.,  X  X n XML-Based [7] U. M. Fayyad, G. Piatetsky-Shapiro and P. Smyth.  X  X rom [8] A. Jain, M.N. Murty, and P.J. Flynn,  X  X ata Clustering: A [9] Y. Kanellopoulos, C. Tjortjis,  X  X ata Mining Source Code to [10] M.M. Lehman,  X  X rograms, Li fe Cycles, and Laws of [11] W. Li, S. Henry, D. Kafura and R. Schulman,  X  X easuring [12] C. M. de Oca and D. L. Ca rver,  X  X dentification of Data [13] T. Pearse and P. Oman,  X  X aintainability Measurements on [14] T.M. Pigoski, Practical Software Maintenance: Best [15] D. Rousidis, C. Tjortjis,  X  X lustering Data Retrieved from [16] H.M. Sneed,  X  X pplying Size Complexity and Quality [17] I. Sommerville, Software Engineering , 6th ed., Harlow, [18] D. Spinellis. Code Quality , Addison-Wesley, 2006. [19] J. Sutherland,  X  X usiness Objects in Corporate Information [20] Y. Tan, V.S. Mookerjee,  X  X om paring Uniform and Flexible [21] C. Tjortjis and P.J. Layzell,  X  X  xpert Maintainers X  Strategies [22] C. Tjortjis, L. Sinos and P.J. Layzell,  X  X acilitating Program [23] C. Xiao, V. Tzerpos,  X  X oftware Clustering on Dynamic [24] S. Zhong, T.M. Khoshgoftaar, and N. Seliya,  X  X nalyzing [25] JBoss Community home page http://www.jboss.org Yiannis Kanellopoulos is a PhD candidate at the School of Informatics, University of Manchester, U.K. His research interests are in the areas of Data Mining, Program Comprehension and Maintenance, and Software Engineering Quality. Thimios Dimopulos is a Software Engineer at Deutsche Telekom Labs, Berlin, Germany. His research interests are in the areas of and Software Engineering and Maintenance. Christos Tjortjis is a Lecturer at the School of Informatics, University of Manchester, and a part time Lecturer at the Nottingham Business School, Nottingham Trent University, U.K. His research interests are in the areas of data mining, software comprehension and maintenance where he has published widely. Christos Makris is an Assistant Professor at the Department of Computer Engineering and Inform atics, University of Patras, Greece. His research interests include Data Structures, Web Algorithmics, Computational Geometry, Data Bases and Information Retrieval. 
