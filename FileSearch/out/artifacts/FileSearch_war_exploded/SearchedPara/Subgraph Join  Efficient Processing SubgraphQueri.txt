 XML has become the de facto standard for information representation and ex-change over the Internet. XML data has hi erarchy nesting structure. XML data is often modeled as a tree. However, XML data may also have IDREFs that add additional relationship to XML data. With such property, XML data also can be represented in graph structure. In many applications, data can be modeled as a graph more naturally than a tree.
 ture by duplicate the element with more than one incoming paths. But it will result in redundancy.
 query language standards for XML data. Structure query on graph structured XML data has more power. Further than branching query on tree structured XML data, structure query on graph-structured XML data can request sub-graphs matching the general graph modeled schema described query.
  X  More complex query can be defined on graph-structured XML data. The  X  One way to processing structural qu ery on XML data is to encode the nodes  X  Another kind query processing methods for XML is to use structural index to process query on graph-structured XML data. With well-designed labeling, the structural relationship between two n odes can be determined efficiently with-out accessing any other node. In this paper we use an extension of the code in [16] as reachability code.
 design a novel subgraph join algorithm based on the reachability code. In order to support the overlapping of intervals in the coding, we design a data structure interval stack . Subgraph join algorithm uses a chain of linked interval stacks to compactly represent partial results. Subgraph join algorithm can be used to process subgraph query with both adjacent and reachability relationship.  X  We use duplication to make the coding possible to be storage in relation or  X  We present efficient graph structural join algorithms and efficient data struc- X  We present subgraph query, a novel kind of structure query using general The reset of the paper is organized as fo llows: Section 2 introduces some back-ground knowledge. Data preprocessing and subgraph join algorithm are pre-sented in Section 3. We present our experim ental results and analysis in section 4. Related work is described in Sectio n 5. We conclude the paper in Section 6 In this section, we briefly introduce Graph-structural XML model and some termsusedinthispaper. 2.1 Data Model XML data is often modeled as a labelled tr ee:elements and attributes are mapped into nodes of graph; directed nesting relationships are mapped into edges in the tree. A feature of XML is that from two elements in XML document, there may be a IDREF representing reference relationships [23]. With this feature, XML data can be modeled as a labelled digra ph: elements and attributes are mapped into nodes of graph; directed nesting and reference relationships are mapped into edges in the graph. An XML fragment i s shown in Fig 1(b). It can be modeled as the graph shown in Fig 1(b). It is noted the graph in Fig 1(b) is not a DAG. outcoming edge is called sink . 2.2 Subgraph Query In graph-structured XML, th e parent-child and ancestor-descendant relationship should be extended. In [13], the idref edges are represented as  X  and  X  for the forward and backward direction, respectively. We define the reachability relationship as two nodes a and b in the graph model G of XML data satisfy reachability relationship if and only there is a path from a to b in G .Eachedge in this path can be either edges representing nested relationship or reference relationship. We represent reachability by . For example, a e is to retrieve all the e elements with a path from a to it. In Fig 1(b), this query will retrieve d 1 ,d 2and d 3.
 graph query will retrieve the subgraphs of graph-structured XML matching the structure given by the query. The graph corresponding to the query is called query graph . The nodes in query graph represent the tag name of required el-ements. The edges in query graph represe nt the relationship between required elements. If an edge in query graph represe nts adjacent relationship, it is called adjacent edge . If an edge in query graph represents reachability relationship, it is called reachability edge . For an example, the query shown in fig 2(a) on XML document shown in fig 1(b) represents the query to retrieve all the subgraphs of it with structure a node connects to a c node, d node reaches to this c node and this c node reaches a f node. the result is shown in fig 6.
 2.3 Reachibility Coding The goal of encoding XML is to represent the structural relationship so that the relationship between nodes in XML graph can be judged from the code quickly. With a good code, the query p rocessing of struct ural query can be efficient. In this paper, we focus on reachability coding , which is used to judge the reachability relationship. We use an extension of reachability coding presented in [16]. In this coding, at first, all strong ly connected componen ts in the graph are contracted. Labeling is done by finding a spanning tree of the DAG generated in last step and assigning interval label s for nodes in the tree. The coding of the spanning tree is generated by post-order traversal. Each node is also assigned the number during traversal. The number is called postid . Next, to capture reachability relationships through non-spanning-forest edges, we add additional intervals to labels in reverse topological order of the DAG; specifically, if (u, v) is an edge not in the spanning forest, then all intervals of v are added to u (as well as labels of all nodes that can reach u). For an example, the reachability coding of graph in fig1(b) is shown in Fig 1(c). Using the spanning tree rooted at a 1, we label d 2, f 1with[2 , 2] and [0 , 0]. In addition, d2 receives intervals from f1, resulting in that b2 X  X  code is [2 , 2] , [0 , 0]. In this coding, a b if and only if b.postid is contained some interval associated with a . In this section, we discuss the processing of subgraph queries. We present sub-graph join algorithm and the method of preprocessing query and data to support subgraph join algorithm. 3.1 Preprocess of the Input The interval labelling scheme of a graph is different from that of tree. There may be more than one intervals assigned to one node. The processing unit of our method is interval. So that we should assign the postid of each node to all of its intervals. If several intervals a ssociated to nodes with the same tag have the same x and y value but different postid , they are merged. The result of this step is a list of intervals, each of which is associated with one or more postid s. The list is called candidate list .
 the same tag by the value of x in ascending order and value of y in descending order. x is prior to y . It means only if two intervals have same x value, their y values are considered. 3.2 Preprocess for Subgraph Query In order to apply subgraph join algorithm to process general subgraph query, some preprocess should be applied on the query when the query graph has circle. If there are some circles in the query graph, a node n in each circle should be split to n a and n b break this circle. n a includes all the incoming edges of n . n b includes all the out edges of n . This node is the nodes related least edges in the circle.
 query node are connected. Hash method is used.
 Theorem 1. After connection processing in the last step, the splitting of query node will not affect the final result of subgraph query.
 Section 3.1, the nodes in the same SCC in each candidate list should be merged into one node. This node is called stub node . Since the coding of nodes in the same SCC have same intervals, the new node has these intervals, the number of the stub node is any of the number of the nodes belonging to the same SCC. Applying such preprocess is to prevent too large intermediate result during query processing without affecting the final result. For example, to process query shown in fig 3, there is a cycle in graph of the XML document with 100 a nodes, 100 b nodes and 100 c nodes respectively. Since they are reachable to each other, there will be 10 6 items in intermediate result after processing these nodes. be extracted. The process of extraction i s,foreachresultwithstubnode,from node set associated each merged nodes, one node is selected for one time to put on the position of the merged node. With a different combination of the selected nodes, one result is generated.
 Theorem 2. With extraction after all results are generated, the merging of nodes in the same SCC before query processing will not affect the final result. 3.3 Data Structure for Subgraph Join In our coding, there may be overlap in the intervals. Therefore, the stack based join of tree structured XML document can not be applied to our coding directly. We design a data structure, interval stack , to support efficient graph structural join. The interval stack is a DAG. Each node represents an interval. Each edge e = n 1  X  n 2 represents the interval of n 1 contains the interval of n 2 . The child of each node is sorted by the x values of the intervals.
 the list of the sinks which are intervals without any interval containing them. Bottom is the list of sources which are intervals without any interval contained in them. They are both sorted by x of the intervals.
 former is to append an interval to interval stack. The latter is to delete useless intervals from interval stack. During the performing of these two operations, the property of interval stack should be kept and top and bottom are maintained. 3.4 Subgraph Join Algorithms With interval stack, we improve stack-based twig join [3]algorithm to support subgraph queries.
  X  The postid of a node is contained one and only one of its intervals.  X  If two nodes have reachability relationship, it can and only can be checked input query will be broken in preprocess. If there is no root. A dummy root is added to the query.
 sponds to.
 stack(S) and its current cursor(C), the parents and children of it in query graph. The interval stack has the same function as that in structural join. M is a hash map, mapping postid of node to its children. The algorithms of subgraph join are described in Alg 1.
 nodes satisfying partial reachability relation described in query is outputted. In the second phase, the nodes in intermediate result unsatisfied the whole query are trimmed. Such nodes being included in intermediate result is because in the first phase, when each pair of nodes is outputted, only partial reachability relation related to these two node is considered. For an example, for query shown in fig 3, some of the intervals to process are shown in fig 4, the ids in brackets are the postid s corresponding to the interval. Suppose the first number in bracket is in corresponding interval and others is not in the interval. During query processing, termediate result. This is because from t he containment of these two intervals, only that c 11 is in interval a 1 can be determined. So only the reachability of all nodes in the extent of a 1 and c 11 is true. getNext of twigjoin in [3]. First of all, the interval with least x value is chosen. If some intervals have same x value, the interval with largest y is chosen. If two intervals have same x and same y and their corresponding query nodes have reachability relation, the interval corresponding query node as ancestor is chosen. Otherwise, some result will be lost. For an example, consider query in fig 3. on the element sets visualized in fig 4, the interval a 1 has the same x and y as interval b 1 . The nodes corresponding to a 1 should be outputted with the nodes corresponding to b 1 and in the interval of b 1 .Butif b 1 is chosen former than a , these pairs will not be outputted. Since interval a 1 contains interval b 2 ,the nodes corresponding to a 1 should be outputted with the nodes corresponding to b 2 and in the interval of b 2 .Butif b 2 is chosen former, these pairs will lose. Algorithm 2. getNext( q ) interval satisfies the restriction of all incoming paths in the query. In out example, when interval c 3 is met, since interval stack of b is empty, it will not be considered. be not enough to store intermediate results. External memory is used to store intermediate results. Since each node may have more than one descendant during query processing, children of one node are stored as a list in disk. The head of the list associated with a node record the number of the node, the query node corresponding to the node and the pointer to the first entry of the list. Each of entries in the list includes a 2-ary,( node , next ), where node is the pointer to the node this entry corresponding to and next is the pointer to next entry of the list. In the hash map, each entry e n corresponds one node n . Each entry contain the head of the the position of the head and tail of list of n . Theorem 3. The logical I/O number of subgraph join algorithms is linear to the number to the pair of nodes satisfying the reachability relationship described in query. In this section, we present results and ana lysis of part of our extensive experiment of subgraph join algorithms based on reachibility coding. 4.1 Experimental Setup The Testbed. All our experiments were performed on a PC with Pentium 1GMHZ CPU, 256M main memory and 30G IDE hard disk. The OS is Windows 2000 Professional. We implemented all the algorithms using Microsoft Visual C++ 6.0. We implemented the encoding of graph and subgraph join algorithms. We use LRU policy for buffer replacement.
 XML document. F&amp;B index supports all the subgraph queries for XML. Dataset. The dataset we tested is the standard XMark benchmark dataset[21]. We used scale factor 0.1, 0.2, 0.3, 0.4 and 0.5, which generated XML document with size 10M, 20M, 30M, 40M and 50M respectively. It has complicated schema, including circle.
 Query Set. In order to better test and understand the characteristics of the algorithms, we designed a set of queries that has different characteristics. We design three queries. They represent various structures. The query graph of them are shown in fig 5(a), fig 5(b) a nd fig 5(c), respectively. 4.2 Changing System Parameters In this subsection, we investigate the performance of our system by varying var-ious system parameters. We use physicalI/O and run time to reflect the impact of different parameter setting.
 Scalability Experiment. We test the queries on XML documents with various sizes. In order to test the scalability of the subgraph join algorithm. We choose SGQ2 and SGQ3 as test query. We fix main memory 8M and block size 4096. The results are shown in fig 6(a) and fig 6(b), respectively. SGQ1 is a simple twig query. The nodes related to SGQ 1 in XML document is not in any SCC and all have single parent. Therefore, the increase trend is nearly linear. SGQ2 is a complex subgraph query. One person node may be reached by more than one seller nodes and only parts of person nodes are reached by both seller node and buyer node. The trend of run time is faster than linear but still slower than square.
 Varying Buffer Size. The physicalIO change with block number of SGQ1 is shown in fig 6(c). From the fig 6(c), we can find that without enough main memory, the second phase result more physical I/O than the first phase. This is because in the second phase the whole intermediate result is traversed while in the first phase, the operation is mainly append. 4.3 Comparison Experiment We do comparison in 10M XML document. Its F&amp;B-index has 167072 nodes. We naive implemented the depth first traversal-based query processing by F&amp;B-index. The reason why we do not compare larger XML document is that when XML document gets larger, the query processing in F&amp;B-index becomes too slow.
 algorithm and F&amp;B index is shown in Fig 6(d). Y axis is in log scale. subgraph join algorithm outperforms the efficiency of F&amp;B index. For SGQ1, the efficiency are similar. It is because the nodes in XML document related to SGQ1 is in tree structured in Xmark document and the s earch depth in F&amp;B index is limited. With efficient coding, XML queries can a lso be evaluated on-the-fly using the join-based approaches. Structural join and twig join are such operators and their efficient evaluation algorit hms have been extensively studied [27,14,8,10,5,25] [3,11]. Their basic tool is the coding schemes that enable efficient checking of structural relationship of any two nodes. TwigStack [3] is the best twig join algorithm to answer all twig queries without using additional index. The idea of these work can be referenced to process query on graph. But these algorithms can not be applied on the coding of graph directly. Information in some applications can be naturally stored as graph modeled data. The processing of graph structured XML data brings new challenges. To process structural query on graph st ructured XML data, in this paper, we present reach-ability labelling scheme for graph structured XML. With such labelling scheme, the reachability relationship between two nodes in graph structured XML can be judged efficiently. Based on the labelling scheme, we design graph structural join and subgraph join algorithms of graph structured XML to perform sub-graph queries. From experiment, our labelling scheme has acceptable size. The subgraph join algorithm outperforms the query processing with F&amp;B-index. cient query processing on graph structured XML document.

