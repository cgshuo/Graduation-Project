 Commercial services based on spoken dialog sys-tems have consistently increased both in number and in application scenarios (Gorin et al., 1997). De-spite its success, current Spoken Language Under-standing (SLU) technology is mainly based on sim-ple conceptual annotation, where just very simple semantic composition is attempted. In contrast, the availability of richer semantic models as FrameNet (Baker et al., 1998) is very appealing for the de-sign of better dialog managers. The first step to en-able the exploitation of frame semantics is to show that accurate automatic semantic labelers can be de-signed for processing conversational speech.
In this paper, we face the problem of perform-ing shallow semantic analysis of speech transcrip-tions from real-world dialogs. In particular, we ap-ply Support Vector Machines (SVMs) and Kernel Methods to the design of a semantic role labeler (SRL) based on FrameNet. Exploiting Tree Kernels (Collins and Duffy, 2002; Moschitti et al., 2008), we can quickly port our system to different languages and domains. In the experiments, we compare results achieved on the English FrameNet against those achieved on a smaller Italian FrameNet-like corpus of spoken dialog transcriptions. They show that the system is robust enough to disfluencies and noise, and that it can be easily ported to new do-mains and languages.

In the remainder of the paper, Section 2 presents our basic Semantic Role Labeling approach, Sec-tion 3 describes the experiments on the English FrameNet and on our Italian dialog corpus, and Sec-tion 4 draws the conclusions. Semantic frames represent prototypical events or situations which individually define their own set of actors, or frame participants. For example, the C OMMERCE S CENARIO frame includes partic-ipants as S ELLER , B UYER , G OODS , and M ONEY . The task of FrameNet-based shallow semantic pars-ing can be implemented as a combination of multi-ple specialized semantic labelers as those in (Car-reras and M ` arquez, 2005), one for each frame. Therefore, the general semantic parsing work-flow includes 4 main steps: (i) Target Word Detec-tion , where the semantically relevant words bringing predicative information (the frame targets ) are de-tected, e.g. the verb to purchase for the above exam-ple; (ii) Frame Disambiguation , where the correct frame for every target word (which may be ambigu-ous) is determined, e.g. C OMMERCE S CENARIO ; (iii) Boundary Detection (BD) , where the sequences of words realizing the frame elements (or predicate arguments) are detected; and (iv) Role Classification (RC) (or argument classification), which assigns se-mantic labels to the frame elements detected in the previous step, e.g. G OODS . Therefore, we imple-ment the full task of FrameNet-based parsing by a combination of multiple specialized SRL-like label-ers, one for each frame (Coppola et al., 2008). For the design of each single labeler, we use the state-of-the-art strategy developed in (Pradhan et al., 2005; Moschitti et al., 2008). 2.1 Standard versus Structural Features In machine learning tasks, the manual engineering of effective features is a complex and time con-suming process. For this reason, our SVM-based SRL approach exploits the combination of two dif-ferent models. We first used Polynomial Kernels over handcrafted, linguistically-motivated,  X  X tan-dard X  SRL features (Gildea and Jurafsky, 2002; Pradhan et al., 2005; Xue and Palmer, 2004). Nonetheless, since we aim at modeling an SRL sys-tem for a new language (Italian) and a new domain (dialog transcriptions), the above features may re-sult ineffective. Thus, to achieve independence on the application domain, we exploited Tree Kernels (Collins and Duffy, 2002) over automatic structural features proposed in (Moschitti et al., 2005; Mos-chitti et al., 2008). These are complementary to stan-dard features and are obtained by applying Tree Ker-nels (Collins and Duffy, 2002; Moschitti et al., 2008) to basic tree structures expressing the syntactic rela-tion between arguments and predicates. Our purpose is to show that an accurate automatic FrameNet parser can be designed with reasonable effort for Italian conversational speech. For this pur-pose, we designed and evaluated both a semantic parser for the English FrameNet (Section 3.1) and one for a corpus of Italian spoken dialogs (Section 3.2). The accuracy of the latter and its comparison against the former can provide evidence to sustain out thesis or not. 3.1 Evaluation on the English FrameNet In this experiment we trained and tested boundary detectors (BD) and role classifiers (RC) as described in Section 2. More in detail, (a) we trained 5 BDs according to the syntactic categories of the possi-ble target predicates, namely nouns, verbs, adjec-tives, adverbs and prepositions; (b) we trained 782 one-versus-all multi-role classifiers RC, one for each available frame and predicate syntactic category, for a total of 5,345 binary classifiers; and (c) we ap-plied the above models for recognizing predicate ar-guments and their associated semantic labels in sen-tences, where the frame label and the target predi-cate were considered as given. 3.1.1 Data Set
We exploited the FrameNet 1.3 data base. After preprocessing and parsing the sentences with Char-niak X  X  parser, we obtained 135,293 semantically-annotated and syntactically-parsed sentences.
The above dataset was partitioned into three sub-sets: 2% of data (2,782 sentences) for training the BDs, 90% (121,798 sentences) for training RC, and 1% (1,345 sentences) as test set. The remaining data were discarded. Accordingly, the number of pos-itive and negative training examples for BD were: 2,764 positive and 37,497 negative examples for ver-bal, 1,189 and 35,576 for nominal, 615 and 14,544 for adjectival, 0 and 40 for adverbial, and 7 and 177 for prepositional predicates (for a total of 4,575 and 87,834). For RC, the total numbers were 207,662 and 1,960,423, which divided by the number of role types show the average number of 39 positive versus 367 negative examples per role label. 3.1.2 Results
We tested several kernels over standard fea-tures (Gildea and Jurafsky, 2002; Pradhan et al., 2005) and structured features (Moschitti et al., 2008): the Polynomial Kernel ( PK , with a degree of 3), the Tree Kernel (TK) and its combination with the bag of word kernel on the tree leaves (TKL). Also, the combinations PK+TK and PK+TKL were tested.

The 4 rows of Table 1 report the performance of different classification tasks. They show in turn: (1) the  X  X ure X  performance of the BD classifiers, i.e. considering correct the classification decisions also when a correctly classified tree node does not ex-actly correspond to its argument X  X  word boundaries. Such mismatch frequently happens when the parse tree (which is automatically generated) contains in-correct node attachments; (2) the real performance of the BD classification when actually  X  X rojected X  ( X  X j X ) on the tree leaves, i.e. when matching not only the constituent node as in 1, but also exactly matching the selected words (leaves) with those in the FrameNet gold standard. This also implies the exact automatic syntactic analysis for the subtree; (3) the same as in (1), with the argument role classi-fication (RC) also performed (frame element labels must also match); (4) the same as in (2), with RC also performed. For each classification task, the Pre-cision, Recall and F 1 measure achieved by means of different kernel combinations are shown in the columns of the table. Only for the best configuration in Table 1 (PK+TK, results in bold) the amount of training data for the BD model was increased from 2% to 90%, resulting in a popular splitting for this task(Erk and Pado, 2006). Results are shown in Ta-ble 2: the PK+TK kernel achieves 1.0 Precision, 0.732 Recall, and 0.847 F 1 . These figures can be compared to 0.855 Precision, 0.669 Recall and 0.751 F 1 of the system described in (Erk and Pado, 2006) and trained over the same amount of data. In con-clusion, our best learning scheme is currently capa-ble of tagging FrameNet data with exact boundaries and role labels at 63% F 1 . Our next steps will be (1) further improving the RC models using FrameNet-specific information (such as Frame and role inheri-tance), and (2) introducing an effective Frame clas-sifier to automatically choose Frame labels. 3.2 Evaluation on Italian Spoken Dialogs In this section, we present the results of BD and RC of our FrameNet parser on the smaller Italian spoken dialog corpus. We assume here as well that the target word (i.e. the predicate for which arguments have to be extracted) along with the correct frame are given. 3.2.1 Data Set
The Italian dialog corpus includes 50 real human-human dialogs recorded and manually transcribed at the call center of the help-desk facility of an Ital-ian Consortium for Information Systems. The di-alogs are fluent and spontaneous conversations be-tween a caller and an operator, concerning hard-ware and software problems. The dialog turns con-tain 1,677 annotated frame instances spanning 154 FrameNet frames and 20 new ad hoc frames spe-cific for the domain. New frames mostly con-cern data processing such as N AVIGATION , D IS -intended as a reference resource, this dataset in-cludes partially human-validated syntactic analysis, i.e. lower branches corrected to fit arguments. We divided such dataset into 90% training (1,521 frame instances) and 10% testing (156 frame instances). Each frame instance brings its own set of frame par-ticipant (or predicate argument) instances.
For BD, the very same approach as in Section 3.1 was followed. For RC, we also followed the same approach but, in order to cope with data sparse-ness, we also attempted a different RC strategy by merging data related to different syntactic predicates within the same frame. So, within each frame, we merged data related to verbal predicates, nominal predicates, and so on. Due to the short space avail-able, we will just report results for this latter ap-proach, which performed sensitively better. 3.2.2 Results
The results are reported in Table 3. Each ta-ble block shows Precision, Recall and F 1 for ei-ther PK, TK, or PK+TK. The rows marked as BD show the results for the task of marking the exact constituent boundaries of every frame element (ar-gument) found. The rows marked as BD+RC show the results for the two-stage pipeline of both marking the exact constituent boundaries and also assigning the correct semantic label. A few observations hold. First, the highest F 1 has been achieved using the PK+TK combination. On this concern, we under-line that kernel combinations always gave the best performance in any experiment we run.

Second, we emphasize that the F 1 of PK is sur-prisingly high, since it exploits the set of standard SRL feature (Gildea and Jurafsky, 2002; Pradhan et al., 2005), originally developed for English and left unmodified for Italian. Nonetheless, their per-formance is comparable to the Tree Kernels and, as we said, their combination improves the result. Concerning the structured features exploited by Tree Kernels, we note that they work as well without any tuning when ported to Italian dialogs.

Finally, the achieved F 1 is extremely good. In fact, our corresponding result on the FrameNet cor-pus (Table 2) is P =0.784, R =0.571, F 1 =0.661, where the corpus contains much more data, its sen-tences come from a standard written text (no dis-fluencies are present) and it is in English language, which is morphologically simpler than Italian. On the other hand, the Italian corpus includes optimal syntactic annotation which exactly fits the frame se-mantics, and the number of frames is lower than in the FrameNet experiment. The good performance achieved for Italian dialogs shows that FrameNet-based parsing is viable for la-beling conversational speech in any language us-ing a few training data. Moreover, the approach works well for very specific domains, like help-desk/customer conversations. Nonetheless, addi-tional tests based on fully automatic transcription and syntactic parsing are needed. However, our cur-rent results show that future research on complex spoken dialog systems is enabled to exploit automat-ically generated frame semantics, which is our very direction.

