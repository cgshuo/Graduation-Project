 Combinatory Categorial Grammar ( CCG ; Steedman (2000)) is a lexicalised theory of grammar which has been successfully applied to a range of problems in NLP , including treebank creation (Hockenmaier and Steedman, 2007), syntactic parsing (Hockenmaier, 2003; Clark and Curran, 2007), logical form con-struction (Bos et al., 2004) and surface realization (White and Rajkumar, 2009). From a parsing per-spective, the C&amp;C parser (Clark and Curran, 2007) has been shown to be competitive with state-of-the-art statistical parsers on a variety of test suites, in-cluding those consisting of grammatical relations (Clark and Curran, 2007), Penn Treebank phrase-structure trees (Clark and Curran, 2009), and un-bounded dependencies (Rimell et al., 2009).

The binary branching nature of CCG means that it is naturally compatible with bottom-up parsing al-gorithms such as shift-reduce and CKY (Ades and Steedman, 1982; Steedman, 2000). However, the parsing work by Clark and Curran (2007), and also Hockenmaier (2003) and Fowler and Penn (2010), has only considered chart-parsing. In this paper we fill a gap in the CCG literature by developing a shift-reduce parser for CCG .

Shift-reduce parsers have become popular for de-pendency parsing, building on the initial work of Ya-mada and Matsumoto (2003) and Nivre and Scholz (2004). One advantage of shift-reduce parsers is that the scoring model can be defined over actions, al-lowing highly efficient parsing by using a greedy algorithm in which the highest scoring action (or a small number of possible actions) is taken at each step. In addition, high accuracy can be maintained by using a model which utilises a rich set of features for making each local decision (Nivre et al., 2006).
Following recent work applying global discrim-inative models to large-scale structured prediction problems (Collins and Roark, 2004; Miyao and Tsujii, 2005; Clark and Curran, 2007; Finkel et al., 2008), we build our shift-reduce parser using a global linear model, and compare it with the chart-based C&amp;C parser. Using standard development and test sets from CCGbank, our shift-reduce parser gives a labeled F-measure of 85.53%, which is com-petitive with the 85.45% F-measure of the C&amp;C parser on recovery of predicate-argument dependen-cies from CCGbank. Hence our work shows that transition-based parsing can be successfully applied to
CCG , improving on earlier attempts such as Has-san et al. (2008). Detailed analysis shows that our shift-reduce parser yields a higher precision, lower recall and higher F-score on most of the common CCG dependency types compared to C&amp;C.

One advantage of the shift-reduce parser is that it easily handles sentences for which it is difficult to find a spanning analysis, which can happen with CCG because the lexical categories at the leaves of a derivation place strong contraints on the set of possi-ble derivations, and the supertagger which provides the lexical categories sometimes makes mistakes. Unlike the C&amp;C parser, the shift-reduce parser nat-urally produces fragmentary analyses when appro-priate (Nivre et al., 2006), and can produce sensible local structures even when a full spanning analysis
Finally, considering this work in the wider pars-ing context, it provides an interesting comparison between heuristic beam search using a rich set of features, and optimal dynamic programming search where the feature range is restricted. We are able to perform this comparison because the use of the CCG supertagger means that the C&amp;C parser is able to build the complete chart, from which it can find the optimal derivation, with no pruning whatsoever at the parsing stage. In contrast, the shift-reduce parser uses a simple beam search with a relatively small beam. Perhaps surprisingly, given the ambiguity lev-els in an automatically-extracted grammar, and the amount of information in the CCG lexical categories which form the shift actions, the shift-reduce parser using heuristic beam search is able to outperform the chart-based parser. CCG , and the application of CCG to wide-coverage parsing, is described in detail elsewhere (Steedman, 2000; Hockenmaier, 2003; Clark and Curran, 2007). Here we provide only a short description.

During CCG parsing, adjacent categories are com-bined using CCG  X  X  combinatory rules. For example, a verb phrase in English ( S \ NP ) can combine with an NP to its left using function application:
Categories can also combine using function composition, allowing the combination of  X  X ay X  (( S \ NP ) / ( S \ NP )) and  X  X ike X  (( S \ NP ) / NP ) in coordination examples such as  X  X ohn may like but may detest Mary X : ( S \ NP ) / ( S \ NP ) ( S \ NP ) / NP  X  ( S \ NP ) / NP
In addition to binary rules, such as function appli-cation and composition, there are also unary rules which operate on a single category in order to change its type. For example, forward type-raising can change a subject NP into a complex category looking to the right for a verb phrase: An example CCG derivation is given in Section 3. The resource used for building wide-coverage CCG parsers of English is CCGbank (Hockenmaier and Steedman, 2007), a version of the Penn Tree-bank in which each phrase-structure tree has been transformed into a normal-form CCG derivation. There are two ways to extract a grammar from this resource. One approach is to extract a lexicon, i.e. a mapping from words to sets of lexical cat-egories, and then manually define the combinatory rule schemas, such as functional application and composition, which combine the categories together. The derivations in the treebank are then used to pro-vide training data for the statistical disambiguation
The second approach is to read the complete grammar from the derivations, by extracting combi-natory rule instances from the local trees consisting of a parent category and one or two child categories, and applying only those instances during parsing. (These rule instances also include rules to deal with punctuation and unary type-changing rules, in addi-tion to instances of the combinatory rule schemas.) This is the method used by Hockenmaier (2003) and is the method we adopt in this paper.

Fowler and Penn (2010) demonstrate that the sec-ond extraction method results in a context-free ap-proximation to the grammar resulting from the first method, which has the potential to produce a mildly-context sensitive grammar (given the existence of certain combinatory rules) (Weir, 1988). However, it is important to note that the advantages of CCG , in particular the tight relationship between syntax and semantic interpretation, are still maintained with the second approach, as Fowler and Penn (2010) argue. Given an input sentence, our parser uses a stack of partial derivations, a queue of incoming words, and a series of actions X  X erived from the rule instances in CCGbank X  X o build a derivation tree. Following Clark and Curran (2007), we assume that each input word has been assigned a POS -tag (from the Penn Treebank tagset) and a set of CCG lexical categories. We use the same maximum entropy POS -tagger and supertagger as the C&amp;C parser. The derivation tree can be transformed into CCG dependencies or gram-matical relations by a post-processing step, which essentially runs the C&amp;C parser deterministically over the derivation, interpreting the derivation and generating the required output.

The configuration of the parser, at each step of the parsing process, is shown in part (a) of Figure 1, where the stack holds the partial derivation trees that have been built, and the queue contains the incoming words that have not been processed. In the figure, S (H) represents a category S on the stack with head word H , while Q queue.

The set of action types used by the parser is as follows: { SHIFT , COMBINE , UNARY , FINISH } . Each action type represents a set of possible actions available to the parser at each step in the process.
The SHIFT -X action pushes the next incoming word onto the stack, and assigns the lexical category X to the word (Figure 1(b)). The label X can be any lexical category from the set assigned to the word being shifted by the supertagger. Hence the shift ac-tion performs lexical category disambiguation. This is in contrast to a shift-reduce dependency parser in which a shift action typically just pushes a word onto the stack.

The COMBINE -X action pops the top two nodes off the stack, and combines them into a new node, which is pushed back on the stack. The category of the new node is X . A COMBINE action corresponds to a combinatory rule in the CCG grammar (or one of the additional punctuation or type-changing rules), which is applied to the categories of the top two nodes on the stack.

The UNARY -X action pops the top of the stack, transforms it into a new node with category X , and pushes the new node onto the stack. A UNARY ac-tion corresponds to a unary type-changing or type-raising rule in the CCG grammar, which is applied to the category on top of the stack.

The FINISH action terminates the parsing pro-cess; it can be applied when all input words have been shifted onto the stack. Note that the FINISH action can be applied when the stack contains more than one node, in which case the parser produces a set of partial derivation trees, each corresponding to a node on the stack. This sometimes happens when a full derivation tree cannot be built due to su-pertagging errors, and provides a graceful solution to the problem of producing high-quality fragmen-tary parses when necessary.
Figure 2 shows the shift-reduce parsing process for the example sentence  X  X BM bought Lotus X . First the word  X  X BM X  is shifted onto the stack as an NP; then  X  X ought X  is shifted as a transitive verb look-ing for its object NP on the right and subject NP on the left ( (S[dcl] \ NP)/NP ); and then  X  X otus X  is shifted as an NP. Then  X  X ought X  is combined with its ob-ject  X  X otus X  resulting in a verb phrase looking for its subject on the left ( S[dcl] \ NP ). Finally, the resulting verb phrase is combined with its subject, resulting in a declarative sentence ( S[dcl] ).

A key difference with previous work on shift-reduce dependency (Nivre et al., 2006) and CFG (Sagae and Lavie, 2006b) parsing is that, for CCG , there are many more shift actions  X  a shift action for each word-lexical category pair. Given the amount of syntactic information in the lexical categories, the choice of correct category, from those supplied by the supertagger, is often a difficult one, and often a choice best left to the parsing model. The C&amp;C parser solves this problem by building the complete packed chart consistent with the lexical categories supplied by the supertagger, leaving the selection of the lexical categories to the Viterbi algorithm. For the shift-reduce parser the choice is also left to the parsing model, but in contrast to C&amp;C the correct lexical category could be lost at any point in the heuristic search process. Hence it is perhaps sur-prising that we are able to achieve a high parsing ac-curacy of 85.5%, given a relatively small beam size. Greedy local search (Yamada and Matsumoto, 2003; Sagae and Lavie, 2005; Nivre and Scholz, 2004) has typically been used for decoding in shift-reduce parsers, while beam-search has recently been ap-plied as an alternative to reduce error-propagation (Johansson and Nugues, 2007; Zhang and Clark, 2008; Zhang and Clark, 2009; Huang et al., 2009). Both greedy local search and beam-search have lin-ear time complexity. We use beam-search in our CCG parser.

To formulate the decoding algorithm, we define a candidate item as a tuple h S, Q, F i , where S repre-sents the stack with partial derivations that have been built, Q represents the queue of incoming words that have not been processed, and F is a boolean value that represents whether the candidate item has been finished. A candidate item is finished if and only if the FINISH action has been applied to it, and no more actions can be applied to a candidate item af-ter it reaches the finished status. Given an input sen-tence, we define the start item as the unfinished item with an empty stack and the whole input sentence as the incoming words. A derivation is built from the start item by repeated applications of actions until the item is finished.

To apply beam-search, an agenda is used to hold the N -best partial (unfinished) candidate items at each parsing step. A separate candidate output is function D ECODE ( input , agenda , list , N , used to record the current best finished item that has been found, since candidate items can be finished at different steps. Initially the agenda contains only the start item, and the candidate output is set to none. At each step during parsing, each candidate item from the agenda is extended in all possible ways by apply-ing one action according to the grammar, and a num-ber of new candidate items are generated. If a newly generated candidate is finished, it is compared with the current candidate output . If the candidate output is none or the score of the newly generated candi-date is higher than the score of the candidate output, the candidate output is replaced with the newly gen-erated item; otherwise the newly generated item is discarded. If the newly generated candidate is un-finished, it is appended to a list of newly generated partial candidates. After all candidate items from the agenda have been processed, the agenda is cleared and the N -best items from the list are put on the agenda. Then the list is cleared and the parser moves on to the next step. This process repeats until the agenda is empty (which means that no new items have been generated in the previous step), and the candidate output is the final derivation. Pseudocode for the algorithm is shown in Figure 3. We use a global linear model to score candidate items, trained discriminatively with the averaged perceptron (Collins, 2002). Features for a (finished or partial) candidate are extracted from each ac-tion that have been applied to build the candidate. Following Collins and Roark (2004), we apply the  X  X arly update X  strategy to perceptron training: at any step during decoding, if neither the candidate out-put nor any item in the agenda is correct, decoding is stopped and the parameters are updated using the current highest scored item in the agenda or the can-didate output, whichever has the higher score.
Table 1 shows the feature templates used by the parser. The symbols S ble represent the top four nodes on the stack (if ex-istent), and Q four words in the incoming queue (if existent). S and S have the lexical head of S represents the left subnode of S head is from the right subnode. S resent the right subnode of S when the lexical head is from the left subnode. If S is built by a UNARY action, S subnode of S word, the POS , and the CCG category, respectively.
These rich feature templates produce a large num-ber of features: 36 million after the first training it-eration, compared to around 0.5 million in the C&amp;C parser. Our experiments were performed using CCGBank (Hockenmaier and Steedman, 2007), which was split into three subsets for training (Sections 02 X 21), development testing (Section 00) and the final test (Section 23). Extracted from the training data, the CCG grammar used by our parser consists of 3070 binary rule instances and 191 unary rule instances.
We compute F-scores over labeled CCG depen-dencies and also lexical category accuracy. CCG de-pendencies are defined in terms of lexical categories, by numbering each argument slot in a complex cat-egory. For example, the first NP in a transitive verb category is a CCG dependency relation, correspond-ing to the subject of the verb. Clark and Curran (2007) gives a more precise definition. We use the generate script from the C&amp;C tools 3 to transform derivations into CCG dependencies.

There is a mismatch between the grammar that generate uses, which is the same grammar as the C&amp;C parser, and the grammar we extract from CCG-bank, which contains more rule instances. Hence generate is unable to produce dependencies for some of the derivations our shift-reduce parser pro-duces. In order to allow generate to process all derivations from the shift-reduce parser, we repeat-edly removed rules that the generate script can-not handle from our grammar, until all derivations in the development data could be dealt with. In fact, this procedure potentially reduces the accuracy of the shift-reduce parser, but the effect is compar-atively small because only about 4% of the devel-opment and test sentences contain rules that are not handled by the generate script.

All experiments were performed using automati-cally assigned POS -tags, with 10-fold cross valida-tion used to assign POS -tags and lexical categories to the training data. At the supertagging stage, mul-tiple lexical categories are assigned to each word in the input. For each word, the supertagger assigns all lexical categories whose forward-backward proba-bility is above  X  max , where max is the highest lexical category probability for the word, and  X  is a threshold parameter. To give the parser a reasonable freedom in lexical category disambiguation, we used a small  X  value of 0.0001, which results in 3.6 lexi-cal categories being assigned to each word on aver-age in the training data. For training, but not testing, we also added the correct lexical category to the list of lexical categories for a word in cases when it was not provided by the supertagger.

Increasing the size of the beam in the parser beam search leads to higher accuracies but slower running time. In our development experiments, the accu-racy improvement became small when the beam size reached 16, and so we set the size of the beam to 16 for the remainder of the experiments. 6.1 Development test accuracies Table 2 shows the labeled precision (lp), recall (lr), F-score (lf), sentence-level accuracy (lsent) and lex-ical category accuracy (cats) of our parser and the C&amp;C parser on the development data. We ran the C&amp;C parser using the normal-form model (we re-produced the numbers reported in Clark and Cur-ran (2007)), and copied the results of the hybrid model from Clark and Curran (2007), since the hy-brid model is not part of the public release.
The accuracy of our parser is much better when evaluated on all sentences, partly because C&amp;C failed on 0.94% of the data due to the failure to pro-duce a spanning analysis. Our shift-reduce parser does not suffer from this problem because it pro-duces fragmentary analyses for those cases. When evaluated on only those sentences that C&amp;C could analyze, our parser gave 0.29% higher F-score. Our shift-reduce parser also gave higher accuracies on lexical category assignment. The sentence accuracy of our shift-reduce parser is also higher than C&amp;C, which confirms that our shift-reduce parser produces reasonable sentence-level analyses, despite the pos-sibility for fragmentary analysis. 6.2 Error comparison with C&amp;C parser Our shift-reduce parser and the chart-based C&amp;C parser offer two different solutions to the CCG pars-ing problem. The comparison reported in this sec-tion is similar to the comparison between the chart-based MSTParser (McDonald et al., 2005) and shift-reduce MaltParser (Nivre et al., 2006) for depen-dency parsing. We follow McDonald and Nivre (2007) and characterize the errors of the two parsers by sentence and dependency length and dependency type.

We measured precision, recall and F-score rel-ative to different sentence lengths. Both parsers performed better on shorter sentences, as expected. Our shift-reduce parser performed consistently bet-ter than C&amp;C on all sentence lengths, and there was no significant difference in the rate of perfor-mance degradation between the parsers as the sen-tence length increased.

Figure 4 shows the comparison of labeled preci-sion and recall relative to the dependency length (i.e. the number of words between the head and depen-dent), in bins of size 5 (e.g. the point at x =5 shows the precision or recall for dependency lengths 1  X  5). This experiment was performed using the normal-form version of the C&amp;C parser, and the evaluation was on the sentences for which C&amp;C gave an anal-ysis. The number of dependencies drops when the dependency length increases; there are 141, 180 and 124 dependencies from the gold-standard, C&amp;C out-put and our shift-reduce parser output, respectively, when the dependency length is between 21 and 25, inclusive. The numbers drop to 47, 56 and 36 when the dependency length is between 26 and 30. The recall of our parser drops more quickly as the de-pendency length grows beyond 15. A likely reason is that the recovery of longer-range dependencies re-quires more processing steps, increasing the chance of the correct structure being thrown off the beam. In contrast, the precision did not drop more quickly than C&amp;C, and in fact is consistently higher than C&amp;C across all dependency lengths, which reflects the fact that the long range dependencies our parser managed to recover are comparatively reliable.
Table 3 shows the comparison of labeled precision (lp), recall (lr) and F-score (lf) for the most common CCG dependency types. The numbers for C&amp;C are for the hybrid model, copied from Clark and Curran (2007). While our shift-reduce parser gave higher precision for almost all categories, it gave higher re-call on only half of them, but higher F-scores for all but one dependency type. 6.3 Final results Table 4 shows the accuracies on the test data. The numbers for the normal-form model are evaluated by running the publicly available parser, while those for the hybrid dependency model are from Clark and Curran (2007). Evaluated on all sentences, the accuracies of our parser are much higher than the C&amp;C parser, since the C&amp;C parser failed to produce any output for 10 sentences. When evaluating both parsers on the sentences for which C&amp;C produces an analysis, our parser still gave the highest accuracies. The shift-reduce parser gave higher precision, and lower recall, than C&amp;C; it also gave higher sentence-level and lexical category accuracy.

The last two rows in the table show the accuracies of Fowler and Penn (2010) (F&amp;P), who applied the CFG parser of Petrov and Klein (2007) to CCG , and the corresponding accuracies for the C&amp;C parser on the same test sentences. F&amp;P can be treated as an-other chart-based parser; their evaluation is based on the sentences for which both their parser and C&amp;C produced dependencies (or more specifically those sentences for which generate could pro-duce dependencies), and is not directly comparable with ours, especially considering that their test set is smaller and potentially slightly easier.

The final comparison is parser speed. The shift-reduce parser is linear-time (in both sentence length and beam size), and can analyse over 10 sentences per second on a 2GHz CPU, with a beam of 16, which compares very well with other constituency parsers. However, this is no faster than the chart-based C&amp;C parser, although speed comparisons are difficult because of implementation differences (C&amp;C uses heavily engineered C++ with a focus on efficiency). Sagae and Lavie (2006a) describes a shift-reduce parser for the Penn Treebank parsing task which uses best-first search to allow some ambiguity into the parsing process. Differences with our approach are that we use a beam, rather than best-first, search; we use a global model rather than local models chained together; and finally, our results surpass the best published results on the CCG parsing task, whereas Sagae and Lavie (2006a) matched the best PTB results only by using a parser combination.
Matsuzaki et al. (2007) describes similar work to ours but using an automatically-extracted HPSG , rather than CCG , grammar. They also use the gen-eralised perceptron to train a disambiguation model. One difference is that Matsuzaki et al. (2007) use an approximating CFG , in addition to the supertagger, to improve the efficiency of the parser.
Ninomiya et al. (2009) (and Ninomiya et al. (2010)) describe a greedy shift-reduce parser for HPSG , in which a single action is chosen at each parsing step, allowing the possibility of highly ef-ficient parsing. Since the HPSG grammar has rela-tively tight constraints, similar to CCG , the possibil-ity arises that a spanning analysis cannot be found for some sentences. Our approach to this problem was to allow the parser to return a fragmentary anal-ysis; Ninomiya et al. (2009) adopt a different ap-proach based on default unification.

Finally, our work is similar to the comparison of the chart-based MSTParser (McDonald et al., 2005) and shift-reduce MaltParser (Nivre et al., 2006) for dependency parsing. MSTParser can perform ex-haustive search, given certain feature restrictions, because the complexity of the parsing task is lower than for constituent parsing. C&amp;C can perform ex-haustive search because the supertagger has already reduced the search space. We also found that ap-proximate heuristic search for shift-reduce parsing, utilising a rich feature space, can match the perfor-mance of the optimal chart-based parser, as well as similar error profiles for the two CCG parsers com-pared to the two dependency parsers. This is the first work to present competitive results for CCG using a transition-based parser, filling a gap in the CCG parsing literature. Considered in terms of the wider parsing problem, we have shown that state-of-the-art parsing results can be obtained using a global discriminative model, one of the few pa-pers to do so without using a generative baseline as a feature. The comparison with C&amp;C also allowed us to compare a shift-reduce parser based on heuristic beam search utilising a rich feature set with an opti-mal chart-based parser whose features are restricted by dynamic programming, with favourable results for the shift-reduce parser.

The complementary errors made by the chart-based and shift-reduce parsers opens the possibil-ity of effective parser combination, following sim-ilar work for dependency parsing.

The parser code can be downloaded at version 0.5.
 We thank the anonymous reviewers for their sugges-tions. Yue Zhang and Stephen Clark are supported by the European Union Seventh Framework Pro-gramme (FP7-ICT-2009-4) under grant agreement no. 247762.

