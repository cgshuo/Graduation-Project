 Syntactic analysis of search queries is important for a variety of tasks including better query refinement, improved matching and better ad targeting (Barr et al., 2008). However, search queries differ sub-stantially from traditional forms of written language (e.g., no capitalization, few function words, fairly free word order, etc.), and are therefore difficult to process with natural language processing tools trained on standard corpora (Barr et al., 2008). In this paper we focus on part-of-speech (POS) tagging queries entered into commercial search engines and compare different strategies for learning from search logs. The search logs consist of user queries and relevant search results retrieved by a search engine. We use a supervised POS tagger to label the result snippets and then transfer the tags to the queries, producing a set of noisy labeled queries. These la-beled queries are then added to the training data and the tagger is retrained. We evaluate different strate-gies for selecting which annotation to transfer and find that using the result that was clicked by the user gives comparable performance to using just the top result or to aggregating over the top-k results. The most closely related previous work is that of Bendersky et al. (2010, 2011). In their work, un-igram POS tag priors generated from a large cor-pus are blended with information from the top-50 results from a search engine at prediction time. Such an approach has the disadvantage that it necessitates access to a search engine at run-time and is com-putationally very expensive. We re-implement their method and show that our direct transfer approach is more effective, while being simpler to instrument: since we use information from the search engine only during training, we can train a stand-alone POS tagger that can be run without access to additional resources. We also perform an error analysis and find that most of the remaining errors are due to er-rors in POS tagging of the snippets. The main intuition behind our work, Bendersky et al. (2010) and R  X  ud et al. (2011), is that standard NLP annotation tools work better on snippets returned by a search engine than on user supplied queries. This is because snippets are typically well-formed En-glish sentences, while queries are not. Our goal is to leverage this observation and use a supervised POS tagger trained on regular English sentences to gen-erate annotations for a large set of queries that can be used for training a query-specific model. Perhaps the simplest approach  X  but also a surprisingly pow-erful one  X  is to POS tag some relevant snippets for a given query, and then to transfer the tags from the snippet tokens to matching query tokens. This  X  X i-rect X  transfer idea is at the core of all our experi-ments. In this work, we provide a comparison of techniques for selecting snippets associated with the query, as well as an evaluation of methods for align-ing the matching words in the query to those in the selected snippets.

Specifically, for each query 1 with a corresponding set of  X  X elevant snippets, X  we first apply the baseline tagger to the query and all the snippets. We match any query terms in these snippets, and copy over the POS tag to the matching query term. Note that this can produce multiple labelings as the relevant snip-pet set can be very diverse and varies even for the same query. We choose the most frequent tagging as the canonical one and add it to our training set. We then train a query tagger on all our training data: the original human annotated English sentences and also the automatically generated query training set.
The simplest way to match query tokens to snip-pet tokens is to allow a query token to match any snippet token. This can be problematic when we have queries that have a token repeated with differ-ent parts-of-speech such as in  X  X ie a tie. X  To make a more precise matching we try a sequence of match-ing rules: First, exact match of the query n-gram. Then matching the terms in order, so the query  X  X ie a a tie b  X  matched to the snippet  X  X o tie 1 a neck tie 2  X  would match tie a :tie 1 and tie b :tie 2 . Finally, we match as many query terms as possible. An early observation showed that when a query term occurs in the result URL, e.g., searching for  X  X rs mileage rate X  results in the page irs.gov , the query term matching the URL domain name is usually a proper noun. Consequently we add this rule.

In the context of search logs, a relevant snippet set can refer to the top k snippets (including the case where k = 1 ) or the snippet(s) associated with re-sults clicked by users that issued the query. In our experiments we found that different strategies for se-lecting relevant snippets, such as selecting the snip-pets of the clicked results, using the top-10 results or using only the top result, perform similarly (see Table 1).
By contrast Bendersky et al. (2010) use a lin-ear interpolation between a prior probability and the snippet tagging. They define  X  ( t | w ) as the relative frequency of tag t given by the baseline tagger to word w in some corpus and  X  ( t | w,s ) as the indica-tor function for word w in the context of snippet s has tag t . They define the tagging of a word as
We illustrate the difference between the two ap-proaches in Figure 1. The numbered rows of the table correspond to three snippets (with non-query terms elided). The strategy that uses the clicks to se-lect the tagging would count two examples of  X  X ud-get/NNP Rent/NNP A/NNP Car/NNP X  and one for each of two other taggings. Note that snippet 1 and the query get different taggings primarily due to orthographic variations. It would then add  X  X ud-get/NNP rent/NNP a/NNP car/NNP X  to its training set. The interpolation approach of Bendersky et al. (2010) would tag the query as  X  X udget/NNP rent/VB a/DET car/NN X . To see why this is the case, consider the probability for rent/VB vs rent/NNP. For rent/VB we have 0 . 2 + 0 . 8  X  2 3 , while for rent/NNP we have 0 + 0 . 8  X  1 3 assuming that  X  ( VB | rent ) = 1 . We assume that we have access to labeled English sentences from the PennTreebank (Marcus et al., 1993) and the QuestionBank (Judge et al., 2006), as well as large amounts of unlabeled search queries. Each query is paired with a set of relevant results represented by snippets (sentence fragments con-taining the search terms), as well as information about the order in which the results were shown to the user and possibly the result the user clicked on. Note that different sets of results are possible for the same query, because of personalization and ranking changes over time. 3.1 Evaluation Data We use two data sets for evaluation. The first is the set of 251 queries from Microsoft search logs (MS-251) used in Bendersky et al. (2010, 2011). The queries are annotated with three POS tags represent-ing nouns, verbs and  X  X ther X  tags (MS-251 NVX). We additionally refine the annotation to cover 14 POS tags comprising the 12 universal tags of Petrov et al. (2012), as well as proper nouns and a special tag for search operator symbols such as  X - X  (for excluding the subsequent word). We refer to this evaluation set as MS-251 in our experiments. We had two annotators annotate the whole of the MS-251 data set. Before arbitration, the inter-annotator agreement was 90.2%. As a reference, Barr et al. (2008) report 79.3% when annotating queries with 19 POS tags. We then examined all the instances where the annotators disagreed, and corrected the discrepancy. Our annotations are available at http://code.google.com/p/query-syntax/ .

The second evaluation set consists of 500 so called  X  X ong-tail X  queries. These are queries that oc-curred rarely in the search logs, and are typically difficult to tag because they are searching for less-frequent information. They do not contain naviga-tional queries. 3.2 Baseline Model We use a linear chain tagger trained with the aver-aged perceptron (Collins, 2002). We use the follow-ing features for our tagger: current word, suffixes and prefixes of length 1 to 3; additionally we use word cluster features (Uszkoreit and Brants, 2008) for the current word, and transition features of the cluster of the current and previous word. When training on Sections 1-18 of the Penn Treebank and testing on sections 22-24, our tagger achieves 97.22% accuracy with the Penn Treebank tag set, which is state-of-the-art for this data set. When we evaluate only on the 14 tags used in our experiments, the accuracy increases to 97.88%.

We experimented with 4 baseline taggers (see Ta-ble 2). WSJ corresponds to training on only the standard training sections of Wall Street Journal por-tion of the Penn Treebank. WSJ+QTB adds the QuestionBank as training data. WSJ NOCASE and WSJ+QTB NOCASE use case-insensitive version of the tagger (conceptually lowercasing the text before training and before applying the tagger). As we will see, all our baseline models are better than the base-line reported in Bendersky et al. (2010); our lower-cased baseline model significantly outperforms even their best model. First, we compared different strategies for selecting relevant snippets from which to transfer the tags. These systems are: D IRECT -CLICK , which uses snippets clicked on by users; D IRECT -ALL , which uses all the returned snippets seen by the user; 2 and D IRECT -TOP -1, which uses just the snippet in the top result. Table 1 compares these systems on our three evaluation sets. While D IRECT -ALL and D
IRECT -TOP -1 perform best on the MS-251 data sets, D IRECT -CLICK has an advantage on the long tail queries. However, these differences are small ( &lt; 0.6%) suggesting that any strategy for selecting relevant snippet sets will return comparable results when aggregated over large amounts of data.

We then compared our method to the baseline models and a re-implementation of Bendersky et al. (2010), which we denote BSC. We use the same matching scheme for both BSC and our system, in-cluding the URL matching described in Section 2. The URL matching improves performance by 0.4-3.0% across all models and evaluation settings.
Table 2 summarizes our final results. For com-parison, Bendersky et al. (2010) report 91.6% for their final system, which is comparable to our im-plementation of their system when the baseline tag-ger is trained on just the WSJ corpus. Our best sys-tem achieves a 21.2% relative reduction in error on their annotations. Some other trends become appar-ent in Table 2. Firstly, a large part of the benefit of transfer has to do with case information that is avail-able in the snippets but is missing in the query. The uncased tagger is insensitive to this mismatch and achieves significantly better results than the cased taggers. However, transferring information from the snippets provides additional benefits, significantly improving even the uncased baseline taggers. This is consistent with the analysis in Barr et al. (2008). Finally, we see that the direct transfer method from Section 2 significantly outperforms the method de-scribed in Bendersky et al. (2010). Table 3 confirms this trend when focusing on proper nouns, which are particularly difficult to identify in queries.
We also manually examined a set of 40 queries with their associated snippets, for which our best D
IRECT -CLICK system made mistakes. In 32 cases, the errors in the query tagging could be traced back to errors in the snippet tagging. A better snippet tagger could alleviate that problem. In the remain-ing 8 cases there were problems with the matching  X  either the mis-tagged word was not found at all, or it was matched incorrectly. For example one of the results for the query  X  X ell helmet X  had a snippet containing  X  X ell cycling helmets X  and we failed to match helmet to helmets.
 Barr et al. (2008) manually annotate a corpus of 2722 queries with 19 POS tags and use it to train and evaluate POS taggers, and also describe the lin-guistic structures they find. Unfortunately their data is not available so we cannot use it to compare to their results. R  X  ud et al. (2011) create features based on search engine results, that they use in an NER system applied to queries. They report report sig-nificant improvements when incorporating features from the snippets. In particular, they exploit capital-ization and query terms matching URL components; both of which we have used in this work. Li et al. (2009) use clicks in a product data base to train a tag-ger for product queries, but they do not use snippets and do not annotate syntax. Li (2010) and Manshadi and Li (2009) also work on adding tags to queries, but do not use snippets or search logs as a source of information. We described a simple method for training a search-query POS tagger from search-logs by transfer-ring context from relevant snippet sets to query terms. We compared our approach to previous work, achieving an error reduction of 20%. In contrast to the approach proposed by Bendersky et al. (2010), our approach does not require access to the search engine or index when tagging a new query. By ex-plicitly re-training our final model, it has the ability to pool knowledge from several related queries and incorporate the information into the model param-eters. An area for future work is to transfer other syntactic information, such as parse structures or su-pertags using a similar transfer approach.
