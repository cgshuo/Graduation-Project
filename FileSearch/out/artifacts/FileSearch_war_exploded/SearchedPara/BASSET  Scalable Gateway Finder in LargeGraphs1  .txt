 What is the best gateway between a source node and a target node, in a net-work? This is a core problem that appears under several guises, with numerous generalizations. Motivating applications include the following: 1. In a corporate social network, which are the key people that bring or hold 2. In an immunization setting, given a set of nodes that are infected, and a set 3. Similarly, in a network setting, which are the gateway nodes we should best The problem has several, natural generalizations: (a) we may be interested in the top k best gateways (in case our first few choices are unavailable); (b) we may have more than one source nodes, and more than one target nodes, as in the immunization setting above; (c) we may have a bi-partite graph with relationships (edges) between different node types, as in the last example above. Our main contributions in this paper are:  X  A novel  X  X ateway-ness X  score for a given source and target, that agrees with  X  Two algorithms to find a set of nodes with the highest  X  X ateway-ness X  score,  X  Extensive experimental results on real data sets, showing the effectiveness The rest of the paper is organized as follows: We give the problem definitions in Section 2; present  X  X ateway-ness X  sc ores in Section 3; and deal with the com-putational issues in Section 4. We evaluate the proposed methods in Section 5. Finally, we review the related work in Section 6 and conclude in Section 7. Table 1 lists the main symbols we use throughout the paper. In this paper, we focus on directed weighted graphs. We r epresent the graph by its normalized adjacency matrix ( A ). Following standard notation, we use capital bold letters for matrices (e.g., A ), lower-case bold letters for vectors (e.g., a ), and calli-graphic fonts for sets (e.g., S ). We denote the transpose with a prime (i.e., A is the transpose of A ). We use arrowed lower-case letters for paths on the graph (e.g., p ), which are ordered sequences. We use parenthesized superscripts to represent source/target information for the corresponding variables. For example p node t . If the source/target information is clear from the context, we omit the superscript for brevity. A sink node i on the graph is a node without out-links (i.e., A (: ,i ) = 0). We use subscripts to denote the corresponding variable after setting the nodes indexed by the subscripts as sinks. For example, p ( s,t ) I is the path from the source node s to the target node t , which does not go through any our problems can be formally defined as follows: Problem 1. (Pair-Gateway) Given: A weighted directed graph A , a source node s , a target node t ,anda Find: A set of at most k nodes which has the highest  X  X ate-way-ness X  score wrt Problem 2. (Group-Gateway) Given: A weighted directed graph A , a group of source nodes S , a group of Find: A set of at most k nodes which has the highest  X  X ate-way-ness X  score wrt In both Problem 1 (Pair-Gateway) and Problem 2 (Group-Gateway), there are two sub-problems: (1) how to define the  X  X ateway-ness X  score of a given subset of nodes I ; (2) how to find the subset of nodes with the highest  X  X ateway-ness X  score. In the next two sections, we prese nt the solutions for each, respectively. In this section, we present our definitions for  X  X ateway-ness X . We first focus on the case of a single source s and a single target t (Pair-Gateway). We then generalize to the case where both the source and the target are a group of nodes (Group-Gateway) 3.1 Node  X  X ateway-ness X  Score Given a single source s and a single target t ,wewanttomeasurethe X  X ateway-ness X  score for a given set of nodes I . We first give the formal definitions in such a setting and then provide some intuitions for our definitions.

For a graph A , we can use random walk with restart to measure the proxim-ity (i.e., relevance/closeness) from the source node s to the target node t ,which is defined as follows: Consider a random particle that starts from node s .The particle iteratively transits to its neighbors with probability proportional to the corresponding edge weights. Also at each step, the particle returns to node s with some restart probability (1  X  c ). The proximity score from node s to node t node s will spend on node t of the graph, after an infinite number of steps.
Intuitively, a set of nodes I are good gateways wrt s and t if they play an important role in the proximity measure from the source to the target. Therefore, our  X  X ateway-ness X  score can be defined as follows: where r I ( s, t ) is the proximity score from source s to t after setting the subset of nodes indexed by I as sinks. 3.2 Group  X  X ateway-ness X  Score Here we consider the case where the source and/or target consist of more than one nodes. Suppose we have a group of source nodes S and a group of target nodes T . Then, the  X  X ateway-ness X  score for a given set of nodes I can be defined in a similar way: where r I ( s, t ) is the proximity score from s to t by setting the subset of nodes indexed by I as sinks (i.e., delete all out-edges, by setting A (: ,i ) = 0 for all i  X  X  ). In this section, we address how to quickly find a subset of nodes of the highest  X  X ateway-ness X  score. We start by showing that the straight-forward methods (re-ferred to as  X  X om-RWR X ) are computationally intractable. Then, we present the proposed BASSET (BASSET-N for Pair-Gateway and BASSET-G for Group-Gateway). For each case, we first present the algorithm and then analyze its effectiveness as well as its co mputational complexity. 4.1 Computational Challenges Here, we present the computational challenges and the way we tackle them. For the sake of succinctness, we mainly focus on BASSET-N.

There are two main computational challenges in order to find a subset of nodes with the highest  X  X ateway-ness X  score. First of all, we need to compute the proximity from the source to the target on different graphs, each of which is a perturbed version of the original graph. This essentially means that we cannot directly apply some powerful pre-computational method to evaluate the proximity from the source to the target (after setting the subset of nodes indexed by I as sinks). Instead, we have to rely on on-line iterative methods, whose computational complexity is O ( m ). The challenges are compounded by the need to evaluate g( s, t, I )(eq.(1))org( S , T , I )(eq. (2)) an exponential number of times ( n k ). Putting these together, the straightforward way to find k nodes with the highest  X  X ateway-ness X  score is O ( n k m ). This is computationally intractable. Suppose on a graph with 1 , 000 , 000 nodes, we want to find the best k =5 gateway nodes. If computing each proximity score takes 0 . 001 seconds, then 2 . 64  X  10 17 years are needed to find the gateways. This is much longer than the age of the universe. 1
To tackle such challenges, we resort to two main ideas, which are summarized in Theorem 1. According to Theorem 1, in order to evaluate the  X  X ateway-ness X  score of a given set of nodes, we do not need to actually set these nodes as sinks and compute the proximity score on the new graph. Instead, we can compute it from the original graph. In this way, we can utilize methods based on pre-computation to a ccelerate the process. Furthermore, since g( s, t, I )and g(
S , T , I ) are sub-modular wrt I , we can develop some greedy algorithm to avoid exponential enumeration, and still get some near-optimal solution. In The-orem 1, A is the normalized adjacency matrix of the graph. It is worth pointing out that The proposed methods (BASSET-N and BASSET-G) we will intro-duce are orthogonal to the specific way of normalization. For simplicity, we use column-normalization throughout this paper. Also, Q ( I , I )isa |I| X |I| matrix, containing the elements in the matrix Q which are at the rows/columns indexed in the matrix Q which are at the t th row and the columns indexed by I . Q ( I ,s ) is a column vector with length |I| , containing the elements in the matrix Q which are at the s th column and the rows indexed by I .
 Theorem 1. Core Theorem. Let A be the normalized adjacency matrix of the ness X  X coreofasubsetofnodes I defined in eq. (1) satisfies the properties P1 and P2. For a given source group S and target group T , the  X  X ateway-ness X  score of asubsetofnodes I defined in eq. (2) satisfies the properties P3 and P4, where s = t , s, t /  X  X  , S P1. g ( s, t, I )= Q ( t, I ) Q ( I , I )  X  1 Q ( I ,s ) ; P2. g ( s, t, I ) is sub-modular wrt the set I .
 P3. g ( S , T , I )= s  X  X  ,t  X  X  Q ( t, I ) Q ( I , I )  X  1 Q ( I ,s ) ; P4. g ( S , T , I ) is sub-modular wrt the set I .
 Proof of P1: WLOG, we assume that I = { n  X  k +1 , ...n } .Let A and  X  A be the normalized adjacency matrices of th e graph before/after we set the subset of nodes in I as sinks. Write A and  X  A in block form: where 0 is a matrix with all zero elements.
 Let  X  Q =(1  X  c )( I  X  c  X  A )  X  1 . We can also write  X  Q and Q in block form: Applying the block matrix inverse lemma [12] to  X  Q and Q ,wegetthefollowing equations: Therefore, we have On the other hand, based on the properties of random walk with restart [15], eq. (5), we have which completes the proofs of P1. * + Proof of P3: Since P1 holds, we have which completes the proofs of P3. * + ProofofP2: Let I , J , K be three subsets and I X  X  . We will first prove by induction that, for any integer power j , the following inequality holds element-wise.
 It is easy to verify the base case (i.e., j = 1) for eq. (8) holds. Next, assume that j = j 0 +1: In eq. (9), the first inequality holds because of the induction assumption. The second inequality holds because A I  X  A J  X  0 holds element-wise, and A I . K  X  A J . K  X  0 holds element-wise.

Since  X  Q =(1  X  c )( I  X  c  X  A )  X  1 =(1  X  c )  X  j =0 ( c  X  A ) j ,wehave Therefore, g( s, t, I ) is sub-modular, which completes the proof of P2. * + is a non-negative linear combination of sub-modular functions) , according to the linearity of sub-modular functions [8], we have that g( S , T , I ) is also sub-modular, which completes the proof of P4. * + 4.2 BASSET-N for Problem 1 BASSET-N Algorithm. Our fast solution for Problem 1is summarized in Alg. 1. in each outer loop, we try to find one more node while keeping the current I un-changed.AccordingtoP1oftheorem1, v ( i ) computed in step 7 is the gateway score for the subset J . 2 If the current subset of nodes I can completely disconnect the algorithm (step 12). Therefore, Alg. 1 always returns no more than k nodes. It is worth pointing out that in Alg. 1, all the proximity scores are computed from the original graph A . Therefore, we can utilize some powerful methods based on pre-computation to accelerate t he whole process. To name a few, for a medium size graph A (e.g., a few thousands of nodes), we can pre-compute and store the matrix Q =(1  X  c )( I  X  c A )  X  1 ; for large unipartite graphs and bipartite graphs, we can use the NB LIN and BB LIN algorithms, respectively [15].
 Analysis of BASSET-N. In this subsection, we analyze the effectiveness and the efficiency of Alg. 1. First, the effect iveness of the proposed BASSET-N is guaranteed by the following lemma. According to Lemma 1, although BASSET-N is a greedy algorithm, the results it outputs are near-optimal .
 Lemma 1. Effectiveness of BASSET-N. Let I be the subset of nodes se-lected by Alg. 1 and |I| = k 0 .Then,g ( s, t, I )  X  (1  X  1 /e ) max |J| = k where g ( s, t, I ) ,andg ( s, t, J ) are defined by eq. (1) .
 Proof: It is easy to verify that the node i 0 selected in step 10 of Alg. 1 satisfies i Algorithm 1. BASSET-N empty set. On the other hand, according to Theorem 1, g( s, t, I ) is sub-modular wrt the subset I . Therefore, we have g( s, t, I )  X  (1  X  1 /e )max |J| = k which completes the proof. * + Next, we analyze the efficiency of BASSET-N, which is given in Lemma 2 3 .We can draw the following two conclusions, according to Lemma 2: (1) the proposed BASSET-N achieves a significant speedup over the straight-forward method ( O ( n  X  k )vs. O ( n k m )). For example, in the graph with 100 nodes and 1,000 edges, in order to find the gateway with k = 5 nodes, BASSET-N is more than 6orders of magnitude faster, and the speedup quickly increases wrt the size of the graph; (2) the proposed BASSET-N is applicable to large graphs since it is linear wrt the number of the nodes.
 Lemma 2. Efficiency of BASSET-N. The computational complexity of Alg. 1 is upper bounded by O ( n  X  k 4 ) .
 Proof: The cost for steps 1-2 is constant. The cost for step 3 is O ( n ). At each The outer loop has no more than k  X  1 iterations. Putting these together, the computational cost for BASSET-N is: which completes the proof. * + 4.3 BASSET-G for Problem 2 BASSET-G Algorithm. Our fast solution for Problem 2 is summarized in Alg. 2. It works in a similar way as Alg. 1: after initialization (step 1), we first 4-14, we find the rest of the nodes in a greedy way. That is, in each outer-loop, we try to find one more node while keeping the current I unchanged. If the current subset of the nodes I can completely disconn ectthesourcegroupand the target group (by setting them as sinks), we will stop the algorithm (step 10). As in Alg. 1, all the proximity scores are computed from the original graph A . Therefore, we can again utilize those powe rful pre-computation based methods to accelerate the whole process.
 Algorithm 2. BASSET-G Analysis of BASSET-G. The effectiveness and efficiency of the proposed BASSET-G are given in Lemma 3 and Lemma 4, respectively. Similar as BASSET-N, the proposed BASSET-G is (1) near-optimal ; and (2) fast and scalable for large graphs.
 Lemma 3. Effectiveness of BASSET-G. Let I be the subset of nodes se-lected by Alg. 2 and |I| = k 0 .Then,g ( S , T , I )  X  (1  X  1 /e ) max |J| = k where g ( S , T , I ) ,andg ( S , T , J ) are defined by eq. (2) .
 Proof: Similar as for Lemma 1. Omitted for brevity. * + Lemma 4. Efficiency of BASSET-G. The computational complexity of Alg. 2 is upper bounded by O ( n  X  ( max ( k, |S| , |T | )) 4 ) .
 Proof: Similar as for Lemma 2. Omitted for brevity. * + In this section we present experimental results. All the experiments are designed to answer the following questions:  X  Effectiveness: how effective are the  X  X ateway-ness X  scores in real graphs?  X  Efficiency: how fast and scalable are BASSET-N and BASSET-G? 5.1 Data Sets We used three real data sets, which are summarized in table 2.

The first data set ( PolBooks ) is a co-purchasing book network. 4 Each node is a political book and there is an edge between two books if purchased by the same person. Overall, we have n = 105 nodes and m = 882 edges.

The second data set ( AA ) is a co-authorship network, where each node is an author and the edge weight is the numbe r of the co-authored papers between the two corresponding persons. Overall, we have n = 418 , 236 nodes and m = 2 , 753 , 798 edges.

The last data set ( NetFlix ) is from the Netflix prize 5 . Rows represent users and columns represent movies. If a user has given a particular movie positive ratings (4 or 5), we connect them with an edge. In total, we have 2,667,199 nodes (2,649,429 users and 17,770 movies), and 56,919,190 edges. 5.2 Effectiveness Here, we evaluate the effectiveness of the proposed  X  X ateway-ness X  scores. We first compare with several candidate methods in terms of separating the source from the target. And then, we present various case studies.
 Quantitative Comparisons. The basic idea of the proposed  X  X ateway-ness X  scores is to find a subset of nodes which collectively play an important role in measuring the proximity from the source node (or source group) to the target node (or target group). Here, we want to validate this basic assumption. We compare it with the following alternative choices: (a) selecting k nodes with the highest center-piece AND score (CePS-AND) [13]; (b) selecting k nodes with the highest center-piece OR score (Ce PS-OR) [13]; (c) randomly selecting k nodes (Rand); (d) randomly selecting k nodes from the neighboring nodes of the source node and the target node (Neighbor-Rand); (e) selecting k nodes a target node t , 6 and then use the different methods to select a subset I with k nodes. Figure 2 presents the comparison results, where the x-axis is the number of nodes selected ( k ), and the y-axis is the normalized decay in terms of the resulting curves are averaged over 1,000 randomly chosen source-target pairs. From table 3, we can see that (1) the proposed BASSET-N performs best in terms of separating the source from the target; (2)Topk-Ind, where we simply where we want to find a subset of k nodes which collectively has the highest score r ( I ,t ) r ( I , I )  X  1 r ( s, I ) .
 Case Studies. Next, we will show some case studies, to demonstrate the effec-tiveness of BASSET-N and BASSET-G.
 PolBooks . For this data set, the nodes are political books and the existence of the edge indicates the co-purchasing (by the same person) of the two books. Each book is annotated by one of the following three labels:  X  X iberal X ,  X  X onservative X  and  X  X eutral X . We pick a  X  X iberal X  book ( X  X he Price of Loyalty X ) as the source node, and a  X  X onservative X  book ( X  X osing Bin Laden X ) as the target node. Then, we ran the proposed BASSET-N to find the gateway with 10 nodes. The result is presented in table 4. The result is again consistent with human intuition, -the resulting gate-way books are either popular books in one of the two communities ( X  X onservative X  vs.  X  X iberal X ) such as,  X  X ush country X  from  X  X onservative X ,  X  X ack up suck up X  from  X  X iberal X , etc; or those  X  X eutral X  books which are likely to be purchased by readers from both communities (e.g.,  X  X leeping with the devil X , etc). AA . We use this data set to perform case studies for the proposed BASSET-G. We choose (1) a group of people from a certain field (e.g.,  X  X ext X ,  X  X heory X , etc) as the source group S ; and (2) another group of people in some other field (e.g.,  X  X atabases X ,  X  X ioinfomatics X , etc) as the target group T . Then, we ran the proposed BASSET-N to find the gateway with k = 10 nodes. Table 5 lists some results. They are all consistent with human intuition, -the resulting authors are either productive authors in one of the two fields, or multi-disciplinary, who have close collaborations to both the source and the target groups of authors. 5.3 Efficiency We will study the wall-clock running time of the proposed BASSET-N and BASSET-G here. Basically, we want to answer the following two questions: 1. (Speed) What is the speedup of the proposed BASSET-N and BASSET-G 2. (Scalability) How do BASSET-N and BASSET-G scale with the size of the First, we compare BASSET-N and BASSET-G with two straightforward meth-ods: (1)  X  X om-RWR X , where we use combinatorial enumeration to find the gateway and, for each enumeration, we compute the proximity from the new graph; and (2)  X  X om-Eval X , where we use combinatorial enumeration to find the gateway, and for each enumeration, we compute the proximity from the original graph. Figure 1 shows the comparison on PolBooks graph. We can draw the following conclusions. (1) Straightforward methods ( X  X om-RWR X  and  X  X om-Eval X ) are computationally intractable even for a small graph. For example, it takes more than 1 , 000 seconds and 100 , 000 seconds to find the k = 5 gateway by  X  X om-Eval X  and by  X  X om-RWR X , respectively. (2) The speedup of the proposed BASSET-N and BASSET-G over both  X  X om-Eval X  and  X  X om-RWR X  is significant -in most cases, we achieve several (upto6)ordersofmagnitude speedups. (3) The speedup of the proposed BASSET-N and BASSET-G over both  X  X om-RWR X  and  X  X om-Eval X  quickly increases wrt thesizeofthegateway k . Note that we stop running the program if it takes more than 100,000 seconds (i.e., longer than a day).

Next, we evaluate the scalability of the proposed BASSET-N and BASSET-G wrt the size of the graph, using the largest data set ( NetFlix ). From figure 2, we can make the following conclusions: (1) if we fix the number of nodes ( n ) in the graph, the wall-clock time of both BASSET-N and BASSET-G is almost constant wrt the number of edges ( m ); and (2) if we fix the number of edges ( m ) in the graph, the wall-clock time of both BASSET-N and BASSET-G is linear wrt the number of nodes ( n ). Therefore, they are sui table for large graphs. In this section, we review the related wo rk, which can be categorized into three parts: Betweenness centrality. The proposed  X  X ateway-ness X  scores relate to mea-sures of betweenness centrality, both th ose based on the shortest path [4], as well as those based on random walk [10]. When the gateway set size is k =1, the proposed  X  X ateway-ness X  scores can be viewed as query-specific betweenness centrality measures. Moreover, in the proposed BASSET-N and BASSET-G, we aim to find a subset of nodes collectively , wherein traditional betweenness cen-trality, we usually calculate the score for each node independently (and then might pick k nodes with the highest individual scores).
 Connection subgraphs. In the proposed BASSET-N, the idea of finding a subset of nodes wrt the source/target is al so related to the concept of connection subgraphs, such as [3,7,13]. However, in connection subgraphs, we aim to find a subset of nodes which have strong connections among themselves for the purpose of visualization. While in the proposed BASSET-N, we implicity encourage the resulting subset of nodes to be disconnected with each other so that they are able to collectively disconnect the target node from the source node to the largest extent (if we set them as sinks).
 Graph proximity. The basic idea of the proposed BASSET-N and BASSET-G is to find a subset of nodes which will bring the largest decrease of the prox-imity score from the source node (or the source group) to the target node (or the target group). Graph proximity itself is an important building block in many graph mining settings. Representative work includes the BANKS system [1], link prediction [9], content-based image retrieval [6], cross-modal correlation discov-ery [11], pattern matching [14], ObjectRank [2], RelationalRank [5], etc. In this paper, we study how to find good  X  X ateway X  nodes in a graph, given one or more source and target nodes. Our main contributions are: (a) we formulate the problem precisely; (b) we develop BASSET-N and BASSET-G, two fast (up to 6,000,000x speedup) and scalable ( linear wrt the number of the nodes in the graph) algorithms to solve it in a provably near-optimal fashion, using sub-modularity. We applied the proposed BASSET-N and BASSET-G on real data sets to validate the effectiveness and efficiency.
 This material is based upon work supported by the National Science Foun-dation under Grants No. DBI-0640543 IIS-0705359 CNS-0721736 IIS0808661 iCAST and was performed under the auspices of the U.S. Department of En-ergy by Lawrence Livermore National Laboratory under contract No. DE-AC52-07NA27344. This work is also partially supported by an IBM Faculty Award, a SPRINT gift, with additional funding from Intel, and Hewlett-Packard. Any opinions, findings, and conclusions or recommendations expressed in this ma-terial are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, or other funding parties.

