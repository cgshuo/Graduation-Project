 To overcome problems of Apriori-based algorithms [1, 2], such as generation and test methods mine the complete set of frequent patterns using a divide and conquer method to reduce the search space without generating all the candidates. An associa-tion mining algorithm generates frequent patterns and then makes association rules satisfying a minimum support. Two main limi tations of the traditional approach exist when mining frequent patterns. ferent importance. For this reason, weighted frequent pattern mining algorithms [3, 4, database. These algorithms focus on satisfying the downward closure property be-discovered patterns. The key observation here is that long patterns can be interesting support. LPMiner [7] and Bamboo [8] have addressed these issues. As stated in [7, 8, 9], the downward closure property can not be used with length decreasing support duced to prune the search space. The weight constraint and the length decreasing support constraint are key factors, but no mining algorithms consider both constraints. 
In this paper, we re-examine two basic but interesting constraints, a weight con-straint and a length decreasing support constraint and propose weighted frequent pat-tern mining with length decreasing support constraints. The simple way to use a length decreasing support constraint is to set min l&gt;0 f(l) and remove patterns which do not satisfy the length decreasing constraints. However, it takes a lot of time to gener-ate frequent patterns. WLPMiner takes into account two features, a weight constraint and a length decreasing support constraint in real world instead of only resetting the minimum support. This allows WLPMiner to generate more meaningful patterns. For pruning techniques, we propose 1) the notion of Weighted Smallest Valid Extension (WSVE) to apply to both the length decreasing support constraints and weight con-straints and 2) a weight range is used as a supplement to maintain the downward clo-sure property. Our Contributions: The main contributions of this paper are: 1) incorporation of two property, 3) description of pruning techniques, transaction pruning and node pruning, using the weighted smallest valid extension property, 4) implementation of our algo-rithm, WLPMiner, and 5) execution of an extensive experimental study to compare the performance of our algorithm with BAMBOO [8] and WFIM [3]. problem definition and related work. In Section 3, we present WLPMiner (Weighted Frequent Pattern Mining with Length decreasing support constraints). Section 4 shows the extensive experimental study and results. Finally, conclusions are presented in section 5. transactions in which each transaction, denoted as a tuple &lt;tid, X&gt;, contains a unique {x ber of transactions containing the pattern in the database. 2.1.1 Weighted Frequent Itemset Mining In weighted frequent itemset mining, a weight of an item is a non-negative real num-ber that shows the importance of the item. We can use the term, weighted itemset to calculate the average value of the weights of the items in the itemset. The weight of base. A weight is given to an item within a weight range, W min  X  W  X  W max . We want to give a balance between the two measures of weight and support. Therefore, we use a minimum weight constraint (min_weight) like a minimum support (min_sup) in order to prune items which have lower weights. condition 2 below is satisfied. If an itemset does not satisfy both of these, it is called a weighted frequent itemset. In the pruning conditions, a maximum weight (MaxW) is defined as the value of the maximum weight of items in a transaction database and a minimum weight (MinW) is defined as the value of the minimum weight of a condi-tional pattern in a conditional database. Pruning Condition 1: (support &lt; min_sup &amp;&amp; weight &lt; min_weight) The support of an itemset is less than a minimum support and the weight of an itemset is less than a minimum weight threshold. Pruning Condition 2: (support * MaxW (MinW) &lt; min_sup) In a transaction database, the value of mu ltiplying the support of an itemset with the maximum weight (MaxW) among items in the transaction database is less than a minimum support. In conditional databases, the value of multiplying the support of an less than a minimum support. Example 1: Table 1 shows the transaction database TDB. Table 2 shows example The minimum support threshold (min_sup) is 2. The columns in Table 3 show the set of weighted frequent itemsets after pruning weighted infrequent itemsets using prun-ing condition1 and pruning condition 2 by applying different WRs. 2.1.2 Frequent Itemset Mining with a Length Decreasing Support Constraint The length decreasing support constraint was suggested from the observation that long become interesting if they have high support. Given a transaction database TDB and its |TDB| for any positive integer x, frequent itemset mining with length decreasing support 
The itemsets found are called frequent itemsets with a length decreasing support constraint. However, the downward closure property can not be used to find a fre-quent itemset with a length decreasing support constraint because an infrequent item-set may become a frequent itemset in the next step using a length decreasing support (support (P)) = min (l| f (l)  X  support (P)) is the minimum length that a super itemset straint. The SVE property can be used to prune the conditional FP trees. Example 2: We use the transaction database TDB in Table 1 and assume that a length  X  f:3, g:1&gt;. By using a constant minimum support threshold, the frequent itemsets are {ac:2, bc:2, bd3, bf:2, cd:3, cf:3, df:2, bcd:2, bcf:2}. We can easily show that the final frequent itemset using length support constraint f(x) is {bc:4, bd:3, cd:3 and cf:3}. 2.2 Related Work No association rule mining algorithms exist that consider both a weight constraint and a length decreasing support constraint, both of which are characteristics of real data-suggested so far have used Apriori-like a pproaches. Therefore, previous algorithms for weighted association rule mining generate many candidates and scans of the data-base. Recently, we have suggested WFIM (Weighted Frequent Itemset Mining) weighted itemset mining. WFIM can push weight constraints into the pattern growth algorithm while maintaining the downward closure property. A minimum weight and range. However, the WFIM did not take into account a length decreasing support constraint. In WARM (Weighted Association Rule Mining) [4], the problem of breaking the downward closure property is solved by using a weighted support and developing a weighted downward closure property. However, this algorithm is still based on the Apriori algorithm which uses a candidate generation and test mecha-nism. WAR (Weighted Association rules) [5] generates the frequent items without considering the weights and then does post-processing during the rule generation step. The WAR algorithm does not concern mining frequent itemsets, so this technique is a Extension (SVE) property. Assigning weights according to the importance of the items is one of the main considerations for real datasets. However, LPMiner dose not creasing support constraints. BAMBOO [8] pushed the length decreasing support sets. While BAMBOO outperforms LPMiner, it is only concerned with the length decreasing support constraint. BAMBOO also does not consider different weights of items within patterns. 
In this paper, we propose an efficient weighted pattern growth algorithm with a length decreasing support constraint. We use a prefix tree structure to construct condi-tional databases. Our algorithm adopts an ascending weight order method and a bot-tom-up traversal strategy. with a length decreasing support constraint, called WLPMiner. Our approach is to growth algorithm. We introduce the weighted smallest valid extension (WSVE) prop-weight constraint and a length decreasing support constraint generates fewer but im-portant patterns. 3.1 Weighted Smallest Valid Extension (WSVE) Property and Pruning by Definition 3.1. Weighted Smallest Valid Extension (WSVE) Property (support (P) * weight (P)) = min (l| f (l)  X  (support (P) * weight (P))) is the minimum deceasing support constraint. Lemma 3.1. As the value, x, of multiplying the support with the weight of pattern P constraint function increases. Meanwhile, as the value of x increases, the value of the inverse function of a length decreasing support constraint function, f -1 (x) decreases. 
The WSVE property allows us to prune the search space. It considers not only a support measure but also a weight measure. From the WSVE property, if the pattern P frequent pattern, so it can be pruned. Lemma 3.2 Given a conditional pattern, X, and a pattern in the conditional database, Y, weight (X) is greater than or equal to a weight of a pattern, Y within a transac-tion t in the conditional database. WLPMiner uses an ascending weight ordered prefix tree and the tree is traversed conditional database. Lemma 3.3. The following formula is always satisfied: f -1 (support (X) * weight (X))  X  f -1 (support (X) * weight (Y))  X  f -1 (support (X+Y) * weight (Y)). 
As stated in lemma 3.2, weight (X) is al ways greater than or equal to weight (Y) and weight (X+Y) is always greater than or equal to weight (Y). From lemma 3.1, we (support (X) * weight (Y)) is less than or equal to f -1 (support (X+Y) * weight (Y)). In lemma 3.3, we see that f -1 (support (X) * weight (X)) is the minimum length for a superset (X+Y) of a conditional pattern (X). Weighted frequent patterns with a length decreasing support constraint should satisfy the WSVE property, although other pat-terns may also satisfy the WSVE property. 
Using the weighted smallest valid extension property, we suggest two pruning techniques, transaction pruning and node pruning. Transaction pruning is applied before constructing FP-tree, while node pruning is used after building FP-tree. Definition 3.2. Transaction Pruning by Weighted Smallest Valid Extension (WSVE) Given a length decreasing support constraint f(l), and a conditional database D` with regard to a conditional pattern X, a pattern Y  X  D` can be pruned from D` if ((support (X) * weight (X)) &lt; f (|X| + |Y|)). 
The transaction pruning method is used to remove candidate transactions of a con-WSVE property, any superset (X+Y) of a conditional pattern (X) must have a length length of less than f -1 (support (X) * weight (X)) -|X|. This formula can be rewritten weight (X)) &lt; f (|X| + |Y|). Definition 3.3. Node Pruning by Weighted Smallest Valid Extension (WSVE) with regard to a conditional pattern P, and the FP tree, T, built from D`, a node v in T can be pruned from T if h (v) + |P| &lt; f -1 (support(I (v)) * weight (I (v))). 
The node pruning method reduces nodes of a conditional local FP-tree. Assume that I(v) is the item stored in this node and h(v) is the height of the longest path from the root to a leaf node in which path, the node v should be located. From the weighted smallest valid extension property, we can see that a node that contributes to a (support (I(v)) * weight (I(v))). Therefore, we can define node pruning by the weighted smallest valid extension in definition 3.1. This formula can be rewritten as: f (support (I(v)) * weight (I(v))). Assume that the transactions of the conditional data-order. Let t be a transaction and l (t) be its length. For practical considerations, we can (I (v)) * weight (I (v))). Definition 3.4. Weighted Frequent Pa ttern with Length decreasing support A pattern is a weighted frequent pattern with length decreasing support constraints if all of the following pruning conditions are satisfied. If a pattern does not satisfy any-one of them, the pattern is called a weighted infrequent pattern with length decreasing support constraints. Pruning condition 1: (support  X  f (maxLength) || weight  X  min_weight) Pruning condition 2: (support * MaxW (MinW)  X  f (maxLength) Pruning condition 3: Transaction pruning by the WSVE property Pruning condition 4: Node pruning by the WSVE property maximum weight (MaxW) among items in the transaction database is less than f pattern with a minimum weight (MinW) of a conditional pattern in the conditional database is less than f (|maxLength|), a length decreasing minimum support. 
In WLPMiner, an ascending weight order method and a bottom-up traversal strat-egy are used in mining weighted frequent patterns. WLPMiner defines weighted Smallest Valid Extension property and prunes transactions and nodes by the WSVE property. The performance of pruning conditions 1 and 2 may not be good since the must be used in order to keep downward closure property. However, performance can be improved by using these pruning conditions with the weighted smallest valid ex-tension property and the weight range. The weighted smallest valid extension and the downward closure property are both used to prune the search space. 3.2 WLPMiner Algorithm The WLPMiner algorithm uses a weight range and a minimum weight. Items are given different weights within the weight range. We now the weighted frequent pat-tern mining process and present the mining algorithm. WLPMiner algorithm: Mining weighted frequent patterns with a length decreasing support constraint Input: (1) A transaction database: TDB (2) f(x): a length decreasing support constraint function (3) weights of the items within weight range : w i (4) minimum weight threshold : min_weight length decreasing support constraint. Begin 1. Let WFP be the set of weighted frequent patterns that satisfy the length decreasing support constraint. Initialize WFP  X  0; 2. Scan TDB once to find the global weighted frequent items satisfying the following conditions 1 and 2 are not satisfied. Condition 2.1: (support &lt; f(maxLength) &amp;&amp; weight &lt; min_weight) The support of a pattern is less than a minimum support and the weight of a pattern is less than a minimum weight constraint. Condition 2.2: (support * MaxW &lt; f(maxLength)) maximum weight (MaxW) of each item in the transaction database is less than a minimum support. list forms the weighted frequent list. 4. Scan the TDB again and build a global FP-tree using weight_order. 5. Call WLPMiner (FP-tree, 0, WFP) Procedure WLPMiner (Tree,  X  , WFP) 1: for each a i in the header of Tree do 2: set  X  =  X  U a i ; 3: get a set I  X  of items to be included in  X  conditional database, CDB  X  ; 4: for each item in I  X  , compute its count in  X  conditional database; 5: for each b j in I  X  do 7: if (sub (  X  b j ) * MinW &lt; f(maxLength)) delete b j from I  X  ; 8: end for 9: CDB  X   X  transaction_pruning_by_WSVE (  X  , CDB  X  ); 10: Tree  X   X  FP_Tree_Construction (I  X  , CDB  X  ) 11: Tree  X   X  node_pruning_by_WSVE (  X  , Tree  X  ); 12: if Tree  X   X  0 then 13: call WLPMiner (Tree  X  ,  X  , WFP) 14: end if 15: end for 
In the WLPMiner algorithm, TDB is scanned once, weighted frequent items satis-fying condition 2.1 and condition 2.2 are found and these items are sorted in weight WLPMiner (Tree,  X  , WFP). Lines 6 and 7 generate weighted frequent patterns with a length decreasing constraint. Line 9 conducts transaction pruning by the WSVE prop-serted into a local FP-tree. After a local FP-tree is constructed in line 10, node pruning by the WSVE property is carried out in line 11. WLPMiner algorithm adopts the bot-line 13. In this section, we present our performance study over various datasets. WLPMiner is datasets. We report our experimental results on the performance of WLPMiner in comparison with recently developed algorithms such as BAMBOO and WFIM. Our results show that WLPMiner not only generates more concise and important result sets, but also has much better performance than recently developed mining algorithms through incorporating a length decreasing support constraint into weighted frequent pattern mining. Moreover, WLPminer has good scalability of the number of transac-tions. In our experiments, we compared WLPMiner with BAMBOO [8] which is a frequent pattern mining algorithm with a length decreasing support constraint. We also compared WLPMiner with WFIM [3] that is a weighted frequent pattern mining algorithm developed recently. We used one real dataset and one synthetic dataset that are popularly used in pervious experiments [3, 8, 11, 12, 13]. Table 4 shows the char-acteristic of two datasets used for performance evaluation. The real dataset used is the generated from IBM dataset generator. We used T10I4D100k which is very sparse and contains 100,000 transactions. However, the synthetic datasets T10I4Dx contain 200k to 1000k transactions. To test scalability, T10I4Dx datasets have been popularly used in the previous performance evaluations [3, 8, 12, 13]. WLPMiner was written in C++. Experiments were performed on a sparcv9 processor operating at 1062 MHz, with 2048MB of memory. All experiments were performed on a Unix machine. In our experiments, a random generation function generates weights for each item. When running WLPMiner, the minimum support was determined as the cut off value for the maximum pattern length under the corresponding length decreasing support con-straint. performance evaluation for different datasets. These length decreasing support con-straints are the same as those used in BAMBOO [8]. LPMiner [7] and BAMBOO [8] are recently developed mining algorithms us ing length decreasing support constraints. Bamboo outperforms LPMiner in terms of runtime and the number of frequent pat-terns. Therefore, we compared WLPMiner with BAMBOO. Fig. 3 to Fig. 6 show the comparison results for datasets connect and T10I4D100K. In Fig. 3 and Fig 5, we can see WLPMiner generates smaller weighted frequent pat-WLPMiner is much faster than BAMBOO. Although WLPMiner and BAMBOO algorithms use a length decreasing support constraint, WLPMiner outperforms BAMBOO because WLPMiner uses the Weight ed Smallest Valid Extension property WLPMiner and WFIM [3] are both weighted frequent pattern mining algorithms. We weighted frequent patterns of WLPMiner with those of WFIM and BAMBOO. Fig. 6 shows the runtime of the algorithms under the same weight range. In Fig. 5 and Fig. orders of magnitude faster than WFIM since the Weighted Smallest Valid Extension property for the length decreasing support constraint is effective and efficient in prun-ing the result set in both the connect and T10I4D100K dataset. Scalability Test WLPMiner scales much better than previous mining algorithms. In this scalability test, WLPMiner is compared with BAMBOO. BAMBOO shows linear scalability with the number of transactions from 200k to 1000k. However, WLPMiner is much more scalable than BAMBOO. From Fig 7, the difference between the two algorithms becomes clear. We first tested the scalability in terms of base size from 200K tuples to 1000K tuples and different minimum support of 0.001% to 0.005%. From Fig. 7, slope ratio for each different minimum support is almost similar. We developed the WLPMiner algorithm that integrates a weight constraint measure with a length decreasing support constraint measure for mining frequent patterns. The weight constraint with a length decreasing support constraint improves performance In future work, the WSVE property will be used with different pruning techniques suggested in other algorithms using length decreasing support constraints. We would like to thank Dr. George Karypis and Dr. Jianyong Wang for providing executable code for the BAMBOO algorithm. 
