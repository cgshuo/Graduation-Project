 Abstract This paper presents Xigt, an extensible storage format for interlinear glossed text (IGT). We review design desiderata for such a format based on our own use cases as well as general best practices, and then explore existing representations of IGT through the lens of those desiderata. We give an overview of the data model and XML serialization of Xigt, and then describe its application to the use case of representing a large, noisy, heterogeneous set of IGT.
 Keywords Interlinear glossed text (IGT) Annotation Storage format 1 Introduction In this paper, we propose a new model for representing a distinctive datatype of linguistics, interlinear glossed text (IGT), and its extension enriched IGT which consists of the original IGT plus additional layers of annotation (e.g. word alignment and parse trees). IGT is a datatype that emerged from linguistic research as a way of compactly displaying a range of annotations which are of interest to linguists working in a variety of subfields, including structural subfields (most notably syntax, but also others), typology, and descriptive and documentary linguistics. As a display format, IGT serves to make linguistic examples more comprehensible by pairing source language strings 1 with translations into a language of wider communication and word-by-word (often morpheme-by-morpheme) annotations of the source language string. This helps other linguists reading the discussion of the example understand how the language under study is expressing the meaning indicated in the translation line. A simple example from Shona (adapted from Toews 2009 ) is shown in (1): We will refer to the first line of this example as the source language line, the second as the morpheme-segmented line, the third as the gloss line, and the fourth as the translation. 2
Recent years have seen much interest in the standardization of storage formats (in contrast to display formats) for IGT. This interest has been driven in large part by the needs and goals of the documentary linguistics community. In particular, the representations proposed so far have been developed in the context of either tools supporting the production of large collections of IGT (such as are produced in many documentary linguistics projects) or the long-term preservation of such collections. Our focus, somewhat in contrast, is on the reuse of IGT through automated processing and accommodating additional layers of annotation in the enriched IGT. Section 2 provides some further background on IGT as a datatype and on enriched IGT. In Sect. 3 , we describe our use cases and the desiderata they motivate regarding the design of a representation format for IGT. In Sect. 4 , we review existing IGT representation formats through the lens of these desiderata. We then present our new format, Xigt, in Sect. 5 and discuss a case study of importing a large, heterogeneous collection of IGT to Xigt in Sect. 6 . Finally, Sect. 7 concludes with a discussion of future work. 2 Interlinear glossed text and enriched IGT In order to support the following discussion, we draw a distinction between the display formats and storage formats of IGT. A display format specifies conventions of lay-out on a (virtual) page for human consumption. The IGT example in (1) conforms to a common display format for IGT, where the order of lines and the white space between items serve as cues to human readers as to the import of each symbol in the representation. A storage format is meant for machine consumption and typically uses devices other than lay-out to make the role of each part of the IGT explicit. The representation we propose here, Xigt, is intended as a storage format. In our use cases (see Sect. 3 ) we translate IGT from other storage formats (those of tools presently used by documentary linguists developing IGT collections) or in fact display formats [the IGT collected from PDFs by the ODIN project (Lewis and Xia 2010 )] to Xigt for the purposes of further processing.

From a formal point of view, IGT involves aligned tiers of hierarchically nested structure: The sentence consists of words, and words of morphemes (and in some cases clitics). When the source and morpheme-segmented lines are both present, there is an implicit alignment between them. Likewise, there is an implicit alignment between the gloss line and the source and morpheme-segmented lines. The de facto standard for the content of IGT is the Leipzig Glossing Rules (LGR; Bickel et al. 2008 ), which specify conventions on the representation of morpheme boundaries in the morpheme-segmented and gloss lines as well as the representation of grammatical information ( X  X rams X ) in the gloss line. A complete and well-annotated IGT instance contains information about aspects of the string not directly under discussion. Therefore, the LGR serve to improve both scientific accountabil-ity and productivity. For the former, LGR-compliance allows readers and reviewers to potentially notice correlations among linguistic facts and suggest possible alternative analyses, even if they do not know the language in question. For the latter, standardized representations make examples more amenable to reuse by facilitating comparison across descriptions of the same language and across languages.

As it is used as a display format, IGT generally contains only the information discussed above. The most typical departures from the format illustrated in (1) are the addition of brackets to show partial constituent structure and/or the incorpo-ration of symbols displaying the putative position of empty elements. If IGT data are to be used for further automated processing, however, enriching the represen-tation can increase its value for NLP tasks (Xia and Lewis 2009 ; Georgi et al. 2012 ). In particular, enriched IGT can include both explicit representations of the implicit alignments, as well as further information gleaned by parsing the translation line (Lewis and Xia 2008 ). The desiderata explored in the next section are meant to apply to both  X  X tandard X  and enriched IGT. 3 Motivation/desiderata The Xigt format has been developed in the context of the AGGREGATION project, 3 a project whose goal is to combine two sources of linguistic knowledge to create precision implemented grammars. The knowledge sources are the LinGO Grammar Matrix (Bender et al. 2002 , 2010 ), a language-independent resource which maps relatively simple linguistic descriptions to working grammar fragments, on the one hand, and IGT on the other. We aim to infer these kinds of linguistic descriptions by applying and extending the methodology of Lewis and Xia ( 2008 ), who glean information about the structure of the source languages by parsing the translation line and projecting the information through the gloss line to the source line.

The purpose of creating the implemented grammars is to assist in the development of further documentary linguistic resources, including such ambitious goals as creating grammar-derived treebanks (in the style of Oepen et al. 2004 , see also Bender et al. 2012 ) and using the implemented grammars to comb through collected texts to identify as-yet unaccounted for phenomena (see Baldwin et al. 2005 ). In order to fulfill this purpose, the system we build must be able to work with IGT collections as actually produced by current and future language documentation projects.

To this end, we need an internal representation format and associated import facilities that can map from the representations produced by various IGT production (and collection) systems to our internal representation. Similarly, as the results of our processing are meant to eventually enrich the documentary resources, we should be able to map from our internal representation to standard display formats at the very least.

Thus our primary use case involves the processing of collections of IGT, looking at both properties of individual items and comparing/aggregating across items, in order to extract hypotheses about linguistic properties of both individual items and whole languages. This use case also raises considerations of import and export: even if we are not using all of the information encoded in a particular collection of IGT, we should be able to translate formats in a lossless fashion.

A second use case involves the aggregation and enrichment of IGT for use in processing by others. In particular, we take the data curated by the ODIN project (Lewis and Xia 2010 ) as a specific test case. The ODIN project collects IGT from linguistics papers available as PDFs on the web, and then puts the IGT through several cleaning and enriching steps. The enriched IGT includes (1) word alignment among source language line, morpheme line, gloss line, and English translation; (2) a parse tree for the English translation; (3) a projected parse tree for the source language line; (4) the alignment between nodes in the two parse trees; and so on. The result is a resource that is accessible through a web page 4 with a search interface, but also one that users might want to download in bulk for processing akin to what we describe above. This use case shares with the primary one the focus on amenability to processing, but also adds considerations of encoding provenance of individual annotations. Xia et al. ( 2013 ) introduce the new ODIN corpus 5 that has been encoded in Xigt, and detail how the original and cleaned IGT are stored with enriched annotations as stand-off to the cleaned form. The initial release includes the original and cleaned text data, basic structural alignments (e.g. aligning the gloss line to the original language line), and metadata for source-document provenance and language names. Further annotations, such as more detailed structural alignments, bilingual word alignments (between the translation line and original language or gloss tokens), syntax trees, and dependency structures are left to future work and will be distributed as additional annotation layers. A brief description of the way this data is encoded is given in Sect. 6 .

These use cases have lead us to identify seven characteristics that we would like to see in a representation of IGT.

Stand-off Ide et al. ( 2003 ) underscore the importance of the ability to deploy an annotation without doing violence to the original. This promotes reuse of linguistic data and constitutes a best practice. In this case, we want to keep the original IGT lines unchanged, while adding the results produced by subsequent processing steps as additional tiers.

Incrementality Ide et al. ( 2003 ) also note that representations of annotations must allow for incremental development of analyses. This is equally true of annotations in the form of IGT: On the one hand, documentary linguists develop analyses of data over time, and on the other hand, automatic processing of existing data of the kind done in the ODIN project provides further annotations to existing records. Furthermore, we wish to accommodate IGT instances that may include errors or omissions of various sorts, as these still may be useful for linguistic studies. 6 For instance, morpheme and gloss lines in some items in the ODIN database are not alignable but the grams in the gloss lines may still be informative for studies of the case system or inflection of a language.

Extensibility The format should not be so rigorous as to disallow annotation beyond that envisioned by the LGR. While it should be possible to encode (and perhaps validate compliance with) any convention defined by the LGR, the LGR rules do not cover every possible variation among the world X  X  languages, particularly with regard to grammatical category labels. But we don X  X  just anticipate extensions for basic interlinear annotation. Indeed, as discussed in our use cases, we envision alignment of syntactic trees to IGT, bilingual word alignments, and more, so we require our IGT representation to allow this and other extensions beyond the common analytical levels.

Complex alignments Related to the need for an extensible format is our desire to represent complex alignments between annotation tiers. Some examples of complex alignments are many-to-one (as a series of elements on one tier may align to a single one on another, such as morphemes to a word), one-to-zero (e.g. a case marker in the gloss line may not align to anything in the translation line), and mapping to several discontiguous text spans (e.g. a gloss of an Arabic templatic radical aligns to discontiguous text spans in the source language line). Representing syntactic structure also requires a type of complex alignment in which items on a phrase structure tier have overlapping alignments to items on a tier of syntactic elements. Similarly, semantic notions such as coreference structure require complex alignments.

ID-reference annotations In many linguistic theories, certain levels of analysis are nested in a tree-like structure within others (morphemes within words, for example). In some of the existing formats for IGT (e.g. Hughes et al. 2003 ), this constraint is captured by XML nesting of elements, and in others, such as Toolbox (discussed in Sect. 4.2 ), it is captured by the vertical alignment of textual columns. We choose to use an ID-reference method of annotation instead, where alignable tokens are first assigned an identifier, then annotations can refer to the identifiers in order to establish alignments. Palmer and Erk ( 2007 ) point out that the nested XML technique leads to difficulty modifying and extending the analysis. If a new annotation tier is to be added, all elements on the tier which contains the new tier must have their structure modified. The vertically aligned text technique has its own drawbacks: the tiers that are aligned must be specified separately, as presumably not every tier vertically aligns to the one above it; complex alignments are very difficult to capture; and so on. In contrast, the ID-reference technique do not suffer these drawbacks at the cost of some additional verbosity (the assignment and referencing of identifiers). We therefore echo Palmer and Erk ( 2007 ) in calling for a referential annotation scheme. This scheme allows a new tier to be added alongside existing tiers without their modification, and it simplifies the representation of complex alignments between tiers.

Applicability to automatic processing Because our use cases are dedicated to mining and enriching large collections of IGT, a Xigt corpus should be easy to query and manipulate with automatic methods. For us, this means that IGT instances in the corpus can be inspected or modified independently, i.e. without requiring or affecting other IGT instances, and that suitable methods exist to retrieve the information contained within an IGT. This desideratum also implies reasonably efficient methods to iterate over IGT instances and extract information from tiers. Much of this efficiency depends on the software used to process Xigt, which is outside the scope of this paper, but the data format itself can have an effect, too. For example, IGT-XML (Palmer and Erk 2007 ), described in more detail below, uses a tier-focused model, where the same tiers for all IGT (e.g. all morpheme tiers) are grouped together and separate from groupings of other tiers. While this is adequate if you wish to retrieve or modify all tiers of the same type without the context of the IGT they come from, reassembling an IGT instance requires the computer to read the entire corpus. Similarly, Annotation Graphs (AGs) (Bird and Liberman 2001 ), also defined in more detail below, list the source signals (audio segment, text span, etc.) for all IGT together at the beginning of a corpus and then list the annotations later, so in order to reassemble an IGT from its source signal and aligned annotations, the computer must either read through the entire corpus or hold the signals for all IGT in memory while later reading the annotations. In contrast to these two methods, Xigt groups all information specific to an IGT within the same structure. Within this IGT structure, tiers of annotation are not nested, but flat, and annotation alignments are notated through ID-reference. This approach provides a balance between expressive power and computational processability. Furthermore, for the XML serializations of Xigt, we use a small inventory of element names with variation expressed as the value of a  X  X  X ype X  X  attribute. The flat structure and element naming scheme helps tools in the XML ecosystem like XPath (Berglund et al. 2007 ) and XSLT (Kay et al. 2007 ) to be flexible and efficient in processing the IGT data. 7 Predictable representation of tiers Many of the existing formats (e.g. Maeda and Bird 2000 ) provide a generalized framework which is expressive enough in principle to accommodate extremely complex annotation schemes on text and audio/video. However, the greater generality of these models presents a trade-off which limits the range of assumptions that can be made about input data, limiting in computational linguists looking for new data sources and for software-tool makers who want to render and visualize data. Therefore, we suggest that a storage format for IGT should have a standard representation for at least those levels of analysis formalized in the LGR plus the common levels of annotation in enriched IGT (e.g. word alignment and parse trees).

In this section, we have identified seven desiderata for a representation of IGT given our use cases. While some of these are in fact very general, pertaining to any kind of linguistic annotation ( Stand-off , Incrementality , Extensibility ), others are more specific to IGT ( Complex Alignments , ID-Reference Annotations ) and yet others specific to the processing of IGT in bulk ( Applicability to Automatic Processing , Predictable Representation of Tiers ). In the next section, we will review existing data models for linguistic annotation in general IGT through the lens of these specific desiderata. 4 Previous work In reviewing previous work on representations of IGT (and other annotations), we find it helpful to distinguish between data models and serialization formats . A data model, in this context, is a specification of which entities exist in the annotations and underlying data and the relationships they can stand in with each other. A serialization format, on the other hand, is a means of representing data encoded according to a data model in terms of strings. Some previous work is focused on data models (and may or may not describe possible serialization formats for their proposed models). Other work is focused on formats or on tools (with associated input/output formats) leaving the data models implicit. When the data models are implicit, they can be relatively strictly defined and inferable from the discussed formats X  X r relatively loosely defined (allowing more or less ad-hoc user extensions) and/or non-inferable but nominally encoded in the associated software. In this review, we focus on data models and group them into two relevant classes: those proposed for generalized annotation (linguistic or nonlinguistic features of potentially multimodal data artifacts) and those specific to the representation of IGT. 4.1 Data models for general annotation Annotation graphs/sets Bird and Liberman ( 2001 ) introduce AG as a general formalism for providing annotations on any 1-D, serialized data. In this model, the original data to be annotated is termed a  X  X ignal X . This generalized definition of signal allows text or audio to be annotated within the same formalism. An AG consists of a set of nodes ( N ), a collection of arcs ( A ), and a function ( s ) that maps nodes to timepoints. The arcs in A are labeled with linguistic annotations which provide information about features of the signal occurring between the two time points. The example in Fig. 1 illustrates this formalism for a Portuguese O Pedro baixou a bola  X  X  X edro calmed down X  X  (lit.  X  X  X edro lowered the ball X  X ). Here, the signal is the textual representation of the sentence. 8 N is a set of names that refer to character offsets and the mapping from the names to the offsets are specified in s . The arcs in A mark various sections of the signal as morph or word . 9
In Bird et al. ( 2000 ), the AG formalism is used as the core of a three-layer database platform: Architecture and Tools for Linguistic Analysis Systems (ATLAS). Within the ATLAS project, the notion of AGs is generalized to annotation sets. This extension adds the ability to annotate multidimensional signals instead of just linear ones (i.e. video and image data).

Maeda and Bird ( 2000 ) apply the AG format as a basis for IGT representation. In order to capture the hierarchical layers of annotations which are characteristic of IGT (i.e. words within sentences, morphemes within words, etc.) as well as the alignments which hold between certain layers (e.g. alignment between morphemes and glosses), they introduce the notions of annotation groups and subgroups (within an AG). With this extension, AG provides an elegant way to represent legacy IGT. However, its application to our goal of enriching IGT structures with nonlinear structures is less straightforward. Although the AG formalism generally captures the fundamental properties of annotation, one of our goals is to provide a straightfor-ward way to represent complex alignments with potentially overlapping or non-contiguous spans; it is not clear how AG can be used to represent those layers. Abstract corpus model ( ACM ) ACM provides the underlying model for the ELAN annotation tools (Brugman and Russel 2004 ). While the ACM model can in principle be used for annotated text, the focus is on audio and video annotation. ACM defines tier objects which can contain two types of annotations: alignable annotations and reference annotations. Alignable annotations refer directly to two  X  X  X ime slots X  X  of the media being annotated while reference annotations inherit their alignment information indirectly from an ancestor annotation. Constraints placed upon tiers include that annotations on a given tier cannot overlap in the timespan they refer to and that a mix of alignable and reference annotations on the same tier is not allowed.

Tiers can also be constrained such that the annotations they contain are required to fall into specific relationships with the annotations on a parent tier. For example, in  X  X ymbolic subdivision X  annotations referring to the same parent are ordered. This sort of tier constraint is appropriate for capturing the hierarchical relationships found in IGT such as the decomposition of words into morphemes. Another relevant type of tier constraint is called  X  X ymbolic association X , where a one-to-one association exists with a parent annotation. This constraint type is appropriate whenever items in the parent tier are being tagged according to some attribute, such as POS tags on words, or glosses on morphemes.

The ACM model provides a powerful framework for capturing many other annotation relationships beyond the ones mentioned here. Because any tier can be independent or constrained in several predefined ways, the format provides flexibility. As future work, Brugman and Russel ( 2004 ) describe a tier constraint type which allows annotations on a dependent tier to reference annotations on a specific parent tier in order to allow construction of syntactic trees, so in principle the model does support complex annotations. However, the model enforces constraints against overlapping time spans which we do not want for our purposes. For example, with manual languages there may be overlapping gestures, such as with gaze and hand signs, and these become very difficult to annotate with non-overlapping time spans.

LAF/GrAF Graph annotation framework (GrAF; Ide and Suderman 2007 ), extending linguistic annotation format (LAF; Ide et al. 2003 ), provides an abstract data model which aims to be universal in its scope of linguistic annotations. The format relies on annotations being translatable to a generalized feature structure model.
Within the LAF model, two types of annotations are defined: segmentation and linguistic. The former type provides reference points to which the latter type refer. Like ATLAS, LAF aims to provide an ecosystem around which application services can be developed and with the extension to GrAF, the model X  X  export format can be processed by generic graph processing tools.

Both the ACM and LAF/GrAF model provide an expressive framework which could in principle be used to represent enriched IGT, but for our purposes these models are too general. That is, we seek a data model that is more tailored to IGT and our use cases (while still being extensible). It should be possible to create a translation between Xigt and LAF/GrAF, such that Xigt annotations can be translated into a common format with other annotations that can be mapped to GrAF, and thus gain the interoperability benefits of that more general model. 10 We intend to explore this in future work. 4.2 Data models specific to IGT Shoebox/Toolbox Shoebox/Toolbox is both a tool to aid linguists in the creation of an IGT corpus and an eponymous storage format. 11 , 12 This format serves as the basis for linguistic databases of IGT examples and other materials such as lexica and dictionaries. The format specifies database items expressed as blocks of labeled lines in text files, as in Fig. 2 . Line names are preceded by a backslash. These ad-hoc identifiers are not fixed by the software, but rather freely defined by the linguist (user).

The Shoebox software does provide the ability to define types of tiers and relationships between them in additional files. However, the storage format doesn X  X  support this directly; the ability is a property of the software and not made explicit in the storage of the IGT.

The Shoebox format provides simplicity and flexibility, which explains its popularity and longevity. But the open-ended set of possible line names and lack of predefined semantics or predefined tiers means that no assumptions can be made about alignment of tokens from line to line in a given Shoebox corpus without consulting metadata about the corpus X  construction. This restricts automatic processing of alignment between tiers because which tiers are to be aligned is unknown. For example, if a user wants to add a new tier of annotation (say syntactic structure), she could use the label name  X  X  X hs X  X  and an ad-hoc system to indicate alignment spans on the  X  X  X ds X  X  tier, as shown in Fig. 3 . Another user with the same goal could choose a different label name and a different system. Without the knowledge of the meanings of those label names or the workings of the ad-hoc systems, the ability to combine IGT data from different Shoebox corpora is lost.
 EMELD/BHB Hughes et al. ( 2003 ), in the context of Electronic Metastructure for Endangered Languages Data (EMELD), 13 introduce an XML format specifically for capturing IGT. They provide a four-level XML containment structure to capture hierarchical nesting of standard annotations. That is, the four levels of the model: interlinear-text , phrase , word and morpheme are represented as elements which are contained within the value of an XML element at the level above. Figure 4 shows our Portuguese example in this format.

This model generalizes content to a single element type item , which allows for general processing rules to be written to access content from an arbitrary level of annotation. However, as discussed above, direct nesting of hierarchical levels leads to difficulty adding new tiers of annotations beyond the four proposed in this model. Furthermore, the direct nesting of elements rather than the use of ID-reference means that complex alignments are not supported.
IGT-XML Palmer and Erk ( 2007 ) point out that the use of XML containment in annotation elements leaves little flexibility to add or remove layers. Thus the representation they propose, IGT-XML, provides a similar model to BHB/EMELD, but uses ID-reference between annotations rather than direct containment. This is a useful step forward, but IGT-XML also focuses on tiers; it groups all similar tiers in a document under one XML element, leading to processing inefficiency when operating on IGT instances instead of solitary tiers. For example, consider using an XSLT transformation to visualize the IGT instances on a webpage. If the IGT-XML data is sent by a stream (e.g. over an internet connection), the viewer would have to wait until the most of the document is transferred before seeing the first IGT instance. Furthermore, IGT-XML only allows one-to-one alignments, and not sub-segmental (e.g. character spans) or one-to-many (e.g. for discontiguous selections) alignments, although it does allow for many-to-one alignments (e.g. for portmanteau morphemes). In order to define segmentation, multiple annotations can refer to the same identifier (e.g. multiple morphemes refer to the same word identifier), which gives an implicit segmentation as it is not explicit where one segment ends and another begins (Fig. 5 ). 4.3 Discussion In the preceding review of the existing data models for IGT, we find that they are either too general or too specific. On the one hand, there are models that are designed to be flexible enough to handle any type of linguistic annotation, but aren X  X  really tailored to IGT. On the other hand, there are models built around legacy IGT that don X  X  readily extend to the use cases we have in mind. In designing Xigt we have endeavored to combine the features of the various previous proposals that respond to our desiderata, creating a model that is specific to automatic processing of IGT, extensible in the ways we require, and (in principle) interoperable X  X ia translation X  X ith more general annotation storage formats. 5 The Xigt specification We aim for Xigt to be expressively adequate for both coarse-and fine-grained annotation, while keeping IGT as the core interest. A coarse-grained IGT annotation might align an entire tier of morphemes X  X s an atomic string X  X o a sentence. A fine-grained annotation might align words to sub-spans of the sentence, and then morphemes to sub-spans of the words. We consider an IGT to be multiple tiers of linear data with hierarchical relationships among the tiers. With this conception in mind, we give an overview of the Xigt data model in Sect. 5.1 , and an XML serialization format in Sect. 5.2 . 14 We chose XML to make use of tools in the XML ecosystem (XPath; Berglund et al. 2007 , XSLT; Kay et al. 2007 , etc.), and for its general familiarity. The Xigt data model could be serialized into other formats, such as JSON, or even used for describing and populating a relational database, but in this paper we only describe XML serialization. 5.1 The Xigt data model Here we explain the basics of the data model, including the structures involved and the methods of aligning them. The manifestation of the conceptual data model is the open-source, core code library of the Xigt project. 15 5.1.1 Structures The Xigt data model uses just four structures to encode a corpus of IGT data and annotations: (1) a xigt-corpus groups IGT instances and metadata relevant to all items, (2) an igt contains all of the tiers represented by an IGT instance, (3) a tier groups data or annotations of the same type, and (4) an item contains the actual data or annotations. This organization keeps the overall structure mostly flat; a new type of annotation would not require another level of nested structure, but just a new tier appended to the list of tiers on an igt . This core model is kept simple and predictable so processing tools can reliably parse X  X ven if they cannot accurately interpret X  X ew types of information added to a Xigtcorpus via extensions. A fifth, optional structure called metadata may appear under xigt-corpus , igt ,or tier , and is used to describe the properties of the data encoded by IGT instances, such as the language or author. (2) Is a sample IGT for Icelandic, 16 and a visualization of the primary data structures involved in modeling it is given in Fig. 6 . 5.1.2 Alignments To represent the relationships (i.e. alignments) encoded in IGT, Xigt allows any structure (but most interestingly tier and item ) to declare an id that can be referenced. There are two ways to draw references: basic alignments and alignment expressions . Basic alignments are one-to-one references from an object to a single id . In Fig. 6 , a basic alignment would align tier w to tier p . Basic alignments are also used for referring to metadata, such as for stating that an IGT comes from a book that has been described in the corpus-level metadata (thus preventing the need to redefine the book for every IGT). Alignment expressions are one-to-many references used solely by item objects. They are able to select sub-spans of the content of a referenced item . In Fig. 6 , an alignment expression would align item w1 to a sub-span (the first two characters) of item p1 .

Alignment expressions Alignment expressions, which both unify and extend the methods of alignment from previous models, are a novel contribution of the Xigt model. AGs, for example, segment data by specifying anchor points in a signal (text, audio, etc.), possibly with offsets (characters, milliseconds, etc.), and annotations select spans by specifying start and end anchor points. In Xigt, data segmentation and annotation alignment (i.e. span selection) are both accomplished by alignment expressions. 17 There are advantages and disadvantages to each approach. The anchor points for AGs are useful when later adjustments are necessary, for example when one reanalyzes a speech signal and wants to change the endpoints of a word or morpheme, because all tiers that use the anchor will refer to the new selection without needing to be changed. Alignment expressions, however, are more suited to our goals because of their ability to select discontiguous spans and how they can readily select from different tiers.

Alignment expressions are designed to be compact and expressive. We define a small grammar for alignment expressions in Fig. 7 . A single selection is an item identifier (e.g. w2 ) with an optional content range (e.g. [0:6] ). The range specifies spans of content (e.g. 0:6 selects characters between positions 0 and 6) to select from the referenced item. Identifiers are strings beginning with a letter, and in general they must be unique within an igt . 18 Spans on text data use 0-indexed pivot points, as shown in Fig. 8 , and are similar to slicing operations in common programming languages like Perl or Python. If the range is omitted from a selection, it is interpreted as selecting the entire content of the referenced item. The alignment expressions, with their resolved content, for each item in the glosses tier of Fig. 6 are given in Table 1 . Some more illustrative examples of alignment expressions are given later in Fig. 9 .

Multiple selections or multiple spans may be combined with one of two with an intervening separator. These are useful when selecting discontiguous elements. For example, consider the English sentence Pick the book up with a words tier where item w1 is  X  X  X ick X  X , item w2 is  X  X  X he X  X , and so on. Now consider creating a word-senses tier where  X  X  X ick up X  X  should be given a single, unique sense. In order to select the words to align to the sense, an alignment expression of w1, w4 would yield  X  X  X ick up X  X , which maintains the separation between the two words, but groups them as a single unit to be annotated. If, instead, w1 ? w4 were used, it would yield  X  X  X ickup X  X ; a word for a kind of vehicle instead of the intended verbal sense.
We recognize that different kinds of data may require idiosyncratic separators, such as a space character, a zero-width space character (Unicode U ? 200B ; for languages in which a space is not defined as a word-separator, like Chinese, Japanese, or Thai), or gaps of silence (for audio data). Because alignments are likely to occur on annotation tiers rather than tiers with native orthography or audio data,  X  X  ,  X  X  joins selections with a space character as a convenient default. Both  X  X  ?  X  X  and  X  X  ,  X  X  may be redefined in an extension.
 Some example alignment expressions with their resolved strings are given in Fig. 9 . Note that different alignment expressions can resolve to the same string. The invalidity of the final expression is explained below.

Constraints on alignment expressions There is a structural constraint for alignment expressions: an item may only refer to an item within the tier its own tier refers to. That is, a tier first draws a relationship to another tier, then items in the first tier may annotate those in the second, but no others. Looking back at Fig. 6 , if the glosses tier g refers to the words tier w , this constraint would ensure that gloss items ( g1  X  g7 ) may refer only to word items ( w1  X  w3 ), and not to items on the phrases tier or translations tier. This constraint is artificial, but X  X e think X  X ell motivated, as it would be strange for some annotation to apply to multiple tiers (i.e. different kinds of data) simultaneously.

There are times when a tier must refer to more than one other tier, albeit in different ways. For example, in order to capture bilingual word alignments between the translation and original language lines, we need a way to select multiple words on either the translation line or original language line, since words don X  X  always translate one-to-one. If we just put the alignments on one of these tiers (say, on the translation tier, selecting the original language words), we could not get alignments involving more than one translation word. Instead, we create a third tier with items having two alignment expressions each: a source and a target. With this new tier, we can capture many-to-many alignments. In order for this configuration to still be valid with respect to the constraint given above, we give references names, and the constraint only applies to references with the same name. In XML these names are those of the attributes that specify the references. Figure 10 illustrates what the bilingual word alignment tier would look like if added to Fig. 6 , where the references are shown in angle brackets.

Floating alignments If multiple items share the same alignment, they have floating alignments . This is useful for phenomena like portmanteau morphemes, but also for relaxed (i.e. less granular) annotation where the user does not want to be specific about the alignments. In Fig. 6 , glosses g1 and g2 are portmanteau morphs and would be in a floating alignment with word w1 . Even though g1 and g2 both align to w1 , they maintain their relative order, so if one were to (re-)serialize them as a string, the result would be  X  X  X . NOM  X  X  and not  X  X  NOM .I X  X . 5.1.3 Items and annotation content Most item s will have some content associated with them, whether it is source data, annotations, or something else. Xigt does not make any distinction between source data (such as sentences or words) and subsequent annotations, although in practice the source data do not often align to anything else. For all items, content can be specified in two ways: it can be specified directly on the item, or it can be selected with a special alignment. Content selected via alignments is dynamic X  X t will update when the source data changes X  X ut the ranges of sub-span selections may need to be adjusted.
It is also possible to both select existing content and introduce new content. In this case, the content introduced directly on the item shadows the selected content, meaning that the selected content is not used. The purpose is to trace where data comes from; the alignment for the selection points to the source of the data, but the actual content is overridden with the introduced data. This technique is useful for smoothing over OCR or ASR errors (so annotations target the clean form and not the erroneous one), or for providing the underlying form of morphemes rather than the overt phonological realization [as in (1), where  X  X  X dakanga X  X  is aligned to the underlying morphemes  X  X  X di X  X ,  X  X  X ka X  X , and  X  X  X ga X  X  X . 5.1.4 Primary tier types and alignment types Different kinds of data are encoded in subtypes of the primary data structures. Xigt X  X  core model provides five basic tier subtypes: phrases , words , morphemes , glosses , and translations . Xigt also provides several item subtypes, such as clitic and affix to distinguish multiple kinds of morpheme elements, or transliteration to distinguish phrases in the source language orthography from a transliteration in another script.

All tiers and items have three basic kinds of references: alignment , content , and segmentation . The alignment reference selects the target of the annotation, while the content reference is used for selecting item content. The segmentation reference is the combination of the other two (it both specifies the target of the annotation and uses that target as the content of the annotation), and is convenient for specifying subparts of other items, such as selecting words from phrases and morphemes from words. As such, the segmentation reference is incompatible with the other two. 5.2 The Xigt XML data format The XML serialization format for Xigt closely resembles the data model. It was designed to optimize predictability of the data without sacrificing expressibility or extensibility. We therefore have a basic, fixed core format, and extensions can add information but not remove or alter the core format. The implementation of this format consists of two parts: (1) a RelaxNG (Clark and Murata 2001 ) schema for validating the XML documents, and (2) code for the serialization of XML from virtual data structures. 19
Data structure The XML format follows the data model naming conventions: a &lt;xigt-corpus&gt; root element contains &lt;igt&gt; elements, which in turn contain all &lt;tier&gt; elements relevant to an IGT. The &lt;tier&gt; elcntain the primary or annotation data, which are encapsulated in &lt;item&gt; elements. All four of these kinds of elements are ID-bearing (via an id attribute), meaning they may establish an ID that other elements can reference. The &lt;igt&gt; , &lt;tier&gt; ,and &lt;item&gt; elements may specify subtypes with a type attribute. These subtypes can place constraints on their child elements X  subtypes and attributes. &lt;xigt-corpus&gt; , &lt;igt&gt; ,and &lt;tier&gt; elements mayhavezeroormore &lt;metadata&gt; children, which describe the data contained in any &lt;item&gt; elements under them, such as the language or script used, author of the IGT, grammaticality of the example, etc. References appear as attributes on the referencing object. To specify these references, an &lt;item&gt; mayhavean alignment or a content attribute, or both, or it may have a segmentation attribute.

Figure 11 is a simple example of the Xigt XML format based on the IGT in (3) that showcases some of Xigt X  X  features, such as alignment expressions, reference-based content selection, floating alignments, and data shadowing. In this example, alignment expressions segment the Spanish word cocinas  X  X ou cook X  into two morphemes, cocin and as . The glosses tier then annotates these morphemes. The four glosses (2nd person, singular number, present tense, and indicative mood) are all in a floating alignment with the same morpheme, as , meaning they all simultaneously annotate it. Because the glosses tier introduces annotation content ( cook , 2 , etc.), the contents shadow the aligned content in the morphemes tier, such that if another tier annotates on top of the glosses, it will annotate the glosses and not the morphemes the glosses align to. 5.3 Extensions While the core Xigt framework is likely sufficient for encoding and operating on IGT data, some users may need specialized logic for certain applications. As mentioned, the data model has a small, fixed inventory of structures and the XML format similarly fixes the element names. These constraints allow for extensions that are predictable in structure and thus easy for processors to handle. Simple extensions, such as adding a required attribute or a new basic tier type, only need an updated schema for validation, because the code can handle an unknown attribute or tier type as long as it doesn X  X  need new logic for interpreting the new data. Structural extensions, such as adding a new reference attribute for additional kinds of annotation alignment, require changes to the serialization code. This code needs to be aware that the new attribute is indeed a reference and not merely a descriptive attribute (e.g. one that says whether the content is manually transcribed or automatically generated).

In either case, we make both the schema and the code easy to extend. Symbols can be redefined so only the changes need to be added, and the default behavior is used everywhere else. We provide some example extensions at the project X  X  website, and explain one such extension in Sect. 6 . 6 Case study: importing ODIN to Xigt In developing Xigt, one key use case has been the importing of IGT from ODIN (Lewis and Xia 2010 ) for processing in the AGGREGATION project 20 (Bender et al. 2013 ). As the ODIN data is initially text extracted from PDFs, an important sub-task is the conversion of the ODIN textual data into the Xigt XML format. Our motivations for doing this are twofold: on the one hand, we want to encode the raw ODIN text data into a format that is easier for a computer to interpret and process, and on the other hand, we want to enable the enrichment of IGT with bilingual word alignments and syntax trees. In this section, we will describe the extensions for storing ODIN data, and briefly cover those for enriching the IGT. 6.1 ODIN textual data ODIN researchers have identified and extracted myriad IGT examples from PDF documents found on the web. The lines are annotated with the line number they came from in the initial PDF extraction, and tags that explain their content, such as  X  X  X  X  X  for the source text (or  X  X  X anguage line X  X ),  X  X  X  X  X  for glosses,  X  X  X  X  X  for translation, and occasionally metadata from the example (like the language name or author). Each block of lines representing an IGT instance is preceded by generated metadata, such as the language X  X hich has been identified automatically from the source line X  X nd the ID of the document the example came from. The result of this preprocessing, shown in Fig. 12 , 21 is what we work with in converting to the Xigt XML format.

Figure 12 is a particularly clean example. Note that even this clean example has some extraneous data, such as the example number on the language line, the quotes on the translation line, and leading spaces on all three lines. Some more challenging examples may have PDF extraction errors (e.g. diacritics not appearing on their respective glyphs); OCR errors; two-column IGT; long, wrapped lines; multiple (i.e. alternate) gloss lines or translations; differing numbers of tokens on the language and gloss lines (which makes alignment difficult); and so on. For example, Fig. 13 22 has PDF extraction errors (the language line is split into two; the final word should be  X  X  X   X  k  X  yor X  X ), which causes a difference in token counts in the language and gloss lines, and inline alternations ( X  X  X  X  X  ideally aligns to both  X  X  X e X  X  and  X  X  X t X  X  as alternates, but  X  X  X e/It X  X  is treated as a single token).

We perform some cleaning steps to try and account for predictable kinds of noise, but we are unable to get a clean representation of every example. For this reason, desideratum of incrementality) helps us encode as much information as is available in each case. For example, the IGT in Fig. 12 has the same number of space-separated tokens in the language and gloss lines, and each token has the same number of hyphen-separated morphemes. We can, therefore, fairly confidently align individual gloss tokens to words, and even gloss grams to morphemes. The IGT in Fig. 13 , however, has an unequal number of gloss and word tokens (assuming we cannot automatically recover the word with PDF extraction errors), so we cannot confidently align glosses to words. Instead, we align the entire gloss line to the language line, without segmenting tokens.
The algorithms we deploy for cleanup and interpretation of the textual ODIN data are potentially lossy. To prevent any actual loss of information, we include the original text lines in a tier, 23 and the cleaned text lines in a second tier. The contents of the first tier remain unchanged as much as possible, but occasionally we had to replace control characters X  X ntroduced during PDF extraction X  X hat are invalid in XML, such as the form feed character. We do not directly use the original text data in the AGGREGATION project, but we keep it for the sake of storing and distributing the Xigt-formatted ODIN corpus as stand-off annotation, for which the second tier of cleaned text is the target. 24 6.2 Xigt extensions The ODIN extension to Xigt consists of several changes to the schema, but no special serialization code is necessary. We define two new tiers, odin-raw and odin-clean , both with optional attributes for the line number and tag. These ODIN text tiers are only used for establishing a link to the original data so the structural annotations are stand-off, and do not affect the actual IGT structure at all. In other words, the extension is a monotonic addition and can be ignored entirely without disrupting the relationships in the IGT extracted from the text. Removing the extension (i.e. encoding the data without the stand-off tiers), however, would result in a non-stand-off, potentially lossy representation of the ODIN textual IGT.
Figure 14 shows an XML-formatted 25 Xigt corpus with the textual Korean IGT from Fig. 12 .The odin-raw tier contains the original text from ODIN, and the odin-clean tier has the cleaned version (with the example number, quotes, and extraneous spaces removed). The IGT annotations (specification of words, glosses, relationships between them, etc.) follow, selecting their content with the content attribute, which makes them stand-off annotations, rather than introducing it themselves. In the interest of space, the tier for morphemes is not shown, but for this example it is possible to confidently align sub-glosses to morphemes. Note that only one tier needs to select a unique line from the ODIN text; derivative tiers can simply segment the first one, as is done with the words tier from phrases. Annotation alignments, via the alignment attribute, target only the IGT structures, and not the ODIN text tiers. This separation of concerns makes it easy to compare IGT utilizing stand-off or stand-alone annotations, and also makes it easy to convert to stand-alone annotation by resolving the content selections and removing the ODIN tiers.
Figure 15 is an example using the noisy Turkish data from Fig. 13 . We are less confident about how to segment the data, so instead we align the glosses tier directly to the phrases tier without an intervening words tier, and further we align the entire line as one string instead of segmenting it into separate gloss grams. 26
Whether we get fine-grained alignments from clean data or coarse-grained alignments from noisy data, the alignments are all generated automatically and are not vetted by a human. Because of this situation, we set the corpus-level attribute alignment-method to auto so users of the corpus can be aware of the quality of the alignments. Other possible values for this attribute are: gold for manually-created annotations, and vetted for automatically created annotations that have been checked by a human. 6.3 Statistics for the basic corpus The first step of creating the Xigt-formatted ODIN corpus is just conversion from the textual corpus, so here we will present some statistics of the results. The basic corpus has the odin-raw and odin-clean tiers; coarse, line-based alignments between phrases , glosses , and translations tiers, where they exist; and basic metadata for the language and source document of each IGT. Fine-grained alignments from tokenization of the phrases and glosses tiers will be distributed as an extension to the basic corpus, as will the enriched tiers for syntax trees and bilingual alignments (described in Sect. 6.4 ). The basic corpus is a truer representation 27 of the original ODIN data than it would be with the advanced tiers, because the advanced tiers introduce information not explicitly present in the textual corpus, and moreover because the advanced tiers, being automatically created, are more likely to have errors than the coarse-grained alignments.
In the basic corpus, there are 157,144 IGT instances representing 1,493 languages, 28 and 2,025 source documents. Of the 157,144 instances, 146,128 have a phrases tier created from the language ( X  X  X  X  X ) line, 138,547 have a glosses tier created from the glosses ( X  X  X  X  X ) line, and 126,253 have a translations tier created from the translation ( X  X  X  X  X ) line. Table 2 shows the distribution of IGT instances by the tier types that were present. Each row represents a mutually exclusive set; e.g. the first row represents instances that have an  X  X  X  X  X  line, but no  X  X  X  X  X  or  X  X  X  X  X  lines. Other line types, such as metadata lines, are not considered. The last row,  X  X  X ther X  X , represents items that either had none of  X  X  X  X  X ,  X  X  X  X  X , or  X  X  X  X  X  lines, or had them in a form that we cannot currently detect, such as when two line types share a single line (e.g.  X  X  X  X  X / X  X  X  X  X  lines are common when an author provides a small inline glossary). 6.4 Enriching IGT Above we have described how we are encoding ODIN IGT into Xigt, but for the AGGREGATION project we also need to process the IGT and enrich them with bilingual word alignments and parse trees. This work is ongoing, and the decisions of how to best encode such information are left to future work, but we present here possible solutions based on the capabilities of Xigt.

For bilingual word alignments, we need a way to do many-to-many alignments, as it may be possible for multiple translation words to map to a single original-language word, vice-versa, or even multiple translation words to multiple original words. We accomplish this with a tier that utilizes two alignment expressions. As the alignment itself is the annotation, the items on this tier do not need content. For the AGGREGATION project, we actually align translation words to gloss tokens rather than to original words, as the gloss tokens share a similar form to translation words and thus make a better (i.e. easier) target for an automatic aligner. Moreover, they share the same word order as the original words, so it X  X  possible to project the alignments. Therefore, we obtain the raw alignments by extracting the gloss line and translation line from an IGT and processing them with an external word aligner, then encode the results into Xigt in a bilingual-alignments tier with the source alignment expression aligned to the translation tier and the target alignment expression to the glosses tier. An example is given in Fig. 16 with data taken from Fig. 14 . For clarity, we only show the relevant tiers and we X  X e resolved the content alignments. We see that the aligner covered most words, but some others ( made and the ) were left unaligned (a more sophisticated aligner might relate made to the  X  X aus X  gram in the glosses tier).

Syntax trees require entities not present in the original IGT, namely nodes on the parse tree, so this extension also requires a second alignment expression. To get the raw parse tree, we extract the translation line from the IGT and process it with an external parser, then encode the results into Xigt. There are some precedents for XML-based encodings of syntax trees (Mengel and Lezius 2000 ;Brantsetal. 2002 ), and one possibility for us is to integrate their basic structure with our alignment expressions. An example of such an encoding is given in Fig. 18 , which represents the tree in Fig. 17 . Again, for clarity we only show the relevant tiers, and resolve content alignments. The syntax tier has two alignment expressions, lex and node , which may not both appear on the same item. Items with lex select the lexical unit(s) at the leaves of the tree. Items with node represent non-terminal (i.e. phrasal) nodes in the tree, and select items (either lex or node ) from the same tier. 29 The item contents are the node labels of the syntax tree. Encoding syntax trees in this way allows us to easily give only partial tree structures, which would be useful when creators of IGT annotate syntactic structure for only a portion of the sentence, or when an automatic parser fails to give a full representation. It can also handle packed-representations of multiple parses (e.g. with an item attribute that specifies for which parses a node is used) for when there is syntactic ambiguity. Furthermore, it is straightforward to refer to any node in the tree, since they can all have identifiers, thus allowing annotation on top of the syntax tree. 6.5 Summary In this section we have described our process for importing data from ODIN to Xigt, including the Xigt extensions required for this dataset. We also described our tentative plans for encoding bilingual word alignments and syntax trees. The ODIN use case illustrates how Xigt satisfies our design desiderata, including especially Stand-Off , Incrementality , Extensibility and Complex Alignments . 7 Conclusion and future work This paper has presented Xigt, an extensible representation for interlinear glossed text. The schema, code, examples, and documentation are all open-source and available from the project website: http://depts.washington.edu/uwcl/xigt
Our motivation for creating Xigt stems from work repurposing IGT data collected from various sources for NLP applications, including specifically applications of NLP to language documentation. We reviewed existing formats before creating Xigt but found that they did not answer to our specific needs. In particular, the formats that came closest were either not optimized for efficient processing or too general. We defined Xigt with automatic processing as its primary purpose, and such that it answers to our design desiderata: 1. Stand-off Through ids and references (including alignment expressions), it can 2. Incrementality There is no fixed nesting of types, which allows flexibility in the 3. Extensibility The core of Xigt is designed to be simple, and to support 4. Complex alignments Xigt X  X  alignment expressions allow for one-to-many 5. ID-reference annotations IDs and references allow complex relationships in a 6. Applicability to automatic processing Our data model groups all relevant data 7. Predictable representation We use a relatively flat structure of elements and
We present as a test case the import of ODIN data into Xigt. The ODIN data is of interest as a test case because it encompasses wide variation in the quality and quantity of annotation as well as additional sources of noise (PDF extraction and OCR errors). This test case illustrates how Xigt allows us to flexibly represent as much information as is available on an item-by-item basis.
 Work is currently underway to import Abui (a Papuan language of Eastern Indonesia) data from Toolbox for the purpose of automatically discovering phenomena and linguistic patterns. Frantis  X  ek Kratochv X   X  l, the linguist who created and maintains the Toolbox corpus, is closely supervising our efforts at conversion, and can verify when our methods are accurate. Once we have successfully converted the Abui Toolbox data into Xigt, the next step (for Xigt X  X  purposes) is to make a language-independent conversion routine for Toolbox data.

Our future goals for Xigt itself include adding to the ODIN extension to represent parse trees, developing a translation layer between Xigt and LAF/GrAF, and further extensions relating to content standards in the general IGT space (e.g. the Leipzig Glossing Rules and OLAC metadata). We are also interested in importing to Xigt from sources beyond ODIN, and in particular from tools that support the creation of IGT including Shoebox/Toolbox and TypeCraft (Beermann and Mihaylov 2009 ).
 References
