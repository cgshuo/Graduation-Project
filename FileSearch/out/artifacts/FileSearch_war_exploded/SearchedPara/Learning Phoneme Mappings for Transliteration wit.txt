 Transliteration refers to the transport of names and terms between languages with different writing sys-tems and phoneme inventories. Recently there has been a large amount of interesting work in this area, and the literature has outgrown being citable in its entirety. Much of this work focuses on back-transliteration , which tries to restore a name or term that has been transported into a foreign lan-guage. Here, there is often only one correct target spelling X  X or example, given jyon.kairu (the name of a U.S. Senator transported to Japanese), we must output  X  X on Kyl X , not  X  X ohn Kyre X  or any other variation.

There are many techniques for transliteration and back-transliteration, and they vary along a number of dimensions:  X  phoneme substitution vs. character substitution  X  heuristic vs. generative vs. discriminative mod- X  manual vs. automatic knowledge acquisition
We explore the third dimension, where we see several techniques in use:  X  Manually-constructed transliteration models,  X  Models constructed from bilingual dictionaries  X  Extraction of parallel examples from bilin- X  Extraction of parallel examples from compara- X  Extraction of parallel examples from web  X  Comparing terms from different languages in
In this paper, we investigate methods to acquire transliteration mappings from non-parallel sources . We are inspired by previous work in unsupervised learning for natural language, e.g. (Yarowsky, 1995; Goldwater and Griffiths, 2007), and we are also in-spired by cryptanalysis X  X e view a corpus of for-eign terms as a code for English, and we attempt to break the code. We follow (Knight and Graehl, 1998) in tackling back-transliteration of Japanese katakana expres-sions into English. Knight and Graehl (1998) devel-oped a four-stage cascade of finite-state transducers, shown in Figure 1.  X  WFSA A -produces an English word sequence  X  WFST B -generates an English phoneme se- X  WFST C -transforms the English phoneme se- X  WFST D -writes out the Japanese phoneme
Using the cascade in the reverse (noisy-channel) direction, they are able to translate new katakana names and terms into English. They report 36% er-ror in translating 100 U.S. Senators X  names, and they report exceeding human transliteration performance in the presence of optical scanning noise.

The only transducer that requires parallel training data is WFST C. Knight and Graehl (1998) take sev-eral thousand phoneme string pairs, automatically align them with the EM algorithm (Dempster et al., 1977), and construct WFST C from the aligned phoneme pieces.

We re-implement their basic method by instanti-ating a densely-connected version of WFST C with all 1-to-1 and 1-to-2 phoneme connections between English and Japanese. Phoneme bigrams that occur fewer than 10 times in a Japanese corpus are omit-ted, and we omit 1-to-3 connections. This initial WFST C model has 15320 uniformly weighted pa-rameters. We then train the model on 3343 phoneme string pairs from a bilingual dictionary, using the EM algorithm. EM immediately reduces the con-nections in the model to those actually observed in the parallel data, and after 14 iterations, there are only 188 connections left with P ( j | e )  X  0 . 01 . Fig-ure 2 shows the phonemic substitution table learnt from parallel training.

We use this trained WFST C model and apply it to the U.S. Senator name transliteration task (which we update to the 2008 roster). We obtain 40% er-ror, roughly matching the performance observed in (Knight and Graehl, 1998). The task of this paper is to learn the mappings in Figure 2, but without parallel data , and to test those mappings in end-to-end transliteration. We imagine our problem as one faced by monolingual English speaker wandering around Japan, reading a multi-tude of katakana signs, listening to people speak Japanese, and eventually deciphering those signs into English. To mis-quote Warren Weaver:
Our larger motivation is to move toward easily-built transliteration systems for all language pairs, regardless of parallel resources. While Japanese/English transliteration has its own partic-ular features, we believe it is a reasonable starting point.
Our monolingual resources are:  X  43717 unique Japanese katakana sequences  X  The CMU pronunciation dictionary of English,  X  The English gigaword corpus. Knight and
We seek to use our English knowledge (derived from 2 and 3) to decipher the Japanese katakana cor-pus (1) into English. Figure 3 shows a portion of the Japanese corpus, which we transform into Japanese phoneme sequences using the monolingual resource of WFST D. We note that the Japanese phoneme in-ventory contains 39 unique ( X  X iphertext X ) symbols, compared to the 40 English ( X  X laintext X ) phonemes.
Our goal is to compare and evaluate the WFST C model learnt under two different scenarios X (a) us-ing parallel data, and (b) using monolingual data. For each experiment, we train only the WFST C model and then apply it to the name translitera-tion task X  X ecoding 100 U.S. Senator names from Japanese to English using the automata shown in Figure 1. For all experiments, we keep the rest of the models in the cascade (WFSA A, WFST B, and WFST D) unchanged. We evaluate on whole-name error-rate (maximum of 100/100) as well as normal-ized word edit distance, which gives partial credit for getting the first or last name correct. Our main data consists of 9350 unique Japanese phoneme sequences, which we can consider as a sin-gle long sequence j . As suggested by Knight et al (2006), we explain the existence of j as the re-sult of someone initially producing a long English phoneme sequence e , according to P( e ), then trans-forming it into j , according to P( j | e ). The probabil-ity of our observed data P( j ) can be written as: We take P( e ) to be some fixed model of mono-lingual English phoneme production, represented as a weighted finite-state acceptor (WFSA). P( j | e ) is implemented as the initial, uniformly-weighted WFST C described in Section 2, with 15320 phone-mic connections.

We next maximize P( j ) by manipulating the sub-stitution table P( j | e ), aiming to produce a result such as shown in Figure 2. We accomplish this by composing the English phoneme model P ( e ) WFSA with the P ( j | e ) transducer. We then use the EM al-gorithm to train just the P ( j | e ) parameters (inside the composition that predicts j ), and guess the val-ues for the individual phonemic substitutions that maximize the likelihood of the observed data P ( j ) . 2 We allow EM to run until the P ( j ) likelihood ra-tio between subsequent training iterations reaches 0.9999, and we terminate early if 200 iterations are reached.

Finally, we decode our test set of U.S. Senator names. Following Knight et al (2006), we stretch out the P ( j | e ) model probabilities after decipher-ment training and prior to decoding our test set, by cubing their values.

Decipherment under the conditions of translit-eration is substantially more difficult than solv-ing letter-substitution ciphers (Knight et al., 2006; Ravi and Knight, 2008; Ravi and Knight, 2009) or phoneme-substitution ciphers (Knight and Yamada, 1999). This is because the target table contains sig-nificant non-determinism, and because each symbol has multiple possible fertilities, which introduces uncertainty about the length of the target string. 4.1 Baseline P( e ) Model Clearly, we can design P( e ) in a number of ways. We might expect that the more the system knows about English, the better it will be able to decipher the Japanese. Our baseline P( e ) is a 2-gram phoneme model trained on phoneme sequences from the CMU dictionary. The second row (2a) in Figure 4 shows results when we decipher with this fixed P( e ). This approach performs poorly and gets all the Senator names wrong. 4.2 Consonant Parity When training under non-parallel conditions, we find that we would like to keep our WFST C model small, rather than instantiating a fully-connected model. In the supervised case, parallel training al-lows the trained model to retain only those con-nections which were observed from the data, and this helps eliminate many bad connections from the model. In the unsupervised case, there is no parallel data available to help us make the right choices.
We therefore use prior knowledge and place a consonant-parity constraint on the WFST C model. Prior to EM training, we throw out any mapping from the P ( j | e ) substitution model that does not have the same number of English and Japanese con-sonant phonemes. This is a pattern that we observe across a range of transliteration tasks. Here are ex-amples of mappings where consonant parity is vio-lated: Modifying the WFST C in this way leads to bet-ter decipherment tables and slightly better results for the U.S. Senator task. Normalized edit distance drops from 100 to just under 90 (row 2b in Figure 4). 4.3 Better English Models Row 2c in Figure 4 shows decipherment results when we move to a 3-gram English phoneme model for P ( e ) . We notice considerable improvements in accuracy. On the U.S. Senator task, normalized edit distance drops from 89.8 to 73.6, and whole-name error decreases from 98 to 94.

When we analyze the results from deciphering with a 3-gram P( e ) model, we find that many of the Japanese phoneme test sequences are decoded into English phoneme sequences (such as  X  IH K R IH N  X  and  X  AE G M AH N  X ) that are not valid words. This happens because the models we used for de-cipherment so far have no knowledge of what con-stitutes a globally valid English sequence. To help the phonemic substitution model learn this infor-mation automatically, we build a word-based P( e ) from English phoneme sequences in the CMU dic-tionary and use this model for decipherment train-ing. The word-based model produces complete En-glish phoneme sequences corresponding to 76,152 actual English words from the CMU dictionary. The English phoneme sequences are represented as paths through a WFSA, and all paths are weighted equally. We represent the word-based model in com-pact form, using determinization and minimization techniques applicable to weighted finite-state au-tomata. This allows us to perform efficient EM train-ing on the cascade of P ( e ) and P ( j | e ) models. Under this scheme, English phoneme sequences resulting from decipherment are always analyzable into actual words.

Row 2d in Figure 4 shows the results we ob-tain when training our WFST C with a word-based English phoneme model. Using the word-based model produces the best result so far on the phone-mic substitution task with non-parallel data. On the U.S. Senator task, word-based decipherment outper-forms the other methods by a large margin. It gets 23 out of 100 Senator names exactly right, with a much lower normalized edit distance (57.2). We have managed to achieve this performance using only monolingual data. This also puts us within reach of the parallel-trained system X  X  performance (40% whole-name errors, and 25.9 word edit dis-tance error) without using a single English/Japanese pair for training.

To summarize, the quality of the English phoneme model used in decipherment training has a large ef-fect on the learnt P ( j | e ) phonemic substitution ta-ble (i.e., probabilities for the various phoneme map-pings within the WFST C model), which in turn af-fects the quality of the back-transliterated English output produced when decoding Japanese.

Figure 5 shows the phonemic substitution table learnt using word-based decipherment. The map-pings are reasonable, given the lack of parallel data. They are not entirely correct X  X or example, the map-ping  X  X   X  s u X  is there, but  X  X   X  s X  is missing.
Sample end-to-end transliterations are illustrated in Figure 6. The figure shows how the transliteration results from non-parallel training improve steadily as we use stronger decipherment techniques. We note that in one case (LAUTENBERG), the deci-pherment mapping table leads to a correct answer where the mapping table derived from parallel data does not. Because parallel data is limited, it may not contain all of the necessary mappings. 4.4 Size of Japanese Training Data Monolingual corpora are more easily available than parallel corpora, so we can use increasing amounts of monolingual Japanese training data during de-cipherment training. The table below shows that using more Japanese training data produces bet-ter transliteration results when deciphering with the word-based English model.
 !,#G,%33)?%+#,&amp;H).#)!/,/44%4)7/&amp;/)&lt;3%IH 4.5 P ( j | e ) Initialization So far, the P ( j | e ) connections within the WFST C model were initialized with uniform weights prior to EM training. It is a known fact that the EM al-gorithm does not necessarily find a global minimum for the given objective function. If the search space is bumpy and non-convex as is the case in our prob-lem, EM can get stuck in any of the local minima depending on what weights were used to initialize the search. Different sets of initialization weights can lead to different convergence points during EM training, or in other words, depending on how the P ( j | e ) probabilities are initialized, the final P ( j | e substitution table learnt by EM can vary.

We can use some prior knowledge to initialize the probability weights in our WFST C model, so as to give EM a good starting point to work with. In-stead of using uniform weights, in the P ( j | e ) model we set higher weights for the mappings where En-glish and Japanese sounds share common consonant phonemes.
 For example, mappings such as: are weighted X (a constant) times higher than other mappings such as: in the P ( j | e ) model. In our experiments, we set the value X to 100.

Initializing the WFST C in this way results in EM learning better substitution tables and yields slightly better results for the Senator task. Normalized edit distance drops from 57.2 to 54.2, and the whole-name error is also reduced from 77% to 73% (row 2e in Figure 4). 4.6 Size of English Training Data We saw earlier (in Section 4.4) that using more monolingual Japanese training data yields improve-ments in decipherment results. Similarly, we hy-pothesize that using more monolingual English data can drive the decipherment towards better translit-eration results. On the English side, we build dif-ferent word-based P ( e ) models, each trained on dif-ferent amounts of data (English phoneme sequences from the CMU dictionary). The table below shows that deciphering with a word-based English model built from more data produces better transliteration results.
 This yields the best transliteration results on the Senator task with non-parallel data, getting 34 out of 100 Senator names exactly right. 4.7 Re-ranking Results Using the Web It is possible to improve our results on the U.S. Sen-ator task further using external monolingual re-sources. Web counts are frequently used to auto-matically re-rank candidate lists for various NLP tasks (Al-Onaizan and Knight, 2002). We extract the top 10 English candidates produced by our word-based decipherment method for each Japanese test name. Using a search engine, we query the entire English name (first and last name) corresponding to each candidate, and collect search result counts. We then re-rank the candidates using the collected Web counts and pick the most frequent candidate as our choice.

For example, France Murkowski gets only 1 hit on Google, whereas Frank Murkowski gets 135,000 hits. Re-ranking the results in this manner lowers the whole-name error on the Senator task from 66% to 61%, and also lowers the normalized edit dis-tance from 49.3 to 48.8. However, we do note that re-ranking using Web counts produces similar im-provements in the case of parallel training as well and lowers the whole-name error from 40% to 24%.
So, the re-ranking idea, which is simple and re-quires only monolingual resources, seems like a nice strategy to apply at the end of transliteration exper-iments (during decoding), and can result in further gains on the final transliteration performance. We also present decipherment results when using comparable corpora for training the WFST C model. We use English and Japanese phoneme sequences derived from a parallel corpus containing 2,683 phoneme sequence pairs to construct comparable corpora (such that for each Japanese phoneme se-quence, the correct back-transliterated phoneme se-quence is present somewhere in the English data) and apply the same decipherment strategy using a word-based English model. The table below com-pares the transliteration results for the U.S. Sena-tor task, when using comparable versus non-parallel data for decipherment training. While training on comparable corpora does have benefits and reduces the whole-name error to 59% on the Senator task, it is encouraging to see that our best decipherment re-sults using only non-parallel data comes close (66% error).
 We have presented a method for attacking machine transliteration problems without parallel data. We developed phonemic substitution tables trained us-ing only monolingual resources and demonstrated their performance in an end-to-end name translitera-tion task. We showed that consistent improvements in transliteration performance are possible with the use of strong decipherment techniques, and our best system achieves significant improvements over the baseline system. In future work, we would like to develop more powerful decipherment models and techniques, and we would like to harness the infor-mation available from a wide variety of monolingual resources, and use it to further narrow the gap be-tween parallel-trained and non-parallel-trained ap-proaches. This research was supported by the Defense Ad-vanced Research Projects Agency under SRI Inter-national X  X  prime Contract Number NBCHD040058.
