 Managing and querying Semantic Web are important issues for Semantic Web applications. Ther efore, we have developed a Semantic Web database system with logically and physically optimized SPARQL engines to manage and query RDF data, named LuposDate . In order to present the functionalities of the LUPOSDATE system and engines, we have developed an online demonstration, which is available at http://www.ifis.uni-luebeck.de/index.php?id=luposdate-demo. H.2.4 [ Database Management ]: Systems  X  Query processing. Management, Performance. Semantic Web, Query pr ocessing, RDF, SPARQL. The LuposDate system integrates many optimization techniques, and supports various approaches to manage RDF data and process SPARQL queries: Jena ( //jena.sourceforge.net/ ) and Sesame ( //www.openrdf.org/ ) refer to third-party SPARQL engines; Index is our in-memory engine (s ee [1] and Section 1.1); Stream is our streaming engine [2]; RDF3X and Hexastore are our re-implementations of [3] and [4]; RDF3X X  X resorting and Hexastore X  Presorting are the extensions of RDF3X and Hexastore by integrating our presorting numbe ring scheme (see Section 1.2). All approaches (except for Stream ) support full SPARQL 1.0 and SPARUL, and pass all of the W3C test cases ( //www.w3.org/2001/sw/DataAccess/tests/r2 ) with over 200 queries. The Stream engine does not support named graphs. Figure 1 presents the functionalitie s of the LuposDate engines. The SPARQL query is first transformed into a CoreSPARQL query. CoreSPARQL is a core fragment of SPARQL, which eliminates redundant language constructs and allows only machine-friendly syntax, and thus CoreSPARQL simplifies the following processing of SPARQL queries. The operator graph is used to further logically and phy sically optimize queries. We use indexing techniques to manage and access data efficiently. In the Stream engine, we index only that fragment of data, which is necessary to answer the query dur ing query evaluation, and thus Stream does not have an extra indexi ng phase and data is directly transmitted to the query evaluation phase. Depending on the individual approach, the operator gr aphs consist of different sets of operators and lead to different execution plans. sorting algorithm for merge joins outperforms the hash joins; our fast sorting capability is a big gain for ordering of results and elimination of duplicates; our sorting numbering scheme integrated into index approaches significantly speeds up querying large-scale Semantic Web data. Figure 3 demonstrates how to fast sort variable bindings according to ?y using the OPS-presorting numbers when computing the join of two triple pa tterns. Firstly, the triple pattern ?x :a :b is computed using POS; ?x :c ?y is computed using PSO, and thus the two results are already sorted according to ?x . If the result of the join needs to be sorted according to ?y , we choose, e.g. OPS, to sort ?y . We attach each binding retrieved by ?x :c ?y with the OPS-presorting numbers of the triples. Having the OPS-presorting numbers, we can sort the join result according to ?y in linear time when computing the join. We use n buckets (where n is the number of the queried RD F triples), numbering them from 1 to n . Once a binding has been computed as a solution of this join, it is put into the corresponding bucket according to the OPS-presorting number. Once the join computation is finished, the result in these buckets are already sorted according to ?y . Within our demonstration, the user can choose an evaluator; formulate a SPARQL query or choose a predefined one; provide RDF data in N3 format, or choose from predefined ones. Two predefined data sets and queries are from two benchmarks: SP2B ( //dbis.informatik.uni-freiburg.de/index.php?project=SP2B ) and LUBM ( //swat.cse.lehigh.edu/projects/lubm/ ). Except for the third-party tools Jena and Sesame , our demo visualizes the output of the different phases of query processing (see Figure 1), e.g. displaying the abstract syntax trees of queries, the CoreSPARQL queries and the operator graphs generate d in different phases. Figure 5 and Figure 6 present two operator graphs after physical optimization, generated by RDF3X and RDF3X-Presorting , when they evaluate the SPARQL query in Figure 4. At (1) (Figure 5), RDF3X uses a merge join over sorted data, and the result of join is not sorted according to ?y . Therefore, at (2), RDF3X indexes on ?y and then uses a hash-join. In comparison, at (3) (Figure 6) RDF3X-Presorting performs the merge-join over sorted data and simultaneously sorts each join result according to ?y ; at (4), a merge-join over this sorted data is used. As the Index approach processes one triple pattern afte r the other, its operator graph contains a right-deep tree of joins after optimization. 
