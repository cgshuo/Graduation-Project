 Sequence tagging algorithms including HMMs (Ra-biner, 1989), CRFs (Lafferty et al., 2001), and Collins X  X  perceptron (Collins, 2002) have been widely employed in NLP applications. Sequential decoding, which finds the best tag sequences for given inputs, is an important part of the sequential tagging framework. Traditionally, the Viterbi al-gorithm (Viterbi, 1967) is used. This algorithm is quite efficient when the label size of problem mod-eled is low. Unfortunately, due to its O ( TL 2 ) time complexity, where T is the input token size and L is the label size, the Viterbi decoding can become prohibitively slow when the label size is large (say, larger than 200).

It is not uncommon that the problem modeled consists of more than 200 labels. The Viterbi al-gorithm cannot find the best sequences in tolerable response time. To resolve this, Esposito and Radi-cioni (2009) have proposed a Carpediem algorithm which opens only necessary nodes in searching the best sequence. More recently, Kaji et al. (2010) pro-posed a staggered decoding algorithm, which proves to be very efficient on datasets with a large number of labels.

What the aforementioned literature does not cover is the k -best sequential decoding problem, which is indeed frequently required in practice. For example to pursue a high recall ratio, a named entity recogni-tion system may have to adopt k -best sequences in case the true entities are not recognized at the best one. The k -best parses have been extensively stud-ied in syntactic parsing context (Huang, 2005; Pauls and Klein, 2009), but it is not well accommodated in sequential decoding context. To our best knowl-edge, the state-of-the-art k -best sequential decoding algorithm is Viterbi A* 1 . In this paper, we general-ize the iterative process from the work of (Kaji et al., 2010) and propose a k -best sequential decoding al-gorithm, namely iterative Viterbi A* . We show that the proposed algorithm is several times or orders of magnitude faster than the state-of-the-art in all tag-ging tasks which consist of more than 200 labels.
Our contributions can be summarized as follows. (1) We apply the A* search framework to sequential decoding problem. We show that A* with a proper heuristic can outperform the classic Viterbi decod-ing. (2) We propose 1 -best A*, 1 -best iterative A* decoding algorithms which are the second and third fastest decoding algorithms among the five decod-ing algorithms for comparison, although there is a significant gap to the fastest 1 -best decoding algo-rithm. (3) We propose k -best A* and k -best iterative Viterbi A* algorithms. The latter is several times or orders of magnitude faster than the state-of-the-art k -best decoding algorithm. This algorithm makes real-time large-scale tagging applications with thou-sands of labels feasible. In this section, we formulate the sequential decod-ing problem in the context of perceptron algorithm (Collins, 2002) and CRFs (Lafferty et al., 2001). All the discussions apply to HMMs as well. Formally, a perceptron model is and a CRFs model is where x and y is an observation sequence and a la-bel sequence respectively, t is the sequence position, T is the sequence size, f k are feature functions and K is the number of feature functions.  X  k are the pa-rameters that need to be estimated. They represent the importance of feature functions f k in prediction. For CRFs, Z ( x ) is an instance-specific normaliza-tion function If x is given, the decoding is to find the best y which maximizes the score of f ( y , x ) for perceptron or the probability of p ( y | x ) for CRFs. As Z ( x ) is a con-stant for any given input sequence x , the decoding for perceptron or CRFs is identical, that is, To simplify the discussion, we divide the features into two groups: unigram label features and bi-gram label features. Unigram features are of form f ( y t , x t ) which are concerned with the current la-bel and arbitrary feature patterns from input se-quence. Bigram features are of form f k ( y t ,y t  X  1 , x which are concerned with both the previous and the current labels. We thus rewrite the decoding prob-lem as For a better understanding, one can inter-pret the term P K 1 k =1  X  1 k f 1 k ( y t , x t ) as node y score at position t , and interpret the term P score. So the sequential decoding problem is cast as a max score pathfinding problem 2 . In the discussion hereafter, we assume scores of nodes and edges are pre-computed (denoted as n ( y t ) and e ( y t  X  1 ,y t and we can thus focus on the analysis of different decoding algorithms. We present the existing algorithms for both 1 -best and k -best sequential decoding in this section. These algorithms serve as basis for the proposed algo-rithms in Section 4. 3.1 1 -Best Viterbi The Viterbi algorithm is a classic dynamic program-ming based decoding algorithm. It has the computa-tional complexity of O ( TL 2 ) , where T is the input sequence size and L is the label size 3 . Formally, the Viterbi computes  X  ( y t ) , the best score from starting position to label y t , as follows. where e ( y t  X  1 ,y t ) is the edge score between nodes y t  X  1 and y t , n ( y t ) is the node score for y t . Note that the terms  X  y t  X  1 and e ( y t  X  1 ,y t ) take value 0 for t = 0 at initialization. Using the recursion defined above, we can compute the highest score at end po-sition T  X  1 and its corresponding sequence. The recursive computation of  X  y t is denoted as forward pass since the computing traverses the lattice from left to right. Conversely, the backward pass com-putes  X  y t as the follows. Note that  X y T  X  1 = 0 at initialization. The max score can be computed using max y 0 (  X  0 + n ( y 0 )) . We can use either forward or backward pass to compute the best sequence. Table 1 summarizes the computational complexity of all decoding algo-rithms including Viterbi, which has the complexity of TL 2 for both best and worst cases. Note that N/A means the decoding algorithms are not applica-ble (for example, iterative Viterbi is not applicable to k -best decoding). The proposed algorithms (see Section 4) are highlighted in bold. 3.2 1 -Best iterative Viterbi Kaji et al. (Kaji et al., 2010) presented an efficient sequential decoding algorithm named staggered de-coding . We use the name iterative Viterbi to describe this algorithm for the reason that the iterative pro-cess plays a central role in this algorithm. Indeed, this iterative process is generalized in this paper to handle k -best sequential decoding (see Section 4.4).
The main idea is to start with a coarse lattice which consists of both active labels and degenerate labels. A label is referred to as an active label if it is not grouped (e.g., all labels in Fig. 1 (a) and la-bel A at each position in Fig. 1 (b)), and otherwise as an inactive label (i.e., dotted nodes). The new la-bel, which is made by grouping the inactive labels, is referred to as a degenerate label (i.e., large nodes covering the dotted ones). Fig. 1 (a) shows a lattice which consists of active labels only and (b) shows a lattice which consists of both active and degener-ate ones. The score of a degenerate label is the max score of inactive labels which are included in the de-generate label. Similarly, the edge score between a degenerate label z and an active label y 0 is the max edge score between any inactive label y  X  z and y 0 , and the score of two degenerate labels z and z 0 is the max edge score between any inactive label y  X  z and y 0  X  z 0 . Using the above definitions, the best sequence derived from a degenerate lattice would be the upper bound of the sequence derived from the original lattice. If the best sequence does not include any degenerate labels, it is indeed the best sequence for the original lattice.
 The pseudo code for this algorithm is shown in Algorithm 1. The lattice is initialized to include one active label and one degenerate label at each position (see Figure 1 (b)). Note that the labels are ranked by the probabilities estimated from the training data. The Viterbi algorithm is applied to the lattice to find the best sequence. If the sequence consists of ac-tive labels only, the algorithm terminates and returns such a sequence. Otherwise, the lower bound lb 4 of the active sequence in the lattice is updated and the lattice is expanded. The lower bound can be initial-ized to the best sequence score using a beam search (with beam size being 1). After either a forward or a backward pass, the lower bound is assigned with the best active sequence score best ( lattice ) 5 if the former is less than the latter. The expansion of lat-tice ensures that the lattice has twice active labels as before at a given position. Figure 2 shows the column-wise expansion step. The number of active labels in the column is doubled only if the best se-quence of the degenerate lattice passes through the degenerate label of that column.
 Algorithm 1 Iterative Viterbi Algorithm Algorithm 2 Forward
Algorithm 2 shows the forward pass in which the node pruning is performed. That is, for any node, if the best score of sequence which passes such a node is less than the lower bound lb , such a node is removed from the lattice. This removal is safe as such a node does not have a chance to form an optimal sequence. It is worth noting that, if a node is removed, it can no longer be added into the lattice. This property ensures the efficiency of the iterative Viterbi algorithm. The backward pass is similar to the forward one and it is thus omitted.

The alternative calls of forward and backward passes (in Algorithm 1) ensure the alternative updat-ing/lowering of node forward and backward scores, which makes the node pruning in either forward pass (see Algorithm 2) or backward pass more efficient. The lower bound lb is updated once in each iteration of the main loop in Algorithm 1. While the forward and backwards scores of nodes gradually decrease and the lower bound lb increases, more and more nodes are pruned.

The iterative Viterbi algorithm has computational complexity of T and TL 2 for best and worst cases respectively. This can be proved as follows (Kaji et al., 2010). At the m -th iteration in Algorithm 1, it-erative Viterbi decoding requires order of T 4 m time because there are 2 m active labels (plus one degen-erate label). Therefore, it has P m i =0 T 4 i time com-plexity if it terminates at the m -th iteration. In the best case in which m = 0 , the time complexity is T . In the worst case in which m = d log 2 L e X  1 ( d . e is the ceiling function which maps a real number to the smallest following integer), the time complexity is 3.3 1 -Best Carpediem Esposito and Radicioni (2009) have proposed a novel 1 -best 6 sequential decoding algorithm, Car-pediem , which attempts to open only necessary nodes in searching the best sequence in a given lat-tice. Carpediem has the complexity of TL log L and TL 2 for the best and worst cases respectively. We skip the description of this algorithm due to space limitations. Carpediem is used as a baseline in our experiments for decoding speed comparison. 3.4 K -Best Viterbi In order to produce k -best sequences, it is not enough to store 1 -best label per node, as the k -best sequences may include suboptimal labels. The k -best sequential decoding gives up this 1 -best label memorization in the dynamic programming paradigm. It stores up to k -best labels which are nec-essary to form k -best sequences. The k -best Viterbi algorithm thus has the computational complexity of KTL 2 for both best and worst cases.

Once we store the k -best labels per node in a lat-tice, the k -best Viterbi algorithm calls either the for-ward or the backward passes just in the same way as the 1 -best Viterbi decoding does. We can compute the k highest score at the end position T  X  1 and the corresponding k -best sequences. 3.5 K -Best Viterbi A* To our best knowledge the most efficient k -best se-quence algorithm is the Viterbi A* algorithm as shown in Algorithm 3. The algorithm consists of one forward pass and an A* backward pass. The forward pass computes and stores the Viterbi forward scores, which are the best scores from the start to the cur-rent nodes. In addition, each node stores a backlink which points to its predecessor.

The major part of Algorithm 3 describes the back-ward A* pass. Before describing the algorithm, we note that each node in the agenda represents a se-quence. So the operations on nodes (push or pop) correspond to the operations on sequences. Initially, the L nodes at position T  X  1 are pushed to an agenda. Each of the L nodes n i , i = 0 ,...,L  X  1 , represents a sequence. That is, node n i represents the best sequence from the start to itself. The best of the L sequences is the globally best sequence. How-ever, the i -th best, i = 2 ,...,k , of the L sequence may not be the globally i -th best sequence. The pri-ority of each node is set as the score of the sequence which is derived by such a node. The algorithm then goes to a loop of k . In each loop, the best node is popped off from the agenda and is stored in a set r . The algorithm adds alternative candidate nodes (or sequences) to the agenda via a double nested loop. The idea is that, when an optimal node (or sequence) is popped off, we have to push to the agenda all nodes (sequences) which are slightly worse than the just popped one. The interpretation of slightly worse is to replace one edge from the popped node (se-quence). The slightly worse sequences can be found by the exact heuristic derived from the first Viterbi forward pass.

Figure 3 shows an example of the push operations for a lattice of T = 4 , Y = 4 . Suppose an optimal node 2: B (in red, standing for node B at position 2, representing the sequence of 0: A 1: D 2: B 3: C ) is popped off, new nodes of 1: A , 1: B , 1: C and 0: B , 0: C and 0: D are pushed to the agenda according to the double nested for loop in Algorithm 3. Each of the pushed nodes represents a sequence, for ex-ample, node 1: B represents a sequence which con-sists of three parts: Viterb sequence from start to 1: B (0: C 1: B ), 2: B and forward link of 2: B (3: C in this case). All of these pushed nodes (sequences) are served as candidates for the next agenda pop op-eration.

The algorithm terminates the loop once it has op-timal k nodes. The k -best sequences can be de-rived by the k optimal nodes. This algorithm has computation complexity of TL 2 + TL for both best and worst cases, with the first term accounting for Viterbi forward pass and the second term account-ing for A* backward process. The bottleneck is thus at the Viterbi forward pass.
 Algorithm 3 K -Best Viterbi A* algorithm In this section, we propose A* based sequen-tial decoding algorithms that can efficiently handle datasets with a large number of labels. In particular, we first propose the A* and the iterative A* decod-ing algorithm for 1 -best sequential decoding. We then extend the 1 -best A* algorithm to a k -best A* decoding algorithm. We finally apply the iterative process to the Viterbi A* algorithm, resulting in the iterative Viterbi A* decoding algorithm. 4.1 1 -Best A* A*(Hart et al., 1968; Russell and Norvig, 1995), as a classic search algorithm, has been successfully ap-plied in syntactic parsing (Klein and Manning, 2003; Pauls and Klein, 2009). The general idea of A* is to consider labels y t which are likely to result in the best sequence using a score f as follows. where g ( y ) is the score from start to the current node and h ( y ) is a heuristic which estimates the score from the current node to the target. A* uses an agenda (based on the f score) to decide which nodes are to be processed next. If the heuristic satisfies the called monotone or admissible . In such a case, A* is guaranteed to find the best sequence. We start with the naive (but admissible) heuristic as follows h ( y t ) = That is, the heuristic of node y t to the end is the sum of max edge scores between any two positions and max node scores per position. Similar to (Pauls and Klein, 2009) we explore the heuristic in different coarse levels. We apply the Viterbi backward pass to different degenerate lattices and use the Viterbi backward scores as different heuristics. Different degenerate lattices are generated from different it-erations of Algorithm 1: The m -th iteration corre-sponds to a lattice of (2 m +1)  X  T nodes. A larger m indicates a more accurate heuristic, which results in a more efficient A* search (fewer nodes being pro-cessed). However, this efficiency comes with the price that such an accurate heuristic requires more computation time in the Viterbi backward pass. In our experiments, we try the naive heuristic and the following values of m : 0 , 3 , 6 and 9 .

In the best case, A* expands one node per posi-tion, and each expansion results in the push of all nodes at next position to the agenda. The search is similar to the beam search with beam size being 1. The complexity is thus TL . In the worst case, A* expands every node per position, and each expan-sion results in the push of all nodes at next position to the agenda. The complexity thus becomes TL 2 . 4.2 1 -Best Iterative A* The iterative process as described in the iterative Viterbi decoding can be used to boost A* algorithm, resulting in the iterative A* algorithm. For simplic-ity, we only make use of the naive heuristic in Equa-tion (9) in the iterative A* algorithm. We initialize the lattice with one active label and one degenerate label at each position (see Figure 1 (b)). We then run A* algorithm on the degenerate lattice and get the best sequence. If the sequence is active we return it. Otherwise we expand the lattice in each iteration until we find the best active sequence. Similar to iterative Viterbi algorithm, iterative A* has the com-plexity of T and TL 2 for the best and worst cases respectively. 4.3 K -Best A* The extension from 1 -best A* to k -best A* is again due to the memorization of k -best labels per node. We use either the naive heuristic (Equation (9)) or different coarse level heuristics by setting m to be 0 , 3 , 6 or 9 (see Section 4.1). The first k nodes which are popped off the agenda can be used to back track the k -best sequences. The k -best A* algorithm has the computational complexity of KTL and KTL 2 for best and worst cases respectively. 4.4 K -Best Iterative Viterbi A* We now present the k -best iterative Viterbi A* algo-rithm (see Algorithm 4) which applies the iterative process to k -best Viterbi A* algorithm. The major difference between 1 -best iterative Viterbi A* algo-rithm (Algorithm 1) and this algorithm is that the latter calls the k -best Vitebi A* (Algorithm 3) after the best sequence is found. If the k -best sequences are all active, we terminate the algorithm and return the k -best sequences. If we cannot find either the best active sequence or the k -best active sequences, we expand the lattice to continue the search in the next iteration.

As in the iterative Viterbi algorithm (see Section 3.2), nodes are pruned at each position in forward or backward passes. Efficient pruning contributes significantly to speeding up decoding. Therefore, to have a tighter (higher) lower bound lb is important. We initialize the lower bound lb with the k -th best score from beam search (with beam size being k ) at line 1. Note that the beam search is performed on the original lattice which consists of L active labels per position. The beam search time is negligible com-pared to the total decoding time. At line 16, we up-date lb as follows. We enumerate the best active se-quences backtracked by the nodes at position T  X  1 . If the current lb is less than the k -th active sequence score, we update the lb with the k -th active sequence score (we do not update lb if there are less than k ac-tive sequences). At line 19, we use the sequences returned from Viterbi A* algorithm to update the lb in the same manner. To enable this update, we re-quest the Viterbi A* algorithm to return k 0 , k 0 &gt; k , sequences (line 10). A larger number of k 0 results in a higher chance to find the k -th active sequence, which in turn offers a tighter (higher) lb , but it comes with the expense of additional time (the backward A* process takes O ( TL ) time to return one more sequence). In experiments, we found the lb updates on line 1 and line 16 are essential for fast decoding. The updating of lb using Viterbi A* sequences (line 19) can boost the decoding speed further. We exper-imented with different k 0 values ( k 0 = nk , where n is an integer) and selected k 0 = 2 k which results in the largest decoding speed boost.
 Algorithm 4 K -Best iterative Viterbi A* algorithm We compare aforementioned 1 -best and k -best se-quential decoding algorithms using five datasets in this section. 5.1 Experimental setting We apply 1 -best and k -best sequential decoding al-gorithms to five NLP tagging tasks: Penn TreeBank (PTB) POS tagging, CoNLL2000 joint POS tag-ging and chunking, CoNLL 2003 joint POS tagging, chunking and named entity tagging, HPSG supertag-ging (Matsuzaki et al., 2007) and a search query named entity recognition (NER) dataset. We used sections 02-21 of PTB for training and section 23 for testing in POS task. As in (Kaji et al., 2010), we combine the POS tags and chunk tags to form joint tags for CoNLL 2000 dataset, e.g., NN | B-NP. Similarly we combine the POS tags, chunk tags, and named entity tags to form joint tags for CoNLL 2003 dataset, e.g., PRP$ | I-NP | O. Note that by such tag joining, we are able to offer different tag decodings (for example, chunking and named entity tagging) simultaneously. This indeed is one of the effective approaches for joint tag decoding problems. The search query NER dataset is an in-house annotated dataset which assigns semantic labels, such as prod-uct , business tags to web search queries.

Table 2 shows the training and test sets size (sen-tence #), the average token length of test dataset and the label size for the five datasets. POS and su-pertag datasets assign tags to tokens while CoNLL 2000 , CoNLL 2003 and search query datasets as-sign tags to phrases. We use the standard BIO en-coding for CoNLL 2000, CoNLL 2003 and search query datasets.

Due to the long CRF training time (days to weeks even for stochastic gradient descent training) for these large label size datasets, we choose the percep-tron algorithm for training. The models are averaged over 10 iterations (Collins, 2002). The training time takes minutes to hours for all datasets. We note that the selection of training algorithm does not affect the decoding process: the decoding is identical for both CRF and perceptron training algorithms. We use the common features which are adopted in previ-ous studies, for example (Sha and Periera, 2003). In particular, we use the unigrams of the current and its neighboring words, word bigrams, prefixes and suf-fixes of the current word, capitalization, all-number, punctuation, and tag bigrams for POS, CoNLL2000 and CoNLL 2003 datasets. For supertag dataset, we use the same features for the word inputs, and the unigrams and bigrams for gold POS inputs. For search query dataset, we use the same features plus gazetteer based features. 5.2 Results We report the token accuracy for all datasets to facil-itate comparison to previous work. They are 97.00, 94.70, 95.80, 90.60 and 88.60 for POS, CoNLL 2000, CoNLL 2003, supertag, and search query re-spectively. We note that all decoding algorithms as listed in Section 3 and Section 4 are exact. That is, they produce exactly the same accuracy. The accu-racy we get for the first four tasks is comparable to the state-of-the-art. We do not have a baseline to compare with for the last dataset as it is not pub-licly available 7 . Higher accuracy may be achieved if more task specific features are introduced on top of the standard features. As this paper is more con-cerned with the decoding speed, the feature engi-neering is beyond the scope of this paper.

Table 3 shows how many iterations in average are required for iterative Viterbi and iterative Viterbi A* algorithms. Although the max iteration size is bounded to d log 2 L e for each position (for exam-ple, 9 for CoNLL 2003 dataset), the total iteration number for the whole lattice may be greater than d log 2 L e as different positions may not expand at the same time. Despite the large number of itera-tions used in iterative based algorithms (especially iterative Viterbi A* algorithm), the algorithms are still very efficient (see below).

Table 4 and 5 show the decoding speed (sen-tences per second) of 1 -best and 5 -best decoding al-gorithms respectively. The proposed decoding algo-rithms and the largest decoding speeds across differ-ent decoding algorithms (other than beam) are high-lighted in bold. We exclude the time for feature ex-traction in computing the speed. The beam search decoding is also shown as a baseline. We note that beam decoding is the only approximate decoding al-gorithm in this table. All other decoding algorithms produce exactly the same accuracy, which is usually much better than the accuracy of beam decoding.
For 1 -best decoding, iterative Viterbi always out-performs other ones. A* with a proper heuristic de-noted as A* (best) , that is, the best A* using naive heuristic or the values of m being 0 , 3 , 6 or 9 (see Section 4.1), can be the second best choice (ex-cept for the POS task), although the gap between iterative Viterbi and A* is significant. For exam-ple, for CoNLL 2003 dataset, the former can de-code 2239 sentences per second while the latter only decodes 225 sentences per second. The iterative process successfully boosts the decoding speed of iterative Viterbi compared to Viterbi, but it slows down the decoding speed of iterative A* compared to A*(best). This is because in the Viterbi case, the iterative process has a node pruning procedure, while it does not have such pruning in A*(best) algorithm. Take CoNLL 2003 data as an exam-ple, the removal of the pruning slows down the 1-best iterative Viterbi decoding from 2239 to 604 sentences/second. Carpediem algorithm performs poorly in four out of five tasks. This can be ex-plained as follows. The Carpediem implicitly as-sumes that the node scores are the dominant factors to determine the best sequence. However, this as-sumption does not hold as the edge scores play an important role.

For 5 -best decoding, k -best Viterbi decoding is very slow. A* with a proper heuristic is still slow. For example, it only reaches 11 sentences per second for CoNLL 2003 dataset. The classic Viterbi A* can usually obtain a decent decoding speed, for example, 40 sentences per second for CoNLL 2003 dataset. The only exception is supertag dataset, on which the Viterbi A* decodes 0.1 sentence per second while the A* decodes 3. This indicates the scalability is-sue of Viterbi A* algorithm for datasets with more than one thousand labels. The proposed iterative Viterbi A* is clearly the winner. It speeds up the Viterbi A* to factors of 4, 7, 360, and 3 for CoNLL 2000, CoNLL 2003, supertag and query search data respectively. The decoding speed of iterative Viterbi A* can even be comparable to that of beam search.
Figure 4 shows k -best decoding algorithms de-coding speed with respect to different k values for CoNLL 2003 data . The Viterbi A* and iterative Viterbi A* algorithms are significantly faster than the Viterbi and A*(best) algorithms. Although the iterative Viterbi A* significantly outperforms the Viterbi A* for k &lt; 30 , the speed of the former con-verges to the latter when k becomes 90 or larger. This is expected as the k -best sequences span over the whole lattice: the earlier iteration in iterative Viterbi A* algorithm cannot provide the k -best se-quences using the degenerate lattice. The over-head of multiple iterations slows down the decoding speed compared to the Viterbi A* algorithm. The Viterbi algorithm is the only exact algorithm widely adopted in the NLP applications. Esposito and Radicioni (2009) proposed an algorithm which opens necessary nodes in a lattice in searching the best sequence. The staggered decoding (Kaji et al., 2010) forms the basis for our work on iterative based decoding algorithms. Apart from the exact decod-ing, approximate decoding algorithms such as beam search are also related to our work. Tsuruoka and Tsujii (2005) proposed easiest-first deterministic de-coding. Siddiqi and Moore (2005) presented the pa-rameter tying approach for fast inference in HMMs. A similar idea was applied to CRFs as well (Cohn, 2006; Jeong, 2009). We note that the exact algo-rithm always guarantees the optimality which can-not be attained in approximate algorithms.

In terms of k -best parsing, Huang and Chiang (2005) proposed an efficient algorithm which is sim-ilar to the k -best Viterbi A* algorithm presented in this paper. Pauls and Klein (2009) proposed an algo-rithm which replaces the Viterbi forward pass with an A* search. Their algorithm optimizes the Viterbi pass, while the proposed iterative Viterbi A* algo-rithm optimizes both Viterbi and A* passes.
 This paper is also related to the coarse to fine PCFG parsing (Charniak et al., 2006) as the degen-erate labels can be treated as coarse levels. How-ever, the difference is that the coarse-to-fine parsing is an approximate decoding while ours is exact one. In terms of different coarse levels of heuristic used in A* decoding, this paper is related to the work of hierarchical A* framework (Raphael, 2001; Felzen-szwalb et al., 2007). In terms of iterative process, this paper is close to (Burkett et al., 2011) as both exploit the search-and-expand approach. We have presented and evaluated the A* and itera-tive A* algorithms for 1 -best sequential decoding in this paper. In addition, we proposed A* and iterative Viterbi A* algorithm for k -best sequential decoding. K -best Iterative A* algorithm can be several times or orders of magnitude faster than the state-of-the-art k -best decoding algorithm. It makes real-time large-scale tagging applications with thousands of labels feasible.
 We wish to thank Yusuke Miyao and Nobuhiro Kaji for providing us the HPSG Treebank data. We are grateful for the invaluable comments offered by the anonymous reviewers.
