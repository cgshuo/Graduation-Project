 zational cooperation and e-business, face the challenge to retain the advantages of intra organizational business process management for the design of enterprise information systems -which extensively takes advantage of a central coordi-nation -while expanding the technology to fully distributed collaborations of autonomous entities. One of the major differences between centralized and dis-tributed process management is the access to data: uniform access to a joint central data store versus distributed management of data with explicit exchange of data via messages.
 where the explicit dataflow between participants is established. Starting point of our considerations is a process definition which assumes a global data store. This model is then augmented with messages for passing data between partic-ipants such that the process model can be executed in a fully distributed way, participants, and input and output parameters of activities. Many approaches down or mixed strategy. A global process definition including input and out-put data already implicitly defines the data flow between participants. For the explicit realization of the data flow, however, there are numerous possibilities tions explicitly into account and, therefore, cannot reason about the quality of however, only a single solution based on one fixed strategy is generated. Take for example the following trivial process chunk: lets an activity duce the parameters x and y , the succeeding activity B updates fer: the interface of B is widened to also include y (assuming that A sends y directly to C which requires additional messaging activities which are not yet included in the process definition. Now consider that conditionally. A simple solution, as proposed by [ 7 ] is that y to
C . On the one hand, this results in additional message overhead and on the other hand C may not even be allowed to get access to the (intermediate) transfer x from A to C ,if B is not executed later.
 One can easily see that for a given process definition as above there are numerous solutions for establishing a correct explicit data flow. We can reason about properties of a solution and define criteria, such as the number of (addi-for choosing among the possible solutions.
 The major contribution of this paper is a set of equivalence transformations space in which we can (heuristically) search for the best solution with respect to constraints and an objective function.
 The results presented here can be used for several purposes: to automatically a participant with a given unchangeable process interface can be accommodated to join the interorganizational workflow, or to verify and evaluate procedures and guidelines for establishing the data flow for interorganizational processes. 2.1 Basic Process Model defined as a process rather than as a set of protocols between two participants. usual basic control flow patterns sequence, par split / join, and xor split/join the WS-BPEL [ 19 ] standard. The process definition is extended with data defi-variables are its input and its output. Furthermore, we assign to each activity and each control step one of the participants as actor.
 task to be executed by participant a . R defines the set of input variables, process (including empty ones) and are represented by their label. defines a sequence of the blocks A and B . Sequences can also be defined by nesting: SEQ ( A, SEQ ( B, C ))  X  SEQ ( A, B, C ). XOR px,pj xor-block, where the xor-split is executed by participant cuted by participant pj .Block A is executed, if the condition B ps and the join is executed by participant pj . We also use a graphical repre-sentation which in analogy to the usual BPMN notation. The major difference is that we show which the participant executing a step as subscript, the set of is denoted by SR s ( X, pn, b ). It defines that participant the set of variables X to participant pn , if the condition cal notation we represent send-receive steps in analogy to BPMN choreography tasks. See the first step of TS 1 a in Fig. 2 as an example for communication step is implemented as a sending task in the local process of the sender and as a receiving task in the local process of the receiver. 2.2 Decision Model and Coordination The xor-split requires special attention in interorganizational processes. There are the following possibilities: (1) The condition is not defined in the global process, or (2) the condition is defined using some global variables. In case (1) the actor of the XOR-split makes the decision and informs the other participants, if necessary. In case (2) each participant could make the decision. However, this make the decision (i.e. evaluate the condition). This may result in additional communication overhead. Therefore and for providing a uniform treatment for condition.
 message they receive or do not receive. For an example, step not need to know about the decision of the xor-split. Only when participant b joins the process. In contrast participant a A a and E A must also be informed if E a is not called. Otherwise, forever to be called. (See also death paths elimination in BPEL [ 10 ].) allows each participant to execute each (required) xor-block locally. which is output of a preceding activity called decision step this pattern can be generated automatically. For the coordination it is important that all participants take the same decisions. Since variables can in general be updated, dependent xor-gateways or send-receive steps rely on the value a deci-sion variable had when it was written by the deciding participant. To make our life (and that of workflow designers) easier, we require that decision variables must only be written once.
 Data access within parallel blocks may lead to race conditions. In an intraor-ganizational setting this can be resolved by a transactional data store. For dis-tributed processes we do not assume a distributed transactional data store and, therefore, do not allow parallel read-write or write-write dependencies between or output in branches parallel to this activity. 2.3 Realizing Interorganizational Data Flow The process definition discussed above uses global variables as if there would be that each activity can access the most recent value of each variable. Implicitly ment of interorganizational processes we have to realize this implicit data flow by augmenting the process definition with explicit message exchanges which pass the content of variables between participants.
 Fig. 1 presents an example process using the graphical representation. The step A of participant a has variable x as input and as output.
 In the example there are 5 data flow dependencies between tasks of different participants shown with dotted lines. Data flow dependencies can be conditional. For example step E a only needs x from B b ,if B b and E a conditions b 1and b 2 hold). In order to support an interorganizational operation of the process, each data flow between different participants needs to be imple-mented by messages. Now there exist multiple solutions to support the data needs of E a . We may add a message exchange right after the execution of this case the message is only sent if B b is executed. However, it will always be sent, even if E a is not executed. The decision whether E or not. However, sending the message does not lead to an error in the data flow. A message is sent but its contents are not consumed as they are overwritten by a succeeding message. So this solution contains redundant message exchanges but it is correct. Another option is to add the message exchange sending b to a directly before E a . However, in this case it must only be executed if was executed. Otherwise a will get a wrong value for x . While B b was executed participant a does not and therefore needs to know whether a message will arrive.
 expression consisting of decision variables. In our example, we can now add the send-receive step SR b ( { x } ,a,b 1) directly before discussed problem. 2.4 Process Model Definitions A process model consists of sets of participants P , variables Let S be a task label, R,W sets of variables, c a decision variable, expression consisting of the decision variables d 1 ,...d is a block, and if A and B are blocks, then SEQ ( A,...,B PAR p s is the sender and r is the recipient of a communication step, d ,...d n are (sets of) input variables, W and X are output variables. In addition, a block inherits all input variables of its superordinate block. of an initial process P contains all the steps of P in the same topological order and some communication steps in addition. Each instantiation decision variables of a process P constitutes an instance type as a sub-model of P where each xor retains exactly one sub-block (depending on the value of the decision variable) and only those communication steps where the condition is true while the other sub-block is empty.
 data flow of an interorganizational process if for centralized and distributed executions the value of each input variable of a step originates from the output of the same activity. The origin of an input parameter x in block a of an instance type is defined as follows: If b is the closest predecessor activity step of output parameter then o ( P I ,a,x )= b .
 An initial process is correct, if all input parameters of all steps have a unique tialized variables and race conditions [ 23 ]. We emphasize that due to the hier-archical definition of process models it is not possible to define an incorrect workflow net.
 For the distributed execution of an augmented process we have to consider that a participant only can access the content of a variable if it was produced locally or if it was received through a communication steps.
 The distributed origin of the input parameter x in block a type
P I , o d ( P I ,a,x ) is defined as follows: Let p be the actor or sender of and let b be the closest predecessor step of a with x as output parameter and p as actor (for activity steps) or recipient (for communication steps). If activity step then o d ( P I ,a,x )= b ,if b is a communication step then Definition 1. Correct Augmentation. The augmentation P of a process is x of each block a : o ( P I ,a,x ) exists and is unique and There exists numerous correct augmentations of the data flow of a process. For they may be sent as late as possible or every data-exchange may follow the control-flow including transitive transfers. We present a set of transformations on augmented processes that allow to derive all other correct augmentations. 3.1 Equivalence Transformations on Sequences We provide a graphical description of equivalence transformations on sequences expression b .
 TS1a -Swap (Send-Receive / Activity): A send-receive step be swapped with an activity a , unless a is the destination of some variable transmitted or referenced by c : SEQ ( SR p SEQ ( a p 2 ( R, W ) ,SR p 1 ( X, pn, b )), unless ( W  X  X = {} p 2)  X  ref ( b )  X  W ) TS1b -Swap (Send-Receive -Send-Receive): Two send-receive steps in a sequence can be swapped, unless one is the destination of the other. SEQ ( SR p b 1)), unless: ( pn = p 2  X  pm = p 1)  X  ( X  X  Y = {}  X  ref ( pants is equivalent to transitive sending of the variables to these participants. SEQ ( SR p is equivalent to no send-receive step at the end of the process. the activity-step: SEQ ( SR p 1 ( X, pn, b ) ,a p 2 ( R, W unless R  X  X = {}  X  pn = p 2.
 variables by one single send-receive step or by two send-receive steps: SEQ ( SR p transfer the same set of variables from the same source participant to the same at least one of the conditions holds: SEQ ( SR p 3.2 Equivalence Transformations on XOR We first introduce two predicates: hasV alue and takesP art pos) returns true , if participant p 1 certainly has the value of the variable before the execution of the block pos . takesPart(xorBlock,participant) returns true , if the participant participant participates in any step of the xor-block xorBlock (recursively). Fig. 3 shows all equivalence transformations on xor-blocks.
 a xor-split is equivalent to two send-receive steps with the same parameters as s , where one is in each branch of the xor-split directly following the xor-split, if the sender and the receiver of s have the current value of the decision variable: SEQ ( SR p 1 ( X, pn, b ) ,XOR p 2 ,pj ( xb,A,B (
X, pn, b ) ,A ) ,SEQ ( SR p Value ( pn, xb, XS p receive step s located directly before a xor-join in the true of s and s are equivalent but the condition in s is a conjunction of the one of and the decision variable of the xor-split. XOR p 2 ,pj ( B )  X  SEQ ( XOR p 2 ,pj ( xb,A,B ) ,SR p 1 ( X, pn, { b  X  xb } TX2b Passing Join on false: XOR p 2 ,pj ( xb,A,SEQ ( B, SR SEQ ( XOR p 2 ,pj ( xb,A,B ) ,SR p 1 ( X, pn, { b  X  X  xb } ) TX3 -Jump over XOR-Block A send-receive step s , which is located and the target participant of s does not take part in the xor-block or any sub-blockofit: SEQ ( SR p 1 ( X, pn, b ) ,XOR p 2 ,pj ( xb,A,B A, B ) ,SR p TX4 -Inherit Conditions Given a send-receive step s with a condition which is nested into some xor-block x referencing the decision variable  X  bx ,if s is in Block A of x and b  X  b  X  X  bx if s is in Block TX1b -Add Send/Receive after XOR-Split Given a send-receive step s as a direct successor of a xor-split, we can add another send-receive step This is a one-way transformation. XOR p 2 ,pj ( xb, SEQ ( XOR =  X  XOR p 3.3 Equivalence Transformations on Parallel Blocks Equivalence transformations on par-blocks need to consider in which branch reading or writing activities of the transmitted variables are located. We first define the predicates hasW riter , hasReader and inB : hasW riter ( var, Block ) returns true if the variable in the block (recursively). hasReader ( var, block, participant the variable var is read by participant participant in the block (recursively). inB(var, Block, participant) is true ,if hasW riter ( var, Block ( var, block, participant ). Fig. 4 illustrates TP 1 a , TP branch with a consumer or a writer to every transferred variable. There are the following cases: A consumer or writer for every transmitted variable is in block A (TP1a), a consumer or writer for every transmitted variable is in block B (TP1b), a consumer for every transmitted variable is in Block (TP1c). If there is no consumer of any transmitted variable in also TP1a and TP1b applies.
 TP1a: SEQ ( SR p 1 ( X, pn, b ) ,PAR ps,pj ( A, B ))  X  PAR pn,b ) ,A ) ,B ), if  X  v  X  X :( inB ( v, A, pn )  X  X  inB ( v, B, pn  X  inB ( v, B, pn )) TP1b: SEQ ( SR p 1 ( X, pn, b ) ,PAR ps,pj ( A, B ))  X  PAR pn, b ) ,B )), if  X  v  X  X :( inB ( v, B, pn )  X  X  inB ( v, A, pn ))  X  inB ( v, B, pn )) TP1c: SEQ ( SR p 1 ( X, pn, b ) ,PAR ps,pj ( A, B ))  X  PAR pn, b ) ,A ) ,SEQ ( SR p TP2: Passing PAR-Join: A send-receive step located in some branch read or updated in branch B 1 and none is read or updated in the other branch, or if none of the variables is read or updated in any branch. In particular there are the cases: A reader or writer only in branch A , only in Branch TP2a: PAR ps,pj ( SEQ ( A, SR p 1 ( X, pn, b )) ,B )  X  SEQ ( PAR ps,pj ( A, B ) ,A,SR p 1 ( X, pn, b )), if  X  v  X  X :(  X  inB ( v, B, pn ))  X  (  X  inB ( v, A, pn )  X  X  inB ( v, B, pn )) TP2b: PAR ps,pj ( SEQ ( SR p 1 ( X, pn, b ) ,A ) ,B )  X  SEQ ( PAR ps,pj ( A, B ) ,A,SR p 1 ( X, pn, b )), if  X  v  X  X :(  X  inB ( v, A, pn ))  X  (  X  inB ( v, A, pn )  X  X  inB ( v, B, pn )) 3.4 Correctness and Completeness Theorem 1 (Correctness of the Equivalence Transformations) . Any application of any of the transformations on a correct augmentation of a process Definition 1 ) P leads to another correct augmentation of the process We prove the correctness of each transformation by showing that the trans-(details in [ 13 ]).
 Theorem 2 (Completeness of the set of equivalence transformations) . Every correct augmentation of a process P can be created by the application of the transformations starting from any correct augmentation of the process We define a normal form for augmentations of a process and show that, if an augmentation cannot be transformed to this normal form it is incorrect. The theorem then follows from the fact that each transformation has an inverse (details in [ 13 ]).
 The presented equivalence transformations provide a formal grounding for vari-ous applications dealing with data flow of interorganizational processes. We will present three applications scenarios as examples here. 4.1 Optimizing Message Exchanges Under Constraints Given an interorganizational process without communication steps we can gener-ate the complete solution space of correct implementations of the data flow. This objective functions and constraints. The best solutions heavily depends on user requirements. For example a major goal could be to achieve simple processes with minimal number of send-receive steps and favor message exchanges that can be integrated into the control-flow, while accepting some potentially redun-dant transfers. In another scenario minimizing the transferred data at runtime could be the major goal, when communications costs are high. For any of the previous examples additional constraints may exist. For example a participant specific step or a participant should not receive messages from a predefined set of other participants. We have implemented a proof-of-concept prototype that uses best first search to find optimal solutions based on the transformations starting from an initial augmentation where all values are broadcasted to all participants after each modification. It allows the user to define an objective function based on various parameters including the weighted number of send-receive steps, the weighted number of transmitted variables and the number of transfers from unknown par-xor-blocks and their conditions. For the weighted number of send-receive we do not count communication steps, which can be integrated into the control-flow. When a solution is derived, local processes can be generated for each partici-pant by simple projection of the steps onto each participant [ 15 ]. These local conducted initial experiments with our implementation and the generated solu-tions are promising. Future work will address starting with a more efficient ini-tial augmentation and the application of sophisticated heuristics and a flexible framework for modeling various constraints. 4.2 Integrating Participants with Existing Processes The previous scenario assumed a top-down development paradigm. However, in many cases participants already have existing processes that may not be changeable leading to a mixed approach. When participants with existing pro-whether their (data) interfaces are compatible with the interorganizational pro-cess and to select the best solution based on an objective function. This can be realized in analogy to the previous application scenario. The only difference is that we start with an interorganizational process with fixed (data) interfaces of one or more participants. In a next step an initial augmentation is created. Then solutions can be generated. However, only those are acceptable, where the participants with existing interfaces have only send-receive steps that are equivalent to their existing interfaces. In other words solutions are gener-ated, where the non fixed participants act as mediators for the fixed ones. An example is the following: One participant needs to receive the variables one single message from participant e . However, a , b and by different other participants. Then the equivalence transformations can be used to generate solutions where participant e collects the results of the other participants and then sends the variables with one single message. 4.3 Validation of Guidelines and Methods Using the equivalence definition we can also validate guidelines for designing the dataflow or procedures generating the dataflow by analyzing whether the resulting augmented processes can be transformed to a process known to be correct (e.g. the initial processes described in Section 4.1 above). We propose a set of equivalence transformations on the realization of the data flow of inter-organizational processes to derive (interfaces to) local processes from a global process definition. Approaches like the public to private approach onto different participants and the correct implementation of control-flow in the private process. Our approach complements these approaches for the correct implementation of the data flow specification using message exchanges. ing or in form of interaction-centric modeling are both supported by BPMN (2) [ 20 ]. Interconnection modeling wires multiple (collaboration) models together using message exchanges. Interaction-centric modeling is supported by choreog-raphy diagrams. An advantage of the interaction-centric style is that a global view of the choreography exists, preventing typical flaws of not properly aligned models. However, they still require that the message exchanges are modeled ing the goals of the choreography in terms of control-and data flow requirements -message exchanges are not part of the global process. Instead our approach allows to automatically generate and optimize the required message exchanges (choreography) between the participants. We address the data flow perspective eling guidelines that allow to derive message contents of a given choreography automatically. It is based on a global data model which is mapped to the local ones of each participant. Since our rules allow to automatically generate opti-mized message exchanges (choreographies) our output can be used as an input the participants. [ 17 ] proposes a set of design patterns for the implementation of data flows satisfying data dependencies. Instead of proposing a fixed set of common patterns we allow to automatically select the best solution according to the users requirements.
 cesses with the aim to find assignments of participants that result in optimal assignment of participants is fixed. Directly related to our approach are role approaches also allow to derive processes for each participant. However, the implementation of the data flow is based on a fixed strategy and consequently provide only one solution is provided. An approach focusing on privacy aspects [ 29 ] allows to define which participants may exchange messages and to automat-ically find alternative paths if certain exchanges are forbidden. In contrast, we have provided a general approach for optimizing the implementation of data-transfers based on various criteria where privacy issues and constraints -among those also privacy constraints.
 space for the correct realization of inter organizational data flow via message exchanges, taking a (correct) global process with implicit data flow as input. Interorganizational business process management -a promising techniques to foster collaboration and e-business -still requires research and development, in particular in architecture, design and implementation techniques. There exists various implementations for the data flow of an interorganizational process. In this paper we have provided a comprehensive set of equivalence transformations that can act as a solid foundation for several applications such as: Top-down development of interorganizational processes including the automatic optimiza-tion of the data flow between different participants and the enforcement of var-procedures for designing interorganizational processes with data flow. It allows ganizational process not only regarding the control-flow but also regarding the (optimized) data flow.

