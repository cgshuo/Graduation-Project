 Outsourcing data to a datacenter is a typical type of computing paradigm in the cloud. To ensure the privacy of the sensitive data, storing those data encrypted on remote servers becomes a common view. However, encryption also destroys the natural structure of data and introduces many challenges in running database applications.

One of the main challenges is how to execute queries over encrypted data. De-veloping new ciphers for keyword searching on encrypted data seems a compre-hensive solution for this issue. However, either the symmetric encryption scheme [6] or the asymmetric encryption scheme [7] cannot prevent the curious service provider locating the positions with the same method. The DAS (Database as a Service) model [4] addresses a bucketization method. According to this model, the data is encrypted by a traditional block cipher and the domain of each sensitive attribute is divided into a set of bucket s which is labeled by bucket tags. Thus some values can be mapped into a single bucket and the tuples with the same bucket tag may have different original values. This scheme obviously introduces false answers when retrieving data from remote servers.

Another challenge is on the computations over encrypted data. Since ho-momorphic encryption (HE) enables an equivalent relation exists between one operation performed on the plaintext an d another operation on the ciphertext, it is considered as an effective solution t o this issue. According to the relations supported, the homomorphic encryption methods can be partially [2] or fully [3]. The introduced nonce in both methods makes it difficult to distinguish two HE-encrypted values even if they are the same in plaintext. The HE methods require locating the encrypted tuples precisely before performing any computation.
Locate encrypted tuples implies execute comparison operations over encrypted data on server without decryption. As m entioned above, if the comparison re-sults could be distinguished on server, the curious service provider could also manipulate in the same way to obtain information about sensitive values. The CryptDB scheme [8] defines layers of encryption for different types of database queries. For executing a specific query, layers of encryption can be removed by decrypting to an appropriate layer and the tuple locating is based on the cipher-text comparing. This may lead many sensi tive values be stored to the lowest level of data confidentiality provided by the weakest encryption scheme, and leak sen-sitive details such as the relations between sensitive values and the distribution of values. Furthermore, the introduced nonce in this scheme makes the cipher-text comparing become complicated even if a proxy at client side maintains the relations between the plaintext and ciphertext.
 It is necessary to introduce the HE methods in encrypting outsourced data. In this paper, we aim at providing a simple method for locating HE-encrypted data precisely. Compared with the matching methods of an encrypted string, we introduce the notion of value tags and perform the comparisons based on the value tags. A sensitive value being encrypted is mapped into an appropriate value called value tag. It implies that two encrypted tuples with a same value tag will have a same sensitive value.

The contributions of this paper can be enumerated as follows. 1. We introduce an auxiliary attribute for precisely locating HE-encrypted val-2. We propose a method, named Splitting -Duplicating , to construct the value 3. We develop an entropy-based metric to measure the protected degree of data The rest of this paper is structured as follows. In Section 2, we give our moti-vation. In Section 3, we formulate the proposed Splitting-Duplicating method. In Section 4, conduct some range query experiments to validate our proposed method. And finally, the conclusion is drawn in Section 5. We assume the database is outsourced to a database service provider and the provider is curious but honest.

Considering the relation, R =( A 1 ,A 2 , ..., A n ), with n sensitive attributes. Its corresponding encrypted relatio nonservercanbedescribedas R s 1 =( A s 1 e ,A s 2 e , all the attribute value need to be modified during the database running, the attributes can be simplified into two types, the modifiable attributes and the non-modifiable ones.

Without loss of generality, assume the attribute A n is modifiable and the others are non-modifiable in relation R . Considering the encryption features in traditional ciphers and the computation feature in HE methods, we redescribe R 1 as R version of n  X  1 tuple A 1 ,A 2 , ..., A n  X  1 , A s n HE denotes the HE-encrypted A n attribute.

However, the data in a database is not only for storage but also for queries and computations. The introduced nonce in HE methods makes it difficult to perform equality tests on server. To support the encrypted tuple locating, we introduce value tag . A value tag is used to identify an attribute value. If two value tags of an attribute are equal, the corresponding two attribute values are also equal. Therefore, the encryp tedrelationstoredonservercanbe R s = attribute A i .

Table 1 shows an example for a relation in original and on server. When executing an SQL operation over the encrypted data, a translator at client will translate the plain operation in R into the server-side operation in R s .
For example, the SQL Update operation: can be translated into the following on server: where 2 HE is the HE-encrypted result of 2.

It is easy to distinguish the two Update operations. The server-side operation can be viewed as the encrypted version of the client-side operation. The transla-tion, besides changes the plain value modification into an encrypted one, changes the where condition into an OR-Expression whose length is 2..

We also note that the distribution of salary tag is the same as the attribute salary in plaintext. The link attack could immediately be proceeded to this encrypted relation [1]. A simple strategy against the link attack is to destroy the consistency between the two distributions.
 In this paper, we consider to change the distribution of the artificial tag values. We intend to limit the frequencies of value tags in a given range and make the distribution as uniform as possible. Two approaches can be adopted to reach the target. 1. Splitting . Adding new tag values to the table. For example (as in Table 2), 2. Duplicating . Adding new noisy items to the table. For example (as in Ta-3.1 The Value Tag Entropy We follow the basic notations described previously. The tag construction for traditional encrypted attributes are referred in [4], we only need to consider how to construct the value tags for the HE-encrypted attributes. Without causing confusion, we suppose the attribute A is the HE-encrypted attribute. Definition 1. Given an attribute A with domain D A and a value v  X  D A ,a value tag mapping is the mapping, VTmap : D A  X  Integer , and the value tag for v is the integer VTmap ( v ) , denoted by vt .
 Some typical cryptology techniques, such as the block ciphers and the keyed hash functions, can be used to define the mapping VTmap .
 Definition 2. An HE-related tuple is the tuple v,vt,n vt ,n a where v is the original value, vt is the corresponding value tag stored on server, n vt is the frequency of vt ,and n a is the additional frequency increment for vt . The HE-related tuples are stored on clients for translating the SQL operations. Initializing a set of HE-related tuples is straightforward. The following procedure demonstrates the sketch for initializing the HE-related tuple set T with size N , where the HE-related tupl e set is constructed as a RTLtup structure. Given the value tag set VT = { vt | v,vt,n vt ,n a  X  T } and n = vt n vt ,the following formula can be used to compute the entropy of VT : We use the above formula to measure the degree of original data distribution protected in a given value tag set. It is obviously that the H ( VT ) reaches its maximize value log 2 | VT | when the frequencies of each value tag are the same.
Intuitively, if the frequencies of ea ch value tag are nearly the same, an ad-versary need more efforts to guess the whole value distribution of sensitive data on the database server, even if he knows the probability distribution of sensitive data and a few exact values of sensitive data. This intuition is consistent with the notion of the value tag set entropy. It is noted that the information entropy is a measure of unpredictability. The larger the entropy, the more privacy pro-tected in a value tag set. It implies that t he approximative frequencies of each value tag may introduce more power against the link attacks. 3.2 Limiting the Frequencies of Value Tags Let t low ,t high be two threshold values where t low &lt;t high . We try to limit the frequencies of each value tag in a range ( t low ,t high ].
 Definition 3. The HE-related tuple set HFset = { v,vt,n vt ,n a | v,vt,n vt ,n a  X  T  X  n vt  X  t high } is called as the high frequency set.
 Definition 4. The HE-related tuple set LFset = { v,vt,n vt ,n a | v,vt,n vt ,n a  X  T  X  n vt &lt;t low } is called as the low frequency set.
 In general, when an HE-related tuple set is initialized, both HFset and LFset are not empty. Our goal is to reconstruct the HE-related tuple set T with emptied HFset and LFset . We will adopt two strategies, Spiltting and Duplicating ,to empty HFset and LFset , respectively.

We first give a method for decomposing n into a sequence: sn 1 ,sn 2 , ...sn k s.t.  X  i : sn i  X  ( t low ,t high ]and i sn i = n . We only consider two scenarios, the case of (0 ,t ]andthecaseof( t, 2 t ].

The decomposition in case (0 ,t ] is trivial and we only need iteratively pick an integer from (0 ,t ]. For the case of ( t, 2 t ], the procedure can be showed as follows. Theorem 1. The procedure of Decomposing can decompose the integer n (n  X  2t) into a sequence of integers that are in ( t, 2 t ] .
 Definition 5. For a tuple t = v,vt,n vt ,n a  X  T ,wesay t is split into two value tag is vt ) are mapped into tags vt 1 and vt 2 ,and n vt 1 =0 ,n vt 2 =0 . We denote VT s asthenewvaluetagsetafteratupleissplit.
 Theorem 2. If a tuple t  X  T is split into two tuples t 1 , t 2 , we have H ( VT s ) &gt; H ( VT ) .
 This theorem indicates that when a tuple is split into two parts, the entropy of value tag set becomes larger. 3.3 The Splitting Procedure and Duplicating Procedure The Splitting procedure and the Duplicating procedure are simple and directly. We sketch them as following. In the Splitting procedure, the HE-related tuple set T is scanned to check whetherornotthe HFset ( T ) is empty. If the element v,vt,n vt , 0 is in HFset ( T ), we will decompose n vt into a sequence of integer { k i } such that  X  k i : k i  X  ( t low ,t high ]and i k i = n . It implies that we have split n vt tuples into a set of tuplesetwhosesizeis k i , respectively. For the tuple set with size k i , we generate anewvaluetag vt i for those k i tuples and append the tuple v,vt i ,k i , 0 into value tag set T .The Splitting procedure empties the subset HFset ( T ). In the Duplicating procedure, the iterative check targets at LFset ( T ). If the element v,vt,n vt ,n a is in LFset ( T ), some random noise tuples with the same value tag vt will be created and stored into the encrypted database on server. This makes the frequency of vt in R s increase to the range ( t low ,t high ]. The Duplicating procedure empties the subset LFset ( T ) but also introduces some noise tuples. 4.1 Measuring SQL Operation Time Cost Based on OR-Expression After performing Splitting -Duplicating over the encrypted data, the where con-dition of a plain SQL operation will be translated into an OR-expression. The number of operands in an OR-expression is called as the length of this OR-expression. Different lengths of OR-exp ression may lead to different SQL oper-ation response time. We run a set of exp eriments to confirm this intuition.
These experiments are on an HP mini-210 with Intel Atom N450 1.66GHz and 1GB memory. We create 5 tables, each is with 20k integers, under Win-dows XP sp3 and MS SQL2000. The integers is evenly distributed in intervals [1 , 1 k ] , [1 , 2 k ] , [1 , 5 k ] , [1 , 10 k ], and [1 , 20 k ], respectively.
We perform the query, select  X  from T where OR -expression ,andregulate the OR -expression in order to retrieve 20 tuples on each table. We randomly generate the OR -expression , execute the query, and record the response time. The average time in 1,000 tests is shown as in Fig. 1
Fig. 1 demonstrates that as the length of OR -expression increases, the query retrieved the same number of tuples n eeds more response times. Based on this observation, we use the length of OR -expression to evaluate the SQL operation time cost for our proposed Splitting -Duplicating method.
 4.2 Performing Splitting -Duplicating on Synthesized Dataset The next experiments are on synthesized data. We assume the sensitive data are on normal distribution and generate a test dataset data 500 k with 500,000 integers in the interval [1, 999]. These 500 k integers are viewed as the attribute values needed to be HE-encrypted, and we adopt our proposed method to construct corresponding value tags.

The original value distribution in data 500 k is demonstrated in Fig.2. Fig. 3 demonstrates two instances of value tag distribution after performing the Splitting -Duplicating procedure. Fig. 3(a) is for the case of limiting the fre-quencies in (400 , 800] and (b) is for limiting in (0 , 800]. The tag values in both instances demonstrate completely different distribution comparing to the origi-nal value distribution.

Fig. 4 demonstrates how the entropy changes with the parameter t of the two scenarios, ( t, 2 t ]and(0 ,t ]. We find that as t increases, the value of entropy de-creases in both cases. It implies that smaller t s will bring larger entropy because of the larger state variable space. This means the smaller t s will provide more degrees of the capability of privacy protected. 4.3 Range Queries Range query is a fundamental class of queries in database applications. For a relation with a single attribute, the range query window can be formulated as [ x, x + size ], denoted by querywin ( x, size ), where size is the range size. In our experiments, we set size from 0 to 100 with step size 1.

There are two kinds of possible user behaviors in range queries [5].  X  Data-based query. Each value in attribute domain can be chosen to construct  X  Value-based query. Each value in attribute domain is equally chosen to con-
Thus, the range query windows, querywin ( x, size ), can be constructed by different x selection methods. The data-bas ed query window is constructed by randomly choosing x from data 500 k while the value-based query window is con-structed by randomly choosing x from [1, 999].

For each range size size , we respectively generat e 1,000 random queries on the two user behaviors, and apply these queries on the constructed value tag set. We evaluate the experiment results on the following items.
  X  The OR-expression length ratio. It reflects the average query response time  X  The proportion of noise tuple cases. It is the average proportion of the query  X  The number of noise tuples. It defines average number of noise tuples intro-Fig.5, Fig.6, and Fig.7 demonstrate three sets of experiment results.
As shown in Fig.5(a), Fig.5(b), Fig.6(a), and Fig.7(a), we find that the OR-expression length ratio values almost keep invariable when varying the query window sizes in our conducted experiments. The larger the frequency limitation parameter t , the smaller the OR-expression length ratio. The length ratios intro-duced in two query behaviors for the Scenario (t, 2t] are almost the same, while for the Scenario (0, t], the value-based queries can be responded more efficiently.
There are not noisy tuples in quer y results because of no needing Duplicating procedure in the scenario (0, t]. For the scenario (t, 2t], the two query behaviors demonstrate similar characteristics in noise tuple appearance. As demonstrated in Fig.6(b), Fig.7(b), the proportions of noise tuple cases are almost the same in both behaviors, and the proportion values increase slightly when the query range increases. Both two figures show that the larger frequency limitation parameter t leads to larger proportions of noise tuple cases. For the average number of noise tuples, as shown in Fig.6(c) and Fig.7(c ), the value-based queries may receive less noise tuples obviously. 4.4 Trade-Off Between the Privacy and the Performance According to the results of conducted experiments, we can define a trade-off strategy between the privacy and the performance. On one hand, as shown in Fig.4, the smaller the frequency limitation parameter t , the larger entropy the system has. On the other hand, as shown in Fig.5, Fig.6, and Fig.7, the smaller t will introduce more response cost. Therefore, given a degree of privacy pro-tected, we can define an entropy-base d method to find a proper parameter t with minimum query response time cost. We have proposed Splitting -Duplicating method to support locating HE-encrypted data precisely by introducing an auxiliary value tag. To protect the privacy of original data distribution, we limit the frequencies of different tag values varying in a given range. We use an entropy based metric to measure the degree of privacy protected. Some experiments have been conducted to validate our proposed method.

