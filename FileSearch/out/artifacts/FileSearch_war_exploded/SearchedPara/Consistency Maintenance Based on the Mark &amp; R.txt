 Replicated architecture is widely used for concealing net-work delay. However, consistency maintenance in fully repli-cated architecture is a major technical challenge. In this pa-per, we report a Mark &amp; Retrace based method in replicated groupware systems. Compared with the Operation Trans-formation technique, it does not adjust the operation X  X  posi-tion but retraces the document X  X  address space to the state at the time of the operation X  X  generation. Then the opera-tion can be executed directly in this address space. Mark &amp; Retrace method can not only achieve the same goal of consistency maintenance but also provide a better support for Undo . This paper provides the proof of the algorithm X  X  correctness of consistency maintenance, in which both the orders of character nodes and marks of each node at all sites are kept consistent. Furthermore, the amortized efficiency can reach O ( logn ).
 C.2.4 [ Computer-Communication Networks ]: Distribu-ted Systems X  Distributed applications ; H.5.3 [ Information Interfaces and Presentation ]: Group and Organization Interfaces X  Collaborative computing, Synchronous interac-tion Algorithms, Design, Human Factors CSCW, Concurrency Control, Consistency, Group editors, Undo, Address Space Transformation, Mark &amp; Retrace  X  The work is supported by N SFC under Gra nt No.60473124, National Grand Fundamental Research 973 Program of China under Grant No.2005CB321905, Shanghai Yi-Wang-Liang-Ku under Grant No. 20051020d1sj05-A a nd Shanghai Science and Technology Committee Key Project.

Group editors are one of the most commonly used group-ware applications [2, 7, 15]. It allows multiple users to par-ticipate in the editing and modification of shared data ob-jects, such as word, graphics, and media documents, using a computer network. Techniques for building group editors have been widely applied and practiced [2, 3, 7, 12]. Group editors have also been acknowledged as powerful research vehicles in exploring solution to consistency problems [2, 4, 6, 15, 19].

To hide the effects of network delay and give better local response to users, a replicated architecture has been widely adopted [2, 6, 15]. In a replicated architecture, a local user X  X  operations are executed immediately to achieve good respon-siveness and are then multicast to remote replicas to keep the document states consistent. Compared with conven-tional techniques such as locking and serialization, it has no adverse effects on the user interface while the replicated document states are maintained in consistent states which observe the CCI model [6, 15].

OT is a consistency maintenance technique. In the OT method, due to the existence of concurrent operations, a remote operation should include or exclude some operations X  effects [14, 15] and find the correct operation position or area at the local site. To maintain the CCI model, in the past decade, OT method has been gradually improved (include extensions of control algorithms [2, 14, 15, 8, 17] and OT functions [5, 9] ). In this process, we have realized that an OT algorithm which completely maintains the CCI model will be very intricate.

Mark &amp; Retrace is a new method, which is different and independent of the OT technique. It retraces the document X  X  address space to the state at the time of the operation X  X  generation. In this state, we can directly find the execution position for the operation. This process does not affect the order of characters in current document. It only needs to determine the position of a new operation. It can maintain the CCI model in replicated architecture and is easier to support group Undo [19, 20].

This paper is organized as follows. First, the concept of the address space transformation is introduced in Section 1. Then, the Mark &amp; Retrace method is described. The correctness and efficiency of the technique and how it sup-ports Undo operation are discussed in Sections 3, 4 and 5, respectively. In Section 6, the Mark &amp; Retrace method is compared with related works. Finally, we conclude this pa-per and point out future directions.
State vector based timestamping [2] has been widely used to detect causal relationships among operations. In the timestamping scheme, every site maintains its own state vec-tor. After an operation is generated, it is attached with the generating site X  X  current state vector, and is then multicast to all other sites.

Then, we discuss the operation X  X  expression. Without loss of generality, each character is indivisible and each opera-tion targets only one character. In fact, any complex Insert or Delete can be divided into a group of indivisible oper-ations. So this assumption does not affect operation X  X  ca-pability. Since an operation targets only one character, a Delete can only be represented by a position P .A Delete is timestamped by SV O del , which indicates that the site X  X  state vector is SV O del when the operation was generated and its intension is to delete the P th effective character counting from the left. And an Insert can be represented by an In-serted content C and an Inserting position P .AnInsert timestamped by SV O ins denotes that the site X  X  state vector is SV O ins when the operation was generated and its inten-tion is to Insert the content C between the P th and P +1th effective characters counting from the left. (There also exist two special Inserting positions: the left of the most left ef-fective character and the right of the most right character). Figure 1: The order of operations X  producing and executing
A remote operation cannot be directly executed at the local site due to the effect of concurrent operations on the local document state, which may result in an offset in the execution position of the remote operation. Consider a sys-tem consisting of three users and a shared empty document state. The order of operations  X  generation and execution is shown in Fig.1. Here we only need to focus on operation O and O 5 , but this example is also relevant to later Fig.3 and 4. Operation O 5 is to insert  X  X  X  at position 3 between  X  X  X  and  X  X  X . Consider what happens when user U 1 attempts to execute the operation O 5  X  X nserting the character  X  X  X  at position 3. Since the character  X  X  X  was deleted by O 4 ,po-sition 3 now refers to the posit ion on the right of  X  X  X  rather than the intended position of the left of  X  X  X . To resolve this problem, the OT technique transforms the operation X  X  target position. It adjusts the target position of an opera-tion by taking into account of all the effects of concurrent operations. In Fig.1, due to the existence of concurrent op-eration O 4 , O 5 shall be transformed to Insert [ X  X  X , 2] before execution.

The AST (Address Space Transformation) is a different technique to OT  X  X he operation X  X  intention is achieved by transforming the address space, rather than the operation itself. The basic idea of AST is as follows. If it is known that user U 1 cannot execute O 5 directly because the address space of the document has been changed, address  X 3 X  rep-resents the right of character  X  X  X  which is different from the one at the time of O 5  X  X  generation. To execute operation O we shall retrace the document X  X  address space to the state at the time of O 5  X  X  generation, which is shown in Fig.2. In this way, O 5 can be executed directly in this new address space, that is address  X 3 X  represents the position between  X  X  X  and  X  X  X . To support the transformation of the document X  X  ad-dress space, a marking technique is used. A mark indicates if a character node effective or ineffective at a given time. We shall describe the Mark &amp; Retrace method and how it may be used to achieve consistency in the next section.
To achieve causality preservation in the timestamping scheme, we only need to ensure that every remote operation is causally-ready before its execution, which we call execution condition [2, 15]. It should be noted that even if causality is preserved, the execution order of the operations would still be different because of their different orders of arrival at different sites. In the following, we shall focus on the issues of how we can execute an operation correctly to achieve convergence and intention preservation, under the assumption that causality is preserved. In follow discussion we use the same definition of casual ordering relation  X   X   X  and independent relation  X   X  in [15].
The difficulty in achieving convergence and intention preser-vation is that the relationships that exist among indepen-dent operations can result in changes to the operations X  po-sitions and area. The OT technique searches the operations that may cause these changes and derives their effects first. Then it adjusts the operation current position accordingly [2, 6, 15]. Mark &amp; Retrace method tries to conceal such ef-fects in the document. It marks and conceals the execution effects of some operations, which allows the document to be converted to the document to the address space at the time of an operation X  X  generation. In this way we can directly find an accurate position and then achieve the execution ef-fects of the operation. The advantage of this method is that we do not have to think of the complex relations among op-erations. We only need to pay attention to each operation X  X  effect on user X  X  view.

Assume a document is a liner structure composed of char-acters. Each character may have several operations target-ing itself while each operation targets only one character. Then we save the operation together with its timestamp to the character X  X  liner node. So apart from the information of characters and corresponding operations, we also add the effective/ineffective mark information to every node in the liner structure. The mark indicates whether the current node is observable on the user interface or not. So a doc-ument structure might be expressed as Fig.3. In Mark &amp; Retrace method, the address space can be expressed as the effective character nodes from left to right.
 Figure 3: The final state of document X  X  liner struc-ture and user X  X  view in the case of Fig.1
Given the liner structure of document at site S , Doc S ,and the state vector at site S , SV S . Suppose SV is a timestamp which meets the execution condition. Then the Retracing procedure can be expressed as Proc.1:
The goal of the Retracing procedure is to retrace the address space to the state at a given timestamp SV .It reviews every character node and determines their  X  X ffec-tive/ineffective X  marks in the timestamp SV . Its execu-tion is only to preserve the effects of operations which are causally before generation. For every character node, sup-pose that the Insert and Delete attached are timestamped by SV O ins and SV O del . We should consider the following four situations. (1) if SV O ins  X  SV , then this node is marked ineffective; (2) if SV O ins  X  SV and there is no Delete targeting this character node, then this node is marked effec-tive; (3) if SV O ins  X  SV and SV O del  X  SV , then this node is marked effective; (4) if SV O ins  X  SV but SV O del  X  SV , then this node is marked ineffective.

On one hand, consider an Insert and a Delete attached on a node, then it must be SV O ins  X  SV O del .Inotherwords Procedure 1 Retracing ( Doc S , SV ), retrace the address space of Doc S with timestamp SV 1: for all character node CN i of liner structure of Doc S 2: Set CN i ineffective 3: Consider the Insert O ins of CN i 4: if O ins is timestamped by SV O ins and SV O ins  X  SV 5: set CN i effective 6: end if 7: for each Delete O del of CN i 8: if O del is timestamped by SV O del and SV O del  X  SV 9: set CN i ineffective 10: end if 11: end for there will not exist the situation where SV O ins  X  SV while SV
O del  X  SV . On the other hand, when several concur-rent Delete operations target one character, there may be several Delete operations attached on one node. When one of them satisfies SV O del  X  SV , this node must be marked ineffective. We can see that inside a node, the effects of op-erations independent or causally after timestamp SV have not been considered. As to the result of Retracing, an  X  X ffec-tive/ineffective X  mark of one character node is determinate as long as timestamp SV is fixed.

There are two examples. Given an operation O which is timestamped by SV and is causally-ready for execution. For any operation O and O  X  O , O is sure to have been ex-ecuted. The result of Retracing ( Doc S , SV )isthatitcan conceal all the effects of operations which are independent of operation O and retrace the address space to the time SV at the time of its generation. In other words, it can achieve an address space of liner structure, whose effective character nodes are completely consistent with the site X  liner structure at the time of operation O X  X  generation. This con-sistency has two meanings. One is that they both have the same set of effective character nodes. The other is that all the ineffective character nodes at the current site are either ineffective or nonexistent at the operation X  X  generation site and at the time of the operation X  X  generation. Another ex-ample. When current state vector of the site S is SV ,the result of Retracing( Doc S , SV )is that it can restore the ad-dress space to the state that is used by the local user. If SV represents the state vector when a new operation has just been executed at the site S, the effect of the new operation has already been involved. All the timestamps of operations which have been executed before the new one are all before SV . And the adjustment of SV after new operation X  X  ex-ecution also makes new operation X  X  timestamp before SV . So all the effects of executed operations have been retained and the new operation X  X  effect also has been applied.
When a remote operation O generates at site R and times-tamped by SV O is causally-ready for execution, we can ex-press the execution process of O at site S whose state vector is SV S in Proc.2.

The definition of operation position is obtained by count-ing the number of effective character nodes on the left side of linear structure at the time of its generation. When the Procedure 2 Control-Algorithm ( Doc S , O ), execute O on Doc S 1: Retracing( Doc S , SV O ) 2: Execute the operation O 3: Attach the operation with its timestamp to the character 4: SV S [ R ]  X  SV S [ R ]+1 5: Retracing( Doc S , SV S ) order of any two character nodes is certain, Retracing( Doc SV
O ) ensures that the address space (effective character nodes) of the current document X  X  liner structure is the same as the one at the time of the operation X  X  generation. So control algorithms ensure that we can count to the correct effective character node when executing an operation. And by adjusting SV S ,Retracing( Doc S , SV S ) can restore the ad-dress space to the state which has included the new opera-tion X  X  execution effect. See also Fig.4. When user U 1 intends to execute operation Insert[ X  X  X , 3] with timestamp &lt; 1,1,2 &gt; , the document state is shown in top-left. First, the control al-gorithm retraces the document to the view  X  X bd X (top-right) atthetimeoftimestamp &lt; 1,1,2 &gt; by concealing the effect of operation Delete[ X  X  X , 2], then inserts  X  X  X  between  X  X  X  and  X  X  X . The State Vector of the local site has been adjusted to &lt; 2,1,2 &gt; after the execution is finished. And then it re-traces to the view  X  X cd X (bottom-left) of new State Vector by restoring the effect of operation Delete[ X  X  X , 2] and adding the execution effect of the new operation Insert[ X  X  X , 3].
The focus of this section is on how an operation O is executed:
If O denotes a Delete operation , just find the characters in the address space (count the effective character nodes in the liner structure of Doc S ) to find the position.
If O denotes an Insert operation , find the position in the address space (count the effective character nodes in the liner structure of Doc S to find the range between two adjoining effective character nodes), build a new character node, initialize the mark and Insert it to an accurate posi-tion within the range.

Since Retrace( Doc S , SV O ) transforms the address space to the state at the time of the operation X  X  generation, the Delete operation X  X  execution is simple. The process is to find the corresponding character node, attach the operation on the character node and then perform the Retracing pro-cedure to give this node a correct effective/ineffective mark. But the Insert is to search for an Inserting position in the address space, which is corresponding to a range in docu-ment between two effective character nodes. There may ex-ist some other ineffective character nodes in this range. We need a Range-Scan process to determine the right-and-left relation between the new Insert and these ineffective char-acter nodes and then find an accurate position. A TOrder function, which realizes a total order relation among In-sert operations, has been involved in the follow to realize this Range-Scan process. Since the Delete only revises the mark information and has no effect on the order of char-acter nodes, the focus of following discussion is on Insert operations.

To realize the comparability between two Insert opera-tions, we refer to the technique of maintaining operation transformation order[15]. Given the TOrder relation to rep-resent the right-and-left relation between two inserted char-acters. Given two character nodes CN a and CN b .Theat-tached operations are generated at site a and site b ,andare timestamped by SV a and SV b .Wehave TOrder ( CN a ) &lt; TOrder ( CN b ), iff: (1) sum ( SV a ) &lt;sum ( SV b ), or (2) a&lt;b when sum ( SV a )= sum ( SV b ), where sum ( SV )= N  X  1 i The TOrder relation is a total order which is transitive and any two TOrder are comparable.

The process to determine an accurate position of a new operation O is to scan every Insert in this range from left to right. There are two kinds of Insert operations in this range. Some of these operation s are casually before oper-ation O .Weforcethenew Insert O to insert on the left side of these Insert operations, so when Range-Scan scans to these operations, it will directly end itself (Range-Scan Function, line 12-17). The other Insert operations are con-current with operation O . We compare them by comparing the TOrder relation (Range-Scan Function, line 4-11). The inserting position is saved in the P . The new operation will be inserted on the left side of P . We can sketch the scanning process as Func.3.
 Function 3 Range-Scan( CN a , CN b , CN new ), scan charac-ter nodes between CN a and CN b , then return the position 1: P  X  Nill and CN scan  X  CN a .right 2: repeat 3: Compare CN new with CN scan 5: if TOrder ( CN new ) &lt;TOrder ( CN scan ) 7: end if 8: if TOrder ( CN new ) &gt;TOrder ( CN scan ) 9: P  X  Nill 10: end if 11: end if 13: if P = Nill then 14: P  X  CN scan 15: end if 16: exit the loop 17: end if 19: until CN scan = CN b 20: if P = Nill then 21: return P 22: else 23: return CN b 24: end if
Retracing process locates the Insert into a one-and-only range. Range-Scan process determines a one-and-only po-sition for this Insert in the range and keeps it from being affected by concurrent operations. Then we explain how algorithm maintains the convergence and intention preser-vation in detail in the next section.
Suppose that originally, every site has the same initial document state and that all the character node orders at every site are the same. Given n operations to be executed, we shall discuss how to ensure that all the sites still have the same character nodes orders after the operations X  execution.
Consider the situation where there are two operations O 1 and O 2 . If they are casually ordered, since the execution order is certain, the result will be certain too. If they are concurrent, we prove the following theorem.

Theorem 1. If O 1 and O 2 are concurrent and inserted to a same scan-range (i.e. the range between two effective characters CN a and CN b in the Range-Scan process), the execution effects of two operations have no relation with their execution order.

Proof. When O 1 and O 2 are executed respectively in this range, there are only three possible cases: 1. O 1 , O 2 ends with the same return position. 2. O 1 ends with the return position on the left of O 2  X  X . 3. O 1 ends with the return position on the right of O 2  X  X .
We would like to prove that in the three cases above, if we execute one operation after another (i.e. O 1 before O O 2 before O 1 ), the results are the same no matter in what sequence they are executed. With out loss of generality, assume TOrder ( O 1 ) &gt;TOrder ( O 2 ).
 To simplify description, given the following notations in Fig.5,6.
 Figure 5: Definition of some special character nodes
Case 1: O 1 and O 2 end with the same return position when they are executed respectively.

In this case, the possible situations before the execution can only be Fig.7.
 Figure 7: Possible situations before executing O 1 and O 2 respectively in case 1: O 1 and O 2 end with Then in the situation in Fig.7, if O 1 is executed before O , the result is Fig.8.

If O 2 is executed before O 1 , the same result can be ob-tained due to the certain TOrder relationship between O 1 and O 2 . Case 2: O 1 ends with the return position on the left of O  X  X  when they are executed respectively.

In this case, the possible situations before the execution can only be Fig.9.
 Figure 9: Possible situations before executing O 1 and O 2 respectively in case 2: O 1 ends with the re-turn poison O T L 2 ; O 2 passes through O T L 2 and ends with the return position O T any or O T G 2 or O T any Then in the situation in Fig.9, if O 1 is executed before O , the result is shown in Fig.10-a. O 1 ends with the return position O T L 2 . During the Range-Scan process of O 2 ,when it scans to O 1 , it will record O 1 into P and go on scanning to O T L 2 .Since O T L 2  X  X  TOrder is less than O 2  X  X  and O is causally before O 1 which is saved in P ,so P will be reset to Nill . And then the process ends with the return position O If O 2 is executed before O 1 , the result is shown in Fig.10-b. O 2 passes through O T L 2 and ends with the return position O sition O T L 2 as before. We can see that the two results in Fig.10-a and Fig.10-b are the same.
 Case 3: O 1 ends with the return position on the right of O  X  X  when they are executed respectively.

In this case, the possible situations before the execution can only be Fig.11.
 Then in the situation in Fig.11, if O 1 is executed before O , the result is shown in Fig.12. Because O 1 is concurrent with O T L 1 and O T L 1 G 2 ,andthe TOrder of O 1 is more than that of O T L 1 and O T L 1 G 2 , O 1 will pass through O O O any .When O 2 is being executed, it will end with the Figure 11: Possible situations before executing O 1 and O 2 respectively in case 3: O 2 ends with the re-turn position O T L 1 or O T L 1 G 2 ; O 1 passes through O or O T L 1 G 2 and ends with the return position O T G 1 or O
If O 2 is executed before O 1 , O 2 ends with the return posi-tion O T L 1 or O T L 1 G 2 as before. When O 1 is executed, since it is concurrent with O 2 and its TOrder is more than that of O 2 , it will pass through O 2 as well as O T L 1 or O end with return position O T G 1 or O T any or O T any .Thusthe same result is obtained.
 All the three cases show that no matter in what sequence O 1 and O 2 are executed the results are always the same, i.e. the execution effects of the two operations have no relation with their execution order.

Theorem 2. If O 1 and O 2 are concurrent, the execution effects of two operations have no relation with their execution order.

Proof. Consider the scan-range of the two operations. 1. If the scan-ranges of the two operations have no shared 2. If the scan-ranges of the two operations have one shared
Therefore, the execution effects of two operations have no relation with their execution order no matter what scan-ranges they have.
Theorem 3. Orders of character nodes at every site are still consistent when n operations have been executed.
Proof. First, when all the document orders at every site are consistent, executing two operations under the execu-tion condition, a consistent order is certain to be obtained. Then suppose the orders of character nodes at every site are consistent after we have executed n  X  1operationsinthe order which meets the execution condition. What we want to prove is that the orders of character nodes at every site are still consistent when n operations have been executed.
Suppose executing n operations under the execution con-dition at two sites, whose order can be expressed as O 1 O O 3 ...O n and O k 1 O k 2 O k 3 ...O k n . Without loss of gener-ality, suppose O k i = O 1 .Since O 1 O 2 O 3 ...O n meets the current. The change of any two concurrent operations X  exe-cution order does not affect the result of the document, so O Since O k i = O 1 and after the adjustment the first operation of every sequence is O 1 , we can execute the first operation of every sequence first. Here, all the sites X  orders are still consistent and the operation sequences to be executed are which still meet the execution condition. According to the assumption, the orders of character nodes at every site are consistent after we have executed n  X  1operationsinthe order which meets the execution condition, so the orders of document X  X  character nodes are still consistent after these two sequences have been executed. So all the orders of char-acter node at the sites X  are consistent after n operations have been executed in the order which meets the execution con-dition.
We have proved that after executing several operations in any order which meets the execution condition, the orders of character nodes at every site will keep consistent. It is to say that the order in which two operations are executed at one site for the first time has been kept at any other sites. In addition, the key to the correctness of a Delete operation is that it can find the correct effective character node and the consistency of orders of character node ensures it to count to the correct effective character node. Both of the orders of character nodes and effective/ineffective marks of every character node at all sites are kept consistent, so the documents are convergent. Since a Insert operation can find the correct scan-range and a Delete operation can find its corresponding character node at any sites and they do not interfere with other operations, those satisfy operations X  definition in Section 2. However, there are still some argu-ments for intention preservation, we plan to present more about intention X  X  formal definition and the complete proof in the next future.
The dOPT puzzle described in C.A.Ellis et al.[2] supposes that several Insert operations targeting the same position satisfy certain causal or concurrent relationships. Judging their order by simple priority cannot ensure convergence. In the dOPT puzzle, different operations execution orders canbereducedtothetwotypicalcasesshowninFig.10.
 In Fig.10, O 1 is causally after O T L 2 and O 2 are concurrent with O 1 and O T L 2 . It is shown that we can always obtain the same result no matter in what sequence the operations are executed. It is proved in Section 3.5.2 that the convergence can also be ensured in some more complex situations. The false-tie puzzle in C.Sun et al.[15], which is also called ERV puzzle in D.Li et al.[6], supposed that two concurrent Insert operations may lose their relative position (left or right) due to the Delete between them and obtain the oppo-site result. In the Mark &amp; Retra ce method, the scan-ranges of two Insert operations with the relative position (left or right) have no shared pa rt. Since a concurrent Delete has no impact on the result of the retracing process, the range-scan processes of these two Insert operations are performed in two independent scan-ranges and do not affect each other. So the results of every site are convergent.
In Control-algorithm, we can see that the cost of algo-rithm is mainly spent on two aspects. One is the execution of Retracing and the other is the execution of Insert or Delete . Attaching operations on corresponding nodes and modify-ing the state of the local site can be finished in time O (1). Discuss these two aspects respectively. Since the execution efficiency of Retracing is relevant to the operations X  organize structure, we first introduce the optimization of operation execution efficiency.
The first step of operation X  X  execution is to count to the appointednodes. Thenthe Insert chooses an inserting posi-tion between two nodes during the Rang-Scan proc while the Delete only revises that node X  X  effective/ineffective mark. The efficiency of mark revision is obviously O (1) and the time complexity of Rang-Scan is O ( m )inwhichmrepre-sents the number of the ineffective character nodes between the two effective character nodes. When the document is of great scope, comparing with the great number of ineffective character nodes produced by Delete , the concurrent opera-tions which are marked ineffective can be neglected. So m is approximately equal to the using rate of Delete and Insert .
When a document is organized by liner structure, the pro-cess of counting is sequential access to linear structure. Its time complexity is linear which is expressed as O ( n )inwhich n is the number of character nodes in the document. But when the document is of great scope, the great number of ineffective nodes makes the execution time of algorithm dis-satisfactory. We hope to further optimize the operation ex-ecution efficiency.

We reorganize the character nodes to a Red-Black Tree [1] and ensure the result of pre-order traversal of the Black-Red tree is the original linear order. It means that every node X  X  left sub-tree is the set of the nodes which are on the left of itself in the original linear structure. As the figure below, the Insert and Delete operations in the Red-Black Tree can keep this property easily. Since the internal ro-tation rules of Red-Black Tree do not affect the result of pre-order traversal, as long as the counting process can find the correct position, the correctness of algorithm will not be affected if we change the sequential access from left to right to the pre-order traversal of the tree.
 Figure 14: Adjusting the liner structure to a Red-Blacktree Then we extend the data structure of original Red-Black Tree . Every node of the tree saves two additional data  X  X he two numbers of the effective character nodes of left sub-tree and right sub-tree. When the effective/ineffective mark of every node has been changed or there is a effective charac-ter node being Inserted or deleted, only the data of ancestor of this node has to be changed. Suppose a Red-Black Tree has n nodes ( n is the number of the document X  X  character nodes). The time complexity is O ( logn ) when changing the mark of one node because of the tree is approximately bal-anced. In one Red-Black Tree ,one Insert or Delete operation can result in at most two or three rotations and every rota-tion only involves two nodes. We can adjust the data of this node (the number of effective character nodes of this node X  X  left and right sub-tree) when executing rotation operations. The time complexity of changing the two nodes X  mark is O (1) and the time complexity of ancestor X  X  adjustment is O ( logn ), so the time complexity of Insert or Delete in one Red-Black Tree is still kept O ( logn ). The reader can derive the analysis and the proof of the correctness of expanded Red-Black Tree in [1].

Then when we need to count the P th effective character node in pre-order traversal, we can search it recursively as Func.4.

This recursively searching process is the extension of the general traversal process of binary search tree, whose time complexity is still O ( logn ).
 So in the new document structure, the optimization of an Insert operation X  X  time complexity is O ( logn + m )andthe Delete operation X  X  is O ( logn ). Since m is the using rate of Delete and Insert , we can use ordinary potential method to make the further analysis: since the Delete is executed m times while the Insert is executed once, we can amortize the cost O ( m ) of Range-Scan within an Insert to m corre-sponding Delete operations. And then the amortized costs of Insert and Delete are both O ( logn ).
 Function 4 Count( P , node ), return the P th effective char-acter node 1: if node.Numof Lef t = P  X  1and node.effective = true 2: return node 3: end if 4: if node.Numof Lef t &gt; P  X  1 then 5: return Count( P , node.lef t ) 6: else 7: if node.effective = true then 8: return Count( P  X  node.Numof Lef t  X  1, 9: else 10: return Count( P  X  node.Numof Lef t , node.right ) 11: end if 12: end if
The Retracing procedure is to retrace to the state accord-ing to the given timestamp SV . The effective/ineffective mark is only determined by the relations between SV and timestamp of every operation attached on the node. When the timestamp of every operation attached on the node are kept causal before SV , the node X  X  effective/ineffective mark is certain. In other words, for every operation to be exe-cuted, only when the operation attached on a certain node is concurrent with it, this node X  X  effective/ineffective mark will be changed.

On the one hand, suppose an operation O has been exe-cuted at every site, and another operation O generates after O .Theremustbe O  X  O and there is no need to consider operation O when we executing Retracing by the timestamp of operation O . On the other hand, every operation is sent to other sites together with SV of current site. This SV represents the documents state at the time of operation X  X  generation and through it other sites will know what opera-tions have been executed at the sending site. We only keep the OList containing the operations which haven X  X  been exe-cuted at some sites. During Retracing process, we only take into account of the character nodes relevant to these opera-tions into consideration and as long as we have ensured that one operation has been executed at every site, we can delete it from the OList .

Then we can use the same method as State Vector Ta-ble(SVT) in Garbage Collection Scheme in [15] to deter-mine the members of OList . Maintain a SV T at every site and suppose the state vector table of the k th site is SV T Initially, SV T k [ i ][ j ] = 0 for all i, j  X  0 ,...,N  X  ecuting an operation O from a remote site r , timestamped by SV O ,updatedthe SV T k : SV T k [ r ][ i ]= SV O [ i ], for all i  X  0 ,...,N  X  1. Let MSV k be the minimum state vector at site k : MSV k [ i ]= min ( SV T k [0][ i ] ,...,SVT k for all i  X  0 ,...,N  X  1. MSV k is updated after the new operation X  X  execution at site k . Then check every operation OList -i in OList . Suppose OList -i is generated at site r and timestamped by SV OList  X  i .When SV OList  X  i [ r ]  X  MSV it is obvious that OList -i has been executed at all sites. So we can delete it from the list.

Suppose the length of OList is h which means we need to check and change at most h character nodes X  effective/ineffective mark during Retracting process. Under the new document structure, suppose the number of operations attached on a character node is d and then the cost of checking the node X  X  effective/ineffective mark is O ( d ) and the cost of adjusting its ancestor X  X  data(the number of effective character nodes of node X  X  left and right sub-tree) is O ( logn ). So the time com-plexity of Retracing can be expressed as O ( d  X  h + h  X  logn ). Generally, the number of the operations attached on a node is smaller than ten, so we can consider d as a constant. Dur-ing the operation execution process, when the operation is executed and fed back in good time, the length of OList will not be increased. Obviously, we can also consider h as a constant.

Before the execution of Control-Algorithm process, the state vector of site S is SV . Control-Algorithm adjusts this state vector to SV by SV S [ R ]  X  SV S [ R ]+1 and only the R th element has been changed. So after the second Re-tracing process in Control-Algorithm is finished, only the targeting character node of the new operation has changed. We record all the changed nodes in the Retracing( Doc S SV
O ) first. When it is the time to execute Retracing( Doc S SV
O ), we restore the changed nodes instead of the Retracing process. After then, we only need to deal with the targeting character node of the new operation. The time complexity of the restore process can be expressed as O ( h + d ).
Colligate the execution efficiency of operation and process of Retracing, we have the actual execution cost. The cost of Insert is O ( h  X  logn + logn + d  X  h + h + d + m )andof Delete is great number of operations, consider h (the OList  X  X  length) and d (the number of operations attached on every node) as two constants, we have the amortized cost of an operation O ( logn ), in which n is the number of character nodes in the document. And we plan to give a further comprehensive comparison with OT technique in the future work.
In Mark &amp; Retrace method, the expression of Undo is like that of Insert and Delete . It includes the state vector of its generation site and the operation that is being undone. We can identify the corresponding operation of the Undo by the number of generation sites and the timestamp attached [19, 20]. When the Undo operation is causally-ready, it will be executed in the control algorithms. Given an Undo opera-tion O 2 , Undo[ O 1 ], in which O 1  X  X  target position is P timestamped by SV O 1 . O 1 and O 2 should be attached on the same character node. The execution process can be per-formed as follow. Rretrace the address space to the state at the time SV O 1 , count to the P 1 th effective character node and attach O 2 on it. Then the second Retracing process takes this new Undo into consideration and gives this node the correct effective/ineffective mark.

During the Retracing process, the only adjustment pro-duced by the introduction of Undo operation is that it takes the effect of Undo into consideration when deciding the ef-fective/ineffective mark of a character node. Since there may attached several concurrent Delete operations or Undo operations on one character node, it may cause the intention violation [19, 20]. We have discussed the cause of intention violation and how to judge and deal with it in [19, 20], but we have not discussed the display strategy in detail. Ac-tually, the method will be very simply if we want to real-ize Multi-version/Single-display [12, 13, 16]. The advantage of Multi-version/Single-display has been also emphasized in CoWord/CoPowerPoint [12, 13, 16].

In order to realize the Multi-version/Single-display strat-egy of intention violation by Undo ,weappenda Delete counter to every character node, whose initial value is zero. Every Delete and every Undo toward Insert will plus 1 to this counter while every Undo toward Delete will minus 1 to this counter. The Retracing process only considers the effects of other valid operations (the timestamp is causally before the given one) on the counter. Consider a charac-ter node, when the Insert is valid and the counter X  X  value is 0, this character is marked effective, otherwise it will be marked ineffective. When there are several Delete opera-tions in the algorithm, the character node is effective only when all the Delete operations are undone, otherwise it will keep ineffective. When there exists intention violation, the algorithm maintains the intention of users who want char-acter node to be ineffective, namely Multi-version/Single-display strategy [16].

During the revised Retracing process, the set of valid oper-ations in a given SV is certain so the result of the counter is also certain and the effective/ineffective mark as well. Since the Undo does not affect the order of character nodes, the CCI model is also maintained. Compared with OT, Mark &amp;Retracewith Undo operation can deal with current undo puzzles well and it does not need any other adjustments [10, 11]. For space reason, please refer to [19, 20] for the anal-ysis of how to deal with undo puzzles and the cause and judgments of intention violation. The execution efficiency of undo operation approximates that of Delete .Thetime complexity and its amortized cost are both kept as O ( logn ).
The initial concept of Address Space Transformation was reported early in [4, 18] but was not able to resolve the dOPT puzzle. The algorithms in [4, 18] are localized in the relation between the new operation and the executed ones at current site but has not fully considered the confu-sion of concurrent operations. When all the operations in dOPT puzzle are executed between two existing character nodes (for example, executing dOPT puzzle in an initially vacant document), the operation order will not be affected by the retracing process. So it needs additional solutions when there are several concurre nt operations targeting one position, but [4, 18] lack such support to this situation.
Algorithm dOPT, adOPTed and GOTO are based on TP2, [2, 7, 14, 15], but cannot fully satisfy TP2. NICE reported notification server [8] and SOCT3/4 used the sequence method [17], but neither of them is able to resolve the false-tie (ERV) puzzle. GOT maintains the convergence by the method of a global total order of execution. But Li et al.[6] pointed out that the original GOT will fail in the case of complicated false-tie (ERV) scenarios but the details have not been pub-lished. Li et al.[6] also pointed out that although the so-lution of false-tie (ERV) has been realized in [12], it is still not published. Imine et al.[5] tried to support TP2 by ex-panding IT function but fails in solving dOPT puzzle. Li et al.[6] reported a solution and also gave the proof. We have explained that our Mark &amp; Retrace method can satisfy the CCI model and deal with dOPT puzzle and false-tie(ERV) puzzle.

We discuss the support to Undo based on the current work, finally. Among the algorithms above, adOPTed sup-ports the sequential Undo by maintaining a multiple dimen-sions data structure [7]. REDUCE supports undo any op-eration at any time by inversing the Undo operation [10, 11]. But when facing Undo puzzles, it needs to maintain the operations X  relationship additionally, which adds to the time complexity of algorithm (nonlinear time complexity). Mark &amp; Retrace method also can support any Undo and can resolve the Undo puzzles in [10] more easily. None of the cur-rent methods has considered the intention violation in Undo [19, 20]. Although REDUCE can maintain convergence in the intention violation and obtain the effect of Multi-version /Single-display strategy, it lacks related examining method and enough hints to users. In this paper, we report a new solution to Multi-version/Single-display strategy and plan to discuss the Multi-version/ Multi-display strategy and its related examining and hinting method in the further work. More information can be derived in [19, 20].
In this paper we present a strategy which can maintain the CCI model and is different from OT. It does not en-sure the operation X  X  execution correctness by modifying the operation X  X  address but by transforming the address space of the document. Since the Mark &amp; Retrace processes do not affect the relative position (left or right) between char-acters, it is easier to maintain operations X  order. It can not only achieve all the consistency criteria in [6, 15], but can support any Undo as well.

For space reason, we have not given more examples to de-scribe the process to resolve the Undo puzzles using Mark &amp; Retrace. More information can be derived in [19, 20]. We plan to discuss more about the Multi-version/Multi-display strategy in Undo intention violation and the support to up-date operation and tree based structures of Mark &amp; Retrace Algorithm.
The authors wish to thank Yan Yu and David Sun for their help in improving the final presentation of this article and Qin Zhang for his assistance in the proofs. The authors are also very grateful to anonymous referees for their detailed and insightful comments and suggestions. [1] T. H. Cormen, C. E. Leiserson, and R. L. Rivest. [2] C. A. Ellis and S. J. Gibbs. Concurrency control in [3] N. Gu, J. Xu, X. Wu, J. Yang, and W. Ye. Ontology [4] H. He, Q. Wu, and L. Luo. Document marking scheme [5] A. Imine, P. Molli, G. Oster, and M. Rusinowitch. [6] D.LiandR.Li.Preservin g operation effects relation [7] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenbauser. [8] H. Shen and C. Sun. Flexible notification for [9] M. Suleiman, M. Cart, and J. Ferrie. Concurrent [10] C. Sun. Undo any operation at any time in group [11] C. Sun. Undo as concurrent inverse in group editors. [12] C. Sun. The coword and copowerpoint project. [13] C. Sun and D. Chen. Consistency maintenance in [14] C. Sun and C. A. Ellis. Operation transformation in [15] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen. [16] D. Sun, S. Xia, C. Sun, and D. Chen. Operational [17] N. Vidot, M. Cart, J. Ferrie, and M. Suleiman. Copies [18] X. Wu and N. Gu. A concurrency control method [19] J. Yang, N. Gu, and X. Wu. A document mark based [20] J. Yang, Q. Zhang, N. Gu, G. Yang, and Z. Liu. The
