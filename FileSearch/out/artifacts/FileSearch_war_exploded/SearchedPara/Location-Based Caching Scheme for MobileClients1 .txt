 Over the last two decades, several studies have been conducted with emphasis on spatial database processing. Location-dependent information services(LDISs) is one of the applications which is gaining increasing attention. LDISs represent new innovating ways to satisfy customer needs, such as traffic reports, hotel information and weather broadcasts [10]. A core concept of LDISs is the NN query, which retrieves the data closest to a query point.
 without the any specific client having to send an actual request. Any number of clients can monitor and retrieve data from the broadcast. Therefore, the client is to represent the needs of the clients, such a scheme makes effective use of low wireless bandwidth and is ideal for achieving maximum scalability. Two key requirements for data access in wireless e nvironments are power conservation and the minimization of client waiting time. In push-based systems, the mobile clients must wait until the server broadcasts the desired data. In this case, the client waiting time is determined by the overall usage of the broadcast data channel [1]. A technique used to address this issue, called air indexing ,operatesby interleaving indexing information among the broadcast data items. At the same time, the client device can reduce its battery power consumption through the use of selective tuning [2,4]. The Air Indexing technique can be evaluated in terms of the following factors:  X  Access Time (AT): The average time elapsed from the moment a client issues  X  Tuning Time (TT): The amount of time spent by a client listening to the  X  Probe Wait : The average duration for getting to the next index segment. If  X  Bcast Wait : The average duration from the moment the index segment is work against each other [2,4].
 mobile computing environment. After pointing out the limitations of the existing indexing schemes, we present various schemes that can overcome these problems. We believe this is the first work in which NN query processing without an index segment is proposed, providing the opti mum access time. Thro ughout this paper, we assume that the data objects are in 2-dimensional space and are static, such as restaurants, hospitals, and hotels. The mobile clients can identify their locations using systems such as the Global Positioning System(GPS). Spatial databases have been studied extensively during the last two decades, from this research, several spatial acces s methods have been proposed. In this section, we provide some background on the location model, caching models and air index schemes, which we adapt in this study. 2.1 Data on Air The broadcasting of spatial data together with an index structure is an effective way of disseminating data in a wireless mobile environment. This method allows mobile clients requesting data to tune into a continuous broadcast channel only when spatial data of interest and relevance is available on the channel, thus minimizing their power consumption [2,3,8]. 2.2 Voronoi Diagrams VDs are fundamental tools used to express the proximity of geometric objects. The VD divides a space into disjoint polygons where the nearest neighbor of any point inside a polygon is the generator of the polygon. The VD for n objects on a plane can be constructed at O ( n log n ) complexity using a simple sweep algorithm. The general definition of the Voronoi Cell(VC) of a point in the d-dimensional space d follows: Theorem 2.2.1: If n is a d-dimensional point, N is a set of n points in the d-dimensional space d ,then V ( p ), the VC of the point n given set N , is defined as the unique convex polygon which contains all the points in the set V ( p ): In this section, we first introduce the broadcast-based LDIS scheme(BBS) [8]. Then, we describe the VD-based Energy Efficient Selective Tuning method. Fi-nally we present adjacency data prefetching and caching methods in a way with the aim of reducing the client X  X  a ccess time and energy consumption. 3.1 Broadcast Sequence for NN Search In a recent paper [8], we have proposed the c oncept of data sorti ng for broadcast-ing called BBS(Broadcast-based Locati on Dependent Data Delivery Scheme). In the BBS method, the server periodically broadcasts the IDs and coordinates of the data objects, without an index segment, to the clients, and these broad-casted data objects are sort ed sequentially, according to the location of the data objects, before being sent to the clients. The BBS provides the fastest access time, since no index is broadcasted along with the data and thus, the size of the entire broadcast cycle is minimized. A preliminary simulation-based results showed that BBS is significantly reduce the AT.
 mensional coordinates in two different ways: i.e. horizontal broadcasting(HB) or vertical broadcasting(VB). In HB, the server broadcasts the LDD(location dependent data) in horizontal order, that is, from the leftmost coordinate to the rightmost coordinate. On the other hand, in VB, the server broadcasts the LDD in vertical order, that is, from the bottom coordinate to the top coordi-nate. In this paper, we assume that the server broadcasts the data objects using HB.
 Definitions of Symbols and Parameters:  X  S : Server data set  X  T i : boundary lines of the current broadcast data object  X  T :setof T i  X  O i : broadcast data object, where O i  X  S  X  O candi : candidate for the nearest data object  X  O c : current broadcast data object(initially O c regarded as NN),  X  O ps : one of the data items broadcast before O c in the current broadcast  X  O p : a data item broadcast just before O c in the current broadcast cycle,  X  O FP : data object of FP  X  O f : the client X  X  first tuned data item in the broadcast channel  X  Data first: the server X  X  first broadcast data item in the current broadcast  X  TN : nearest boundary line on the left-hand side of the q, e.g., T5 in Figure 1  X  ON : data object of TN , e.g., O 16 in Figure 1  X  TS : safe nearest boundary line on the left-hand side of the q, where x- X  TS candi : candidate of TS 3.2 VD-Based Energy Efficient Selective Tuning BBS scheme[8] can significantly reduce the average access time, since it elim-inate the probe wait time for the clients. However, tuning time may increase, since the client has to tune the broadcast channel until the desire data item is arrived.
 ment namely, VD-based Selective Tuning(VST) method. The VCs can be used to find out NN. The present scheme provides the ability to selective tune the clients and therefore helps reduce the client X  X  tuning time.
 VD-Based Selective Tuning(VST). In this section, we present a selective tuning method for use in the BBS environment. In this method, the client uses exponential pointers from each data item for the purpose of reducing energy consumption. Each data item contains the following information:  X  It X  X  ID and VE(Voronoi Edge: vertex pointers)  X  Initial Pointer: arrival time of the first broadcast data item for the next  X  Forward Pointer(FP): IDs, it X  X  VE and arrival times of the data items that data obtained at the broadcast channel. Then, it checks the VE of the cur-rent data item and FP in order to find out the object that contains query point q within the VC. If there is no data object that contains query point q within the cell, then it switches to doze mode until the desired data item appears on the broadcast channel. The client repeatedly switches between the doze and wake up modes until it retrieves the NN.
 broadcast channel at T1 and obtains the following FP: ID= { 2,4,8,16,32 } ,their arrival times and VEs from data item O 1. Then the client checks the VEs of each date object O 1, O 2, O 4, O 8, O 16 and O 32 in order to find out the VC that contains query point q. The client switches to doze mode, since VC of data object O 1, O 2, O 4, O 8, O 16 and O 32 does not contains query point q. The client sleeps until O 16(at T5) has appeared on the broadcast channel, since T5 is the nearest boundary line on the left-hand side of the query point q up to the present time. Then, the client wakes up at T5, and obtains FP ID= { 17,19,23,31 } from data item O 16, and checks the VC of each date object O 17, O 19, O 23 and O 31. The client switches to doze mode, since VC of data object O 17, O 19, O 23 and O 31 does not contains query point q. Thus, the client again switches to doze mode until O 23(at T4 X ) has appeared on the broadcast channel, since T4 X  is the nearest boundary line on the left-hand side of the query point q up to the present time. Then, the client wakes up at T4 X  and obtains FP ID=24, 26, 30 from data item O 23, and checks the VC of each date object O 24, O 26 and O 30. Finally, the client returns data item O 26 as the NN, since VC of the data object O 26 contains the query point q.
 Theorem 3.2.1: While the data objects are sequ entially broadcasted in hor-izontal order, from the leftmost coordinate to the rightmost coordinate, if x-coordinate of O f &gt; x-coordinate of q, then the client cannot guarantee that it dose not miss NN in the current broadcast cycle. Theorem 3.2.2: To guarantee that the client does not miss the NN, the dist(x-coordinate of TS, x-coordinate of q) must be longer than dist(ON, q). 3.3 Adjacency Data Caching(ADC) In this method, the client prefetches th e data objects that are adjacently located in the map for future use.
 Moreover, since the broadca sted data objects are sorted sequentially according to the location of the data objects, clie nts can prefetch adjacent located data objects. Let w p denote the size of prefetched data objects. Prefetching can be cat-egorized into pre-fetch and post-fetch, w here pre-fetch represents fetching data objects before NN data item is broadcast while post-fetch represents fetching data objects after the NN data object is broadcasted respect ively. The value of pre-fetch and post-fetch represents th e number of data items to be prefetched. The client adjusts the size of w p according to the client X  X  moving direction, speed or the cache size. It should be noted that prefetching does not necessarily re-quire continuous active monitoring of the broadcast channel to determine what the next arriving data object is, if the client knows in advance the broadcast schedule. Cached data items contain the information of the object X  X  ID and it X  X  VE. Let us consider the case where the s erver broadcasts data items using the BBS and the client detects the nearest data object from the query point q as O 26. Let the value of the pre-fetch be 2 and post-fetch be 3 on the basis of the NN. In this case, the client wakes up at T4 X  and prefetch data objects as the fol-lowing sequential order:= { O 24, O 25, O 26, O 27, O 28, O 29 } ,asshowninFigure 2. The client cached the data object from O 24 to O 29 while it located at Voronoi Cell ID(CID) 4. Then, the client moves from CID 4 to CID 3(see Figure 2). The client checks the prefetched data items in CID 3 instead of tuning the broadcast channel again and returns O 25 as newly nearest data object, if it receives the same query.
 Definition 3.3.1: x-coordinate of pre-fetch  X  x-coordinate of NN  X  x-coordinate of post-fetch.
 in ADC, in this case, AT and TT may significantly increase, since the client has to repeatedly switch between the doze and wake up modes until it obtains the desired data items.
 set of data items in the cache. The following summarizes the steps taken by the client to process the NN search: Step 1: When a query is issued by a mobile client, it first checks the V ( O c x ), go to step 3.
 Step 2: If V ( O c x ) contains the query point q, the data item is retrieved locally. Go to step 5.
 Step 3: If V ( O c x ) does not contain the query point q, the client starts tune the broadcast channel in order to process the NN query.
 Step 4: The client switches to doze and wake up mode until NN has appeared on the broadcast channel. Obtain the NN through the broadcast channel. Step 5: A result is returned to the client. In this section, we evaluate the performance with various kinds of parameters settings such as the client X  X  speed, the si ze of the service area, and the distri-butions of the data items. In section 4.1, we analyze the proposed approaches. Then, we present performance results of simulation experiments in section 4.2. 4.1 Analytic Evaluation Access Time. In this section, we compare t he access time of the BBS with (1,m) index. The following shows comparison of the Probe Wait and the Bcast Wait between BBS and previous index method [4,2]. Let AAT be the average access time, m be the number of times broadcast indices, N be the number of data items and C be the average number of buckets containing records with the same attribute value:  X  Previous index method: 1 2  X  ( index + N m )  X  BBS method: None  X  Previous index method: 1 2  X  (( m  X  index )+ N )+ C  X  BBS method: 1 2  X  N + C Since the AT is the sum of the Probe Wait and the Bcast Wait , average AT for: Previous Index Method Is: BBS is: Tuning Time. In this section, we evaluate the tuning time for the proposed schemes with (1, m) index. The probability distribution of the initial probe of clients is assumed to be uniform within a broadcast and data items of the same size.
 multileveled index tree. The ATT for (1,m) index is: The ATT of BBS is as follows: of levels in the index tree for BBS and P denote the probability: P { containing the desired data object among the index } is 1 P { obtaining the desired data object } is 1 reading data objects + P { failure obtaining the desired data object after read the index } X  cost of obtain the desire data object after read the index, and thus, Finally, we evaluate the ATT for VST. Let N be the number of data items, e be the exponent value and AT T VST be the average tuning time for VST. The minimum number of steps is 1 and the maximum number of steps is k-1, where k= log e N . For example, if N=1024 and e =2, then in the best case, the client obtains the desired data item within a single step while, in the worst case, the client obtains the desired data item within 9 steps. The frequency of the worst case for N is 1, while the frequency of the best case for N is k.
 4.2 Experimental Evaluation This section presents the numerical results obtained through analysis and sim-ulation. For fairness, we use a single dedicated machine. The machine is a PC with a Pentium III 800 MHz, 512 MB, a nd running on Windo ws 2000. We imple-mented the system in Java and run it under the JVM version 1.3.0. We evaluated two different parameters: energy cons umption and access time. We assume that the broadcast data objects are static, such as restaurants, hospitals, and hotels. We use a system model similar to that described in [5,6]. The whole geometric service area is divided into groups of MSSs (Mobile Supporting Stations). In this paper, two datasets are used in the experiments. The first data set D 1contains data objects randomly distributed in a square Euclidian space, while the second data set D 2 contains the data objects of hospitals in the Southern California area, and is extracted from the data set at [7]. In this experiment, we assume that the client X  X  mobility pattern follows Random Waypoint Mobility Model [12]. Access Time. In this section, we evaluate the A ccess Latency for various para-meter settings. Figure 3(a),3(b) and 3( c) show the results of the access latency as the number. of clients, size of data and the frequency of data increases in D 1 respectively. number of clients and the size of data increases in D 2 respectively. Cache Hits. This section evaluates the cache hit ratio for various parameters settings such as the size of the cache, the client X  X  speed and the number of clients. First, we vary the size of the cache from 3072 to 11264 bytes. In this experiment, we assume that all data items are of the same size, for example 1024bytes. Figure 5(a) shows the result of the number of cache hits as the size of the cache is increased. As shown in the figure, ADC(Adjacency Data Caching) outperforms (1,m) index method, since the ADC caches the sequentially ordered data items according to their locations, whereas the (1, m) index method caches the irregularly ordered data items. Evid ently, in the (1, m) index method, the average access time may significantly incr ease if the client is a ttempting to cache the data items with the sequential order, since the broadcast data items are not ordered based on their locations. Second, we vary the client X  X  speed from 10 to 100 in D 1. As shown in Figure 5(b), the number of cache hits decreases as the client X  X  speed increases. Third, we vary the number of clients from 10 to 50 in D 1. As shown in Figures 5(b) and 5(c), ADC outperforms the (1,m) index method for the same reason shown above. We have explored the different broadcasting and tuning methods, which can be used for NN query processing. For the purpose of broadcasting in LDISs, we present the BBS and for the purpose of selective tuning with the BBS, we present the VST method. The BBS method attempts to reduce the Access Latency and the VST method attempts to conserve battery power consumption. With the proposed schemes, the client can perfo rm NN query processing without having to tune an index segment. We also present the proposed schemes as investigated in relation to various environmental variables. The experimental results show that the proposed BBS scheme significa ntly reduces access latency, since the client does not always have to wait for the index segment. The resulting latency and tuning time is close to the optimum as our analyses and simulation results indicate. In a future study, we plan to inv estigate the cache replacement scheme.
