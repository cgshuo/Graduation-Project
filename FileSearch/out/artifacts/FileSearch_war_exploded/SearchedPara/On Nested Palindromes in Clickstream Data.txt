 In this paper we discuss an interesting and useful property of clickstream data. Often a visit includes repeated views of the same page. We show that in three real datasets, sampled from the websites of technology and consulting groups and a news broadcaster, page repetitions occur for the majority as a very specific structure, namely in the form of nested palin-dromes. This can be explained by the widespread use of fea-tures which are available in any web browser: the  X  X efresh X  and  X  X ack X  buttons. Among the types of patterns which can be mined from sequence data, many either stumble if symbol repetitions are involved, or else fail to capture inter-esting aspects related to symbol repetitions. In an attempt to remedy this, we characterize the palindromic structures, and discuss possible ways of making use of them. One way is to pre-process the sequence data by explicitly inserting these structures, in order to obtain a richer output from conven-tional mining algorithms. Another application we discuss is to use the information directly, in order to analyze certain aspects of the website under study. We also provide the simple linear-time algorithm which we developed to identify and extract the structures from our data.
 H.2.8 [ Database Management ]: Database Applications X  Data Mining ; E.m [ Data ]: Miscellaneous Algorithms, Measurement palindrome, web usage mining, backtrack, refresh
The motivation of this research was to discover patterns in clickstream data. In this Section, we first give an insight into what clickstream data are, and how they can be obtained. We then briefly discuss some of the relevant patterns which were studied in data mining literature, and describe their difficulties in dealing with the specific structural property of palindromicity.

In Section 2 we describe why nested palindromes can be anticipated with normal web-browsing behavior, and pro-vide a simple algorithm which extracts these structures in linear time (proof of correctness is provided in the appendix). In Section 3 we briefly describe the clickstream datasets studied, and show how the methods can be used for finer analysis. Finally, conclusions are given in Section 4.
A clickstream, or visit, is defined as a sequence of URLs visited from a single device (and presumably by a single individual) within a single session. The notion of visit is necessarily arbitrary, since it corresponds to some form of contiguity in time; the scale of this contiguity is then a re-quired parameter. In standard practice, if two consecutive web server log entries belonging to the same user are sep-arated by a time lapse greater than 30 minutes, they are considered to belong to two distinct visits. A visits database can be obtained by transforming web server logs through a process called sessionization (see e.g. [5, 15]). Nowadays many tools exist to feed such databases in an ongoing man-ner, by incorporating active elements in the pages of the website, which is usually referred to as page tagging.
Since a visit can be seen as a sequence of pages, we can apply a host of data-mining techniques designed for sequence data, namely frequent pattern mining. For an overview see e.g. [13, 24]. In line with the usual vocabulary, given a pattern and a collection of sequences, we say that a sequence supports a pattern if the pattern occurs in the sequence. We call the number of sequences in the collection which support the pattern the support of the pattern. Furthermore, we say that a pattern is frequent if its support is at least min sup ( a user-defined threshold), and a pattern is closed if it has no superpattern of equal support.

Two basic patterns which can be mined from a database of sequences are  X  X requent subsets X  and  X  X ssociation rules X  [1, 18], both of which capture sets of symbols which frequently co-occur in the database. Classic Apriori type algorithms readily provide these [1]. Another well-studied pattern is the  X  X equential pattern X  [2, 23, 20] which, in its simplest form, is a frequent (not necessarily contiguous) subsequence of maximal length. Among others, an efficient algorithm called PrefixSpan was proposed to extract such patterns [20]. The partial order pattern (partially ordered set, also called p oset) was also studied [17, 4, 21]. It occurs in a sequence if all symbols of the poset are present, and they occur in an order which is compatible with the partial order defined by the poset. More general graph patterns can also be mined. For instance, one can extract from a set of graphs all frequent common subgraphs [8].

Each of these pattern types runs into some problems in capturing aspects of clickstream data which we hold to be important. The frequent subset discards ordering informa-tion, which we deem to be essential for the purpose at hand, since our objective is to study traffic flow, which intuitively includes the notion of direction. The sequential pattern is thus a closer fit, but it has a drawback in that it treats a symbol repetition in a rather neutral manner  X  essentially as just another symbol. The strength drawn from disregarding the contiguity of symbols can turn into a weakness for click-streams, as we shall see. Symbol repetitions are downright problematic for partial orders, and indeed one of the hy-potheses of the Frecpo [21] algorithm is that the sequences in the database are repetition-free. A similar problem af-fects the subgraph pattern; in the general case, for sequences containing symbol repetitions (which translate to cycles in graph representations), chronological precedence is ambigu-ous. Thus, it seems that none of these patterns is ideally suited to describe data in which repetitions carry a partic-ular importance, as in our clickstream data which will be described in Section 2.1. We will now argue why this is to be expected, and what shape these repetitions take on.
Loosely speaking, a palindrome is a word which is the same whether it is read from left to right or from right to left, such as level or redder . It is a sequence with a central symmetry. Palindromes have been the subject of countless human expressions and inquiries since ancient Greece, at-tracting artistic and mathematical curiosity. Palindromes are investigated in biology; DNA segments often contain palindromic structures which are thought to have certain functional implications, like self-repair. Properties of palin-dromicity have also been investigated in proteins [11]. As far as computer science is concerned, palindromes are a classic example of an important language type in the Chomsky hi-erarchy [6]. The set of all palindromes on a given alphabet of symbols is context-free but not regular  X  no finite state machine can accept the language; at least a pushdown au-tomaton is required.

We argue that palindromes are relevant to web usage min-ing, and we make this case both by arguing in terms of ex-pected outcome of standard behavior, as well as by showing the patterns observed in real datasets. Imagine the follow-ing browsing experience. Catherine knows that the com-pany Pumpkin Umbrellas will launch its new product line today, and lands on the website by typing the URL pumpkin-umbrellas.com into her browser. When the page is dis-played, an announcement about membership with Pumpkin Umbrellas catches her eye, but she clicks on the  X  X ress re-leases X  link instead, to find that the information she was expecting has not been published yet. She gets out of her chair to get a cup of coffee, comes back ten minutes later and hits the  X  X efresh X  button on her browser. Now the news item is displayed; she clicks on the link to see the press release. When she is done reading it, she hits the  X  X ack X  button twice, and clicks on the membership promotion link she had seen earlier. However, membership looks too com-plicated, so she grows disinterested and walks away from her computer.

Stripping away the narrative, we are left with the se-quence of pages through which the user navigated: Main, Press Releases, Press Releases, Product Launch, Press Re-leases, Main, Membership. We can encode this as the sym-bol sequence ABBCBAD , and visualize it as the graph in Figure 1; each node represents a symbol, and the arcs are labelled in chronological order of the symbols X  appearance in the sequence. A page refresh always translates into a re-flexive arc (e.g. B  X  B ), and a backtrack always translates into a pair of opposite arcs (e.g. { A  X  B , B  X  A } ).
Looking at the sequence ABBCBAD , we notice that there are three repetitions in this sequence; the symbol B is re-peated twice and the symbol A is repeated once. We also see two contiguous subsequences which are palindromes, BB and BCB , corresponding to the page refresh and to the first backtrack, respectively. They overlap on their outermost symbol B . Next, we make the less obvious observation that ABBCBA is  X  X lmost X  a palindrome  X  it would be a palin-drome if BB were replaced by a single B . Finally, notice that if we take the sequence ABBCBAD and iteratively re-place the first-ending palindrome by its outermost symbol, the resulting sequence AD does not contain any repetitions (see Table 1 for the steps). In other words, the repetitions in this sequence are all accounted for by short palindromes. These intuitions form the basis of our approach. Table 1: Successively replacing the first-ending palindrome t ransforms the sequence ABBCBAD into the sequence AD , which contains no repetitions.

Many efficient (linear time) algorithms exist to extract different kinds of palindromes from sequences, e.g. maxi-mal palindromes, palindromes with gaps, etc (see e.g. [14, 12]). However, we are not aware of an algorithm which per-forms the process we describe above. It is captured formally in the algorithm extract-pals , listed as Algorithm 1. For a proof of correctness, please see the appendix. The algorithm transforms the graph in a straightforward way. It iteratively F igure 2: Successive removals of the first-ending palindrome in ABCCBDBBA reduce the sequence to a single symbol. Input : A sequence s Output : The list (refreshes, backtracks, leftover) R = empty set B = empty set
T = empty stack for i = 1 to length ( s ) do end return ( R, B, T ) removes the first (and earliest in a chronological sense) of the following:
The complexity of the algorithm is linear in the sum of the lengths of the sequences in the database. The process is illustrated for the more complex sequence ABCCBDBBA ; the successive steps are shown in Table 2 and represented graphically in Figure 2. Notice that here again, all repeti-tions are accounted for by palindromes.

This need of course not be the case for every sequence, for instance the sequence ABCA , shown in Figure 3, con-tains a repetition but no palindromes. If a sequence contains at least one repetition which is not accounted for by palin-dromes, we will call it unaccounted . Otherwise we will say that the sequence is accounted . In the next section, we will show that in our datasets, unaccounted sequences are a mi-nority.
W e now turn to real data, to show that palindromes are indeed a characteristic feature of clickstreams. We analyze three different datasets, the two first of which we will call Blue and Orange for anonymity purposes. The datasets are collections of visits to the websites of two distinct groups of a large technology and consulting company, from the year 2011, collected by a page tagging solution. The third dataset is a database of visits to msnbc.com on September 28, 1999, gathered from an IIS log, which we obtained from the UCI Machine Learning Repository [10]. It differs from the first two datasets in that the level of granularity is coarser; while Blue and Orange consist of sequences of URLs, a visit in the MSNBC dataset is given as a sequence of news categories. For example, if a user read an article about French politics, another on the tour de France, an opinion piece about doping in cycling, a second tour de France article, and finally the weather forecast, the corresponding visit was recorded as  X  X rontpage, sports, opinion, sports, weather X . In this study, over about 1 . 8  X  10 3 pages, 8 . 8  X  10 3 pages, and seventeen cate-gories, respectively (see Table 3 for a summary). Most visits are made up of very few pageviews, but a small percent-age range into a length of several hundreds. Our goal is to study human behavior, and most likely very long visits were made by crawlers or similar programs. For this reason, and also to make the presentation of results easier, we remove from the databases all visits with length above 20 pageviews, since they correspond to a low proportion of 0.16%, 0.53% and 2.8% of the visits, respectively. The visit length dis-tributions are shown as log-log plots in Figure 4. The first two datasets look quite regular in this respect, and visually they seem to be approximately Zipf distributed, although goodness-of-fit tests such as the Kolmogorov-Smirnoff test (cf. [7]) fail quite unequivocally. The MSNBC visits are a bit less regular in their length distribution, however clearly all datasets share the characteristic that visit lengths are rather heavy-tailed.

Applying our extraction algorithm, we obtain for each sequence the set of refreshes and the set of backtracks it contains, as well as the  X  X eftover X  sequence  X  the sequence that remains after all palindromes have been compressed. Notice that a sequence is unaccounted if and only if the leftover sequence contains at least one repetition. We find that the proportion of unaccounted sequences is as low as 0.86%, 1.6% and 5.4%, respectively. Of course, to be fair, it should be said that the shortest sequence which can be However, even if we consider only the sequences which both contain repetitions and are of length  X  4, the proportion of unaccounted sequences remains low; the values are then 14%, 18% and 8.3%. refreshes will be over-estimated, since any intra-category transition will look like a refresh. Likewise, the backtracks will be both under-estimated (for the same reason) and over-estimated because  X  X kiing, Banking crisis, Basketball X , will turn into  X  X ports, finance, sports X  and be interpreted as a backtrack. It should also be noted that this log-based dataset is likely more susceptible to caching effects. counted.

In order to get a more complete picture of this character-istic in our datasets, in Figure 5 we categorize visits by the number of refreshes and backtracks they contain. The blobs are sized according to the number of visits in the category, and the black spokes indicate the proportion of accounted sequences in each category  X  a vertical spoke means that the proportion is 1, while a horizontal spoke means that the proportion is 0. As can be seen, the proportion is large in most categories. For instance, in the Blue dataset, among the visits containing 3 page refreshes and 4 backtracks (i.e. 7 repetitions explained by palindromes) virtually none con-tain a repetition of another form. On the whole, in our data, it seems that palindromes account for the lion X  X  share of repetitions all around.

Taking a slightly different approach, if we look at counts of non-palindromic repetitions (as opposed to counts of vis-its containing non-palindromic repetitions ), we find that out of all repetitions, those explained by palindromes make up 95%, 92% and 96% of the respective datasets. The  X  X alin-dromicity X  X hroughout our data is thus confirmed from quite a few different angles. The strength of the presence of this property, and the independence of the datasets, together suggest that the same structure may be found in other click-stream databases as well.
Being confident in the strong presence of palindromes in our datasets, we can now turn to discussing possible ways of making use of it. We identify at least two simple appli-cations of the presented material. Firstly, it can be used in a pre-processing step to ensure richer output of existing algorithms. Secondly, we sketch how one can make a direct use of the extracted features in order to analyze navigational properties of a website.
Recall the sequence ABBCBAD studied above, which contains one refresh and two backtracks. This sequence is easily transformed to AB X BC Y B Z AD , where we have in-serted the new symbols X , Y and Z to specifically mark the places where the behaviors of interest occur; for instance, Y stands for  X  X acktrack from C to B  X . The set of sequen-tial patterns obtained from such a transformed dataset will be strictly richer than the set obtained from the original dataset; no information is lost, however the extra informa-tion can be put to good use. For instance, imagine the pattern ABCY B is found to be frequent. Obviously, if we had run the algorithm on the original sequences, the pat-tern ABCB would have been reported as frequent. How-ever, ABCY B contains more information, because it tells us that a backtrack from C to B occurs, whereas ABCB could correspond to backtracks as well as sequences like ABCDEB . Thus, rather than reporting ABCB we can report e.g. A \ BCB .

The same concept holds for the partial order pattern. In order to quantify the  X  X nrichment X  of the result set, we run the Frecpo algorithm on the three pre-processed datasets, setting the support thresholds so as to obtain a few hundred frequent patterns, and observe how many of them contain at least one of the added symbols. The proportions are quite high: 193/418 (46%), 313/339 (92%) and 317/437 (73%). This means that in our data, refreshes and backtracks are not only frequent as a general feature, but furthermore, spe-proportion of sequences of that length, and the cumulative proportion. horizontal means 0). statistic Blue Orange MSNBC sample size 3 . 1  X  1 0 5 3 . 2  X  1 0 5 9 . 9  X  1 0 5 distinct items 1822 8822 17 visits over length 20 (removed) 0.16% 0.53% 2.8% unaccounted visits among all visits 0.86% 1.6% 5.4% proportion of palindromic repetitions 95% 92% 96% c ific instances are also frequent, and part of larger frequent browsing patterns. For an example of how to graphically in-corporate the additional information in a partial order pat-tern, see Figure 6.

One caveat which should be mentioned about our proce-dure of enriching sequences is that it may result in aggra-vating the redundancy in the result set, which is a much-reported problem in frequent pattern mining. Fortunately a lot of excellent research is being done to manage this redun-dancy (see e.g. [3, 16]).
Surely the tendencies of a page to be refreshed, or back-tracked from, or backtracked to, are features of direct inter-est for anyone who aims to understand the dynamics of a website. In order to achieve these insights, we extract the palindromic patterns previously discussed. Here we opt for finding the support of the palindromes, rather than the oc-currence count. This means that if a given backtrack ( B, A ) occurs n  X  1 times during a single visit, we count 1 rather than n . This approach is popular in data mining, and from a statistical robustness viewpoint a good choice. Indeed, the breakdown point 3 of the occurrence count is 1 /N (where N is the number of sequences) since a single  X  X ad X  sequence with a large number of occurrences can perturb the statistic by an arbitrary amount. By contrast, the support statis-tic has no breakdown point, because it is always contained in the interval [0 , N ]; any observation can only perturb the statistic by 1 /N .

We provide an adaptation of Algorithm 1 to extract the support of all refreshes and backtracks from a visits database. It is called sup-pals and listed as Algorithm 2. Notice that unlike in the case of frequent pattern algorithms, no thresh-old parameter is required as input. The support sup re ( x ) equals the number of visits in which at least one refresh of x occurs, while supports sup bf ( x ) and sup bt ( x ) equal the number of visits containing at least one backtrack from and to x , respectively. Using these supports, we can now derive some quite informative metrics about web pages.

One straight-forward such metric is the refresh rate REF ( x ) of page x , defined as which is contained between 0 and 1. Depending on the in-tended function of a page x within a website, different values of REF ( x ) may be desirable. For example, if an active news-feed page has a high refresh rate, this can be taken as a good sign, since the implication is that many of the visitors are eager for more news items. If however a static page has a high refresh rate, it may indicate that the page often dis-plays poorly in users X  browsers for some reason, and should be checked by a webmaster for possible malfunction. It also bears mentioning that some pages reload automatically by design , which then needs to be kept in mind when analyzing the results. We further define the cul-de-sac rate CDS ( x ) of page x as which is also contained between 0 and 1. This metric re-flects the tendency of the page X  X  visitors to return to an earlier page. Here again, different values may be desirable depending on the context. A help page, for instance, will hopefully have a high CDS , indicating that visitors returned sample proportion of contaminated observations needed to change the value of a statistic by an arbitrarily large amount [9]. For a survey of the field of robust statistics see [19]. Input : A sequence database S
Output : The supports sup re , sup bf and sup bt . foreach sequence s  X  S do end return ( sup re , sup bf , sup bt ) to the website, presumably because they found the help they needed on the help page. Conversely, if an  X  X ndex X  page de-signed to act as a hub has a high CDS , the page may need a redesign. Similarly, let us define the pivot rate P IV ( x ) of a page as which again falls into the interval [0 , 1]. This metric indi-cates the tendency of visitors to return to the page, possibly in order to proceed elsewhere. An  X  X ndex X  page should prob-ably have a relatively high P IV , whereas if a page in the checkout/ordering workflow of an online retailer has high P IV , it is probably indicative of a malfunction or of a prob-lem in the web design. If for some page x , both CDS ( x ) and P IV ( x ) are high, i.e. visitors backtrack both from and to that page a lot, it could be indicative of some kind of  X  X orri-dor X  which visitors need to follow in order to get from A to B. Perhaps a direct link would be more convenient; it is also worthwhile to investigate whether x should be merged with a page people frequently backtrack to (from x ), in order to spare visitors a click.

While it may be difficult to decide which absolute values are desirable, one can turn to a comparative analysis; are there outliers? Do the pages look like they are in their proper place in the distribution? Note that if additionally to the page sequences, we also had access to the time at which each click was made, we could incorporate this information to allow for a more precise interpretation  X  if a page refresh occurs after several minutes spent on the page, it is arguably a better sign than if it occurs shortly after the preceding view of the page.

Combined outlier analysis can also be of interest for di-agnostics purposes. For instance, a plot of P IV vs CDS in Figure 7 simultaneously shows both tendencies of backtrack-ing from and to a page. Here we plot only the top 200 pages (in terms of support) of the sites Blue and Orange. We can notice that in the Blue dataset, there are quite many low-PIV, high-CDS pages  X  31 points in the delimited region, versus 9 in the same region in the Orange dataset. On the other hand, there are quite many high-PIV, high-CDS pages in the Orange dataset  X  50 pages in the region vs 15 in the same region in the Blue dataset. Accordingly, the owner of the Blue website may wish to examine all those  X  X ead ends X , while the owner of the Orange website might want to investigate why it has so many  X  X orridors X .
We have illustrated that nested palindromes are strongly present in clickstream data; we first argued that standard browsing behavior generates clickstreams containing such structures. A simple stack-based algorithm was derived to extract such patterns (in linear time), and used to confirm the presence of palindromicity in three independent datasets of real data. We showed how sequence data can be pre-processed by insert new symbols which explicitly mark the phenomena in question, and illustrated ways in which the resulting patterns become richer. Furthermore, we showed examples of metrics which can be derived from the results, and how those can be interpreted. Such information is help-ful to people in charge of designing and/or analyzing the usage of the website. In particular, it can be used to detect whether a page is failing in its intended function.
Our considerations in this work are limited to X  X irst-order X  palindromes, for instance for the sequence ABCBA we pro-duce backtracks ( C, B ) and ( B, A ). In some applications it may be of interest to know that there was an uninter-rupted return from C to A , which would require extracting ( C, B, A ) or something similar.

In future work, we intend to use the discovered features to produce more accurate generative models which could improve the results of approaches such as we described e.g. in [22]. We are also in the process of developing website optimizations utilizing these results, and of validating the practical use of the findings with the websites X  stakeholders.
Our approach was studied with web navigation in mind, but could in principle be useful in analyzing data arising from other processes with a similar structure. In particular, studies of navigation of all kinds could benefit, for instance, if the dataset consists in descriptions of daily itineraries, such as sequences of stations/stops in a public transporta-tion network, or of areas in a roads network traversed by car. [ 1] R. Agrawal and R. Srikant. Fast algorithms for mining [2] R. Agrawal and R. Srikant. Mining sequential [3] T. Calders and B. Goethals. Mining all non-derivable [4] G. Casas-Garriga. Summarizing sequential data with [5] S. Chakrabarti. Mining the Web: Discovering [6] N. Chomsky. Three models for the description of [7] A. Clauset, C. R. Shalizi, and M. E. J. Newman. [8] D. J. Cook and L. B. Holder. Mining Graph Data . [9] A. Davison. Statistical Models . Cambridge University [10] A. Frank and A. Asuncion. UCI machine learning [11] M. Giel-Pietraszuk, M. Hoffmann, S. Dolecka, [12] D. Gusfield. Algorithms on strings, trees, and [13] J. Han, H. Cheng, D. Xin, and X. Yan. Frequent [14] R. Kolpakov and G. Kucherov. Searching for gapped [15] B. Liu. Web Data Mining: Exploring Hyperlinks, [16] M. Mampaey, N. Tatti, and J. Vreeken. Tell me what i [17] H. Mannila and C. Meek. Global partial orders from [18] H. Mannila, H. Toivonen, and I. Verkamo. Efficient [19] S. Morgenthaler. A survey of robust statistics. [20] J. Pei, J. Han, B. Mortazavi-Asl, J. Wang, H. Pinto, [21] J. Pei, H. Wang, J. Liu, K. Wang, J. Wang, and P. S. [22] M. Speiser, G. Antonini, and A. Labbi. Ranking [23] X. Yan, J. Han, and R. Afshar. Clospan: Mining [24] M. Zaki, N. Parimi, N. De, F. Gao, B. Phoophakdee,
If s is a sequence, then given integers i  X  j we denote by s [ i : j ] the contiguous subsequence of s from position i to position j . A subsequence s [ i : i ] of length 1 can also be written as s [ i ], and s [ i : j ] with i &gt; j is interpreted as the empty sequence. We denote by  X  ( s ) the reversed sequence (the symbols in reverse order), and we say that s is a palin-drome if it has length &gt; 1 and s =  X  ( s ). If s 1 , s sequences, we denote by s 1 s 2 ...s n the sequence obtained by their concatenation. Now, for a sequence s , let
If such an  X  exists, then  X  is unique, that is, s [  X  :  X  ] is the unique first-ending palindrome of s . Indeed, suppose that  X  is not unique, i.e. that the statement holds for two different values  X  1 &lt;  X  2 . Since we have s [  X  1 :  X  ] =  X  ( s [  X  s [  X  2 :  X  ] =  X  ( s [  X  2 :  X  ]) it follows that s [  X  1  X  ( s [  X  1 :  X  1 +  X   X   X  2 ]), i.e. there is a palindrome ending at  X  +  X   X   X  2 &lt;  X  , which contradicts the definition of  X  . This means that we can unambiguously define the function CF P as follows. If  X  and  X  of equation (4) exist, otherwise,
In words, CF P , which stands for Compress First Palin-drome, is a function which takes as input a sequence s , and returns a sequence identical to s , except that the first-ending palindrome in s (if it exists) is replaced by its outermost symbol  X  we say that the palindrome is compressed . Table 2 shows a few examples of CF P preimages and images.
Notice that we know the lengths of palindromes com-pressed by CF P : if a sequence s contains a palindrome, the first-ending palindrome is of length 2 or 3. Indeed, suppose that s h as a first-ending palindrome of length  X  &gt; 3. Let  X  be the starting index of the palindrome, and  X  =  X  +  X   X  1 its end index. Since s [  X  :  X  ] is a palindrome, then so is s [  X  + 1 :  X   X  1], which has a length  X   X  2 &gt; 1. But then, there is a palindrome ending at  X   X  1, i.e. before  X  , which contradicts the hypothesis. As a consequence, CF P ( s ) ei-ther leaves the sequence s unchanged, or compresses a palin-drome of length 2 or 3. This is fortunate, because in terms of browsing behavior, CF P compresses either a page re-fresh (palindrome of length 2) or a backtrack (palindrome of length 3), which are precisely the features of interest to us. Denote by CF P  X  ( s ) the fixed point of CF P reached by successive applications of CF P to s , i.e.

This fixed point exists for any sequence s of finite, pos-itive length; the image is either identical to the preimage or shorter than the preimage, and any sequence of length 1 is obviously a fixed point, so a fixed point is reached in a finite number of iterations. As an example, for the sequence s = ABCCBDBBA , Table 2 tells us that CF P  X  ( s ) = A . We now turn our attention to exploiting this structural prop-erty in order to mine features of interest. As a first step, an algorithm which computes CF P  X  is listed as Algorithm 3. The algorithm X  X  complexity is linear in the length of the sequence.
 Input : A sequence s Output : The sequence CF P  X  ( s )
T = empty stack for i = 1 to length ( s ) do end return T
Theorem 1. Given a sequence s , the algorithm rm-pals computes CF P  X  ( s ) .

We will prove a few intermediate steps first. During the execution of rm-pals(s) , we call the pair ( T, s [ i : length ( s )]) observed immediately after i is modified the state at i . We say that a loop iteration is called trivial if it is of type #1; otherwise, it is called non-trivial .

Lemma 1. The execution rm-pals(s) contains only type #1 iterations until iteration  X  , where  X  is the end index of the first-ending palindrome of s .

Proof. Observe that while no non-trivial iteration has occurred, T = s [1 : i  X  1]. Now, suppose a non-trivial it-eration first occurs before  X  , and consider the state for s before this iteration; we have that either T.top = s [ i ] or Table 4: Sequence of r m-pals states for the sequence ABCCBDBBA .
 T.undertop = s [ i ]. In the first case s [ i  X  1] = s [ i ], that is s [ i  X  1 : i ] =  X  ( s [ i  X  1 : i ]), and in the second case ther case, s contains a palindrome ending before  X  , which contradicts the hypothesis.

Corollary 1 . For an input s which contains no palin-dromes, rm-pals(s) terminates using only trivial loop itera-tions, and hence the algorithm returns s .

Lemma 2. If sequence s has a first-ending palindrome of length  X  , the first non-trivial loop iteration of rm-pals(s) is of type #  X  .

Proof. Observe that while only type #1 iterations have occurred, T = s [1 : i  X  1]. Hence if the first-ending palin-drome s [  X  :  X  ] is of length 2, at iteration  X  we have which results in type #2. Conversely, if s [  X  :  X  ] is of length 3, this becomes which results in type #3.

Lemma 3 . For an input sequence s with first-ending palin-drome s [  X  :  X  ] , the state after the first non-trivial iteration is ( s [1 :  X  ] , s [  X  + 1 : length ( s )]) .
 Proof. The first non-trivial loop iteration occurs at  X  . If the first-ending palindrome has length 2, we have a type #2 iteration and the stack remains unchanged from the last iteration, i.e. T = s [1 :  X   X  1]. If the palindrome has length 3, we have a type #3 iteration and the top element is popped from the stack, yielding T = s [1 :  X   X  2]. In both events, the resulting stack is T = s [1 :  X  ], and the remaining sequence is s [  X  + 1 : length ( s )].

Lemma 4 . For a sequence s with first-ending palindrome s [  X  :  X  ] , the execution rm-pals(CPF(s)) reaches the state ( s [1 :  X  ] , s [  X  + 1 : length ( s )]) using only trivial loops. Proof. First, notice that CF P ( s )[1 :  X  ] = s [1 :  X  ]. Since the right-hand side can not contain a palindrome, all loop iterations until  X  are of type #1. Finally, recall that CF P ( s ) = s [1 :  X  ] s [  X  + 1 : length ( s )].
Theorem 1, which states that the algorithm is correct, e asily follows from Corollary 1 and Lemmas 3 and 4.
