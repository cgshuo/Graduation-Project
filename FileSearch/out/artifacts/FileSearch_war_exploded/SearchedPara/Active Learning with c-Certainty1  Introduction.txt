 It is well known that the noise in labels det eriorates learning performance, espe-cially for active learning, as most active learning strategies often select examples with noise on many natural learning problems [1]. To rule out the negative effects of the noisy labels, querying multiple oracles has been proposed in active learn-ing [2,3,4]. This multiple-oracle strategy is reasonable and useful in improving label quality. For example, in paper reviewing, multiple reviewers (i.e., oracles or labelers) are requested to label a paper (as accepted, weak accepted, weak rejected or rejected), so that the final deci sion (i.e., label) can be more accurate.
However, there is still no way to guarantee the label quality in spite of the improvements obtained in pr evious works [3,4,5]. Furthermore, strong assump-tions, such as even distribution of noise [3], and example-independent (fixed) noise level [4], have been made. These assumptions, in the paper reviewing ex-ample mentioned above, imply that all the reviewers are at the same level of expertise and have the same probability in making mistakes.

Obviously, the assumptions may be too strong and not realistic, as it is ubiqui-tous that label quality (or noise-level) is example-dependent in real-world data. In the paper reviewing example, the quality of a label given by a reviewer should depend heavily on how close the reviewer X  X  research is to the topic of the paper. The closer it is, the higher quality the label has. Thus, it is necessary to study this learning problem further.

In this paper, we propose a novel active learning paradigm, under which or-acles are assumed to return both labels and confidences. This assumption is reasonable in real-life applications. Taking paper reviewing as an example again, usually a reviewer is required to give not only a label (accept, weak accept, weak reject or reject) for a paper, but also his confidence (high, medium or low) for the labeling.

Under the paradigm, we propose a new active learning strategy, called c-certainty learning . C-certainty learning guarantees the label quality to be equal to or higher than a threshold c ( c is the probability of correct labeling; see later) by querying oracles multiple times. In the paper reviewing example, with the labels and confidences given by reviewers (oracles), we can estimate the certainty of the label. If the certainty is too low (e.g., lower than a given c ), another reviewer has to be sought to review the paper to improve the label quality.

Furthermore, instead of assuming noise level to be example-independent in the previous works, we allow it to be example-dependent. We design an algorithm that is able to select the Best Multiple Oracles to query (called BMO )foreach given example. With BMO, fewer queries are required on average for a label to meet the threshold c compared to random s election of oracles. Thus, for a given query budget, BMO is expected to obtain more examples with labels of high quality due to the selection of best ora cles. As a result, more accurate models can be built.

We conduct extensive experiments on the UCI datasets by generating various types of oracles. The results show that our new algorithm BMO is robust, and performs well with the different types of oracles. The reason is that BMO can guarantee the label quality by querying oracles repeatedly and ensure the best oracles can be queried. As far as we know, this is the first work that proposes this new active learning paradigm.
 The rest of this paper is organized as follows. We review related works in Section 2. Section 3 introduces the lea rning paradigm and the calculation of certainty after querying multiple oracles. We present our learning algorithm, BMO, in Section 4 and the experiment results in Section 5. We conclude our work in Section 6. Labeling each example with multiple oracles has been studied when labeling is not perfect in supervised learning [5,6,7]. Some principled probabilistic solutions have been proposed on how to learn and eva luate the multiple-oracle problem. However, as far as we know, few of them can guarantee the labeling quality to be equal to or greater than a given threshold c , which can be guaranteed in our work.

Other recent works related to multiple o racles have some assumptions which may be too strong and unrealistic. One assumption is that the noise of oracles is equally distributed [3]. The other type of assumption is that the noise level of different oracles are different as long as they do not change over time [4,8]. Their works estimate the noise level of different oracles during the learning process and prefer querying the oracles with low noise levels. However, it is ubiquitous that the quality of an oracle is example-depe ndent. In this paper, we remove all the assumptions and allow the noise level of oracles vary among different examples.
Active learning on the data with example-dependent noise level was studied in [9]. However, it focuses on how to choose examples considering the tradeoff between more informative examples and examples with lower noise level. C-Certainty labeling is based on the assumption that oracles can return both labels and their confidences in the labelings. For this study, we define confidence formally first here. Confidence for labeling an example x is the probability that the label given by an oracle is the same as the true label of x . We assume that
By using the labels and confidences given by oracles, we guarantee that the label certainty of each exam ple can meet the threshold c ( c  X  (0 . 5 , 1] ) by querying oracles repeatedly (called c -certainty labeling ). That is, a label is valid if its certainty is or equal to than c . Otherwise, more queries would be issued to different oracles to improve the certainty.

How to update the label certainty of an example x after obtaining a new answer from an oracle? Let the set of previous n  X  1 answers be A n  X  1 ,andthe new answer be A n in the form of ( P,f n ), where P indicates positive and f n is the confidence. The label certainty of x , C ( T P | A n ) , can be updated with Formula 1 (See Appendix for the details of its derivation).
 where T P and T N are the true positive and negative labels respectively. Formula 1 can be applied directly when A n is positive (i.e., A n = { P,f n } ); while for a negative answer, we can transform it as A n = { N,f n } = { P, (1  X  f n ) } such that Formula 1 is also applicable. In addition, Formula 1 is for calculating the cer-the label is negative and the certainty is 1  X  C ( T P | A n ) . With Formula 1, the pro-is greater than or equal to c .

However, from Formula 1 we can see that the certainty, C ( T P | A n ) ,isnot monotonic. It is possible that the certainty dangles around and is always lower than c . For example, in paper reviewing, if the labels given by reviewers are with low confidence or alternating between positive and negative, the certainty may not be able to reach the threshold c even many reviewers are requested.
To guarantee that the threshold c is reachable, we will propose an effective algorithm to improve the effici ency of selecting oracles. To improve the querying efficiency, the key issue is to select the best oracle for every given example. This is very different f rom the case when the noise level is example-independent [4,8], as in our case the performance of each oracle varies on labeling different examples. 4.1 Selecting the Best Oracle How to select the best oracle given that the noise levels are example-dependent? The basic idea is that an oracle can probably label an example x with high confidence if it has labeled x j confidently and x j is close to x . This idea is reasonable as the confidence distribution (expertise level) of oracles is usually continuous, and does not change abruptly. More specifically, we assume that each of the m oracle candidates ( O 1 ,  X  X  X  ,O m ) has labeled a set of examples E i ( 1 neighbors of x in E i ( 1  X  i  X  m ). BMO chooses the oracle O i such that examples in E k i are of high confidence and close to the example x . The potential confidence for each oracle in labeling x can be calculated with Formula 2.
 Euclidean distance between x j and x . The numerator of Formula 2 is the average confidence of the k nearest neighbors of x . The last item in the denominator is the average distance, and the 1 is added to prevent the denominator from being zero. High confidence and short distance indicate that the oracle O i will more likely label x with a higher confidence. Thus, BMO selects the oracle O i if 4.2 Active Learning Process of BMO BMO is a wrapper learning algorithm, a nd it treats the str ategy of selecting examples to label as a black box. Any existi ng query strategies in active learning, such as uncertainty sampling [10], expect ed error reduction [11] and the density-weighted [12] method can be fit in easily.

We assume that BMO starts with an empty training set, and the learning process is as follows. For an example x i ( x i  X  X  u ) selected by an example-selecting strategy (e.g.,uncertain sampling), BMO selects the best oracle among the ones that have not been queried for x i yet to query, and updates the label certainty of with Formula 1. This process repeats until the certainty meets the threshold c . Then BMO adds x i into its labeled example set E l . This example-labeling process continues until certain stop criterion is met (such as the predefined query budget is used up in our experiment). (See Algorithm 1 for details.) Algorithm 1. BMO (Best Multiple Oracles)
By selecting the best oracles, BMO can improve the label certainty of a given example to meet the threshold c with only a few queries (See Section 5). That is, more labeled examples can be obtained for a predefined query budget compared to random selection of oracles. Thus, th e model built is expected to have better performance. In our experiment, to compare with B MO, we implement two other learning strategies. One is Random selection of Multiple Oracles (RMO). Rather than selecting the best oracle in BMO, RMO s elects oracles randomly to query for a given example and repeats until the label certainty is greater than or equal to c . The other strategy is Random selection of Single Oracle (RSO). RSO queries for each example only once without considering c , which is similar to traditional active learning algorithms.

Since RSO only queries one oracle for each example, it will have the most labeled examples for a predefined query budget but with the highest noise level. To reduce the negative effect of noisy labels, we weight all labeled examples ac-cording to their label certainty when building final models. To make all the three strategies comparable, we also use weighting in BMO and RMO. In addition, all the three algorithms take uncertain samp ling as the example-selecting strategy and decision tree (J48 in WEKA [13]) as their base learners. The implementation is based on the WEKA source code.

The experiment is conducted on UCI datasets [14], including abolone, anneal, cmc new, credit, mushroom, spambase and splice, which are commonly used in the supervised learning research. As the number of oracles cannot be infinite in real world, we only generate 10 oracles for each dataset. If an example has been presented to all the 10 oracles, the label and the certainty obtained will be taken in directly. The threshold c is predefined to be 0.8 and 0.9 respectively. The experiment results presented are th e average of 10 runs, and t-test results are of 95% confidence.

In our previous discussion, we take the confidence given by an oracle as the true confidence. However, in real life, oracles may overestimate or underestimate themselves intentionally or unintentionally. If the confidence given by an oracle O does not equal the true confidence, we call O an unfaithful oracle ;otherwise,it is faithful. To observe the robustness of our algorithm, we conduct our empirical 5.1 Results on Faithful Oracles As no oracle is provided for the UCI data, we generate a faithful oracle as follows. Firstly, we select one example x randomly as an  X  X xpertise center X  and label it with the highest confidence. Then, to make the oracle faithful, we calculate the Euclidean distance from each of the rest examples to x , and assign them confi-dences based on the distances. The further the distance is, the lower confidence the oracle has in labeling the example. Noise is added into labels according to the confidence level. Thus the oracle is faithful.

The confidence is supposed to follow a certain distribution. We choose three common distributions, linear, normal and dual normal distributions. Linear dis-tribution assumes the confidence reduces linearly as the distance increases. For normal distribution, the reduction of confidence follows the probability density the oracle has two  X  X xpertise centers X  (see Figure 1). As mentioned earlier, we generate 10 oracles for each dataset in this experiment. Among the 10 oracles, three of them follow the linear distribution, three the normal distribution and four the dual normal distribution.

Due to the similar results of different datasets, we only show the details of one dataset (anneal) in Figure 2 and a summary of the comparison afterwards. Figure 2 shows the testing error rates of BMO, RMO and RSO for the threshold 0 . 8 (left) and 0 . 9 (right) respectively. The x axis indicates the query budgets while the y axis represents the error rate on test data. On one hand, as we expected that, for both thresholds 0 . 8 and 0 . 9 , the error rate of BMO is much lower than that of RMO and RSO for all different budgets, and the performances of the latter two are similar. On the other hand, the curve of RMO when c =0 . 8 is not as smooth as the other ones.

The different performances of the three learning strategies can be explained by two factors, the noise level and the nu mber of examples. Due to limited space, we only show how the two factors affect the performances through one dataset (anneal) when the query budget is 500 in Figure 3.

Figure 3 shows that on average BMO only queries about 1 . 4 ( c =0 . 8 )and 1 . 7 ( c =0 . 9 ) oracles for each example; while RMO queries more oracles ( 1 . 7 and 2 . 0 ). That is, BMO obtains more labeled examples than RMO for a given bud-get. Moreover, the examples labeled b y BMO have much higher label certainty more noisy than BMO (i.e., the red portion is much larger). It is the noise that deteriorates the performance of RSO. Thus, BMO outperforms the other two strategies because of its guaranteed la bel quality and the selection of the best oracles to query.

By looking closely into the curves in Figure 2, we find that the curve of RMO when c =0 . 8 is not as smooth as the other ones. The reason is that RMO of c =0 . 8 has fewer labeled examples when compared to BMO and RSO of c =0 . 8 and has more noise when compared to that of c =0 . 9 . Fewer examples make the model learnt more sensitive to the quality of each label; while the label quality of c =0 . 8 is not high enough. Thus, the stability of RMO when c =0 . 8 is weakened.
In addition, we also show the t-test results in terms of the error rate on all the seven UCI datasets in Table 1. As for each dataset 10 different query budgets are considered, the total times of t-test for each group is 70. Table 1 shows that BMO wins RMO 94 times out of 140 ( c =0 . 8 and c =0 . 9 ) and wins RSO 86 out of 140 without losing once. It is clear that BMO outperforms RMO and RSO significantly.

In summary, with faithful oracles, the experiment results show that BMO does work better by guaranteeing the label quality and selecting the best oracles to query. On the other hand, even though RMO also can guarantee the label qual-ity, its strategy of randoml y selecting oracles reduces the learning performance. Furthermore, the results of RSO illustrate that weighting with the label quality may reduce the negative influence of noise but still its effect is limited. 5.2 Results on Unfaithful Oracles Unfaithful oracles are generated for each dataset by building models over 20% of the examples. More specifically, to g enerate an oracle, we randomly select one example x as an  X  X xpertise center X , and sample examples around it. The closer an example x i is to x , the higher the probability it will be sampled with. Thus, the oracle built on the sampled examples can label the examples closer to x with higher confidences. The sampling probability follows exactly the same distribution in Figure 1. For each data set, 10 oracles are generated and three follow the linear distribution, three the normal distribution and four the dual normal distribution.
As sampling rate declines with the increasing distance, the oracle built may fail to give true confidence for the examples that are far from the  X  X enter X . As a result, the oracle is unfaithful. That is, the oracles are unfaithful due to  X  X nsufficient knowledge X  rather than  X  X ying X  deliberately.

We run BMO, RMO and RSO on the seven UCI datasets and show the testing error rates and the number of labeled examples on one data set (anneal) in Figure 4 and a summary on all the datasets afterwards. It is surprising that the performances of BMO on unfaithful oracles are similar to that on faithful oracles. That is, the error rate of BMO is much less than that of RMO and RSO, and the latter two are similar. The examples labeled by BMO are more than that by RMO and its label quality is higher than that of both RMO and SMO, which are also similar to that on faithful oracles. The comparison shows clearly that BMO is robust even for unfaithful oracles. The reason is that BMO selects the best multiple oracles to query, and it is unlikely that all the best oracles are unfaithful at the same time as our unfaithful oracles do not  X  X ie X  deliberately as mentioned. Thus, BMO still performs well.
Table 2 shows the t-test results on 10 different query budgets for all the seven UCI datasets. We can see that BMO wins RMO 95 times out of 140 and wins RSO 98 out of 140, which indicates that BMO works significantly better than RMO and RSO under most of the circumstances. However, BMO loses to RMO 19 times and RSO 10 times, which are different from the results on faithful oracles. Thus, even though BMO is robust, still it works slightly worse on unfaithful oracles than on faithful ones.

In summary, BMO is robust for working with unfaithful oracles, even though its good performance may be reduced slightly. This property is crucial for BMO to be applied successfully in real applications. In this paper, we proposed a novel active learning paradigm, c-certainty learning, in which oracles can return both labels and confidence. Under this new paradigm, the label quality is guaranteed to be grea ter than or equal to a given threshold c by querying multiple oracles. Furthermore, we designed the learning algorithm BMO to select the best oracles to query so that the threshold c can be met with fewer queries compared to selecting o racles randomly. Empirical studies are conducted for both faithful and unfaithful oracles. The results show that BMO works robustly and outperforms other active learning strategies significantly on both faithful and unfaithful oracles, even though its performance can be affected slightly by unfaithful oracles.

The last item in Equation 3 can be further transformed as follows.
