 1. On coordination and situatedness: conceptual premises
When does complexity arise in systems? Many articulated and legitimate answers are possible, and can be found in the literature.
At the bottom line, an acceptable answer can be drawn from organisation theory: complexity comes in when dependencies among activities are not trivial ( Malone and Crowston, 1994 ). It seems to be quite symptomatic, for instance, the fact that in classical mechanics the 2-body problem was already solved by Bernoulli in the 17th century; whereas the attempts by Poincar X  to fi nd a solution to the general n -body problem at the end of the 19th century mostly led to the development of chaos theory, rather than to a proper solution.
Nowadays, activities in computational systems are typically modelled by means of agents in multi-agent systems (MAS). Agents are computational entities whose de fi ning feature is autonomy ( Wooldridge, 2002; Castelfranchi, 2012; Omicini et al., 2008 ), so that MAS are collection of autonomous agents working together as a system.

Modelling activities through agents basically means representing actions along with their motivations  X  namely the goals that deter-mine and explain the agent's course of actions ( Castelfranchi, 2012 ).
Whenever the goals are explicitly represented within agents through mentalistic abstractions  X  as in the case of BDI agent architectures ( Rao and Georgeff, 1995 )  X  intelligent agents ( Wooldridge and
Jennings, 1995 ) are involved, setting their course of actions according
Handling dependencies in MAS is in essence a coordination problem ( Malone and Crowston, 1994 ), that is, understanding how actions by (intelligent) agents interfere with each other in the MAS when each agent aims at its own goal, and governing them altogether to make the whole MAS achieve its overall global goal.
Accordingly, coordination models are the most suitable tools to harness complexity in MAS ( Ciancarini et al., 2000 ), as they are explicitly meant to provide the abstractions and mechanisms to  X  glue  X  agents together ( Gelernter and Carriero, 1992; Ciancarini, 1996 ) by governing agent interaction in a MAS ( Wegner, 1996 ).
Through the notion of social action ( Castelfranchi, 1998 ), depen-dencies are modelled in MAS in terms of agent societies , in turn represented computationally by means of coordination artefacts the general case of distributed systems.
 However, agents and societies are not the only basic bricks for
MAS: environment , too, is an essential abstraction for MAS modelling and engineering ( Weyns et al., 2007 ), which needs to be suitably represented, and related to agents. This is the core of the notion of situated action , as the realisation that coordinated, social, intelligent action arises from strict interaction with the environment, rather than from rational practical reasoning ( Suchman, 1987 ).
The need for situatedness of agents and MAS is often translated into the requirement of being sensitive to environment change ( Ferber and M X ller, 1996 ). This basically means dependency, again: so, agent behaviour should be affected by environment change.
In all, this means that (i) things happen in a MAS because of either agent activity or environment change  X  the only two sources of events in MAS  X  , (ii) complexity arises from both agent  X  agent  X  environment dependency  X  roughly speaking, from both social and situated interaction. Also, this suggests that coordination charge of managing dependencies ( Malone and Crowston, 1994 ) couldbeusedtodealwithbothformsofdependencyinauniform way; so, also, that coordination arte facts could be exploited to handle both social and situated interaction ( Omicini and Mariani, 2013 ).
Accordingly, in this paper we propose an agent-oriented, event-driven architecture for complex computational systems that exploits coordination to handle both social and situated interac-tion. By focussing on situatedness, we fi rst observe the evolution of the notion of environment in MAS meta-models ( Section 2 ), then we explore the approach to situatedness by some well-known agent frameworks ( Section 3 ). Our proposed architecture is presented and detailed ( Section 4 ), conceptually tested against a few use cases ( Section 5 ), then implemented upon the TuCSoN middleware for MAS coordination ( Omicini and Zambonelli, 1999 ) ( Section 6 ). Finally, comparison with some related work ( Section 7 ) precedes conclusion ( Section 8 ). 2. Situatedness and coordination in MAS: meta-models
A linear account of the evolution of the concepts and ideas within any fi eld of human knowledge is likely to be at the same is actually never linear, so that for instance several contrasting ideas typically coexist altogether at the same time on the same subject in the same fi eld. Essential in that understanding history of ideas typically requires some linearisation, for instance when trying to explain the emergence of new concepts, or, to foresee the next steps of their evolution.

Accordingly, in this section we provide a short linear account of the evolution of agent-oriented meta-models along the years, by focussing on the abstractions adopted to address the issues of situatedness and coordination in MAS engineering. 2.1. Activities by agents
While the essential role of the environment was made clear since the early days of research on MAS ( Ferber and M X ller, 1996 )  X  mostly based on the work on reactive agents ( Brooks, 1986;
Demazeau and M X ller, 1991 )  X  , all the focus then was on activities, with no abstractions devoted to model either environment change or dependencies. Fig. 1 roughly depicts the corresponding (impli-cit) meta-model.

There, fi rst of all, the only means of interaction for agents is by messages exchange. This means that inter-agent dependencies are basically dealt with via inter-agent communication, handling all coordination issues at the individual level  X  using the so-called subjective approach to coordination ( Schumacher, 2001; Omicini and Ossowski, 2003 ).

Furthermore, no speci fi c abstraction is devoted to environment engineering ( Weyns et al., 2007 ): every agent is basically supposed to directly deal with environment resources, thus providing no speci fi c support to agent  X  environment interaction. So, on the one hand, the only thing that makes things happen in a MAS are activities, modelled through agents. On the other hand, any sort of situatedness requires ad-hoc solutions  X  such as  X  bridges lower-level languages  X  , with no general-purpose abstraction to directly support environment engineering. 2.2. Environment change by agents
When the notion of environment was not yet recognised as a fi rst-class MAS abstraction  X  as the one of agent  X  but as a sort of technical  X  missing link  X  between agent technology and real-world applications, the easiest approach to environment modelling in MAS was quite obvious: environment resources or properties are repre-sented and manipulated by environment agents ,actingas  X  wrap-pers  X  X  as in Cheyer and Martin (2001) , for instance. Thus, no novel, speci fi c abstraction is provided for capturing environment change: simply, the agent abstraction is somehow abused, exploiting auton-omy just to reproduce unpredictable behaviour. Correspondingly, situatedness is handled as mere inter-agent communication.
Fig. 2 depicts the corresponding MAS scenario: a software layer of environment agents is built upon the lower level of environ-ment resources  X  the one of low-level languages and legacy API. In this way, situatedness of  X  proper  X  agents (those on the left side of Fig. 2 ) is just a consequence of their communication with their reactive siblings (the ones within the Layer 1 frame).
As far as dependencies are concerned, nothing new happens: agents in a MAS are still a bunch of autonomous components exchanging messages, and the reach of subjective coordination is extended to cover all dependencies among activities, including agent  X  environment interactions. 2.3. Coordination for social dependencies
Since MAS became the reference paradigm for complex compu-tational systems ( Omicini and Zambonelli, 2004 ), direct inter-agent communication clearly turned out to be quite a feeble solution for handling non-trivial dependencies. The recognition that an interac-tion space exists in MAS, and is a primary source of complexity, made the need of speci fi c abstractions emerge, devoted to the management of social interaction.

Along this line  X  as depicted in Fig. 3  X  the importance of governing the interaction space outside the agents was recognised, and the shift towards objective coordination began ( Schumacher, 2001; Omicini and Ossowski, 2003 )  X  that is, coordination provi-ded to agents as a service ( Viroli and Omicini, 2006 ), rather than cooperatively built by agent the mselves through communication protocols. Starting from the simplest attempts  X  such as inter-agent communication protocols and individual agent mailboxes  X  ,anumber of general-purpose coordination models were de fi ned ( Omicini et al., 2001 )  X  such as Law-Governed Linda ( Minsky and Leichter, 1995 ), TuCSoN ( Omicini and Zambonelli, 1999 ), L IME ( Picco et al., 1999 ), and
MARS ( Cabri et al., 2000 )  X  , allowing MAS engineers to manage MAS interaction space via coordination artefacts  X  handling social depen-dencies by ruling agent  X  agent interaction ( Ciancarini et al., 2000 ).
However, no speci fi c attention was still devoted here to the interaction with MAS environment, since environment represen-tation lacks suitable abstractions supporting agent  X  environment dependencies. Thus, even though clearly a coordination issue, situatedness here is still conceived as a separated problem independent of coordination, and consequently managed just at the technology level  X  that is, according to the custom solutions provided by the MAS development framework at hand. 2.4. Coordination for all dependencies
As soon as situatedness is considered as a proper coordination issue  X  since it deals with agent  X  environment interaction chance of a uniform meta-model emerges, which could handle both social and situated dependencies in a coherent way. This is for instance the view promoted by the TuCSoN architecture ( Mariani and Omicini, 2013c ), where ReSpecT tuple centres work as coordination artefacts handling both agent  X  agent and agent environment interaction ( Mariani and Omicini, 2013a ).
The corresponding meta-model is depicted in Fig. 4 , where also interaction with MAS environment is considered to be part of the
MAS interaction space  X  now, a situated coordination space promoting a view of MAS in which all dependencies are uniformly handled by coordination abstractions ( Mariani and Omicini, 2013c ).
In this scenario, the property of being situated can be inter-preted both at the individual agent level and at the overall system level , as a property belonging to the whole coordinated MAS since agent  X  environment interaction can be handled at both the individual and the social level by coordination artefacts ( Omicini et al., 2004a ). 3. Situatedness and coordination in MAS: architectures
Agent-oriented programming frameworks bring agent abstrac-tions to life, by reifying agent (meta-)models, and making them available to MAS engineers. It is then easy to understand how the conceptual evolution devised in Section 2 has led to different frameworks for MAS development over the years.

Accordingly, in this section we focus on agent-oriented archi-tectures , as they are adopted by some well-known agent-oriented programming frameworks, and discuss how they address the issues of situatedness and coordination in the engineering of
MAS. In particular, we analyse three MAS development frame-works  X  J ADE , Jason, and CArtAgO  X  , chosen for their relevance and wide-spread adoption, as well as for their belonging to different periods of MAS research. 3.1. Activities, dependencies, environment change in J ADE J
ADE (Java Agent DEvelopment Framework) 1 ( Bellifemine et al., 1999 ) is a Java-based framework and run-time middleware to develop agent-based applications in compliance with FIPA 2 dards for interoperable, intelligent MAS. Generally speaking, J most notable features are transparent message-passing layer based on FIPA ACL (agent communication language), white and yellow pages services, support for strong mobility, and built-in FIPA protocols.

As far as we are concerned here, the most relevant architectural components of the J ADE middleware are the following:
Agents :J ADE agents are Java objects executed by a single thread of
ACC : The Agent Communication Channel is the run-time
FIPA protocols :J ADE supports FIPA standard communication proto-
This brief middleware description is enough to relate J ADE pictures in Section 2 : (i) agents are obviously the abstractions to deal with activities in J ADE ; (ii) J ADE provides no speci ment abstraction, so that J ADE agents have to be used to capture environment change, too; and (iii) the only J ADE abstraction to handle dependencies is the FIPA protocol, constraining agent agent communication. Accordingly, Fig. 5 relates J ADE architectural model with the meta-model of Fig. 3 , emphasising how J ADE are (over)used to represent environment properties and resources.
As a result, the implicit J ADE coordination model is somehow a hybrid one, borrowing from both subjective and objective coor-dination: on the one hand, most is charged upon subjective coordination, since coordination is based on protocols, and proto-cols are implemented as agent behaviours; on the other hand, the fact that protocols are behaviour  X  hence, Java objects different from agents  X  makes it possible to separate to some extent the coordination (social) logic (indeed, inside the protocols) from the agent (individual) logic (inside  X  non-protocol  X  agent behaviours).
Also, as depicted in Fig. 3 , situatedness in J ADE is merely handled as an inter-agent communication issue. 3.2. Activities, dependencies, environment change in Jason
Jason 3 ( Bordini et al., 2007 ) is an agent language, an agent development framework, and a run-time system as well. As a language, it implements a dialect of AgentSpeak ( Rao, 1996 ); as a development framework, it comes with APIs to design agents and
MAS; as a run-time system, it provides the infrastructure needed to execute a MAS (in a non-distributed setting; to enable distribu-tion, an integration with J ADE exists). Although Jason is entirely programmed in Java, it features BDI agents, so that a higher-level language (the Jason language) is used to program Jason agents using BDI architectural abstractions.

Jason natively supports the notion of MAS environment and situatedness: in particular, Jason agents are said to be situated in an environment since they can sense it through sensors, and act upon it through actuators. Unlike Jason agents, Jason sensors and actuators  X  along with all the environment resources needed to model the MAS environment  X  have to be implemented directly using Java.

As a result, Jason architectural components that are worth to be mentioned here for our purpose are the following:
Agents : Jason agents are BDI architectures whose reasoning cycle Messages : By exploiting message passing, Jason agents can exch-Environment : Unlike J ADE , Jason supports the environment as a Events : Somehow hidden inside Jason agent architecture, the Fig. 6 depicts how Jason architectural model can be mapped upon the architecture in Fig. 2 : the environment layer is simply based on Java, with no higher-level abstraction provided, furthermore no explicit abstraction to govern the interaction space is given neither  X  other than message passing and goal/plan/beliefs sharing.
Thus, Jason coordination model is in principle a subjective one, since agents themselves are in charge of properly coordinate: how-ever, coordination may occur either directly  X  by means of message passing  X  or indirectly  X  that is, mediated by environment perception and action, as in stigmergy-coordinated MAS ( Omicini, 2012 ).
Situatedness is still a feature belonging to individual agents, but, unlike J ADE , it is achieved through the environment abstractions of sensors ( -perception ) and actuators ( -action )  X  although no specialised architectural component is given except for an abstract
Java class. 3.3. Activities, dependencies, environment change in CArtAgO
CArtAgO 4 ( Ricci et al., 2007 )isaJava-basedframeworkand infrastructure based on the A&amp;A (agents &amp; artefacts) meta-model ( Omicini et al., 2008 ). The A&amp;A meta-model introduces artefacts as the tools that agents use to enhance their own capabilities, for achieving their own goals ( Omicini et al., 2009 )  X  as human beings do with their tools ( Nardi, 1996 ). So, artefacts can be used to (compu-tationally) represent any kind of environmental resource within a
MAS in a uniform way  X  from sensors to actuators, from databases to legacy OO applications, from real-world objects to virtual black-boards. Given its focus on artefact design, implementation, and run-time support, rather than on agent development, CArtAgO is designed so as to be as much orth ogonal as possible w.r.t. the agent-platform  X  Java bridges exist, e.g., towards both J
Correspondingly, CArtAgO main architectural components are the following:
Artefacts :Artefacts are the basic bricks in the A&amp;A meta-model,
Workspaces : Workspaces play the role of the topological contain-
Agent bodies : By exposing effectors API and enabling perception of
Observable events : While implementing artefacts, CArtAgO pro-
Fig. 7 depicts the above-mentioned architectural components along with their mutual relationships. In summary, CArtAgO handles situated interaction by providing artefacts as a means to mediate agents interaction with their environment  X  via agent bodies. As far as coordination is concerned, neither built-in services nor abstrac-tions are speci fi cally devoted to the purpose: coordination could be then achieved only by means of ad-hoc-designed social artefacts e.g., by implementing a channel, a mailbox, a shared blackboard as a suitably tailored CArtAgO artefact. 4. Coordination for situation: an event-driven architecture
A well-founded software architecture relies on a well-de fi meta-model  X  that is, the set of concepts and abstractions the architecture is grounded on. Besides setting the architecture within a sound conceptual framework, this makes it possible to place the proposed architecture within the historical perspective taken in Section 2  X  in particular, by mapping our architecture onto the meta-model depicted in Fig. 4 . 4.1. Meta-model
In the widespread acceptation of MAS nowadays, agents , environment and societies are the three fundamental abstractions around which MAS should be modelled and engineered ( Omicini et al., 2004a ). While our meta-model still adopts such three abstractions as its reference conceptual framework, there are three core concepts that motivate the architecture, which the meta-model should account for:
Activities : Goal-directed/oriented proceedings resulting into actions
Environment change : The (possibly unpredictable) variations in
Dependencies : In any non-trivial MAS, activities depend on other
The core notion that links the architecture to the meta-model is the one of event :
Events : Despite their intrinsic diversity, actions and environm-4.2. Architecture
Our event-driven architecture for MAS is depicted in Fig. 8 , and is based on the following (abstract) components:
Agents : Agents are the autonomous entities in charge of the
Environment resources : While the notion of environment is quite a
Boundary artefacts : Heterogeneity of agents and of resources, along Coordination artefacts : Coordination artefacts are the components Events : First of all, boundary artefacts generate external events, as Summing up, in the abstract architecture in Fig. 8 (i) agents and environmental resources interact through boundary artefacts , (ii) mapping agent activities and environment changes into events , (iii) which are handled by coordination artefacts . 5. Testing the architecture: use cases
The architecture proposed here is general enough to be suitable for implementation and deployment in a wide range of business domains and application scenarios  X  the only conceptual require-ment being agent-orientation of the software engineering process. Nevertheless, describing how each of the architectural components could be actually instantiated in some concrete use cases may help the reader better understand the potential impact of the architec-ture. To this end, in the remainder of this section we provide the reader with some potential applications of the architecture in the fi elds of smart buildings ( Section 5.1 ), plant automation control ( Section 5.2 ), and work fl ow management systems ( Section 5.3 ). 5.1. Smart buildings: of fi ce scenario
Fig. 9 depicts a smart of fi ce scenario, in particular, the second fl oor of the headquarters of the  X  This&amp;That ACME Inc.  X  X  fi being irrelevant.

Being a smart of fi ce, the  X  This&amp;That ACME Inc.  X  headquarters bene fi t from a number of features: Smart illumination : Lights automatically turn on/off depending
Smart AC : Similarly, air conditioning (AC), too, can be pro-
Smart displays : displays are all virtually connected to a common
Smart collaboration : actually, all the co-workers' desktops and
In order to set up and manage the above smart infrastructure, the  X  This&amp;That ACME Inc.  X  deploys our proposed architecture as follows:
Agents are embedded in each co-worker's desktop, representing
Environment resources areallthepresencesensors,temperatureand
Boundary artefacts are deployed wherever an agent or an envir-
Coordination artefacts are embedded in co-workers' desktops as well
Events are generated by boundary artefacts and coordination
In such a scenario, event-driven coordination may for instance result in the following activities  X  as also depicted in Fig. 9 :
Set up the meeting room whenever a meeting is scheduled : namely program timed turning on/off of lights and AC as well as display mirroring for a remote participant (if needed). For such a coordination law,  X  events are the scheduling of a meeting, approaching the  X  boundary artefacts generating and consuming events are  X  coordination artefacts can be situated in  X  The MAS  X  room,
Coordinate lights and AC so as to avoid wasting energy : namely turning off lights and AC if somebody leaves a room and does not come back for a while.

Coordinate displays so as to follow me : namely switching on and off screens as well as migrating displayed content from screen to screen as the owner user passes by.
 Fire an alarm whenever somebody enters the fl oor :at  X  This&amp;That
ACME Inc.  X  employers are obsessed by secrecy of their IT projects. 5.2. Plant automation control: winery scenario
In our case-study winery, there are tanks storing must, tanks storing wine waiting for yeasts, as well as tanks storing wine already fermented; also, there are other tanks meant to store different kinds of fermented wines waiting to be mixed so as to compose a fi nished product (e.g., Sangiovese di Romagna); there are pipes connecting different kinds of tanks, as well as pipes connecting tanks to delivery spots, where tank trucks wait for a fi nished product to be loaded. There are also various kinds of sensors  X  e.g., pressure and temperature sensors inside tanks, and fl ow meters in pipes  X  as well as different kinds of actuators e.g. blenders inside tanks, valves at both ends of pipes, and hatches at delivery spots  X  , and each of them can be automatically controlled by digital controllers connected over an ad-hoc net-work. Finally, there are also various digital control panels, enabling human supervisors to monitor and control all the automated processes taking place within the winery  X  e.g. valves opening/ closing when due, pipes fl ow strength adjustment, and blenders speed according to yeasts quantity.

Within such a scenario, our reference architecture could be deployed as follows: agents are embedded in each control panel, representing the environment resources are all the pressure and temperature sensors, boundary artefacts are deployed either on board, directly within coordination artefacts can be as well placed in the server room, events are generated by boundary artefacts and coordination
In this way, all the automatic processes taking place in the winery can be programmed (and re-programmed, at run-time) as coordi-nation policies, taking care of suitably managing dependencies among events generated by boundary artefacts, so as to achieve the goals ascribed by designers of the winery IT system to the winery MAS. 5.3. Work fl ow management systems Any work fl ow management system ( Van Der Aalst and Van
Hee, 2004 ) is mainly concerned in supporting the collaboration of human users toward a shared goal  X  between themselves and with software processes. Therefore, regardless of the speci fi application domain target, a work fl ow management system typi-cally involves the following: human users interacting with the system, both to consume the information needed to carry out their work and to produce the information needed by others, e.g., co-workers in a news agency sharing their editing and corrections to news stories waiting for publication; software processes part of the software system pursuing the business needs, e.g. printing services, web crawlers, and docu-ment editors; work fl ow engines handling dependencies between co-workers activities and with software services needed, e.g. automatic revision tool waiting for  X  release candidate  X  version of a story and chief editor waiting for release candidate version of the whole newspaper.
 In such a scenario, our event-driven architecture could be deployed as follows: agents are deployed on human users' laptops, smartphones, environment resources are all the software and hardware tools boundary artefacts are in charge of interfacing all the environment coordination artefacts play the role of work fl ow engines, now events are generated by boundary artefacts and coordination Once again, the architecture is suitable for deployment and may well support coordination of co-worker's needs so as to achieve the goals of the MAS designed. 6. Implementing situated coordination in TuCSoN
TuCSoN 5 ( Omicini and Zambonelli, 1999 ) is a tuple-based coordination infrastructure for open distributed MAS. It features ReSpecT tuple centres ( Omicini and Denti, 2001 ) as its coordination artefacts  X  that is, logic tuple spaces enhanced with programmable behaviour via the ReSpecT logic language ( Omicini, 2007 ) distributed over a network of connected TuCSoN nodes .
ReSpecT allows MAS designers to program their custom coor-dination laws , by associating events in the interaction space occurring as a consequence to agents activities as well as to environment change  X  to computations enacting coordination laws. Such association is implemented by means of reaction speci fi cation tuples , which are a special kind of fi rst-order logic tuples whose structure is reaction( E , G , R ) : E is the triggering event causing reaction scheduling, G is the conjunction of guard predicates to fi ne-select reactions for execution, R is the reaction to execute, that is, the computations to be carried in response to event E .

Being TuCSoN services available through both Java and tuPro-log 6 ( Denti et al., 2001 ) APIs, any agent written in such languages can bene fi t of TuCSoN coordination facilities  X  thus, e.g., both J and Jason agents.
TuCSoN represents quite a consistent example of implementa-tion of our proposed event-driven architecture. In fact, as depicted in Fig. 10 , TuCSoN main architectural abstractions (as well as run-time components) are the following:
Agents : Any computational entity choosing the TuCSoN coordi-Probes : Environmental resources in TuCSoN are called probes .
ACC : Agent coordination contexts ( Omicini, 2002 ) are TuCSoN
Transducers : Analogous to ACCs for agents, TuCSoN transducers
Events : TuCSoNadopts and generalises the ReSpecT event model,
Tuple centres : ReSpecT tuple centres ( Omicini and Denti, 2001 )
As depicted in Fig. 10 , TuCSoN tackles the issues of coordination and situatedness in open MAS with a uniform and coherent set of abstractions and architectural components: ACCs and transducers stand for coordinated entities (the agents and the environment) in the MAS, and translate activities and changes coming from them in a common event model (ReSpecT situated event model), while tuple centres coordinate both social dependencies and situated dependencies by allowing the management of such events to be programmed.

As a result, by implementing our event-driven architecture via its distributed middleware, TuCSoN promotes both objective coor-dination and situatedness at the MAS level . 7. Related works
By considering the technologies described in Section 3 , one can easily see how they could be read as progressively improving the way in which MAS deal with environment modelling and situatedness.

The fi rst one, J ADE , provides more or less nothing on the environment side, being focussed on supporting agents with a set of services, mostly dedicated to communication, mobility and interoperability. On the coordination side, J ADE adopts ACL mes-sages as the data structure to exchange and FIPA protocols as the only means to manage (social) dependencies  X  thus, in a subjective way. Thus, situated dependencies should be managed without a speci fi c abstraction, by falling back to agents and message passing re-use (or abuse). This can be seen also by considering the (implicit) meta-model behind J ADE ( Fig. 3 ), which somehow recog-nises the existence of an interaction space between agents, but fails short in taking also MAS environment into account.
It is worth noticing here that an integration between J ADE TuCSoN was already proposed in Omicini et al. (2004b) , allowing J
ADE to bene fi t of TuCSoN coordination services. In principle, this allows J ADE to bene fi t of all the architectural components provided by TuCSoN  X  thus, ultimately, to bene fi t of our proposed architec-ture. Nevertheless, such integration was not discussed in this paper for a few good reasons. First of all, when Omicini et al. (2004b) was published, transducers did not exist in TuCSoN (they were fi rst introduced by Casadei and Omicini, 2009 ): thus, neither dedicated abstractions (boundary artefacts) nor architectural com-ponents (transducers) were provided there to deal speci fi with environment resources of any sort. Furthermore, the goal of
Omicini et al. (2004b) was enabling seamless integration of subjective and objective coordination approaches, so that the focus of the paper was on interpreting agents actions over coordination artefacts (only) as physical acts, according to the
FIPA standard implemented by J ADE : as a result, no other kinds of actions (e.g., situated actions) were considered there. Lastly, the fundamental role played by the event abstraction as the glue supporting a uniform interpretation of both social and situa-ted actions (activities and environment change) was not yet recognised.

When considering Jason, environment modelling improves thanks to an explicit Java environment layer, which enables agents to sense perceptions (mapped into beliefs) and to act on effectors (mapped into Jason internal actions). Furthermore, the notion of event as the central abstraction around which the whole agent inner reasoning cycle as well as its  X  perception-action  X  should revolve is recognised in Jason. Nevertheless, something is still missing on the coordination side: Jason features nothing more than message passing and plans/goals sharing, thus leaving coordination issues to agents themselves. For these reasons, Jason (implicit) meta-model corresponds to the one depicted in Fig. 2 , although Jason support to situatedness is better w.r.t. J
Finally, CArtAgO is the technology whose architecture is clearly the closest to ours, as discussed in Section 4  X  hence, to the TuCSoN architecture, too. To some extent, in fact, the following mapping could be attempted: CArtAgO artefacts are explicitly conceived to model and implement environmental resources (in some sense, the union of probes and transducers, in TuCSoN); agent bodies could be classi fi ed as (sorts of) boundary artefacts (they may also resemble TuCSoN ACCs and transducers) although the latter concept is much more generally applicable; CArtAgO observable events are one of the possible implementations of the event abstraction (as TuCSoN events are based on the ReSpecT event model). Also, CArtAgO artefacts could as well be used to imple-ment coordination artefacts, e.g., TuCSoN tuple centres.
Nevertheless, such mapping is actually quite imprecise as well as somewhat unnatural. Focussing, for instance, on CArtAgO implementation of the event abstraction, the difference is quite evident: CArtAgO observable events are bound to the artefact they come from, as a means to check the outcome of agents situated actions and to reactively respond to environment stimuli  X  they reify only situated dependencies; whereas events in TuCSoN are the rei fi cation of whatever happens within the MAS  X  social dependencies, too. A much more general difference lies in the artefact abstraction itself: whereas CArtAgO allows MAS designers to program any kind of artefact they need according to whatever sort of interaction model is required, TuCSoN provides a fi xed set of artefacts  X  that is, ACCs, transducers, and tuple centres  X  which are both (i) each responsible for a general aspect of MAS situated coordination  X  ACCs for activities, transducers for envir-onment changes, tuple centres for social and situated coordination  X  and (ii) actually specialisable depending on the MAS at hand e.g., although exposing the same API, transducers behaviour can be specialised according to the nature of the resource they model. This leads to a fundamental difference w.r.t. uniformity :ina CArtAgO-coordinated MAS, artefacts can be heterogeneous both in their exposed APIs and in their semantics, whereas TuCSoN ACCs, transducers, and tuple centres have a well-de fi ned semantics which remains coherent regardless of the actual specialisation required. Furthermore, CArtAgO observable events are created by the artefact they belong to in a custom way, that is, by storing the information MAS designers believe to be useful at design time. In TuCSoN, instead, the event model used by, e.g., transducers is always the same  X  actually, the ReSpecT event model  X  regardless of the environmental resource nature or the MAS deployment scenario.

Among the works not considered in Section 3 , at least the following three are worth to be mentioned here: the SADE ( Dong et al., 2009 ) and ELDA ( Fortino et al., 2010 ) development frame-works, as well as the iCore European project ( Vlacheas et al., 2013 ).
SADE is a development environment for the engineering of self-adaptive MAS. Acknowledging the role played by the environ-ment in MAS, authors adopt the event abstraction to design a self-adaptation mechanism based on the organisation metaphor  X  similar to our concept of society. In particular, environmental events are noti fi ed to agents according to a publish/subscribe architecture, possibly triggering a change of role  X  leading to a change of behaviour. Nevertheless, the environment abstraction is not developed up to its full extent. In fact, environmental events are generated by other agents, playing the role of wrappers of the portion of the environment that should be observable to the MAS. Furthermore, situatedness support is limited, since the only describing an event in Dong et al. (2009) are (i) its type , which can refer to a change in agent state, behaviour, role, or offered services; (ii) its source (the agent who generated it); and (iii) a set of constraints whose function is not clearly explained  X  at least in Dong et al. (2009) .

In ELDA ( Fortino et al., 2010 ), the event abstraction is adopted to design a lightweight agent model  X  indeed, ELDA. In particular, any ELDA agent is a single-threaded autonomous entity interact-ing through asynchronous events, whose behaviour is expressed reactively in response to incoming events. Although ELDA does not natively support any environment abstraction, it has been extended to support the PACO model abstractions ( Hallenborg et al., 2007 ), splitting MAS into four parts: agents, environment, interactions, and organisation. Nevertheless, such an extension seemingly accounts for agent position only, and the only agent environment interaction is due to a monitor agent  X  again, a wrapper  X  which continuously monitor the environment and the agent state, triggering events when some pre-conditions are met.
The Cognitive Management Framework for the Internet of Things (IoT) ( Vlacheas et al., 2013 ), proposed within the iCore European project, aims at developing a framework able to abstract away from the technological heterogeneity of nowadays devices while improv-ing context-awareness. Among its proposals, a three-layered archi-tecture is conceived to face the above challenges: the lowest layer is meant to collect Virtual Representations (VOs) of real-world objects; the mid-layer to aggregate such representations in Cognitive Mash-ups of VOs according to the way in which they collaborate to offer higher-level functionalities; the top layer is the service-oriented layer providing users and stakeholders with the APIs bridging the gap between application and IoT resources. Such a three layered-architecture  X  in particular the mid-layer promoting and supporting
IoT resources service-oriented aggregation  X  somehow stresses the need to tackle situatedness-related issues as coordination ones. Asfaraspreviousworkofoursareconcerned, Mariani and
Omicini (2013a) primarily focus on the event model to be implemen-ted in the ReSpecT language, which is here revised according to latest development reported in Mariani and Omicini (2013b) .Furthermore, a fl avour of ReSpecT programming is given to the reader through a series of simple examples, by showcasing ReSpecT language features regarding events inspection and computation.

In Omicini and Mariani (2013) , instead, our very preliminary thoughts about the construction of an event-driven architecture for situated MAS coordination are sketched. Most notably, the abstractions of boundary and coordination artefacts, as well as the central role played by the notion of event, are already recognised there, although not yet fully generalised.

Finally, in MarianiandOmicini(2013c) we propose an architec-turebasedonTuCSoNfortheintegrationofbothembodiedand disembodied coordination in MAS. Unsurprisingly, our focus there is on the event model to be adopted: by carefully building such model in fact, both embodied and disembodied systems could be dealt with using the same set of abstractions and (quite) the same architecture.
In particular, the architecture there proposed can be interpreted as a specialisation of the one here proposed in Section 4 ,gearedtoward integration of cloud-based systems with pervasive computing. 8. Conclusion
MAS represent the most suitable paradigm for modelling complex computational systems ( Zambonelli and Omicini, 2004 ).
However, engineering complex systems  X  such as pervasive, adaptive, and self-organising systems  X  requires more than a suitable set of abstractions: well-founded agent-oriented architec-tures and technologies are required, too.

Once interaction is recognised as one of the main sources of system complexity ( Wegner, 1997 ), and coordination is acknowl-edged as the source of the abstractions and mechanisms for managing both agent  X  agent and agent  X  environment interaction ( Casadei and Omicini, 2009 ), the key role of coordination technol-ogy to deal with complexity in MAS is manifest.

Accordingly, in this paper we propose an event-based archi-tecture for MAS that exploits coordination to handle both social and situated dependencies in a uniform way, based on the notions of coordination and boundary artefacts. Also, we describe the
TuCSoN implementation of the architecture, providing ACCs and transducers as boundary artefacts (for agents and probes, respec-tively) as well as ReSpecT tuple centres as coordination artefacts. References
