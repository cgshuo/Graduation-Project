 The emergence of wireless technologies ha s enabled the development of tiny, low-power, wireless sensors capable of sensing physical phenomena such as tempera-ture, humidity, etc.. Sensor networks h ave been adopted in various scientific and commercial applications [1, 2, 3]. Data collection in a sensor network is achieved by modeling it as a distributed database where sensor readings are collected and processed using queries [4, 5, 6].
 In this paper, we address in-network join query processing in sensor networks. Join is an important operation in sensor networks for correlating sensor readings since a single sensor reading may not provide enough information representing a meaningful event or entity. Consider a sensor network covering a road network. Each sensor node can detect the ID X  X  of v ehicles in close vicinity, record the timestamps at which the vehicles are det ected, and keep the timestamped records for a fixed duration, say 1 hour. Suppose N R and N S represent two sets of sensor nodes located at two regions of a road segment, Region1 and Region2, respectively. To gather the necessary data for determining the speeds of vehicles traveling between the two regions, the f ollowing join query can be expressed.
To evaluate the above query, sensor readings from Region1 and Region2 need to be collected and joined on the vehId attribute. We focus on addressing join scenarios whereby the join selectivity is s o low that is it not cost-effective to ship source tuples to the sink for join. Therefore, efficient in-network join algorithms are required. Suppose a sensor network consisting of N sensor nodes. We assume there are two virtual tables in the sensor network, R and S , containing sensor readings distributed in sensors. Each sensor reading is a tuple with two mandatory at-tributes, timestamp and sensorID , indicating the time and the sensor at which the tuple is generated. A sensor reading may contain other attributes that are measurements generated by a sensor or multiple sensors, e.g., temperature. We are interested in the evaluation of static one-shot binary equi-join (BEJ) queries in sensor networks. A BEJ query for sensor networks is defined as follows. Definition 1. Given two sensor tables R ( A 1 ,A 2 ,...,A n ) and S ( B 1 ,B 2 , ...,B m ) ,abinaryequi-join(BEJ)is where A i and B j are two attributes of R and S respectively, which have the same domain.

We assume that R and S are stored in two sets of sensor nodes N R and N S located in two distinct regions known as R and S , respectively. A BEJ query can be issued from any sensor node called query sink , which is responsible for collecting the join result. Due to limited memory, the query sink cannot perform the join by itself. A set of nodes is required to process the join collaboratively, referred to as join nodes . The join processing can be divided into three stages, query dissemination , join evaluation ,and result collection .
 In the query dissemination stage, the sink sends a BEJ query to one of the N R (and N S ) nodes using a location-based ro uting protocol such as GPSR [7]. Once the first N R (and N S ) node receives the query, the node broadcasts the query among the N R ( N S ) nodes. The query dissemi nation cost is therefore O(  X  data to the join nodes which are either determined in the query dissemination phase, or adaptively selected according to the network conditions in the join evaluation phase. Once the join results are ready, the query sink collects the join results from the join nodes 1 .

Our objective is to minimize the total c ommunication cost for processing a given BEJ query in order to prolong the sensor network lifetime. In addition, the join scheme has to ensure that the memory space needed by the join operation on each join node does not exceed the availa ble memory space. In the next section, we present several general strategies for performing in-network join. In Section 4 we describe a synopsis join strategy in which unnecessary data transmission is reduced by an additional synopsis join process. In general strategies, join nodes N F are selected to join tuples of R and S , without attempting to firstly filter out tuples that are not involved in the join results (referred to as non-candidate tuples ).

When a join query is issued, a join node selection process is initiated to find a set of join nodes N F to perform the join. R tuples are routed to a join region F where the join nodes N F reside in. Each join node n f  X  N F stores a horizontal partition of the table R , denoted as R f . S tuples are transmitted to and broadcast in F . Each join node n f receives a copy of S and processes local join R f S . The query sink obtains the join results by collecting the partial join results at each n f . Note that though S could be large, the local join R f S at n f can be performed in a pipelined ma nner to avoid memory overflow [8].
The selection of N F is critical to the join performance. Join node selection involves selecting the number of nodes in N F , denoted by | N F | ,andthelo-cation of the join region F . To avoid memory overflow, assuming R is evenly distributed in N F , | N F | should be at least |R| /m ,where |R| denotes the number of tuples in R and m denotes the maximum number of R tuples a join node n f can store.

Depending on the location of the join region, we have at least three join strategies, namely, naive join , sequential join ,and centroid join (see Figure 1). Naive Join. In naive join, sensor nodes around the sink are selected as the join nodes N F , so that the cost of routing join results to the sink can be minimized (Figure 1(a)). The communication cost involves routing tables R and S to the join region F , broadcasting S to the join nodes, and sending the join results from N F to the sink (shown in Equation 1) 2 . Naive join establishes a basis for performances of all join strategies, since any join strategy should at least perform better than naive join in terms of total communication cost in order to be a reasonable join strategy.
 Sequential Join. Sequential join minimizes the cost of routing and distributing R tuples to the join region by selecting the nodes N R as N F (see Figure 1(b)). In this case, R tuples remain in their respective nodes. S tuples are routed to the region R , and broadcast to all nodes N R .Eachnode n i  X  N R performs the local join R i S where R i is the local table stored at n i . Join results are delivered to the sink as shown in Figure 1(b). The communication cost of this strategy is: Centroid Join. Centroid join selects an optimal join region within the triangle formed by R , S , such that the total communication cost are minimized (see Figure 1(c)). The communication cost is shown in Equation 3. Path-Join [9] is an example of this strategy, which tries to find an optimal join region by minimizing a target cost function. Note that naive join and sequential join are special cases of centroid join.

The above three strategies can be furt her optimized for BEJ queries. A hash-based join can be applied in which both R and S are partitioned into a number of disjoint sub-tables, each with a join attribute value range. Each node n f in N F 3 is dedicated to join two subsets of range v . In this way, tuples with the same join attribute value are always joined at the same join node, and the broadcasting of S in N F can be avoided.
The major problem associated with general strategies is the communication overhead for transmitting non-candidate tuples in R and S , especially for queries with low join selectivity. The synopsis join strategy prunes non-candidate tuples and only joins candidate tuples. The key to the pruning process is to keep the cost overhead as low as possible. The synopsis join strategy comprises three phases, synopsis join , notification transmission and final join . 4.1 Synopsis Join The synopsis join phase performs an inexpensive synopsis join, aiming at reduc-ing the number of R and S tuples to be transmitted for final join. The synopsis join phase comprises two steps: synopsis generation , synopsis join . Synopsis Generation. A synopsis is a digest of a relation that is able to represent the relation to perform operations such as aggregation or join. We denote S ( R ) as the synopsis of a table R . A synopsis can be in any form such as histograms, wavelets, etc., which is generally smaller than the size of the cor-responding table. In this paper, we adopt simple histograms as synopses where a synopsis is represented by the join attribute values of a table and their fre-quencies. For example, assume a sensor table R shown in Figure 3(a). Let the join attribute be Vehicle-type . The corresponding synopsis S ( R ) consists of two attributes, the join attribute value, whose domain is all possible values of Vehicle-Type , and the number of tuples for each Vehicle-Type ,asshownin Figure 3(b).
 In synopsis generation, each sensor generates a synopsis of its local table. Consider a relation R distributed among N R sensor nodes. Each node n i  X  N R stores a local table R i that is part of R . n i generates a local synopsis S ( R i )by extracting the join column A J of R i , and computing the frequencies of the dis-tinct values in A J . Assuming uniform data distribution, we can derive | S ( R i ) | as: Synopsis Join. In this stage, a set of synopsis join nodes N L in the synopsis join region L is selected to join the synopses of R and S to determine the candidate tuples in R and S (see Figure 2). Once N L nodes are determined, the local synopses are routed to N L for synopsis join. For BEJ queries, each synopsis join node n l  X  N L is assigned a range v of join attribute values using a geographic hash function [10], so that only synopses with join attribute value in v are transmitted to n l for synopsis join. For a node n i  X  N R ,thelocalsynopsis S (
R of tuples with join attribute values in v is sent to n l maintaining the range v .
Consider the example shown in Figure 3. Suppose there are two synopsis join nodes n l 1 and n l 2 . n l 1 is dedicated to handle join attribute values car , while n l 2 handles bus and lorry . When a sensor n i 1 generates a local synopses as the one in Figure 3(b), it divides the synopses into two partitions, one partition S ( R n i 1 ) contains tuples t 1and t 3, whose join attribute values are car ,andthe other partition S 2 ( R n i 1 ) contains tuples t 2and t 4 whose join attribute values synopsis join, respectively.

The synopsis join nodes perform synopsis join as synopses from N R and N S nodes arrive. We denote a synopsis from a node n i  X  N R received by a synopsis join node n l as S l ( R i ). A synopsis join operation performed at n l is defined as follows. The operator is a merge function which takes multiple synopses as inputs and produces a new synopsis. In particular, for our histogram synopsis, is defined as a function that accumulates the frequency values if two input tuples are of the same join attribute value. The output of is therefore the accumulation of the input histograms.
 Synopsis Join Node Selection. The number of synopsis join nodes is determined by the sizes of local synopses N L nodes receive. Specifically, suppose a node X  X  memory space is m s (number of synopsis tuples that can fit into a node), the number of synopsis join nodes is determined as follows.
The locations of N L nodes are selected so that the communication cost for routing local synopses is minimized. The communication cost of sending local synopses from N R and N S nodes to N L nodes can be expressed as: Assuming the synopsis join region L is small, we can simplify the above equation: where | P R | (or | P S | )isdist( R, L )(ordist( S, L )) 4 . Given the above equation, the optimal set of synopsis join nodes that minimize C syno  X  join are located on the line connecting R and S . Therefore | P R | + | P S | =dist( R, S ). Assuming mized when | P R | is zero, and | P S | is dist( R, S ). Hence, Therefore, the optimal set of synopsis join nodes N L are chosen from nodes in N
R that are nearest to N S , assuming the size of the region R is small compared to the distance between R and S . Optimal selection of N L for arbitrary R and S regions are part of the future work. 4.2 Notification Transmission Each sensor node in N R and N S needs to be notified of which are the candidate tuples. To achieve this, a synopsis join node n l stores the ID of the sensor a local synopsis originates from. For each join attribute value a , it identifies two set of sensors N a R and N a S storing tuples with join attribute value a , and selects a final join node n f to join these tuples, such that the communication cost of sending data tuples with join attribute value a from N a R and N a S to n f , and sending the results from n f to the sink is minimized. Therefore n f is the node that minimizes the cost function in Formula 10. where |R a i | and |S a j | denote the number of R tuples in n i and S tuples in n j with the join attribute value a , respectively.
 In order to simplify the problem, the weighted centers of sensors in N a R and N
S are derived, respectively. The weighted center c of a set of sensors N storing atable T are defined in Equation 11, where T i refers to the table stored in node n ,andloc( n ) refers to the location of a node n . With Formula 11, the weighted centers c r and c s for sensors in N a R and N a S can be computed respectively. Since n we can rewrite Formula 10 as: Formula 12 is minimum when n f is the generalized Fermat X  X  point [11] of the triangle formed by c r ,c s , and the sink. Note that there may not exist a sensor located at the derived generalized Fermat X  X  point g . GPSR is used to select a node that is nearest to g as the final join node n f .
 The same operation is performed for all join attribute values handled by n l . When synopsis join is completed, n l obtains for each sensor node n i asetof a, n f pairs, which means tuples stored in n i with the join attribute value a are to be sent to n f for final join. The set of pairs are sent to n i in a notification message . A notification message can be broken up into multiple ones if it cannot fit into one network packet. The communica tion cost for notification transmission is similar to Equation 9.
 where | d i | denotes the total size of the notification messages sensor n i receives. 4.3 Final Join Upon receiving a notification message fr om a synopsis join node, each node in N
R or N S sends the candidate tuples whose join attribute values are specified in the notification message to a final join node n f . In the final join stage, a group of final join nodes N F are selected to join the candidate tuples sent from R and S , as shown in Figure 2. The final join node n f performs the join R v S v ,and sends the join results to the query sink. If n f does not have enough memory space, it requests its neighbors to help in the join operation. In this section, we evaluate the performance of synopsis join strategy and com-pare it with other general join strategies, i.e., naive join, sequential join, and centroid join. Throughout the experimen ts, performance is measured by the to-tal number of messages incurred for each join strategy. The control messages for synchronization and coordination among the sensors are negligible compared to the heavy data traffic caused by large tables. More realistic simulation and experiments will be included in our future work.

We varied the following parameters: joi n selectivity, network density, node memory capacity and synopsi s size. Join selectivity  X  is defined as |R S| / ( |R| X  |S| ). The join attribute values are uniformly distributed within the domain of the attribute. Network density affects t he number of neighboring nodes within the communication range of a sensor node. We varied the communication radius of the sensors to achieve different network densities. The size of the synopsis is determined by the data width of join attribute. If the synopsis size is small, the number of messages needed for routing the synopses to the synopsis join nodes becomes small. If it is large, we expect a h igh communication overhead incurred due to the transmission of synopses.
 Experiment Setup. We created a simulation environment with 10 , 000 sensor nodes uniformly placed in a 100  X  100 grid. Each grid contains one sensor node located at the center of the grid. The sink is located at the right-top corner of the area, with coordinates (0 . 5 , 0 . 5). The regions R and S are located at the bottom-right and bottom-left corners of t he network region, respectively, each covering 870 sensor nodes. Table R consists of 2000 tuples, while S consists of 1000 tuples. R and S tuples are uniformly distributed in R and S , respectively.
We assume a dense network with GPSR as the routing protocol. The number of hops required to route a message from a source node to a destination node is approximated using the distance between the two sensors and the communi-cation radius. The simplification enables analysis of network traffic under ideal conditions where there is no message loss. In addition, the overhead of GPSR perimeter mode is avoided with the assumption of dense network. Simulations and experiments under real conditions using GPSR are part of our future work. We set a message size of 40 bytes, which is equal to the size of a data tuple. A tuple in the join result is 80 bytes since it is a concatenation of two data tuples. Join Strategies. We evaluate and compare the performances of five different join strategies, namely, naive join, centroid join, sequential join, optimal join, and synopsis join.

The optimal join provides a lower bound on the total communication cost involved in the join operation. It assumes that the query sink has a complete knowledge about the distribution of R and S . Hence, unlike centroid join, only candidate tuples are transmitted for the final join at N F . Similar to the final join phase of the synopsis join strategy, for each join attribute value a ,anoptimal node n f is selected such that the total cost of routing R a and S a to n f and routing the result R a S a is minimized. The cost is expressed as in Equation 14. Since for any join strategy, the transmissions of candidate tuples and the join results cannot be avoided, the optimal join provides a lower bound on the total number of messages. Note that the assumption is impractical in real environment. 5.1 Performance Evaluation Performance vs. Join Selectivity. Figure 4(a) shows the total communi-cation cost for different join selectivit ies while keeping the memory capacity, communication radius and synopsis size fixed at 250  X  40 bytes, 2 units and 10 bytes respectively. As shown in the figure, sequential join performs worse than all others due to the high cost of broadcasting S to all nodes in N R . Therefore we ex-clude it from subsequent experiments. As expected, optimal join outperforms all other strategies for all selectivitie s. When selectivity is lower than 0 . 001, synop-sis join outperforms naive join and centroid join. This is because non-candidate tuples can be determined in the synopsis join stage, and only a small portion of data are transmitted during the final join. On the other hand, when selectivity is high, almost all data tuples are involved in the result. With large join result sizes, the final join nodes are centered around the sink. This explains why naive, centroid and optimal joins have the same communication cost. Moreover, synop-sis join incurs unnecessary communication sending the synopses, making it less desirable for high selectivity joins.

Although there is an overhead of using synopsis join when selectivity is high, it accounts for a small portion of the total communication cost. The overhead when selectivity is 0.1 is only 7%. Only when the selectivity is 0 . 005 and 0 . 01, the synopsis overhead accounts for a significant portion (20%  X  30%) of the total cost. Many queries have small selectivities where synopsis join is more suitable. Consider our BEJ query example in Section 1, the BEJ query joining on the Vehicle-ID attribute has a maximum join selectivity of 0 . 0005, which favors the synopsis join.
 Impact of Network Density. Figure 4(b) shows the scalability of the join strategies with varied network density . In this experiment, sensors have a mem-ory capacity of 250  X  40 bytes. The join selectivity and synopsis size is 0.0001 and 10 bytes, respectively. As the network b ecomes denser, the total communication costs for all strategies reduce too. Thi s is expected because with a larger com-munication range, fewer hops are needed to send a message across the network. Impact of Memory Capacity. Figure 4(c) shows the total communication cost with different memory capacities. In this exper iment, the communication radius is 2. The synopsis size is 10 bytes, and the selectivity is 0.0001. It is shown that the communication costs of all strategies do not change much when the memory capacity increases. The change in the memory capacity only affects the number of join nodes (and the number of synopsis join nodes for synopsis join). When the memory capacity is large r, there are fewer join nodes selected (8 join nodes reduced to 1 in our experiment setup), and fewer messages are required for sending the result tuples to the sink. There is no reduction in the communication cost of sending data from R and S to the join nodes. Therefore we cannot see much reduction in th e total communication cost.
 Impact of Synopsis Size. Figure 4(d) shows the total communication cost with varied synopsis sizes and join selectivities. The memory capacity is 250  X  40 bytes. And the communication radius is 2 units. As shown in Figure 4(d), with the experiment setup, the smaller the synopsis size, the better the performance of the synopsis join. Small synopses results in lower communication overhead during the synopsis join stage. Therefore, it is beneficial for synopses with small join attribute width compared to the data tuple size. We also observe that the synopsis join performs slightly worse than the centroid join when the synopsis size is greater than 30 bytes, indicating that the overhead of sending the synopsis is greater than the cost savings in data tuple transmission. The popular aggregation-tree-based techniques for solving in-network aggregate queries [5, 6, 12] typically use an aggregation tree to progressively reduce data by merging partial results from child nodes so as to generate new results. The same data reduction technique cannot be directly applied to in-network join queries Several solutions have been proposed to handle joins in sensor networks. TinyDB [13] supports only simple joins in a local node, or between a node and the global data stream. Join operations across arbitrary pairs of sensors are not supported. Chowdhary et al. [9] proposed a path-join algorithm to select an optimal set of join nodes to minimize transmission cost involved in the join. Our technique differs from path-join by pre-filtering non-candidate tuples using synopsis join. Ahmad et al. [14] proposed a join algorithm by utilizing the data and space locality in a network. Their focus is on optimizing the output delay in-stead of the communication cost. Recently Abadi et al. [15] designed techniques to perform event detection using distributed joins. The technique joins sensor data with external static tables, and does not address the problem of joining in-network sensor readings. Also related is the work from Bonfils et al. [16] ad-dressing the problem of optimal operator placement in a sensor network. The join is limited on only a single node, which is prohibitive for large data tables. In this paper, we present a synopsis join strategy for efficient processing of BEJ queries in sensor networks. Unlike the general strategies, the synopsis join strat-egy executes a synopsis join step before performing a final join. The synopsis join step joins synopses generated by the sensors to filter out non-candidate data tuples and avoid unnecessary data transmission. As part of the synopsis join strategy, we have developed methods for determining the optimal set of synopsis join nodes and final join nodes. We have also performed cost analysis on synopsis join. Our preliminary experiments have shown that synopsis join performs well for joins with low selectivity and does not incur much overheads for high join selectivity.

