 Query auto-completion (QAC) plays an important role in assisting users typing less while submitting a query. The QAC engine gen-erally offers a list of suggested queries that start with a user X  X  input as a prefix, and the list of suggestions is changed to match the up-dated input after the user types each keystroke. Therefore rich user interactions can be observed along with each keystroke until a user clicks a suggestion or types the entire query manually. It becomes increasingly important to analyze and understand users X  interac-tions with the QAC engine, to improve its performance. Existing works on QAC either ignored users X  interaction data, or assumed that their interactions at each keystroke are independent from oth-ers. Our paper pays high attention to users X  sequential interactions with a QAC engine in and across QAC sessions, rather than users X  interactions at each keystroke of each QAC session separately. An-alyzing the dependencies in users X  sequential interactions improves our understanding of the following three questions: 1) how is a user X  X  skipping/viewing move at the current keystroke influenced by that at the previous keystroke? 2) how to improve search en-gines X  query suggestions at short keystrokes based on those at latter long keystrokes? and 3) facing a targeted query shown in the sug-gestion list, why does a user decide to continue typing rather than click the intended suggestion? We propose a probabilistic model that addresses those three questions in a unified way, and illustrate how the model determines users X  final click decisions. By compar-ing with state-of-the-art methods, our proposed model does suggest queries that better satisfy users X  intents.
 Categories and Subject Descriptors: I.2.6 [ Artificial Intelligence ]: Learning; H.3.3 [ Information Stor-age and Retrieval ]: Information Search and Retrieval; J.4 [ Com-puter Applications ]: Social and Behavioral Sciences General Terms: Algorithm, Experimentation, Performance Keywords: hidden Markov model, variational Inference, query auto-completion  X 
Query auto-completion (QAC) has been widely used in modern search engines to reduce users X  effort to submit a query by predict-ing the users X  intended queries. The QAC engine generally offers a list of suggested queries that start with a user X  X  input as a prefix, and the list of suggestions is changed to match the updated input after the user types each character. Let us suppose that a user is go-ing to submit a query q to the search engine, and the user types the prefix of the query q of length i as q [1 ..i ] sequentially. The QAC engine will return the corresponding suggestion list after the user types each character, until the user clicks the suggestion q from the list or presses return, ending the interaction with the QAC en-gine. Usually, even for submitting the same query q , different users may have different interactions with the QAC engine, which are shown from their different sequential behaviors. For example, user u a chooses the suggestion q at position 5 after typing 3 characters, while user u b chooses the suggestion q at position 1 after typing 5 characters. In order to better improve users X  search experience, it becomes increasingly important to analyze users X  sequential be-havior with the QAC engine, to understand users X  real preferences and then improve the performance of QAC.

Recently, many studies have been proposed to address the QAC problem in different perspectives, including designing more ef-ficient indexes and algorithms [2, 20, 11], leveraging context in long term and short term query history [1], investigating the time-sensitive aspect of QAC [19, 21], learning to combine more person-alized signals [18], etc. Despite of those numerous works on QAC, most of them only utilize the information of submitted queries and associated prefixes, thus lose details of how users X  interact with the QAC engine, such as the suggested query lists of each prefix before query submission, users X  query typing speed, and so on. Re-cently, a high-resolution QAC dataset was collected from PC (per-sonal computer) and mobile phones [15], where each keystroke of users and clicks were recorded. A two-dimensional click model was trained on this high-resolution QAC dataset, revealing users X  behaviors such as horizontal skipping bias and vertical position bias. However, this work assumed that users X  behaviors at different keystrokes are independent in order to simplify the model estima-tion, which results in information loss.

Our work, on the other hand, attempts to capture three types of relationship between users X  behaviors at different keystrokes that are ignored or failed to model until now: 1) State transitions be-tween skipping and viewing. The study on high-resolution query log data revealed that a user may choose to either view or skip the suggestion list at each keystroke in a QAC session. It already explored how users X  interactions with QAC engine at the current keystroke, such as typing speed and whether the end of current pre-fix is at word boundary, influence users X  decisions on skipping or viewing. However, besides those factors, we believe that such de-cisions should also be influenced by their decisions on skipping or viewing at the previous keystroke. For instance, imagine a user u has 5 sequential skipping moves in one QAC session and 2 sequen-tial skipping moves in another QAC session, the chance becomes higher for the same user to stop and view the suggestion list at the current keystroke after 5 sequential skipping moves. On the other hands, if the same user has already viewed too many keystrokes continuously but finds no intended query, it becomes more likely that he/she may skip the next one; 2) Users X  real preference of suggestions . For each keystroke, the associated users X  real pref-erence is hard to be detected from the current suggested query list alone. On the other hand, we need to utilize the rankings of suggested query lists of latter keystrokes together with users X  fi-nal click choices to re-rank the suggested queries in the list of the current keystroke. Intuitively, a clicked query, i.e. the user X  X  in-tended query, should get a higher rank not only at the keystroke he/she makes the click, but also at previous keystrokes where this query appears, despite that it is not clicked at that time; and 3) User-specific cost between position clicking and typing . Some users prefer typing than viewing and clicking, while others don X  X . Consequently, users X  click choices are not only affected by their in-tent, but also by the position where the intended query is shown and their preference of clicking that position over typing the remaining keystrokes. For instance, a user that prefers clicking will probably click an intended query the first time it is shown to him/her, despite that it may be shown in a low position; while another user focuses on typing his/her intended query despite that the query already ap-pears in the suggestion list, until it is ranked at the top position, or even worse, he/she will type the entire query manually without any intent to click the suggestions.

To model these three aspects, we propose a probabilistic model, which is a combination of three parts that address each separately. The hidden Markov model part takes the skipping and viewing choices as two different states, and assumes the transition between keystrokes is influenced by users X  interactions with the QAC en-gine at that keystroke. The logistic regression part weighs a set of our designed user-specific relevance features that imply users X  own preference on each prefix-query pair, which is expected to capture users X  real preference. The Dirichlet prior part estimates the ra-tio between position-biased clicking and typing costs. Those three parts together determine the probability that a user clicks a cer-tain suggested query located at a certain position of the suggested query list of a certain keystroke in a QAC session. We develop a mean-field variational inference algorithm to learn the parameters that optimize the data likelihood.

We evaluate our method on high-resolution QAC logs collected from a commercial search engine on both PCs and mobile phones. We compare the performance of our model with some alternative probabilistic models and state-of-the-art QAC algorithms. Experi-mental results show that the proposed method can predict queries that better satisfy users X  search intent. Moreover, the learned model provides us insights into the relationship between users X  behaviors at different keystrokes.

In a nutshell, the major contributions of this paper include: 1. We explore the relationship between users X  behaviors at dif-2. We propose a new probabilistic model that combines three 3. We propose a generic model whose parameters are shared
The rest of the paper is organized as follows. We first introduce related work in Section 2, after that we formally define our prob-lem and introduce the proposed model in Section 3. In Section 4, we develop a fast mean-field variational inference algorithm to op-timize the solution. We then describe and report the experimental evaluations in Section 5, and finally present our conclusions and future work in Section 6.
Query Auto-Completion (QAC). The main objective of QAC is to predict users X  intended queries and assist them formulate a query while typing. The most popular QAC algorithm is to sug-gest completions according to their past popularity. Generally, a popularity score is assigned to each query based on the frequency of the query in the query log from which the query database was built. This simple QAC algorithm is called MostPopularComple-tion (MPC), which can be regarded as an approximate maximum likelihood estimator [1].
 Several QAC methods [1, 19, 18, 21] were proposed to extend MPC from various aspects. Bar-Yossef and Kraus [1] introduced the context-sensitive QAC method by treating users X  recent queries as context and taking into account the similarity of QAC candi-dates with this context for ranking. But there is no consensus of how to optimally train the relevance model. Shokouhi [18] em-ployed learning-based strategy to incorporate several global and personal features into the QAC model. However, these methods only exploit the final submitted query or simulate the prefixes of the clicked query, which do not investigate the users X  interactions with the QAC engine.

In addition the above models, there are several studies address-ing different aspects of QAC. For example, [19, 21] focused on the time-sensitive aspect of QAC. Other methods studied the space ef-ficiency of index for QAC [2, 11]. Duan and Hsu [7] addressed the problem of suggesting query completions when the prefix is mis-spelled. Kharitonov et al. [13] proposed two new metrics for offline QAC evaluation, and [12] investigated user reformation behavior for QAC.

The QAC is a complex process where a user goes through a se-ries of interactions with the QAC engine before clicking on a sug-gestion. As can be seen from the related work, little attention has been paid to understand the interactions with the QAC engine. Un-til recently, Li et al. [15] created a two-dimensional click model to combine users X  behaviors with the existing learning-based QAC model. The study assumed users X  behaviors at different keystrokes, even for the consecutive two keystrokes, are independent in order to simplify the model estimation, which results in information lose. In this paper, we attempt to directly model and leverage the relation-ship between users X  behaviors, so as to improve the performance of QAC.

Click Models. This work is related to click models. In the field of document retrieval, the main purpose for modeling users X  clicks is to infer the intrinsic relevance between the query and document by explaining the positional bias. The position bias assumption was first introduced by Granka et al. [9], stating that a document on higher rank tends to attract more clicks. Richardson et al. [17] attempted to model the true relevance of documents by imposing a multiplicative factor. Later examination hypothesis is formalized in [5], with a key assumption (Cascade Assumption) that a user will click on a document if and only if that document has been examined and it is relevant to the query. In addition, several exten-sions were proposed, such as the User Browsing Model (UBM) [8], the Bayesian Browsing Model [16], the General Click Model [23] and the Dynamic Bayesian Network model (DBN) [4]. Despite the abundance of click models, these existing click models cannot be directly applied to QAC without considerable modification. The click model most similar to our work is [22], which models users X  clicks on a series of queries in a session. However, because of the main difference between QAC and document retrieval, our model is very different from [22].
In this section, we first introduce the concept of the high-resolution QAC log, and then propose appropriate models to predict how likely a user will click a certain query at a certain location in a QAC session.
Traditionally, the search query log only includes the submitted query and its associated search results, while it does not contain the sequential keystrokes (prefixes) users typed in the search box, as well as their corresponding QAC suggestions. In order to better an-alyze and understand real users X  behaviors, a high-resolution QAC log is introduced and analyzed in [15], which records users X  inter-actions with a QAC engine at each keystroke and associated system respond in an entire QAC process. For each submitted query, there is only one record in a traditional search query log. However, in the high-resolution QAC log, each submitted query is associated with a QAC session , which is defined to begin with the first keystroke a user typed in the search box towards the final submitted query. The recorded information in each QAC session includes each keystroke a user has entered, the timestamp of a keystroke, the corresponding top 10 suggested queries to a prefix, the anonymous user ID, and the final clicked query.

Let us take a toy example to briefly introduce how a user interacts with a QAC engine and makes the final click in an entire QAC ses-sion. As shown in Figure 1, a QAC session contains S keystrokes and each keystroke has a suggested query list of length D . session ends at the keystroke where the user clicks a query in the suggested query list, or when the prefix at that keystroke is exactly the query the user enters into the search engine. Among the S  X  D slot s in each QAC session, where each slot q ij is indexed by the i -th position at the j -th keystroke, a user clicks at most one of them, although the user intended query may appear in many slots. Since users X  clicked queries are usually their intended queries, appropri-ate modeling of users X  click actions can be a good solution of the QAC problem. The ideal QAC engine should be able to rank the user intended query higher with less keystrokes or short prefixes. In this work, we leverage such a QAC log data to get a better un-derstanding of user X  X  sequential behavior in the QAC process.
We view the QAC problem, which predicts a user X  X  intended query, as the problem of predicting the query the user will click. Unlike existing works on query auto-completion, which paid no attention to those non-clicked suggested queries at the keystrokes before users X  make clicks, or failed to straightforwardly analyze
We experiment with real-world QAC logs where D = 10 . and reveal the difference between click cases and non-click cases, our paper proposes a model which predicts the most likely slot a user will click in each QAC session by capturing the relationship between users X  behaviors at different keystrokes.

To predict how likely a user will click a certain slot, there are mainly three issues we need to solve:
We use Figure 2 to illustrate how the above three issues together determine users X  click choices among all potential slots. Figure 2 shows a QAC session which contains S (=4) columns/keystrokes, and each keystroke contains D (=4) positions, thus makes a total number of 16 potential slots to click. Among those 16 potential slots, the queries in 12 of them do not satisfy the user X  X  intent, thus the user will not click it anyway. On the other hand, the user X  X  intended query appears in the other four slots, where each keystroke contains one appearance. The user viewed the suggested query lists at both the first and second keystrokes, however, the intended query is ranked at a relatively low position, which the user failed to pay attention to, or thought this position costs him/her too much effort to click, thus he/she didn X  X  click it. At the third keystroke, although the intended query is ranked at the top position, the user didn X  X  view this suggestion, thus he/she missed the information and failed to click. Finally, at the last keystroke, the user viewed it, found his/her intended query lies at the top position, and then he/she clicked that query.
In the following, we show how to better address the above is-sues by taking the relationship between users X  behaviors at differ-ent keystrokes into account. We also introduce some analysis con-ducted on the real-world high-resolution QAC log, to show why our proposed ideas are reasonable.

Skipping or viewing a keystroke? Existing works [2, 1] mostly failed to address the first (and the third) issue since they lack the information of users X  interactions with a QAC engine before mak-ing a click, i.e., the high-resolution QAC log. Generally, it is as-sumed that a user makes a decision to either viewing or skipping at each keystroke, which depends only upon the user X  X  interaction with the QAC engine at that keystroke. Based on its definition that  X  X kipping behavior happens when the final clicked query is ranked within top 3 in the suggestion list of any of the prefixes except the final prefix X  as introduced in [15], we count the sequential appear-ance of skipping and viewing states statistically on a real-world high-resolution QAC log collected from a commercial search en-gine, and find that 78.4% of the states are followed the same type of states. Thus the transitions between skipping and viewing states are not random, and the error of inferring state type based only upon user behavior at that keystroke can be significant. Thus, our paper, on the other hand, assumes that the user X  X  decision will also be influenced by his/her decision at the previous keystroke besides his/her interaction. As shown in Figure 1, we use a hidden Markov model to capture such influence, and take viewing and skipping as K = 2 states. We assume that T state transition rules exist in the observed QAC logs, where each rule is actually a probability ma-trix corresponding to a certain type of viewing/skipping behavior. Users X  interactions with the QAC engine, such as typing speed and reaching word boundary, at the current keystroke influence their choice of transition rules at this keystroke. For instance, for a fast typing user, the probability of transition from skipping to skipping can be very small. When a user reaches a word boundary, he is very likely to follow the transition rule where the probability of transition from skipping to viewing is significant. Assuming T user interaction patterns lie in the entire QAC log, and each user inter-action pattern  X  0 t corresponds to one state transition rule  X  keystroke, we analyze a user X  X  interaction with the QAC engine and find which interaction pattern it belongs to, then choose ac-cordingly the corresponding move transition rules. We use features introduced in [15] to describe users X  interactions with the QAC en-gine, and denote those interaction features as X 0 .

How to capture users X  intent? We adopt logistic regression (LR) to model how likely a query satisfies a user X  X  intent under the current prefix. Existing works [15] already demonstrated a set of relevance features, which characterize the relevance between a certain prefix-query pair, to be effective in predicting the user X  X  in-tent given certain prefixes. However, we find those features not enough due to two drawbacks: 1) those features mainly reflect the general interest of majority of users, and care little about users X  personal history and preference; and 2) those features rarely imply the relationship between different prefixes, which makes them dif-ficult to utilize users X  preference of queries in the suggested lists of other keystrokes to improve the ranking at the current keystroke. As shown in Figure 1, a user X  X  intended query, should get a higher rank at previous keystrokes where this query appears, despite that it is not clicked at that time. Actually, the real-world QAC log shows that 29.4% of users X  submitted queries (this number counts redundant appearances) have been submitted more than 3 times by a user, while among those queries, only 18.4% of them has been submitted multiple times by more than 25% of users, i.e. different users favorite different query sets. Thus, besides existing features, we also employ a set of user-specific relevance features, which are designed to capture users X  personal preference of queries and their corresponding relationship with keystrokes.

We summarize these search behavior features in Table 2. Our features generally originate from statistical counting of users X  inter-actions with the QAC engine in their own historical sessions. For each user, given a certain query, we measure the number of times the same query has been clicked by that user in the past (denoted as Query Clicks). For users who have some queries daily issued, such as  X  X acebook X  or  X  X outube X , this feature is capable of predicting Figure 2: How Users Choose to Click Suggested Queries.
 Feature x Description
Query Length The average length of queries a user
Query Word Num-ber
Query Clicks The number of clicks a user makes on the
Prefix/Query Ratio The percentage of the appearance of PQLR his intent at the first few keystrokes. We also measure the average length of queries the user has clicked in the past (denoted as Query Length), the average number of words in queries that a user clicked (denoted as Query Word Number). In addition, we define the ratio between the length of a prefix and that of a query as Prefix/Query Length Ratio (PQLR) , and calculate the distribution of the associ-ated PQLR of queries the user clicked in the past. For each new coming query, we estimate the percentage of the appearance of the associated PQLR in the user X  X  history (denoted as Prefix/Query Ra-tio). PQLR is supposed to capture a user X  X  preference of typing when taking the query length into consideration.

Clicking a position or continue typing? In addressing the third issue, we find it very necessary to take a user X  X  tendency of viewing and clicking a certain position or continuing typing into consid-Symbol Description S The number of keystrokes in a QAC session.

D The number of suggested queries at a keystroke. x The relevance features. x 0 The interaction features.  X  The bias of viewing and clicking each position. z Whether a query is clicked.  X  Feature weights of the relevance features.  X  t ,  X  0 t The t -th move transition pattern and the associated eration. On the real-world QAC log, we find that when a user X  X  intended query (the click this user finally clicks in a QAC session) is ranked within the top 2 positions, 37.6% of them will be clicked by users. On the other hand, if this intended query is ranked out of the top 2 positions, only 13.4% of them will be clicked by users. Furthermore, such tendencies can be very different for different groups of users. For mobile users, 42.9% of intended queries will be clicked if they are ranked within the top 2 positions, otherwise, 23.0% of them will be clicked. While for PC users, 35.1% of in-tended queries will be clicked if they are ranked within the top 2 positions, otherwise, 11.7% of them will be clicked. Here we can clearly find that on mobile, users are more likely to make clicks when their intended queries appear on the suggestion lists, even if they are ranked at low positions, while PC users prefer typing, since typing on PC is much more convenient than on mobile.

We use a D -dimensional Dirichlet prior  X  to learn the relative cost ratio of viewing and clicking a certain position against typ-ing. Such a prior allows each user m to have distinguished posi-tion bias  X  m in the preference of viewing and clicking than typing. Users who prefer clicking than typing will have a higher average clicking/typing cost ratio (CTCR) than users who prefer typing than clicking. The gaps of CTCR between high position and low posi-tion of users who rarely click suggested queries in low positions are generally larger than those of users who tend to click their intended queries the first time they are suggested no matter how lower their positions are.

Let us consider a typical scenario where M users issue M cor-responding query sequences, where for each user m , the QAC log records N m QAC sessions. The n -th QAC session of user m con-tains S m,n keystrokes, where each keystroke contains D suggested queries. In total, each QAC session has S  X  D potential slots where a user can click, and we use z m,n,s,d = 1 to denote that a user clicks the slot ranked d at the s -th keystroke, and z m,n,s,d erwise. We also use x m,n,s,d to denote the relevance feature of a prefix-query pair, where the prefix is at the s -th keystroke and the query is ranked d at that keystroke. Then given the weights  X  of those relevance features, we can derive the relevance score of each suggestion as  X x m,n,s,d . In addition, we use x 0 m,n,s user X  X  interaction with the QAC engine at the s -th keystroke.
Based on our proposed solution of the listed three issues and above definitions, finally, we present our generative model as fol-lows: Notice that the proposed model is a combination of three parts that address the listed issues respectively. We name this probabilistic model as relationship-based click model (RBCM). To better illus-trate the generative process of the proposed RBCM model, we show the flowchart of user behaviors in Figure 3.

Under our RBCM model, the joint probability of the click information Z = {{ z m,n } N m n =1 } , the relevance features X = {{ x m,n } N m n =1 } , the user interaction features X 0 and latent variables {  X  1: M , X ,Y } can be written as follows:
In this section, we derive a mean-field variational Bayesian in-ference algorithm for our proposed RBCM model.
Under the RBCM model, given observations of both click in-formation Z = { Z m } = { z m,n } N m n =1 , the relevance features X , and the user interaction features X 0 , the log-likelihood for the complete data is given by log P ( Z,X,X 0 |  X , X  0 , X , X  0 , X  ) . Since this true posterior is hard to infer directly, we turn to variational methods [3, 14], whose main idea is to posit a distribution over the latent variables with variational parameters, and find the settings of the parameters so as to make the distribution close to the true pos-terior in Kullback-Leibler (KL) divergence. Our paper chooses to introduce a distribution of latent variables q specified as the mean-field fully factorized family as follows: where q 1 is a multinomial, q 2 is a Dirichlet, and {  X , X , X  the set of variational parameters. We optimize those free parame-ters to tight the following lower bound L 0 for our likelihood:
Under a coordinate descent framework, we optimize the lower bound as in Eqn (1) against each variational latent variable and the model hyper-parameter. For variational latent variables, we have the following process
We use a variational expectation-maximization (EM) algorithm [6] to compute the empirical Bayes estimates of the Dirichlet hyper-parameters  X  and  X  0 in our RBCM model. This variational EM al-gorithm optimizes the lower bound as in Eqn (1) instead of the real likelihood, and iteratively approximates the posterior by fitting the variational distribution q and optimizes the corresponding bound against the parameters.

In updating  X  , we use a Newton-Raphson method, since the ap-proximate maximum likelihood estimate of  X  doesn X  X  have a closed form solution. The Newton-Raphson method is conducted with a gradient and Hessian as follows: Similar update rules can be derived for  X  0 .

On the other hand, to obtain the approximate maximum likeli-hood estimation of  X  , we employ the stochastic gradient descent to update  X  in each interaction based on the observed click data z , relevance features x , and the inferred latent variables  X  and  X  . On the other hand, the approximate maximum likelihood estimation of  X  will lead to the following update rule,
Our variational inference algorithm, named RBCM, can be in-terpreted intuitively in the following way. The CTCR distribution  X  of each user is determined by both the topic prior and the accu-racy that the learned weights of relevance features predict users X  in-tended queries. Users X  viewing/skipping states  X  at each keystroke is determined by the influence from users X  states at the previous keystroke and that from users X  states at the next keystroke. The state transition at each keystroke is determined by the transition prior, users X  interaction patterns at that keystroke, and users X  states at that keystroke and the keystroke before that. The probability of the interaction of a user m at the s -th keystroke in the n -th QAC session belonging to interaction pattern k is jointly determined by the state transition between the current and the next keystroke and the user X  X  interaction at the current keystroke.

In our mean-field variation inference algorithm, the computa-tional cost of inferring variational variables is O ( N  X  where  X  S is the average number of keystrokes in a QAC session, and N = P m N m is the total number of QAC sessions in the entire high-resolution QAC log. The computational cost of the es-timation of Dirichlet hyper-parameters is O ( M  X  D ) . The compu-tational cost of the estimation of weights of relevance features is O ( N  X   X  S  X  D ) , while the cost of the estimation of user interaction patterns is O ( N  X   X  S  X  T ) . Thus the total computational cost of our algorithm is O ( N  X   X  S  X  ( T + D )) . Since T and D are both small constants, we can view the computational cost as linear in the total number of keystrokes in all sessions in the QAC log.
We evaluated our RBCM model on real-world data sets, and compared the performance with the following baselines: three al-ternative probabilistic models that only use two parts of the pro-posed model and four state-of-the-art QAC algorithms: Alternative-A: This model does not use the hidden Markov model to capture the state transition of skipping/viewing moves. The state of skipping/viewing is determined by users X  interactions with the QAC engine only.
 Alternative-B: This model avoids using user-dependent features in the logistic regression part to capture users X  real preference of suggested queries. It only utilizes user-independent features in the logistic regression part.
 Alternative-C: This model avoids using a Dirichlet prior to model users X  CTCR. Instead, it assumes users have no pref-erence in clicking different positions as well as typing, i.e., the probabilities of clicking any positions and typing are all equal, and user X  X  clicked suggestion is drawn via z Multinomial(LR(  X x m,n,s,d )) .
 MPC [1, 18]: This method, named MostPopularCompletion, is a widely used baseline in Query Auto-Completion, and employed as one main feature in many QAC engines.
 UBM [8]: This User Browsing Model proposes a number of as-sumptions on user browsing behavior that allows the estimation of the probability of observing a document. It depends on statistical counting of prefix-query pairs, thus unable to predict unseen prefix-query pairs.
 BSS [10]: This Bayesian Sequential State model uses a probabilis-tic graphical model to characterize the document content and de-pendencies among the sequential click events within a query with a set of descriptive features. This is a content-aware model, which is able to predict unobserved prefix-query pairs.
 TDCM [15]: This is a two-dimensional click model which em-phasizes two kinds of user behaviors. It consists of a horizontal model, which explains the skipping behavior, and a vertical model that depicts the vertical examination behavior.
We conducted extensive experiments on two real-world high-resolution QAC logs that collected from a commercial search en-gine. The first data set, which we name LargeQAC , contains high-resolution QAC logs from May 2014 to July 2014. The collection consists of a sample of 7.4 million QAC session from about 40,000 users over a 3-month period. We randomly selected a subset of ac-tive users who submitted over 500 QAC sessions during this period, and collected their corresponding search activities, including the anonymized user ID, query string, timestamp, and the clicked URL. As a result, we collected 3,954 users with 2.6 million queries, and their activities span from 22 days to 3 months. According to differ-ent platforms (PC or mobile phones), we split the entire dataset into two subsets. One is PC, which contains 1.6 million QAC sessions, while the other is mobile phones, which contains 1.0 million QAC sessions.

The second data set is also collected from a commercial search engine. We name this data SmallQAC to distinguish it from the previous one. This data set is constituted of random sampled high-resolution QAC logs dating from Nov 2013 to Jan 2014. The log contains 125 thousand QAC sessions from PCs. Since existing QAC algorithms utilizing high-resolution QAC logs have already shown rich results on the QAC log, we utilize both data sets to evaluate our proposed model and compare with the state-of-the-art methods in the following section. Model Fitness. This section evaluates the fitness of our proposed model on real-world data, and compares our model with proba-bilistic model based methods. We split the data based on the time information: the QAC sessions occurred in the first 90% of the time period are used as the training data, while the remaining 10% used as the test data. Table 3 shows the log predictive likelihood on ses-sions falling in the final 10% of the total time of QAC log data. Ac-cording to Table 3, RBCM fits the real-world data better than the three alternative probabilistic models and TDCM. This illustrates that in the proposed RBCM model, all three parts play an important role in capturing the relationship between users X  behaviors at dif-ferent keystrokes. Alter-A performs the worst among all three alter-native probabilistic models, which shows the importance of using the Markov process to model the state transition between skipping and viewing. Alter-B performs the best among three alternative probabilistic models, which shows that user-specific features do not fully utilize the relationship between users X  behaviors. The reason may be that, even when the relevance features and their associated weights fail to reflect users X  real preference of suggested queries, the other two parts of the proposed model can reduce the harm of those mispredictions by inferring reasonable skipping/viewing states and user-specific CTCR. TDCM performs the worst, since it fails to utilize the relationship between users X  behaviors from any aspects.
 Query Auto-Completion. To evaluate the effectiveness of the proposed model in suggesting users intended queries in each QAC session, we compare the proposed model with both alternative probabilistic models and state-of-the-art QAC algorithms. All compared methods re-rank the suggested queries at each keystroke and compete to rank the intended query as high as possible. In the proposed RBCM model, we use the relevance model part LR(  X  X x ) to re-rank the suggested queries. We employ the Mean Reciprocal Rank (MRR) as the relevance measurement, which is a widely used evaluation metric in measuring QAC performance [1, 18, 15], where Q is the set of queries a user finally submitted, and rank denotes the rank of the query q in the suggested query list.
Notice that among the suggested query lists of all keystrokes, those lists that do not contain users X  finally submitted queries are removed from our experimental analysis. Since our experiments are conducted on high-resolution QAC data, we report both the av-erage MRR score of all keystrokes, and the average MRR of the last keystroke only, since this is the keystroke where the user X  X  click occurs. Notice that existing works which didn X  X  make use of high-resolution QAC logs usually used the MRR of the last keystroke to measure their performance. In the following experiments, the whole dataset is divided evenly into a training set and a test set for different settings.

Figure 4 compares the proposed model with alternative proba-bilistic models and state-of-the-art QAC algorithms by MRR. We can observe that RBCM performs the best among all compared ap-proaches, and outperforms existing QAC algorithms by over 6%, for all the data sets and different settings. The advantage of RBCM over Alter-A illustrates the necessity of modeling the transition be-tween skipping and viewing. The learned transition rules work for both existing users and new coming users, thus can provide better query suggestions for new coming users than TDCM, which mod-els no relationship between users X  behaviors at different keystrokes. In addition, the three alternative probabilistic models generally perform better than existing QAC algorithms. Such phenomenon demonstrates the effectiveness of making use of the relationship between users X  interactions in different keystrokes in solving the QAC task. Essentially, appropriate modeling of such relationships together makes the proposed model much better than those alterna-tive baselines. In specific, the advantage of Alter-B over TDCM illustrates that for those unseen prefix/query pairs, the proposed model can also achieve a sound performance, which attributes to the skipping/viewing transition and the user-specific preference of position clicking and typing captured by the proposed model. Be-sides our proposed model and its alternatives, TDCM performs bet-ter than the rest of existing QAC algorithms, which we attribute to (a) LargeQAC (all keystrokes) (c) SmallQAC (all keystrokes) the usage of high-resolution QAC logs. BBS outperforms UBM since it adopts the content-aware relevance model. MPC performs the worse, since it pays little attention to users X  behaviors in QAC logs. By comparing with the performance using all the keystrokes and last keystroke only, we find that the advantages of the proposed model are ever more significant when measured by MRR@All. It indicates that the proposed model can recommend user intended queries higher when only a few keystrokes have been typed. State Transition of Skipping/Viewing. Based on the state transi-tion matrices and the corresponding user interaction patterns that learned by the proposed RBCM model from real world QAC logs, we provide a detailed analysis on the difference of transition rules between skipping/viewing and the associated user interaction pat-terns. Among all learned state transition rules, we pick two of them which differ the most in probability. Figure 5 shows the state tran-sition rules and their corresponding user interaction patterns, where each block is the transition probability from the previous state (ver-tical) to the current state (horizontal). Intuitively, we find Figure 5(a) represents skipping user s, i.e., users who prefer skipping than viewing, as these users have a much higher probability to skip at the current keystroke no matter the previous state is skipping or viewing, while Figure 5(b) represents viewing user s, i.e., users who prefer viewing than skipping, because these users are more likely to switch to the viewing state from previous skipping or viewing status. Notice that skipping and viewing user s only refer to the tendency of users X  at each keystroke. A user who always skips sug-gested query lists will behave like skipping user consistently, while a user who has no habit in querying may alternatively switch be-tween skipping and viewing user s from time to time.

From Figure 5, we find that no matter what the state of the cur-rent keystroke is, skipping user s are more likely to skip the sug-gested query list of next keystroke than viewing user s. On the con-trary, viewing user s are more likely to view the suggested query list of next keystroke than skipping user s under all circumstances. We also find that no matter which type a user belongs to, if he/she already viewed the suggested query list of the current keystroke, he/she will be more likely to skip the next keystroke than that un-der the situation where he/she skipped the current keystroke. More-over, the corresponding user interaction patterns of different state transition rules appear quite different. Skipping user s generally have faster typing speed, and come across less word boundaries, and enter more navigational queries.
 Users X  Real Preference of Suggested Queries . We use this series of experiments to discuss how our designed user-specific features enable the proposed model to understand users X  real preference of suggested queries. We compare the proposed model with Alter-B on the QAC task measured by MRR, so as to illustrate the impor-tance of using user-specific features. From Figure 6, we find that the proposed model performs better than Alter-B in recommend-ing users X  queries that satisfy their intent. In addition, we list a subset of learned weights of those designed user-specific features in Figure 7. From here, we can find that the history of queries that a user clicked plays a very important role in predicting the fu-ture queries he/she will click, especially when certain prefixes are given. Meanwhile, the length of the queries a user used to click is a significant signal for learning users X  real preference of queries in the suggested query lists. The reason can be that such a signal im-plies users X  clicking habit from some aspects. A skipping user who always clicks long queries will probably ignore his/her intended queries shown to him/her, before he/she enters enough number of keystrokes. Under such situation, the signal of query length will be capable of capturing users X  real preference at keystrokes with short prefixes, which enables the proposed model to rank the in-tended queries at higher positions than those shorter queries. On the other hand, when a user has no preference in clicking long queries, (a) LargeQAC (all keystrokes) Figure 7: Weights of Relevance Features Learned by RBCM. Indice of selected user-specific relevance features: 1-Query Clicks, 2-Query Length, 3-Prefix/Query Ratio, 4-Query Word Number. The values of weights are scaled to the range of [0 , 1] to clarify the comparison of relative importance of different features. this signal will not take effect, and the proposed model will recom-mend popular queries according to the frequency of the occurrence of prefix-query pairs. Such suggested queries are usually not that much longer than the given prefixes.
 User-specific Cost Between Position Clicking and Typing . Based on the latent variable  X  learned by the proposed model, we analyze the specific cost balance between position clicking and typ-ing of different users. We select two subsets of users: one named typing user , which is formed by the top 20% users with the high-est average click positions, and another, clicking user , is formed by the bottom 20% users with the lowest average click positions. We calculate the averaged CTCR of both two subsets of users, sep-arately, and plot the results in Figure 8. From here, we find that the learned CTCR  X   X  X  of typing user s and clicking user s have very different distributions. Although users from both subsets are most likely to click the top query of a suggested query list, clicking user s also occasionally click queries located at the middle positions of a suggested query list, while typing user s rarely click those positions.
Furthermore, we try to distinguish the difference between typ-ing user &amp; clicking user and viewing user &amp; skipping user . We select the top 20% users with the largest percentage of viewing states , and the bottom 20% users with the smallest percentage of skipping states. We compared the selected subsets of typing user s with skip-ping user s, and the selected subset of clicking user s with viewing user s. Table 4 shows the overlaps of the two pairs of compared subsets. According to Table 4, we find that there exists overlap be-tween typing user s and skipping user s, clicking user s and viewing user s. For users sharing the same tendency of skipping/viewing Table 4: Overlap between typing user -skipping user pair and clicking user -viewing user pair state choices, the difference of users in choosing clicking and typ-ing becomes smaller. Skipping and typing are two reasons that a user does not click his/her intended query when it appears. Skip-ping users are more likely to click upper position queries, but this is not always true. A user who owns a high typing speed may not only prefer skipping than viewing but also prefer typing than click-ing. However, he/she may also click the intended query the first time he/she views it.
 Case Study of Query Auto-Completion. Now we show a few examples that illustrate how RBCM recommends users queries that better satisfy user intent by capturing the relationship between users X  behaviors at different keystrokes. Figure 9 shows a QAC ses-sion where a user finally submitted  X  X tar wars X , which is the user X  X  intended query in this session. From Figure 9, we can find that the proposed model generally ranks users X  intended queries higher than TDCM, especially at keystrokes with shorter prefixes. For example, with the prefix  X  X t X , RBCM ranks the intended query at the position 3 while TDCM ranks it at the position 10. The rea-son is that the proposed model utilizes the user X  X  preference of the clicked queries at the last keystroke to improve its ranking at shorter keystrokes in the future by modeling the relationship be-tween users X  behaviors at different keystrokes. Our designed rel-evance features show that the query  X  X tar wars X  has been issued many times by this user. Thus, although for the entire user col-lection, the generally frequencies of the appearances of  X  X tar wars X  are relatively low given short prefixes, such as  X  X t X  or  X  X ta X , the proposed model ranks this query at the higher position for the spe-cific user than other users who rarely search  X  X tar wars X . We also notice that queries of similar intent, such as  X  X tar wars the old re-public X  and  X  X tar wars episode 7 X  are also ranked higher by our proposed model than by TDCM, which emphasizes that our model can better capture users X  personal interests. Actually, through the analysis of the historical log of this particular user, we can find that he/she is a science fiction fan, which explains why our model also ranks  X  X tar trek X  higher than TDCM. Thus we can conclude that appropriate modeling of such relationships is critical for predicting users X  intended queries given short prefixes. Figure 9: Case Study: The position of list queries from top to down shows the ranking of suggested queries predicted by TDCM, while the number tagged with # behind each query shows its ranking given by the proposed model. The yellow box highlights the user X  X  intended query, and the green box high-lights queries satisfy similar user intent. Notice that  X  X  X  is the cursor.
In this paper, we have presented a probabilistic model to solve the query auto-completion (QAC) task by capturing the relationship between users X  behaviors at different keystrokes in high-resolution QAC logs. The proposed model integrates three parts, each ad-dressing a single aspect of the above relationship, and illustrates how the three parts together determine users X  final click decisions. We have applied the proposed model to predict users X  intended queries on real world high-resolution QAC logs collected from a commercial search engine, and compare it with several alternative approaches. Experimental results show that the improvements of our proposed model are consistent, and our model achieves the best performance. In future work, it would be interesting to consider more complex relationships between users X  behaviors at different keystrokes. For instance, we could increase the number of states from simply skipping or viewing to viewing to a certain position d , which enables a more precise modeling of users X  behaviors in QAC.
This work is supported in part by NSF grant IIS-1116886.
