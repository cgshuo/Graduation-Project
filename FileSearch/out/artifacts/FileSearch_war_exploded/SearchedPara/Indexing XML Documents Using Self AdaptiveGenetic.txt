 Extensible markup langauges are widely used for publishing data on the web. The number of XML documents on the web is growing enormously and hence there is a need for search over the XML documents to retrieve keywords. Keyword search over large document coll ections has been extensively used for text and HTML documents [1] and it has two main drawbacks. First, Search engines are not as intelligent as their users. For example, a keyword search Kevin Database Tech-nology will retrieve documents in which Kevin is the author and also documents in which Kevin is mentioned in the references with equal priority, though the former is more semantically relevant to the user. The second drawback is that keyword queries are inherently flexible in nature and can produce large number of results. The results are of varying relevance to the user and they need to be ranked. The time taken to rank the results should be a small portion of the total query execution time. In contrast, a structured query language will retrieve only the most relevant results, but the complex query syntax makes it unsuitable for naive. Thus an approach which has the flexibility of keyword queries that still retains the accuracy of a query language would be most suitable.

GA is an evolutionary process where at each generation, from a set of feasible solutions, individuals are selected such that those with higher fitness value have a greater possibility of reproduction. At each generation, the chosen individuals undergo crossover and mutation to produce populations of successive genera-tions. The selection chooses the best indi viduals for crossover. With crossover the characteristics of the parents are inherited by the individuals in the next generation. Mutation helps in restoring lost or unexplored regions in the search space. These three operator s are inspired from the biological process of evolution and can find possible solutions even in a large problem space.
 Contributions: We have made use of Self Adaptive Migration Model Genetic Algoritms to learn the tag information. This information is used to distinguish between the frequently used and the less frequently used tags. We have also proposed an index structure that stores the frequently and less frequently stored tag information seperately. Consider the XML document fragments, a n excerpt from a health-care record.
Consider a keyword search Vinu salbutamol over the XML document in Table 1. A standard HTML search engine would consider the whole document in Table 1 as a suitable response, due to the presence of both the terms in the search query. However, in XML environment the two search terms occur as totally unrelated elements in the document as they belong to the medical records of different patients. In the XML document of Table 2 the keyword penicillin appears in two different contexts; first it is associated with the &lt; administer &gt; tag and then with the &lt; drug allergy &gt; tag and the tag name preci sely categorizes between the two occurrences. Additi onal information like name, record identifiers are also explicitly captured using application specific self explanatory tags. This is useful in keyword search over XML documents. Thus exploiting the tagged and nested structure of XML can help in effect ive knowledge discovery. We describe in this paper, an architecture, implementation and evaluation of a search engine for retrieving relevant XML document fragments in real time. Extensive research has been done on stru ctured declarative queries over XML documents. A structured declarative query is supported by XQuery [2], which is analogous to SQL queries over relational databases. Though XQuery can achieve perfect precision and recall, they requir e user to learn query semantics and in cases where the user is unaware of the document structure, a search cannot be performed. An improvement over XQu ery that has elegant syntax and se-mantics is developed in [3]. Informatio n retrieval techniques can consider XML documents as normal text documents, with additional markup overhead. There are several ways of handling the tags. For simplicity the tags can simply be ignored but the document loses its semanti cs, leading to lower retrieval perfor-mance. When tags are taken into consider ation, search can retrieve documents containing certain tags, o r certain words. Keyword search over XML documents falls under this category. Keyword search over XML documents is supported by XKeyword [4], XRANK [5] and XSEarch [6]. All these keyword search tech-niques have elaborate ranking schemes. The simplicity of the search queries i.e., keywords make these techniques suitable for nave users. But, precision and re-call values tend to suffer and the extensive ranking function employed acts as an overhead during query execution. In XRANK [5], the hierarchical and hy-perlinked structure of XML documents are taken into account while computing the ranks for the search results. A ranking technique at the granularity of XML elements is considered here. XRANK can query over a mix of XML and HTML documents. XSEarch [6] introduces a con cept known as interconnected relation-ship. However, checking for the interco nnected relationship is a huge overhead during runtime. Moreover, XSEarch suffers from drawbacks similar to other key-word search engines: unimpressive precision and recall values. In our proposed SAGAXsearch algorithm, the association of Self Adaptive Genetic Algorithms with keyword queries ensures high accura cy i.e., very few non-relevant fragments (high precision) and most of the relevan t fragments (high recall) will be selected as results. In this section, we briefly describe the XML data model and the keyword query semantics for search over XML documents.
 Data Model: The Extensible Markup Language (XML) is a human readable, machine understandable, general syntax for describing hierarchical data, appli-cable to a wide range of applications. XML allows users to bring multiple files together to form a compound document. The XML document consists of nested elements starting from the root and corre sponding associated values. The XML document can be considered as a directed, node-labeled data graph G =( X, E ). Each node in X corresponds to an XML element in the document and is char-acterized by a unique object identifier ,anda label that captures the semantics of the element. Leaf nodes are also associated with a sequence of keywords. E is the set of edges which define the relationships between nodes in X .Theedge ( l, k )  X  E , if there exists a directed edge from node l to node k in G .Theedge ( l, k )  X  E also denotes that node l is the parent of node k in G .Node l is also the ancestor of node k if a sequence of directed edges from node l leads to node k . An example XML document tree is shown in Figure 1.
 Query Semantics and Results: Let the XML document tree be called  X  .Let x be an interior node in this tree. We say that x directly satisfies a search term k if x has a leaf child that contains the keyword k and x indirectly satisfies a keyword k if some descendent of x directly satisfies the search term k .Asearch either directly or indirectly. For exam ple, in the XML tree shown in Figure 2, inproceedings(1) satisfies the search term Vipin and the search term Vipin 1979 but not the term Vipin 1980 . The nodes obtained as result should also be semantically related. Semantically related nodes are nodes that appear in the same context; for example, an author and the title of his book having the inproceedings ancestor node. A mathematical measure of semantic relationship is given in section 6. The various steps in the working of SAGAXsearch are enlisted below. 1. A representative training set is chosen to assist the genetic learning of tags. 2. The keyword queries and the relevant s earch results are collected from the 3. The genetic algorithm retrieves the tag combination which can answer a 4. Separate indices are built for the frequently used and occasionally used tag 5. A search over the XML documents in the decreasing order of importance of 6. The search produces only semantically related results. The characteristics of XML documents is that they include extensible tags for formatting the data. The Self Adaptive Migration Model Genetic Algorithms [7], is used to identify the tags which are frequently used and distinguish them from those which are ocasionally used. The architecture of the genetic learning system is illustrated in Figure 2.

In simple GA, the three basic operators of GA namely, selection, crossover and mutation are fixed apriori. As the individuals evolve through generations, these operators remain constant. A new breed of GA called adaptive GA [8] adjusts the values of the operators based on the fitness of the individual in the population. Such an adaptive GA can exploit previously discovered knowledge for a focused search on parts of the search space which is more likely to yield better results and at the same time can search over the unexplored regions. In migration model GA, instead of a single population, a set of populations is evolved. The basic operators of GA are applied independently for each population and at some regular intervals; individuals are exchanged between populations for a more diversified search.

The Self Adaptive Real coded GA to learn the tag information is adaptive in three aspects. The first parameter that is adaptively changed is the size of each population. The population size is determined by the fitness of the best individual in the population compared to the mean fitness of the population. The number of individuals in the population P i is updated as, where t is used to represent the time in generations. With this update, the size of the population grows when the fitness is greater than the value of the mean fitness and vice versa. Thus, the algorithm is more explorative in the problem space where there is more likelihood of finding the solution. Though the number of individuals in each population varies, the total number of individuals in the ecosystem remains the same. The second parameter that is dynamically updated is the mutation rate and is given by,
Using this update we see that, if the number of individuals in a population is less than the size of the mean population then the mutation rate is increased in order to make the search more explorative. In contrast, if the size of the mean population is smaller, then the mutation rate is decreased. The final pa-rameter that is adaptive in the algorithm is the rate of migration. Migration refers to copying individuals from one population to another. Migration helps in discovering new schemas generated by the crossover of two populations. In the algorithm, migration occurs only when the average fitness of the populations remains unchanged between two generations. Thus, when populations have at-tained a steady state, migration occurs to try and discover a new schema.
The selection operator tries to improve the quality of the future generations by giving individuals with higher fitness, a greater probability of getting copied into the next generation. Here the assumption is that parents with higher fitness values generate better Offspring. The purpose of SAMGA is to select from the tag pool, the tag combinations which are interesting to a user. The user has to first issue a set of search queries q = { k 1 ,k 2 , ...k m } . The documents satisfying the search terms are retrieved as result s. The user has to classify the results relevant to him. This is the feedback given to the system in order to learn the user interest. The fitness function used in the GA is given by, where N is the number of documents retrieved with a specific tag configuration, S tag is the set of top k tags with highest tag weights. freq ( i, S tag ) is the frequency of occurrence of the terms of the query q = { q 1 ,q 2 , ...q m } within the tags in S tag in the i th retrieved document . The retrieved documents are ranked according to the frequency of occurrence of the terms. The rank ( i ) denotes the rank of the i th retrieved document provided the document is also classified as relevant by the user.  X  is a parameter that is used to the express the degree of user preference for accuracy of the search results or th e total number of documents that are retrieved. The selection operator used in the algorithm is stochastic universal sampling . Here individuals of the population are assigned contiguous segments on a straight line based on their fitness values. Let b be the total number of individuals selected, which are placed on equidistant points over a line. The dis-tance between the points is given by 1 b . Such a selection scheme has a zero bias and minimum spread, and is found suitable for our algorithm. The recombina-tion operator used is intermediate recombination, where the variable values of the offspring are around and between the variable values of the parents. Geo-metrically intermediate recombination produces variables with a slightly larger hypercube than that defined by the parents but constrained by the values of  X  . A real valued mutation operation is also applied in the algorithm to explore new regions and make sure that good genetic material is never lost. Consider a representative training set with n documents on which keyword search is to be performed. Let q = { q 1 ,q 2 , ...q m } be a collection of typical user queries where q i represents the i th query and m is the total number of queries. A brief overview of SAMGA [7] is illustrated in Table 2.

After the algorithm determines the frequently and the less frequently used tags, the information within the frequently used tags is stored in an index called Most frequently used Index (MFI) and the information within the occasionally used tags is stored in an index called Less frequently used Index (LFI). The granularity of search over XML documents is not at the document level, but at the node level in the XML document tree. Hence, an identification scheme for the nodes in the document tree is required. This is accomplished by encoding the position of each node in the tree as a data value before storing it in an index. Given the identification values of the nodes, the scheme must also be able to reconstruct the original XML tree. An identification scheme called Hierarchical Vector for Identification ( hvi ) is derived.

Let x be a node in the XML document tree  X  . Then the Hierarchal Vector unique identification number assigned to the XML document tree  X  ,and p ( x )is and s j ( p ) denotes the j th sibling of the parent p . With this identification scheme, each node captures its absolute position within the whole document. The hvi of a node identifies itself and all its ancestors. The hvi of various nodes in two XML documents are shown in Figure 3(a) and 3(b).

It can be observed that if  X  1 , X  2 , ... X  n represent the XML document trees of the documents with identification numbers (1, 2, 3,... n ), where n is the number x ,hvi ( x i ) = hvi ( x j ) } , that is, there exist no two distinct nodes among all the XML documents in the collection, such that they have the same hvi .Thesame can be observed from Figure 3(a) and 3(b).
 Relationship Strength: Let hvi ( x i )and hvi ( x j )representthe hvi of two distinct nodes x i and x j , existing in the XML document tree  X  . The length of the longest common prefix( lcp ) for both the hvi is denoted as lcp ( x i ,x j ). Consider two keywords k 1 , k 2 . The relationship strength between these two keywords, satisfies k 1 and x j directly satisfies k 2 . The condition that the node should directly satisfy the keyword ensures that only those nodes satisfying the keyword and also having the longest length of their identification vectors ( hvi ), are selected while evaluating the Relationship Strength(RS). For example, in the document trees in Figure 3(a) and 3(b), the nodes A and B have a common prefix of length two. Thus, they have a RS value of two; similarly nodes A and C have an RS value of one. Whereas, nodes A and D have an RS value zero since they belong to different document trees.
 Semantic Interconnection: In terms of the XML document tree, two nodes are semantically interconnected if they share a common ances tor and this ances-tor is not the root of the document tree. As an illustration, consider the XML document tree in Figure 1. The keywords Vipin and 1979 have a common ances-tor, inproceedings (1). Thus, they are semantically interconnected. Whereas the keywords Vipin and 1980 have a common ancestor, dblp (0), which is the root of the document tree. Hence, the two keyw ords are not semantically connected. Thus, two keywords k 1 and k 2 are semantically interconnected if and only if, RS ( k 1 ,k 2 ) &gt; level i +1,where level i is the first such level in the document tree where the degree of the node is greater than one.

For example, in the XML document tree in Figure 3(a), since level i =0,RS must be greater than one for the nodes to be semantically relevant. The nodes A and B have an RS value of two and are semantically relevant. Whereas, nodes A and C have an RS value of one, and hence are not semantically relevant. 000
Let q = { k 1 ,k 2 , ...k m } be the search query where k i represents the i th term in the query q and m represents the total number of terms in the query. The algorithm to find the semantically interc onnected elements is given in Table 3.
The search algorithm first checks the length of the keyword query. If the query consists of a single term, a search ove r the MFI is performed. If the search is not successful, the algorithm continues search over the LFI. A failure to retrieve results from both MFI and LFI implies that the term is not found. The same technique is extended when searching with queries having more than one term. The only change is that, at each stage the semantic interconnection of the results is checked. Only semantically interconn ected nodes are considered as the search results.
 The Self Adaptive GA used in SAGAXsearch takes a small number of user queries (10-20 queries) and the documents adjudged as relevant by the user as inputs. The input documents to the GA are XML fragments from the DBLP XML database [9]. The GA tries to explore all possible tag combinations from the DBLP database and tries to find the best tag combination which satisfies the maximum number of queries. The experimental result in Figure 4(a) shows the average fitness for the generations of population. Note that the fluctuations in the curve representing Self Adaptive Migration model GA (SAMGA) is because of the adaptiveness introduced in the mig ration rate and population size. For SAMGA the average fitness steadily raises until about the fifteenth generation and then the fitness increases slowly. As the generation progresses further, the increment of fitness falls, as most of the individuals have already converged to their best fitness values. In contrast, a Simple GA (SGA) fails to converge even after 20 generations. Thus, the application of SAMGA helps in faster convergence when compared to SGA.
Table 4, shows the tag weights of the top four tags with the largest tag weights at the end of every five generations. It can be observed that the tags like when compared to the other tags. Query execution time using the MFI and the LFI (partitioned index) and the normal index is shown in Figure 4(b). It can be observed that the partitioned index has lesser query execution time and hence is more efficient.
 Precision and Recall: Precision of the search results is the proportion of the retrieved document fragments that are relevant. Relevance is the proportion of relevant document fragments that are r etrieved. For precision and recall, we compare SAGaXsearch with XSEarch [6] and the naive results. Naive results are those which satisfy the search query, but are not semantically interconnected. All these techniques yield perfect recall i.e., all relevant documents are retrieved and the precision values vary. This is because of the factor that apart from the relevant results, some irrelevant results are also retrieved. The precision values of SAGaXsearch are found to be higher than those of XSEarch and naive approaches, when compared with the DBLP XML dataset. The small loss in precision occurs when the same keyword s are present in both the MFI and LFI and the intention of the user is to retrieve information from the LFI. In such cases, the algorithm has already retrieved the results from the MFI, it will not continue search over the LFI. The possibility of such an event is quite rare, and hence SAGaXsearch manages to exhibit high precision values. The comparision of precision values of these techniques is shown in Figure 5.
 We have proposed a framework for information retrieval from XML documents that uses tag information to improve the retrieval performance. Self Adaptive Mi-gration Model Genetic Algorithms, which are efficient for search in large problem spaces, are used to learn the significance of the tags. The notations for relation-ship strength and semantic relationship help in efficient retrieval of semantically interconnected results as well as ranking the search results based on the prox-imity of the keywords. Experiment on real data show that the SAGaXsearch is accurate and efficient.

