 Many applications require executing  X  X ind-si milar-object X  query in their transactions, which implies the computation of similarity between objects. As an example, thinking about clustering a collection of documents, we should compute the similarity scores of each pair documents first. In collaborative filtering, similar items are clustered based on their similarities [6]. 
In many real-world domains, linkage among objects can be the most useful infor-mation for similarity measuring. One obvious example is the WWW. Due to the lim-ited effect of understanding web pages automatically, link analysis is still a popular approach to exploit the web structure. If we treated these object-to-object links as edges, the real-world domain can be best described as a heterogeneous graph. In this paper, we focus our research target on the similarity computation of link graph, which is the abstract model of many real-world domains. 
There have been many similarity computing methods [2, 3, 4, 5], which will be in-troduced in related work. Thereinto, Jeh and Widom [2] propose a notable method are related to similar objects X . SimRank provides a wonderful definition for similarity on a link graph, but unfortunately, it computes the similarity between every pair of objects, which results in high complexity in both time and space. 
The study of real-world datasets indicates that block structure naturally exists among objects. Taking the web graph for example, web pages of host A are more likely to cite pages belonging to the same host A . Viewing a host as a block, the web graph can be regarded as a block structure, and the similar phenomenon can be found in other domains. As another example, based on the statistics of words frequencies occurring in articles, the density of linkages between collections of articles and words is shown in Figure 1(a) (adapted from Figure 2 in [7]). Taking advantage of the block structure, we propose an algorithm called Block-graph into blocks properly; (2) compute the similarity of each block-pair; (3) for each block, use SimRank to obtain local similarity scores; (4) estimate the  X  X nter-block X  nodes similarity using block-pair similarity and local similarity. 
Comparing with SimRank , our method can significantly speed up the identification of similar objects. SimRank computes the similarity of each node-pair. However, BlockSimRank only computes the similarity between blocks and the similarity be-tween nodes in the same block. The similarity between nodes in different blocks is estimated reasonably. For example, in a link graph shown in Figure 1(b), we can gain its transition matrix shown in Figure 1(c) . Because most edges are intra-block links, only the dense area of transition matrix (d iagonal area in Figure 1(c)) is worth consid-ering. For a graph having n nodes, supposing this graph has m blocks and let d denote the average number of neighbors, the time complexity of SimRank and BlockSimRank When setting m properly, the least time cost of BlockSimRank is O ( n 4/3 ). Experiments on real datasets are conducted to test the accuracy and efficiency of BlockSimRank . By partitioning the link graph, our method can remarkably speed up the similarity computation and win great advantage in efficiency with the accuracy retained, compared with other methods such as SimRank and SimFusion [4]. The rest of the paper is organized as follows. Section 2 surveys related work. In Section 3, we exploit the block structure of link graph in real domains. Afterwards, Section 4 describes the BlockSimRank method and explains its theoretical model. The results of experiments are shown in Section 5 and this study is concluded in Section 6. Similarity measuring has been extensively studied in different disciplines for a long time, with multiple methods proposed [2, 3, 4, 5, 9]. Traditional approaches that cal-culate the similarity of documents using Vector Space Model (VSM) (included in [3]) and its variations can be viewed as a general algorithm, which map documents and queries into a vector space. They differ in how the vectors are constructed and how weights are assigned [4]. These methods are useful to compute the similarity between the external information about objects (e.g., the references among documents). 
In some situations, linkages among objects can be the only or the most explicit in-formation available. Many datasets are heterogeneous [1], in which there may be multiple object and link types, and are best described as networks or graphs. Naively applying traditional approaches may bring on invalid conclusions. 
Some researchers use multiple relationships to compute the similarity between objects based on different theoretical foundations. In the WWW, [5] explains an ap-proach using hyperlinks among pages to calculate the similarity of web objects. To realize the global ranking of objects in a static graph, Jeh and Widom [2] proposed a strategy called SimRank , in which the similarity between two objects is updated itera-tively by the average similarity between objects linked with them. For example, in Figure 1(b), the similarity between a and d (defined as S ( a, d )) is decided by the simi- X  X andom surfer-pairs X , a concept derived from PageRank algorithm [8]. Unfortu-datasets. The authors of [2] also discuss a pruning technology to approximate SimRank , but it is a challenge to select the right node pairs in initial stage. 
Yin et al. [7] proposed a hierarchical structure called SimTree to represent similari-ties between objects in a compact way. SimTree only computes and stores the simi-obtains great efficiency compared with SimRank . Besides, Xi et al. [4] use a Unified Relationship Matrix ( URM ) to represent a collection of heterogeneous objects and their interrelationships. By iteratively computing over the URM , they present a simi-larity-calculating algorithm called SimFusion . SimFusion can effectively integrate relationships from multiple sources to measure the similarity, and takes O ( kn 2 d ) time, where d is a constant with respect to n . 
In this issue, Sun et al. [9] proposed a correlation degree computation approach for relevance search and anomaly detection, which combines random walk and graph partitioning together to improve scalability. Although the principle of [9] is similar to our work, it is only suitable for bipartite graph, while our method is applicable to arbitrary graph, even if this gr aph is not a connected graph. 
Our method, BlockSimRank , is originated from the observation of block structure concealed in the link graph. A similar work has been done by [11], which exploit the block structure of the web for computing PageRank . The underlying model of Block-SimRank based on random walk [10], a concept that simulates walkers randomly surf the graph along edges; and k -way graph partitioning, a method introduced by [12], which is a high-quality and computationally inexpensive refinement algorithm. Our method can be mainly applied in link-based object ranking. The taxonomy or hierarchical categories ar e ubiquitous among data objects in many domains. Usually, two objects of the same type are more similar than objects in dif-ferent categories, and it makes similar objects gathered into the same block. represents the number of intra-block links of A . We take For Example, in Figure 1(b), the value of R ( A, B ) is 1/5. Block Structure of the Citation Graph. Considering a corpus of scientific papers, each paper can be regarded as an identically distributed node, and the references or cited-by relationships correspond to edges between nodes. Our dataset is crawled from ACM Computing Classification System (CCS) [13], which is a subject classifi-cation system for Computer Science. Taking Section F in ACM CCS for an example, there are 6 main categories in it, and each category includes some subtopics. 
Treating each category as a block, We use R ( A, B ) defined in equation (1) to repre-papers in that category. The block structure of citation graph is shown in Figure 2. Block Structure of the Web Graph. The WWW is naturally modeled as a huge graph, with nodes representing pages and edges representing hyperlinks. We do a crawl of the ruc.edu.cn in July 2008 to generate a link graph for analysis. This graph contains roughly 45,000 nodes, and more than 0.5 million links with ineffectual hyperlinks (links citing other pages out of the graph) removed. To investigate the structure of the web, we use the terms given in Table 1. 
A similar work has been done by Kamvar et al. [11] by using dot-plots to visualize the link matrix at page level. Our work is done at host level (Figure 3 (a)) and direc-tory level (Figure 3 (b)) based on the measurement of links flow among blocks. A view of nested block structure is shown in Figure 3, by filling plots with different cates that most links are  X  X ntra-block X  links. 4.1 Preliminaries Transition Matrix. Given a undirected graph G ( V, E ), supposing there is a random surfer standing on node a , he has identical probability to visit each node direct-weights may be imported to represent varying importance of links, but it X  X  not the key point of our work. We only focus on undirected graphs and it X  X  easy to extend our method to directed graphs. 
A transition matrix or stochastic matrix is introduced to describe the transition probability of a Markov Chain [14]. We define transition matrix T as a square matrix each of whose rows consists of nonnegative values, with each row summing to 1. In an undirected graph, T is symmetric. For example, the transition matrix shown in Figure 1 (c) corresponds to the graph in Figure 1 (b). Based on the block feature we discussed in Section 3, we use to generalize it, where P IJ is the probability matrix between all nodes in block I and all nodes in J . Note that only the dense valued areas (e.g. P AA , P BB and P CC ) have signifi-cant effect on similarity computation. This feature is utilized by our method. Graph Partitioning. The graph partitioning problem is to divide the vertices of a graph into n roughly equal parts, with the number of edges connecting nodes in dif-ferent parts minimized. In our method, blocks are detected by graph partitioning. Many algorithms [12, 15, 16] have been developed to find reasonably partitions. We use the multilevel k -way partitioning method proposed by Karypis et al. [12], whose strategy is performing a k -way partitioning on the smaller graph, and then refine it to construct a k -way partitioning of the original graph. This algorithm partitions a graph G = ( V, E ) in O ( |E| ) time and is implemented in METIS package [18]. 4.2 Assessing Similarity between Nodes Basic SimRank . As algorithm SimRank [2] is closely related to our work, we describe it here. Given an undirected graph G = ( V, E ), we denote the k -th iterative similarity given transition matrix T and initial similarity matrix Sim 0 , we get here is the initialization of ) , ( b a k V V S when k =0. Since we can X  X  foreknow the similar-ity between two objects before iteration, it is reasonable to simply define We give the major steps of SimRank algorithm as follows. Algorithm 1. ( Basic SimRank ) Input : transition matrix T, initial similarity matrix Sim 0 , tolerance factor t. 
Output : c onvergent similarity matrix Sim k . Local Similarity and Global Similarity. Local similarity is the similarity between objects in the same block without considering objects in other blocks. Let LSim ( B ) node-pairs X  similarities in block B , which means given transition matrix P BB (defined LSim ( B ) recursively by Equation (2). As an example, for block A in Figure 4(a), rela-tionships between A and its nodes can be better visualized in another view shown in Figure 4 (b), which indicates LSim ( A ) is a 3-by-3 matrix. Definition 1. ( Block Similarity ) Treating each block as an object, we can compute the similarity between blocks as we do between objects by Equation (2). The transition probability between block A and B is R ( A, B ) (defined by Equation (1)), so we can get transition matrix T . Figure 4 (c) shows an transition matrix between blocks. Let BSim ( A, B ) denote the similarity between block A and B . Definition 2. ( Inter-Block Nodes Similarity ) Inter-block nodes similarity is the simi-larity between nodes in different blocks. Supposing node V a and V b are in block A and B respectively, we define the similarity between V a and V b on the k -th iteration by where ) , ( X V S x k represents the similarity between object x and the center of block X . Usually the center of block X is virtual and hard to ascertain, so we take the average similarity between x and every object in block X to estimate it. That is where |X| is the number of objects in block X . We will explain equation (3) in section 4.4 later. Further study indicates that it X  X  not necessary to compute inter-block nodes similarity on every iteration. Theorem 1. If block similarity and local similarity are convergent, inter-block nodes similarity will be convergent too. get the Theorem 1 soon from Equation (3). block nodes similarity decided by Equation (3). We call the similarity of any node-pair calculated this way global similarity, and use GSim to denote it. The BlockSimRank Algorithm. The block structure suggests a fast algorithm. We propose BlockSimRank for more effective and efficient similarity computation, and its major steps are summarized as follows: 1. Split the graph into n roughly equal blocks using METIS [18]; 2. For the k -th iteration, regarding each block as an object, compute the Block Simi-larity Matrix using basic SimRank algorithm; 3. Compute the Local Similarity Matrix of each block by basic SimRank algorithm; jump to step 2; else continue; 5. Estimate the Inter-Block Nodes Similarity using Equation (3); 6. Obtain global similarity matrix GSim . 4.3 Complexity Analysis For simplicity, we assume the link graph G = ( V, E ) has n objects and can be split into m roughly identical blocks. Time Complexity. The time consumed by step 1 of BlockSimRank Algorithm usually can be ignored, because it takes O ( |E| ) time and the real graphs are often sparse. The time cost of BlockSimRank is mainly composed of block similarity computation (step O ( kd 2 n 2 ), we write the equation for time complexity of BlockSimRank as follows: k is the number of iteration and d 2 is the average direct-connected neighbor pairs of a block-pair or node-pair (usually a constant with respect to n 2 ). Calculating the deriva-the time complexity is O ( n 4/3 ), that is the lowest. Space Complexity. Since it is not necessary to put the entire global similarity matrix and local similarity matrices. When m = m 0 , the space complexity is the smallest too. 
Our experiment in Section 5 shows that the accuracy is still comparable to the ac-curacy of SimRank when m=m 0 , so it is our suggestion to set m=m 0 when using BlockSimRank method. Besides, the computations of local similarity matrices are independent, which indicates the possibility of parallelization. 4.4 Theoretical Model The block structure implies that a random surf er is more likely to meet another surfer from the same block. The meeting of two surfers from different blocks also needs to model based on two kinds of random surfers: the surfer traveling among blocks (we call it BSurfer ) and the surfer traveling among local nodes (we call it NSurfer ). Random Walk on Two Layers Model. In Figure 5 (a), all nodes belong to the same neighbor pairs and the probability from ( a, b ) to these node-pairs. That is to say, S k ( a, b ) = 0.25( S k-1 ( c, e ) +S k-1 ( c, d ) +S k-1 ( e, e ) +S k-1 ( d, e )). 
If nodes a and b are in different blocks as shown in Figure 5 (b), NSurfer at node a and Nsurfer at node b can X  X  meet without the help of BSurfer . Regarding BSurfer as a transmitter or bridge, the similarity S ( a, b ) is determined by BSim ( A, B ) and the prob-ability from ( a, b ) to block-pair ( A, B ). We use Equation (4) to approximate the prob-ability from object x to its block X . Thus we have the following theorem. Theorem 2. Global similarity of any node-pair in Graph G can be computed based on the Random Walk on two layers model. Proof . Given a node-pair ( a, b ), its similarity is determined by similarities of all its in-neighbor node-pairs (or block-pair) and the probability from ( a, b ) to these node-pairs (or block-pair). We described above an approach for efficient similarity computation on link graph. In this section, the accuracy and efficiency of our approach will be tested, compared with the following similarity measuring methods: (1) SimRank [2], an approach that iteratively computes the similarity of each node-pair; (2) SimFusion [4], an approach that reinforces and propagates the similarity between objects. 
All experiments are performed on a PC with a 1.86G Intel Core 2 processor, 2 GB memory, and Windows XP Professional. All algorithms are implemented using Java. Datasets. A good evaluation of similarity measuring methods is difficult, because the similarity between two objects is hard to ascertain without performing extensively user studies. ACM CCS [13] is a credible subject classification system for Computer Science. It can provide an identification of similar papers by organizing these papers in the same category. Our dataset is crawled from Section F in ACM CCS. With the ineffectual papers removed, we get a citation graph using the reference and  X  X ited-by X  information. This undirected graph has 9549 nodes and 44822 edges. The detailed node number of each category and edge number between each pair of categories are shown in Table 2.
 The Selection of Partition Number m . When partitioning a graph into blocks at the beginning of BlockSimRank algorithm, the number of partitions should be decided. From Equation (5) we know m influences time complexity remarkably. In the mean-time, too many partitions imply too many edges between different blocks, which induce the decline of accuracy. 
There is a trade-off between accuracy and efficiency. The accuracy and the time consumed on each iteration of different partition numbers are shown in Figure 6 (a) and (b) respectively. With the increase of partition numbers, the accuracy descends slowly. As we discussed in Section 4.3, if the assumed conditions are satisfied, when where e is an adjustment factor and in our ACM dataset, e  X  0.4, making m 0  X  150. 
Experiments show that the accuracy of BlockSimRank is acceptable when time cost is the lowest. So we suggest setting m = m 0 when using BlockSimRank algorithm. Accuracy. We use PAM [17], a k -medoids clustering approach, to cluster papers into groups based on global similarity matrix. In the meantime, ACM CCS provides a credible classification on these papers. Comparing these groups with CCS categories, let C denotes the number of correct classified papers, and N denotes the total number of papers. We define accuracy as the ratio between C and N .

In this experiment, we compare BlockSimRank with SimRank and SimFusion on accuracy. We set m = m 0 in BlockSimRank (now time cost is the lowest). As Table 3 shows, BlockSimRank wins slight advantage to other methods, which is because graph partitioning can eliminate noise to some extent. Performances. The motivation of BlockSimRank is exploiting the block structure to improve the performance of SimRank . By partitioning a global matrix into several local matrices, the performance is enhanced markedly. The time complexities on each O ( dn 2 ) respectively, where d is related to n and explained above. 
When we set m = m 0 , the time cost of BlockSimRank is O ( n 4/3 ), which wins notable advantage to SimRank . We list the time consumed on each iteration and the total time before convergence in Table 4. The tolerance factor of convergence is set to be 0.001, which is the maximum difference (explained in next subsection) of similarity scores between adjacent iterations. From Table 4 we can see the improvement of perform-ances from SimRank to BlockSimRank is huge, which is from O ( n 2 ) to O ( n 4/3 ), where n is the node number 9549. Convergence Rate. We measure the convergence rate from two aspects: maximum the tolerance factor of convergence (set to be 0.001), iterative process will finish. 
By analyzing similarity matrices of the first ten iterations of each approach, we get the maximum difference of each iteration shown in Figure 7 (a), and the accuracy of each iteration shown in Figure 7(b). Comparing with other methods, BlockSimRank holds advantage at the beginning of iterative process. Considering the first iteration in Figure 7, the maximum difference of BlockSimRank is the smallest and the accuracy is the highest. This advantage is attributed to graph partitioning, because it can detect potential groups via partitioning a graph into blocks. The similarity between objects in the same block is usually higher than the one in different blocks, which results in more accurate clustering. Due to this advantage, BlockSimRank algorithm has higher convergence rate than SimFusion , and is as fast as SimRank in most cases. In this paper, we propose a high efficient similarity computation method by exploiting the block structure of link graph. Many datasets involve relationships between objects and can be best described as link graphs. Using the block structure implied in the link graph, we propose an algorithm called BlockSimRank , which partitions a graph into blocks, and iteratively computes the similarity between blocks and the similarity be-tween objects in the same block until similarity matrices are convergent, and then estimate the similarity between objects in different blocks properly. The time cost of our method is O ( n 4/3 ), whereas SimRank takes O ( n 2 ) time. Experimental results show BlockSimRank achieves high efficiency and acceptable accuracy in computing simi-larity of a link graph. Acknowledgments. This work was supported in part by the National Natural Science Foundation of China under Grant No. 70871068, 70621061, 70890083, 60873017, 60573092 and 60496325.

