 Driven by growing demand for efficientl y querying and managing large-scale data, the distributed stor age systems have received considerable attention. And a lot of systems are proposed, such as Google X  X  BigTable, Yahoo X  X  Pnuts and Amazon X  X  Dynamo, they store data with key-value model and have scalability and fault-tolerance. But they only support simple key-value queries instead of similarity queries such as range queries and KNN queries. For example, it often happens that a traveler wants to find the restaurants from which the distance is less than 1 km or the two of the nearest restaurants. That X  X  to say, the user needs to issue a range query with range = 1 km or a KNN query with k =2. To support these queries in the large-scale dataset with high-dimensional or unstructured data, an efficient distributed index structure is pressing needed.
As for querying high-dimensional or unstructured data, such as locations, im-ages, micro-blogs, protein sequences, and so on, there are basically two kinds of index structures: vector based index s tructures(spacial access methods) [1,2] and distance based index structures [3,4]. To obtain scalability these index struc-tures are extended by integrating with p2p overlay, and many distributed index structures are proposed. For example, [5] integrates R-tree and CAN overlay, [6] integrates quad-tree and Chord overlay, and [7] combines GHT and Chord over-lay. Unfortunately, existing vector based distributed index structures cannot efficiently query high-dimensional data [5]. What X  X  more, some complex unstruc-tured data cannot be precisely represented by the vector model. Existing distance based distributed index structures [7 X 10] have to select pivots in advance, and if the distribution of data changes after updating, the index structure needs to be totally rebuilt or the performance cannot be guaranteed. That X  X  to say, they are static rather than dynamic.

Hence, a novel distributed index, MT-Chord, is proposed to support range queries and KNN queries for large-scale complex data. MT-Chord integrates Chord [11] based routing protocol and M-tree [3] based index structure by dis-seminating the M-tree index nodes to Chord overly. The contributions of this paper are summarized as follows. (1) A novel distributed index structure, MT-Chord, is presented. (2) A cost model and an adaptive tuning algorithm are put forward which can dynamically definite the optimal number of replicas for each index node and tune it accordingly. (3) Results of extensive experimental studies on real-life datasets demonstrate the efficiency and scalability of the proposed index structure and algorithms.

The rest of this paper is organized as fo llows: Section 2 pres ents related works and Section 3 shows the structure of our index structure. Section 4 proposes the cost mode. Section 5 presents the experimental studies and we conclude in Sect. 6. To satisfy with similarity queries for large-scale data, various index structures are proposed. For example, [6] integrates quadtree index with Chord overlay to enable more powerful accesses to data in p2p networks. [5] integrates R-tree and CAN overlay to process multi-dim ensional data in a cloud system. [12] combines B-tree and BATON overlay to provide a distributed index which has high scalability but incurs low maintenance. They both choose a part of local index nodes to build global index node by computing the cost model. In metric spaces, [13] partitions the data space into clusters and selects a reference point for each cluster, and every data object is a ssigned a one-dimensi onal key according to the distance to its clusters reference object. [9] integrates the idea of [13] and Chord overlay to distribute the storage space and parallelize the execution of similarity search. [8] proposes a mapping mechanism that enables to actually store the data in well-established structures such as the B-tree. [7] proposes a distributed index, GHT* index, which can exploit parallelism in a dynamic network of computers by putting a part of the index structure in every network node. MT-Chord index is a type of distributed M-tree index built on a shared-nothing cluster which is organized by the Chord overlay. The key problem of MT-Chord index lies in query processing and determining the optimal number of replicas of each index node, which are detailed in S ect. 4. In this section the structure of MT-Chord is presented.

Each index node has multiple replicas, and MT-Chord is built by mapping each replica to a Chord node using consistent hashing. Figure 1 depicts some mappings between index nodes and Chord nodes. As shown in Fig. 1, the data are logically organized by M-tree index, while they are physically stored in the Chord overlay. Every index node has at least three replicas. When a new index node is created during object insertion, it is assigned a node ID ( nid ) and initially it has three replicas whose replica ID ( rid ) are 0, 1 and 2 respectively. Each replica is mapped to the corresponding Chord node by a hashing function taking nid and rid as parameters. For example, in Fig. 1, the index node 4 has 4 replicas, and these replicas are mapped to Chord node b , d , g and h through a hashing function H( X ( nid , rid ) X ). As for the hashing function, SHA-1 can be adopted, because it has the capability to map two index nodes with similar ID numbers to totally different Chord nodes [6].

Considering query processing, let rn i denote the number of replicas of the index node i ,where i is the node ID. These replicas are not only used to guarantee the robustness of MT-Chord in case of node failure, but also used to balance the query load. For example, if a client issues a query to a index node i ,firstlythe client randomly chooses a value v  X  [0 ,rn i  X  1], and then sends the query to the Chord node corresponding to H( X ( i, v ) X ), say, n .If n  X  X  location is in the client X  X  cache, the query will be directly sent, oth erwise the location should be acquired by using Chord routing protocol in advance. In the similar way, the query should be sent from n to one or more child nodes chosen by computing the distance between the query and the child nodes, recu rsively, until leaf nodes are reached and the query is answered.

Intuitively, more replicas can increase query throughput by balancing query load, however, at the same time, they increase the cost of update because more data need to be updated. Hence, a balance should be found. Generally for a relatively stable tree index, the index nodes close to root node are more likely to be queried than be updated while for the index nodes close to the leaves it X  X  just the opposite, which make the intent of adaptive replication feasible. To determine the optimal number of replicas for each index node, periodically an algorithm of cost estimation is called as a basis for increasing or decreasing replicas, which is detailed in Sect. 4. Now we consider the cost of replication in the distributed environment. We do this by estimating the number of messages which are relevant to replicas of index nodes in the network. For our index structure, the number of messages is linearly proportional to the number of distance computation, hence it can reflects both network and computation cost.

In query processing, if the number of messages received by a Chord node exceed its processing capacity, the excess messages will be discarded and be reissued. So we can estimate the query cost as: cost q =( qn i rn i  X  cap )  X  H i ,where qn i is the number of queries in a time unit through index node i , cap is the number of messages which the Chord node can process before a timeout happens and H i is the hight of the index node i . When index nodes split or merge and index structure updates, s ynchronization is needed to keep replicas consistent, and A slightly mordified Paxos protocol is proposed to keep replicas consistent during update. One synchronization needs csyn 4  X  (4  X  1)+ rn i  X  3= rn i +9 . messages. We can divide the cost of update into two parts: the cost of splitting and the cost of merging. When an index node need s split, it needs two synchronizations of replicas and one notification to its parent. Similarly, when an index node needs merge, it needs two synchronizations of replicas and two notifications to its parent. So the cost of update is: cost u =[ ps (2  X  csyn + n )+ pm (2  X  csyn +2  X  n )]  X  un , where un is the number of updates in a time unit, ps and pm is the probability of splitting and merging respectively, whic h can be estimated by using the random walk theory [12]. Finally, the total cost of index node i can be summarized as:
After the optimal number of replicas is figured out, the current number of replicas will be set to the value. Three real-life datasets are used in our experiences. YouKu dataset: 500,000 im-ages are obtained from YouKu videos which involve different categories such as film, music, education, and so on. MicroBlog dataset: 1,000,000 micro-blogs are downloaded from Sina and Tencent which are short messages with at most 140 characters. DNA dataset: 8,130,000 protein sequences of length 64 are extracted from the largest, the smallest, and the median chromosome of human MT-Chord is compared with RT-CAN [5]. PeerSim is used to simulate a Chord overlay. All experiments are conducted with JAVA 1.6.0 25 and Intel(R) Core(TM) i7 Quad CPU 870 @2.93GHz and 8G RAM. Performance of Queries. In this experiment, we evaluate the performance of range queries. Figure 2 shows the throughput with the different computing nodes for the three datasets. With increasing of the computing nodes, the throughput grows linearly, which confirms the scalability of MT-Chord. And the perfor-mance of MT-Chord is better than that of RT-CAN. In Fig. 3, different radii are adopted, and as expected, with increasing of the query radius the performance degrades. Performance of Updates. In our algorithm, the process of update is similar to the range query with radius set to 0 and the involved computation cost is con-siderably smaller, so generally its performance is better than that of the range query. As shown in Fig. 4, the performa nce of updates in MT-Chord keeps good because of the adaptive tuning algorithm and is better than that in RT-CAN. Effect of Dimensionality. The dimensionality of YouKu dataset varies from 20 to 100 to evaluate the performance of our index. As shown in Fig. 5 the performance of our index is better than that of RT-CAN and is not as sensitive to dimensionality as RT-CAN, although the performance is slightly degrade with increasing the dimensionality. MT-Chord is a distributed M-tree built on top of the Chord p2p overlay. As far as we know, MT-Chord is the first distributed and adaptive index in metric spaces which doesn X  X  have to choose pivots before constructing the index. MT-Chord in-dex can dynamically tune the number of replicas at the granularity of the index node. A cost model are proposed to estimate the cost. Extensive experiments are conducted, which verify the efficiency and scalability of MT-Chord.
 Acknowledgements. This research is supported by the State Key Program of National Natural Science of China (61033007), the National Natural Science Foundation of China (60973021) , and the Fundamental Research Funds for the Central Universities(N100704001).

