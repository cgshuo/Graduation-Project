 We focus on large graphs where nodes have attributes, such as a social network where the nodes are labelled with each person X  X  job user query pattern. For example, a  X  X tar X  query would be,  X  find a CEO who has strong interactions with a Manager, a Lawyer, and an Accountant, or another structure as close to that as possible  X . Similarly, a  X  X oop X  query could help spot a money laundering ring.
Traditional SQL-based methods, as well as more recent graph indexing methods, will return no answer when an exact match does not exist. Our method can find exact-, as well as near-matches, and it will present them to the user in our proposed  X  X oodness X  order. For example, our method tolerates indirect paths between, say, the  X  X EO X  and the  X  X ccountant X  of the above sample query, when direct paths do not exist. Its second feature is scalability. In general, if the query has n q nodes and the data graph has n nodes, the problem needs polynomial time complexity O ( n n q ) , which is prohibitive. Our G-Ray ( X  Graph X-Ray  X ) method finds high-quality subgraphs in time linear on the size of the data graph.

Experimental results on the DLBP author-publication graph (with 356K nodes and 1.9M edges) illustrate both the effectiveness and scalability of our approach. The results agree with our intuition, and the speed is excellent. It takes 4 seconds on average for a 4-node query on the DBLP graph.
 H.2.8 [ Database Management ]: Database Applications  X  Data Mining Algorithm, experimentation Pattern match, random walk, graph mining
Given a large graph with attributed nodes, how can we quickly find patterns that match, say, the  X  X tar X  query of the abstract? And what should we do when no exact instance of the specified pattern exists?
We propose Graph X-Ray (G-Ray), a fast method that finds sub-graphs that either match the desirable query pattern exactly, or as well as possible. We propose an intuitive goodness score g () to measure how well a subgraph matches the query pattern, and we give a fast algorithm to find and rank qualifying subgraphs. The idea of best-effort is illustrated by an example. Figure 2(a) shows a  X  X ine X  query on the fictitious graph of Figure 1. Since no instance of the query exists, our system returns a  X  X est-effort X  match, as shown in Figure 2(b). Traditional SQL-based methods, as well as more re-cent graph indexing methods, will return no answer when an exact instance of a pattern does not exist.
 Contributions. G-Ray provides a framework and a method for quickly finding the best-effort subgraphs that qualify for a given pattern query on large (categorically) attributed graphs, like author-conference networks (DBLP). Our main contributions are:
Effectiveness: G-Ray returns the best-effort results. That is, the
Scalability: G-Ray scales up linearly (instead of polynomially)
The rest of the paper is organized as follows. Section 2 describes the formal definition of our inexact subgraph matching problem. Sections 3 and 4 provide the overview and details of our proposed approach, respectively. Our experimental results are in Section 5, and related work in Section 6. We conclude the paper in Section 7.
Here, we give the formal problem definition. To start with, we assume that only the nodes in a data graph have categorical at-tributes. We shall use a running example of the fictitious social network of Figure 1, where nodes indicate people, the (weighted) edges indicate volume of communication (e.g., number of phone-calls exchanged), and the shape of each node indicates the job-title.
In this setting, the problem for Best-effort Subgraph Matching is defined as follows Figure 1: A simplified social network with attributes on nodes.  X  X EO X  X  (in Yellow Squares),  X  X EC X  (secretaries, in green cir-cles), etc P ROBLEM 1. Best-effort Subgraph Matching Given: (i) A (large) graph G whose nodes have one categorical at-Find: n matching subgraphs H t ( t =1 ,...,n ), that match the
Next, we will define our goodness scoring function g () , after we define some preliminary, important terms. Notice that the graphs H q and H t are qualitatively different. The nodes of H tribute values (e.g.,  X  X EO, X   X  X awyer, X  etc), while the nodes of the subgraph H t are data nodes (e.g., people like  X  X ohn Smith, X   X  X ane Doe, X  etc).
We say that a subgraph H t (as in Figure 2(f)) conforms to a query graph H q (say, as in Figure 2(e)), if the subgraph has all the appro-priate job-titles, with the correct connections between them, except that some connections may be indirect, including additional nodes. We shall refer to these extra nodes as intermediate nodes, and to this phenomenon as interception . The non-intermediate nodes will be referred to as matching nodes. Thus, node  X 12 X  is an intermedi-ate node in Figure 2(f), because, without it, nodes 11-13-4-7 would form a perfect loop, matching the loop query of Figure 2(e). Simi-larly, node  X 13 X  can be viewed as an intermediate node in the same setting.

Whenever there is a matching subgraph H t we say that its match-ing nodes instantiate the corresponding nodes of the query graph H q , and also that the subgraph instantiates the query. In the ex-ample above (Figures 2(e-f)), node  X 11 X  instantiates the circle node ( X  X ecretary X ) of the loop query graph.
How can we measure the goodness of a match g () between a (conforming) subgraph H t , and a query graph H q ? Intuitively, if two nodes are adjacent in the query graph H q , their matching nodes should have good  X  X roximity X  in the matching subgraph H t are two questions: (a) how to measure the proximity of two nodes in a graph and (b) how to combine all these proximity scores.
For the first question, we propose to measure the proximity r between node i and node j as the score of j on a random walk with restarts, when node i is the restarting node. Once we decide the fly-out probability c (which is the probability of flying to a ran-dom node; e.g., c =0 . 1 [20]), all the r i,j scores are well defined, between any two nodes in our data graph G .

For the second question, we propose to consider only the edges of the query graph, and aggregate the proximity scores r i,j the pairs of ( i , j ) matching nodes, where nodes i and j match nodes of the query graph that are adjacent. For example, in the query and subgraph example of Figures 2(e-f), and treating node  X 13 X  as the intermediate node, the goodness score would be the combination of scores going clockwise on the edges r 11 , 12 , r 12 , and counter-clockwise: r 12 , 11 , r 11 , 7 , r 7 , 4 , r combine these scores? Should we add them? or consider them in triplets of nodes ( X  X hains X )? or in some other way? It turns out that we can take their product, which has a probabilistic interpretation. It is the probability that the appropriate random particles, walking on the full data graph G with restarts, will find themselves on the matching nodes of the subgraph H t .

Mathematically, we define the goodness score g ( H q , H subgraph H t with respect to a query graph H q , as the product of r i,j proximity scores of the matching nodes, taken pairwise accord-ing to the matched edges of H q .
 D EFINITION 1(G OODNESS FUNCTION ). Consider a query graph H q and a conforming data subgraph H t , with matching function m ( i )= v (i.e., data node i matches/instantiates query node v ), then the goodness function g ( H q , H t ) is defined as g ( H q , H t )=
Thus, Problem 1 is well defined. Given a data graph G and a query graph H q , find the best n matching subgraphs (best accord-ing to the aforementioned goodness function g () ).
Problem 1 is polynomial for fixed-size pattern queries. This is prohibitive for large data graphs. Suppose you have a data graph with size n =( | V | ) and a query graph H q with size n q then for a fixed-size n q the subgraph isomorphism problem is poly-nomial O ( n n q ) . G-Ray , on the other hand, has time complexity linearly on the size of the data graph.

There are some additional observations and potential general-izations, before we present an example. In this work, we assume there is only one attribute (eg., job-title), with m possible cate-gorical values ( v 1 =  X  X EO X , v 2 =  X  X anager X  etc, in our example). Formally, the attributed graph G can be described by an n node-to-node matrix W and an n  X  m node-to-attribute matrix G = { W =[ w i,j ] , A =[ a i,k ] } . Each pair of nodes ( i, j ) is asso-ciated with a nonzero weight w i,j if there exists an edge between them. For every node i , it is associated with an attribute vector a i =[ a i, 1 , ..., a i,m ] T : a i,k =1 if node i is labelled with k attribute value; 0 otherwise.

The query H q is another graph (usually much smaller compared with G ). The nodes of H q are labelled with 1-out-of-m attribute values, indicating what kinds of nodes we want to find, while the edges of H q indicate what kinds of connection we require between different nodes. Like G , the query graph can also be denoted by two matrices: as H q = { W q , A q } . Similarly, every resulting subgraph is also denoted by two matrices: H t = { W t , A t } .

Table (1) gives all the symbols used in the paper. Following stan-dard notation, we use calligraphic for subgraphs (e.g., H bold capitals for matrices (e.g., W , A ), and an arrow for column vector (e.g., a i ). Since we have two graphs ( G , H q ) as inputs, for clarification, we reserve i, j as the indices for the nodes in is, ( i, j ) is the index for the edges in G . We reserve k, l as the in-dices for the nodes in H q , where ( k, l ) is the index for the edges in
H q . Node i in G can be uniquely identified by i, a T i in G only has one attribute value k , or we only care for its k attribute value, we denote it as i, k for simplification.
As we mentioned, we allow best-effort matching, in the sense that we allow for indirect paths, when the desirable direct paths do not exist.

Figure (1) gives a simplified social network (who-talks-to-whom) with job title as the node attribute, which can take 1-out-of-4 val-ues:  X  X ccountant X ,  X  X anager X ,  X  X EO X , and  X  X EC X  (short for  X  X ec-retary X ). Thus, the who-talks-to-whom graph G is represented by a 14 node-to-node matrix and a 14  X  4 node-to-attribute matrix A . For example, if we store the attribute values  X  X ccountant X ,  X  X anager X ,  X  X EO X , and  X  X EC X  sequentially, the attribute vector a 4 =[1000] T since node 4 is labelled as  X  X ccountant X  (the first attribute value). Thus, we can identify node 4 in this graph by ei-ther 4 , [1000] T or simply as 4 , 1 (since here every node is only labelled by one attribute value.)
Figure (2) shows some sample queries as well as the correspond-ing results. Fig. (2.a) is a line-query, that is  X  X ind instances of Ac-countant, Manager, SEC and CEO such that, the qualifying Man-ager has strong connection with CEO as well as Accountant; while the qualifying CEO has strong connection with Manager and SEC. X  Fig. (2.b) shows a best-effort match (the connection between node 11 and node 13 is indirect). 1 Fig. (2.d) shows an exact match for the star-query in Fig. (2.c), which says  X  X ind an Accountant, a Man-ager, a SEC and a CEO such that the qualifying Manager has strong connections to the other 3. X  Figures (2.e-h) show some more com-plicated queries and corresponding results. Again, the results are not exact, but best-effort.
If we only wanted exact matches, we could write SQL queries to identify any and all of the patterns in the left column of Figure 2. G-Ray has two distinct advantages: (a) it can allow for best-effort matches (tolerating longer, indirect paths, when direct paths do not exist) and (b) due to our proposed goodness function g () , it can rank the output and avoid flooding the user with a potentially huge number of near-unimportant matches.

On the other hand, our method can easily incorporate SQL, if necessary. That is, we can always use our algorithm together with , rather than  X  against , X  SQL-based methods. For example, if there exist many exact matching results, we can use SQL as a pre-G-Ray to find a few  X  X est X  ones, and/or to rank the results.
Our G-Ray method uses two stepping stones: the random walk with restart idea [16, 20] and the CenterPiece Subgraphs idea [19]. The former is necessary to estimate our proposed goodness func-compute or partially pre-compute the desirable proximity scores r i,j for every pair of nodes ( i , j ). G-Ray is completely independent of how the proximity scores are computed, and thus it can easily take advantage of any fast method, as well as any faster method that may appear in the future.

The other stepping stone is the CenterPiece Subgraphs (CePS), which operate on a plain graph (no attributes on the nodes) to find the few most central ( X  X enterPiece X ) people that are well connected to the k given query nodes. For example, if  X  X mith X ,  X  X ohnson X  and  X  X hompson X  are data mining researchers in a graph where the links represent coauthorship, the query would be who are the researchers that are most central to all three of them? CePS is able to quickly find such central/CenterPiece nodes, and we make heavy use of it.
Since we allow inexact match, there might be two types of nodes in the resulting conforming subgraphs: matching data nodes and intermediate data nodes. The latter are nodes which bridge two matching nodes when no direct connection exists between them.
Given a query graph H q , how should we start looking for promis-ing subgraphs H t , i.e., data subgraphs that may have high goodness score g () ?
Our idea is best illustrated with an example. This time we shall to find good starting points (seed data nodes), like square (CEO)
For the query examples shown here, G-Ray also finds other exact matches, e.g., the subgraph containing nodes 1, 5, 11, 12 for the line-query. For clarity of exposition, we omit them.

G . a nodes surrounded by many circle (SEC) nodes and many hexagonal (Manager) nodes. Say we find that node  X 13 X  is the most promis-ing such CEO node. The measure for  X  X romise X  will be formally defined next  X  and in fact, it is the CenterPiece node of a carefully designed setting.

Once we have decided on a good  X  X eed, X  we want to expand to create a full, conforming subgraph. For the line query scenario above, G-Ray will choose the best neighboring node of the neces-sary type (say,  X  X EC X ), and then look for the best path to connect them. In our example, suppose that node  X 11 X  is the best neighbor-ing node, and G-Ray has to go through node  X 12 X  to connect the CEO at  X 13 X  with the  X  X EC X  at  X 11 X .

The algorithm continues until the seed node  X 11 X  is expanded to a full, conforming subgraph (if possible). By its construction, the resulting subgraph will have a high goodness score.

We can repeat with another seed node, until the user has all n matching subgraphs that he/she requested.

Thus, there are three basic modules in G-Ray :
It can be seen that G-Ray generates the resulting conforming subgraphs H t ( t =1 , ..., n ) one by one. For each subgraph, it first sets H t to be NULL (step 2); every node k in H q is marked as  X  X n-processed; X  and every edge ( k, l ) in H q is marked as  X  X n-processed. X  Then, G-Ray builds the subgraph H t gradually, by the above three modules: Seed-Finder , Neighbor-Expander , and Bridge . In addition, we also need to keep track of the status of the nodes and edges in the query graph H q , which is defined as following: Algorithm 1 G-Ray Require: The attributed graph G , the query graph H q 1: for t =1: n do 2: initialization 3: find matching node i, k by Seed-Finder 4: add i, k to H t , and mark node k in H q as  X  X ouched X  5: repeat 6: pick up a  X  X ouched X  node k in H q 7: for each of k  X  X   X  X n-processed X  edges ( k, l ) in H q do 8: find matching node j, l by Neighbor-Expander 9: find a  X  X est X  path between i and j by Bridge 10: add it to H t ; mark edge ( k, l ) as  X  X rocessed X  11: end for 12: update the status of node k and l in H q 13: until every node in H q is marked as  X  X rocessed X  14: end for
In this section, we provide the details of G-Ray . There are three basic modules of G-Ray , as we mentioned before. In the first two, Seed-Finder and Neighbor-Expander , we find those matching nodes with desired attribute values. The Bridge module identifies intermediate nodes (if necessary) and finds a  X  X est path X  to connect two matching nodes.
 4.1 Seed-Finder Seed-Finder takes the attributed graph G , the query graph and the one attribute value k in H q 2 as input, and outputs a quali-fying seed node i, k in G .

Let g ( H q ,i ) be the goodness function for a given node i, k : g ( H q ,i )
It can be seen that g ( H q ,i ) is the contribution of node i, k to the total goodness function in Equation (1). Thus, if all of k s neighbors have been instantiated/matched, we can just choose seed node i, k by optimizing Equation (2).

However, since the resulting subgraph H t is empty, to ensure that the final subgraph H t is well connected, a matching node i, k should also have high proximity score with some unknown node j, l , even if the attribute value k is not directly adjacent to l in the query graph H q (as long as they are closely related to each other). Moreover, if in the query graph H q , the attribute value k is closely related to two different attribute values l and l , we should give more weight to the attribute value that is more relevant to k . Finally, since the resulting subgraph H t is empty, we really do not know which node j, l in graph G should be referred to. Thus, we relax this quantity to the average proximity score for node i, k w.r.t. all the nodes j, l in graph G .

Formally, g ( H q ,i ) in Seed-Finder is relaxed as follows: where n l is the total number of nodes in G having attribute l ; and r l,k measures the proximity between l and k by random walk with restart on H q (see Table 1).

The pseudo code of Seed-Finder is given in Alg.(2). Note that in step 7, we maintain a global seed list (sl) which contains all the seeds found in the previous subgraphs( H 1 , ..., H t  X  1 we ensure that different subgraphs have different seeds. Algorithm 2 Seed-Finder Require: The attributed graph G , the query graph H q 1: for each l  X  X  q ( l = k ) do 2: compute r l,k 3: end for 4: for each i, k in G do 5: compute g ( H q ,i ) by equation (3) 6: end for 7: return: i = argmax j/  X  sl g ( H q ,j ) 4.2 Neighbor-Expander
Neighbor-Expander takes as input the attributed graph G , the query graph H q , one  X  X ouched X  attribute value k in H partially built subgraph H t . It outputs a matching node i, k in The basic idea of Neighbor-Expander is similar to that of Seed-Finder . However, at this point, we already have the partially built subgraph H t , which distinguishes the two modules.

First of all, since k is marked as  X  X ouched, X  at least some of its edges in H q must have been marked as  X  X rocessed. X  Suppose edge
In this paper, we always choose the attribute value with the highest degree in H q . ( k, l ) is marked as  X  X rocessed, X  there must exist some matching nodes j, l , which can be used in calculating g ( H q ,i ) . Secondly, given a node i, k , while Seed-Finder relaxes its goodness func-query graph H q ,in Neighbor-Expander we do not need this relax-ation to ensure that the final H t is well-connected since the result-ing subgraph H t is already partially built. Finally, while in Seed-Finder the (relaxed) average score (e.g., Equation (3)) is weighed by the proximity between l and k ,in Neighbor-Expander this is not weighted because every l is directly adjacent to k  X  i.e., r does not make much difference.

Formally, the goodness function g ( H q ,i ) in this case is relaxed as Equation (4). Note that the indicator function I ( l, k )=1 if edge ( l, k ) in H q is marked as  X  X rocessed X , and 0 otherwise. Also the whole product is taken among k  X  X  directly adjacent neighbors in H q . The pseudo code of Neighbor-Expander is given in Alg. (3). g ( H q ,i )= Algorithm 3 Neighbor-Expander Require: The attributed graph G , the query graph H 1: for each i, k in G do 2: compute g ( H q ,i ) by equation (4) 3: end for 4: return: i = argmax j/  X  X  t r ( H q ,j )
Bridge takes as input two matching nodes i and j , and the at-tributed graph G . It outputs a  X  X est path X  to connect i and j .
At first glance, we can use the  X  X XTRACT X  algorithm [19] or the display generation algorithm [7]. However, the situation is dif-graph H t grows, some intermediate nodes might be already in the partially built H t , both  X  X XTRACT X  [19] and display generation algorithm [7] will favor such kind of paths because of the total bud-get limitation on the size of the subgraph. However in our problem setting, we forbid such paths. Otherwise, H t might not conform with the query graph H q because of path overlap. More impor-tantly, here we only need to find one  X  X est X  path (rather than multi-ple  X  X est X  paths in  X  X XTRACT X  and display generation algorithm), which enables us to design a more efficient, Prim-like, algorithm. Formally, we define the  X  X est path X  between two matching nodes i and j as the one that maximizes the captured proximity score along the path over the total length of the path. Intuitively, a  X  X est path X  should contribute as much as possible for a particle to reach j from i when it does random walk with restart from node i .

The pseudo code of Bridge is given in Alg. (4). Note that in step 8, if the node v is already in the H t , we will block it.
In G-Ray we use random walk with restart. First of all, the size of the query graph H q (usually less than 10 nodes) is much smaller than the attributed graphs, so the main time cost lies in the random walk with restart in G . In this subsection, we first reduce the total number of random walks with restart by constructing an augmented Algorithm 4 Bridge Require: The attributed graph G , two matching nodes i, j , and the 1: let V be the total node set in G : V = { 1 , 2 , ..., n 2: let X = { i } , d ( i )= r i,i , len ( i )=1 , and Pre ( i )= i 3: for each node u in V do 4: d ( u )=0 , len ( u )=0 5: end for 6: while V is not empty do 7: u = argmax  X  u  X  V d (  X  u ) , move u from V to X 8: for each edge ( u, v ) in G , v  X  V , and v/  X  X  t do 11: end if 12: end for 13: end while 14: Output the path from i to j by tracing back Pre ( j ) . graph (to be described next); and then we use a hybrid strategy to perform only one random walk with restart.

Based on Equations (3 and 4), we will have to perform a lot of random walks with restart. For example, for one item in g ( for a given node i, k , we need n l random walks with restart if edge ( k, l ) has been marked as  X  X n-processed. X  Thus, in total we will need at most ( n q + l  X  X  q n l ) random walks with restart, which might be very time consuming. However, based on the fol-lowing lemma, the number of random walks with restart can be largely reduced. We give the formal definition of the augmented graph , and then follow with an example (see Figure (3)).
L EMMA 1. Given an attributed graph G = { W , A } , construct an augmented graph W as Equation (5). Let r j,i ( 1  X  i, j n + m ) be the steady-state probability that a particle will find itself at node i when it does random walks with restart from node j in the augmented W . Then the following equivalence holds: P ROOF . Omitted for brevity
In the augmented graph W , we refer to the newly added nodes as attribute nodes , and to the original nodes in W as data nodes . Intuitively, we put a directed edge from the attribute node to each of the data nodes having the corresponding attribute value. For example, Figure (3) is the augmented graph for the simplified social network in Figure (1). We introduce a new node for the attribute value CEO; and put a directed edge from this node to both nodes 12 and 13, respectively. For the other attribute values, we process similarly.

In order to measure the average proximity for a given node i w.r.t. all the data nodes having attribute value l in G , (according to Lemma 1) we only need to do random walk with restart from the corresponding attribute node ( n + l ) in the augmented graph Based on Lemma 1, it can be proved that we only need at most 2 n random walks with restart on the augmented graph W .
 Figure 3: Augmented graph for the attributed graph in Fig-ure (1). Small-size glyphs stand for  X  X ttribute X  nodes, and have (directed) connections to the corresponding data nodes.

The most straightforward way to solve one random walk with restart is the iterative method [16], which is simple and accurate. However, it is slow for large graphs. In existing literature, there are many fast/approximate solutions, e.g., BlockRank [12], Fingerprint-based method [8], B_Lin [20], etc. It should be pointed out that these methods are orthogonal to G-Ray  X  i.e., we can choose any of them. In this paper, we use a hybrid strategy. Specifically, we use B_Lin [20] to generate a small fraction of the whole attributed graph G as the so-called candidate graph; and then run the whole algorithm on this candidate graph by the iterative method. As we will show in the next section, this strategy will largely reduce the response time (usually one order of magnitude faster).
We present experiments to answer the following questions:
We use the DBLP dataset 3 to construct the attributed graph, where the nodes are authors and the attribute is the conference name (and year, e.g.,  X  X DD-2001 X ). The node-to-node matrix W is constructed from the authorship ( w i,j is the number of the co-authored paper between author i and j ); the node-to-attribute matrix structed from author-conference relationship ( a i,j =1 if the author i has ever published in the conference j , 0 otherwise). In total, there are n =356,364 nodes; E =1,905,970 edges, and m =12,920 attribute values in the graph.
Selection of the size of the candidate graph is a trade-off be-tween the response time and the quality/goodness of the resulting subgraphs. We perform the following parametric study. For a given size of the candidate graph, we issue a 4-node query and return the top-5 subgraphs. We test different types of queries (line-query, http://www.informatik.uni-trier.de/ ~ ley/db/ loop-query, and star-query). For each type of query, the experiment is run multiple times.

Figure (4) shows the mean log quality/goodness vs. the aver-age response time per subgraph. There is a plateau in Figure (4) at log(goodness) = -30, starting at 3 seconds of average response time. At this point, the size of the candidate graph is 1% of the whole graph. Thus this is the ratio that we use in the remaining experiments. Figure 4: Quality vs. response time. Notice the plateau, start-ing at about 3 seconds.

There are two parameters left, the fly-out probability c of ran-dom walk with restart, and the number of iterations for the iterative method. In all the experiments, c is set to be 0 . 1 and the number of iterations is set to be 50 since no performance improvement is observed with more iterations.
The question is how effective our proposed goodness function g () is, and whether the subgraphs that G-Ray retrieves would agree with the intuition of a domain expert.

Figures 5(a-f) show three queries (star, line, loop) and the result-ing retrieved graphs. In all the cases, the results make sense.
Let us analyze the  X  X tar X  query first, which requests a star-shape group of co-authors, with one author from each of PODS, IAT ( X  X n-telligent Agent Technology X ) and ISBMS ( X  X nt. Symposium on Biomedical Simulation X ). We see that Philip Yu is in the center, with the rest of the matching nodes being well known domain ex-perts (H. Wang of IBM, Mark Zhang for Agents); the connection to biomedical simulation is strained, requiring an interception (by Bing Liu).
 For the line query ( X  X ind a chain of co-authors, from STOC to SIGMOD to ICML to ISBMS X ), again G-Ray retrieves well es-tablished researchers from theory (Charikar), databases (Garcia-Molina), machine learning (Fayyad); and, again, the connection to biomedical simulation is strained, requiring 3 intermediate nodes (in white, or unshaded).

The loop query (KDD, RECOMB, INFOCOMM, and ICML) is also very interesting. There is a gap between KDD96 and RE-COMB00 (biology). In addition, there is a surprising, direct link between biomedical and computer networks (Karp-Shenker). Fi-nally, there is a long path from INFOCOMM00 to ICML93 (prob-ably due to both chronological difference, as well as the lack of interaction between the research communities).
We use different sizes of subsets of the whole DBLP dataset to test how G-Ray scales with the size of the graph. For each sub-set, we randomly generate a 4-node query of different types (star-query, line-query, and loop-query) and return the top-5 subgraphs. For each type of query, we run the experiment multiple times and report the average time. We compared two strategies for perform-ing random walk with restart G-Ray : 1) using the iterative method on the whole subset (Ite-G-Ray ) and 2) using the hybrid strategy as in Section (4.4) (Fast-G-Ray ).

The average response time per subgraph vs. the number of nodes/ edges is presented in Figure 6. It can be seen that in both cases, G-Ray scales linearly with the size of the graphs. More importantly, Fast-G-Ray scales linearly with a much smaller slope. For example, on the full size of graph (356K nodes and 1.9M edges), the average response time per subgraph is 3 seconds , while it takes more than 1 minute for Ite-G-Ray . Figure 6: Scalability of G-Ray . Time versus data graph size. Both versions of G-Ray scale linearly, with Fast-G-Ray (bottom) having significantly lower slope.
Graph matching algorithms vary widely due to differences in the specific problems they address. G-Ray is a fast approximate algo-rithm for inexact pattern matching in large, attributed graphs. G-Ray extends the ideas of connection subgraphs [7] and centerpiece graphs [19, 20] and applies them to pattern matching in attributed graphs. This work is also related to the idea of network proximity, which builds on connection subgraphs [13].

While there has been a large amount of work on graph matching over the past 30 years, much of it is not directly applicable to our problem setting. Many graph matching techniques focus strictly on matching graph structure and do not utilize attributes. Other work focuses on exact matching, but cannot handle inexact matching. Still other methods focus on matching against a database of many small graphs (i.e., the graph-transaction setting) instead of a single large graph (i.e., the single-graph setting). The single-graph setting is more general and algorithms developed for single graphs can be readily applied to the graph-transaction setting, although the con-verse is not true [15]. For additional background on graph matching algorithms, we refer the reader to a recent survey by Gallagher [9].
There has been significant work on inexact graph matching [18, 22, 5], and on matching in the single-graph setting [3, 22, 5, 1]. However, there are relatively few algorithms that combine the three to tackle inexact matching in large, attributed graphs [6, 22, 5, 1]. Furthermore, while these algorithms employ various optimizations to mitigate the computational complexity of the problem, they all exhibit super-linear complexity in the worst case. Unfortunately, it is also difficult to determine the performance characteristics of these algorithms due to a lack of reported results and complexity analysis.

In addition to the graph matching work described above, there is related work of interest in the database and data mining literature. Our work focuses on finding instances of user-specified patterns in graphs. Related problems include discovery of frequent or interest-ing patterns (i.e., graph mining) and inexact querying of databases.
Yan, Yu, and Han propose efficient methods for indexing and mining graph databases based on the occurrence of frequent sub-structures [23, 24]. Jin et al. use the concept of a topological mi-nor to quickly discover frequent large-scale patterns [11]. As with many of the graph matching techniques described above, these min-ing algorithms are designed for graph-transactional databases (e.g., collections of biological or chemical structures) and are not read-ily applicable to the single-graph setting. Cook and Holder [6] and Kuramochi and Karypis [15] propose algorithms for graph mining in the single-graph setting. The empirical evaluation by the latter shows that their method outperforms that of Cook and Holder in terms of runtime on a number of real data sets. Pei et al. [17] take on a somewhat different graph mining task. Their goal is to dis-cover quasi-clique patterns across multiple related graph data sets (e.g., groups of customers with similar behavior across markets). We refer the reader to Chakrabarti X  X  book [4] on Web mining for more information on Web and graph mining techniques.

We also find related work in the area of inexact querying of relational databases. Koudas et al. propose a method for relax-ing relational database queries to accommodate near, but inexact matches [14]. However, this work does not support inexact struc-tural matching. The method will relax attribute value conditions and join conditions, but there is no flexibility in terms of what re-lations are involved in the joins. The BANKS system proposed by Bhalotia et al. enables a user to issue keyword-based queries to a relational database without any knowledge of the underlying database schema [2]. BANKS models database tuples as nodes in a graph, but is restricted to return tree-structured results. G-Ray im-poses no such restriction. In addition, BANKS assesses relevance of results based on the proximity of matching nodes and an infor-mation retrieval inspired weighting scheme. In our method, results are ranked according to the goodness function.
We have addressed the problem of finding best-effort subgraph patterns in attributed graphs. The typical query is, say,  X  find a po-tential money laundering ring, consisting of alternating nodes of businessmen and bankers.  X  To the best of our knowledge, this is the first method that returns best-effort results, even when the exact pattern does not exist in the dataset. The second major characteris-tic of our method is that it scales very well with the database size. Our experiments show that the wall-clock time grows near-linearly with the size of the graph.

We also report experiments on the DBLP dataset (356K nodes, 1.9M edges), where the results agree with intuition, and the wall-clock time is about 3-5 seconds, on a commodity PC.

Future work includes extension to handle attributes on the edges.
This material is based upon work supported by the National Sci-ence Foundation under Grants No. IIS-0326322 IIS-0534205 and under the auspices of the U.S. Department of Energy by Univer-sity of California Lawrence Livermore National Laboratory under contract No.W-7405-ENG-48 UCRL-CONF-231426. This work is also partially supported by the Pennsylvania Infrastructure Tech-nology Alliance (PITA), an IBM Faculty Award, a Yahoo Research Alliance Gift, with additional funding from Intel, NTT and Hewlett-Packard. Any opinions, findings, and conclusions or recommenda-tions expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, or other funding parties. [1] B. Aleman-Meza, C. Halaschek-Wiener, S. Sahoo, A. Sheth, [2] G. Bhalotia, A. Hulgeri, C. Nakhe, S. Chakrabarti, and [3] H. Blau, N. Immerman, and D. Jensen. A visual language for [4] S. Chakrabarti. Mining the Web: Discovering Knowledge [5] T. Coffman, S. Greenblatt, and S. Marcus. Graph-based [6] D. J. Cook and L. B. Holder. Substructure discovery using [7] C. Faloutsos, K. S. McCurley, and A. Tomkins. Fast [8] D. Fogaras and B. Racz. Towards scaling fully personalized [9] B. Gallagher. Matching structure and semantics: A survey on [10] N. Guarino, C. Masolo, and G. Vetere. Ontoseek: [11] R. Jin, C. Wang, D. Polshakov, S. Parthasarathy, and [12] S. Kamvar, T. Haveliwala, C. Manning, and G. Golub. [13] Y. Koren, S. North, and C. Volinsky. Measuring and [14] N. Koudas, C. Li, A. Tung, and R. Vernica. Relaxing join [15] M. Kuramochi and G. Karypis. Finding frequent patterns in a [16] J.-Y. Pan, H.-J. Yang, C. Faloutsos, and P. Duygulu. [17] J. Pei, D. Jiang, and A. Zhang. On mining cross-graph [18] L. Shapiro and R. Haralick. Structural descriptions and [19] H. Tong and C. Faloutsos. Center-piece subgraphs: Problem [20] H. Tong, C. Faloutsos, and J.-Y. Pan. Fast random walk with [21] W.-H. Tsai and K.-S. Fu. Error-correcting isomorphisms of [22] M. Wolverton, P. Berry, I. W. Harrison, J. D. Lowrance, [23] X. Yan and J. Han. gspan: Graph-based substructure pattern [24] X. Yan, P. Yu, and J. Han. Graph indexing: A frequent
