 Privacy-preservi ng data mining has made major advances in the recent years. Many protocols have been proposed for different data mining algorithms such as classification, association rule minin g, clustering, and outlier detection, etc. [1] provides a comprehensive survey. There are two main types of technique  X  perturbation based methods and secure multiparty computation techniques. In the perturbation methods the data is locally perturbed before delivering it to the data miner. Special techniques are used to reconstruct the original distribution (not the actual data values), and the mining algorithm needs to be modified to take this into consideration. The seminal paper by Agrawal and Srikant [2] intro-duced this approach in the form of a procedure to build a decision tree classifier from perturbed data. The second approach assumes that data is distributed be-tween two or more sites that cooperate t o learn the global data mining results without revealing the data at individual sites. This approach was introduced by Lindell and Pinkas [3], with a method that enabled two parties to build a de-cision tree without either party learning anything about the other party X  X  data, except what might be revealed throug h the final decision tree. Typically, the techniques used are cryptographic. While the first approach has known security problems[4,5] and cannot lead to provably secure solutions, the second approach has typically been too computationally intensive. This is especially the case for vertically partitioned data (e.g., [6]), where unlike horizontally partitioned data (e.g.,[7]) little data summarization can be carried out before engaging in the distributed protocol.

So the essential question is  X  how can we mine data in an efficient and provably secure way? Since most data mining deals with aggregates, one way of solving this conundrum is through approximation. It may be possible to create highly efficient provably secure protocols that approximate the answer. In this paper, we present one of the first such approaches. Instead of directly approach one particular data mining technique, we present an approximate protocol for com-puting the scalar (dot) product of two v ectors owned by two different parties. This is very important, since the dot product is actually used as a sub-protocol in many data mining tasks such as classification, association rule mining, etc. As a sample application, we show how a completely secure and efficient association rule mining protocol could easily be created using our protocol. We implement our protocol and demonstrate the sign ificant efficiency and quality of the ap-proximation, and discuss the implications for association rule mining. 1.1 Related Work While there has been a lot of related work in privacy-preserving data mining, due to space constraints, we only focus on the tightly related efforts. Several protocols have been proposed for computing the scalar product[8,6,9,10]. Out of these [6] is an algebraic protocol that requires quadratic complexity though the constituent operations are quite simple. The other protocols all require significant crypto-graphic operations and are significantly (orders of magnitude) less efficient. [11] present a simple sampling based protocol for approximately computing the scalar product that is similar in notion to ours. However, since our protocol is based on Bloom filters, it is more sophisticated, has better bounds on accuracy, and is highly efficient. [12] proposes a techniqu e using bloom filters to do association rule mining. However, here transactions a re represented via bloom filters and the association rule mining is done centrally , where as enable efficient distributed as-sociation rule mining. There is also work on privacy-preserving association rule mining for vertically partitioned data[6,13]. However, by comparison, this is the first secure, highly efficient protocol proposed for this problem.

Securely computing the dot product of two vectors is a very important sub-protocol required in many privacy-preserving data mining tasks. Many secure dot product protocols have been proposed in the past. [6,8,9,10,11]. For comparison purposes, we use the method of Goethals et al., described in [10], as an exact scalar product protocol, since it is quite simple and provably secure. Its runtime is O ( n ) in public-key encryptions. 1.2 Bloom Filters We now give some background on Bloom Filters. Bloom filters have been exten-sively used for various application domains ranging from networking to databases [14]. Basically, a bloom filter represents a set S = { x 1 ,x 2 ,...,x n } of n elements using array of m bits ( m  X  n ), initially all set to 0. For each element x  X  S ,weuse k independent random hash functions h 1 () ,h 2 () ,...,h k () with range { 1 ,...,m } such that the bits h i ( x ) of the array are set to 1 for 1  X  i  X  k .Inthisbasic version, a location can be set to 1 multiple times but only the first change has an effect. To check whether an item t  X  S , we need to check whether all h i ( t )for 1  X  i  X  k are set to 1. If they are not all set to 1, we can conclude that t/  X  S . On the other hand, if all h i ( t )for1  X  i  X  k set to 1, we can assume that t  X  S , with some nonzero probability.

Bloom filters can be used to approximat e the intersection size between two sets. Given two bloom filters with the same m and k values that represent two sets S 1 and S 2 , we can approximate | S 1  X  S 2 | by getting the dot product of the two filters. More precisely, let Z 1 (resp. Z 2 ) be the number of 0s in the filter S 1 (resp. S 2 )and Z 12 be the number of 0s in the inner product, then we can approximate | S 1  X  S 2 | using the following formula [14]: Instead of looking at the computation of the scalar product, we look at a slight variant of this problem  X  checking if the scalar product of two distributed vectors is greater than some threshold. I n other words, given two vectors X 1 and X 2 ,we need to compute whether X 1  X  X 2 = n i =1 X 1 [ i ] .X 2 [ i ]  X  t for a given threshold Algorithm 1. Approximate threshold dot product algorithm value t . This variation is more useful in many applications, such as computing association rules (a s will be seen later).

To do this, we use an approximation based on bloom filters. Note that for a given binary vector X i , we can create a set S i where j is an element of S i if the j th |
S for each X i , we can create the corresponding set S i = { j | X i [ j ]=1 } .Given S i , and k hash functions, we can create a bloom filter of size m for each S i .Let Z 1 (resp. Z 2 ) be the number of 0s in the filter S 1 (resp. S 2 )and Z 12 be the number of 0s in the inner product of the bloom filters for S 1 and S 2 . Using equation 1, we can compute the following approximations:
The above approximations could be used to give an efficient secure approx-imate protocol for checking whether X 1  X  X 2  X  t for given binary vectors X 1 and X 2 and threshold value t . The algorithm 1 gives the details of our secure approximate threshold dot product algorithm. In the algorithm, each party first creates its own bloom filter using the common bloom filter parameters (line: 3). Secondly, they participate in a secure dot product algorithm using their own pri-vate bloom filters and get the random shares of the dot product result (line: 5). Thirdly, each party participates in secure multiplication protocol using their pri-vate Z i values to get the random share of the multiplication result (line: 6). Finally, they combine their local inputs and random shares accordingly to get the final result (lines: 7-9).

We would like to stress that similar secure approximate dot product algorithm could be given using existing secure ln() function evaluation techniques [3] and the equation 2. For secure approximate dot product case, we need to use just one invocation of the secure ln() protocol to get the shares of the ln ( Z 1 + Z 2  X  Z 12 ). Similarly, Z 12 could be computed by using any secure dot product protocol. 2.1 Security It is easy to prove that algorithm 1 is secu re in semi-honest model [15] assuming that the dot product, multiplications and comparison protocols that are used are secure. Below, we give a sketch of the security proof.
 Theorem 1. Given secure dot product, multiplication and comparison protocols, algorithm 1 is secure in the semi-honest model.
 Proof. (Sketch) After secure multiplication and secure dot product protocols, each party only gets random shares. Therefore simulator for each P i could simply generate random values to simulate u i and v i . Since each y i value only depends on the local or publicly known inputs, each party does not learn anything while computing y i values. Finally, each party participates in a secure comparison protocol to learn the final result. Again assuming that comparison protocol is secure, we can provide a simulator for each P i that can just return the final result. Using composition theorem [15], we can conclude our proof sketch. 2.2 Computational and Communicational Cost It is clear from the description of algorithm 1 that we need to use a secure dot product algorithm on binary vectors of size m (i.e., the bloom filters). All the other operations are constant time and do not depend on either n or m .Inour method, we also have an additional cost of O ( nk )( n is the size of the original binary vectors, k is the number of hash functions used for bloom filter) hash function operations to create the bloom filters. As we show in the next section, the hashing cost is negligible compared to expensive public key operations used in the secure dot product protocol. As long as, m&lt;&lt;n , our method would be much faster than the typical implemen tation of a secure dot product protocol. Even more, if more efficient techniques are found for securely computing dot product of two binary vectors, we may just use it to improve our performance even further. The communication cost of our protocol is also much lower, since it is only proportional to m . In the next section, we discuss the appropriate values of m and k that need to be used in practice for efficiency and accuracy. To evaluate the efficiency and accuracy of our approximation algorithm, we de-signed and ran several experiments. W e considered the effects of vector length ( ), vector density ( d ), the actual intersect ion of the two vectors ( i ), and the bloom filter parameters m (length of filter) and k (number of hash functions) on the performance of the algorithm. As an underlying secure dot product proto-col, we used the completely secure homomorphic encryption-based protocol [10]. The Paillier key length was set to 512 bits. The hash functions used were keyed versions of SHA-1 via the HMAC protocol [16]. 3.1 Accuracy Several experiments were carried out t o determine the accuracy of the approx-imate dot product method. The results are depicted in the figures below. Each data point represents the results of 100 trials, depicting the distribution in which the dot product estimates fell. Note that the bars on the figures represent plus or minus one standard deviation from the mean, while the extended lines denote the minimum and maximum error. Error is given relative to the vector length.
Figure 1 shows the accuracy when different parameters are varied. Figure 1(f) gives the default values of the different parameters in all of the experiments. Figure 1(a) plots the accuracy for different values of k (number of hash func-tions). The results show that accuracy actually decreases with increasing k .This is because the distortion in creases while increasing k when the filter is small. In a separate experiment, it was d etermined that an increase in k did increase accuracy for m = 40000, however, this is not a practical use of the protocol, since the Bloom filters would no longer give us the efficiency we desire. Overall, the experiment shows that for both accura cy and efficiency, nothing is gained by increasing k for small filters.

In Figure 1(b), we study the relation o f accuracy with filter length. We can see that the accuracy of the approximation increases as m increases. This makes sense, since as the filter length increases, there is less distortion (and collision) in the data, and more accurate results o ccur. However, even in the lowest case of m = 1000 (95% data compression), the error was no more than 1 . 5% of the vector length, and the average absolute error was only around 9, meaning that with a significant probability, even a high compression ratio can result in high utility.

Next, we study the effect of vector length . Figure 1(c) reports accuracy results when the vector length varies from 1000 to 100000. The figure shows that the relative error decreases as the vector leng th increases. This makes sense since we keep the filter length a fixed percentage of the vector length. A key property of Bloom filters is that increase in vector length requires only sub-linear increase in the Bloom filter length to maintain simila r accuracy. This helps us significantly for large vectors. As can be seen, the relative error was always within 2% of the vector length.

Next, we study the effect of varying the density of the vector. Figure 1(d) shows the relative error when the density was varied from 0% to 65%. The rest of the parameters were kept at the defa ult values. As expected, the accuracy drastically fell off as the density of the vectors increased, although reasonable (within 5%) accuracy could still be ac hieved for vectors as dense as 35%. One interesting thing to note is the fact that at 0% density (that is, no 1 X  X  in either vector) the approximate algorithm will give an exact answer of 0, and there will be no error.

Finally, we vary the vectors to achieve the size of the intersections to be from 0% to 100% of their densities. The results are shown in figure 1(e). The error was, in all cases, less than 1%, although slightly greater error was produced toward the lower end of the intersection spectrum. We hypothesize that this is because the lower end is closer to the  X  X verage X  dot product for two randomly generated 10% dense vectors, and is therefore less distinguishable. On another interesting note, when there was zero int ersection between the two vectors, the approximation function sometimes produced a negative estimate. On the whole, though, the function produced exceptional accuracy, no matter what the actual intersection was. 3.2 Efficiency We also demonstrate the efficiency of th e algorithm. An experiment was carried out on a 2.8GHz dual core AMD Athlon machine with 2 GB of RAM to de-termine the run time efficiency of the approximation algorithm versus the run time efficiency of the exact algorithm. On two vectors of 20000 elements, whose density was 10%, (that is each vector contained 2000 1 X  X ) and whose intersection was 50% of the density (that is, 1000), the exact version took 27 minutes and 51 seconds to run. On the same vectors, the approximation algorithm with bloom filter parameters m = 3000, k = 2, ran in only 4 minutes and 4 seconds.
We also compared the relative run times of the public key encryption used versus the hash functions used in the bloom filter. On average, a single Paillier encryption ( t e )took82 . 454ms, a Paillier decryption ( t d )took81 . 583ms, and the hash function computation ( t h )was0 . 00418ms. Since, with the approximation algorithm, we need only run m public key encryptions instead of the full public key encryptions, we can account for the vast majority of the difference in the algorithms X  run times. In fact, the approximate runtime of the approximate al-gorithm is given by t e m + t d + t h  X  d  X  k . By comparison, the runtime of the exact algorithm is given by t e + t d .Since m&lt; , usually significantly (80-90%), and t h &lt;&lt; t e , the runtime of the approximate algorithm is significantly lower than the exact algorithm. Figure 2 is a chart of the expected run times (relative to the exact algorithm) of the previous experiments varying m , together with the maximum error observed in any run with that given m (relative to the vector length), in order to show the trade-off between accuracy and efficiency. This clearly demonstrates the great accuracy/efficiency trade-off of our algorithm. We now show how the protocol described above would affect the process of privacy-preserving assocation rules mining. We assume that the data is vertically partitioned  X  each site holds some attributes of each transaction, and the sites wish to collaborate to identify globally valid association rules. However, the sites must not reveal individual transaction data.
 The association rule mining problem can be formally stated as follows[17]: Let I = { i 1 ,i 2 ,  X  X  X  ,i m } be a set of literals, called items. Let D be a set of transac-tions, where each transaction T is a set of items such that T  X  X  . Associated with each transaction is a unique identifier, called its TID .Wesaythatatrans-action T contains X ,asetofsomeitemsin I ,if X  X  T .An association rule is an implication of the form X  X  Y ,where X  X  X  , Y  X  X  ,and X  X  Y =  X  . The rule X  X  Y holds in the transaction set D with confidence c if c %of transactions in D that contain X also contain Y .Therule X  X  Y has support s in D if s% of the transactions in D contain X  X  Y . Vaidya and Clifton[6] show that this problem can be reduced to the simple calculation of a zero-one dot product of vectors whose length is the size of the transaction set.

Our experimental results show that the Bloom filter approximation method should apply to association rule mining very well. In terms of accuracy, the Bloom filter approximation method is extremely good for sparse vectors, which tends to be the norm in association rule mining. In addition, the filter length can be increased more gradually for larger vectors, allowing the algorithm to scale better than linearly in terms of efficiency.

As an example, consider an association rule mining whose required confidence is 70%, and support is 7%. Using our protocol, assuming 10% of the sample had entries for a given item on either side, and based on figure 1(e), the absolute least confidence that a selected rule could have is 65%, and the absolute most that an unselected rule could have is 75%, and with a high probability, most selected would have at least 68% and most not selected would have at most 72%. The number of false positives and false negatives, therefore, would be quite small, even given large data compression. The main contribution of paper is an efficient and provably secure protocol that approximately computes the scalar (dot) product of two vectors based on Bloom Filters. We show how this can be used to mine association rules in a privacy-preserving way. Our experim ental results show that protocol is highly efficient, accurate and easily applicable to association rule mining. The dot product is actually useful in many different privacy-preserving data mining protocols be-yond association rule mining. In the future, we intend to explore our protocol X  X  applicability in other tasks. We also plan on extending it to work for more than two parties. Other dimension reduction techniques could also be used to approx-imate the vector space. Using these, the scalar product could also be computed. Different techniques may have different trade offs of security, efficiency and ac-curacy. In the future, we plan to look at these alternatives such as using space filling curves or techniques utilizing the Johnson-Lindenstruass theorem.
