 ORIGINAL PAPER Kunal Sain  X  Abhishek Dasgupta  X  Utpal Garain Abstract Performance evaluation of mathematical expres-sion recognition systems is attempted. The proposed method assumes expressions (input as well as recognition output) are coded following MathML or T E X/L A T E X (which also gets converted into MathML) format. Since any MathML repre-sentation follows a tree structure, evaluation of performance has been modeled as a tree-matching problem. The tree cor-responding to the expression generated by the recognizer is compared with the groundtruthed one by comparing the cor-responding Euler strings. The changes required to convert the tree corresponding to the expression generated by the recognizer into the groundtruthed one are noted. The num-ber of changes required to make such a conversion is basi-cally the distance between the trees. This distance gives the performance measure for the system under testing. The pro-posed algorithm also pinpoints the positions of the changes in the output MathML file. Testing of the proposed evaluation methodconsidersasetofexamplegroundtruthedexpressions and their corresponding recognized results produced by an expression recognition system.
 Keywords OCR  X  Mathematical expressions  X  Performance evaluation  X  Tree matching  X  Euler strings 1 Introduction Opticalcharacterrecognition(OCR)ofmathematicalexpres-sions facilitates automatic transcription of paper-based sci-entific documents into electronic versions. On the other hand, recognition of handwritten (on-line or off-line) mathemati-cal expressions makes entry of expressions (into an electronic document under preparation) easy. However, the commercial products are yet to achieve acceptable performance for rec-ognizing mathematical expressions. Therefore, substantial research is still going on for designing efficient methods to serve the purpose. Papers in [ 1 , 2 , 7 ] provide an introduction to the problem and the advances made in this field.
On studying these research efforts, one may feel that as far as systematic research is concerned the field lacks in cer-tain aspects. Absence of benchmark datasets and strategy for evaluating performance of the competing methods make quantification of the advances difficult. Researchers in most of the cases generate their own private datasets and perfor-mance is generally measured as counting how many symbols and structures (e.g. fraction, root, script, etc.) are properly recognized [ 2 ]. Manual interventions are often involved to measure these quantities or counts, especially to know how many structures are correctly recognized.

Later on, some efforts [ 13 , 5 ] have been made for gen-erating benchmark datasets but a method for judging the capability of an approach is yet to come. Earlier studies like [ 5 , 6 ] report a performance index but they assume that the expressions are recognized following a particular recogni-tion method. Since all competing methods may not follow the same approach for recognition of expressions, it is some-what difficult to use the index described in [ 5 ] for evaluating any expression recognition system in general.

In a recent study, Lapointe and Blostein [ 9 ] pointed out different issues related to performance evaluation of expression recognition systems. This paper attempts to add-ress many of the issues mentioned there and presents a general approach for measuring performance of any expres-sion recognition method. For this purpose, the MathML (Mathematical Markup Language 1 ) representations (using presentation tags) of benchmark expressions are considered. A system undergoing evaluation process takes a test expres-sionasinputandproducesthecorrespondingrecognitionout-put in MathML or T E X/L A T E X format. In case of a T E output, the output string is first converted into MathML for-mat and many freely available utilities 2 exist in the Internet for doing such a conversion. Since any MathML repre-sentation defines a tree structure, comparing two MathML files then becomes a problem of matching two trees. How-ever, matching of trees [ 12 ] is always a non-trivial problem because of its algorithmic complexity and implementation difficulties. We have tackled these problems by considering matching of ordered trees and representing trees by their cor-responding Euler strings as discussed later.

The rest of the paper is organized as follows. Section 2 gives a brief background of the problem. Typical issues asso-ciated with evaluating any expression recognition system are discussed here. Section 3 introduces the terminologies needed to explain the tree matching algorithm. Implementa-tion details, complexity analysis, and computational results are provided in different sub-sections under the Sect. 4 . Section 5 concludes the paper along with a discussion for the future scope of the present study. 2 Background If we look at the aforementioned expressions, we can note certain geometric properties in them. Even without having any definition for geometric complexity it is quite evident that the equation in (a) is the simplest one as it is just like an one-dimensional normal text. To recognize this equation, an OCR task is only to recognize all the five symbols, i.e.  X  a  X , X  =  X ,  X  b  X , X + X , and a = b + c  X  X  X  ( a ) a n = b n + c n  X  X  X  ( b ) a  X  c  X . The equation in (b) is having one level of subscript that gives a two-dimensional nature to the equation. Here, just a symbol recognition task will not help as the OCR has to real-ize that  X  n  X  is a subscript of  X  a  X , and so on. So compared to the recognition of the equation in (a), recognition of the one in (b) is more difficult. Following this argument, the equations in (c) and (d) gradually impose more and more difficulty for an OCR task.

One way to evaluate expression recognition engines is to compute how many test expressions are properly recog-nized. However, in doing so, we treat these cases similarly whether there are just a few errors or many while recogniz-ing an expression. For example, one system may just make a mistake in recognizing the subscript structure in  X  c k n equation in (d) above; while another system may completely fail to recognize the entire expression. Expression level accu-racy will treat these cases similarly.

In fact, a quick review on the state of art of mathematical expressions as highlighted in the previous section shows that ME recognition consists of three main sub-problems: seg-mentation, symbol recognition, and interpretation (or struc-ture recognition). Different systems implement those three sub-problems in different ways, and though, it is indispens-able to evaluate the system not only at expression level but also at symbol segmentation, recognition and interpretation (spatial relations) levels. Many systems avoid explicit seg-mentation (which goes hand-in-hand with recognition) while others prefer to explicitly segment symbols before recogniz-ing them. However, whatever the approach is, the segmenta-tion strategy will have definite effect on symbol as well as structure recognition accuracies. Therefore, two aspects are generally considered namely, symbol recognition and struc-ture recognition .

Computation of symbol recognition accuracy r sy is quite straightforward as it can be expressed as, r
We follow the usual definition of the term symbol as an entity that can be typed with a single stroke on the keyboard or by a single keyword of a markup language like L A T E X. gle symbols. It is true that recognition of all symbols may not have equal complexity. For example, symbols used for scripts, limits, etc. are smaller in their sizes than normal base level symbols. Third or fourth level scripts are often very small in shape. Symbols are often in different styles like, bold, italic, calligraphic, double barred etc. However, con-sidering the capabilities of today X  X  character recognizer it is not unrealistic to expect that a recognition engine will be able to recognize this set of few hundred characters despite the variations in their shape, size and style.

Computation of structure recognition accuracy requires some discussion. So far one approach that is predominant in the previous studies is to compute this accuracy in a way similar to what is followed for computation of symbols rec-ognition accuracy. Such a technique was also followed in [ 2 ] where the accuracy was given as a fraction of the number of properly recognized structures out of the total number of structures. In most of the previous attempts, the accuracy has been measured manually. Some studies as reported in [ 11 , 15 , 10 ] have attempted to separate out different struc-tures like fraction, root, limit, script , etc. from a set of test expressions and then compute how many of the structures in a particular class are recognized properly.

Apart from the aforementioned aspects, the present study would like to add one more attribute while evaluating expres-sion recognition approaches. Let us consider two expression fragments: (1) a i and (2) e c i k . Both of them primarily impose superscript structure. Let the recognition result for the first expression be ai and for the second one be e c i k . Both the results are erroneous. In the first case, the error lies in ana-lyzing the first level script and in the second case, the error is in the second level (or nested) script. Therefore, it would be not judicious if we give more penalty to the second type of error than the first type. The engine making the first kind of error is definitely less efficient than the one which makes the second type of error but not the first type. Note that stan-dard string matching algorithms (say, using the Levenshtein distance) will not help in formulating this kind of perfor-mance index. For the first expression, the truth is  X  X  X  i  X  and the result is  X  X i X . So the Levenshtein distance is 1. On the other hand, the truth for the second expression is  X  X  X {c_k X i} X  and the result is  X  X  X {c X ik} X . Here, the Levenshtein distance between two strings is 3. So  X  X ore the distance, more the penalty X  does not justify this case.

The study in [ 5 , 6 ] attempted to address this problem by defining horizontal levels of each expression symbol. Level value of a base-level symbol is assigned to zero (0). Symbols above the base line are having positive level values increas-ing with level upward, and symbols below the base line are having negative values decreasing with levels downward. For are 0, +1, and -1,respectively. The plan was to tag such a label with each symbol in the groundtruth expression. Dur-ing evaluation if the structure recognition for an k -th level is found to be wrong then a penalty of 1 | k |+ 1 was imposed. Apparently this scheme seems judicious but it gives rise to one major concern in defining the level value for a sym-bol. For example, in the expression  X  e c i k  X ,thelevelsof X  e  X ,  X  k  X ,  X  c  X , and  X  i  X  are assigned as 0, 1, 2, and 3, respectively. Thus, the superscript and subscript of  X  c  X  are getting different level values. So the error in recognition of one script would impose a different penalty from that of the other and this is obviously not judicious. One more problem lies in find-ing distinct horizontal lines in expressions. Though it was reasonably assumed that the symbols in an expression are arranged on different horizontal lines but it was experienced that finding out these lines is prone to frequent errors due to expression skew, smaller sizes of symbols in expressions with many levels, etc. Apart from these shortcomings, the central problem remains unaddressed in the previous stud-ies, i.e. how to evaluate performance in an automatic way.
This study attempts to address all these issues by adopt-ing the view that the formulation of a performance index for evaluation of an expression recognizer is synonymous to a tree-matching problem. Let e g be an expression in the test set and T g be the ordered tree corresponds to e g . Let a recog-nizer give e r as recognition output while recognizing image or pen input corresponds to e g and T r be the ordered tree corresponds to e r . Then the edit distance between T g and T can be used in formulating the performance index. We will later see how we can get an unambiguous ordered tree for an expression and then how the edit distance between two ordered trees defines the performance index.

We consider only ordered trees because unordered trees are not sufficient to express mathematical expressions (more specifically to express the meaning of expressions). This is because the order of operators in an expression plays an important role. For example, the order of the  X  minus  X  X ign (whether after  X  x  X  X r X  y  X ) in  X  x  X  y  X  is important and therefore, in case of tree representation of mathematical expressions we must consider the ordered trees only. Before discussing about how to compute the edit distance between a pair of ordered trees, we, at first, start by defining the terms and concepts used later in our discussion. 3 Definitions 3.1 Edit distance Three kinds of edit operations are defined: changing, insert-ing and deleting. Changing node n means relabeling n . Delet-ing a node n means the parent of n inherits the children of n ; while inserting a node n means that n inherits a subsequence of the children of its parent.

A forest is a collection of trees, where the definition of a tree is the graph theoretic one. In our paper, trees are usually represented by upper case letters. denotes an empty tree or forest. | A | denotes the number of nodes in A . Nodes in trees are labeled by lower case alphabets. Nodes and labels of nodes are used interchangeably here; thus, a  X  A means that the node labeled a is present in the tree A .
Just as in [ 16 ], we represent an edit operation as o := b where a = or a  X  A , and b = or b  X  B , but both of them are not allowed to be (empty) as that would be meaningless. Here the transformation is happening from tree A to tree B . a  X  b is a delete operation if b = , an insert operation if a = , a change operation otherwise. A cost function  X  is defined which associates a non-negative real number  X ( a  X  b ) to each edit operation a  X  b . The cost function is a distance metric [ 14 ].

Let S be a sequence of edit operations o 1 , o 2 ..., o n takes a tree from A to B . Thus,  X ( S ) = i = n i = 1  X ( o  X ( S ) and  X ( a  X  b ) are really two different functions; however, we maintain the same symbol  X  to avoid cluttering the notation.

Then edit distance is formally defined as:  X ( A , B ) is the cost of edit sequence which takes A to B in a minimum num-ber of steps.  X (
A , B ) =min(  X ( S ) | S is an edit sequence that takes A to B in a minimum number of steps) 3.2 Mapping Let A and B be two trees. Since we are dealing with ordered trees, we can assume that each node in a tree can be uniquely assigned a number from 1 to N , where N is the number of nodes in the tree. Let A [ i ] denote the i th node in A and B denote the j th node in B .
 We can think of the edit operations as a mapping from A to B . A mapping is a graphical way of describing what happens to each node in the process of transformation from one tree to another (or from one ordered forest to another). In the mapping, a dotted line from A [ i ] to B [ j ] indicates that A [ i ] is to be changed to B [ j ] if A [ i ] = B [ unchanged if A [ i ]= B [ j ] (here i and j are the indices of two nodes). The nodes of A which are not connected by a dotted line to some node in B are to be deleted and the nodes of B not connected by a dotted line to A are to be inserted. A mapping M can be formally defined as a set of ordered pairs ( i , j ) which obey the following conditions: 1. 1  X  i  X | A | , 1  X  j  X | B | 2. For any two ordered pairs ( i 1 , j 1 ), ( i 2 , j 2 )
Consider the mapping as shown in Fig. 1 transforming A to B is given. The dotted lines connect nodes with the same label. In A , the node e is not connected to any node of B by a dotted line, thus e is to be deleted from A . By the same logic, e is to be inserted afterward in the tree A  X  e . We need to delete and then re-insert e to preserve the sibling and ances-tor order (notice that e in A is to the left of the subtree rooted at b , whereas e in B is to the right of the subtree rooted at b , thus there is a change in the ordering). Since nodes d in A and f in B are connected, d of A is changed to f .
We define the edit distance as a function of the mapping M (here I and J are the set of nodes of A and B respectively):  X (
M ) =
Then we can rewrite the edit distance between A and B in terms of M [ 16 ]:  X ( A , B ) =min(  X ( M ) | M is a mapping that takes A to B in a minimum number of steps). 4 The algorithm In this paper, we basically follow the approximate tree match-ing algorithm proposed by Zhang and Shasha [ 16 ]. Modifi-cation adopted by us are presented in next two sub-sections. Initially, two functions are defined: match and dist .
Suppose i and j arethe indices of theroots of therightmost tree in the forests s and t . Then: match ( s , t ) = dist ( s 1 , t 1 ) + dist ( s 2 , t 2 ) +  X ( where s and t are split into s 1 , s 2 and t 1 , t 2 . Figure 2 shows splitting of a forest s into s 1 and s 2 , where i is the index of the root of the rightmost tree, of s , i.e. s 2 and s 1 is the rest of the forest.

The match function gives the edit distance between s and t for the change operation. In the match operation, no insertions or deletions are done. If ( i , k ) and ( h , j the mapping M , then i = h and k = j , that is ( i , j )  X  This can be proved from the sibling and ancestor condition on mappings [ 16 ]. Then we can write match in the form given in Eq. ( 2 ).

The main function which gives us the edit distance is defined recursively in a function named dist . The base case is: dist (, ) = 0 The recursive part is: dist ( s , t ) = min { if t = and s then match ( s , t ) else  X  , if t = then  X  else dist ( s , t  X  last ( t )) +  X ( last ( if s = then  X  else dist ( s  X  last ( s ), t ) +  X ( last ( where last ( s ) and last ( t ) are the roots of the rightmost nodes in s and t respectively. Here t -last ( t ) denotes the forest obtained by deleting the root of the rightmost tree from t .
The recurrence relation is like this because while calcu-lating the edit distance, there are only three possibilities: 1. We match the forests s and t , and get the edit cost. This 2. last ( s ) is deleted, so the cost will be the (cost of trans-3. last ( t ) is inserted in s , which is equivalent to last Since these are the only three possibilities, we take the cost of the one that gives us the minimum number of edit operations to get the edit distance.

It is to be noted that in case of computing the function match , it makes no sense to continue the computation when t or s = , the computation is stopped by returning  X  as that will prevent the min() function from calling those cases. 4.1 Euler strings We have not used trees/forests directly in our implementa-tion. Instead we have converted the trees/forests into Euler strings. An Euler string is an unique representation of a tree, meaning that there is a one to one correspondence between a tree and its Euler string. While Zhang and Shasha X  X  [ 16 ] original implementation did not use Euler strings, an Euler string makes storage easier and trees are much more easier to handle. This is the reason our implementation uses Euler strings. To represent a forest as an Euler string, we do a depth-first traversal of each of the trees starting from the left to the right in the forest and concatenate the Euler strings obtained from each tree.

The first time we encounter a node, the node label (say, a in Fig. 3 ) is added to the Euler string. On encountering the node a second time, we append the complement (let a be the complement of a ) of the label. How the complement is denoted is up to the implementation; however, there must be a clear way of distinguishing a node from its complement and also a unambiguous way of finding where in the string a node X  X  complement is. In Fig. 3 , a node X  X  complement is simply denoted by adding an apostrophe to the label. A node label and its complement together denote a single node, and each of the individual labels is called a dart.

There is no change in the algorithm; when inserting or deleting, we remember to always delete a dart and its com-plement. We have also recorded the operations, so that we can print out which operations transformed the tree, instead of just printing the edit distance. 4.2 Our implementation The aforementioned algorithm is implemented to find dis-tance between two MathML representations. The first tree (corresponds to A ) comes from the recognizer output for a given input expression and the second tree (corresponds to B ) is the groundtruth MathML description for the input expression. Here, though we assume that a recognizer gives MathML output on recognizing an input expression (printed or handwritten), the present implementation works well even if the recognizer gives T E XorL A T E X string as output. Such a string is first converted into MathML by using freely avail-able converters (as mentioned before) to generate the first tree, i.e. A .

Next, the two MathML trees are represented by corre-sponding Euler strings. Since MathML defines a document object model (DOM, which is a cross-platform and language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents), it is eas-ily converted to an Euler string. In MathML, most elements have corresponding closing tags (for example, a &lt;msup&gt; has a corresponding &lt;/msup&gt; ); thus, it naturally corre-sponds to the dart and complement dart of an Euler string. However some elements are self-closing (like &lt;times/&gt; ), in which both the opening and closing tag are merged into one token. These cases are dealt with and converted to the corresponding Euler string representation. Euler strings not only make representation and storage of trees easier, but also it helps to reduce the run time of the algorithm. Such strings make matching of two strings a constant time process using in-built fast string comparison functions, which gives an advantage over normal tree comparison methods, thus reducing the runtime. We have already stated that every tree gives an unique Euler string. Thus if two Euler strings match, we can say that the two trees are the same.

We have also added a base case to dist , namely if s = t then dist ( s , t ) = 0. This modification could not be incorpo-rated earlier as the algorithm section was more general and did not take into consideration our Euler string implementa-tion. Using strings enables us to use the native string com-parison methods. This change saves quite a few unnecessary calls to match and dist .

The cost function we have used in our implementation is ( a , b are indices of nodes in two trees with a  X  A , b  X  B ):  X ( a  X  b ) =
Any kind of error (recognition or structure analysis) is penalized by the last part of the Eq. 3 , where L is the level of a node a ; the level of the root node of a tree is assumed to be 0. In the MathML representation, a &lt;mathml&gt; tag represents the root node. The further a symbol arrangement error is from the base line, the less is the penalty. The level of the base line is 0. This part in fact takes care of the geometric complex-ity of an expression as discussed in Sect. 2 . In MathML, the tags that generally create a change in level are &lt;msub&gt;, &lt;msup&gt;, &lt;mfrac&gt; , &lt;msubsup&gt; , etc. However, one may find that using the factor L in the Eq. 3 might be not necessary because this is very subjective as one may assume that errors of symbol and structure recognition have the same impor-tance at all levels. Therefore, we do not make the use of L mandatory, rather one has the liberty to ignore the geometric complexity in evaluating expression recognition by simply setting the value of L to 0. In this case, all types of errors are treated similarly giving equal amount of penalties. The examples as given in the next section also show edit costs with and without considering L .

Different systems may follow different standards in gen-erating MathML descriptions. This may rise to different MathML descriptions of the same expression and a pair of such MathML descriptions does not give zero edit dis-tance. This problem can be tackled by using two particu-lar converters (1) a MathML to TeX converter (several such converters are freely available in the net) that converts differ-ent MathML descriptions of a particular expression into the same TeX strings and then (2) a TeX to MathML converter (e.g. Blahtexml as mentioned in the paper, see footnote no. 2) that generates the same MathML descriptions for the same TeX/LaTeX strings, giving zero edit distance when one is compared with another. 4.3 Complexity The nature of the recursion suggests a dynamic programming method in which we compute dist ( s , t ) for every pair of sub-strings of A and B . The subproblems are solved in increasing order of s and t . The number of pairs ( s , t ) of substrings is O ( | A | 2 | B | 2 ) . Each dist ( s , t ) can be computed in constant time. Therefore the overall complexity of the algorithm is O ( | A | 2 | B | 2 ) or O ( n 4 ) .

However, it is important to note that in the present imple-mentation we improve the runtime of the original algorithm as in [ 16 ] by introducing an improvised storage. This takes care of the fact that the edit distance between two trees (or sub-tress) once calculated will be stored for further use and will not be re-calculated in future. This saves a lot of time wasted in useless calculation of the edit distance between the same two trees/sub-trees repeatedly. 4.4 Computational results To test the correctness of the implementation, we used a set of example expressions considering both printed (scanned into images) and handwritten expressions. The scanned expres-sions are recognized by the approach described in [ 10 ] and the recognizer described in [ 4 ] is used to recognize the hand-written expressions. For a given expression (printed or hand-written), the corresponding recognizer returns a L A T E X string as recognition output. This L A T E X was converted to MathML and fed into our program as the first tree, i.e. A . Groundtruth data is available in MathML format. So the groundtruthed MathML corresponding to the input expression is fed to our evaluation system as the second tree, i.e. B . Next, we checked for the correctness of the output by comparing the matching score to the results obtained by manually comparing the two MathML trees. Our performance evaluation tool not only prints the edit distance between two MathML trees but also prints the operations required to transform one tree to one another, along with the relevant line numbers. A few exam-ples follow (a few more results are presented in the Appendix section). The results we got were in accordance with manu-ally computed results.
 Recognized expression :1 d x x Actual expression : d x x
MathML for the recognition output (with some comments in parenthesis):
MathML (actual expression): Edit operations: Edit Cost is: 2 The Modify operations are : Mod-&lt;mn&gt; to &lt;mo&gt; on line 4.
 Mod-1 to #x222b; on line 4.

Two edit operations (two modify/change operations) are needed to convert the first MathML to the second one. They are (note that all edit operations take place on the first MathML and levels are considered with respect to the second MathML): 1. Modify &lt;mn&gt; to &lt;mo&gt; on line 4. The cost of this oper-2. Modify 1 to #x222b; on line 4. The cost of this operation Hence, an overall edit distance between the above two MathML files is 2. In this case, we get an edit distance of 2 even if we ignore L values as two edit operations are required. However, the use of the level i.e. L will be more clear from the following two examples. In both the cases, input expressions were handwritten.
 Actual expression : e c i k Recognized expression : e c i k
MathML (Recognized expression):
MathML (actual expression):
Four edit operations (three modify/change operations and one delete operation) are needed to convert the first MathML to the second one. They are: 1. Modify &lt;msub&gt; to &lt;msubsup&gt; on line 6 and 12 (i.e. 2. Modify i to k on line 9. The cost of this operation too 3. Similarly Modify k to i on line 9 has cost of operation 4. Delete &lt;msup&gt; on 7 and 10 (i.e. the closing tag of Hence, an overall edit distance between the aforementioned MathML files is 1 2 + 1 3 + 1 3 + 1 3 = 1 . 5. However, ignoring the concept of level the edit distance becomes 4 as 4 changes are needed to convert the output into the truthed one. Actual expression : e c i k Recognized expression : e c i k
MathML (Recognized expression):
MathML (actual expression): Edit Cost is: 1.83333 The Modify operations are : Mod-&lt;msup&gt; to &lt;msubsup&gt; on 6 and 14.
 Mod-itokon9.
 Mod-k to i on 11.
 The Delete operations are : Del-&lt;mstyle&gt; on 10 and 12.
 Del-&lt;msup&gt; on 8 and 13.
 Five edit operations are needed to convert the first MathML to the second one. They are: 1. Modify &lt;msup&gt; to &lt;msubsup&gt; on line 6 and 14 (i.e. 2. Modify i to k on line 9. The cost of this operation too 3. Similarly Modify k to i on line 11 incurs a cost of 1 4. Delete &lt;mstyle&gt; on 10 and 12 (i.e. the closing tag of 5. Delete &lt;msup&gt; on 8 and 13 (i.e. the closing tag of Hence, an overall edit distance between the above MathML files is 1 2 + 1 3 + 1 3 + 1 3 + 1 3 = 1 . 83333. However, ignoring the concept of level the edit distance will be 5 as 5 changes are needed to convert the output into the truthed one. Here it is to be noted that in the above recognized expression, if we replace j and k by x and y in the recognized result, we will have the same structural errors but also two symbol recogni-tion errors. However, in this case also only 5 edit operations are required resulting also a distance of 1.83.

This happens because the proposed evaluation method is not able to report when transposition of symbols takes place. For example, the method gives similar penalties to (1) if x is recognized as y  X  x , and (2) if x  X  y is recognized as i  X  j . The reason behind this is that in case of these trans-position errors the modification operation  X  y is changed to x  X  for the first example is treated similar as the modification operation  X  i is changed to x  X  in the second example. One may view that when x  X  y is recognized as y  X  x , at least the symbols are recognized and their positions are only tog-gled. However, we should keep this thing in mind that this kind of error (i.e. x  X  y is recognized as y  X  x ) is not just a transposition error as happens in typing words (where xy may changed to yx during typing where there is no opera-tor in between the symbols). Sometimes, the meaning of the expression may be completely changed (e.g. x  X  is recog-nized as  X  x ). Therefore, we view that it is not a significant shortcoming of the evaluation process when it gives similar penalties to these types of errors (e.g. (1) x  X  y is recognized as y  X  x and (2) x  X  y is recognized as i  X  j ). However, we agree that it would have been nice if such transposition of expression symbols could be located during the evalua-tion process. The current evaluation strategy is not able to do this. 5 Conclusion and future scope A performance evaluation scheme is formulated for evaluat-ing expression recognition systems. The expressions can be printed or handwritten (off-line or on-line). The only assump-tionusedhereisthatasystemgivesaMathMLorT E X(L A T E X) string as output. This is quite realistic as almost all the meth-ods proposed in the literature give recognition output in one of these formats. Though there are many research groups working in this area, it has always been difficult to assess performance of different systems on a common data set due to unavailability of any proper evaluation scheme. The pres-ent study will bridge the gap and will facilitate a systematic research on expression recognition.

Another area that needs further attention is the time com-plexity of the algorithm used here. The algorithm in [ 16 ] has a high time complexity of O ( n 4 ) which becomes a problem as the number of elements in the formula increases. Other recent improvements in this area are due to Klein [ 8 ] and Erik Demaine et al. [ 3 ]. Implementation of these algorithms could be considered in future. Moreover, Zhang-Shasha X  X  algo-rithm can always be parallelized to give a much better com-plexity of O ( | A |+| B | ) for two trees A and B [ 16 ]. However, as far evaluation of expressions is concerned the computa-tion time taken by the present implementation does not matter much as the evaluation process can always be executed as an off-line background task.
 Appendix Recognized expression : E x d x Actual expression : e x d x
MathML (Recognized expression):
MathML (actual expression): Edit operations: Edit Cost is: 2 The Modify operations are : Mod-Etoeon8.
 The Delete operations are : Del-&lt;msub&gt; on 11 and 14.
 Recognized expression : 4 x 3 + x + 42 1 + x 4
Actual expression : 4 x 3 + x + 42
MathML (Recognized expression):
MathML (actual expression): Edit operations: Edit Cost is: 0.5 The Insert operations are : Ins-&lt;msup&gt; between 24 and 26.

Recognized expression : 1
Actual expression : 1
MathML (Recognized expression):
MathML (actual expression): Edit Cost is: 0.65 The Insert operations are : Ins-&lt;mfrac&gt; between 19 and 29.
 The Delete operations are : Del-+ on 20.
 Del-&lt;mo&gt; on 20.
 References
