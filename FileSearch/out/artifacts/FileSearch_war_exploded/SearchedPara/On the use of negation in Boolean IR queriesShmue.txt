 Shmuel T. Klein * 1. Introduction cessful, one needs, in addition to mastering the query language syntax, also knowledge about the underlying textual data-base, its language and peculiarities.

It might be objected that in a time where powerful search engines can freely be used by everybody to access an ever rarely used in practice. But this view of the potential set of people seeking some information is very much biased toward of the users access the internet only occasionally and with very simple queries (Spink, Wolfram, Jansen, &amp; Saracevic, 2001). On the other hand, there are entire communities of users of Information Retrieval systems that are often focused on specific topics. Examples are lawyers and judges wishing to access juridical databases (such as Lexis), physicians and other health professionals interested in various collections of medical information (such as Medline), researchers in the more sophisticated tools than the most basic queries. Research to provide good query languages can thus be justified.
Indeed, correct query formulation has been a prominent subject in the Information Retrieval literature, and various lan-base systems (DBS) are usually more involved, permitting a precise description of what is being looked for, but the task text, and some information need has to be translated into queries which are generally quite fuzzy. XML files have common features with both database and IR systems, and languages have been adapted to treat XML files, ranging from the simplest of the processing of metrical constraints for XML files can be found in (Klein, 2008 ).
 applications. In fact, we restrict attention to the Boolean query model, as in Chang, Garcia-Molina, and Paepcke (1999) , model, and others. By dealing with the impact of negation on the formulation of Boolean queries, this paper complements the work in Widdows (2003) , which considers negation in the context of the vector space model: a negative term is imple-mented as a vector which is orthogonal to the vectors of the positive terms.

The natural approach of most users to query formulation involves the choice of keywords that best describe their infor-appear in the vicinity of some others, thereby achieving improved precision. But the use of negation might sometimes be tricky and is not always symmetrical to the use of positive terms. To bring an example from another IR connected applica-queries therefore needs precise definitions.

Negative keyword sets are, however, not the only application of negation. Distances can also be negative in proximity searches, and individual characters can be excluded when defining query terms using regular expressions. In the next sec-exponential to polynomial. 2. Using negation operators studied. 2.1. Negating keywords in a query we shall do incrementally. 2.1.1. Simplest syntax Most search engines allow simple queries, consisting just of a set of keywords, such as which should retrieve all the documents in the underlying textual database in which all the terms A
Often, some kind of stemming is automatically performed on all the terms of the text during the construction of the data-been pre-processed, the system has to replace each A i by a set [ ple, a typical query could be seeking documents in which all these terms appear, but instead of solve , one could also accept an occurrence of solving, solves, solution, solved, etc., and equation could as well appear in plural form.

Negating one or more keywords in the query means that one is interested in prohibiting the occurrence of the negated terms in the retrieved documents. The query is thus extended to the form keyword is preceded by an optional minus sign. For example, an auto mechanic could be interested in solving problems re-lated to a differential gear, and thus submit a query of the form keywords will be referred to in the sequel as positive terms. 2.1.2. Adding global proximity restrictions wants to avoid texts dealing with New Orleans, which appears much more frequently in the news, especially in the Katrina aftermath. A simple query could thus be not immediately preceding the term Orleans . Note that the simple solution of using also the term France in the query occurrence that the town is in France.
 act phrase option would retrieve passages containing ... solving differential equations ... , but not text parts that include ... solving these differential equations ... or ... set of differential equations that could not be solved ... .

The exact phrase option is therefore also too restrictive and should be relaxed. One possible alternative is to define a iting the diameter, formally defined as the maximal distance between any pair of the occurrences of the A query would be rephrased as
For example, reusing the last example, if the text contains where the keywords have been underlined, then the diameter is 6, since this is the distance in words from differential to solved . Thus only if in the query one chooses D P 6 would this passage be retrieved. lowering precision. Moreover, the global nature of the diameter bound is not always appropriate. In a query with keywords New, Orleans and Katrina , one would like to restrict to 1 the distance between the first two terms, but the name
Katrina could appear several words before or after the occurrence of the pair New Orleans . 2.1.3. Adding local proximity restrictions
One therefore needs a syntax allowing more flexibility, putting constraints not just on the global diameter, but on indi-vidual pairs of keywords. Consider thus a query containing only positive terms as consisting of m keywords and m 1 binary distance constraints, as in
This is a conjunctive query, requiring all the keywords A which are integers satisfying l i 6 u i for 1 6 i &lt; m , with the couple  X  l some small number of adjacent sentences or the same paragraph.
 more extended features, mixing Boolean operators with proximity constraints between certain keywords can be found in the word pattern models for Boolean Information Retrieval WP and AWP (Tryfonopoulos, Koubarakis, &amp; Drougas, 2004 ). Note changing the constraints and/or the keywords.

In a more general setting, one could also consider extended queries, consisting of several disjuncts, each having a form for each of the disjuncts. We may therefore restrict our attention to queries of the form (4). 2.1.4. Formal definition of the set of retrieved locations: only positive terms ment number, p is the number of the paragraph within the document, s is the number of the sentence within the paragraph its most general form, of finding all the m -tuples h a 1 and w -component of the coordinate x is w  X  x  X  , then omitted, for example ( l i : u i ) = (1:1), so that a query consisting only of a sequence of keywords without ( l is interpreted as a query requesting an exact phrase. 2.1.5. Adding negated keywords from left to right or vice versa will yield the same result. A query equivalence is important when one has to decide about the order of processing the terms based on the number of their occurrences, see Section 3 below. However, in the presence of negated terms, the above symmetry is broken: reading from left to right, being preceded by A at distance up to 5. Suppose a text passage contains the sequence of terms xxAxxxCxx , where A to left one, it should.

The problem is that the treatment of negated keywords is not symmetrical to that of their non-negated counterparts. In processing retrieves first the coordinates of A and then filters those out that are preceded by B .
Therefore one has to decide whether a keyword is connected to the  X  l the above example, whether it should be read word). For example, the query will be interpreted as since almost every word pair in the text would match that definition. To give some examples using real English terms: looks for documents related to the development of (or in) European countries, but wants to avoid documents containing the frequent phrases research and development or development fund , which are considered as noise and would re-duce precision.

To get information about United Airlines, an appropriate query seems to be simply United Airlines . But in many contexts, the name United by itself refers to the airline as in I took a United flight ; requiring the appearance of the term Airlines would thus have a negative impact on the recall. The same is true for the auto mechanic example United alone as query term would produce much noise, reducing precision. A better query could thus be
One could abbreviate the query by using the _ (OR) operator, thereby defining the set [ Emirates , so that the query could be rewritten as 2.1.6. Adding negated distances
If in the sentence xxAxxxBxx , the distance from A to B is 4, then the distance from B to A is 4, in accordance with the definition in (5). In the query syntax, the bounds on the distance constraints can be relaxed to 1 &lt; l the lower and upper bounds can be negative, as long as l i
Such an extension is natural and often needed, as a user may not always know the order in which the keywords appear in solve can possibly appear both before and after the others, so a good query could be differential . But the negative and positive parts of the range need not be symmetrical: a family name sometimes fol-lows the first name, and sometimes precedes it, so a correct query could be matching both Edgar Allan Poe and Poe, Edgar Allan.
 reformulate the query as but this method cannot be extended to three or more constraints on distances from the same keyword, because at most two keywords can be adjacent to any given one and by the definition of our syntax, metrical constraints operate between code-words that are adjacent in the query. in Eq. (7), the leftmost keyword is a positive one, so that association of keywords with  X  l can equivalently be reformulated as 2.1.7. Formal definition of the set of retrieved locations: including negated terms
To formally redefine Eq. (5) also for the case of negated terms, we need to distinguish between positive and negated keywords.

The extended query is given by query of type (7) is then any p -tuple h a 1 ; ... ; a p i of coordinates a and and satisfying the additional constraint on the negative terms, namely that where the distance d is defined by Eq. (5). 2.2. Negating characters in the definition of keywords
The definition of a query as given in Eq. (7), with its positive or negated keywords and with metrical constraints,
Indeed, in all of the examples above, and possibly in most real life user queries, the keywords are either given explic-itly, or one relies on some automated thesauri to generate, for a given keyword, a set of related morphological variants.
There are however many instances in which we may want to define the set represented by a given keyword on our owns.
 the keywords may appear in a variety of not always predictable spelling variants.

One of the useful tools for such definitions is a wild-card , often denoted by empty) don X  X  care sub-string, which allows the use of truncated terms. For example, comput puter, computers, computation, computability , and many other variants of this root; way, for example, in Ba * rain , the * could match h, kh, ch, ha , and possibly other strings. 2.2.1. Adding constraints to strings matched by wild-cards
A variable length wild-card character is sometimes not precise enough. In the last example, one would also like to match other spelling variants, such as Bahrein with e , but using here another wild-card as in Ba much noise: that would also match the word Bargain . The solution is to restrict the patterns to be matched by means of a regular expression, using for example a syntax adapted from the Unix gawk command: allows more flexibility, such as the use of variable length strings, for example Ba [  X  kh,ch,h,ha ] rain . position. Suppose we are looking for documents related to the city of Venice in a multilingual database. Using Venic guages: Venezia, Venecia, Venetia, Venetsia, Venice, Venise, Venedig, Velence, Ben ecja, Ben  X  tky , etc. Note that the last two variants have only two letters in common, though W and B are obviously related, just as c and k . Trying to match all these by would again yield unwanted words, like Vendetta, Ventilate or Venezuela , so one may wish to restrict the scope by using negated characters, as in its sense. Similarly xy[  X  z,w]t looks for xy , followed by z or w , and then followed by t , but the negated version xy[ z,w]t does not mean that we want xy , not followed by either z or w , but followed by t ; to get the latter interpre-minus operator can be applied to a single character as in xy since xy * [  X  z]t is equivalent to just xy * zt . 2.2.2. Formal definition of the minus operator
The definition of the minus operator should therefore be amended as follows: a negated component is not the counterpart terms must appear in combination with some wild-card. This wild-card could be the etc. In any case, for * there is no need to require left or right association, because x be a confusion, so we decide that left association is used wherever the meaning is not obvious. Using # trary string of fixed length n , the interpretation of ther followed by some 2-character string which is not qu and finally followed by t .
 preceding sections, coupling negated terms with the special distance constraint (0:0). For example could be used to match words like computed, computation or computing but not computer or computerize . 2.2.3. Extended example ited series of word concatenations. For certain non-European languages, and especially those using other scripts than the enumeration impossible.

Though this work is intended to be mainly theoretical, we now give an extended example showing the usefulness of reg-on a Hebrew database. The underlying IR system is that of the Responsa Project (Fraenkel, 1976; Choueka, 1989 ) and con-using the Hebrew alphabet. The size of the database is about 60 million words.
 use { ABGDHWZXtYKLMNSaPCQR $ T } as transliteration of { aleph, beth, ... , tav } respectively.
Table 1 lists the various queries and for each, the number of retrieved terms and total number of their occurrences. The next column shows how many of the retrieved terms and occurrences were relevant, that is, indeed dealing with the city of usual document retrieval sense; no documents are retrieved and there is no relevance assessment. The elements produced not have been retrieved. Indeed, we found two more relevant occurrences, which explains why recall is not 1.0 in our example.

Recall is based on the fact that 2 more relevant occurrences have been found, which were not matched by the given que-for doubling the W to get the consonant, but this rule is only partially adhered to. Using W alone would produce too much noise, as this single letter corresponds to the conjunction and .

The first two lines show queries retrieving almost all the relevant variants but producing many irrelevant terms; using recall and precision may change. 3. Implementation issues
While Section 2 dealt mainly with the definition of negation operators in various settings, we now turn to implementa-processed. 3.1. Processing negated keywords in a query
The way to process queries depends on the algorithmic approach chosen for the Information Retrieval system at hand. For (Zobel &amp; Moffat, 2006 ).
 tains for each word a pointer to the concordance , which is often called postings file or simply index. The concordance on the documents of the database. This order may be chronological, referring to the time the documents have been created, der of their names, etc.
 example, if the query is A  X  2 : 8  X  B and the text contains the passage query is the set of pairs f X  a 1 ; b 1  X  ;  X  a 2 ; b 1  X  ;  X  a f X  a 1  X g ; note that the occurrence a 3 was invalidated by b 1 3.2. Evaluating the processing order
When longer queries are to be processed, the question of the order in which the keywords should be dealt with arises. For the discussion below, we define the size of keyword A i , denoted by s  X  A there are some keywords with very large sizes, a more careful approach is needed. Intuitively, one would suggest to start then with the  X  X  X mallest X  keyword, i.e., one with minimal s  X  A all the coordinates of all the terms in the query and storing them temporarily, only to throw away most of them after the be dynamically reduced during the processing stages, so that parts of the lists of the larger keywords, which have been deferred to later processing, may not have to be read at all.
 varying distance constraints may force a more restricted order, and second, even if processing by non-decreasing order is feasible, it is not necessarily the best choice.

If all the constraints are fixed, that is l i  X  u i for 1 occurrences of B either up to 3 words after A or 2 to 4 words before C . Consider the text passages ... x a x b xxxx c x the query, the first because d  X  b ; c  X  X  5 &gt; 4, the second because d  X  a ; b  X  X  4 &gt; 3.
The processing order is therefore restricted to dealing at every step with one of the keywords that is adjacent to one of adjacent keywords, we have that the last keyword to be dealt with must be either the leftmost or the rightmost, so that
T  X  m  X  X  2 T  X  m 1  X  ; since T  X  1  X  X  1 we get that T  X  m  X  X  2
The fact that the keywords have to be processed by adjacency order also provides an example of the non-optimality of the left after the intersection will probably be much lower than 100, so the intersection with the 10,000 elements of B will be more efficient.

It is true that for many queries, the number m of keywords will be small enough to justify an exhaustive search through applications, with much larger databases and possibly automatically generated query terms, an exponential number of pos-sibilities might be prohibitive.

To choose a priori the best among the 2 m 1 orders, we suggest the following heuristic, trying to estimate the expected number of comparisons needed for the sequence of intersections induced by each of the orderings of the keywords, and reducing the number of the orderings to be inspected from exponential to polynomial. Since this paper is intended for ex-perts in IR which might not be specialists in algorithms, some necessary background will now be given. 3.2.1. Algorithmic background
One of the major problems dealt with by research in algorithms relates to their time complexity , which measures the time 2 m 1 for an input of m query terms, are prohibitive, because even for moderately large m such algorithms cannot be performed in reasonable time. On the other hand, a polynomial complexity is usually considered acceptable.
There are many optimization problems which at first sight, using a straightforward exhaustive search through all the based on defining the solution of a problem recursively as a combination of the solutions of some of its subproblems, but the exponential blowup of the recursive procedure  X  which is often due to the frequent reevaluation of the same subproblems  X  may be avoided by cleverly choosing the order in which all the subproblems are solved, thereby solving each path in a graph from every origin node to every target node, finding longest common subsequences of two given input and many others.

In our application, we have to compare 2 m 1 possible orderings of the m keywords of the query and choose one with low-est processing cost according to some pricing heuristic defined below. Defining the subproblems in the proper way then cuss adaptations to negated terms later. 3.2.2. Processing order with positive keywords only
Let r be a permutation of the numbers f 1 ; 2 ; ... ; m g corresponding to one of the 2 keywords, that is A r  X  1  X  is the first element to be chosen, and it is intersected with A r  X  1  X  X  1or m ), etc.

The number of comparisons requested by each of the possible orderings depends on the sizes of the lists to be intersected be relevant is possibly reduced. The first step is to intersect C  X  A ignore the range in our estimates.
 ler or equal to the shorter one. We estimate this size as course easy to come up with artificial counter examples, showing cases in which smaller lists gave larger intersection. estimated cost implied by permutation r is thus
Q the minimal expected cost of processing the query terms A subsequence is either A i or A j , so that V  X  i ; j  X  is the smaller of the two values L and R defined by
A ... A j , so it is either i or j .
  X  1 ; m ; m  X  to fill, in time O  X  m  X  , the optimal permutation r backwards from the end. 3.2.3. Processing order allowing negative keywords
Several adaptations are necessary to extend the above algorithm also to cases including negated keywords. For the posi-tendency to better reduce the remaining set of coordinates. The reason for not using the order implied by non-decreasing sizes was that varying distance constraints forced us to proceed by adjacency only. For negated terms, a decision to make the more coordinates are generally left after the intersection.
 and F can be performed in any of the 5! = 120 possible orderings.
 To derive an upper bound on the time needed to evaluate the optimal processing order, recall that we defined words is still restricted as before, thus their number is 2 which the bound is not exaggerated: consider a query with a single positive and m 1 negated keywords; the number of possible processing orders is then  X  m 1  X  !
The following observation permits a dynamic programming solution as above, reducing the processing time to polyno-mial. The intersection process is done by pairs, and when keyword A coordinate list, whether it should be proportional to s  X  A list of a negated keyword. Thus when computing the total cost of a given processing order, all the values s  X  A optimal way to process the negated keywords is to choose, every time there is a choice, the one with the largest s  X  A this will best reduce the size of the remaining coordinate list.
 the negated terms is given, at each stage, by the order induced by s  X  A only a subset of the negated keywords that is relevant.
 according to the non-increasing order of the corresponding keyword sizes. The following example should clarify these def-suppose the sizes of the negated terms are as given in the row s  X  A and N  X  i  X  , and the matrix to the right gives the sets CNI  X  i ; j  X  for 1
C  X  A
 X  as reducing the size of the current set by a factor of s  X  A reduction is by a factor of 1 s  X  A i  X  = 2 M 0 , where M set of remaining coordinated should not be empty.

To extend the above dynamic programming procedure, define V  X  i ; j ; X   X  as the minimum expected processing cost of the sub-query A P  X  i  X  ... A P  X  j  X  in which  X  negated keywords are allowed to participate, 0 lowing notations are useful: let C  X  i ; j ; X   X  be the expected size of the coordinates list after intersecting A one, in which case it must be A P  X  i  X  or A P  X  j  X  , or a negative one, in which case it must be A element of the list CNI  X  i ; j ; X   X  . This yields the following recursion: where the minimum should be understood as being applied only to the first two lines for the special case  X   X  0.
Fill-sigma of Fig. 5 is called with parameters  X  1 ; p ; m p ; m  X  and works in time O  X  m  X  . 4. Conclusion
Negation has been part of most retrieval systems before and the purpose of this work was not to reinvent some unknown notation, negation can have some very positive aspects.
 References
