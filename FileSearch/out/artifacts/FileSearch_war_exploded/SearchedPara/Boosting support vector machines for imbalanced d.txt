 Benjamin X. Wang  X  Nathalie Japkowicz Abstract Real world data mining applications must address the issue of learning from imbalanced data sets. The problem occurs when the number of instances in one class greatly outnumbers the number of instances in the other class. Such data sets often cause a default classifier to be built due to skewed vector spaces or lack of information. Common approaches for dealing with the class imbalance problem involve modifying the data distribution or mod-ifying the classifier. In this work, we choose to use a combination of both approaches. We use support vector machines with soft margins as the base classifier to solve the skewed vector spaces problem. We then counter the excessive bias introduced by this approach with a boost-ing algorithm. We found that this ensemble of SVMs makes an impressive improvement in prediction performance, not only for the majority class, but also for the minority class. Keywords Imbalanced data sets  X  Support vector machines  X  Boosting 1 Introduction A data set is imbalanced if the number of instances in one class greatly outnumbers the num-ber of instances in the other class. Some examples of domains presenting a class imbalance are: fraudulent telephone calls, telecommunications management, text and image classifica-tion, and disease detection. For reasons of simplicity, and with no loss in generality, only binary classification problems are considered in this paper. However, it is important to keep in mind that the class imbalance problem is pervasive in other areas as well such as multi-class classification [ 37 ] and association rule mining [ 33 ].
 Recently, the class imbalance problem has received a lot of attention in the Machine Learning community by virtue of the fact that the performance of the algorithms used degrades significantly if the data set is imbalanced [ 23 ]. Performance can also be affected if the cost of making errors favours one class in particular. This is caused by the fact that classes with fewer examples in the training set have a lower prior probability and a lower error cost. should be based on the distribution of examples in the training set. More specifically, in very imbalanced domains, most standard classifiers will tend to learn how to predict the majority class. While these classifiers can obtain higher predictive accuracies than those that also try to consider the minority class, this seemingly good performance can be argued as being meaningless.

Over the years, the machine learning community has addressed the issue of class imbalance set. The second way involves modifying the classifiers in order to adapt them to the data sets. The two approaches are independent of each other and can be combined to enhance each other X  X  performance.

In this paper, we present a system that combines these two general methods. The system works by modifying the classifier using cost assignation, but counters the bias introduced with this modification by using a combination scheme, which is similar, in effect, to modifying the data distribution. The base classifier we selected for our system is SVM and the combination scheme is Boosting. As will be shown in a subsequent section, SVMs are naturally quite robust to the class imbalance problem as compared to other classifiers. In addition, a number of effective schemes were already proposed in the literature to create cost-sensitive SVMs. Boosting, on the other hand, has the advantage of increasing the accuracy of prediction rules often without causing over-fitting. 1 Indeed, our experiments show that boosting methods can be combined with SVMs very effectively in the presence of imbalanced data. Our results show that our approach is not only able to solve the skewed vector spaces problem, but also the over-fitting problem caused by the support vector machines.

The remainder of the paper is organized as follows: the next section will discuss some of the approaches previously applied to deal with the class imbalance problem. Section 3 introduces the performance measures we use to evaluate our research. Section 4 discusses the motivations for our approach. It first gives an intuitive explanation followed by a more technical one. Next, Sect. 5 describes our approach while Sect. 6 presents the results we obtained. Section 7 is the conclusion. 2 Previous work As discussed in the introduction, there are two general ways to deal with the class imbal-ance or skewed vector space problem: a classifier-independent data-driven approach and a classifier-based cost-adaptation method. Here, we will talk about some of the most effec-tive approaches that have been proposed within these two categories. We will discuss these approaches in terms of both their benefits and their limitations. Please note that although class imbalances are often related to other phenomena, such as noise, overlapping examples and small disjuncts, such issues go beyond the scope of our study [ 42 ]. However, this gives a comprehensive survey of these various data defects in relation with the class imbalance problem. 2.1 Balancing the data set The simplest way to balance a data set is by under-sampling (randomly or selectively) the the fact that this method results in information loss for the majority class, it must be noted that undersampling is generally quite successful at countering the class imbalance problem, especially when it uses sophisticated data elimination methods (e.g., [ 22 , 24 ]). minority instances in the hope of reducing class imbalance. With over-sampling, the neigh-borhood of a positive instance is assumed to be also positive as are the instances between two positive instances. Assumptions like these, however, are data dependent and do not apply in all cases. Experimental results show that under-sampling produces better results than over-sampling in many cases. The reason is that although over-sampling does not lose any information about the majority class, it introduces an unnatural bias in favour of the minority class. Using synthetic examples to augment the minority class is believed to be better than over-sampling with replacement [ 7 ]. It does not cause any information loss and could potentially find  X  X idden X  minority regions. The disadvantage of this method is that it creates noise for the classifiers which could result in a loss of performance. Nonetheless, a method of this kind has the potential of being better than the other approaches discussed since it uses a non-skewed mechanism to solve the problem of skewed data.

While [ 7 ] presents an interesting approach to oversampling, it also combines elements of oversampling and undersampling together. They are not the only authors to have tried this approach. More recently [ 4 ], study several such methods and [ 36 ] propose an effective approach for selectively filtering the majority class while strengthening relevant minority class examples. 2.2 Modifying the classifiers Working with classifiers to adapt data sets is another way to deal with the imbalanced data problem. Assigning distinct costs to the training examples seems to be the most effective approach of this kind. Various experimental studies, doing just that, have been performed using both different kinds of classifiers and different types of cost-adaptation strategies per se, a number of researchers [ 9 , 42 ]and[ 19 ] demonstrated that these types of cost-sensi-tive approaches are good ways to deal with the class imbalance problem, as well.
In terms of SVMs, several specific attempts have been made at improving their class pre-diction accuracy in the case of class imbalances [ 1 , 21 , 28 ]. The results obtained with such methods show that SVMs have the particular advantage of being able to solve the problem of skewed vector spaces, without introducing noise. However, the resulting classifiers may over-fit the data, as we will discuss later. Our proposed system is one that attempts to reduce the amount of over-fitting introduced by the above techniques. The approaches suggested for SVMs will be discussed in detail in Sect. 4 since they are closely related to our own solution. Prior to doing so, however, the next section discusses the performance estimators we will be using in our study. 3 Effective performance estimators for the class imbalance problem Before carrying on with the description of our research, we must first introduce the measures that will be used in our experiments. The problem of how to evaluate the effectiveness of our learners, be they binary, multi-class or regression algorithms, is very difficult and is a current topic of investigation both from a metric and a confidence viewpoint (e.g., [ 25 , 34 ]).
The problem of assessing the quality of learning from extremely imbalanced data is par-ticularly problematic. Indeed, in such cases, the overall classification accuracy is often not an appropriate measure of performance given that a trivial classifier that predicts every case as the majority class could achieve very high accuracy in extremely skewed domains.
Several proposals have been made to address this issue. One of them is to use ROC Anal-ysis, which consists of plotting the true positive rate as a function of the false positive rate along all possible threshold values for the classifier under study. ROC Analysis produces to the Area under the ROC Curve (AUC) which can be interpreted as the expected pro-portion of positive examples ranked before a uniformly drawn random negative example [ 16 ].

In this work, we decided not to use ROC Analysis because of the difficulty to summarize the results it obtains on the large number of experiments we ran. Furthermore, we decided that while the AUC is quite informative, its meaning remains a bit abstract and a bit too general in the sense that an algorithm with higher AUC than another has the potential of outperforming the other, but there is no guarantee that, with the threshold in actual use, this is the case. In addition, the AUC does not separate the performance of the classifiers on a class-by-class basis.
 Instead of ROC Analysis and AUC, we, thus, settled for three measures: Sensitivity, Specificity and the G-mean, which are more intuitive and more practical, as they apply to fully determined algorithms rather than algorithms in which an optimal threshold remains to be determined. Furthermore, unlike the AUC, these measures give us a class-by-class performance estimate. More specifically, Sensitivity refers to the proportion of truly positive examples that were labeled positive by the system being evaluated; while Specificity corre-sponds to the proportion of truly negative examples that were labeled negative by that system. The G-mean is a combination of both Sensitivity and Specificity. As such, it is a nice and compact measure, which has the the distinct advantage of taking the class imbalance into consideration. On the other hand, because it combines two other measures, it hides certain details of the algorithm X  X  performance. For this reason, we are also reporting the results of both Sensitivity and Specificity.

The formulae for Sensitivity, Specificity and the G-mean (Geometric-mean) are listed after the confusion matrix displayed below.
 Specificity: ( Acc  X  ) = TN /( TN + FP ) Sensitivity: True positive rate ( Acc + ) = TP /( TP + FN ) Gmean = ( Acc  X   X  Acc + ) 1 / 2
Please, note that Specificity is also known as the true negative rate and Sensitivity is also known as the true positive rate. The terms  X  X pecificity X  and  X  X ensitivity X  are the terms used to describe these quantities in the medical domain. We adopted them here, given that the primary application of our research was a set of four medical data sets provided to us by the US National Institute of Health (Please, see the description of our datasets below). 4 Motivation for our approach We begin this section by explaining the motivation for our approach at an intuitive level. The second part of the section reviews our motivations from a more technical standpoint. In particular, Sect. 4.2 discusses SVM and the skewed boundary problem and Sect. 4.3 discusses previous methods for handling the problem. 4.1 Intuitive motivation We selected to study the class imbalance problem in the context of SVMs for several rea-sons. First, support vector machines are an effective classification method in many application domains. In addition, they have a very strong theoretical basis. Furthermore, although the performance of SVMs does deteriorate when applied to the class imbalanced problem, this deterioration occurs when considering much more severe cases of class imbalances than the deterioration of other classifiers such as decision trees or neural networks [ 43 ]. Finally, a number of methods specifically designed to deal with the class imbalance problem with SVMs were already proposed and shown to be quite promising. All these factors seemed to favour SVMs over other classifiers.

The motivation for our specific SVM-based approach was the observation, which will be detailed in the next section, that previously proposed SVM-based solutions to the class imbalance problem have a tendency to overfit the data, thus, resulting in systems that trade-off sensitivity for specificity or the other way around. In order to counter this tendency, we hypothesized that this overfitting tendency could be mitigated by modifying the distribution of the data, leading it towards a more balanced distribution.

Rather than modifying the balance of the data per se, however, we chose to simulate this modification by using a classifier combination method. This would result, we believed, in a more principled approach. We considered three major classifier ensemble methods including bagging, boosting and stacking. Random forests, another leading ensemble method, does not apply to SVMs and was, thus, automatically discarded. Of the three considered methods, the bagging method was shown to require unstable weak learners. This means that small changes requires less unstable algorithms as it actively tries to force the weak leaning algorithm to change its hypotheses by constructing a  X  X ard X  distribution over the examples, based on the performance of previously generated hypotheses. Unlike the Bagging and Boosting methods, the Stacking method is not normally used to combine models of the same type. It was, thus, quickly dismissed. 2 In the end, we reasoned that because SVM, the algorithm we chose to use as a base classifier is a strong stable algorithm, Boosting should be selected as the best option among the popular choices of ensemble methods. 4.2 SVMs and the skewed boundary Support vector machines are based on the principle of Structural Risk Minimization from statistical learning theory. The idea of structural risk minimization is to find a hypothesis h for which we can guarantee the lowest true error. In the presence of noise, the idea of using a soft margin was introduced by [ 39 ].
 SVMs is formulated in terms of a kernel function K: where b is the bias and the optimal coefficients  X  i are found by maximizing the primal Lagrangian: where  X  i  X  0, and  X  i  X  0. The formula is also subject to the Karush X  X uhn X  X ucker (KKT) conditions: Here the penalty constant C represents the trade-off between the empirical error  X  and the size of the margin.

In imbalanced data sets, the negative examples usually correspond to the large class while the positive examples correspond to the small one. As noted earlier, a data imbalance causes most common default classifiers to always predict the  X  X egative X  class. Wu and Chang [ 43 ] observed two potential causes for the problem of a skewed boundary: (1) the imbalanced training data ratio and (2) the imbalanced support-vector ratio. For the first cause, we note that on the minority side of the boundary, the positive examples may not always reside as close to the  X  X deal boundary X  as the negative examples. In terms of the second cause, we note that according to the KKT conditions, the values for  X  i must satisfy n i = 1  X  i y i = 0. Since the values for the minority class tend to be much larger than those for the majority class and the number of positive support vectors substantially smaller, the nearest neighborhood of a test point is likely to be dominated by negative support vectors. In other words, the decision function is more likely to classify a boundary point as negative.
 All the strategies designed to deal with the class imbalance problem in the context of SVMs attempt to address either one or both of these underlying causes. The next section outlines the most important such proposed strategies. 4.3 Analysis of Strategies for the imbalanced problem for SVMs To deal with the imbalanced boundary problem, several approaches were given for adjusting the skewed boundary. We first present two approaches and, then, outline our own strategy for handling this problem. Section 5 presents a full-blown description of our approach. 4.3.1 Kernel transformation method Adaptively modifying the kernel function K based on the training data distribution is an effective method for improving SVMs. Amari and Wu [ 2 ] proposed a method for modifying a kernel function to improve the performance of a support vector machine classifier. This method is based on the structure of the Riemannian geometry induced by the kernel function. The idea is to increase the separability between classes by enlarging the space around the separating boundary surface.

Improving upon Amari and Wu X  X  method, Wu and Chang [ 43 ] proposed a class-boundary-alignment algorithm, which also modifies the kernel matrix K based on the distribution of the training data. Instead of using an input space, they conduct the kernel transformation based on the spatial distribution of the support vectors in feature space. A function D ( x ) = k  X  SV exp (  X  | x  X  x k |  X  2 tion, with  X  k being a free parameter which controls the magnification rate around the support vectors [ 2 ]and[ 43 ].

This method takes advantage of the new information learned in every iteration of the SVM algorithm while leaving the input-space distance unchanged. The class boundary alignment algorithm can be applied directly to adjust the pair-wise object distance in the kernel matrix K in cases where the input space may not physically exist. Theoretical justifications and empirical studies show that the kernel transformation method is effective on imbalanced classification, but this technique is too complex to be implemented efficiently. 4.3.2 Biased penalties method Shawe-Taylor and Cristianini [ 35 ] showed that the distance of a test point from the boundary is related to its probability of misclassification. This observation motivated the technique introduced in their paper. The technique consists of providing a more severe penalty if an error is made on a positive example than if it is made on a negative example. By using the cost factors and adjusting the cost of false positives and false negatives, such penalties can be directly incorporated into the SVM algorithm.

Finding the separating hyper-plane can therefore be expressed by the following optimi-zation problem:
Here the formulation of L p has two loss functions to describe the two different types of errors: where k = 1or2 , C +  X   X  i  X  0 , C  X   X   X  i  X  0, and  X  i  X  0.
 Morik et al. [ 28 ] and Shawe-Taylor and Cristianini [ 35 ] proposes an algorithm to use the L 1 norm ( k = 1). Two cost-factors are chosen so that the potential total cost of the false positives equals the potential total cost of the false negatives. This means that the parameters of the SVM are selected such that they obey the ratio: C + / C  X  = n  X  / n + . By increasing the margin on the side of the smaller class, this method provides a way to induce a decision boundary which is much more distant from the  X  X ritical X  class than it is from the other. But in this model, the balance between sensitivity and specificity cannot be controlled adaptively, resulting in over-fitting.

Instead of using the L 1 norm for the loss measure, [ 40 ] use the square of the L 2 norm ( k = 2). Their system can be described as follows: From the formulation of L p , we can get the dual formulation: If be controlled using the diagonal components of the kernel matrices supplemented by the K ( x i , x i ) +  X   X  for y i = X  1. With this model we can see that increasing the cost ratio does not necessarily have any effect  X  i sinceifweusethe L 1 norm ( k = 1) to calculate loss, its dual formation results in the same Lagrangian as for the original soft-margin SVMs. The only difference is that they are constrained as follows: According to the KKT conditions, the value of  X  i satisfies So we can see that to increase C + or C  X  does not necessarily affect  X  i since C + and C  X  only impose an upper bound on  X  i and not a lower bound. Moreover, the KKT constraints impose an equal amount of influence from the positive and negative support vectors. Thus, increases in the  X  i on the positive side will inadvertently increase  X  i onthenegativeside to satisfy the constraint, which nullifies the effect of the original C + increase. On the other and specificity at the same time. Veropoulos et al. [ 40 ], thus, enables the algorithm to control the balance between sensitivity and specificity, not adding any information. Experimental results, however, show that this method has the power to effectively control the sensitivity, but not the specificity of the learning machine. We thus ignored their approach. 4.3.3 Our take on the problem From the description and analysis of the previous approaches, we can see that what is really required is a method that is able to introduce some information to the problem in order to increase both sensitivity and specificity.
 Our approach, thus, seeks to improve upon the method in [ 28 ]. Instead of increasing C + or C  X  to get the balance between sensitivity and specificity, we provide another solu-each. We choose to use boosting, a general method which combines several simple clas-sifiers, to modify the training data sets. The details of this technique are given in the next section. 5 Boosting SVM with asymmetric misclassification cost Boosting and other ensemble learning methods have recently been used with great success on many applications [ 8 , 17 , 19 ]. In our algorithm, we chose to use the L 1 norm ( k = 1) SVM (as described in Sect. 4 ) with asymmetric misclassification cost as the component classifier in a boosting scheme. Our method will now be presented formally: classifier is formulated in terms of the kernel function K: where b is the bias and the optimal coefficients are found by maximizing the primal Lagrangian: we found that the points labeled  X   X  i , where since  X   X  i =  X  i /  X  , are said to be on the wrong side of the margin , as shown in Fig. 1 . In terms of the L 1 norm margin slack vector optimi-zation, the feasibility gap can be computed since the  X  i are not specified when moving to the dual problem. The values for  X  i can therefore be chosen in order to ensure that the primary problem is feasible. The values are calculated using the following equation: Here, the task consists of modifying the weights  X  i of the training observations x i in the input space in order to modify the point labeled  X   X  i . The advantage of this technique is that we are able to easily build a modified version of the training data and improve the class prediction function of the boosting procedure.

Our purpose is to sequentially apply the component classification algorithm to the mod-ified versions of the data, thereby producing a sequence of component classifiers G m ( x ) , m = 1 , 2 ,..., M .

The predictions from all of the component classifiers are then combined by a weighted for  X  1 ,  X  2 ,...,  X  M are computed by the boosting algorithm and are used to weight the contri-accurate classifiers in the sequence.

The details of our boosting-SVM algorithm are shown in Table 2 . In this algorithm, error rate  X  is computed as shown at line (c). The weight  X  m is then found by calculating  X  m =  X  log ( 1  X   X )/ X  .Herethe  X  is an empirical parameter used to tune the magnitude of the penalty for each iteration. We use the G-mean instead of prediction accuracy to evaluate the classifier since it combines the values of both sensitivity and specificity. We apply our algo-rithm on the training data set X train until the G-mean value on the test set X validation cannot be improved. I is a function such that I(false) = 0 and I(true) = 1. Please, note that we slightly modified the AdaBoost Algorithm. We did so because we applied the Boosting method to strong component classifiers (SVMs), and in order to benefit from boosting, these classifiers must be appropriately weakened: AdaBoost with a strong component classifier is not viable. We chose to weaken SVM using the simple but effective method of reducing the diversity of the component classifiers. This modification appears at line (e) where we do not explicitly reduce the weights of the correctly classified objects. Algorithm Boosting-SVM: Given: Sequence of N examples X Train , X Validation M; /  X  the maximum running iterations  X  / Output: G; /  X  output ensemble classifier  X  / Va r i a b l e s :  X  ; /  X  weights to training observations ( x i , y i ) , i=1,2,...,N  X  / T; /  X  the selected running iterations  X  /  X /  X  G-mean value  X  / Function Calls: S ; /  X  single classifier  X  / SVMTrain(X) ; /  X  training the single classifier S using SVMs with Asymmetric Cost  X  / SVMClassify(X,S) ; /  X  classify X by the classifier S  X  / Gmean(G) ; /  X  obtain the G-mean value from G  X  / Begin Initialize  X  = 1, i=1,2,...N T=1.
 Doform=1,2,M (a) X train ( x )  X  X train ( x ) using weights  X  i . (b) S m  X  SV MTrain ( X train ) . (c) Compute  X  m = N i = 1 (d) Compute  X  m =  X  log 1  X   X  m  X  (e) Set  X  i  X   X  i  X  exp [  X  m  X  I ( y i = SV MClassi f y ( X train , S m )) ] , i=1,2,...,N. (f) G m = sign [ m j = 1  X  j S j ] (g)  X  m = Gmean [ G m ( X v alidation ) ] (h) if  X  m &gt; X  best ,thenT=mand  X  best =  X  m .
 Return G T .
 End Algorithm 1: Boosting-SVM with Asymmetric Cost algorithm The final classification is found following a vote by the sequence of component classifiers. Figure 2 provides an illustration of a final classifier built from three component classifiers. The ensemble classifier will have lower training error on the full training set than any other single component classifier. The ensemble classifier will also have lower error than a single linear classifier trained on the entire data set. 6 Experiments and discussion This section describes the experimental set-up we used to test the performance of our approach. We begin by describing the classifiers compared to our system, along with their tunings; the data sets on which the classifiers were compared are then introduced; we conclude the section by presenting the results obtained and their analysis. 6.1 The classifiers and their tunings In our experiments, we compare the performance of our classifier with eight other popu-lar methods: (I)Adacost [ 15 ], (II)SMOTEboost [ 8 ], (III)WRF [ 9 ], (IV)Databoost-IM [ 19 ], (V)Under-sampling with SVMs, (VI)SMOTE [ 7 ] with SVMs, (VII)SVMs with Asymmetric Cost [ 28 ], (VIII)SMOTE combined with VII [ 1 ]. The first four classifiers correspond to other ensemble classifiers, while the next four correspond to SVM-based classifiers. Because our system is both an ensemble method and an SVM-based system, we judged it necessary to pit it against both kinds of approaches.
 For under-sampling we used a random sampling method. For both over-sampling and SMOTE, the minority class was over-sampled at the different candidate rates of 200, 300, 400 and 500%. The results obtained at these various rates showed a small but unstable fluctu-ation [ 3 ]. We, thus, decided to average them since this average would be more representative than our use of the best rate which may be difficult, if not impossible, to find in practice. 3 We used the same component classifier for all methods. SMOTE was used with five neighbours. The ensemble methods were run for a maximum of 40 epochs. For our method and the SVMs ments, we used 10-fold cross-validation to train our classifiers. In the boosting schemes we used 70% of the data set for training, 20% to set the threshold for each boosting iteration. The remaining 10% of the data was used as a normal fold in the tenfold cross validation testing scheme. All training, validation, and test subsets were sampled in a stratified manner that ensured that each of them had the same ratio of negative to positive examples [ 28 ]. Finally, for all the SVM classifiers, we used a linear kernel function to prevent the choice of kernel function from affecting our results. Future work will involve experimentations with other kernels, such as the L 2 norm ( k = 2). 6.2 Data sets We chose to experiment on 12 different imbalanced data sets. The first eight, Abalone19, B-cancer, Car3, Glass7, Heart-disease1, Letter4, Segment and Yeast are from the UCI Repos-itory for Machine Learning.

The next four, Lupus-I, Lupus-II, Stroke-I, Stroke-II, are health related data sets that were provided by the (US) National Institute of Health (NIH). Table 1 lists the data sets, along with some pertinent statistics such as the number of positive and negative examples, their ratios, as well as their number of features.

Because the information about the UCI data sets is public, we do not report it here. Instead, we report the information about the new data sets that were provided to us by the NIH: Lupus: The creator of this data is the Office of Statewide Planning and Development. Report of results from the OSHPD reabstracting project: an evaluation of the reliability of selected patient discharge data, July through December 1988. Sacramento, CA: Office of Statewide Planning and Development; 1990. The dataset Lupus-I includes 3,839 instances, 58 attri-butes and two classes. We selected the majority class as our negative class which has 3,730 cases and the minority class as our positive class which has 109 cases. The dataset Lupus-II includes 3,077 instances, 59 attributes and two classes. We selected the majority class as our negative class which has 2,907 cases and the minority class as our positive class which has 170 cases.
 Stroke: The creator of this data is the German Stroke Data Bank funded by the Stiftung Deutsche Schlaganfall-Hilfe (German Stroke Foundation) and the German Stroke Study Collaboration funded by the Bundesministerium fur Bildung und Forschung (German Minis-try of Education and Research). Senior investigator: Prof. Dr. rer. nat. Andreas Ziegler, Institut fuer Medizinische Biometrie und Statistik Universitaet zu Luebeck. email: ziegler@imbs.uni-luebeck.de. The dataset Stroke-I includes 1,869 instances, 43 attributes and six classes. We selected the fifth class as our positive class which contains 98 cases and the other classes as our negative class which contains 1,771 cases. The dataset Stroke-II includes 1,805 instances, 38 attributes and six classes. We selected the fourth class as our positive class which contains 107 cases and the other classes as our positive class which contains 1,698 cases. 6.3 Results This section reports on a number of results that can help explain the behaviour of our new method. We begin by reporting our results in terms of Kubat X  X  G-mean, which was described in Sect. 3 , and we expand this report by listing the sensitivity and specificity separately.
As mentioned previously, because our system is both an SVM-based technique and an ensemble method, it was important to compare it to other systems in both these categories. In each series of results, we thus, display two tables. The first one (Table 2 ), reporting on the results of methods I, II, III and IV (see above) focuses on the results obtained by other ensemble methods. The second one (Table 3 ), reporting on the results of methods V, VI, VII and VIII focuses on the results obtained by other SVM-based methods. This second table also lists the results obtained by our method (B-SVM). The results indicated in boldfaced characters represent the best results obtained for the particular data set considered. Because the results span both tables, it is possible that no result appears in bold for a particular data set in a particular table. This is the case, for example, in Table 3 where no boldfaced results appear for data sets  X  X lass X  and  X  X egment X . The best results for these data sets were, in fact, obtained by methods I and IV, respectively, as shown by the boldfaced results in Table 2 . As mentioned previously, all the results reported in these tables were obtained by running 10-fold cross validation experiments on each domain.

We now provide a detailed analysis of the results reported in these tables. The first obser-vation is that the mean G-measure of B-SVM computed over all the domains is superior to that of all the other classifiers. Indeed, B-SVM obtains a mean of 77.01 while the mean of the other classifiers range between 63.91 and 73.32. While we report this observation in view of the fact that it is an indication of B-SVM X  X  general strength, we would like to acknowl-edge, however, that considering such means is not particularly significant on its own, given the performance variation that may occur from domain to domain. We thus consider other indicators as well. The second observation, then, looks at the number of domains on which B-SVM overtakes all the other classifiers. As shown in bold in Table 3 , B-SVM outperforms all the other classifiers on the great majority of domains. As a matter of fact, there are only two domains (Glass and Segment) for which B-SVM is not the ideal classifier. Tables 2 and 3 also indicate that Classifiers IV (Databoost-IM) and VII (SVMs with Asymetric Costs) are the two methods that share most of the second best results, after B-SVMs. While the infor-mation regarding how many times B-SVM outperforms all the other classifiers is important, so is the amount by which B-SVM X  X  performance differs from that of the other classifiers in all the domains. A look at Tables 2 and 3 reveals that this difference is truly remarkable in three cases: Heart Disease (H-Disease), Lupus-I and Lupus-II. 4 It is particularly remarkable on Lupus I, where it exceeds 7% on all classifiers and in Heart Disease where it exceeds 5% on all classifiers.

We then tried to explain the success of B-SVM on all these domains, but soon discovered that the explanation is not straightforward. While both the Lupus I and II data sets have higher dimensionality than all the other domains, which may be a factor in B-SVM X  X  success, we noted that Stroke I and II also have high dimensionality and, yet, are not much better classi-fied by B-SVM than by the next best classifier (Classifier IV). Conversely, H-Disease, which is the other domains particularly well classified by B-SVM, does not have a particularly high dimensionality (nor a particularly high class imbalance, either, for that matter). This suggests that we need more information on B-SVM as well as on the other classifiers to truly understand their difference. The following analysis provides some insights on the matter, by considering more detailed results.

We now show the results for sensitivity and specificity separately, in the hope of gleaning more information about our results. Tables 4 and 5 display the Sensitivity results for the ensemble methods and the SVM-based methods, respectively, while Tables 6 and 7 display the specificity results for the ensemble methods and the SVM-based methods, respectively.
Considering the two leading contenders, algorithms IV and VII, after B-SVM, we can see that the disparity between the sensitivity and specificity results they return is generally (but not always) higher than for B-SVM. Table 8 lists the absolute values of the differences between specificity and sensitivity for each of the 12 domains and for these three systems.
From this table, we can see that Systems IV and VII display higher differences between these two quantities than B-SVM in 10 and 9 of the 12 domains, respectively, and that the average differences for IV, VII and B-SVM, in absolute values, are 21.6, 14.5 and 12.53, respectively, thus showing a generally smaller difference for B-SVM. These results, thus, suggest that our approach has the power to more effectively control both the sensitivity and specificity components of the error than classifiers IV and VII, and that, without adding noise, as suggested by the better overall results obtained by B-SVM in Tables 2 and 3 . Finally, it is worth noting that our approach is always better than SVMs with Asymmetric Cost and L 1 norm (System VII) which is used as the component classifier of our approach. The improvement in terms of both sensitivity and specificity over VII, thus, means that our method is, as we had hoped, better able to avoid over-fitting the data. 7Conclusion We have proposed a new algorithm, boosting-SVMs with Asymmetric Cost, for tackling some of the problems associated with imbalanced data sets. Through theoretical justifications and empirical studies, we demonstrated this method to be effective. In particular, we found that our boosted SVM classifiers are robust in two ways: (1) they improve the performance of the SVM classifier; and (2) they are sufficiently simple to be immediately applicable.
In future work, we hope to test more effective boosting methods on our algorithm. We will also test our framework on different kernel functions and we will use additional measures to evaluate the performance of our system.
 References Author Biographies
