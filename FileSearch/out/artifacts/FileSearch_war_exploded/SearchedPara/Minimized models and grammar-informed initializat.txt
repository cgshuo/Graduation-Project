 Creating accurate part-of-speech (POS) taggers using a tag dictionary and unlabeled data is an interesting task with practical applications. It has been explored at length in the literature since Merialdo (1994), though the task setting as usu-ally defined in such experiments is somewhat arti-ficial since the tag dictionaries are derived from tagged corpora. Nonetheless, the methods pro-posed apply to realistic scenarios in which one has an electronic part-of-speech tag dictionary or a hand-crafted grammar with limited coverage. Most work has focused on POS-tagging for English using the Penn Treebank (Marcus et al., 1993), such as (Banko and Moore, 2004; Gold-water and Griffiths, 2007; Toutanova and John-son, 2008; Goldberg et al., 2008; Ravi and Knight, 2009). This generally involves working with the standard set of 45 POS-tags employed in the Penn Treebank. The most ambiguous word has 7 dif-ferent POS tags associated with it. Most methods have employed some variant of Expectation Max-imization (EM) to learn parameters for a bigram or trigram Hidden Markov Model (HMM). Ravi and Knight (2009) achieved the best results thus far (92.3% word token accuracy) via a Minimum Description Length approach using an integer pro-gram (IP) that finds a minimal bigram grammar that obeys the tag dictionary constraints and cov-ers the observed data.

A more challenging task is learning supertag-gers for lexicalized grammar formalisms such as Combinatory Categorial Grammar (CCG) (Steed-man, 2000). For example, CCGbank (Hocken-maier and Steedman, 2007) contains 1241 dis-tinct supertags (lexical categories) and the most ambiguous word has 126 supertags. This pro-vides a much more challenging starting point for the semi-supervised methods typically ap-plied to the task. Yet, this is an important task since creating grammars and resources for CCG parsers for new domains and languages is highly labor-and knowledge-intensive. Baldridge (2008) uses grammar-informed initialization for HMM tag transitions based on the universal combinatory rules of the CCG formalism to obtain 56.1% accu-racy on ambiguous word tokens, a large improve-ment over the 33.0% accuracy obtained with uni-form initialization for tag transitions.

The strategies employed in Ravi and Knight (2009) and Baldridge (2008) are complementary. The former reduces the model size globally given a data set, while the latter biases bitag transitions toward those which are more likely based on a uni-versal grammar without reference to any data. In this paper, we show how these strategies may be combined straightforwardly to produce improve-ments on the task of learning supertaggers from lexicons that have not been filtered in any way. 1 We demonstrate their cross-lingual effectiveness on CCGbank (English) and the Italian CCG-TUT corpus (Bos et al., 2009). We find a consistent im-proved performance by using each of the methods compared to basic EM, and further improvements by using them in combination.

Applying the approach of Ravi and Knight (2009) naively to CCG supertagging is intractable due to the high level of ambiguity. We deal with this by defining a new two-stage integer program-ming formulation that identifies minimal gram-mars efficiently and effectively. CCGbank. CCGbank was created by semi-automatically converting the Penn Treebank to CCG derivations (Hockenmaier and Steedman, 2007). We use the standard splits of the data used in semi-supervised tagging experiments (e.g. Banko and Moore (2004)): sections 0-18 for train-ing, 19-21 for development, and 22-24 for test. CCG-TUT. CCG-TUT was created by semi-automatically converting dependencies in the Ital-ian Turin University Treebank to CCG deriva-tions (Bos et al., 2009). It is much smaller than CCGbank, with only 1837 sentences. It is split into three sections: newspaper texts (NPAPER), civil code texts (CIVIL), and European law texts from the JRC-Acquis Multilingual Parallel Corpus (JRC). For test sets, we use the first 400 sentences of NPAPER, the first 400 of CIVIL, and all of JRC. This leaves 409 and 498 sentences from NPAPER and CIVIL, respectively, for training (to acquire a lexicon and run EM). For evaluation, we use two different settings of train/test splits: TEST 1 Evaluate on the NPAPER section of test TEST 2 Evaluate on the entire test using lexi-
Table 1 shows statistics for supertag ambiguity in CCGbank and CCG-TUT. As a comparison, the POS word token ambiguity in CCGbank is 2.2: the corresponding value of 18.71 for supertags is in-dicative of the (challenging) fact that supertag am-biguity is greatest for the most frequent words. Part-of-speech tags are atomic labels that in and of themselves encode no internal structure. In con-Table 1: Statistics for the training data used to ex-tract lexicons for CCGbank and CCG-TUT. Dis-tinct : # of distinct lexical categories; Max : # of categories for the most ambiguous word; Type ambig : per word type category ambiguity; Tok ambig : per word token category ambiguity. trast, supertags are detailed, structured labels; a universal set of grammatical rules defines how cat-egories may combine with one another to project syntactic structure. 2 Because of this, properties of the CCG formalism itself can be used to constrain learning X  X rior to considering any particular lan-guage, grammar or data set. Baldridge (2008) uses this observation to create grammar-informed tag transitions for a bitag HMM supertagger based on two main properties. First, categories differ in their complexity and less complex categories tend to be used more frequently. For example, two cat-egories for buy in CCGbank are (S[dcl] \ NP)/NP and ((((S[b] \ NP)/PP)/PP)/(S[adj] \ NP))/NP; the former occurs 33 times, the latter once. Second, categories indicate the form of categories found adjacent to them; for example, the category for sentential complement verbs ((S \ NP)/S) expects an NP to its left and an S to its right.

Categories combine via rules such as applica-tion and composition (see Steedman (2000) for de-tails). Given a lexicon containing the categories for each word, these allow derivations like: Other derivations are possible. In fact, every pair of adjacent words above may be combined di-rectly. For example, see and a may combine through forward composition to produce the cate-gory (S \ NP)/N, and Ed  X  X  category may type-raise to S/(S \ NP) and compose with might  X  X  category.
Baldridge uses these properties to define tag transition distributions that have higher likeli-hood for simpler categories that are able to combine. For example, for the distribution p ( t i | t i  X  1 = N P ) , (S \ NP) \ NP is more likely than ((S \ NP)/(N/N)) \ NP because both categories may combine with a preceding NP but the former is simpler. In turn, the latter is more likely than NP: it is more complex but can combine with the preced-ing NP. Finally, NP is more likely than (S/NP)/NP since neither can combine, but NP is simpler.
By starting EM with these tag transition dis-tributions and an unfiltered lexicon (word-to-supertag dictionary), Baldridge obtains a tagging accuracy of 56.1% on ambiguous words X  X  large improvement over the accuracy of 33.0% obtained by starting with uniform transition distributions. We refer to a model learned from basic EM (uni-formly initialized) as EM, and to a model with grammar-informed initialization as EM GI . The idea of searching for minimized models is related to classic Minimum Description Length (MDL) (Barron et al., 1998), which seeks to se-lect a small model that captures the most regularity in the observed data. This modeling strategy has been shown to produce good results for many nat-ural language tasks (Goldsmith, 2001; Creutz and Lagus, 2002; Ravi and Knight, 2009). For tagging, the idea has been implemented using Bayesian models with priors that indirectly induce sparsity in the learned models (Goldwater and Griffiths, 2007); however, Ravi and Knight (2009) show a better approach is to directly minimize the model using an integer programming (IP) formulation. Here, we build on this idea for supertagging.
There are many challenges involved in using IP minimization for supertagging. The 1241 distinct supertags in the tagset result in 1.5 million tag bi-gram entries in the model and the dictionary con-tains almost 3.5 million word/tag pairs that are rel-evant to the test data. The set of 45 POS tags for the same data yields 2025 tag bigrams and 8910 dictionary entries. We also wish to scale our meth-ods to larger data settings than the 24k word tokens in the test data used in the POS tagging task.
Our objective is to find the smallest supertag grammar (of tag bigram types) that explains the entire text while obeying the lexicon X  X  constraints. However, the original IP method of Ravi and Knight (2009) is intractable for supertagging, so we propose a new two-stage method that scales to the larger tagsets and data involved. 4.1 IP method for supertagging Our goal for supertagging is to build a minimized model with the following objective:
Using the full grammar and lexicon to perform model minimization results in a very large, diffi-cult to solve integer program involving billions of variables and constraints. This renders the mini-mization objective IP original intractable. One way of combating this is to use a reduced grammar and lexicon as input to the integer program. We do this without further supervision by using the HMM model trained using basic EM: entries are pruned based on the tag sequence it predicts on the test data. This produces an observed grammar of distinct tag bigrams ( G obs ) and lexicon of ob-served lexical assignments ( L obs ). For CCGbank, G obs and L obs have 12,363 and 18,869 entries, respectively X  X ar less than the millions of entries in the full grammar and lexicon.

Even though EM minimizes the model some-what, many bad entries remain in the grammar. We prune further by supplying G obs and L obs as input ( G, L ) to the IP-minimization procedure. However, even with the EM-reduced grammar and lexicon, the IP-minimization is still very hard to solve. We thus split it into two stages. The first stage (Minimization 1) finds the smallest grammar G min 1  X  G that explains the set of word bigram types observed in the data rather than the word sequence itself, and the second (Minimization 2) finds the smallest augmentation of G min 1 that ex-plains the full word sequence.
 Minimization 1 (M IN 1). We begin with a sim-pler minimization problem than the original one ( IP original ), with the following objective: We formulate this as an integer program, creat-ing binary variables gvar i for every tag bigram g i = t j t k in G . Binary link variables connect tag bigrams with word bigrams; these are restricted to the set of links that respect the lexicon L pro-vided as input, i.e., there exists a link variable link jklm connecting tag bigram t j t k with word bi-gram w l w m only if the word/tag pairs ( w l , t j ) and ( w m , t k ) are present in L . The entire integer pro-gramming formulation is shown Figure 2.

The IP solver 3 solves the above integer program and we extract the set of tag bigrams G min 1 based on the activated grammar variables. For the CCG-bank test data, M IN 1 yields 2530 tag bigrams. However, a second stage is needed since there is no guarantee that G min 1 can explain the test data: it contains tags for all word bigram types, but it cannot necessarily tag the full word sequence. Fig-ure 1 illustrates this. Using only tag bigrams from M
IN 1 (shown in blue), there is no fully-linked tag path through the network. There are missing links between words w 2 and w 3 and between words w 3 and w 4 in the word sequence. The next stage fills in these missing links.
 Minimization 2 (M IN 2). This stage uses the original minimization formulation for the su-pertagging problem IP original , again using an in-teger programming method similar to that pro-posed by Ravi and Knight (2009). If applied to the observed grammar G obs , the resulting integer program is hard to solve. 4 However, by using the partial solution G min 1 obtained in M IN 1 the IP optimization speeds up considerably. We imple-ment this by fixing the values of all binary gram-mar variables present in G min 1 to 1 before opti-mization. This reduces the search space signifi-
Figure 2: IP formulation for Minimization 1. cantly, and CPLEX finishes in just a few hours. The details of this method are described below.
We instantiate binary variables gvar i and lvar i for every tag bigram (in G ) and lexicon entry (in L ). We then create a network of possible taggings for the word token sequence w 1 w 2 ....w n in the corpus and assign a binary variable to each link in the network. We name these variables link cjk , where c indicates the column of the link X  X  source in the network, and j and k represent the link X  X  source and destination (i.e., link cjk corresponds to tag bigram t j t k in column c ). Next, we formulate the integer program given in Figure 3.

Figure 1 illustrates how M IN 2 augments the grammar G min 1 (links shown in blue) with addi-
Figure 3: IP formulation for Minimization 2. tional tag bigrams (shown in red) to form a com-plete tag path through the network. The minimized grammar set in the final solution G min 2 contains only 2810 entries, significantly fewer than the original grammar G obs  X  X  12,363 tag bigrams.
We note that the two-stage minimization pro-cedure proposed here is not guaranteed to yield the optimal solution to our original objective IP original . On the simpler task of unsupervised POS tagging with a dictionary, we compared our method versus directly solving IP original and found that the minimization (in terms of grammar size) achieved by our method is close to the opti-mal solution for the original objective and yields the same tagging accuracy far more efficiently. Fitting the minimized model. The IP-minimization procedure gives us a minimal grammar, but does not fit the model to the data. In order to estimate probabilities for the HMM model for supertagging, we use the EM algorithm but with certain restrictions. We build the transi-tion model using only entries from the minimized grammar set G min 2 , and instantiate an emission model using the word/tag pairs seen in L (pro-vided as input to the minimization procedure). All the parameters in the HMM model are initialized with uniform probabilities, and we run EM for 40 iterations. The trained model is used to find the Viterbi tag sequence for the corpus. We refer to this model (where the EM output ( G obs , L obs ) was provided to the IP-minimization as initial input) as EM+IP .
 Bootstrapped minimization. The quality of the observed grammar and lexicon improves consid-erably at the end of a single EM+IP run. Ravi and Knight (2009) exploited this to iteratively im-prove their POS tag model: since the first mini-mization procedure is seeded with a noisy gram-mar and tag dictionary, iterating the IP procedure with progressively better grammars further im-proves the model. We do likewise, bootstrapping a new EM+IP run using as input, the observed gram-mar G obs and lexicon L obs from the last tagging output of the previous iteration. We run this until the chosen grammar set G min 2 does not change. 5 4.2 Minimization with grammar-informed There are two complementary ways to use grammar-informed initialization with the IP-minimization approach: (1) using EM GI output as the starting grammar/lexicon and (2) using the tag transitions directly in the IP objective function. The first takes advantage of the earlier observation that the quality of the grammar and lexicon pro-vided as initial input to the minimization proce-dure can affect the quality of the final supertagging output. For the second, we modify the objective function used in the two IP-minimization steps to be: where, G is the set of tag bigrams provided as in-put to IP, gvar i is a binary variable in the integer program corresponding to tag bigram ( t i  X  1 , t i )  X  G , and w i is negative logarithm of p gii ( t i | t i  X  1 as given by Baldridge (2008). 6 All other parts of the integer program including the constraints re-main unchanged, and, we acquire a final tagger in the same manner as described in the previous sec-tion. In this way, we combine the minimization and GI strategies into a single objective function that finds a minimal grammar set while keeping the more likely tag bigrams in the chosen solution. EM GI +IP GI is used to refer to the method that uses GI information in both ways: EM GI output as the starting grammar/lexicon and GI weights in the IP-minimization objective. We compare the four strategies described in Sec-tions 3 and 4, summarized below: EM HMM uniformly initialized, EM training.
 EM+IP IP minimization using initial grammar EM GI HMM with grammar-informed initializa-EM GI +IP GI IP minimization using initial gram-For EM+IP and EM GI +IP GI , the minimization and EM training processes are iterated until the resulting grammar and lexicon remain unchanged. Forty EM iterations are used for all cases.

We also include a baseline which randomly chooses a tag from those associated with each word in the lexicon, averaged over three runs. Accuracy on ambiguous word tokens. We evaluate the performance in terms of tagging accu-racy with respect to gold tags for ambiguous words in held-out test sets for English and Italian. We consider results with and without punctuation. 7
Recall that unlike much previous work, we do not collect the lexicon (tag dictionary) from the test set: this means the model must handle un-known words and the possibility of having missing lexical entries for covering the test set.
 Precision and recall of grammar and lexicon. In addition to accuracy, we measure precision and
Model ambig ambig all all Random 17.9 16.2 27.4 21.9 EM 38.7 35.6 45.6 39.8 EM+IP 52.1 51.0 57.3 53.9 EM GI 56.3 59.4 61.0 61.7 Table 2: Supertagging accuracy for CCGbank sec-tions 22-24. Accuracies are reported for four settings X (1) ambiguous word tokens in the test corpus, (2) ambiguous word tokens, ignoring punctuation, (3) all word tokens, and (4) all word tokens except punctuation. recall for each model on the observed bitag gram-mar and observed lexicon on the test set. We cal-culate them as follows, for an observed grammar or lexicon X: This provides a measure of model performance on bitag types for the grammar and lexical entry types for the lexicon, rather than tokens. 5.1 English CCGbank results Accuracy on ambiguous tokens. Table 2 gives performance on the CCGbank test sections. All models are well above the random baseline, and both of the strategies individually boost perfor-mance over basic EM by a large margin. For the models using GI, accuracy ignoring punctuation is higher than for all almost entirely due to the fact that  X . X  has the supertags  X . X  and S, and the GI gives a preference to S since it can in fact combine with other categories, unlike  X . X  X  X he effect is that nearly every sentence-final period (  X 5.5k tokens) is tagged S rather than  X . X .

EM GI is more effective than EM+IP; however, it should be kept in mind that IP-minimization is a general technique that can be applied to any sequence prediction task, whereas grammar-informed initialization may be used only with tasks in which the interactions of adjacent labels may be derived from the labels themselves. In-terestingly, the gap between the two approaches is greater when punctuation is ignored (51.0 vs. 59.4) X  X his is unsurprising because, as noted al-ready, punctuation supertags are not actual cate-Table 3: Comparison of grammar/lexicon ob-served in the model tagging vs. gold tagging in terms of precision and recall measures for su-pertagging on CCGbank data. gories, so EM GI is unable to model their distribu-tion. Most importantly, the complementary effects of the two approaches can be seen in the improved results for EM GI +IP GI , which obtains about 3% better accuracy than EM GI .
 Accuracy on all tokens. Table 2 also gives per-formance when taking all tokens into account. The HMM when using full supervision obtains 87.6% accuracy (Baldridge, 2008), 8 so the accuracy of 63.8% achieved by EM GI +IP GI nearly halves the gap between the supervised model and the 45.6% obtained by basic EM semi-supervised model.
 Effect of GI information in EM and/or IP-minimization stages. We can also consider the effect of GI information in either EM training or IP-minimization to see whether it can be effec-tively exploited in both. The latter, EM+IP GI , obtains 53.2/51.1 for all/no-punc X  X  small gain compared to EM+IP X  X  52.1/51.0. The former, EM GI +IP, obtains 58.9/61.6 X  X  much larger gain. Thus, the better starting point provided by EM GI has more impact than the integer program that in-cludes GI in its objective function. However, we note that it should be possible to exploit the GI information more effectively in the integer pro-gram than we have here. Also, our best model, EM GI +IP GI , uses GI information in both stages to obtain our best accuracy of 59.6/62.3.
 P/R for grammars and lexicons. We can ob-tain a more-fine grained understanding of how the models differ by considering the precision and re-call values for the grammars and lexicons of the different models, given in Table 3. The basic EM model has very low precision for the grammar, in-dicating it proposes many unnecessary bitags; it achieves better recall because of the sheer num-ber of bitags it proposes (12,363). EM+IP prunes that set of bitags considerably, leading to better precision at the cost of recall. EM GI  X  X  higher re-call and precision indicate the tag transition dis-tributions do capture general patterns of linkage between adjacent CCG categories, while EM en-sures that the data filters out combinable, but un-necessary, bitags. With EM GI +IP GI , we again see that IP-minimization prunes even more entries, improving precision at the loss of some recall.
Similar trends are seen for precision and recall on the lexicon. IP-minimization X  X  pruning of inap-propriate taggings means more common words are not assigned highly infrequent supertags (boosting precision) while unknown words are generally as-signed more sensible supertags (boosting recall). EM GI again focuses taggings on combinable con-texts, boosting precision and recall similarly to EM+IP, but in greater measure. EM GI +IP GI then prunes some of the spurious entries, boosting pre-cision at some loss of recall.
 Tag frequencies predicted on the test set. Ta-ble 4 compares gold tags to tags generated by all four methods for the frequent and highly am-biguous words the and in . Basic EM wanders far away from the gold assignments; it has little guidance in the very large search space available to it. IP-minimization identifies a smaller set of tags that better matches the gold tags; this emerges because other determiners and prepositions evoke similar, but not identical, supertags, and the gram-mar minimization pushes (but does not force) them to rely on the same supertags wherever pos-sible. However, the proportions are incorrect; for example, the tag assigned most frequently to in is ((S \ NP) \ (S \ NP))/NP though (NP \ NP)/NP is more frequent in the test set. EM GI  X  X  tags correct that balance and find better proportions, but also some less common categories, such as (((N/N) \ (N/N)) \ ((N/N) \ (N/N)))/N, sneak in be-cause they combine with frequent categories like N/N and N. Bringing the two strategies together with EM GI +IP GI filters out the unwanted cate-gories while getting better overall proportions. 5.2 Italian CCG-TUT results To demonstrate that both methods and their com-bination are language independent, we apply them to the Italian CCG-TUT corpus. We wanted to evaluate performance out-of-the-box because Table 5: Comparison of supertagging results for CCG-TUT. Accuracies are for ambiguous word tokens in the test corpus, ignoring punctuation. bootstrapping a supertagger for a new language is one of the main use scenarios we envision: in such a scenario, there is no development data for chang-ing settings and parameters. Thus, we determined a train/test split beforehand and ran the methods exactly as we had for CCGbank.

The results, given in Table 5, demonstrate the same trends as for English: basic EM is far more accurate than random, EM+IP adds another 8-10% absolute accuracy, and EM GI adds an additional 8-10% again. The combination of the methods gen-erally improves over EM GI , except when the lex-icon is extracted from NPAPER+CIVIL. Table 6 gives precision and recall for the grammars and lexicons for CCG-TUT X  X he values are lower than for CCGbank (in line with the lower baseline), but exhibit the same trends. We have shown how two complementary strategies X  X rammar-informed tag transitions and IP-minimization X  X or learning of supertaggers from highly ambiguous lexicons can be straight-Table 6: Comparison of grammar/lexicon ob-served in the model tagging vs. gold tagging in terms of precision and recall measures for su-pertagging on CCG-TUT. forwardly integrated. We verify the benefits of both cross-lingually, on English and Italian data. We also provide a new two-stage integer program-ming setup that allows model minimization to be tractable for supertagging without sacrificing the quality of the search for minimal bitag grammars.
The experiments in this paper use large lexi-cons, but the methodology will be particularly use-ful in the context of bootstrapping from smaller ones. This brings further challenges; in particular, it will be necessary to identify novel entries con-sisting of seen word and seen category and to pre-dict unseen, but valid, categories which are needed to explain the data. For this, it will be necessary to forgo the assumption that the provided lexicon is always obeyed. The methods we introduce here should help maintain good accuracy while open-ing up these degrees of freedom. Because the lexi-con is the grammar in CCG, learning new word-category associations is grammar generalization and is of interest for grammar acquisition.
Finally, such lexicon refinement and generaliza-tion is directly relevant for using CCG in syntax-based machine translation models (Hassan et al., 2009). Such models are currently limited to lan-guages for which corpora annotated with CCG derivations are available. Clark and Curran (2006) show that CCG parsers can be learned from sen-tences labeled with just supertags X  X ithout full derivations X  X ith little loss in accuracy. The im-provements we show here for learning supertag-gers from lexicons without labeled data may be able to help create annotated resources more ef-ficiently, or enable CCG parsers to be learned with less human-coded knowledge.
 The authors would like to thank Johan Bos, Joey Frazee, Taesun Moon, the members of the UT-NLL reading group, and the anonymous review-ers. Ravi and Knight acknowledge the support of the NSF (grant IIS-0904684) for this work. Baldridge acknowledges the support of a grant from the Morris Memorial Trust Fund of the New York Community Trust.

