
Frequent subtree mining has become increasingly impor-tant in recent years. In this paper, we present AMIOT algo-rithm to discover all frequent ordered subtrees in a tree-structured database. In order to avoid the generation of in-frequent candidate trees, we propose the techniques such as right-and-left tree join and serial tree extension. Proposed methods enumerate only the candidate trees with high prob-ability of being frequent without any duplications. The ex-periments on synthetic dataset and XML database show that AMIOT reduces redundant candidate trees and outperforms FREQT algorithm by up to five times in execution time.
There exist many studies on frequent structure mining and its applications [4, 13]. A graph mining algorithm AGM [10] is applied to molecular structure analysis in chemistry [11]. FREQT [3] and TreeMiner [16] are proposed for fre-quent ordered subtree discovery and applied to machine learning for text classification [12] and web access log min-ing [14] respectively.

This paper focuses on frequent ordered subtree mining in a tree-structured database. Most of structure mining al-gorithms are based on the enumerating techniques similar to Apriori [1]which generates a candidate of size k +1 from fre-quent patterns of size k . A simple enumerating method with tree expansion, however, often duplicates the same trees re-peatedly because a candidate tree can be generated in multi-ple ways by expansion [4]. Therefore, FREQT and TreeM-iner utilize the technique of rightmost expansion which cre-ates a candidate tree of size k +1 by adding a new node only to the rightmost branch of a frequent tree of size k . Though rightmost expansion enumerates all frequent trees without any duplicates, the method still generates a number of non-frequent candidate trees which lead to unnecessary database scans for frequency calculations.
 In this paper, we propose a novel algorithm AMIOT; Apriori-based Mining of Induced Ordered Trees. It utilizes an efficient enumeration method, right-and-left tree join to avoid useless database scans. Right-and-left tree join cre-ates a candidate tree of size k +1 by joining two frequent trees of size k in a similar way with Apriori [1] in order to eliminate redundant candidate trees. It is theoretically guaranteed that the join method never enumerates a larger number of infrequent candidate trees than rightmost expan-sion. All frequent trees are generated just once as well as rightmost expansion because there is only one way to create each candidate tree by right-and-left tree join. We discuss the advantages of AMIOT in comparison with FREQT, and evaluate the performance of AMIOT based on the experi-ments with synthetic dataset and XML database.

The paper is organized as follows. In Section 2, we in-troduce the frequent tree discovery problem. We mention the related works in Section 3. In Section 4, we define right-and-left tree join and serial tree extension, then present AMIOT algorithm. We study the performance of AMIOT and show the experimental results in Section 5. In Section 6, we conclude this paper and point out the future works.
In this section, we formally define the problem of fre-quent labeled ordered tree discovery. 2.1 Labeled Ordered Tree
Let L = { l 0 ,l 1 ,  X  X  X } be a finite set of labels. T = { V, E, B, label, root } represents a labeled ordered tree on L . V denotes a set of nodes and | T | means the size of tree which equals the number of nodes | V | . E  X  V 2 and B  X  V 2 present the set of parent-child relations and sibling relations of two adjacent child nodes respectively. Label function label : V  X  L gives the label l  X  X  of a node. root represents the unique node which does not have a par-ent node. Leaf node denotes a node which has no child 1 node. Serial tree represents the tree which has only one leaf node. The depth of v  X  V , depth ( v ) is defined as the num-ber of nodes on the path from root to v . Labeled ordered tree is hereinafter referred to as ordered tree or tree . 2.2 Frequent Ordered Tree Let D be a data tree which the frequent trees occur on. S denotes the set of data trees or tree-structured database. The size of S is defined as | S | = D  X  S | D | . Given data tree D = { V D ,E D ,B D , label D , root D } X  S and ordered tree T = { V T ,E T ,B T , label T , root T } , we define that T occurs on D if and only if there exists an injection between V and sibling relations.
 In this paper, we define the number of the occurrences of T as Occ ( root ) , the number of the occurrences of root T on S without duplications. Then we represent the frequency of T on S as F S ( T )= | Occ ( root ) | / | S | .

Frequent ordered tree of size k is hereinafter referred to as k -pattern. Let F k be the set of k -patterns. C k represents the set of candidate trees which have opportunity to be k -pattern. 2.3 Frequent Tree Discovery Problem
Let  X  (0  X   X   X  1) be a minimum support of frequent tree. T is frequent when F S ( T )  X   X  is satisfied. Frequent tree discovery problem is defined as below.
 Problem 2.1. Given database S and minimum support  X  , find all frequent subtrees of which frequency on S is not less than  X  .

In Figure 1, we present an example of the frequent tree discovery problem on only one data tree D ( | D | = 15) with minimum support  X  = 20% . In this case, T 1 is frequent since the number of the occurrences of root T 1 equals 3 and its frequency equals  X  . On the other hand, T 2 is not frequent because root T 2 occurs only twice on D .

We describe the characteristics of the frequent tree dis-covery problem and the related works. Then we depict the technical overview of FREQT [3], especially about right-most expansion. 3.1 Basis for Frequent Subtree Mining We introduce the following lemma on frequent subtrees. Lemma 3.1. If T is ( k +1)-pattern, all subtrees of T of size k , obtained by the removal of leaf nodes from T , are also frequent.

This lemma is equivalent to the anti-monotony property of frequent itemset mentioned in Apriori [1].

Based on Lemma 3.1, the structures of typical frequent tree mining algorithms are organized as follows. [Main Procedure on Frequent Tree Mining Algorithm] STEP 1. Scan database S , find F 1 and F 2 .
 STEP 2. Let tree size k =2 .
 STEP 3. Generate the candidate trees of size k +1 from F k , STEP 4. Scan S for each C  X  X  k +1 , then add C to F k +1 STEP 5. Exit if |F k +1 | =0 , otherwise go back to STEP 3 3.2 Various Tree Mining Algorithms
The key issue on the procedure in Section 3.1 is how to enumerate the candidate trees and create C k +1 efficiently in STEP 3. For example, suppose that we apply a tech-nique which appends new nodes with each label l  X  X  to T  X  X  k and enumerates the trees of size k +1 as candidate trees. Though the expanding method can generate all fre-quent candidate trees, it leads to the duplication of many candidate trees because there are multiple ways of expan-sion to produce the same tree. In addition, the size of C increases exponentially with k due to the infrequent candi-date trees. Therefore the simple enumerating methods are not efficient [4].

Asai et al and Zaki independently proposed FREQT [3] and TreeMiner [16] as algorithms using rightmost expan-sion for enumeration. Rightmost expansion is a natural ex-tension of set enumeration tree developed by Bayardo [5]. Wang et al proposed Chopper and XSpanner [15] using sim-ilar techniques with FP-growth [7].

These algorithms can be classified into two categories by the definition of tree occurrence. TreeMiner, Chopper and XSpanner find out embedded trees by considering ancestor-descendant relations. On the contrary, FREQT discovers induced trees. In Section 3.3, we describe the overview of rightmost expansion and FREQT. 3.3 FREQT
In FREQT, each ordered tree is uniquely represented as a depth-label sequence. The depth-label sequence of T consists of the ( depth , label )-pairs of the nodes, ordered from root T in a depth-first manner as T = (1 , label ( root ))(2 , label ( v 1 ))(2 , label ( v 2 ))  X  X  X  the rightmost leaf of T ( rml ( T ) ) as the leaf node located in the end of the depth-label sequence of T . The rightmost branch of T indicates the path from root T to rml ( T ) .
We define ( d , l )-expansion of T as the rightmost expan-sion of T with a node of depth d and label l .

P ( T ) denotes the parent tree of ( k +1)-pattern T ob-tained by the removal of rml ( T ) from T . Therefore, each T most expansion of P ( T )  X  X  k because P ( T ) is unique and entirely included in F k . Rightmost expansion is done in constant time by appending the depth-label pair of the new node to the end of the depth-label sequence. FREQT enu-merates the candidate trees in linear time of the number of the trees and discovers all frequent trees with no duplicate.
FREQT utilizes two techniques, such as node-skip and edge-skip to reduce the number of rightmost expansions since it is not efficient to repeat the rightmost expansions for all labels in L .

Given a frequent tree T , FREQT preserves a rightmost occurrence list of T that consists of the occurrence loca-tions of rml ( T ) in the data trees. The occurrence list makes it easier to count the root occurrences of the candidate trees derived as the rightmost expansions of T . FREQT addition-ally applies a duplicate detecting method to avoid counting the same root occurrence more than once.
 We show an example of rightmost expansion in Figure 2. The shaded nodes represent new rightmost leaf on the right-most branch. The trees marked with a cross are not frequent. The most important problem is that some non-frequent can-didate trees are generated in Figure 2. For example, T 4 is clearly not frequent because it includes a infrequent subtree T T with database scan. We evaluate the efficiency of enumera-tion in Section 5.
In this section, we propose AMIOT algorithm which discovers all frequent induced ordered subtrees in a tree-structured database. We devised right-and-left tree join for the enumeration of frequent candidate trees [8] and apply it to AMIOT in the intension to naturally extend Apriori for tree mining. However, right-and-left tree join never enu-merates serial trees. Therefore we devise a method, se-rial tree extension which generates serial trees as candidate trees.

Chi et al lately proposed HybridTreeMiner [6] which in-cludes a similar enumerating method by join-and-extension for mining unordered trees and free trees. We introduce our new techniques in Section 4.1 and Section 4.2. 4.1 Right and Left Tree Join
In the same way with rightmost leaf, we define the left-most leaf of T ( lml ( T ) ) as the first leaf node in the depth-label sequence of T . Right ( T ) represents the right tree ob-tained by the removal of lml ( T ) from T , and Lef t ( T the left tree obtained by the removal of rml ( T ) from T . Let Center ( T ) be the center tree where both right and left leaves of T were eliminated.
 Given a non-serial tree T , Right ( Lef t ( T )) equals Lef t ( Right ( T )) i.e. both trees represent Center ( T cause lml ( T ) and rml ( T ) can be removed independently of the order if lml ( T ) is different from rml ( T ) .
The right-and-left tree join between trees L and R is de-fined as follows.
 Definition 4.1. Given two trees L and R which satisfy Right ( L )= Lef t ( R ) , their right-and-left tree join is given as follows:
We show an example of right-and-left tree join in Figure 3. Right ( L ) obtained by the removal of the shaded lml ( with label 4 is equivalent to Lef t ( R ) where rml ( R ) has label 5 was eliminated. In this case, the right-and-left tree join Join ( L, R ) can be created.

Every non-serial tree is represented as the right-and-left tree join of its right and left trees. Therefore, we derive Theorem 4.2 and Theorem 4.3.
 Theorem 4.2. The combination of left tree and right tree can be put in one-to-one correspondence with their right-and-left tree join.
 Proof. (Necessity) Obvious from the definition of right-and-left tree join. (Sufficiency) Since left and right trees are represented uniquely, two following equations are given.
 trees of both sides of Join ( T 1 ,T 2 )= Join ( S 1 ,S 2 Theorem 4.3. The right-and-left tree join of L and R is equivalent to the rightmost expansion of L with rml ( R ) Proof. Obvious from the definitions of rightmost expan-sion and right-and-left tree join.

We describe how to apply right-and-left tree join to the enumeration of candidate trees. Given a ( k +1)-pattern T F k +1 , it is guaranteed that Lef t ( T ) and Right ( T ) are also k -patterns by Lemma 3.1. Therefore, each ( k +1)-pattern T can be obtained by the right-and-left tree join of trees T 1 and T 2 which satisfy Right ( T 1 )= Lef t ( T 2 )= Center ( T )
We introduce join candidate class to show the proce-dure of the candidate tree enumeration. A join candidate class J C ( C T ) consists of { C T ,J L ( C T ) ,J R ( C C
T ( | C T | = k  X  1) denotes the center tree, J L ( C T ) resents the list of left tree candidates and J R ( C T ) is that of right tree candidates.

We show an example of join candidate class in Figure 4. Left tree candidates L 1 and L 2 include C T as right tree. On the other hand, right tree candidates R 1 and R 2 con-tain C T as left tree. Figure 5 presents four candidate trees enumerated by the right-and-left tree joins in J C ( C T ) candidate trees which involve C T as center tree are entirely generated in join candidate class J C ( C T ) and never created in other classes. 4.2 Serial Tree Extension
As mentioned in Section 4.1, serial trees cannot be enu-merated by right-and-left tree join. Thus we consider the serial tree extension which appends a new node to the leaf node of a serial k -pattern.
 Definition 4.4. Given a serial tree T and a node v , the se-rial tree extension Ext ( T,v ) is defined as follows.
As well as right-and-left tree join, uniqueness of serial tree extension guarantees that all frequent serial trees are entirely enumerated only once in the candidate serial trees.
Consequently, all ( k +1)-pattern in F k +1 are definitely enumerated just once by right-and-left tree join or serial tree extension using F k . 4.3 Pseudo Code of AMIOT Algorithm
We show the pseudo code of AMIOT in Figure 6. Due to lack of space, we omit the details of how AMIOT works. F 2 and the minimum support  X  are given as input. AMIOT repeats the enumeration of candidate trees by right-and-left tree join and serial tree extension, and the frequency calcu-lations in the data trees to obtain the set of frequent trees in common with the procedure described in Section 3.1. Here 1: procedure AMIOT( F 2 ,  X  ) 2: k  X  2 3: while |F k | &gt; 0 do 4: for all T  X  X  k do 5: for all L  X  J L ( Lef t ( T )) do as right tree 7: end for 8: J R ( Lef t ( T ))  X  J R ( Lef t ( T ))  X  T 9: for all R  X  J R ( Right ( T )) do as left tree 11: end for 12: J L ( Right ( T ))  X  J L ( Right ( T ))  X  T 13: if T is a serial tree then as serial tree 14: for all M  X  X  2 ( rml ( T )) do 16: end for 17: end if 18: end for 19: for all C  X  X  k +1 do frequency check 20: if F S ( C )  X   X  then 22: end if 23: end for 24: k  X  k +1 increment the tree size 25: end while 26: Output F 2  X  X  3  X  X  4  X  X  X  X  27: end procedure F ( v )  X  X  2 gives the set of 2 -patterns of which root has label ( v ) .

We can count the root occurrences with preserved right-most occurrence lists and represent trees as depth-label se-quences in the same way with FREQT by Theorem 4.3.
In this section, we study the performance of AMIOT and demonstrate its effectiveness through several experiments. 5.1 Analytical Consideration
In this subsection, we evaluate the computational cost of candidate tree generation, the efficiency of enumeration and the memory space of AMIOT and FREQT.

We prove that the candidate tree enumeration in AMIOT can be executed in linear time. Right-and-left tree join re-quires only constant time because it is equivalent to right-most expansion of left tree with the rightmost leaf of right tree as described in Theorem 4.3. In addition, all candidate trees are generated without duplicates. Therefore AMIOT enumerates all candidate trees in linear time with respect to the number of the trees.

We describe the reason why AMIOT is more efficient than FREQT in enumeration. The candidate trees generated by right-and-left tree join are always produced by rightmost expansion due to Theorem 4.3. On the other hand, some of the candidate trees generated by rightmost expansion may not be enumerated by right-and-left tree join and they are actually infrequent. For example, in Figure 4, we assume an non-frequent candidate tree ( 2 , 1 )-expansion of L 1 is gen-erated by rightmost expansion, though it is not created in right-and-left tree join because J R ( C T ) does not include the right tree of ( 2 , 1 )-expansion of L 1 . In fact, the set of the candidate trees of size k enumerated by right-and-left tree join C A k and that of rightmost expansion C F k always sat-isfy C A k  X  X  F k , or more specially, |C A k | X |C F k | due to the reduction of infrequent candidate trees.
 We compare the memory usage of AMIOT and FREQT.
 FREQT with rightmost expansion can discover the fre-quent trees with small memory space because it performs in depth-first manner. In contrast, AMIOT is essentially a breadth-first algorithm. Therefore AMIOT requires the larger memory space than FREQT since it needs to preserve a number of trees in main memory at the same time. It is possible, however, to reduce the memory space to some de-gree by dividing the search space using the characteristics of tree and right-and-left tree join. For instance, we present depth-by-depth enumeration method. The method increases the maximum depth of candidate trees one-by-one, and then disposes the candidate trees of maximum depth d before the candidate trees of maximum depth d +2 are enumerated be-cause a couple of trees are never joined if their maximum depths differ by more than 2. 5.2 Experimental Results with Synthetic Data We evaluate the performance of AMIOT and FREQT.
 In order to achieve the best performance, we implement AMIOT with the depth-by-depth enumeration and FREQT with node-skip and edge-skip. Table 1 shows the experi-mental environments. The mining algorithms are executed on the Mining-PC.
 We generate synthetic dataset with several parameters, Main Memory 512MB 1GB Java Version Sun JDK 1.5.0 01 JavaVM Option -Xmx350m -Xmx800m
Figure 7. Original Trees for Synthetic Dataset original data tree D , label set L , maximum value of size ( maxSize ) and maximum value of depth ( maxDepth ). We produce the assigned number of data trees by insert-ing and appending some nodes with a random label to D and store them in main memory. In the experiments, we apply T W and T D ( | T W | = | T D | =15 ) in Figure 7 and produce the datasets S W n and S D n . Here n gives the num-ber of data trees. Other parameters are given as |L| =10 , maxSize =50 , maxDepth =10 . The average size of the data trees is 33 .
 During the execution with minimum support  X  =0 . 5% , AMIOT and FREQT discover exactly the same set of fre-quent trees. Figure 8 and Figure 9 show the results of the execution time, enumeration efficiency and memory space. Both of diagrams (a) in Figure 8 and Figure 9 indicate that the execution time of algorithms increases linearly with the size of dataset. The time complexity of tree mining algo-rithm never becomes less than linear due to the necessity of database scan for frequency calculations. Therefore we conclude that AMIOT has the property of sufficient scal-ability. Compared with FREQT, AMIOT is two and half times faster on S W n and five times faster on S D n .
In order to validate the reason why AMIOT performs faster, we present the size of each C k with the condition n =10 4 in Figure 8 (b) and Figure 9 (b). The size of set on AMIOT approaches the actual number of frequent trees. In contrast, the set on FREQT includes a lot of non-frequent candidate trees. This distinction directly leads to the dif-ference of the execution time. Furthermore, the larger the average of maximum depths is, the more efficient the enu-meration by right-and-left tree join becomes. Thus the ad-vantage of AMIOT is clearer on S D n than S W n .
The memory usages in the experiments with n =10 4 are drawn in Figure 8 (c) and Figure 9 (c). The memory space depends on the property of data trees such as max-imum depth because of the difference of depth-first man-ner and breadth-first manner as described in Section 5.1. In this case, AMIOT temporarily requires at most one and half times larger memory space than FREQT.
 5.3 Experimental Result with XML
We apply the algorithms to XML as an actual tree-structured data. XML is the standard mark-up language which describes data in tree-structure. A lot of XML-based formats have been proposed recently in various fields such as web services and bioinformatics. Thus XML is clearly the most important target of semi-structured data mining.
We study the performance of both algorithms with the experiments using XML on the same environment in Sec-tion 5.2. If we assume that a tree mining algorithm performs in real applications, XML data must be stored in some kind of database on Database-PC and the mining software should be executed on Mining-PC. When the mining soft-ware needs to access the data trees in the database, it sends queries and receives responses from the database via net-work because it is unrealistic to store all XML documents in the main memory of Mining-PC. We utilize a native XML database, Xindice [2] for the experiments though there are some techniques to covert and store XML into a relational database. ToXGene is a template-based XML generator for the benchmark of the performance of XML databases [9]. Using ToXGene, we generate 10 4 XML documents similar to the example shown in Figure 10 with a XML template and store them in Xindice running on Database-PC. The av-erage size of the data trees is about 200 and the average of maximum depth is 5.

We execute AMIOT and FREQT with minimum support  X  =2 . 0% increasing the number of target trees gradually. The obtained set of frequent trees are surely equivalent be-tween two algorithms. Figure 11 presents an example of the discovered frequent trees by the mining algorithms. The association between the branches is important in real appli-cations. We show the results in Figure 12. Figure 12 (a) indicates that AMIOT discovers all frequent trees five times faster than FREQT independently of the size of database. Figure 12 (b) shows that AMIOT consumes at most one and one-third times memory space than FREQT in the experi-ment with 2 , 000 data trees because FREQT preserves all frequent trees of size 2 and their rightmost occurrence lists during execution in common with AMIOT. Since the occur-rence list of size 2 tends to become large, the memory space of both algorithms does not have much difference.
In conclusion, AMIOT performs by up to five times faster and requires at most one and half times memory space than FREQT though the performance of the algo-rithms strongly depends on the structural property of data trees.
In this paper, we focus on the frequent tree pat-tern discovery problem and propose AMIOT algorithm which reduces infrequent candidate trees to avoid redun-dant database scans. AMIOT efficiently enumerates only the candidate trees with high probability of being frequent by using right-and-left tree join method Right-and-left tree join generates a candidate tree by joining two frequent trees of same size in a similar way of Apriori. Serial tree ex-tension is devised as a complemental enumeration method that enumerates the candidate trees with only one leaf node since right-and-left tree join never generates the serial trees. We derive join candidate class for the enumeration in linear time of the number of candidate trees.

We evaluate the performance of AMIOT in comparison with FREQT. The experimental results on synthetic dataset and XML database show that AMIOT has sufficient scala-bility because the algorithm performs in linear time with re-spect to the size of data trees. The experiment on synthetic dataset indicates that AMIOT is more effective for mining in the data trees of higher depth. We show that AMIOT per-forms much faster than FREQT in real applications such as mining in XML database on Database-PC due to the reduc-tion of redundant database scans because the database scan via network requires much more expensive cost. On the other hand, we have to improve the memory consumption of AMIOT since it basically adopts a breadth-first approach. We need further studies; (1) the comparisons with TreeMiner, Chopper and XSpanner for the embedded tree discovery, and (2) the application of right-and-left tree join for other frequent structure mining such as frequent un-ordered tree discovery, or mining frequent free trees in a graph-structured database.

The part of this research was supported by Grant-in-Aid for Scientific Research (16016248) of the Ministry of Edu-cation, Culture, Sports, Science and Technology, Japan. [1] R. Agrawal and R. Srikant. Fast algorithms for mining asso-[2] Apache. Xindice. http://xml.apache.org/xindice, 2002. [3] T. Asai, K. Abe, S. Kawasoe, H. Arimura, H. Sakamoto, [4] T. Asai and H. Arimura. Algorithms for mining semistruc-[5] R. J. Bayardo Jr. Efficiently mining long patterns from [6] Y. Chi, Y. Yang, and R. R. Muntz. Hybridtreeminer: An [7] J. Han, J. Pei, and Y. Yin. Mining frequent patterns with-[8] S. Hido and H. Kawano. Proposal of efficient enumeration [9] IBM alphaWorks. ToXgene -the ToX XML Data Generator. [10] A. Inokuchi, T. Washio, and H. Motoda. An apriori-based al-[11] A. Inokuchi, T. Washio, and H. Motoda. Applying the [12] T. Kudo and Y. Matsumoto. A boosting algorithm for clas-[13] S. Nijssen. Frequent structure mining: Efficiency is-[14] J. R. Punin, M. S. Krishnamoorthy, and M. J. Zaki. Web [15] C. Wang, M. Hong, J. Pei, H. Zhou, W. Wang, and B. Shi. [16] M. J. Zaki. Efficiently mining frequent trees in a forest. In
