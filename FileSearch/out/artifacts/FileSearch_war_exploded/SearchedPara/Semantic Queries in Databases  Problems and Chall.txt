 Supporting semantic queries in relational databases is essential to many advanced applications. Recently, with the increasing use of ontology in various applications, the need for querying relational data together with its related ontology has become more urgent. In this paper, we identify and discuss the problem of querying rela-tional data with its ontologies. Two fundamental challenges make the problem interesting. First, it is extremely difficult to express queries against graph structured ontology in the relational query language SQL, and second, in many cases where data and its re-lated ontology are complicated, queries are usually not precise, that is, users often have only a vague notion, rather than a clear understanding and definition, of what they query for. We outline a query-by-example approach that enables us to support semantic queries in relational databases with ease. Instead of endeavoring to incorporate ontology into relational form and create new language constructs to express such queries, we ask the user to provide a small number of examples that satisfy the query she has in mind. Using these examples as seeds, the system infers the exact query automatically, and the user is therefore shielded from the complex-ity of interfacing with the ontology.
 H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Query formulation ; H.5 [ Information Interfaces and Presentation ]: Miscellaneous Algorithms
There is an urgent need to incorporate ontology into the realm of object relational databases (ORDBMs) so that the user can query  X 
Work done while author is at IBM T J Watson.  X  Work done while author is at IBM T J Watson.
 data and its related ontology in a consistent manner [6, 12, 18]. Fu-eling this need to support semantic queries in relational databases is a growing number of advanced applications such as product in-formation management (PIM) systems, customer relationship man-agement (CRM) systems, electronic medical records (EMRs) sys-tems, etc.

Consider an EMR (electronic medical records) system. Clini-cians recording the diagnosis of a patient visit may use different disease codes for the same symptoms that the patient is exhibiting. One clinician might describe a patient diagnosis using the code for  X  X umor of the Uvea X , while another might use the code for  X  X ris Neoplasm X . In the patient X  X  EMR a generic term such as  X  X ye Neoplasm X  might be recorded instead of the more specific  X  X u-mor of the Uvea X  (we will use the more descriptive terms instead of the corresponding codes in this paper in the interest of readabil-ity). Hence, in order to obtain meaningful results from querying an EMR database, the query processing system needs to understand the semantics of the query and the data.

The need for data semantics has spurred the increasing use of on-tology in various applications. Continuing with the EMR example, many ontologies have been developed to capture the semantics of various sub-components of EMR data. For example, the National Cancer Institute (NCI) Thesaurus [14] is a collection of ontolo-gies spanning the following areas: Drugs and Chemicals, Diseases Disorders and Findings, Anatomic Structure System or Substance, Gene, Chemotherapy Regimen etc. Fig. 2 shows a fragment of the NCI Thesaurus in graphical form. Moreover, many of these on-tologies are well integrated with existing data coding terminologies (eg, SNOMED [9], ICD9 [8]) used by industry EMR formats such as HL7 [7] and CCR [5]. With the confluence of ontologies, coding terminologies, and data standards, the need for querying relational data along with its related ontology has become even more urgent.
Although we recognize the importance of querying relational data along with its related ontology, it is extremely tedious and time consuming to understand ontology, and use ontology in database queries. The success of the relational database technology is at least partly due to the spartan simplicity of its data model and query lan-guage, which insulate the user from the physical implementation of the database. But for semantic queries, users are often exposed to the full complexity of the ontology. Still, integrating data and its related ontology is a challenge too important to ignore. There are two major approaches in attacking this problem. One is to flat-ten graph-structured ontologies into relational form [6, 18], and the other is to extend ORDBMSs and SQL to handle non-relational data directly [11, 12]. However, both approaches incur tremendous system cost, but have limited success in taking the tediousness out of handling semantic queries.

In this paper, we discuss the problems and challenges of support-ing semantic queries in database systems. Our experience tells us that if the semantic query can be expressed using traditional query languages such as SQL, processing the semantic query is relatively straightforward even though the challenge of query optimization remains. The crux of the problem lies in the difficulty and complex-ity of expressing the semantic queries. There are two fundamental challenges in expressing semantic queries. First, ontologies are in-herently graph-structured and expressing graph structured queries succinctly is extremely difficult. Second, there is often a mismatch between the semantics in the users mind and the semantics ex-pressed in the ontology. Consequently semantic queries are often difficult to be crisply defined. One possible solution is to define new query languages that would allow the user to express graph-structured queries more easily. Even then, the second challenge is not addressed. The future success of incorporating ontologies into practical database query processing depends on whether we can find automatic or semi-automatic methods to help users express se-mantic queries.

Our investigation into the problem of expressing semantic queries lead us to find a different approach that would insulate the users from the complexity of the ontology, yet still enable them to ask every possible semantic query. We believe that a semi-automatic framework is required that would bridge the gap between a query in a user X  X  mind and the final result of the query. Furthermore, the users should not be required to handle the ontology directly, or to map the ontology into a relational form.

The rest of the paper is organized as follows. The next two sec-tions describe the two fundamental challenges in detail. Section 4 summarizes the requirements needed to address the two challenges. Section 6 concludes with an outline of a possible approach.
The first fundamental challenge is the difficulty in expressing queries against a graph structured ontology. The following example illustrates the complexity of expressing semantic queries in SQL.
E XAMPLE 1 (R UNNING E XAMPLE ). Suppose we have a ta-ble of patient visit records as shown in Fig. 1, of which the diagno-sis column is associated with the NCI Thesaurus ontology (Fig. 2). Consider the query to find all patients diagnosed with eye tumor. Using existing RDF-like data models [18], we could store the ontol-ogy as triples in the Thesaurus(src,rel,tgt) relation and attempt to write the query in Example 1 using recursive SQL: Alternatively, if we write the same query against the original XML format of the NCI Thesaurus, we have the following.
 In both instances, it is not straight-forward to write the query and the user needs to have an intimate knowledge of the structure of the ontology such as existence of  X  X ynonym X , and  X  X s_a X  edges.
The second fundamental challenge is the inherent fuzziness in the semantics of the query. In most practical applications, the data and the ontology behind it are quite complicated and consequently the queries are no longer exact, that is, users often have no more than a vague notion, rather than a clear understanding and defini-tion, of what they query for. In other words, even if the users have intimate knowledge of the structure of the ontology, they might not be able to precisely specify what they want to find.

E XAMPLE 2. Find all patients diagnosed with some disease in the choroid, which is part of the eye.
 Intuitively, the user wants to find patients with some disease that af-fects or is located in the choroid. In the NCI Thesaurus, there are 3 separate types of relationship linking disease concepts to anatomic locations: 1 . Disease_Has_Primary_Anatomic_Site 2 . Disease_Has_Associated_Anatomic_Site 3 . Disease_Has_Metastatic_Anatomic_Site
Even if the user knows the structure of the NCI Thesaurus ontol-ogy, i.e., she knows about the three types of relationships that are relevant to the query, without looking at the results, the user still may not know whether the query should use one of these relation-ships to  X  X horoid X  or all of them. If the user does not know the structure of the ontology at all, then he certainly would not know how to specify the query exactly. The query semantics is certainly not crisp and hence not easily expressed in SQL especially when the structure of the ontology is not well-known to the user.
Our investigation lead us to explore semi-automatic approaches for helping the user to express the semantic queries. In order to address the two challenges we identified, an ideal semi-automatic method needs to satisfy the following requirements.

First, the user should not need to know the structure of the ontol-ogy intimately. Ontologies are complex representations of knowl-edge that are meant for computer processing. It would defeat the purpose of having machine readable ontologies, if the user still needs to understand and know the ontologies.

Second, the user should not need to know how the ontology is modeled and stored in the database. The user should be able to pose the semantic query independent of how the ontology is stored and modeled in the database.

Third, we do not need another query language. Having the user learn another query language and express her semantic queries in it is not reducing the complexity of the task.

Fourth, the user needs to be able to refine the semantic query to match her information needs. As we have previously shown, semantic queries are rarely crisply defined.

One particular semi-automatic approach that we are investigat-ing is using the query by example (QBE) paradigm for semantic queries. The QBE paradigm takes advantage of user-provided ex-amples that satisfy the query as seeds to automate the query pro-cess. Specifically, we envision the semantic QBE approach as con-sisting of three steps. In the first step, the user provides several examples that satisfy the query she has in mind. In the second step, the system learns the semantics of the query from the given ex-amples and their related ontologies. In the third step, the system applies the semantics on the data to generate the entire query re-sult and return it to the user. In the query processing process, as an optional active learning mechanism, the user will be probed sys-tematically to determine whether certain tuples satisfy her query in order to help clarify her intention and speed up the query pro-cessing process. False positive errors in the query results can be detected by the user and fed back to the system as part of the active learning process. Since a semantic query is inherently fuzzy, the user typically expects only a subset of the full results, false neg-ative errors can be ameliorated by doing active learning until the desired number of result tuples are obtained.

Using the QBE approach for Example 1, the user no longer needs to write the unwieldy SQL queries, but instead provides examples of tuples, say tuples with vID 4 &amp; 5, that satisfy the query she has in mind. In other words, our method insulates the user entirely from the complexity of understanding and using ontologies. Con-sequently, there is no need to map ontologies into relational form.
Managing ontology data alone is not a new topic and several sys-tems have been developed [13, 15, 16, 19, 20] during the past years. Some of these systems store ontology data in a file system, making querying them very hard [16]. The other systems transform the on-tology data into RDF form and store the RDF triples in a relational database. Processing of ontology-related queries in these systems is typically done by an external middle-ware (wrapper) layer built on top of a DBMS engine, and DBMS users can X  X  really reference ontology data directly.

Querying relational data together with their semantics encoded in ontology is an emerging topic that attracts a lot of attentions re-cently. Das et al. [6] proposed a method to support ontology-based semantic matching in RDBMS using SQL directly. Ontology data are pre-processed and stored in a set of system-defined tables. Sev-eral special operators and a new indexing scheme are introduced. A database user can thus reference the ontology data directly using the new operators. The main drawback of their approach is that se-mantic queries involving the ontology data are usually hard to write and costly to process (in terms of both processing time and storage overhead) due to the graphical structure of the ontology data and the need for reasoning (i.e., transitive closure computation) on the ontology data.

In [12], virtual view is proposed as a way to represent relational data together with their related ontology data in a relational view. However, there are three requirements to apply the virtual view idea: (a)language extensions to SQL to support the creation and use of the virtual view, (b) the DBMS engine must support native XML data (together with relational data) and the processing of the virtual view related operators, and (c) to create a virtual view, the user must understand the complex ontology data and their relation-ship with the base relational data completely.

Query by Example (QBE) is a well-known concept in database community. It was first proposed by Mosh X  M. Zloof in the mid 1970s [21, 22] as a query language that can be used by database users to define and query a relational database. It is quite different from SQL in that it is a graphical query language. Its interface is usually virtual tables where the user could enter commands, exam-ples, etc. After QBE was presented, most research work around QBE has been focused on enrichment and extension of QBE as a query language and developing efficient methods for generating and processing the queries defined by the examples [10].
In commercial database products, QBE is widely used as graph-ical front-end for RDBMSs [1]. It is also used as a convenient in-terface for users to specify queries for image, video, and document databases, and various techniques have been studied [2, 3, 4, 17].
There are two common characteristics for all the previous QBE work: (a) the examples are used to specify a query that will be gen-erated (b) the generated query is a  X  X ormal X  query in terms that all the query conditions (may be in the forms of similarity measures) are defined on the base attributes in the underlying tables.
The semantic QBE problem we discussed in their paper is very different from the traditional QBE problem. First, due to the com-plexity of the semantic information associated with the data in the base relational tables, the real query associated with the user X  X  in-tention which is specified by the input examples is really hard (or impossible) to capture by a traditional SQL query. Secondly, in the problem we described, the underlying  X  X uery X  is defined not only on the base attributes in the relational table, but also on the seman-tics of the base data encoded in the ontology and the connections between the relational data and the ontology data.
In this paper, we have argued for the importance of the prob-lem of expressing semantic queries and identified two fundamental challenges, namely, the complexity of expressing graph structured queries, and the fuzziness of semantic queries. To address these two challenges, we believe that semi-automatic approaches are needed to help user formulate semantic queries and we outlined several im-portant requirements. We also propose to use the query by example (QBE) paradigm for semantic queries, because it addresses the re-quirements we identified. As future work we plan to investigate the concrete algorithms to realize the QBE paradigm for semantic queries. [1] A. Balter. Mastering Microsoft Office Access 2007 [2] M. Belkhatir, P. Mulhem, and Y. Chiaramella. A conceptual [3] G. Boccignone, A. Chianese, V. Moscato, and A. Picariello. [4] A. K. Choupo, L. Berti-Equille, and A. Morin. Optimizing [5] ASTM E2369-05 Standard Specification for Continuity of [6] S. Das, E. I. Chong, G. Eadon, and J. Srinivasan. Supporting [7] Health level seven. http://www.hl7.org . [8] International Classification of Diseases, Ninth Revision, [9] Systematized Nomenclature of Medicine-Clinical Terms. [10] R. Krishnamurthy, S. P. Morgan, and M. M. Zloof.
 [11] L. Lim, H. Wang, and M. Wang. Semantic data management: [12] L. Lim, H. Wang, and M. Wang. Unifying data and domain [13] L. Ma, Z. Su, Y. Pan, L. Zhang, and T. Liu. RStar: An RDF [14] National cancer institute thesaurus. http://www.nci. [15] OntoBroker. http://ontobroker.aifb. [16] OTK tool repository: Ontoedit. http://www. [17] N. Rasiwasia, N. Vasconcelos, and P. J. Moreno. Query by [18] SWAD-Europe Deliverable 10.2: Mapping Semantic Web [19] The KArlsruhe ONtology and semantic web tool suite. [20] The prot X g X  ontology editor and knowledge acquisition [21] M. M. Zloof. Query-by-example: the invocation and [22] M. M. Zloof. Query-by-example: A data base language. IBM
