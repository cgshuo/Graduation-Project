
Kenji Hashimoto, Fumikazu Takasuka, Kimihide Sakano, Yasunori Ishihara, Nowadays, many people and organizations have a growing interest in data se-curity. For a database system to be secure, secrecy, integrity, and availability of data must be achieved appropriately w ith respect to a given security policy. View mechanisms has played a principal role in achieving the secrecy of database systems. Views can avoid direct accesses t o sensitive information in the data-information can be inferred using auth orized views as well as general domain knowledge. Inference attacks mean that a user infers the sensitive information from the information to which accesses are permitted. It is important for data-base managers to know beforehand the possibility that the inference attacks succeed, because databases are often used as the core of the systems requiring high-level security (e.g., e-business, Web services).
 Example 1. We show an example of inference a ttacks on XML databases, which are getting used actively in many organizations recently. Fig. 1 illustrates an XML document D to be attacked. The document D is valid against the following schema A : &lt;!ELEMENT students (student*)&gt; &lt;!ELEMENT student (name, TA?, scholarship?)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT TA (course+)&gt; &lt;!ELEMENT course (#PCDATA)&gt; &lt;!ELEMENT scholarship (#PCDATA)&gt; We consider the following two authorized queries T 1 and T 2 on D :Query T 1 extracts, for each student receiving a scholarship ,the course sofwhich the student is a teaching assistant ( TA ) and the amount of the scholarship . Fig. 2 shows the result T 1 ( D ). Query T 2 extracts, for each student who is a TA of  X  X etwork X  and/or  X  X atabase X , the student  X  X  name and a TA node with the course s  X  X etwork X  and/or  X  X atabases X  of which the student is a TA .Fig.3 and T 2 ( D ), it can be inferred that the student named  X  X lice X  does not receive a scholarship , because T 2 and T 2 ( D ) indicate that  X  X lice X  is a TA of both  X  X etwork X  and  X  X atabase X , and T 1 and T 1 ( D ) indicate that no student who is a TA of both course s receives a scholarship .
 Inference attacks on relational datab ases have been studied for a few decades. the structural information is useless to infer the sensitive information in many situations. On the other hand, the structure of XML databases, which is modeled as labeled ordered trees, is flexible an d complicated. Attackers may use such that verification frameworks for the security against inference attacks on XML databases take account of inference using structural information directly. In this paper, we adopt a concept of k -secrecy against inference attacks on XML databases. The underlying idea is similar to -diversity in [1]: It is con-sidered to be insecure that the set of candidates for the value of the sensitive information can be narrowed down by inference. More formally, let D be an XML document to be attacked. Suppose that the following information is available to the attacker:  X  the schema A of D ,  X  authorized queries (i.e., view definitions) T 1 ,..., T n ,  X  aquery T S to retrieve the sensitive information in D .
 The set of candidates for the value of the sensitive information inferred by the attacker is where TL ( A ) is the set of the XML documents valid against A .Thatis, C is the set of all T S ( D ) such that D behaves the same as D with respect to queries T ,...,T n .Notethat C is never empty because C always contains T S ( D ). Then, D is k -secret with respect to T S under the authorized queries T 1 ,..., T n if |
C Note that this formalization is general and not specific to XML databases; it is easily applicable to other kinds of databases.

The main contribution of the paper is to propose a verification framework with respect to the above security formalization. In the framework, an XML document is modeled as a labeled ordered tree as usual. A schema is represented by a tree automaton, which is the theoretical foundation of Relax NG [2]. A query is represented by a composition of relabeling and/or deleting tree transducers . Our queries are a subclass of XSLT but st ill practical becaus e filtering nodes according to any of their neighboring no des such as ancestors, descendants, and siblings is expressible.

Then, a verification method based on the above framework is straightfor-wardly derived. The method consists of four steps and simulate the attacker X  X  its result T i ( D ), compute a tree automaton representing the set of candidates for D determined by T i and T i ( D ). In the second step, compute the intersec-tion of the tree automata. In the third step, then, compute a tree automaton
However, it is expected that the straightforward method spends a large time in the first step because large tree automata will be produced as intermediate results. The large tree automata can contain many states and transition rules to represent candidate documents which will not be valid against the schema A in the next step. We improve the first step so that intermediate results which contain less such  X  X nnecessary X  states and rules is produced by using the in-formation of the schema. We have found by experiment that time efficiency is improved by the modification.

The rest of the paper is organized as fo llows. Section 2 reviews related works on inference attacks. Section 3 introdu ces models of XML documents, schemas, and queries. Section 4 proposes a verification method and its modification for the security against inference attacks on XML databases. Section 5 mentions the prototype systems and discusses a direction of further improvement of the verification methods. Sect ion 6 summarizes the paper. As stated in Section 1, infer ence attacks on relationa l databases have been stud-ied for a few decades. Inference attacks using aggregate functions are one of the most famous threats in statistical relational databases [3]. Disclosure Monitor [4] is a part of a database management system that monitors information disclosure by inference attacks. [5] incorporates into Disclosure Monitor a mechanism that accomplishes maximum data availability as long as given sensitive information is secure against inference attacks. Also, several sophisticated formalizations of the security have also been proposed, e.g., the one based on information theory [6,7], the one based on rough set theory [8]. Moreover, [9,10] proposes stronger security definitions where the probability distribution of possible secrets does not change before and after authorized views a nd the answers of them are given.
Recently, the security against inference attacks on relational databases is often discussed in the context of privacy protection. Reference [11] proposes a formal-ization of the security, called k -anonymity, which means that for each person, there are at least k tuples in the view that can be associated with the person. After that, some weakness of k -anonymity has been pointed out. For example, [1] demonstrates that even if the database is k -anonymous, the k or more tuples for a person may have the same sensitive value, so the person X  X  sensitive information may be identified. Then, [1] proposes the notion of -diversity, which means that for each person, there are at least possible values (or bits in entropy, etc.) for the person X  X  sensitive information. Reference [12] states that a person X  X  privacy should be customizable by the person, and proposes the notion of personalized anonymity. This paper adopts a concept of k -secrecy similar to -diversity.
AsforXMLdatabases,thenotionofsecurityviewsisproposedin[13].A security view consists of a view XML document and its DTD, and contains no information that may be useful to infer the sensitive information. However, the to use schema information and functional dependencies as well as the view XML document. Then, an algorithm for finding a maximal view document without allowing successful inference attacks is proposed. Both of these researches assume the  X  X ingle-view X  environment, that is, to each user only one view is given. In relational databases, [9] and [10] study the security against multiple-view inference attacks, which can provide more availability in general. This paper assumes the  X  X ultiple-view X  environment in XML databases.
 In this section, first, ordinary models of XML documents and schemas are in-troduced. Then, a model of queries is presented, which is one of the originality of this paper. 3.1 XML Documents An XML document is represented by an unranked labeled ordered tree, i.e., a labeled ordered tree where the number of the children of a node is not bounded. Let  X  be an alphabet including special symbols $ and #, which will be explained in Definition 5 of Section 3.3. Let T  X  denote the set of the unranked labeled the tree which has a root labeled with a and its immediate subtrees t 1 ,  X  X  X  ,t n from the left in the order.
 Definition 1. T  X  is defined as the smallest set satisfying the following condi-tion: a ( t 1  X  X  X  t n )  X  X   X  if a  X   X  and t 1 ,...,t n  X  X   X  ( n  X  0 ). We write a instead of a ( ).

As many theoretical studies do, we would like to avoid distinguishing text nodes (i.e., nodes with string values) with element nodes (i.e., nodes with tag names). However, regarding string values as tag names is not suitable for our should be infinite while the set of tag names defined in a schema is only finite. Therefore, we simulate a text n ode by an element node named string and its children which are also element nodes labeled by the constituent characters. For example, the text node with value  X 500 X  in Fig. 1 is simulated by a string node and its three children labeled with  X 5 X ,  X 0 X , and  X 0 X , respectively (see Fig. 4). 3.2 Sets of XML Documents In this paper, we use a non-deterministic tree automaton (NTA) to represent schemas or sets of candidates for the value of the sensitive information. Definition 2. An NTA A is a 4-tuple ( Q,  X ,  X  q, R ) ,where  X  Q is a finite set of states,  X   X  is an alphabet,  X   X  q  X  Q is the initial state, and  X  R is a set of transition rules in the form of ( q, a, e ) ,where q  X  Q , a  X   X  , Let t = a ( t 1  X  X  X  t n ), where a  X   X  and t 1 ,...,t n  X  X   X  .Let q ( t )denotethe configuration representing that the root of t is associated with a state q .If by A . 3.3 Queries Each query is represented by a compositi on of some relabeling tree transducers and a deleting tree transducer introduced below.
 Definition 3. A (deterministic) bottom-up relabeling tree transducer (BRTT) T
B is a 4-tuple ( Q,  X ,  X  q, P B ) ,where  X  Q is a finite set of states,  X   X  is an alphabet,  X   X  q  X  Q is the final state, and  X  P B is a set of transformation rules in the form of a ( e )  X  q ( a ) ,where A BRTT relabels nodes dependently on their descendants. Formally, let t p = P
B and q 1  X  X  X  q n  X  L ( e ). Let T B ( t )( t  X  X   X  )denote t  X  X   X  such that T B can move from t eventually to  X  q ( t ).
 Example 2. The following BRTT T B =( Q B , X ,  X  q, P B ) relabels every student which has no scholarship to $, given a document valid against the schema { phabetic characters and symbols, and P B consists of the following rules:  X  /* Each leaf a is associated with state q 1 .*/  X  /* Each of string , name , course ,and TA is not relabeled. */  X  /* scholarship is not relabeled but the existence of scholarship  X  /* student is relabeled with $ if and only if it has no q 2 as a child  X  /* students is not relabeled and the final state  X  q is reached Definition 4. A (deterministic) top-down r elabeling tree transducer (TRTT) T
T is a 4-tuple ( Q,  X ,  X  q, P T ) ,where  X  Q is a finite set of states,  X   X  is an alphabet,  X   X  q  X  Q is the initial state, and  X  P T is a set of transformation rules in the form of q ( a )  X  a ( q ) ,where A TRTT relabels nodes dependently on their ancestors. T T can move from con-Note that by definition a state associated with a leaf node will disappear after the next transformation step because a leaf node is a node with the empty se-quence of child subtrees. Let T T ( t )( t  X  X   X  )denote t  X  X   X  such that T T can move from  X  q ( t ) eventually to t  X  X   X  .
 Example 3. The following TRTT T T =( Q T , X ,  X  q, P T ) relabels every TA to # and every name to $, given a document valid against the schema A in Example 1 as an input tree of T T : Q T = {  X  q, q 1 } ,  X  contains { phabetic characters and symbols, and P T consists of the following rules:  X  /* students is not relabeled and its children are associated with q 1 .*/  X  /* name is relabeled with $.*/  X  /* TA is relabeled with #. */  X  /* The others are not relabeled. */ Definition 5. A (deterministic) del eting tree transducer (DTT) T D is a 4-tuple ( { q 0 ,q,q d } , X ,q 0 ,P D ) ,where A DTT deletes #-labeled nodes of the input tree and subtrees rooted by $-labeled nodes of the tree, traversing in a top-down manner. Exceptionally, the root of the input tree is never deleted to ensure that the output is a tree. Note that we have a unique DTT when  X  is fixed. So, we simply write T D as a unique transformed to t = a ( bdeb ( f )) by a DTT.

In this paper, a query is assumed to be a composition of some of BRTTs and/or TRTTs, followed by a DTT. In our model, a query can filter and/or relabel nodes according to any of their n eighboring nodes such as ancestors, de-scendants, and siblings, but cannot reconstruct the input tree with its document order changed or add new nodes to the input tree. From a practical point of view, this class of queries seems sufficien t because many queries to databases es-sentially extracts some parts of its content. We also assume that no constituent labels a node to #. Therefore, T S can delete some subtrees of the input tree, but cannot delete only internal nodes. Without this assumption, candidates for the value of the sensitive information canno t be represented by an NTA in general. Moreover, we assume that each authorized query T i is total to TL ( A )where A is the schema of the XML document D to be attacked, i.e., for each t  X  TL ( A ), there is T i ( t )  X  X   X  .
 Example 4. T 1 in Example 1 can be represented by T D  X  T T  X  T B where T B and T
T are given in Example 2 and 3 respectively. inference attacks on XML databases are presented. The input and output of these methods are as follows: Input. The schema A of an XML document D to be attacked, authorized Output.  X   X  -secret X  if D is  X  -secret with respect to T S under the authorized 4.1 A Straightforward Method: M1 A straightforward method M1 consists of the following four steps: 1. For each i (1  X  i  X  n ), construct an NTA A i which accepts D such that 2. Construct an NTA A D which recognizes the set of the candidates for D , i.e., 3. Construct an NTA A S which recognizes the set of the candidates for the
In Step 1, each A j i can be constructed from T R,j i or T D and A j  X  1 i using a technique called inverse type inference [15]. Roughly speaking, A j i can be con-structed by composing e ach transition rule of A j  X  1 i and each transformation rule of the transducer. Likewise, in Step 3, A j S can be constructed from T R,j S or T D and A j  X  1 S using a technique called type inference .InStep4,  X  -secrecy non-useless transition rules of A S form a cycle or the string automaton of some non-useless transition rule of A S recognizes an infinite language. Also, whether | A accepted by A S . 4.2 A Modified Method: M2 constructed as an intermediate result. Since T D is a DTT which deletes all the #-embedding #-nodes into T i ( D ). However, such arbitrary embedding is often wasteful because it causes many  X  X nappropriate X  candidates in TL ( A 0 i ). More T i ( D A ) for any D A
A modified method M2, obtained by improving Step 1 of M1, uses the infor-mation of A in order to avoid arbitrary embedding of #-nodes. First, in Step 1 of M2, an NTA A F such that A
F are compared in a top-down manner. Roughly speaking, for a node and its by the comparison. The positions may be between some children and/or between the parent and some children. Then, the output NTA of Step 1 is constructed by embedding #-nodes into the positions other than the identified ones of T i ( D ). Basedonthetwoverificationmethodsi n Section 4, we have implemented pro-totype systems. The systems are written in Java and are running on a Windows XP machine with Intel Xeon X5355 2.66GHz CPU and 1.4GB Java VM heap memory.

We used the following schema: &lt;!ELEMENT students (student*)&gt; &lt;!ELEMENT student (name, gender, scholarship)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT gender (#PCDATA)&gt; &lt;!ELEMENT scholarship (#PCDATA)&gt; where amount of scholarship was either 0 or 500. Also, we used the authorized queries T 1 and T 2 , and the secret query T S as follows: T 1 extracts, for each student receiving a scholarship , i.e., amount of scholarship is not 0, the gender of the student and the amount of the scholarship ; T 2 extracts, for each student ,the name and the gender of the student ; T S extracts the name and the scholarship of a particular student . In addition, to make the intermediate results the largest, in each of the XML documents half of all student s receive scholarship s. We executed the prototypes to decide 2-secrecy of such XML documents. Fig. 5 shows verification times and the sum of the size of A 0 i sinStep1of Q is the set of the states of the NTA, R is the set of the transition rules of the NTA, and the size | e | of a string automaton e is the sum of the number of the states of e and the number of the tuples (consisting of a source state, an input symbol, and a destination state) satisfying the transition relation of e .Asshown in Fig. 5, the size of A 0 i in M2 was much smaller than that in M1. While M1 only verified at up to eighty-three because it exhausted heap memory in Step 1 at eighty-four, M2 did at up to a hundred and twenty-three and it exhausted memory in not Step 1 but Step 3. Also, M 2 verified about twenty seconds faster than M1 at eighty-three. We have proposed a verification framework for the security against inference at-tacks on XML databases. The methods proposed in the framework are applicable according to any of their neighboring no des such as ancestors, descendants, and siblings. We have presented the straightforward method and its modification, and confirmed by experiment that the mo dification has effect in time efficiency.
One of our future works is to confirm the effect of the modification in time efficiency by experiment with many othe r instances. Another future work is to take account of attacks using functional dependencies and extend the proposed verification method against such attacks. Also, we would like to propose a static verification method for the security, i.e., given authorized queries and schema information, deciding whether every document valid against the schema is k -secret. Since the running time of static verification does not depend on the results of authorized queries on a databa se instance, the static verification can work even for a large database instance.
 This research was supported in part by  X  X lobal COE (Centers of Excellence) Program X  of the Ministry of Education, Culture, Sports, Science and Technol-ogy, Japan, and by the Telecommunications Advancement Foundation, Japan. Also, the authors thank Mr. Shinichi Minamimoto of Osaka University for im-plementing the prototype system.

