 Frequent pattern miners often discover unmanageable number of patterns. To overcome this problem, several algorithms for mining closed patterns, e.g. [6,3], as well as constrained patterns, e.g. [4,5], have been proposed. Although we can expect to obtain more sophisticated and p owerful miners by combining these two approaches, no such algorithm for structured data mining is proposed as far as the authors know. In this paper, in order to provide such kind of tools for mining in tree-structured databases, we propose two algorithms for discovering closed induced ordered subtrees under anti-monotone constraints about the shape of patterns such as maximum size and maximum height. The proposed algorithms discover closed constrained subtrees not by post-processing but by the search with the pruning based on the occurrence-match and patterns on the border.
The support of an ordered subtree t in a database of ordered subtrees D is defined as sup D ( t )= |{ s  X  D | t s }| / | D | where t s denotes that t is an induced subtree of s .Aconstraint C is called anti-monotone if  X  t tC ( t )  X  C ( t )holdswhere C ( t )meansthat t satisfies C . A subtree t is called closed constrained frequent ordered subtree ,or closed constrained subtree in short, if sup D ( t )  X   X  , C ( t )and  X  s t ( C ( s )  X  sup D ( t )= sup D ( s )) hold. The problem we treat in this paper is formally defined as follows: given D , C and  X  , find all closed constrained subtrees.

This paper is organized as follows. In section2, as the basis of discussion, we show a naive algorithm for mining closed constrained subtrees. In section3, two sophisticated algorithms having the pruning capability by using border patterns are proposed. Experimental results with synthesized and real world datasets are shown in section4. Finally, we conclude the paper and describe future work in section5. Let L be a finite set of labels, on which a total order  X  L is given. The size of an ordered subtree t on L , denoted as | t | , is defined as the number of nodes in t . The label of a node v is denoted as l ( v ). The depth of v , denoted as d ( v ), is defined as the number of edges from the root to v .A depth-label sequence of t is is the list of nodes obtained by pre-order traversal of t [2]. Since there exists one-to-one relation between a tree a nd its depth-label sequence, we use t and ( d ( v 1 | t t if one of the following condition holds. Furthermore, if t 1 = t 2 or the third condition holds, we say that t 1 is a prefix of t 2 and denote it as prefix( t 1 ,t 2 ).
All closed constrained subtr ees can be mined by combining the rightmost expansion [1] and the closedness check by transaction-match [3]. Rightmost ex-pansion is an extension of an efficient set enumeration technique. Each time a subtree t is enumerated, it is expanded into the set of new subtrees child( t )= {
S ( t )( d, l ) | 1  X  d  X  d (rml( t )) + 1 ,l  X  X } where rml( t ) denotes the rightmost leaf in t . By applying this expansion repeatedly, all subtrees can be enumerated without duplication[1]. Note that a subtree t s.t. prefix( t, t ) will be enumer-ated via t .Thesetof transaction-match of t relative to a database D and an anti-monotone constraint C is defined as follows.
 By definition, if C ( t )  X  TM D,C ( t )=  X  holds, then t is a closed constrained subtree. Note that, TM D,C ( t ) can be computed by t and its occurrences, the closedness of a pattern can be judged by itself. We show a naive algorithm named NaiveCC LOOT based on the above discussion in Fig.1(left). Note that, in this algorithm, candidate subtrees are to be enumerated in the order of &lt; lex . We introduce occurrence-match[3] under anti-monotone constraints for incorpo-rating some pruning capability into NaiveCC LOOT . Two subtrees t and t s.t. t t are said to be occurrence-matched if, for each occurrence of t ,thereexists at least one corresponding occurrence of t [3]. The set of left occurrence-match of a tree t under an anti-monotone constraint C is defined as follows. OM L D,C ( t )= { t  X  TM D,C ( t ) | t  X  child ( t ) ,t is occurrence matched with t } holds. However, unlike mining closed subtrees without constraints[3], the pruning of t s.t. OM L D,C ( t ) =  X  causes incompleteness because C ( x ) does not always hold even if C ( x ) holds. For example, if A 11 in Fig.1 is pruned based on A 3  X  OM L D,C ( A 11 ), then a closed constrained subtree A 14 will be never enumerated.
In order to realize the complete search with the effective pruning based on the left occurrence-match, we employ the fo llowing basic strategy. While memorizing some subtrees called border patterns during the search process, we apply the pruning if all subtrees which are needed to maintain the completeness can be restored by using border patterns. In the following two subsections, we show the concrete algorithms for mining closed constrained subtrees by using positive and negative borders . 3.1 Pruning by Positive Borders A subtree t is called positive border relative to a database D , an anti-monotone constraint C and minimum support threshold  X  , denoted as B + D, X ,C ( t ), iff C ( t )  X  child of t s.t. t  X  OM L D,C ( t ) might be a closed constrained subtree but be pruned by the left occurrence-match. For example, A 5 ,A 7 ,A 9 and A 14 in Fig.1 are examples of positive border and A 14 will be pruned because B + D, X ,C ( A 5 ), A
Given two subtrees x and y  X  OM L D,C ( x ), the set of subtrees whose child might be pruned even if it is a closed constrained subtree is defined as follows. where y/x denotes a node v which is in y but not in x ( e.g. A 3 /A 11 = B ), and t \ v denotes a tree obtained by removing v from t . For example, B + D, X ,C ( A 11 ,A 3 )= {
A 13 ,A 15 ,A 17 } . By applying the rightmost expansion repeatedly to each element in B + D, X ,C ( x, y ), we can enumerate the subtrees which are potentially closed constrained but are pruned by the left occurrence-match. For example, A 14 will be enumerated by the following procedure : A 11  X  A 3 (  X  OM L D,C ( A 11 ))  X  A
Given a tree x , in order to guarantee the completeness, all elements in the themselves are enumerated during the search process, it is necessary to com-pute the above set by only the borders which have been already enumerated. In NaiveCC LOOT ,if y&lt; lex x holds, then all element y s.t. prefix( y, y )mustbe enumerated before x . Therefore, given a tree x , the condition under which the  X  y  X  OM L The set [ y ] x, + C,D denotes the equivalence class on the left occurrence-match of x .
From the above discussion, we show the algorithm named posCC LOOT for mining closed constrained subtrees by using positive borders in Fig.2. In this set of representatives of the equivalence classes on the left occurrence-match. A function prefix min ( X )= { x  X  X |  X  x  X  X, x = x , prefix( x ,x ) } is used for the avoidance of the duplicated enumeration. 3.2 Pruning by Negative Borders The algorithm for mining closed constrained subtrees based on the negative border is quite similar to posCC LOOT .
 A subtree t is called negative border relative to D , C and  X  , denoted as B
D, X ,C ( t ), iff C ( t some subtree t s.t. t  X  OM L D,C ( t ) might be a closed constrained subtree but be pruned. Given two subtrees x and y  X  OM L D,C ( x ), we obtain the set of poten-tially closed constrained subtrees which might be pruned as follows.

For example, A 6 in Fig.1 is an example of negative border and A 14 will be pruned because A 6  X  OM L D,C ( A 14 ) holds. We can restore A 14 by the following A As similar to the positive borders, the set y  X  OM L required to guarantee the completeness, can be computed if the following holds.  X  y  X  OM L
We show the algorithm named negCC LOOT for mining closed constrained subtrees by using negative borders in Fig.2. The set of representatives of the equivalence classes is defined as follows.
 While C ( t ) is checked in the procedure Refine in posCC LOOT (line 4), it is done implicitly by checking B  X  D, X ,C ( t ) in Check in negCC LOOT (line 1). Note that, it is difficult to decide which miner should be used in advance. For instance, if we use negCC LOOT and the negative border A 6 is stored, the redundant enumeration of A 13 can be avoided. However, the enumeration of A 6 itself might be redundant since A 6 does not satisfy the constraint. 3.3 Classes of Constrained Occurrence Matching While posCC LOOT and negCC LOOT are the general algorithms for discovering closed subtrees under anti-monotone constraints, it is necessary to implement the concrete equivalence classes of lef t occurrence-match for each constraint. The equivalence classes under some constraints will be explained below with examples shown in Fig.3.
 Maximum size constraint: Since  X  y  X  OM L D,C ( x ) | y | = | x | +1 holds, all Maximum height constraint: Each element y  X  OM L D,C ( x ) belongs to one Maximum branching factor constraint: OM L D,C ( x ) can be divided into the Complex Constraint: The equivalence classes of left occurrence-match under To assess the effectiveness of the propos ed algorithms, we im plement three al-gorithms, NaiveCC LOOT ,posCC LOOT and negCC LOOT , in Java and conduct experiments with the following two datasets on a PC (Pentium 4 CPU 2.80GHz) with 512Mbytes of main memory running Windows XP. 1. Synthetic dataset D 100 generated by Tree Generator [7]. It consisnts of 50,000 2. Real world dataset CSLOGS which con tains access trees to the website[7].
Experimental results are shown in Table.1 and Table.2. In these tables,  X  X  X ,  X  X  X , and  X  X  X  denotes posCC LOOT ,negCC LOOT and NaiveCC LOOT , respectively.
For D 100 , with the decrease of minimum support from 3% to 0.25% gradually, we measure the running time of three miners under several single constraints as well as under the combinations of constraints. While NaiveCC LOOT runs fastest in few cases because of some overh ead for searching border patterns in the proposed algorithms, posCC LOOT and negCC LOOT outperform the naive algorithm in most cases. negCC LOOT runs farster than posCC LOOT in about 70% cases. As whole, the ratio of the gain is higher when the given support is lower and the constraint is looser.
On CSLOGS, given two combinations of constraints, the running time and the number of evaluated subtrees were measured. In Table.2, each number in the parenthesis means the number of evaluated subtrees. The effects of the pruning in the proposed algorithms are confirmed because the number of evaluated sub-trees decreases greatly. Fur thermore, while it might be difficult to evaluate the effectiveness of the proposed algorithms because the running time is very short, the improvement of the execution time is shown in some cases. Especially, the lower minimum support and the looser constraint give a larger improvement.
From these experimental results, we c an conclude that the proposed algo-rithms are especially effective when the search space of the problem becomes large because of the low minimum support and/or loose constraints. In this paper, as an integration of condensed representation mining and constraint-based mining, we propose two algorithms for mining closed constrained frequent ordered subtrees. The proposed algorithms discover closed constrained subtrees by the search with the effective pruning based on the occurrence matching and border patterns.

For future work, the theoretical analysis of the proposed algorithms and fur-ther experiments with large-scale da ta are necessary. We also plan to apply the proposed algorithms to mining more complex structured data such as free trees and graphs.

