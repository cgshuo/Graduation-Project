 As the evolution of the Internet, XML has become the standard of data publishing and documents. How to retrieve information efficiently and effectively became a hot-point in this research area. two taxonomies: structural query and keywords-based search. XPath [9] and XQuery However, most of XML documents in the real world are lack of DTD or XSD. Even document of the same content. In such a case user need write the query expression for constructed even by na X ve users, as it does not need any structural information of the document. 
The basic issue to keyword-based search is how to determine which sets of nodes that satisfy the query are meaningful. Now, most of approaches to this issue are based keyword search engine needs an inverted index to store information corresponding to every keyword in the target documents. For each keyword, traditional inverted index meaningfulness of the returned nodes. However, returning the LCA of nodes directly to user without meaningfulness checking, as Meet [11] does, will clearly lead to poor will increase space complexity, and the latter will be time-consuming. 
In this paper, we propose an enhanced inverted index structure, PN-Inverted Index, which stores path information of each keyword in addition to node id. The concept of numbers of nodes in an XML document are meaningfully related. Compared with XML document only once. Experimental results show that with the promise of Although the size of inverted index is increased somewhat, the total size of indices is much smaller than the existing approaches. 
The rest of the paper is organized as follows. Section 2 introduces the background knowledge of this paper, discusses major related works and our motivation. Section 3 introduces some definitions and concepts we used, and proposes the concept of PLCA and PLCA rule to check the relationship of nodes. Section 4 describes the structure of PN-Inverted Index, and gives the query evaluation algorithm. The experimental results and analysis are presented in Section 5. Section 6 concludes the whole paper. meaningful. 
For example, the following XML document fragment is an excerpt from XMark [16]. Suppose a query Q = { computer, white } on the XML document in Fig.1. As one describing the different items and should not be returned. 
Towards this issue, many concepts and approaches are proposed, such as Meet [11], XSearch [1] and Schema-Free XQuery [2], but most of approaches are based on the concept of Lowest Common Ancestor. In this section, firstly we will introduce this concept and describe a widely accepted rule of checking the relationship of nodes. Secondly, some related works are discussed. 2.1 Lowest Common Ancestor the set of values, also called the set of leaf nodes . self ( N a , N d ) = true . and u 2 if and only if:  X  Ancestor-or-self ( u , u  X   X  u'  X  N , if Ancestor-or-self ( u' , u Ancestor-or-self ( u , u' ) = true u is denoted as LCA ( u 1 , u 2 ). 
Based on the concept of LCA, a widely accepted rule of checking the relationship pair of nodes shares the same label. This rule is proposed firstly in XSEarch and has been proved to be suitable for most situations. Here, this rule is called LCA rule, and introduced in brief. meaningfully if the following conditions hold: 2.2 Related Work Numerous works have been done about query on XML document. Traditionally, query approach and the keyword-based approach. XPath[9] and XQuery [10] are the XSEarch [1]. 
Meet operator returns the LCA as query answer. However, it does not consider the querying heterogeneous XML documents repository. XRANK has a ranking mechanism and it returns document fragments as answers. However, XRANK just query that outperforms other approaches. But Schema-Free XQuery uses and extends feature increases time-complexity in a great degree. 
XSEarch is a keyword-based semantic s earch engine, where the interconnection when deal with query on XML documents with deep hierarchical structure. 
Some query languages and search engines are proposed to support keyword However, all these ranking methods can be easily integrated to our search engine. complexity, or not consider meaningfulness of the query answer at all. In this paper, we achieve this goal by means of a novel concept of lowest common ancestor of label path (PLCA). documents and adopt it as the meaningfulness checking criterion in our approach. Our approach can efficiently determine whether or not two nodes are meaningfully related without storing any relationship of pair of nodes in advanced. This section discusses node encoding method which is absolutely necessary to our approach, and then gives a theorem of relationship determination, which is basement of the following algorithm of relationship determination. 3.1 XML Encoding There are many encoding methods for XML document, such as absolute region code [3], relative region coordinate [4], region-based code [5], PBiTree coding [6] and XR-tree [7]. 
In this paper, we use Dewey encoding of node id. The main reason is that Dewey encoding captures the relationship of ancestor and descendant information. As discussed in the following, this feature is very helpful to determine the relationship of nodes. Due to the limitation of space, the detail of Dewey id is referred to [8], here we just give an example as illustrated in Fig. 2. Let |  X  | be the length of id or path, for example |0.0.1|=3, |regions.Asia|=2. a prefix of id of u 2 . 
Certainly, other encoding also can be applied into our approach if they can get the identifier of LCA and the depth from root to LCA. Here Dewey id is used just for its simplicity of get the identifier of LCA. 3.2 Relationship Determination with LCA of Label Path beginning with lp and | lp'|  X  | lp| . l l ... l m is said to the Common Path of lp 1 and lp 2 if and only if:  X  lp is the prefix path of both lp  X   X  lp' , lp' is a prefix path of both lp then l m is the LCA of lp 1 and lp 2 , denoted as PLCA ( lp 1, lp 2 ). root to u , respectively, then | id |=| lp |. and u = LCA ( u 1 , u 2 ), then | lp |  X  | id of u |. r . l then | lp |= k+k  X  , and then | lp |&gt;| id of u |. relationship of nodes, called PLCA rule.  X  | lp |=| id of u |  X  There are not two distinct label with the same name in the set of ( lp  X  The only two distinct label with the same name in the set of ( lp the ends of lp 1 and lp 2 Theorem 1. PLCA rule is equivalent to LCA rule. Obviously the condition 2 and 3 consist with the condition 1 and 2 of LCA rule. So if nodes u 1 and u 2 satisfy PLCA rule then also satisfy LCA rule, vice versa. 
Theorem 2 is intuitive and it proof is omitted due to the limitation of space. effective and efficient. 4.1 Index Structure In our search engine, we design an enhanced inverted index, PN-Inverted Index. Here, The PN-Inverted Index created only for a single document is discussed, and then the document id is omitted. The support to a document repository is straight forward. The checking into reality. PN-Inverted Index consists of two parts as shown in Fig. 3. 
The first part is an enhanced inverted index as shown in Fig. 3 (a). In each entry of optimizations are made to reduce the size of index. Firstly, although the original XML usually small, as this number is determined by the schema of the document but have only one label path is stored for all these nodes. Clearly this would make the size of name of nodes. Secondly, to further compress the inverted index, an id of label path, Note that label paths for those nodes which have at least one text node as their child are created, as label paths of other nodes would never appear in this inverted index. number of nodes for each label path. Index creating. Note that this algorithm create inverted index only for the keywords in Algorithm 1 : CreateIndex Input : an XML document 
Output : PN-Inverted Index 1. while (parser.readNode( node ) != NULL) 2. if ( node is the start of an element and node  X  NE ) 3. if (! stack .isEmpty) stack [ top ]. childCount ++; 4. childCount = 0; label  X  getCurrentNodeLabel(); 5. stack .push( label , childCount ); 6. if ( node  X  NV ) 7. curID  X  getIDfromStack(); 8. curLabelPath  X  getLabelPathfromStack(); 9. curPathID  X  pathIndex.getPathID( curLabelPath ); 10. for each word in the text 11. invertedIndex .addEntry( word , curID , curPathID ) 12. if ( node is the end of an element and node  X  NE ) stack .pop(); 13. return; 
Algorithm 1 creates the index meanwhile computing the Dewey id for current node. The parser reads in every node in the XML document in pre-order (line 1) and be current label path with these processing. If the node is a value node, the algorithm traverses the stack from bottom to top to compute id and label path of current nodes, and then add an entry for each word (line 6~11). The addEntry (line 11) function adds path id. Proof. Each input node of value is pushed into the stack or popped from the stack at Suppose the total number words in the document is n w , the total number used to add 4.2 Query Evaluation While checking meaningful relationship of arbitrary number of nodes, all-pairs means that all nodes are related with a star center node. 4.2.1 Na X ve Implementation executes the meaningfulness checking based on PLCA rule on each potential answer though there may be just a piece of potential answers are meaningful. maximum time of verifying PLCA rule. 4.2.2 Efficiently Query Evaluation meaningless result at last, and then prune th em as early as possible. The algorithm is as follow. Algorithm 2 : EvaluateQuery Input : a query Q ={ q 1 , q 2 ,..., q k } 
Output : meaningful sets of nodes 1. for each q i  X  Q in query 4. let the intermediate Cartesian product be I ; 5. for each PNPairSet in PNPairSetN 6. I  X  I  X  PNPairSet ; 7. prune meaningless results in I according to PLCA rule; 8. return I ; decrease the time complexity. Theorem 6. The time complexity of algorithm 2 is ) ) 1 ( ( n max is the maximum number of intermediate result. is ) ) 1 ( ( 5.1 Experimental Environment We performed extensive experiments with our search engine, which was implemented in C++. The experiments were carried out on a Pentium 4, with a CPU of 2.8G and 512M RAM, running Windows XP operation system. When parsing an XML document, MSXML3.0 and SAX model are adopted. XMark [16] is used as the data set with factor varies from 0.001 to 0.1, as a result the size of XML document varies from 116K to 11.5M and the detail of these selected from all the words appeared in the document, and the number of keywords of query varies from 2 to 4. 
The experimental results are compared with XSEach [1] as it is a famous keyword search engine on XML documents. We compare the size of index, the indexing time also equal to theirs and we do not give the result here. 5.2 Result Analysis different size of XML documents is presented. Observe that our total index size is just a few bigger than traditional inverted index. The total size of XSEarch is small when online indexing strategy is used, while it becomes very large when offline indexing is created, which can be 100 times of the original document. inverted index and XSEarch without interconnection index is the faster than ours, but our indexing time is faster than XSEarch with interconnection index. We note that the document is flat. But when the depth grows, the indexing process becomes very time of our index has nothing with the structure of the document, but merely determined by the original document size. 
For each approach, we run 300 queries with the number of keyword varying from 2 to 4. All the keywords in the queries are drawn randomly from the set of keywords in the document size. are: 
