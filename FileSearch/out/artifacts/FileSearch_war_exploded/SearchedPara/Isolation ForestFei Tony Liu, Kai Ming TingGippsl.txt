
Most existing model-based approaches to anomaly de-tection construct a profile of normal instances, then iden-tify instances that do not conform to the normal profile as anomalies. This paper proposes a fundamentally different model-based method that explicitly isolates anomalies in-stead of profiles normal points. To our best knowledge, the concept of isolation has not been explored in current liter-ature. The use of isolation enables the proposed method, iForest, to exploit sub-sampling to an extent that is not fea-sible in existing methods, creating an algorithm which has a linear time complexity with a low constant and a low mem-ory requirement. Our empirical evaluation shows that iFor-est performs favourably to ORCA, a near-linear time com-plexity distance-based method, LOF and Random Forests in terms of AUC and processing time, and especially in large data sets. iForest also works well in high dimensional prob-lems which have a large number of irrelevant attributes, and in situations where training set does not contain any anomalies.
Anomalies are data patterns that have different data char-acteristics from normal instances. The detection of anoma-lies has significant relevance and often provides critical ac-tionable information in various application domains. For example, anomalies in credit card transactions could signify fraudulent use of credit cards. An anomalous spot in an as-tronomy image could indicate the discovery of a new star. An unusual computer network traffic pattern could stand for an unauthorised access. These applications demand anomaly detection algorithms with high detection perfor-mance and fast execution.

Most existing model-based approaches to anomaly de-tection construct a profile of normal instances, then iden-tify instances that do not conform to the normal profile as anomalies. Notable examples such as statistical methods [11], classification-based methods [1], and clustering-based methods [5] all use this general approach. Two major draw-backs of this approach are: (i) the anomaly detector is opti-mized to profile normal instances, but not optimized to de-tect anomalies X  X s a consequence, the results of anomaly detection might not be as good as expected, causing too many false alarms (having normal instances identified as anomalies) or too few anomalies being detected; (ii) many existing methods are constrained to low dimensional data and small data size because of their high computational complexity.

This paper proposes a different type of model-based method that explicitly isolates anomalies rather than profiles normal instances. To achieve this, our proposed method takes advantage of two anomalies X  quantitative properties: i) they are the minority consisting of fewer instances and ii) they have attribute-values that are very different from those of normal instances. In other words, anomalies are  X  X ew and different X , which make them more susceptible to isolation than normal points. We show in this paper that a tree structure can be constructed effectively to isolate every single instance. Because of their susceptibility to isolation, anomalies are isolated closer to the root of the tree; whereas normal points are isolated at the deeper end of the tree. This isolation characteristic of tree forms the basis of our method to detect anomalies, and we call this tree Isolation Tree or iTree.

The proposed method, called Isolation Forest or iFor-est, builds an ensemble of iTrees for a given data set, then anomalies are those instances which have short average path lengths on the iTrees. There are only two variables in this method: the number of trees to build and the sub-sampling size. We show that iForest X  X  detection performance con-verges quickly with a very small number of trees, and it only requires a small sub-sampling size to achieve high de-tection performance with high efficiency.

Apart from the key difference of isolation versus pro-filing, iForest is distinguished from existing model-based [11, 1, 5], distance-based [6] and density-based methods [4] in the follow ways:  X  The isolation characteristic of iTrees enables them to  X  iForest utilizes no distance or density measures to de- X  iForest has a linear time complexity with a low  X  iForest has the capacity to scale up to handle extremely
This paper is organised as follows: In Section 2, we demonstrate isolation at work using an iTree that recursively partitions data. A new anomaly score based on iTrees is also proposed. In Section 3, we describe the characteristic of this method that helps to tackle the problems of swamping and masking. In Section 4, we provide the algorithms to con-struct iTrees and iForest. Section 5 empirically compares this method with three state-of-the-art anomaly detectors; we also analyse the efficiency of the proposed method, and report the experimental results in terms of AUC and pro-cessing time. Section 6 provides a discussion on efficiency, and Section 7 concludes this paper.
In this paper, the term isolation means  X  X eparating an in-stance from the rest of the instances X . Since anomalies are  X  X ew and different X  and therefore they are more susceptible to isolation. In a data-induced random tree, partitioning of instances are repeated recursively until all instances are iso-lated. This random partitioning produces noticeable shorter paths for anomalies since (a) the fewer instances of anoma-lies result in a smaller number of partitions  X  shorter paths in a tree structure, and (b) instances with distinguishable attribute-values are more likely to be separated in early par-titioning. Hence, when a forest of random trees collectively produce shorter path lengths for some particular points, then they are highly likely to be anomalies.
Figure 1. Anomalies are more susceptible to isolation and hence have short path lengths.

Given a Gaussian distribution (135 points), ( a ) a normal point x i requires twelve random partitions to be isolated; ( b ) an anomaly x o re-quires only four partitions to be isolated. ( c ) averaged path lengths of x i and x o converge when the number of trees increases.

To demonstrate the idea that anomalies are more suscep-tible to isolation under random partitioning, we illustrate an example in Figures 1(a) and 1(b) to visualise the ran-dom partitioning of a normal point versus an anomaly. We observe that a normal point, x i , generally requires more partitions to be isolated. The opposite is also true for the anomaly point, x o , which generally requires less partitions to be isolated. In this example, partitions are generated by randomly selecting an attribute and then randomly selecting a split value between the maximum and minimum values of the selected attribute. Since recursive partitioning can be represented by a tree structure, the number of partitions re-quired to isolate a point is equivalent to the path length from the root node to a terminating node. In this example, the path length of x i is greater than the path length of x o
Since each partition is randomly generated, individual trees are generated with different sets of partitions. We av-erage path lengths over a number of trees to find the ex-pected path length. Figure 1(c) shows that the average path lengths of x o and x i converge when the number of trees in-creases. Using 1000 trees, the average path lengths of x o and x i converge to 4 . 02 and 12 . 82 respectively. It shows that anomalies are having path lengths shorter than normal instances.
 Definition : Isolation Tree. Let T be a node of an isola-tion tree. T is either an external-node with no child, or an internal-node with one test and exactly two daughter nodes ( T l , T r ). A test consists of an attribute q and a split value p such that the test q &lt; p divides data points into T l and T
Given a sample of data X = { x 1 ,...,x n } of n in-stances from a d -variate distribution, to build an isolation tree (iTree), we recursively divide X by randomly select-ing an attribute q and a split value p , until either: (i) the tree reaches a height limit, (ii) | X | = 1 or (iii) all data in X have the same values. An iTree is a proper binary tree , where each node in the tree has exactly zero or two daughter nodes. Assuming all instances are distinct, each instance is isolated to an external node when an iTree is fully grown, in which case the number of external nodes is n and the num-ber of internal nodes is n  X  1 ; the total number of nodes of an iTrees is 2 n  X  1 ; and thus the memory requirement is bounded and only grows linearly with n .

The task of anomaly detection is to provide a ranking that reflects the degree of anomaly. Thus, one way to de-tect anomalies is to sort data points according to their path lengths or anomaly scores; and anomalies are points that are ranked at the top of the list. We define path length and anomaly score as follows.
 Definition : Path Length h ( x ) of a point x is measured by the number of edges x traverses an iTree from the root node until the traversal is terminated at an external node.
An anomaly score is required for any anomaly detection method. The difficulty in deriving such a score from h ( x ) is that while the maximum possible height of iTree grows in the order of n , the average height grows in the order of log n [7]. Normalization of h ( x ) by any of the above terms is either not bounded or cannot be directly compared. Since iTrees have an equivalent structure to Binary Search Tree or BST (see Table 1), the estimation of aver-age h ( x ) for external node terminations is the same as the
Table 1. List of equivalent structure and oper-ations in iTree and Binary Search Tree (BST) unsuccessful search in BST. We borrow the analysis from BST to estimate the average path length of iTree. Given a data set of n instances, Section 10.3.3 of [9] gives the aver-age path length of unsuccessful search in BST as: where H ( i ) is the harmonic number and it can be estimated by ln( i ) + 0 . 5772156649 (Euler X  X  constant). As c ( n ) is the average of h ( x ) given n , we use it to normalise h ( x ) . The anomaly score s of an instance x is defined as: where E ( h ( x )) is the average of h ( x ) from a collection of isolation trees. In Equation (2):  X  when E ( h ( x ))  X  c ( n ) , s  X  0 . 5 ;  X  when E ( h ( x ))  X  0 , s  X  1 ;  X  and when E ( h ( x ))  X  n  X  1 , s  X  0 . s is monotonic to h ( x ) . Figure 2 illustrates the relationship between E ( h ( x )) and s , and the following conditions ap-plied where 0 &lt; s  X  1 for 0 &lt; h ( x )  X  n  X  1 . Using the anomaly score s , we are able to make the following assess-ment:  X  (a) if instances return s very close to 1 , then they are  X  (b) if instances have s much smaller than 0.5, then they  X  (c) if all the instances return s  X  0 . 5 , then the entire
A contour of anomaly score can be produced by passing a lattice sample through a collection of isolation trees, fa-cilitating a detailed analysis of the detection result. Figure 3 shows an example of such a contour, allowing a user to visualise and identify anomalies in the instance space. Us-ing the contour, we can clearly identify three points, where s  X  0 . 6 , which are potential anomalies.

Figure 2. The relationship of expected path length E ( h ( x )) and anomaly score s . c ( n ) is the average path length as defined in equa-tion 1. If the expected path length E ( h ( x )) is equal to the average path length c ( n ) , then s = 0 . 5 , regardless of the value of n .
This section describes the characteristic of iTrees and their unique way of handling the effects of swamping and masking. As a tree ensemble that employs isolation trees, iForest a) identifies anomalies as points having shorter path lengths, and b) has multiple trees acting as  X  X xperts X  to tar-get different anomalies. Since iForest does not need to iso-late all of normal instances  X  the majority of the training sample, iForest is able to work well with a partial model without isolating all normal points and builds models using a small sample size .

Contrary to existing methods where large sampling size is more desirable, isolation method works best when the sampling size is kept small. Large sampling size reduces iForest X  X  ability to isolate anomalies as normal instances can interfere with the isolation process and therefore reduces its ability to clearly isolate anomalies. Thus, sub-sampling provides a favourable environment for iForest to work well. Throughout this paper, sub-sampling is conducted by ran-dom selection of instances without replacement.

Problems of swamping and masking have been studied extensively in anomaly detection [8]. Swamping refers to
Figure 3. Anomaly score contour of iFor-est for a Gaussian distribution of sixty-four points. Contour lines for s = 0 . 5 , 0 . 6 , 0 . 7 are illustrated. Potential anomalies can be iden-tified as points where s  X  0 . 6 . wrongly identifying normal instances as anomalies. When normal instances are too close to anomalies, the number of partitions required to separate anomalies increases  X  which makes it harder to distinguish anomalies from normal in-stances. Masking is the existence of too many anomalies concealing their own presence. When an anomaly cluster is large and dense, it also increases the number of partitions to isolate each anomaly. Under these circumstances, eval-uations using these trees have longer path lengths making anomalies more difficult to detect. Note that both swamp-ing and masking are a result of too many data for the pur-pose of anomaly detection. The unique characteristic of isolation trees allows iForest to build a partial model by sub-sampling which incidentally alleviates the effects of swamping and masking. It is because: 1) sub-sampling con-trols data size, which helps iForest better isolate examples of anomalies and 2) each isolation tree can be specialised, as each sub-sample includes different set of anomalies or even no anomaly.

To illustrate this, Figure 4(a) shows a data set gener-ated by Mulcross. The data set has two anomaly clusters located close to one large cluster of normal points at the centre. There are interfering normal points surrounding the anomaly clusters, and the anomaly clusters are denser
Figure 4. Using generated data to demon-strate the effects of swamping and masking, (a) shows the original data generated by Mul-cross. (b) shows a sub-sample of the original data. Circles (  X  ) denote normal instances and triangles ( 4 ) denote anomalies. than normal points in this sample of 4096 instances. Fig-ure 4(b) shows a sub-sample of 128 instances of the origi-nal data. The anomalies clusters are clearly identifiable in the sub-sample. Those normal instances surrounding the two anomaly clusters have been cleared out, and the size of anomaly clusters becomes smaller which makes them easier to identify. When using the entire sample, iForest reports an AUC of 0 . 67 . When using a sub-sampling size of 128 , iFor-est achieves an AUC of 0 . 91 . The result shows iForest X  X  superior anomaly detection ability in handling the effects swamping and masking through a sigificantly reduced sub-sample. Anomaly detection using iForest is a two-stage process. The first (training) stage builds isolation trees using sub-samples of the training set. The second (testing) stage passes the test instances through isolation trees to obtain an anomaly score for each instance.
In the training stage, iTrees are constructed by recur-sively partitioning the given training set until instances are isolated or a specific tree height is reached of which results a partial model. Note that the tree height limit l is automat-ically set by the sub-sampling size  X  : l = ceiling (log 2 which is approximately the average tree height [7]. The ra-tionale of growing trees up to the average tree height is that we are only interested in data points that have shorter-than-average path lengths, as those points are more likely to be anomalies. Details of the training stage can be found in Al-gorithms 1 and 2.
 Algorithm 1 : iForest ( X,t, X  ) Inputs : X -input data, t -number of trees,  X  -sub-sampling size Output : a set of t iTrees 1: Initialize Forest 2: set height limit l = ceiling (log 2  X  ) 3: for i = 1 to t do 4: X 0  X  sample ( X, X  ) 5: Forest  X  Forest  X  iTree ( X 0 , 0 ,l ) 6: end for 7: return Forest There are two input parameters to the iForest algorithm. They are the sub-sampling size  X  and the number of trees t . We provide a guide below to select a suitable value for each of the two parameters.

Sub-sampling size  X  controls the training data size. We find that when  X  increases to a desired value, iForest de-tects reliably and there is no need to increase  X  further be-cause it increases processing time and memory size without any gain in detection performance. Empirically, we find that setting  X  to 2 8 or 256 generally provides enough de-tails to perform anomaly detection across a wide range of Algorithm 2 : iTree ( X,e,l ) Inputs : X -input data, e -current tree height, l -height limit Output : an iTree 1: if e  X  l or | X | X  1 then 2: return exNode { Size  X  X  X |} 3: else 4: let Q be a list of attributes in X 5: randomly select an attribute q  X  Q 6: randomly select a split point p from max and min 7: X l  X  filter ( X,q &lt; p ) 8: X r  X  filter ( X,q  X  p ) 9: return inNode { Left  X  iTree ( X l ,e + 1 ,l ) , 10: Right  X  iTree ( X r ,e + 1 ,l ) , 11: SplitAtt  X  q, 12: SplitV alue  X  p } 13: end if data. Unless otherwise specified, we use  X  = 256 as the default value for our experiment. An analysis on the effect sub-sampling size can be found in section 5.2 which shows that the detection performance is near optimal at this default setting and insensitive to a wide range of  X  .

Number of tree t controls the ensemble size. We find that path lengths usually converge well before t = 100 . Un-less otherwise specified, we shall use t = 100 as the default value in our experiment.

At the end of the training process, a collection of trees is returned and is ready for the evaluation stage. The com-plexity of the training an iForest is O ( t X  log  X  ) .
In the evaluating stage, an anomaly score s is derived from the expected path length E ( h ( x )) for each test in-stance. E ( h ( x )) are derived by passing instances through each iTree in an iForest. Using PathLength function, a single path length h ( x ) is derived by counting the number of edges e from the root node to a terminating node as in-stance x traverses through an iTree. When x is terminated at an external node, where Size &gt; 1 , the return value is e plus an adjustment c ( Size ) . The adjustment accounts for an unbuilt subtree beyond the tree height limit. When h ( x ) is obtained for each tree of the ensemble, an anomaly score is produced by computing s ( x, X  ) in Equation 2. The com-plexity of the evaluation process is O ( nt log  X  ) , where n is the testing data size. Details of the PathLength function can be found in Algorithm 3. To find the top m anomalies, simply sorts the data using s in descending order. The first m instances are the top m anomalies.
 Algorithm 3 : PathLength ( x,T,e ) Inputs : x -an instance, T -an iTree, e -current path length; to be initialized to zero when first called Output : path length of x 1: if T is an external node then 2: return e + c ( T.size ) { c ( . ) is defined in Equation 1 } 3: end if 4: a  X  T.splitAtt 5: if x a &lt; T.splitV alue then 6: return PathLength ( x,T.left,e + 1) 7: else { x a  X  T.splitV alue } 8: return PathLength ( x,T.right,e + 1) 9: end if
This section presents the detailed results for four sets of experiment designed to evaluate iForest. In the first exper-iment we compare iForest with ORCA [3], LOF [6] and Random Forests (RF) [12]. LOF is a well known density based method, and RF is selected because this algorithm also uses tree ensembles. In the second experiment, we ex-amine the impact of different sub-sampling sizes using the two largest data sets in our experiments. The results pro-vide an insight as to what sub-sampling size should be used and its effects on detection performance. The third exper-iment extends iForest to handle high-dimensional data; we reduce attribute space before tree construction by applying a simple uni-variate test for each sub-sample. We aim to find out whether this simple mechanism is able to improve iForest X  X  detection performance in high dimensional spaces. In many cases, anomaly data are hard to obtain, the fourth experiment examines iForest X  X  performance when only nor-mal instances are available for training. For all the experi-ments, actual CPU time and Area Under Curve (AUC) are reported. They are conducted as single threaded jobs pro-cessed at 2.3GHz in a Linux cluster (www.vpac.org). The benchmarking method is ORCA -a k -Nearest Neighbour ( k -nn) based method and one of the state-of-the-art anomaly detection methods, where the largest demand of processing time comes from the distance calculation of k nearest neighbours. Using sample randomisation together with a simple pruning rule, ORCA is claimed to be able to cut down the complexity of O ( n 2 ) to near linear time [3].
In ORCA, the parameter k determines the number of nearest neighbourhood, increasing k also increases the run time. We use ORCA X  X  default setting of k = 5 in our ex-periment unless otherwise specified. The parameter N de-termines how many anomalies are reported. If N is small, ORCA increases the running cutoff rapidly and pruning off more searches, resulting in a much faster run time. How-ever, it would be unreasonable to set N below the number of anomalies due to AUC X  X  requirement to report anomaly scores for every instances. Since choosing N has an ef-fect on run time and the number of anomalies is not sup-posed to be known in the training stage, we will use a rea-sonable value N = n 8 unless otherwise specified. Using ORCA X  X  original default setting ( k = 5 and N = 30 ), all data sets larger than one thousand points report AUC close to 0 . 5 , which is equivalent to randomly selecting points as anomalies. In reporting processing time, we report the total training and testing time, but omit the pre-processing time  X  X prep X  from ORCA.

As for LOF, we use a commonly used setting of k = 10 in our experiment. As for RF, we use t = 100 and other pa-rameters in their default values. Because RF is a supervised learner, we follow the exact instruction as in [12] to generate synthetic data as the alternative class. The alternative class is generated by uniformly sampling random points valued between the maximums and minimums of all attributes. Proximity measure is calculated after decision trees are be-ing constructed and anomalies are instances whose proxim-ities to all other instances in the data are generally small.
We use eleven natural data sets plus a synthetic data set for evaluation. They are selected because they contain known anomaly classes as ground truth and these data sets are used in the literature to evaluate anomaly detectors in a similar setting. They include: the two biggest data subsets ( Http and Smtp ) of KDD CUP 99 network intrusion data as used in [14], Annthyroid , Arrhythmia , Wisconsin Breast Cancer ( Breastw ), Forest Cover Type ( ForestCover ), Iono-sphere , Pima , Satellite , Shuttle [2], Mammography 1 and Mulcross [10]. Since we are only interested in continuous-valued attributes in this paper, all nominal and binary at-tributes are removed. The synthetic data generator, Mul-cross generates a multi-variate normal distribution with a selectable number of anomaly clusters. In our experiments, the basic setting for Mulcross is as following: contamina-tion ratio = 10% (number of anomalies over the total num-ber of points), distance factor = 2 (distance between the cen-ter of normal cluster and anomaly clusters), and number of anomaly clusters = 2 . An example of Mulcross data can be found in Figure 4. Table 2 provides the properties of all data sets and information on anomaly classes sorted by the size of data in descending order.

It is assumed that anomaly labels are unavailable in the training stage. Anomaly labels are only available in the evaluation stage to compute the performance measure, AUC. Http (KDDCUP99) 567497 3 attack (0.4%) ForestCover 286048 10 Mulcross 262144 4 2 clusters (10%) Smtp (KDDCUP99) 95156 3 attack (0.03%) Shuttle 49097 9 classes 2,3,5,6,7 (7%) Mammography 11183 6 class 1 (2%) Annthyroid 6832 6 classes 1, 2 (7%) Satellite 6435 36 Pima 768 8 pos (35%) Breastw 683 9 malignant (35%) Arrhythmia 452 274 Ionosphere 351 32 bad (36%)
Table 2. Table of Data properties, where n is the number of instances, and d is the number of dimensions, and the percentage in bracket indicates the percentage of anomalies. The aim of this experiment is to compare iForest with ORCA, LOF and RF in terms of AUC and processing time. Table 3 reports the AUC score and actual run time for all methods. From the table, we observe that iForest compares favourably to ORCA. It shows that iForest as a model-based method outperforms ORCA, a distance based method, in terms of AUC and processing time. In particular, iForest is more accurate and faster in all the data sets larger than one thousand points.

Note that the difference in execution time is huge be-tween iForest and ORCA, especially in large data sets; this is due to the fact that iForest is not required to compute pair-wise distances; this happens despite the fact that ORCA only reports n 8 anomalies where iForest ranks all n points. iForest compares favourable to LOF in seven out of eight data sets examined and iForest is better than RF in all the four data sets tested in terms of AUC. In terms of processing time, iForest is superior in all the data sets as compared with LOF and RF.

The performance of iForest is stable in a wide range of t . Using the two data sets of highest dimension, Figure 5 shows that AUC converges at a small t . Since increasing t also increases processing time, the early convergence of AUC suggests that iForest X  X  execution time can be further reduces if t is tuned to a data set.
 As for the Http and Mulcross data sets, due to the large Train Eval. Total proximity matrix in unsupervised learning settings.
Figure 5. Detection performance AUC (y-axis) is converged at a small t (x-axis). anomaly-cluster size and the fact that anomaly clusters have an equal or higher density as compared to normal instances (i.e., masking effect), ORCA reports a poorer-than-average result on these data sets. We also experiment ORCA on these data sets using a higher value of k (where k = 150 ), however the detection performance is similar. This high-lights one problematic assumption in ORCA and other sim-ilar k -nn based methods: they can only detect low-density anomaly clusters of size smaller than k . Increasing k may solve the problem, but it is not practical in high volume set-ting due to the increase in processing time.
This experiment investigates iForest X  X  efficiency in re-lation to the sub-sampling size  X  . Using the two largest data sets, Http and ForestCover, we examine the effect of sub-sample size on detection accuracy and processing time. In this experiment we adjust the sub-sampling size  X  = 2 , 4 , 8 , 16 ,..., 32768 .
 Our findings are shown in Figure 6. We observe that AUC converges very quickly at small  X  . AUC is near opti-mal when  X  = 128 for Http and  X  = 512 for ForestCover, and they are only a fraction of the original data ( 0 . 00045 for Http and 0 . 0018 for ForestCover). After this  X  setting, the variation of AUC is minimal:  X  0 . 0014 and  X  0 . 023 respectively. Also note that the processing time increases very modestly when  X  increases from 4 up to 8192. iFor-est maintains its near optimal detection performance within this range. In a nutshell, a small  X  provides high AUC and low processing time, and a further increase of  X  is not nec-essary.
One of the important challenges in anomaly detection is high dimensional data. For distance-based methods, every point is equally sparse in high dimensional space  X  render-ing distance a useless measure. For iForest, it also suffers from the same  X  X urse of dimensionality X .

In this experiment, we study a special case in which high
Figure 6. A small sub-sampling size provides both high AUC (left y-axis, solid lines) and low processing time (right y-axis, dashed lines, in seconds). Sub-sampling size (x-axis, log scale) ranges  X  = 2 , 4 , 8 , 16 ,..., 32768 . dimension data sets has a large number of irrelevant at-tributes or background noises, and show that iForest has a significant advantage in processing time. We simulate high dimensional data using Mammography and Annthy-roid data sets. For each data set, 506 random attributes, each uniformly distributed, valued between 0 and 1 are added to simulate background noise. Thus, there is a total of 512 attributes in each data sets. We use a simple sta-tistical test, Kurtosis, to select an attribute subspace from the sub-sample before constructing each iTree. Kurtosis measures the  X  X eakness X  of univariate distribution. Kurto-sis is sensitive to the presence of anomalies and hence it is a good attribute selector for anomaly detection. After Kurtosis has provided a ranking for each attribute, a sub-space of attributes is selected according to this ranking to construct each tree. The result is promising and we show that the detection performance improves when the subspace size comes close to the original number of attributes. There are other attribute selectors that we can choose from, e.g., Grubb X  X  test. However, in this section, we are only con-cern with showcasing iForest X  X  ability to work with an at-tribute selector to reduce dimensionality of anomaly detec-tion tasks.

Figure 7 shows that a) processing time remains less than 30 seconds for the whole range of subspace sizes and b) AUC peaks when subspace size is the same as the number of original attributes and this result comes very close to the result of ORCA using the original attributes only. When ORCA is used on both high dimensional data sets, it reports AUC close to 0.5 with processing time over one hundred seconds. It shows that both data sets are challenging, how-ever, iForest is able to improve the detection performance by a simple addition of Kurtosis test. It may well be possible for other methods to apply similar attribute reduction tech-
Figure 7. iForest achieves good results on high dimensional data using Kurtosis to se-lect attributes. 506 irrelevant attributes are added. AUC (left y-axis, solid lines) improves when the subspace size (x-axis), comes close to the number of original attributes and processing time (right y-axis, dashed lines, in seconds) increases slightly as subspace size increases. iForest trained using the original data has slightly better AUC (shown as the top dotted lines). nique to improve detection accuracy on high-dimensional data, but the advantage of iForest is its low processing time even in high dimensional data.  X  X oes iForest work when training set contains normal instances only?  X  To answer this question, we conduct a simple experiment using the two largest data sets in our ex-periment. We first randomly divide each data set into two parts, one for training and one for evaluation, so that the AUC is derived on unseen data. We repeat this process ten times and report the average AUC.

When training with anomalies and normal points, Http reports AUC = 0 . 9997 ; however, when training with-out anomalies, AUC reduces to 0 . 9919 . For ForestCover, AUC reduces from 0 . 8817 to 0 . 8802 . Whilst there is a small reduction in AUC, we find that using a larger sub-sampling size can help to restore the detection performance. When we increase the sub-sampling size from  X  = 256 to  X  = 8 , 192 for Http and  X  = 512 for ForestCover and train without anomalies, AUC catches up to 0 . 9997 for Http and 0 . 884 for ForestCover.
The implication of using a small sub-sample size is that one can easily host an online anomaly detection system with minimal memory footprint. Using  X  = 256 , the maximum number of nodes is 511 . Let the maximum size of a node be b bytes, t be the number of trees. Thus, a working model to detect anomaly is estimated to be less than 511 tb bytes, which is trivial in modern computing equipments. iForest has time complexities of O ( t X  log  X  ) in the train-ing stage and O ( nt log  X  ) in the evaluating stage. For Http data set, when  X  = 256 , t = 100 and evaluating 283,748 instances, the total processing time is 7 . 6 seconds only. We increase the sub-sampling size 64 times to  X  = 16384 and the processing time increases by only 1.6 times to 11 . 9 sec-onds. It shows that iForest has a low constant in its compu-tational complexity. iForest X  X  fast execution with low memory requirement is a direct result of building partial models and requiring only a significantly small sample size as compared to the given training set. This capability is unparallel in the domain of anomaly detection.
This paper proposes a fundamentally different model-based method that focuses on anomaly isolation rather than normal instance profiling. The concept of isolation has not been explored in the current literature and the use of isola-tion is shown to be highly effective in detecting anomalies with extremely high efficiency. Taking advantage of anoma-lies X  nature of  X  X ew and different X , iTree isolates anoma-lies closer to the root of the tree as compared to normal points. This unique characteristic allows iForest to build partial models (as opposed to full models in profiling) and employ only a tiny proportion of training data to build ef-fective models. As a result, iForest has a linear time com-plexity with a low constant and a low memory requirement which is ideal for high volume data sets.

Our empirical evaluation shows that iForest performs significantly better than a near-linear time complexity distance-based method, ORCA, LOF and RF in terms of AUC and execution time, especially in large data sets. In addition, iForest converges quickly with a small ensemble size, which enables it to detect anomalies with high effi-ciency.

For high dimensional problems that contain a large num-ber of irrelevant attributes, iForest can achieve high detec-tion performance quickly with an additional attribute se-lector; whereas a distance-based method either has poor detection performance or requires significantly more time. We also demonstrate that iForest works well even when no anomalies are present in the training set. Essentially, Iso-lation Forest is an accurate and efficient anomaly detector especially for large databases. Its capacity in handling high volume databases is highly desirable for real life applica-tions.

Acknowledgements The authors thank Victorian Part-nership for Advanced Computing (www.vpac.org) for pro-viding the high-performing computing facility.

Z.-H. Zhou was supported by NSFC (60635030, 60721002) and JiangsuSF (BK2008018).

