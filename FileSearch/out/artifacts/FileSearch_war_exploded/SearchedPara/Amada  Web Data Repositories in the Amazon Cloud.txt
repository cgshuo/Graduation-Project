 We present Amada ,aplatformforstoringWebdata(in particular, XML documents and RDF graphs) based on the Amazon Web Services (AWS) cloud infrastructure. Amada operates in a Software as a Service (SaaS) approach, allow-ing users to upload, index, store, and query large volumes of Web data. The demonstration shows ( i ) the step-by-step procedure for building and exploiting the warehouse (stor-ing, indexing, querying) and ( ii )themonitoringtoolsen-abling one to control the expenses (monetary costs) charged by AWS for the operations involved while running Amada . H.2.4 [ Database Management ]: Systems X  Concurrency, Distributed databases, Query processing Design, Experimentation, Performance, Economics Cloud Computing, Web Data Management, Query Process-ing, AWS, Monetary Cost Increasing volumes of data are produced or exported into Web data formats. Among these, the W3C X  X  XML standard for structured documents (and in particular Web pages) and RDF for Semantic Web data are the best known. XML allows encoding complex documents whose structure may be constrained by an XML Schema. RDF graphs consist of triples of the form ( s, p, o )statingthatthesubjectnode s has the property edge p whose value is the object node o . XML takes the lion X  X  share of Web content nowadays. At the same time, RDF is increasingly being used in numerous data sources such as in Linked Open Data.

To exploit large volumes of Web data, an interesting op-tion is to warehouse it into a single access point reposi-tory. This typically involves some crawling or other means of identifying interesting data sources and loading these data sources into the repository where further processing can be applied. Huge data volumes have raised the need for dis-tributed storage architectures and platforms typically de-ployed in a cloud environment, which provides scalable and elastic resource allocation. In this work, we consider host-ing large volumes of Web data in the cloud, and their e ffi -cient storage and querying through a (distributed, parallel) platform also running in the cloud. Such an architecture belongs to the general Software as a Service (SaaS) setting where the whole stack from the hardware to the data man-agement layer are hosted and rented from the cloud.
In this context, an important challenge is how to e ffi ciently identify the parts of the data which need to be consulted in order to answer a given query. In a cloud SaaS setting, e ffi cient access path selection not only speeds up query pro-cessing, but also helps to reduce the monetary costs charged for querying, by avoiding work on some cloud machines that do not end up producing query results.

Amada is a scalable platform for Web data management within the cloud, with a particular focus on this cloud-based data access path selection challenge [3, 4]. Amada stores Web data in the cloud, and establishes indexes at various granularity over the data. Following other works [2, 11], Amada uses the Amazon Web Services (AWS) cloud ( http://aws.amazon.com ), among the most prominent ones today. An important AWS feature is its elasticity, i.e., the ability to smoothly allocate computing power, storage, or other services, as the application demands vary.
The contribution of Amada is twofold. First, Amada presents a novel architecture harnessing the various sub-systems of the popular cloud platform AWS for higher-level, e ffi cient management of complex data. Second, Amada in-cludes an index-based mechanism for access path selection within a cloud-based repository, reducing query processing time as well as the warehouse operating costs.

The remainder of this work is structured as follows. Sec-tion 2 describes Amada architecture while Section 3 outlines our Web data indexing algorithms. We present the demon-strated features in Section 4. Finally, we briefly discuss other related works in Section 5 and conclude in Section 6.
The design of Amada was guided by the following objec-tives. First, we aimed to leverage AWS resources by scaling up to large data volumes. Second, we aimed at e ffi ciency, in particular for the document storage and querying oper-ations. We quantify this e ffi ciency by the response time provided by the cloud-hosted application. Our third objec-tive is to minimize cloud resource usage, i.e., the total work required for our operations. This is all the more important since in a cloud, total work translates into monetary costs. Fourth, the architecture should not be too closely tied to a specific XML or RDF query processor.
Amada stores data and indexes in a distributed fashion within AWS, but the main ideas of our work can be trans-lated to other platforms. Data is stored within Amazon Sim-ple Storage Service (S3), which is the AWS store for large objects. S3 assigns to each dataset a URI, based on which it can be retrieved. We build data indexes within SimpleDB, a simple database system supporting SQL-style queries based on a key-value model. Observe that while SimpleDB general-izes relational databases by supporting heterogeneous tuple and multi-valued attributes, it is more restricted in that it only supports single-relation queries, i.e., no joins. We have implemented several indexing strategies for both XML and RDF, di ff ering in the choice of index keys, and in their level of detail, i.e., whether they point to specific datasets, or to very fine-grained data items within the datasets. The code which processes queries runs on virtual machines within the Amazon Elastic Compute Cloud (EC2). Finally, in order to synchronize the distributed components of our system, we use Amazon Simple Queue Service (SQS), which provides asynchronous message-based communication.
 Figure 1 gives an in-depth view of Amada  X  X  architecture. Adatasetsubmittedtothe front-end module is stored as a file in S3, whose URI is sent to an indexing module running on an EC2 instance. This module retrieves the correspond-ing dataset from S3 and builds an index that is stored in SimpleDB. A query submitted to the front-end module is sent to a query processor module running on an EC2 in-stance. This module performs a look-up to the indexes in SimpleDB so as to find out the relevant datasets for answer-ing the query, and evaluates the query against them. Results are written in a file stored in S3, whose URI is sent to the front-end module to retrieve the query answers.
 Scalability, parallelism and fault-tolerance Amada ex-ploits the elastic scaling of AWS by increasing and decreas-ing the number of EC2 instances running each module. The synchronization through the SQS message queues among modules supports inter-machine parallelism, whereas intra-machine parallelism is supported by multi-threading our code. Amada also provides fault-tolerance by using the queues. If an instance crashes while loading a document or answering the query, the message which had caused the work to start becomes available again in the queue, and thus another vir-tual instance will retrieve it and take over the job. Amada is implemented in Java and uses AWS SDK for Java. For processing XML queries within EC2, it uses the query processor developed within our ViP2P project [13], while for RDF queries, Amada uses RDF-3X [12]. An important feature of Amada is data indexing within SimpleDB. The structure of SimpleDB is as follows.
SimpleDB data is organized in domains .Eachdomainis acollectionof items identified by their key .Inturn,each item has one or more attributes ;anattributehasa name , and one or several values .Anattributevaluemaybeempty (denoted by ! ). Di ff erent items within a SimpleDB domain may have di ff erent attribute names.

The SimpleDB API provides a get(d,k) operation retriev-ing all items in the domain d having the key k ,anda put operation to set values of attributes: put(d,k,(a,v)+) inserts the attributes (a,v)+ into an item with key k in domain d . A batchPut variant inserts 25 items at a time and leads to a better performance. AWS ensures that queries to di ff erent SimpleDB domains run in parallel.
 Indexing strategies Conceptually, given a data model M , an indexing strategy I is a function extracting quadruplets of the form ( domain name , item key , attribute name , at-tribute value )fromaninputdataset D .Indexing D accord-ing to I ,then,amountsto( i )computingthequadruplets in I ( D )and( ii ) adding these quadruplets to SimpleDB, using appropriate (batched, sometimes conditional) put op-erations. Amada implements four indexing strategies for XML and four for RDF, detailed in [4] and [3], respectively. In the following, we present only some of them.
 XML indexing The XML indexing strategy Label-URI (or LU ,inshort)computesquadrupletsinwhich:
Given an XML query, strategy LU leads to the set of doc-uments featuring each element and attribute name, value, and keyword of the query; intersecting these sets leads to the URIs of documents featuring all of them. Some of the documents whose URIs are thus retrieved may not satisfy the query X  X  structural constraints, e.g., the URI of a docu-ment of the form  X  a  X  X  b/  X  X  c/  X  X  /a  X  will be retrieved for a query of the form /a//b/c ,i.e.,therearesomefalsepositives.
Adi ff erentstrategyis Label-URI-ID (or LUI ,inshort),sim-ilar to LU but using identifiers of the XML nodes instead of the ! attribute values of LU . LUI does not return false posi-tives, but leads to a much larger index than LU ,becauseit introduces e.g., 10 index entries for 10 elements labeled a in adocument,whereas LU uses only one.
 RDF indexing Let D be an RDF graph whose URI is U
D and ( s 1 ,p 1 ,o 1 )beatriplein D .Let s , p and o be three distinct tokens representing subjects, properties and objects, respectively. The simplest RDF indexing strategy called AT T (for attribute-based) uses a single default domain which is split as the index grows. For ( s 1 ,p 1 ,o 1 ), AT T builds 3itemkeys: s s 1 , p p 1 , o o 1 .Eachsuchitemhasasingle attribute U D ,whosevalueis ! .Assumenowthatwewant to evaluate the SPARQL query:
Amada performs three get queries; one for each constant of the query: q1 having key p hasAuthor , q2 having key o Foo and q3 having key p hasTitle .Then,itintersectstheresults of q1 and q2 to ensure that the :hasAuthor property and the "Foo" object value occur in the same dataset. The result is then unioned with the result of q3 to obtain the datasets on which the SPARQL query will be evaluated. SPARQL semantics allows matches for this query to span over multiple datasets, i.e., query results are defined on a global  X  X erged X  graph.

Another RDF indexing strategy similar with AT T is AT S (for attribute subset) but it creates 7 item keys for each triple. Strategy AT S builds a larger index, in exchange for less get calls to identify the relevant graphs to a query. Performance AdetailedperformancestudyoftheXML side of Amada is described in [14]. We compare four index-ing strategies and show that indexing leads to cost savings that o ff set the index building and maintenance costs, in our experiments, after roughly 1000 queries [14].
The demonstration showcases loading and querying data in Amada in real time within AWS. We use datasets about cultural artifacts, e.g., Open Data catalog of Biblioth` eque Nationale de France ( http://data.bnf.fr/semanticweb ), as well as the general DBPedia corpus. Amada displays in a Web-based interface ( i )indexentriestobeaddedtoSim-pleDB, and ( ii )ourreal-timerenditionofthemonetary costs entailed by index creation. Further, for a given query and indexing strategy, demo attendees will be shown ( i )the calls to the SimpleDB API issued by the query processor to look up relevant datasets, ( ii )thelogicalandphysicalplans for recombining (through intersection, join and/or union) the look-up results to identify the relevant datasets, and finally ( iii ) the AWS resource consumption associated to loading the respective datasets from S3 into EC2, process-ing the query there, and downloading the results from the cloud. Amada includes an advisor tool, which based on the datasets and workload, provides index recommendations that depend on the relative importance given to the mini-mization of query response time and up-front monetary cost.
Figure 2 illustrates the interface; a more complete look-and-feel is available at http://team.inria.fr/oak/amada/ .
An early work [2] has established the feasibility of building and exploiting B-tree indexes in S3 of AWS, while [11] fo-cused on the problem of executing transactional workloads on cloud architectures, and AWS in particular. More re-cently, economic models for selecting indexes to materialize in a cloud were proposed in [9]. These works, however, con-sidered regular, table-structured data, whereas we focus on irregular, tree-or graph-structured Web data.

Since the proposal of MapReduce [5] and the appear-ance of Hadoop, massively parallel data management using distributed infrastructures (a typical example of which are cloud-based) is a hot topic in industry and academia. For instance, XML query processing on top of Hadoop is studied in [10, 6]. Further, the increasing popularity of RDF has led to many recent works on parallelizing RDF processing using MapReduce [7, 8].
Amada exploits AWS components in order to achieve scalable storage and query processing for RDF and XML data. A main feature is content indexing, which is also the main focus of this demo proposal. Ongoing work on the platform includes ( i )integratingcontentindexingwithina generic, AWS-independent framework for massively parallel data management [1] and ( ii )furtherinvestigatingtheim-pact of RDF graph partitioning on RDF query answering in a cloud context. Partitioning RDF graphs and e ffi ciently parallelizing queries over triples entailed by the RDF seman-tics are open issues in this context.
 Acknowledgments This work has been partially funded by the KIC EIT ICT Labs activity  X  X louds for Connected Cities X  2011 and an AWS in Education research grant.
