 1. Introduction
Manufacturing execution systems (MES) that incorporate a scheduling component can contribute considerably to the effi-ciency of a factory. A manufacturing execution system is a control system for managing and monitoring work-in-process on a factory floor. MES systems are increasingly being integrated with enterprise resource planning (ERP), hereby connecting the control and management levels automatically and continuously. The overall effect should be that customer requests are processed fast and that available resources are used most efficiently. At the same time, waiting times for materials waste, setup times and prepara-tion times are reduced while product variation and (product) exceptions are managed on the plant floor ( Kletti, 2007 ).
MES systems are perfectly suited for supporting real-world production scheduling for the so-called process industry, where manufacturing is associated with formulas and manufacturing recipes. The primary production processes are either continuous, or occur on an indistinguishable batch of materials. Examples of the process industries include food, beverages, chemicals, phar-maceuticals, petroleum, paints and coatings, etc. In general, the production process can be divided in two stages. First raw materials are processed into (intermediate) products. Next, fin-ished food products are packed. This research concentrates on food processing companies. In these environments, the schedul-ing has to deal with a combination of discrete, continuous and batch processes, and is typically complicated by particular char-acteristics. For instance, the physical routes between workcenters in the plant layout, the high diversity of products (different tastes, different packaging, custom labels, etc), complex product recipes, and many more. More information about the food industry and its characteristics can be found in Akkerman and van Donk (2009) .
Although production scheduling is a widely studied topic ( Hermann, 2006 ), it has received little attention in real (food) processing industries ( Akkerman and van Donk, 2009 ). Nevertheless, a number of related papers can be found in the academic literature.
Christou et al. (2007) and Ferreira et al. (2009) developed a practical production planning approach for a real application in the beverage industry. Blanc et al. (2008) described a holonic approach for an MES, and illustrated this approach on a real industrial application. Bilgen and G  X  unther (2010) introduced a so-called  X  X lock planning approach X  for production scheduling in the fast moving consumer industry. Some recent real life industrial case studies using math-ematical programming techniques can be found. Entrup et al. (2005) introduces three MILP model formulations and apply it for a weekly production planning on an indust rial case study of yogurt produc-tion. A combination of a discrete and continuous representation of time is used. Kopanos et al. (2010) proposes a MILP model for the simultaneous lot-sizing and pro duction scheduling problem in a multiproduct yogurt production line of a diary plant in Greece.
Kapanos et al. (2011) shows a MIP for the production planning and scheduling of parallel (single-stage) continuous processes in the presence of sequence-dependent switchover times and costs for product families, and sequence-independent switchovers for pro-ducts belonging to the same family.
 integrated approach to refine the scheduling kernel inside their products. The overall challenge t he customers of MESware are faced with is to cope with an increasing demand for flexible, customized and faster production. At the same time, MESware also aims to serve larger customers. At this time MESware and its clients do not require optimal schedules. The schedules have to be generated fast enough and must be of sufficient quality compared to manual practice. Explicit requirements for MESware are: (i) being able to schedule multiple orders simultaneously, (ii) being able to map the different processing steps to work centers present in the plant layout of the customer, while satisfying the relations between these steps (i.e. routing), (iii) being able to feed the scheduler with up-to-date information on the production process, (iv) being able to include stock capacities and sequence depending setup times, (v) being able to work with customer specific objectives and finally (vi) being able to integrate with personnel scheduling.

The overall solution approach developed in this paper consists of a generic scheduling framework in which industry specific problems can be included by means of preprocessing or decision modules. A make-to-order setting is assume d, where products are only pro-duced when there is an order for it. Techniques from local search are used to optimize the decisions taken in these modules. Secondly, we use machine learning techniques to improve the background knowl-edge on key performance indicators ( KPIs). Processing times, setup times, breakdowns, etc were brought in. We then show how the modular framework is used to impl ement the first three require-ments, and how it can be used to further address the remaining ones. Currently the scheduler operates in a fully deterministic setting, but in the future we will make it more dynamic.
The main contributions of this research include academic and practical components. Academical ly we show that a combination of artificial intelligence and operational research methods is capable of generically dealing with complex problem definitions provided by theindustry.Wepointatasetofp ractical issues that are under-estimated when considering possible applications of an academic approach. Examples include how to grasp accurate data (expert knowledge); how to get accurate information about the execution; how to make a scalable generic scheduler for all sorts of industrial processes. These issues have b een addressed in the framework.
The remainder of this paper is organized as follows. In the next section the generic scheduling framework is described at an abstract level. Each different module is discussed afterwards in a separate section. The application of our approach to real-life data from the food processing industry is illustrated. We conclude with a discus-sion and, finally, indicate some directions for further research. 2. A high level overview
Real-world scheduling is a highly complex challenge with many constraints. Therefore, the sch eduling task is decomposed into several steps as shown in Fig. 1 . We can distinguish the following steps: a preprocessing step, a decision step, a translation step, a schedule generation step, and finally an optimization step.
The preprocessing step checks the correctness of the incoming orders, and makes some preparations, e.g. it can calculate all the possible assignments of operations to workcenters for the man-ufacturing of the demanded products. This is a routing problem that is discussed in Section 3. Choosing an actual route is left for the decision step.

The decision step , which is a part of the optimization step, assigns values to the decision variables. In the case study here discussed, the decision variables are the possible routes, and the sequence or order in which the orders will be scheduled. This step is discussed in Section 4.

The translation step uses the background information, the incom-ing orders, and the decision variables to formulate a scheduling problem. We use a general scheduling problem, namely the resource-constrained project scheduling problem with generalized precedence relations (RCPSP/GPR) ( Franck et al., 2001 ). It encom-passes all the resource and time constraints. Each order is translated into one project scheduling problem. Multiple orders will then compose a multi-project scheduling problem.

The schedule generation step solves the scheduling problem formulated in the previous step, which is a multi-project RCPSP/ GPR. The multiple scheduling problems are solved one by one by the given sequence of orders (chosen in the decision step). The individual scheduling problems can be solved by any applicable method from the literature ( Bartusch et al., 1988 ; De Reyck and Herroelen, 1998 ; Schwindt, 1998 ; Franck et al., 2001 ). For the RCPSP/GPR, we use a scheduling method based on priority rules, together with a serial schedule generation scheme with an unscheduling step. Section 5 describes the translation step, together with the schedule generation step. The schedule gen-eration step provides some feedback on the quality of the solution that was generated. This information is fed back to the optimiza-tion step, so that better local decisions can be made and better solutions (schedules) can be found iteratively.

Finally, the optimization step searches for good quality solutions in a guided way. Many optimization methods can serve as guiding mechanism. For example, steepest descent, simulated annealing ( Kirkpatrick et al., 1983 ), tabu-search ( Glover and Laguna, 1997 ) and variable neighborhood search ( Mladenovic and Hansen, 1997 ) are appropriate. This step also hol ds the termination condition and the set of objectives (e.g. makespan, weighted tardiness, etc). Note, as we discuss later, that an internal optimization algorithm is also possible inside the schedule gen eration step, which itself can be determined by a decision variable.
 In all the steps we assume the presence of background knowledge . It holds static and dynamic information about the plant layout, process relations, product structur e, processing times, setup times, machine breakdown or maintenance, personnel, working hours and equipment. The accuracy of this information strongly influe-nces the applicability of the scheduler. Section 6 discusses the latter topic. 3. Routing 3.1. Routing problem description
In order to manufacture the demanded products, operations have to be assigned to workcenters. This leads to the following routing problem. Consider a plant layout containing all the connections in the plant, i.e. connections between workcenters, buffers and storage zones. The connections contain information about process relations and the possible time lags between them.
Two types of connections are present, i.e. end X  X nd and end X  X tart connections. An end X  X nd connection between two connected workcenters means that the operations on these two workcenters must end at the same time (excluding time lags). An end X  X tart connection means that the second operation cannot start before its predecessor operation finishes. The product structure, which is the recipe of the product or the bill of materials, is also given. This product structure contains a number of process steps and the order relation between them. Fig. 2 shows an example of such a product structure with its process steps. The example shows that processes can have multiple input products in a certain propor-tion. The default form of the product structure is a tree and the plant layout is a graph. Both end X  X nd and end X  X tart connected workcenters are allowed. In fact, the problem is to find one or all mappings from process steps to workcenters, with the restriction that the workcenters can perform the required processes.
By decomposing the product structure into linear substruc-tures, this routing problem can be solved recursively. We start at the root process of the tree defined by the product structure. We move along the tree towards the leafs and add the vertices to the substructure. When arriving in a vertex q with more than one child vertex, we end the current substructure with vertex q and start a new substructure (recursive call) for each subtree starting from the child vertices of q . Vertex q is also added as first vertex of the new substructure, followed by its child vertex. This method results in the following set of substructures for the example given tures are also connected, e.g. A is the parent substructure of substructures B and C .

Once the set of linear substructures is generated, we search for all feasible routes through the plant layout for each substructure.
A feasible route is a mapping from process steps to workcenters, respecting the following two conditions. The workcenters must be able to perform the required process, and two consecutive processes must be mapped to connected workcenters. We have two kinds of connections between workcenters: direct connec-tions and connections through storages and buffers (indirect).
When searching for feasible routes, we prefer the direct connec-tions. Indirect connections are considered when no direct con-nections are available. A depth-first search is used to find all the feasible routes for each linear substructure. When only direct connections are present, we have a worst case time complexity of O  X  b d  X  , with d the number of process steps, and b the average number of feasible connections for each workcenter (which is in practice not very high). When the runtime of the depth-first search would become problematic or when costs are introduced on the connections between workcenters, then more informed routes from the substructures into a route for the whole product structure. This is done by selecting a feasible route for each substructure such that the overlapping vertices (process steps) of the substructures are mapped to the same workcenter. For end X  end connected production steps, an extra requirement is neces-sary. Sibling substructures with end X  X nd parts at the start of their routes must be mapped to different workcenters. 3.2. Special routing case only end X  X nd connections are allowed. We define the product structure as a directed graph G  X  V G , E G  X  with labeled vertices. We further have the plant layout, which is also a directed graph
H  X  V H , E H  X  with a list of labels on the vertices. The labels in G are the process steps, while the labels in H are the process steps supported by the workcenters. Only end X  X nd connected work-centers are allowed. The problem is to find a mapping f from the vertices of G to a subset of the vertices of H , respecting the following constraints. If two vertices v 1 , v 2 A V G are connected by a direct edge in G , then the corresponding vertices f  X  v 1  X  , f  X  v 2  X  must also be connected by a direct edge in H . A second constraint is that the labels of mapped vertices must have a common label, 8 v A V G : ( l i  X  v  X  A L  X  v  X  , l j  X  f  X  v  X  X  A L  X  f  X  v  X  X  : l of labels of vertex v and with l i ( v ) label i of vertex v . The problem described here is a variant of the induced subgraph isomorphism problem, with directed edges and labels on the vertices. Ullmann (1976) proposed a backtracking algorithm for the subgraph isomorphism problem. It is one of the most commonly used algorithms for exact graph matching. It has a worst case time complexity of O  X  N ! N 2  X  . Better (sub)graph isomorphism algorithms exist for matching larger graphs. More recently Cordella et al. (2004) described the VF2 algorithm with a worst case time complexity of O  X  N ! N  X  . Because of its simplicity, we adapted the algorithm of Ullmann (1976) , to handle our specific problem with directed edges and vertex labels that have to match. Experiments have shown that the backtracking algorithm is sufficiently fast for the real world routing problem in this study (less than 10 ms for the largest test case). 4. Decision and optimization
An initial schedule is constructed through subsequent steps (translation, schedule generation). The schedule is fed back to the optimization step. The initial decision variable assignments can be chosen by a simple heuristic procedure.
 and a sequence for processing the orders. A route is the mapping from process steps to workcenters. The list of possible routes was determined in the preprocessing step. Many other decision vari-ables could be added, for example, the algorithm or priority rule that will be used to solve the translated scheduling problem (see
Section 5). This fits perfectly into the idea behind hyperheuristics ( Burke et al., 2003 ). Hyperheuristics are search methods operating on a higher level. Unlike metaheuristics, which are searching in the space of solutions, hyperheuristics are searching in the space of low-level heuristics or metaheuristics. In other words they are searching for the best method to find good solutions quickly. We will further discuss hyperheuristics in Section 8.

The heuristic used for generating an initial schedule is as follows. For mapping the process steps to workcenters, we choose the routes with the largest free capacity and we maximally disperse routes for different orders. Dispersion is arranged by first selecting a random route, and subsequently selecting routes that are maximally different from the previous routes (ties are broken randomly). A random sequence of orders is generated. If tardiness needs to be considered, sorting the orders according to the  X  X arliest due date X  first rule is more appropriate. The decision step is actually a sub step of the optimization step. We have chosen to guide the optimization by a local search algorithm, which can be any metaheuristic or hyperheuristic. For each decision variable a neighborhood is defined. These neighborhoods contain a set of solutions, i.e. one for each alternative value of the decision variable. Some of the solutions in the neighborhood can violate constraints, these are infeasible and are not considered further.

An objective value is determined by information of the con-structed schedules. This could be a time-dependent or a cost-dependent objective. Examples of time-dependent objectives are: lateness, tardiness, total completion time or total makespan. Other objectives are the total cost or a resource leveling objective.
The makespan objective is used in this research, i.e. the difference between the start time of the earliest operation and the end time of the latest operation. The choice of the objective does not influence the general structure of our approach. The optimization stops when a termination condition is met. Possible termination conditions include a certain number of iterations without improvement, the computation time or a quality level. At termi-nation, the system returns the best found schedule. 5. Translation to RCPSP/GPR
The real world constraints, variables and objectives are trans-lated to a scheduling problem. The resource-constrained project scheduling problem with generalized precedence relations (RCPSP/GPR) is a very general scheduling problem, in which resource and time constraints can easily be formulated. An example of these constraints are the time lags between consecu-tive activities, as explained later in the present text. Each order is translated into a RCPSP/GPR. Multiple orders will then compose a multi-project scheduling problem with shared resources. First the
RCPSP/GPR is described, followed by the conversion of the real world constraints to this theoretical scheduling problem.
The RCPSP/GPR is a type of resource-constrained project scheduling problem with minimal and maximal time lags, also called generalized precedence relations or temporal constraints ( Franck et al., 2001 ). Neumann and Schwindt (1997) describe make-to-order production scheduling as one of the most obvious application fields of such a problem. We use a similar notation as described by Franck et al. (2001) . The RCPSP/GPR consists of a project with n real activities  X  1 , ... , n  X  . Two dummy activities (0 and n  X  1) are added to represent the start and the completion of the project. Let p i be the processing time or duration and S start time of activity i . Neither of the time values are limited to integer values, but can be any moment or timespan, since we are working with real world data. In fact, we use a continuous-time implementation. S 0 is set to the earliest point in time from which scheduling activities can start, and S n  X  1 is equal to the project duration or makespan.

Minimum and maximum time lags are defined between the activities of the project. d min ij 4 0 denotes a minimum time lag between activities i and j  X  i a j  X  . Their start times are related as S j S i Z d min ij . For a maximum time lag d max ij 4 0 between activities i and j , the relation between start times is defined as S j all the time lags are respected in a schedule, we say that the schedule is time-feasible.

Activities require resources to be executed. A set R of renew-able resources is available. Renewable resources are resources which can be re-used when a previous activity is finished with it. These resources k have a capacity R k 4 0. A resource capacity r required for carrying out activity i on resource k , where 0 r r ik r R k . If at each time t , the resource capacities are respected in a schedule, we say that the schedule is resource-feasible.
If a schedule is both time-and resource-feasible, then it is called feasible. The question whether or not a feasible schedule exists is an NP-complete decision problem ( Bartusch et al., 1988 ). Finding a feasible solution that minimizes the project duration is strongly NP-hard. Therefore, we have chosen to use heuristic methods for solving this problem.

Table 1 shows how concepts of the real world problem map to a theoretical scheduling problem (RCPSP/GPR). We translate each order to a project. Process steps are t ranslated to activities. Work-stations and equipment are translated into renewable resources. The resources have a capacity of R k  X  1 in most cases, but larger capacities are possible (e.g. a palletising workcenter that can handle input from multiple lines ). Routing relations (i.e. synchronization of start or finish times), time lags and product structure are translated into generalized precedence relations. Mapping the process steps to workcenters was determined in the decision step as discussed in Section 4. The processing times are set.

In what follows, we describe an example of the translation to generalized precedence constraints. Two consecutive process steps PS 1 and PS 2 are assigned to be executed on workcenters WC 1 and WC 2 , respectively. If PS 1 is translated to activity i and PS to activity j , and WC 1 and WC 2 have a time lag of TL , then we define the following minimum and maximum time lags, depend-ing on the type of connection between WC 1 and WC 2 .
 End X  X tart connection: d min ij  X  p i  X  TL End X  X nd connection: d min ij  X  TL and d max ij  X  TL
Once translated, i.e. into an RCPSP/GPR problem, the solution is generated sequentially project by project. The sequence was determined in the decision step. The RCPSP/GPR problems can be solved with techniques from the literature. Several branch-and-bound methods have been proposed for this scheduling problem in Bartusch et al. (1988) , De Reyck and Herroelen (1998) , Schwindt (1998) . Franck et al. (2001) introduce truncated branch and bound methods and metaheuristics such as tabu-search and genetic algorithms. Different priority rules have been presented in the literature ( Franck and Neumann, 1998 ; Kolisch, 1996 ) and can be used: smallest  X  X atest start time X  first (LST rule),  X  X inimum slack time X  first (MST rule),  X  X ost total successors first X  (MTS rule), etc. Priority rules have been shown to be fast, and they produce solutions of acceptable quality (especially for large problems).
Priority rule methods are used together with a serial schedule generation scheme to successively schedule the activities of a project. From Franck et al. (2001) , we selected the priority rule method with LST rule and applied it to the investigated problem. 6. Feeding the scheduler with accurate background knowledge
In various steps of the approach, different background knowl-edge is required. The accuracy of background knowledge is of highest importance for obtaining a good scheduling method. For example, adequate processing time s, i.e. the time needed to process a certain quantity of a certain product on a certain workcenter. Mostly these values are estimated u sing theoretical machine speeds.
This is reasonable as a first estimate, but in practice these values are not very accurate. We use the produ ction history to determine more accurate machine speeds. We will shortly describe this method.
We developed a method based on regression techniques, for adjusting the machine speed values by using the production history. Experiments have been carried out on a confidential dataset provided by a costumer of MESware. The dataset contains logs of executed operations over a period of one year. First of all, we translated the information history of executed operations to a set of instances. Each executed operation corresponds to one instance with multiple parameter values (workcenter, product type, quantity, etc.) and one continuous class value (i.e. machine speed). Afterwards, we feed these instances to a regression technique in order to build a model from the data. The model is then used to adjust the machine speed values in the background knowledge. We experimented with multiple regression techni-ques: neural networks, regression trees, model trees ( Wang and
Witten , 1996 ) and K-nearest neighbor methods ( Atkeson et al., 1997 ). Table 2 shows the results of three regression techniques, using a production history of 1 year. Model trees and K-nearest neighbor methods performed best in terms of root mean squared error (RMSE) performance. We compared the methods to a naive predictor. A naive predictor would always predict the average observed machine speed. The predictor, using a K-nearest neigh-bor method, appeared to meet the quality expectations (50% better than a naive predictor) on our test cases, and is integrated in the scheduler at the production site. 7. Illustrative example
In this section we illustrate the approach by means of an average scale real world example. We have been given data from a plant layout with about 20 workcenters, three parallel packing lines, and a lot of storage zones and buffers. Both end X  X nd and end X  X tart connections are present. Almost all workcenters are different in speed and capability. A number of heterogeneous sets of production orders with different sizes (from 10 to 100 in increments of 10, and from 100 to 1000 in increments of 100 production orders) are prepared, using a set of five different product types given by MESware (all tree structures). The orders consist on average of 10 process steps (including production and packaging). All these orders contain one or more mixing steps where multiple intermediate products are required as input. generating an initial feasible schedule for a set of heterogeneous orders of a certain size. The schedule generation step applies LST as a priority rule. The tests are performed on an Intel core 2 Duo 2.8 GHz processor, and the program is written in the c ] programming language. All background information is loaded in advance, database connection times are excluded. We can see that even for the largest set of 1000 production orders the algorithm needs less than a second to find a first feasible schedule (initial solution). This includes the preprocessing(routing), decision and schedule generation step. At this moment a typical customer of MESware is scheduling less than 100 orders a week. The tested approach needs less than 100 ms for scheduling this number of orders, and thus leaving enough potential for optimization or for scaling to larger clients. The performance scales linearly with the number of orders, because the orders are scheduled one after the other. The number of process steps per order will have a larger impact on the system, and influences the runtime of both the routing and schedule generation steps.
 the calculation time depends on several factors. One such factor is the termination condition. We use the following termination con-dition: stop when the number of consecutive loops (iterations) without significant  X  4 x min %  X  improvement exceeds a limit L .

Other factors that influence the calculation time are the initial solution, the number of orders and t he number of alternative routes.
The local search method used is a simple steepest descent which optimizes the total makespan objective (i.e. minimize the makespan over all projects).

Generating an optimized schedule for a set of 30 orders takes approximately 10 s, when we use x min  X  0 : 01 % and L max termination condition. The progress of this optimization in terms of total makespan is presented in Fig. 4 . The figure shows that the optimization further improves on the initial solution. In our tests we noticed that many improvements are realized by changing the routes. The sequence of orders has less influence on the schedule makespan when all the orders are similar. Note that we could easily replace the steepest descent algorithm by a more intelligent optimization algorithm (tabu-search, simulated annealing, genetic algorithm, etc.), which would enable further improvements. 8. Discussion
In this paper we presented an integrated approach for produc-tion scheduling, and demonstrated its applicability to the food processing industry. In these environments, the scheduling has to deal with a combination of discrete, continuous and batch processes, and is typically complicated by particular character-istics. For instance, the physical routes between workcenters in the plant layout, the high diversity of products (different tastes, different packaging, custom labels, ...  X  , complex product recipes, and many more. We decomposed the real-world scheduling task into several subtasks or steps that can be performed by different components. This allows us to develop methods for each subtask separately and it also allows us to easily extend the approach with new components. We initially modeled the scheduling problem as a very general resource-constrained project schedul-ing problem with generalized precedence relations. It enables us to model a variety of industry related constraints in separate modules. A popular priority rule-based method is used to solve the theoretical scheduling problem. However, it could be inter-changed with other solvers as well.

The presented approach is able to schedule multiple produc-tion orders together, which was actually an important require-ment of the industrial partner. Dealing with any possible plant layout is another essential requirement. Therefore, a routing problem is solved in a separate module, i.e. process steps are mapped onto workcenters. By putting this in a separate module, deciding on a specific route has become an explicit decision variable. By applying local search, new and better decisions can be explored for this module. As Fig. 4 shows, deciding on a route is a well chosen decision variable since considerable improve-ments of the schedule can be reached by changing this decision variable.

Another decision variable determines an explicit sequence in which the customer orders should be scheduled. This module should be extended further, so as to address sequence-dependent setup times. Other modules can be added to decide on, for instance, whether or when to include stock capacity into the production. This module could be designed as a reinforcement learning module ( Sutton and Barto, 1998 ) that learns in which situations stock should be included or not. In the special setting of food industries, keeping products in stock or in refrigerators is subject to timing constraints. This kind of constraints are per-fectly expressible using the generalized precedence relations as well.
 Many other decision variables could be taken into account.
One could even make a decision variable to represent the choice of the actual theoretical scheduling algorithm used. This idea fits into a trend in search methodologies, called hyperheuristics ( Burke et al., 2003 ). The idea behind hyperheuristics is to build generic search methods independent from problem or domain specific characteristics. As such, a hyperheuristic framework is concerned with learning on an abstract level which low-level algorithm is most suited for a problem at hand. It would be interesting to investigate whether hyperheuristics could contri-bute better to the generic applicability of our approach.
One of the remaining requirements is to feed the scheduler with up-to-date information on the production process. This was addressed by replacing the theoretical machine speeds by better estimates. These estimates result from a regression algorithm that uses historical information. For now, only estimations of the processing times are fed back to the system, but this can straightforwardly be extended to other KPIs.

Finally, our approach also showed to be fast enough for practical use and scales well to a large number of production orders.

In the future we will extend our approach by including extra functionality and additional real world constraints. Of particular interest will be a complete integration of stock and buffers, the use of sequence-dependent setup times, customer specific objec-tives and the integration with personnel scheduling. A last addition we consider is grouping and splitting orders on work-centers or production lines.
 Acknowledgments
Research was carried out during the project IWT-090609, supported by the Flemish agency for Innovation by Science and Technology (IWT).
 References
