 1. Introduction [11] and in turn, the execution of activities results in certain data constraints being enforced. specify the effect on the data state for each activity. For instance, in the Sarbanes workflows are properly designed.

Only recently, approaches for verifying workflow models with dataflows have been proposed [11 control flow and dataflow dependencies, as we explain in Section 2 with an example. activity and fails.

We distinguish between two different notions of correctness to diagnose such dataflow errors:  X  which the activity is done.  X  precondition of the activity.
 any ambiguity.

This paper makes several contributions:  X  activities. These conditions are modeled as constraints according to a well-defined grammar in BNF.  X  where the workflow gets stuck.  X  semantics of activities and the corresponding dataflow are specified using extended attributes. literature. And finally, conclusions are drawn and future work is proposed in Section 8 . 2. A motivating example workflow models. We use BPMN 2.0 [18] to visualize workflow models.
 activity names that are listed in Table 1 . The workflow performs the following steps: social events during the conference (O or OS activities).
 4. Next, the registration of the attendees of the conference takes place (R). guest speakers (NGS or IGS).
 variables are used by the activities of the example, indicating if they are read ( rd ) or written ( wt ). shown in Table 4 . The notation is explained in the next section.
 results in a data state (assignment of values to variables) that has to satisfy the precondition of a . every activity can be executed, the workflow is may-correct .
 such that eventually the end state is reached? If the answer is positive, the workflow is must-correct . strict. Must-correctness can be used to check the correctness of the entire workflow with all the activities. next, R , has a precondition that is false, since 3  X  30 + 100 + 30 workflow gets stuck at activity R .
 conditions of each activity, which determines the possible data states just before R . precondition itself is flawed. 3. Work fl ow data graphs Artificial Intelligence techniques.
 workflow models [1,19] by adding data. 3.1. De fi nition directed edges, with a unique start and a unique end node.

De fi nition 1. A workflow data graph is a tuple P =( Act , V , D , C , E , pre , post , wt ) where:  X 
Act is a set of activities;  X  V is a set of typed variables;  X 
D is a set of finite domains (types), that contains for each variable v  X  C is a set of control nodes (gateways), partitioned into disjoints sets of XOR splits S J AND , and { start , end } where start is the unique start node and end the unique end node. Each split in S expressions for each gate of the gateway in order to specify the flow depending on the data;  X 
E p Act  X  Act is a set of edges which determines precedence relation;  X  pre : Act  X  Cs ( V ) assigns to each activity its precondition (a constraint c  X  post : Act  X  Cs ( V ) assigns to each activity its postcondition (a constraint c  X  wt : Act  X  V assigns to each activity its written variables.
 without preconditions [14]. In future work, we plan to consider guard conditions. Variables in the postcondition of a ,soin var ( post ( a )), are read and/or written by a .
De value. The set of constraints on V , denoted Cs ( V ), is generated by the following grammar in BNF: Atomic X Constraint ::  X  Function PREDICATE Function 1. the start node has no incoming edge and one outgoing edge; 2. the end node has one incoming edge and no outgoing edge; 3. each activity has one incoming and one outgoing edge; 4. each split node has one incoming and at least two outgoing edges; 5. each join node has at least two incoming edges and one outgoing edge; 6. each node is on a path from the start to the end node (connectedness); 7. the precedence relation is acyclic.
 by default.
 ensure that loops are exited eventually [21].

As in [1], we also use auxiliary functions inedge ; outedge example, if inedge ( n )={ e 1 , e 2 }, then inedge 1 ( n )= e 3.2. Analysis an instance subgraph , which corresponds to a particular execution instance of a workflow graph. [20].
 graph is generated by traversing a workflow graph from the start node, using the following rules:  X  if an XOR split node is visited, one of its outgoing edge is visited based on a guard condition;  X  if an AND split node is visited, then all outgoing edges are visited [1];  X  incoming edges have not been visited [1];  X   X  if an activity is visited, then its outgoing edge is visited too.
 instance subgraphs plus the additional rule:  X  if the incoming edge of an activity is visited, then the activity is visited too. variables written by the activities in the instance subgraph.
 subgraph such that there is a directed path from a to a  X 
De fi nition 3. A data instance subgraph of a workflow graph ( Act , V , D , C , E , pre , post , wt )isatuple( Act w here:  X  ( Act  X  , V  X  , D  X  , C  X  , E  X  , pre  X  , post  X  , wt  X  ) is an instance subgraph with Act pre  X  ( Act  X   X  Cs ( V )), post  X  = post  X  ( Act  X   X  Cs ( V )) , and wt  X   X  is an assignment of values to the variables in V  X  , so that each variable v evaluates to true, so the assigned values satisfy the postcondition post ( a ).  X  ( regFee ) = 200,  X  ( dinner ) = 30,  X  ( lunch ) = 60,  X  ( others ) = 80, and evaluate to true if for every variable v the value  X  ( v ) is substituted. using existing techniques [1,19] . We therefore ignore such errors for the remainder of this paper. workflow models. For the purpose of this paper, the following two errors are important:  X   X  variable written earlier by the other activity.
 Section 4.2 we define an algorithm for detecting data conflicts.
 point of view. In that case, the workflow gets stuck and fails. does not contain a but does contain the incoming edge of a , which is unique. So the instance subgraph example in Fig. 2 , the shadowed partial instance subgraph triggers the activity R . two auxiliary notions in Definitions 4 and 5 .

De variables satisfies the precondition of a .

De precondition of a .
 Next, we define the two new notions of dataflow correctness.

De fi nition 6. A workflow data graph is may-correct if every activity is may-executable.
De fi nition 7. A workflow data graph is must-correct if every activity is must-executable. absence of precondition violations.
 data graphs. 4. Diagnosis of work fl ow data graphs: May and must-correctness may or must-correct, the algorithms identify which activities are responsible for the incorrectness. necessary to avoid conflicts among postconditions, and detect basic errors in the dataflow. 4.1. Combined IP and CSP model 4.1.1. IP formulation existing IP formulation uses for each a  X  Act the constraint inedge replace for every a  X  Act the constraint inedge 1 ( a )  X  constraint allows that the subgraph  X  stops  X  at a ( inedge inedge 1 ( a ) = 0 and a = 1 is not allowed.
 IP formulation.

De fi x  X  { Act  X  C  X  E }, an IP variable x is created. The constraints, adapted from [1], are: IP0 start = 1
IP1 For n  X  ( S AND  X  S XOR  X  { end }): inedge 1 (n)  X  n = IP1a For n  X  Act : inedge 1 (n)  X  n
IP2 For n  X  ( Act  X  J AND  X  J XOR  X  { start }): outedge 1 IP3 For n  X  S AND , being | outedge ( n )| = k : IP4 For n  X  J AND , being | inedge ( n )| = k : IP5 For n  X  S XOR , being | outedge ( n )| = k : IP6 For n  X  J XOR , being | inedge ( n )| = k : 4.1.2. CSP formulation of the triple b V , D , Cs &gt;, where V is a set of n variables v respectively, and Cs is a set of constraints on their values. The constraint c a  X  postconditions are only enforced if a is activated, so a is in the instance subgraph. and B that both write integer variable i , where the postcondition of A is i postconditions of A and B conflict. To resolve conflicts, we put the CSP model in SSA form, explained next. 4.1.3. SSA form an SSA form, each variable v is separated into several variables v Note that two new constraints have been added at activity D .Theyareknownas section defines an algorithm for detecting basic dataflow errors. 4.2. Detecting basic data fl ow errors dataflow error can be detected.

To identify missing data, we use the following constraint. For each activity a The next theorem asserts the correctness of the algorithm.
 only if there is no conflicting data .
  X  Suppose the algorithm finds an instance subgraph that triggers two activities a 4.3. Algorithm for may-correctness encode that a is triggered and that the precondition of a is satisfied. data graph is may-correct (line 17).
 The next theorem asserts that the algorithm is correct.
 ( Act , V , D , C , E , pre , post , wt ) is may-correct .

Proof 2. The performance of the algorithm is discussed in Section 6 .
 4.4. Algorithm for must-correctness every activity is must-executable, the workflow data graph is must-correct by definition. executable, the workflow data graph is must-correct (line 17).
 We next prove that the algorithm is correct.
 ( Act , V , D , C , E , pre , post , wt ) is must-correct .

Proof 3. 4.5. Correcting errors incorrectness, the designer can decide, for example:  X  strictness of the precondition.  X  precondition of a .  X  data [26] ). 4.6. Diagnosing the motivating example name of the variable to others 3 after the join.
 such that pre ( a ) is satisfied.

R unsatisfiable. Therefore the workflow is not must-correct. 5. Implementation paper. For solving these CSPs, the tool uses the COMET  X  solver by Dynadec [27] .COMET propose the following extension of the XPDL schema, which conforms to the XPDL standard [17]: 1. input data of the activity (read operations) 2. output data of the activity (write operations) 3. precondition: constraint (or constraints) over the input data 4. postcondition: constraint (or constraints) over the input and output data b xpdl : Activity ... &gt;
WorkflowProcess : b = xpdl : WorkflowProcess &gt; .
 6. Empirical evaluation algorithms is acceptable. 6.1. Experimental design verify the different kinds of correctness.
 correctness checking process over workflow data graphs with different control flows and dataflows. getting test cases with different numbers of activities, control nodes and data. 6.2. Performance results In this subsection, the execution time of the correctness checking algorithms is measured. [28 next.
 the size of the workflow data graph being analyzed.
 presence of control nodes in a workflow W , defined as follows: where CFC S XOR n  X  X  X  outedge n  X  X  jj and CFC S AND n  X  X  X  and therefore the execution times are similar.
 presented algorithms is acceptable.
 7. Related work
As stated in the introduction, most of the previous works in the literature [1,3 execution possible (preconditions).
  X  dependencies between activities.
 hand, our approach detects an error in the workflow, as explained in Section 4.6 . execution, we have to take into account all possible executions.
 certain conditions (i.e., some valuations of the variables) the process may get stuck. resulting report only provides general statistics. worlds to deliver advanced yet efficient verification and diagnosis of complex workflow models with dataflows. 8. Conclusions correctness, for workflow data graphs.
 models with dataflows, despite the high worst-case complexity of solving constraint satisfaction programs. of the analysis.
 Acknowledgment School of Industrial Engineering, at Eindhoven University of Technology, for hosting part of the research.
References
