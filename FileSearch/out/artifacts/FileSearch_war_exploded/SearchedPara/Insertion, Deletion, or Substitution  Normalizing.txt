 Recent years have witnessed the explosive growth of text message usage, including the mobile phone text messages (SMS), chat logs, emails, and sta-tus updates from the social network websites such as Twitter and Facebook. These text message col-lections serve as valuable information sources, yet the nonstandard contents within them often degrade the existing language processing systems, calling the need of text normalization before applying the traditional information extraction, retrieval, senti-ment analysis (Celikyilmaz et al., 2010), or sum-marization techniques. Text message normalization is also of crucial importance for building text-to-speech (TTS) systems, which need to determine pro-nunciation for nonstandard words.

Text message normalization aims to replace the non-standard tokens that carry significant mean-ings with the context-appropriate standard English words. This is a very challenging task due to the vast amount and wide variety of existing nonstan-dard tokens. We found more than 4 million dis-tinct out-of-vocabulary tokens in the English tweets of the Edinburgh Twitter corpus (see Section 2.2). Table 1 shows examples of nonstandard tokens orig-inated from the word  X  X ogether X . We can see that some variants can be generated by dropping let-ters from the original word ( X  X gthr X ) or substitut-ing letters with digit ( X 2gether X ); however, many variants are generated by combining the letter in-sertion, deletion, and substitution operations ( X  X o-qethaa X ,  X 2gthr X ). This shows that it is difficult to divide the nonstandard tokens into exclusive cate-gories.

Among the literature of text normalization (for text messages or other domains), Sproat et al. (2001), Cook and Stevenson (2009) employed the noisy channel model to find the most probable word sequence given the observed noisy message. Their approaches first classified the nonstandard tokens into various categories (e.g., abbreviation, stylistic variation, prefix-clipping), then calculated the pos-terior probability of the nonstandard tokens based on each category. Choudhury et al. (2007) de-veloped a hidden Markov model using hand anno-tated training data. Yang et al. (2009), Pennell and Liu (2010) focused on modeling word abbreviations formed by dropping characters from the original word. Toutanova and Moore (2002) addressed the phonetic substitution problem by extending the ini-tial letter-to-phone model. Aw et al. (2006), Kobus et al. (2008) viewed the text message normalization as a statistical machine translation process from the texting language to standard English. Beaufort et al. (2010) experimented with the weighted finite-state machines for normalizing French SMS mes-sages. Most of the above approaches rely heavily on the hand annotated data and involve categorizing the nonstandard tokens in the first place, which gives rise to three problems: (1) the labeled data is very expensive and time consuming to obtain; (2) it is hard to establish a standard taxonomy for categoriz-ing the tokens found in text messages; (3) the lack of optimized way to integrate various category-specific models often compromises the system performance, as confirmed by (Cook and Stevenson, 2009).
In this paper, we propose a general letter trans-formation approach that normalizes nonstandard to-kens without categorizing them. A large set of noisy training word pairs were automatically collected via a novel web-based approach and aligned at the char-acter level for model training. The system was tested on both Twitter and SMS messages. Results show that our system significantly outperformed the jazzy spell checker and the state-of-the-art deletion-based abbreviation system, and also demonstrated good cross-domain portability. 2.1 General Framework Given a noisy text message T , our goal is to nor-malize it into a standard English word sequence S . Under the noisy channel model, this is equivalent to finding the sequence  X  S that maximizes p ( S | T ) : where we assume that each non-standard token T i is dependent on only one English word S i , that is, we are not considering acronyms (e.g.,  X  X bl X  for  X  X e back later X ) in this study. p ( S ) can be cal-culated using a language model (LM). We formu-late the process of generating a nonstandard token T i from dictionary word S i using a letter transfor-mation model, and use the model confidence as the probability p ( T i | S i ) . Figure 1 shows several exam-ple (word, token) pairs 1 . To form a nonstandard to-ken, each letter in the dictionary word can be labeled with: (a) one of the 0-9 digits; (b) one of the 26 char-acters including itself; (c) the null character  X - X ; (d) a letter combination. This transformation process from dictionary words to nonstandard tokens will be learned automatically through a sequence labeling framework that integrates character-, phonetic-, and syllable-level information.

In general, the letter transformation approach will handle the nonstandard tokens listed in Table 2 yet without explicitly categorizing them. Note for the tokens with letter repetition, we first generate a set of variants by varying the repetitive letters (e.g. C i = {  X  X leas X ,  X  X leeas X ,  X  X leaas X ,  X  X leeaas X ,  X  X leeeaas X  } for T i = {  X  X leeeaas X  } ), then select the maximum posterior probability among all the variants: 2.2 Web based Data Collection w/o Supervision We propose to automatically collect training data (annotate nonstandard words with the corresponding English forms) using a web-based approach, there-fore avoiding the expensive human annotation. We use the Edinburgh Twitter corpus (Petrovic et al., 2010) for data collection, which contains 97 mil-lion Twitter messages. The English tweets were extracted using the TextCat language identification toolkit (Cavnar and Trenkle, 1994), and tokenized into a sequence of clean tokens consisting of letters, digits, and apostrophe.

For the out-of-vocabulary (OOV) tokens consist-ing of letters and apostrophe, we form n Google queries for each of them in the form of either  X  w 1 w 2 w 3  X  OOV or OOV  X  w 1 w 2 w 3  X  , where w 1 to w 3 are consecutive context words extracted from the tweets that contain this OOV. n is set to 6 in this study. The first 32 returned snippets for each query are parsed and the words in boldface that are differ-ent from both the OOV and the context words are collected as candidate normalized words. Among them, we further select the words that have longer common character sequence with the OOV than with the context words, and pair each of them with the OOV to form the training pairs. For the OOV tokens consisting of both letters and digits, we use simple rules to recover possible original words. These rules include: 1  X   X  X ne X ,  X  X on X ,  X  X  X ; 2  X   X  X o X ,  X  X wo X ,  X  X oo X ; 3  X   X  X  X ; 4  X   X  X or X ,  X  X ore X ,  X  X our X ; 5  X   X  X  X ; 6  X   X  X  X ; 8  X   X  X te X ,  X  X it X ,  X  X at X ,  X  X ate X ,  X  X ght X ,  X  X ight X . The OOV tokens and any resulting words from the above process are included in the noisy training pairs. In addition, we add 932 word pairs of chat slangs and their normalized word forms col-lected from InternetSlang.com that are not covered by the above training set.

These noisy training pairs were further expanded and purged. We apply the transitive rule on these initially collected training pairs. For example, if the two pairs  X (cause, cauz) X  and  X (cauz, coz) X  are in the data set, we will add  X (cause, coz) X  as another train-ing pair. We remove the data pairs whose word can-didate is not in the CMU dictionary. We also remove the pairs whose word candidate and OOV are simply inflections of each other, e.g.,  X (headed, heading) X , using a set of rules. In total, this procedure generated 62,907 training word pairs including 20,880 unique candidate words and 46,356 unique OOVs. 2 2.3 Automatic Letter-level Alignment Given a training pair ( S i ,T i ) consisting of a word S and its nonstandard variant T i , we propose a proce-dure to align each letter in S i with zero, one, or more letters/digits in T i . First we align the letters of the longest common sequence between the dictionary word and the variant (which gives letter-to-letter cor-respondence in those common subsequences). Then for the letter chunks in between each of the obtained alignments, we process them based on the following three cases: (a) (many-to-0): a chunk in the dictionary word (b) (0-to-many): zero letters in the dictionary word (c) (many-to-many): non-zero letters in the dictio-
The (b) and (c) cases above generate chunk-level (with more than one letter) alignments. To elimi-nate possible noisy training pairs, such as ( X  X ou X ,  X  X aveu X ), we keep all data pairs containing digits, but remove the data pairs with chunks involving three letters or more in either the dictionary word or the variant. For the chunk alignments in the remain-ing pairs, we sequentially align the letters (e.g.,  X  X h X  aligned to  X  X - X ). Note that for those 1-to-2 align-ments, we align the single letter in the dictionary word to a two-letter combination in the variant. We limit to the top 5 most frequent letter combinations, which are  X  X k X ,  X  X y X ,  X  X e X ,  X  X u X ,  X  X h X , and the pairs involving other combinations are removed.

After applying the letter alignment to the col-lected noisy training word pairs, we obtained 298,160 letter-level alignments. Some example alignments and corresponding word pairs are: e  X   X   X  (have, hav) q  X  k (iraq, irak) e  X  a (another, anotha) q  X  g (iraq, irag) e  X  3 (online, 0nlin3) w  X  wh (watch, whatch) 2.4 Sequence Labeling Model for P ( T i | S i ) For a letter sequence S i , we use the conditional ran-dom fields (CRF) model to perform sequence tag-ging to generate its variant T i . To train the model, we first align the collected dictionary word and its variant at the letter level, then construct a feature vector for each letter in the dictionary word, using its mapped character as the reference label. This la-beled data set is used to train a CRF model with L-BFGS (Lafferty et al., 2001; Kudo, 2005). We use the following features:  X  Character-level features  X  Phonetic-level features  X  Syllable-level features
The trained CRF model can be applied to any En-glish word to generate its variants with probabilities. We evaluate the system performance on both Twitter and SMS message test sets. The SMS data was used in previous work (Choudhury et al., 2007; Cook and Stevenson, 2009). It consists of 303 distinct non-standard tokens and their corresponding dictionary words. We developed our own Twitter message test set consisting of 6,150 tweets manually annotated via the Amazon Mechanical Turk. 3 to 6 turkers were required to convert the nonstandard tokens in the tweets to the standard English words. We extract the nonstandard tokens whose most frequently nor-malized word consists of letters/digits/apostrophe, and is different from the token itself. This results in 3,802 distinct nonstandard tokens that we use as the test set. 147 (3.87%) of them have more than one corresponding standard English words. Similar to prior work, we use isolated nonstandard tokens without any context, that is, the LM probabilities P ( S ) are based on unigrams.
 We compare our system against three approaches. The first one is a comprehensive list of chat slangs, abbreviations, and acronyms collected by Internet-Slang.com; it contains normalized word forms for 6,105 commonly used slangs. The second is the word-abbreviation lookup table generated by the su-pervised deletion-based abbreviation approach pro-posed in (Pennell and Liu, 2010). It contains 477,941 (word, abbreviation) pairs automatically generated for 54,594 CMU dictionary words. The third is the jazzy spell checker based on the Aspell algorithm (Idzelis, 2005). It integrates the phonetic matching algorithm (DoubleMetaphone) and Leven-shtein distance that enables the interchanging of two adjacent letters, and changing/deleting/adding of let-ters. The system performance is measured using the n-best accuracy (n=1,3). For each nonstandard to-ken, the system is considered correct if any of the corresponding standard words is among the n-best output from the system.
Results of system accuracies are shown in Ta-ble 3. For the system  X  X etterTran (All) X , we first generate a lookup table by applying the trained CRF model to the CMU dictionary to generate up to 30 variants for each dictionary word. 3 To make the comparison more meaningful, we also trim our lookup table to the same size as the deletion ta-ble, namely  X  X etterTran (Trim) X . The trimming was performed by selecting the most frequent dictionary words and their generated variants until the length limit is reached. Word frequency information was obtained from the entire Edinburgh corpus. For both the deletion and letter transformation lookup tables, we generate a ranked list of candidate words for each nonstandard token, by sorting the combined score fidence and C ( S i ) is the unigram count generated from the Edinburgh corpus (we used counts instead of unigram probability P ( S i ) ). Since the string sim-ilarity and letter switching algorithms implemented in jazzy can compensate the letter transformation model, we also investigate combining it with our ap-proach,  X  X etterTran(All) + Jazzy X . In this configura-tion, we combine the candidate words from both sys-tems and rerank them according to the unigram fre-quency; since the  X  X etterTran X  itself is very effective in ranking candidate words, we only use the jazzy output for tokens where  X  X etterTran X  is not very confident about its best candidate (( p ( T i | S i )  X  C ( S is less than a threshold  X  = 100 ).

We notice the accuracy using the InternetSlang list is very poor, indicating text message normal-ization is a very challenging task that can hardly be tackled by using a hand-crafted list. The dele-tion table has modest performance given the fact that it covers only deletion-based abbreviations and letter repetitions (see Section 2.1). The  X  X etter-Tran X  approach significantly outperforms all base-lines even after trimming. This is because it han-dles different ways of forming nonstandard tokens in an unified framework. Taking the Twitter test set for an example, the lookup table generated by  X  X etterTran X  covered 69.94% of the total test to-kens, and among them, 96% were correctly normal-ized in the 3-best output, resulting in 67.02% over-all accuracy. The test tokens that were not covered by the  X  X etterTrans X  model include those generated by accidentally switching and inserting letters (e.g.,  X  X bsolotuely X  for  X  X bsolutely X ) and slangs ( X  X ddy X  or  X  X ddress X ). Adding the output from jazzy com-pensates these problems and boosts the 1-best ac-curacy, achieving 21.69% and 18.16% absolute per-formance gain respectively on the Twitter and SMS test sets, as compared to using jazzy only. We also observe that the  X  X etterTran X  model can be easily ported to the SMS domain. When combined with the jazzy module, it achieved 62.05% 1-best accu-racy, outperforming the domain-specific supervised system in (Choudhury et al., 2007) (59.9%) and the pre-categorized approach by (Cook and Steven-son, 2009) (59.4%). Regarding different feature cat-egories, we found the character-level features are strong indicators, and using phonetic-and syllabic-level features also slightly benefits the performance. In this paper, we proposed a generic letter trans-formation approach for text message normaliza-tion without pre-categorizing the nonstandard to-kens into insertion, deletion, substitution, etc. We also avoided the expensive and time consuming hand labeling process by automatically collecting a large set of noisy training pairs. Results in the Twitter and SMS domains show that our system can signif-icantly outperform the state-of-the-art systems and have good domain portability. In the future, we would like to compare our method with a statistical machine translation approach performed at the let-ter level, evaluate the system using sentences by in-corporating context word information, and consider many-to-one letter transformation in the model. The authors thank Deana Pennell for sharing the look-up table generated using the deletion-based ab-breviation approach. Thank Sittichai Jiampojamarn for providing the many-to-many letter-phoneme alignment data sets and toolkit. Part of this work was done while Fei Liu was working as a research intern in Bosch Research and Technology Center.
