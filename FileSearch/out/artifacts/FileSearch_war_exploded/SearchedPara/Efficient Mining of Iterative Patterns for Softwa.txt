 Studies have shown that program comprehension takes up to 45% of software development costs. Such high costs are caused by the lack-of documented specification and further aggravated by the phenomenon of software evolution. There is a need for automated tools to extract specifications to aid program comprehension. In this paper, a novel technique to efficiently mine common software tem poral patterns from traces is proposed. These patterns shed light on program behaviors, and are termed iterative patterns .Theycapture unique characteristic of software traces, typically not found in arbitrary sequences. Specifically, due to loops, interesting iterative patterns can occur multiple times within a trace. Furthermore, an occurrence of a n iterative pattern in a trace can extend across a sequence of indefinite length .Since a pro-gram behavior can be manifested in numerous ways, analyz-ing a single trace will not be sufficient . Iterative pattern mining extends sequential pattern and episode minings to discover frequent iterative patterns which occur repetitively both within a program trace and across multiple traces. In this paper, we present CLIPER (CL osed I terative P attern minER ) to efficiently mine a closed set of iterative patterns. A performance study on several simulated and real datasets shows the efficiency of our mining algorithm and effective-ness of our pruning strategy. Our case study on JBoss Ap-plication Server confirms the usefulness of mined patterns in discovering interesting software behavioral specification. H.2.8 [ Database Management ]: Database Applications X  Data Mining ; D.2.1 [ Software Engineering ]: Require-ments/Specifications X  Tools Algorithms, Performance, Experimentation Closed Iterative Patterns, Software Specification Discovery Copyright 2007 ACM 978-1-59593-609-7/07/0008 ... $ 5.00.
It X  X  best if all programs and software projects are de-veloped with clear, precise and documented specifications. However, due to hard deadlines and  X  X hort-time-to-market X  requirement [6], software products often come with poor, in-complete and even without any documented specifications. This situation is further aggravated by a phenomenon termed as software evolution [4, 21]. As software evolves the docu-mented specification is often not updated. This might ren-der the original documented specification of little use after several cycles of program evolution [10].

The above factors has contributed to high software main-tenance costs. It has been investigated that up to 90% of software cost is due to maintenance [12] and 50% of the maintenance cost is due to comprehending or understand-ing the code base [27] (see also [5]). Hence, approximately 45% of software cost is due to difficulty in comprehending an existing code base. This is especially true for software developed by many developers over a long period of time.
The above needs motivate work on building automated tools to extract or mine specifications from programs. An interesting form of specifications to be mined is patterns of software temporal behaviors.

Our motivating application is in the emerging area of dy-namic analysis where program traces (each being a series of method invocations) are analyzed in order to infer or mine temporal program properties or patterns of behavior. Some existing work in this domain includes: [2, 22], which mine temporal program behavioral model expressed as an automata. In this paper, we propose mining interesting pro-gram temporal properties expressed as patterns rather than an automata. These patterns are intuitive and commonly found in software documentations, such as: 1. Resource Locking Protocol : lock, unlock 2. Telecommunication Protocol ( c.f. , [16]): off hook , 3. Java Authentication and Authorization Service (JAAS) 4. Java Transaction Architecture (JTA) Protocol
Each of these patterns reflecting interesting program be-havior can be mined by analyzing a set of program traces  X  each being a series of method invocations. These traces can in turn be generated through running a test suite. From data mining viewpoint, each trace can be considered a se-quence. A pattern ( e.g. , lock-unlock) can appear a repeated number of times within a sequence . Eacheventcanbe sep-arated by an arbitrary number of unrelated events ( e.g. , lock  X  resource use  X  ...  X  unlock ). Since a program behav-ior can be manifested in numerous ways, analyzing a sin-gle trace will not be sufficient . Usually, a set of test cases satisfying certain code coverage ( i.e. , every statements are executed) or branch coverage ( i.e. , every branch decision is taken) criterion ( c.f. , [3]) is required to test the correct-ness of a software system. Running this test suite over an instrumented software will generate the desired traces.
To mine software temporal patterns having the above char-acteristics from traces, iterative pattern mining is proposed. It leverages the techniques found in sequential pattern min-ing and episode mining to handle software specification min-ing.
 Sequential pattern mining first addressed by Agrawal and Srikant in [1] discovers temporal patterns that are supported by a significant number of sequences . A pattern is supported by a sequence if it is a sub-sequence of it. It has applica-tion in many areas, from analysis of market data to gene se-quences. On the other hand, Mannila et al. perform episode mining to discover frequent episodes within a sequence of events [23]. An episode is defined as a series of events oc-curring relatively close to one another ( i.e. they occur at the same window). An episode is supported by a window if it is a sub-sequence of the series of events appearing in the window. Episode mining focuses on mining from a single se-quence of events, and has its application in analyzing events from telecommunication alarm management system.

Iterative pattern is a series of events supported by a sig-nificant number of instances repeated within and across se-quences . Similar to sequential pattern mining, we consider a database of sequences rather than a single sequence. How-ever, we also mine patterns occurring repeatedly within a sequence. This is similar in spirit to episode mining, but we remove the restriction that related events must happen in thesamewindow.

Due to looping, a trace can contain repeated occurrences of interesting patterns. In fact, a series of events in an alarm management system used by Manilla et al. is similar to a series of system calls in a software system. However, there are 2 notable differences.

First, program properties are often inferred from a set of traces instead of a single trace. These are either produced by executing a test suite [32] or generated statically from the source code [30]. Secondly, important patterns for ver-ification, such as, lock acquire and release or stream open and close ( c.f [32, 7]) often have their events occur at some arbitrary distance away from each other in a program trace. Hence, there is a need to  X  X reak X  the  X  X indow barrier X  in or-der to capture these patterns of interest. Interestingly, these two notable differences between analysis of events from an alarm management system and program traces are observed by sequential pattern miner first introduced in [1].
To support iterative pattern mining, we need a clear defi-nition and semantics of iterative pattern different from episo X  des and sequential patterns. Our definition of iterative pat-tern is inspired by the common languages for specifying software behavioral requirements, namely Message Sequence Chart (MSC) [16] and Live Sequence Chart (LSC) [9].
MSC and LSC are variants of sequence diagram speci-fying how a system should behave. An example of such chart is a simplified telephone switching protocol ( c.f. , [16]). Abstracting caller and callee information, it can be repre-sented as a pattern: off hook, dial tone on, dial tone off, seizure int, ring tone, answer, connection on . Such proto-col must possess a total-ordering property and satisfy one-to-one correspondence requirements between events in the chart and events in a trace segment satisfying the chart. (Please refer to Section 3.2 for detail.)
The full language of MSC/LSC is complicated and it is not our intention to mine MSC/LSC. In this paper, itera-tive pattern mined abstracts away the caller and callee infor-mation but ensures total-order ing property and one-to-one correspondence between a pattern and its instance ( i.e. ,a segment of a trace).

Pattern mining in general is an NP-hard problem. For it to be practical, efficient search space pruning strategies need to be employed. One of the most important property to help in ensuring scalability is the apriori property. There are several variants of it. Iterative pattern obeys the follow-ing apriori property utilized by depth-first search sequen-tial pattern miners ( e.g. , FreeSpan [14] and PrefixSpan [25]) which states:
If P is not frequent then P ++ evs (where evs is a series of events) is also not frequent.

Apriori property holds for b oth sequential patterns and episodes. To ensure efficiency, it is desirable to maintain this property for iterative patterns. Fortunately, the formulation of iterative pattern guarantees this property as described in Section 3.

Due to possibly combinatorial number of frequent subse-quences of a long pattern, it X  X  best to mine a closed set of patterns ( c.f. , [31] &amp; [29]). Closed pattern mining discovers patterns without any super-sequence having corresponding set of instances. Resultant pattern set is likely to be more compact and yet stil l complete ( i.e. every frequent pattern is represented by a closed pattern). Closed pattern min-ing can also lead to more efficient pattern mining strategy. Early identification and pruning of non-closed patterns can reduce the runtime significantly.
 In this paper, we mine a closed set of iterative patterns. A search space pruning strategy employed by early identifi-cation and pruning of non-closed patterns is used to mine a closed set of iterative patterns efficiently. Our performance study on synthetic and real-world datasets shows the major success of our pruning strategy: it runs with over an order of magnitude speedup especially on low support thresholds or when the frequent patterns are long.

As a case study we experimented with traces collected from transaction sub-component of JBoss Application Server. Our mined patterns highlight important design patterns shed-ding light on program behavior.

The contributions of this work are as follows: 1. We propose an efficient algorithm to mine a closed set 2. We present a novel formulation of iterative pattern in-3. We extend episode mining by: (1) analyzing multiple 4. We extend closed pattern mining by considering re-
The outline of the paper is as follows: We present related work in Section 2. Section 3 provides an in-depth discussion on semantics of iterative pattern. Section 4 presents the principles behind the generation of closed iterative patterns and its associated pruning strategy. Section 5 describes our closed pattern mining algorithm. Section 6 presents the re-sults of our performance study. Section 7 discusses a case study on mining program behavioral design from traces of JBoss Application Server. We conclude in Section 8.
Our work is a variant of sequential pattern mining, which was originated by Agrawal and Srikant [1]. To remove re-dundant patterns, closed sequential pattern mining was pro-posed by Yan et al. [31] and later improved by Wang and Han [29]. Different from sequential pattern, our pattern cap-ture multiple occurrences of pattern not only across multiple sequences but also those repeated within each sequence .In this aspect, iterative pattern mining resembles episode min-ing initiated by Mannila et al. [23] which was later extended by Casas-Garriga to replace a fixed-window size with a gap constraint between one event to the next in an episode [13]. Both versions of episode mining mine events occurring close to one another, expressed by  X  X indow size X  and gap con-straint respectively. This is different with iterative pattern mining, which does not have the notion of  X  X pisode X . This deviation is significant, since important program behavioral patterns, for example: lock acquire and release or file open and close ( c.f [32, 7]), often have their events occur at some arbitrary distance away from one another in a trace. In addition, both versions of episode mining handle only one single sequence, whereas iterative pattern mining operates over a set of sequences.

In mining DNA sequences, Zhang et al. introduced the idea of  X  X ap requirement X  in mining periodic patterns from sequences [33]. Similar to ours, they detect repeated oc-currences of patterns within a sequence and across multiple sequences. However, the gap requirement used there does not always hold for other purposes. Consider analyzing soft-ware traces, the useful patterns of lock acquire followed-by lock release can be separated by any number of events, and will violate the gap requirement. In addition, the pattern definition proposed in [33] does not follow apriori property and hence potentially reduces the efficiency of the mining process. Lastly, the method only guarantees the mining of a complete set of patterns, all with length less than n ,where n is a user defined parameter. The appropriate value of this parameter n might not be obvious to the user.

In the software engineering domain, Yang et al. mined a restricted form of two-event temporal rules, instead of pat-terns, from program traces [32]. To handle more than two events, they proposed concatenation of 2-event rules to form longer ones. Unfortunately, this method is not sound as only an approximation to significance values of reported rules is made. It is also not complete since potentially many of the more-than-two-event rules cannot be generated by simple concatenation of 2-event rules.

In a similar domain, El-Ramly et al. mined user-usage sce-narios of GUI based program composed of screens  X  these scenarios are termed as intera ction patterns [11]. Given a set of series of screen ids, frequent patterns of user inter-actions are obtained. Similar to ours, interaction pattern mining takes as an input a set of sequences and discover patterns occurring repeat edly within sequences.

However, due to differences in the nature of data mined, there are significant differences between interaction and it-erative pattern mining.

Firstly, the semantics of the patterns mined are differ-ent. Iterative pattern adheres to the semantics of MSC/LSC specification language in describing software behavioral re-quirements, whereas interaction pattern does not. Conse-quently, the apriori property is not observed by interaction patterns  X  a pattern can have a larger support than its sub-sequences. In contrast, iterative patterns observe the apriori property.

Secondly, for each pattern instance, interaction pattern imposes a limit on the number of  X  X nsertions X  between one event to the next by a fixed constant. For many useful software temporal patterns ( e.g. lock, unlock )thenumber of  X  X nsertions X  is irrelevant  X  events can be separated by an arbitrary number of events; iterative patterns capture such  X  X ehavior X  well.
In this section, we define formally iterative pattern, and provide the reasoning behind its semantics.
Let I be a set of distinct events. Let a sequence S be an ordered list of events. We denote S as e 1 ,e 2 ,...,e where each e i is an event from I . We refer to the i th event in the sequence S as S [ i ]. The sequence database under consideration is denoted by SeqDB .

A pattern P 1 ( e 1 ,e 2 ,...,e n )isconsidereda subsequence of another pattern P 2 ( f 1 ,f 2 ,...,f m ) if there exist integers 1  X  i 1 &lt;i 2 &lt;i 3 &lt;i 4 ... &lt; i n  X  m where e 1 = f e = f i 2 ,  X  X  X  , e n = f i n . Notation-wise, we write this relation as P 1 P 2 .Wealsosaythat P 2 is a super-sequence of P 1 . We use the notations first ( P )and last ( P )todenotethe first event and the last event of P respectively. Reference to the database is omitted if it refers to the input sequence database SeqDB .
 Definition 3.1 ( Concatenation and Truncation) . Concatenation of two patterns P 1 ( a 1 , ... , a n )and P ( b 1 , ... , b m ) will result in a longer pattern P 3 ( a 1 a ,b 1 ,...,b m ). Truncation operation is only applicable between a pattern and its suffix. Truncation of a pattern P 3 ( a 1 , ..., a n ,b 1 , ..., b m )andasuffix P 2 ( b 1 , ..., b m ) will result in the pattern P 1 ( a 1 , ..., a n ). Patterns concatenation is denoted by ++ , while pattern truncation is denoted by  X  X  X  .

Another important operation used in this work is the era-sure operation, as defined below.
 Definition 3.2 ( Erasure Operator) . Given a pattern P ( p 1 ,p 2 ,...,p n ) andastring S ( s 1 ,s 2 ,...,s m ) , the era-sure of Swrt.P , denoted by erasure ( S, P ) ,isdefinedasa new string S erased formed from S where all events occurring in P are removed from S .Formally, S erased is defined as ( se 1 ,se 2 ,...,se k ) such that (1)  X  i.se i  X  P and (2) there exists a set of integers { i 1 ...i k } with 1  X  i 1 &lt;i i ... &lt; i k  X  m and se 1 = s i 1 , se 2 = s i 2 ,  X  X  X  , se  X  j  X  X  i 1 ...i k } ,s j  X  P .
Our definition of iterative pattern is inspired by the com-mon languages for specifying software behavioral require-ment: Message Sequence Chart (MSC) (a standard of In-ternational Telecommunication Union (ITU) [16]) and its extension, Live Sequence Chart (LSC) [9].

MSCandLSCisavariantofthewellknownUMLse-quence diagram describing behavioral requirement of soft-ware. Not only does they specify system interaction through ordering of method invocation, but they also specifies caller and callee information. An example of such charts is a sim-plified telephone switching protocol ( c.f. , [16]): abstract-ing caller and callee information, the protocol can be rep-resented as a pattern: off hook , dial tone on , dial tone off , seizure int , ring tone , answer , connection on .
In verifying traces for conformance to an event sequence specified in MSC/LSC, the sub-trace manifesting the event sequence must satify the total-ordering property: Given an event ev i in an MSC/LSC, the occurrence of ev i in the sub-trace occurs before the occurrence of every ev j where j&gt;i and after ev k where k&lt;i [16]. Kugler et al. strengthened the above requirement to include a one-to-one correspon-dence between events in a pattern and events in any sub-trace satisfying it [20]. Basically, this requirement ensures that, if an event appears in the pattern, then it appears as many times in the pattern as it appears in the sub-trace.
For the telephone switching example, the following traces are not in conformance to the protocol:
The first trace above doesn X  X  satisfy the total-ordering requirement due to the out-of-order second occurrence of ring-tone event. The second doesn X  X  satisfy the one-to-one correspondence requirement due to multiple occurrences of answer event.

The full language of MSC/LSC is complicated and it is not our intention to mine MSC/LSC. Iterative pattern ab-stracts away the caller and callee information but retains the uniqueness and total ordering requirements.

The pattern instance definition capturing the total-order X  ing and one-to-one correspondence between events in the pattern and its instance can be expressed unambiguously in the form of Quantified Regular Expression (QRE) [24]. Quantified regular expression is very similar to standard regular expression with  X ; X  as concatenation operator,  X  X -] X  as exclusion operator ( i.e. [-P,S] means any event except P and S) and * as the standard kleene-star.

Definition 3.3 ( Pattern Instance -QRE ). Given a pattern P ( p 1 p 2 ...p n ) ,asubstring SB ( sb 1 sb 2 ...sb sequence S in SeqDB is an instance of P iff it is of the following QRE expression
Operationally we use an equivalent definition of pattern instance described using the erasure operation:
Definition 3.4 ( Iterative Pattern Instance ). Given a pattern P ( p 1 p 2 ...p n ) ,asubstring SB ( sb 1 sb 2 asequence S in SeqDB is an iterative pattern instance of P iff (1) first ( P )= first ( SB ) ,(2) last ( P )= last ( SB ) and (3) the following erasure constraint holds:
We use the term  X  X attern instance X  and  X  X terative pat-tern instance X  interchangeably in this paper. The operation erasure ( SB, erasure ( SB,P )) basically removes all events that occur in SB but not in P . An iterative pattern is thus identified by a set of iterative pattern instances, which can occur repeatedly in a sequence as well as across sequences. We also use the term  X  X attern X  and  X  X terative pattern X  in-terchangeably.

An instance is denoted compactly by a triple ( s idx ,i start i end )where s idx refers to the sequence index of a sequence S in the database while i start and i end refer to the starting point and ending point of a substring in S . By default, all indices start from 1. With the compact notation, an instance is both a string and a triple  X  the representations are used interchangeably. The set of all instances of a pattern P in a database DB is denoted as Inst ( P, DB ). Reference to the database is omitted if it refers to the input sequence database.

As an example, consider a pattern P ( A, B ) and a data X  base consisting of two sequences:
The set Inst ( P ) is the set of triples { (1,3,4),(1,5,6),(2,3,4), (2,7,8) } .

There is a one-to-one ordered correspondence between events in the pattern and events in its instance. This one-to-one correspondence can be captured by the concept of pattern instance landmarks defined below.
 Definition 3.5 ( Pattern Instance Landmarks ). Given a pattern P ( p 1 p 2 ...p n ) , an instance I ( s 1 of pattern P has the following landmarks: l 1 ,l 2 ,...l n 1  X  l 1 &lt;l 2 &lt; ... &lt; l n  X  m and s l 1 = p 1 ,s l 2 p . Due to erasure constraint, for each instance there is only one such set of landmarks. The landmarks of an instance I is denoted as Lnd ( I ) . The ith member of the set Lnd ( I ) is cal led the ith landmark.
 The support of a pattern wrt. to a sequence database SeqDB is the number of its instances in SeqDB . A pattern P is considered frequent when its support, sup ( P ), exceeds a certain threshold ( min s-sup ).
Iterative patterns possess the following  X  X priori X  property used in PrefixSpan [25]:
Theorem 1 ( Apriori Property -PrefixSpan) . If P is not frequent then its extensions ( P ++ evs or evs ++ P ) (where evs is a series of events) are also not frequent.
In general, iterative pattern does not possess the apriori property used in GSP [1]: if a pattern is frequent so does its sub-sequences. However, consid ering patterns having corre-sponding instances as described in Definition 3.6 below, the GSP apriori property holds. It is restated in Theorem 2. Definition 3.6 ( Corresponding Pattern Insts ). Consider a pattern P and its super-sequence Q. Instance I ( seq P , start P , end P ) of P corresponds to an instance I ( seq Q , start Q , end Q )ofQiff seq P = seq Q and start start Q and end P  X  end Q .

Theorem 2 ( Apriori Property -GSP-Like) . If a pattern Q is frequent and P is a sub-sequence of Q ,thenei-ther P is frequent or every instance of Q do not correspond to any instance of P (and vice versa).
 Definition 3.7 ( Closed Pattern) . A frequent pattern P is closed if there exists no super-sequence Q s.t.: 1. P and Q has the same support 2. Every instance of P corresponds to a unique instance
An instance of P ( seq P ,start P ,end P ) corresponds to an instance of Q ( seq Q ,start Q ,end Q ) iff seq P = seq Q  X  start Q and end P  X  end Q .

The second condition of the above definition is to prevent the following case from happening.

Consider the above sequence database. The only instance of the pattern A, B, A is (2,1,3), while the only instance of pattern A, B, B, A is (1,1,4). Both have the same support. However, since their instances match different segments of the sequences they should be reported separately. A, B, A is not  X  X bsorbed X  by A,B, B, A and is thus closed.
Notation-wise, we denote the full set of closed iterative patterns mined from SeqDB by Closed . We consider the following problem: Given a sequence database, find a closed set of iterative patterns .
Iterative pattern instances can be mined using depth first pattern growth and prune strategy ( c.f. , FreeSpan [14] and PrefixSpan [25]). However, rather than using the usual pro-jection that extracts sequent ial patterns, we perform a dif-ferent type of projection outlined below.

Definition 4.1 ( Projected-all) . A database SeqDB projected-all on a pattern P results in a set of pairings and is denoted as SeqDB all P . It is defined recursively as follows.
The definition of projected-all database captures pattern instances that possibly occur repeatedly within a sequence and across multiple sequences. The first element of the pairings corresponds to pattern instances in string format. The second element corresponds to the remaining part of the sequence providing the context from which the pattern can still be extended. Support of a pattern P is equal to the number of instances supporting P , denoted as | Inst ( P, SeqDB ) | . In turn, | Inst ( P, SeqDB ) | is equal to the size of the projected database | SeqDB all P | .

The instances of a length-1 pattern e 1 is simply the oc-currences of event e 1 throughout the sequences in SeqDB . The instances of a length-k e 1 ,...,e k pattern can be found from instances of length-(k-1) e 1 ,...,e k  X  1 pattern.
Instances of a length-2 pattern e 1 ,e 2 can be formed by extending instance pairings of e 1 ,( ox, ss )in SeqDB all on the condition:  X  i.ss [ i ]= e 2  X  X  X  j&lt;i,ss [ j ]  X  X  This condition corresponds to the second conjunctive clause of the inductive case of Definition 4.1. The first conjunctive clause in the definition is trivially satisfied since the erasure of a length-1 pattern instance is an empty string.
Similarly, instances of a length-3 pattern e 1 ,e 2 ,e 3 can be formed by extending instance pairings of e 1 ,e 2 ,( ox, ss )in SeqDB all e 1 ,e 2 , on the conditions:(1) e 3  X  erasure ( ox, e and (2)  X  i.ss [ i ]= e 3  X  X  X  j&lt;i,ss [ j ]  X  X  e 1 ,e 2 } second conditions correspond respectively to the two con-junctive clauses of the inductive case. The first condition is necessary since a substring instance ox of a length-2 pattern e 1 ,e 2 only obeys the erasure constraint for the original pattern  X  ox might contain e 3 .

Generalizing the above, instances of a length-k pattern can be formed from instances of a length-(k-1) pattern, by following the inductive case of Definition 4.1.

A simple depth-first algorithm to generate a full-set of it-erative patterns is as follows. F irst, generate a set of length-1 patterns where the support of each is greater than the min sup threshold. A projected-all database can then be created from the set of frequen t length-1 patterns according to the base case of Definition 4.1. Instances of a length-2 pattern can then be obtained by performing the inductive step of Definition 4.1 to the corresponding length-1 pattern projected database. Pattern not satisfying min sup will be pruned. Since patterns obey apriori property, we can stop extending pruned patterns. Length-(i+1) patterns can be obtained from length-(i) patterns accordingly.

For ease of explanation, let X  X  represent the inductive step of Definition 4.1 with the following Projected-first projection and the related Seq operator.

Definition 4.2 ( Projected-first &amp; Seq) . Aproject X  ed database SeqDB all P can be projected-first on an event e resulting in a set of pairings and denoted as ( SeqDB all It is defined as the following set. We denote the size of ( SeqDB all P ) fst e as Seq ( e, SeqDB
The above operation locates the first instance of an event e in the projected database  X  hence the name projected-first . It computes the sequences in projected database supporting event e  X  hence the name Seq operator. However, constraints corresponding to the inductive step of Definition 4.1 is also
We also define the following two operations of equivalence of projected databases and inclusion of an event in a pro-jected database.
 Definition 4.3 ( Operations on Projected DB) .
 Projected databases DB 1 and DB 2 are equivalent (denoted as DB 1 = DB 2 )iff | DB 1 | = | DB 2 | and  X  ( p 1 ,s 1 ) ( p 2 ,s 2 )  X  DB 2 . s 1 = s 2 . Also, an event e is in a projected database DB (denoted as e  X  DB )iff  X  ( p, s )  X  DB . e is an event in s.

Consider the following running example. Let us have the following sequence database SeqDB showninTable1.

Support of pattern A, B, C can be found by first con-structing the projected database of A . This is shown below in Table 2
The projected database SeqDB all A,B can then be con-structed from SeqDB all A using the inductive step of Defi-nition 4.1. Equivalently, we are applying the projected-first operation to the SeqDB all A with respect to event B .The result is shown below in Table 3.
 Finally, performing the inductive step of Definition 4.1 to SeqDB all A,B will result in SeqDB all A,B,C from which sup-port of A, B, C can be found. Equivalently, we apply the projected-first projection to SeqDB all A,B with respect to event C . The projected database is as shown below in Table 4.
 The support of A, B, C is then given by the size of SeqDB all A,B,C which is 4: one from S 1, two from S 3and another one from S 4in SeqDB .

Generating a full-set of iterative patterns results in many  X  X edundancies X . As all subsequences of a frequent iterative pattern P having corresponding instances are frequent, the number of frequent patterns is potentially exponential to the maximum length of the iterative patterns. Mining for closed patterns is an effective solution. Besides reducing the final number of patterns, closed pattern mining can usually reduce run-time by pruning the search space.

Definition 4.4 ( Prefix Extension Events) . For a pattern P , its set of prefix extension events is defined as the set of length-1 items e where sup ( e ++ P ) =sup ( P ) .
Definition 4.5 ( Infix Extension Events) . An event e is an infix extension of a pattern P iff  X  a super-sequence Q where: (1) SeqDB all P = SeqDB all Q , (2) first(P) = first(Q), (3)  X  event ev 1  X  erasure ( Q, P ) . ev 1 = e , (4) sup( P )= sup( Q ), and (5) Every instance of P corresponds to a unique instance of Q.

Definition 4.6 ( Suffix Extension Events) . For a pattern P , its set of suffix extension events is defined as the set of length-1 items e where sup ( P ++ e ) =sup ( P ) .
Prefix/ suffix extension events define events that can be added as prefix/ suffix (of length 1) to a pattern and re-sults in another pattern having the same support 1 . Infix extension events define events that can be added as infix to a pattern and results in another pattern having the same support and corresponding instances.
 As an example, consider the sample database in Table 1. For pattern D , its set of prefix extension events is { A, B, C } . For pattern A, C , its set of infix extension events is {
B } . For pattern A , its set of suffix extension events is { B } .

The above definitions are used in the next two theorems, which are then used for incremental and early detection of closed patterns and early pruning of search space.
Theorem 3 ( Extension Closure Checks) . If there exists no prefix, infix and suffix extension event w.r.t. a pat-tern P , P must be a closed pattern; otherwise P must be non-closed.

Proof. Part 1: If there exists a prefix, infix or suffix extension event, then P must be non-closed.

Consider a pattern P (where | P | = n). If there exists a suffix extension event e , there exists another pattern Q ( P ++ e ) having the same support and a corresponding set of instances as P .

Patterns P and Q have corresponding set of instances due to the following. The region from the 1st to the n th land-mark of an instance of Q is an instance of P .Hence,every instance of Q matches an instance of P . Also, if sup ( P )= sup ( P ++ e ), we have every instance of P matches an instance of Q as well. They have corresponding instances.

Similarly, if there exists a prefix extension event e ,there exists another pattern Q ( e ++ P ) having the same support and a corresponding set of instances as P .Hence,ifthere exists a prefix or suffix extension event for P ,wecancre-ate a super-sequence of P having the same support and a corresponding set of instances ( i.e. P is not closed).
Patterns e ++ P and P ++ e will have corresponding instances as P iff sup ( e ++ P )= sup ( P )and sup ( P ++ e )= sup ( P ) respectively  X  see proof of Theorem 3
Consider a pattern P . If there exists an infix extension event e , we can create another pattern Q super-sequence of P having the same support and corresponding instances. Hence, P is not closed.
 Part 2: If there exists no prefix, suffix and infix extension event P must be closed.

We can only grow a pattern by adding prefix, infix and suffix to it. Hence, if we cannot find a prefix, infix and suffix extension event of a pattern P resulting in its super-sequence having the same support, P must be closed.

It is enough to consider a single event extension since apriori property holds for patterns having corresponding in-stances.
 As an example, consider the sample database in Table 1. For pattern A, B, C , its sets of prefix, suffix and infix ex-tension events are empty. We can conclude that the pattern
A, B, C is closed. On the other hand, for pattern A ,its set of suffix extension events is not empty. Hence it is not closed since there exists a pattern A, B which is a super-sequence of A with the same support.
 Theorem 4 ( InfixScan Search Space Pruning) .
 Given a pattern P , if there exists an infix extension event e w.r.t. a pattern P and e  X  SeqDB all P , we can safely stop growing pattern P .

Proof. From Definition 4.5, if a pattern P has an in-fix extension event e , there exists a super-sequence pattern Q where: (1) SeqDB all P = SeqDB all Q ,(2)  X  event ev 1 erasure ( Q, P ). ev 1= e , (3) sup( P ) = sup( Q ), and (4) Ev-ery instance of P corresponds to a unique instance of Q.
Since SeqDB all P = SeqDB all Q , if we can extend an in-stance s x in Inst ( P )(andalsoin Inst ( Q )) with a substring s ext where erasure ( s x ++ s ext , erasure ( s x ++ s ext = P ++ s ext , erasure ( s x ++ s ext , erasure ( s x ++ s will also be equal to Q ++ s ext .

Since e is not in SeqDB all P , whenever P ++ s ext violate era-sure constraint so does Q ++ s ext .

Thus, given an arbitrary series of events s ext ,if P ++ s is frequent, there exists another pattern Q ++ s ext having the same support and corresponding instances. Hence, any pat-tern having P as prefix will not be closed. We can stop growing pattern P .
 As an example, consider the sample database in Table 1. For pattern A, C , its set of infix extension events is { There is no point extending pattern A, C further. Take for example pattern A, C, D of support 1. It is not closed since, there exists pattern A, B, C, D which is a super-sequence and has the same support and corresponding in-stances as the pattern A, C, D .

The next section outlines our algorithm utilizing the above closure checks and InfixScan search space pruning for effi-cient memory and time utilizat ion and for pruning of redun-dant search space.
Our CLIPER (CL osed I terative P attern minER ) algo-rithm is shown in Figure 1. The main procedure to com-pute the closed set of iterative patterns: MinePatterns ,is shown at the top of the figure. It will call a recursive pro-cedure MineRecurse shown at the bottom of the figure.
Procedure MinePatterns will first find patterns of length one whose instances are more than or equal to min sup threshold. For all frequent length-1 patterns, it will then call the procedure MineRecurse to recursively grow each patterns.

The recursive algorithm MineRecurse , shown at the bot-tom of Figure 1, will have as inputs the pattern prefix com-puted so far ( Pat ), the projected-all sequence database ( SeqDB all Pat ), the support threshold, the data structure con-taining current set of closed patterns ( Closed )andtheset of frequent events.

The algorithm will first find length-1 event e where Pat ++ e is frequent. Given the input pattern Pat and an event e ,the number of instances of Pat ++ e is equivalent to the num-ber of pairings ( px, sx )in SeqDB all Pat where we can extend px to an instance of Pat ++ e . The above is equivalent to Seq ( e, SeqDB all Pat ).

A set of prefix extension events of Pat is the set of such event e where sup ( e ++ Pat )= sup ( Pat ). A set of suffix extension events of Pat is the set of such event e where sup ( Pat ++ e )= sup ( Pat ).

Only such pattern Pat without any infix extension events will be an input to the recursive algorithm. Hence, it is only necessary to check for the existence of any suffix and prefix extension events. If there isn X  X  any, by Theorem 3, we can add the pattern Pat to the set Closed .

Next, for any frequent pattern Pat ++ e , following Theo-rem 4, we check for its infix extension events. If there is an infix extension event which does not appear in SeqDB all Pat we do not need to grow the pattern Pat ++ e anymore.
Growing patterns is performed recursively. At each step, given an extension event e ,the projected-all database of SeqDB all Pat ++ e need to be computed. It can be computed in-crementally by taking the projected-first database of SeqDB
Experiments had been performed on both synthetic and real datasets to evaluate the scalability of our mining algo-rithm and the effectiveness of our pruning strategy. Similar to work in closed sequential pattern mining [31, 29], low support thresholds are utilized to test for scalability. Datasets. We use three datasets in our experiments: a synthetic and two real datasets. Synthetic data generator provided by IBM was used with modification to ensure gen-eration of sequences of events. The generators accept a set of parameters. The paramete rs D, C, N and S correspond respectively to the number of sequences (in 1000s), the av-erage number of events per sequence, the number of differ-ent events (in 1000s) and the average number of events in the maximal sequences. We experimented with the dataset D5C20N10S20.

We also experimented on click stream dataset ( i.e. , Gazelle dataset) from KDD Cup 2000 [19] which was also used to evaluate CloSpan [31] and BIDE [29]. It contains 29369 se-quences with an average length of 3 and a maximum length of 651.

To evaluate our algorithm performance on mining from program traces, we generate traces from a simple Traffic alert and Collision Avoidance System (TCAS) from the Sie X  mens Test Suite [15], which has been used as one of the benchmarks for research in error localization ( e.g. ,[8]). The test suite comes with 1578 correct test cases. We run these test cases to obtain 1578 traces.

To test for scalability, instead of tracing method invoca-tions, we trace executions of basic blocks of TCAS X  X  con-trol flow graph. A basic block is a maximal sequence of statements such that the execution of one statement will al-ways results in the execution of the subsequent statements in the sequence. Each trace of basic block ids is treated as a sequence. The sequences are of average length of 36 and maximum length of 70. It contains 75 different events  X  the events are the basic block ids of the control flow graph of TCAS. We call this dataset the TCAS dataset.
 Environment and Pattern Miners. All experiments were performed on a Pentium 4 3.0GHz PC with 2GB main memory running Windows XP Professional. Algorithms were written using Visual C#.Net running under .Net Frame-work 2.0 with generics compiled with the release option us-ing Visual Studio.Net 2005.

For the experiments we tested our pattern miner on two configurations to test the effectiveness of our pruning strat-egy. The first mines a closed set of iterative patterns while another mines a full set of iterative patterns. Let X  X  refer the earlier as closed iterative pattern miner and the latter as full-set iterative pattern miner.
 Experiment Results and Analysis. The results of exper-iments performed on the D5C20N10S20, Gazelle and Siemens dataset using closed and full-set iterative pattern miners are shown in Figures 2, 3 &amp; 4 respectively. The Y-axis (in log-scale) corresponds to the runtime taken or the number of generated patterns. The X-axis corresponds to the mini-mum support thresholds. The thresholds are reported rela-tive to the number of sequences in the database. Note that, different from sequential patterns, due to repeated patterns within a sequence this number can exceed 1. Figure 2: Performance results of varying min sup for D5C20N10S20 dataset Figure 3: Performance results of varying min sup for Gazelle dataset Figure 4: Performance results of varying min sup for TCAS dataset
From the plotted results it is noted that the pruning strat-egy significantly reduces the runtime and the number of pat-terns mined especially on low support threshold and when the reported patterns are long. Admittedly, when the num-bers of closed and full-set of patterns differ by only a small factor, the overhead of mining closed patterns may result in longer runtime as compared to mining a full-set of patterns. However, when the length of the patterns is long, the num-ber of closed patterns is likely to be much less than that of a full-set of patterns.

For all datasets, even at very low support, closed pat-tern miner is able to complete within less than 17 minutes. TCAS dataset especially highlights performance benefit of our pruning strategy. Closed iterative pattern miner is able to run even at the lowest possible support threshold (at 1 instance) within less than 17 minutes. On the other hand, full-set iterative pattern miner runs with excessive runtime ( &gt; 6 hours) even at a relatively high support threshold of 867 instances.

The above shows that our miner can efficiently perform its task on various benchmark data. Comparison of perfor-mance results of closed and full-set pattern miner highlights the benefit and effectiveness of our pruning strategy.
A case study was performed on the transaction compo-nent of JBoss Application Server (JBoss AS) [17]. JBoss AS is the most commonly used J2EE application server. It con-tains over 100,000 lines of code and comments. The transac-tion component alone contains over 5,000 lines of code and comments. The purpose of this case study is to show the usefulness of the mined patterns by discovering iterative pat-terns describing behavior of the transaction sub-component of JBoss AS.

Traces are obtained by running JBoss-AOP [18] over JU-nit and Ant on a regression test of the JBoss AS transaction manager. We trace invocations of methods within the trans-action component of JBoss AS ( i.e. , org.jboss.tm package). This produces 28 traces of a total of 2551 events and an av-erage of 91 events. The longest trace is of 125 events. There are 64 unique events. Using min sup of 65%, the closed it-erative pattern mining algorithm runs in less than a minute (29s). Full-set pattern mining doesn X  X  terminate even after running for more than 8 hours and produces more than 5 GB of patterns .

There are a total of 44 patterns resulting from the follow-ing post-processing step after iterative pattern mining: 1. Density. Only report patterns whose number of unique 2. Subsumption. Only report pattern P if none of its super-3. Ranking. Order them according to length and support
We found at least 5 interesting software patterns of be-havior resulting from mining the traces. These correspond to the patterns of longest length and highest support. Their abstracted representations are as follows: 1. Connection Set Up Evs, TxManager Set Up Evs, Trans-2. Connection Set Up Evs, TxManager Set Up Evs, Trans-3. Resource Enlistment Evs, Transaction Execution Evs, 4. Resource Enlistment Evs, Transaction Execution Evs, 5. Lock-Unlock Evs
The first 4 patterns correspond to the few of the longest patterns, the last pattern on lock and unlock events cor-responds to the pattern with the highest support of 313. The actual mined pattern for the first pattern shown above, which is the longest pattern mined (of length 32), is shown in Figure 5.

The first two patterns specify that a series of set up events is always followed by a series of termination events. The first pattern specifies a common behavior where: a connection is first set up to the server, the transaction manager is set up, the transaction is set up, the transaction is committed and the transaction is finally disposed. The second pattern specifies a similar behavior except that the transaction is being roll-backed.

The third and fourth patterns specify the pattern ob-served when the actual work is being performed. A resource need to be enlisted to the transaction and the transaction execution then take place. At the end of the execution, the transaction can either be committed or roll-backed. Note that there can be one or more resource enlistments and transaction executions before a commit. Hence the pattern is not included in the body of the first 2 patterns.
The fifth pattern corresponds to a more fine grained iter-ative pattern occurring most often, namely lock and unlock.
In this paper, we propose iterative patterns  X  iterative patterns are commonly occurring series of events exhibited repeatedly within a sequence and across multiple sequences. We extend sequential pattern mining to consider repeated occurrences of pattern instances within sequences. We ex-tend episode pattern mining by removing the constraint on window size and consider a database of sequences rather than a single sequence. To mine iterative pattern efficiently, we present CL osed I terative P attern MinER (CLIPER).
The motivation of our work comes from the emerging field of dynamic analysis where a set of program traces are ana-lyzed to mine interesting software properties. Due to looping similar patterns occur within a sequence and across multi-ple sequences. Mining interesting patterns should take into account both multiple sequences, and multiple occurrences of patterns within a sequence. Also, since important pat-terns like lock acquire followed-by lock-release and file open followed-by file close ( c.f. , [32, 7]) are often separated by a considerable number of events, we need to remove the win-dow size constraint of frequent episode mining.

To reduce the number of reported patterns and improve efficiency, we mine for the set of closed iterative patterns. This reduces the run-time needed for mining patterns and aids user in analyzing important patterns by sifting out pat-terns  X  X bsorbed X  by another.

Our performance study shows the efficiency of our method in both real-world and synthetic datasets. The effectiveness of our pruning strategy to mine closed patterns is evident by comparing the runtime and the number of patterns gen-erated before and after the pruning strategy is employed. The set of interesting patterns mined from JBoss Applica-tion Server transaction component confirms the usefulness of our method in discovering software specifications in iter-ative pattern form.

Besides mining software behavioral pattern, we believe the proposed mining technique can potentially be applied to other knowledge discovery domains.
 Acknowledgement. We would like to thank Jiawei Han and Shahar Maoz for their valuable comments. We wish to thank Blue Martini Software for contributing the KDD Cup 2000 data. This research is partially supported by an NUS research grant R-252-000-250-112, NSF ITR/CCR-0325603, IIS-05-13678, NSF BDI-05-15813, and IIS-02-42840. [1] R. Agrawal and R. Srikant. Mining sequential [2] G.Ammons,R.Bodik,andJ.R.Larus.Mining [3] R.V. Binder. Testing Object-Oriented Systems Models, [4] B. Boehm. Software Engineering Economics.
 [5] G Canfora and A Cimitile. Software Maintenance , [6] R. Capilla and J.C. Duenas. Light-weight [7] W-N. Chin, S-C. Khoo, S. Qin, C. Popeea, and H.H. [8] C.Liu, X. Yan, L. Fei, J. Han, and S.P. Midkiff. [9] W. Damm and D. Harel. LSCs: Breathing life into [10] S. Deelstra, M. Sinnema, and J. Bosch. Experiences in [11] M. El-Ramly, E. Stroulia, and P. Sorenson. From [12] E. Erlikh. Leveraging legacy system dollars for [13] G.C. Garriga. Discovering unbounded episodes in [14] J. Han, J. Pei, B. Mortazavi-Asl, Q. Chen, U. Dayal, [15] M. Hutchins, H. Foster, T. Goradia, and T. Ostrand. [16] ITU-T. ITU-T Recommendation Z.120: Message [17] JBoss. http://www.jboss.org. [18] JBoss AOP. http://labs.jboss.com/jbossaop/. [19] R. Kohavi, C. Brodley, B. Frasca, L. Mason, and [20] H. Kugler, D. Harel, A. Pnueli, Y. Lu, and [21] M.M. Lehman and L.A. Belady. Program Evolution -[22] D. Lo and S-C. Khoo. SMArTIC: Toward building an [23] H. Mannila, H. Toivonen, and A.I. Verkamo.
 [24] K. Olender and L. Osterweil. Cecil: A sequencing [25] J. Pei, J. Han, B. Mortazavi-Asl, H. Pinto, Q. Chen, [26] Java Trans. API Spec. java.sun.com/products/jta/. [27] T. Standish. An essay on software reuse. IEEE TSE , [28] C. Steel, R. Nagappan, and R. Lai. Core Security [29] J. Wang and J. Han. BIDE: Efficient mining of [30] W.Weimer and G.Necula. Mining temporal [31] X. Yan, J. Han, and R. Afhar. CloSpan: Mining closed [32] J.Yang,D.Evans,D.Bhardwaj,T.Bhat,andM.Das.
 [33] M. Zhang, B. Kao, D.W. Cheung, and K.Y. Yip.
