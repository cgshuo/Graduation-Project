 Keyword query interfaces ( KQIs ) for databases provide easy access to data, but often suffer from low ranking quality, i.e. low precision and/or recall, as shown in recent benchmarks. It would be useful to be able to identify queries that are likely to have low ranking quality to improve the user sat-isfaction. For instance, the system may suggest to the user alternative queries for such hard queries. In this paper, we analyze the characteristics of hard queries and propose a novel framework to measure the degree of difficulty for a keyword query over a database, considering both the struc-ture and the content of the database and the query results. We evaluate our query difficulty prediction model against two relevance judgment benchmarks for keyword search on databases, INEX and SemSearch. Our study shows that our model predicts the hard queries with high accuracy. Further, our prediction algorithms incur minimal time overhead. H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval X  Search process Measurement, Performance Query Performance, Keyword Query, (Semi-)Structured Data, Database
Keyword query interfaces ( KQIs ) for databases have at-tracted much attention in the last decade due to their flex-ibility and ease of use in searching and exploring databases [2, 10, 5, 19, 16, 12]. Since any entity in a data set that contains the query keywords is a potential answer, keyword queries typically have many possible answers. KQIs must identify the information needs behind keyword queries and rank the answers so that the desired answers appear at the top of the list [2, 10]. Unless otherwise noted, we refer to keyword query as query in the remainder of this paper.
Databases contain entities, and entities contain attributes that take attribute values. Some of the difficulties of answer-ing a query are as follows: First, unlike queries in languages like SQL, users do not normally specify the desired schema element(s) for each query term. For instance, query Q 1 : Godfather on the IMDB database ( http://www.imdb.com ) does not specify if the user is interested in movies whose title is Godfather or movies distributed by the Godfather company. Thus, a KQI must find the desired attributes as-sociated with each term in the query. Second, the schema of the output is not specified, i.e., users do not give enough information to single out exactly their desired entities [13]. For example, Q 1 may return movies or actors or produc-ers. We present a more complete analysis of the sources of difficulty and ambiguity in Section 4.2.

Recently, there have been collaborative efforts to provide standard benchmarks and evaluation platforms for keyword search methods over databases. One effort is the data-centric track of INEX Workshop [22] where KQIs are evalu-ated over the well-known IMDB data set that contains struc-tured information about movies and people in show business. Queries were provided by participants of the workshop. An-other effort is the series of Semantic Search Challenges (Sem-Search) at Semantic Search Workshop [21], where the data set is the Billion Triple Challenge data set at http://vmlion25.deri.de . It is extracted from different struc-tured data sources over the Web such as Wikipedia. The queries are taken from Yahoo! keyword query log. Users have provided relevance judgments for both benchmarks.
The Mean Average Precision (MAP) of the best perform-ing method(s) in the last data-centric track in INEX Work-shop and Semantic Search Challenge for queries are about 0.36 and 0.2, respectively. The lower MAP values of meth-ods in Semantic Search Challenge are mainly due to the larger size and more heterogeneity of its data set.
These results indicate that even with structured data, finding the desired answers to keyword queries is still a hard task. More interestingly, looking closer to the ranking qual-ity of the best performing methods on both workshops, we notice that they all have been performing very poorly on a su bset of queries. For instance, consider the query ancient Rome era over the IMDB data set. Users would like to see information about movies that talk about ancient Rome. For this query, the state-of-the-art XML search methods which we implemented return rankings of considerably lower quality than their average ranking quality over all queries. Hence, some queries are more difficult than others. More-over, no matter which ranking method is used, we cannot deliver a reasonable ranking for these queries. Table 1 lists a sample of such hard queries from the two benchmarks. Such a trend has been also observed for keyword queries over text document collections [20]. These queries are usu-ally either under-specified, such as query carolina in Table 1, or over-specified, such as query Movies Klaus Kinski actor good rating in Table 1.
 Table 1: List of difficult queries from both benchmarks.
It is important for a KQI to recognize such queries and warn the user or employ alternative techniques like query reformulation or query suggestions [15]. It may also use techniques such as diversification of its returned ranked list [4]. On the other hand, if a KQI would employ these tech-niques for queries with high-quality results, it may hurt their quality and/or waste computational resources (such as CPU cycle) and the time of users. Hence, it is important that a KQI distinguishes difficult from easy queries and act upon them accordingly (the latter is out of the scope of this work). As a specific example of how knowledge of the query diffi-culty may be leveraged, consider Figure 1 which shows the ranking results for query ancient Rome era by one of our implemented ranking algorithms (details in Section 7). Our algorithms determine that this is a hard (ambiguous) query, which guides the system to generate query reformulation suggestions. Note that the generation of query reformula-tion technique is beyond our scope in this paper. F igure 1: Results for hard query ancient Rome era by our system with query suggestions returned.

To the best of our knowledge, there has not been any work on predicting or analyzing the difficulties of queries over databases. Researchers have proposed some methods to detect difficult queries over plain text document collections [20, 24]. However, these techniques are not applicable to our problem since they ignore the structure of the database. In particular, as mentioned earlier, a KQI must assign each query term to a schema element(s) in the database. It must also distinguish the desired result type(s). We experimen-tally show that direct adaptations of these techniques are ineffective for structured data.

In this paper, we analyze the characteristics of difficult queries over databases and propose a novel method to detect such queries. We take advantage of the structure of the data to gain insight about the degree of the difficulty of a query given the database. We have implemented some of the most popular and representative algorithms for keyword search on databases and used them to evaluate our techniques on both the INEX and SemSearch benchmarks. The results show that our method predicts the degree of the difficulty of a query efficiently and effectively.
 We make the following contributions:
In the remainder of the paper, Section 2 discusses re-lated work and Section 3 presents basic definitions. Sec-tion 4 explains the ranking robustness principle and ana-lyzes the properties of difficult queries over databases. Sec-tion 5 presents concrete methods to compute the SR score in (semi-) structured data. Section 6 describes the algorithms to compute the SR score. Section 7 contains the experimen-tal results, and Section 8 concludes the paper.
In this section we present an overview of the works on predicting the query difficulty in free text collections and explain why they generally cannot be applied to our setting. Researchers have proposed methods to predict hard queries over unstructured text documents [20, 24, 9, 3]. Some meth-ods use the statistical properties of the terms in the query to predict its difficulty. Examples of such statistical character-istics are average inverse document frequency of the terms in the query and number of documents that contain at least one query term [9]. The common idea behind these meth-ods is that the more discriminative the query terms are, the easier the query will be. Empirical evaluations indicate that these methods have limited prediction accuracies [20].
A popular approach called clarity score argues that an easy query is sufficiently distinctive to separate the user X  X  de-sired documents from other documents in the collection [20, 3]. Hence, its top ranked answers belong to very few topics that are very likely to be the desired topics. On the other hand, the top ranked documents of a difficult query describe various topics, which many of them are irrelevant to the user X  X  information need. Consider a set of documents that contain the information about different types of news. The top ranked documents of query European financial crises are mainly about financial news, but the top ranked an-swers for query European crises may describe several topics such as political, financial, and social news. The latter is more difficult than the former. Researchers have shown that this method provides a better estimation of the difficulty of a query for text documents than clues such as number of terms in the query or inverse document frequencies of its terms [20]. In order to measure the number of topics in the top ranked document of a given query, some systems com-pare the probability distribution of terms in the returned documents with the probability distribution of terms in the whole collection. If these probability distributions are rela-tively similar, the top ranked documents contain the infor-mation about almost as many topics as the whole collection, thus, the query is difficult [20].

Each topic in a database contains the entities that are about a similar subject. It is generally hard to define a for-mula that partitions entities into topics as it requires finding an effective similarity function between entities. Such sim-ilarity function depends mainly on the domain knowledge and understanding users X  preferences [8]. For instance, dif-ferent attributes may have different impacts on the degree of the similarity between entities. Assume movies A and B share some terms in their genre attributes, which explain the subjects of the movies, in IMDB database. Also, let movies A and C share the same number of terms in their distributor attributes, which describe the distribution com-pany of the movies. Given other attributes of A , B , and C do not contain any common term, movies A and B are more likely to be about the same subject and satisfy the same information need than movies A and C . Our empir-ical results in Section 7 confirms this argument and shows that the straightforward extension of clarity score method predicts difficulties of the queries over databases poorly.
Some systems use a pre-computed set of topics and assign each document to at least one topic in the set in order to compute the clarity score [3]. They compare the probability distribution of topics in the top ranked documents with the probability distribution of topics of the whole collection to predict the degree of the difficulty of the query. One requires domain knowledge about the data sets and its users to cre-ate a set of useful topics for the tuples in the database. We like to find an effective and domain independent approach to predict the difficulties of queries. Some methods use ma-chine learning techniques to learn the properties of difficult queries and predict them [23]. They have similar limita-tions as the other approaches when applied to structured data. Moreover, their applications depend on the amount and quality of the training data. Sufficient and high quality training data is not normally available for many databases.
We model a database as a set of entity sets. Each entity set S is a collection of entities E . For instance, movies and people are two entity sets in IMDB. Figure 2 depicts a frag-ment of a data set where each subtree whose root X  X  label is movie represents an entity. Each entity E has a set of at-tribute values A i , 1 i j E j . Each attribute value is a bag of terms. Following current unstructured and (semi-) struc-ture retrieval approaches, we ignore stop words that appear in attribute values, although this is not necessary for our methods. Every attribute value A belongs to an attribute T written as A 2 T . For instance, Godfather and Mafia are two attribute values in the movie entity shown in the subtree rooted at node 1 in Figure 2. Node 2 depicts the attribute of Godfather , which is title .

The above is an abstract data model. We ignore the physical representation of data in this paper. That is, an entity could be stored in an XML file or a set of normal-ized relational tables. The above model has been widely used in works on entity search [17, 6] and data-centric XML retrieval [22], and has the advantage that it can be easily mapped to both XML and relational data. Further, if a KQI method relies on the intricacies of the database design (e.g. deep syntactic nesting), it will not be robust and will have considerably different degrees of effectiveness over different databases [18]. Hence, since our goal is to develop princi-pled formal models that cover reasonably well all databases and data formats, we do not consider the intricacies of the database design or data format in our models.

A keyword query is a set Q = f q 1 q | Q | g of terms, where j
Q j is the number of terms in Q . An entity E is an answer to Q iff at least one of its attribute values A contains a term q in Q , written q i 2 A 1 . Given database DB and query Q , retrieval function g ( E, Q, DB ) returns a real number that re-flects the relevance of entity E 2 DB to Q . Given database DB and query Q , a keyword search system returns a ranked list of entities in DB called L ( Q, g, DB ) where entities E are placed in decreasing order of the value of g ( E, Q, DB ).
In this section we present the Ranking Robustness Prin-ciple , which argues that there is a (negative) correlation between the difficulty of a query and its ranking robust-
S ome works on keyword search in databases [10] use con-junctive semantics, where all query keywords must appear in a result. n ess in the presence of noise in the data. Section 4.1 dis-cusses how this principle has been applied to unstructured text data. Section 4.2 presents the factors that make a key-word query on structured data difficult, which explain why we cannot apply the techniques developed for unstructured data. The latter observation is also supported by our experi-ments in Section 7.2 on the Unstructured Robustness Method [24], which is a direct adaptation of the Ranking Robustness Principle for unstructured data.
Mittendorf has shown that if a text retrieval method ef-fectively ranks the answers to a query in a collection of text documents, it will also perform well for that query over the version of the collection that contains some errors such as re-peated terms [14]. In other words, the degree of the difficulty of a query is positively correlated with the robustness of its ranking over the original and the corrupted versions of the collection. We call this observation the Ranking Robustness Principle . Zhou and Croft [24] have applied this principle to predict the degree of the difficulty of a query over free text documents. They compute the similarity between the rankings of the query over the original and the artificially corrupted versions of a collection to predict the difficulty of the query over the collection. They deem a query to be more difficult if its rankings over the original and the corrupted versions of the data are less similar. The have empirically shown their claim to be valid. They have also shown that this approach is generally more effective than using methods based on the similarities of probability distributions, that we reviewed in Section 2. This result is especially important for ranking over databases. As we explained in Section 2, it is generally hard to define an effective and domain independent categorization function for entities in a database. Hence, we can use Ranking Robustness Principle as a domain indepen-dent proxy metric to measure the degree of the difficulties of queries.
As discussed in Section 2, it is well established that the more diverse the candidate answers of a query are, the more difficult the query is over a collection of the text documents. We extend this idea for queries over databases and pro-pose three sources of difficulty for answering a query over a database as follows: 1. The more entities match the terms in a query, the more 2. Each attribute describes a different aspect of an entity. 3. Each entity set contains the information about a differ-
The aforementioned observations show that we may use the statistical properties of the query terms in the database to compute the diversity of its candidate answers and predict its difficulty. One idea is to count the number of possible attributes, entities, and entity sets that contain the query terms and use them to predict the difficulty of the query. The larger this value is the more difficult the query will be. We have shown empirically in Section 7.2 that such ap-proach predicts the difficulty of queries quite poorly. This is because the distribution of query terms over attributes and entity sets may also impact the difficulty of the query. For instance, assume database DB 1 contains two entity sets book and movie and database DB 2 contains entity sets book and article . Let term database appear in both entity sets in DB 1 and DB 2 . Assume that there are far fewer movies that contain term database compared to books and articles. A KQI can leverage this property and rank books higher than movies when answering query Q 8 : database over DB 1 Ho wever, it will be much harder to decide the desired entity set in DB 2 for Q 8 . Hence, a difficulty metric must take in to account the skewness of the distributions of the query term in the database as well. In Section 5 we discuss how these ideas are used to create a concrete noise generation frame-work that consider attribute values, attributes and entity sets.
In Section 4 we presented the Ranking Robustness Prin-ciple and discussed the specific challenges in applying this principle to structured data. In this section we present con-cretely how this principle is quantified in structured data. Section 5.1 discusses the role of the structure and content of the database in the corruption process, and presents the robustness computation formula given corrupted database instances. Section 5.2 provides the details of how we gener-ate corrupted instances of the database. Section 5.3 suggests methods to compute the parameters of our model. In Sec-tion 5.4 we show real examples of how our method corrupts the database and predicts the difficulty of queries. Corruption of structured data. The first challenge in using the Ranking Robustness Principle for databases is to define data corruption for structured data. For that, we model a database DB using a generative probabilistic model based on its building blocks, which are terms, attribute val-ues, attributes, and entity sets. A corrupted version of DB can be seen as a random sample of such a probabilistic model. Given a query Q and a retrieval function g , we rank the candidate answers in DB and its corrupted ver-sions DB  X  , DB  X  X  , to get ranked lists L and L  X  , L  X  X  respectively. The less similar L is to L  X  , L  X  X  , , the more difficult Q will be.
 According to the definitions in Section 3, we model database DB as a triplet ( S , T , A ), where S , T , and A denote the sets of entity sets, attributes, and attribute values in DB , respectively. jAj , jTj , jSj denote the number of attribute values, attributes, and entity sets in the database, respec-tively. Let V be the number of distinct terms in database DB . Each attribute value A a 2A , 1 a jAj , can be modeled using a V-dimensional multivariate distribution X a = ( X a, 1 , , X a,V ), where X a,j 2 X a is a random vari-able that represents the frequency of term w j in A a . The probability mass function of X a is: where  X  X  a = x a, 1 , , x a,V and x a,j 2  X  X  a are non-negative integers.

Random variable X A = ( X 1 , , X |A| ) models attribute value set A , where X a 2 X A is a vector of size V that denotes the frequencies of terms in A a . Hence, X A is a jAj V matrix. The probability mass function for X A is: f
X A (  X  X  ) = f X A (  X  X  1 , ,  X  X  |A| ) = P r ( X 1 =  X  X  1 where  X  X  a 2  X  X  are vectors of size V that contain non-negative integers. The domain of  X  X  is all jAj V matrices that contain non-negative integers, i.e. M ( jAj V ).

We can similarly define X T and X S that model the set of attributes T and the set of entity sets S , respectively. The random variable X DB = ( X A , X T , X S ) models corrupted versions of database DB . In this paper, we focus only on the noise introduced in the content (values) of the database. In other words, we do not consider other types of noise such as changing the attribute or entity set of an attribute value in the database. Since the membership of attribute values to their attributes and entity sets remains the same across the original and the corrupted versions of the database, we can derive X T and X S from X A . Thus, a corrupted version of the database will be a sample from X A ; note that the attributes and entity sets play a key role in the computation of X A as we discuss in Section 5.2. Therefore, we use only X
A to generate the noisy versions of DB , i.e. we assume that X DB = X A . In Section 5.2 we present in detail how X DB is computed.
 Structured Robustness calculation. We compute the similarity of the answer lists using Spearman rank correla-tion [7]. It ranges between 1 and -1, where 1, -1, and 0 indicate perfect positive correlation, perfect negative corre-lation, and almost no correlation, respectively. Equation 3 computes the Structured Robustness score ( SR score), for query Q over database DB given retrieval function g : where  X  X  2 M ( jAj V ) and Sim denotes the Spearman rank correlation between the ranked answer lists.
In order to compute Equation 3, we need to define the noise generation model f X DB ( M ) for database DB . We will show that each attribute value is corrupted by a combination of three corruption levels: on the value itself, its attribute and its entity set. Now the details: Since the ranking meth-ods for queries over structured data do not generally consider the terms in V that do not belong to query Q [10, 12], we consider their frequencies to be the same across the origi-nal and noisy versions of DB . Given query Q , let  X  X  be a vector that contains term frequencies for terms w 2 Q \ V . Similarly to [24], we simplify our model by assuming the at-tribute values in DB and the terms in Q \ V are independent. Hence, we have: and where x j 2  X  X  i depicts the number of times w j appears in a noisy version of attribute value A i and f X i,j ( x j ) computes the probability of term w j to appear in A i x j times.
The corruption model must reflect the challenges discussed in Section 4.2 about search on structured data, where we showed that it is important to capture the statistical proper-ties of the query keywords in the attribute values, attributes and entity sets. We must introduce content noise (recall that we do not corrupt the attributes or entity sets but only the values of attribute values) to the attributes and en tity sets, which will propagate down to the attribute val-ues. For instance, if an attribute value of attribute title con-tains keyword Godfather , then Godfather may appear in any attribute value of attribute title in a corrupted database in-stance. Similarly, if Godfather appears in an attribute value of entity set movie , then Godfather may appear in any at-tribute value of entity set movie in a corrupted instance.
Since the noise introduced in attribute values will propa-gate up to their attributes and entity sets, one may question the need to introduce additional noise in attribute and entity set levels. The following example illustrates the necessity to generate such noises. Let T 1 be an attribute whose attribute values are A 1 and A 2 , where A 1 contains term w 1 and A does not contain w 1 . A possible noisy version of T 1 will be a version where A 1 and A 2 both contain w 1 . However, the aforementioned noise generation model will not produce such a version. Similarly, a noisy version of entity set S must introduce or remove terms from its attributes and attribute values. According to our discussion in Section 4, we must use a model that generates all possible types of noise in the data.

Hence, we model the noise in a DB as a mixture of the noises generated in attribute value, attribute, and entity set levels. Mixture models are typically used to model how the combination of multiple probability distributions generates the data. Let Y t,j be the random variable that represents the frequency of term w j in attribute T t . Probability mass function f Y t,j ( y t,j ) computes the probability of w j y t,j times in T t . Similarly, Z s,j is the random variable that denotes the frequency of term w j in entity set S s and prob-ability mass function f Z s,j ( z s,j ) computes the probability of w j to appear z s,j times in S s . Hence, the noise generation models attribute value A i whose attribute is T t and entity set is S s :  X  f where 0  X  A ,  X  T ,  X  S 1 and  X  A +  X  T +  X  S = 1. f X a,j and f Y s,j model the noise in attribute value, attribute, and entity set levels, respectively. Parameters  X  A ,  X  T and  X  have the same values for all terms w 2 Q \ V and are set empirically.

Since each attribute value A a is a small document, we model f X i,j as a Poisson distribution: Similarly, we model each attribute T t , 1 t jTj , as a bag of words and use Poisson distribution to model the noise generation in the attribute level: Using similar assumptions, we model the changes in the fre-quencies of the terms in entity set S s , 1 s jSj , using Poisson distribution:
In order to use the model in Equation 6, we have to esti-mate  X  A,w ,  X  T,w , and  X  S,w for every w 2 Q \ V , attribute value A , attribute T and entity set S in DB . We treat the original database as an observed value of the space of all possible noisy versions of the database. Thus, using the maximum likelihood estimation method, we set the value of  X 
A,w to the frequency of w in attribute value A . Assuming that w are distributed uniformly over the attribute values of attribute T , we can set the value of  X  T,w to the average frequency of w in T . Similarly, we set the value of  X  S,w the average frequency of w in S . Using these estimations, we can generate noisy versions of a database according to Equation 6.
Equation 6 overestimates the frequency of the terms of the original database in the noisy versions of the database. For example, assume a bibliographic database of computer sci-ence publications that contains attribute T 2 = abstract which constitutes the abstract of a paper. Apparently, many ab-stracts contain term w 2 = algorithm , therefore, this term will appear very frequently with high probability in f T 2 model. On the other hand, a term such as w 3 = Dirichlet is very likely to have very low frequency in f T 2 ,w 3 model. Let attribute value A 2 be of attribute abstract in the bib-liographic DB that contains both w 2 and w 3 . Most likely, term algorithm will appear more frequently than Dirichlet in A 2 . Hence, the mean for f A 2 ,w 2 will be also larger than the mean of f A 2 ,w 3 . Thus, a mixture model of f T 2 ,w f 2 ,w 2 will have much larger mean than a mixture model of f T 2 ,w 3 and f A 2 ,w 3 . The same phenomenon occurs if a term is relatively frequent in an entity set. Hence, a mix-ture model such as Equation 6 overestimates the frequency of the terms that are relatively frequent in an attribute or entity set. Researchers have faced a similar issue in lan-guage model smoothing for speech recognition [11]. We use a similar approach to resolve this issue. If term w appear in attribute value A , we use only the first term in Equation 6 to model the frequency of w in the noisy version of database. Otherwise, we use the second or third terms if w belongs to T and S , respectively. Hence, the noise generation model is:  X  f where we remove the condition  X  A +  X  T +  X  S = 1.
We illustrate the corruption process and the relationship between the robustness of the ranking of a query and its difficulty using INEX queries Q 9: mulan hua animation and Q 11: ancient rome era , over the IMDB dataset. We set  X  A = 1,  X  T = 0 . 9,  X  S = 0 . 8 in Equation 10. We use the XML ranking method proposed in [12], called PRSM , which we explain in more detail in Section 6. Given query Q , PRSM computes the relevance score of entity E based on the weighted linear combination of the relevance scores the attribute values of E .

Example of calculation of  X  t,j for term t = ancient and attribute T j = plot in Equation 8: In the IMDB dataset, ancient occurs in attribute plot 2132 times in total, and total number of attribute values under attribute plot is 184,731,  X  t,j = 2132 / 184731 which is 0.0115. Then, since  X  T = 0 . 9, the probability that ancient occurs k times in a corrupted
Q 11: Figure 3a depicts two of the top results (ranked as 1 st a nd 12 nd respectively) for query Q 11 over IMDB. We omit most attributes (shown as elements in XML lingo in Figure 3a) that do not contain any query keywords due to space consideration. Figure 3b illustrates a corrupted ver-sion of the entities shown in Figure 3a. The new keyword instances are underlined. Note that the ordering changed according to the PRSM ranking. The reason is that PRSM believes that title is an important attribute for rome (for at-tribute weighing in PRSM see Section 7.1) and hence having a query keyword ( rome ) there is important. However, after corruption, query word rome also appears in the title of the other entity, which now ranks higher, because it contains the query words in more attributes.
Word rome was added to the title attribute of the origi-nally second result through the second level (attribute-based, second branch in Equation 10) of corruption, because rome appears in the title attribute of other entities in the database. If no title attribute contained rome , then it could have been added through the third level corruption (entity set-based, third branch in Equation 10) since it appears in attribute values of other movie entities.

The second and third levels corruptions typically have much smaller probability of adding a word than the first level, because they have much smaller  X  ; specifically  X  T the average frequency of the term in attribute T . However, in hard queries like Q 11, the query terms are frequent in the database, and also appear in various entities and attributes, and hence  X  T and  X  S are larger.

In the first keyword attribute of the top result in Figure 3b, rome is added by the first level of corruption, whereas in the trivia attribute rome is removed by the first level of corruption.

To summarize, Q 11 is difficult because its keywords are spread over a large number of attribute values, attributes and entities in the original database, and also most of the top results have a similar number of occurrences of the key-words. Thus, when the corruption process adds even a small number of query keywords to the attribute values of the entities in the original database, it drastically changes the ranking positions of these entities.

Q9 : Q 9 ( mulan hua animation ) is an easy query because most its keywords are quite infrequent in the database. Only term animation is relatively frequent in the IMDB dataset, but almost all its occurrences are in attribute genre . Fig-ures 4a and 4b present two ordered top answers for Q 9 over the original and corrupted versions of IMDB, respectively. The two results are originally ranked as 4 th and 10 th . The attribute values of these two entities contain many query keywords in the original database. Hence, adding and/or re-moving some query keyword instances in these results, does not considerably change their relevance score and they pre-serve their ordering after corruption.

Since keywords mulan and hua appear in a small number of attribute values and attributes, the value of  X  for these terms in the second and the third level of corruption is very small. Similarly, since keyword animation only appears in the genre attribute, the value of  X  for all other attributes (second level corruption) is zero. The value of  X  for an-imation in the third level is reasonable, 0.0007 for movie entity set, but the noise generated in this level alone is not considerable.
A key requirement for this work to be useful in practice is that the computation of the SR score incurs a minimal time overhead compared to the query execution time. In this sec-tion we present efficient SR score computation techniques.
Top-K results: Generally, the basic information units in structured data sets, attribute values, are much shorter than text documents. Thus, a structured data set contains a larger number of information units than an unstructured data set of the same size. For instance, each XML document in the INEX data centric collection constitutes hundreds of elements with textual contents. Hence, computing Equa-tion 3 for a large DB is so inefficient as to be impractical. Hence, similar to [24], we corrupt only the top-K entity re-sults of the original data set. We re-rank these results and shift them up to be the top-K answers for the corrupted versions of DB. In addition to the time savings, our empir-ical results in Section 7.2 show that relatively small values for K predict the difficulty of queries better than large val-ues. For instance, we found that K = 20 delivers the best performance prediction quality in our datasets. We discuss the impact of different values of K in the query difficulty prediction quality more in Section 7.2.

Number of corruption iterations ( N ): Computing the expectation in Equation 3 for all possible values of  X  X  is very inefficient. Hence, we estimate the expectation using N &gt; 0 samples over M ( jAj V ). That is, we use N cor-rupted copies of the data. Obviously, smaller N is preferred for the sake of efficiency. However, if we choose very small values for N the corruption model becomes unstable. We further analyze how to choose the value of N in Section 7.2.
Limi ting the values of K or N are simple ways to decrease the execution time, without much accuracy degradation, as we show in Section 7.
Algorithm 1 shows the Structured Robustness Algorithm (SR Algorithm), which computes the exact SR score based on the top K result entities. Each ranking algorithm uses some statistics about query terms or attributes values over the whole content of DB. Some examples of such statistics are the number of occurrences of a query term in all at-tributes values of the DB or total number of attribute values in each attribute and entity set. These global statistics are stored in M (metadata) and I (inverted indexes) in the SR Algorithm pseudocode.
 A lgorithm 1 CorruptT opResults ( Q, L, M, I, N )
The SR Algorithm generates the noise in the DB on-the-fly during query processing. Since it corrupts only the top K entities, which are anyways returned by the ranking module, it does not perform any extra I/O access to the DB, except to lookup some statistics. Moreover, it uses the information which is already computed and stored in inverted indexes and does not require any extra index.

In order to improve the efficiency of our method, we cor-rupt only the attribute values that contain at least query keywords. We also use the statistics of original database to re-rank the corrupted results. Moreover, we further limit the value of N . Our empirical results in Section 7 show that these will largely improve the efficiency of our model without much degradation of the prediction quality.
Data sets: Table 2 shows the characteristics of two data sets used in our experiments. The INEX data set is from the INEX 2010 Data Centric Track [22] discussed in Sec-tion 1.The SemSearch data set is a subset of the data set used in Semantic Search 2010 challenge [21]. The origi-nal data set contains 116 files with about one billion RDF triplets. Since the size of this data set is extremely large, it takes a very long time to index and run queries over this data set. Hence, we have used a subset of the original data set in our experiments. We first removed duplicate RDF triplets. Then, for each file in SemSearch data set, we calculated the total number of distinct query terms in SemSearch query workload in the file. We selected the 20, out of the 116, files that contain the largest number of query keywords for our experiments. We converted each distinct RDF subject in this data set to an entity whose identifier is the subject identifier. The RDF properties are mapped to attributes in our model. The values of RDF properties that end with substring  X #type X  indicates the type of a subject. Hence, we set the entity set of each entity to the concatenation of the values of RDF properties of its RDF subject that end with substring  X #type X . We have removed the relevance judgment information for the subjects that do not reside in these 20 files.
 Table 2: INEX and SemSearch datasets characteristics
Q uery Workloads: Since we use a subset of the dataset from SemSearch, some queries in its query workload may not contain enough candidate answers. We picked the 55 queries from the 92 in the query workload that have at least 50 candidate answers in our dataset. Because the number of entries for each query in the relevance judgment file has also been reduced, we discarded another two queries (Q6 and Q92) without any relevant answers in our dataset. Hence, our experiments is done using 53 queries (2, 4, 5, 11-12, 14-17, 19-29, 31, 33-34, 37-39, 41-42, 45, 47, 49, 52-54, 56-58, 60, 65, 68, 71, 73-74, 76, 78, 80-83, 88-91) from the Sem-Search query workload. Some INEX queries contain char-acters  X + X  and  X - X  to indicate the conjunctive and exclusive conditions. In our experiments, we do not use these con-ditions and remove the keywords after character  X - X . Gen-erally, KQIs over databases return candidate answers that contain all terms in the query [2, 10, 18]. However, queries in the INEX query workload are relatively long (normally over four distinct keywords). If we retrieve only the enti-ties that contain all query terms, there will not be sufficient number of (in some cases none) candidate answers for many queries in the data. Hence, for every query Q , we use the fol-lowing procedure to get at least 1,000 candidate answers for each query. First, we retrieve the entities that contain j distinct terms in query Q . If they are not sufficient, we re-trieve the entities that contain at least j Q j 1 distinct query keywords, and so on until we get 1000 candidate answers for each query.

Ranking Algorithm: We have evaluated our query per-formance prediction model using a representative ranking algorithm called PRMS [12]. Many ranking methods for key-word queries over structured data follow a similar heuristic as this algorithm (e.g., [1, 4]). PRMS employs a language model approach to search over structured data. It computes the language model of each attribute value smoothed by the language model of its attribute. It assigns each attribute a query keyword-specific weight, which specifies its contribu-tion in the ranking score. It computes the keyword-specific weight  X  j ( q ) for attribute values whose attributes are T and query keyword q as  X  j ( q ) = P ( q | T j )  X  ing score of entity E for query Q , P ( Q j E ) is: where A j is an attribute value of E , T j is the attribute of A , 0  X  1 is the smoothing parameter for the language model of A j , and n is the number of attribute values in E . We adjust parameter  X  in PRMS in our experiments to get the best MAP and then use this value of  X  for query performance prediction evaluations.

Configuration: We have performed our experiments on an AMD Phenom II X6 2.8 GHz machine with 8 GB of main memory that runs on 64-bit Windows 7. We use Berkeley DB 5.1.25 to index the XML files and implement all algo-rithms in Java.
In this section, we evaluate the effectiveness of the query quality prediction model computed using SR Algorithm. We use Pearson X  X  correlation between the SR score and the av-erage precision of a query to evaluate the prediction quality of SR score.

Setting the value of N : Let L and L  X  be the original and corrupted top-K entities for query Q , respectively. The SR score of Q in each corruption iteration is the Spearman X  X  correlation between L and L  X  . We corrupt the results N times to get the average SR score for Q . In order to get a stable SR score, the value of N should be sufficiently large, but this increases the computation time of the SR score. We chose the following strategy to find the appropriate value of N : We progressively corrupt L 50 iterations at a time and calculate the average SR score over all iterations. If the last 50 iterations do not change the average SR score over 1%, we terminate. N may vary for different queries in query workloads. Thus, we set it to the maximum number of iterations over all queries. According to our experiments, the value of N varies very slightly for different value of K . Therefore, we set the value of N to 300 on INEX and 250 on SemSearch for all values of K .

Different Values for K : The number of interesting re-sults for a keyword query is normally small [13]. Hence, it is reasonable to focus on small values of K for query perfor-mance prediction. We conduct our experiments on K =10, 20. Both values deliver reasonable prediction quality (i.e. the robustness of a query is strongly correlated with its ef-fectiveness). We have achieved the best prediction quality using K =20 for both datasets with different combination of  X  ,  X  T , and  X  S which we will introduce later.

Training of  X  A ,  X  T , and  X  S : We denote the coefficients combination in Equation 10 as (  X  A ,  X  T ,  X  S ) for brevity. We train (  X  A ,  X  T ,  X  S ) by 5-fold cross validation. After some preliminary experiments, we found that large  X  A is effective. Hence, to reduce the number of possible combinations, we fix  X 
A as 1, and vary the other two during the training process to find the highest correlation between average precision and SR score. We computed the SR score for  X  T and  X  S from 0 to 3 with step 0.1 for different values of K . Table 3 shows the training of  X  T and  X  S , and the correlation between average precision and SR score on testing sets. It shows that for different training sets, the values of (  X  A ,  X  T ,  X  S ) for the best correlation score are quite stable. In the following results, Table 3: Training and testing of (  X  A ,  X  T ,  X  S ) under K =20. w e set (  X  A ,  X  T ,  X  S ) to (1, 0.9, 0.8) on INEX and (1, 0.1, 0.6) on SemSearch.
 Figures 5 and 6 depict the plot of average precision and SR score for all queries in our query workload on INEX and SemSearch, respectively. In Figure 5, we see that Q 9 is easy (has high average precision) and Q 11 is relatively hard, as discussed in Section 5.4. As shown in Figure 6, query Q 78: sharp-pc is easy (has high average precision), because its keywords appear together in few results, which explains its high SR score. On the other hand, Q 19: carl lewis and Q 90: university of phoenix have a very low average precision as their keywords appear in many attributes and entity sets. Figure 6 shows that the SR scores of these queries are very small, which confirms our model.
 Fi gure 5: Average precision versus SR score for queries on INEX using PRMS, K =20.
 Fi gure 6: Average precision versus SR score for queries on SemSearch using PRMS, K =20.
 Table 4: Correlation of average precision and difficulty mea-surements for different methods for K =10.
 T able 5: Correlation of average precision and difficulty mea-surements for different methods for K =20.
 B aseline Prediction Methods Clarity score (CR) [20] and Unstructured Robustness Method (U RM) [24] are two popular query difficulty prediction tech-niques over text documents. The prediction quality (i.e. the correlation between average precisions of queries and the measurement) of clarity score and URM are 0.21 -0.51 and 0.30 -0.61, respectively [24]. We use these methods as well as prevalence of query keywords as baseline query difficulty prediction algorithms in databases.

URM and CR: Our goal in this experiment is to find how accurately URM can predict the effectiveness of queries over a database. We concatenate the XML elements and tags of each entity into a text document and assume all enti-ties (now text documents) belong to one entity set. The values of all  X  j in PRMS ranking formula are set to 1 for every query term.Hence, PRMS becomes a language model retrieval method for text documents [13]. Similar to URM, we implement CR by treating each entity in database as a text document. We have used similar parameters as [20, 24] to compute the CR for queries over our data sets.
Prevalence of Query Keywords: As we argued in Sec-tion 4.2, if the query keywords appear in many entities, at-tributes, or entity sets, it is harder for a ranking algorithm to locate the desired entities. Given query Q , we compute the average number of attributes ( AA ( Q )), average number of entity sets ( AES ( Q )), and the average number of enti-ties ( AE ( Q )) where each keyword in Q occurs. We consider each of these three values as an individual baseline diffi-culty prediction measurements. We also multiply these three measurements (to avoid normalization issues that summa-tion would have) and create another baseline measurement, denoted as AS ( Q ). Intuitively, if these measurements for query Q have higher values, Q must be harder and have lower average precision. Thus, we use the inverse of these values, denoted as iAA ( Q ), iAES ( Q ), iAE ( Q ), and iAS ( Q ), respectively.

Comparison to Baseline Methods: Table 4 and 5 shows the prediction accuracy (correlation between average pre-cision and each measurement) for SR, URM, CR, iAA(Q), iAES(Q), iAE(Q), and iAS(Q) methods over both datasets for K =10 and 20, respectively. These results are based on all queries in the query workloads without distinguishing be-tween training and testing sets as in Table 3. The n/a value appears in the table because all query keywords in our query workloads occur in both entity sets in the INEX dataset. The correlation values for SR Algorithm are significantly higher than the correlation values of URM and CR on both datasets. This shows that our prediction model is more effec-tive than URM and CR over databases. Measurement iAA provides a more accurate prediction than all other methods over INEX. This indicates that one of the main causes of the difficulties for the queries over the INEX dataset is to find their desired attributes, which confirms our analysis in Sec-tion 4.2. SR also delivers far better prediction qualities than iAA(Q), iAES(Q), iAE(Q), and iAS(Q) measurements over both data sets. Hence, SR effectively considers all causes of the difficulties for queries over databases.
As mentioned in Section 6, we propose techniques to im-prove the efficiency of our prediction model. Using these techniques, the time spent on the calculation of SR score is 1 and 1.1 second with correlation score of over 0.51 and 0.495 for INEX and SemSearch, respectively.
We introduced the novel problem of predicting the effec-tiveness of keyword queries over DBs. We set forth a princi-pled framework and proposed novel algorithms to measure the degree of the difficulty of a query over a DB, using the ranking robustness principle. Our extensive experiments show that the algorithms predict the difficulty of a query with relatively low errors and negligible time overhead. This work was supported in part by National Science Foundation grants IIS-1216032 and IIS-1216007.
