 Linguistically syntax-based statistical machine translation models have made promising progress in recent years. By incorporating the syntactic an-notations of parse trees from both or either side(s) of the bitext, they are believed better than phrase-based counterparts in reorderings. Depending on the type of input, these models can be broadly di-vided into two categories (see Table 1): the string-based systems whose input is a string to be simul-taneously parsed and translated by a synchronous grammar, and the tree-based systems whose input is already a parse tree to be directly converted into a target tree or string. When we also take into ac-count the type of output (tree or string), the tree-based systems can be divided into tree-to-string and tree-to-tree efforts. Table 1: A classification and comparison of lin-guistically syntax-based SMT systems, where gram. denotes grammaticality of the output.

On one hand, tree-to-string systems (Liu et al., 2006; Huang et al., 2006) have gained significant popularity, especially after incorporating packed forests (Mi et al., 2008; Mi and Huang, 2008; Liu et al., 2009; Zhang et al., 2009). Compared with their string-based counterparts, tree-based systems are much faster in decoding (linear time vs. cu-bic time, see (Huang et al., 2006)), do not re-quire a binary-branching grammar as in string-based models (Zhang et al., 2006; Huang et al., 2009), and can have separate grammars for pars-ing and translation (Huang et al., 2006). However, they have a major limitation that they do not have a principled mechanism to guarantee grammatical-ity on the target side, since there is no linguistic tree structure of the output.

On the other hand, string-to-tree systems ex-plicitly model the grammaticality of the output by using target syntactic trees. Both string-to-constituency system (e.g., (Galley et al., 2006; Marcu et al., 2006)) and string-to-dependency model (Shen et al., 2008) have achieved signif-icant improvements over the state-of-the-art for-mally syntax-based system Hiero (Chiang, 2007). However, those systems also have some limita-tions that they run slowly (in cubic time) (Huang et al., 2006), and do not utilize the useful syntactic information on the source side.

We thus combine the advantages of both tree-to-string and string-to-tree approaches, and propose a novel constituency-to-dependency model, which uses constituency forests on the source side to di-rect translation, and dependency trees on the tar-get side to guarantee grammaticality of the out-put. In contrast to conventional tree-to-tree ap-proaches (Ding and Palmer, 2005; Quirk et al., 2005; Xiong et al., 2007; Zhang et al., 2007; Liu et al., 2009), which only make use of a sin-gle type of trees, our model is able to combine two types of trees, outperforming both phrase-based and tree-to-string systems. Current tree-to-tree models (Xiong et al., 2007; Zhang et al., 2007; Liu et al., 2009) still have not outperformed the phrase-based system Moses (Koehn et al., 2007)
Our new constituency-to-dependency model (Section 2) extracts rules from word-aligned pairs of source constituency forests and target depen-dency trees (Section 3), and translates source con-stituency forests into target dependency trees with a set of features (Section 4). Medium data exper-iments (Section 5) show a statistically significant improvement of +0.7 BLEU points over a state-of-the-art forest-based tree-to-string system even with less translation rules, this is also the first time that a tree-to-tree model can surpass tree-to-string counterparts. Figure 1 shows a word-aligned source con-stituency forest F our constituency to dependency translation model can be formalized as: where C tion that translates C tion, r is a constituency to dependency translation rule. 2.1 Constituency Forests on the Source Side A constituency forest (in Figure 1 left) is a com-pact representation of all the derivations (i.e., parse trees) for a given sentence under a context-free grammar (Billot and Lang, 1989).

More formally, following Huang (2008), such a constituency forest is a pair F h V f , H f i , where V f is the set of nodes , and H f the set of hyperedges . For a given source sen-tence c in the form of X of nonterminal X spanning the substring from po-sitions i through j (that is, c peredge h f  X  H f is a pair h tails ( h f ) , head ( h f ) i where head ( h f )  X  V f is the consequent node in the deductive step, and tails ( h f )  X  ( V f )  X  is the list of antecedent nodes . For example, the hyper-edge h f is notated: where
The solid line in Figure 1 shows the best parse tree, while the dashed one shows the second best tree. Note that common sub-derivations like those for the verb VPB forest to represent exponentially many parses in a compact structure.

We also denote IN ( v f ) to be the set of in-coming hyperedges of node v f , which represents the different ways of deriving v f . Take node IP in Figure 1 for example, IN ( IP There is also a distinguished root node TOP in each forest, denoting the goal item in parsing, which is simply S and m is the sentence length. 2.2 Dependency Trees on the Target Side A dependency tree for a sentence represents each word and its syntactic dependents through directed arcs, as shown in the following examples. The main advantage of a dependency tree is that it can explore the long distance dependency. 1: talk 2: held
We use the lexicon dependency grammar (Hell-wig, 2006) to express a projective dependency tree. Take the dependency trees above for exam-ple, they will be expressed: 1: ( a ) talk 2: ( Bush ) held ( ( a ) talk ) ( with ( Sharon ) ) where the lexicons in brackets represent the de-pendencies, while the lexicon out the brackets is the head.
 More formally, a dependency tree is also a pair D e = G d = h V d , H d i tence e a word e H d is a directed arc h v d its head node v d the constituency forest scenario, we denote a pair head ( h d ) is the head node, tails ( h d ) is the node where h d leaves from.

We also denote L and right children sequence of node v d from the nearest to the farthest respectively. Take the node v 2.3 Hypergraph Actually, both the constituency forest and the de-pendency tree can be formalized as a hypergraph G , a pair h V, H i . We use G f and G d to distinguish them. For simplicity, we also use F note a constituency forest and a dependency tree respectively. Specifically, the size of tails ( h d ) of a hyperedge h d in a dependency tree is a constant one.
 x :NPB CC Figure 2: Example of the rule r junction y  X  u  X  X nd X  is translated into English prepo-sition  X  X ith X . We extract constituency to dependency rules from word-aligned source constituency forest and target dependency tree pairs (Figure 1). We mainly ex-tend the tree-to-string rule extraction algorithm of Mi and Huang (2008) to our scenario. In this sec-tion, we first formalize the constituency to string translation rule (Section 3.1). Then we present the restrictions for dependency structures as well formed fragments (Section 3.2). Finally, we de-scribe our rule extraction algorithm (Section 3.3), fractional counts computation and probabilities es-timation (Section 3.4). 3.1 Constituency to Dependency Rule More formally, a constituency to de-pendency translation rule r is a tuple h lhs ( r ) , rhs ( r ) ,  X  ( r ) i , where lhs ( r ) is the source side tree fragment, whose internal nodes are labeled by nonterminal symbols (like NP and VP), and whose frontier nodes are labeled by source language words c from a set X = { x in the target language dependency structure with words e X ; and  X  ( r ) is a mapping from X to nontermi-nals. Each variable x lhs ( r ) and exactly once in rhs ( r ) . For example, the rule r lhs ( r 1 ) = IP(NP( x 1 CC( y  X  u ) x 2 ) x 3 ) , rhs ( r 1 ) = ( x 1 ) x 3 (with ( x 2 )) ,  X  ( r 1 ) = { x 1 7 X  NPB, x 2 7 X  NPB, x 3 7 X  VPB } . 3.2 Well Formed Dependency Fragment Following Shen et al. (2008), we also restrict rhs ( r ) to be well formed dependency fragment. The main difference between us is that we use more flexible restrictions. Given a dependency
NPB
B ` ush  X   X  VPB ( Bush ) held ( ( a ) talk ) ( with ( Sharon ) ) fragment d two kinds of well formed structures are defined as follows:
Fixed on one node v d meets the following conditions:  X  the head of v d one is out of [ i, j ] , i.e.:  X  h d , if  X  the heads of other nodes except v d one are in
Floating with multi nodes M , floating for short, if it meets the following conditions:  X  all nodes in M have a same head node,  X  the heads of other nodes not in M are in
Take the  X  (Bush) held ((a) talk))(with (Sharon))  X  for example: partial fixed examples are  X  (Bush) held  X  and  X  held ((a) talk) X ; while the partial float-ing examples are  X  (talk) (with (Sharon))  X  and  X  ((a) talk) (with (Sharon))  X . Please note that the floating structure  X  (talk) (with (Sharon))  X  can not be allowed in Shen et al. (2008) X  X  model.

The dependency structure  X  held ((a)) X  is not a well formed structure, since the head of word  X  X  X  is out of scope of this structure. 3.3 Rule Extraction Algorithm The algorithm shown in this Section is mainly ex-tended from the forest-based tree-to-string extrac-tion algorithm (Mi and Huang, 2008). We extract rules from word-aligned source constituency for-est and target dependency tree pairs (see Figure 1) in three steps: (1) frontier set computation, (2) fragmentation, (3) composition.

The frontier set (Galley et al., 2004) is the po-tential points to  X  X ut X  the forest and dependency tree pair into fragments, each of which will form a minimal rule (Galley et al., 2006).

However, not every fragment can be used for rule extraction, since it may or may not respect to the restrictions, such as word alignments and well formed dependency structures. So we say a fragment is extractable if it respects to all re-strictions. The root node of every extractable tree fragment corresponds to a faithful structure on the target side, in which case there is a  X  X ransla-tional equivalence X  between the subtree rooted at the node and the corresponding target structure. For example, in Figure 1, every node in the forest is annotated with its corresponding English struc-ture. The NP structure  X (Bush)  X  (with (Sharon)) X , the VV node maps to a contiguous but non-faithful struc-ture  X  X eld ((a) *) X . 1: fs  X  F RONTIER ( F c , D e , a )  X  compute frontier set 2: for each v f  X  fs do 4: while open 6 =  X  do 5: h hs , exps i X  open .pop ()  X  extract a fragment 6: if exps =  X  then  X  nothing to expand? 7: generate a rule r using fragment hs  X  generate a rule 8: R .append( r ) 9: else  X  incomplete: further expand 10: v  X   X  exps .pop()  X  a non-frontier node 11: for each h f  X  IN ( v  X  ) do 12: newexps  X  exps  X  ( tails ( h f ) \ fs )  X  expand 13: open .append( h hs  X  X  h f } , newexps i )
Following Mi and Huang (2008), given a source target sentence pair h c a , the span of node v f on source forest is the set of target words aligned to leaf nodes under v f : where the yield ( v f ) is all the leaf nodes un-der v f . For each span ( v f ) , we also denote dep ( v f ) to be its corresponding dependency struc-ture, which represents the dependency struc-ture of all the words in span ( v f ) . Take the span ( PP 1 , 3 ) = { with, Sharon } for example, the corresponding dep ( PP dep ( v f ) is faithful structure to node v f if it meets the following restrictions:  X  all words in span ( v f ) form a continuous sub- X  every word in span ( v f ) is only aligned to leaf  X  dep ( v f ) is a well formed dependency struc-For example, node VV structure (crossed out in Figure 1), since its dep ( VV 3 , 4 =  X  held ((a) *) X  is not a well formed structure, where the head of word  X  X  X  lies in the outside of its words covered. Nodes with faithful structure form the frontier set (shaded nodes in Figure 1) which serve as potential cut points for rule extraction.

Given the frontier set, fragmentation step is to  X  X ut X  the forest at all frontier nodes and form tree fragments, each of which forms a rule with variables matching the frontier descendant nodes. For example, the forest in Figure 1 is cut into 10 pieces, each of which corresponds to a minimal rule listed on the right.
 Our rule extraction algorithm is formalized in Algorithm 1. After we compute the frontier set fs (line 1). We visit each frontier node v f  X  f s on the source constituency forest F queue open of growing fragments rooted at v f . We keep expanding incomplete fragments from open , and extract a rule if a complete fragment is found (line 7). Each fragment hs in open is associated with a list of expansion sites ( exps in line 5) being the subset of leaf nodes of the current fragment that are not in the frontier set. So each fragment along hyperedge h is associated with A fragment is complete if its expansion sites is empty (line 6), otherwise we pop one expansion node v  X  to grow and spin-off new fragments by following hyperedges of v  X  , adding new expansion sites (lines 11-13), until all active fragments are complete and open queue is empty (line 4).

After we get all the minimal rules, we glue them together to form composed rule s following Galley et al. (2006). For example, the composed rule r in Figure 2 is glued by the following two minimal rules:
IP (NP( x
CC ( y  X  u )  X  with r where x 3.4 Fractional Counts and Rule Probabilities Following Mi and Huang (2008), we penalize a rule r by the posterior probability of the corre-sponding constituent tree fragment lhs ( r ) , which can be computed in an Inside-Outside fashion, be-ing the product of the outside probability of its root node, the inside probabilities of its leaf nodes, and the probabilities of hyperedges involved in the fragment.  X  X  ( lhs ( r )) =  X  ( root ( r )) where root (r) is the root of the rule r ,  X  ( v ) and  X  ( v ) are the outside and inside probabilities of node v , and leaves ( lhs ( r )) returns the leaf nodes of a tree fragment lhs (r).

We use fractional counts to compute three con-ditional probabilities for each rule, which will be used in the next section:
P( r | root ( r )) = Given a source forest F the best derivation o  X  among the set of all possible derivations O , each of which forms a source side constituent tree T a target side dependency tree D where the first two terms are translation and lan-guage model probabilities, e ( o ) is the target string (English sentence) for derivation o , the third and forth items are the dependency language model probabilities on the target side computed with words and POS tags separately, D dependency tree of o , the fifth one is the parsing probability of the source side tree T ill ( o ) is the penalty for the number of ill-formed dependency structures in o , and the last two terms are derivation and translation length penalties, re-spectively. The conditional probability P( o | T is decomposes into the product of rule probabili-ties: where each P( r ) is the product of five probabili-ties: where the first three are conditional probabilities based on fractional counts of rules defined in Sec-tion 3.4, and the last two are lexical probabilities. When computing the lexical translation probabili-ties described in (Koehn et al., 2003), we only take into accout the terminals in a rule. If there is no terminal, we set the lexical probability to 1 .
The decoding algorithm works in a bottom-up search fashion by traversing each node in forest F . We first use pattern-matching algorithm of Mi et al. (2008) to convert F est , each hyperedge of which is associated with a constituency to dependency translation rule. How-cut the derivation path and lead to translation fail-ure. To tackle this problem, we construct a pseudo translation rule for each parse hyperedge h f  X  IN ( v f ) by mapping the CFG rule into a target de-pendency tree using the head rules of Magerman (1995). Take the hyperedge h f ample, the corresponding pseudo translation rule is:
NP ( x since the x rule: NP  X  NPB CC NPB.

After the translation forest is constructed, we traverse each node in translation forest also in bottom-up fashion. For each node, we use the cube pruning technique (Chiang, 2007; Huang and Chiang, 2007) to produce partial hypotheses and compute all the feature scores including the dependency language model score (Section 4.1). If all the nodes are visited, we trace back along the 1-best derivation at goal item S a target side dependency tree. For k -best search after getting 1-best derivation, we use the lazy Al-gorithm 3 of Huang and Chiang (2005) that works backwards from the root node, incrementally com-puting the second, third, through the k th best alter-natives. 4.1 Dependency Language Model Computing We compute the score of a dependency language model for a dependency tree D proposed by Shen et al. (2008). For each nonter-minal node v d quences L the probability of a trigram is computed as fol-lows:
P( L l , L r | e h  X  ) = P( L l | e h  X  ) P( L r | e h  X  ) , where the P( L We use the suffix  X   X   X  to distinguish the head word and child words in the dependency language model.

In order to alleviate the problem of data sparse, we also compute a dependency language model for POS tages over a dependency tree. We store the POS tag information on the target side for each constituency-to-dependency rule. So we will also generate a POS taged dependency tree simulta-neously at the decoding time. We calculate this dependency language model by simply replacing each e 5.1 Data Preparation Our training corpus consists of 239K sentence pairs with about 6.9M/8.9M words in Chi-nese/English, respectively. We first word-align them by GIZA++ (Och and Ney, 2000) with re-finement option  X  X row-diag-and X  (Koehn et al., 2003), and then parse the Chinese sentences using the parser of Xiong et al. (2005) into parse forests, which are pruned into relatively small forests with a pruning threshold 3. We also parse the English sentences using the parser of Charniak (2000) into 1-best constituency trees, which will be converted into dependency trees using Magerman (1995) X  X  head rules. We also store the POS tag informa-tion for each word in dependency trees, and com-pute two different dependency language models for words and POS tags in dependency tree sepa-rately. Finally, we apply translation rule extraction algorithm described in Section 3. We use SRI Lan-guage Modeling Toolkit (Stolcke, 2002) to train a 4-gram language model with Kneser-Ney smooth-ing on the first 1/3 of the Xinhua portion of Giga-word corpus. At the decoding step, we again parse the input sentences into forests and prune them with a threshold 10, which will direct the trans-lation (Section 4).

We use the 2002 NIST MT Evaluation test set as our development set and the 2005 NIST MT Evaluation test set as our test set. We evaluate the translation quality using the BLEU-4 metric (Pap-ineni et al., 2002), which is calculated by the script mteval-v11b.pl with its default setting which is case-insensitive matching of n -grams. We use the standard minimum error-rate training (Och, 2003) to tune the feature weights to maximize the sys-tem X  X  BLEU score on development set. 5.2 Results Table 2 shows the results on the test set. Our baseline system is a state-of-the-art forest-based constituency-to-string model (Mi et al., 2008), or forest c2s for short, which translates a source for-est into a target string by pattern-matching the constituency-to-string ( c2s ) rules and the bilin-gual phrases ( s2s ). The baseline system extracts 31.9M c2s rules, 77.9M s2s rules respectively and
At first, we investigate the influence of differ-ent rule sets on the performance of baseline sys-tem. We first restrict the target side of transla-tion rules to be well-formed structures, and we extract 13.8M constituency-to-dependency ( c2d ) rules, which is 43% of c2s rules. We also extract 9.0M string-to-dependency ( s2d ) rules, which is only 11.6% of s2s rules. Then we convert c2d and s2d rules to c2s and s2s rules separately by re-moving the target-dependency structures and feed them into the baseline system. As shown in the third line in the column of BLEU score, the per-formance drops 1.7 BLEU points over baseline system due to the poorer rule coverage. However, when we further use all s2s rules instead of s2d rules in our next experiment, it achieves a BLEU score of 34.03, which is very similar to the base-line system. Those results suggest that restrictions on c2s rules won X  X  hurt the performance, but re-strictions on s2s will hurt the translation quality badly. So we should utilize all the s2s rules in or-der to preserve a good coverage of translation rule set.

The last two lines in Table 2 show the results of our new forest-based constituency-to-dependency model ( forest c2d for short). When we only use c2d and s2d rules, our system achieves a BLEU score of 33.25, which is lower than the baseline system in the first line. But, with the same rule set, our model still outperform the result in the sec-ond line. This suggests that using dependency lan-guage model really improves the translation qual-ity by less than 1 BLEU point.

In order to utilize all the s2s rules and increase the rule coverage, we parse the target strings of the s2s rules into dependency fragments, and con-struct the pseudo s2d rules ( s2s-dep ). Then we use c2d and s2s-dep rules to direct the translation. With the help of the dependency language model, our new model achieves a significant improvement of +0.7 BLEU points over the forest c2s baseline system ( p &lt; 0 . 05 , using the sign-test suggested by Table 2: Statistics of different types of rules ex-tracted on training corpus and the BLEU scores on the test set.
 Collins et al. (2005)). For the first time, a tree-to-tree model can surpass tree-to-string counterparts significantly even with fewer rules. The concept of packed forest has been used in machine translation for several years. For exam-ple, Huang and Chiang (2007) use forest to char-acterize the search space of decoding with in-tegrated language models. Mi et al. (2008) and Mi and Huang (2008) use forest to direct trans-lation and extract rules rather than 1-best tree in order to weaken the influence of parsing errors, this is also the first time to use forest directly in machine translation. Following this direction, Liu et al. (2009) and Zhang et al. (2009) apply forest into tree-to-tree (Zhang et al., 2007) and tree-sequence-to-string models(Liu et al., 2007) respectively. Different from Liu et al. (2009), we apply forest into a new constituency tree to de-pendency tree translation model rather than con-stituency tree-to-tree model.

Shen et al. (2008) present a string-to-dependency model. They define the well-formed dependency structures to reduce the size of translation rule set, and integrate a dependency language model in decoding step to exploit long distance word relations. This model shows a significant improvement over the state-of-the-art hierarchical phrase-based system (Chiang, 2005). Compared with this work, we put fewer restric-tions on the definition of well-formed dependency structures in order to extract more rules; the other difference is that we can also extract more expressive constituency to dependency rules, since the source side of our rule can encode multi-level reordering and contain more variables being larger than two; furthermore, our rules can be pattern-matched at high level, which is more reasonable than using glue rules in Shen et al. (2008) X  X  scenario; finally, the most important one is that our model runs very faster.

Liu et al. (2009) propose a forest-based constituency-to-constituency model, they put more emphasize on how to utilize parse forest to increase the tree-to-tree rule coverage. By contrast, we only use 1-best dependency trees on the target side to explore long distance rela-tions and extract translation rules. Theoretically, we can extract more rules since dependency tree has the best inter-lingual phrasal cohesion properties (Fox, 2002). In this paper, we presented a novel forest-based constituency-to-dependency translation model, which combines the advantages of both tree-to-string and string-to-tree systems, runs fast and guarantees grammaticality of the output. To learn the constituency-to-dependency translation rules, nodes in the constituency forest on the source side. Then we fragment them and extract mini-mal rules. Finally, we glue them together to be composed rules. At the decoding step, we first parse the input sentence into a constituency for-est. Then we convert it into a translation for-est by patter-matching the constituency to string rules. Finally, we traverse the translation forest in a bottom-up fashion and translate it into a tar-get dependency tree by incorporating string-based and dependency-based language models. Using all constituency-to-dependency translation rules and bilingual phrases, our model achieves +0.7 points improvement in BLEU score significantly over a state-of-the-art forest-based tree-to-string system. This is also the first time that a tree-to-tree model can surpass tree-to-string counterparts.

In the future, we will do more experiments on rule coverage to compare the constituency-to-constituency model with our model. Furthermore, we will replace 1-best dependency trees on the target side with dependency forests to further in-crease the rule coverage.
 The authors were supported by National Natural Science Foundation of China, Contracts 60736014 and 90920004, and 863 State Key Project No. 2006AA010108. We thank the anonymous review-ers for their insightful comments. We are also grateful to Liang Huang for his valuable sugges-tions.

