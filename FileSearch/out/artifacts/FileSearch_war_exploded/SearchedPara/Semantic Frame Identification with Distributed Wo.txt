 Distributed representations of words have proved useful for a number of tasks. By providing richer representations of meaning than what can be en-compassed in a discrete representation, such ap-proaches have successfully been applied to tasks such as sentiment analysis (Socher et al., 2011), topic classification (Klementiev et al., 2012) or word-word similarity (Mitchell and Lapata, 2008).
We present a new technique for semantic frame identification that leverages distributed word rep-resentations. According to the theory of frame se-mantics (Fillmore, 1982), a semantic frame rep-resents an event or scenario, and possesses frame elements (or semantic roles ) that participate in the event. Most work on frame-semantic parsing has usually divided the task into two major subtasks: frame identification , namely the disambiguation of a given predicate to a frame, and argument iden-tification (or semantic role labeling), the analysis of words and phrases in the sentential context that satisfy the frame X  X  semantic roles (Das et al., 2010; task of frame identification for given predicates; we use our novel method (  X  3) in conjunction with a standard argument identification model (  X  4) to perform full frame-semantic parsing.

We present experiments on two tasks. First, we show that for frame identification on the FrameNet corpus (Baker et al., 1998; Fillmore et al., 2003), we outperform the prior state of the art (Das et al., 2014). Moreover, for full frame-semantic parsing, with the presented frame identification technique followed by our argument identification method, we report the best results on this task to date. Sec-ond, we present results on PropBank-style seman-tic role labeling (Palmer et al., 2005; Meyers et al., 2004; M ` arquez et al., 2008), that approach strong baselines, and are on par with prior state of the art (Punyakanok et al., 2008). Early work in frame-semantic analysis was pio-neered by Gildea and Jurafsky (2002). Subsequent work in this area focused on either the FrameNet or PropBank frameworks, and research on the lat-ter has been more popular. Since the CoNLL 2004-2005 shared tasks (Carreras and M ` arquez, 2004; Carreras and M ` arquez, 2005) on PropBank semantic role labeling (SRL), it has been treated as an important NLP problem. However, research has mostly focused on argument analysis, skipping the frame disambiguation step, and its interaction with argument identification. 2.1 Frame-Semantic Parsing Closely related to SRL, frame-semantic parsing consists of the resolution of predicate sense into a frame, and the analysis of the frame X  X  argu-ments. Work in this area exclusively uses the FrameNet full text annotations. Johansson and Nugues (2007) presented the best performing sys-tem at SemEval 2007 (Baker et al., 2007), and Das et al. (2010) improved performance, and later set the current state of the art on this task (Das et al., 2014). We briefly discuss FrameNet, and subse-quently PropBank annotation conventions here. FrameNet The FrameNet project (Baker et al., 1998) is a lexical database that contains informa-tion about words and phrases (represented as lem-mas conjoined with a coarse part-of-speech tag) termed as lexical units, with a set of semantic frames that they could evoke. For each frame, there is a list of associated frame elements (or roles, henceforth), that are also distinguished as ing this universal frame inventory. For exam-ple, consider the pair of sentences in Figure 1(a). morphological variants of the two example lexical units buy .V and sell .V. Buyer , Seller and Goods are some example roles for this frame. PropBank The PropBank project (Palmer et al., 2005) is another popular resource related to se-mantic role labeling. The PropBank corpus has verbs annotated with sense frames and their ar-guments. Like FrameNet, it also has a lexi-cal database that stores type information about verbs, in the form of sense frames and the possi-ble semantic roles each frame could take. There are modifier roles that are shared across verb frames, somewhat similar to the non-core roles in FrameNet. Figure 1(b) shows annotations for two verbs  X  X ought X  and  X  X old X , with their lemmas (akin to the lexical units in FrameNet) and their verb frames buy.01 and sell.01 . Generic core role labels (of which there are seven, namely A0 -A5 and A key difference between the two annotation sys-tems is that PropBank uses a local frame inven-tory, where frames are predicate-specific. More-over, role labels, although few in number, take spe-cific meaning for each verb frame. Figure 1 high-lights this difference: while both sell . V and buy . V are members of the same frame in FrameNet, they evoke different frames in PropBank. In spite of this difference, nearly identical statistical models could be employed for both frameworks.
 Modeling In this paper, we model the frame-semantic parsing problem in two stages: frame identification and argument identification . As mentioned in  X  1, these correspond to a frame dis-ious arguments that fulfill the frame X  X  semantic roles within the sentence, respectively. This re-sembles the framework of Das et al. (2014), who solely focus on FrameNet corpora, unlike this pa-per. The novelty of this paper lies in the frame identification stage (  X  3). Note that this two-stage approach is unusual for the PropBank corpora when compared to prior work, where the vast ma-jority of published papers have not focused on the verb frame disambiguation problem at all, only fo-cusing on the role labeling stage (see the overview paper of M ` arquez et al. (2008) for example). 2.2 Distributed Frame Identification We present a model that takes word embeddings as input and learns to identify semantic frames. A word embedding is a distributed representa-tion of meaning where each word is represented as a vector in R n . Such representations allow a model to share meaning between similar words, and have been used to capture semantic, syntac-tic and morphological content (Collobert and We-ston, 2008; Turian et al., 2010, inter alia ). We use word embeddings to represent the syntactic con-text of a particular predicate instance as a vector. For example, consider the sentence  X  X e runs the company. X  The predicate runs has two syntac-tic dependents  X  a subject and direct object (but no prepositional phrases or clausal complements). We could represent the syntactic context of runs as a vector with blocks for all the possible dependents warranted by a syntactic parser; for example, we could assume that positions 0 ...n in the vector correspond to the subject dependent, n +1 ... 2 n correspond to the clausal complement dependent, with the embedding of He at the subject position, the embedding of company in direct object posi-tion and zeros everywhere else. Given input vec-tors of this form for our training data, we learn a matrix that maps this high dimensional and sparse representation into a lower dimensional space. Si-multaneously, the model learns an embedding for all the possible labels (i.e. the frames in a given lexicon). At inference time, the predicate-context is mapped to the low dimensional space, and we choose the nearest frame label as our classifica-tion. We next describe this model in detail. We continue using the example sentence from  X  2.2:  X  X e runs the company. X  where we want to disambiguate the frame of runs in context. First, we extract the words in the syntactic context of runs ; next, we concatenate their word embeddings as described in  X  2.2 to create an initial vector space representation. Subsequently, we learn a map-ping from this initial representation into a low-dimensional space; we also learn an embedding for each possible frame label in the same low-dimensional space. The goal of learning is to make sure that the correct frame label is as close as possible to the mapped context, while competing frame labels are farther away.

Formally, let x represent the actual sentence with a marked predicate, along with the associated syntactic parse tree; let our initial representation of the predicate context be g ( x ) . Suppose that the word embeddings we start with are of dimension n . Then g is a function from a parsed sentence x to R nk , where k is the number of possible syn-tactic context types. For example g selects some important positions relative to the predicate, and reserves a block in its output space for the embed-ding of words found at that position. Suppose g considers clausal complements and direct objects. Then g : X  X  R 2 n and for the example sentence it has zeros in positions 0 ...n and the embedding of the word company in positions n +1 ... 2 n . Section 3.1 describes the context positions we use in our experiments. Let the low dimensional space we map to be R m and the learned mapping be M : R nk  X  R m . The mapping M is a linear trans-formation, and we learn it using the W SABIE algo-rithm (Weston et al., 2011). W SABIE also learns an embedding for each frame label ( y , henceforth). In our setting, this means that each frame corre-sponds to a point in R m . If we have F possi-ble frames we can store those parameters in an F  X  m matrix, one m -dimensional point for each frame, which we will refer to as the linear map-ping Y . Let the lexical unit (the lemma conjoined with a coarse POS tag) for the marked predicate be ` . We denote the frames that associate with ` in the frame lexicon 5 and our training corpus as F ` . W SABIE performs gradient-based updates on an objective that tries to minimize the distance between M ( g ( x )) and the embedding of the cor-rect label Y ( y ) , while maintaining a large distance between M ( g ( x )) and the other possible labels Y (  X  y ) in the confusion set F ` . At disambiguation time, we use a simple dot product similarity as our distance metric, meaning that the model chooses a label by computing the argmax y s ( x,y ) where s ( x,y ) = M ( g ( x ))  X  Y ( y ) , where the argmax iter-ates over the possible frames y  X  F ` if ` was seen in the lexicon or the training data, or y  X  F , if it the margin ranking loss function as described in Weston et al. (2011), and in more detail in section 3.2.

Since W SABIE learns a single mapping from g ( x ) to R m , parameters are shared between different words and different frames. So for example  X  X e runs the company X  could help the model disam-biguate  X  X e owns the company. X  Moreover, since g ( x ) relies on word embeddings rather than word identities, information is shared between words. For example  X  He runs the company  X  could help us to learn about  X  She runs a corporation  X . 3.1 Context Representation Extraction In principle g ( x ) could be any feature function, but we performed an initial investigation of two partic-ular variants. In both variants, our representation is a block vector where each block corresponds to a syntactic position relative to the predicate, and each block X  X  values correspond to the embedding of the word at that position.
 Direct Dependents The first context function we considered corresponds to the examples in  X  3. To elaborate, the positions of interest are the labels of the direct dependents of the predicate, so k is the number of labels that the dependency parser can produce. For example, if the label on the edge be-tween runs and He is nsubj , we would put the em-bedding of He in the block corresponding to nsubj . If a label occurs multiple times, then the embed-dings of the words below this label are averaged.
Unfortunately, using only the direct dependents can miss a lot of useful information. For exam-ple, topicalization can place discriminating infor-mation farther from the predicate. Consider  X  X e runs the company . X  vs.  X  X t was the company that he runs . X  In the second sentence, the discrim-inating word, company dominates the predicate runs . Similarly, predicates in embedded clauses may have a distant agent which cannot be captured using direct dependents. Consider  X  The athlete ran the marathon. X  vs.  X  The athlete prepared him-self for three months to run the marathon. X  In the second example, for the predicate run , the agent The athlete is not a direct dependent, but is con-nected via a longer dependency path.
 Dependency Paths To capture more relevant context, we developed a second context function as follows. We scanned the training data for a given task (either the PropBank or the FrameNet domains) for the dependency paths that connected the gold predicates to the gold semantic argu-ments. This set of dependency paths were deemed as possible positions in the initial vector space rep-resentation. In addition, akin to the first context function, we also added all dependency labels to the context set. Thus for this context function, the block cardinality k was the sum of the number of scanned gold dependency path types and the num-ber of dependency labels. Given a predicate in its sentential context, we therefore extract only those context words that appear in positions warranted by the above set. See Figure 2 for an illustration of this process.

We performed initial experiments using con-text extracted from 1) direct dependents, 2) de-pendency paths, and 3) both. For all our experi-ments, setting 3) which concatenates the direct de-pendents and dependency path always dominated the other two, so we only report results for this setting. 3.2 Learning We model our objective function following We-ston et al. (2011), using a weighted approximate-rank pairwise loss, learned with stochastic gradi-ent descent. The mapping from g ( x ) to the low dimensional space R m is a linear transformation, so the model parameters to be learnt are the matrix possible frame label, represented as another ma-trix Y  X  R F  X  m where there are F frames in total. The training objective function minimizes: X where x,y are the training inputs and their cor-responding correct frames, and  X  y are negative frames,  X  is the margin. Here, rank y ( x ) is the rank of the positive frame y relative to all the neg-ative frames: and L (  X  ) converts the rank to a weight. Choos-ing L (  X  ) = C X  for any positive constant C opti-mizes the mean rank, whereas a weighting such as L (  X  ) = top of the ranked list, as described in (Usunier et al., 2009). To train with such an objective, stochastic gradient is employed. For speed the computation of rank y ( x ) is then replaced with a sampled approximation: sample N items  X  y until a violation is found, i.e. max(0 , X  + s ( x,  X  y )  X  s ( x,y ))) &gt; 0 and then approximate the rank with ( F  X  1) /N , see Weston et al. (2011) for more details on this procedure. For the choices of the stochastic gradient learning rate, margin (  X  ) and dimensionality ( m ), please refer to  X  5.4- X  5.5.
Note that an alternative approach could learn only the matrix M , and then use a k -nearest neigh-bor classifier in R m , as in Weinberger and Saul (2009). The advantage of learning an embedding for the frame labels is that at inference time we need to consider only the set of labels for classi-fication rather than all training examples. Addi-tionally, since we use a frame lexicon that gives us the possible frames for a given predicate, we usually only consider a handful of candidate la-bels. If we used all training examples for a given predicate for finding a nearest-neighbor match at inference time, we would have to consider many more candidates, making the process very slow. Here, we briefly describe the argument identifi-cation model used in our frame-semantic parsing experiments, post frame identification. Given x , the sentence with a marked predicate, the argu-ment identification model assumes that the pred-icate frame y has been disambiguated. From a frame lexicon, we look up the set of semantic roles R y that associate with y . This set also contains the null role r  X  . From x , a rule-based candidate argu-ment extraction algorithm extracts a set of spans A that could potentially serve as the overt 7 argu-ments A y for y (see  X  5.4- X  5.5 for the details of the candidate argument extraction algorithms).
 Learning Given training data of the form a set of tuples that associates each role r in R y with a span a according to the gold data. Note that this mapping associates spans with the null role r  X  as well. We optimize the following log-likelihood to train our model: max where p set R y , with features described in Table 1. We set C = 1 . 0 and use L-BFGS (Liu and Nocedal, 1989) for training.
 Inference Although our learning mechanism uses a local log-linear model, we perform infer-ence globally on a per-frame basis by applying hard structural constraints. Following Das et al. (2014) and Punyakanok et al. (2008) we use the log-probability of the local classifiers as a score in an integer linear program (ILP) to assign roles sub-ject to hard constraints described in  X  5.4 and  X  5.5. We use an off-the-shelf ILP solver for inference. In this section, we present our experiments and the results achieved. We evaluate our novel frame identification approach in isolation and also con-joined with argument identification resulting in full frame-semantic structures; before presenting our model X  X  performance we first focus on the datasets, baselines and the experimental setup. 5.1 Data We evaluate our models on both FrameNet-and PropBank-style structures. For FrameNet, we use the full-text annotations in the FrameNet 1.5 re-lease 8 which was used by Das et al. (2014,  X  3.2). We used the same test set as Das et al. contain-ing 23 documents with 4,458 predicates. Of the remaining 55 documents, 16 documents were ran-For experiments with PropBank, we used the Ontonotes corpus (Hovy et al., 2006), version 4.0, and only made use of the Wall Street Journal doc-uments; we used sections 2-21 for training, sec-tion 24 for development and section 23 for testing. This resembles the setup used by Punyakanok et al. (2008). All the verb frame files in Ontonotes were used for creating our frame lexicon. 5.2 Frame Identification Baselines For comparison, we implemented a set of baseline models, with varying feature configurations. The baselines use a log-linear model that models the following probability at training time: At test time, this model chooses the best frame as argmax y  X   X  f ( y,x,` ) where argmax iterates over the possible frames y  X  F ` if ` was seen in the lexicon or the training data, or y  X  F , if it was un-seen, like the disambiguation scheme of  X  3. We train this model by maximizing L 2 regularized log-likelihood, using L-BFGS; the regularization constant was set to 0.1 in all experiments.

For comparison with our model from  X  3, which baselines with the log-linear model. Both the baselines use features very similar to the input rep-resentations described in  X  3.1. The first one com-putes the direct dependents and dependency paths as described in  X  3.1 but conjoins them with the word identity rather than a word embedding. Ad-ditionally, this model uses the un-conjoined words as backoff features. This would be a standard NLP approach for the frame identification problem, but is surprisingly competitive with the state of the art. ond baseline, tries to decouple the W SABIE training from the embedding input, and trains a log linear model using the embeddings. So the second base-line has the same input representation as W SABIE MBEDDING but uses a log-linear model instead of 5.3 Common Experimental Setup We process our PropBank and FrameNet training, development and test corpora with a shift-reduce dependency parser that uses the Stanford conven-tions (de Marneffe and Manning, 2013) and uses an arc-eager transition system with beam size of 8; the parser and its features are described by Zhang and Nivre (2011). Before parsing the data, it is tagged with a POS tagger trained with a condi-tional random field (Lafferty et al., 2001) with the following emission features: word, the word clus-ter, word suffixes of length 1, 2 and 3, capitaliza-tion, whether it has a hyphen, digit and punctua-tion. Beyond the bias transition feature, we have two cluster features for the left and right words in the transition. We use Brown clusters learned us-ing the algorithm of Uszkoreit and Brants (2008) on a large English newswire corpus for cluster fea-tures. We use the same word clusters for the argu-ment identification features in Table 1.

We learn the initial embedding representations for our frame identification model (  X  3) using a deep neural language model similar to the one pro-posed by Bengio et al. (2003). We use 3 hidden layers each with 1024 neurons and learn a 128-dimensional embedding from a large corpus con-taining over 100 billion tokens. In order to speed up learning, we use an unnormalized output layer and a hinge-loss objective. The objective tries to ensure that the correct word scores higher than a random incorrect word, and we train with mini-batch stochastic gradient descent. 5.4 Experimental Setup for FrameNet Hyperparameters For our frame identification model with embeddings, we search for the W SA -BIE hyperparameters using the development data. We search for the stochastic gradient learning rate in { 0 . 0001 , 0 . 001 , 0 . 01 } , the margin  X   X  { 0 . 001 , 0 . 01 , 0 . 1 , 1 } and the dimensionality of the final vector space m  X  { 256 , 512 } , to maximize the frame identification accuracy of ambiguous lexical units; by ambiguous, we imply lexical units that appear in the training data or the lexicon with more than one semantic frame. The underlined values are the chosen hyperparameters used to an-alyze the test data.
 Argument Candidates The candidate argument extraction method used for the FrameNet data, (as mentioned in  X  4) was adapted from the algorithm of Xue and Palmer (2004) applied to dependency trees. Since the original algorithm was designed for verbs, we added a few extra rules to handle non-verbal predicates: we added 1) the predicate itself as a candidate argument, 2) the span ranging from the sentence position to the right of the pred-icate to the rightmost index of the subtree headed by the predicate X  X  head; this helped capture cases like  X  X  few months  X  (where few is the predicate and months is the argument), and 3) the span ranging from the leftmost index of the subtree headed by the predicate X  X  head to the position immediately before the predicate, for cases like  X  X our gift to Goodwill X  (where to is the predicate and your gift Frame Lexicon In our experimental setup, we scanned the XML files in the  X  X rames X  directory of the FrameNet 1.5 release, which lists all the frames, the corresponding roles and the associ-ated lexical units, and created a frame lexicon to be used in our frame and argument identification models. We noted that this renders every lexical unit as seen ; in other words, at frame disambigua-tion time on our test set, for all instances, we only had to score the frames in F ` for a predicate with lexical unit ` (see  X  3 and  X  5.2). We call this setup of the art on the same corpus, we noted that Das et al. (2014) found several unseen predicates at test units for the predicates that Das et al. considered as seen, and constructed a lexicon with only those; training instances, if any, for the unseen predicates under Das et al. X  X  setup were thrown out as well. experimented on the set of unseen instances used by Das et al.
 ILP constraints For FrameNet, we used three ILP constraints during argument identification (  X  4). 1) each span could have only one role, 2) each core role could be present only once, and 3) all overt arguments had to be non-overlapping. 5.5 Experimental Setup for PropBank Hyperparameters As in  X  5.4, we made a hyper-parameter sweep in the same space. The chosen learning rate was 0 . 01 , while the other values were  X  = 0 . 01 and m = 512 . Ambiguous lexical units were used for this selection process.
 Argument Candidates For PropBank we use the algorithm of Xue and Palmer (2004) applied to dependency trees.
 Frame Lexicon For the PropBank experiments we scanned the frame files for propositions in Ontonotes 4.0, and stored possible core roles for each verb frame. The lexical units were simply the verb associating with the verb frames. There were no unseen verbs at test time.
 ILP constraints We used the constraints of Pun-yakanok et al. (2008). 5.6 FrameNet Results Table 2 presents accuracy results on frame iden-ambiguous predicates seen in the lexicon or the training data, and rare ambiguous predicates that appear  X  11 times in the training data. The W S -we also compare with the state of the art from Das et al. (2014), who used a semi-supervised learn-ing method to improve upon a supervised latent-variable log-linear model. For unseen predicates from the Das et al. system, we perform better as well. Finally, for the F ULL L EXICON setting, the ab-solute accuracy numbers are even better for our best model. Table 3 presents results on the full frame-semantic parsing task (measured by a reim-plementation of the SemEval 2007 shared task evaluation script) when our argument identifica-tion model (  X  4) is used after frame identification. We notice similar trends as in Table 2, and our re-sults outperform the previously published best re-sults, setting a new state of the art. 5.7 PropBank Results Table 4 shows frame identification results on the PropBank data. On the development set, our best model performs with the highest accuracy on all and ambiguous predicates, but performs worse on rare ambiguous predicates. On the test set, the very narrow margin. See  X  6 for a discussion.
Table 5 presents results where we measure pre-cision, recall and F 1 for frames and arguments to-gether; this strict metric penalizes arguments for mismatched frames, like in Table 3. We see the same trend as in Table 4. Finally, Table 6 presents SRL results that measures argument performance only, irrespective of the frame; we use the eval-uation script from CoNLL 2005 (Carreras and M ` arquez, 2005). We note that with a better frame identification model, our performance on SRL im-proves in general. Here, too, the embedding model barely misses the performance of the best baseline, but we are at par and sometimes better than the sin-gle parser setting of a state-of-the-art SRL system propose strongly outperforms the baselines on all metrics, and sets a new state of the art. We be-(that uses the same input representation) because the former setting allows examples with differ-ent labels and confusion sets to share informa-tion; this is due to the fact that all labels live in the same label space, and a single projection ma-trix is shared across the examples to map the input features to this space. Consequently, the W SABIE
MBEDDING model can share more information be-tween different examples in the training data than that the primary benefit does not come from the On the PropBank data, we see that the L OG -formance as our model on most metrics: slightly better on the test data and slightly worse on the development data. This can be partially explained with the significantly larger training set size for PropBank, making features based on words more useful. Another important distinction between PropBank and FrameNet is that the latter shares frames between multiple lexical units. The ef-fect of this is clearly observable from the  X  X are X  performs well. Part of the explanation has to do with the specifics of W SABIE training. Recall that the label location in R m for each frame. In other words, it must estimate 512 parameters based on at most 10 training examples. However, since the input representation is shared across all frames, every other training example from all the lexical units affects the optimal estimate, since they all modify the joint parameter matrix M . By contrast, in the log-linear models each label has its own set of parameters, and they interact only via the model does not have this entanglement, but cannot share information between words. For PropBank, these drawbacks and benefits balance out and we mating the label embedding is not as much of a problem because even if a lexical unit is rare, the potential frames can be frequent. For example, we might have seen the S ENDING frame many times, even though telex .V is a rare lexical unit.
In comparison to prior work on FrameNet, even our baseline models outperform the previous state of the art. A particularly interesting comparison is supervised model of Das et al. (2014). They also use a log-linear model, but they incorporate a la-tent variable that uses WordNet (Fellbaum, 1998) to get lexical-semantic relationships and smooths over frames for ambiguous lexical units. It is possible that this reduces the model X  X  power and causes it to over-generalize. Another difference is that when training the log-linear model, they nor-malize over all frames, while we normalize over the allowed frames for the current lexical unit. This would tend to encourage their model to ex-pend more of its modeling power to rule out pos-sibilities that will be pruned out at test time. We have presented a simple model that outper-forms the prior state of the art on FrameNet-style frame-semantic parsing, and performs at par with one of the previous-best single-parser sys-tems on PropBank SRL. Unlike Das et al. (2014), our model does not rely on heuristics to con-struct a similarity graph and leverage WordNet; hence, in principle it is generalizable to varying domains, and to other languages. Finally, we pre-sented results on PropBank-style semantic role la-beling with a system that included the task of au-tomatic verb frame identification, in tune with the FrameNet literature; we believe that such a sys-tem produces more interpretable output, both from the perspective of human understanding as well as downstream applications, than pipelines that are oblivious to the verb frame, only focusing on ar-gument analysis.
 We thank Emily Pitler for comments on an early draft, and the anonymous reviewers for their valu-able feedback.
Number Filename dev-1 LUCorpus-v0.3 20000420 xin eng-NEW.xml dev-2 NTI SouthAfrica Introduction.xml dev-4 LUCorpus-v0.3 AFGP-2002-600045-Trans.xml dev-5 PropBank TicketSplitting.xml dev-6 Miscellaneous Hijack.xml dev-7 LUCorpus-v0.3 artb 004 A1 E1 NEW.xml dev-8 NTI WMDNews 042106.xml dev-9 C-4 C-4Text.xml dev-10 ANC EntrepreneurAsMadonna.xml dev-11 NTI LibyaCountry1.xml dev-12 NTI NorthKorea NuclearOverview.xml dev-13 LUCorpus-v0.3 20000424 nyt-NEW.xml dev-14 NTI WMDNews 062606.xml dev-15 ANC 110CYL070.xml dev-16 LUCorpus-v0.3 CNN ENG 20030614 173123.4-NEW-1.xml Table 7 features a list of the 16 randomly selected documents from the FrameNet 1.5 corpus, which we used for development. The resultant develop-ment set consists of roughly 4,500 predicates. We use the same test set as in Das et al. (2014), con-taining 23 documents and 4,458 predicates.
 Distributed representations of words have proved useful for a number of tasks. By providing richer representations of meaning than what can be en-compassed in a discrete representation, such ap-proaches have successfully been applied to tasks such as sentiment analysis (Socher et al., 2011), topic classification (Klementiev et al., 2012) or word-word similarity (Mitchell and Lapata, 2008).
We present a new technique for semantic frame identification that leverages distributed word rep-resentations. According to the theory of frame se-mantics (Fillmore, 1982), a semantic frame rep-resents an event or scenario, and possesses frame elements (or semantic roles ) that participate in the event. Most work on frame-semantic parsing has usually divided the task into two major subtasks: frame identification , namely the disambiguation of a given predicate to a frame, and argument iden-tification (or semantic role labeling), the analysis of words and phrases in the sentential context that satisfy the frame X  X  semantic roles (Das et al., 2010; Das et al., 2014). 1 Here, we focus on the first sub-task of frame identification for given predicates; we use our novel method (  X  3) in conjunction with a standard argument identification model (  X  4) to perform full frame-semantic parsing.

We present experiments on two tasks. First, we show that for frame identification on the FrameNet corpus (Baker et al., 1998; Fillmore et al., 2003), we outperform the prior state of the art (Das et al., 2014). Moreover, for full frame-semantic parsing, with the presented frame identification technique followed by our argument identification method, we report the best results on this task to date. Sec-ond, we present results on PropBank-style seman-tic role labeling (Palmer et al., 2005; Meyers et al., 2004; M ` arquez et al., 2008), that approach strong baselines, and are on par with prior state of the art (Punyakanok et al., 2008). Early work in frame-semantic analysis was pio-neered by Gildea and Jurafsky (2002). Subsequent work in this area focused on either the FrameNet or PropBank frameworks, and research on the lat-ter has been more popular. Since the CoNLL 2004-2005 shared tasks (Carreras and M ` arquez, 2004; Carreras and M ` arquez, 2005) on PropBank semantic role labeling (SRL), it has been treated as an important NLP problem. However, research has mostly focused on argument analysis, skipping the frame disambiguation step, and its interaction with argument identification. 2.1 Frame-Semantic Parsing Closely related to SRL, frame-semantic parsing consists of the resolution of predicate sense into a frame, and the analysis of the frame X  X  argu-ments. Work in this area exclusively uses the FrameNet full text annotations. Johansson and Nugues (2007) presented the best performing sys-tem at SemEval 2007 (Baker et al., 2007), and Das et al. (2010) improved performance, and later set the current state of the art on this task (Das et al., 2014). We briefly discuss FrameNet, and subse-quently PropBank annotation conventions here. FrameNet The FrameNet project (Baker et al., 1998) is a lexical database that contains informa-tion about words and phrases (represented as lem-mas conjoined with a coarse part-of-speech tag) termed as lexical units, with a set of semantic frames that they could evoke. For each frame, there is a list of associated frame elements (or roles, henceforth), that are also distinguished as core or non-core. 2 Sentences are annotated us-ing this universal frame inventory. For exam-ple, consider the pair of sentences in Figure 1(a). morphological variants of the two example lexical units buy .V and sell .V. Buyer , Seller and Goods are some example roles for this frame. PropBank The PropBank project (Palmer et al., 2005) is another popular resource related to se-mantic role labeling. The PropBank corpus has verbs annotated with sense frames and their ar-guments. Like FrameNet, it also has a lexi-cal database that stores type information about verbs, in the form of sense frames and the possi-ble semantic roles each frame could take. There are modifier roles that are shared across verb frames, somewhat similar to the non-core roles in FrameNet. Figure 1(b) shows annotations for two verbs  X  X ought X  and  X  X old X , with their lemmas (akin to the lexical units in FrameNet) and their verb frames buy.01 and sell.01 . Generic core role labels (of which there are seven, namely A0 -A5 and A key difference between the two annotation sys-tems is that PropBank uses a local frame inven-tory, where frames are predicate-specific. More-over, role labels, although few in number, take spe-cific meaning for each verb frame. Figure 1 high-lights this difference: while both sell . V and buy . V are members of the same frame in FrameNet, they evoke different frames in PropBank. In spite of this difference, nearly identical statistical models could be employed for both frameworks.
 Modeling In this paper, we model the frame-semantic parsing problem in two stages: frame identification and argument identification . As mentioned in  X  1, these correspond to a frame dis-ambiguation stage, 4 and a stage that finds the var-ious arguments that fulfill the frame X  X  semantic roles within the sentence, respectively. This re-sembles the framework of Das et al. (2014), who solely focus on FrameNet corpora, unlike this pa-per. The novelty of this paper lies in the frame identification stage (  X  3). Note that this two-stage approach is unusual for the PropBank corpora when compared to prior work, where the vast ma-jority of published papers have not focused on the verb frame disambiguation problem at all, only fo-cusing on the role labeling stage (see the overview paper of M ` arquez et al. (2008) for example). 2.2 Distributed Frame Identification We present a model that takes word embeddings as input and learns to identify semantic frames. A word embedding is a distributed representa-tion of meaning where each word is represented as a vector in R n . Such representations allow a model to share meaning between similar words, and have been used to capture semantic, syntac-tic and morphological content (Collobert and We-ston, 2008; Turian et al., 2010, inter alia ). We use word embeddings to represent the syntactic con-text of a particular predicate instance as a vector. For example, consider the sentence  X  X e runs the company. X  The predicate runs has two syntac-tic dependents  X  a subject and direct object (but no prepositional phrases or clausal complements). We could represent the syntactic context of runs as a vector with blocks for all the possible dependents warranted by a syntactic parser; for example, we could assume that positions 0 ...n in the vector correspond to the subject dependent, n +1 ... 2 n correspond to the clausal complement dependent, and so forth. Thus, the context is a vector in R nk with the embedding of He at the subject position, the embedding of company in direct object posi-tion and zeros everywhere else. Given input vec-tors of this form for our training data, we learn a matrix that maps this high dimensional and sparse representation into a lower dimensional space. Si-multaneously, the model learns an embedding for all the possible labels (i.e. the frames in a given lexicon). At inference time, the predicate-context is mapped to the low dimensional space, and we choose the nearest frame label as our classifica-tion. We next describe this model in detail. We continue using the example sentence from  X  2.2:  X  X e runs the company. X  where we want to disambiguate the frame of runs in context. First, we extract the words in the syntactic context of runs ; next, we concatenate their word embeddings as described in  X  2.2 to create an initial vector space representation. Subsequently, we learn a map-ping from this initial representation into a low-dimensional space; we also learn an embedding for each possible frame label in the same low-dimensional space. The goal of learning is to make sure that the correct frame label is as close as possible to the mapped context, while competing frame labels are farther away.

Formally, let x represent the actual sentence with a marked predicate, along with the associated syntactic parse tree; let our initial representation of the predicate context be g ( x ) . Suppose that the word embeddings we start with are of dimension n . Then g is a function from a parsed sentence x to R nk , where k is the number of possible syn-tactic context types. For example g selects some important positions relative to the predicate, and reserves a block in its output space for the embed-ding of words found at that position. Suppose g considers clausal complements and direct objects. Then g : X  X  R 2 n and for the example sentence it has zeros in positions 0 ...n and the embedding of the word company in positions n +1 ... 2 n . Section 3.1 describes the context positions we use in our experiments. Let the low dimensional space we map to be R m and the learned mapping be M : R nk  X  R m . The mapping M is a linear trans-formation, and we learn it using the W SABIE algo-rithm (Weston et al., 2011). W SABIE also learns an embedding for each frame label ( y , henceforth). In our setting, this means that each frame corre-sponds to a point in R m . If we have F possi-ble frames we can store those parameters in an F  X  m matrix, one m -dimensional point for each frame, which we will refer to as the linear map-ping Y . Let the lexical unit (the lemma conjoined with a coarse POS tag) for the marked predicate be ` . We denote the frames that associate with ` in the frame lexicon 5 and our training corpus as F ` . W SABIE performs gradient-based updates on an objective that tries to minimize the distance between M ( g ( x )) and the embedding of the cor-rect label Y ( y ) , while maintaining a large distance between M ( g ( x )) and the other possible labels Y (  X  y ) in the confusion set F ` . At disambiguation time, we use a simple dot product similarity as our distance metric, meaning that the model chooses a label by computing the argmax y s ( x,y ) where s ( x,y ) = M ( g ( x ))  X  Y ( y ) , where the argmax iter-ates over the possible frames y  X  F ` if ` was seen in the lexicon or the training data, or y  X  F , if it was unseen. 6 Model learning is performed using the margin ranking loss function as described in Weston et al. (2011), and in more detail in section 3.2.

Since W SABIE learns a single mapping from g ( x ) to R m , parameters are shared between different words and different frames. So for example  X  X e runs the company X  could help the model disam-biguate  X  X e owns the company. X  Moreover, since g ( x ) relies on word embeddings rather than word identities, information is shared between words. For example  X  He runs the company  X  could help us to learn about  X  She runs a corporation  X . 3.1 Context Representation Extraction In principle g ( x ) could be any feature function, but we performed an initial investigation of two partic-ular variants. In both variants, our representation is a block vector where each block corresponds to a syntactic position relative to the predicate, and each block X  X  values correspond to the embedding of the word at that position.
 Direct Dependents The first context function we considered corresponds to the examples in  X  3. To elaborate, the positions of interest are the labels of the direct dependents of the predicate, so k is the number of labels that the dependency parser can produce. For example, if the label on the edge be-tween runs and He is nsubj , we would put the em-bedding of He in the block corresponding to nsubj . If a label occurs multiple times, then the embed-dings of the words below this label are averaged.
Unfortunately, using only the direct dependents can miss a lot of useful information. For exam-ple, topicalization can place discriminating infor-mation farther from the predicate. Consider  X  X e runs the company . X  vs.  X  X t was the company that he runs . X  In the second sentence, the discrim-inating word, company dominates the predicate runs . Similarly, predicates in embedded clauses may have a distant agent which cannot be captured using direct dependents. Consider  X  The athlete ran the marathon. X  vs.  X  The athlete prepared him-self for three months to run the marathon. X  In the second example, for the predicate run , the agent The athlete is not a direct dependent, but is con-nected via a longer dependency path.
 Dependency Paths To capture more relevant context, we developed a second context function as follows. We scanned the training data for a given task (either the PropBank or the FrameNet domains) for the dependency paths that connected the gold predicates to the gold semantic argu-ments. This set of dependency paths were deemed as possible positions in the initial vector space rep-resentation. In addition, akin to the first context function, we also added all dependency labels to the context set. Thus for this context function, the block cardinality k was the sum of the number of scanned gold dependency path types and the num-ber of dependency labels. Given a predicate in its sentential context, we therefore extract only those context words that appear in positions warranted by the above set. See Figure 2 for an illustration of this process.

We performed initial experiments using con-text extracted from 1) direct dependents, 2) de-pendency paths, and 3) both. For all our experi-ments, setting 3) which concatenates the direct de-pendents and dependency path always dominated the other two, so we only report results for this setting. 3.2 Learning We model our objective function following We-ston et al. (2011), using a weighted approximate-rank pairwise loss, learned with stochastic gradi-ent descent. The mapping from g ( x ) to the low dimensional space R m is a linear transformation, so the model parameters to be learnt are the matrix M  X  R nk  X  m as well as the embedding of each possible frame label, represented as another ma-trix Y  X  R F  X  m where there are F frames in total. The training objective function minimizes: X where x,y are the training inputs and their cor-responding correct frames, and  X  y are negative frames,  X  is the margin. Here, rank y ( x ) is the rank of the positive frame y relative to all the neg-ative frames: and L (  X  ) converts the rank to a weight. Choos-ing L (  X  ) = C X  for any positive constant C opti-mizes the mean rank, whereas a weighting such as L (  X  ) = P  X  i =1 1 /i (adopted here) optimizes the top of the ranked list, as described in (Usunier et al., 2009). To train with such an objective, stochastic gradient is employed. For speed the computation of rank y ( x ) is then replaced with a sampled approximation: sample N items  X  y until a violation is found, i.e. max(0 , X  + s ( x,  X  y )  X  s ( x,y ))) &gt; 0 and then approximate the rank with ( F  X  1) /N , see Weston et al. (2011) for more details on this procedure. For the choices of the stochastic gradient learning rate, margin (  X  ) and dimensionality ( m ), please refer to  X  5.4- X  5.5.
Note that an alternative approach could learn only the matrix M , and then use a k -nearest neigh-bor classifier in R m , as in Weinberger and Saul (2009). The advantage of learning an embedding for the frame labels is that at inference time we need to consider only the set of labels for classi-fication rather than all training examples. Addi-tionally, since we use a frame lexicon that gives us the possible frames for a given predicate, we usually only consider a handful of candidate la-bels. If we used all training examples for a given predicate for finding a nearest-neighbor match at inference time, we would have to consider many more candidates, making the process very slow. Here, we briefly describe the argument identifi-cation model used in our frame-semantic parsing experiments, post frame identification. Given x , the sentence with a marked predicate, the argu-ment identification model assumes that the pred-icate frame y has been disambiguated. From a frame lexicon, we look up the set of semantic roles R y that associate with y . This set also contains the null role r  X  . From x , a rule-based candidate argu-ment extraction algorithm extracts a set of spans A that could potentially serve as the overt 7 argu-ments A y for y (see  X  5.4- X  5.5 for the details of the candidate argument extraction algorithms).
 Learning Given training data of the form a set of tuples that associates each role r in R y with a span a according to the gold data. Note that this mapping associates spans with the null role r  X  as well. We optimize the following log-likelihood to train our model: max where p  X  is a log-linear model normalized over the set R y , with features described in Table 1. We set C = 1 . 0 and use L-BFGS (Liu and Nocedal, 1989) for training.
 Inference Although our learning mechanism uses a local log-linear model, we perform infer-ence globally on a per-frame basis by applying hard structural constraints. Following Das et al. (2014) and Punyakanok et al. (2008) we use the log-probability of the local classifiers as a score in an integer linear program (ILP) to assign roles sub-ject to hard constraints described in  X  5.4 and  X  5.5. We use an off-the-shelf ILP solver for inference. In this section, we present our experiments and the results achieved. We evaluate our novel frame identification approach in isolation and also con-joined with argument identification resulting in full frame-semantic structures; before presenting our model X  X  performance we first focus on the datasets, baselines and the experimental setup. 5.1 Data We evaluate our models on both FrameNet-and PropBank-style structures. For FrameNet, we use the full-text annotations in the FrameNet 1.5 re-lease 8 which was used by Das et al. (2014,  X  3.2). We used the same test set as Das et al. contain-ing 23 documents with 4,458 predicates. Of the remaining 55 documents, 16 documents were ran-domly chosen for development. 9 For experiments with PropBank, we used the Ontonotes corpus (Hovy et al., 2006), version 4.0, and only made use of the Wall Street Journal doc-uments; we used sections 2-21 for training, sec-tion 24 for development and section 23 for testing. This resembles the setup used by Punyakanok et al. (2008). All the verb frame files in Ontonotes were used for creating our frame lexicon. 5.2 Frame Identification Baselines For comparison, we implemented a set of baseline models, with varying feature configurations. The baselines use a log-linear model that models the following probability at training time: At test time, this model chooses the best frame as argmax y  X   X  f ( y,x,` ) where argmax iterates over the possible frames y  X  F ` if ` was seen in the lexicon or the training data, or y  X  F , if it was un-seen, like the disambiguation scheme of  X  3. We train this model by maximizing L 2 regularized log-likelihood, using L-BFGS; the regularization constant was set to 0.1 in all experiments.

For comparison with our model from  X  3, which baselines with the log-linear model. Both the baselines use features very similar to the input rep-resentations described in  X  3.1. The first one com-putes the direct dependents and dependency paths as described in  X  3.1 but conjoins them with the word identity rather than a word embedding. Ad-ditionally, this model uses the un-conjoined words as backoff features. This would be a standard NLP approach for the frame identification problem, but is surprisingly competitive with the state of the art. ond baseline, tries to decouple the W SABIE training from the embedding input, and trains a log linear model using the embeddings. So the second base-line has the same input representation as W SABIE MBEDDING but uses a log-linear model instead of 5.3 Common Experimental Setup We process our PropBank and FrameNet training, development and test corpora with a shift-reduce dependency parser that uses the Stanford conven-tions (de Marneffe and Manning, 2013) and uses an arc-eager transition system with beam size of 8; the parser and its features are described by Zhang and Nivre (2011). Before parsing the data, it is tagged with a POS tagger trained with a condi-tional random field (Lafferty et al., 2001) with the following emission features: word, the word clus-ter, word suffixes of length 1, 2 and 3, capitaliza-tion, whether it has a hyphen, digit and punctua-tion. Beyond the bias transition feature, we have two cluster features for the left and right words in the transition. We use Brown clusters learned us-ing the algorithm of Uszkoreit and Brants (2008) on a large English newswire corpus for cluster fea-tures. We use the same word clusters for the argu-ment identification features in Table 1.

We learn the initial embedding representations for our frame identification model (  X  3) using a deep neural language model similar to the one pro-posed by Bengio et al. (2003). We use 3 hidden layers each with 1024 neurons and learn a 128-dimensional embedding from a large corpus con-taining over 100 billion tokens. In order to speed up learning, we use an unnormalized output layer and a hinge-loss objective. The objective tries to ensure that the correct word scores higher than a random incorrect word, and we train with mini-batch stochastic gradient descent. 5.4 Experimental Setup for FrameNet Hyperparameters For our frame identification model with embeddings, we search for the W SA -BIE hyperparameters using the development data. We search for the stochastic gradient learning rate in { 0 . 0001 , 0 . 001 , 0 . 01 } , the margin  X   X  { 0 . 001 , 0 . 01 , 0 . 1 , 1 } and the dimensionality of the final vector space m  X  { 256 , 512 } , to maximize the frame identification accuracy of ambiguous lexical units; by ambiguous, we imply lexical units that appear in the training data or the lexicon with more than one semantic frame. The underlined values are the chosen hyperparameters used to an-alyze the test data.
 Argument Candidates The candidate argument extraction method used for the FrameNet data, (as mentioned in  X  4) was adapted from the algorithm of Xue and Palmer (2004) applied to dependency trees. Since the original algorithm was designed for verbs, we added a few extra rules to handle non-verbal predicates: we added 1) the predicate itself as a candidate argument, 2) the span ranging from the sentence position to the right of the pred-icate to the rightmost index of the subtree headed by the predicate X  X  head; this helped capture cases like  X  X  few months  X  (where few is the predicate and months is the argument), and 3) the span ranging from the leftmost index of the subtree headed by the predicate X  X  head to the position immediately before the predicate, for cases like  X  X our gift to Goodwill X  (where to is the predicate and your gift is the argument). 10 Frame Lexicon In our experimental setup, we scanned the XML files in the  X  X rames X  directory of the FrameNet 1.5 release, which lists all the frames, the corresponding roles and the associ-ated lexical units, and created a frame lexicon to be used in our frame and argument identification models. We noted that this renders every lexical unit as seen ; in other words, at frame disambigua-tion time on our test set, for all instances, we only had to score the frames in F ` for a predicate with lexical unit ` (see  X  3 and  X  5.2). We call this setup of the art on the same corpus, we noted that Das et al. (2014) found several unseen predicates at test time. 11 For fair comparison, we took the lexical units for the predicates that Das et al. considered as seen, and constructed a lexicon with only those; training instances, if any, for the unseen predicates under Das et al. X  X  setup were thrown out as well. experimented on the set of unseen instances used by Das et al.
 ILP constraints For FrameNet, we used three ILP constraints during argument identification (  X  4). 1) each span could have only one role, 2) each core role could be present only once, and 3) all overt arguments had to be non-overlapping. 5.5 Experimental Setup for PropBank Hyperparameters As in  X  5.4, we made a hyper-parameter sweep in the same space. The chosen learning rate was 0 . 01 , while the other values were  X  = 0 . 01 and m = 512 . Ambiguous lexical units were used for this selection process.
 Argument Candidates For PropBank we use the algorithm of Xue and Palmer (2004) applied to dependency trees.
 Frame Lexicon For the PropBank experiments we scanned the frame files for propositions in Ontonotes 4.0, and stored possible core roles for each verb frame. The lexical units were simply the verb associating with the verb frames. There were no unseen verbs at test time.
 ILP constraints We used the constraints of Pun-yakanok et al. (2008). 5.6 FrameNet Results Table 2 presents accuracy results on frame iden-tification. 13 We present results on all predicates, ambiguous predicates seen in the lexicon or the training data, and rare ambiguous predicates that appear  X  11 times in the training data. The W S -we also compare with the state of the art from Das et al. (2014), who used a semi-supervised learn-ing method to improve upon a supervised latent-variable log-linear model. For unseen predicates from the Das et al. system, we perform better as well. Finally, for the F ULL L EXICON setting, the ab-solute accuracy numbers are even better for our best model. Table 3 presents results on the full frame-semantic parsing task (measured by a reim-plementation of the SemEval 2007 shared task evaluation script) when our argument identifica-tion model (  X  4) is used after frame identification. We notice similar trends as in Table 2, and our re-sults outperform the previously published best re-sults, setting a new state of the art. 5.7 PropBank Results Table 4 shows frame identification results on the PropBank data. On the development set, our best model performs with the highest accuracy on all and ambiguous predicates, but performs worse on rare ambiguous predicates. On the test set, the very narrow margin. See  X  6 for a discussion.
Table 5 presents results where we measure pre-cision, recall and F 1 for frames and arguments to-gether; this strict metric penalizes arguments for mismatched frames, like in Table 3. We see the same trend as in Table 4. Finally, Table 6 presents SRL results that measures argument performance only, irrespective of the frame; we use the eval-uation script from CoNLL 2005 (Carreras and M ` arquez, 2005). We note that with a better frame identification model, our performance on SRL im-proves in general. Here, too, the embedding model barely misses the performance of the best baseline, but we are at par and sometimes better than the sin-gle parser setting of a state-of-the-art SRL system (Punyakanok et al., 2008). 14 propose strongly outperforms the baselines on all metrics, and sets a new state of the art. We be-(that uses the same input representation) because the former setting allows examples with differ-ent labels and confusion sets to share informa-tion; this is due to the fact that all labels live in the same label space, and a single projection ma-trix is shared across the examples to map the input features to this space. Consequently, the W SABIE
MBEDDING model can share more information be-tween different examples in the training data than that the primary benefit does not come from the input embedding representation. 15 On the PropBank data, we see that the L OG -formance as our model on most metrics: slightly better on the test data and slightly worse on the development data. This can be partially explained with the significantly larger training set size for PropBank, making features based on words more useful. Another important distinction between PropBank and FrameNet is that the latter shares frames between multiple lexical units. The ef-fect of this is clearly observable from the  X  X are X  performs well. Part of the explanation has to do with the specifics of W SABIE training. Recall that the label location in R m for each frame. In other words, it must estimate 512 parameters based on at most 10 training examples. However, since the input representation is shared across all frames, every other training example from all the lexical units affects the optimal estimate, since they all modify the joint parameter matrix M . By contrast, in the log-linear models each label has its own set of parameters, and they interact only via the model does not have this entanglement, but cannot share information between words. For PropBank, these drawbacks and benefits balance out and we mating the label embedding is not as much of a problem because even if a lexical unit is rare, the potential frames can be frequent. For example, we even though telex .V is a rare lexical unit.
In comparison to prior work on FrameNet, even our baseline models outperform the previous state of the art. A particularly interesting comparison is supervised model of Das et al. (2014). They also use a log-linear model, but they incorporate a la-tent variable that uses WordNet (Fellbaum, 1998) to get lexical-semantic relationships and smooths over frames for ambiguous lexical units. It is possible that this reduces the model X  X  power and causes it to over-generalize. Another difference is that when training the log-linear model, they nor-malize over all frames, while we normalize over the allowed frames for the current lexical unit. This would tend to encourage their model to ex-pend more of its modeling power to rule out pos-sibilities that will be pruned out at test time. We have presented a simple model that outper-forms the prior state of the art on FrameNet-style frame-semantic parsing, and performs at par with one of the previous-best single-parser sys-tems on PropBank SRL. Unlike Das et al. (2014), our model does not rely on heuristics to con-struct a similarity graph and leverage WordNet; hence, in principle it is generalizable to varying domains, and to other languages. Finally, we pre-sented results on PropBank-style semantic role la-beling with a system that included the task of au-tomatic verb frame identification, in tune with the FrameNet literature; we believe that such a sys-tem produces more interpretable output, both from the perspective of human understanding as well as downstream applications, than pipelines that are oblivious to the verb frame, only focusing on ar-gument analysis.
 We thank Emily Pitler for comments on an early draft, and the anonymous reviewers for their valu-able feedback.

Number Filename dev-1 LUCorpus-v0.3 20000420 xin eng-NEW.xml dev-2 NTI SouthAfrica Introduction.xml dev-4 LUCorpus-v0.3 AFGP-2002-600045-Trans.xml dev-5 PropBank TicketSplitting.xml dev-6 Miscellaneous Hijack.xml dev-7 LUCorpus-v0.3 artb 004 A1 E1 NEW.xml dev-8 NTI WMDNews 042106.xml dev-9 C-4 C-4Text.xml dev-10 ANC EntrepreneurAsMadonna.xml dev-11 NTI LibyaCountry1.xml dev-12 NTI NorthKorea NuclearOverview.xml dev-13 LUCorpus-v0.3 20000424 nyt-NEW.xml dev-14 NTI WMDNews 062606.xml dev-15 ANC 110CYL070.xml dev-16 LUCorpus-v0.3 CNN ENG 20030614 173123.4-NEW-1.xml Table 7 features a list of the 16 randomly selected documents from the FrameNet 1.5 corpus, which we used for development. The resultant develop-ment set consists of roughly 4,500 predicates. We use the same test set as in Das et al. (2014), con-
