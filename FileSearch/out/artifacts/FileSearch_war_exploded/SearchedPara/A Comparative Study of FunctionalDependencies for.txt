 Integrity constraints play major roles in ensuring data consistency in traditional database systems. Among them functional dependencies (FDs) are of particular interest because of their ubiquity, simplicity and applications to database design as well as to maintaining data integrity. It is therefore natural to extend the concept of FDs to XML data, and such attempts have been made by several groups of researchers [1, 2, 3, 4, 5, 6, 7, 8, 9].
 tending FDs to XML is not a trivial task, and not surprisingly, all definitions of FDs for XML so far capture different types of constraints. In this paper, we first survey and compare previous XML functional dependencies (XFDs) in terms of the constraints they express, in particular we show the equivalence of the XFDs in [3] and [5] when there are no null values. We then propose a generalized XFD (GXFD) which is a generalization of the previous XFDs. We show how our GXFDs can be used to express some natural constraints that cannot be captured by previous XFDs, and hence to detect more redundancies in XML data. nary terminology and notations. Section 3 surveys and compares the XFDs in previous work. Section 4 presents our generalized XFDs and shows how they generalize and extend the previous XFDs. Section 5 concludes the paper with a brief discussion about future work.
 In this section, we introduce the basic definitions, some of which are modified from [9, 3, 10]. We assume the existence of three pairwise disjoint sets E 1 , E 2 and A of labels . The labels in E 1 , E 2 and A represent complex element names, simple element names, and attribute names respectively. Let E = E 1  X  E 2 . Scheme file. An (XML) scheme file is defined to be S =( E 1 ,E 2 ,A,P,R,r ) where E 1  X  E 1 is a finite set of complex element names; E 2  X  E 2 is a finite set of simple element names; A  X  A is a finite set of attribute names . P is a mapping from E 1 to element type definitions:  X   X   X  E 1 , P (  X  ) is a regular expression where  X  is the empty sequence,  X   X  E 1  X  E 2 , and  X  |  X  ,  X , X , and  X * X  denote union, concatenation, and the Kleene closure respectively; R is a mapping from E 1 to distinct element name, which is the only label in E 1 that does not appear in the alphabet of P (  X  ) for any  X   X  E 1 .
 XML tree. An XML tree is defined to be T =( V, lab, ele, att, val, root ), where (1) V is a set of nodes; (2) lab is a mapping from V to E  X  A which assigns a label to each node in V ;anode v  X  V is called a complex element node if lab ( v )  X  E 1 ,a simple element node if lab ( v )  X  E 2 , and an attribute node if lab ( v )  X  A . (3) ele and att are functions from the set of complex elements in V : for every v  X  V ,if lab ( v )  X  E 1 then ele ( v ) is a sequence of element nodes, and att ( v )is a set of attribute nodes with distinct labels; (4) val is a function that assigns a value to each attribute or simple element. (5) root is the unique root node. (6) defined by ele and att form a tree rooted at root .
 Conformity. T is said to conform to S if (1) lab ( root )= r , (2) lab maps every node in V to E 1  X  E 2  X  A , and (3) for every complex element node v  X  V , { lab ( v 1 ) ,...,lab ( v m ) } X  R ( lab ( v )).
 scheme file, complex elements appear to the left of  X ::= X , their type definitions are shown in the parenthesis to the right of  X ::= X , and their attributes (in the set R (  X  )) are inside curved braces. We also use the convention that simple elements start with $, and attributes start with @.
 Value equality. Let v 1 and v 2 be nodes in T . We say that v 1 and v 2 are value and (1) their sequence of child elements are pairwise value equal; (2) for every attribute  X  of v 1 , there is an attribute  X  of v 2 such that  X  = v  X  and vice versa. Clearly if v 1 and v 2 are the same node (denoted v 1 = v 2 ), then v 1 = v v 2 . Paths. Let S =( E 1 ,E 2 ,A,P,R,r ) be a scheme file. We are interested in the following types of paths in S .
 E l m is in the alphabet of P ( l m  X  1 )orin R ( l m  X  1 ), and l 1 = r . The number of labels in a simple path is called the length of the path. The simple path with length 0 is called the empty path , denoted . The simple path is said to be an l .  X  X  X  .l k .l k is not the prefix of any other paths in paths ( S ) is called a full path in S . obtained from another downward path by replacing a label (except the last one) with , or by replacing a substring (that does not contain the last label) with  X  . In a downward path, the symbol represents a wildcard (which can match any label), and  X  represents the Kleene closure of the wildcard.
 require k  X  [1 ,M ], where M is the length of the longest simple path in S ), we will sometimes abbreviate the path as  X  k .
 simple path. An upward path is a special composite path.
 l .l i +1 .  X  X  X  .l k in S .
 Path instances, target set, and target list. Let T be an XML tree con-forming to S and v 0 beanodein T .An instance of a non-empty downward path l .  X  X  X  .l n wrt v if l l (note that the label of any node matches ); (2) if l i is  X  , then v i is v i  X  1 or a descendant of v i  X  1 .
 n ,...,n k , v 1 ,...,v n in T such that n 1 is the parent of v 0 , n i is the parent of n the label of v i matches l i for i  X  [1 ,n ].
 and call it the target set of p wrt v 0 .
 are visited in a pre-order traversal of T . We call this ordered list of nodes the target list of p wrt v 0 , denoted v 0 ( p ). XFDs have been defined in [1, 2, 3, 4, 5, 6, 7, 8, 9]. The XFDs in all but [8] are path based , namely, they are based on the paths in the scheme files and/or trees. Among them, [1],[3], [5, 6] and [4] are based on absolute paths, while [2], [7] and [9] allow for more general paths. The definition in [8] is subtree based , that is, it uses subtrees instead of paths in the definition. [i]. We will also use the following example constraints for the scheme file shown in the up left corner of Fig. 2 in our discussion. 3.1 XFDs Based on Absolute Paths The authors of [3], [5] and [6] regard a simple element as having a child node labelled S , under which is attached the value of the element. For example, using their notation the XML tree in Fig. 1 (b) will look like what is in Fig. 3 (b). XFD [ 3 ] . An XFD [ 3 ] is defined on a DTD which is the same as a scheme file except that there is no explicit distinction between simple and complex elements. However, an element in their DTDs may have a single text child labelled S , and these elements are exactly the same as our simple elements (see Fig. 3 (a)). Paths in the DTDs are of the form r.p , where p is the same as an absolute path defined in Section 2 except it can end up with the text label S . We will use P ( D )to denote the set of all paths in DTD D as defined in [3].
 thors treat a DTD D as a single relation schema, a path in P ( D ) as an attribute, and a tree-tuple a tuple in that relation. By definition, a tree-tuple is a mapping from P ( D ) to  X  X alues X : every path which ends with an element name is mapped to a distinct node ID or the null value (  X  ), and every other path is mapped to either a string value or  X  . For example, the DTD in Fig. 3 (a) is regarded as a relation schema consisting of the following attributes: An example tree-tuple maps the above relation schema to and the tree-tuple corresponds to a tree, as shown in Fig. 3 (c).
 by T if the tree obtained by removing the null value nodes from t is a subtree of T . A subsumed tree-tuple t is said to be maximal in T if one cannot replace a null value with a non-null value and leave t still subsumed by T . The tree T can then be thought of as consisting of a set of maximal tree-tuples. For example, the XML tree shown in Fig. 3 (b) can be regarded as an instance consisting of the (maximal tree) tuples where p i ,...,p n and q 1 ,...,q m are paths in P ( D ). An XML document con-forming to D is said to satisfy the XFD if for every two maximal tree-tuples t t ( q j )= t 2 ( q j ) for all j  X  [1 ,m ]. For example, the XML tree in Fig. 3 (b) satisfies the FD where p is the path school.course.students.student . Since all null values are considered to be equal, the tree also satisfies XFD [ 5 ] . XFD [ 5 ] is defined on a set P of closed paths, where a path is of the same form as that in [3], and  X  X losed X  means that if a path is in the set, then all prefixes of the path is also in the set. This set of paths plays the role of the XML scheme file. An XFD [ 5 ] is defined to be an expression of the form p ,p 2 ,  X  X  X  ,p n  X  q where p 1 ,...,p n and q are paths in P . Satisfaction of the dependency is defined for XML trees that comform to P , i.e, all absolute paths in T are paths in P . The satisfaction can be checked as follows. element, the value is a distinct node ID, otherwise the value is a string value. there is an instance v 1 ,...,v k of l 1 .....l k in T , but there is no path instance v values. The original tree T is said to have missing nodes . set of nodes that can be reached by following pre ( p i ,q ) from r ; (3) for each distinct path instance I of q , find the unique node x I,i , which is the common then find the set N I,i of nodes which are descendants of x I,i and can be reached i of I and J are not equal, then the XFD is satisfied by T .
 Fig. 3 (b) as follows: 1. Extend the XML tree by adding a $grade node under each student node, and a S node under each $grade node, and assign distinct null values to these nodes. 2. (1) The common prefix pre of the two paths in (i) is N not null, and only the values of the nodes in N I and N K are equal, but so are the values of last nodes in the corresponding path instances I and K . by the tree according to [5].
 Discussion. As seen above, except for the number of paths on the RHS, the XFDs in [5] and [3] are of the same form. Although the approaches of checking satisfaction of a XFD appear totally different, the actual type of constraints captured by the two are equivalent except for the treatment of null values. In fact, we can prove the following result.
 Proposition 1. Let D be a DTD, and T be an XML tree that conforms to D (so it also conforms to P ( D ) ). Suppose T has no missing nodes. Then every is satisfied by T .
 values. When null values (i.e, missing nodes) exist, the satisfaction of XFD [ 5 ] is a stronger condition than that of XFD [ 3 ] . For example, in the XML tree of Fig. 3, if we remove both v 11 and v 15 (or alternatively, if we remove v 10 ), then the XFD (i) is still considered satisfied by [3], but not by [5].
 is defined for documents conforming to a DTD, while XFD [ 5 ] is defined for documents conforming to a set of closed paths, some trivial XFDs in [3] may be non-trivial in [5]. This is because conforming to a DTD puts more restrictions on XML trees than conforming to the set of paths in the DTD. For example, suppose we have a DTD (in the definition of [3]) For documents conforming to the DTD, the XFD r.a  X  r.a.b is trivial be-cause every node labelled with a must have exactly one child labelled with b . But r.a  X  r.a.b is not trivial for documents conforming to the set of paths { r, r.a, r.a.b, r.a.c } .
 consider the value equality of complex element nodes, they cannot express the constraints (A), (B), (C) and (F) at the beginning of this section.
 XFD [ 6 ] . XFD [ 6 ] defines local XFDs of the form Q 1  X  w Q 2 , where Q 1 ,Q 2 are sets of paths, and w is a common prefix of the paths in Q 1 and Q 2 . The local XFDs are intended by the authors to capture constraints that hold in part of an XML tree determined by w .
 XFD [ 4 ] . [4] defines XFDs on DTDs, where DTDs and paths are the same as in [3]. XML trees are also defined similarly to that of [3], except a string value is assigned for every node (it is not explained what this value will be, however). Value-equality between two nodes v 1 and v 2 is defined in the same way as in [10], except the string values of v 1 and v 2 must also be equal. An XFD [ 4 ] over DTD P v Hence the XFDs in [4] cannot express the constraints (A) X (F) (assuming each leaf node is assigned its string value, and other nodes are assigned a common value).
 XFD [ 1 ] . The authors of [1] made the assumption that, in a scheme file, a label cannot appear in the alphabets of two different complex element names. An XFD is defined to be X  X  Y , where X, Y are sets of labels. Because of the assumption in the scheme file, there is a unique path from the root to a label, hence the XFD can be equivalently written as P X  X  P Y where P X ( P Y )isthe set of paths corresponding to X ( Y ). Satisfaction of the XFD is defined for a set of XML trees conforming to the scheme file rather than for a single tree. The constraint is said to be satisfied if for any two trees, if they agree on X , they must also agree on Y . Agreements of two trees T 1 and T 2 on a label means the intersection of the two sets of nodes that can be reached by following the unique path, from the roots of T 1 and T 2 respectively, have nodes that are value-equal. Hence the constraints expressed by XFD [ 1 ] are similar to those by XFD [ 4 ] . 3.2 XFDs Based on More General Paths XFD [ 2 ] . [2] uses XPaths to define XFDs among a set of XML subtrees. An XFD is defined as an expression ( Q, [ e 1 ,  X  X  X  ,e n  X  e n +1 ]) where Q is an XPath, and e i , for i  X  [1 ,n + 1], is either an element or an element followed by dot and a set of key attributes of the element. An XML tree is said to satisfy the XFD if for any two subtrees rooted at a node in root [ Q ], if they agree on the value of e For example, for the scheme file in Fig. 2, to say student number determines student name, we can use ( //student, [@ sno  X  @ name ]). While this seems to be more expressive than the XFDs in [3] and [5], it is generally not clear what the  X  X alue X  of an element means. For example, in Fig. 1 (b), the value of a students node is not defined. Apparently when e i is an element it must be a simple element so that its value has a meaning. But there is also a strong structural restriction on the elements involved in the XFD: if an element X  X  ancestor appears in the XFD, then so must its parent. This puts restrictions on the expressiveness. For example, to say course number and student number determines student X  X  grade in the course in Fig. 1 (b), we have to use the students node. This will cause trouble because we do not know the  X  X alue X  of the students nodes.
 XFD [ 7 ] . The XFDs in [7] are based on simple and downward paths that may contain  X  . So the XFDs may express constraints such as (A). However, no set equality or list equality is considered. Therefore the constraints (B), (C) and (F) cannot be captured.
 XFD [ 9 ] . We defined parameterized XFDs using simple, downward, upward and composite paths in [9]. The ordering of subelements is assumed to be insignificant in [9], and therefore, the conformity of trees to scheme files and the value equality are slightly different from those defined in Section 2. To unify and generalize the XFDs in other previous work, we will use the definitions in Section 2 and describe a modified parameterized XFD in Section 4. The details of XFD [ 9 ] will not be repeated here. 3.3 XFDs Based on Subtrees XFD [ 8 ] . Unlike other previous work that use paths to define XFDs, [8] defines two types of XFDs using homomorphism, v -subtrees and isomorphism of XML trees. The authors consider slightly different XML scheme files and conforming XML trees from ours. Both a scheme tree and an XML data tree are a labelled tree (we mention only trees although the authors allow more general rooted graphs ) with each node assigned a type Ele or Att , and each edge assigned a frequency of either 1 or *. In a scheme tree, no two descendants of a node can have the same type and label. While in a data tree, every leaf node is assigned a value. A homomorphism between two trees T and G is a mapping  X  from the nodes is a (unique) homomorphism between them such that the edges in T observe the frequency specified in G .A v -subtree is a subtree which roots at node v and it is determined by the paths from v to a given subset of leaves of the original tree. The isomorphism of two subtrees is a 1-1 mapping between the two sets of nodes which is homomorphic in both directions. Two data trees are equivalent if there is an isomorphism  X  between them and value ( v )= value (  X  ( v )) for the leaf nodes. An XFD is defined to be of the form v : X  X  Y , where v is a node in the schema tree, and X and Y are v -subtrees in the schema tree. Two types of satisfaction by a conforming data tree T (notice the unique homomorphism  X  between T and G ) are defined, and they represent two different types of constraints. The first type is that for every two pre-images W 1 and W 2 of the total subtree T ( v ) rooted at v , W 1 | Y and W 2 | Y are equivalent whenever W 1 | X and W 2 | X are equivalent. is the projection of W 1 on Y , which is the root -subtree of W 1 determined by the pre-images of the leaves in Y . The second type is exactly the same as the first type except  X  X re-images X  is replaced with  X  X aximal subcopies X . Here a maximal and which is not contained in any other such subtrees. Fig. 4 shows the schema graph corresponding to the scheme file in Fig. 2, a pre-image and a maximal subcopy of T ( v ) in the tree shown in Fig. 2. The first type of satisfaction allows us to express some constraints involving set equality, while the second type allows us to express some constraints similar to those in [3]. However, since there are no node equality defined, the XFDs in [8] cannot express the constraint that the student number determines the student node in each course in Fig. 2. Also, since W 1 and W 2 must be both maximal copies or both pre-images, the XFDs cannot express the constraint (F) listed at the beginning of this section. The constraint (C) cannot be expressed either since no ordered lists of nodes are considered. In this section we provide the definition of generalized XFDs. We need the fol-lowing types of agreements between two nodes.
 are interested in four types of agreements of v 1 and v 2 on p . We say that v 1 and v 2 node-agree or N-agree on p if (1) p is a simple path, and v 1 = v 2 ,or(2) p is and v 2 N-agree on the upward path part of p . We say that v 1 and v 2 list-agree or L-agree on p if the nodes in v 1 ( p ) and v 2 ( p ) are pairwise value equal. We say that v 1 and v 2 set-agree or S-agree on p if for every node v in v 1 [ p ], there isanode v in v 2 [ p ] such that v = v v , and vice versa. We say that v 1 and v 2 such that v = v v .
 address ; v 5 ,v 6 N-agree on  X  .
 Definition 1. Let S =( E 1 ,E 2 ,A,P,R,r ) be an XML scheme file. A generalized functional dependency (GXFD) over S is an expression of the form where Q is a downward path, p 1 ,p 2 ,...,p n are simple or composite paths, p n +1 and c i ( i  X  [1 ,n +1] ) is one of N, L, S, and I .
 c v 1 and v 2 also c n +1 -agree on p n +1 .
 not empty, and v 1 and v 2 also c n +1 -agree on p n +1 .
 types of agreement: for the empty path or an upward path, the default is N -agreement; for all other paths, the default is S -agreement. Note that the strong satisfaction implies the weak satisfaction.
 can express many constraints that cannot be expressed by the previous XFDs. In particular, the strong satisfaction of a special form of the GXFDs is a gen-eralization of XFD [ 5 ] , except for some subtle differences when null values exist. This special form is when the RHS is always , and the type of agreement on is S , and for each path p i on the LHS, the type of agreement is N if last ( p i )is a complex element or  X  , and it is I otherwise. For instance, the XFD [ 5 ] (i) in Section 3 for the scheme file in Fig. 1 (b) can be expressed as through (F) at the beginning of Section 3 can be expressed as follows. does not strongly satisfy (F). It does not satisfy (C) and (D).
 detect more data redundancies in XML documents. The GXFDs will be of practical use only if there are efficient algorithms for their reasoning. We are currently working on such algorithms.

