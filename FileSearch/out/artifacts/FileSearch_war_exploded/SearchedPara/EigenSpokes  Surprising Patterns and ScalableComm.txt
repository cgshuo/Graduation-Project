 Given a large phone-call network, how can we find communities of users? While the behavior of users in landline networks has been examined before [4], we study here the phone call network of mobile users in cellular networks. The analysis of mobile phone graphs is interesting for multiple reasons as mobile phones are ubiquitous and are a key conduit for Internet access too. Several recent studies have used mobile call gr aph data to examine and characterize the social interactions of cell phone users, with a focus on understanding the structural properties of the graph [13,11,21], the evolution of social groups and the spread of new produc ts and services [14].

Our objective in this paper is to identify if and to what extent do well-defined social groups of callers exist in such networks. We emphasize that understanding the entire graph structure is not our goal. Indeed, in large social networks, not every node can be expected to belong to a community. Hence, extraction of community-like structures, which can be independently analyzed, is the focus of this paper rather than graph-partitioning. This approach based on chipping off communities is also supported by recent studies [10] that have shown the presence of small communities loosely co nnected with the remaining  X  X ore X  of the graph. Furthermore, when we applied well-known graph clustering techniques on our datasets, none of them provided much insight into chipping off interesting community structures for further analys is, since these techniques are geared towards partitioning the entire graph. What was surprising, though, was our discovery of the  X  spokes  X (or EigenSpokes ) phenomenon (see Figure 1(b)): the singular vectors of the Mobile Call graph, when plotted against each other, often have clear separate lines, typically aligned with axes. We term such plots EigenEigen (or EE )plots.
 We concentrate on three key questions in this paper: 1. Cause: What causes these spokes ? 2. Ubiquity: Do they occur across varied datasets to be worth studying? 3. Community Extraction: How can we exploit them, to chip off meaningful We answer these three questions on graphs of Table 1. Our primary dataset in this paper is an anonymized social graph based on mobile calls made from/to callers located within a geographically contiguous urban area. In this social graph, callers are represented as nodes, and edges represent calls between nodes. This Mobile Call graph captures activity over the duration of a month (mil-lions of successfully completed calls) and consists of about 186 , 000 nodes and 464 , 000 edges. We also investigate similar Mobile Phone graph datasets obtained from other geographic areas, to support our findings. Since these graphs are dis-connected, we focus on the largest conn ected component. Our graphs exhibit characteristics such as degree distributions and generative processes similar to those of other mobile call graphs [11,21].

In addition to the above, we also investigate several other datasets (Table 1) in the public domain 1 which allow us to determine the generality of our observations and the underlying phenomenon. Also, they have meta-information that helps us demonstrate that our algorithm chips-off meaningful communities.

The following sections discuss the related work, problems with traditional methods, explain the EigenSpokes pattern, develop the SpokEn algorithm and finally present many surprising communities found in the datasets. Graph partitioning is a popular approach for studying community structure in graphs. Popular methods include Spectral clustering (see [24] for a survey), a  X  X ut-based X  method for understanding graph structures, which has been suc-cessful in machine-learning and image segmentation. Similar approaches (e.g. [19,16]) use the eigenvectors of the adja cency matrix. Lastly, spectral inspired methods have been used to learn model pa rameters for well-separated Gaussian mixtures [22]. Alternative cut-based multilevel approaches like Metis [8] and Gr-aclus [5,20] coarsen the graph by coalescing nodes and then apply refinement steps to recover partitions. We address b oth the Spectral and multi-level parti-tioning techniques in greater detail in  X  3.

Cross-Association [2] partitions the graph so as to maximize information com-pression, but is limited to bi-partite structures. Co-clustering [6] trys to maxi-mize mutual information, but like k -means, requires apriori information on the number of clusters. More generally in terms of clique extraction, [15] trys to extract quasi-cliques from graphs. Our focus however is on chipping out general community structures.

Modularity based approaches compare a graph X  X  community structure against a random graph. Studies have proposed using modularity based Laplacian-like matrices [12,25] or greedy heuristics [3] for graph clustering. However all these techniques also partition the entire graph rather than extract relevant commu-nities, which is our objective.

In terms of social network analysis, [18] extracts communities from an In-stant Messenger Network by applying Co -clustering. [7] proposes flow-based techniques to identify Web-based comm unities. However, it identifies commu-nities for a set of known nodes, while our objective is to extract all nodes that constitute communities. Also, although the focus of [26] is on randomness mea-sures, they observed quasi-orthogonal spectral lines in context of small cavemen-like graphs. To the best of our knowledge the EigenSpokes pattern has not been observed in any real , large social networks. We analyzed the mobile call graph using well-known spectral clustering [24] and multi-level graph partitioning [8,5] techniques. Our goal here is to explore if these methods can help us extract communities of nodes for further analysis. Although remarkably successful in other settings like image segmentation etc., we find, as shown below, that these methods do not yield good communities in our graph. Spectral Clustering: L rw , L sym ,... Many  X  X aplacian X  matrices can be de-fined on a graph G =( V , E ) (see [24]). We applied the L rw method [24] on our primary data set to obtain k -way partitions from k =2to k = 100. As in recent studies ([9], [10]), we found that th e application of the technique yields :a) skewed partitions consisting of very small clusters and a large  X  X ore X  and b) the clusters lack internal coherence. The partitions we got from L rw while lowering the N-cut value had no or little internal coherence with long chains and most nodes connected to 1 or 2 other nodes (s ee Figure 1(a)). We experimented with several other Laplacians including L sym [24] and L Q (based on modularity) [25] but obtained similar results of limited utility.
 Graph Partitioning Methods Prevailing multilevel algorithms for graph partitioning like Metis [8] and their improvements like Graclus [5] and MCR-MCL [20] are based on repeated coarsening and refinements of nodes with em-phasis on balanced cuts. To explore how well multilevel algorithms perform, we ran Graclus on the Mobile Call graph to obtain k partitions. We invoked the algorithm with various values for k from k =2to k =10 , 000. While Graclus yields more balanced clusters than Spect ral partitioning, we observed that, as before, the clusters lack internal coherence. This can be attributed, again, to the following two causes : a) these algorithms also utilize a cut-based metric and b) their objective is to partition the entire graph; as shown by our results as well as [10], this is not feasible when applied to social graphs that comprise of a large set of random nodes and small communities. As demonstrated in the previous section (and prior work), Laplacians in certain large graphs yield communities that have a low cut but possess little internal coher-ence. Hence, we investigate using the adja cency matrix itself. T his leads to several interesting observations, and motivates our approach for community identification. 4.1 A Surprise: Spokes Recall that the Singular Value Decomposition (SVD) of an m  X  n matrix W is a factorization defined as: W = U X V T ,where U and V are m  X  m and n  X  n size matrices respectively, and  X  is an m  X  n diagonal matrix comprised of the singular values. Taking the top K values of  X  yields the best rank-K approximation (w.r.t. the Frobenius norm) to the original matrix [23].
We define the EE-plot as the scatter plot of vector U i and U , for any i and j , i.e., they plot one point ( U in ,U jn )for each node n in the graph. Sur-prisingly, we find that the EE-plots for our Mobile Call graph show clear separate straight lines that are often aligned with axes 2 ! We call this the EigenSpokes pattern. This is demonstrated in Figure 1(b), whereweplotthefirst K = 18 singular vectors pairw ise. Even more striking is that, as shown in Figure 2, these spokes occur in many Mobile Call graphs collected at various points of time (separated by several months) and at various geographic regions.
 Some intuition: We delve further into the EigenSpokes pattern by identifying the nodes that lie on the extremities of the  X  X pokes X ; more precisely, for each of the first 9 singular vectors, we identify the 20 nodes that had the highest mag-nitude projection along that vector. We then plot the induced sub-graph of these nodes (see Figure 1(c)). Clearly, almost all of the induced sub-graphs contain near-cliques. These observations hint toward a strong connection between EigenSpokes and communities, and raise the following questions : are these spokes representa-tive of fundamental community structures; do they occur elsewhere? What is their origin and how exactly can they be used for chipping off communities?
We answer these questions next: in  X  4.2, we provide a rigorous basis for the link between EigenSpokes and communities; in  X  4.3, we show that EigenSpokes can be observed in several real-world graphs; and in  X  4.4, we demonstrate the various conditions that lead to the pr esence (and absence) of the EigenSpokes phenomenon. 4.2 Justification and Proofs Our focus in this paper is on undirected graphs, which implies that the adjacency matrix A is a square, symmetric matrix. For such a matrix, it is well known that the singular values are absolute values of the non-zero eigenvalues:  X  i = |  X  i | and the singular vectors coincide with the non-null eigenvectors. Due to the equivalence between singular vectors a nd eigenvectors for the (symmetric) graphs considered in this paper, we abuse language and often refer to singular vectors as being the spectra of A .

Given the presence of EigenSpokes , is it reasonable to expect the nodes lying along the extremes to have sim ilar connectivity patterns? EigenSpokes , Connectivity and Communities: The presence of spokes in EE-plots (axis-aligned or not) implies that nodes close to each other on a line have similar scores along two eigenvectors ( X  X core X  of node n along vector U i is U in ). In fact, plots of the first 3 eigenvectors, or EEE-plots (see Figure 3) show lines too. This strongly suggests similar scores for the nodes in many vectors. Specifically, consider two nodes i and j whose connectivity information is rep-resented by their rows A i and A j in A .Ifthe k th eigenvector is denoted by U ,then A i U k and A j U k are the i th and j th components of U k . These will be equal if A i = A j . Hence, the two nodes will have the same components along the eigenvectors. In general, we expect that nodes with similar connectivity will have similar scores along the vectors of U .

Is the converse also true? We can prove the following lemma to this end (note that x, y = x T y denotes the dot-product of two column vectors x and y ): Lemma 1. For any real, symmetric adjacency matrix A , if for any i and j ,  X  k, | ( A i  X  A j ) T ,U k |  X  ,then  X  k, | A ik  X  A jk | X  ( Proof. As A is real symmetric, by the Spectral Theorem, it is orthogonally diago-nalizable. Hence, it is non-defective and has a full basis of eigenvectors. Consider any vector C = k c k U k written using the basis consisting of the eigenvectors. Then, where we use the Cauchy-Schwartz inequality in step 2 and given bound in step 3. Use the above inequality for C = e k (indicator vector which is zero everywhere except at index k where it is 1), for every k . Also, note that orthogonal transfor-mations preserve the norm of a vector -hence, k c 2 k = C , which would be equal to 1 for our choice of C  X  X . Therefore, we get:  X  k, | A ik  X  A jk | X  ( Note that the above proof holds for any orthogonal basis set of vectors U ; but our basis set U is also a carefully chosen set: it is the set of singular vectors. Hence, we expect the bound to be tighter in practice.

In view of the above, we expect that nodes lying close to each other on a spoke will have similar neighbor sets. But what i s the link between similar neighbor sets and communities in the graph? Consider the following two (sufficient) conditions that result in similar neighbor sets: 1. Cliques (or near-cliques) result in exactly the same 3 (or similar) adjacency 2. Perfect (or near-perfect) Bipartite-cores also result in the same (or similar) Consequently, we expect to see communities in the form of (near-)cliques or (near-)bi-partite cores among the nodes in the spokes.
 Axis-alignment (or not): Recall another striking feature of the EE-plots :the presence of largely axis-aligned spokes. From the preceding discussion, given the presence of EigenSpokes , we should traverse the extreme points on each spoke to extract communities. This reduces to searching for  X  X igh-scoring X  nodes in each singular vector separately , since axis-alignment implies that the extreme points have high values only in one of the vectors. In fact, prior work [1] has already shown that nodes with scores at the extreme ends of the principal eigenvector of Erdos-Renyi graphs do belong to the same clique. However, some spokes are not axis-aligned (as in the last EE -plot of Figure 1(b)). This implies that some nodes have significant scores along multiple singular vectors. In the specific case of EE-plots the linear nature of spokes means that the scores of the nodes are linearly correlated . Hence, exploring dominant nodes along one singular vector should be sufficient to extract nodes of a community. 4.3 Ubiquity of Spokes Apart from Mobile Call graphs, we have observed the EigenSpokes pattern with singular vectors of several other real world graphs. We show the EE-plots for Patents, Dictionary and Internet ro uter connectivity in Figure 3(b), 3(c) and 3(d) ([17] contains more detailed plots). In all three cases, we see that most pairwise combinations align in a spoke pattern, with some exceptions in the Dictionary graph. We also observe that some of these spoke patterns are not axis-aligned; as discussed earlier though, the linear correlation between the scores of the nodes is preserved. Thus the EigenSpokes pattern is persistent across a wide array of diverse datasets. 4.4 Recreating Spokes So far, we have provided some insight into why spokes arise. We now demon-strate exactly which features of graphs and community structure result in spokes using both synthetic and real graphs. Synthetic graphs, in particular, allow us to experiment with various parameters and ch aracteristics, and observe their effect on their EE -plots. We show that the key factors responsible for these patterns are a large number of well-knit communities embedded in very sparse graphs.
We started with a synthetic random heavy-tailed graph with the same number of nodes and degree distribu-tion as our Mobile Call graph but with no community structure.
 The EE-plots don X  X  ex-hibit any spokes pat-tern (Figure 4(a)) but, when we synthetically introduce 40 communities (near-cliques of sizes 31  X  50, with a probability 0 . 8 of an intra-community edge) into the above random graph, in Figure 4(b), we observe the emergence of the spokes pattern. When we increase the number of communities to 400, in Figure 4(c), the spoke pattern becomes more clear, and resembles Figure 2. Further, we verified that the nodes at the extremities do indeed form the artificially embedded communities. We also found that the na-ture of the communities, including the level of internal connectivity, does not affect the emergence of the spokes pattern as long as such connectivity is signif-icant. Thus we infer that one of the important causes for a spokes pattern is the presence of a large number of tightly knit communities in the graph.
Due to lack of space we omit details about the effect of sparsity and degree density; they are demonstrated in greater detail in [17]. Based on the insights from previous sections, we now develop our community identification approach SpokEn , that exploits EigenSpokes . While developing SpokEn , we also use experiments with synthetically generated graphs to help us choose from the various algorithmic choices. Our approach differs from prior work on graph partitioning as for certain classes of graphs, we observe a specific structural property and exploit it. While this may not apply to all graphs, our approach is highly effective for the large sparse graphs we consider, as shown by our results later in the paper. 5.1 Designing SpokEn Our proposed approach is based on the key property of EigenSpokes highlighted in  X  4.2: the existence of EigenSpokes indicates the presen ce of well-knit com-munities whose nodes have a significant component in that singular vector. Thus an appropriate traversal of each singular vector in isolation can extract these communities. A good traversal should s elect only the nodes which belong to a coherent community. We now discuss where to start the traversal, how to grow the community and finally, when to stop.
 Initialization: We choose the node with the score of maximum magnitude as the seed for the community. We multiply the given singular vector U i by  X  1if necessary to ensure that the score with the largest magnitude is positive. Discovery: A simple algorithm for discovery is one that picks nodes in decreas-ing order of their scores. Such an algorithm can pick a node that is disconnected from all the nodes chosen previously. Hence, we propose the following: let C denote the set of all nodes that have been discovered so far; the next node that we select is the node with the largest s core that is connected to some node in C . Formally, we augment C with a node n  X  that satisfies n  X  =argmax n  X  N C U i ( n ), where N C is the neighborhood of C 4 . This algorithm is intuitive and keeps C always connected.
 Termination and Trimming: For termination, we need to use a metric that quantifies the quality of the community extracted so far. We propose to use a novel hybrid approach based on conductance [24] for cut and modularity (actu-ally relative modularity) for coherence. The process discovers and adds nodes to the set C as long as the relative modularity increases and terminates once it re-duces indicating reduction in community structure. We finally use a conductance based method to trim out the remaining false positives. 5.2 Discussion Relative Modularity: In large graphs such as ours, underlying communities are typically small (10  X  100 in a million node-graph) [10]. The equation for modularity 5 indicates that when extracting a single small community from a large graph, the modularity metric computed on such a highly unbalanced par-tition would be dominated by the larger partition and not the discovered com-munity, thus rendering it useless. This was also empirically observed in extensive evaluations over our datasets.

To resolve this problem, we once again utilize the concept of scores. When traversing a singular vector (say U i ), as a pre-processing step, we construct a new sub-graph G =( V ,E )from G wherein we discard all nodes n with values U i ( n ) below a certain threshold . The modularity computation is then conducted w.r.t. G (hence relative modularity). This is justified since in the first place, we do not expect the discarded nodes to belong to the community under consideration. The removal of such nodes induces a more balanced partition and makes the modularity values more meaningful. We set =10  X  4 in our experiments as several tests showed the results were insensitive around it. Trimming using Conductance: As shown later in  X  5.3, conductance as a termination criterion results in premature termination of the discovery process, causing several false negatives while relative modularity as a termination metric often results in overshooting and hence false positives. These two observations indicate that modularity and conductance are complementary in the role of a ter-mination metric which is why we adopt a hybrid approach. Hence as mentioned before, after a community is extracted using relative modularity (to discover all relevant nodes at the cost of false positives), a standard spectral technique ( L rw ) is used to trim-out false positives by further bisection to determine a better cut. Wegivethepseudo-codeof SpokEn in Algorithm 1.
 Algorithm 1. SpokEn 5.3 Empirical Results To evaluate the performance of our disco very process and termination crite-rion, we applied SpokEn on various synthetically generated graphs with known ground truths in each case (like the ones described in  X  4.4 including an ER graph embedded with bi-partite cores ). While the detailed results are provided in [17], we found that conductance as a termination criterion undershot and hence detected fewer communities (about 60% with almost no false positives). On the other hand, modularity discovered about 80% communities but with 4% false positives. Their combination, SpokEn , was able to identify 76-90% of the embedded communities with almost no false positives.
 Speed : The computation time is mainly dominated by the eigenvector calcula-tion which is linear in edges. We ran SpokEn on graphs of various sizes on a Dell Server with an Intel Xeon 3 GHz processor and 4 GB of RAM. In each case, we computed 100 singular vectors and mined communities from them. Figure 5(a) plots the computation time required by SpokEn to extract communities as a function of the number of edges of the graph. As expected, it clearly shows the processing time is linear in the number of graph edges, which is a key indication of scalability.
 We applied SpokEn to our real-world datasets and found that it extracts several interesting communities that reveal useful and relevant information about the connectivity patterns.

We illustrate four typical communities extracted by SpokEn from our Mo-bile Call graph. Figure 5(b) presents the spy plots which clearly show that the communities are well-connected (the com munities are red nodes on the top de-lineated by black boxes). To show the su ccess of our terminating criterion, we plot additional nodes that would have been explored by the discovery process without termination. Notice that SpokEn does indeed typically stop at points where a community appears to have ended. In the bottom left case, however, it overshoots and combines what appear to be two near-cliques into the same community. We observe similar results for the other singular vectors as well: SpokEn extracts communities of nodes with good internal coherence though it sometimes clubs together two such communities into one.
 The prevalence of such close-knit communities of more than 10 nodes in a Mobile Call graph was quite unexpected to us. Temporal analysis of the usage of at least a few communities leads us to believe that these communities arise from users of the same organization.
Next, we analyze a few typical communities from other data sets. Figure 6(a) plots the connectivity between nodes of a community extracted from the Patent citation dataset. Notice the striking bipartite nature of the community. Upon further investigation, we find that the bipartite nature arises because of patents filed by the same organization on related topics reuse the bibliography entries. In the example shown here, one-half of the bi-partite graph comprises of about 25 patents that were filed in a period of 1998  X  1999 by (the same) authors from Kimberly-Clark in the area of photosensitive pigments for color printers. The bi-partite nature of the graph arises because all these 25 patents cited the same set of past references. This also illustrates a crucial aspect of SpokEn :it extracts communities of nodes with similar connectivity. This may or may not imply mutual connectivity.
 Figure 6(b) shows a typical community extracted from the Dictionary graph. Recall that this dataset connects two words if they differ by exactly one letter. The clique shown in Figure 6(b) arises from three-letter words that all end with  X  X n X . We found many similar cases including words that end with  X  X n X ,  X  X l X , etc. Finally, Figure 6(c) shows a community extracted from the router graph. The community highlights the tiering relationship typical in the Internet. The community consists of 4 UUNET back-bone routers (first and third row) from the Tier-1 layer that serve as gateways for a large community of Tier-2 Verizon Business and other small business (th e second row) and are also connected to other Tier-1 routers (Sprint, AT&amp;T etc., last row). In answer to the questions we posed earlier in  X  1, we find that: 1. Cause: Spokes can be strongly associated with the presence of well-defined 2. Ubiquity: Apart from Mobile Call graphs, they occur in a variety of data-3. Community Extraction: The spokes pattern allows us to construct an
