 Manipulating graph-structured schemas (ontologies, models, etc.) requires the result to remain fully connected. In certain cases, e.g., calculating the difference of two schemas, support structures may be needed in the result. We describe our en-gine to process support structures in the context of a schema management system and describe schema reintegration ex-periments which validate the performance and correctness of our system.
 H.2.5 [ Database Management ]: Heterogeneous Databases; H.2.1 [ Database Management ]: Logical Design Algorithms,Management Many different kinds of schemas can be modeled as graphs. These graph-based schemas must be updated and changed, e.g., in schema reintegration . Schema reintegration occurs when different changes are made to schemas having a com-mon ancestor. Consider the following scenario: a company has a schema with the relation PRODUCTS(ProductID, Brand, Quantity, UnitPrice). PRODUCTS is modified by team A and team B. Team A deletes Brand , while team B does not modify Brand , but instead adds Discount . Even-tually, the two modified versions need to be reconciled. Pre-vious research (e.g., [1, 9]) shows that reintegration is com-mon and the goal is to keep all changes. In our current example, this is simple: since team A has deleted Brand , it should not appear in the final version. Because the new attribute  X  X iscount X  has been added by team B, it should be in the final version. Therefore, the final relation is PROD-UCTS(ProductID, Quantity, UnitPrice, Discount).

This is often challenging. In Figure 1, S A has deleted y and S B has deleted x . z is in both and hence should be in the
Graph-based schemas often require reorganization (e.g. from reintegration or view evolution.) To ensure our support element engine handles all possible reorganizations, we use the context of a generic schema manipulation framework like model management. Model management [2, 4] abstracts the manipulation of schemas with operators that can be reused across applications and data models.

Formally, we consider each schema S = ( E, R ) as com-prised of a set of elements E and directed relationships R between elements. As in model management, elements have properties with additional details. We use p ( e ) to denote the property p of element e . We require each element e to have one property ID ( e )  X  which gives an ID for each element.
We formalize reintegration as follows: Given an original schema S O and two modified versions, S A and S B , which are generated from S O , generate an integrated schema S M that incorporates the changes in both S A and S B . The set of relationships R is a binary relation on E (i.e., R  X  E  X  E ). Our methods are independent of relationship types, so all edges in examples express containment. A Valid Schema is one for which R is a partial order on E (i.e., it is connected and acyclic), with a unique root element.
Given schemas S 1 = ( E 1 , R 1 ), S 2 = ( E 2 , R 2 ), a map-ping M ap over S 1 and S 2 is any M ap  X  E 1  X  E 2 . We use the notation M ap ( e 1 , e 2 ) as shorthand for ( e 1 , e 2 )  X  M ap . Our work is independent of mapping semantics. For ease of exposition, we assume elements with the same name refer to the same object. However, our implementation uses the first-class mappings of [4, 10].

An important reintegration question is handling conflict-ing changes to S O in S A and S B . We use the semantics of [1, 9], retaining all changed elements and deleting unchanged elements that are deleted in either S A or S B .
This section defines the operators for schema reintegra-tion. Since our focus is on the support elements, we give only enough detail to make the rest of the work comprehen-sible. Greater detail can be found in [12].

All operators delete lazily, using a Delete property to mark which elements should be deleted. Each operator is followed by a pass through the Support Element Engine (Section 4), ensuring a valid schema by removing the Delete property and adding a Support property to some elements. Finally, elements marked with Delete are deleted. Section 4 gives three alternative implementations for the Support operator.
The necessary operators are:  X  Match ( S X , S Y , f ): Produces a mapping between S X and
S Y using function f . Although our implementation does not require it, in examples in this paper, matches are based on ID values.  X  Merge ( S X , S Y , Map X,Y ): Produces a schema which con-tains the union of the elements of S X and S Y , where elements mapped by Map X,Y are fused into a single ele-ment. We use the Merge operator from [10].  X  Range ( S X , S Y , M ap X,Y ): Produces a schema containing only the elements of S Y that are mapped in M ap M,Y .  X  Diff ( S X , S Y , Map X,Y ): Produces a schema containing the elements in S X that are unmapped by Map X,Y . Be-cause our Diff is new, we describe it in more detail below. itively, adding a support element that connects one ele-ment of E ENS to the root may also cause other elements of E ENS to be connected to the root as well. [12] shows a reverse breadth first search algorithm for choosing a representative from among the possibilities.  X  Find Support Elements. Find a set of support elements which make the schema valid again. This phase is now discussed in more detail.

Of the three algorithms to find support elements,  X  X hort-est Path X  is the most straightforward,  X  X east Support El-ements X  minimizes the number of support elements, and  X  X reedy X  trades off between efficiency and minimality. Algorithm 2 Find a set of support elements for E ENSR using shortest path.
Shortest Path Algorithm: Our Shortest Path Algo-rithm, (Algorithm 2), is simple and efficient. For each e  X  E
ENSR , it finds the shortest path from the root to e ; it marks all deleted nodes along this path as support nodes.
For each E ENSR element, we use a reverse breadth-first search to track its ancestors. The algorithm terminates when the tracing process reaches the root element, or any element that is already included in the schema, or an element that has been marked as a support element by using the rela-tionships. All the elements in the found path that did not belong to the result elements set are included in the result schema as support elements. Because the path is found with breadth-first search, it is guaranteed to be the shortest path.
The advantage of this algorithm is the speed. Even to reach the root, the average case complexity for this algo-rithm is O ( | E ENSR | log( n )). However, since we need to keep track of each level, the space usage is very high.
Least Support Elements Algorithm (LSE): Some applications may benefit from using as few support elements as possible. LSE (Algorithm 3) minimizes the number of support elements to be added overall. Determining the least support elements requires finding all possible paths from the root to each element in E ENSR .

LSE first finds all possible paths from the root to each e  X  E ENSR . Every set of deleted elements along each of these paths is a necessary and sufficient set of support elements for e . These sets are the elements of candidates ( e ). Since the candidates of different elements may overlap, we check each ally critical, LSE gives the optimal solution. When most elements have a high out-degree, and there are complex re-lationships between elements, LSE is very costly since it finds all the paths to some elements already included in the schema. In such cases, Greedy is a good choice.
 Most operators need support elements in their result schema. These results can be further used as input to other operators. Therefore, each operator needs to consider how to deal with the support elements in their input. Moreover, it should also be considered when such schemas (which already have support elements) need to add more support elements.
We implemented a schema reintegration system, includ-ing all operators in Section 3. We tested a variety of schema reintegration scenarios. We focus on showing that our imple-mentation ensured correct behavior; full details are in [12].
We designed 18 test cases for the  X  X upport Element En-gine X . All algorithms performed correctly. The shortest path algorithm was a bit faster than the other two.

We designed four experiments to test the reintegration system, ranging from simple to very complex. Even from simple experiments, we found many improvements neces-sary for stability. For example, the simpler the schemas and changes are, the more likely there are empty schemas in the result. The full version of this paper [12] discusses the spe-cial handling necessary for empty schemas.

Our second experiment included elements covering all pos-sible additions, deletions and modifications. The original schema includes eight elements which are arranged in three levels. One derived schema contains eight elements and the other contains seven elements. These elements are arranged in a designed hierarchy to cover each scenario tested.
Finally, we experimented on the same cases that Rondo [8] uses: a relational schema case and an XML schema case. Our system obtained the results dictated by schema reinte-gration and the same results as Rondo. [2] motivates model management, but does not give algo-rithms for the operators. [4] is the first mention of support elements, but it also does not provide algorithms for the op-erators. Rondo [8] does not require that intermediate steps are models (i.e., they do not require connected components). Rondo also does not have an explicit Diff . Our method is more self-contained. Gubanov et al. [5] propose a model management engine for reverse-engineering. They do not describe their operators in detail, nor do they appear to re-quire their intermediate operator results to be a model, so there is no requirement to create support elements. Bern-stein and Melnik [3] provide a new vision for model manage-ment; these mappings are richer than those in other model management works. [3] focuses on describing the difficulties in creating applications using simpler mappings; they do not focus on the operators X  implementations. [7] manipulates both the schema and the data using rela-tional algebra type concepts, such as selection, projection, and joins. Their Diff is a relational algebra style operator; either the entire sub-tree of a model is present, or it is not. Hence, they do not need support structures.

McBrien and Poulovassilis [11] describe a set of schema transformation operations. Their work includes the  X  X elN-
