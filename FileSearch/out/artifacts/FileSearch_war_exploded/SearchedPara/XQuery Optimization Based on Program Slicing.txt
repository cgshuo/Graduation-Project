 XQuery has become the standard query language for XML. The efforts put on this language have produced mature and efficient implementations of XQuery processors. However, in practice the efficiency of XQuery programs is strongly dependent on the ability of the programmer to combine dif-ferent queries which often affect several XML sources that in turn can be distributed in different branches of the or-ganization. Therefore, techniques to reduce the amount of data loaded and also to reduce the intermediate structures computed by queries is a necessity. In this work we propose a novel technique that allows the programmer to automat-ically optimize a query in such a way that unnecessary in-termediate computations are avoided, and, in addition, it identifies the paths in the source XML documents that are really required to resolve the query.
 H.2 [ DATABASE MANAGEMENT ]: H.2.3 Languages X  Query languages ;F.3[ LOGICS AND MEANINGS OF PROGRAMS ]: F.3.2 Semantics of Programming Languages X  Program analysis Languages XQuery, Slicing, Query Optimization  X  This work has been partially supported by the Spanish Ministerio de Ciencia e Innovaci  X  on under grants TIN2008-06622-C03-02 and TIN2008-06622-C03-03, by the Generali-tat Valenciana under grant PROMETEO/2011/052, and by the Junta de Andaluc  X   X a under grant TIC-6114. Salvador Tamarit was partially supported by the Spanish MICINN under FPI grant BES-2009-015019.

XQuery [21, 6] is a typed functional language devoted to express queries against XML documents. It contains XPath [2] as a sublanguage. XPath supports navigation, selection and extraction of fragments from XML documents. XQuery also includes flowr expressions (i.e. for-let-orderby-where-return expressions) to construct new XML values and to join multiple documents. The design of XQuery has been influ-enced by group members with expertise in the design and implementation of other high-level languages. XQuery has static typed semantics which is part of the W3C standard [6, 21].

XQuery has evolved into a widely accepted query language for XML processing and many XQuery engines have been developed [12, 8, 3, 14, 10, 16]. However, memory con-sumption and execution time remains a crucial bottleneck in query evaluation. Queries against large data sources re-quire the improving of data loading and buffering together with XQuery optimization. Sometimes the refactoring of the XQuery or the pre-filtering of the source XML files is mandatory to be able to process large XML documents. As a matter of fact, standard XML processors have a maximum size in the XML documents they can process. Nevertheless, some XML documents such as the XML version of DBLP are very large and could require pre-processing and query optimization to be handled.

In this work we introduce a novel technique able to auto-matically project the portion of the input XML document that is needed to resolve a given XQuery expression (thus the remaining parts of the document are not loaded), and at the same time, it also allows us to optimize the XQuery itself with a refactoring process based on program slicing .
Program slicing is a general technique of program analysis and transformation whose main aim is to extract the part of a program (called slice) that influences or is influenced by a given point of interest [22, 20]. Program slicing has been traditionally based on a data structure called program dependence graph (PDG) [9] that represents all statements in a program with nodes and their control and data depen-dences with edges. Once the PDG is computed, slicing is reduced to a graph reachability problem, and slices can be computed in linear time.

Our slicing-based technique aims to provide an optimiza-tion method for XQuery. Given a (composed) query, we are able to detect those parts of the XQuery code which are not relevant for the output of the query. In addition, we are able to rewrite the query into a new one in which the irrelevant parts have been removed. Unfortunately, the PDG cannot be used with XQuery because the notion of statement is not applicable to functional languages. Therefore, firstly, we will define a notion of XQuery Dependence Graph (XDG) which is a labelled graph able to represent XQuery expressions. Secondly, we will describe how to transform an XDG in order to optimize an XQuery expression in such a way that only those expressions that contribute to the final result remain in the graph. The transformation consists on forward and backward propagation of data dependences together with an slicing procedure in order to detect the required paths in an XQuery expression. From the transformed XDG we extract a new optimized XQuery and, additionally, we deduce the parts of the documents used by the XQuery expression.
Example 1. The following composed query requests the customer elements obtained from a nested query in which all customer ,andsome provider elements are computed.
This query shows an example of query optimization. Given that the provider elements are never used by Q2, they can be pruned from Q1 when they are composed. This produces an equivalent optimized query.

The structure of the paper is as follows. Section 2 presents the related work. Section 3 introduces some preliminaries. The XDG is introduced in Section 4, and the slicing algo-rithms are presented in Section 5. Section 6 describes the implementation. Section 7 presents our experimental re-sults. Finally, Section 8 concludes and presents future work.
There exist two major research lines concerning the op-timization of XQuery. The first line tries to improve the processing of the XML input data. The second line oper-ates over the source XQuery expressions transforming them to improve efficiency.

On one hand, XML document loading and buffering tech-niques have been studied in [17, 1, 4, 19]. The static projec-tion technique of [17] of input XML documents implemented in the Galax [8] processor and refined in [1, 4] proposes that only the parts of the input documents relevant to query eval-uation are loaded into memory. The projected documents are computed before query evaluation starts. In the case of [19], they distinguish bulk input data only used to generate the output from input data which are traversed in query evaluation, improving XML projection.

On the other hand, XQuery optimization techniques have been proposed. In [13], they describe a technique for prun-ing XQuery in order to improve composition based queries. Rather than projecting XML documents, they project XQue-ry sub-expressions with respect to other sub-expressions que-rying them. In other words, they propose the pruning of queries in which an (intermediate) result computed by means of a query is used as input of another query.

Our work follows the same line as [13] and [17], providing a query optimization technique based on query transforma-tion which combines prunning and projection. However, our technique is much more precise because it uses a data depen-dence analysis that is performed bottom-up and top-down in the XQuery expression. Contrarily, their pruning technique is a bottom-up analysis that fails to prune many useless ex-pressions as shown in the following XQuery expression: Clearly, in this expression, the C elements are not necessary and can be removed. However, this simplification cannot be detected by their pruning technique (that would leave the query unchanged). The reason is that they only use a bottom-up analysis. Hence, when some inner subexpression is pruned, they do not have information about the outer subexpressions, thus missing pruning opportunities.
Example 2. The following query presented in [13] re-quests the close_auction elements obtained from a nested query in which the elements computed are open_auction el-ements enclosed by means of the label site . The pruning technique in [13] would produce the following simplified query:
However, this simplification is suboptimal and it can be further optimized in our approach: the nested query does not compute close_auction nor person elements and therefore the query can be completely pruned because the where clause cannot be satisfied (i.e., the final query should be the empty sequence () ).
 In our technique, the same analysis performed to prune XQuery expressions provides the information needed to pro-ject the source XML documents. This means that with the XDG we can also project the XML documents that partic-ipate in the XQuery expression as it is done in [17]. Let us remark that the projecting technique of [17] is also im-proved here by means of our query optimization technique. For instance, in Example 1 provider elements will not be projected from the input XML document.

There has been previous attempts to define a PDG-like data structure for functional languages. The first attempt to adapt the PDG to the functional paradigm was [18] where they introduced the functional dependence graph (FDG). Unfortunately, FDGs are useful at a high abstraction level (i.e., they can slice modules or functions), but they can-not slice expressions and thus they are useless for XQuery. Another approach is based on the term dependence graphs (TDG) [7]. However, these graphs only consider term rewrit-ing systems with function calls and data constructors (i.e., no complex structures such as let-expressions, for-expressions, if-then-else, etc. are considered). Finally, another use of program slicing has been done in [5] for Haskell. But in this case, no new data structure was defined and the abstract syntax tree of Haskell was used with extra annotations about data dependences.
Expr ::= Literal Tag ::= &lt;QName&gt; LExpr 1 ...LExpr n &lt; \ QN ame &gt; LExpr ::= { Expr }| Literal | Tag Path ::= Expr ( /QN ame ) + Var ::= $ VarName Op ::= &lt; | &gt; | = | + | X  X  X  X  / | and | or
For the sake of concreteness, in the rest of the paper we will consider the subset of the XQuery core language shown in Figure 2. We need to introduce a normaliza-tion process for XQuery expressions. This process ensures that (1) all variables defined in both let and for expres-sions are pairwise different, that is, they are renamed when they coincide; and (2) all Path expressions start with a variable. The normalization substitutes e ( /QN ame ) + by let $ x := e return $ x ( /QN ame ) + , whenever e is not a Var expression, where $ x is a new variable, and e is recursively normalized.

Example 3. The query of Example 1: is normalized as follows:
We define functions first , suffix and last to extract a portion of a normalized path as follows: first ($ x ( /QN ame ) + )=$ x , suffix ($ x ( /QN ame ) + )=( /QN ame ) + , last ($ x/QName 1 .../QName n )= QN ame n .
In this section we define the XQuery dependence graph (XDG). Such data structure is one of the main contributions of this work. It allows us to graphically represent XQuery expressions establishing data and control relations between subexpressions. Therefore, it is very useful for refactoring and, in particular, it is the basis of our slicing algorithms for XQuery. First, we define the graph representation of a XQuery expression.

Definition 1 (Graph Representation). Given a nor-malized XQuery expression e ,werepresent e with a labelled graph ( N , E , F ) where N are the nodes, E =( C , S ) are edges of two types: C the control edges, and S the structural edges, and F is a set of partial functions:
The set F of partial functions defines the labels of each node in the graph. Function type returns the type of a node. T is the set of node types: literal , seq , var , doc , path , let-Ty p e seq represents a sequence of elements in a tuple or in a Tag element. Function literal is defined for nodes of type literal including elements doc(literal) . The partial function children is defined for nodes of type seq and op . It returns a set of pairs of the form ( pos, n )where pos is the position in the sequence or operation of the expression represented by node n . Function var , is defined for binding nodes (i.e, forBinding and letBinding ) and represents the bound vari-able. The other functions are defined for nodes of type path , op and tag , respectively, and their results are straightfor-ward. We denote by f F the meaning that F assigns to the function f .

The graph representation of a XQuery expression is con-structed compositionally according to the cases of Figure 1. In such representation, each graph has a final node (which has been graphically distinguished with a bold line) except if-then-else that has two final nodes. The nodes with a dashed line represent the graph associated to their subex-pression, and all nodes connected to a dashed node are linked to the final nodes of the graph represented by the dashed node. We have graphically distinguished the two kinds of edges: control edges with a solid line, and structural edges with a dashed line. In addition, nodes are graphically repre-sented including the information provided by means of the associated partial functions.

We are now in a position to define our main data struc-ture called XQuery Dependence Graph (XDG). Essentially, the XDG augments the graph representation of a XQuery expression with the standard notion of data dependence of static analysis (see, e.g., [20]). Formally,
Definition 2 (XQuery Dependence Graph). Given a XQuery expression e ,the XQuery Dependence Graph (XDG) of e is a directed labelled graph X =( N , E , F ) where N the nodes and E =( C , S , D ) are the edges. ( N , E , F the graph representation of e being E =( C , S ) with C the control edges, and S the structural edges. The set D rep-resents data edges . We have a data edge from node n to n iff first ( path ( n )) = var ( n ) . F is a set containing the functions in F plus a partial function called label which re-turns a set of pairs of the form ( P path, boolean ) for each data edge, that is, label : D X  X  ( Ppath  X  boolean ) .
In the previous definition Ppath denotes partial paths of the form: Ppath =($ | QN ame )( /QN ame )  X  . Functions first , suffix and last can be also defined for partial paths. Given pp =($ | QN ame )( /QN ame )  X  we have: first ( pp )=($ | QN ame )and suffix ( pp )=( /QN ame )  X  in addition, last (($ | QN ame ) /QN ame 1 .../QName n )= QN ame n if n  X  1, and ($ | QN ame ), otherwise.

Observe that the definition of XDG uses the standard no-tion of data dependence (see, e.g., [9]). In the case of XQuery the notion of variable definition and variable usage is similar to the other languages. In particular, variables are always defined in forBinding and letBinding nodes and they are used in any node that contains this variable (i.e., there ex-istsadataedgefromnode n to n when first ( path ( n )) = $ v and var ( n )=$ v ). Observe that, thanks to the normaliza-tion process, no redefinition of a variable is possible, thus, all uses of a particular variable data-depend on the same variable definition.

The labels of the data edges are useful to know what in-formation (i.e., partial paths) is required and provided by each node (i.e., true means that the partial path could 1 be provided by the node, and false means that it cannot be provided). Such labels represent complete or incomplete paths from a bound variable. The name of the bound vari-able does not need to be specified in edges, for this reason we have used the notation $ in partial paths.

Example 4. The XDG of the normalized XQuery in Ex-ample 3 is shown in Figure 3 where nodes are identified with numbers. We have graphically represented the function children by means of sequences (# n 1 ,..., # n k ) represent-ing the order of the children. The example contains five data dependence edges (the dotted edges) representing the request of $j/customer from the outermost for (A), the request of $i/customer (A) and $i/provider (B) from the innermost for ,andtherequestof $v/company from the let expression (C). Let us remark that initially they are marked as true , but the proposed slicing algorithms will update such boolean values.
In this section we describe how to transform a XDG in order to optimize an XQuery expression in such a way that only those expressions that contribute to the final result re-main in the graph. From the final transformed XDG we can
Whether the path is actually provided or not depends on the XML source. (i) extract a new optimized query and (ii) deduce the parts of the source documents used by the query that are really needed.
 The transformation is divided into two independent stages. In the first stage, all data dependences are propagated for-wards and backwards in order to determine which expres-sions are needed and which of them are available. This process mainly affects data edges: labels of data edges are updated, and some new data edges can be also added or deleted. In the second stage, by means of an slicing proce-dure, those expressions that are useless are removed, and the graph is further transformed to ensure that the final XQuery expression is syntactically correct. In addition, there is a garbage removal procedure that can be applied before and after propagation and slicing procedures.

Now, we define some notation that will be used in the slicing algorithms. Given a XDG G =( N , ( C , S , D ) , F (1) We use ine E ( n )and oute E ( n ) to denote, respectively, (2) Function reachable G ( n ), denotes the set of data and (3) Finally, we denote by init ( G ) the set of initial nodes
We can remove from the XDG all the letBinding nodes that are not the target of a data edge. Such bindings are useless in the XQuery expression: they represent variables that are declared and not used. Note that forBinding nodes cannot be removed because they can be useful for iteration even if they do not have incoming data edges. It provides our first optimization step, and in addition, it avoids to traverse such nodes in the next stages. Such garbage removal can be done in linear time with respect to the size of the XDG and it must be done before and after both stages of the transformation because the propagation of dependences and the slicing process itself could remove the incoming data edgesofa letBinding node producing new garbage. The Algorithm 1 implements the garbage removal process. Algorithm 1 Garbage Removal Input :AXDG G =( N , E =( C , S , D ) , F )
Output :AXDG G repeat until Garbage =  X  return G Algorithm 2 deleteFrom Function
Function deleteF rom ( n, G =( N , E =( C , S , D ) , F )) return G Note that, the removal of a letBinding node (and all its re-lated nodes) is implemented with function deleteF rom in Algorithm 2. This function starts from a given node and re-moves recursively all the nodes reachable from them, follow-ing structural edges forwards and control edges backwards; it also removes all their structural/data edges. Observe also that the application of this function could produce new garbage and thus the process is repeated until no garbage exists in the XDG. This phase propagates data dependences through the XDG. Such propagation must be done forwards and backwards.
Roughly speaking, the forward propagation says what (sub) paths are required by the expressions in the XQuery. And the backward propagation says which of these (sub)paths could be provided to the expressions that required them. Ba-sically, propagation is as follows: the data dependences are represented by means of labelled edges in which a partial path is requested by a certain (sub)expression. The forward propagation starts from initial nodes and follows structural and data edges in order to (1) update labelled data edges with false whenever the partial path cannot be obtained, (2) delete useless data edges, and (3) add new data edges. The backward propagation updates the data edges from the forward propagation. 1. Forward Algorithm (see Algorithm 3): Algorithm 3 Propagating Dependences Forwards Input :AXDG G
Output :AXDG G for each node n  X  init ( G ) (i) return G
Function propagateForward(n, G =( N ,( C , S , D ), F )) Algorithm 4 Propagating Dependences Backwards Input :AXDG G =( N , ( C , S , D ) , F ) Output :AXDG G
Pending := { n  X  X | ine D ( n ) =  X  X  X  oute D ( n ) =  X  X  (i) for each node n  X  Pending : Pending  X  outn D ( n )=  X  (ii) return G
Function propagateBackward(n,( N ,( C , S , D ), F )) 2. Backward Algorithm (see Algorithm 4):
Let us remark that both propagation algorithms can be performed in linear time with respect to the size of the XDG.
Example 5. In Figure 4 we can see the forward and back-ward propagation of the normalized query in Example 3. init ( G )=0 , thus the forward propagation starts in node 0, propagating A until node 7. Then, B is propagated un-til nodes 15, 18 and 19 because only customer is required (i.e., the variable $ jispairedwith sales ). Becausenode19 only provides provider elements, and node 18 is the empty sequence, they cannot provide customer and thus they are updated to false (C). Moreover, because these nodes can-not provide required elements, the dependences that start from them are deleted. Note that the data edge from node 19 to node 2 has been deleted. The dependences (A) and Algorithm 5 Slicing Input :AXDG G =( N , ( C , S , D ) , F ) Output : A pruned XDG G
Pending := { n  X  X | ( ine D ( n ) =  X  X  X  X  e  X  ine D ( n ): ( pp, true )  X  label ( oute D ( n ) =  X  X  X  X  e  X  oute D ( n ): ( pp, true )  X  label (i) for each node n  X  Pending : Pending  X  outn S X  X  ( n )=  X  (ii) return G (D) arriving to node 2 are also propagated forward (E) un-til node 9. This means that we only require elements cus-tomer and provider from the company elements provided by node 9. Therefore, the dependence F is updated from E to express that node 9 only needs company/customer and com-pany/provider elements. This is then propagated until node 8. In the backward propagation, the (B) dependences between nodes 10-16 and 10-17 are updated to false (C).
Once the dependences of the XDG have been propagated, the optimization technique uses a program slicing-based al-gorithm to produce a new optimised query. 3. Slicing Algorithm (see Algorithm 5):
Example 6. In the XDG of Figure 4 the slicing process starts from nodes 18 and 19 because all incoming data edges are labelled with false . In particular, the set Pending con-tains nodes 18 and 19 and thus Algorithm 5 performs, e.g., acall slicingF rom (18 , G ) being G the XDG of Figure 4. Then, the case type F ( n )= seq of Algorithm 6 is executed with noN ext = true and hence, node 18 is removed and node 16 is included in pending. Then, e.g., it performs a call slicingF rom (19 , G ) and the last if of Algorithm 6 is ex-ecuted because allT rue =  X  and hence, function deleteF rom removes node 19. The next calls slicingF rom (16 , G ) and slicingF rom (17 , G ) produce the complete removal of the whole if-then-else. After unnormalization, the final result produced is optimal: Algorithm 6 SlicingFrom Function
Function slicingFrom(n, G =( N , E =( C , S , D ), F )) return ( G ,  X  ) Algorithm 7 replaceByChildren Function Function replaceByChildren ( n, ( N , E , F )) return ( N , E , F )
When the forward propagation process is finished, we can check all the data dependences of those nodes that represent an XML document (i.e., those labeled with doc(Literal) ). These data dependences are a collection of paths that rep-resent the information required by the query from this par-ticular XML document. The projection P of the XML doc-uments can be extracted from the XDG as follows: P = { ( literal F ( n ) , { pp | e  X  ine D ( n )  X  ( pp, true )
Each one of the computed pairs contains an input XML file and the paths required from this file.

The projection of XML documents can be done at any stage after the forward propagation. If it is computed imme-diately after the forward propagation, the result is equivalent to the projecting technique in [17]. If we compute it after the slicing phase, the result is much more precise because the projection takes advantage of the pruning analysis.
For instance, with the query of Example 2, the projection information that we get after the forward propagation is: { ( File 1 ,  X  ) , ( File 2 , { site/people/person } ) }
In contrast, the projecting information after the slicing phase is the empty set (no information is really needed from the XML sources).
All the algorithms proposed have been implemented and integrated into a tool called XQSlicer . This tool allows us to automatically generate an XDG from a given XQuery expression. The tool has been implemented in Haskell. It has about 1000 LOC and generates XDGs in dot and jpg formats. The implementation is composed of eight different modules that interact to produce the final XDG: Main This is the main module that coordinates all the Parse Module used to transform XQueries to an internal Normalization This module automatically normalizes the Graph Creation Creates the initial graph (i.e., without Propagation Performs backward and forward propagation Slice Used to obtain the sliced graph after data propaga-Restore Contains all the needed functionality to produce Dot Generation To obtain a Dot file from a given XDG. Utilities It contains common and auxiliary functions and
There is an online version of XQSlicer that can be used to test the tool. This online version is publicly available at http://kaz.dsic.upv.es/xqslicer.html .Figure5shows a screenshot of the online version of XQSlicer . The user can either write down the initial XQuery expression or choose one from the list of available examples. Once the XDG is generated ( Generate XDG ) it is possible to visualize it ( View XDG ) and to save it as jpg or dot formats. The same options are available for the XDG with propagated dependences. And also for the sliced XDG. For instance, the XDGs in Fig-ure 5 has been automatically generated by XQSlicer from the XQuery expression of Example 1. After the XDG is gen-erated, the tool shows the final XQuery expression produced after the slicing process and the projecting information.
We tested our approach by means of the BaseX processor in a Intel machine of 1.60 GHz and 2 GB of RAM. We tested the following query: for $j in &lt;site&gt;{ where $j/person = $k/people/person return &lt;common-auction&gt;{$j/open_auction}&lt;/common-auction&gt;
We used benchmarks for XML documents with (1) 100, (2) 1000, (3) 10000 and (4) 100000 records. Table 1 shows the execution time in ms.

This result shows that the proposed technique not only al-lows us to save memory by avoiding the computation, stor-age, and transfer of intermediate data structures. It also allows us to scale up with respect to the time needed to process the query. Note that the impact on time is very significative (from ms. to hours in the last case).
This work introduces a program slicing based technique to automatically optimize XQuery expressions. This is the first adaptation of program slicing to XQuery and it has the advantage that the dependence analysis performed al-lows us to project the source XML documents and to prune the XQuery expression. The technique is based on a data structure, the XDG, that is the adaptation to XQuery of the well-known PDG used in imperative languages. The defini-tion of the XDG is by itself an important contribution of this work because it allows us to perform many other different static analyses and refactoring transformations for XQuery expressions that are expressed with this formalism. The way in which we have defined the XDG for XQuery could be eas-ily adapted to other functional languages. In fact, we think that the slicing algorithms could be also adapted with slight modifications.

One important advantage of our technique is that it pro-duces XQuery expressions that are executable. This means that other analyses and tools could use our transformation as a preprocessing stage simplifying the initial query and pro-ducing a more accurate and reduced expression that would predictably speed up the subsequent transformations.
Our proposed slicing technique can be extended in the fu-ture with some optimizations. For instance, in [11] they pro-pose a rewriting-based optimization technique for XQuery in which they change the order of operations checking boolean conditions before constructing XML elements, and comput-ing statically path expressions when they are applied to XML element constructors. In [15] they study under which conditions query composition can be eliminated and show a set of rules to this end. We think that the XDG can be used to improve these transformations. [1] V. Benzaken, G. Castagna, D. Colazzo, and [2] A. Berglund, S. Boag, D. Chamberlin, M. Fernandez, [3] P. A. Boncz, T. Grust, M. van Keulen, S. Manegold, [4] S. Bressan, B. Catania, Z. Lacroix, Y. Li, and [5] C. Brown. Tool Support for Refactoring Haskell [6] D. Chamberlin, D. Draper, M. Fern  X  andez, M. Kay, [7] D. Cheda, J. Silva, and G. Vidal. Static slicing of [8] M. Fern  X  andez, J. Sim  X  eon, B. Choi, A. Marian, and [9] J. Ferrante, K. Ottenstein, and J. Warren. The [10] X. Franc. Qizx, a fast XML database engine fully [11] M. Grinev and M. Pleshachkov. Rewriting-based [12] C. Gr  X  un. BaseX. The XML Database, 2011. [13] B. Gueni, T. Abdessalem, B. Cautis, and E. Waller. [14] M. Kay. Ten reasons why Saxon XQuery is fast. IEEE [15] C. Koch. On the role of composition in XQuery. In [16] C. Koch, S. Scherzinger, and M. Schmidt. The GCX [17] A. Marian and J. Simeon. Projecting XML [18] N. F. Rodrigues and L. S. Barbosa. Component [19] S. Scherzinger. Bulk data in main memory-based [20] F. Tip. A survey of program slicing techniques. [21] W3C. XML Query Working Group and XSL Working [22] M. Weiser. Program slicing. In Proceedings of the 5th
