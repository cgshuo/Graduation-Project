 Relational pattern mining is discussed in the framework of multi-relational min-ing and it is suitable to use the technique of inductive logic programming (ILP). Warmr [2,3,4] is a representative algorithm of this context.

Warmr generates candidate patterns (queries) in top-down way from simple to complex in level-wise. Then it cuts down unnecessary patterns using a saved infrequent query set. The set has a similar function to the principle used in Apriori[1]. In spite of the cut-down procedure it has limitation, because of the exponentially growing space of hypothes is with respect to the length of patterns and the number of relations. Mapix acquired much efficiency at the sacrifice of the variety of patterns. It only finds patterns as combination of attributes, instances. It is bottom-up in the sense that attributes are not given in advance called property items, appeared in target instances. Then it applies Apriori-like procedure for the property items. It succeeded to prohibit duplication of patterns in the sense of logical equivalence.

The bottom-up construction restricts the range of patterns in ones appeared in instances. This paper studies to construct a large variety of patterns by com-bining attributes. The method becomes truly first-order. The variety approaches to full enumeration in keeping the efficiency. Familiarity on logic programming is assumed. We use Datalog, a Prolog without functors, to represent data and patterns. A Datalog clause is a universally quan-and P X  for a formula P means replacing every variable v i in P with a term t i .
For our mining task a Datalog DB R is given. A predicate corresponds to a relation. A predicate p is extensional when every formula whose head uses p is a ground (no variable) fact in R , otherwise intensional. One of extensional relationsisspecifiedasa target (It corresponds to the concept key of Warmr ). A fact of the target relation is called a target instance .
 is said to succeed wrt R when R | =  X  Q .
 Definitions bellow are brought from [3] with slight modification.
 Definition 1 (pattern). A pattern is a Datalog clause whose head is of the  X  e possesses P .
 Definition 2 (frequent pattern). The frequency of P is the number of target instances which possess P . supp [ P ]=( The frequency of P ) /N and is called the support of P ,where N is the number of all target instances. P is frequent if supp [ P ] &gt; sup min for a given minimal support sup min .
 Example 1 (running example). Consider a DB R fam (Fig. 1), including relations, p ( meaning x is someone X  X  grandfather. Let gf be a target and = gf ( taro )isa target instance. The following formula is a pattern.
 P by assigning jiro to B then e possesses P .
 In order to discuss for equivalence of patterns we use  X  -subsumption. Definition 3. Let  X  C and  X  D be patterns, i.e. C and D are conjunctions and are regarded as sets of conjunct atoms. When C  X  D X  , we say that C subsumes D which is denoted by C D .If C D and D C , then we say that C and D is subsumption-equivalent and write C  X  D .
 The coincides with logical implication when patterns have no recursion.
Many ILP algorithms assumes modes for a rguments of predicates to restrict patterns. Some arguments have a role as input and others as output. For example + /  X  means an input/output mode.

We distinct two classes of predicates obeying [6]. Predicates with at least one An instance of a path/check predicate in DB is called a path/check literal. We do not give mode for target. The outline of Mapix algorithm is as follows: 1. It samples target instances from a target relation. 2. For each sampled inst ance it collects things ( properties )holdonDB. 3. By generalising the properties it generates first-order attributes (which cor-4. It executes Apriori-like level-wise f requent pattern mining algorithm by re-For an instance = gf ( taro ) we may find a thing hold on it, It may be read that taro has a grandson and regard it a property of . By replacing terms by variables and giving a head we have a pattern, term in a target instance make a chain, e.g. taro , ichiro ,and ken ,anditstopsby a check literal, e.g. m ( ken ).

Path literals have a function referring an object (an attribute) of an instance, and a check literal describes its character (an attribute value). We assume all form . Similar ideas have appeared in first-order features in LINUS[7] and 1BC[5] and a search used in pathfinding[8].

When a target instance possesses a pattern yielded from a property as in (1), we can regard the pattern as an item of the instance. To find combinations of items that are frequently appeared in instances are a standard task in association rule mining. This was the idea of Mapix . Again consider the example and = gf ( taro ). has properties pr1 ,..., pr5 as shown in Table 1 and then it has property items i1 ,..., i5 . To see the structure a variable is given for positions occupied by a term.

Mapix has difficulty that it can not treat patterns that cross more than one item. When Mapix treats a combination of items it just concerns if an instance has the two items independently. For pr1 and pr2 , which are connected on ichiro , the itemset { i1 , i2 } is treated as a pattern, This is possessed by but we may expect another straight pattern, which is obtained when we unify I and I according as I and I are occupied by a term ichiro in the original properties. A strategy is suggested to obtain a pattern according to occurrence of terms.

We face another difficulty when we adopt this strategy and also are interested in producing a pattern only once in the sense of logical equivalence. We see i1  X  i3 and i2  X  i5 . We can discard i3 because it relates to no other items but when we throw away i5 we can not obtain the pattern by combining it and i4 .The i2 can not be dropped either since it relates to i1 . Keeping necessary items all causes large inefficiency, because the nu mber of itemsets grows exponentially on the number of items and also because kept equivalent items produce many equivalent patterns.

Now we describe our idea. Let think of a pattern by combining the equivalent items i2 and i5 just as in an itemset of Mapix . We can see that this is equivalent to i2 and also to i5 . It is convenient that a simple union of this pattern and i1 , yields an equivalent pattern produced by combining i1 and i2 , We can also find that combination of the pattern (2) and i4 yields, and it is equivalent to the pattern, with other items produces patterns no more than once. We introduce concepts including ones used in [9] with some extensions. Definition 4 (property). A property of a target instance e on a check literal c wrt DB R is a minimal set L of ground atoms in R satisfying 1. L includes exactly the one check literal c ,and 2. L can be given a linear order where every term in an input argument of a Definition 5 (variablization). For a ground formula  X  aformula  X  is a vari-ablization of  X  when 1.  X  does not include any ground term, and 2. there exists a substitution  X  = { v 1 /t 1 ,  X  X  X  ,v n /t n } that satisfies We assume to use new variables never used before when variablizing. e var ( e  X  L ) denotes a variablization of e  X  l 1  X  ...  X  l m .
 When L is a property of e , var ( e  X  L ) is called a property item (an item in short) of e . Possessing P by e and a query P ( e ) are said as in Definition 1. is possessed by , i.e. R fam | = i1 ( ).
 Here we give combination operators of properties to produce patterns. Definition 7. When IL = { L 1 ,...,L n } is a set of some properties of a target instance e and P i = var ( e  X  L i ) for i =1 ,...,n ,an independently combined the mgu unifying head ( P 1 )  X  =  X  X  X  = head ( P n )  X  .
 When P = ind ( e  X  IL ) a n d P i = var ( e  X  L i ) for a set of properties IL = { L i  X  n ) R | = P i ( e ).
 the pattern P = var ( e  X  ( L 1  X  ...  X  L n )) .
 Example 3 (cont.). For IL 1 = { pr1 , pr2 } of the example, its i-pattern is,
P The s-patterns of IL 1 and also of IL 2 = { pr4 , pr5 } are as follows.
P
P We realize that P 2 and P 3 can be combined like i-pattern, that is, which is another different pattern from others.
 head( P 1 )  X  = ... =head( P n )  X  .

Move to treat the equivalence among items. We have i2 = var (  X  pr2 )  X  i5 = var (  X  pr5 ). In that case we can be aware of The union pr2  X  pr5 can be taken as a compound property. Not only it is equivalent to pr2 and pr5 but it has the same role to make s-pattern. equivalent properties as a compound property.
 Definition 9. Let  X  be the set of all properties of a target instance e of a given R .Then  X  is a relation on  X  defined as, Then for an equivalent class E  X   X /  X  , pr  X  E pr is a compound property and a pattern str ( e  X  E )= var ( e  X  X  X  pr  X  E pr ) is called a compound property item caused by E .
 Example 4 (cont.). i2  X  i5 and then pr2  X  pr5 . Hence E =[ pr2 ]  X  =[ pr5 ]  X  = { pr2 , pr5 } yields a compound property item, We are ready to describe the algorithm. Unlike Mapix an equivalent class of properties, i.e. E =  X /  X  , is an item. A pattern is made from a subset of E using not appeared in the target instance. Otherwise their s-pattern is equivalent to their i-pattern. So another components, binders ,areused. bind i,j designates to use str () for E i and E j in E .

B = bind i,j  X  pr  X  E i ,  X  pr  X  E j , pr and pr  X  share a term not appeared Example 5 (cont.). The example has equivalent classes E = { E 1 ,E 2 ,E 3 } where E because pr1  X  E 1 and pr2  X  E 2 share ichiro and pr5  X  E 2 and pr4  X  E 3 share yoko .(Weomit bind 2 , 1 and bind 4 , 2 .) A subset S  X  X  X  X  makes sense when for every bind i,j  X  SE i and E j are also in S . In this case we call S valid. For a valid S  X  X  X  X  a subset S  X  S is called a bind-maximal if S is a maximal subset s.t. it includes a binder bind i,j for every pair of E i ,E j  X  S .
 Definition 10. When S 1 ,...,S m are all of the bind-maximal subsets of a valid S  X  X  X  X  , the pattern represented by S , denoted by pat ( e  X  S ) ,is { E { E { E Table 2 shows the algorithm, EquivPix (an equivalent-cla ss-based miner using property items extracted from examples), which enumerates all of subsets of E X  X  that represent frequent patterns. The main routine simply obeys Apriori. Candidate has differences from the original. Since EquivPix uses binders it can not nominated yet. It introduces binders at the second level in Line 7. As Mapix does EquivPix also checks the subsumption in Line 8 to prohibit duplicate patterns.

Properties and binders have to be from a single instance in principle. This is partially solved. If a single instance includes all structure appeared in in-stances the instance is enough to produce all patterns. The idea is to integrate all instances to a single instance. It is done by making an isomorphism from an instance to another. Then all terms are replaced by terms mapped by the morphism. This overlapping yields a single large instance and it is reduced by the subsumption equivalence. Unfortunately this integration do not keep all of properties before the integration. EquivPix is implemented using SWI-Prolog on PC of Xeon 2.8GHz. We con-veyed a simple experiment to compare with Mapix and Warmr using a dataset Bongard. Its language bias is modified to test algorithms appropriately. As in Table 3 EquivPix produced 625 patterns while Warmr , a complete enumera-tor, produced 782 patterns, a part of tot al 5480 outputs including duplication. Runtime was less than double of Mapix .

EquivPix includes ideas: (1) two combination operators for properties ex-tracted from samples; (2) equivalence of properties to make compound prop-erties, which keeps efficiency and prohibits duplicated patterns; and (3) the heuristics to integrate instances. The number of patterns output by EquivPix approached to Warmr compared to Mapix .

