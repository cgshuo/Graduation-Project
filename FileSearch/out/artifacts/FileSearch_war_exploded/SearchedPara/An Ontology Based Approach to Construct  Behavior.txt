 amount of data make WIS development a troublesome and complaining task. quite different and hard to be integrated. can be found in reference [5] [6]. good template for codes generation. difficult for modeling. following features: z WISE Builder implements the system behaviors as page elements and supports z By analyzing the domain ontology, WISE Builder gets the characters of each summarizes the paper and discusses future work. and generation of WIS behaviors. work. deficient at the same time. applications. tools and WISE Builder. conveniently by other tools through XML interface. information system. are rather complex. They will be defined step by step. 3.1 Review of Domain Ontology work [13] . The main concepts are as follows: information, Constraints is a set of constraints for the value. Constraints can be used to verify inputs. AddTag records the style of the pieces. 3.2 The Definitions of Behavior Ontology the dynamic process of WIS in the following example. scenario as Table 2. behaviors. system functions in WHRP. We have following observations from the example: some basic items such as clicking buttons; validated to ensure the safety and efficiency; etc; those things. To format above observations, we introduce: the format of constraint about the item. and display results .
 the page to display search results; page itself, thus the page will be updated to display results. behavior ontology: example of the behaviors is described in XML as in Figure 3 domain piece to define the WIS ontology component component. is called Page Component , and the latter one is called Child Component . 3.3 The Problem Specification gives a new observation: items in same component. components) contain more than 18 basic items. the action type of B .
 paper: ontology component C . behavior. ontology: Algorithm 1 Statistics of Items Input: A piece of domain ontology, named Piece  X  Output: A statistic set of piece items, named StatSet Interior variables: a variable denotes the basic item, named Item; Begin 1 Initialize the stack; 2 For each line of the file Piece, do 3 If the line contains  X &lt;  X  X hen 4 Push the current XML element in stack; 5 Else if the line contains  X &lt;/ X  and the element.type !=  X  X iece X  6 Pop stack top to variable Item; 7 If Item.Type is included in StatSet 8 Add 1 to  X  X ime X  of corresponding; 9 Else 10 Create a new record R of StatSet; 11 R.Type  X  Item.type; 12 R.Time = 1; 13 End if 14 End if 15 End for 16 Return StatSet; END Algorithm 1 is O(n 2 ).
 The proofs of the propositions are omitted here due to page limitation. Algorithm 2 Determine Action Types RuleSet; Output: The set of action types, named ActionTypes; Interior variables: a variable denotes the rule in RuleSet, named Rule Begin 1 Initialize the stack; 2 For each line of the file RuleSet, do 3 If the line contains  X &lt;Rule&gt; X  4 Push the current XML element in stack; 5 Else if the line contains  X &lt;/Rule&gt; X  6 Pop stack top to variable Rule; 7 Search Rule. Presupposition in StatSet; 8 If( Rule. Presupposition in StatSet) 9 ActionTypes = ActionTypes Rule.Result; 10 End if 11 End for 12 Return ActionTypes; END complexity of Algorithm 2 is O(m*n). Clear.
 Algorithm 3 Building Actions named Piece; Output: a set of generated actions, named ActionSet; Interior variables: a variable denotes an action, named Action. Begin 1  X  For each action type of the set ActionTypes, do 2  X  If the type is  X  X elect X  3  X  Action  X  Generate_Select_Action; //Procedure 1 4  X  ActionSet = ActionSet Action  X  ; 5  X  Continue; 6  X  Else if the type is  X  X nsert X  7  X  Action  X  Generate_ Insert_Action; //Procedure 2 8  X  ActionSet = ActionSet Action ;  X  9  X  Continue; 10  X  ............ 11  X  Else if the type is  X  X lear X  12  X  Action  X  Generate_ Clear_Action; //Procedure 5 13  X  ActionSet = ActionSet Action ;  X  14  X  Continue; 15 End if 16 End for 17 Return ActionSet; END limitation. Procedure 1 Generate_Select_Action Input: The piece, named Piece; Output: Generated select action, named SAction; Interior variables: a variable denotes the basic item, named Item; Begin 1 SAction. ActionType  X   X  X elect X ; 2 Search in Piece for the basic item  X  X able X ; 3 Item  X  search result; 4 SAction. Destination  X  Item.ItemName; 5 Table  X  Item.ValueInfo.Table; 7 For each basic item I of the search result, do 8 Item  X  I; 9 SAction. ParameterItemNames = ParameterItemNames Item.ItemName; 10 End for 11 Return SAction; END complexity of Algorithm 3 is O(m*n). Algorithm 4 Generating Conditions Output: a set of conditions, named ConditionSet; the action, named Action; a variable denotes the condition, named Condition; Begin 1 For each action A in ActionSet, do 2 Action  X  A; 3 For each ItemName in Action, do 5 Item  X  I ; 6 Condition.ItemName  X  Item.ItemName; 7 Condition.ValidConstraints  X  Item.Constraints; 8 ConditionSet = ConditionSet Condition; 9 End for 10 End for 11 Return ConditionSet; END and c be the length of the piece, the complexity of Algorithm 4 is O(a*b*c). size is always small, so the total time complexity is acceptable. omitted here due to page limitation. good quality. problems: automatic tool named WISE Builder, the main contributions include: more work to be done, such as: z Implementing user custom action and complex behaviors: WISE Builder can anonymous reviewers for their comments. 
