 With the emergence of XML as the de facto standard to exchange and disseminate information, the problem of regulating access to XML documents has attracted a considerable attention in recent years. Existing models attach authorizations to nodes of an XML document but disregard relationships between them. However, ancestor and sibling relationships may reveal information as sensitive as the one carried out by the nodes themselves (e.g., classification). This paper advocates the integration of relationships as first class citizen in the access control models for XML and makes the following contributions. First, it characterizes important relationship authorizations and identifies the mechanisms required to translate them accurately in an authorized view of a source document. Second, it introduces a rule-based formulation for expressing these classes of relationship authorizations and defines an associated conflict resolution strategy. Rather than being yet-another XML access control model, the proposed approach allows a seamless integration of relationship authorizations in existing XML access control model. D.4.6 [Security and Protection] Access controls; H.2.7 [ Database Administration ] Security, integrity, and protection Security, Legal Aspects Data confidentiality, XML access control, XML relationship, need-to-know and consent principles . XML has become the de facto standard to describe, exchange and disseminate any kind of information among various partners and for various purposes. Meanwhile, safeguarding data confidentiality, privacy and intellectual property has become a primary concern for citizens, administrations and companies. This motivated several recent works on XML access control, tackling different facets of the problem. Discretionary [2,8,12,16], Role-Based [15, 25] and Mandatory [7] access control models have been proposed in the context of XML. A particular attention has been paid on the granularity of the access control (from DTD to attribute instances) [2,8,12], on the performance of the algorithms implementing this control [7,19,26], on the distribution channel used to expose the information (pull, push, selective dissemination) [3,5,20] and on the tamper-resistance of the access control [6,18,23]. All these works have the commonality to focus the access control on the nodes of an XML document (elements and attributes). Ancestor and sibling relationships among nodes are not considered as legitimate targets of the access control. Roughly speaking, an access control policy is composed of a set of positive (resp. negative) authorization rules granting (resp. denying) a given subject access to some nodes of the document. These nodes are usually selected thanks to XPath expressions. The descendant relationship among nodes is simply exploited as a mean to propagate authorization rules down through the XML hierarchy. There are substantial differences among the models in the way conflicts among  X  potentially propagated  X  positive and negative rules are tackled. In [2,12], the complete subtree rooted at a forbidden node is forbidden. This constraint is relaxed in [8], allowing exceptions to a negative rule to be expressed. However, this leads to make visible the label (i.e., tag) of forbidden ancestor(s) in the path from the root to an authorized node. Replacing the node label by a dummy value has been proposed in [10,13] to reduce information disclosure in such situation. These discrepancies among the models brings to light the difficulty to define accurately the view that s hould be delivered of the path leading to an authorized node. More precisely, disregarding XML relationships in the expression of the access control leads to two important problems. -Classification disclosure : the structure of an XML document -Uniform filiation: the authorization rules expressed on These two problems hurt the basic need-to-know and consent principles enacted in most directives and laws related to the safeguard of personal information, like the Federal Privacy Act in the US [22] and the Data Protection Directive in the EU [9]. The need-to-know principle limits access to information to those people who need strictly this information to carry out their duties. Clearly, classification disclosure hurts this principle each time the information contained in a given subtree (e.g., a personal folder) is self-content wrt a given purpose. The consent principle prohibits the disclosure of personal information without the explicit consent of the donor in a number of situations defined by the law. In our context, this means that the donor must be given some prerogative to control how her information (e.g., her medical folder) is exposed and made accessible in an XML document. This requirement contradicts a uniform filiation. More than ever, there is a strong need to define access control models that help translating more accurately law principles into practice. To make a step forward in this direction, this paper advocates the integration of ancestor and sibling relationships as first class citizen in the access control models for XML. As mentioned above, relationships between nodes may reveal information as sensitive as the one carried out by the nodes themselves and hence, deserve to be protected as such. The objective is to provide means to control accurately the view that must be delivered of the path leading to any authorized node (i.e., subtree) in an XML document. More precisely, this paper makes the following contributions : 1. Characterization of relationship authorizations The first problem is to characterize which relationships need to be protected and to define the means by which they can be protected. We identify the relationship authorizations required to deal with the classification disclosure and uniform filiation problems. Then, we exhibit the mechanisms necessary to translate them accurately into the authorized view of a source document. 2. Relationship-aware access control model The second problem is to define a simple but comprehensive access control model encompassing nodes and relationships authorizations. We propose a rule-based formulation for expressing relationship authorizations and we define a conflict resolution strategy to manage the conflicts that may occur among them. Rather than being yet-another XML access control model, our approach allows a seamless integration of relationship authorizations in existing XML access control models. The paper is organized as follows. Section 2 introduces a case study motivating the integration of XML relationships in the expression of access control policies. Section 3 characterizes the relationship authorizations required to deal with the classification disclosure and uniform filiation problems. Section 4 introduces a rule-based formulation for expressing relationship authorizations and discusses the upward compatibility of our approach with existing XML access control models. Section 5 presents related works. Finally, section 6 concludes and sketches important open issues. We built our motivating example from requirements expressed by a real life medical application related to the treatment of AIDS disease. Figure 1 depicts the way the medical information of interest is structured. Organizing a safe sharing of medical folders among several parties (patients, physicians, pharmacists, medical labs, Medicare and insurance companies) having different duties and objectives is a rather challenging task. Below are three examples of simple but important authorization rules that cannot be managed accurately with existing XML access control models .  X  R1 : Hide to the hospital X  X  directory application the name of As stated in HIPAA (Health Insurance Portability and Accountability Act) [24], the hospital directory is a rather sensitive information considering the inquiries made about patients by relatives, employers, media, police and members of religious groups. The effect of this authorization rule on the document pictured in Figure 1 should be to attach the element of each patient of interest to a depersonalized medical service element (i.e., element with an anonymous label) while keeping the ancestor chain of the other folders unaffected. XML access control models like [2,12] give the ability to hide a folder in the document. This does not match the objective since the presence of the patient in the hospital turns to be hidden as well, which is not the purpose of Rule R1. The model proposed in [8] allows defining a negative rule on a medical service and a positive one on folder. Unfortunately, the label of the medical service (the information to be protected in our context) will be disclosed. This problem is tackled in [10,13], by replacing this label by a dummy value. However, whatever be the model, classification disclosure is not precluded and above all, the authorization rule applies uniformly to all folders, neglecting the patient X  X  consent.  X  R2 : Hide to pharmacists the fact that some drug The pharmacist must be aware of all prescriptions to check drug incompatibilities. However, giving him the knowledge that some drugs participate in a protocol discloses unnecessary information on the patient X  X  disease and its stage. The expected effect of this authorization rule is to drop Protocol elements and attach elements as direct children of their MedActs ancestor, giving them a position similar to regular Act elements. Depersonalizing Protocol is useless in this case since that information would be obvious to infer ( Act elements children of MedActs children of Protocol form two classes with their ancestor as a distinguishing factor). Again, existing access control models give the ability either to hide the complete subtree rooted at a Protocol element or to depersonalize Protocol elements. Both solutions hurt the need-to-know principle by disclosing too little or too much information.  X  R3 : Hide to medical labs the correlation between medical and HIPAA stipulates that the patient consent is required for any disclosure related to marketing. In the following we assume that the medical information ( MedActs, Analysis ) is required wrt the need-to-know principle while the administrative information ( Name, Address ) is collected under the patient consent for marketing purpose (e.g., related to new medications). The expected effect of this authorization rule is to make both groups of information available while precluding the inference of their initial sibling relationship . Using existing access control models would impose to define two separate access control policies for the same document and the same user (i.e., the medical lab). However, the conjunction of both authorized views must be precluded and the risk of inference mentioned above must be carefully tackled, a rather challenging issue [14]. These three situations demonstrate the limits of existing access control models and advocate the integration of explicit authorizations on ancestor and sibling relationships in the expression of access control policies. On the other hand, authorizations on nodes are well suited to define the fraction of each folder that must be disclosed in each situation. The three expected authorized views of the initial document, derived by a combination of nodes and relationship authorizations, are pictured in Figure 2. Finally, one may wonder about the number of authorization rules that should be defined to capture the personal consent of each person. While consent is a personal matter, it is worth-noting that its dimensions (as enacted by the law) are quite reduced. Therefore, consent can be integrated in each folder by dedicated XML elements, allowing capturing the common consent of several people in a single set-oriented authorization rule. This point will be illustrated in Section 4. Existing XML access control models interpret an access control policy as a mapping between a source document (or Source short) and an authorized view of this same document (or and rely on the assumption that View  X  Source precisely, authorization rules select the subset of that will participate in View . As a side effect, edges having one of their extremity node discarded by an authorization rule are in turn discarded from View . As our motivating example makes clear, considering relationship authorizations compels us to revisit this assumption since View may result from a more complex restructuration of Source . Typically, new paths and nodes may appear in View and the node ordering may be different from the Source one to prevent inference. In other words, represents the total amount of information a grantee can gather by subsequent queries. In this section, we concentrate on the semantics of relationship authorizations and define for each of them its impact on the resulting View . Let us now introduce the model of XML document we consider and the associated notations that will be used along the paper. An XML document d is defined by a tuple ( Label d , Value d  X   X  Label d : is a set of element labels (also called tags) and  X  Value d : is a set of attribute/element values of type string.  X  N d = N e d  X  N a d is a set of nodes representing elements and  X  r d : is a particular node representing the document root.  X   X  label : N d  X  Label d is the node labeling function.  X   X  value : N d  X  Value d is the node valuation function.  X   X  order : N d  X  Integer is the node ordering function, reflecting a In addition, Anc(n) , Child(n) , Desc(n) and Sibling(n) denote respectively the set of ancestors, childs, descendants and siblings of a given node n  X  N d and Parent(n) denotes its parent node. Path(n1,n2) denotes a path from node n1 to node n2 . According to this model, an XML document is modeled as a labeled graph where nodes represent elements and attributes, and edges relationships between them. If a node does not have any parent, it is implicitly linked with the document root. Taking into account user X  X  consent in a ccess control models imposes to generate in View different replicas of the same Source nodes and paths. Basically, replicating a n1 is required each time two of its authorized descendants n2 and n3 must be reachable in View by a path delivering two conflicting visions of n1 to conform to the semantics of a given authorization rule. Rule R1 of our motivating example illustrates this point. Since an XML document is a tree, every node participating in the common subpath Path (n1,Parent(n2))  X  Path(n1,Parent (n3)) has in turn to be replicated. Cloning is the principle by which Source elements and paths are replicated in View . Note that leaf nodes of a source document (terminal elements and attributes) are never subject to cloning. In the following, we use the term original and clone(s) to distinguish in View between the genuine image of a Source element or path, and the element(s) or path(s) resulting from a cloning operation. Element Cloning We denote by  X  i  X  N e View the i th clone of node n  X  N Subscripts are used when the different clones of a same node have to be distinguished and are omitted otherwise. The label, value and order of a clone are defined as follows: Where Shuffle defines a random order among the clones being sibling of a same node. The n ecessity of shuffling is explained afterward. Path Cloning Let u be a path (n1,n2...nk) / n1,n2...nk  X  N (n1,n2)...(nk-1,nk)  X  E Source ,  X  denotes the clone of u and is defined by ( X 1, X 2... X k) /  X 1, X 2... X k  X  N e View and ( X 1, X 2)...( X k-1, X k)  X  E View . The ordering of clones in View has to be carefully managed to avoid basic inference. To illustrate this, let us consider Rule R3 of our motivating example and assume that the View ordering is such that all instances of the two groups ( MedActs , Analysis and ( Name , Address ) keep the same relative order as in Source . In this case, their initial sibling relationship, which should be obfuscated by the cloning mechanism, is patently disclosed by the element ordering (i.e., the i MedActs , Analysis ) corresponds to the i th instance of ( Address )). A similar problem exists with Rule R1 if the clones of a medical service element are placed in close proximity to their original (e.g., direct right or left sibling). Thus, cloning does not make sense without node shuffling (see Figure 2.a and 2.c). Node shuffling Node shuffling is a recursive process that applies at each node of View containing clone children. All clones, children of a given node, are shuffled together to prevent ordering-based inference. For a given node, the clone children are grouped after the original ones (by convention), and then shuffled. The relative order of the original children must however be preserved in View since node ordering is significant in XML. The ordering function  X  therefore satisfy the two following properties:  X   X  ni,nj  X  N Source ,  X  ni X ,nj X   X  N View / ni=ni X  and nj=nj X ,  X 
By default, a clone inherits the label of its source counterpart, except if the anonymous value is explicitely selected.  X   X   X   X  N View ,  X  order ( X )=random(]max(  X  order (Parent( X )), where iops and ifol denote respectively the immediate original preceding sibling and immediate following of a given node, where preceding sibling and following conform to the XPath semantics. Relationship authorizations are introduced to tackle the two problems identified in the introduction and exemplified in the motivating example, namely classification disclosure and uniform filiation. Let us first consider classification disclosure. The objective is to mask the membership of a given descendant node n to a given have to be carefully distinguished. The information to be protected can be either: (1) to which class the node n belongs to, or (2) the fact that n is actually classified. In the former case, the information to be hidden is the identification of the class n belongs to. This information is carried out by the ancestor node a , either by its label, by one of its attribute or by one of its sub-element. Cloning the ancestor node a and the path leading to n is a mean to hide this information. Indeed, attributes and sub-elements do not participate in the cloning operation and a X  X  label can be made anonymous if it actually conveys the class identification. This leads to a first class of authorization called ancestor depersonalization . In the latter case, the information to be hidden is the presence of a class membership reveals an exception to a general situation (e.g., Rule R2 of our motivating example). Cloning the path from the ancestor node a to n allows discarding a from that path. This leads to a second class of authorization called path reduction . Regarding now the uniform filiation problem, the objective is to allow descendant nodes expressing potentially different requirements in terms of classification disclosure. Hence, both problems have to be considered jointly. Cloning provides a uniform solution to them. Indeed, cloning the path linking an ancestor to one of its descendant gives the opportunity to personalize the authorized view of each ancestor relationship. The semantics of ancestor depersonalization and of path reduction authorizations is defined as follows in terms of their expected effects on View . Let n  X  N Source . Let a, u  X  N e Source and u = Parent(n). Ancestor depersonalization -If a=u then Element_Cloning(a) else Path_Cloning(a,u); -Parent( X )  X  Parent(a); -Parent(n)  X   X  ; // if a=u then  X  =  X  Path reduction -If a=u then Parent(n)  X  Parent(a) else { Let e  X  N e Source / e = Child(a)  X  Anc(n) -if e=u then Element_Cloning(e) else Path_Cloning(e,u); -Parent(  X  )  X  Parent(a); -Parent(n)  X   X  ; // if e=u then  X  =  X  } Notice that n is always attached along with its potential subtree to the extremity of the cloned path. At this point, it is interesting to note that node authorizations in existing models follow a top-down approach in the sense that node authorizations usually propagate down through the XML hierarchy. Conversely, ancestor depersonalization and path reduction authorizations follow a bottom-up approach by impacting the relationship between descendant nodes and their respective ancestors. While masking the membership of a given node to a given class, care should be taken about the correlation between that node and its initial siblings. The semantics introduced in the preceding section for relationship authorizations implicitly break down sibling relationships. This side effect may hurt the need-to-know principle in a number of situations. Conversely, implicitly preserving all sibling relationships while disconnecting a node from a class resurrects the uniform filiation problem and hence may hurt the consent principle. Therefore, there is a need for a more selective sibling decorrelation to cope with situations where a node has to retain its relationships with a group of siblings while being disconnected from its initial class. Sibling Selection on Ancestor Relationships Let n  X  N Source and n' its image in N View . Let g1, g2  X  N  X  e1, e2  X  g1  X  g2, Parent(e1)=Parent(e2)= Parent(n). Keeping the sibling relationship between g1  X  X  elements and n has the following impact on the document View : As a conclusion, dealing with classification disclosure and uniform filiation introduces a two-dimensional problem that must be tackled on a node basis: (1) how the relationships between a given node and its ancestors must be mapped in View ; (2) which sibling relationships have to be preserved for that node in How relationship authorizations are actually declared, how they interact with node authorizations and how conflicts among rules are managed is the topic of the next section. An authorized view can be seen as the result of a global selection and restructuration process applied to the source document. At first glance, a general-purpose language like XQuery could be considered as the appropriate mean to define this process. However, even simple XML document restructurations can result in rather complex XQuery expressions [11]. For this reason, we follow in existing XML access control models X  footstep by expressing an access control policy as a set of authorization rules, a rule engine being responsible for managing conflicts among rules and for translating Source into View according to these rules . Our approach allows a seamless integration of relationship authorizations in existing models. In this section, we first introduce a reference model for expressing node authorizations that captures the common foundation of existing XML access control models. Then, we propose an extension to this reference model that supports relationship authorizations. While existing XML access control models introduce subtleties on the way node authorizations propagate down through the hierarchy and conflicts are solved, they share strong commonalities. Basically, an authorization rule takes the form of a tuple &lt; Subject, Object, Operation, Sign &gt;. Depending on the models, Subject can take many forms (a user, a group of users, a role, an application, an IP address, etc). Object characterizes the part of the XML document targeted by the rule. Due to its simplicity and expressiveness, XPath is usually the language elected to identify the target nodes of each rule. Operation denotes the operation (read, update, etc) the Subject may perform on the Object. Finally, Sign denotes either a permission (grant rule) or a prohibition (deny rule) for that operation. In the sequel, we do not make any assumption on the way subjects are managed and, since the focus is on data confidentiality, read is the only operation of interest. A node authorization rule NA is defined by a entity, Objects  X  N Source , Sign  X  {+, -}. To match the well accepted least privilege principle, we consider a closed policy, meaning that an implicit negative authorization applies to the whole document. In other words, the access to every object that is not explicitly authorized is forbidden. We assume that both positive and negative authorizations propagate implicitly down through the XML hierarchy. This mode of propagation corresponds to the cascading option present in well-known models [3,8,12,19]. Conflicts between direct and/or propagated rules are managed as follows. Let us assume two rules R1 and R2 of opposite sign. These rules may conflict because they are defined either on the same node, or on two different nodes n1 and n2 , linked by an ancestor relationship (i.e., n1  X  Anc(n2)). In the former situation, the Denial-Takes-Precedence policy favors the negative rule according to the least privilege principle. In the latter situation, the Most-Specific-Object-Takes-Precedence policy favors the rule that applies directly to a node against the inherited one (i.e., R2 takes precedence over R1 on n2 ). In other words, authorizations propagate until overridden by an opposite authorization on a descendant node. A relationship authorization rule RA is defined by a tuple &lt; Subject, Objects &gt;, where Objects is in turn defined by a 4-tuples: &lt; Anc, Desc, Path-visibility, Sibling &gt;  X  Anc and Desc characterize the relationship(s) to be protected among a (set of) descendant(s) and one of its (their) ancestor. 
Anc and Desc are the common denominator of all relationship authorizations. They are both defined as XP {[],*,//} expressions.  X  Path-visibility characterizes the vision of the path u linking each descendant node to its ancestor. For each node n participating in u , Path-visibility states whether the node is preserved or not in preserved or not in  X  .  X  Implicitly, hiding an ancestor relationship hides the relationship between a descendant node and its siblings. To allow for a selective sibling decorrelation, Sibling characterizes the list of siblings a descendant must keep its relationships with. The RA definition deserves two important remarks. First, RA captures gracefully and in a rather simple way the different forms of relationship authorizations. By defining Anc and Desc as XPath expressions, it allows to sum up  X  Desc  X  ancestor relationships in a single statement. Second, unlike NA, RA does not integrate a Sign parameter. The reason for this is that RA characterizes only negative authorizations. The global semantics of the model is as follows. NA rules are defined according to a closed policy and deliver an authorized view View X   X  Source in the usual way (i.e., edges having one of their extremity node discarded by a NA rule are in turn discarded from rules are defined on View X  according to an open policy and deliver the final authorized view View . Consequently, if no RA rule is defined, the semantics of the model complies with the one of the existing XML access control models. Hence, a seamless integration of relationship authorizations in these models can be reached. Ancestors and Descendants For a RA rule to be consistent, condition Desc  X  Anc must be enforced, where  X  denotes the containment relation between XPath expressions. Unfortunately, the containment problem has been shown co-NP complete for the class of XP {[],//,*} expressions [17]. To avoid consistency checking, Desc is defined as a relative expression with respect to Anc. Thus, Anc determines a set of path origins while Anc/Desc determines a set of path extremities. Path visibility and Sibling Table 1 (resp. Table 2) summarizes the possible choices for the Path-visibility (resp. Sibling) parameter along with their associated semantics. The first row of each table gives an extensive syntax for the corresponding parameter while the next rows propose shortcuts to express a monotonic policy along the path. 
Path-visibility Semantics of Path visibility [label 1 ?,.,label n ?] gives the list of nodes to be discarded (?= X ) [label 1 ,...label n ] Nodes those label belongs to this list must keep Figure 3 illustrates the use of a relationship-aware access control model for expressing the access control rules introduced in our motivating example. Each of these rules actually mix NA and RA rules. Some NA and RA rules reference the user X  X  consent. We do the assumption that the user X  X  consent is materialized by a Consent element present in each folder. The element is in turn composed of subelements (e.g., marketing ) expressing each dimension of this user X  X  consent. For expressing R1, three NA rules are required. NA1, NA2 and NA3 capture the information strictly required by the hospital X  X  directory group to accomplish their duty (typically, MedActs Analysis are withdrawn). RA1 depersonalizes ([  X  ]) the medical service ancestor (/* targets all medical service elements) of each folder owned by a patient who didn X  X  consent disclosing that information and disconnects that folder from its siblings ([  X  ]). For rule R2, RA2 alone expresses a path reduction discarding the parent Protocol ([  X  ]) of Act elements. For expressing R3, two NA rules deny to the medical lab access to the name and address of patients who didn X  X  consent disclosing this information for marketing purpose. For patients giving their consent, RA3 precludes the inference between the identification information ( Name , Address ) and the rest of the folder. Three classes of conflicts have to be tackled in a relationship-aware model: conflicts among NA rules, conflict between NA and RA rules and conflicts among RA rules. The resolution of conflicts among NA rules is directly inherited from existing XML access control models and is detailed in Section 4.2. Conflicts between NA and RA rules are avoided by construction since RA rules are defined on the view produced by the evaluation of NA rules, according to an open policy. In other words, NA rules always take precedence on RA rules. This section is thus devoted to the management of the third class of conflicts, namely conflicts among RA rules. Again, three classes of conflicts among RA rules have to be distinguished: conflicts on Desc (different rules targeting the same descendant node), on Path-visibility (different rules targeting the same ancestor-descendant relationship with different Path-visibility options) and on Sibling (different rules targeting the same ancestor-descendant relationship with different Sibling decorrelations) Conflicts on Desc Conflicts on Desc arise when two rules RA1 and RA2 are such that RA1.Anc  X  RA2.Anc and RA1.Desc=RA2.Desc, here  X  denotes the inclusion of XPath expressions. Independently of the value of the Path-visibility and Sibling parameters, rule RA1 states that a new path has to be created from any pair of nodes (Parent(n1),n2) such that n1  X  RA1.Anc and n2  X  RA1.Desc, thereby hiding the ancestor relationship between n1 and n2 . Similarly, rule RA2 states that a new path has to be created from any pair of nodes (Parent(n3),n2) such that n3  X  RA2.Anc and n2  X  RA2.Desc. Since RA1.Anc  X  RA2.Anc, Parent(n3)  X  Anc(Parent(n1)). Thus, hiding the ancestor relationship between n3 and n2 in turn hides the one between n1 and n3 , due to the transitivity of the ancestor relationship. In other words, RA1 is subsumed by RA2. Conflicts on Path-Visibility Path-visibility conflicts arise when two different rules, targeting RA1.Anc=RA2.Anc and RA1.Desc=RA2.Desc), exhibit two different Path-visibility. Table 3 summarizes all possible combinations of Path-visibility for these two rules and their associated conflict resolution. The proposed conflict resolution being commutative, operand1 and operand2 represent either the Path-visibility of RA1 or RA2. While solving conflicts, the decision is always taken based on the least privilege principle. If one rule does not impose any restriction on the path, the Path-visibility of the second rule always takes pr ecedence (row 1). If one rule discards all nodes from the path, its Path-visibility always takes precedence (row 2). Row 3 is self-explanatory. If one rule depersonalizes all nodes on the path while the other rule missing depersonalized labels (row 4). Finally, if each rule selects a list of labels, the union of the two lists has to be computed (row 5). If the same label is present on both lists, label precedence over label i  X  . Operand1 Operand2 Conflict Resolution [label 1 ?,..., label n ?] Conflicts on Sibling Sibling conflicts arise when two different rules, targeting the same ancestor-descendant relationship, exhibit two different sibling decorrelations. Table 4 summarizes all possible combinations of Sibling for these two rules and their associated conflict resolution. Again, the proposed conflict resolution being commutative, operand1 and operand2 represent either the Sibling parameter of RA1 or RA2 and the conflict resolution is done in accordance with the least privilege principle. 
Operand1 Operand2 Conflict Resolution [label 1 , ... Row 1 states that [  X  ] takes always precedence over [  X  ], (the descendant is disconnected from all its siblings). In the same way, [  X  ] and [label1,...,labeln] takes always precedence over [  X  ], since [  X  ] is the less restrictive policy (row 2). Conflicts between (row 4) can be treated uniformly, considering that [  X  ] is nothing but the singleton [  X  label (desc)]. Solving the conflict sums up to compute the intersection between both lists of labels. If this intersection turns to be empty, [  X  ] becomes the final decision. Note that sibling conflicts may happen indirectly if a same node is selected to participate in different groups of siblings (e.g., RA1:&lt;-duplicate A elements in order to integrate them at the same time in B X  X  and C X  X  siblings. However, the presence of the same A element(s) in both sets may allow some inference regarding the relationship between B and C elements. For this reason, the conflict is solved by enforcing [  X  ] as the Sibling parameter of the conflicting rules. As stated in the introduction, the problem of regulating access to XML documents has attracted a considerable attention from the database community in recent years. Most discretionary access control (DAC) models for XML [1,2,3,8,12] share the same foundation while proposing different interpretations or options to define subjects, to propagate rules down through the hierarchy and to solve conflicts among rules. [19] introduces static analysis rather than run-time checks for this class of models. [16] proposes a provisional access control model that allows for more sophisticated controls (e.g., an access can be granted provided it is recorded in an audit trail). All these models focus on node authorizations and then fail in answering the requirements introduced in our motivating example. In addition, and as mentioned in the introduction, expressing an exception to a negative rule may lead to tricky situations that are difficult to manage accurately without relationship authorization. While this situation is even not mentioned in certain proposals, some models preclude it [2,12,19] while some others disclose the label of forbidden ancestors [8,16] or disclose at least the presence of these ancestors by replacing their label by a dummy value [10,13]. In addition to dummy labels, [10] provides a new answer to this problem by transforming the view of a given path thanks to an XPath expression (executed at traversal time), under the assumption that the resulting view remains compliant with the DTD provided to the subject. Role-based access control (RBAC) models for XML [15,25] suffer from the same limitation wrt access control on XML relationships. Finally, mandatory access control (MAC) models for XML deserve an interesting remark regarding the management of XML relationships. MAC models are generally monotonic, meaning that sensitivity level (classification in the MAC vocable) assigned to objects increase along the hierarchy (i.e., descendants have a higher sensitivity level than their respective ancestor). Therefore, the situation where a given subject is granted access to a descendant of a prohibited node can simply not be expressed. [7] introduces a non-monotonic MAC model that circumvents this limitation. However, the focus of this work is on optimizing the secure evaluation of XPath twig queries. Query rewriting techniques are used to append additional security check predicates on sensitivity levels to the original twig query. Therefore, the model can grant access to a descendant of a forbidden node but no visibility can be given of the path from the document root to this node. The protection of relationships has been considered in other contexts. Access control models for object-oriented databases handle relationship authorizations but with a focus on instantiation and inheritance [21]. [4] deals with the identification of sensitive associations in a relational context but for release control rather than access control. Finally, [14] introduces the concept of association security objects in the RDF context. An history of query results is built and serves for the detection of forbidden correlations among data. Therefore, we are not aware of other works trying to tackle the classification disclosure and uniform filiation problems in XML. In addition, due to the lack of explicit ancestor relationship authorizations, granting access to a descendant of a prohibited node is either impossible or source of important difficulties in existing models. Several access control models have been proposed so far for regulating access to XML documents. By focusing on node authorizations and disregarding relationship authorizations, these models fail in answering the classification disclosure and uniform filiation problems. The consequence is the violation of the need-to-know and consent principles (two basic principles of laws related to the safeguard of personal information) in a number of situations. To tackle this important issue, we advocate the integration of ancestor and sibling relationships as first class citizen in the access control models for XML. More precisely, this paper makes the following contributions. First, it characterizes two classes of relationship authorizations (ancestor depersonalization and path reduction) taking into account the sibling relationship dimension. Two mechanisms (cloning and shuffling) are introduced to translate accurately these authorizations into an authorized view of a source document. Second, it proposes a rule-based formulation for these classes of relationship authorizations allowing their seamless integration in existing XML access control models. This makes these models (some of them being well recognized today) relationship-aware. In [11], we shown that tractable algorithms can be devised to support relationship authorizations. To this end, we extended a public domain XML access control algorithm and we c onducted preliminary performance measurements. In this setting, the control of relationship authorizations represented less than 15% of the total cost in most situations. The next step in our research agenda is to study streaming algorithms supporting relationship authorizations. Streaming access control is actually a major issue with respect to performance (management of large documents) and support of new forms of data delivery (selective data dissemination). [1] Bertino, E., Braum, M., Castano, S., Ferrari, E., Mesiti, M. [2] Bertino, E., Castano, S., Ferrari, E., Mesiti, M. Specifying and [3] Bertino, E., Ferrari, E. Secure and Selective Dissemination of [4] Bettini, C., Wang, X.S., Jajodia, S. Identifying Sensitive [5] Birget, J., Zou, X., Noubir, G., Ramamurthy, B. Hierarchy-Based [6] Bouganim, L., Dang-Ngoc, F., Pucheral, P. Client-Based Access [7] Cho, S., Amer-Yahia, S. , Lakshmanan, L., and Srivastava, D. [8] Damiani, E., De Capitani di Vimercati, S., Paraboschi, S. , [9] European Directive 95/46/EC, "Protection of individuals with [10] Fan, W. , Chan, C.Y. , Garofalakis, M. Secure XML Querying [11] Finance, B, Medjdoub, S, Pucheral, P "The case of access [12] Gabillon, A., Bruno, E. Regulating access to XML documents . [13] Gabillon, A. An Authorization Model for XML DataBases . ACM [14] Gowadia, V., Farkas, C. RDF Metadata for XML Access Control. [15] Hitchens, M., Varadharajan, V. RBAC for XML Document [16] Kudo, M., Hada, S. XML Document Security based on [17] Miklau, G., Suciu, D. Containment and equivalence for an [18] Miklau, G., Suciu, D. Cryptographically Enforced Conditional [19] Murata M., Tozawa A., Kudo M., XML Access Control Using [20] OASIS standard, eXtensible Access Control Markup Language , [21] Olivier, M., Von Solms, S. A Taxonomy for Object-Oriented [22] The Privacy Act, 5 U.S.C.  X  552a, 1974. [23] Ray,I., Ray,I., Narasimhamurthi, N. A Cryptographic Solution to [24] United States Department of Health and Human Services, [25] Wang, J., Osborn, S.L. A Role-Based Approach to Access [26] Wang, Y., Tan, K.L. A Scalable XML Access Control System , 
