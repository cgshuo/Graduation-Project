 Web services are nowadays emerging as a major technology for deploying auto-mated interactions between distributed and heterogeneous systems. While much of the work on Web services (also called services in the rest of this paper) to date has focussed on low-level standards for publishing, discovering, and invoking them [14], we aim at promoting Web services to the level of active components by using conversations . A conversation is a consistent exchange of messages be-tween participants that are engaged in joint operations and hence, have common interests. A conversation either succeeds or fails. When a conversation succeeds, this means that the expectations out of the conversation are reached (e.g., ac-tion implemented). When a conversation fails, this means that the conversation faced technical difficulties (e.g., communication medium disconnected) or didn X  X  achieve what was expected (e.g., action requested not-implemented).
 search fields [7]. In this paper we discuss conversations from a Web services per-spective. In order to engage in a conversation, Web services have to be leveraged from the level of passive components, which only respond to triggers, to the level of active components, which make decisions in order to adjust their behavior to their surrounding environment. Sensing, collecting, and refining the features of an environment result in defining its context . Context is the information that characterizes the interactions between humans, applications, and the surround-ing environment [5]. Huhns backs the importance of leveraging Web services and suggests using software agents [8]. Indeed Web services, unlike software agents, are not designed to use and reconcile ontologies. Moreover software agents are inherently communicative, whereas Web services remain passive until triggered. others already identify some similarities between Web services and software agents [6]. Web services advertise their capabilities, search for other services, and invoke other services without prior notice. This kind of behavior bears many similarities to software agents. A service accepts requests (i.e., sense) and returns responses (i.e., action) [6]. In addition once a service is invoked it performs tasks with or without further inputs (i.e., autonomy). Despite these similarities, the aforementioned behavior is mainly hard-coded in the service and consequently, limits the service in its actions. Web services should  X  X alk X  to each other so that they can discover their capabilities, reveal their constraints, decide on the actions to take, and coordinate their actions.
 has been achieved to date regarding the seamless integration of conversations into composition approaches of Web services. In particular, several obstacles still hinder this integration including (i) Web services are dealt with as passive components rather than active components that can be embedded with context-awareness mechanisms, (ii) existing approaches for service composition typically facilitate orchestration only, while neglecting contextual information on services, and (iii) lack of support techniques for modeling and specifying conversations between Web services. In this paper the focus is on the conversations hap-pening among a group of Web services, which are called to constitute composite services . The rest of this paper is organized as follows. Section 2 discusses the rationale of using conversations in Web services. Section 3 presents the context-aware conversation approach for composing Web services. Section 4 provides some examples on specifying conversations between Web services. Sec-tion 5 overviews the status of the implementation work and concludes the paper. Ardissono et al. observe that current standards of Web services are integrated into systems featured by simple interactions [2]. Simple because the interactions are based on question-answer communication-patterns (e.g., announce/confirm). However there are multiple situations such as negotiation, that require more than two turns of interaction (e.g., propose/counter-propose/accept  X  reject  X  counter-propose/...,  X  stands for exclusive or). The participants in these situations have to engage in conversations before they reach an agreement. In addition Benatal-lah et al. notice that despite the growing interest in Web services, several issues remain to be addressed before Web services can provide the same benefits as tra-ditional integration middleware do [3]. Benatallah et al. X  X  suggestion to enhance Web services is to develop a conversational metamodel. Yi and Kochut also note that as the range of Web services-based applications expands, complex conversa-tion protocols are required [15]. Participants in these protocols exchange a series of messages that comply with synchronization rules. Last but not least, the Web Services Conversation Language (WSCL) is an initiative, which promotes the adoption of conversations in Web services [4]. WSCL describes the structure of documents that a Web service expects receiving and producing, and the order in which the exchange of documents is expected occurring. In this paper we focus on the conversations that take place among Web services, which are requested to enroll in a composite service as components . These Web services might have different providers and have to engage in conversations in order to agree on what to exchange, how to exchange, when to exchange, and what to expect out of an exchange. 2.1 Stages of Web Services Composition To assess the progress of the conversations during Web services composition, we decompose this progress into three stages: pre-composition, composition, and post-composition.
 Pre-Composition Stage. Because similar Web services exist on the Internet, it is important to search for and identify the services that satisfy user-defined selection criteria (e.g., execution cost/time).Conversations in this stage are about the following aspects:  X  Identification aspect: use search mechanisms (e.g., UDDI registries) to iden- X  Invitation aspect: invite Web services to participate in a composition. The  X  Compatibility aspect: check if the Web services can exchange meaningful Composition Stage. It aims at completing the details that finalize a compo-sition. These details are related to the nature of exchange (e.g., representative, directive) in which the Web services will be involved with peers, with whom to exchange after invitation acceptance, and what to exchange after a positive compatibility check. Conversations in this stage are about the following aspects:  X  Execution aspect: details sent out to Web services on the execution proce- X  Interaction aspect: details sent out to Web services on the invocation proce-Post-Composition Stage. It consists of executing the specification of the com-posite service (we combine service and state chart diagrams for this specifica-tion [10]) by invoking the respective component Web services. Conversations in this stage are about the following aspects:  X  Monitoring aspect: progress acquisition of the status of the Web services.  X  Exception handling aspect: corrective strategies to Web services in case of 2.2 Building Blocks of a Conversation Pre-composition, composition, and post-composition stages have each focussed on specific conversational aspects that occur during Web services composition. Because of the variety and complexity of these aspects, we decided on (i) asso-ciating each aspect with a conversation session and (ii) encoding a conversation session as a course of actions .
 Schemas (CSs) for describing these sessions and their respective courses of ac-tions. A conversation schema is a specification of the exchange of messages that is expected to happen between participants. This exchange depends on several factors including the application domain, current context, and current status of a chronology. For example, a conversation schema describes both the side-effects and corrective actions of a conversation that is misunderstood.
 The argument part is made up of the following arguments: sender, receiver, category, conversation object, and condition of activation. Category corresponds to a conversation aspect as listed in Section 2.1. Conversation object is the topic of exchange (e.g., invitation to participate). Finally, condition of activation is the data elements that are checked before the status of a conversation changes (i.e., conversation takes on a new state). The policy part manages the dynamic aspect of a conversation such as status changes, admissible turns, and timeouts. of conversation schemas (Fig. 2) according to the following elements: (i) current composition stage, and (ii) progress in this stage with regard to the active as-pect. Next, the initiator instantiates the conversation object (i.e., gives a value) and checks the activation condition before it sends a message to a receiver. Upon reception of the conversation object, the receiver adopts one of the fol-lowing options: (i) accept the conversation object and take actions based on the conversation object X  X  content by triggering for example a service; (ii) change the conversation object and submit this conversation object to the initiator by changing for example the triggering time of a service; and (iii) reject the con-versation object and either submit a new conversation object to the initiator or ignore the initiator (this one conforms to a time-out constraint).
 to be satisfied. Some of these requirements include [9]: (i) conversation models should be task-oriented, (ii) conversation models should be associated with a semantics, (iii) conversation models must provide communication abstractions, and (iv) conversation models should be reusable and extendable. In this paper, we specify a conversation schema with state charts. In addition to satisfying some of the aforementioned requirements such as (i) and (iv), encoding the flow of conversations using state charts has several benefits. First, state charts have a formal semantics, which is essential for reasoning over the content of conver-sations. Second, state charts support modeling admissible turns and decision makings during conversations. Finally, state charts offer most of the control-flow constructs that can be found in real conversations (e.g., branching, looping). Fig. 1 depicts the mapping of the arguments of a conversation schema into the concepts of a state chart. This mapping is as follows:  X  Name of states has an S/R (sender/receiver) label. These states track the progress of a conversation.  X  Name of transitions has an activation condition and a conversation object.  X  Actions of states implement the information that conversation objects carry.  X  A complete state chart corresponds to a conversation schema of a conversation session. Examples of developing such schemas are given in Section 4. 3.1 Overview To assess the progress of a composition of Web services so that relevant conversa-tion schemas are downloaded from the library of conversation schemas (Fig. 2), the use of awareness mechanisms is required. These mechanisms ensure that the status of a Web service is known and reflected in its W -context (context of W eb service). Using W -context, it is possible to know if a Web service is (i) part of a composition, (ii) under execution, or (iii) invited to participate in a composition. Besides W -context, it will be shown in the rest of the paper that several types of context are adopted. These types are decomposed into those associated with services and those associated with conversations.
 (software agent, Web service). Agents track Web services in order to update their respective W -contexts. The tracking concerns the composition in which a service takes part, the current state of a service, and the type of conversation that a service has initiated during the composition. Fig. 2 presents the context-aware conversation approach for Web services composition. The features of this approach are as follows.
 service-agent, and service-agent.
 schemas. It updates the library when a new specification of a conversation schema is ready (e.g, updates done by designer). Plus the conversation-manager-agent responds to the requests of downloading conversation schemas that come from composite-service-agents and service-agents.
 ification of a composite service (to keep Fig. 2 clear, the specification reposi-tory is not represented). This monitoring is reflected in its C -context (context of C omposite-service). In addition, the composite-service-agent interacts with service-agents when it comes to inviting services for composition or informing services of the changes of the specification of a composite service.
 through its state chart, and updates its W -context.
 state charts are associated with Web services so that their tracking can hap-pen (Fig. 2). The states of a Web service are reflected in its W -context. Interest-ing to note that the transitions in the state chart of a service are context-based and conversation-oriented (see ( 2 ) in Fig. 2). However these conversations are less complex than the conversations that involve Web services (see ( 1 ) in Fig. 2). Therefore, each state of a Web service is associated with a T -context (context of Web-service s T ate). In Fig. 2, T 1 i -context corresponds to the context of state 1 i of Web service 1 .
 tion schemas (Fig. 2). The library is a resource from which composite-service-agents and service-agents download conversation schemas after interaction with the conversation-manager-agent.
 service ( W -context), and composite service ( C -context). State context is fine grained, whereas the composite-service context is coarse grained. Details of the context of a state are used for updating the context of a Web service. In addition details of the context of a Web service are used for updating the context of composite services. The update operations are illustrated in Section 3.4. 3.2 Operation The operation of the context-aware conversation approach consists of four steps. The context awareness step is about the mechanisms that track the changes of the states of a Web service (e.g., from committed to executed state). In case a change of state happens, the T -context of the current and previous states of the Web service are updated. The context acquisition step is about the mechanisms that collect information from the T -contexts of a Web service so that these details are submitted to the W -context of the Web service for update needs. In addition the update is propagated to the C -context of the composite service. The context assessment step is about the mechanisms that refine the information obtained from the context acquisition step. The purpose is to assess the contexts so that decisions are made on (i) the conversation session to enter and (ii) the conversation schema to download. Finally the conversation session deployment step is about the actions that are executed such as downloading a conversation schema after assessing the appropriate contexts.
 (see ( 1 ) in Fig. 2), the conversations concern the component Web services of a composite service. These conversations are specified using the conversation schemas of Fig. 1. In the second location (see ( 2 ) in Fig. 2), the conversations concern the states of the Web services. It should be noted that the state chart of a conversation schema is primarily aimed at supporting the interactions between the state charts of Web services. The distinction between states of services and states of conversations gives better flexibility for managing the aspects that each type of state chart is concerned about. The state chart of a service focusses on the changes that apply to the service such as availability and commitment, whereas the state chart of a conversation focusses on the changes that apply to the conversation such as formulation and response.
 sociated with conversations), we deemed appropriate annotating each state of conversation with a context that we refer to as S -context (context of conversa-tion S tate). The rationale of S -contexts of the states of conversations is similar to the rationale of T -contexts of the states of services. Moreover to track the progress of a conversation, a context that we denote by V -context (context of a con V ersation), is used. This is similar to the W -context of a Web service. 3.3 Structure of Contexts The T -context of a service state has these parameters:  X  Label : corresponds to the name of the service state.  X  Status (confirmed/not-confirmed) : informs if the current state of the service  X  Transition in/Previous state : illustrates the pre-arguments in terms of tran- X  Transition out/Next state : illustrates the post-arguments in terms of tran- X  Regular actions : illustrates the operations to execute in the current state in  X  Compensation actions : illustrates the operations to execute in the current  X  Time : illustrates the period of time in which the service has been in the  X  Date : identifies the time of updating the parameters above.
 states and has these parameters (not detailed): label, status, previous states, current active state, potential next state, time, and date.
 ponent services and has these parameters (not detailed): label, previous services, current active services, next potential services, time, and date.
  X  Label : corresponds to the name of the current conversation state.  X  Transition in/Previous state : illustrates the pre-arguments in terms of tran- X  Transition out/Next state : illustrates the post-arguments in terms of transi- X  Regular actions : illustrates the operations to execute in the current state in  X  Compensation actions : illustrates the operations to execute in the current  X  Time : illustrates the period of time in which the conversation has been in  X  Date : identifies the time of updating the parameters above.
 We recall that the states in a conversation X  X  state chart are not conversation-oriented, which is in opposition with the states in a service X  X  state chart. states and has these parameters (not detailed): label, conversation session, con-versation schema, participants, previous states, current active state, potential next state, time, and date. 3.4 Interactions Between Contexts Fig. 3 shows how the different contexts are devised and inter-connected. The fig-ure is divided into two parts: service and conversation. In addition two types of connection exist: vertical and horizontal . In the service part the vertical connec-tions involve C -context, W -context, and T -context. In the conversation part the vertical connections involve V -context and S -context. Regarding the horizontal connections, which are the most interesting to our context-aware conversation approach, they involve the T -context of the service part and the S -context of the conversation part. The link between both contexts corresponds to previous state and next state parameters of the S -context of a conversation. These parameters can receive as value the value of label parameter of the T -context of a service 1 . Indeed the previous state of the current state of a conversation can be the state of a service. Plus the next state of a conversation can be the state of a service. texts are inter-related and thus, engage in interactions for information exchange and update purposes (Fig. 3, vertical and horizontal connections). For instance the contexts of states update the contexts of services. In the context-aware con-versation approach, interactions between contexts are encoded as control tuples stored in a control tuple space [1]. A control tuple is a rule of the form Event-Condition-Action ( E[C]|A ) where:  X  E is an event. For example, modified( T -context t, WebService ws)  X  C is a conjunction of conditions on the parameters of contexts. These param- X  A is an execution action. For example, update( W -context w, WebService In Section 2.1 we decomposed the composition of Web services into three stages. Each stage has different aspects, which characterize the conversations that oc-cur. In the following we provide an example of how a conversation schema is developed. This consists of devising two state charts, one for conversations and one for the services that participate in these conversations. Prior to description, the following comments are made on both types of state chart:  X  State labels are annotated with S/R (sender/receiver). If there is no anno- X  Transitions connect the states together. Two types of transition exist. Those composition stage with a focus on the execution aspect. The submission of the details of an execution occurs from a composite service to a component service. There are two service states seen from a sender perspective (one state identi-fies the sender service namely scheduling) and a receiver perspective (one state identifies the receiver service namely analysis). In addition, there are three con-versation states seen from a sender perspective (one state identifies the sender service namely preparation), a receiver perspective (one state identifies the re-ceiver service namely reception), and a network perspective (one state identifies the network namely transmission from the sender to the receiver). As a first step of validating the approach of Fig. 2, we have developed a conversa-tion and Web services composition-manager , using Borland JBuilder Enterprise Edition version 9.0 (www.borland.com/jbuilder/enterprise/index.html). providers and users to create, compose, and execute services based on the differ-ent contexts. WSDL is used for Web services specification and UDDI is used for Web services announcement and discovery. Details of contexts and conversation sessions are structured as XML files. A dedicated XML editor is developed in or-der to create, validate, test, and monitor the different XML files. The validation of these files is based on two XML schemas (conversations.xsd and context.xds). In addition, the conversation manager offers an editor for describing the state charts of conversation sessions and composite services. The graphical editor pro-vides means for directly manipulating conversations and service chart diagrams, states, and transitions graphically using drag and drop operations. All changes are reflected in real time into the corresponding conversation and context details, in the same way all modifications of the conversation or context details files are directly reflected into the graphical representation of the state chart. Web services composition. We mainly focussed on modeling these conversations using state charts, which in fact connect the state charts of the services that participate in these conversations. Both services and conversations have been contextualized to ensure that the actions of services and the progress of conver-sations consider the features of their surrounding environments. We promoted the idea that Web services have to engage in conversations in order to decide whether to join a composition process, what states to take with regard to the outcome of a conversation, and what actions to perform within these states.
