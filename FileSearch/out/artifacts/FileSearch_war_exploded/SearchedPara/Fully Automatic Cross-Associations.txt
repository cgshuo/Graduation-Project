 Large, sparse binary matrices arise in numerous data min-ing applications, such as the analysis of market baskets, web graphs, social networks, co-citations, as well as information retrieval, collaborative filtering, sparse matrix reordering, etc. Virtually all popular methods for the analysis of such matrices X  X .g., k -means clustering, METIS graph partition-ing, SVD/PCA and frequent itemset mining X  X equire the user to specify various parameters, such as the number of clusters, number of principal components, number of par-titions, and  X  X upport. X  Choosing suitable values for such parameters is a challenging problem.

Cross-association is a joint decomposition of a binary ma-trix into disjoint row and column groups such that the rect-angular intersections of groups are homogeneous. Start-ing from first principles, we furnish a clear, information-theoretic criterion to choose a good cross-association as well as its parameters, namely, the number of row and column groups. We provide scalable algorithms to approach the op-timal. Our algorithm is parameter-free , and requires no user intervention. In practice it scales linearly with the problem size, and is thus applicable to very large matrices. Finally, we present experiments on multiple synthetic and real-life datasets, where our method gives high-quality, intuitive re-sults.
This material is based upon work supported by the Na-tional Science Foundation under Grants No. IIS-9817496, IIS-9988876, IIS-0083148, IIS-0113089, IIS-0209107 IIS-0205224 INT-0318547 SENSOR-0329549 EF-0331657IIS-0326322 by the Pennsylvania Infrastructure Technology Al-liance (PITA) Grant No. 22-901-0001, and by the Defense Advanced Research Projects Agency under Contract No. N66001-00-1-8936. Additional funding was provided by do-nations from Intel, and by a gift from Northrop-Grumman Corporation. Any opinions, findings, and conclusions or rec-ommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Na-tional Science Foundation, or other funding parties.  X 
An extended version of this paper is available as technical report CMU-CALD-04-107.
 H.1.1 [ Systems and Information Theory ]: Information Theory; H.3.1 [ Information Storage and Retrieval ]: Con-tent Analysis and Indexing Algorithms, Theory Information Theory, MDL, Cross-Association
Large, sparse binary matrices arise in many applications, under several guises. Consequently, because of its impor-tance and prevalence, the problem of discovering structure in binary matrices has been widely studied in several do-mains: (1) Market basket analysis and frequent itemsets: The rows of the matrix represent customers (or transactions) and the columns represent products. Entry ( i, j ) of the matrix is 1 if customer i purchased product j and 0 oth-erwise. (2) Information retrieval: Rows correspond to doc-uments, columns to words and an entry in the matrix repre-sent whether a certain word is present in a document or not. (3) Graph partitioning and community detection: Rows and columns correspond to source and target objects and matrix entries represent links from a source to a destination. (4) Collaborative filtering, microarray analysis, and numerous other applications X  X n fact, any setting that has a many-to-many relationship (in database terminology) in which we need to find patterns.

We ideally want a method that discovers structure in such datasets and has the following main properties: (P1) It is fully automatic; in particular, we want a princi-(P2) It simultaneously discovers both row and column groups. (P3) It scales up for large matrices.
 mental question in mining large, sparse binary matrices is whether there is any underlying structure. In these cases, the labels (or, equivalently, the ordering) of the rows and columns is immaterial. The binary matrix contains informa-tion about associations between objects, irrespective of their rows and columns are rearranged to improve the code cost. labeling. Intuitively, we seek row and column groupings (equivalently, labellings) that reveal the underlying struc-ture. We can group rows, based on some notion of  X  X imi-larity X  and we could do the same for columns. Better yet, we would like to simultaneously find row and column groups, which divide the matrix into rectangular regions as  X  X imilar X  or  X  X omogeneous X  as possible. These intersections of row and column groups, or cross-associations , succinctly sum-marize the underlying structure of object associations. The corresponding rectangular regions of varying density can be used to quickly navigate through the structure of the matrix.
In short, we would like a method that will take as input a matrix like in Figure 1(a), and will quickly and automat-ically (i) determine a good number of row groups k and column groups l and (ii) re-order the rows and columns, to reveal the hidden structure of the matrix, like in Figure 1(e). We propose a method that has precisely the above prop-erties: it requires no  X  X agic numbers, X  discovers row and column groups simultaneously (see Figure 1) and scales lin-early with the problem size. We introduce a novel approach and propose a general, intuitive model founded on compres-sion and information-theoretic principles. In particular, un-like existing methods, we employ lossless compression and always operate at a zero-distortion level. Thus, we can use the MDL principle to automatically select the number of row and column groups. We provide an integrated framework to automatically find cross-associations. Also, our method is easily extensible to matrices with categorical values.
In Section 2, we survey the related work. In Section 3, we formulate our data description model starting from first principles. Based on this, in Section 4 we develop an effi-cient, parameter-free algorithm to discover cross-associations. In Section 5 we evaluate cross-associations demonstrating good results on several real and synthetic datasets. Finally, we conclude in Section 6.
In general, there are numerous settings where we want to find patterns, correlations and rules. There are several time-tested tools for most of these tasks. Next, we discuss several of these approaches, dividing them broadly into application domains. However, with few exceptions, all require tuning and human intervention, thus failing on property (P1). Clustering. We discuss work in the  X  X raditional X  cluster-ing setting first. By that we mean approaches for grouping along the row dimension only: given a collection of n points in m dimensions, find  X  X roupings X  of the n points. This setting makes sense in several domains (for example, if the m dimensions have an inherent ordering), but it is different from our problem setting.

Also, most of the algorithms assume a user-given parame-ter. For example, the most popular approach, k -means clus-tering, requires k from the user. The problem of finding k is a difficult one and has attracted attention recently; for ex-ample X-means [1] uses BIC to determine k . Another more recent approach is G-means [2], which assumes a mixture of Gaussians (often a reasonable assumption, but which may not hold for binary matrices). Other interesting variants of k -means that improve clustering quality is k -harmonic means [3] (which still requires k ) and spherical k -means (e.g., see [4]), which applies to binary data but still focuses on clustering along one dimension). Finally, there are many other recent clustering algorithms (CURE [5], BIRCH [6], Chameleon [7], [8]; see also [9]).

Several of the clustering methods might suffer from the dimensionality curse (like the ones that require a co-variance matrix); others may not scale up for large datasets. Information Co-clustering (ITCC) [10] is a recent algorithm for simultaneously clustering rows and columns of a nor-malized contingency table or a two-dimensional probability distribution. Cross-associations (CA) also simultaneously group rows and columns of a binary (or categorical) matrix and, at the surface, bear similarity to ITCC. However, the two approaches are quite different: (1) For each rectangular intersection of a row cluster with a column cluster, CA constructs a lossless code , whereas ITCC constructs a lossy code that can be thought of as a rank-one matrix approximation. (2) ITCC generates a progressively finer approximation of the original matrix. More specifically, as the number of row and column clusters are increased, the Kullback-Leibler divergence (or, KL-divergence) between the original matrix and its lossy approximation tends to zero. In contrast, re-gardless of the number of clusters, CA always losslessy trans-mits the entire matrix. In other words, as the number of row and column clusters are increased, ITCC tries to sweep an underlying rate-distortion curve, where the rate depends upon the number of row and column clusters and distortion is the KL-divergence between the original matrix and its lossy approximation. In comparison, CA always operates at zero distortion. (3) While both ITCC and CA use alternating minimiza-tion techniques, ITCC minimizes the KL-divergence between the original matrix and its lossy approximation, while CA minimizes the resulting codelength for the original matrix. (4) As our key contribution, in CA, we use the MDL prin-ciple to automatically select the number of row and column clusters. While MDL is well known for lossless coding which is the domain of CA, no MDL-like principle is yet known for lossy coding; for a very recent proposal towards this direc-tion, see [11]. As a result, selecting the number of row and column clusters in ITCC is still an art. Note that ITCC is similar in spirit to the Information Bottleneck formula-tion [12].

Thus, to the best of our knowledge, our method is the first to study explicitly the problem of parameter-free, joint clustering of large binary matrices.
 set mining brought a revolution [13] with a lot of follow-up work [9, 14]. However, they require the user to specify a  X  X upport. X  The work on  X  X nterestingness X  is related [15], but still does not answer the question of  X  X upport. X  LSI [16] uses SVD on the term-document matrix. Again, the number k of eigenvectors/concepts to keep is up to the user ([16] empirically suggest about 200 concepts). Additional matrix decompositions include the Semi-Discrete Decompo-sition (SDD) [17], PLSA [18], the clever use of random pro-jections to accelerate SVD [19], and many more. However, they all fail on property (P1).
 Graph partitioning. The prevailing methods are METIS [20] and spectral partitioning [21]. These approaches have at-tracted a lot of interest and attention; however, both need the user to specify k , that is, the number of pieces to break the graph into. Moreover, they typically also require a mea-sure of imbalance between the two pieces of each split. Other domains. Related to graphs in several settings is the work on conjunctive clustering [22] X  X hich requires density (i.e.,  X  X omogeneity X ) and overlap parameters X  X s well as community detection [23], among many. Finally, there are several approaches to cluster micro-array data (e.g., [24]). In conclusion, the above methods miss one or more of our prerequisites, typically (P1). Next, we present our method.
Our goal is to find patterns in a large, binary matrix, with no user intervention, as shown in Figure 1. How should we decide the number of row and column groups ( k and ` , respectively) along with the assignments of rows/columns to their  X  X roper X  groups?
We introduce a novel approach and propose a general, intuitive model founded on compression, and more specifi-cally, on the MDL (Minimum Description Language) prin-ciple [25]. The idea is the following: the binary matrix rep-resents associations between objects (corresponding to rows and columns). We want to somehow summarize these in cross-associations , i.e., homogeneous, rectangular regions of high and low densities. At the very extreme, we can have m  X  n  X  X ectangles, X  each really being an element of the orig-Symbol Definition
D Binary data matrix m, n Dimensions of D (rows, columns) k, ` Number of row and column groups k  X  , `  X  Optimal number of groups ( X  ,  X ) Cross-association
D i,j Cross-associate (submatrix) a i , b j Dimensions of D i,j n ( D i,j ) Number of elements n ( D i,j ) := a i b j n 0 ( D i,j ) , n 1 ( D i,j ) Number of 0, 1 elements in D H ( p ) Binary Shannon entropy function C ( D i,j ) Code cost for D i,j T ( D ; k, `,  X  ,  X ) Total cost for D inal matrix, and having  X  X ensity X  of either 0 or 1. Then, each rectangle needs no further description. At the other extreme, we can have one rectangle, with a density in the range from 0 to 1. However, neither really is a summary of the data. So, the question is, how many rectangles should we have? The idea is that we penalize the number of rect-angles, i.e., the complexity of the data description. We do this in a principled manner, based on a novel application of the MDL philosophy (where the costs are based on the number of bits required to transmit both the  X  X ummary X  of the structure, as well as each rectangular region, given the structure).

This is an intuitive and very general model of the data, that requires no parameters. Our model allows us to find good cross-associations automatically . Next, we describe the theoretical underpinnings in detail.
Let D = [ d i,j ] denote a m  X  n ( m, n  X  1) binary data matrix. Let us index the rows as 1 , 2 , . . . , m and columns as 1 , 2 , . . . , n .

Let k denote the desired number of disjoint row groups and let ` denote the desired number of disjoint column groups. Let us index the row groups by 1 , 2 , . . . , k and the column groups by 1 , 2 , . . . , ` . Let denote the assignments of rows to row groups and columns to column groups, respectively. We refer to {  X  ,  X  } as a cross-association . To gain further intuition about a given cross-association, given row groups  X  and column groups  X , let us rearrange the underlying data matrix D such that all rows corresponding to group 1 are listed first, followed by rows in group 2, and so on. Similarly, let us rearrange D such that all columns corresponding to group 1 are listed first, followed by columns in group 2, and so on. Such a rear-rangement, implicitly, sub-divides the matrix D into smaller two-dimensional, rectangular blocks. We refer to each such sub-matrix as a cross-associate , and denote them as D i,j i = 1 , . . . , k and j = 1 , . . . , ` . Let the dimensions of D ( a , b j ).
With the intent of establishing a close connection between cross-association and compression, we first describe a loss-less code for a binary matrix. There are several possible models and algorithms for encoding a binary matrix. With hindsight, we have simply chosen a code that allows us to build an efficient and analyzable cross-association algorithm. Throughout this paper, all logarithms are base 2 and all code lengths are in bits.

Let A denote an a  X  b binary matrix. Define
Intuitively, we model the matrix A such that its elements are drawn in an i.i.d. fashion according to the distribution P . Given the knowledge of the matrix dimensions ( a, b ) and the distribution P A , we can encode A as follows. Scan A in a fixed, predetermined ordering. Whenever i , i = 0 , 1 is encountered, it can be encoded using  X  log P A ( i ) bits, on average. The total number of bits sent (this can also be achieved in practice using, e.g., arithmetic coding [26, 27, 28]) will be where H is the binary Shannon entropy function.
 For example, consider the matrix In this case, n 1 ( A ) = 4, n 0 ( A ) = 12, n ( A ) = 16, P 1 / 4, P A (0) = 3 / 4. We can encode each 0 element using roughly log(4 / 3) bits and each 1 element using roughly log 4 bits. The total code length for A is: 4  X  log 4+12  X  log 4 / 3 = 16  X  H (1 / 4).
We now make precise the link between cross-association and compression. Let us suppose that we are interested in transmitting (or storing) the data matrix D of size m  X  n ( m, n  X  1), and would like to do so as efficiently as possible. Let us also suppose that we are given a cross-association ( X  ,  X ) of D into k row groups and ` column groups, with none of them empty.

With these assumptions, we now describe a two-part code for the matrix D . The first part will be a description com-plexity involved in describing the cross-association ( X  ,  X ). The second part will be the actual code for the matrix, given the cross-association.
The description complexity in transmitting the cross-asso-ciation shall consist of the following terms: 1. Send the matrix dimensions m and n using, e.g., log ? ( m )+
It can be shown that log ? ( x )  X  log 2 ( x ) + log 2 log where only the positive terms are retained and this is the optimal length, if we do not know the range of values for x beforehand [29] 2. Send the row and column permutations using, e.g., 3. Send the number of groups ( k, ` ) using log ? k + log 4. Send the number of rows in each row group and also 5. For each cross-associate D i,j , i = 1 , . . . , k and j =
Let us now suppose that the entire preamble specified above has been sent. We now transmit the each of the using C ( D i,j ) bits according to Eq. 1.
We can now write the total code length for the matrix D , with respect to a given cross-association as:
T ( D ; k, `,  X  ,  X ) := where we ignore the costs log ? ( m )+log ? ( n ) and m d log m e + n d log n e , since they do not depend upon the given cross-association.
An optimal cross-association corresponds to the number of row groups k ? , the number of column groups ` ? , and a cross-association ( X  ? ,  X  ? ) such that the total resulting code length, namely, T ( D ; k ? , ` ? ,  X  ? ,  X  ? ) is minimized. Typically, such problems are computationally hard. Hence, in this pa-per, we shall pursue feasible practical strategies. To de-termine the optimal cross-association, we must determine both the number of row and columns groups and also a corresponding cross-association. We break this joint prob-lem into two related components: (i) finding a good cross-association for a given number of row and column groups; and (ii) searching for the number of row and column groups. In Section 4.1 we describe an alternating minimization algo-rithm to find an optimal cross-association for a fixed number of row and column groups. In Section 4.2, we outline an ef-fective heuristic strategy that searches over k and ` to min-imize the total code length T . This heuristic is integrated with the minimization algorithm.
In the previous section we established our goal: Among all possible k and l values, and all possible row-and column-groups, pick the arrangement with the smallest total com-pression cost, as MDL suggests (model plus data). Although theoretically pleasing, Eq. 2 does not tell us how to go about finding the best arrangement X  X t can only pinpoint the best one, among several candidates. The question is how to gen-erate good candidates .

We answer this question in two steps: 1. ReGroup (inner loop): For a given k and ` , find a 2. CrossAssociationSearch (outer loop): Search for We present each in the following sections.
Suppose we are given the number of row groups k and the number of column groups ` and are are interested in finding a cross-association ( X  ? ,  X  ? ) that minimizes where D i,j are the cross-associates of D , given ( X  ? ,  X  now outline a simple and efficient alternating minimization algorithm that yields a local minimum of Eq. 3. We should note that, in the regions we typically perform the search, the code cost dominates the total cost by far (see also Figure 3 and Section 5.1), which justifies this choice.
 Algorithm ReGroup : 1. Let t denote the iteration index. Initially, set t = 0. 2. For this step, we will hold column assignments, i.e., 3. With respect to cross-association ( X  t +1 ,  X  t ), recom-4 X 5. Similar to steps 2 X 3, but swapping columns instead 6. If there is no decrease in total cost, stop; otherwise,
Figure 2 shows the alternating minimization algorithm in action. The graph consists of three square sub-matrices ( X  X aves X  [30]) with sizes 280, 180 and 90, plus 1% noise. We permute this matrix and try to recover its structure. As expected, for k = ` = 3, the algorithm discovers the correct cross-associations. It is also clear that the algorithm finds progressively better representations of the matrix. Theorem 4.1 For t  X  1 ,
X In words, ReGroup never increases the objective function (Eq. 3).

Proof. We shall only prove the first inequality, the sec-ond inequality will follow by symmetry between rows and columns. model, as well as why our minimization strategy is effective. where (a) follows from Step 2 of ReGroup ; (b) follows by re-writing the outer two sums X  X ince i is not used any-where inside the [  X  X  X  ] terms; and (c) follows from the non-negativity of the Kullback-Leibler distance.
 Remarks. Instead of batch updates, sequential updates are also possible. Also, rows and columns need not alternate in the minimization. We have many locally good moves available (based on Theorem 4.1) which require only linear time.

It is possible that ReGroup may cause some groups to be empty, i.e., a i = 0 or b j = 0 for some 1  X  i  X  m , 1  X  j  X  n (to see that, consider e.g., a homogeneous matrix; then we always end up with one group). In other words, we may find k and ` less than those specified.

Finally, we can easily avoid infinite quantities in Eq. 4 by using, e.g., ( n u ( A ) + 1 / 2) / ( n ( A ) + 1) for P A itself, we have to initialize the mappings ( X  ,  X ). For  X , the simplest approach is to divide the rows evenly into k initial  X  X roups, X  taking them in their original order. For  X  we do the initialization in the same manner. This often works well in practice. A better approach is to divide the  X  X esidual masses X  (i.e., marginal sums of each column) evenly among k groups, taking the rows in order of increasing mass (and similarly for  X ). The initialization in Figure 2 is mass-based.
However, our CrossAssociationSearch (outer loop) al-gorithm, described in the next section, is an even better al-ternative. We start with k = ` = 1, increase k and ` and cre-ate new groups, taking into account the cross-associations up to that point. This tightly integrated group creation scheme, that reuses current ReGroup row and column group assign-ments, yields much better results.
 Complexity. The algorithm is O ( n is the number of iterations. In step (2) of the algorithm, we access each row and count their nonzero elements (of which there are n 1 ( d ) in total), then consider k possible candidate row groups to place it into. Therefore, an iteration over rows is O ( n 1 ( D )  X  k ). Similarly, an iteration over columns (step 4) is O ( n 1 ( D )  X  ` ). There is a total of I/ 2 row and I/ 2 column iterations. All this adds up to O ( n 1 ( D )  X  ( k + ` )  X  I ).
The last part of our approach is an algorithm to look for good values of k and ` . Based on our cost model (Eq. 2), we have a way to attack this problem. As we discuss later, the cost function usually has a  X  X aterfall X  shape (see Figure 3), with a sharp drop for small k and ` , and an ascent after-wards. Thus, it makes sense to start with small values of k, ` , progressively increase them, and keep rearranging rows and columns based on fast, local moves in the search space (
ReGroup ). We experimented with several search strate-gies, and obtained good results with the following algorithm. Algorithm CrossAssociationSearch : 1. Let T denote the search iteration index. Start with 2. [Outer loop] At iteration T , try to increase the num-3. [Inner loop] Use ReGroup with initial cross-associa-4. If there is no decrease in total cost, stop and return 5 X 7. Similar to steps 2 X 4, but trying to increase column
Figure 1 shows the search algorithm in action. Starting from the initial matrix ( CAVES ), we successively increase the number of column and row groups. For each such increase, the columns are shifted using ReGroup . The algorithm successfully stops after iteration pair 4 (Figure 1(e)). Lemma 4.1 If D = [ D 1 D 2 ] , then C ( D 1 )+ C ( D 2 )  X  C ( D ) . Proof. We have where the inequality follows from the concavity of H (  X  ) and the fact that n ( D 1 ) + n ( D 2 ) = n ( D ) or n ( D n ( D 2 ) /n ( D ) = 1.

Note that the original code cost is zero only for a com-pletely homogeneous matrix. Also, the code length for ( k, l ) = ( a, b ) is, by definition, zero. Therefore, provided that the fraction of non-zeros is not the same for every column (and since H (  X  ) is strictly concave), the next observation follows immediately.
 Corollary 4.1 For any k 1  X  k 2 and ` 1  X  ` 2 , there exists cross-associations such that ( k 1 , ` 1 ) leads to a shorter code (Eq. 3).
 By Corollary 4.1, the outer loop in CrossAssociation-Search decreases the objective cost function. By The-orem 4.1 the same holds for the inner loop ( ReGroup ). Therefore, the entire algorithm CrossAssociationSearch also decreases the objective cost function (Eq. 3). However, the description complexity evidently increases with ( k, ` ). We have found that, in practice, this search strategy per-forms very well. Figure 3 (discussed in Section 5.1) provides an indication why this is so.
 Complexity. Since at each step of the search we increase ei-ther k or ` , the sum k + ` always increases by one. Therefore, the overall complexity of the search is O ( n 1 ( D )( k  X  we ignore the number of ReGroup iterations I (in practice, I  X  20 is always sufficient).
We did experiments to answer two key questions: (i) how good is the quality of the results (which involves both the proposed criterion and the minimization strategy), and (ii) how well does the method scale up. To the best of our knowl-edge, in the literature to date, no other method has been ex-plicitly proposed and studied for parameter-free, joint clus-tering of binary matrices.

We used several datasets (see Table 2), both real and syn-thetic. The synthetic ones were: (1) CAVE , representing a social network of  X  X avemen X  [30], that is, a block-diagonal matrix of variable-size blocks (or  X  X aves X ), (2) CUSTPROD , representing groups of customers and their buying prefer-ences 2 , (3) NOISE , with pure white noise. We also cre-ated noisy versions of CAVE and CUSTPROD ( CAVE-Noisy and
We try to capture market segments with heavily overlap-ping product preferences, like, say,  X  X ingle persons X , buying beer and chips,  X  X ouples, X  buying the above plus frozen din-ners,  X  X amilies, X  buying all the above plus milk, etc. CUSTPROD-Noisy ), by adding noise (10% of the number of non-zeros).

The real datasets are: (1) CLASSIC , Usenet documents (Cornell X  X  SMART collection [10]), (2) GRANTS , 13,297 doc-uments (NSF grant proposal abstracts) from several disci-plines (physics, bio-informatics, etc.), (3) EPINIONS , a who-trusts-whom social graph of www.epinions.com users [31], and (4) CLICKSTREAM , with users and URLs they clicked on [32].

Our implementation was done in MATLAB (version 6.5 on Linux) using sparse matrices. The experiments were per-formed on an Intel Xeon 2.8GHz machine with 1GB RAM. tuition behind both our information-theoretic cost model, as well as our minimization strategy. It shows the general shape of the total cost (in number of bits) versus the num-ber of cross-associates. For this graph, we used a  X  X aveman X  matrix with three caves of sizes 32, 16 and 8, adding noise (1% of non-zeros). We used ReGroup , forcing it to never empty a group. The slight local jaggedness in the plots is due to the presence of noise and occasional local minima hit by ReGroup .

However, the figure reveals nicely the overall, global shape of the cost function. It has a  X  X aterfall X  shape, dropping very fast initially, then rising again as the number of cross-associates increases. For small k, ` , the code cost dominates the description cost (in bits), while for large k, ` the descrip-tion cost is the dominant one. The key points, regarding the model as well as the search strategies, are: Table 3: The clusters for CLASSIC (see Figure 5(a)) recover the known document classes. Furthermore, our approach also captures unknown structure (such as the  X  X echnical X  and  X  X veryday X  medical terms). Results X  X ynthetic data. Figure 4 depicts the cross-asso-ciations found by our method on several synthetic datasets. For the noise-free synthetic matrices CAVE and CUSTPROD , we get exactly the intuitively correct groups. This serves as a sanity check for our whole approach (criterion plus heuris-tics). When noise is present, we find some extra groups which, on closer examination, are picking up patterns in the noise. This is expected: it is well known that spurious pat-terns emerge, even when we have pure noise. Figure 4(e) confirms it: even in the NOISE matrix, our algorithm finds blocks of clearly lower or higher density.
 Results X  X eal data. Figures 5 and 6 show the cross-asso-ciations found on several real-world datasets. They demon-strate that our method gives intuitive results.

Figure 5(a) shows the CLASSIC dataset, where the rows correspond to documents from MEDLINE (medical jour-nals), CISI (information retrieval) and CRANFIELD (aero-dynamics); and the columns correspond to words.

First, we observe that the cross-associates are in agree-ment with the known document classes (left axis annota-tions). We also annotated some of the column groups with their most frequent words. Cross-associates belonging to the same document (row) group clearly follow similar patterns with respect to the word (column) groups. For example, the MEDLINE row groups are most strongly related to the first and second column groups, both of which are related to medicine. ( X  X nsipidus, X   X  X lveolar, X   X  X rognosis X  in the first column group;  X  X lood, X   X  X isease, X   X  X ell, X  etc, in the second).
Besides being in agreement with the known document classes, the cross-associates reveal further structure (see Ta-words for several of the word (column) groups. ble 3). For example, the first word group consists of more  X  X echnical X  medical terms, while second group consists of  X  X veryday X  terms, or terms that are used in medicine often, but not exclusively 3 . Thus, the second word group is more likely to show up in other document groups (and indeed it does, although not immediately apparent in the figure), which is why our algorithm separates the two.

Figure 5(b) shows GRANTS , which consists of NSF grant proposal abstracts in several disciplines, such as genetics, mathematics, physics, organizational studies. Again, the terms are meaningfully grouped: e.g., those related to biol-ogy ( X  X ncoding, X   X  X ecombination, X  etc.), to physics ( X  X ou-pling, X   X  X lasma, X  etc.) and to material sciences.
We present briefly (due to space constraints) experiments on matrices from other settings: social networks ( EPINIONS ) and web visit patterns ( CLICKSTREAM ). In all cases, our al-gorithm organizes the matrices in homogeneous regions. Figure 7 shows wall-clock times (in seconds) of our MAT-LAB implementation. In all plots, the datasets were cave-graphs with three caves. For the noiseless case (b), times for both ReGroup and CrossAssociationSearch increase lin-early with respect to number of non-zeros. We observe simi-lar behavior for the noisy case (c). The  X  X awtooth X  patterns are explained by the fact that we used a new matrix for each case. Thus, it was possible for some graphs to have differ-ent  X  X egularity X  (spuriously emerging patterns), and thus compress better and faster. Indeed, when we approximately scale by the number of inner loop iterations in CrossAsso-ciationSearch , an overall linear trend (with variance due to memory access overheads in MATLAB) appears.
We have proposed one of the few methods for clustering and graph partitioning, that needs no  X  X agic numbers. X 
This observation is also true for nearly all of the (approx-imately) 600 and 100 words belonging to each group, not only the most frequent ones shown here. Also, our method is easily extensible to matrices with cate-gorical values. We evaluate our method on several real and synthetic datasets, where it produces intuitive results. [1] D. Pelleg and A. Moore,  X  X -means: Extending [2] G. Hamerly and C. Elkan,  X  X earning the k in [3] B. Zhang, M. Hsu, and U. Dayal,  X  X -harmonic [4] I. S. Dhillon and D. S. Modha,  X  X oncept decom-[5] S. Guha, R. Rastogi, and K. Shim,  X  X URE: an [6] T. Zhang, R. Ramakrishnan, and M. Livny,  X  X IRCH: [7] G. Karypis, E.-H. Han, and V. Kumar,  X  X hameleon: [8] A. Hinneburg and D. A. Keim,  X  X n efficient approach [9] J. Han and M. Kamber, Data Mining: Concepts and [10] I. S. Dhillon, S. Mallela, and D. S. Modha, = 15 , `  X  = 13) (c) Blow-up of section in (b) [11] M. M. Madiman, M. Harrison, and I. Kontoyiannis, [12] N. Friedman, O. Mosenzon, N. Slonim, and N. Tishby, [13] R. Agrawal and R. Srikant,  X  X ast algorithms for [14] J. Han, J. Pei, Y. Yin, and R. Mao,  X  X ining frequent [15] A. Tuzhilin and G. Adomavicius,  X  X andling very large [16] S. Deerwester, S. T. Dumais, G. W. Furnas, T. K. [17] T. G. Kolda and D. P. O X  X eary,  X  X  semidiscrete [18] T. Hofmann,  X  X robabilistic latent semantic indexing, X  [19] C. H. Papadimitriou, P. Raghavan, H. Tamaki, and [20] G. Karypis and V. Kumar,  X  X ultilevel algorithms for [21] A. Y. Ng, M. I. Jordan, and Y. Weiss,  X  X n spectral [22] N. Mishra, D. Ron, and R. Swaminathan,  X  X n finding [23] P. K. Reddy and M. Kitsuregawa,  X  X n approach to [24] C. Tang and A. Zhang,  X  X ining multiple phenotype [25] J. Rissanen,  X  X odeling by shortest data description, X  [26] J. Rissanen,  X  X eneralized Kraft inequality and [27] J. Rissanen and G. G. Langdon Jr.,  X  X rithmetic [28] I. H. Witten, R. Neal, and J. G. Cleary,  X  X rithmetic [29] J. Rissanen,  X  X niversal prior for integers and [30] D. J. Watts, Small Worlds: The Dynamics of [31] M. Richardson, R. Agrawal, and P. Domingos,  X  X rust [32] A. L. Montgomery and C. Faloutsos,  X  X dentifying web
