 Hot path (or popular path) is a path that is frequently passed through by people or vehicles. It is useful in many scenarios, e.g., trip planning, traffic management and animal movement studies. Many works [1 X 5] have been proposed to find hot path. However, most of them do not aim to finding time-dependent hot paths. In practice, the hotness of a path may change over time. This paper studies how to answer Time-Dependent Hot Path(TDHP) query. We begin by two motivating examples and then introduce the TDHP problem.
 Example 1. Lily is on vacation. She arrives at a city for the first time and wants to find an attractive path which has been chosen by many travellers. If it is a sunny morning, travellers may prefer paths with natural landscapes, but if it is an evening, travellers may prefer paths wi th fantastic architectures shining at night. We can see that hot path is related to time of a day.
 Example 2. Assume a taxi to be idle. To meet potential passengers as soon as possible, the taxi driver would like to drive on roads that are frequently passed through by taxis or pedestrians. During morning rush hours he/she could choose roads around residential area because many people go to work by taxi, while in the evening he/she prefers roads around entertainment area since there would be a significant demand of going home for passengers.

The two examples above illustrate the necessity of finding time-dependent hot path. Furthermore, we visualize the distribution of real trajectory points on map. Figure 1 draws Beijing taxi trajectory points in respective time ranges(denoted by tr ). We can see that the points in 1(a) and 1(b) are both quite dense but cover different edges, but that in 1(c) is relatively sparse. Therefore, it is not appropriate to answer a hot path query without the time factor.
Given a source and a destination, the TDHP is to find an optimal path (with the maximum hotness) with a departure time and a user-specified travel time limit.

To our best knowledge, this is the first work that addresses the time-dependence of hot path problem. However, it is a non-trival work and we have identified two challenges. First, there is no available edge hotness data for path finding. We need to add time-dependent hotness information to the road net-work. Second, finding this hot path is difficult. As hotness changes over time, every time one edge is visited in path finding process, the time when moving objects arrive this edge should be known for hotness calculation. This is so time-consuming that some appropriate fast algorithm must be applied in this problem.

To answer the query, we first employ a clustering method towards all times-tamps of trajectory points to construct hotness function for each edge. Then, we solve the TDHP problem by an A*-like algorithm. We also design an appropriate estimation function and give two strategies to improve the performance.
The contributions are as follows.  X  We formally define the TDHP problem to find hot path with time-dependence  X  We propose a method to construct hotn ess function from a real trajectory  X  We propose a new searching strategy for TDHP and we use two optimizing  X  We design innovative evaluation methods and perform extensive experiments The rest of the paper is organized as follows. We formally define our problem in Section 2. We present hotness function construction method in Section 3. The search strategy for hot path finding is introduced in Section 4. Section 5 includes our experimental study. The related work is discussed in Section 6. Finally Section 7 concludes the paper. We first introduce preliminaries and then define the TDHP problem.
 Definition 1 (Time-Dependent Hotness Graph). A time-dependent hot-ness graph is a directed graph G T ( V,E,H ) (or G T for short): V = { v i } is a set for each e i,j where t is a time variable in a day.
 Definition 2 (Trajectory). Atrajectory traj is a sequence of GPS points. It can be transformed by map-matching into a sequence of neighbour nodes with records the time arriving at v i .
 Definition 3 (Edge Hotness). Given a trajectory dataset Traj , the hotness of an edge e i,j at time t is defined as: H where [ t  X   X t, t +  X t ] is a nearby time range(denoted by TR )around t and { traj } are trajectories that pass through e i,j during this time range.
 Due to different hotnesses in different t imes, it is more appropriate to count those time-nearby trajectories than all trajectories in a day. To divide the count by TR  X  X  length is because the hotness is meaningful in unit time. In addition, for simplicity, we assume that edge hotness keeps fixed while an object is traveling on the edge.
 Definition 4 (Path). Apath p is a sequence of neighbour nodes, i.e., p : v 1  X  v  X  ...  X  v Definition 5 (Path Hotness). Given a departure time t d , the hotness of a path p is defined as the average hotness of E p .
 where t i is the arrival time for e i,i +1 . We denode the travel time for e i,i +1 by e Problem 1 (TDHP Problem). Given a time-dependent hotness graph G
T ( V,E,H ) and a query with a source v s , a destination v e , a departure time t d and a travel time limit tl , the Time-Dependent Hot Path(TDHP) problem is to find a path with maximal hotness: It seems not practical that moving objects spend all the time on the way and they never stop during driving. Considering the stops are uncertain and too many constraints will bring more unnecessary complication, we assume that moving objects never stop in our problem. To solve problem 1, we need edge hotness function h i,j ( t ) and an efficient algo-rithm. These issues are discussed next. 3.1 Hotness Function Analysis The H is a continuous function and provides a statistic solution for constructing h i,j ( t ). However, a continuous hotness function would bring serious efficiency problems. First, it is space-consuming if we store hotness information for all possible time stamps. Second, it will waste much running time if the hotness is calculated during the on-line path finding process.

In this paper, we propose a TimeParti algorithm to discrete the continuous hotness function H . Generally speaking, edge hotness does not change sharply during a short tr . So we can discrete the continuous H by partitioning a day into appropriate tr s and then calculate a hotness value for each tr . Therefore, nearby times having similar hotness can be merged to share the same hotness. 3.2 TimeParti Algorithm We begin by presenting the desired properties of partitioned TR s, and then introduce our TimeParti algorithm.
 Definition 6 (Timestamp Set). For an edge e i,j ,atimestampset ts t 1 ,t 2  X  traj  X  Traj that arrives e i,j at t .
 function is correspondingly constructed as follows: Indeed, Equation 4 is an approximation of H . It counts trajectories passing a given edge in a certain tr , while the H counts trajectories in a tr around a certain time. The notion of time range partition is practical, because we only need to store a small number of hotness values to answer for any time in [ t start ,t end ).
There are two objectives in the time range partition. First, the hotness for any two timestamps t 1 ,t 2  X  tr should be similar. Second, the number of tr s should be bounded. Too many tr s would be space-consuming. In this paper, we measure the quality of time range partition for an edge e i,j by a classic standard metric SSE (Sum of Squares for Error): where SSE ([ t k ,t k +1 )) is the SSE of an tr that is defined as: where t is the average time in ts t k ,t k +1 .

TimeParti algorithm is a modified bisecting K-means clustering method. We choose bisecting K-means rather than the famous K-means. This is because the number of time ranges is not fiexed for d ifferent edges. In TimeParti, we set a SSE bound(denoted by SSEbd ) to stop the partition when the SSE of all existing time ranges are smaller than SSEbd . We use an example in Figure 2 to describe TimeParti. For a certain edge, 2(a)we initialize a ts 1 including all 2(c)select a ts with the biggest SSE (assume ts = ts 3 ), and partition it into ts 4 can be stopped, because the SSE of ts 4 , ts 5 , ts 6 and ts 7 are all below SSEbd . If there exists | ts | =1 and t  X  ts , then we enlarge the corresponding time range by [ t  X   X , t +  X  ](here we set  X  =30min for example).
 This section introduces TDHP algorithm first, and then proposes techniques for optimization. 4.1 TDHP Algorithm We novelly extend the A* algorithm by estimating path hotness. A* is an al-gorithm for goal-directed search that keeps a priority queue PQ of alternative nodes ordered by an evaluation function. In TDHP, we redefine the evaluation function by an estimated path hotness function f ( x ) for node x . f ( x ) determines the order in which the search visits nodes in PQ . Differing from traditional A*, in TDHP, the bigger f ( x ), node x is more likely to be extended. f ( x ) is sum of two functions: the past path hotness function(denoted by g ( x )) and a future path hotness function(denoted by h ( x )). For g ( x ), instead of using H p , we give a slightly rough version using h i,j ( t ) which has been constructed in
Algorithm 1: The TDHP Algorithm the previous section, to simplify the calculation. Assume p  X  to be a path from v s to x ,wehave h ( x ) is a heuristic estimate of the hotness from x to v e . Assume E R to be a set of edges that could possibly passed through in tl ,then h ( x ) can be defined as: in next subsection.

The pseudocode for this algorithm is given in Algorithm 1. A max priority queue PQ is utilized to determine the node with the maximum f ( x )value.In the while loop, we extract v with the maximum f ( x )from PQ .Thenforeach neighbour node u : we use a fastest-travel time pruning strategy in line 10-11 and update PQ with f ( x ) in line 14-19. Once the destination node is extended, the algorithm will stop and return the result hot path in line 6. 4.2 Details on Optimization We now discuss the pruning strategy and the calculation of h ( x ) in algorithm 1. Pruning Strategy. With a travel time limit, possible nodes between any two locations can be restrict ed in an area(denoted by A ). Follow Algorithm 1 and assume that u is a node that is to be extended from v ,let tt ( v s  X  u )bethe total travel time from v s to u , and let FT ( u  X  v e ) be the fastest travel time from u to v e ,then u would be pruned if the following condition is satisfied: This strategy can be applied to selection of E R for h ( x ) with little change. For  X  e The left part infers that the fastest travel time of a path that starts from v s , passes through u and e i,j and finally arrives at v e .
 To obtain the travel time for each edge, we add up all actual travel times from Traj and calculate average as the edge X  X  travel time. For those edges with no trajectories passing through, we first calculate an average speed v from Traj , and then estimate the travel time by dividing the edge length with v . Hotness Function Filtering. The quality of h ( x ) is influenced not only by h i,j ( t ) because we have no idea about in which time range the object will arrive e hotness when an object is passing e i,j . Next we propose the filtering method and how this h i,j ( t )iscalculated.

The filtering method is based on two observations: for e i,j , first, the time arriving at v i can not be earlier than some time t early because it is limited by the graph topological structure. Second, the time leaving v j can not be later than some other time t late because of the travel time limit. Then we can filter the h i,j ( t )by[ t early ,t late ] and average the left hotness for h ( x ).
The time range can be easily computed in the following way: t early = t s + t ( s  X  would be filtered if either of the following two conditions is satisfied:
Assume TR left as the left time ranges after hotness function filtering, then h can be calculated by averaging all hotness corresponding to TR left . The pseu-docode for this algorithm is given in Algorithm 2. The pruning strategy is used in line 3 and the hotness function filtering is used in line 7.

Finally, we present the time complexity analysis. The calculation of g ( x )can make use of the parent node of x , so its time complexity is O (1). Assume that TR max is the time range set of an edge with biggest | TR | . Hence, h ( x ) |
E | 2 | TR In this section, we test the efficiency a nd effectiveness of both TimeParti and TDHP algorithms.

Algorithm 2: The future path hotness function h ( x ) 5.1 Dataset We use a graph dataset and a real-world trajectory dataset in our experiments. The graph dataset is a Beijing road network from OpenStreetMap, including 2011 nodes and 5118 edges. The trajectory dataset we use for hotness function construction is offered by [6, 7]. It contains real GPS trajectories of 10,357 taxis during the period of Feb. 2 to Feb. 8, 2008 in Beijing. The total number of points in this dataset is about 15 million and the total distance of the trajectories reaches to 9 million kilometers. In the preprocessing, we did map matching and transformed each trajectory into an edge sequence with time stamps. Table 1 depicts the time distribution of all trajectory points.
 5.2 Parameter Tuning on TimeParti The TimeParti algorithm is sensitive to the tuning parameter SSEbd . Figure 3(a) shows how the clust ering error is affected by SSEbd . The average edge SSE increases as SSEbd increases. Figure 3(b) gives a relation between SSEbd and the query time of TDHP. As we can see, a larger SSEbd will make the hot path finding more efficient, because less time ranges are produced and traversed in h(x). Observing the query time slightly decreases when SSEbd increases to 1.0, we set SSEbd =1.0. 5.3 Evaluation on TDHP In the following, we illustrate the search results of TDHP algorithm and compare the results with a baseline approach(RICK) in [6] in three ways. We show in the experiments that TDHP performs better in time-dependent hotness environment. Metrics and Baseline. We use two criterions: path hotness and trajectory sim-ilarity to evaluate the effectiveness of TDHP. The path hotness defined in Defini-tion 7 makes a quantization on the hotness of a path. Given a ground-truth hottest path from the trajectory dataset, the trajectory similarity infers how close the re-sult path is to the ground-truth. Different from [6], we select from the dataset the ground-truth with the highest hotness score defined in Section 5 for a given query. In addtion, we compare the results with the existing approach(RICK) in [6]. In [6], given a sequence of locations, they find a hot path connecting any two contiguous locations. In this experiment, the parameters of RICK are set as | q | =2and k =1. Querydata Preperation. We set three time ranges an d design three query sets respectively. The query source-destination pairs are the same in three sets but the departure times are in corresponding time ranges. Taking the trajectory points X  time distribution in Table 1 into consideration, we set the time ranges as 4:00-8:00, 8:00-12:00 and 12:00-16:00. In addition, we also run experiments on a dataset ignoring the time-dependence, denoted as average time. For each query q , we collect all trajectories travelling from the q.s to q.e during a time interval around q.t . Then these trajectories are ranked by their hotness. We can assume that the greater the hotness is, the respective trajectory is more likely to be a hot path found by an experienced and professional driver.
 Performance on Path Hotness. Figure 4 verifies the relation between the dis-tance of query nodes and the path hotness. To study the path hotness difference, we compare TDHP with 3 competitors:(1)RICK,(2)the hotness of ground-truth hottest path and (3)average hotness of all trajectories that from v s to v e .The x-coordinate refers to the length of short est path(SP) between query node pairs. We can see in Figure 4 that the path hotness(in Definition 7) decreases as the distance increases. It is because the incr easing distance leads to more edges. As-sume the number of trajectories on the path to be fixed, then path hotness would get smaller with a bigger denominator. The TDHP performs better than RICK because the evaluation function in TDHP only counts those edge hotnesses in satisfied time ranges. Performance on Trajectory Similarity. Figure 5 verifies the error of TDHP. To evaluate the difference between a path and the corresponding ground-truth hottest trajectory, we apply the length-Normalized Dynamic Time Warping distance(NDTW)[6]. For each query, we get top-k hottest trajectories as ground-truth and average the k NDTWs as the error of the path finding algorithms. Figure 5 shows that the NDTW of TDHP slightly grows as the length of SP increases. We can also infer that the hot path of RICK is hot but is quite differ-ent from drivers X  experience.
 Efficiency. We investigate the query time of TDHP and show the results in Figure 6. In the path finding, we improve the efficiency of the path generation by a travel time pruning strategy. As shown in Figure 6(a), TDHP outperforms RICK a lot. The reason is that every time the h ( x ) is called, it is only the time in RICK, for  X  e i,j  X  E R , every trajectory that passes e i,j would be checked to be included into a set of existing trajectories(details in [6]). Figure6(b) compares the times that time ranges are visited in TDHP with the times that trajectories are visited in RICK. As we can see, the query time is in direct proportion to the visiting number. Evaluation on Hotness Function Filtering In the end, we investigate the performance of hotness function filtering in Figure 7. The path hotness and NDTW of TDHP and TDHP without hotness filtering(denoted by TDHP-) are recorded in 7(a) and 7(b) respectivel y. As we can see in both Figure 7(a) and 7(b), as the length of SP increases, TDHP performs much better than TDHP-. This is because by calculating edge X  X  earliest arrival time and latest leaving time, TDHP filters a few time ranges, and limits the possible arrival time of each edge in time ranges that are left after filtering. Our TDHP problem is highly related to hot route finding, time-dependent hot-ness, trajectory pattern mining and time-dependent fastest path.
 Hot Route Finding. It is [1] that first put forward the end-to-end hot route problem and assumed there was no background graph information. It used a modified DBSCAN algorithm to cluster intersections and a markov model to calculate transfer probabilities between intersections, and finally discovered the most popular route. Given a location se quence and a time span, the work [2] presented a framework to get top-k hottest paths passing through the location sequence within a time span. P.Kumar[3] provided users with a path strategy that fitted most people X  X  driving behaviour. However, all the works above ignored the hotness time-dependence.

The work [4] proposed a method to on-line achieve hot motion paths that are close to the query location. A FlowScan algorithm presented by [5] clustered road segments. Both works got a set of hot roads, instead of continual paths. Time-Dependent Hotness. The study [8] analysed a trajectory dataset and it showed the distribution of trajectory p oints changed over time. The work [9] vi-sualized this phenomenon of a small part of the map. They just gave a subjective explaination but did not systematically quantize the edge hotness. Several stud-ies [10 X 12] discovered period moving trends of objects that share alike routes. To better make use of these trends, the study [13] clustered trajectory points at fixed intervals, hence converted GPS t rajectories into cluster sequences. But these works lack of a straightforward definition and expression of hotness,thus their efficiency of algorithm is not good.
 Trajectory Pattern Mining. Several works [10 X 12] focused on mining tra-jectory patterns. By tagging these patterns in the graph, some hot paths could be found. However, these popular paths were discrete and scattered over the whole graph. Given a certain source-dest ination pair, there may be no consecu-tive paths that could pass through the two locations. Therefore, retrieving hot paths from trajectory patterns is not a good solution for the problem in this paper.
 Time-Dependent Fastest Path. Given a graph with edge travel time changing over time, time-dependent fastest path aims at finding a path of which the total travel time is minimized. The work [14] studied the online algorithm for fastest path in time-dependent graph and presented a technique speeding up path calculation. However, the problem addressed in this paper is fairly different from this kind of problem, for it is the hotness rather than the travel time that is dynamic. Besides, the fastest path only demanded that the travel time of path should be minimized. But TDHP is to get a path with maximized average hotness of edges as long as the travel time would not surpass a specified value. In this paper, we studied the problem of time-dependent hot path finding between two given locations by using users X  daily moving trajectories. We first converted GPS points to road segment sequences with timestamps by a map-matching al-gorithm. Then we proposed a novel method to construct time-dependent hotness function for each edge. Based on the hotness function, we proposed an A*-like algorithm to find the optimal TDHP. We conducted extensive studies and con-firmed that our algorithms outperformed than the baseline algorithm in terms of both effectiveness and efficiency.

