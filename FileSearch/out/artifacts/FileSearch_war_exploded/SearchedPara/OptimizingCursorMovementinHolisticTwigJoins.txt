 Categories and Subject Descriptors: H.3[Information Systems]: Information Storage and Retriev al; E.1[Data]: Data Structures General Terms: Algorithms, Performance, Experimen ta-tion Keyw ords: XML, Twig Joins, Indexing, Evaluation
Both XPath and XQuery allow users to specify value and structural constrain ts in XML queries using path expres-sions. A path expression can be represen ted as a query tree , which is structurally matc hed against XML data. Perform-ing this structural matc hing as e X cien tly as possible is one of the key issues in building an XML query engine.
There are two common approac hes to perform structural matc hing e X cien tly. One approac h is to use a structur al join [1, 5, 19], where a query tree is decomp osed into a set of binary ancestor-descendan t or paren t-child relationships. The relationships are then evaluated using a binary merge join. Another approac h is to use a holistic twig join [3, 10], which processes a query tree with a single n-ary join. Holistic twig joins represen t the state of the art for eval-uating path expressions in XML queries. Not only do they perform better [10], but they are self-tuning and do not re-quire a query optimizer. Holistic twig joins are index-b ased , typically relying on an inverte d index for positional informa-tion about XML elemen ts. Cursors are used to access the inverted index and moved in a coordinated way to e X cien tly  X nd structural matc hes.

Several variations on holistic twig joins have been pro-posed in the literature [3, 4, 9, 10, 16, 18]. Because each cursor move in an inverted index can trigger I/O, the per-formance of a twig join 1 is largely determined by how many cursor moves it makes. Despite this observ ation, existing twig join algorithms have not been optimized along these lines. There has been more focus on minimizing the mem-ory requiremen ts of intermediate results than on minimizing the number of cursors moves. The problem with existing twig join algorithms is that they make a local, and hence sub-optimal, decision in choosing which cursor to move next and how far to move it.

In this paper, we describ e TwigOptimal , a new holistic twig join algorithm with optimal cursor movemen t. This is accomplished by looking more globally at the query's state to determine which cursor to move next. We provide a sketch of TwigOptimal 's optimalit y, and presen t experimen-tal results, showing its superiorit y over existing twig join algorithms.

Another shortcoming of existing twig join algorithms is that they assume all nodes in a query tree need to be out-put. However, an XQuery return clause often requires only a subset of the nodes being matc hed to be output. We refer to the nodes that need to be output in the return clause as extraction points . By being aware of extraction points, we show how TwigOptimal can dramatically reduce the number of cursor moves it makes. This is accomplished by skipping over nodes that do not need to be output.

In summary , the main contributions of this paper are:
Note that, for readabilit y, we will often use \twig join" as a shorthand for \holistic twig join".
Structural joins [1, 5, 19] were the  X rst metho d prop osed for evaluating path expressions. In a structural join, com-plex path expressions are broken down into a set of ancestor-descendan t or paren t-child relationships and then evaluated using binary merge joins.

Holistic twig joins were  X rst describ ed in [3], which showed how performance could be impro ved by considering all nodes in the query tree holistically . Optimizations to the original twig join algorithm were later describ ed in [10] and then extended to handle OR predicates in [9]. Several papers have also investigated new index types to speed up twig joins [5, 8, 10, 12, 18]). TwigOptimal provides the same functionalit y o X ered by existing twig joins, including OR predicates. Although a standard inverted index is assumed in this paper, TwigOptimal can also be used with many of the new index types that have been prop osed to speed up twig joins.

Reference [10] is the only other paper that really addresses the problem of choosing which index cursor to move next in a holistic twig join. In [10], when the cursor positions do not form a structural matc h, a \brok en edge" in the query tree is chosen using various heuristics and then \ X xed". Fix-ing a broken edge consists of repeatedly moving the two cursors forming the edge until they structurally matc h the query . The problem with this approac h is that, once a bro-ken edge is chosen, only the two cursors forming the edge can be moved. In contrast, using the concept of virtual cursor moves, TwigOptimal is able to consider the whole query's cursor state every time a cursor needs to be moved.
To evaluate a path expression like /x/y/z , a holistic twig join will typically open three index cursors, one for each path step. However, if the position of data nodes are encoded with a Dewey value [15], the cursors for x and y can be deriv ed from the cursor for z . In [18], these deriv ed cursors were called virtual cursors . The choice of names is perhaps unfortunate, but the virtual cursors describ ed in [18] should not be confused with the virtual cursor moves describ ed in this paper. The former describ es a deriv ed cursor, whereas the latter describ es a virtual move of a physical cursor.
References [2] and [11] describ ed metho ds for minimiz-ing the memory requiremen ts of intermediate results when processing XQuery fragmen ts over XML streams. Similarly , [3, 10] describ ed metho ds for minimizing the memory re-quiremen ts of intermediate results in twig joins. However, the performance of a twig join is largely determined by how many cursor moves it makes. Therefore, the focus in this pa-per is on minimizing the number of cursor moves in a twig join rather than on its memory requiremen ts.
In this section, we establish some background that will be used in the remainder of the paper.
As in the previous work on holistic twig joins [3, 10], we will focus on XPath expressions or XQuery fragmen ts that can be represen ted by a single query tree and structurally matc hed against XML data in one pass over an index. These are basically single-do cumen t path expressions containing child ('/') axis, descendan t ('//') axis, and equalit y predi-cates, all of which can be combined using Boolean AND and OR operators.
As an example, consider the following XQuery fragmen t, which returns the titles of XML articles in 2005: for $a in //article[year = "2005" or This query has three XPath expressions, one in each of the two for clauses, and one in the return clause. Figure 1 shows the resulting query tree. Each XPath step in Figure 1 is represen ted by a path node . There are also AND and OR branching nodes , which specify that all or at least one of the subpatterns below the node must be matc hed, respec-tively. Finally , dotted lines are used to indicate that a path node corresp onds to an extraction point , i.e., it is returned by the query . In general a query tree can have more than one extraction point since the for-let-wher e block of XQuery returns tuples of bindings.
XML data is also commonly represen ted as a tree, with nodes corresp onding to text values, elemen ts, or attributes, and edges capturing the nesting of elemen ts. The position of XML data nodes are used by holistic twig joins to do structural matc hing. The position of an XML data node can be encoded in di X eren t ways. One alternativ e is to use the well-kno wn BEL encoding, where a node's begin, end, level forms its position. Another alternativ e is the Dewey encoding [15]. In this paper, we assume BEL encoding, but the techniques we describ e are orthogonal to the choice of the encoding.

Holistic twig joins have been implemen ted over several indexing structures [8, 13, 16]. Here, we assume a standard inverted index [7]. Inverted indexes have stood the test of time and are frequen tly used in information retriev al and XML systems alike [1, 3, 5]). Brie X  X  , an inverted index consists of one posting list per distinct token in the dataset, where a token can be a text value, attribute, or elemen t tag. A posting list contains one posting for each occurrence of its token in the dataset and is sorted by position (in our case using BEL). Stepping through the posting list for a token T will enumerate the positions of every occurrence of T in order, by documen t and then within documen t. We assume each posting list is itself indexed, typically with a B-tree, so that searc hing for a particular position within a posting list is e X cien t. To  X nd documen ts that structurally matc h a query tree Q , a holistic twig join associates each path node q with the posting list in the inverted index whose token matc hes q . A cursor is opened for each of these posting lists, and then moved in a coordinated way to  X nd documen ts that struc-turally matc h Q . Parent-child and ancestor-descendan t con-strain ts imposed by the query are checked by looking at the curren t positions of cursors. The output of a holistic twig join is a stream of tuples, where each tuple corresp onds to a solution , that is, a set of data nodes that structurally matc h the path nodes in Q . In existing twig join algorithms, all possible solutions are output [3, 10].
In this section we describ e TwigOptimal . For simplicit y and to make the comparison to existing algorithms clearer, TwigOptimal is initially describ ed without taking extraction points into accoun t. Extraction points are addressed in Sec-tion 7.
As in existing holistic twig join algorithms [3, 10], the eval-uation state of TwigOptimal is a triplet &lt; Q, C, S &gt; , where Q is the query tree being evaluated, C is the set of cursors for accessing the inverted index, and S is a set of stacks for constructing solutions. Data nodes that are part of a so-lution are stacked on S and output when a full solution is found.

An index cursor Cq and a stack Sq are associated with each path node q in Q . Cq points to the curren t posting for q , while Sq is used to remem ber the data nodes for q that are part of a solution. Each stack entry also has a pointer to an entry in an ancestor stack, which is used by TwigOptimal to output a solution, much like in [3, 10, 11].
 The position of a cursor Cq is accessed via Cq:beg in , Cq:end , and Cq:level , and similarly for a stacked node in Sq . Parent-child or ancestor-descendan t constrain ts are checked by looking at BEL values. We say a cursor Cp contains another cursor Cq i X  Cp:beg in  X  Cq:beg in and Cp:end  X  Cq:end . Similarly , we say that a stack Sp contains Cq if there is some entry in Sp that contains Cq .
 For each cursor Cq , the metho d Cq:f orwardT o ( pos ) moves Cq forward from its curren t position to the  X rst position greater than or equal to pos . This can trigger I/O as Cq physically seeks to pos . To optimize its cursor movemen ts, TwigOptimal also uses virtual cursor moves that, unlik e phys-ical cursor moves, do not trigger I/O. Instead, a virtual move on Cq simply sets Cq:beg in without physically moving Cq . This will be made clearer shortly . Cq:virtual is set to true whenev er Cq is virtually moved and reset to false whenev er Cq is physically moved.

Unlik e path nodes, each branc hing node in Q is not as-sociated with a posting list in the inverted index. However, each branc hing node does have a cursor, which is used to pass along the position of its paren t or a child cursor when TwigOptimal is deciding which cursor to move next. Con-sequen tly, the cursor of a branc hing node is always virtual. By main taining a cursor for each branc hing node, TwigOp-timal does not need to distinguish between path nodes and branc hing nodes in most cases, which in turn simpli X es the algorithm.
ExecuteQuery() , which is shown in Figure 2, forms the entry point and main loop of TwigOptimal . It initializes each cursor to their  X rst posting (line 1), then it repeatedly inspects the path node q corresp onding to the min cursor (line 3), that is, the cursor with the smallest beg in value, until is has found and output all solutions.
 To  X nd and output solutions, the cursors are moved until an extension [10] for q is found (lines 4{7). An extension for q is basically a partial solution rooted at q . When an extension for q has been found, the cursor positions in the subtree rooted at q are guaran teed to be a part of a solution. In addition, the stacks of q 's ancestors contain the position of data nodes that, when combined with the extension for q , forms a full solution.

Once an extension has been found, OutputA ndPush() is called (line 8) to output any new stacked solutions and push Cq onto its stack. As in [10], Cq is only stacked when it is part of a solution. Finally , Cq is advanced to its next physi-cal location (line 9) to start the searc h for another solution. The main loop terminates when the end of one or more post-ing lists is reached, allowing the algorithm to conclude that no more solutions can be found.
Extension() , which is shown in Figure 3, checks whether the cursor positions in the subtree rooted at q form an ex-tension. f C g is the set path of cursors in the subtree rooted at q . For the subtree rooted at q to form an extension, Cq must be contained by its paren t's stack Sp , all the cursors in f C g must be real (not virtual), and all the cursors in f C g must recursiv ely satisfy the containmen t constrain ts of Q (line 3). In the latter case, a cursor with an AND under it needs to contain all its children cursors, while a cursor with and OR under it needs to contain at least one of its children cursors.

TwigOptimal calls MoveCursors(q) in its main loop as it searc hes for an extension, where q corresp onds to the min cursor. MoveCursors() basically tries to move the cursors in the subtree rooted at q to the next extension for q , if any. To avoid I/O, this is done using virtual cursor moves. A physical cursor move is made only when further virtual progress becomes impossible.

MoveCursors() is shown in Figure 4. Two passes over the subtree rooted at q are made to virtually move the cur-sors, a bottom-up pass (line 6) and a top-do wn pass (line 7). The two passes over the subtree globally disco ver the furthest each cursor can be moved forward without missing an extension for q . This is in contrast to existing twig join algorithms, where cursors are moved in a localized way, only looking at the positions of one paren t-child pair of cursors at a time.

MoveCursors() begins by checking whether Cq is con-tained by its paren t stack (line 2). If not, then Cq is virtually moved to the max of Cq:beg in or Cp:beg in + 1, which is the most Cq can be moved forward without missing an exten-sion for q . Next, the cursors are virtually moved bottom-up and then top-do wn (lines 6{7), as describ ed earlier. Finally , a check is made to see whether q still corresp onds to the min cursor (line 8). If so, then further virtual progress is impossible, at which point a physical cursor move is made (lines 9{11). Note that, on exit, MoveCursors() may or may not have actually found an extension for q . This is checked in the main loop of TwigOptimal .

When MoveCursors() is forced to make a physical cursor move, it picks the \best" virtual cursor in the subtree rooted at q to move (line 9). This is essen tially the cursor that is predicted to move the furthest. How to determine the best cursor to move is beyond the scope of this papers. For various heuristics see [10].

MoveCursorsBottomUp() , which is shown in Figure 5 re-cursiv ely performs a bottom-up pass over the subtree under consideration. The goal of this pass is to try and move each paren t cursor forward so it contains its children cursors. If q is an AND node (line 4), then Cq must contain the cursor of its max child in order for there to be an extension. Simi-larly, if q is an OR node (line 8), then Cq must contain the cursor of its min child. Finally , if q is a path node with a child (line 12), then Cq must contain that child's cursor. Figure 5: The bottom-up pass to move cursors
Recall that each branc hing node's cursor is used to pass along the position of its paren t cursor or a child cursor. Here, in the case of an AND node, Cq is used to pass up the beg in value of its max child cursor (lines 5{6). Similar action is taken in the case of an OR node with its min child cursor (lines 9{10). Finally , if q is a path node with a child, and Cq:end falls before that child's cursor, then Cq is virtually moved to the max of Cq:beg in or Cq:end + 1 (lines 15{16), which is the most Cq can be moved forward without missing an extension. The max is needed (line 15) to deal with the case where a previous call to MoveCursors has already virtually moved Cq:beg in past Cq:end .

After MoveCursorsBottomUp()  X nishes, each cursor will have been virtually moved as far forward as its children cur-sors will allow it to be moved without missing an exten-sion. MoveCursorsT opDown() , which is shown in Figure 6, is then called to recursiv ely perform the top-do wn pass over the subtree under consideration. The goal of this pass is to try and move each child cursor forward so it is contained by its paren t cursor.
 Figure 6: The top-do wn pass to move cursors
In MoveCursorsT opDown() , c and q corresp ond to the curren t child and paren t nodes being examined, respectiv ely. If c is a branc hing node, then the child cursor Cc is used to pass down the position of the paren t cursor Cq (line 3). Else, if Cc:beg in falls before Cq and is not contained by its paren t stack Sq , then Cc is virtually moved to Cq:beg in + 1 (lines 5{8), which is the most Cc can be moved forward without missing an extension. Sq needs to be checked for containmen t in this case to guard against missing solutions when there is recursiv e data for q .
Solutions are output and pushed onto the stacks in Out-putA ndPush() , which is shown in Figure 7. Before the cursor of node q is stacked (line 8), a check is made to see if q cor-responds to the root of Q . If so, then one or more solutions are output before the new root cursor is stacked (lines 2{6).
The simple stacking metho d use here is not optimized for space, since that is not the focus of this paper. However, note that OutputA ndPush() can easily be changed to use the stacking metho d describ ed in [10], which is optimized along those lines.
We now illustrate TwigOptimal 's cursor movemen t using the query shown in Figure 8. In this example, there are three cursors on posting lists, one per query tree node. The scope of each x elemen t is represen ted by a triangle enclos-ing its descendan t y and z elemen ts. For clarit y, the  X gure does not show a complete XML documen t, but rather only two sibling x elemen ts. The left-to-righ t position of the let-ters in the  X gure indicates the relativ e position of the data nodes in the documen t. Physical cursor moves are depicted by solid curved lines, labeled with the sequence number in which they are performed, while virtual moves are depicted by dashed lines.

At the beginning, the three cursors are positioned on x 1 y , and z 1 , which do not form an extension. Cx is the min cursor and there is no extension for it, so MoveCursors(x) is called. Since x 1 ends before y 1 and z 1 , Cx is virtually moved just past the end of x 1 . At that point, Cx is still the min cur-sor, so it is physically moved to x 2 , after which Cz becomes the min cursor. In the subsequen t calls to MoveCursors() , Cz and Cy are virtually moved within x 2 , causing postings y 2 and y 3 to be skipp ed. Then Cy is physically moved to y . At that point Cx is the min cursor again, but the call to Extension(x) returns false since Cz is virtual. Cz is then physically moved to z 2 , Cx remains the min cursor, and the next call to Extension(x) succeeds.

The call to OutputA ndPush(x) stacks x 2 and then Cx is physically moved to the next x (not shown). At that point, Cy is the min cursor and, since Extension(y) returns true, y 4 is stacked and physically moved to y 5 . The same steps are repeated for y 5 since it is also part of an extension. Cy is then physically moved to the next y (not shown). This ensures that all the y nodes within x 2 have been exhausted. Finally , Cz becomes the min cursor, Extension(z) returns true, and z 2 stacked. Since Cz is still the min cursor, it is moved again, this time beyond x 2 . At that point, there are four stack entries that make up two solutions. These will be output after the next x node is stacked.
Figure 9 and Figure 10 are used to illustrate how TwigOp-timal can generate far fewer physical cursor moves than ex-isting twig join algorithms. Both  X gures trace the evaluation of the query //w//x//y//z on two sibling w elemen ts. Fig-ure 9 illustrates how the cursors would be moved using the twig join algorithm describ ed in [10], which represen ts the Figure 9: Counting physical cursor moves with existing state of the art among existing algorithms, while Figure 10 illustrates how the cursors would be moved in TwigOptimal .
As shown, both algorithms start out in the same state, with the  X rst solution w 1 , x 1 , y 1 and z 1 stacked, and with Cw , Cx , Cy , Cz positioned on w 2 , x 2 , y 2 and z 2 , respec-tively. We compare the number of physical cursor moves needed for each algorithm to reach the second solution, which is w 2 , x 50 , y 100 and z 2 .

In [10], when the test for an extension on y returns false, a \brok en edge" in the subtree rooted at y is identi X ed. A broken edge is a paren t-child pair, where the paren t cur-sor does not contain its child cursor. The paren t and child cursors for the broken edge are then repeatedly moved in a coordinated way until the paren t cursor contains the child cursor. As shown in Figure 9, this causes Cx and Cy to be moved between x 2  X  x 50 and y 1  X  y 100 , respectiv ely, result-ing in roughly 150 physical cursor moves to  X nd the second solution.

In contrast, as shown in Figure 10, TwigOptimal performs only two physical cursor moves. Three virtual moves place Cx and Cy within w 2 , and then two physical cursor moves are made to  X nd the second solution.
In this section, we provide a sketch of TwigOptimal 's op-timalit y. Our main claim is stated in Theorem 1.
Theorem 1. Given an evaluation state &lt; Q, C, S &gt; , when-ever a cursor is physic ally move d in TwigOptimal: 1. It is necessary to move one of the cursors consider ed 2. The cursor that is physic ally move d is move d as far
For the  X rst part of Theorem 1, we examine the two places in TwigOptimal where forwar dTo() is called to physically move a cursor. In ExecuteQuery() , a cursor Cq is physically moved after q has been found to be a part of an extension (and thus, a solution). This physical move is necessary to Figure 10: Counting physical cursor moves with check if Cq 's next position is part of a solution. For example, in Figure 8, Cy has to be physically moved until it exits from the x 2 's subtree. If any other cursor is moved at that point, the solution x 2 , y 5 and z 2 would be missed.

The second call to forwar dTo() is performed in MoveCur-sors() when the min cursor is virtual. In that case, the two passes over the query tree have virtually moved cursors in the subtree of the min cursor. If some of the cursors are virtual, TwigOptimal cannot con X rm that it has found an extension. Therefore, TwigOptimal has to physically move one of the virtual cursors to  X nd out if it has found a solu-tion. This is illustrated in Figure 8 when Cz is moved to check if there is a z posting within x 2 .

For the second part of Theorem 1, it can be shown by in-duction that the two-pass algorithm used in MoveCursors() passes along restrictions on the maxim um possible location of the next physical cursor move from descendan ts to an-cestors (in the bottom-up pass) and then from ancestors to descendan ts (in the top-do wn pass). Therefore, after Move-Cursors() has been called, the cursors will have been moved as far forward as possible without missing a solution.
Note that if more than one virtual cursor is available to be physically moved, TwigOptimal chooses the \best" cursor using heuristics based on the available statistics [10]. This means that TwigOptimal is not instance optimal [6], as in-stance optimalit y can only be achieved if there was a way to always choose the best cursor to move. However, Move-Cursors() does guaran tee that when a cursor is physically moved, it is moved as far forward as possible without missing a solution.

Also note that Theorem 1 assumes forward-only cursor moves on a standard inverted index. Unfortunately , this means that when an ancestor cursor is moved to contain a descendan t cursor in MoveCursorsBottomUp() , TwigOpti-mal can behave ine X cien tly. Special indexes and the cursor metho d forwar dToAncestor() have been prop osed to deal with this situation [8, 13]. Instead of using a special index, we prop ose an implemen tation of forwar dToAncestor() that simply moves the ancestor cursor forward to the descen-dant cursor, then backs up the ancestor cursor to the  X rst position before the descendan t cursor. In the (rare) case of recursion, the backward step may have to be repeated. If forwar dTo() is modi X ed to detect when to call forwar d-ToAncestor() under the covers, then nothing in TwigOptimal has to be changed to take advantage of this optimization. Theorem 2. Assuming forwar d-only cursor moves, Twig-Optimal performs the minimum numb er of physic al cursor moves to evaluate Q .

The proof follows from Theorem 1, where we conclude that every physical cursor move performed by TwigOpti-mal is necessary and goes as far forward as possible without missing a solution.
Existing twig join algorithms assume that all path nodes in a query tree need to be output. However, an XQuery return clause often requires only a subset of the path nodes being matc hed to be output. For example, in Figure 1, only the title node needs to be output. By being aware of these extraction points and \skipping" over data nodes that do not need to be output, the number of cursor moves per-formed by a twig join can be dramatically reduced. This sec-tion describ es how extraction points can be used to impro ve TwigOptimal 's performance by making only minor changes to ExecuteQuery() , as shown in Figure 11. Lines 9a{9j in Figure 11 simply replace line 9 in Figure 2. Figure 11: Changes to ExecuteQuery() for extraction points
To understand the code in Figure 11, let q be a path node in the query tree with paren t p and consider the four possibilities for q and its descendan ts: 1. Neither q nor any of its descendan ts in the query tree 2. Node q is an extraction point but none of its descen-3. Both q and some descendan t of q are extraction points. 4. Node q is not an extraction point but some descendan t
Case 1) is handled by lines 9a{9d. In this case, it should be clear that TwigOptimal does not need to  X nd all the ex-tensions rooted at q . Consequen tly, once an extension for q has been found, Cq and all its descendan t cursors can be virtually moved within Cp (line 9c).

Case 2) is handled by lines 9e{9i. In this case, it should be clear that TwigOptimal does not need to  X nd all the ex-tensions below q . Consequen tly, after physically moving Cq (line 9f), all its descendan t cursors can be virtually moved to within Cq (line 9h). Figure 12: Physical cursor moves for the synthetic Figure 13: Running time for the synthetic dataset
Finally , case 3) and case 4) fall through the  X rst part of the if-statemen t and are handled the same as in the ver-sion of ExecuteQuery() without extraction points, that is, just line 9f is executed. Also, although it is not shown, Out-putA ndPush() changes with extraction points. In particular, if neither q nor any of its descendan ts are extraction points, then Cq should not be stacked. In this section, we presen t experimen tal results comparing TwigOptimal with TSGeneric+ [9, 10], which represen ts the state of the art among existing twig join algorithms, Results are also provided to show how TwigOptimal 's performance can be impro ved by being aware of extraction points.
Our experimen tal testb ed was built on the Berk eley DB [14] embedded database, where we implemen ted both TwigOp-timal and TSGeneric+ . All experimen ts were run on a Linux Red Hat 8.0 workstation, with a 2.2 GHz Intel Pen-tium 4 processor and 2 GB of main memory . Although, the amoun t of main memory was large, both twig join algo-rithms only access their posting lists in the forward direction (with skips). Consequen tly, our running times are represen-tativ e of any memory bu X er large enough to hold at least the internal pages of the B-tree and one leaf page per posting list.

For data, we used the XMark [17] dataset and a synthetic dataset [18]. For both datasets, the di X erence in the relativ e performance of TwigOptimal and TSGeneric+ was similar.
In all our experimen ts, TwigOptimal and TSGeneric+ both used the same top-do wn strategy [10] for picking which cursor to physically move next. As noted earlier, if both al-gorithms use the same strategy for picking which cursor to move next, TwigOptimal should never generate more phys-Figure 14: Physical cursor moves for the XMark dataset ical cursor moves than TSGeneric+ . Moreo ver, by looking more globally at the query's evaluation state to determine which cursor to move next, TwigOptimal should be able to generate fewer physical cursor moves in many cases.
Figure 12 shows the number of physical cursor moves for three queries on the synthetic dataset, while Figure 13 shows their running time using cold bu X ers. As shown, both algo-rithms performed exactly the same on the  X rst query . This is because the query tree in that case only had two levels (i.e., two cursors), providing little room for TwigOptimal to optimize its cursor movemen t. However, as the queries got more complex and the number of levels in their query tree grew, TwigOptimal generated 40% fewer physical cur-sor moves than TSGeneric+ and its running time impro ved prop ortionally .

For the XMark dataset, we studied two queries, a small one with a 4-node query tree, and a large one with a 10-no de query tree: Figure 14 shows the number of physical cursor moves for these queries. As with the synthetic dataset, on the smaller query , both algorithms generated roughly the same number of cursor moves, while for the larger query , TwigOptimal generated 45% fewer cursor moves. TwigOptimal 's running time also impro ved prop ortionally , but because of space lim-itations, the graph with those results has been omitted.
Figure 15 and Figure 16 show how TwigOptimal 's perfor-mance can be impro ved by being aware of extraction points. The graphs in those  X gures were generated using the syn-thetic dataset. Moving from left to right in the graphs, the number of extraction points in the query decreases from all 4 nodes to 1 node. The left-most query represen ts TwigOp-timal without any optimization for extraction points.
As expected, the number of physical cursor moves TwigOp-timal made decreased as the number of extraction points in the query decreased. The fact that they decreased some-what linearly is an artifact of the dataset and the way it was generated with uniform probabilities. In general, the impact of extraction points on performance can vary dra-matically , depending on the query and the dataset. The im-provemen t in performance can be substan tial anytime there is a pattern like a[.//b] , where there are a large number of b nodes under each a node. To illustrate this, another data point was taken from the XMark dataset. On that dataset, the query //item//text with 2 extraction points generated Figure 15: Physical cursor moves for queries with dif-Figure 16: Running time for queries with di X eren t num-835,740 cursor moves, whereas the same query with 1 ex-traction point //item[.//text] generated 435,000 cursor moves, roughly half as many.
Because each cursor move can trigger I/O, the perfor-mance of a holistic twig join is largely determined by how many cursor moves it makes. Yet, existing twig join algo-rithms have not been optimized along these lines. Instead, they make a local, and hence sub-optimal, decision in choos-ing which cursor to move next and how far to move it. In this paper, we describ ed TwigOptimal , a new holistic twig join algorithm that minimizes the number of cursor moves it makes by looking more globally at the query's state to determine which cursor to move next. Experimen tal results were provided, showing that TwigOptimal can outp erform existing twig joins algorithms by up to 40%.

Another shortcoming of existing twig join algorithms is that they assume all nodes in a query tree need to be out-put. However, an XQuery return clause often requires only a subset of the nodes being matc hed to be output. By being aware of these so-called extraction points, we describ ed how TwigOptimal is able to further reduce the number of cur-sors moves it makes. Experimen tal results were provided, showing that this can provide a substan tial impro vemen t in performance. [1] S. Al-Khalifa, H. Jagadish, N. Koudas, J. Patel, [2] Z. Bar-Y ossef, M. Fontoura, and V. Josifo vski. [3] N. Bruno, N. Koudas, and D. Srivastava. Holistic twig [4] T. Chen, J Lu, and T. W. Ling. On boosting holism in [5] S. Chien, Z. Vagena, D. Zhang, V. Tsotras, and [6] R. Fagin, A. Lotem, and M. Naor. Optimal [7] G.Salton and M. J. McGill. Introduction to modern [8] H. Jiang, H. Lu, W. Wang, and B. C. Ooi. Xr-tree: [9] H. Jiang, W. Wang, and H. Lu. E X cien t processing of [10] H. Jiang, W. Wang, H. Lu, and J. Yu. Holistic twig [11] V. Josifo vski, M. Fontoura, and A. Barta. Querying [12] R. Kaushik, R. Krishnam urthy, J. Naugh ton, and [13] Q. Li and B. Moon. Indexing and querying xml data [14] M. Olson, K. Bostic, and M. Seltzer. Berk eley DB. In [15] I. Tatarino v, S. Viglas, K. Beyer, [16] H. Wang, S. Park, W. Fan, and P. Yu. Vist: A [17] Xmark: The xml benchmark project. [18] B. Yang, M. Fontoura, E. Shekita, S. Rajagopalan, [19] C. Zhang, J. Naugh ton, D. DeWitt, Q. Luo, and
