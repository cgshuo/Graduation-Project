 In many applications, such as online dating or job hunting web-sites, users often need to search for potential matches based on the requirements or preferences imposed by both sides. We refer to this type of queries as matching queries. In spite of their wide applica-bilities, there has been little attention devoted to improve their per-formance. As matching queries often appear in various forms even within a single application, we, in this paper, propose a general pro-cessing framework, which can efficiently process various forms of matching queries. Moreover, we elaborate the detailed processing algorithms for two particular forms of matching queries to illus-trate the applicability of this framework. We conduct an extensive experimental study with both synthetic and real datasets. The re-sults indicate that, for various matching queries, our techniques can dramatically improve the query performance, especially when the dimensionality is high.
 Many matching services allow users to search for matching coun-terparts based on the requirements and/or preferences of both par-ties. Below are a few examples:
Case 1: Each subscriber of an online dating website has some personal properties such as age, stature, weight, income, hobbies, etc. At the same time, he or she has some requirements for the po-tential partners, characterized as ranges of age, weight, income, etc. When a user, say Tom, searches for potential partners on the web-site, it is desirable to return a list of candidates such that the can-
This work is supported in part by the National Science Foundation of China (NSFC Grant No. 60803003, 60970124).
 didates meet Tom X  X  requirements and Tom fulfills the requirements imposed by the candidates as well.

Case 2: Nowadays home exchange is a very popular vacation al-ternative where you allow someone else to stay at your home while you stay in theirs during a vacation. Users of a website that pro-vides this service would provide information of their houses as well as their requirements for the residences that they would like to ex-change with. Suppose a young couple in Beijing plan a vacation in Shanghai. Then the website should provide the couple the candi-date houses that meet most of the couple X  X  requirements and, at the same time, the couple X  X  house can match requirements imposed by those houses X  owners.

Case 3: Consider a job hunting website. Information of each open position on the website consists of the properties of the job, such as job category, title, salary, office locations, etc., as well as the requirements for job applicants, including education level, ma-jor, age, and so on. When a person searches for jobs on this website, he will input his personal information, including education level, age, major, etc., and his expectation on the jobs that he would like to find, such as salary, working locations, etc. The desirable results returned by the website should be the openings that meet most of his requirements and are looking for someone like him.

We refer to the queries in the aforementioned examples as match-ing queries . This type of queries is usually specified as a query ob-ject, which is associated with a number of attributes, together with a list of matching conditions. Each data object in the database also has a number of attributes and a list of conditions. Unlike tradi-tional queries, such as range queries, whose processing only needs to check whether the data objects are within the query region, the processing of matching queries needs to determine if both the data object and the query object can match each other X  X  conditions.
Besides the new query semantics, there are a couple of additional challenges in processing matching queries. First, the data type here is more complicated than traditional spatial data types, such as point data or region data. Instead, each data object in the above ap-plications can be modeled as a combination of a point and a region that represent the data object X  X  attributes and matching conditions respectively. Moreover, the point and the region could be in differ-ent domain spaces. For example in case 3, the attributes of an open position could be in a domain space consisting of job category, ti-tle, salary and locations; meanwhile, the required qualifications for the job applicants could be specified in a space with three dimen-sions: education level, age and major. This problem imposes extra challenges in building index on the data to speed up the queries.
Second, matching queries could exist in different forms even in a single application. For instance, in the job finding application, it is desirable to allow the users to choose whether they only want the jobs that satisfy all their conditions or they want a list of jobs, which may not meet all the conditions but are ranked by  X  X ow well X  the conditions are met. To realize this, a uniform indexing and process-ing framework could simplify the implementation and maintenance of the system.

Motivated by the above observations, we propose a matching query processing framework in this paper. In the framework, a sin-gle index is built on the joint space of the data object X  X  attributes and matching conditions. Note that in real applications, the user data and matching conditions can easily contain and involve dozens of attributes respectively. So the attribute space or the condition space alone, not to mention the joint space, is often high-dimensional. To overcome the curse of dimensionality, we transform each object into a single point in the joint space associated with several auxil-iary parameters and then we map the point into a one-dimensional key value. The resulting key value as well as the auxiliary param-eters are stored within a B + -tree like index. The framework also provides a generic query evaluation algorithm template, with which the system can evaluate various specific forms of matching queries in a uniform way by plugging in the appropriate functions.
Furthermore, we develop detailed algorithms for two specific forms of matching queries and show how they can be fit into the uniform processing framework. Finally, we perform an extensive experimental study on both real and synthetic datasets. The results show that our algorithms consistently outperform the other alterna-tive methods, especially when the dimensionality is high.
The rest of the paper is organized as follows. Section 2 reviews the related work. Section 3 presents the data model and query def-initions. The uniform indexing and processing framework as well as the detailed processing algorithms for the specific queries are described in Section 4 and Section 5 respectively. Section 6 reports the results of an extensive experimental study of our proposals. Sec-tion 7 concludes the paper. In this section we first review the spatial assignment problem in Section 2.1. Second, we review existing multi-dimensional indexes in Section 2.2. The most famous spatial assignment problem is known as the Sta-ble Marriage Problem (SMP)[12, 2, 8, 5, 7, 6].

The SMP is mainly involved in applications of resource assign-ment, where there is always a centralized management system. The SMP in these applications focuses on centrally assigning all objects from two different datasets into 1-1 pairs to achieve certain global stableness. After centralized assignment, each object is given a de-termined resource without personal choices. On the contrary in this paper we do not compel all objects to be assigned. Our goal is to provide customers good matching options and leave the decision to them. The matching query addressed in this paper is based on users X  individual demands and is a different problem from the SMP.
Further more, since the SMP focuses on achieving global stable-ness, the techniques proposed for SMP cannot achieve the goal of the matching queries proposed in this paper. The R*-tree is the state-of-art index for multi-dimensional objects. The R*-tree is optimized for range queries. The main concern about R*-tree is that it cannot scale to high-dimensional data well [11].
Many existing studies attempt to break the curse of dimension-ality[4, 11, 1, 13, 3]. However these high-dimensional indexes are only designed for point data and cannot handle data objects in more complicated forms. And there is no straightforward way to directly adapt any of them to index objects modeled in this paper. A data model should represent the attributes and matching condi-tions of objects at the same time.

First let D a denotes the number of attributes of each object, then the attributes of an object X can be modeled as a hyper-point in a D a -dimensional attribute domain space.

Each object is also associated with a number of matching con-ditions. Let D c denotes the number of dimensions that each object has matching conditions on and then the matching conditions of an object X can be modeled inside a D c -dimensional condition do-main space. In particular, each condition is represented as a tolerant range in the domain of one of the counterpart X  X  attributes.
In many applications, users may have different preferences among different attributes. We model the preferences of users as different weights on different attributes.
 Next, we give the formal definition of an object.

D EFINITION 1. An object X is represented as { P X ,R X W
X } ,where P X = { p X, 1 ,p X, 2 , ...,p X,D a } is the attribute point in a D a -dimensional attribute space, R X = { [ l X, [ l dimensional condition space and W X = { w X, 1 ,w X, 2 w
X,D c } contains the weight of each dimension of R X . Given a database where the attributes of objects are in a D dimensional attribute space and conditions are in a D c -dimensional condition space, a query object Q is a triplet, { P Q ,R Q where P Q is a point in the D c -dimensional condition space, R a rectangle in the D a -dimensional attribute space and W weights of each dimension of R Q .

In this section we define two specific types of matching queries, the full matching query and the tolerant top-k matching query. A full matching query is defined as follows: D EFINITION 2. Full matching query (FMQ) Given a database DB and a query object Q , a full matching query returns every object X from DB that P X is inside R Q in the at-tribute space and P Q is inside R X in the condition space.
An object X is the answer of a FMQ of Q iff for each dimen-sion i in the attribute space p X,i is inside [ l Q,i ,u Q,i dimension i in the condition space p Q,i is inside [ l X,i Next we introduce the tolerant top-k matching query (TKMQ), where a ranking is imposed on a data object based on  X  X ow tightly X  it and the query match each other X  X  tolerant ranges. We refer to the  X  X ightness X  of the match between a data object and a query as the tolerant matching coefficient and it is formally defined as follows:
D EFINITION 3. Given an object X and a query object Q , the tolerant matching coefficient between X and Q , denoted as t , is defined as where and
The M XY t can be viewed as the weighted number of dimen-sions that X and Q meet each other X  X  matching conditions. Next we give the formal definition of the tolerant top-k matching query. D EFINITION 4. Tolerant top-k matching query (TKMQ) Given a database DB , a query object Q and an integer k , a tol-erant top-k matching query returns a set S which consists of k objects from DB so that for any object X  X  S and any object Y  X  DB  X  S , M QX
A TKMQ answer object X does not have to match Q in all di-mensions but just matches Q in more dimensions than others. Usu-ally TKMQs are issued when there are no or not enough objects in the databases that totally matches with the query but users still want adequate choices. In this section, we present our matching query processing frame-work, PROM ( PRO cess various forms of M atching queries). PROM joins the attribute space and the condition space of the objects together and then builds index structure and processes matching queries in the joint space. In particular, we first propose an efficient and intuitive index technique utilized by PROM in Section 4.1. Then in Section 4.2 we summarize the general query processing procedure of PROM . The index is built in a ( D a + D c ) -dimensional domain space which is the joint space of the attribute space and condition space of ob-jects. In particular the first D a dimensions are corresponding to the attribute space and the last D c ones are corresponding to the condition space. In the rest of the paper, we use D J to denote the dimensionality of the joint space, i.e. D J = D a + D c . The index is built in the following three steps:
Step 1. For each object X = { P X ,R X ,W X } ,werepresentthe attribute point P X and tolerant range R X with a D J -dimensional rectangle, which is X D J = { [ p X, 1 ,p X, 1 ] , ..., [ [ l denote the center of X D J ,then c X,i = p X,i when i  X  [1 Furthermore, let r X be the maximum distance between C X and the bounds of X D J in each dimension, then r X =max D c i l X,i ) / 2 . We call r X the radius of X . In addition let  X  maximum weight of W X ,sothat  X  X =max D c i =1 w X,i . Therefore we transform X into a single point in the joint space associated with two auxiliary parameters.

Step 2. As mentioned earlier, the joint space is often of high dimensionality. Therefore in the second step for each object X we employ certain mapping technique to map the D J -dimensional center point C X into a one-dimensional key value. Note that any mapping technique, such as iDistance [3], the Pyramid [1] and P tree [13] can be used here. We will not go into details of the map-ping techniques due the space limit.

Step 3. After the second step, each object X is represented as combination of a key value and two auxiliary parameters, i.e. r and  X  X . In the third step we index these information of objects with one tree structure. Note that all existing mapping techniques employ B + -tree to index objects X  key s. We also employ B due to its simplicity and small size. However traditional B can only index objects based on one key value. In order to index key s together with the radiuses and maximum weights, we modify the node structure of B + -tree. The data structure of the new ad-vanced B + -tree is shown in Figure 1. In each tree node, besides the key values (shadowed in grey in the figure), we also store a radius and a weight of each child, which is the maximum radius and maxi-mum weight of all objects in the subtree of that branch. A leaf node serves as a bucket, containing the objects with key values falling in a range determined by key s stored in its father node. Algorithm 1 presents the processing algorithm template for match-ing queries. Note that when constructing the index, the center points of objects are all mapped into the one-dimensional space of the key values. Accordingly, given a matching query, we also need map the matching query into the same one-dimensional space. To achieve this we first transform the matching query into one or more range queries, since range queries can be easily mapped into one-dimensional space. This transformation is dependent on the exact query type, whose details will be presented in the following section. For each range query, we map it into an interval of one-dimensional key s in the same way as we handle the objects X  center points. These key intervals are then stored in a list L key . This whole process is done in a function GetKeyInterval () , which is different for each type of matching query.

Then PROM visits the advanced B + -tree from the root node down to the leaf nodes. In order to check as few objects as possi-ble, we search the advanced B + -tree in a  X  X est-first X  manner. That means the node whose subtree has the highest possibility of con-taining matching objects will be visited before the others. Finally, when a leaf node is visited, each object in the corresponding leaf node is checked to see if it is a match.

Specially, we maintain a max heap H in the memory. The entries in H are in the form of ( N,N.value ) ,where N is a tree node and N.value is N  X  X  ranking value in H . N.value indicates the likelihood that the objects in N  X  X  subtree satisfy the query.
The way to calculate N.value is different for different query types. (1) For ranking matching queries, such as TKMQ, N.value is usually a bound of the ordering value of objects in N  X  X  subtree. For example, for TKMQs, N.value is the upper bound of matching coefficient of objects in the subtree. Large N.value means that ob-jects in N  X  X  subtree may have high matching coefficients and high likelihood to be answers of the query. (2) For non-ranking matching queries, N.value is a Boolean value. For instance, in FMQ, if there are possible matching objects in N  X  X  subtree, we set N.value Otherwise, we set N.value =0 . More details of the estimation of N.value will be presented in the next section.
 Initially we push the root node with N root .value =  X  into H . Afterwards we always visit the node N in the top entry (
N,N.value ) of H ,since N has the greatest ranking value and hence is most likely to contain answers in the subtree.
If N is a non-leaf node, for each child node of N ,de-noted as N child , we compute N child .value and push it into H . N child .value is computed by a function GetRankV alue () , which works by directly comparing the key interval of N child the key intervals in L key . The function GetRankV alue () ferent for different types of matching queries.

If N is a leaf node, for each object X in N we check if X is a matching object. If yes, we put X into the answer list L ans
Avalue V thres is used to indicate when to stop visiting the nodes in H . (1) For ranking matching queries (top-k queries), V the k th maximum ordering value of the objects in the current an-swer list. The process stops when N.value is no larger than V which indicates no unvisited object can have higher rank than the current answers. For example, for TKMQs, V thres is always the k th maximum matching coefficient of the current objects in the answer list L ans . The visiting process stops when the top entry in H has a N.value no greater than V thres , which means no unvisited objects can have a matching coefficient greater than the current k objects in L ans . (2) For non-ranking queries, V thres is set to ing process stops when no nodes in H have N.value =1 ,which means no more nodes can have matching objects in their subtrees. Algorithm 1 : MatchingQuery( Q )
With the above algorithm template, for each particular query type, we only need to implement the appropriate function GetKeyInterval () and GetRankV alue () . In the next section, we will show how these functions can be designed for two example queries. FMQ.GetKeyInterval( Q )
Given a query Q , PROM transforms a FMQ into a number of range queries and pre-computes key intervals for these range queries in the following way.

First, we transform P Q and R Q into a rectangle in the data [ l [ l Now we can decide if an object X is a full matching answer of Q based on the following theorem.

T HEOREM 1. Given an object X with C X and r X ,if C X is not inside Q D J ( r X ) in the joint space, X cannot be a full matching answer of Q .
 The proof of Theorem 1 is omitted due to space limits. Based on Theorem 1, given a query Q , a full matching query is equivalent to searching every object X with its center C X inside an extension
Note that r X is the radius of a data object X and different ob-jects have different radiuses. Intuitively it is not feasible to get the some catalog radiuses. In particular, suppose r max is the maximum radius of all objects. Then we uniformly choose T values from (0 ,r max ] as the catalog radiuses , denoted as { r 0 ,r 1 ,...,r where r j &lt;r j +1 and r T  X  1 = r max . For each catalog radius r compute its corresponding key interval, denoted as [ key  X  in the same way as we handle the objects X  center points. All key in-tervals are stored in the form of ( r j , [ key  X  j ,key + FMQ.GetRankValue( N child , L key )
Note that for FMQs, the ranking value N child .value is a Boolean value, where 1 means that there may be matching objects in the subtree of N child and 0 means that no matching can be found in the subtree. In particular, we decide if there can be matchings in N child  X  X  subtree based on the following lemma.

T HEOREM 2. Given a child node N child associated with the maximum radius r child and key interval [ key  X  child ,key jects in the subtree of N child cannot be full matching answers of Q , if there is a radius r j in L key that r j  X  r r [ The proof of Theorem 2 is omitted due to the space constraint. Based on Theorem 2, for each child node N child associated with r following way. Let r chosen be the minimum catalog radius that is N TKMQ.GetKeyInterval( Q ) A TKMQ returns objects that match with Q in most dimensions. PROM transforms this problem into a number of range queries in the joint space in the following way.
 [ p
Q,D c  X  r, p Q,D c + r ] } , for each dimension i ( i  X  [1 Q D J ( r, i ) equals { [0 , 1] , ..., [ l Q,i ,u Q,i ] , ..., each dimension i ( i  X  [ D a +1 ,D J ] ), Q D J ( r, i ) is [ p lowing theorem.

T HEOREM 3. Given an object X with C X and r X ,foreach dimension i in the attribute space ( i  X  [1 ,D a ]) , p [ l dimension i in the condition space ( i  X  [1 ,D c ]) , p [ l The proof of Theorem 3 is omitted due to space constraint. Based on Theorem 3 for TKMQs, PROM transforms the problem of de-termining if X and Q match each other in each dimension into a number of subproblems, each of which is to determine if C inside Q D J ( r X ,i ) for a dimension i in the joint space.
We also choose T catalog radiuses { r 0 ,r 1 ,...,r T  X  1 (0 ,r max ] in the same way as we handle FMQs in the previous subsection. Then, for each catalog radius r j and each dimension For each Q D J ( r j ,i ) we compute its corresponding key interval, form of ( i, r j , [ key  X  i,j ,key + i,j ] ) into a list L
Note that for i  X  [1 ,D a ] , given two catalog radiuses r Q D J ( r j ,i )= Q D J ( r j ,i ) . So for each dimension i ( i diuses do not need further computation.
 TKMQ.GetRankValue( N child , L key )
The ranking value of each child node N child is the up-per bound of the tolerant matching coefficients of objects in the subtree of N child . For each N child , we initially set N child .value =0 .Thenlet r chosen be the minimum cata-logradiusthatisnolessthan r child . For each dimension i ,we i  X  [1 ,D a ] N child .value = N child .value + w Q,i and for i [
D All the experiments are run on a desktop PC with a 2.66GHz CPU and 4GB RAM. The page size is set to 4096 bytes.

We use both real and synthetic datasets. Details of the datasets and query generation are given in Section 6.2.

We conduct comparative performance study of both types of matching queries in Sections 6.3 and 6.4. We compare PROM based approach with the R*-tree based approach and sequential scan. All three approaches are implemented using C++ language. Particularly, we employ the P + -tree technique [13] as the mapping technique for PROM in this paper, since the mapping technique of P -tree is the latest and most efficient one.

We process matching queries with support of the R*-tree in the following ways. First we represent each object X = { P X ,R W X } with a D T -dimensional rectangle X D T = { [ p X, 1 ,p ..., [ l X, 1 ,u X, 1 ] ,..., [ w X, 1 ,w X, 1 ] ,... } ,where D Then we use a D T -dimensional R*-tree to index the transformed rectangles of objects. To process FMQs, we search the R*-tree from the root node to find all objects with transformed rectangles that in-tersect R Q in the first D a dimensions and P Q in dimensions from dimension D a +1 to dimension D a + D c . To process TKMQs, we search the R*-tree following a  X  X est-first X  manner in a similar way as processing TKMQs based on the PROM . Real Data . We downloaded two datasets from [9, 10]. The US Census (1990) data set contains 2,458,285 samples drawn from the full 1990 census sample. We use a subset of 50,000 samples in our experiments. The Adult Income data set contains the information of personal income of 48,842 adults drawn from the 1994 Cen-sus database. Both real datasets contain only point data. We obtain objects in our paper by attaching a range, with weights on each di-mension, to each point data. Specially we let the dimensionality of the attribute space and the condition space be the same.
Synthetic Data . We first generate a dataset containing d -dimensional points which follow certain distribution (uniform or Gaussian). Then we construct our objects based on these datasets in the same way as described above. Without additional specifi-cation, the basic information of real and synthetic datasets in our experiments are listed in Table 1.

Queries . The query object of a matching query is an object ran-domly chosen from the database. For every experiment, we run 100 queries and the result presented is the average on 100 queries. We measure the pruning power, query processing time and the number of disk page accesses (I/O). The pruning power is measured by the percentage of objects we need access during the query processing. The results of FMQs on all datasets in Table 1 are demonstrated in Figure 2. As shown by the results, the pruning power of R*-tree is only a little worse than PROM . However during query processing a large percentage of nodes of R*-tree are visited, which causes high I/O cost and time cost due to high cost of random accesses of these nodes. The speedup of PROM compared to the R*-tree reaches up to 24 times during these experiments (Census dataset). To summa-rize, PROM beats both other techniques in terms of pruning power, total precessing time and the number of I/O accesses.

We also construct two sets of experiments on synthetic data to investigate the impact of dimensionality and dataset cardinality on the query performance, respectively. The results are shown in Fig-ure 3 and 4. Note that the pruning power of both PROM and R*-tree increases as the dataset dimensionality increases. This is be-cause when the width of tolerant range on each dimension is fixed, the selectivity of a FMQ decreases as the dimensionality increases. Both the query processing time and the number of I/O of PROM increase linearly as the dataset dimensionality and cardinality in-crease, which proves that PROM scales very well in terms of di-mensionality and dataset cardinality. And it beats both other tech-niques in all aspects in this set of experiments. The default value of k is 10 in this set of experiments. As shown in Figure 5(a), the pruning power of PROM is much better than the R*-tree. On all datasets more than 80% objects are pruned by PROM . And with the R*-tree, 70% objects are left in the worst case (Gau32 dataset). This explains the huge improvement of PROM in terms of query processing time and number of I/O accesses, as shown in Figure 5(b) and 5(c).

We also construct two sets of experiments on synthetic data to investigate the impact of the dimensionality and dataset cardinality. In these experiments the comparative order of these techniques re-mains the same. Specially, the improvement of PROM compared to the other two approaches enhances as the dimensionality increases. Due to the space constraint, detailed results are omitted here. In this paper, we formulate the problem of matching queries, which has a wide applicability in many applications. To facilitate the ac-commodation of multiple types of matching queries in an applica-tion, we propose a processing framework, PROM , which is com-posed by an efficient index and a query processing template. With this framework, one can easily extend the query types that can be supported by the system. Moreover, we conduct a detailed analysis of two specific types of matching queries and show how the pro-cessing algorithms of these queries can be developed within our framework. Finally, we conduct an extensive experimental study on both real and synthetic datasets to prove the efficiency of our proposal. The experimental results suggest that our algorithms can outperform the other alternatives significantly.
