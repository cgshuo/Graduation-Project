 Top-k preference queries with multiple attributes are critical for decision-making applications. Previous research has con-centrated on improving the computational efficiency mainly by using novel index structures and search strategies. Since current applications need to scale to terabytes of data and thousands of users, performance of such systems is strongly impacted by the amount of available memory. This pa-per proposes a scalable approach for memory-bounded top-k query processing.
 H.2.4 [ Database Management ]: Systems X  Query Pro-cessing Performance, Algorithm Preference queries, Query Optimization
There has been increasing interest in top-k preference queries from information retrieval (IR) and decision-making applications. In these applications, the data sets usually consist of data entities with a variety of attributes which can be used to order the data. The data entities are objects from the application domains such as images or documents. The attributes which can be used to rank objects are called rank attributes . For example, hotels could be ordered ac-cording to such attributes as price, number of rooms, and quality of service. Users might need to rank the data enti-ties with different metrics represented as a function defined over a selection of rank attributes. The metrics are referred to as score functions . Usually the score functions are mono-tonically increasing or decreasing w.r.t the rank attributes.
Top-k query processing is usually studied in two scenarios: in a distributed systems model, a.k.a middleware systems, or in database systems. The solutions of top-k query [4, 5, 7] in middleware systems is applicable, but neither scalable nor efficient when used in database systems. For example, in our experiments with TA (Threshold Algorithm), for a uniform dataset with 10,000 objects, when the independent  X 
This work was supported by NSF under the following grants: CNF-04-23336, IIS-02-23022 and IIS-02-09112 rank attributes grow from 2 to 8, the number of objects accessed using the TA increases from 400 to 8,000, which is 80% of the size of the entire dataset.

Most research on top-k queries in database systems[2, 3, 9] improves performance by utilizing customerized index struc-tures and efficient search strategies on the indexes. The best-first search algorithm [8] can be shown to be optimal in terms of the number of node accesses, when applied to top-k queries using multi-dimensional indexes. At each iteration, the node with the highest best possible score is chosen as the next one to be expanded till k data tuples are generated. Memory plays an important role in query performance. Although the best-first search algorithm ensures optimality, the size of the priority queue, that is, the memory require-ment grows with the number of nodes intersecting with the optimal search range, thus proportional to the data set size. Therefore, the available memory might not always meet the memory needs of the proposed query processing methods, given the increasing data amount especially in web-based applications. Furthermore, the client-base demanding top-k preference queries is expanding rapidly. As many as 150,000 queries need to be serviced in peak time and hundreds of concurrent users send requests. We, therefore, propose a scalable approach to ensure both flexible memory bounds and computational optimality.
The analysis above suggests to bound the data space in order to bound the memory usage in the optimal best-first search algorithm. This objective is consistent with the op-timization based on the cost model for minimizing object accesses in Fagin X  X  algorithms [4, 5] for distributed systems. Fagin X  X  first algorithm(FA) [4] can be applied to generate the reduced candidate data set FA ( k ) for top-k queries with ar-bitrary monotonic score functions. The idea is to sort tuples by their rank attribute values and access sorted lists of tu-ples simultaneously, just as scanning sorted lists of objects in FA. The candidate data include the tuples retrieved when k common tuples are accessed from all sorted rank attributes. However, the candidate set can be further minimized by ex-ploiting the dominance rank of d -dimensional data sets.
Definition 1. Let t denote a data tuple for a given d -dimensional data set, the dominance rank of t , dr ( t ) , is the number of data tuples dominating the tuple t .

Intuitively, the dominance rank of point p is the number of data points dominating point p . For example, tuple s 1 has dominance rank 0(Figure 1). Based on the dominance rank , we can further introduce the dominance rank k set DR ( k ) as { t | dr ( t ) &lt; k } . For the example of Figure 1, DR (2) = DR (1)
Figure 1: Dominance ranks of an example table = { s 1 , s 2 , s 4 } . It is straightforward to see from the definition that DR ( k )  X  DR ( k + 1). Also as expected, DR ( k ) can be proven as the minimal candidate data set for top-k queries with any arbitrary monotonic score functions. Moreover, it can be shown that FA ( k )  X  DR ( k ).
Dominance rank can reduce the data space for any given top-k query by partitioning data apriori. Then top-k query evaluation can be decomposed on multiple partitions.
The preprocessing phrase includes three steps: (1) to com-pute the dominance rank of the whole data set; (2) to par-tition data tuples; (3) to build a multi-dimensional index on each partition. As the third step is based on indexes of choice, we detail the first two steps below.

The computation of dominance rank can be accom-plished by a multidimensional divide-and-conquer algorithm for all-point ECDF rank problem proposed by Bentley [1]. The computation complexity is O ( Nlog d  X  1 N ) for any d &gt; 1, and d is the number of rank attributes and N is the num-ber of data tuples. An alternative to achieve better pre-processing time at the expense of approximation is to ap-proximate DR ( k ) using FA ( k ). Therefore, the approxima-tion algorithm costs linear time complexity, O(Nd).
The next step, partitioning the data space , aims to bound the partition size preferably by some constants. There-fore, the threshold size partitioning is empolyed here. It di-vides the whole datasets into p ordered subsets: DR ( k 1 proceeds to ensure bounded partition size using O ( n ) time complexity: First, the data set is scanned in the ascending order of dominance ranks. The data points with dominance rank k are put into a bucket bin [ i ] until the bin [ i ] size exceeds the max size, threshold  X  . Then a new bucket bin [ i + 1] is created to accommodate data points with dominance rank k + 1. Figure 2(b) shows an example for partitions with threshold 200, i.e. each partition size is at least 200.
Theoretically, if  X  &gt; max i | DR ( i )  X  DR ( i  X  1) | , that is, threshold  X  is greater than any set of dominance rank k data, the partition size is bounded within  X  and 2  X  .
Figure 2: Reducing the search space by partitions
In order to process top-k preference queries over parti-tioned data, two questions need to be addressed: (1)Which partitions need to be examined to answer the top-k prefer-ence queries correctly? (2) What kind of queries should be posted on those partitions?
The first question can be answered by the results in Sec-tion 2. Only the partitions containing data from set DR ( k ) is possible to be a top-k answer for any monotonic score function. As an example in Figure 3, a top-5 query involves three partitions: P 1 , P 2 , P 3 .

For each of the partitions to be examined, a top-k query can be decomposed into several top-k sub-queries on them. The following lemma answers the second question: how the top-k queries are decomposed.

Lemma 1. Suppose the dominance ranks of data in Parti-tion P i range from k i  X  1 +1 to k i , where k i  X  1 &lt; k . Partition P i can only contribute to at most k  X  k i  X  1 members in any top-k query result set, ranging from the ( k i  X  1 +1) -th to k -th answers. Therefore, the top-k query can be decomposed to a top-( k  X  k i  X  1 ) sub-query on each partition P i containing the candidate answers.

For example, in Figure 3, a top-5 query is decomposed into a top-5 query on P 1 , a top-2 query on P 2 and a top-1 query on P 3 . The algorithm to process sub-queries is not described here due to space limit [6].
We address the challenges of memory bounds using op-timal best-first search algorithm to improve the scalability for preference queries in database systems. The advantages of the proposed technique include: (1) It provides a scal-able approach to process top-k preference query with flexible memory bounds; (2) The query processing is progressive.
