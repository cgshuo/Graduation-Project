
Many important industrial applications rely on data mining methods to uncover patterns and trends in large data warehouse environments. Since a data warehouse is typically updated periodically in a batch mode, the mined patterns have to be updated as well. This re-quires not only accuracy from data mining methods but also fast availability of up-to-date knowledge, particu-larly in the presence of a heavy update load. To cope with this problem, we propose the use of online data mining algorithms which permanently store the discov-ered knowledge in suitable data structures and enable an efficient adaptation of these structures after inser-tions and deletions on the raw data. In this paper, we demonstrate how hierarchical clustering methods can be reformulated as online algorithms based on the hierar-chical clustering method OPTICS, using a density esti-mator for data grouping. We also discuss how this al-gorithmic schema can be specialized for efficient online single-link clustering. A broad experimental evaluation demonstrates that the efficiency is superior with signif-icant speed-up factors even for large bulk insertions and deletions.
Many companies store terabytes of corperate data in large-scale data warehouses. This tremendous amount of data can only be fully exploited and utilized by ef-ficient and effective data mining tools. Industrial ap-plications such as decision support systems in a data warehouse environment require not only high accuracy from data analysis methods but also fast availability of up-to-date knowledge. The challenge is to recall cur-rent knowledge from anywhere at any time with a delay of no more than a few minutes  X  a prohibitive demand for many data mining algorithms which are able to gain knowledge only from scratch using highly complex op-erations.

To cope with this problem of updating mined pat-terns in a data warehouse environment, we propose the use of data mining algorithms which permanently store the acquired knowledge in suitable data structures and facilitate an efficient adaptation of this stored knowl-edge whenever the raw data from which the knowl-edge is drawn changes. We call such a method an on-line data mining algorithm, and its conventional coun-terpart is called offline . When speaking of a data warehouse environment, we do not anticipate a cer-tain architecture, but address an environment in which changes in the transactional database are collected over some period (e.g. daily) and the data warehouse is up-dated using batch operations, i.e. bulk insertions and deletions. Therefore, it is important that online data mining algorithms efficiently support insertions, dele-tions and updates not only of single data items but also for larger sets. Depending on the size of the bulk to be inserted, deleted, or updated, the response of an online data mining algorithm is much faster compared to its offline competitor. Let us note that the concepts presented in this paper are independent of the physical process of incremental data warehouse maintainance (cf. e.g. [11] for a discussion on that topic).
One of the major data mining tasks is clustering which aims at partitioning the data set into groups (clusters) of similar objects. Hierarchical algorithms determine a hierarchy of nested clusters. Widespread methods such as single-link, complete-linkage, aver-age linkage [8] or OPTICS [1] represent and visual-ize cluster hierarchies by dendrograms or reachability diagrams. A dendrogram (cf. Figure 1 (right)) is a (usually unbalanced) tree where the root represents the complete data set, each leaf node represents a single ob-ject and the internal nodes represent the cluster struc-ture. A reachability diagram (cf. Figure 1 (left)) can be regarded as a linearization of this tree by a depth-first traversal, depicting only the degree of similarity of the objects in a cluster. Both structures visualize the hierarchical cluster structure of the data set and can be transferred into each other [12].

Both the dendrogram as well as the reachability dia-gram are exactly those knowledge representations that need to be stored permanently and need to be updated accordingly when reformulating a hierarchical cluster-ing algorithm from the conventional offline version into the new online version. In this paper, we focus on reachability diagrams, mainly because the online main-tainance is easier to handle as we will see later. By doing this we do not sacrifice generality, due to the equivalence of dendrograms and reachability diagrams. We show how this structure can be efficiently updated whenever the data set changes due to insertions, dele-tions or update operations.
 The rest of the paper is organized as follows: In Section 2 we discuss related work and different meth-ods to represent the hierarchical clustering structure. Section 3 proposes algorithms for hierarchical online clustering. Section 4, presents a broad experimental evaluation. Section 5 concludes the paper. Clustering is one of the primary data mining tasks. A huge amount of clustering algorithms have been pro-posed in the past years (see e.g. [8] for an overview). Since we tackle the problem of hierarchical clustering, we focus on discussing recent work on online hierar-chical clustering in this paper, rather than online algo-rithms for flat partitioning clustering algorithms.
Several methods have been proposed for online hier-archical clustering, e.g. SLINK [13] for single-linkage, CLINK [6] for complete-linkage, GRIN [5] based on the gravity theory in physics, and IHC [14]. All thesse ap-proaches suffer from at least one of the following draw-backs: (1) The algorithms only provide the possibility to handle insertions of data objects. Deletions cannot be handled in an online fashion. (2) The algorithms can only process one update object at a time and are usually difficult to generalize to manage sets of update objects. Thus, they are not efficient for large bulk up-dates which frequently occur in a data warehouse en-vironment. In this paper, we propose an algorithmic schema that overcomes these limitations, i.e. enables efficient online hierarchical clustering when inserting and deleting huge bulks of data objects.

In [4] a compression technique for hierarchical clus-tering called  X  X ata Bubbles X  is proposed (recently ex-tended in [15]). In [10], the authors propose an incre-mental summarization method based on Data Bubbles which can be applied to dynamic hierarchical cluster-ing. Since Data Bubbles tend to miss details in the cluster hierarchy when increasing the compression rate, the benefit of improving the runtime is limited by the accuracy. The approach of compressing data by Data Bubbles, however, is orthogonal to the approach pro-posed in this paper: Online hierarchical clustering can be applied to the original data or to compressed data.
The clustering of a data stream is to some degree re-lated to the online clustering in data warehouses. Both methodologies aim at providing the user with up-to-date information on clusters very quickly in a dynamic environment. However, data streams impose different requirements on clustering algorithms and the entire data mining process (see e.g. [2, 7]). In particular, in a data warehouse, the clustering algorithm has access to all points currently in the database and not necessar-ily only to the most recently inserted points as usually in case of stream data. In addition, when clustering stream data, the algorithm is restricted to sequential access to newly inserted objects. This restriction does obviously not apply to algorithms for online cluster-ing in a data warehouse environment. Our solutions are therefore different from the data stream clustering context in these two aspects. In particular, we empir-ically show that our bulk update algorithms are con-siderably more efficient than a sequential processing of each single object in the update bulk.

In [9] an preliminary incremental version of OPTICS is presented. However, this approach has no bulk up-date mode and thus, cannot handle large sets of up-dates.
Hierarchical clustering algorithms compute a hier-archical decomposition of the data objects. The hier-archical clustering structure is usually visualized using a dendrogram (cf. Figure 1 (right)). One leaf of this tree corresponds to one data object. The root repre-sents the entire database. A node in the dendrogram represents a cluster containing all child nodes.
A well-known algorithmic schema constructs a den-drogram in an agglomerative fashion. It starts with each object of the database placed in a unique clus-ter (leaf nodes) and then merges in each step that pair of clusters having minimal distance until all data ob-jects are contained in one cluster. Algorithms differ in the definition of the distance between clusters, e.g. the single-link method [13] defines the distance between two sets of objects as the distance of the closest pair between both sets. Most popular distance measures be-tween clusters (e.g. single-link, average-link, complete-link) usually favor clusters of certain shapes.
In [1] the hierarchical algorithm called OPTICS is presented which uses a density-based clustering notion. In particular, OPTICS takes the density in the neigh-borhood of an object into account, using two input parameters,  X  and minPts .The core distance of o  X  X  , denoted by CDist ( o ), measures the density around o and is computed as CoreDist ( o )= nn-dist minPts ( o )if |N notes the  X  -neighborhood of o and nn-dist k ( o ) denotes the k -nearest neighbor distance of o .The reachabil-ity distance of an object p  X  X  relative from object o  X  X  w.r.t.  X   X  and minPts  X  is then de-fined as RDist ( o, p )=max( CDist ( o ) , X  ( o, p )), where  X  is the distance function. The reachability distance of p from o is an asymmetric distance measure that takes the density around o (its core distance) into ac-count. Let us point out that for  X  =  X  and minPts =2 the reachability distance of p from o is  X  ( o, p )), since CDist ( o )=  X  ( o, p )).

The OPTICS algorithm computes a so-called cluster ordering of a database w.r.t. the two input parameters  X  and minPts . In addition, the core distance and a  X  X uitable X  reachability distance is stored for each ob-ject. This information is enough to extract the hierar-chical clustering structure of the data set. The algo-rithm starts with an arbitrary object o  X  X  , assigns a reachability distance of  X  to o and expands the cluster order if the core distance of o is smaller than the input parameter  X  . The expansion is performed by inserting the objects p  X  X   X  ( o ) into a seed list. This seed list is organized as a heap, storing that object q as first object in the list, having the minimum reachability distance to all the already processed objects. The next object to be inserted in the cluster ordering is always the first ob-ject in the seed list. If the core distance of this object is smallerorequalto  X  , all objects in the  X  -neighborhood are again inserted into or updated in the seed list. If the seed list is empty and there are still some not yet processed objects in D , we have a so-called  X  X ump X . OPTICS selects another arbitrary not yet handled ob-ject in D to further expand the cluster ordering CO as described above.

The resulting cluster ordering can be visualized very intuitively and clearly by means of a so-called reacha-bility diagram , even for very large datasets. A reach-ability diagram is a 2D visualization of a cluster or-dering, where the objects are plotted according to the cluster ordering along the x-axis, and the reachability distance of each object along the y-axis (cf. Figure 1 (left)). Clusters are  X  X alleys X  in the diagram.
In contrast to other methods, OPTICS does not fa-vor clusters of a particular size or shape. Single-link clustering is in fact a special parametrisation of OP-TICS. A single-link clustering can be computed using OPTICS with  X  =  X  and minPts =2.
As discussed above, usually a reachability diagram can be transformed into a dendrogram and vice versa [12]. Due to these relationships, we can develop on-line algorithms for bulk insertions and deletions using reachability diagrams as a representation of a hierar-chical clustering structure without loosing generality. We propose algorithmic schemata called OnlineOP-TICS that can be used for efficient online clustering in both worlds  X  agglomerative single-link clustering and density-based clustering.

In the following, we call the insertion or deletion of a bulk of objects an update operation . The bulk of update objects is denoted by U . We further assume D to be a database of n objects and  X  to be a metric distance function on the objects in D .
OPTICS computes a cluster ordering. In order to maintain a cluster ordering, we first formalize it.
Figure 2. Visualization of predecessor and successors.
 Definition 1 (cluster ordering) Let minPts  X  ,  X   X  ,and CO be a permutation of the objects in D .Each o  X  X  has additional attributes o.P , o.C and o.R ,where o.P  X  X  1 ,...,n } symbolizes the position of o in CO .Wecall CO a cluster ordering w.r.t.  X  and minPts if the following conditions hold: (1)  X  p  X  CO : p.C = CDist ( p ) (2)  X  p  X  CO : p.P = i  X  Condition (1) states that p.C is the core distance of ob-ject p . Intuitively, condition (2) states that the order is built by starting at an arbitrary object in D and then selecting at each position i in CO that object p hav-ing the minimum reachability distance from any object before i . p.R is this minimum reachability distance as-signed to object p during the generation of CO .The object p which is responsible for the choice of object o at position o.P is called the predecessor of o in CO , denoted by Pre ( o ). We say that o has been  X  X eached X  from its predecessor. If o has not been reached from any other object, its reachability distance o.R in CO is  X  , and thus, its predecessor is undefined. Analo-gously, the successors of on object o in CO , denoted by Suc ( o ), are those objects having o as their prede-cessor, i.e. Suc ( o )= { p  X  CO | Pre ( p )= o } .The successors of an object o include all objects in the clus-ter ordering that have been reached from o . Obviously, there may also be objects that do not have any succes-sors. Both concepts of predecessor and successors are visualized in Figure 2.

As stated above, the cluster ordering is exactly that representation we need for an efficient online recon-struction of the hierarchical clustering structure. In particular, for each object o in the cluster ordering, we compute its position ( o.P ), its core distance ( o.C ), the  X  X uitable X  reachability distance ( o.R ),andinaddi-tion to the original OPTICS algorithm its predecessor (
Pre ( o )) and its successors ( Suc ( o )) on the fly during the original OPTICS run or during reorganization.
In case of an update operation, condition (2) of Defi-nition 1 may be violated. Recomputing the entire clus-ter ordering using the offline OPTICS algorithm re-quires the computation of one range query for each ob-ject in the database. However, in most cases, several parts of the cluster ordering remain unchanged. For these parts of the cluster ordering, we do not need to computerangequeries. Theideaofanonlineupdateis to save unnecessary range queries and distance calcu-lations during reconstruction. In the following, we say that if we decide to compute a range query around an object, this object is affected by the update and needs reorganization.

To determine the objects that are affected by up-date operations, we make the following considerations. Due to an update operation, the core distance of some objects may change. As a consequence, the reachabil-ity distances of some objects that were  X  X eached X  from these objects in the cluster ordering may also change, causing the above mentioned violation of condition (2) in Definition 1. We call the objects with changing core distances directly affected objects .Let NN k ( q )bethe set of the k -nearest neighbors of q  X  X  .Thesetof re-verse k -nearest neighbors of an object p  X  X  is defined as Rev k ( p )= { q  X  X | p  X  NN k ( q ) } .
 Definition 2 (directly affected objects) Let U be the update set and CO be a cluster ordering of D w.r.t.  X   X  and minPts  X  .Thesetof directly affected ob-jects due to an update operation, denoted by DAff( U ) , is defined as DAff( U )= { o  X  Rev minPts (u) | u  X  X  X   X  (o , u)  X   X  } .
In fact, not all objects in DAff( U ) must change their core distances. It may happen that an object o  X  DAff( U ) has a core distance of already  X  . Then, in case of deletion, the core distance of o obviously re-mains unchanged. In case of insertion, the change of the core distance of o depends on whether the minPts -nearest neighbor distance of o decreases under the limit of  X  . Obviously, an object not belonging to DAff( U ) cannot change its core distance due to the update op-eration.

The set DAff( U ) can be efficiently computed using the following lemma.
 Lemma 1 Let U be the update set and CO be a cluster ordering of D . Then the following holds: DAff( U )= { o | u  X  X  X  o  X  X   X  (u)  X   X  (u , o)  X  CDist (o) } .
 Proof. Let X := { o | u  X  X  X  o  X  X   X  ( u )  X   X  ( u, o )  X  CDist ( o ) } . We show that DAff( U )=X :  X  o  X  DAff( U ):u  X  X  X   X  (o , u)  X   X   X  o  X  Rev minPts (u)  X  u  X  X  X  o  X  X   X  u  X  X  X  o  X  X   X  u  X  X  X  o  X  X   X  u  X  X  X  o  X  X 
Lemma 1 states that we can filter out a lot of objects not belonging to DAff( U ) by computing only one range query around each update object u  X  X  . In addition, for all u  X  X  we only have to test the objects o  X  X   X  ( u ) whether o  X  Rev minPts ( u ) holds. The idea is that for all o  X  Rev minPts ( u ), it holds that  X  ( u, o )  X  CDist If the update operation is an insertion, the core dis-tance of o decreases, whereas if the update operation is a deletion, the core distance of o increases.
Due to mutating core distances, reachability dis-tances of some objects may change. We call these ob-jects indirectly affected. A changing reachability dis-tance may cause the violation of condition (2) in Def-inition 1. If a reachability distance of an object o de-creases due to a changed core distance, o may move forward in the cluster ordering, otherwise o may move backwards. In addition, if an object o has changed its postion in the cluster ordering, the successors and the predecessor (if not yet handled) might also be affected because these objects may now be reached earlier or later, i.e. may be placed at a different position in the new cluster ordering.

We call these objects that may be indirectly affected by the reorganization of an object o the potential suc-cessors of o . The set of potential successors Suc ( o )of an affected object o  X  CO is recursively defined: (1) if p  X  Suc ( o )then p  X  Suc pot ( o ). (2) if q  X  Suc pot ( o )and p  X  Suc ( q )and
Condition (1) states that all direct successors of o are also candidates for reorganization. The second condition collects recursively the direct successors of potential successors, as long as their assigned reacha-bility distance increases. If the reachability distance decreases, we enter a new cluster where the objects are more densely packed. In this case, the objects can only be affected by the local neighborhood. The intuition behind condition (2) is visualized in Figure 3. The re-cursive collection of the potential successors of object o stops at object p . All objects in C will be reached from
Figure 3. The recursive collection of potential successors of o stops at p and may restart at q . p or another object in C but not from o . The recursive collection may restart at q if q or any object after q is the successor of p or of any object before p . Lemma 2 Let U be the update set, CO be a cluster ordering of D ,and o, p  X  CO .If p  X  Suc pot ( o ) ,then o = Pre ( p ) .
 Proof. Let p  X  Suc pot ( o ) . We show o = Pre ( p ) by recursion over Suc pot ( o ) : (1) p  X  Suc ( o )  X  o = Pre ( p ) . (2) q  X  Suc pot ( o ) and p  X  Suc ( q ) and x  X  Suc pot ( o )  X  x.P = p.P  X  1  X  x.R &gt; p.R : Since x has been reached earlier than p from the ob-jects before x , x.P = p.P  X  1 ,and x.R &gt; p.R , p must have been reached from x , i.e. Pre ( p )= x  X  o = Pre ( p ) .

Lemma 2 states, that only the points in PotSuc ( o ) can be affected by a reorganization of an object o Now we are able to develop online versions to handle insertions and deletions efficiently. In the following, CO old denotes the original cluster ordering before the update. OnlineOPTICS will create CO new , the new (valid) cluster ordering after the update, by perform-ing a single pass over CO old .
The pseudo code of the online bulk insertion algo-rithm is depicted in Figure 4. In the first step of the insertion of all objects in U , the core distances of each o  X  DAff( U ) are updated and all objects u  X  X  are inserted into the seed list OrderedSeeds with u.R =  X  and Pre ( u )=  X  . Thisisbecauseitisnotyetclear, from which object the objects in U are reached in
After that, the reorganization is performed, imitat-ing the original OPTICS algorithm. We manage the objects that need reorganization in the seed list. In each iteration of the reconstruction loop, we compare the next not yet handled object c in CO old with the first object s in OrderedSeeds . The object among the two ( c and s ) which has the smaller reachability dis-tance value is appended to CO new . If the reachability distance values of both objects are equal, we append that object having the smaller position.

After the insertion of an object l into the new cluster ordering CO new ,wehavetoupdate OrderedSeeds .This is done by the method update which is an adoption of the corresponding method in [1]. If the recently processed object l is derived from the original cluster ordering CO old , we have to test which update objects u  X  X  have been already processed. If any u  X  X  has not been processed and l.C =  X  and  X  ( l, u )  X   X  , u would have been inserted/updated in OrderedSeeds in the original OPTICS run. Thus, l may be a potential predecessor of u and OrderedSeeds has to be updated accordingly. Other connections are not affected, since we store the objects that need reorganization in the seed list. If l is derived from OrderedSeeds or from DAff( U ), some connections may need reorganization. Thus, all not yet processed potential successors x  X  Suc pot ( l ) have to be inserted/updated in the seed list.
The reorganization stops if the original cluster or-dering CO old does not contain unprocessed objects any more and the seed list is empty.
 Lemma 3 The online bulk insert algorithm produces a valid cluster ordering w.r.t. Definition 1. Proof. Due to space limitations, we refer to the long version of this paper for the proof.
The pseudo code of the online bulk deletion is de-picted in Figure 5. In the first step, all objects u  X  X  are marked as handled. In addition, for each o  X  DAff( U ) the core distance of each o is updated and its potential successors Suc pot ( o ) are inserted into Or-deredSeeds with a reachability distance of  X  and (yet) undefined predecessor.

After that, the reorganization is performed, again simulating the original OPTICS algorithm. In each iteration of the reconstruction loop, we compare the reachability distance of the next not yet handled object c in CO old which is not contained in DAff( U )withthat of the first object s in OrderedSeeds . If the predecessor of c is not yet processed (i.e. inserted into CO new ), c cannot be taken from CO old and cannot be appended to
CO new . Otherwise, that object of c and s ,having the smaller reachability distance value, is appended to
After the insertion of an object l into the new cluster ordering CO new ,wehavetoupdate OrderedSeeds .This is done by the methods update and updateAll which are both adoptions of the according method in [1].
The reorganization stops if the original cluster or-dering CO old does not contain unprocessed objects any more and the seed list is empty.
 Lemma 4 The online bulk delete algorithm produces a valid cluster ordering w.r.t. Definition 1. Proof. Due to space limitations, we refer to the long version of this paper for the proof. We compared OnlineOPTICS with offline OPTICS. We on several synthetic databases and a real-world database containing TV-snapshots represented by 64D color histograms. All tests were run under Linux on a workstation with a 3.2 GHz CPU, and hard disk with a transfer rate of 20 MByte/s for the sequential scan. Random page accesses need 8ms including seek time, latency delay, and transfer time. Unless other-wise specified, we used an X-Tree [3] to speed-up the range-queries required by both algorithms.

The speed-up factors of OnlineOPTICS over the of-fline version w.r.t. the database size are depicted in Figure 6. As it can be seen, the performance gain achieved by the online update algorithm is growing with an increasing number of data objects both for insertions and deletions. In fact, an online update of nearly 10% of the data objects is still more efficient than an offline update.

We illustrate the speed-up factors of OnlineOPTICS over offline OPTICS w.r.t. the dimensionality of the database in Figure 7. With increasing dimensionality of the database, the speed-up factors slightly decrease due to the performance deterioration of the underlying index.

The only parameter of offline OPTICS that affects the performance is  X  . In [1] the authors state, that  X  has to be chosen large enough. In particular,  X  has to be chosen large enough, such that there is no jump in the ordering. In general, the optimal choice of  X  is quite hard to anticipated beforehand, so we copmared Onli-neOPTICS to offline OPTICS w.r.t. several choices of  X  . The results are depicted in Figure 8 showing that the higher the value for  X  , the bigger is the performance gain of the online update. This can be explained by the decreasing selectivity of the underlying index.
We applied offline OPTICS and OnlineOPTICS to the above mentioned real-world dataset of 64D color histograms representing TV snapshots. The results are illustrated in Figure 9, confirming the observations made on the synthetic data. As it can be seen, On-lineOPTICS also achieved impressive speed-up factors over OPTICS for both insertion and deletion of a bulk of objects.

We also tested offline OPTICS and OnlineOPTICS computing all range queries on top of the sequential scan using a synthetic database of 2D feature vectors. The result is not shown due to space limitations. We observed that for 200,000 data objects, the online up-date of 10% of the data objects is still more efficient than an offline update.

Our proposed bulk update algorithms can easily be adopted to process the update set sequentially, i.e. pro-cessing each object u in the update set separately as it is required for data streams. We compared our bulk schema with such a sequential update processing on a 2D dataset containing 10,000 points. We varied the update load between 1% and 10% of the database size. Figure 10 illustrates the speed-up factor of bulk Onli-neOPTICS over sequential Online OPTICS. As it can be seen, the bulk mode clearly outperforms the sequen-tial update processing. The ratio between the speed-up factors of the bulk mode and of the sequential mode is increasing with growing update load, i.e. the bulk mode outperforms the sequential mode the more, the larger the size of the update set is. Obviously, this is because the bulk mode only requires one run through the old cluster ordering while the sequential update processing requires multiple runs over the old cluster ordering.
Online algorithms for data mining are important to detect knowledge which is not only accurate but also immediately available and up-to-date. In this paper, we have proposed OnlineOPTICS, an online version of the single-link method and its generalization OPTICS which is able to process large bulk insertions and dele-tions as occuring in a data warehouse environment. We have shown that the performance of our algorithm is superior to offline algorithms even in the presence of a heavy update load (large bulk insertions and bulk deletions). In addition, we empirically showed that the bulk mode clearly outperforms a sequential processing of the update set. Our solution could also serve as a template for online versions of further data mining algorithms such as single-link.

Figure 10. Comparison of bulk update versus sequential update processing.
