 become a common configuration for modern computers. HANA[1] proposed an in-memory computing platform with dramatic performance enhancement. It has been In-Memory Machine[2] also employs TBs of RAM and flash memory to achieve high However, in-memory computing mechanisms still need further optimization to make full use of the multicore and the large RAM. 
In [3], the authors announced that memory access is a new bottleneck for in-memory computing. Column-store, the BAT (Binary Associated Table) algebra and the radix-clustering are key techniques to optimize memory bandwidth and memory in-memory data warehouses. Examples include MonetDB, HANA and HyPer[4]. Analytical processing usually relies on column scan and column join to filter out un-the selectivity varies from 3.4% to 0.0000762%), column scan can actually be tion. In data warehouses, these  X  X ot data X  are usually defined by keywords in dimen-sion tables and can be mapped to the big fact table. For example, the user group in keywords to retrieve hot data. The useful information linked by the keywords is join relation between  X  X ot X  keywords and fact records, we could improve the perfor-instance, Oracle X  X  bitmap join index[6] is a bitmap index for the join of two or more tables. However, as a join index is very space consuming, it is usually very expensive to maintain such an index completely in memory. According to the Power law[7](also known as 80-20 rule) phenomenon, only 20% attributes are frequently accessed frequently accessed items, we can achieve 80% of the performance improvement. 
In this paper, we focus on how to identify the hot data using keywords and how to normally looks like the following example (SSB Q4.1): The WHERE clause in the box involves the join relations between the fact and dimen-served. We can represent the predicates with four keywords:  X  X _region_AMERICA X ,  X  X _region_AMERICA X ,  X  X _mfgr_MFGR#1 X  and  X  X _mfgr_MFGR#2 X . To facilitate the data access, we can create a bitmap index for these keywords to identify which pos itions in the fact table satisfying the predicate expressions. When similar queries are invoked, we can reuse the bitmap to filter fact table. If we use hot keywords as hot data axis, the keywords. Traditional index scan only filters records for routine join operations. In con-proach, a query with star-join is simplified as a positional scan and filtering operation. 
Our contributions can be considered as two-folds: hot data for both flexibility and space efficiency. 
Keyword bitmaps are used to produce global keyword filter. Predicate bitmaps are used as star-join filter for survived records to further filter final result set. cussed in Sec.3. Sec.4 presents the results of experiments. Finally, Sec.5 summarizes the paper. 2.1 Hot Data Identification Both in OLTP and OLAP workloads, data accesses always tend to be skewed. In identify which records are frequently accessed by record counter or sampling method. [8] proposed a sample record access me thod with record accesses on log, forward and backward algorithms are designed for past-to-present scan and present-to-past scan to posed multiple bloom filter based hot data identification to capture recency. warehouse. Moreover, data warehouse employs multidimensional model, and hot data in data warehouse is commonly defined as hypercube with predicates on different dimensions such as  X  X _region= X  X MERICA X  AND s_region= X  X MERICA X  AND (p_mfgr= X  X FGR#1 X  OR p_mfgr= X  X FGR#2 X  ) X ; each predicate expression denotes a slice on different axis. It is simple and efficient to identify hot predicate expressions dimensions and hierarchies, analytical processing usually follows the pre-defined using combined hot keywords to identify hot data cost much less than identifying hot data records. 2.2 Bitmap Join Index We use bitmap as keyword filter. So we need a bitmap join index for hot keywords. attribute. Each item in the attribute has a bitmap to identify the join relation between fact table and specified dimension table on current keyword. High cardinality rowid for direct access instead of costly full table scan. Compared with B+-tree index, join relations between multiple tables and can reduce some costly join operations. 
Index is tradeoff between space and performance. [10] proposed bitmap join index data access and join without indexes. Bitmap join index size can be accurately com-puted with cardinality and rows in fact table, and selectivity in each bitmap is accurate for evaluating data access cost. 
For in-memory analytical processing, original data volume is big, and RAM is ex-pensive for high value data. So a light-weight bitmap join index is necessary for glob-al frequent keywords instead of frequent attributes to balance both the space efficien-cy and performance. 3.1 Identify Hot Keywords Keywords are extracted from WHERE clauses except equal join clauses no matter they are from fact table, dimension tables or which attributes they belong. Keywords are organized with uniform name, for example:  X   X   X   X  The principle of uniform keyword name is: table name(in short)_attribute name_operator(equal can be neglected)_key(between operator has another key). frequency model based on frequency list and selectivity. reduces as time window get old, and the latest windows have higher effectiveness for varies from 0 to 1, (2-s ) generates a selectivity weight(e.g. 5% for 1.95), so weighted frequency Fw can represents frequency, recency and selectivity. We use TOP K me-table, we can get maximal keyword candidate size K=8* m / n . 3.2 Organize Keyword Oriented Bitmap Join Index keyword maps in fact table. We need a mechanism to store keyword and bitmap in-formation, when and how to create bitmaps for specified keywords. 
As keywords are not extracted from same attribute but extracted from the whole database only if they are frequently accessed in recent time and the selectivity is low enough. We use key/bitmap store for keyword oriented bitmap join index as the fol-lowing example, in which we use uniform keyword name as key. Key/bitmap store can employ a hash table structure or pluggable key/value store such as Mem-map by keyword. 
Keyword weighted frequency counters decide K candidate keywords. Bitmaps are created by join operation, we can attach ke yword bitmap creating procedure to similar all candidate keyword bitmaps in a batched processing. 3.3 Keyword Filtering for Analytical Processing query and probe in key/bitmap store to find matched bitmaps. Figure 1 shows how to generate the keyword filter. 
Keywords  X  X _region_AMERICA X ,  X  X _region_AMERICA X ,  X  X _mfgr_MFGR#1 X  and  X  X _mfgr_MFGR#2 X  are extracted from query and first three keywords have bit maps. Because  X  X _mfgr_MFGR#1 X  and  X  X _mfgr_MFGR#2 X  are connected with OR, and only one keyword has bitmap, so we discard keyword  X  X _mfgr_MFGR#1 X  for global keyword bitmap filter. We combine keyword bitmaps of  X  X _region_AMERICA X  and  X  X _region_AMERICA X  with bit-wise AND for global keyword filter. 
We transform traditional query tree in database into two level filtering. First of all, we divide query clauses into different processes:  X   X   X   X   X  X _mfgr_MFGR#1 X  and  X  X _mfgr_MFGR#2 X  with the following SQL command: 
For grouping attribute  X  X _nation X , we generate a group vector with same rows as customer table, in which  X  X _nation X  value with  X  X MERICA X  in  X  X _region X  attribute is so we directly project d_year attribute as group vector. Data warehouse commonly employs surrogate key[13] as primary key of dimension which is a sequential number rows as dimension table, the bitmap index or group vector can be mapped to surrogate key. So foreign key in fact table can be directly mapped to correlated position in pre-dicate bitmap filter and group vector[14,15]. group vectors. positional scan on big fact table with generated keyword filter to skip records with  X 0 X  positions; in step  X  , foreign key 1 in lo_partkey attr ibute locates 1st position in pre-dicate bitmap filter; if the correlated bit is 1 then get lo_orderdate attribute value 1 to locate 1st item in group vector d_year in step  X  and get lo_custkey attribute value 2 to locate 2nd item in group vector c_nation in step  X  ; otherwise, skip current record and go to step  X  ; in step  X  and  X  , correlated items 1997 and nation key 1 are ex-lo_suppcost are extracted and executed lo_revenue-lo_suppcost as result measure value. Finally, query result with hash keys and measure value is pushed into aggregate hash table for aggregation. 3.4 Multicore Parallel Processing scan on fact table with predicate bitmap filters, and it is easy to be divided into paral-process can also be converted to parallel processing with horizontal partitions. Figure 3 illustrates the multicore parallel processing for two level filtering. tion, locates  X 1 X  position on fact table, executes predicate bitmap filtering and aggre-sets and make final aggregate. In the parallel processing, predicate bitmap filters and table during processing isolated from other cores. After parallel processing, the global merging is efficient because the analytical results are very small aggregate datasets. 3.5 System Storage Model In our prototype system, we divide tables into two kinds of storage models: dimension complex predicates, we adopt pluggable database engine for dimension tables such as PostgreSQL or MonetDB; fact table is very big with simple data type on foreign key columns and measure columns, we use an array based column store for efficiency on plex query as keyword search style processing. If RAM capacity is much smaller than SSD capacity, for example Oracle Exadata X3 Database In-Memory Machine has 256GB RAM and 1.6TB flash memory, we can RAM resident, so we can perform efficient keyword bitmap combination with bit-wise operators, high selective positional scan on flash memory, low latency predicate only processing related vectors and hot data index(keyword bitmaps) need to be RAM with efficient positional scan, dimension tables can be RAM resident or flash memory and low cost. 3.6 Update for Keyword Oriented Bitmap Join Index We always maintain TOP K hot keywords in key/bitmap store, if existed keywords When keywords are non-frequent, they can be removed permanently. When fact table append bitmaps on existed bitmaps. Our experiments are conducted on a HP ProLiant BL460c G7 server with two Intel X  Xeon X  Processor E5645 (6-core, 12M Cache, 2.40 GHz), 48GB memory and 300G 10Krpm 2.5 X  SAS hard disk. The OS version is ubuntu-11.10-server-amd64. We use star schema benchmark(SSB) dataset with SF=100 with standard SSB data generator, the row number of fact table is 600,000,000, and four dimension tables only takes up 0.84% in total size. 
We store dimension tables in MonetDB for generating predicate bitmap filters and group vectors, we also use MonetDB as performance benchmark because MonetDB is an in-memory column-store analytical database which is well known for its excellent performance. We load fact table into array oriented column store to provide positional scan according to keyword bitmap filter. Ke yword bitmap join index uses hash table for key/bitmap pairs storage and access. 4.1 Overall Performance We divide the whole processing into two large parts: (1) Bitmap combination. In this phase, we analyze SQL statement and extract key-(2) Processing. We use multicore parallel processing for maximal performance. Se-Figure 5 shows the processing time of the two phases. We can see that bitmap combi-nation cost is very close to each other. Multicore parallel bitmap combination is very efficient. Average time of processing one bitmap is about 143ms. 
Different queries have different complexity for the second level filtering and ag-filtering and the following aggregation like Q2.1, Q3.1 and Q4.1. For other low selec-bitmap combination time for better performance by GPGPU or Coprocessor with more cores and higher parallel processing power. 
We also measure performance without keyword bitmaps. If we have no available 
We also use MonetDB as benchmark database with same dataset. Each query is continuously performed 5 times to select the minimal execution time as in-memory filtering costs average 30.4% query time as MonetDB, and costs 66.3% time of Mo-netDB without keyword bitmaps. Keyword bitmaps costs 45.8% time of one level filtering process. 4.2 Performance Analysis Table 1 shows the detailed processing information. Bitmap combination is almost linear time, and we can predict bitmap combination time according to bitmap num-bers. Column of  X  X wo level filtering X  equals to column  X  X itmap combination X  plus column  X  X rocessing X , column  X  X ne level filtering X  denotes processing without key-word bitmaps, column  X  X electivity X  denotes total selectivity by all keywords, and column  X  X mprovement ratio X  is calculated by  X (one level filtering-two level filtering)/ two level filtering X  to measure the improvement for two level filtering compared with process without keyword bitmaps. 
Bitmap combination time is 30.27% in total processing time. We can shorten this time by using less selective keywords instead of using all available keywords, we can also improve bit-wise operation performance by storing keyword bitmap in GPGPU or Coprocessor(e.g., Intel X  Xeon Phi X  coprocessor 5110P) for even shorter time. If we compress bitmap with selectivity of 1/100, using SHORT INT(according to max-imal offset value) vector to record non-zero positions, we can compress bitmap size to 16% of original size(1%*N*16-bit/N-bit). With compression, we can store more keyword bitmaps in high performance coprocessor. 
The minimal performance improvement is 18.68% in Q3.1 with selectivity 3.4%, and the maximal performance improvement is 646.85% in Q2.3 with selectivity of 0.02%. The general rule is that keyword filtering improves more with lower selectivi-ty query. Average improvement for keyword filtering is 118.37%. words. Creating bitmap join index for these hot keywords can dramatically reduce join cost for queries with same keywords. We first set up keyword bitmap join index mechanism to manage bitmap join index for global keywords to improve index sto-and predicate bitmap filtering to improve query processing efficiency. Keyword bit-map filtering improves efficiency of big fact table scan, and can be also used as mem-ory resident index while big fact table can be stored in large flash memory to reduce storage cost. Acknowledgements. This work is supported by the Fundamental Research Funds for No.12XNQ072 and project of  X  X ey Research of Big Data In-memory Analytical No.61170013), Heilongjiang technical project of GC12A307, the Program for  X  X ew Century Excellent Talents X  and the RUC-NEC joint project on In-memory Column Store Techniques. 
