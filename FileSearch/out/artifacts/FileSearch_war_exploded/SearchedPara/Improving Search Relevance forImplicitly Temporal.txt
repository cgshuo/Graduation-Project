 Categories and Subject Descriptors: H.3.3 Information Storage and Retrieval: Information Search and Retrieval General Terms: Algorithms, Experimentation Keywords: temporal queries, query log analysis, web search
Many web search queries have implicit intents associated with them that, if detected and used effectively, can be used to improve search quality. For example, a user who enters the query  X  X oyota camry X  may wish to find the official web page for the car, reviews about the car, or the location of the closest Toyota dealership. However, since the user only en-tered a couple of keywords, it may be difficult to accurately determine which of these implicit intents the user actually meant. Given such an ambiguous query, a search engine must use personalization, click information, query log ana l-ysis, and other means for determining implicit intent.
Rather than solving the general problem of automatically determining user intent, we focus on queries that have a tem-porally dependent intent. Temporally dependent queries ar e queries for which the best search results change with time. Simple examples include  X  X ew years X  and  X  X residential elec -tions X , which are events that recur over time. The search results for these queries should reflect the freshest, most current results. A slightly more complex example is the query  X  X urkey X . For this query, it may be useful to return turkey recipes or cooking instructions around the Thanks-giving holiday and travel information during peak vacation times. In all of our examples thus far, the events have oc-curred with (mostly) predictable periodicity. However, fo r queries such as  X  X ldest person alive X , the best result chang es unpredictably, making it difficult for search engines to con-sistently return correct results. Therefore, temporally d e-pendent queries come in many different forms and pose many challenges to search engines.

In this paper, we investigate a subset of temporal queries that we call implicitly year qualified queries. A year quali-fied query is a query that contains a year. An implicitly year qualified query is a query that does not actually contain a year, but yet the user may have implicitly formulated the query with a specific year in mind. An example implicitly year qualified query is  X  X iss universe X . It is plausible that the user actually meant  X  X iss universe 2008 X ,  X  X iss univers e 2007 X , or maybe even X  X iss universe 1990 X , yet did not actu-ally qualify the query with a year. Other examples include  X  X lympics X ,  X  X oyota camry X ,  X  X aster X , and the names of con-ferences, such as  X  X IGMOD X  or  X  X DD X .

Implicitly year qualified queries are particularly interes t-ing and challenging from a search point of view. Our analysis shows that more than 7% of queries belong to this category. However, correctly handling this type of query is not trivia l. As anecdotal evidence, as of this writing, only one of the three major search engines ranks the SIGIR 2009 web page higher than the SIGIR 2008 web page for the query X  X IGIR X , despite the fact that most people searching for the SIGIR conference are interested in the upcoming event, rather tha n the previous event. Therefore, in order to improve search quality for temporal queries, a search engine must be able to detect that certain queries have an implicit temporal in-tent and use this information to improve the search results. These are precisely the types of issues that we tackle in the remainder of this paper.
We propose a simple, yet efficient algorithm for mining implicitly year qualified queries. The algorithm relies onl y on having access to a query log with frequency information. The approach does not rely on user, click, or session data. Our work differs from previous work on temporal query min-ing (e.g., [1, 2, 3, 4]), because we mine temporal patterns directly from query logs and do not make use of query fre-quency information or document timestamps.

The primary idea behind our proposed approach is to see how often a base query, such as  X  X lympics X  is year quali-fied in the query log. If the base query is commonly year qualified, then we declare that it is implicitly year quali-fied. For the olympics case, it is very likely that the queries  X  X lympics 2008 X ,  X 2004 olympics X , etc. occur with relative ly high frequency in the log, which allows us to determine that  X  X lympics X  X s implicitly year qualified. Thus, the foundati ons of our algorithm are built upon the following assumptions: 1) implicitly year qualified queries are strongly associate d with several different years, and 2) implicitly year qualifie d queries are associated with years more than they are asso-ciated with non-years. We now describe how these two as-sumptions can be turned into an effective mining algorithm.
Perhaps one of the most important properties of implic-itly year qualified queries is how strongly they are associat ed with a given year. This value, which we call the year quali-fied weight, is formally defined as: Figure 1: Implicit year distribution mined for the query  X  X ord mustang X . where #( q.y ) denotes the number of times that the base query q is post-qualified with the year y in the query log. Similarly, #( y.q ) is the number of times that q is pre-qualified with the year y . Figure 1 shows the weight distribution for the query X  X ord mustang X , a car model that was once popular in the 1960s and now again popular in recent years.
Given these weights, we use the following methodology to automatically mine implicitly year qualified queries. Give n a query q , we first compute w ( q, y ) for all plausible years. We then use the following function to determine if a query is implicitly year qualified: which simply states that a query is implicitly year qualified if it is qualified by at least two unique years. We set the threshold at 2 because we are interested in temporally re-curring events. It is possible to mine one-time events by lowering the threshold to 1, but this may result in spurious detections.

Even though a query is identified as implicitly year qual-ified does not necessarily mean that the query should al-ways be treated as temporal in nature. Consider the query  X  X hi X , which happens to be the name of a popular human-computer interaction conference. This query is clearly tem -poral, and indeed, our algorithm detects the query as being implicitly year qualified. However,  X  X hi X  is a very common term that is often qualified in many different ways, including  X  X hi squared X  (statistical test),  X  X hi chis X  (restaurant) , and  X  X hi omega X  (sorority). In fact, these other qualifications are much more common than the temporal ones. We call this phenomenon temporal ambiguity . We quantify temporal am-biguity as follows: where the sums P x #( q.x ) and P x #( x.q ) go over all pre-and post-qualifications for the query q . It should be easy to see that if the query is always qualified with a year then  X  ( q ) = 1. Although we call this measure temporal ambigu-ity, it may also be interpreted as a confidence value that the query has implicit temporal intent.
We can use information mined to improve search rele-vance for implicitly temporal queries. We propose explicit ly adjusting the score of document d in response to query q Table 1: Baseline and temporal reordering results. A  X  represents a statistically significant ( p &lt; 0 . 05 ) difference versus the baseline. according to the years found in the document. Given an im-plicitly year qualified query q , we first weight the qualified years associated with q as follows: where N ( y ;  X ,  X  2 ) is a normal distribution with mean  X  and variance  X  2 ,  X  ( q ) is the temporal ambiguity (Equation 2), and w ( q, y ) is the number of times that query q is qualified with year y (Equation 1).

Given a ranking function S ( q, d ) that produces a score for documents d in response to query q , we can use the z ( q, y ) weights to temporally bias S ( q, d ) towards q  X  X  implicit temporal intent as follows: where S  X  ( q, d ) is the temporally biased score, S ( q, d ) is the original score of document d with respect to query q , f  X  d is the set of document fields (e.g., title, anchor text, body),  X  is the weight associated with field f , and y  X  f denotes the set of years that occur in field f in document d . Documents are then reordered according to S  X  ( q, d ) to produce the final temporally-biased ranking. In our experiments,  X  = 2008,  X  assigned weights (  X  f ) of 2.0, 2.0, 0.5, and 0.5, respectively.
Our evaluation involves a set of 670 web queries. We compare our temporal reordering approach to the ranking of a commercial search engine. Editors judged the relevance of each document retrieved for each query as either Perfect, Excellent, Good, Fair, or Bad.

The results are shown in Table 1. The first thing to no-tice is that DCG@5 decreases monotonically as the queries become less temporally ambiguous. This suggests that web search engines tend to perform substantially worse on tem-poral queries, highlighting the need for special temporal query handling. The results also show that our proposed temporal result set reordering tends to improve temporally unambiguous queries more than temporally ambiguous querie s.
