 Xinghuo Zeng  X  Jian Pei  X  Ke Wang  X  Jinyan Li Abstract While frequent pattern mining is fundamental for many data mining tasks, mining maximal frequent patterns efficiently is important in both theory and applications of frequent pattern mining. The fundamental challenge is how to search a large space of item combinations. Most of the existing methods search an enumeration tree of item combinations in a depth-first manner. In this paper, we develop a new technique for more efficient max-pattern mining. Our method is pattern-aware: it uses the patterns already found to schedule its future search so that many search subspaces can be pruned. We present efficient tech-niques to implement the new approach. As indicated by a systematic empirical study using the benchmark data sets, our new approach outperforms the currently fastest max-pattern mining algorithms FPMax* and LCM2 clearly. The source code and the executable code (on both Windows and Linux platforms) are publicly available at http://www.cs.sfu.ca/~jpei/ Software/PADS.zip .
 Keywords Max-pattern mining  X  Frequent pattern mining  X  Pattern-aware search 1 Introduction Let I be a set of items. An itemset X is a subset of I .A transaction is a tuple ( tid , Y ) where tid is a unique transaction-id and Y is an itemset. Transaction ( tid , Y ) is said to contain itemset X if X  X  Y .Foragiven transaction database TDB which consists of a set of transactions, the support of an itemset X is the number of transactions containing X ,that is, sup ( X ) =|{ ( tid , Y )  X  TDB | X  X  Y }| .Foragiven minimum support threshold min_sup, an itemset X is a frequent pattern if sup ( X )  X  min_sup. Given a transaction database and a minimum support threshold, the problem of frequent pattern mining [ 4 ]istofindthe complete set of frequent patterns.

For example, consider the transaction database TDB in Fig. 1 . For the sake of simplicity, we write an itemset as a string of items. For example, itemset { a , c , d } is written as acd .Let the support threshold min_sup = 2. Since abcd is contained in transactions 20, 30 and 40, sup ( abcd ) = 3and abcd is a frequent pattern.

Frequent pattern mining is fundamental for many data mining tasks, such as mining partial periodicity [ 16 ], iceberg-cube computation [ 8 ], associative classification [ 19 ], and subspace clustering [ 3 ]. It is also important in many applications, such as market analysis and network intrusion detection.

Frequent patterns have the well-known monotonic Apriori property [ 4 ]: if X is frequent, then every nonempty subset of X is also frequent. For an itemset X , | X | is called the length of X . According to the Apriori property, a long frequent pattern of length n leads to ( 2 n  X  2 ) shor-ter non-empty frequent patterns. For example, in Fig. 1 , if min_sup = 2, abcd is a frequent pattern. All subsets of abcd including a , b , c , d , ab ,..., bcd are also frequent patterns. To avoid mining all frequent patterns, we can mine only those max-patterns [ 7 ]. An itemset X is a maximal frequent pattern or a max-pattern for short if X is frequent and every proper superset of X is infrequent. In Fig. 1 , when min_sup = 2, the max-patterns are abcd , bcde and df . The problem of mining maximal frequent patterns (or mining max-patterns for short) is to find the complete set of max-patterns.

Mining max-patterns efficiently is important in both theory and applications of frequent pattern mining. On the theoretical side, the max-patterns serve as the border between the frequent patterns and the infrequent ones. With the set of max-patterns, whether an itemset is frequent or not can be determined quickly using the Apriori property. On the application side, max-patterns are used in a few interesting and challenging data mining tasks. For example, using max-patterns, we can find emerging patterns [ 12 ] which are patterns frequent in the positive samples and infrequent in the negative samples. Emerging patterns can be used to construct effective classifiers [ 18 ]. As another example, using max-patterns with respect to a series of support thresholds, we can summarize and approximate the support information of all frequent patterns [ 24 ].

More broadly, mining max-patterns is also related to many data mining problems, inclu-ding mining generators [ 20 ], mining borderline description [ 13 ], mining maximal sequential patterns [ 21 ], web log mining [ 28 ], condensed representations of constrained frequent pat-terns [ 9 ], and summarizing association rules [ 23 ].

The fundamental challenge of mining max-patterns is how to search a large space of itemsets and identify max-patterns. Most of the existing methods search an enumeration tree of itemsets in a depth-first manner. The search is often arranged according to some heuristics such as the frequencies of items. [ 2 ] provides a good survey.

One important and interesting issue overlooked in the previous studies is how the max-patterns already found can help to plan the search of new max-patterns. In this paper, we develop a novel pattern-aware approach which dynamically schedules the search based on the max-patterns already found. A distinct advantage is that many branches in the dynamic scheduled search space can be pruned sharply. We also present efficient techniques to imple-ment the new approach. As indicated by a systematic empirical study using the benchmark data sets, our new approach outperforms the currently fastest max-pattern mining algorithms FPMax* [ 15 ]andLCM2[ 30 ] in a clear margin. 2 Search space and search strategies Due to the Apriori property, only frequent items can appear in a max-pattern. Thus, the search space of max-pattern mining is the lattice of itemsets consisting of only frequent items, which is called the itemset lattice . Figure 2 a shows the itemset lattice of the transaction database in Fig. 1 ,where I ={ a , b , c , d , e , f } , min_sup = 2, and every item is frequent.
Essentially, the itemset lattice can be searched in an either breadth-first or depth-first manner. Consider the transaction database TDB in Fig. 1 . In a breadth-first search, we start with finding the frequent items, i.e., a , b , c , d , e and f . Then, we combine the frequent items to generate length-2 itemsets, i.e., ab , ac ,..., ef . The supports of those length-2 candidates are counted, and the length-2 frequent patterns are found. A length-3 pattern X is gener-ated as a candidate only if every length-2 subset of X is frequent. For example, abc is generated as a length-3 candidate since ab , ac and bc are frequent, while def should not abcde abcdf abcef abdef acdef bcdef abc abd abe abf acd ace acf ...
 be generated as a length-3 candidate since ef is infrequent. The search continues until all candidates of the current iteration are infrequent, or no longer candidates can be generated. A few methods such as MaxMiner [ 7 ] search an itemset lattice in a breadth-first manner. As indicated by some previous studies such as [ 2 ], the breadth-first search methods may have to search many patterns that are not maximal or even infrequent.
 To reduce the number of patterns searched, some recently developed methods such as DepthProject [ 1 ], Mafia [ 11 ], GenMax [ 14 ], FPMax* [ 15 ]andLCM2[ 30 ] conduct depth-first searches. A global order called the enumeration order on all frequent items can be used to enumerate all itemsets systematically in a set enumeration tree [ 27 ]. Figure 2 bshowsa set enumeration tree of the lattice in Fig. 2 a where the lexicographic order of items is used as the enumeration order. In the subtree of a , we search for patterns having item a .Inthe subtree of b , we search for patterns having item b but no item a . The search space of other subtrees can be specified similarly.

Depth-first searches can be implemented efficiently using projected databases. To search patterns in the subtree of a , we only need to check the transactions containing a ,whichis called the a-projected database . Similarly, to search patterns in the subtree of ab , we only need to check the ab -projected database, which is a subset of the a -projected database. Since ab is a child of a in the set-enumeration tree, the depth-first search takes a divide-and-conquer strategy.
 A critical pruning technique called head-and-tail pruning was firstly proposed in Max-Miner, and was adopted by DepthProject, Mafia, GenMax and FPMax*. Consider Fig. 1 again and let min_sup = 2. Suppose we use the lexicographic order of items in a depth-first search of max-patterns. The a -projected database consists of transactions 20, 30 and 40. Items b , c and d are frequent in the a -projected database and form the tail of a , denoted by Ta i l ( a ) = bcd . According to the Apriori property, any pattern X containing a can have only items from Tail ( a ) or a itself, i.e., X  X  a  X  Ta i l ( a ) = abcd . Before we unfold the subtree of a , we can first check sup ( abcd ) .Since abcd is frequent and no other max-patterns found later will contain a (due to the divide-and-conquer partitioning in the set-enumeration tree), abcd is a max-pattern. Any frequent pattern in the subtree of a must be a subset of abcd and thus cannot be a max-pattern. We do not need to search the subtree. Similarly, we can find max-pattern bcde from the subtree of b . Now, let us consider c .Tail ( c ) = de which means any pattern containing c but no a or b must be a subset of c  X  Ta i l ( c ) = cde .Since cde is a subset of bcde , a max-pattern found before, the subtree of c does contain any max-pattern and thus can be pruned immediately.

In the head-and-tail pruning, finding long max-patterns early may prune more subtrees. A heuristic called dynamically ordering of frequent items was firstly proposed in MaxMiner, and was adopted by DepthProject, Mafia, GenMax and FPMax*. When we search the subtree of itemset X , we find the set of items that are frequent in the X -projected database. We sort those frequent items in the support ascending order to construct the subtree of X . The rationale is that a set enumeration tree constructed using such an order may have a small left subtree, and may lead to max-patterns early.

The previous studies such as [ 2 ] suggest that depth-first searches often have a better performance than breadth-first searches in mining max-patterns. 3 Pattern-aware dynamic search Consider TDB in Fig. 1 again. From the a -projected database, we can find max-pattern abcd . Now, let us consider how to search the subtree of b .Tail ( b ) = cde .Since b  X  Ta i l ( b )  X  abcd , we need to search the subtree of b . If we use the order of c  X  d  X  e to enumerate patterns containing b but no a , as shown in
Given abcd is a max-pattern found before, one critical observation here is that e is the only item in b  X  Ta i l ( b ) but not in abcd . Any pattern in the subtree of b not containing item e is a subset of max-pattern abcd and thus cannot be a max-pattern. In other words, in the subtree, we only need to search the patterns containing e . Thus, in the subtree of b ,ifwe sort the items such that e precedes c and d , as shown in Fig. 3 b, we only need to search the subtree of e , and the subtrees of c and d can be pruned immediately. In fact, the ordering between c and d does not matter.

The essential idea of pattern-aware dynamic search is simple. When a subtree is searched, based on the max-patterns found before, we construct the subtree in a way that the potential max-patterns are scheduled into some branches that have to be searched, and the patterns that are subsets of max-patterns found before are organized into branches that can be pruned. Let us generalize the idea technically. Suppose we want to search the subtree of an itemset X .Let Y  X  X be a max-pattern found before. Then, we can schedule the search of the subtree of X as follows. We partition Tail ( X ) into two subsets: T 1 = Ta i l ( X )  X  Y is the set of items that do not appear in Y ;and T 2 = Ta i l ( X )  X  Y is the set of items that appear in Y .Any max-pattern in the subtree of X must contain at least one item from T 1 .Thus,weorderthe items such that the items in T 1 precede the items in T 2 .

Using this order, we only need to search the children of X that are in T 1 . The children of X in T 2 and their subtrees can be pruned immediately. The above process is called the pattern-aware dynamic search (PADS for short), and an order where items in T 1 precede items in T 2 is called a PADS order with respect to Y . Max-pattern Y is called the key pattern of the search scheduling.
 We prove the correctness of the above scheduling.
 Theorem 1 (Correctness) Let X be a frequent pattern, and Y be a max-pattern such that X  X  Y . If a PADS order with respect to Y is used to construct the set enumeration subtree of X , then for any item z  X  Ta i l ( X )  X  Y and any pattern Z in the subtree of X  X  X  z } ,Z  X  Y. Proof As discussed before, Tail ( X  X  X  z } )  X  Ta i l ( X ) . Since a PADS order with respect to Y is used, z is behind all items in Tail ( X )  X  Y in the order. That is, Tail ( X  X  X  z } )  X  Y .Since z  X  Ta i l ( X )  X  Y and X  X  Y ,wehave Z  X  ( X  X  X  z } X  Ta i l ( X  X  X  z } ))  X  Y .
The pattern-aware dynamic search technique is different from the technique of dynami-cally ordering frequent items developed in the previous studies, which uses the item frequency ascending order to construct a set enumeration subtree. Dynamically ordering frequent items is a heuristic method. Due to the correlations among frequent items, there exist counter examples where sorting frequent items in support ascending order does not help pruning. In contrast, the effect of pattern-aware dynamic search is determined once the key pattern is chosen. To search the subtree of a pattern X , once there exists at least one key pattern Y  X  X found before, a PADS order based on Y can be used to prune some children of X by pattern-aware dynamic search. It is not heuristic. 4 Choosing a good PADS order To the best our knowledge, LCM2 [ 30 ] is the only existing method adopting a similar idea in mining max-patterns. What is the critical difference between our method and LCM2?
For a pattern X , if there are more than one pattern Y such that Y  X  X , then each pattern can serve as a key pattern, and thus multiple PADS orders are feasible. Now, the problem becomes how to select a good PADS order.
 In LCM2, an arbitrary item e in the tail of Y is picked, and the max-patterns containing Y  X  X  e } are mined. Then, the longest max-pattern containing Y  X  X  e } is chosen as the key pattern, and the PADS order is determined accordingly. However, the method may not lead to good performance all the time.

First, issuing a sub-routine to find all max-patterns containing Y  X  X  e } may lead to searching a large part of the subtree of Y  X  X  e } . Those max-patterns are not necessarily good since e is chosen arbitrarily.

Instead of searching many new max-patterns containing Y  X  X  e } , PADS reuses the max-patterns already found as much as possible to find a good key pattern. Therefore, we avoid the cost of searching many new max-patterns in order to scheduling the future search.
Second, the longest max-pattern may not be always good. For example, suppose the current pattern Y = fgh ,tail ( Y ) = ijk , and item i is chosen. Furthermore, suppose the longest max-pattern found containing Y  X  X  i }= fghi is X 1 = abcd f ghi . It in fact does not provide any pruning power in the scheduling. Suppose another max-pattern X 2 = efghik is found before. Then, X 2 provides a good pruning power in the scheduling: we only need to search the Y  X  X  j } subtree.

Instead of choosing key patterns based on length, PADS measures the pruning powers of the max-patterns already found, and selects key patterns accordingly.

As analyzed, the effect of the pattern-aware dynamic search technique depends on the choice of key patterns. In this section, we discuss how to choose a good key pattern.
Let us consider choosing a key pattern for an itemset X .If Y  X  X is chosen, as indicated by Theorem 1 , all children of X in Tail ( X )  X  Y can be pruned. Therefore, the more items in Ta i l ( X ) appear in the key pattern, the more children can be pruned. Thus, we can choose a max-pattern Y  X  X as the key pattern such that Y has the largest overlap with Tail ( X ) .Thatis,
Please note that Y contains at least one item that is not in Tail ( X ) . Otherwise, X  X  Ta i l ( X ) is a subset of Y , and thus X is pruned by the head and tail pruning technique. In the example showninFig. 3 b, pattern abcd is a perfect choice for b since we only need to search one child of b .

We choose key patterns for itemset X in two steps. 4.1 Step 1 In the first step, we check all max-patterns Y 1 found before that are supersets of X and candidate. This step can be implemented as a byproduct of the head-and-tail pruning. For each itemset X , to apply the head-and-tail pruning, we have to check X  X  Ta i l ( X ) against the max-patterns found so far. We also collect the information of | Y 1  X  Ta i l ( X ) | at the same time. Thus, the cost of computing the candidate in this step is very little.

There can be many (millions or more) max-patterns found so far in a large database. To speed up checking whether X is a subset of some max-patterns found before, we adopt the progressive focusing search strategy developed in GenMax. When we search an itemset X and its subtree, any patterns found in the subtree must be a superset of X .Thus,wecan maintain the set of max-patterns found so far that are supersets of X . Any patterns found in thesubtreeof X only need to be checked against those max-patterns.

The technique can be applied recursively. For itemset X  X  X  y } that is a child of X in the set enumeration tree, the max-patterns containing X  X  X  y } is a subset of those containing X . Thus, the maintenance of the matching max-patterns is progressive. 4.2 Step 2 In some situations, max-patterns found so far may not have heavy overlaps with the tail of X . Thus, as the second step, we also find in the projected database of X  X  X  parent one max-pattern Y such that Y 2  X  X and Y 2  X  X  X  Ta i l ( X ) . This can be done quickly as follows. According to Since x 1 is frequent in the X -projected database, X  X  X  x 1 } must be frequent. We first assign Y 2 = X  X  X  x 1 } and check the supports of Y 2  X  X  x 2 } , Y 2  X  X  x 3 } ,..., Y 2  X  X  x n } . If none of them is frequent, then Y 2 is the candidate key pattern. Otherwise, let i 1 be the smallest index x + 1 , x i 1 + 2 ,..., x n to expand Y 2 until it cannot be expanded longer. It is easy to see that the pattern Y 2 found as such is a max-pattern if it is not a subset of a max-pattern found before. By the second step, we can find at least one max-pattern that can be used as a key pattern. We compare the two key pattern candidates found from the two steps, and pick the one Y having the better pruning power as the key pattern. The PADS order is made accordingly.
In implementation, we use FP-trees [ 17 ] as the core data structure to store transactions and projected databases. We also integrate the advantages in the existing methods. Particularly, we adopt the pattern expansion technique which was firstly proposed in CLOSET [ 26 ]and CHARM [ 32 ] in the context of frequent closed itemset mining, and later used by Mafia and GenMax in max-pattern mining. Consider the situation where every transaction containing itemset X also contains item y  X  Ta i l ( X ) . Then, it is impossible that a max-pattern contains X but does not contain y . Therefore, we do not need to search any subtree of X where y does not appear. In other words, instead of searching the subtree of X , we can directly search the subtree of X  X  X  y } .
 The algorithm PADS (for pattern-aware dynamic search) is summarized in Fig. 4 . Moreover, we make the source code and the executable code (on both Windows and Linux platforms) publicly available at http://www.cs.sfu.ca/~jpei/Software/PADS.zip . Complexity analysis As indicated in [ 31 ], the problem of mining max-patterns is NP-hard. Therefore, all max-pattern mining algorithms developed so far unfortunately have the exponential complexity.
Our PADS method shares the same depth-first search framework with the state-of-the-art, depth-first search methods such as FPMax* and LCM2. To analytically understand the efficiency of the PADS method, the critical issue is to analyze the cost of implementing the pattern-aware dynamic search. Particularly, the cost of finding key patterns in PADS is important.

First of all, let us consider the complexity of finding the first max-pattern. Algorithm PADS works as any depth-first search max-pattern mining algorithm. It starts with the first frequent item x 1 in the alphabetical order, 1 and sets pattern Y = x 1 . Recursively, a projected database TDB Y is formed and the frequent items in TDB Y are found. The first frequent item in the alphabetical order in TDB Y ,say x , is used to expand Y to a longer pattern Y  X  X  x } .The recursion continues until no frequent item can be found in the projected database. Clearly, we have the following result.
 Lemma 1 The time complexity of finding the first max-pattern is O ( | TDB | X  l ) where l is the length of the longest transaction in TDB.
 Proof Trivially, a projected database can be formed and the frequent items in the projected database can be found in time O ( | TDB | ) .Thereareatmost l recursion steps is needed to find the first max-pattern, since any frequent pattern cannot be longer than the length of the longest transaction. Thus, we have the lemma.
 In implementation, PADS adopts pseudo-projection [ 25 ] to find the first max pattern. In pseudo projection, no physical projected databases are constructed. Instead, PADS only manipulates pointers to construct  X  X irtual X  projected database.

As analyzed before, for an itemset X , algorithm PADS chooses a key pattern for X in two steps. In the first step, PADS finds a max-pattern Y 1 found before which maximizes the overlap between Y 1 and Tail ( X ) . Clearly, the complexity of this step is linear with respect to the number of max-patterns found so far that contain X . In the second step, PADS finds a max-pattern containing X by considering the items in since a max-pattern cannot be longer than l , the length of the min_sup-th longest transaction in the X -projected database, the cost of this step is also linear with respect to l .Intheworst case where min_sup = 1, l is the length of the longest transaction in the X -projected database. Last, the cost in this step is linear with respect to the number of transactions in the X -projected database, since PADS needs to scan the database iteratively to count the support of items in Ta i l ( X ) . In summary, we have the following claim about the cost in the second step. where l is the length of the longest transaction in the X -projected database.

Taking both the cost of the two steps in finding key patterns together, we have the following result about the cost of finding a key pattern.
 Theorem 2 For an itemset X , the cost of finding a key pattern for X in PADS is O ( m + |
TDB X | X  min {| Ta i l ( X ) | , l } ) , where m is the number of max-patterns containing X and l is the length of the longest transaction in the X -projected database.

How can we compare the cost of finding key patterns against the benefit of pruning sub-trees in the set-enumeration search space using the pattern-aware dynamic search? One important observation is that the cost of determining whether a frequent pattern X is maximal is O ( m ) ,where m is the number of max-patterns containing X . Therefore, the cost of finding a Following with the results in [ 31 ], the cost of finding all max-patterns in a sub-tree rooted at X in the set-enumeration search space is of complexity O ( 2 | Ta i l ( X ) | ) . Therefore, once a pruning case happens in PADS, we save the search cost of O ( 2 | Ta i l ( X ) | ) using a key pattern searching cost O ( | TDB X | X  min {| Ta i l ( X ) | , l } ) .

Both PADS and LCM2 use pattern-aware dynamic search. Then, what is the difference between their efficiency? For an itemset X , LCM2 chooses an arbitrary item x  X  Ta i l ( X ) and use the longest max-pattern containing X  X  X  x } as the key pattern. The cost of finding key pattern finding in PADS. However, the effectiveness of the key pattern chosen by LCM2 may not be always better than that of PADS since PADS considers all max-patterns found so far (step 1) and also one max-pattern of good coverage in Tail ( X ) (step 2). Our experimental results clearly show that PADS outperforms LCM2 in both the number of patterns checked and the number of projected databases generated. 5 Empirical evaluation We conducted an extensive performance study to evaluate the effectiveness of the pattern-aware dynamic search and the efficiency of our PADS algorithm. Here we report the expe-rimental results on five real data sets. Those five real data sets were prepared by Roberto Bayardo from the UCI datasets and PUMSB. They have been used extensively in the previous studies as the benchmark data sets. Some characteristics of the five data sets are shown in Ta b l e 1 . We downloaded the data sets from http://fimi.cs.helsinki.fi/data/ . All the experiments were conducted on a PC computer running the Microsoft Windows XP SP2 Professional Edition operating system, with a 3 . 0 GHz Pentium 4 CPU, 1 . 0GB main memory, and a 160 GB hard disk. The programs were implemented in C/C++ using Microsoft Visual Studio. NET 2003.
We compare our method with FPMax* and LCM2, the currently fastest max-pattern mining methods according to the extensive empirical study reported in the Frequent Itemset Mining Implementations Repository website ( http://fimi.cs.helsinki.fi/ ). We used the code of the two algorithms published by the authors. It should be mentioned that LCM2 has execution problems under some circumstances. On the Pumsb data set with min_sup lower than 40%, on the Pumsb* data set with min_sup lower than 6%, and on the Connect data set with min_sup lower than 0 . 2%, LCM2 gives segmentation faults and cannot finish properly. Therefore parts of its curves are missing. Figure 5 shows the runtime comparison among the three algorithms on the five data sets. In the figures, a support threshold is presented as a percentage with respect to the total number of transactions in the data set, i.e., min_sup | D | where D is the data set in question.
Figure 5 clearly shows that PADS outperforms FPMax* on all data sets. The lower the support threshold, the larger the difference in runtime. With a smaller support threshold, more patterns and longer patterns are qualified as frequent patterns. This trend suggests that PADS is more scalable than FPMax* on mining a large number of long patterns. When the support threshold is low, the difference in runtime between the two methods can be more than 60%. Most of the time, PADS outperforms LCM2 clearly, especially on the Mushroom and the Connect data sets. The only circumstance where LCM2 outperforms PADS is on the Chess data set with min_sup  X  15%. The reason is that the number of max-patterns is large (more than 1 million) but the database size is very small (only 3,196 tuples). The advantage of selecting a good key pattern is not clear in this situation.

What are the major reasons that PADS outperforms FPMax* and LCM2? The major cost of max-pattern mining in depth-first manner comes from two aspects: generating projected databases and checking whether a pattern is a subset of some max-patterns found before.
In Fig. 6 , we compare the three methods in terms of the number of projected databases ge-nerated on the five data sets. PADS generates much (about 80%) less projected databases than FPMax*. LCM2 generates the largest number of projected databases. This clearly shows the power of pattern-aware dynamic search in PADS. Many subtrees can be pruned by scheduling using good key patterns carefully chosen by our method.

In Fig. 7 , we compare the three methods in terms of the number of patterns that are checked against the max-patterns found before. PADS also conducts less subpattern checking than FPMax* and LCM2. The reason is that the pattern-aware dynamic search prunes many subtrees. Some patterns in those subtrees that are checked in FPMax* and LCM2 do not need to be checked by PADS. The savings in generating projected databases and checking subpatterns explain the advantage of PADS in performance.

Last, Fig. 8 compares the memory usage of the three methods. Both PADS and FPMax* use FP-trees as the major data structure. Thus, their memory usage is very similar. Their memory usage increases as the support threshold decreases, since they store the max-patterns already found in memory, and the number of such patterns increases as the support threshold decreases. On the other hand, LCM2 stores max-patterns on disk, and uses an array in main memory to store the database and the projected databases. Thus, its memory usage is insen-sitive with respect to support thresholds. In large data sets such as Mushroom and Connect, PADS and FPMax* use less memory than LCM2. In small data sets, LCM2 consumes a smaller amount of main memory than the other two methods. 6 Conclusions Max-pattern mining is important in both theory and applications of frequent pattern mining. In this paper, we developed a novel pattern-aware dynamic search method for fast max-pattern mining. The major idea is to schedule the depth-first search according to the max-patterns found so far, and prune the search space systematically. We present efficient methods to implement pattern-aware dynamic search. An empirical evaluation using the benchmark real data sets clearly shows that our method outperforms the currently fastest max-pattern mining algorithms FPMax* and LCM2 in a clear margin.

As future work, it is interesting to explore how the pattern-aware dynamic search method can be extended to other frequent pattern mining tasks, such as mining frequent closed itemsets, max-and closed sequential patterns, and max-and closed graph patterns. References Author biographies
