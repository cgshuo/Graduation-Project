
Graphs have become popular for modeling scientific data in recent years. As a result, techniques for mining graphs are extremely important for understanding inher-ent data and domain characteristics. One such exploratory mining paradigm is the k -MST (minimum spanning tree over k vertices) problem that can be used to discover sig-nificant local substructures. In this paper, we present an efficient approximation algorithm for the k -MST problem in large graphs. The algorithm has an O ( mation ratio and O ( n log n + m log m log k + nk 2 log k ) running time, where n and m are the number of vertices and edges respectively. Experimental results on synthetic graphs and protein interaction networks show that the algo-rithm is scalable to large graphs and useful for discovering biological pathways. The highlight of the algorithm is that it offers both analytical guarantees and empirical evidence of good running time and quality.
Recent technological and scientific advances have re-sulted in an abundance of data that describe and model phe-nomena in terms of graphs. Graphs have been used for modeling hypertext, chemical compounds, biological path-ways, protein structures and interactions, social networks, and taxonomies. For example, a metabolic pathway [19] is modeled as a set of reactions, enzymes, and metabolites, and an edge is placed between a reaction and a metabo-lite (or enzyme) if it participates in the reaction. Simi-larly, the 3D structure of proteins can be modeled as con-tact maps [17]: atoms whose distance is less than a thresh-old have an edge between them. Schema of heterogeneous web-based data sources and e-commerce sites or video data scenes [23] can also be modeled as graphs. A large pro-portion of the resulting graphs are annotated and weighted. The weights on edges can capture the physical proximity of the end nodes (contact maps, video scenes), frequency of their co-occurrence (hypertext), propensity of their interac-tion (pathways), or their similarity measured in other ways (social networks).

Given such an abundance of graphs derived from dif-ferent application domains, there is a need for new tech-niques that can explore and mine graphs. Such tech-niques have the potential to advance our understanding in numerous ways: discovery of topological properties and connectivity patterns [1, 13, 28], understanding of evo-lutionary changes [5, 24], and isolation of network mo-tifs [8, 25]. Many graph mining problems involve the dis-covery of substructures that have some significant prop-erties. The substructures take the shape of paths [31], trees [9], clusters (cliques) [10, 26], or general graph pat-terns [8, 12, 18, 20, 25, 32, 33]. The metric for evaluating a substructure can be expressed in terms of weights on the paths or trees, density of the clusters, or frequency of the re-curring graph patterns. Additional constraints can be added, such as size of the substructures, or specific vertices, edges, or subgraphs to be included. Most of these mining prob-lems turn out to be intractable in the context of graphs. This has led to the development of heuristics that are efficient on large problem sizes and produce good results based on em-pirical evidence. While recognizing the need for scalability, we adopt a different approach toward measuring the qual-ity: We develop efficient heuristics that are good not just on account of empirical evidence but also because a provable bound exists on the quality of their results compared to the optimal solution (measured as an approximation ratio).
The specific problem we consider in the context of the mining of local maximal structures is the k -MST problem: Given a weighted graph, find a minimum weight tree span-ning k vertices. The k -MST problem can be used for explor-ing a well-connected set of nodes in weighted graphs. For example, it can be used for finding pathways in stochastic biological networks, a group of people in a social network, or a set of amino acids in physical proximity in a protein structure. There are a number of variants of the basic k -MST problem. One might specify a vertex of interest to be included in the k -MST, leading to the rooted version of the problem. Additionally, one may specify other constraints such as the type of nodes or edges to include in the tree. The k -MST problem has been of historical interest. Since it has been proved NP-hard [29], the focus though has been on improving the approximation ratio with little regard to the running time (although polynomial). Thus, the approximation ratio has been improved from O ( O ( log 2 k ) [4], O ( logk ) [27], 17 [7], 3 [14], 2 . 5 [3], 2+ [2], and recently to 2 [15]. However, all the existing approxima-tion algorithms have a non-trivial time complexity, greater than O ( n 2 ) , where n is the number of nodes. For very large graphs, this time complexity is prohibitive, especially for exploratory interactive mining that requires an instant re-sponse. More importantly, these algorithms are designed just for ensuring the approximation factor. They rely on complicated routines such as primal-dual methods.

We present an efficient approximation algorithm for rooted k -MST in large graphs. The algorithm has an O ( approximation ratio and an O ( n log n + m log m log k + nk 2 log k ) time complexity for the rooted version of the problem, where m is the number of edges (we assume k is much smaller than n ). The algorithm easily outperforms existing algorithms in terms of time complexity and is the first known implementation for the k -MST problem. More-over, in the process of developing our algorithm, we define two new problems, that of k -MST in arbitrary unrooted, undirected trees and subset selection in hierarchical clus-ters. Both problems are solved optimally in tree structures using dynamic programming (DP). Specifically, we make the following contributions: 1. We present a double dynamic programming technique 2. We define the problem of subset selection in hierarchi-3. We present an approximation algorithm for rooted k -
Experimental results on synthetic graphs and protein in-teraction networks validate the scalability and quality of the approximation algorithm. The algorithm takes only seconds for graphs having about 100K vertices and 500K edges. The empirical quality is consistent with the theoretical O ( approximation ratio. The algorithm outperforms an alterna-tive approach based on shortest paths significantly in terms of quality. We also apply the algorithm to discover biolog-ical pathways in a yeast network. In particular, we found a pathway which is consistent with the reference MAPK sig-naling pathways. This validates the practical usefulness of the algorithm.

The rest of this paper is organized as follows. Section 2 presents double dynamic programming for k -MST in trees. Section 3 presents our approximation algorithm for k -MST in graphs. Section 4 proves the approximation guarantee of our algorithm. Experimental results are reported in Sec-tion 5. Section 6 discusses related work and Section 7 con-cludes the paper.
When the input graph is a tree, the k -MST problem can be solved in polynomial time. In this section, we present a double dynamic programming technique for k -MST in trees. The technique will be used in our approximation al-gorithm for k -MST in graphs.

Figure 1 illustrates the idea of outer dynamic program-ming. Let u be a node and v be a neighbor node of u , F ( u, v, l ) be the cost of the optimal subtree of size l that contains u but not v . The size of a tree is defined as the number of nodes in the tree. Let r 1 , ..., r d be the neighbor nodes of u exclusive of v . Then, the optimal subtree con-sists of node u and d branches where each branch is either empty or is another optimal subtree of size l i that contains r but not u . Thus, a recurrence relation can be established as F ( u, v, l +1)= c ( u ) + min F ( u, v, 1) = c ( u ) (1) where c ( u ) is the cost of node u and is the cost of the optimal subtree associated with ( r, u, l ) plus the cost of edge ( r, u ) . In other words, we can assem-ble a larger optimal subtree by combining smaller optimal subtrees.
Figure 1. Illustration of outer dynamic pro-gramming
In Eqn. (1), the number of combinations for splitting l ber is small. For arbitrary trees where the degree of a node is unconstrained, a naive approach is not efficient. Fortu-nately, we can find the optimal combination using dynamic programming again, namely Inner Dynamic Programming .
Figure 2 illustrates the idea of inner dynamic program-ming. Let A ( t, y ) be the optimal forest from the first t
Figure 2. Illustration of inner dynamic pro-gramming branches r 1 ..r t having y nodes. Then A ( t, y ) can be com-puted by considering the optimal forest from the first t  X  branches and the optimal subtree from the t th branch:
A ( t, y ) = min A ( t, 0) = 0 (2) A (1 ,y )= F ( r 1 ,u,y )
Using the inner dynamic programming, Eqn. (1) can then be computed by
For the rooted version of k -MST, i.e., the k -MST must contain a specific node u 0 , all neighbors of u 0 are taken into account at the final iteration of the outer DP:
F ( u 0 ,k )= c ( u 0 ) + min or F ( u 0 ,k )= c ( u 0 )+ min The time complexity is analyzed as follows. The outer DP computes k entries for each edge, totally O ( mk ) entries. For each entry F ( u, v, l +1) , the inner DP updates matrix A (  X  ,  X  ) by computing a new column A ( i, l ) for i =1 ..d . This update takes O ( dk ) time. Note that the degrees d s sum up to 2 m . Therefore, the total time complexity is O ( mk 2 ) . The space complexity is also O ( mk 2 ) .
In this section, we present the approximation algorithm for k -MST in graphs. Our algorithm actually solves the rooted version of k -MST. We first describe subset selection on hierarchical clusters, the main building block of our al-gorithm, and then present the approximation algorithm and its time complexity.
Given a graph and a hierarchical clustering of its ver-tices, we can select a subset of clusters that have exactly (or at least) k vertices. If we assign a cost to each cluster, can we find the subset of clusters that minimizes the total cost? Since the hierarchical clustering forms a rooted tree struc-ture, this problem can be solved optimally using dynamic programming as well.
 G
OAL . Given a rooted binary tree, each tree node (cor-responding to a cluster) has a given cost. The cost of a subset of nodes is the sum of costs of the nodes. Nodes are disjoint if they do not form an ancestor-descendent re-lationship. The goal is to find the minimum cost subset of disjoint nodes subject to the constraint that these nodes have exactly (or at least) k leaves in total. An example of the sub-set selection problem is shown in Figures 3 and 4. D
YNAMIC P ROGRAMMING . Let C be a tree node, C L and C R be the left and right child node of C , F ( C, k ) be the cost of the optimal subset under C having exactly k leaves. Then, If the number of leaves under C is equal to k , then the set consisting of node C only is considered as well:
Once a node is selected, none of its descendent nodes are selected. Thus, the subset of nodes is always disjoint. For leaves, the costs are trivially defined by leaves, let H ( C, k ) be the cost of the optimal subset of nodes having at least k leaves. Then, If node C has at least k leaves, then
The dynamic programming is carried out from bottom to top. The total time complexity is O ( nk ) where n is the number of tree nodes. For arbitrary rooted trees, one can use an inner dynamic programming in a similar way as in Section 2.

Although designed for our approximation algorithm for k -MST, the problem of subset selection on hierarchical clusters is general in its own and can be used for other sce-narios. Variants of the problem include constraining the number of clusters instead of the number of vertices, or con-straining both of them. These variants can also be solved by dynamic programming.
Our approximation algorithm first performs a hierarchi-cal clustering, selects the best subset of clusters having k vertices, connects them to the root vertex, and finally ex-tracts the optimal k -MST from the resultant tree.
To guarantee the theoretical approximation ratio, we need to guess the optimal solution OP T .Let L low be the distance from root vertex u 0 to the k th nearest vertex, L be the sum of edges in the shortest paths that connect the first k vertices. Clearly, L low and L up are the lower and upper bound of OP T respectively, and L up  X  kL low .
The approximation algorithm for k -MST is as follows. 1. Compute the shortest distance from each vertex to the 2. Guess the bound of the optimal cost OP T .For 3. Single linkage hierarchical clustering (Kruskal X  X  algo-4. For each cluster C i , compute its distance from the root 5. Denote the set of all clusters by S . Find the optimal 6. For each cluster C i in C , connect C i to the root vertex 7. Find the optimal k -MST from the resultant tree using
Some aspects to note about the above algorithm: 1. Step 2 (guessing the bound of OP T ) is used to guar-2. In step 5 (subset selection of clusters), the goal could 3. Step 7 extracts the best k -MST from the resultant tree. The time complexity is analyzed as follows. Step 1 takes O (( m + n ) log n ) (or O ( m + n log n ) if using the Fibonacci heap). Step 2 repeats log k times. Step 3 takes O ( m log m ) time. Step 4 takes O ( n ) time. Step 5 takes O ( nk ) time. Step 6 takes O ( n ) time. Step 7 takes O ( nk 2 ) time (or O ( k ) if extracting a simple k -subtree). Thus, the total time com-plexity is O ( n log n + m log m log k + nk 2 log k ) . Since k n in practice, the algorithm is scalable to large graphs. This is validated in the experiments.

In addition to the time efficiency, the algorithm is highly adaptable and allows for variants: 1) Instead of single link-age clustering, other hierarchical clustering can be used. 2) Other cost functions can be used for subset selection of clus-ters. 3) Vertices can have weights. 4) Multiple roots can be allowed (i.e., Steiner trees).

We illustrate the algorithm using an example. Figure 3 shows an edge weighted graph. Figure 4 shows a hierarchi-cal clustering of the graph. Leaves are shown in ellipses and internal nodes are shown in rectangles. Now, suppose one
Figure 4. Subset selection on hierarchical clusters with k =3 . The optimal subset of clusters is { C 1 , v 4 } with a total cost of 10. The corresponding vertices are { v 1 ,v 2 ,v 4 } wants to find a k -MST rooted at v 0 with size of 4. By Steps 3 and 4 of the algorithm, the cost of each cluster is computed as the the weight of the cluster plus its distance to v 0 costs are shown in the tree nodes of Figure 4. Next, Step 5 selects the optimal subset of clusters having 3 vertices. The selected subset of clusters is { C 1 ,v 4 } . It can be verified that this subset outperforms other candidates, such as { C 4 } {
C 2 ,v 1 } . The selected clusters are then connected to the root vertex. Figure 5 shows the resultant tree. As this tree already has exactly 4 vertices, the algorithm terminates.
In this section we prove the quality of our approximation algorithm. Let OP T be the cost of the optimal k -MST. We have the following approximation guarantee: Theorem 1. The cost of the approximate k -MST is at most O (  X 
To prove Theorem 1, we first show that there always ex-ists a small subset of clusters that has k leaves. Lemma 1. Given a rooted binary tree having n leaves, for any k and l , n  X  k  X  l  X  log k , there exist l nodes (ei-ther internal nodes or leaves) such that the total number of leaves under these l nodes is equal to k .
 Proof of Lemma 1. (By construction) We allocate k recur-sively from top to bottom. At each node, if one subtree has at least k leaves, then allocate k into that subtree. Oth-erwise, allocate fully to the larger subtree, and the rest of k into the smaller subtree. Let L and R be the number of leaves under the larger and smaller subtree. We have k  X  L + R  X  2 L . Then, k  X  L  X  k/ 2 , i.e., the rest allo-cated into the smaller subtree must be at most k/ 2 .Inthe end, there are at most log k fully allocated subtrees. These subtrees cover k leaves.

Next, we collapse nodes bottom-up under these fully al-located subtrees. A node can be collapsed if both of its child nodes are leaves. The node then become a new  X  X eaf X . Re-peating this process will cause the number of  X  X eaves X  to decrease gradually. Eventually there will be log k  X  X eaves X  left. Since k  X  l  X  log k , at some stage, we can find l  X  X eaves X  left. These l  X  X eaves X  correspond to l nodes in the original tree, which cover k leaves.

The lemma can be generalized to rooted trees with max-imum fan-out of  X  , and l is limited by k  X  l  X  ( X   X  1) log k .
 Now, we prove the approximation ratio in Theorem 1. The basic idea is to decompose the optimal k -MST into a set of clusters, and then infer the existence of a feasible so-lution (a subset of clusters in the clustering hierarchy) such that: each intra-cluster edge is bounded by O ( OP T  X  as a result, their sum is bounded by O ( inter-cluster edge is bounded by O ( OP T ) but the number of clusters is at most O ( Proof of Theorem 1. Let w be the threshold edge weight be-low which the optimal k -MST is divided into C 1 ..C
Now, consider the optimal clusters C  X  1 ..C  X   X  ters in the clustering hierarchy. Each C  X  i is not necessarily a cluster in the clustering hierarchy. However, its vertices must be contained in some super-cluster C i in the cluster-ing hierarchy below the same w threshold. The following properties can be observed: 1) the number of such super-clusters C i s is at most under these super-clusters is at least k ; 3) The weight of each edge in the super-clusters is no more than w . Figure 6 illustrates the optimal clusters and the super-clusters.
Next, we show that there exist O ( clustering hierarchy which cover exactly k vertices. Let S be the total number of leaves in the first i super-clusters C , ..., C i . Then, there exists j&lt; S +1 . We select the first j super-clusters C 1 , ..., C then select sub-clusters from super-cluster C j +1 such that they cover k  X  S j vertices. According to Lemma 1, the number of these sub-clusters is bounded by log( k  X  S j ) . Thus, there exist O ( which cover exactly k vertices.

As a result, these O ( tion in the search space of the algorithm (Step 5: subset selection on hierarchical clusters). The sum of intra-cluster edges of this solution is bounded by cluster edges, the guessing step (step 2) guarantees two tri-als L and 2 L where L  X  OP T  X  2 L . The trial 2 L en-sures that all distances from the root vertex to the clusters (and in turn inter-cluster edges) are bounded by 2 OP T . Thus, the total cost of this feasible solution is bounded by O (  X 
Since the algorithm always finds the optimal subset of clusters, the cost of the optimal subset is also bounded by the above feasible solution. Therefore, the algorithm guar-antees an O (
In this section, we evaluate our approximation algorithm on both synthetic and real graphs, and apply the algorithm to pathway discovery of biological networks. Section 5.1 evaluates the performance and quality of the algorithm on synthetic graphs. Section 5.2 reports results on protein in-teraction networks and compares the discovered pathways to reference pathways.
 We measure the quality of results by comparison to OP T . Since calculating OP T is intractable, we compute a naive lower bound of OP T which is the distance from the k th nearest vertex to the root ( L low from Section 3.2). The upper bound of approximation ratio is defined by the ratio of the algorithm X  X  cost to L low .

Since no implementations of the state-of-the-art algo-rithms exist, we empirically compare our algorithm with a shortest path approach: find the first k nearest vertices, and then connect them to the root to form a subtree of size k ( L up from Section 3.2). The shortest path approach has an O ( k ) approximation ratio.
 All the algorithms were implemented in Java using Sun JDK 1.6. All experiments were performed on an Intel 2.8GHz, 2G memory running MS Win XP.
The synthetic graphs are generated using a simple ran-dom graph model: given n and m , first generate a random tree that connects n vertices, and then generate the rest of edges by randomly choosing two end points. (More real-istic models [1, 13, 24] could also be used for generating the synthetic graphs.) To generate the edge weight, we first generate a random probability value, and then convert it to an edge weight by taking the negative log.

We first fix n and m at 20K and 100K respectively, and vary k as [10, 30, 50, 70, 90]. For each k , we randomly select a vertex as the root and run the approximation algo-rithm. 1000 trials are conducted and the average results are reported.

Figure 7 shows the running time with varying k .Theto-tal running time is broken down to four phases: 1) Shortest path computation, 2) Hierarchical clustering, 3) Cluster se-lection, and 4) Finding k -MST in the resultant tree. Phase 1 is independent of k and depends only on the graph. Phase 2 is repeated at most log k times. Phase 3 takes time linear in k , which is consistent with the time complexity of clus-ter selection. This step dominates the running time for high values of k . Phase 4 has a time complexity of O ( nk 2 ) .In practice, the size of the resultant tree is much smaller than n . Thus, the running time of this phase is smaller than the other phases. Overall, the running time is in seconds, indi-cating the efficiency of the approximation algorithm.
Figure 7. Running time with various k for syn-thetic graphs
Figure 8. Upper bound of approximation ratio with various k for synthetic graphs
Figure 8 shows the upper bound of approximation ratio with varying k . As can be seen in the figure, the approxi-mation ratio of our algorithm is much smaller than that of the shortest path approach. The ratio grows slowly with in-creasing k . This validates the quality of our algorithm.
Next, We vary the number of vertices n as [20 K, 40 K, 60 K, 80 K, 100 K ] and m =5  X  n , and fix k at 10 and 100 respectively. Figure 9 shows the running time with varying n . As the graphs become larger, the running time increases accordingly. However, the running time is still in seconds when the graph contains 100K vertices. The results validates the scalability of our algorithm.
Figure 9. Running time with various sizes of synthetic graphs
We use the yeast ( S. cerevisiae ) probabilistic network by Lee et al. [22] which contains 5552 vertices and 34000 edges. The probabilities on edges are converted into edge weights by taking the negative log.

We apply our algorithm for finding biological pathways in the yeast network. We consider the known MAPK signal-ing pathways in yeast as the reference pathways. Figure 10 (a) shows the pheromone and filamentous growth pathways adapted from [30] and the KEGG database. Note that the two pathways share the MAPK chain  X  X DC42-STE20-STE11-STE7 X  and the transcription factor  X  X TE12 X .

We choose the receptor  X  X TE2 X  in the pheromone path-way as the root vertex. By setting k at 10, we found a pathway from the yeast network as shown in Figure 10 (b). All vertices in the discovered pathway except  X  X ST2 X  show up in the reference pathways. Interestingly, the discovered pathway contains  X  X SS1 X , which is present in the filamen-tous growth pathway.  X  X ST2 X  does not exist in the reference pathways. This protein is responsible for activating  X  X PA1 X  (http://www.yeastgenome.org). It regulates desensitization to alpha factor pheromone. It is also required to prevent receptor-independent signaling of the mating pathway.
The tree structure of the discovered pathway does not completely match the reference pathways. This is due to the limitation of the input graph. For instance, there is no edge between  X  X TE18 X  and  X  X DC42 X  in Lee X  X  network. How-ever, the algorithm is still able to circumvent the broken chain to find the rest of the vertices.

Figure 11 shows the induced subgraph of Figure 10 (b) in Lee X  X  network. The induced subgraph forms a clique-like pattern. By comparison, the tree-like pattern has a few advantages over the clique-like pattern. First, it is easier
Figure 10. MAPK signaling pathways in yeast. (a) The known pheromone and filamenta-tion pathways, adapted from [30] and KEGG (http://www.genome.jp/kegg). (b) the path-way discovered from Lee X  X  network by our al-gorithm with root= X  X TE2 X  and k =10 .

Figure 11. The induced subgraph of the dis-covered pathway (Figure 10 (b)) in Lee X  X  net-work to examine and explain the biological meaning of a tree-like pattern than that of a clique-like pattern. The tree-like pattern has a smaller number of edges and defines how the proteins interact in the pathway. Second, a tree-like pattern may span vertices in multiple clusters. In contrast, tech-niques for clique discovery tend to exclude vertices not in the same cluster. Inter-cluster interactions are ignored. Fi-nally, when the network itself does not include cliques (e.g., signal transduction pathways), tree-based pattern finding al-gorithms will perform better.
Figure 12. Running time with various k for the yeast network
We also evaluate the running time of our algorithm on the yeast network. Figure 12 shows the running time with varying k . The breakdown across the different phases is similar to the case of synthetic graphs. The total running time is in seconds. This validates the practical efficiency of our algorithm on real graphs. A MST problem has been studied in the algorithm community for a long time. Ravi et al. [29] gave the first non-trivial algorithm for unrooted k -MST with O ( ratio and O ( n 2 ( m + n log n )) running time. The algorithm consists of two phases. The merge phase generates clus-ters by single linkage hierarchical clustering. The merge phase continues until there exists a cluster having between k and 2 k vertices. A new instance of collect phase is en-tered whenever there exist at most least k vertices. The approximation guarantee lies in that the weight of each intra-cluster edge is bounded by OP T/ (  X  k  X  OP T in sum) and the number of inter-cluster edges is bounded by of the optimal k -MST. Our proof of Theorem 1 is inspired by this approach.
 Awerbuch et al. [4] improved the approximation ratio to O (log 2 k ) for the rooted version. They merged clusters us-ters are preferred for merging. The merge phase is invoked several times and each time a cluster is found and connected to the root. At most O (log k ) clusters are required such that the clusters have at least k vertices. The algorithm needs to compute the distance between every pair of clusters. The time complexity is at least O ( n 2 log n ) .

Blum et al. [7] gave the first constant factor 17-approximation algorithm for rooted k -MST with an O ( n 2 log 4 n ) running time. Garg [14] improved the fac-tor to 3 for rooted k -MST. Based on Garg X  X  algorithm, Arya and Ramesh [3] presented a 2.5 approximation algorithm. Arora and Karakostas [2] presented a 2+ approximation algorithm. Recently, Garg [15] improved the approxima-tion ratio to 2 for unrooted k -MST. All the constant factor approximation algorithms rely on the Goemans-Williamson algorithm [16] for the prize-collecting Steiner tree problem, which has a time complexity of O ( n 2 log n ) .
 D to trees, the k -MST problem can be solved in polynomial time using dynamic programming [29]. Fagin et al. [11] used dynamic programming to implement analytical opera-tions on multi-structural databases. Kumar et al. [21] used dynamic programming for hierarchical topic segmentation of websites. All the techniques transform the tree into a rooted binary tree (or binary composition rules) before ap-plying dynamic programming. In contrast, our double dy-namic programming technique (Section 2) can be directly applied to arbitrary unrooted, undirected trees.
 D sis of protein interaction networks, Scott et al. [31] proposed a randomized algorithm for detecting signaling pathways. They used a technique called color coding to find optimal simple paths of length k with probability e  X  k . The problem is NP-hard since the traveling salesman problem can be re-duced to it. Instead of approximating the optimal path, they repeat many trials until the algorithm has a high probability of finding the optimal path. The probability depends on the number of trials which is exponential in k .
 C
LUSTER DISCOVERY . A number of algorithms have been proposed recently for finding clusters or clique-like substructures in graphs [6, 10]. These algorithms are use-ful in finding substructures where each node is connected closely to all other nodes in the substructure. The k -MST problem on the other hand finds substructures that are branching or  X  X ree-like X . The difference between the two kinds of substructures can be illustrated by noting that the former corresponds to protein complexes in biological net-works, while the latter corresponds to signaling, transcrip-tional, or metabolic pathways.
Graph mining has become an extremely important prob-lem due to the exponential growth in scientific data of var-ious kinds. We have presented an efficient algorithm for significant substructure discovery, specifically k -MST, in large graphs. The algorithm has an interesting framework for mining significant substructures: a hierarchical cluster-ing step collects significant components; a selection step ex-tracts an optimal subset of the components; finally, a signifi-cant substructure is assembled using the subset. Theoretical analyses establish a good time complexity and approxima-tion ratio of the algorithm. Experimental results provide empirical evidence that the algorithm is scalable to large graphs and achieves a good quality. We have demonstrated the practical usefulness of the algorithm by finding path-ways in biological interaction networks. Extensions to other substructure discovery problems while ensuring worst-case bounds on both running time and quality are planned for the future.

