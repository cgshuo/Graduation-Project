 Recent research in privacy-preserving data mining (PPDM) has become increasingly popular due to the wide application of data mining and the increased concern regarding the protection of private and personal information. Lately, numerous methods of privacy-preserving data mining have been proposed. Most of these methods are based on an assu mption that semi-honest is and collusion is not present. In other words, every party follows such protocol properly with the exception that it keeps a record of all its intermediate computations w ithout sharing the record with others. In this paper, we focus our attention on the problem of collusions, in which some parties may collude and share their record to deduce the private information of other parties. In particular, we consider a general problem in PPDM -multiparty secure computation of some func tions of secure summations of data spreading around multiple parties. To solve such a problem, we propose a new method that entails a high level of security -full-privacy. With this method, no sensitive information of a party will be revealed even when all other parties collude. In addition, this method is efficient with a running time of O ( m ). We will also show that by applying this ge neral method, a large number of problems in PPDM can be solved with enhanced security. H.2.7 [ Database Administration ]: Database Administration  X  Security, integrity, and protection ; H.2.8 [ Database Administration ]: Database applications  X  Data mining ; H.3.4 [ Information Storage and Retrieval ]: Systems and Software  X  Distributed systems. Algorithms, Performance, Experimentation, Security Privacy, Distributed, Collusion, Data Mining, Secure Multiparty Computation. Data mining technology has emerged as a means of identifying patterns and trends from large quantities of data. In recent years, increased concern over personal information and privacy protection has led to the devel opment of a number of techniques such as randomization and hom omorphic encryption. Such techniques have been suggested to ensure that data mining can be performed while maintaining the preservation of private information protection. The goal of privacy-preserving data mining with m parties is that the parties will collaborate to compute some function of their input, and that no party in the system will learn any additional information separate from the functions and the parties' own input. Large numbers of conclusions in privacy-preserving data mining have been obtained by researchers, most of which are based on an assumption that each party is semi-honest. In particular, a party is deemed  X  X emi-honest X  when that the party follows the protocol properly with the exception that it keeps a record of all its intermediate computation results and then tries to deduce further information in addition to th e protocol result. Moreover, researchers also assume that every party does not collude or share its record with any other party. However, reliance on such assumptions proves problematic in that a party cannot trust any private information. Consider a scenario in which a large number compute some secure function of their inputs. For example, they want to get some information regarding market conditions. In exception that some of the parties involved may be enticed to sneak a peek at their competitor X  X  pr ivate records. This scenario is collaborating to compute some s ecure function of their inputs, 
X , 3 X and 4 X respectively. Assume that party 1 is a common competitor of party 2, 3 and 4. Then these parties may thus choose to unite to form a coalition after the execution of the protocol to deduce the privacy information of party 1 from the messages received from party 1 ( m 2 , m 3 , m 4 ) and the final result. Another example is that m parties collaborate to securely compute the average of all data on them. Each party has the inputs the summation of all data on that party and the number of those data respectively. The goal is to compute r = ( 1 s + 2 n +...+ m n ), the overall average of the data in all parties. A straightforward method is secu rely computing the numerator s =( + s +...+ m s ) and the denominator n = 1 n + 2 n +...+ everyone knows the values of s and n , if party 2, 3, ... , m collude, are revealed to others. In order to prevent such a thing from happening, a protocol against collusions is necessary for each party. Here, the collusion problem is that a subset of the participants, a coalition, might get together after the execution of the protocol and attempt to deduce additional information from non-coalition parties. We propose a symmetric protocol called Secure Product of Summations (SPoS) protocol, in which every party in the system is equal to any other. We can also prove that the protocol is full-private (( m-1 )-private), where m is the number of parties. Here, a protocol is called t -additional information from its execu tion. From this protocol we can derive applicable protocol s by which several problems in privacy-preserving data mining can be solved. Throughout this paper we consider the case of m -party, where m is larger than 1. In principle, distributed data in privacy-preserving data mining can be classified into two cate gories -vertically partitioned and horizontally partitioned data. In the case of horizontally partitioned data, each site has complete information on a distinct these datasets. In contrast, verti cally partitioned data has different types of information at each site, and each has partial information on the same set of entities. In the following paragraphs, we w ill list some examples to show that the computation of Secure Function of Summations that we address in this paper is a general problem in PPDM. Probability Distribution Estimation. Consider a scenario where a set of data are drawn from the same probability distribution and distribute to several parties. Each party must keep from revealing its private information to other parties, but at the same time all the parties want to learn about the whole distribution. To be more specific, suppose that party i has an observation data set of N true, and 0 if otherwise. It is ob livious that both the numerator and the denominator are secure summations of data spreading around m parties. Hence the computation of this probability becomes a problem of secure computa tion of ratio of summations. Na X ve Bayes. The problem of privacy-preserving na X ve Bayes on horizontally partitioned data can also be formulated to a problem of computation of the ratio of (two) secure summations spreading around m parties. ([28]) K-Means on Horizontally Partitioned Data. The major point of privacy-preserving K-Means on horizontally partitioned data is to securely compute the weighted average, which can also be treated as summation of number. ([16]) K-Means over Vertically Partitioned Data. Different from the case of horizontally partitioned data, the problem of privacy-preserving K-Means on vertically partitioned data can be translated summations of data spreading around m parties. That is equivalent to the secure comparison of summations. ([26]) Sorting of Secure Summations. By extending the above secure comparison problem, we can get that the problem of securely sorting secure summations is also what we addressed. Our contributions: The computation of the function of secure summations of data spreading around multiparty is a general problem in distributed computa tion and privacy-preserving data mining. Our newly proposed method enhances the security against party collusion, i.e. satisfaction of full-privacy so that a secure communication channel is no longer nece ssary. It is also an efficient one with a running time of O ( m ) in the case of full-privacy. efficiency if we choose to decreas e the level of security. It can therefore be used as a common tool to solve a large number of problems in privacy-preserving data mining. The remainder of this paper is organized as follows. Section 2 provides an overview of existing work related to our proposals. Section 3 introduces related notations and basic concepts in the area of privacy-preserving data mining. Section 4 provides formulations of common problems faced in PPDM. Section 5 provides the protocols we propose for solving th ese problems. In section 6, we evaluate the security and efficiency of our protocols. The performance of our protocol is conf irmed by experiments in section 7. Conclusive remarks are pr ovided in the last section. There have been numerous propos als in the area of privacy-preserving data mining recently. Following is an overview of the most pertinent proposals. In 2005, Jha et al. ([16]) attempted to solve the 2-party privacy-preserving K-means algorithm with horizontally partitioned data. Jha et al. proposed an algorithm to securely compute the weighted average problem (WAP) in the case of 2-party. With this algorithm, a ratio of two secure summations of two parties is securely computed. Mert Ozarar et al.([22] 2007) extended WAP to multi-party case. In Mert's method, which is called  X  X verall mean problem X  or OMP, two numbe rs are used as input for each party -the average and size of the data in that party. The goal of OMP protocol is to securely compute a ratio of the summation of data and the summation of size in the case of multiple parties. They proposed an iterative algorith m to securely compute this ratio. In the j th step, the average and size of the first j +1 parties are securely computed by party j+ 1. However, party j +1 can compute j +1 from the total size of the first j +1 parties. Furthermore, since parties collude, they can easily deduce the size of party j . Similarly, they can also deduce the summation of data in party j . collusion. Vaidya et al. ([28], 2008) proposed another solution of computation of the ratio of (two) summations of data spreading around m parties to solve the problem of privacy-preserving na X ve Bayes. To securely compute the ratio of two secure summations, they employed the secure summa tion protocol to compute two summations. In order to prevent these two summations from being revealed to another party, they replaced the last step with the secure-logarithm-based approach proposed by Lindell ([17], 2002). If every party does not collude, the final result can be computed without revealing thes e two summations. However, if revealed. Vaidya et al. ([26], 2003) studied the problem of privacy-preserving K-Means clustering on vertically partitioned data. The goal was to securely compute the index that represents the largest summation of data spreading around m parties. With their method, all data in each party is securely permutated and randomized by one special party, called party 1. The permutated summations are then securely compared by two other special parties, called party 2 and party r , and the largest of which is selected. As a final step, the original index is resumed by party 1. Since there are three special parties in their protocol , the summations of all data may be revealed if these three parties collude. Although the possibility of handling collusion was considered in [26], unfortunately, if party 2 and party r collude, all permutated summations are revealed to them. Thus the largest summation can be easily obtained. In other words, th e summation corresponding to the final result is revealed. Yao ([29]) first introduced the secu re 2-party computation. It is well known that any 2-party distributed function can be securely evaluated by Yao's Secure Func tion Evaluation (SFE). Goldreich et al. ([11]) had extended it to multiparty. Malkhi et al. introduced Fairplay ([18]), a full-fledged sy stem that implements generic secure function evaluation (SFE) in the case of 2-party. A. Ben-David et al. ([3]) extended it to multi-party. As a special case, the problem we address is also ca rried out by SFE. Unfortunately, because the arithmetic circuits is too many, SFE can be too inefficient, particularly when the number of parties is very large and the computation is complex, as the problems that we address. In this paper, m denotes the number of parties in the secure multiparty computation, while [ m ] denotes the set {1, 2, ... , m }. The m parties are numbered 1, 2, ... , m , respectively. For the set the left-top of a variable to denote the party by which the variable is generated, for example i x is denoted a variable generated by can be extended to real number ([4]): for a , b  X  R , M a = b + qM . For example, 6.2  X  -5.8  X  0.2(mod 2.0). Moreover, some similar properties of congruence can be derived directly from this definition. Especially, for any a , b , c , d , r , s Secure Summation: Assuming that all parties communicate on a secure channel, the following pr otocol securely computes a summation of values from each party, v = v 1 +...+ v m . Assume that party 1 to be the master party. Party 1 generates a random number R uniformly in Z N ={0,1,2,..., N -1}, computes ( R + v ( R + v 1 ) (mod N ), which party 2 got is also uniformly in Z about v 1 . And then, party 2 adds v 2 to this number, ( R + v (mod N ), and sends the result to party 3, and so on. In each step, every party learns nothing about the others. Finally, after receiving R + v 1 +...+ v m-1 , party m computes ( R + v N ) and sends the result back to part y 1. Party 1 also learns nothing about the others, but can compute v 1 +...+ v m by subtracting R from the received number. This method works well in the case of semi-example, party l -1 and party l +1 can easily collaborate to compute v . Several solutions against collusi on have been proposed, such as [25] and [15]. However, there is no fully-private protocol that is able to securely compute the summation, because no matter how secure the protocol is, the valu e of one party can be computed directly by subtracting the summation of all other values from the final result if all parties other than this one collude. Homomorphic encryption: Public key encryption is a fundamental and widely used technique. The asymmetric key algorithm generates a pair of encryption keys  X  a public key and a private key. The public key used to encrypt a given message is different from the private key used to decrypt the cryptograph. The private key is kept secret, while the public key may be widely distributed. Given a key pair ( sk, pk ) and a message m in Z c = E pk ( m ) denotes an encryption of the plaintext m , and d = D denotes the decryption of the cryptograph c . Most of public key encryptions are based on the modul ar arithmetic with a modulus N , a large integer. In particular, we call such an encryption system a homomorphic encryption, if th ere are two operations + and * satisfying the condition for any m 1 and m 2 : There are several classical homomorphic cryptosystems, such as RSA ([24]), ElGamal ([10]), Go ldwasser-Micali ([14]), Benaloh ([2]), Okamoto-Uchiyama ([21]), Paillier ([23]), Naccache-Stern ([20]), Damgard-Jurik ([8]), etc. The operation + in (2) may be addition (such as Benaloh and Paillier) or multiplication (such as RSA and ElGamal). In this paper, an additively homomorphic cryptosystem is needed, so we choose the Paillier ([23]). It is worth emphasizing that all these algorithms are based on the modular arithmetic and that the m odulus is almost contained in the public key. In the case of Paillier cryptosystem, the public key is a pair of two large numbers, g and n , and the homomorphism is expressed as below. 2 1000 . From equation (3), we can get directly that the following condition is also satisfied for any m and k . As we have mentioned, we are focusing on the secure multiparty term of collusion-resistance. D
EFINITION 1 ( t -Private). Let f : ({0,1} * ) m  X  {0,1} input, single-output function, and let  X  be a m-party protocol for computing f. We denote the party input sequence by x=(x x ). For the subset of [m], I ={i 1 , i 2 ,..., i t the joint protocol view of parties in I , and OUT protocol output. For 0&lt;t&lt;m, we say that  X  is a t-private protocol for computing f if there exist s a probabilistic polynomial-time every x, it holds that where "= C " denotes computational indistinguishability. A fully private if it is (m-1)-private. ([9]) In other words, a protocol is called t -private if no collusion containing at most t parties can get any additional information from its execution. Accordingly, the security is defined by by those parties in an ideal world where parties send their inputs to a trusted party who com putes and sends back their corresponding outputs. Obviously, the bigger the value of t is, the use the composition theorem to simplify the process of proving security. D
EFINITION 2 (Privately reducible) A protocol is said to privately case, we say that g is privately reducible to f. ([12]) T
HEOREM 1 (Composition theorem) Suppose that g is privately reducible to f and that there exi sts a protocol for privately computing f. Then there exists a protocol for privately computing g. ([12]) This implies that we can prove a pr otocol is private by treating the secure sub-protocol as a black box. Observing the examples listed in section 2, we notice that they are all the secure computation of some function of summations of the data spreading around m parties. Also, they are classified into two categories: the computation of secure ratio of summations ([16, 22 and 28]) and the secure comparison of summations ([26]). Our main idea is proposing a basic prot ocol to securely compute the product of summations against collusion and then deriving two protocols from the basic one. the range (0, 1). This is not the case for many clustering problems. However, since the range of the inputs in clustering problem is assumed to be known to all partie s, we can normalize them into the range (0, 1) by some linear transformation. For example, if linear transformation similarly. This can be checked in each definition in the following. Since the goal of our basic protoc ol is to compute the secure product of (two) summations, we abbreviate it as "SPoS." Problem 1 Secure Product of Summation Protocol Input : Each party has two real numbers: 
Output : All the m parties collaborate to compute Condition : There are three levels of meanings in this condition of security. First, the inputs of each party are not revealed to any other party; second, the summation of  X  s and the summation of  X  s are also revealed to no one; and third, this protocol deals with collusion problem, and is fully-private. Using the SPoS protocol, we can de rive two derivative protocols which can be applied to solve many problems in PPDM. In the following, we formulate these protocols. This protocol is to compute the secure ratios of k summations of ratio is meaningless when k =1, we set k  X  2. Problem 2 Secure Ratios of Summations Protocol Input : Each party has k real numbers: 
Output : All the m parties collaborate to compute Condition : This condition of security is the same as that of SPoS protocol. Especially when k = 2 , this protocol becomes 2-SRoS, which computes a secure ra tio of two summations: The 2-SRoS problem is similar to Mert's OMP ([22]) and Vaidya's method ([28]), but 2-SRoS deals with the problem of collusion, whereas the other two methods do not. This protocol is to securely compare (two) summations of data spreading around m parties. We call it "SCoS." Problem 3 Secure Comparison of Summations Protocol Input : Each party has two real numbers: 
Output : All the m parties collaborate to compute Condition : This condition of security is the same as that of SPoS protocol. Moreover, it can also be used to securely sort more than two summations. In this section, we propose our prot ocols formulated in section 4. Before explaining SPoS protocol , we introduce a sub-protocol that we have entitled  X  X ecure Linear Function Evaluation X  or SLFE. This SLFE will be used in the SPoS protocol. With SLFE, the value of a linear function can be securely computed. Here the of the public key of each party is always equal to a constant l , and the length of M is l/2 , i.e. M 2  X  N . N is used as a modulus. Protocol 1 Secure Linear Function Evaluation Input : Output : begin end In fact, from the homomorphism (3) and (3') of the encryption, e is congruent to the value: With the property of modular arith metic on real numbers (1), we divide N/m 2 on both sides of (10), and then get the value we want: In this paper, we use SLFE(  X  ,  X  ,  X  ) to express SLFE protocol with input  X  of Alice and  X  ,  X  of Bob. In most of the protocols introduced in section 2, there are some special parties that perform more operations and hold more information than others, thus having opportunity to get extra information about other parties. In contrast, the parties in our new proposal are completely symmetric, ensuring that full-privacy is realized. To make our protocol easy to understand, we use a 3-party case to illustrate the main strategy of it. Suppose that party 1 (resp., 2 and 3) has the pair of input data ( compute p=  X  X  = ( 1  X  + 2  X  + 3  X  )(  X  + 2  X  + 3  X  ). Stage 1. Firstly, party 1 (resp., 2 and 3) randomly generates (  X  , 1  X  3 ) (resp., ( 2  X  1 , 2  X  2 , 2  X  3 ) and ( 3  X  1 Then using SLFE protocol, party 1 (resp., 2 and 3) randomly generates ( 1  X  1 , 1  X  2 , 1  X  3 ) (resp., ( 2  X  1 , satisfying (13). Stage 2. Party 1 (resp., 2 and 3) computes ( 1  X  (  X  following. Since  X  s are random numbers,  X  s do not contain any information about the inputs  X  s. 
Party 1 : 1  X  + 1  X  1  X  1  X  1 , 1  X  + 1  X  2  X  1  X  2
Party 2 : 2  X  + 2  X  1  X  2  X  1 , 2  X  + 2  X  2  X  2  X  2
Party 3 : 3  X  + 3  X  1  X  3  X  1 , 3  X  + 3  X  2  X  3  X  2 Party 1 (resp., 2 and 3) sends ( 1  X  1 , 1  X  2 , each party computing p with received numbers as below. 
Party 1 : 1  X  1 , 2  X  1 , 3  X  1 ( 1  X  1 + 2
Party 2 : 1  X  2 , 2  X  2 , 3  X  2 ( 1  X  2 + 2
Party 3 : 1  X  3 , 2  X  3 , 3  X  3 ( 1  X  3 + 2 In the end, Party 1 (resp., 2 and 3) publishes the value of p and 3 p ), thus they can compute the summation: Since each input is bounded in (0, 1), the value of ( (  X  + 2  X  + 3  X  ) will be bounded in (0, m 2 ). So if we bound the result p = p + 2 p + 3 p (mod m 2 ) in (0, m 2 ), this value is what we want. Above example is not strict, now we introduce the complete protocol. Since any one of these protocols are completely symmetric, we practice, all m parties run the same procedure in parallel. In stage 1, we generate random values satisfying some conditions. Protocol SPoS -Stage 1 Generating Parameters Input : a real number i  X 
Output : real numbers i  X  1 , i  X  2 ,..., i  X  m , i  X  begin end In this stage, party i runs SLFE with each other party to securely computes i  X  i i  X  . From (17), (18) and (19), we can get that the parameters generated by all par ties satisfy the conditions below. After this stage, each party knows only its own parameters, conditions of (20) and (21). Moreover, from the security offered by SLFE protocol, the privacy of i  X  is protected. Using the parameters generated in stage 1, we can keep the privacy of the input i  X  by adding the random numbers  X  s to the input, and then securely computing the result. Protocol SPoS -Stage 2 Computing the Result
Input : real numbers i  X  , i  X  , i  X  1 , i  X  2 ,..., begin end Substituting (22) and (20) into equation (23), i p becomes: Furthermore, substituting (25) and (21) into (24), we can get the following equation: Since 0&lt; i x &lt;1 and 0&lt; i c &lt;1, we have 0 &lt; ( +  X  ) &lt; m 2 . Therefore, if we bound p in [0, m 2 ), i.e. p is just the final result we want to compute. In the rest of this paper, we denote SPoS(( 1  X  , 1  X  ), ( 2  X  , 2  X  ),..., ( protocol with input of ( i  X  , i  X  ) of party i , for 1  X  i  X  m . Using (22) we can rewrite (23) as That is to say, in the practical computation of stage 1, we need only compute i  X  i i  X  . The computation of i  X  i is unnecessary. The relationship between the integer parameters and the real parameters are shown in the equa tions (8) and (9). We summarize the range and the accuracy of these parameters in Table 1. In any PPDM problem, the accuracy of input is not very high. On the other hand, N j is a very large integer and M is also very large with half length of N j . We understand from Table 1 that the range of higher than the accuracy of i  X  . The value of i  X  is therefore hidden by adding i  X  j to it. In other words, sending reveal any information about i  X  . In practice, instead of float num bers, we use large integers to express real numbers. For example, to express 1/3 with accuracy of 0.001, we will compute an integer, 1000*1/3=333, which means integer 333 representing real number 1/3 with accuracy of 0.001. Because the accuracy of parameters in Table 1 is far higher than the accuracy of inputs and outputs, we can treat those parameters as real numbers. Accordingly, since the accuracy of these parameters is extremely high, the computational error is also decreased to an extremely low level. In other words, the length of integers increases not only the security but also the accuracy. Using the SPoS protocol introduced in the above section, we realize the k -SRoS protocol easily. The following protocol is also with respect to party i . Protocol k -SRoS Input : i x 1 , i x 2 ,..., i x k begin end r is the obvious final result of this protocol. The protocol SCoS can also be realized as follows. Suppose that there exists an integer P &gt;1. Protocol SCoS Input : i x 1 , i x 2
Output : ) ( max arg begin end Obviously, i y 1  X  (0, 1) and i y 2  X  (0, 1). From (27) and (29) we have: =( 1 x 1 + 2 x 1 +...+ m x 1 )*( 1 c + 2 And similarly, from (28) and (30), =( 1 x 2 + 2 x 2 +...+ m x 2 )*( 1 c + 2 where From (31) and (32), we can draw a conclusion that the value of l is just what we want. In general, P is a very large integer known to every party, but far less than the modulus in encryption. Such a design can well protect the privacy of the inputs. In this section, we discuss the security and efficiency of SPoS. The SLFE protocol acts as a com ponent of the SPoS protocol. We first evaluate the security of SL FE. Since it is a 2-party protocol, we need not consider the collusion problem. T HEOREM 2 ( Security of SLFE ) SLFE protocol is secure.
 Proof. The only number received from sender Alice is the cryptograph E pk ( c ). From the composition theorem, we treat the well-studied encryption as a secure component of SLFE protocol. Its security therefore does not need to be considered. Hence nothing about c is revealed from the value of E pk ( c ).  X  From theorem 1 (Composition Theorem), we can use SLFE to prove the security of SPoS by treating SLFE as a secure black-box component and without c onsidering its security. T
HEOREM 3 ( Security of SPoS ) SPoS protocol is fully private ((m-1)-private) where m is the number of parties.
 Proof. We need to prove that the set &lt;VIEW I  X  ( x ), OUT parties, I , that contain m -1 parties. Here, both OUT are the final result p . Without loss of generality, we only consider the case of I = [ m ]-{1}. In such a case, the view of I , VIEW becomes { 1  X  2 , 1  X  3 , ... , 1  X  m , 2  X  1 , 3  X  1 In the beginning, we consider the joint probability of 1 Pr( 1  X  2 , 2  X  1 ) = Pr( 1  X  2 = 1  X  + 1  X  2 (mod M ), 2  X  1 = the other hand, no matter what 1  X  2 is, 1  X  2 is uniform in [0, m  X  = 1  X  2 -1  X  2 2  X  is also uniform in [0, m 2 ). In summary, are independent and the joint distribution of ( 1  X  in [0, M )*[0, m 2 ). In the same way, ( 1  X  j , j  X  1 [0, m 2 ), for 2  X  j  X  m . Because all the 1  X  j independently for 2  X  j  X  m , ( 1  X  2 , 1  X  3 ,..., independent and the joint distribu tion of them is uniform in [0, M ) m-1 *[0, m 2 ) m-1 . Then we can say that the random variables (  X  Next we consider 1 p . Using equation (19), party I can compute the variables 2  X  2 , 3  X  3 , ..., m  X  m . Then party I can compute using (23). With equation (24), they can compute 1 p as: In conclusion, party I can simulate the view of I by drawing (  X  computing 1 p with (34).  X  outputs are known to other parties. So we can draw a conclusion that SPoS is still private even though the communication channel used in this protocol is unsecu re, by which the message between any two parties may be exposed to adversaries. The reason is that any coalition of m -1 parties holds all information communicated on the network, but nothing about the other party can be deduced by this coalition, unless the party reveals its local information. Compared with related works, the SPoS protocol has the following advantages. First, while the goal of SPoS is to compute the function of some secure summations, we do not compute these summations in the process of the protocol. Second, it satisfies full-privacy, i.e. nothing about a party is revealed even though all other parties collude. Third, this protocol is with respect to the case of m -party where m is any number larger than 1. If we consider the probing attacks like [27], our protocols seem to be vulnerable. For example, assu me that two parties, Alice and Bob, apply the SLFE protocol to compute a linear function over their data. In that case, if Alice sets  X  = 0, then Alice would know Bob X  X  private number  X  . In fact, our protocols do deal with such a problem because: (i) our protocols are based on the assumption of semi-honest with the exception of collusion. In other words, every party still follows the protocol properly. Hence they should not party 3 sets 3  X  = 0 to infer 1  X  3 . For party 1, the risk of revealing is that 1  X  3 may be computed using (13) and hence 1  X  is computed using (14) by party 3. However, since 3  X  = 0, party 3 also cannot infer 1  X  3 using the third equation of (13), even if party3 and party 2 collude; (iii) consider the privacy of party 3. If party 3 sets 0, then 3 p = 0, hence using (15) everyone knows that 3 since p = ( 1  X  + 2  X  + 3  X  ) ( 1  X  + 2  X  + 3  X  ). That means setting lead to the leakage of 3  X  . The procedure in our protocol includes many operations in which each party interacts with each other party. Since the number of the parties is m , the total cost is O ( m 2 ). The following theorem shows that the running time of th ese operations is just O ( m ), not O ( m because all parties perform these operations in parallel. T
HEOREM 4 m parties collaborate to achieve a process in which each party achieves the same operation with each other party. Suppose that the running time of such an operation is T and no party can achieve that operati on with more than one party simultaneously. The total cost is then m(m-1)T/2, and the running time is (m-1)T when m is even, mT when m is odd.
 Proof. In [19], Eric et al. introduced a strategy of the arrangement task described in this theorem. It was shown that such a strategy always exists. The conclusion of this theorem is always true.  X  For further details, please refer to [19]. In SPoS, the communications and the SLFE protocols are performed by each pair of two parties. By theorem 4, the running time of these operations is O ( m ). On the other hand, the amount of computations inside one party is proportional to m . Therefore, the the higher the level of security, the longer the running time. In some cases, full-privacy is unnecessary in practice. In fact, we can improve the efficiency of SRoS and SCoS by reducing the privacy requirement. For example, in the case of m =15 and t =2, we evenly divide all parties into t +1=3 rows as shown in Figure 2. Different from the protocols in the case of full-privacy in which each party generates one i c , in the case of t -privacy, all parties in i row share a unique random number i c , as shown in Figure 2. 
Figure 2. Arrangement of a 2-pri vate protocol in the case of Then all the parties in each column run the original SPoS protocol to compute the following values respectively: Publishing all p j s, every party can compute the summation of all p using the following equation: result p is just equal to ( 1 x + 2 x +...+ 15 x )( 1 c + times and deeming this procedure as SPoS protocol, the final results of the SRoS and SCoS can be computed as same as the original SRoS and SCoS. However it can be easily confirmed th at this protocol still satisfies t -parameters and the parallel com putation of (35), the running time reduces to just O ( t ). In other words, the running time is proportional time-consuming. In this section, we implemented the SPoS protocol to evaluate its efficiency. In our experiments, we used two machines to simulate all the tasks, and then calculated the running time of one party. The main scheme of our evaluation was simulating the tasks of party 1 in machine with the cooperation of the second machine. Since every party can perform the tasks in paralle l with the strategy described in [19], the above scheme is able to calculate the running time in a real environment. We realized our protocol in C++ using the implementation of large numbers in OpenSSL library. Our machines are similar to personal computers with Intel Pentium Core2 Duo CPU 2.67 GHz and 2.00 GB ram. We used a classical encryption system, the Paillier cryptosystem ([23]), to implement the SLFE protocol. The network environment in our experime nts was wireless LAN of IEEE802.11g/IEEE802.11b. All of our experiment results contain the communication time in such an environment. We implement our protocol in the cases of 2, 5, 10, 20, 50 and 100-party, and the cases of 512, 1024 and 2048 bits key, respectively. The correctness of the computation in the multi-party case is confirmed by the results computed locally. In term of the efficiency, running time of a computation of SPoS is a bout 0.769 seconds in the case of 10 parties and 1024 bits size key. From Figure 3, we can see that the running time is proportional to the number of parties if the key size is fixed. Figure 3. Number of parties (horizontal axis) vs. running time (vertical axis) in SPoS protocol . Blue points, red points and green points correspond to the ca ses where the key size is 512, We now compare the efficiency of Vaidya's method with ours by viewing the experiment result of both. Since the experiment in [28] was done under the environmen ts similar to ours, we can directly compare our result with theirs. The most time-consuming operation in Vaidya's is the last step of the secure-logarithm-based protocol, while other opera tions' computational time can be ignore, hence the time is almost not related to the number of parties. In other words, the effi ciency of that method is almost equal to the secure-logarithm-based protocol. However, the computational time of the secure -logarithm-based protocol is quite long. As mentioned in [28], one computation with the 1024 bits key takes about 3.54 seconds , whereas the co mputational time the same of Vaidya X  X , yet the security level our method achieves is much higher. Note that computing one secure ratio of summations needs two times of the SPoS protocol. If we reduce the security level of SPoS to 1-private with the method introduced in 6.3, the running time will be re duced to less than 0.2 seconds. The WAP protocol proposed in [16] contains two times of encryptions, two times of d ecryptions and two times of communications, which is similar to the 2-party case in our method. Thus the efficiencies of both methods are similar. Mert's OMP protocol is an extension of the WAP protocol. With OMP, each party runs the WAP protocol with the next party in order. Then the efficiency is similar to SPoS in the case of multi-party. Table 2. Comparison of Efficiency and Security of OMP (WAP), Vaidya's protocol, SPoS (2 times of executions) in the cases of 2-party, 5-party, 10-party, 20-party and 100-party We implement these related protocols, and compare them with SRoS protocol. Here WAP can be treated as 2-party case of OMP. Table 2 shows the comparison of OMP, WAP, Vaidya's method, and SRoS. In Table 2, the tim e row denotes the running time, while the privacy row denotes the level of t -privacy. As we mentioned earlier, the 2-party cas e of OMP is equal to WAP. Although the privacy levels of OMP are all 1 and we assume that no party will collude, there is still some privacy revealed in OMP. From Table 2, we note that SPoS is equal to OMP in term of efficiency, but with higher privacy. Moreover, although the SRoS is less efficient than Vaidya's me thod with large number of parties, if we decrease the security le vel to less than 20, SRoS will Vaidya's. 
Table 3. Comparison of Efficien cy of SPoS in the cases of 1-Our experiments evaluated the running time only in the case that our protocol satisfies ( m -1)-privacy. Now we also consider the case of t -privacy, where 1  X  t  X  m -1. We run SPoS protocol in the cases of 10-party and 20-party, and record the running time in the cases of 1-privacy, 4-privacy, 9-pr ivacy and 19-privacy in Table 3. From Table 3, we can get that the running time is related to only t , but not the number of parties. Moreover, the running time is proportional to t +1. This is because the computation of each (35) contains t +1 parties, and the computations of all parallel. In addition, the comput ation of (36) is only simple summation, which is not cons uming significant amount of computation time. Among all kinds of computations in SPoS protocol, encryption and communication are the most time-consuming operations. In our experiments, we also found th at the time of communication is quite short. In the full-privat e 10-party case, the communication time is only about 0.02 second. So we can say that the bottleneck of our protocols is not communication, but encryption. We must also note that SPoS is only an atomic operation, so the O ( m ) cost is for only one summation. For example, the time complexity of a k -Means protocol for one time iteration is O ( km ), experiments and comparing with th e related works, our protocols are practical and efficient in ma ny privacy-preserving data mining problems. In this paper we summed up a large number of problems in privacy-preserving data mining in to a formal problem, SPoS. We proposed a protocol to securely co mpute the value of that product. Our proposed protocol satisfies a high level of security -full-privacy. It therefore is more s ecure than other related methods. Our protocol is also an efficient one because its running time is proportional to the number of partie s. Moreover, its efficiency can be improved further if we reduce the level of security. In addition, a secure communication channel is unnecessary for our protocol because of its high security. Since the secure computation of functions on secure summations is a general issue in privacy-preserving data mining, our proposed protocol can be applied to solve many of the problems in this field. [1] Charu C.Aggarwal, and Philip S. Yu, Privacy-Preserving [2] J. Benaloh, Dense Probabilistic Encryption. In Proceedings [3] A. Ben-David, N. Nisan a nd B. Pinkas FairplayMP -A [4] Raymond T. Boute, (April 1992). "The Euclidean [5] Christopher M. Bishop, Pattern Recognition and Machine [6] B. Chor, M. Gereb-Graus, and E. Kushilevitz, On the [7] B. Chor, Y. Ishai, On Privacy and Partition Arguments, [8] I. Damg X rd, M. Jurik: A Ge neralisation, a Simplification [9] Y.Desmedt, J. Pieprzyk, R. Steinfeld, H. Wang: On secure [10] T. ElGamal, A Public-Key Cryptosystem and a Signature [11] O. Goldreich, Foundations of Cryptography: Volume 1, [12] O. Goldreich, Foundations of Cryptography: Volume 2, [13] O. Goldreich, S. Micali, A. Wigderson: How to play any [14] S. Goldwasser and S. Micali. Probabilistic Encryption. [15] M. Kantarcioglu and C. Clifton. Privacy-preserving [16] S. Jha, L. Kruger, and P. McDamiel, Privacy Preserving [17] Y. Lindell, B. Pinkas: Privacy preserving data mining. In [18] D. Malkhi, N. Nisan, B. Pinkas and Y. Sella, Fairplay -A [19] E. Mendelsohn and A. Rosa, One-factorizations of the [20] D. Naccache and J. Stern. A New Public Key [21] T. Okamoto and S. Uchiyama. A New Public Key [22] M. Ozarar and A. Ozgit, Secure Multiparty Overall Mean [23] P. Paillier, Public-Key Cryptosystems based on Composite [24] R. Rivest, A. Shamir; L. Adleman. A Method for [25] S. Urabe, J. Wang, E. K odama and T. Takata, A High [26] J. Vaidya, C. Clifton (2003) Privacy-preserving k-means [27] J. Vaidya, C. Clifton, Secure set intersection cardinality [28] J. Vaidya, M. Kantarc  X  oglu, C. Clifton: Privacy-preserving [29] A. C. Yao. How to generate a nd exchange secrets. In Proc. 
