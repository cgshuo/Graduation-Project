 The shortest-path problem is a routine graph problem in a variety of real-word applications, e.g,routing in a road network, routing/data harvesting in sensor networks[1]. It is often defined in terms of all-pairs shortest path, single-source shortest-path, and point-to-point shortest path. In practise,there is an industrial demand for computing point-to-point shortest path(P2P) on dynamic large-scale network such as road network whose edges are dynamic changed with the traffic condition, sensor network whose sensor m ay not work effectively. Given a graph G =( V,E ), a source node s  X  V , a terminal node t  X  V , and a list of changes  X G , e.g, edge deletions, edge insertions and edge weight updating, the dynamic shortest path algorithm is to compute the update shortest path from s to t in G  X   X G . We call an algorithm which handle only the edge insertion as incremental algorithm. The decremental algor ithm solves the edge deletion.

As discussed in [2], the traditional computation complexity analysis for the static algorithms is no longer suitable for the dynamic algorithms. It is clearly that the cost of a dynamic algorithm only depends on the update size in the computation. Using worst-case analysis analysis and a function with the size of problem input to express it is not informative. Instead, one can define an adaptive parameter | changed | , which captures the size of the changes in the input and output, to analysis the dynamic algorithms. This parameter indicates that the updating cost is inherent to the dynamic algorithm itself. An dynamic algorithm is said to be bound if its computation cost depends only on the size of | changed | , and not on the size of the entire input. i.e, it can be expressed by a function of | changed | . This paper, we define the set of nodes whose input value and output value change as | changed | .Weusetheparameter | AFF | to denote the number of nodes in | changed | and || AFF || to denote the number of edges incident on some nodes in | changed | .
 Contributions. In this paper we focus on dynamic point-to-point shortest-path problem(P2P) for directed graphs with positive edge weights. We provide effec-tive dynamic algorithms for unit update, i.e, a single-edge deletion or insertion, and bath updates, i.e, a list of edge deletions and insertions mixed together. We show that all the dynamic algorithms are bound. Using both real-life data and synthetic data, we experimentally evaluate the efficiency and scalability of our dynamic algorithms. We find that our dynamic algorithms perform significantly better than their static counterparts, even in worst case. When data graphs are changed up to 40%, our algorithms consistently outperform the static algorithm. Organization. Section 2 states the basic definition and data structure. The dynamic shortest-path problems for single-edge update and bath update are studied in section 3,4, respectively. Sect ion 5 represents experimental results. This paper ends with conclusion in Section 6.
 Related Work. There are some work concerni ng the dynamic shortest path problem. IEven [3] and Rohnert [4] presented algorithms for maintaining shortest paths on directed graphs with arbitrary real weights. Their algorithms required O( n 2 ) per edge insertion; Ramalingam and Reps [5], [2], Frigioni et al. [6], [7] introduced a batch dynamic shortest path algorithms with arbitrary real weights, they use the model that the running time of their algorithm is analyzed in terms of the output change rather than the input size, but they only handle the single edge update. As far as we know, there is no algorithm which the worst case is always better than recomputing the new solution from scratch.

There are some works on special case to compute the shortest path problem. [8] depicted an incremental shortest path algorithm for directed graphs with positive integer weights less than C: the amortized running time of their algo-rithm is O ( Cnlogn ) per edge insertion. [9] designed a fully dynamic algorithm with mortized time O ( n 9 / 7 log ( nC )) for all pair shortest path problem on planar graphs with integer weights. A fully dynamic algorithm for single-source shortest paths in planar directed graphs in O ( n 4 / 5 log 13 / 5 n ) mortized time per operation was presented in [10].

The existing method which related to ours is proposed in [5]. This paper proposed a fully-dynamic algorithm called SWSF-FP which handled the batch update at the same time. Our partial work batch update is closely to the SWSF-FP, but we maintain it on a special shortest path tree to reduce the unnecessary computation. 2.1 Problem Statement Let G =( V,E ) be a directed graph with a non-negative length function len : V  X  V  X  R + { X  X  ,where V is the vertex set, E  X  V  X  V istheedgeset.
 Let s ( t )  X  V be an arbitrary but fixed source(destination), ( v 1 ,v 2 , ...v s )bea shortest path from v 1 to v s . With dist ( v ) we denote the length of a shortest s  X  v  X  path in G for any v  X  V . i.e, dist [ v ] is the shortest distance from s to t .
Given a shortest-path P from s to v ,abatchupdate G to G , the dynamic shortest-path problem is to find the new shortest-path P from s to t without recomputing from the original graph. 2.2 Data Structure To avoid of recomputing the P from scratch, we introduce some auxiliary data structures.

The basic idea of finding new shortest path in dynamic graph is to store the single source shortest path graph( SP ), then update the SP to obtain the result. There is lots of unnecessary computation in the update process. To de-crease the redundant cost, we propose a new structure which is called adaptive shortest-path subgraph. Before we define the adaptive shortest-path subgraph, we introduce the concept of SSP edge: An edge in the graph is said to be an SSP edge iff it occurs on some shortest path from the source vertex s to the other Adaptive shortest-path subgraph are defined as followed: Definition 1. A subgraph T is said to be an adaptive shortest-paths subgraph for a given graph G with source node s if (1)for each v  X  V ( T ) , there is a path from s to v . (2)every edge in T is a SSP edge.
 We maintain a distance vector D containing d ( v ) for each node v in ASP ( G ). After each update, D has to be updated accordin gly. For every each vertex v  X  V ( G ), we use out [ x ] to denote the outgoing vertices of x , in [ x ]todenotethe ingoing vertices of x.

For each node v in ASP ( G ), we maintain a list pre [ v ] to denote the previous node of v in the shortest-path from s to v . (Considering the shortest-path be-tween two nodes is not unique, so pre [ v ] is a list.) Succ [ v ] represent the list of successor node of v .

As pointed out in section 1, instead of analyzing the cost of the dynamic algorithms in terms of the size of the entire input, we analyze them by the size of | changed | . The notion of affected areas is introduced to characterize changed . Affected Areas. Let G be the graph before the edge update, G be the graph after the edge update, ASP ( G ) be the adaptive shortest-path subgraph of G , ASP ( G ) be the new adaptive shortest-path subgraph of G .The Affecteareas of G by the edge update is the difference between ASP ( G )and ASP ( G ). We use | AFF | to denote the number of v ertices in Affected areas, || AFF || to denote the number of edge incident to the vertices in Affected Area. Example 1. Consider the weighted directed graph G shown in the left of Fig1.(a). Without loss of generality, we set 0 as the source node and 4 the destination node. The shortest-path from 0 to 4 is the indirect root 0  X  2  X  4. The right graph of Figure 1 depicts the adaptive shortest-path graph ASP ( G )of G and the left figure1 with dotted line part is the shortest-graph SP ( G )of G .Check the ASP(G) against SP ( G ), we obtain that the size of SP ( G ) is smaller than the size of SP ( G ).
 Proposition 1. Thesizeof ASP ( G ) is always less than or equal to the size of SP ( G ) .
 All the auxiliary structure are summarized in table 1.

The preconditions of the algorithm is in following: (1) ASP(G), which store all the shortest-path form s to vertex v which d [ v ]  X  d [ t ]. (2) A priority queue Q, a vertex v  X  Q if v  X  V ( ASP ( G )) and v [ Succ ]=  X  . In this section, we provide a bound incremental algorithm for single-edge inser-tions and a bound decremental algorithm fo r single-edge deletion. Furthermore, we analysis the complexity and prove the correctness of our algorithms. 3.1 Single-Edge Insertion The insertion of an edge from G may only reduce the shortest distance from the source vertex s to the terminal vertex t . That is, the insertion operate may only decrease the size of ASP ( G ). We denote those edges in graph G whose insertions may change the shortest-path as si edges. An inserted edge ( u, v )isa si edge if u  X  V ( ASP ( G )). one can verify the following: Proposition 2. Given a graph G and a shortest-path from the source node s to the terminal node t , only the insertions of si edge in G may reduce the shortest distance from s to t .
 Example 2. Recall the Example 1, if we insert an edge (2 , 1) with weight 3, which is not a si , the shortest path is not changed and the adaptive shortest path graph of the new graph G ASP ( G ) holds the line.
 Based on Proposition 1, we provide algorithm InsertEdge shown to compute the shortest-path from s to t when the edge e =( v ,v )isinsertedintoG.
 Algorithm 1. Procedure InsertEdge
In the first step, we insert the edge into the original graph G . Then we judge wether the edge e is a si edge. If not, return P and the ASP ( G ) is not changed. There are two situations when e  X  si : (1) the insertion of e indeed reduces the shortest distance from s to t . (2)the shortest path is remain P . In the first case, when update the ASP ( G ), we need to cut the node and edge whose dist is larger than dist [ v ]. In the other case, we need update the affected node the ASP ( G ). Anode v is an affected node when the update d [ v ] is less than original dist [ v ], these nodes may only appear in the subtree of v .
 Correctness and Complexity. When the inserted edge( v ,v ) affect the ASP ( G ), two kinds of node may be affected. One is the subtree nodes of v , the distance of this kind of nodes decrease, the other kinds is the nodes in sub-tree nodes of v in G \ ASP ( G ), this kind of nodes may be added into the ASP ( G ). Our algorithm traverse the outgoing edge of v, then relax these edges and update corresponding prev and Succ . This step we update the new distance of nodes in ASP ( G ) until its distance is larger than new d [ t ], also add the nodes who is not in the ASP ( G ) but update distance lower than d [ t ]. It ensures the correctness of updating ASP ( G ).
 Let L be the distance of P , L be the distance of P . The affected area of InsertEdge is shown in Fig1.(b): let  X  be the nodes in in smaller triangle, |  X  | be the number of  X  and ||  X  || be the number of edges related to nodes in  X  .This triangle includes the subtree nodes of v . The update of this area node takes O (  X  log  X  ) time to update. Denote the number of diagonal marked area as m , we need delete the node in this area from ASP(G). It takes O ( m ) time. The entire complexity of this algorithm is O ( m +  X  log  X  ). If the insertion edge did not change the shortest path, m =0.Let | AFF | = m +  X  , we can verify that this algorithm is bound by the affected nodes. 3.2 Single-Edge Deletion In contrast to edge insertions, the deletion of an edge may only increase the shortest distance from s to t . i.e, the old shortest-path from s to t may be not connected. We identify those edges in G whose deletions affect the shortest-path, referred to as sd edges, as follows. An edge ( u, v )in G is a sd edge for a shortest-path P if u  X  V ( P ) ,v  X  V ( P ). It suffices to consider sd edge for edge deletions: Proposition 3. Given a graph G and a shortest-path from the source node s to the destination node t , only the deletions of sd edge in G may increase the shortest distance from s to t .

After delete the edge in the shortest-path P ,wefirstcheckthe prev list from terminal vertex t . Going through the prev list, if the vertex s is reached, the algorithm return Path P , the shortest-path is not change. We only need to update the subtree rooted at v in ASP ( G ). If not, we have to find another shortest-path from G . According to the Proposition 2, we only need to extend the ASP ( G ) until we meet the vertex t . In the worst case, the path from s to t is not connected after the deletion operation. In this case, the ASP ( G )isequal to SP ( G ), that is to say, we have to compute all the shortest-path from single source s to the other vertex. In the process of updating ASP ( G ), firstly, we should identify the affected area. The aff ected area consists of vertices whose d [] Algorithm 2. Procedure DeleteEdge changes. We use a stack to find them. Suppose v is an affected node, we check the nodes in Succ [ v ] and put them into the stack. Then we handle them one by one. If the prev of node x in Succ [ v ] is empty after deleting v from prev [ x ], we add x into the affected area.
 Correctness and Complexity. According to the updated ASP(G), we can obtain the update shortest-path P . The process of the DeleteEdge algorithm ensures every path in the ASP(G) is a shortest-path, so, P is the shortest-path from s to t . The size of the affected vertices is the number of vertices in the smaller triangle and diagonal marked area in Fig1.(c)(edge deletion). We denote the number as | AFF | . The number of associate edge as || AFF || . We adopt Fibonacci heap to update the ASP(G), so the complexity of the algorithm is O ( | AFF | + || AFF || log || AFF || ). Given a series of edge operations + e 1 ,  X  e 2 ,  X  e 3 , + e 4 ,.. , + (  X  )representthe insertion(deletion) operation. It is cost when we update the shortest-path one by one because of the turbulence of the ASP(G).To avoid redundant computation and improve the efficiency of the update, We introduce a batch update algorithm for point-to-point shortest path problem.

The batch update algorithm is based on two principle. (1)remove redundant edge operation as much as possible. (2)handle multiple edge operations simulta-neously rather than one by one.
 Algorithm 3. Algorithm BatchUpdate
In algorithm BatchUpdate, the procedure MinDelta minimize the size of G by reducing the nodes who don X  X  affect the ASP ( G ). i,e, the inserted edges which are not si edges and the deleted edges which are not sa edges. When updating ASP ( G ), we use new [ v ] to store the tempt distance of shortest path from s to v .Letkey=min { d[v],new[v] } , the key value sort the sequence of nodes to be process. This order can set all the affected nodes on correct values. Theorem 1. In the Batch update algorithm, every affected vertices at most pro-cessed two times. Proof. When all the G are edge deletions, no ver tices can have shorter dis-tances. According to the algorithm, d [ v ] will be first assigned  X  and then back to its correct value. Therefore, the affect ed vertices are insert into heap and ex-tracted from heap twice. Similarly, when all the input updates are edge insertion, no vertices can have longer distances. d [ v ] is assigned his new [ v ] value and will not be processed again.Consequently, the affected vertices are processed only once.
 Correctness and Complexity. When the iteration procedure abort, all the ASP(G) are update correctly. L et AFF be the affected area nodes, | AFF | be the number of AFF and || AFF || be the affected edge a ssociated vertices in AFF . The complexity of our algorithm is O ( | AFF | + || AFF || log || AFF || ). In this section, we present an experimen tal study using both real-life and syn-thetic data, we conduct three sets of experiments to evaluate (1) the effectiveness of our algorithms compared to Dijikstra and DynamicDijikstr, (2)the efficiency and scalability of batch updates algorithms, (3) the performance and advantage of our algorithm compared to the scratch method and MFP [11] method. Experimental Setting. We used two real-life datasets to evaluate the effec-tiveness of our algorithms, and synthetic data to change graph characteristics, for an in-depth analysis. (1)Real-life data. Both of the real-life datasets come from websites. (a)The first is taken from website 1 , it describes the North American Road Network with 174k nodes and 179k edges and San Joaquin County road network with 18K nodes and 23k edges. Each road was represented by the nodeID and his location information, each edge wa s associated a float number denoting the distance of two nodes. We extract the North American Road network data snapshots based on the road location,each has 18k nodes and 20k edges. (b)the second datasets came from a crawled LiveJournal social network graph. With node denotes person and edge denotes friendship relation. The size of this datasets is 5M with 75knodes and 508k edges. We extract snapshots based on the age of people, each consisting of 20k nodes and 80k edges. (2)synthetic data. .We use a generator to produc e directed weight graph with two parameters, the number of nodes and the average degree. The parameter density denotes the density of edge in the graph.
 Implementation. We implemented the following in C++: (1)InsetEdge and DeleteEdge (2)BatchUpdate (3)the Dijkstra algorithm.(4)DynamicDijkstra [11]. (5)MFP.
 All experiments were executed on a ma chine with an Intel Pentium@2.93GHz CPU and 2GB of memory running Windows XP. Experimental Result 1.The Efficiency and Scalability of Single-Edge Update Algorithms We use real-life and synthetic data to evaluate the efficiency of our algorithms. If the source and terminal nodes were fixed, we select arbitrary an edge for 10 times to compute the average running time and the affected area.

Next we present our findings. Fig2.(a) shows the efficiency of our algorithms using real-life data. The data size is 20k and 175K. Both of these two cases, our algorithms perform better. This is because our unit algorithm save a lot of time recomputing the shortest path gra ph. The affected size represents the same character.

Figure2.(b) shows the scalability of our algorithms. We generate graph with fixed average degree 500. The size of graph vary 1K nodes to 20k nodes, each increases by 5k nodes. In contrast to the DynamicDijikstra algorithm, the Insert-Edge algorithms always perform good. Its average of the running time changes in a small range. In practise, when we insert an edge into a big graph, the prob-ability of the edge changing exiting shortest path is very small. Even in the shortest path changed case, the InsertEdge only need to compute a tiny subtree which was introduced in Fig1.(b), while the DynamicDijikstra have to update all the subtree in the entire shortest path graph. However, the procedure Dele-teEdge sometimes defeated by DynamicDijikstra algorithm. The reason for that is the worst case occurs or the updated d[t] far outweight the old d[t]. In the worst case, the DynamicDijikstra algorithms just update the subtree of node of the tailing deleted edge. But the DeleteEdge must extend the adaptive shortest path graph. Let L be the old shortest distance from source vertex to termi-nal vertex, L X  be the updated value. Consider the following situations: (1)L=L X , that is, the distance of shortest path do not change. (2)L X =  X  . i,e. there is no path from the source vertex to the end v ertex. We compare these two cases in Fig3.(a). | L  X  L | = 1 represents L X =  X  . In best case(L=L X ), InsertEdge algo-rithm has decisive advantage. While in the worst case, the DynamicDijikstra performs better.

We also study the effects of the graph density. We fix the graph size as 2k with average degree 100 and vary the average degree from 100 to 1000, separated by 200. It can be found in Fig3.(b) that dealing with dense graph need more time for Dijikstra algorithms, the dynamic al gorithms is affected little. In fact,the dense graph reduce the probability of worst case occurring. 2.The Efficiency and Scalability of Batch Update Algorithms We compare batch update algorithm with MFP in both real-life dataset and synthetic dataset. The change size set as 10% of the edge number. Every set-ting is implemented 10 times to obtain the average value. In most cases, the performance of BatchUpdate is superior to the MFP. The cause is the affected nodes that BatchUpdate update less than MFP in general case. However, in worst case, BatchUpdate needs some extra cost to extend the adaptive shortest graph to a single source shortest graph. The result shows the average time. We can see that algorithm BatchUpdate gains advantage over MFP and Dijikstra algorithms. The scalability of BatchUpdate is depicted in Fig4.(b),we set the size of graph as above described the scalability of unit update.The figure shows that our algorithms scale well.
 Finally, we change the size of  X G to present the adaptability of our algorithms. We increase the updating edge number by 10% percent of all edges number, from 10% to 50%.And the graph size is 2K nodes with average degree 100. The result is shown in Fig2.(c), the BatchUpdate algorithm perform well until 40% edges changed. This paper study the dynamic algorithms of Point-to-Point shortest path prob-lem. We propose a new method using Adaptive shortest path graph to reduce the size of update cost comparing to the single source shortest path problem.Using this method, we present the unit update and batch update algorithms. We state that all the algorithms are bound by the change of input and output size. Finally, we experimentally demonstrate our algorithms perform better than recompute the shortest path from static algorithm and the dynamic algorithm maintaining the shortest path graph. Unfortunately, There is no dynamic algorithm always performing better than recomputing fro m scratch. It is an open issue to deserve study.

