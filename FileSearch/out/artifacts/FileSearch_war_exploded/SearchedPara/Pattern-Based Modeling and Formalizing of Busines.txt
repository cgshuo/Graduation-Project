 One of the most important factors of the success and reputation of any business is the quality of products and services it provides. For this reason, quality management has become an important competitive factor that must be considered on all levels in-cluding business processes. In this context, many standards were developed for total quality management, aiming at fulfilling the requirements of customers and improv-ing the quality of products, as e.g. ISO 9001 re gulations and constr aints [1], which can be applied to any business. Quality constraints may be defined by producers or by customers. No matter who defines quality constraints, there must be a way to ensure that business processes satisfy them. However, since standard or user-defined quality constraints are usually documented as informal texts, it becomes difficult to prove their correctness, especially when business pro cesses are complex. One solution for this problem is automating the verification of quality constraints on business processes by using the technique of model checking. To apply this technique, both business processes and quality constraints have to be formalized. To achieve this goal, many approaches were developed, where each one depends on a d ifferent temporal logic to formalize quality constraints, in order to enhance and increase their expressiveness. However, the major problem is still that no approach allows to formalize user-defined quality constraints, which include a non-determin istic future, as e.g. formalizing a quality con-straint or a part of it which must not hold for all control flows in a business process, but for at least one control flow.
 Our goal in this paper is to overcome the expressiveness limitations concerning the branching logic, by allowing to formalize non-deterministic user-defined quality con-straints, and to make this formalization intuitively understandable for business process users. For this reason, we have investigated the formalization approaches, which are based on UML Activity Diagrams [3], since these diagrams are a widely used standard and are familiar to business process users. One of these approaches is developed in [2]. It models business processes as UML 2.0 Activity Diagrams, and quality constraints as business process patterns using the Proces s Pattern Specification Language (PPSL) [4], which is a light weight extension of UML Activity Diagrams. Both business processes and business process patterns are then written in a formal way by transforming UML 2.0 Activity Diagrams into labeled transition systems, and translating business pro-cess patterns into LTL-formulas [5]. This enables the automated verification of quality constraints on business processes by using a model checker to verify LTL formulas on labeled transition systems. However, the Linear Temporal Logic (LTL) does not support the non-deterministic future. To support this kind of future, we replace LTL by the Com-putation Tree Logic (CTL) [6]. To achieve that, we extend PPSL to a new visual model-ing language, Extended Process Pattern Sp ecification Language (EPPSL), which has a formally defined semantics given by a translation into CTL-formulas. EPPSL is a heavy weight extension of UML Activity Diagrams. In other words, EPPSL uses the elements of UML Activity Diagrams, which semantics can serve to model quality constraints. It also defines new classes of elements to cover the semantics of quality constraints which are not defined by UML Activity Diagrams. We a lso provide a pattern-based translation for EPPSL models into CTL-formulas. In the following section, we give an overview of the related work. In Section 3, we provide a scenario for verifying business process quality constraints. In Section 4, we describe the modeling elements of EPPSL and how to use them for composing EPPSL models. In Section 5, we explain how to translate EPPSL models into CTL-formulas. In Section 6, we provide a conclusion and outlook for our approach. Modeling and formalizing business process constraints in order to verify their correct-ness are considered in several approaches . For example, PPSL is introduced in [4] and translated in [2] into LTL formulas. In [7], the graphical Business Property Specifica-tion Language is used to capture business process compliance rules, which are trans-lated into LTL. In [8], DecSerFlow is mapped on LTL. DECLARE is defined in [9] and [10]. DECLARE models are also translated into LTL. BPMN-Q is developed in [11] to model requested compliance rules on business processes as queries. These queries are translated in [12] into PLTL [13][14] formulas. BPMN is used in [15] to check the semantic correctness of business process models by mapping them to Petri nets. In [16], the Object Constraint Language [17] expressions are used to refer to an integrated meta-model for different process models. In [18], process-independent compliance rules are specified using graph structures and formalized in terms of FOL [19]. All the previous approaches are not sufficient to express constraints, which contain a non-deterministic future and which have the degree of complexity required by users. But, in our approach, we define EPPSL which allows the users to build high complex shapes of quality con-straints and we support the non-deterministic fu ture by formalizing quality constraints as CTL-formulas. In [20], a lightweight, analyst-mediated approach introduces com-pliance patterns in terms of CTL as a heuristic basis for resolving the non compliance of process models, but it does not provide a way to map informal user-defined compli-ance rules into CTL-formulas. Additionally, expressing the non-deterministic future is limited to a set of structural and semantic patterns, which have a predefined shape of rules, but in our approach, we define EPPSL to enable modeling and formalizing quality constraints which can reach the complexity of CTL expressions. We assume that a company wants to hire new employees. The company has developed a business process to model the activities that must be carried out to accept or refuse applications. Fig. 1 shows the business process modeled as a UML Activity Diagram. To ensure the quality of this business process, some quality constraints may have to be checked on it, e.g. if a business analyst wants to know whether the lack of employees could result in accepting the appli cation, then the correctness of QC 1 must be checked (We use an abbreviation QC to refer to a quality constraint).

QC 1 : "It is always the case, that when the number of required employees has not yet been reached, then there exists a possibility to accept the application" .

By looking at the business process model, we see that it satisfies QC 1 , since whenever we encounter the Guard "the number of requi red employees has not yet been reached", there exists at least one control flow, on which this Guard is followed by the Action "accept the application" where in between other Actions may occu r and other Guards maybe be satisfied. However, verifying a te xtual quality constrai nt by looking at the business process model is prone to errors, especially when business processes become complex. In order to be able to verify QC 1 automatically on the business process model in Fig. 1 , we have to model QC 1 using specific patterns, which have a formally defined semantics given by a translation into temporal logic formulas.

The expression "there exists a possibility" in QC 1 states that the lack of employees enables the possibility of accepting the application, but does not enforce it. In other words, QC 1 states that accepting the application c ould be a non-deterministic future for the lack of employees. In order to have the ability to express this kind of future, it is not enough that we model QC 1 using specific patterns, which have a formally defined se-mantics given by a translation into temporal logic formulas, but also the temporal logic formulas should have the ability to e xpress a non-deterministic future.
 In this paper, we define a new modeling langua ge EPPSL, which provides the patterns required by the previous scenario, since these patterns have a formally defined seman-tics given by a translation into CTL-formulas. We specify EPPSL by a meta model which we provide in [21]. In the following section, we introduce how to model quality constraints with EPPSL. We model a quality constraint by modeling its basic blocks and its temporal and logical relationships. The basic blocks could be actions, guards, anonymous steps, and partial quality constraints. The temporal and logical relationships are based on the semantics of the temporal and logical relationships of CTL [6] to provide the ability to express both deterministic and non-deterministic futures. In the following, we explain the semantics of both basic blocks and relationships and how to model them. 4.1 Modeling Basic Blocks A quality constraint may include a mixture of the following basic blocks: Actions: An action is an activity which is carried out by the system, the customer or any other entity in the business process. For example, QC 1 consists of the action "accept the application". The start of a business process and the end of a control flow in a business process are also considered to be actions. EPPSL uses the modeling elements "Action" (Fig. 2.a), "InitialNode" (Fig. 2.b), and "ActivityFinalNode" (Fig. 2.c) to model actions, the start of a business process, and the end of a control flow in a business process, respectively.
 Guards: A guard is a condition which can be false or true. For example, QC 1 consists of the Guard "the number of required employees has not yet been reached". EPPSL uses the modeling element "Guard" (Fig. 2.d) to model guards.
 Anonymous steps: A quality constraint may refer to an anonymous step which could be an unknown action or an unknown guard. For example, a quality constraint might be dedicated to ensure that the business process model in Fig. 1 includes a possibility to accept the application after 6 steps from sta rting the process without any need to know to which actions or guards these steps are re ferring. Quality constr aints which counts anonymous steps are useful if the number of steps refers e.g. to the time consumed or the money paid to perform these steps, or if it plays a role in the satisfaction of the customer. For this reason, we introduce in EPPSL a modeling element called "AnonymousStep" (Fig. 2.e).
 Partial quality constraints: A partial quality constraint is a quality constraint which is linked to other partial quality constraint(s) with a logical relationship to build another quality constraint. We use the concept of the partial quality constraint, since we need sometimes to model a quality constraint which consists of several quality constraints that are logically related, but temporally not related. For example, a quality constraint might be dedicated to ensure that if the business process model in Fig. 1 includes a possibility to make an interview, then it includes no possibility to accept the application online. The first possibility is not temporally related to the second one. However, they are logically related, since the first possibility implies the negation of the second one. We model partial quality constraints as separated units. For this reason, we provide in EPPSL a modeling element called "ConstraintContainer" (Fig. 2.f) which is dedicated to contain a partial quality constraint model separating it temporally from other partial quality constraint models.

The elements in Fig. 2.a, Fig. 2.b, Fig. 2.c, and Fig. 2.d are the same elements used by UML 2.0 Activity Diagrams to model Actions, InitialNodes, ActivityFinalNodes, and Guards. The elements in Fig. 2.e and Fig. 2.f are new classes defined by EPPSL.
EPPSL models for quality constraints provide the ability to link the modeling ele-ments of the basic blocks with temporal and logical relationships. In the following, we introduce how EPPSL can model these relationships. 4.2 Modeling Temporal Relationships A temporal relationship determines the order of actions, guards, and anonymous steps. For example, QC 2 , which we want to verify on the business process model in Fig. 1, consists of a temporal relationship "After":
QC 2 : "After checking the application data, the qualifications of the applicant are considered to be either sufficient or not sufficient" .

The temporal relationship in QC 2 states that the action "ch eck the application data" must be followed by one of the guards "qualifications are not sufficient", or "qualifica-tions are sufficient".
 EPPSL provides a set of modeling elements to express temporal relationships. Since EPPSL considers deterministic and non-dete rministic futures, it provides for each tem-poral relationship two modeling elements. The first one represents the relationship when it holds for all control flows of a business process (deterministic). The second one repre-sents the relationship when it holds for at least one control flow (non-deterministic). Fig. 3 shows the notation of EPPSL modeling elements for temporal relationships. These el-ements are new classes defined by EPPSL.
 Deterministic Temporal Relationships: The deterministic temporal relationships are "Next", "After", "Until", and "All". "Next" and "After" may link two basic blocks, which could be "Actions", "Guards" or "AnonymousSteps". "Next" states that the first block must be followed next by the second block on all control flows of a business process. "After" states that the first block must be followed by the second block on all control flows of the business process, no matter if other blocks occur between the first and the second block. "Until" connects two ba sic blocks, which could be two "Actions", or an "Action" and a "Guard". "Until" states that an action must be repeated on all con-trol flows of a business process until another action takes place or a guard is satisfied. "All" refers to all instances of an action on all control flows of a business process. "All" is usually used to confirm that a quality constraint which includes an action, to which the temporal relationship "All" is applied, must hold for all instances of that action on all control flows of a business process.

For example, we want to verify QC 3 on a business process model for using a bank card to withdraw money.

QC 3 : "The pin number must always be entered repeatedly until the pin number is correct" .

The EPPSL model in Fig. 4 models QC 3 . It states that all instances of the action "enter the pin number" must be repeated on all control flows of the business process until the guard "pin number is correct" is satisfied. In this model, we have applied an "All" temporal relationship on the action "enter the pin number", since the word "always" in QC 3 states that the temporal relationship "Until" must hold for all instances of the action "enter the pin number".
 Non-Deterministic Temporal Relationships: The non-deterministic temporal rela-tionships are "PossiblyNext", "PossiblyAfter", "PossiblyUntil", and "PossiblyAll". These relationships have the same semantics of "Next", "After", "Until", and "All" re-spectively with one different aspect that they must not hold for all control flows of a business process, but for at least one control flow. For example, we want to verify QC 4 on the business process model in Fig. 1.

QC 4 : "There exists a possibility after starting the proces s to check the application data which is possibly followed by making an interview" .

The EPPSL model in Fig. 5 models QC 4 . It states that there exists at least one control flow on which starting the process is followe d by checking the application data which is followed on at least one control flow by making an interview.
 4.3 Modeling Logical Relationships A logical relationship may link actions, guards, and partial quality constraints. For ex-ample, QC 2 consists of a logical relationship "Or" which combines two guards and states that either the first guard "qualifications are sufficient" or the second one "quali-fications are not sufficient" must follow t he action "check the application data". EPPSL provides the following set of modeling elements to express logical relationships, which may link Actions, Guards, and ConstraintContainers:  X  Join/ForkNode: is used to model the logical relationship "And". "Join/ForkNodes"  X  Decision/MergeNode: is used to model the logical relationship "Or". "Decision/  X  X ot: is used to model the "Not" logical operator. "Not" can be applied to Actions,  X  Connector: is used to model the "Imply" logical relationship. Connectors can link Fig. 6 shows the notation of the EPPSL modeling elements for logical relationships. The "Join/ForkNodes" and "Decision/MergeNodes" are the same control nodes used by UML 2.0 Activity Diagrams. The "Not" and "Connector" elements are new classes defined by EPPSL.

To give an example for using the logical relationships modeling elements, we assume that we want to verify QC 5 on the business process model in Fig. 1.

QC 5 : "If there exists a possibility to make an interview, then there exists no possibility to accept the applic ation online" .

The EPPSL model in Fig. 7 models QC 5 . It includes two EPPSL models for two par-tial quality constraints, which are temporally not related. This means that each one of them must be checked separately on the business process. For this reason, we separate each one in a ConstraintContainer. The first model states that there exists a possibility to make an interview after starting the process. The second model states that there exists no possibility to accept the application online after starting the process. The Constraint-Containers are linked with a Connector, which means that the partial quality constraint represented by the first model must imply the partial quality constraint represented by the second model.
 The Computation Tree Logic (CTL) [6] views the time as a tree. It considers all different paths, allowing the future to be non-deterministic. CTL-formulas are based on a set of atomic propositions (statements which truth value may change over time), logical connectives (  X  ,  X  ,  X  ,  X  ), temporal operators ( X :Next, F : Eventually, U : Until, G : Globally), and path quantifiers ( A : On all paths, E : On at least one path). Whenever there is a temporal operator in a CTL-form ula, a path quantifier must precede it. For example, if  X  is an atomic proposition, then AX  X  is a CTL-formula, which states that, On all paths,  X  holds next.

In order to formalize quality constraints, we translate their EPPSL models into CTL-formulas. Here, we differentiate between two kinds of models depending on the number of control nodes they contain. Models which contain at most one control node are sim-ple models. Models which contain more than one control node are complex models.
When we translate a simple or a complex m odel into a CTL-formula, we translate the basic blocks: Actions, Guards, InitialNodes, and ActivityFinalNodes into the atomic propositions: Actions labels, Guards texts, " Start", and "End" respectively. However, the strategy for constructing the CTL-formula for a simple model differs from the strat-egy for constructing it for a complex model. In the following, we explain the different strategies. 5.1 The Translation Strategy for Simple Models The translation of simple models depends on analyzing them to specific EPPSL pat-terns, for which we provide a translation into CTL-formulas [21]. These patterns enable all required combinations of EPPSL modeling elements, in order to cover all possible semantics of quality constraints when the model contains at most one control node. For example, we want to formalize QC 6 which has to be verified on the business process model in Fig. 1:
QC 6 : "It is always true that checking the application data might be followed by re-fusing the application, which is followed next by removing the application data from the system" .
 First, we model QC 6 with EPPSL (see Fig. 8), then we translate the model into a CTL-formula by comparing it to the EPPSL patterns given by the translation tables, which we provide in [21].

Due to lack of space, we show in Fig. 9 only a part of the translation tables ded-icated for simple models, where S represents an EPPSL pattern, which is attached to the element preceding S ,and S  X  refers to the CTL-formula, to which S is translated. C represents a partial quality constraint model, and C  X  refers to the CTL-formula, to which C is translated. M represents an EPPSL modeling element, and M  X  refers to the CTL-formula, to which M is translated.

We can translate simple models from right to left or left to right. Here e.g., we trans-late the model of QC 6 from right to left as explained by Fig. 10. In Step 1, we translate the Action "remove the appli cation data from the system" to an atomic proposition rep-resented by the Action label. In Steps 2, 3, 4, and 5, we divide the model into EPPSL patterns provided by the translation table in Fig. 9. This enables us to translate each pattern separately, until we reach the CTL-fo rmula, which represents the whole model in Step 5. 5.2 The Translation Strategies for Complex Models Logical relationships may link actions and guards, or may link partial quality constraints with respect to the basic assumptions defined in [21]. For this purpose, we define two different translation strategies for complex models. The first one is used when more than one control node link Actions and Guards (e.g. the model in Fig. 11), and the second one is used when more than one control node link ConstraintContainers (e.g. the model in Fig. 13).

Strategy 1: Given an EPPSL complex model, e.g. the complex model of QC 7 in Fig. 11, which we want to verify on the business process model in Fig. 1:
QC 7 : "Receiving an application is always follo wed by making an interview or refus-ing the application and remove the application data from the system" .

We translate the model in Fig. 11 by applying the following steps: 1. We divide the model into levels numbering them in the opposite direction of the 2. We assign a variable name to each temporal relationship followed and preceded 3. When a control node is preceded directly only by a variable with no assigned value 4. When a control node is followed directly only by a variable with no assigned value 5. We translate the control nodes of the model if they are yet not translated starting Strategy 2: Given an EPPSL complex model, e.g. the complex model of QC 8 in Fig. 13, which we want to verify on the business process model in Fig. 1:
QC 8 : "If there exists a possibility to make an interview, then there exists no possibility to accept the application onlin e and there exists a possibility to make an interview per phone or there exists a possibility to ma ke an interview per Internet" .

We translate the model in Fig. 13 by applying the following steps: 1. Each control node may have either multip le incoming connectors or multiple out-2. We start to translate the partial quality constraint models which do not include 3. We translate the partial quality constraint models which contain ConstraintContain-4. We always reach a state, where we have tw o ConstraintContaine rs, including two In this paper, we have introduced a new approach for modeling and formalizing busi-ness process quality constraints aiming at providing the users with more flexibility by allowing them to construct constraints with either deterministic or non-deterministic future and by that to enhance the expressi veness ability. Our approach introduces the Extended Process Pattern Specification Language (EPPSL), which is a heavy weight extension of UML Activity Diagrams, and could be easily transformed to be based on any other business process modeling la nguage. EPPSL provides a set of intuitively understandable modeling eleme nts to model quality constraints in terms of branching temporal logic. We also provide a pattern-based translation for EPPSL models into CTL-formulas to achieve the formalization of quality constraints. In our approach, the basic blocks of quality constraints are based only on actions and guards, since these blocks could be actions, guards, anon ymous steps (refer to unknown actions or un-known guards), and partial quality constraints (based on the previous three blocks). Later, other basic blocks could be considered, e.g. data objects. In our approach, we only consider future temporal relationships. Past temporal relationships and real-time relationships are open for future work. In our approach, we do not consider the iden-tification of conflicting constraints, which may contain contradicting semantics. Later, this aspect could be considered.

