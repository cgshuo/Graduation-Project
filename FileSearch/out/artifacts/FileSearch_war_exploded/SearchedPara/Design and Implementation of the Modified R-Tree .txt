
Myungkeun Kim 1 , Sanghun Eo 1 , Seokkyu Jang 1 , Jaedong Lee 2 , and Haeyoung Bae 3 The advance in wireless networks and in positioning systems has led to the emergence of location-based services (LBS). LBS support useful and convenient services based on the user's location such as emergency service, driving direction, and buddy finding. subscribers is continuously moving and sends queries via wireless communication. number of moving user and process the location based query in real-time manner [13, 14]. To index massive moving objects, R-tree structure [4] may be used. However, traditional R-tree structure suffers from poor performance since the query processing change. 
During the last decade, a number of index methods, which modified the basic struc-ture of R-Tree, have been proposed to maximize the concurrent efficiency of updating improve the query performance by using the lock minimally or by linking the sibling nodes like Rlink-tree. In highly concurrent environments, those index methods are not suitable for indexing moving objects since the query processing is frequently blocked even they have tried to minimize the blocking probability. 
In this paper, the modified R-tree structure using  X  X he instant versioning technique X  version for compensating the data intactness. Unlike the traditional versioning tech-original data only until the creation of new version is done. That is, the original data is remained intact not for further operations but for operations that are currently access-ing it. According to the instant versioning technique, an entry or a node is versioned. The proposed technique make lock-free sear ch operations by reading old version even during the modification of an entry or a node. 
The remainder of this paper is organized as follows. Section 2 describes related works and section 3 describes the proposed concurrency technique. Section 4 presents consistency, section 5 proves that the proposed index is the deadlock-free, and Sec-tion 6 presents experiments compared to Rl ink-tree. Finally section 7 makes a conclu-sion. In this section we present a problem of concurrent operations in the R-Tree. And we e xplain how the previous techniques solve this problem. Fig. 1 presents the problem of wrong path. 
In Fig. 1, let X  X  assume that o 1 is a search operation that is waiting for acquiring lock lock on node n 2 after node-split finishes, it only searches the half of n 2 since the other half of n 2 has been moved to n 3 by o 2 . 
The previous concurrency control techniques are classified into the pessimistic so-lution [2, 9] and the optimistic solution [6, 7, 12] to solve the problem of wrong path. solution allows the problem of wrong path but it corrects the wrong path by applying some special action. The representative technique of the pessimistic solution is the lock-coupling [2, 9]. When descending the tree a lock on a parent node can only be released after the lock on the child node is granted, also when ascending the tree (node-splits or region propagation) locks on ancestor nodes should be held until ascending step is termi-nated. This technique decreases concurrent efficiency since minimum of two nodes are kept locked at a time. The optimistic solution needs special method to correct the technique for the optimistic technique is Rlink-tree [6]. Rlink-tree uses LSN (Logical path by maintaining the link between sibling nodes. LSN is in charge of same roles as the maximum key of Blink-tree [10] due to the fact that R-Tree has the property that the entries of nodes are not linearly ordered. Each entry in a non-leaf node consists of node, a process moves right via sibling link until the node having the expected LSN is found, is carried out. 
All of the previous works have the same drawback that search processing should be blocked since they use the lock-based technique. They require the shared mode the lock-based technique cannot be avoided. This paper proposes the version-based technique which enables the search operation to progress without blocking it. This section describes the concept of the instant versioning technique, and introduces the modified structure of R-Tree, called R ver -Tree, for applying the instant versioning cusses the reclamation of garbage space due to the instant versioning technique. 3.1 Instant Versioning Technique The traditional versioning technique is designed for record manager. This approach can make read-only transaction non-blocki ng by reading suitable record among mul-tiple versions. From indexing point of view, keeping multiple versions is unnecessary since index operations have to get only the latest versions. 
Let f(x) be a function that chooses a latest version among the set of derived versions { a not done yet, the function f(x) chooses a n . This simple rule can make search operation access data without any locking even when data is being physically modified. Let X  X  assume that a n is a non-leaf node and it is being split. Node-split does not physically modify a n , rather makes a new version a n+1 . Search operation can traverse sub-tree of a entry. In order to implement the instant versioning technique, the linked list style is used. non-latest versions. To add additional link pointers, the traditional R-Tree structure is extended. 
First, the entry structure is extended by adding two pointers for linking between sibling entries. Each entry in a node consists of a key rectangle, a pointer to the child pointer nxtFree to the next sibling free entry. Also, the node structure is extended by adding two pointers, fstActive and fstFree , for completing the instant entry versioning. fstActive is a pointer that points to the first among the active entries. And fstFree is a pointer that points to the first among the unused entry. Search operations initially take new entry from fstFree . 
Second, the node structure does not need additional pointers for applying the in-stant node versioning technique since nodes in the tree are already linked between unlike the traditional splitting (that only creates one new node), then entries of n 2 are tree of n 2 without any locking and latching. However, if insert operation is waiting for This is the problem of wrong path as mentioned above in the related works. In order to solve this problem, the basic node structure of R ver -tree is extended as described in the following paragraph. of R ver -tree. The variables are used to solve the problem of wrong path. That is, opera-wrong path. v is marked during the split process, and it indicates the fact that the node is versioned. If a version bit v of visiting node is true, update operations can judge that the node has been split by another operation while they were waiting. p 1 , p 2 are point-ers that point to the two new nodes derived from the original node. 
If the visiting node is a versioned node, a process moves right via version pointers until meeting the latest nodes. Fig. 5 presents the scenario to correct the wrong path. These pointers may point to another versioned node since the non-versioned node that was derived from versioned node can still be versioned again by subsequent splits, but continued moving via version pointers can guarantee that non-versioned nodes (latest nodes) are found. 3.2 Internal Operations R try, and search operation. They are limited to a node. 
Insertion and deletion of entry are very simple. A new entry, allocated from the free link, is appended to the end of the active link. It is linked only after it becomes consis-entry is done by unlinking from the active link. In Fig. 6 (b), an entry e 2 is deleted by link of e 2 should not be cut because of search operations that are accessing e 2 . If it is still accessing it. In order to simplify the procedure of internal operations, this issue is discussed in subsection 3.4. 
Entry modification is a combination of the insertion and deletion of entry. It should be atomically done since search operations could access both entries, the original entry and the entry derived from the original entry. Fig 6 (c) describes modification of Especially, when splitting a node according to the instant node versioning, entry also done in the same manner. 
Internal search operations visit entries by taking nxtActive . They do not require any locking and latching due to the atomic linking of internal update operations. 3.3 External Operations This subsection describes external operations such as search and insert operation. These operations are interactively invoked by the external component above the in-dex, such as  X  X ursor X . In this subsection, delete operation is not described since it is a combination of the search and insert operation. Deletion of empty node is discussed in subsection 3.4. 3.3.1 The Search Operation Search operation finds all entries that belong in the range of query condition. Search-ing starts by pushing the root node pointer to the stack. The stack is used to remember voked search operation. In next time, findNext procedure is invoked with the returned empty. 3.3.2 The Insert Operation down the tree. The second step inserts the new key to the found leaf node, and the last cases: when the region of node has changed or a node should be split due to the lack of space. 
When descending the tree the visited nodes are pushed to the stack. Its saved path node is maybe found since the insert operation does not use lock-coupling to heighten concurrent execution. That is, the child node could be split by another insert operation after taking the child node pointer from its parent node. In this case, the non-pointers points to each derived nodes that have been created due to node-split, so that process finds non-versioned node leading to geometrically optimal node, it is pushed to the stack. Finally, only non-versioned nodes are in turn pushed to the stack, and if a process reaches to a leaf node, it returns. 
If there is space to insert the new key to the found leaf node, it is simply inserted. If region of the node is changed due to the key insertion, the region propagation occurs until the region of ancestor nodes do not need to be changed any more. It may meet a versioned node during the region propagation. However, this case is little different to the wrong path correction of the descending step. The descending step fixes the path by finding a geometrically optimal node among all non-versioned nodes that have been derived from the versioned node. That is, all non-versioned nodes derived from the versioned node should be visited. But the ascending step only moves right via sponding child node, is found. 
A node is split if there is no space to insert the new key to the leaf node. Unlike the pensating its intactness. Finally, the pointers of newly created two nodes are reflected on parent node. If there is no space to insert them in the parent node, the split process moves up to its parent node again. 3.4 Space Reclamation reclaim garbage space and who collects it. In order to implement the timestamp, a logical version number is used. 
The versioned entries are not returned to system, but they are reused by internal update operations. Each node keeps a logical entry version number ( levn ) in its header section. When versioning an entry, levn is increased and the new value is assigned to the versioned entry. The internal operations memorize levn before they visit the node. If levn of the versioned entry is smaller or equal to the smallest one among the inter-nal operations that are currently visiting the node, the versioned entry can be reused. tree globally keeps another logical version number, a logical node version number ( lnvn ), and the external operations memorize lnvn before they start. When versioning the node. Garbage collector is activated on a regular basis, and pops a node from the active external operations, it is returned to system. 
Actually, the space reclamation does not require heavy overhead since the ver-sioned entries are reused and the versioned nodes are reclaimed by an independent process without disturbing the normal operations. This section discusses the phantom problem that is a common requirement of data-base systems. It is difficult to avoid the phantom problem by index itself. One simple way to avoid the phantom problem is to hold the lock on every node (leaf nodes and non-leaf nodes) that search operations visit until transaction finishes. However the concurrent execution is severely decreased. Rlink-tree introduces a simplified form of predicate locks [3], where exclusive pred icates consist of a single rectangle and shared predicates consist of query range. Insert operations check shared predicates shared predicate is released. The main advant age of the predicate locking is to isolate the concurrency technique on index from the phantom problem. That is, when an the tree without considering the phantom problem. The predicate locking could be employed with R ver -tree. However, it does not utilize the advantage of this paper, i.e. non-blocking search operation, since search operations could be blocked before enter-ing to the index by the predicate locking. 
A more effective solution for R ver -tree is to cooperate with the multi-version record manager. Read transaction gets a candidate object qualifying their search condition transaction, it is ignored since the candidat e object was created after read transaction has installed, and the next candidate object is got from the index. This approach needs to consider a delete operation on index. If a key is deleted after search operation scan the tree, the number of objects got from rescan operation is maybe smaller than that of previous scan. So, the key deletion is not done by the current delete transaction, but it pendent process that reclaims garbage reco rds. When reclaiming the garbage records the corresponding keys are deleted from the index. In this section, R ver -tree proves itself to be deadlock-f ree. Deadlock occurs when there sub-functions, it is shown that R ver -tree does not make a cycle. 
Fig. 11 shows the locking sequence of sub-functions of the external insert opera-locks of two nodes at a time, external search operation does not acquire any lock, and external delete operation uses the same functions in external insert operation. The dot line indicates to release the lock on the visiting node before requiring the lock on next node. And the solid line indicates to use lo ck-coupling. Deadlock can occurs only when the solid line is crossed. As shown in Fig 11, the solid line is never crossed. This section proves the excellence of this technique through comparison to Rlink-tree. It explains experimental environment, and estimates the proposed technique by in-creasing insert and search process. 6.1 Experimental Environment database management system. GMS run on Solaris equipped with 8 CPUs of 1.2GHz and main memory of 1G bytes. 
The size of node is 4K. The fan-out of non-leaf node and leaf node is each 98 and 81 for Rlink-tree, 89 and 75 for R ver -tree. This experiment does not consider the phan-tom problem since Rlink-tree does not mention in detail. And the quadratic split algo-rithm is applied to both indexes. 20000 X 20000 area. It was equally distributed in total domain area. In actual experi-ments, each insert process inserts objects with size of 10x10 randomly extracted from and insert operation is estimated by dynamically increasing the number of insert and search process. 6.2 Experimental Results Fig. 11 and Fig. 12 are the results of estimating response times and throughputs by inc reasing number of insert processes to measure insert-workload. It shows that R ver -tree has slightly bad performance even though it tries to improve the concurrent efficiency of the update operations. This is due to the fact that R ver -tree is more split than Rlink-t ree since the fan-out of R ver -tree is smaller than Rlink-tree. That is, the overhead cause d by correction of wrong path or blocking due to node-split, is increased. 
Fig. 13, Fig. 14, Fig. 15, and Fig. 16 are the results of estimating average response times and throughput of search operations by increasing search operations under the low-contention (4 insert processes) and high-contention (20 insert processes). R ver -tree is showing better performance than Rlink-tree under the low-contention as shown in Fig. 12 and Fig. 13. This is due to the fact that search operations of R ver -tree trav-erse the tree without any locking. In contrast, those of Rlink-tree are blocked by con-current insert operations. The difference in performance of both indexes is more se-vere under the high-contention. Rlink-tree is getting worse as contention is increased. low-contention and high-contention. Consequently, response times of R ver -tree is shown within expected time even though the contention is increased since search operations of R ver -tree do not require any locking or latching. This paper has designed the modified R-Tree structure with lock-free querying, and implements it on existing spatial database management system. In order to achieve the goal, the instant versioning technique is introduced. This technique has not physically modified data, but rather new version has been created for compensating data intact-old version. This approach has made garbage data due to compensating action, but the been executed by an independent process. Experiments have shown better perform-ance in search operation at least twice as fast as compared to Rlink-tree. 
The further work for this paper is the study of recovery. The reclamation of gar-bage nodes are executed independently of transactions. If system is crashed after committed. 
