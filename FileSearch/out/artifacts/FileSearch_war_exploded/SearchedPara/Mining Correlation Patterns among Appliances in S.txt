 house appliances can be collected easily. In particular, an increasing number of smart power meters, which facilitates data collection of appliance usage, have been dep-loyed. With the usage data, residents could supposedly visualize how the appliances are used. Nonetheless, with an anticipated huge amount of appliance usage data, sub-algorithms to discover appliance usage patterns in order to make representative usage behavior of appliances explicit. Appliance usage patterns not only help users to better understand how they use the appliances at home but also detect abnormal usages of appliances. Moreover, it facilitates appliance manufacturers to design intelligent con-trol of smart appliances. 
Most prior studies focus on knowledge ex traction for a single appliance instead of the correlation among appliances in a house. In our daily life, we usually use dif-The correlation among the usage of some appliances can provide valuable information to assist residents better understand how they use appliances. pliances, which undoubtedly is more complex and arduous than mining the usage patterns of an appliance alone, and thus requires new mining techniques. In this paper, a new framework fundamentally different from previous work is proposed to discover the usage correlation patterns. 
The contributions of our work are as follows: (1) We define the notion of correlation pattern based on time interval-based sequence including probability concept. Since the turn-off ), interval-based sequences can depict users X  daily behaviors unambiguously. (2) The relation between any two usage intervals is intrinsically complex which may lead to more candidate sequences and heavier workload for computation. We propose a me-thod, called usage representation , to simplify the processing of complex relations among intervals by considering the global information of intervals in the sequence. (3) CoPMiner ), to capture the usage patterns implying the correlations among appliances with several optimized techniques to reduce the search space effectively. (4) The reada-obstacle for users to understand their actual behaviors. A spatial constraint is introduced to prune off non-promising correlation and reduce the number of generated correlation CoPMiner on a real dataset and analyze the results to show the discovered patterns are not just an anecdote. 
The rest of the paper is organized as follows. Sections 2 and 3 provide the related works and preliminaries, respectively. Section 4 introduces the proposed CoPMiner algorithm. Section 5 reports the experimental results in a performance study, and finally Section 6 concludes the paper. In this section, we discuss some previous works extracted useful knowledge and pat-appliance recognition [2, 5, 7, 10, 18]. Suzuki et al. [18] use a new NIALM technique use a dynamic Bayesian network and filter to disaggregate the data online. Kim et al. [11] investigate the effectiveness of several unsupervised disaggregation methods on low frequency power measurements collected in real homes. They also propose a et al. [6] explore an unsupervised approach to determine the number of appliances in the household, including their power consumption and state, at any given moment. Chen et al. [3] disaggregate utility consumption from smart meters into specific usage for disaggregation on coarse granular smart meter readings by modeling fixture cha-racteristic, household behavior, and activity co rrelations. Ito et al. [7] extract features appliance recognition, Kato et al. [10] use Principal Component Analysis to extract features from electric signals and classify them using Support Vector Machine. Arito-representative behaviors. Based on these two types of patterns, an intelligent system, anomaly detection from sensor data in a smart home. All aforementioned studies fo-appliances in a house. In this paper, we propose a mining algorithm to extract patterns including correlation among appliances and probability concept. spaced location and time points based on natural numbering N . A function, Loc : A  X  N o  X  ( a 1 , o 1 , f 1 ), ( a 2 , o 2 , f 2 ), ..., ( a n , o n , f n ) rior location of appliance a i in a smart home environment. r }, each record r i , where 1  X  i  X  m , consists of a date, a usage-interval and an interior with the same date are grouped together and ordered by nondecreasing turn-on time, turn-off time and appliance symbol, actually, DB can be transformed into a collection of daily usage-interval sequences. Note that the location information can be viewed as intervals and 4 daily usage-interval sequences. Definition 3 (Usage-point and usage sequence). Given a usage-interval sequence Q =  X  t . T Q is called a time sequence corresponding to Q . A function  X  that maps a usage in Fig. 2, the database collects 4 daily usage-interval sequences. The usage sequence are two pointsets because they occur at the same time, respectively. f tion of Q is defined as a pair, as an example. Without leading into ambigu ity, we consider the turn-on and turn-off times by hour. The usage representation of DB is shown in the last column in Fig. 2. For the rest of this paper, we assume the usage database has already been transformed into usage representation. S x . Given a usage-interval database DB in usage representation, the tuple ( date , S , T )  X  DB is said to contain a usage sequence S X  if S X   X  S . The support of a usage sequence 
As mentioned above, each appliance in a house has its own location. For an ap-The similarity between two appliances a 1 and a 2 is defined as follows: For example, in Fig. 2, the similarity of appliances B and C is . 2 . 0 Definition 5 (Co rrelation pattern). Given DB in usage representation and two thre-sholds, min_sup and min_sim , the set of frequent sequences, FS , includes all frequent usage sequences in DB . A correlation pattern P is defined as, We modify the idea of multivariate kernel density estimation [14, 17] to estimate the t , ... t im }, the probability function is defined as, For example, in Fig. 2, with min_sup = 2 and min_sim = 0.3,  X  A  X  A  X  D  X  D  X   X  is a correlation pattern with respective to  X  A  X  A  X  D  X  D  X   X  is  X   X  We only discuss f A + as an example. The time information of A  X  is {2, 6, 13}; hence f ( x ) We focus our study on correlation pattern mining in smart home due to its wide appli-cability and the lack of research on this topic. In this paper, we develop a new algo-rithm, called Correlation Pattern Miner (abbreviated as CoPMiner ), to discover correlation patterns effectively and efficiently. CoPMiner utilizes the arrangement of endpoints to accomplish the mining of correlation among appliances X  usage. We also propose four pruning strategies to effectively reduce the search space and speedup the mining process. 4.1 Merits of Correlation Pattern and Usage Representation Extracting correlation patterns from data collected in smart homes can provide resi-Given a correlation pattern, as defined in Definition 5, a user can know the distribu-tion of usage time of appliances. With a turn-on/off time of an appliance, we can de-rive the usage probability of other appliances. Consider the correlation pattern in machine, respectively. Given the turn-on/of f times of light and coffee machine, we can derive the usage probability for them, i.e., the probability for the light and coffee machine to be on/off at that time. This probability information is very useful for sev-eral applications, such as abnormal detection and activity prediction. 
Obviously, the correlation pattern mining is an arduous task. Since the time period of the two usage-intervals may overlap, the relation between them is intrinsically relations among intervals. However, Allen X  X  logics are binary relations. When de-scribing relationships among more than three intervals, Allen X  X  temporal logics may suffer several problems. address the ambiguous and scalable issue [19] for describing relationships among usage representation are discussed as follows: (1) Lossless: Usage representation not only implies the temporal relation among intervals, but also includes the accurate usage time of each interval. This concept can achieve a lossless representation to ex-can find that the usage representation has no ambiguous problem. First, by Definition 3, we can transform every usage-interval sequence to a unique usage sequence. In other words, the temporal relations among intervals can be mapped to a usage se-endpoints of A and B can be depicted easily. Hence, we can infer the original temporal relationships between intervals A and B nonambiguously. (3) Simplicity: Obviously, the complex relations between intervals are the major bottleneck of correlation pattern mining. However, the relation between two usage points is simple, just  X  before , X   X  af-ter  X  and  X  equal . X  The simpler the relations, the less number of intermediate candidate sequences are generated and processed. 4.2 CoPMiner Algorithm Before introducing the algorithm, we modify the idea in [16] and define the projected database first. Let  X  be a usage sequence in a database DB with usage representation. quences (including usage sequences and corresponding time sequence) in DB with regards to prefix  X  . 
Algorithm 1 illustrates the main framework of CoPMiner. It first transforms the usage database to usage representation and calculates the count of each usage-point concurrently (line 2, algorithm 1). CoPMiner removes infrequent usage-points under probability function f s by Definition 5 (lines 6-7, algorithm 1). 
As mentioned above, the spatial distance may conflict with the correlation depen-dency between two appliances. When building the projected database DB | s , CoPMiner collects the postfixes by using spatial pruning strategy . We eliminate the usage-postfix sequences (line 8, algorithm 1). Fi nally, CoPMiner calls UPrefixSpan recur-sively and output all correlation patterns (lines 9-10, algorithm 1). 
By borrowing the idea of the PrefixSpan [16], UPrefixSpan is developed with two search space pruning methods. The pseudo code is shown in Algorithm 2. For a prefix  X  usage-points and remove infrequent ones (line 1, algorithm 2). For frequent usage-with the length increased by 1. We also use the time information of s in DB |  X  to esti-sequence appear in pairs, i.e., every on(off)-point has corresponding off(on)-point, we can output this frequent sequence and its probability function as a correlation pattern (lines 8-9, algorithm 2). Finally, we can discover all correlation patterns by construct-ing the projected database with the frequently extended prefixes and recursively run-ning until the prefixes cannot be extended (lines 10-11, algorithm 2). 
Taking into account the property of usage-point, we propose two pruning strate-effectively. Firstly, the on-points and the off-points definitely occur in pairs in a usage sequence. We only require projecting the frequent on-points or the frequent off-points which have the corresponding on-points in th eir prefixes. For example, if we scan the points in its prefix. It is because that sequence  X  A  X  B  X   X  has no chance to grow to a 12-19, algorithm 2) which can prune off non-qualified patterns before constructing projected database. 
Second, when we construct a projected database, some usage-points in postfix se-quences need not be considered. W ith respect to a prefix sequence  X   X   X  , an off-point in  X   X  . Hence, when collecting postfix sequences to construct DB |  X   X   X  , we can eliminate all insignificant off-points since they can be ignored in the discovery of correlation pat-length of postfix sequence and further reduce the size of projected database effective-ly (line 14 and lines 20-25, algorithm 2). among appliances included probability concept. Three interval-pattern mining algo-performance discussion. For fair comparison, when comparing the execution time of CoPMiner with other interval-pattern mining algorithms, we only discuss the part of usage sequence mining (i.e., exclusive of computation of probability function). All algo-rithms were implemented in Java language and tested on a workstation with Intel i7-3370 3.4 GHz with 8 GB main memory. First, we compare the execution time using observe the memory usage and the scalability on execution time of CoPMiner. Finally, CoPMiner is applied in real-world dataset [12] to show the performance and the practi-generated using synthetic generator in [4] and the parameter setting is shown in Fig. 3. 5.1 Performance and Scalability on Synthetic Dataset 5,000. The other parameters are configured for comparison. Note that, for fair com-parison, when comparing the performance of CoPMiner with other interval-pattern mining algorithms, we only discuss the part of usage sequence mining (i.e., exclusive of computation of probability function). Fig. 4(a) shows the running time of the four D 100k X  C 20 X  N 10k. Obviously, when the minimum support value decreases, the processing time required for all algorithms increases. We can see that when we continue to lower the threshold, the runtime for IEMiner and TPrefixSpan increase drastically compared to CTMiner and CoPM iner. This is partly because these two algorithms still process interval-based data with complex relationship which may lead to generate more number of intermediate candidate sequences. 
Then, we study the scalability of CoPMiner. Here, we use the data set C = 20, N = 10k with varying different database size. Fig. 4(b) shows the results of scalability tests of four algorithms with the database size growing from 100K to 500K sequences. We under different database size growing with different minimum support threshold varying from 1% to 5%. As the size of database increases and minimum support decreases, the processing time of all algor ithms increase, since the number of patterns also increases. As can be seen, CoPMiner is linearly scalable with different minimum support threshold. When the number of generated patterns is large, the runtime of CoPMiner still increases linearly with different database size. 5.2 Influence of Proposed Pruning Strategies To reflect the speedup of proposed pruning methods, we measure CoPMiner with pruning strategies and without pruning strategy on time performance. We compare five algorithms, CoPMiner (includes all pruning strategies), CoP_Point (only point-pruning strategy), CoP_Postfix (only postfix-pruning strategy), CoP_Spatial (only spatial-pruning strategy) and CoP_None (without any pruning strategy). The experi-ment is performed on the data set D 100k X  C 20 X  N 10k. Fig. 4(d) is the results of vary-ing minimum support thresholds from 0.5% to 1%. As shown in figure, point-pruning can improve about 25% performance. Because of removing non-qualified usage-points before database projection, point-pruning can efficiently speedup the execution time. As can be seen from the graph, postfix-pruning can improve about 11% perfor-mance. Postfix-pruning can improve the performance by effectively eliminating all useless usage-points for correlation pattern construction. We also can observe that spatial-pruning constantly ameliorate the performance about 2.5. 5.3 Real-World Dataset Analysis In addition to using synthetic datasets, we also have performed an experiment on real-REDD [12] used in the experiment is the po wer reading of appliances collected from six different houses. Each house has about 15 appliances. We convert the raw data mining result with min_sup = 0.3 and min_sim = 0.1. The probability function of each usage-point in pattern is listed below. Recently, considerable concern has arisen ov er the electricity conservation due to the issue of greenhouse gas emissions. If repres entative behaviors of appliance usages are available, residents may adapt their usage patterns to conserve energy effectively. However, previous studies on usage pattern discovery are mainly focused on analyz-new concept, correlation pattern, to capture the usage patterns and correlations among appliances probabilistically. An efficient algorithm, CoPMiner is developed to dis-cover patterns based on proposed usage representation. The experimental studies indi-cate that CoPMiner is efficient and scalable. Furthermore, CoPMiner is applied on a real-world dataset to show the practicability of correlation pattern mining. 
