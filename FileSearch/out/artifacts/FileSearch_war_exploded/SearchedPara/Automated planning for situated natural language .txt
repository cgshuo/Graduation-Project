 The problem of situated natural language gen-eration (NLG) X  X .e., of generating natural lan-guage in the context of a physical (or virtual) environment X  X as received increasing attention in the past few years. On the one hand, this is be-cause it is the foundation of various emerging ap-plications, including human-robot interaction and mobile navigation systems, and is the focus of a current evaluation effort, the Challenges on Gener-ating Instructions in Virtual Environments (GIVE; (Koller et al., 2010b)). On the other hand, situated generation comes with interesting theoretical chal-lenges: Compared to the generation of pure text, the interpretation of expressions in situated com-munication is sensitive to the non-linguistic con-text, and this context can change as easily as the user can move around in the environment.

One interesting aspect of situated communica-tion from an NLG perspective is that this non-linguistic context can be manipulated by the speaker. Consider the following segment of dis-course between an instruction giver (IG) and an instruction follower (IF), which is adapted from the SCARE corpus (Stoia et al., 2008): (1) IG: Walk forward and then turn right.

In this example, the IG plans to refer to an ob-ject (here, a button); and in order to do so, gives a navigation instruction to guide the IF to a conve-nient location at which she can then use a simple referring expression (RE). That is, there is an inter-action between navigation instructions (intended to manipulate the non-linguistic context in a cer-tain way) and referring expressions (which exploit the non-linguistic context). Although such subdi-alogues are common in SCARE, we are not aware of any previous research that can generate them in a computationally feasible manner.

This paper presents an approach to generation which is able to model the effect of an utter-ance on the non-linguistic context, and to inten-tionally generate utterances such as the above as part of a process of referring to objects. Our ap-proach builds upon the CRISP generation system (Koller and Stone, 2007), which translates gener-ation problems into planning problems and solves these with an AI planner. We extend the CRISP planning operators with the perlocutionary effects that uttering a particular word has on the physi-cal environment if it is understood correctly; more specifically, on the position and orientation of the hearer. This allows the planner to predict the non-linguistic context in which a later part of the ut-terance will be interpreted, and therefore to search for contexts that allow the use of simple REs. As a result, the work of referring to an object gets dis-tributed over multiple utterances of low cognitive load rather than a single complex noun phrase.
A second contribution of our paper is the gen-eration of REs involving context-dependent adjec-tives: A button can be described as  X  X he left blue button X  even if there is a red button to its left. We model adjectives whose interpretation depends on the nominal phrases they modify, as well as on the non-linguistic context, by keeping track of the dis-tractors that remain after uttering a series of mod-ifiers. Thus, unlike most other RE generation ap-proaches, we are not restricted to building an RE by simply intersecting lexically specified sets rep-resenting the extensions of different attributes, but can correctly generate expressions whose mean-ing depends on the context in a number of ways. In this way we are able to refer to objects earlier and more flexibly.

We implement and evaluate our approach in the context of a GIVE NLG system, by using the GIVE-1 software infrastructure and a GIVE-1 evaluation world. This shows that our system gen-erates an instruction-giving discourse as in (1) in about a second. It outperforms a mostly non-situated baseline significantly, and compares well against a second baseline based on one of the top-performing systems of the GIVE-1 Challenge. Next to the practical usefulness this evaluation es-tablishes, we argue that our approach to jointly modeling the grammatical and physical effects of a communicative action can also inform new mod-els of the pragmatics of speech acts.
 Plan of the paper. We discuss related work in Section 2, and review the CRISP system, on which our work is based, in Section 3. We then show in Section 4 how we extend CRISP to generate navigation-and-reference discourses as in (1), and add context-dependent adjectives in Section 5. We evaluate our system in Section 6; Section 7 con-cludes and points to future work. The research reported here can be seen in the wider context of approaches to generating refer-ring expressions. Since the foundational work of Dale and Reiter (1995), there has been a consider-able amount of literature on this topic. Our work departs from the mainstream in two ways. First, it exploits the situated communicative setting to de-liberately modify the context in which an RE is generated. Second, unlike most other RE genera-tion systems, we allow the contribution of a modi-fier to an RE to depend both on the context and on the rest of the RE.

We are aware of only one earlier study on gen-eration of REs with focus on interleaving naviga-tion and referring (Stoia et al., 2006). In this ma-chine learning approach, Stoia et al. train classi-fiers that signal when the context conditions (e.g. visibility of target and distractors) are appropriate for the generation of an RE. This method can be then used as part of a content selection component of an NLG system. Such a component, however, can only inform a system on whether to choose navigation over RE generation at a given point of the discourse, and is not able to help it decide what kind of navigational instructions to generate so that subsequent REs become simple.

To our knowledge, the only previous research on generating REs with context-dependent modi-fiers is van Deemter X  X  (2006) algorithm for gener-ating vague adjectives. Unlike van Deemter, we integrate the RE generation process tightly with the syntactic realization, which allows us to gen-erate REs with more than one context-dependent modifier and model the effect of their linear or-der on the meaning of the phrase. In modeling the context, we focus on the non-linguistic con-text and the influence of each of the RE X  X  words; this is in contrast to previous research on context-sensitive generation of REs, which mainly focused on the discourse context (Krahmer and Theune, 2002). Our interpretation of context-dependent modifiers picks up ideas by Kamp and Partee (1995) and implements them in a practical system, while our method of ordering modifiers is linguis-tically informed by the class-based paradigm (e.g., Mitchell (2009)).

On the other hand, our work also stands in a tra-dition of NLG research that is based on AI plan-ning. Early approaches (Perrault and Allen, 1980; Appelt, 1985) provided compelling intuitions for this connection, but were not computationally vi-able. The research we report here can be seen as combining Appelt X  X  idea of using planning for sentence-level NLG with a computationally be-nign variant of Perrault et al. X  X  approach of model-ing the intended perlocutionary effects of a speech act as the effects of a planning operator. Our work is linked to a growing body of very recent work that applies modern planning research to various problems in NLG (Steedman and Petrick, 2007; Brenner and Kruijff-Korbayov  X  a, 2008; Benotti, 2009). It is directly based on Koller and Stone X  X  (2007) reimplementation of the SPUD generator (Stone et al., 2003) with planning. As far as we know, ours is the first system in the SPUD tradi-tion that explicitly models the context change ef-fects of an utterance.

While nothing in our work directly hinges on this, we implemented our approach in the context of an NLG system for the GIVE Challenge (Koller et al., 2010b), that is, as an instruction giving sys-tem for virtual worlds. This makes our system comparable with other approaches to instruction giving implemented in the GIVE framework. Our work is based on the CRISP system (Koller and Stone, 2007), which encodes sentence gener-ation with tree-adjoining grammars (TAG; (Joshi and Schabes, 1997)) as an AI planning problem and solves that using efficient planners. It then decodes the resulting plan into a TAG derivation, from which it can read off a sentence. In this sec-tion, we briefly recall how this works. For space reasons, we will present primarily examples in-stead of definitions. 3.1 TAG sentence generation The CRISP generation problem (like that of SPUD (Stone et al., 2003)) assumes a lexicon of entries consisting of a TAG elementary tree annotated with semantic and pragmatic information. An ex-ample is shown in Fig. 1a. In addition to the el-ementary tree, each lexicon entry specifies its se-mantic content and possibly a semantic require-ment , which can express certain presuppositions triggered by this entry. The nodes in the tree may be labeled with argument names such as semantic roles , which specify the participants in the rela-tion expressed by the lexicon entry; in the exam-ple, every entry uses the semantic role self repre-senting the event or individual itself, and the en-try for  X  X ushes X  furthermore uses subj and obj for the subject and object argument, respectively. We combine here for simplicity the entries for  X  X he X  and  X  X utton X  into  X  X he button X .

For generation, we assume as input a knowl-edge base and a communicative goal in addition to the grammar. The goal is to compute a derivation that expresses the communicative goal in a sen-tence that is grammatically correct and complete; whose meaning is justified by the knowledge base; and in which all REs can be resolved to unique individuals in the world by the hearer. Let X  X  say, for example, that we have a knowledge base { push ( e, j , b 1 ) , John ( j ) , button ( b 1 ) , button ( b red ( b 1 ) } . Then we can combine instances of the trees for  X  X ohn X ,  X  X ushes X , and  X  X he button X  into a grammatically complete derivation. However, because both b 1 and b 2 satisfy the semantic content of  X  X he button X , we must adjoin  X  X ed X  into the derivation to make the RE refer uniquely to b . The complete derivation is shown in Fig. 1b; we can read off the output sentence  X  X ohn pushes the red button X  from the leaves of the derived tree we build in this way. 3.2 TAG generation as planning In the CRISP system, Koller and Stone (2007) show how this generation problem can be solved by converting it into a planning problem (Nau et al., 2004). The basic idea is to encode the partial derivation in the planning state, and to encode the action of adding each elementary tree in the plan-ning operators. The encoding of our example as a planning problem is shown in Fig. 2.

In the example, we start with an initial state which contains the entire knowledge base, plus atoms subst (S , root ) and ref ( root , e ) expressing that we want to generate a sentence about the event e . We can then apply the (instantiated) action pushes ( root , n 1 , n 2 , n 3 , e, j , b 1 ) , which models the act of substituting the elementary tree for  X  X ushes X  Figure 2: CRISP planning operators for the ele-mentary trees in Fig. 1. into the substitution node root : It can only be applied because root is an unfilled substitution node (precondition subst (S , root ) ), and its effect is to remove subst (S , root ) from the planning state while adding two new atoms subst (NP , n 1 ) and subst (NP , n 2 ) for the substitution nodes of the  X  X ushes X  tree. The planning state maintains in-formation about which individual each node refers to in the ref atoms. The current and next atoms are needed to select unused names for newly in-troduced syntax nodes. 1 Finally, the action in-troduces a number of distractor atoms including distractor ( n 2 , e ) and distractor ( n 2 , b 2 ) , express-ing that the RE at n 2 can still be misunderstood by the hearer as e or b 2 .

In this new state, all subst and distractor atoms for n 1 can be eliminated with the ac-tion John ( n 1 , j ) . We can also apply the action the-button ( n 2 , b 1 ) to eliminate subst (NP , n 2 ) and distractor ( n 2 , e ) , since e is not a button. However distractor ( n 2 , b 2 ) remains. Now be-cause the action the-button also introduced the atom canadjoin (N , n 2 ) , we can remove the fi-nal distractor atom by applying red ( n 2 , b 1 ) . This brings us into a goal state, and we are done. Goal states in CRISP planning problems are characterized by axioms such as  X  A  X  u.  X  subst ( A, u ) (encoding grammatical com-pleteness) and  X  u  X  x.  X  distractor ( u, x ) (requiring unique reference). Figure 3: An example map for instruction giving. 3.3 Decoding the plan An AI planner such as FF (Hoffmann and Nebel, 2001) can compute a plan for a planning problem that consists of the planning operators in Fig. 2 and a specification of the initial state and the goal. We can then decode this plan into the TAG deriva-tion shown in Fig. 1b. The basic idea of this decoding step is that an action with a precondi-tion subst ( A, u ) fills the substitution node u , while an action with a precondition canadjoin ( A, u ) ad-joins into a node of category A in the elementary tree that was substituted into u . CRISP allows multiple trees to adjoin into the same node. In this case, the decoder executes the adjunctions in the order in which they occur in the plan. We are now ready to describe our NLG ap-proach, SCRISP ( X  X ituated CRISP X ), which ex-tends CRISP to take the non-linguistic context of the generated utterance into account, and deliber-ately manipulate it to simplify RE generation.
As a simplified version of our introductory in-struction giving example (1), consider the map in Fig. 3. The instruction follower (IF), who is lo-cated on the map at position pos 3 , 2 facing north , sees the scene from the first-person perspective as in Fig. 7. Now an instruction giver (IG) could in-struct the IF to press the button b 1 in this scene by saying  X  X ush the button on the wall to your left X . Interpreting this instruction is difficult for the IF because it requires her to either memorize the RE until she has turned to see the button, or to per-form a mental rotation task to visualize b 1 inter-nally. Alternatively, the IG can first instruct the IF to  X  X urn left X ; once the IF has done this, the IG can then simply say  X  X ow push the button in front of you X . This lowers the cognitive load on the IF, and presumably improves the rate of correctly in-terpreted REs.

SCRISP is capable of deliberately generat-ing such context-changing navigation instructions. The key idea of our approach is to extend the CRISP planning operators with preconditions and effects that describe the (simulated) physical envi-ronment: A  X  X urn left X  action, for example, mod-ifies the IF X  X  orientation in space and changes the set of visible objects; a  X  X ush X  operator can then pick up this changed set and restrict the distractors of the forthcoming RE it introduces (i.e.  X  X he but-ton X ) to only objects that are visible in the changed context. We also extend CRISP to generate imper-ative rather than declarative sentences. 4.1 Situated CRISP We define a lexicon for SCRISP to be a CRISP lexicon in which every lexicon entry may also de-scribe non-linguistic conditions , non-linguistic ef-fects and imperative effects . Each of these is a set of atoms over constants, semantic roles, and possibly some free variables. Non-linguistic con-ditions specify what must be true in the world so a particular instance of a lexicon entry can be uttered felicitously; non-linguistic effects specify what changes uttering the word brings about in the world; and imperative effects contribute to the IF X  X   X  X o-do list X  (Portner, 2007) by adding the proper-ties they denote.
 A small lexicon for our example is shown in Fig. 4. This lexicon specifies that saying  X  X ush X X  puts pushing X on the IF X  X  to-do list, and car-ries the presupposition that X must be visible from the location where  X  X ush X X  is uttered; this re-flects our simplifying assumption that the IG can Figure 5: SCRISP planning operators for the lexi-con in Fig. 4. only refer to objects that are currently visible. Similarly,  X  X urn left X  puts turning left on the IF X  X  agenda. In addition, the lexicon entry for  X  X urn left X  specifies that, under the assumption that the IF understands and follows the instruction, they will turn 90 degrees to the left after hearing it. The planning operators are written in a way that as-sumes that the intended (perlocutionary) effects of an utterance actually come true. This assumption is crucial in connecting the non-linguistic effects of one SCRISP action to the non-linguistic pre-conditions of another, and generalizes to a scalable model of planning perlocutionary acts. We discuss this in more detail in Koller et al. (2010a).
We then translate a SCRISP generation prob-lem into a planning problem. In addition to what CRISP does, we translate all non-linguistic condi-tions into preconditions and all non-linguistic ef-fects into effects of the planning operator, adding any free variables to the operator X  X  parameters. An imperative effect P is translated into an ef-fect to  X  do ( P ) . The operators for the example lex-icon of Fig. 4 are shown in Fig. 5. Finally, we add information about the situated environment to the initial state, and specify the planning goal by adding to  X  do ( P ) atoms for each atom P that is to be placed on the IF X  X  agenda. 4.2 An example Now let X  X  look at how this generates the appropri-ate instructions for our example scene of Fig. 3. We encode the state of the world as depicted in the map in an initial state which contains, among others, the atoms player  X  pos ( pos 3 , 2 ) , player  X  ori ( north ) , next  X  ori  X  left ( north , west ) , visible ( pos 3 , 2 , west , b 1 ) , etc. 2 We want the IF to press b 1 , so we add to  X  do ( push ( b 1 )) to the goal.
We can start by applying the action turnleft ( root , e, north , west ) to the initial state. Next to the ordinary grammatical effects from CRISP, this action makes player  X  ori ( west ) true. The new state does not contain any subst atoms, but we can continue the sentence by adjoining  X  X nd X , i.e. by applying the action and ( root , n 1 , n 2 , e, e 1 ) . This produces a new atom subst (S , e 1 ) , which satisfies one precon-Because turnleft changed the player orientation, the visible precondition of push is now satisfied too (unlike in the initial state, in which b 1 was not visible). Applying the action push now introduces the need to substitute a noun phrase for the object, which we can eliminate with an application of the-button ( n 2 , b 1 ) as in Subsection 3.2.
Since there are no other visible buttons from pos 3 , 2 facing west , there are no remaining distractor atoms at this point, and a goal state has been reached. Together, this four-step plan decodes into the sentence  X  X urn left and push the button X . The final state contains the atoms to  X  do ( push ( b 1 )) and to  X  do ( turnleft ) , indicating that an IF that understands and accepts this in-struction also accepts these two commitments into their to-do list. Now consider if we wanted to instruct the IF to press b 2 in Fig. 3 instead of b 1 , say with the instruction  X  X ush the left button X . This is still challenging, because (like most other approaches to RE generation) CRISP interprets adjectives by simply intersecting all their extensions. In the case of  X  X eft X , the most reasonable way to do this would be to interpret it as  X  X eftmost among all visible ob-jects X ; but this is f 1 in the example, and so there is no distinguishing RE for b 2 .

In truth, spatial adjectives like  X  X eft X  and  X  X p-per X  depend on the context in two different ways. On the one hand, they are interpreted with respect to the current spatio-visual context, in that what is on the left depends on the current position and ori-entation of the hearer. On the other hand, they also Figure 6: SCRISP operators for context-dependent and context-independent adjectives. depend on the meaning of the phrase they modify:  X  X he left button X  is not necessarily both a button and further to the left than all other objects, it is only the leftmost object among the buttons.

We will now show how to extend SCRISP so it can generate REs that use such context-dependent adjectives. 5.1 Context-dependence of adjectives in As a planning-based approach to NLG, SCRISP is not limited to simply intersecting sets of po-tential referents that only depend on the attributes that contribute to an RE: Distractors are removed by applying operators which may have context-sensitive conditions depending on the referent and the distractors that are still left.

Our encoding of context-dependent adjectives as planning operators is shown in Fig. 6. We only show the operators here for lack of space; they can of course be computed automatically from lexicon entries. In addition to the ordinary CRISP precon-ditions, the left operator has a precondition requir-ing that no current distractor for the RE u is to the left of x , capturing a presupposition of the adjec-tive. Its effect is that everything that is to the right of x is no longer a distractor for u . Notice that we allow that there may still be distractors after left has been applied (above or below x ); we only re-quire unique reference in the goal state. (Ignore the premod  X  index part of the effect for now; we will get to that in a moment.)
Let X  X  say that we are computing a plan for re-ferring to b 2 in the example map of Fig. 3, starting with push ( root , n 1 , n 2 , e, b 2 , pos 3 , 1 , north ) and the-button ( n 1 , b 2 ) . The state after these two ac-tions is not a goal state, because it still contains the atom distractor ( n 1 , b 3 ) (the plant f 1 was re-moved as a distractor by the action the-button ). Now assume that we have modeled the spatial relations between all objects in the initial state in left  X  of and above atoms; in particular, we have left  X  of ( b 2 , b 3 ) . Then the action instance left ( n 1 , b 2 ) is applicable in this state, as there is no other object that is still a distractor in this state and that is to the left of b 2 . Applying left removes distractor ( n 1 , b 3 ) from the state. Thus we have reached a goal state; the complete plan decodes to the sentence  X  X ush the left button X .

This system is sensitive to the order in which operators for context-dependent adjectives are ap-plied. To generate the RE  X  X he upper left but-ton X , for instance, we first apply the left action and then the upper action, and therefore upper only needs to remove distractors in the leftmost posi-tion. On the other hand, the RE  X  X he left upper button X  corresponds to first applying upper and then left . These action sequences succeed in re-moving all distractors for different context states, which is consistent with the difference in meaning between the two REs.

Furthermore, notice that the adjective operators themselves do not interact directly with the en-coding of the context in atoms like visible and player  X  pos , just like the noun operators in Sec-tion 4 didn X  X . The REs to which the adjectives and nouns contribute are introduced by verb operators; it is these verb operators that inspect the current context and initialize the distractor set for the new RE appropriately. This makes the correctness of the generated sentence independent of the order in which noun and adjective operators occur in the plan. We only need to ensure that the verbs are ordered correctly, and the workload of modeling interactions with the non-linguistic context is lim-ited to a single place in the encoding. 5.2 Adjective word order One final challenge that arises in our system is to generate the adjectives in the correct order, which on top of semantically valid must be linguisti-cally acceptable. In particular, it is known that some types of adjectives are limited with respect to the word order in which they can occur in a noun phrase. For instance,  X  X arge foreign finan-cial firms X  sounds perfectly acceptable, but  X ? for-eign large financial firms X  sounds odd (Shaw and Hatzivassiloglou, 1999). In our setting, some ad-jective orders are forbidden because only one or-der produces a correct and distinguishing descrip-Figure 7: The IF X  X  view of the scene in Fig. 3, as rendered by the GIVE client. tion of the target referent (cf.  X  X pper left X  vs.  X  X eft upper X  example above). However, there are also other constraints at work:  X ? the red left button X  is rather odd even when it is a semantically correct description, whereas  X  X he left red button X  is fine.
To ensure that SCRISP chooses to generate these adjectives correctly, we follow a class-based approach to the premodifier ordering problem (Mitchell, 2009). In our lexicon we assign adjec-tives denoting spatial relations ( X  X eft X ) to one class and adjectives denoting color ( X  X ed X ) to another; then we require that spatial adjectives must always precede color adjectives. We enforce this by keep-ing track of the current premodifier index of the RE in atoms of the form premod  X  index . Any newly generated RE node starts off with a premodifier index of zero; adjoining an adjective of a certain class then raises this number to the index for that class. As the operators in Fig. 6 illustrate, color adjectives such as  X  X ed X  have index one and can only be used while the index is not higher; once an adjective from a higher class (such as  X  X eft X , of a class with index two) is used, the premod  X  index precondition of the  X  X ed X  operator will fail. For this reason, we can generate a plan for  X  X he left red button X , but not for  X ? the red left button X , as desired. To establish the quality of the generated instruc-tions, we implemented SCRISP as part of a gener-ation system in the GIVE-1 framework, and eval-uated it against two baselines. GIVE-1 was the First Challenge on Generating Instructions in Vir-tual Environments, which was completed in 2009 Table 1: Example system instructions generated in the same scene. REs for the target are typeset in boldface. (Koller et al., 2010b). In this challenge, sys-tems must generate real-time instructions that help users perform a task in a treasure-hunt virtual en-vironment such as the one shown in Fig. 7.
 We conducted our evaluation in World 2 from GIVE-1, which was deliberately designed to be challenging for RE generation. The world con-sists of one room filled with several objects and buttons, most of which cannot be distinguished by simple descriptions. Moreover, some of those may activate an alarm and cause the player to lose the game. The player X  X  moves and turns are discrete and the NLG system has complete and accurate real-time information about the state of the world. Instructions that each of the three systems under comparison generated in an example scene of the evaluation world are presented in Table 1.

The evaluation took place online via the Ama-zon Mechanical Turk, where we collected 25 games for each system. We focus on four mea-sures of evaluation: success rates for solving the task and resolving the generated REs, average task completion time (in seconds) for successful games, and average distance (in steps) between the IF and the referent at the time when the RE was generated. As in the challenge, the task is consid-ered as solved if the player has correctly been led through manipulating all target objects required to discover and collect the treasure; in World 2, the minimum number of such targets is eight. An RE is successfully resolved if it results in the manipu-lation of the referent, whereas manipulation of an alarm-triggering distractor ends the game unsuc-cessfully. 6.1 The SCRISP system Our system receives as input a plan for what the IF should do to solve the task, and successively takes object-manipulating actions as the commu-Table 2: Evaluation results. Differences to SCRISP are significant at * p &lt; . 05 , ** p &lt; . 005 (Pearson X  X  chi-square test for system success rates; unpaired two-sample t-test for the rest). nicative goals for SCRISP. Then, for each of the communicative goals, it generates instructions us-ing SCRISP, segments them into navigation and action parts, and presents these to the user as sep-arate instructions sequentially (see Table 1).
For each instruction, SCRISP thus draws from a knowledge base of about 1500 facts and a gram-mar of about 30 lexicon entries. We use the FF planner (Hoffmann and Nebel, 2001; Koller and Hoffmann, 2010) to solve the planning prob-lems. The maximum planning time for any in-struction is 1.03 seconds on a 3.06 GHz Intel Core 2 Duo CPU. So although our planning-based sys-tem tackles a very difficult search problem, FF is very good at solving it X  X ast enough to generate instructions in real time. 6.2 Comparison with Baseline A Baseline A is a very basic system designed to sim-ulate the performance of a classical RE genera-tion module which does not attempt to manipu-late the visual context. We hand-coded a correct distinguishing RE for each target button in the world; the only way in which Baseline A reacts to changes of the context is to describe on which wall the button is with respect to the user X  X  current orientation (e.g.  X  X ress the right red button on the wall to your right  X ).

As Table 2 shows, our system guided 69% of users to complete the task successfully, compared to only 16% for Baseline A (difference is statis-tically significant at p &lt; . 005 ; Pearson X  X  chi-square test). This is primarily because only 49% of the REs generated by Baseline A were success-ful. This comparison illustrates the importance of REs that minimize the cognitive load on the IF to avoid misunderstandings. 6.3 Comparison with Baseline B Baseline B is a corrected and improved version of the  X  X ustin X  system (Chen and Karpov, 2009), one of the best-performing systems of the GIVE-1 Challenge. Baseline B, like the original  X  X ustin X  system, issues navigation instructions by precom-puting the shortest path from the IF X  X  current lo-cation to the target, and generates REs using the description logic based algorithm of Areces et al. (2008). Unlike the original system, which inflex-ibly navigates the user all the way to the target, Baseline B starts off with navigation, and oppor-tunistically instructs the IF to push a button once it has become visible and can be described by a dis-tinguishing RE. We fixed bugs in the original im-plementation of the RE generation module, so that Baseline B generates only unambiguous REs. The module nonetheless naively treats all adjectives as intersective and is not sensitive to the context of their comparison set. Specifically, a button can-not be referred to as  X  X he right red button X  if it is not the rightmost of all visible objects X  X hich ex-plains the long chain of navigational instructions the system produced in Table 1.

We did not find any significant differences in the success rates or task completion times between this system and SCRISP, but the former achieved a higher RE success rate (see Table 2). However, a closer analysis shows that SCRISP was able to generate REs from significantly further away. This means that SCRISP X  X  RE generator solves a harder problem, as it typically has to deal with more vis-ible distractors. Furthermore, because of the in-creased distance, the system X  X  execution monitor-ing strategies (e.g. for detection and repair of mis-understandings) become increasingly important, and this was not a focus of this work. In summary, then, we take the results to mean that SCRISP per-forms quite capably in comparison to a top-ranked GIVE-1 system. In this paper, we have shown how situated instruc-tions can be generated using AI planning. We ex-ploited the planner X  X  ability to model the perlocu-tionary effects of communicative actions for effi-cient generation. We showed how this made it pos-sible to generate instructions that manipulate the non-linguistic context in convenient ways, and to generate correct REs with context-dependent ad-jectives.

We believe that this illustrates the power of a planning-based approach to NLG to flexibly model very different phenomena. An interesting topic for future work, for instance, is to expand our notion of context by taking visual and discourse salience into account when generating REs. In ad-dition, we plan to experiment with assigning costs to planning operators in a metric planning problem (Hoffmann, 2002) in order to model the cognitive cost of an RE (Krahmer et al., 2003) and compute minimal-cost instruction sequences.

On a more theoretical level, the SCRISP actions model the physical effects of a correctly under-stood and grounded instruction directly as effects of the planning operator. This is computationally much less complex than classical speech act plan-ning (Perrault and Allen, 1980), in which the in-tended physical effect comes at the end of a long chain of inferences. But our approach is also very optimistic in estimating the perlocutionary effects of an instruction, and must be complemented by an appropriate model of execution monitoring. What this means for a novel scalable approach to the pragmatics of speech acts (Koller et al., 2010a) is, we believe, an interesting avenue for future re-search.
 Acknowledgments. We are grateful to J  X  org Hoffmann for improving the efficiency of FF in the SCRISP domain at a crucial time, and to Margaret Mitchell, Matthew Stone and Kees van Deemter for helping us expand our view of the context-dependent adjective generation problem. We also thank Ines Rehbein and Josef Ruppenhofer for testing early implementations of our system, and Andrew Gargett as well as the reviewers for their helpful comments.

