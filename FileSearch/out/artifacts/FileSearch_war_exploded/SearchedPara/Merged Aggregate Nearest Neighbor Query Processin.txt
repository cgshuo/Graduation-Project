 Aggregate nearest neighbor query, which returns a common inter-esting point that minimizes the aggregate distance for a given query point set, is one of the most important operations in spatial databas-es and their application domains. This paper addresses the problem of finding the aggregate nearest neighbor for a merged set that con-sists of the given query point set and multiple points needed to be selected from a candidate set, which we name as merged aggregate nearest neighbor(MANN) query. This paper proposes an effective algorithm to process MANN query in road networks based on our pruning strategies. Extensive experiments are conducted to exam-ine the behaviors of the solutions and the overall experiments show that our strategies to minimize the response time are effective and achieve several orders of magnitude speedup compared with the baseline methods.
 H.2.8 [ Database Application ]: Spatial databases Query Processing; Nearest Neighbor; Road Networks
Location-based services (LBSs) become more and more impor-tant in our everyday life. Worldwide revenues from LBSs are ex-pected to break the US$4 billion mark in 2012, according to ABI Research. This huge and ever-growing market has attracted lot-s of attentions from both academy and industry. In this paper, we study a new location-based query, namely Merged Aggregate Near-est Neighbor (MANN) , on a spatial road network.

Formally, given a target set P , a query set Q , a candidate set C and an integer n , a MANN query returns an optimal target point p  X  P and a set of n candidates C s from C ( C s  X  C ), such that the aggregate distance from target point p to all the points in Q and C s is minimized, i.e., q ( P , Q , n , C ) = {  X  p; C s  X  X  ( C; n )  X  X  X  p  X   X  P ,  X  C  X   X  ( C; n ) , f ( p; C s  X  Q ) be sum or max or others based on application needs. Take sum as an example, f ( p; S ) = network distance between p and s in a given road network; and function ( C; n ) is a function which returns all the subsets C that are formed by n candidate points of C , i.e.,  X  C  X   X  C  X   X  C and | C  X  | = n . As we consider the merged set of Q and C s and the aggregated distance, we simply name the new query as MANN.

MANN can be fit into many real life applications. For example, three friends want to play basketball. They need to find a basketball court and meanwhile invite seven of their friends to play basketball. set C is a set of friends, and n is 7. MANN can help to select 7 friends and meanwhile locate a basketball court such that the total distance from 10 participants X  locations to the court is minimum.
Figure 1 shows a simple example of the MANN query that will be used as the running example throughout this paper. The star points form the target set P , the circle points form the candidate set C , the square points form the query set Q , and the integers next to the edges represent the edges X  length. Suppose n is 2 and the aggregate distance function considered is sum , we list in Table 1 some potential answers and MANN will return p 2 as the answer target point, and c 3 and c 4 as the corresponding answer candidate points.

As shown in the above example, MANN is complex. It consider-s the distance from the target point to points in Q and the distance from the same target point to n candidate points, while both the target point and the n candidate points are unknown. To the best of our knowledge, MANN query has not been studied in the literature and the most close one is ANN query [11]. However, ANN only considers the distance from a target point to the query points that are fixed and there is no need to locate n candidate points. Given the definition of MANN, there are two naive solutions to process MANN query, namely p -oriented and c -oriented . The p -oriented algorithm considers target point p  X  P first and it locates, for each target point p  X  P , the n points from C that are nearest to p as the candidate points. The one that has the minimum aggregated distance to all the query points and the n candidate points is the answer. On the other hand, the c -oriented algorithm considers can-didate points first. It enumerates all the potential candidate set C and there are in total ANN query is issued with Q  X  C s as the input, and the one with minimal aggregated distance forms the answer to MANN. Obvi-ously, both approaches are inefficient as they blindly scan either all the points in P or all those Motivated by the fact that existing algorithms cannot support MANN queries efficiently, we develop a few pruning strategies in this paper to prune away unnecessary target points and develop a search algorithm to process MANN queries efficiently.
 Our main contribution presented in this paper is threefold. (1) We formalize the MANN query in road networks. (2) We pro-pose an efficient algorithm to support MANN queries based on our pruning strategies. (3) We perform comprehensive simulation study based on the real dataset to evaluate our algorithm and the exper-imental results demonstrate that our algorithm achieves excellent search performance and also has great scalability.
In this section, we first present the formal definition of road net-works and MANN, and then we give the definition of candidate result, which will be used in our algorithm. Table 2 defines the common symbols used in this paper.

Symbol Description d e ( p; q ) the Euclidean distance between p and q || p; q || the minimum network distance from p to q || p; S || sum the aggregate network distance from point p || p; S || max the maximum network distance from p to a
W e model a road network G as a weighted graph that consists of a set of nodes N and edges E , i.e., G = ( N; E ) . A node n represents a road intersection and an edge ( n; n  X  )  X  E represents a road segment connecting nodes n and n  X  . w ( n; n  X  ) denotes the edge weight, which can represent the travel distance or trip time, and we assume all distances are positive. For simplicity, we use distance hereafter. A path P ( u; v ) stands for a set of edges con-necting nodes u and v and its distance | P ( u; v ) | = w ( n; n  X  ) . Among all paths connecting node u and node v , the one with the smallest distance is referred to as the shortest path , denoted by SP ( u; v ) . The network distance || u; v || and v is the distance of their shortest path SP ( u; v ) , i.e., = | SP ( u; v ) | . On road network, MANN query is introduced, as defined in Definition 1.
 Definition 1. MANN Query. Given a set of target points P and a road network G ( N; E ) , a MANN query q ( P; Q; n; C ) specifies a query set Q that contains one or multiple query points, an integer n , and a candidate set C that contains at least n candidate points. It returns a target point p  X  P and a set of n candidate points from candidate set C (denoted as C s ) such that the aggregated distance = {  X  p; C s  X  X  p  X  P  X  C s  X  ( C; n )  X   X  p  X   X  P;  X  C  X   X  f ( p; C s  X  Q )  X  f ( p  X  ; C  X   X  Q ) } Here, ( C; n ) is a function to return all the subsets of C that con-tain n points of C , i.e., ( C; n ) = { C  X  | C  X   X  C  X  | and f ( p; S ) is an aggregate distance function and it can be sum or max or other operations based on application needs. If sum is con-|| p; S || max . To simplify our discussion, we use sum as the default setting for f ( p; S ) .
 To facilitate our discussion, we also introduce a concept, namely Candidate Result , as defined in Definition 2. If function f con-siders sum , the candidate result p:CR of a target point p actual-ly contains the n nearest candidate points. Take the running ex-ample depicted in Figure 1 as the example. p 1 :CR = { c 1 p :CR = { c 3 ; c 4 } , and p 3 :CR = { c 5 ; c 7 } . Given two target points p 1 and p 2 , we say p 1 is better than p 2 for a given MANN query q ( P; Q; n; C ) if f ( p 1 ; p 1 :CR  X  Q )  X  f ( p Back to our running example. Target points p 2 is better than p as f ( p 1 ; p 1 :CR  X  Q ) = || p 1 ; { c 1 ; c 2 ; q 1 ; q f ( p 2 ; p 2 :CR  X  Q ) = || p 2 ; { c 3 ; c 4 ; q 1 ; q 2 Definition 2. Candidate Result. Given a target point p  X  P and a MANN query q ( P; Q; n; C ) on a road network G ( N; E ) , the can-didate result of p is defined as the set of n candidate points, denot-ed as p:CR , that can minimize the aggregated distance from p to n candidate points, i.e.,  X  C  X   X  ( C; n ) , f ( p; p:CR )  X  other words, if p is returned by q ( P; Q; n; C ) , p:CR must be the corresponding candidate points returned.
As we explain in Section 1, the baseline p -oriented algorithm and c -oriented algorithm do not perform well because they need to point set C s formed by n candidate points of C . In this section, we develop a pruning strategy to improve the performance of p -oriented algorithm via pruning away certain target points. In the following, we first present how to find the candidate result, based on which pruning strategy is developed, finally we present the Fast-Pruning (FP) Algorithm .
First, we introduce the algorithm used to locate the candidate re-sult p:CR for a given target point p in Algorithm 1, which extends the Dijkstra algorithm. It explores the road network from the target point p , and always explores nodes that have the shortest distances to p . Although the candidate result p:CR contains only n candidate points, our network expansion stops when the set p:CR contains n candidate points and meanwhile all the query points in Q have been visited. This is because the pruning rule used by FP is based on f ( p; Q  X  p:CR ) and Algorithm 1 returns not only p:CR but also f ( p; Q  X  p:CR ) . If we consider max , instead of maintaining the aggregated distance, it needs to maintain the maximum distance. As the adjustment is straightforward, we omit the details to save space. It X  X  worth noting that finding the candidate result of a target point can be costly, so reducing the times of invoking Algorithm 1 is quite important, which is the main point of our work. Algorithm 1 Find Candidate Result Input: p; Q; C; n; G ( N; E ) Output: p:CR , || p; Q  X  p:CR || sum 1: if | C | &lt; n then 2: return p:CR =  X  ; || p; Q  X  p:CR || sum =  X  ; 3: aggregate _ dist  X  0 ; C p  X  X  X  ; 4: H  X  new min-heap; 5: insert H ( p; || p; p || = 0) ; 6: while ( H  X  =  X  ) and 7: ( u; || u; p || )  X  H:deheap (); 8: if u  X  Q then 9: update aggregate _ dist by || u; p || ; 10: remove u from Q ; 11: else if u  X  C and | p:CR | &lt; n then 12: update aggregate _ dist by || u; p || ; 13: insert u to p:CR ; 14: explore u  X  X  neighbor nodes and put them into H ; 15: return p:CR; || p; Q  X  p:CR || sum = aggregate _ dist ;
Based on a given target point p and its corresponding candidate result, we develop two pruning strategies for different aggregate distance functions to prune away certain target points that definitely will not produce results better than p . In the following, we first present the corresponding lemma that builds the theory foundation of our pruning strategy and then present our pruning rules. Lemma 1. Let V be a point set in a Euclidean Space with V = { v 1 ; v 2 ;  X  X  X  ; v n } and v m be the geometry center of V . Then, for any point p in the space, we have Proof. Given four real numbers a 1 , a 2 , b 1 , b 2 , we have  X  By the mathematical induction, we have Assume point p is located at  X  x; y  X  , and point p i is located at  X  x ; y i  X  . Then, the geometry center v m is located at  X  .
 we have The proof completes.
 Theorem 1. Given a MANN query q ( P; Q; n; C ) and a road net-work G ( N; E ) , let q m be the geometry center of Q . Assume sum is considered.  X  p 1 ; p 2  X  P , if d e ( p 1 ; q m )  X  || is certain that p 1 can X  X  be better than p 2 . proof Based on Lemma 1, we have As the Euclidean distance between two objects does not exceed the network distance, we have  X  Here, p i :CR is the candidate result corresponding to p i ous that p 1 can X  X  be better than p 2 . Our proof completes.
The above pruning rule is to prune away certain target points based on sum function. We also develop following pruning rules for max function.
 Lemma 2. Let V be a point set in the Euclidean Space, the geom-etry center of V is v m . For any point p in the space, we have Proof. Assume the above statement is not valid, i.e., if d max v i  X  V d e ( p; v i ) , we have d e ( p; v m ) &gt; d d ( p; v i ) = max v i  X  V d e ( p; v i ) and d e ( p; v m ) &gt; d points of V must be located inside the circle cir p . But the point v m is located outside of the circle cir p , as shown in Figure 2. If we set the line l ( p; v m ) that passes point p and v m as the x-axis and set the intersection point o of l ( p; v m ) and the circumference located at one side of the y-axis while v m is on the other side. This contradicts our statement that v m is the geometry center of points in V and hence our assumption is invalid. The proof completes. Theorem 2. Given a MANN query q ( P; Q; n; C ) and a road net-work G ( N; E ) , let q m be the geometry center of Q . Assume max is considered.  X  p 1 ; p 2  X  P , if d e ( p 1 ; q m )  X  || p it is certain that p 1 can X  X  be better than p 2 .
 Proof. Based on Lemma 2, we have W e all understand that Based on our statement, we know d e ( p 1 ; q m )  X || p 2 and hence we have
Based on the pruning rules we propose, the FP algorithm is de-veloped. Its pseudo-code is listed in Algorithm 2. Since our prun-ing rule (i.e., Theorem 1) is based on Euclidean distance, we as-sume all the target points are indexed by a R-tree with its root n-ode root being an input for Algorithm 2. The algorithm mainly contains two steps. The first step is to complete the initialization for the pruning distance d , which captures the aggregate distance corresponding to current result maintained by S (lines 1-7). The second step is to prune away the target points based on Theorem 1 and update the pruning distance d if necessary. They are detailed in the following.

In our first step, we find the geometry center q m for the input query set Q , and then retrieve the nearest target point q q m based on best-first NN search [1]. We then retrieve the candi-date result ( q m :N N ) :CR corresponding to q m :N N based on Al-gorithm 1, and initialize the pruning distance d as || q m ( q m :N N ) :CR || sum . In most cases, the target point closer to the center of Q usually has a smaller aggregate distance to Q and hence initializing the pruning distance d based on q m :N N and its corre-sponding candidate result is a good choice. The experimental re-sults to be presented in Section 4 will further justify our selection.
Next, we start our second step to evaluate the target points. In order to enable an early termination of this step, we strategically visit target points based on ascending order of their mindist to q To be more specific, we visit the nodes of R-tree that indexes all the target points based on best-first order, with the help of the min-heap H . Initially, H has only one node, that X  X  the root of the R-tree. Thereafter, we de-heap the top entry  X  e; d e  X  of H for evaluation. Note that e is the entry within H that has the smallest mindist to q If e  X  X  mindist to q m (i.e., d e ) is already larger than the d= guaranteed that all the remaining entries in H and all the unvisited objects will have their mindist to q m larger than d= | Q pruned away based on Theorem 1. Otherwise, we need evaluate e . If e is a non-leaf node, all its child nodes are en-heap to H . Otherwise, e must be an object. We then check whether e is better than the current result and update the pruning distance d and result S if necessary.
 Lemma 3. The result identified by Algorithm 2 must be the real result for a MANN query.
 Proof. Assume the above statement is not valid, and the real result q ( P; Q; n; C ) (=  X  p; p:CR  X  ) is different from the one turned by Algorithm 2. Given the fact that the target point p is not returned by Algorithm 2, it must be enclosed by a node N d orem 1, we understand that p cannot be better than e . Consequently, our assumption is invalid and the proof completes.

Notice that we invoke Algorithm 1 to look for the candidate re-sult corresponding to each examined object e (Line 16). However, it is not always necessary to locate the candidate result if we know the aggregated distance generated by e and its candidate result will not be shorter than that of the current best candidate maintained by S of Algorithm 2 (i.e., d ). To enable this early termination of Algorithm 1, we can add following code right before Line 14 of Algorithm 1. In addition, Algorithm 2 can be easily adjusted to support max function based on Theorem 2. We skip the details for space saving. Algorithm 2 FP Algorithm for sum function Input: P ; Q; C; n; G ( N; E ) ; root Output: q ( P; Q; n; C ) 1: H  X  new min-heap; 2: get the geometry center of set Q , denoted as q m ; 3: H:enheap (  X  root; mindist ( q m ; root )  X  ); 4: get q m  X  X  NN in Euclidean Space, denoted as q m :N N , based 5: retrieve q m :N N  X  X  candidate result ( q m :N N ) :CR based on 6: d  X  X | q m :N N; Q  X  ( q m :N N ) :CR || sum ; 7: initialize result S  X  X  X  q m :N N; q m :N N:CR  X  ; 8: while H is not empty do 9:  X  e; d e  X  X  X  H:deheap () ; 10: if d e  X  d= | Q | then 11: breaks; 12: else if e is not an object then 13: for each child e:c of e do 14: H:enheap (  X  e:c; mindist ( q m ; e:c )  X  ); 15: else 16: retrieve e  X  X  candidate result e:CR based on Algorithm1; 17: if || e; Q  X  e:CR || sum  X  d then 18: d  X  X | e; Q  X  e:CR || sum ; S  X  X  X  e; e:CR  X  ; 19: return S ;
In the following, we use an example, as shown in Figure 1, to illustrate how FP algorithm works. Here, Q = { q 1 , q 2 , q { p 1 , p 2 , p 3 , p 4 , p 5 , p 6 }, n = 2, and C ={ c 1 , c c , c 8 , c 9 , c 10 , c 11 }. First, we derive the geometry center q all the query points, denoted as the green triangle in Figure 3, and locate its nearest target point p 1 (i.e., q m :N N = p 1 we adopt the best-first order for NN search, and we maintain all the unexamined nodes in H for later exploration. Thereafter, we invoke Algorithm 1 to find the candidate result p 1 :CR of p is { c 1 , c 2 }. We initialize the result set S as  X  p 1 evaluate the nodes maintained in H . This is to continue previous NN search, and try to locate the next NN objects of q m . As we do not depict the R-tree structure of target points, we use target points the target points whose Euclidean distance to q m do not exceed 6 , i.e., the target points located inside the shaded circle centered at q m as shown in Figure 3 1 . Then, we retrieve p 2 as the next NN of q m and its corresponding candidate result and update the pruning
Note that the shaded circle may keep shrinking as better results are retrieved and pruning distance d gets reduced. distance to a smaller value 16. Next, we explore target point p retrieve its candidate result { c 5 , c 7 }. After the evaluation of p algorithm can terminate as the rest objects have their mindist to q is  X  p 2 ; p 2 :CR (= { c 3 ; c 4 } )  X  .
In this section, we conduct several experiments to evaluate the performance of proposed FP algorithm in supporting MANN queries. In addition, we also implement baseline algorithms, i.e., the p -oriented algorithm explained in Section 1 as the competitors. The performance metrics considered include the total execution time and I/O cost. All the algorithms were implemented in C++. The ex-periments are conducted on a machine with an Intel Core i7-3770 CPU @ 3.40GHz and 16GB RAM. We assume the buffer size is 1Mb, managed by LRU, and the page size is 4Kb.

We use the real road network California Road Network[6]. Based on the road network, we generate the target points and candidate points uniformly. Three parameters are studied, and they are i) the value of n , . In each set of experiments, we only change the value of one parameter while fixing others at their default values. Table 3 lists the settings for each parameter, and the bold one represents the default setting. Notice that the Euclidean extent of Q is defined as the ratio of the area of the minimum bounding rectangle (M-BR) of Q to the overall area of the MBR corresponding to the road network. In each set of experiments, 10 queries are generated ran-domly, and the average performance is reported in the following.
P arameter V alue size of Q 4, 8, 16 , 32, 64
Q  X  s Euclidean extent 1 % , 2 % , 4 % , 8 % , 16 % v alue of n 4, 8, 16 , 32, 64
Our first set of experiments is to evaluate the impact of the search performance, with the results shown in Figure 4. It is obvious that FP performs much better than the baseline algorithm. For example, compared with the baseline algorithm, when | 16 and sum is the function considered, FP only takes about 1% execution time.

Our second observation is that the impact of | Q | is quite dif-ferent between different functions. When sum is considered, F-P cuts down its execution time as | Q | increases. This is because given a fixed n setting, when | Q | enlarges, the pruning distance less target points are evaluated which helps to improve the search performance. From our statistics, when | Q | increases to 64, FP only needs to explore about 26% target points of that when 4.

On the other hand, when max is considered, the cost of FP in-creases. As | Q | increases, it is very likely the maximum distance from a target point to a query point enlarges as well and hence less target points are pruned. Our second set of experiments is to evaluate the impact of the Euclidean extent of Q on the search performance, shown in Fig-ure 5.

As the Euclidean extent of Q enlarges, the pruning distance used in our algorithms always gets larger, and we compare the Euclidean distance d e ( p; q m ) between the evaluated target point p and Q  X  X  geometry center q m with the pruning distance. As the Euclidean be visited as the Euclidean extent of Q increases. Nevertheless, FP is still 7 times faster than the baseline algorithm in the worst case, i.e., Q % is 16 and max is considered.
Our last set of experiments is to investigate the impact of n on the overall performance, and the result is depicted in Figure 6. We observe that the impact of n is dependent on the function consid-ered. when sum is considered, both the execution time and I/O cost increase as n increases. The reason is just contrary to that of |
Q | , given a fixed | Q | setting, when n enlarges, the pruning dis-and hence more target points are evaluated which leads to the in-crease of the cost.
On the other hand, when max is considered, the effect of n is much less. But notice that, the cost starts to increase a little no-table when n increases to 64, which is four times of | Q | || p; Q  X  p:CR || max may be affected by || p; p:CR || max as there are much more candidate points in the candidate result of a target point.
Nearest Neighbor(NN) query and its variants in road networks have been well studied. [8] introduces a storage scheme for object search in road networks and proposes two algorithms. Hereafter many efficient algorithms have been proposed [3, 4, 2, 9, 5].
The most related studies to our problem are group queries [11, 12, 7, 10]. [11] is the first work to process ANN query in road networks. [12] presents a pruning technique based on the network Voronoi diagram to accelerate ANN query processing. [7, 10] can be regarded as two special cases of ANN query. While they all assume that the query points are given, while in MANN queries, the query points are consisted of the given query points and multiple points needed to be selected from a candidate set. MANN queries will find the optimal aggregate point as well as the undetermined query points. This paper studies the merged aggregate nearest neighbor (MAN-N) query. We develop an algorithm for processing this query, the Fast-Pruning algorithm. It uses the Euclidean aggregate distance between a target point and the query set as the pruning distance to prune away unnecessary target points, the experiment results show that it can discard a considerable part of target points which in turn save the execution time and I/O cost.
This research is supported in part by the National Natural Sci-ence Foundation of China (NSFC) under grant 61073001.
Additional author: Yan Huang (University of North Texas, e-mail: huangyan@ntu.edu ) [1] G. R. Hjaltason and H. Samet. Distance browsing in spatial [2] H. Hu, D. L. Lee, and V. Lee. Distance indexing on road [3] M. Kolahdouzan and C. Shahabi. Voronoi-based k nearest [4] H. Kriegel, P. Kr X ger, P. Kunath, M. Renz, and T. Schmidt. [5] K. C. Lee, W.-C. Lee, B. Zheng, and Y. Tian. Road: a new [6] F. Li, D. Cheng, M. Hadjieleftheriou, G. Kollios, and [7] D. Papadias, Q. Shen, Y. Tao, and K. Mouratidis. Group [8] D. Papadias, J. Zhang, N. Mamoulis, and Y. Tao. Query [9] H. Samet, J. Sankaranarayanan, and H. Alborzi. Scalable [10] D. Yan, Z. Zhao, and W. Ng. Efficient algorithms for finding [11] M. Yiu, N. Mamoulis, and D. Papadias. Aggregate nearest [12] L. Zhu, Y. Jing, W. Sun, D. Mao, and P. Liu. Voronoi-based
