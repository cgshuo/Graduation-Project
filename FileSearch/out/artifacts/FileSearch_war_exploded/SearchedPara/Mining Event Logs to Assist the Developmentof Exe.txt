
Nguyen Ngoc Chan 1 , Karn Yongsiriwit 2 , Walid Gaaloul 2 , and Jan Mendling 3 A process variant is an adjustment of a business process to flexibly adapt the support many variants of the same process due to constraints from regulations, geography, religion, etc. For example, car rental companies, such as Hertz, Avis or Sixt, need to customize their reservation process to follows laws in a country or culture of a region. Suncorp, one of the largest Australian insurance group, has developed more than 30 different variants of the process of handling an insurance claim [32].

In recent years, there have been many efforts on facilitating the development of business process variants such as (i) using available reference models to be individualized to fit the requirements [14, 31], or (ii) finding existing similar models to inspire the new process design [4, 15, 35]. However, the design with and time-consuming design [3]. Meanwh ile, recommending entire process models costs much computation time, especially when the number of activities is large. Large models are also not handy for a designer who needs to pick a specific piece of functionality from them. In this context, it is desirable to recommend only a small but well-selected set of activities in order to help the designer.
Prior research has emphasized the adv antages of recommendations during process model design [11 X 13, 21]. However, business process models do not al-ways exist in large-scale information systems such as ERP, CRM, or workflow management systems [1], even when process logs are available. Executable pro-cess models also require detailed techni cal activities to be recommended, while conceptual process models often describe processes in a coarse-granular way [6]. Moreover, process models do not explicitly show the importance of activities or connection flows, which can be a valuabl e parameter to compute more precisely the similarity between two activities. Meanwhile, this information is recorded in process event logs in the form of traces and their frequency.

In this paper, we propose an approach that builds upon process event logs for making activity recommendations during the development of executable process variants. We examine the relationbetween activities based on their execution order frequency provide the basis for the computation of the similarity between activi-which might be closely related to the one that has just been added to the model.
The rest of the paper is organized as fo llows. Section 2 presents an example that motivates our approach. Section 3 continues with the process model and the neighborhood context graph extracted from logs. Section 4 defines the recom-mendation approach. Section 5 presents the implementation and experimental results. Section 6 discusses related work before Section 7 concludes the paper. Consider a process designer who is about to develop a new variant of a liability claim process of an insurance company (inspired from[28]). She starts her work by either retrieving an existing process or quickly designing a new one based on activity A), and then a full check is performed (B). Afterwards, the claim will be evaluated (D), and then it is either rejected (F) or approved (E and G). Finally, the case is archived and closed (H ).

To develop a new variant, the designer may need recommendations for certain positions of the current process. Our approach assist her by providing recom-mended activities for at each selected position. For example, in Fig. 2, K is recommended for A, C is recommended for B and so on. These recommenda-tions possibly help her easily have new ideas to design a new process variant, for instance, as given in Fig. 3.
Recommendations for each activity are made based on their similarity. The computation of this similarity can be b ased on process event logs even when a a-priori process model is not available.

To elaborate the steps to recommendations in our approach, we use the exam-ple of a liability claim process within an insurance company that was presented in [28] and another example of a custom er subscription process. Table 1 and Table 2 present the process event logs of these processes. Each process instance Forexample,consideratrace  X  = ABCD , activity B is performed after activity A and before activity C. The third column of Table 1 and Table 2 presents the repetition of a trace that was previously executed.

In the following, we present an approach to build log-based business process models based on process event logs. These models provide the basis for defining a notion of activity neighborhood context, which we utilize for computing the similarity between activities. In this section, we present the log-ba sed business process and the neighbor-hood context that are captured from business process logs. We firstly present some definitions related to business pro cess logs (section 3.1). Then, we present borhood context (section 3.3). 3.1 Preliminaries According to [1] and [29], a business process log is defined as follows. Definition 1 (Log trace, business process log, L ). Let A be a set of activ-alogtrace. L  X  X  ( A  X  ) is a business process log 1 .
 a trace. For example, in Table 1, L includes only traces 1, 2, 3, 6 and 7. Traces 4 and 5 are excluded by L as they repeat traces 2 and 1. In our approach, we includes all log traces.
 Definition 2 (Full business process log, L  X  ). A full business process log is denoted by L  X  ,L  X   X  X   X  ( A  X  ) . L  X  L  X  .
 all traces from 1 to 5, while L includes only trace 1 and 2.
 Definition 3 (Log-based ordering relation, &gt; L ). Let L be a business pro-i  X  X  1 , 2 ,...,n  X  1 } :  X   X  L  X  a B&gt; L D ,andsoon. 3.2 Log-Based Business Process The sequence of activities in a log trace  X  = a 1 a 2 ...a n  X  A  X  presents their ordering relations. A relation between an activity a i and its followed activity a i +1 in the trace  X  ,1 weighted directed graph where the edge X  sweightpresentsthenumberoftimes that the edge was repeated in the log L . This graph is called log-based business process graph (Definition 4).
 Definition 4 (Log-based business process graph). A log business process log L  X   X  X   X  ( A  X  ) where:  X  V L = A = { a 1 ,a 2 ,...,a n } ,  X  E L = { ( a i ,a j )  X  A  X  A : a i &gt; L a j } X  A  X  A ,  X  w is a weight function from E L to N : For example, the log-based business process graphs of the event logs given in Table 1 and Table 2 are depicted in Fig. 4. The weight of each flow is the number of times that the flow is executed. It is emphasized by the arrow X  X  thickness.
The log-based graph presents the execu tion of a business process in reality, regardless its conceptual model. The wei ghts of edges present their execution frequency which indicates the strength of relations between activities. In the following, we present our approach to build the neighborhood context of an activity based on these relations. 3.3 Log-Based Neighborhood Context We define the log-based neighborhood cont ext as a directed labeled graph that presents the shortest path from an activity to its neighbors. Intuitively, the closeness between activities is presen ted by the paths connecting them. The shortest path between activities presents their closest relation. The log-based neighborhood context of an activity presents the best relations between the activity and its neighbors.

In a log-based neighborhood context g raph, each vertex is associated to a number that indicates the shortest path length from it to the associated activ-on the same layer around the associated activity. Thus, we name the number associated to each activity in a neighborhood context graph layer number .The layer number of an activity a is denoted by l ( a ). The area limited between two adjacent layers is called zone . The edge connecting two vertexes in a neighbor-hood context graph belongs to a zone as t he vertexes are on the same or adjacent layers. We assign to each edge a number, so-call zone number , which determines the zone that the edge belongs to.

The edge connecting a j , a k in the neighborhood context graph of an activity a same layer, the edge connecting them bel ongs to the outer zone of their layer, which is limited by layers l ( a j )and l ( a j )+1.
 Definition 5 (Activity neighborhood context graph). The neighborhood graph G L =( V L ,E L ,w ) with vertex layer numbers and edge zone numbers. The layer number of an vertex a j , denoted by l ( a j ) G has value min ( l ( a j ) G 1. l ( a j ) G 2. z ( a j ,a k ) G
For example, the neighborhood context graphs of activity D and J in Fig. 4 are depicted in Fig. 5. Definition 6 ( k th -neighbor). a is the k th -neighbor of b ,iff l ( a ) G l ( a j ) G N 1 ( D )= { C, B, F, E, G } , N 2 ( D )= { A, H } , N 3 ( D )=  X  ,andsoon. The layer number and the zone number in a neighborhood context graph present present the strength of their relations. In this section, we detail our approach with log-based neighborhood context matching and activity recommendation. 4.1 Neighborhood Context Matching To compute the matching between two nei ghborhood contexts, we (1) compute the matching of their edges in each zone, (2) multiply this matching with a zone-weight value and (3) sum up the matching in all zones.

We apply the vector space model (VSM) to compute the matching of edges in each zone of two neighborhood context g raphs. VSM is a common technique used in Information Retrieval to compute the similarity between two items. It presents items in vectors and compute their similarity based on the cosine of the angle between the two corresponding vectors. In our approach, we present each zone as a vector of which elements are edges and values are their corresponding weights. Then, we align elements that connect the same activities in the same layers. Next, we present these vectors in the same space by filling 0 values in corresponding positions of the unaligned elements. Finally, we compute the cosine value of these two zone-vectors.

Particularly, in the first zone, we match the edges that connect the two asso-ciated activities to the same activities in the first layer. To formalize our com-putation, we define the two associated activities as root activities and name them r 0 .

Concretely, assume that P p and P q are two log-based business processes con-P q respectively. We compute the similarity between activities a by applying VSM as following.

Let E k P respectively. Let layers k  X  1and k , k&gt; 0. We have:
As we define the two associated activities as root activities and name them r , we have: N 0 P Let E k c be the set of common edges of a and b in k th -zone.

Let By applying VSM, the similarity between a and b in the k th zone is given by Equation. 1.

For example, we have: the common neighbors of D and J in the 1 st -layer are N 1 c ( D,J )= { F,G,B } .So,  X   X  X  X   X  e is:
In the 2 nd -zone, we have the common edges of these two context graphs are: ( F,G )and( G, H ). So, their matching in this zone is: neighbors. Therefore, we propose to consider a zone weight in our matching. Con-cretely, as the zone-weight has t o have greater values in smaller k th connection zone, we propose to assign the zone-weight a value computed by a polynomial function which is w z j = k is the number of considered zones around an associated activity. The closest zone to the associated activity has a weight 1 and the farthest zone has a weight 1 k . The final matching formula improved with the zone weight consideration is given in Equation 2.
 For example, the matching between the neighborhood contexts of D and J (in 2 zones) with zone weights is:
M  X  ( D,J )= 4.2 Activity Recommendation The neighborhood context graph presents the interactions between the associ-ated activity and its neighbors in layer s. It can infer the behavior of the asso-ciated activity. Therefore, the matching between neighborhood context graphs exposes the similarity between the associ ated activities. In our approach, the higher the matching value is, the more similar the activities are. Basically, the steps to make recommendations based on log-based neighborhood context matching are: 1. We represent the business execution logs in a log-based graph. This graph 2. For each activity in the log-based graph, we build a neighborhood context 3. We compute the matching between neighborhood context graphs using vec-4. Finally, for a selected activity, we sort other activities in descending order 4.3 Computational Complexity In our approach, only the connection flows connecting common neighbors in two adjacent layers are taken into account for the matching computation. So, by using queues (data structure) to store the common neighbors and track them from the neighbors . On the other hand, the number of activities as well as the number of common neighbors in a log-based business process are not great 2 , our algorithm can run fast in computing the neighborhood context matching of two activities. The worst case of this algorithm X  X  computation time is O ( n A  X  n P  X  n  X  k ), where n A is the number of activities, n P is the number of business processes, n is the maximum number of common activities located on a layer and k is the number of considered layers. The worst case only happens when all the business processes in the system are entirely matched. In addition, the performance of thealgorithmcanbeimprovedbyprocessi ng the neighborhood context matching periodically off-line. To validate our approach, we implement a tool that generates recommendations based on business process logs. We also perform experiments on a large pub-lic dataset shared by the IBM Business Integration Technologies (BIT) team. Details of our implementation (section 5.1) and experiments (section 5.2) are presented as follows. 5.1 Implementation We implemented an activity recommendation plug-in and integrated it into mendations for each selected activity in the ProM interface. This application 3 was developed to validate our approach as a proof of concept.

The screen-shot of our application is shown in Fig. 6. It includes of 8 ar-eas. Areas 1 and 4 allow selecting event lo g resources, which can be either from a database or a log files directory. The d esigner selects a working process in area 2 and specifies a zone number to be co nsidered by the algorithm in area 3. The working process is shown in area 5. The designer can select an activity in the working process to obtain recommendations. Area 6 shows the top-5 rec-ommended activities without zone-weight in the computation. Meanwhile, area 7 shows the top-10 recommended activities with zone-weight consideration. If the designer selects a reco mmended activity in area 6 or 7, this activity and its involved process will be shown in area 8 (the selected activity is highlighted). 5.2 Experiments A big challenge of our approach is the availability of real business process logs. We attempted to search and contact other research groups for both public and private logs. However, process event logs are not published or they are not under a disclosure agreement. There are very few logs that are shared for the competi-tion of the BPI challenge 4 . But they are not usable in our approach as they are We performed experiments on logs generated from real business processes. Data of these processes were shared by the IBM Business Integration Tech-nologies (BIT) team. This dataset includes 735 different processes in Petri net Markup Language (PNML) format. These processes are designed for insurance, banking, customer relationship, as well as construction and automotive supply chain domains [20].

We transformed the collected busines sprocessmodelsfromPNMLformatto the Colored Petri Net (CPN) format. Then, we used CPN Tools 5 to load the transformed process models to generate p rocess event logs, which are resulted in XES files. Finally, these log files were imported by our application, which is a ProM plugin, to display the log-based business process graphs, compute the similarity between activities and show r ecommendations (as pr esented in Fig. 6). Details of the log-based dataset is given in Table 3.

We perform two experiments to evaluate the feasibility and the accuracy of our approach. In the first experiment, we vary the k th -zone values from 1 to 5 and make statistics on the number of r ecommended activities for each selected activities. Fig. 7 shows the percentage of activities that have at least 1 recom-mended activity with the similarity value is greater than 0, 0.5 and 0.8.
Concretely, we obtained that more than 76 . 56% activities that have at least one similarity value greater than 0 with k variesfrom1to5.With k =1,we obtained 53 . 68% activities with similarity value greater than 0.5 and 23 . 31% activities with similarity value greater than 0.8. These results show that our ap-proach can provide recommendations for a majority activities as we can retrieve similar activities for more than 3/4 number of activities in average. It means that our approach is feasible and can be applied in real use-cases.
In the second experiment, we evaluate the accuracy of our approach based on Pre-cision and Recall metrics. As our approach takes into ac-count neighborhood contexts instead of activity identifiers, we consider activity identi-fiers as ground-truth data in computing Precision and Re-call. Concretely, consider a selected activity a in a log-based business process P .
 Assume that a appears in n log-based business processes. The reco mmendations for this selected position these recommendations are given by Equation 3.

The primary objective of the experiment is to retrieve a small share of ac-to retrieve the full range of potentially relevant activities (moderate recall) in order to avoid the desig ner being overwhelmed.

In our experiment, we computed the Precision and Recall with l (number of activities recommended for each selected activity) equal to 1, 4, 7 and 10. We performed the experiment with k th -zone=1 and on activities that appear in at least 2, 5, 7 and 10 different business processes.
Fig. 8 shows that we obtained good Precision values (from 0.42 to 0.59) in case of recommending 1 activity for each se lected activity. These values decrease when we increase the number of recomme nded activities. On the other hand, activities that appear in more processes will have greater Precision values. It also shows that the Recall values increase when l (or top-N) changes from 1 to 10. This means that we can retrieve more relevant activities when the number of recommended activities increases. The highest Recall value in our experiment is 0.264 when l =10. Fig. 9 shows the average Precision and Recall values of our approach with differ-ent k th -zone values. It shows that our approach achieved much better results than an approach that generates rec-ommendations randomly (in average, 8.6 times greater the Precision value and 17.4 times greater the Recall value).

The Precision and Recall values showed that our approach retrieve not only the right activities but also increases when the number of recommended a ctivities increases. These results showed that our approach can be applied in real use-cases as we can provide the designer the flexibility in using existing process fragments or designing new process variants. Computing the similarity of two process models first requires the definition of a mapping between the activities using automatic matching techniques [17]. Prin-ciples for matching process models have been integrated in the ICoP frame-work [33] and extended with semantic matching techniques [23]. Applications in the area of supporting process model design adopt such semantic techniques, as ommendation approach reported in [21]. Approaches to harmonize structure [27] and labels [24] were also proposed. Se rvice recommendation [9, 10] can be also applied in the context of activity recomme ndation. Behavioral abstractions such as trace adjacency [5, 36] and weak order relations[19, 34] provide a means to compare process behavior [15, 16, 22]. These notions are applied, e.g., for iden-tifying connections between actions [30] comparable to our notion of activity neighborhood. Our approach builds on this observation to make recommenda-of the entire model. We recommend activities instead of process models and we do not face the computational complexity problem.

In our previous work [11 X 13], we exploited activity relations in process models and we did not take into account the occurrence frequency of activities. In this work, we realize that knowledge from process logs can be also utilized for process design by applying process mining techniques. Different techniques have been de-fined for automatically discovering whole models from logs, e.g. [1, 18, 26]. The automatic matching between event logs and process models is discussed in [6] showing that logs on the execution level are often much more detailed than mod-els. The challenge of process mining is the observation that process models often turn out to be overwhelmingly complex, so-called spaghetti models [2]. The ap-proach reported in this paper helps to present correlations between activities in a context-specific way, which allows us to hide the complexity of the behavior. Hidden knowledge in process event logs are discovered for assisting business pro-cess design. In this way, we complement log-based recommendation approaches to support process designers at runtime [7] or at configuration time [8]. In this paper, we addressed the challenge of supporting the designer during the act of modeling, even in cases where no comparable process models ex-ist. We present an approach that effectiv ely utilizes knowledge extracted from business process logs for recommending activities. This approach is based on a notion of activity neighborhood and a corresponding calculation of similarity. The approach has been implemented as a plug-in for ProM and evaluated using generated log data of 735 processes from practice.

In future work, we aim to extend the similarity calculation with other prop-erties of an activity such as descriptions, actors, resources and dependencies. We also plan to integrate our neighborhood matching technique with a specific query language to help to retrieve activities that have similar contexts based on a requested activity context.

