 Empty elements in the syntactic analysis of a sen-tence are markers that show where a word or phrase might otherwise be expected to appear, but does not. They play an important role in understanding the grammatical relations in the sentence. For example, in the tree of Figure 2a, the first empty element ( * ) marks where John would be if believed were in the active voice ( someone believed ::: ), and the second empty element ( *T* ) marks where the man would be if who were not fronted ( John was believed to admire who? ).

Empty elements exist in many languages and serve different purposes. In languages such as Chinese and Korean, where subjects and objects can be dropped to avoid duplication, empty elements are particularly important, as they indicate the position of dropped arguments. Figure 1 gives an example of a Chinese parse tree with empty elements. The first empty el-ement ( *pro* ) marks the subject of the whole sen-tence, a pronoun inferable from context. The second empty element ( *PRO* ) marks the subject of the de-pendent VP ( sh X sh X  f X l X  ti X ow X n ).

The Penn Treebanks (Marcus et al., 1993; Xue et al., 2005) contain detailed annotations of empty elements. Yet most parsing work based on these resources has ignored empty elements, with some notable exceptions. Johnson (2002) studied empty-element recovery in English, followed by several others (Dienes and Dubey, 2003; Campbell, 2004; Gabbard et al., 2006); the best results we are aware of are due to Schmid (2006). Recently, empty-element recovery for Chinese has begun to receive attention: Yang and Xue (2010) treat it as classification prob-lem, while Chung and Gildea (2010) pursue several approaches for both Korean and Chinese, and ex-plore applications to machine translation.

Our intuition motivating this work is that empty elements are an integral part of syntactic structure, and should be constructed jointly with it, not added in afterwards. Moreover, we expect empty-element recovery to improve as the parsing quality improves. Our method makes use of a strong syntactic model, the PCFGs with latent annotation of Petrov et al. (2006), which we extend to predict empty cate-gories by the use of lattice parsing . The method is language-independent and performs very well on both languages we tested it on: for English, it out-performs the best published method we are aware of (Schmid, 2006), and for Chinese, it outperforms the method of Yang and Xue (2010). 1 Our method is fairly simple. We take a state-of-the-art parsing model, the Berkeley parser (Petrov et al., 2006), train it on data with explicit empty elements, and test it on word lattices that can nondeterminis-tically insert empty elements anywhere. The idea is that the state-splitting of the parsing model will en-able it to learn where to expect empty elements to be inserted into the test sentences.
 Tree transformations Prior to training, we alter the annotation of empty elements so that the termi-nal label is a consistent symbol (  X  ), the preterminal is deleted (see Figure 2b). This simplifies the lat-tices because there is only one empty symbol, and helps the parsing model to learn dependencies be-tween nonterminal labels and empty-category types because there is no intervening -NONE-.

Then, following Schmid (2006), if a constituent contains an empty element that is linked to another node with label X , then we append = X to its label. If there is more than one empty element, we pro-cess them bottom-up (see Figure 2b). This helps the parser learn to expect where to find empty elements. In our experiments, we did this only for elements of type *T* . Finally, we train the Berkeley parser on the preprocessed training data.
 Lattice parsing Unlike the training data, the test data does not mark any empty elements. We allow the parser to produce empty elements by means of lattice-parsing (Chappelier et al., 1999), a general-ization of CKY parsing allowing it to parse a word-lattice instead of a predetermined list of terminals. Lattice parsing adds a layer of flexibility to exist-ing parsing technology, and allows parsing in sit-uations where the yield of the tree is not known in advance. Lattice parsing originated in the speech processing community (Hall, 2005; Chappelier et al., 1999), and was recently applied to the task of joint clitic-segmentation and syntactic-parsing in Hebrew (Goldberg and Tsarfaty, 2008; Goldberg and Elhadad, 2011) and Arabic (Green and Man-ning, 2010). Here, we use lattice parsing for empty-element recovery.

We use a modified version of the Berkeley parser which allows handling lattices as input. 2 The modifi-cation is fairly straightforward: Each lattice arc cor-respond to a lexical item. Lexical items are now in-dexed by their start and end states rather than by their sentence position, and the initialization proce-dure of the CKY chart is changed to allow lexical items of spans greater than 1. We then make the nec-essary adjustments to the parsing algorithm to sup-port this change: trying rules involving preterminals even when the span is greater than 1, and not relying on span size for identifying lexical items.
At test time, we first construct a lattice for each test sentence that allows 0, 1, or 2 empty symbols (  X  ) between each pair of words or at the start/end of the sentence. Then we feed these lattices through our lattice parser to produce trees with empty elements. Finally, we reverse the transformations that had been applied to the training data. Evaluation metrics for empty-element recovery are not well established, and previous studies use a vari-ety of metrics. We review several of these here and additionally propose a unified evaluation of parsing and empty-element recovery. 3
If A and B are multisets, let A ( x ) be the number of occurrences of x in A , let | A | = let A  X  B be the multiset such that ( A  X  B )( x ) = min( A ( x ) ; B ( x )) . If T is the multiset of  X  X tems X  in the trees being tested and G is the multiset of  X  X tems X  in the gold-standard trees, then where  X  X tems X  are defined differently for each met-ric, as follows. Define a nonterminal node, for present purposes, to be a node which is neither a ter-minal nor preterminal node.

The standard PARSEVAL metric (Black et al., 1991) counts labeled nonempty brackets : items are ( X ; i ; j ) for each nonempty nonterminal node, where X is its label and i ; j are the start and end positions of its span.

Yang and Xue (2010) simply count unlabeled empty elements : items are ( i ; i ) for each empty ele-ment, where i is its position. If multiple empty ele-ments occur at the same position, they only count the last one.

The metric originally proposed by Johnson (2002) counts labeled empty brackets : items are ( X = t ; i ; i ) for each empty nonterminal node, where X is its label and t is the type of the empty element it dominates, but also ( t ; i ; i ) for each empty element not domi-nated by an empty nonterminal node. 4 The following structure has an empty nonterminal dominating two empty elements: Johnson counts this as ( SBAR ; i ; i ) ; ( S = *T* Schmid (2006) counts it as a single ( SBAR-S = *T* ; i ; i ) . 5 We tried to follow Schmid in a generic way: we collapse any vertical chain of empty nonterminals into a single nonterminal.
In order to avoid problems associated with cases like this, we suggest a pair of simpler metrics. The first is to count labeled empty elements , i.e., items are ( t ; i ; i ) for each empty element, and the second, similar in spirit to SParseval (Roark et al., 2006), is to count all labeled brackets , i.e., items are ( X ; i ; for each nonterminal node (whether nonempty or empty). These two metrics, together with part-of-speech accuracy, cover all possible nodes in the tree. English As is standard, we trained the parser on sections 02 X 21 of the Penn Treebank Wall Street Journal corpus, used section 00 for development, and section 23 for testing. We ran 6 cycles of training; then, because we were unable to complete the 7th split-merge cycle with the default setting of merg-ing 50% of splits, we tried increasing merges to 75% and ran 7 cycles of training. Table 1 presents our results. We chose the parser settings that gave the best labeled empty elements F 1 on the dev set, and used these settings for the test set. We outperform the state of the art at recovering empty elements, as well as achieving state of the art accuracy at recovering phrase structure. Chinese We also experimented on a subset of the Penn Chinese Treebank 6.0. For comparabil-ity with previous work (Yang and Xue, 2010), we trained the parser on sections 0081 X 0900, used sections 0041 X 0080 for development, and sections 0001 X 0040 and 0901 X 0931 for testing. The results are shown in Table 2. We selected the 6th split-merge cycle based on the labeled empty elements F 1 mea-sure. The unlabeled empty elements column shows that our system outperforms the baseline system of Yang and Xue (2010). We also analyzed the empty-element recall by type (Table 3). Our system outper-formed that of Yang and Xue (2010) especially on for relative clauses and topicalization. The empty-element recovery method we have presented is simple, highly effective, and fully integrated with state of the art parsing. We hope to exploit cross-lingual information about empty elements in machine translation. Chung and Gildea (2010) have shown that such information indeed helps translation, and we plan to extend this work by handling more empty categories (rather than just *pro* and *PRO* ), and to incorporate them into a syntax-based translation model instead of a phrase-based model.

We also plan to extend our work here to recover coindexation information (links between a moved el-ement and the trace which marks the position it was moved from). As a step towards shallow semantic analysis, this may further benefit other natural lan-guage processing tasks such as machine translation and summary generation.
 We would like to thank Slav Petrov for his help in running the Berkeley parser, and Yaqin Yang, Bert Xue, Tagyoung Chung, and Dan Gildea for their an-swering our many questions. We would also like to thank our colleagues in the Natural Language Group at ISI for meaningful discussions and the anonymous reviewers for their thoughtful sugges-tions. This work was supported in part by DARPA under contracts HR0011-06-C-0022 (subcontract to BBN Technologies) and DOI-NBC N10AP20031, and by NSF under contract IIS-0908532.

