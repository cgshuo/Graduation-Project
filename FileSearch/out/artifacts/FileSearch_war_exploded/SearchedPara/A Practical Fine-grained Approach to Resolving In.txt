 Resolving incoherent terminologies is an important task in the maintenance of evolving OWL 2 DL ontologies. Existing approaches to this task are either semi-automatic or based on simple deletion of axioms. There is a need of fine-grained approaches to automatize this task. Since a fine-grained approach should consider multiple choices for modifying an axiom other than the deletion of axioms only, the primary challenges for developing such an approach lie in both the semantics of the repaired results and the efficiency in com-puting the repaired results. To tackle these challenges, we first introduce the notion of fine-grained repair based on modifying one axiom to zero or more axioms, then pro-pose an efficient incremental method for computing all fine-grained repairs one by one. We also propose a modification function for axioms expressed in OWL 2 DL, which returns weaker axioms. Based on this modification function and the method for computing fine-grained repairs, we develop an automatic approach to resolving incoherent OWL 2 DL ter-minologies. Our extensive experimental results demonstrate that the proposed approach is efficient and practical. I.2.3 [ Artificial Intelligence ]: Deduction and Theorem Proving X  Nonmonotonic reasoning and belief revision ; I.2.4 [ Artificial Intelligence ]: Knowledge Representation For-malisms and Methods X  Semantic networks OWL; description logics; incoherence; repair; fine-grained
The W3C proposal of the Web Ontology Language (OWL) has encouraged more and more ontologies to be developed in real-life applications. Up to now the most expressive while decidable species of OWL is OWL 2 DL, which corresponds to description logic (DL) SROIQ [6]. To enable standard reasoning such as instance checking over an OWL 2 DL on-tology, we should keep the ontology consistent since any-thing is derivable from inconsistency, making standard rea-soning useless. We should also guarantee that the ontology has a coherent terminology (i.e. TBox) in which there is no unsatisfiable concept name, because inconsistency usually results from the existence of instances of unsatisfiable con-cept names [16, 12]. Hence we need to render all unsatisfi-able concept names satisfiable whenever the TBox becomes incoherent. In this paper we will address the problem of restoring the satisfiability of unsatisfiable concept names.
Most existing approaches to the aforementioned problem (e.g. [10, 15, 19, 21]) compute maximal subsets of the TBox in which all the given unsatisfiable concept names become satisfiable. These maximal subsets are simply called MSSes. Using an MSS as the repaired result amounts to removing from the TBox all axioms that are not in the MSS. However, it may not be desirable to delete an axiom as whole or mod-ify the axiom to a single axiom under the consideration that the information of the original TBox should be kept as much as possible. For example, consider a TBox that consists of two axioms Child  X  Adult  X  Young and Adult  X  X  Child , saying that children amount to young adults while adults are not children. It can been seen that this TBox has a unique un-satisfiable concept name Child . To restore the satisfiability of Child , deleting the first axiom Child  X  Adult  X  Young or mod-ifying it to a single axiom such as Adult  X  Young  X  Child will do, but the resulting TBox will keep less information than another coherent one obtained by replacing the first axiom with two axioms Adult  X  Young  X  Child and Child  X  Young . This example shows that allowing to modify one axiom to multiple axioms is a key to restore satisfiability without un-necessarily losing information.

To formally define how to restore satisfiability of concepts by modifying one axiom to zero or more axioms, we intro-duce the notion of fine-grained repair . This notion is based on a modification function that takes an axiom as input and returns a set of axioms that can be modified from the axiom. Given a TBox, a set of unsatisfiable concept names to be re-paired and a modification function for axioms in the TBox, a fine-grained repair is a set of modification operations, each of which modifies an axiom to a subset of the set of axioms returned by the modification function for this axiom, such that the union set of modification results is as large as pos-sible while it restores the satisfiability of all given concept names. Computing fine-grained repairs is harder than com-puting MSSes because it involves multiple choices for mod-i fying an axiom besides two trivial ones namely keeping the axiom intact and deleting the axiom as a whole. Since there exist efficient methods for computing all MSSes (e.g. [15, 9, 21, 26]), it is of practical interest to see whether these meth-ods can be adapted to computing all fine-grained repairs and how well the adaptation will do.

In this paper we give positive answers to the above ques-tions. We show that there is a one-to-one correspondence between fine-grained repairs and MSSes. We also propose an efficient method and some specific optimizations for com-puting all fine-grained repairs. The method incrementally computes fine-grained repairs one by one through the com-putation of MSSes in a modified TBox. This incremental way makes it possible for users to handle a fine-grained re-pair once it is generated without waiting for more repairs to be computed, and to stop computing repairs after a desirable one has been found. To fully automatize the computation of fine-grained repairs, we propose a modification function for axioms expressed in OWL 2 DL. When given an axiom, the modification function returns a finite set of semantically weaker axioms for it. By combining this modification func-tion and the method for computing fine-grained repairs, we develop an automatic approach to resolving an incoherent TBox. Our extensive experimental results demonstrate that this approach is efficient and practical for large TBoxes with up to thousands of unsatisfiable concept names.
 The remainder of this paper is organized as follows. In Section 2 we discuss related work. In Section 3 we give some preliminaries on OWL 2 DL. In Section 4 we formally introduce the notion of fine-grained repair. In Section 5 we describe the proposed method for computing all fine-grained repairs and the proposed modification function. Before con-cluding, we present our experimental evaluation in Section 6. There exist two general strategies to resolving incoherent TBoxes. One is the automatic strategy (see e.g. [10, 15, 19, 21]), adopted in this work, which automatically computes new TBoxes that keep as much information as possible. The other is explanation-based (see e.g. [20, 16, 9, 13, 5, 1, 26]), which automatically pinpoints which axioms or which parts of axioms cause the unsatisfiability, and then relies on users to correct some of these axioms.
 The aforementioned MSSes (i.e. maximal subsets of the TBox that restore the satisfiability of all given unsatisfiable concept names) are commonly computed in the automatic strategy. Based on Reiter X  X  theory [17], the minimal subsets of the TBox that are responsible for the unsatisfiability of at least one given concept name, simply called MUSes, are often computed before the computation of MSSes. In [19, 21] the authors propose some methods for computing MSSes from MUSes using Reiter X  X  hitting set tree (HST) algorithm [17]. In [10] the authors extend Reiter X  X  HST algorithm to compute certain MSSes in which the sum of axiom ranks is minimized. In [15] the authors propose a direct method for computing MSSes without computing MUSes beforehand. The method extends the tableaux-based method for consis-tency checking but works only for unfoldable ALC TBoxes, where ALC is a fragment of OWL 2 DL.

Besides being used to compute MSSes, MUSes are used in the explanation-based strategy to guide users to identify erroneous axioms. In [20] the authors propose a tableaux-based method for computing MUSes in ALC TBoxes. To handle DLs that are more expressive than ALC , in [16] the authors extend the tableaux-based method for consistency checking to compute MUSes. In [26] the authors propose a graph-based method for computing MUSes in OWL 2 EL, a profile of OWL 2 DL that corresponds to a lightweight DL. All the above methods are glass-box methods which depend on specific DLs and currently do not work for OWL 2 DL. In contrast, a black-box method can invoke an existing OWL 2 DL reasoner to compute MUSes. The method proposed in [9] is a typical black-box method for computing all MUSes, but it uses some suboptimal techniques and can further be optimized, as shown in Subsection 5.2.

Some work on the explanation-based strategy addresses fine-grained explanations or isomorphisms between expla-nations. In [13] the authors consider parts of axioms for resolving an incoherent TBox. They propose the notions of harmful and helpful changes to explain what happens when a part of an axiom is deleted. However, this repairing ap-proach can only work in a user-interactive mode, while the kernel computational method only works for unfoldable ALC TBoxes. In [5] the authors present a formal semantics for parts of axioms that are responsible for a logical consequence (such as unsatisfiability) and also propose methods for com-puting it. This semantics does not apply to operations for restoring satisfiability, since what can be obtained from an axiom by deleting a part of it is not well-defined in DLs. For example, it is unclear what is the resulting axiom ob-tained from A  X   X  r.B by deleting the part A  X   X  r.  X  of it. In [1] the authors consider different kinds of isomorphisms between explanations so as to present users with abstract templates about explanations. This work gives users a bet-ter way to understand the causes of unsatisfiability, but it does not deal with operations for restoring satisfiability.
By adopting the explanation-based strategy to resolve an incoherent TBox, it is hard to guarantee that a repaired TBox keeps as much information as possible. The automatic strategy is preferred in the sense of meeting the minimal-change principle. Although the automatic strategy suffers from a problem that it is hard to identify the best MSS among probably multiple MSSes, there exists a query-based selection approach [22] that can solve this problem. This approach computes the best MSS from multiple MSSes by a sequence of queries on entailments. It can be adapted to identifying the best one among multiple fine-grained repairs. We will address this adaptation in our future work.
We recall the syntax of the DL SROIQ [6] which cor-responds to OWL 2 DL. Since an unsatisfiable concept in a SROIQ ontology is mostly caused by the terminological part (simply terminology ) of this ontology, we only consider SROIQ terminologies which are briefly introduced below.
A role r is a role name or the inverse of a role name (called an inverse role , denoted by s  X  for s a role name). A SROIQ TBox consists of a finite set of concept inclusion ax-ioms C  X  D and concept equivalence axioms C  X  D (short for C  X  D and D  X  C ), where C and D are SROIQ con-cepts recursively constructed by  X  ,  X  , A , { a } ,  X  C  X  C  X   X  D  X  ,  X  r.C  X  ,  X  r. Self ,  X  r.C  X  ,  X  n r.C  X  and  X  n a nonnegative integer, A a concept name, a an individ-ual, r a role, and C  X  and D  X  SROIQ concepts. A SROIQ RBox consists of a finite set of complex role inclusion axioms r  X  . . .  X  r n  X  s and role declaration axioms Sym ( r ) ( meaning r is symmetric ), Asy ( r ) ( meaning r is asymmetric ), Ref ( r ) (meaning r is reflexive ), Irr ( r ) (meaning r is irreflexive ) and Dis ( r, s ) ( meaning r and s are disjoint ), where s , r , r r n are roles. We do not mention the global syntax restric-tions on SROIQ that guarantee decidability, because in our work there is no special treatment on these restrictions. A SROIQ terminology consists of a TBox and an RBox [6]. To simplify the presentation, we use the term TBox to stand for both the TBox and the RBox throughout this paper. In addition, we treat a TBox as a set of axioms.

We briefly mention the standard semantics for SROIQ which uses interpretations I = ( X  I , I ), where  X  I is the do-main of I , and I is a mapping function that maps concepts to subsets of  X  I , roles to subsets of  X  I  X   X  I and individu-als to elements of  X  I . A concept inclusion axiom C  X  D is said to be satisfied by an interpretation I if C I  X  D I ; simi-lar definitions on satisfaction apply to other kinds of axioms (see [6]). An interpretation I is called a model of a TBox T if it satisfies all axioms in T . An axiom  X  is said to be entailed by T , written T | =  X  , if  X  is satisfied by all models of T . A concept C is said to be unsatisfiable in T if C I for all models I of T ; i.e., T | = C  X  X  X  . The TBox T is said to be coherent if all concept names in it are satisfiable.
There are three main strategies for resolving an incoher-ent TBox [8]. The first one, called the one-by-one strategy, repairs a single unsatisfiable concept name at a time. The second strategy, called the root-based strategy, repairs all root unsatisfiable concept names together. A root unsatisfi-able concept name is an unsatisfiable concept name for which any contradiction found in related axioms does not depend on the unsatisfiability of other concept names (see [8, 12] for the formal definition). These two strategies require some it-erations to finish repairing all unsatisfiable concept names. The last strategy, called the one-off strategy, repairs all un-satisfiable concept names at a time. By considering all these strategies we intend to address the following problem: given a set C of unsatisfiable concept names in a TBox T , where C is determined by the strategy adopted, how to restore the satisfiability of C , i.e., to render all concepts in C satisfiable?
To solve this problem we need to modify axioms in T to restore the satisfiability of C while keeping as much informa-tion of T as possible. Since some axioms in T are designed carefully and cannot be modified, we should enforce these axioms to be intact in a repaired TBox. Therefore we as-sume that T has a user-specified background subset B in which none of axioms can be modified. As discussed in Sec-tion 1, to guarantee that the repaired TBox keeps as much information as possible, we assume that every axiom in T \B is modified to zero or more axioms. Furthermore, to make the repaired TBox concise, for the set of axioms that can be modified from one axiom, we need to keep only those axioms in the set, each of which is not entailed by any other axiom in the same set. Hence we only keep the representative sub-set (defined below) of the set of axioms modifiable from one axiom to restore satisfiability.

Definition 1. Given a set S of axioms and a set B of ax-ioms treated as the background knowledge, the representa-tive subset of S w.r.t. B , denoted by rep( S, B ), is defined as {  X   X  S |  X   X   X  S : {  X  } X  X  | =  X , {  X  } X  X  6| =  X  } .
Intuitively, in the above definition {  X  } X  X  | =  X  means that  X  is more informative than  X  w.r.t. B . Moreover, rep( S, B ) consists of all the most informative axioms in S , making rep( S, B )  X  X  entail the same set of axioms as S  X  X  .
We suppose users can provide a modification function  X  : T \B 7 X  2 A SROIQ for all axioms in T \B , where A SROIQ denotes the set of all possible axioms expressed in SROIQ . From the practical point of view, it is often unrealistic for a user to define a modification function, so we will discuss some principles for defining this function and recommend a definition of it in Subsection 5.3. With a modification func-tion  X  , a repaired TBox is of the form B X  S  X   X  X  \B rep( S where S  X  is a subset of  X  (  X  ). We refer to the function that returns a subset of  X  (  X  ) for every  X   X  T \ B as a repair function . A preferred repair function should make the re-paired TBox keep as much information of T as possible. To characterize this preference, we introduce below two classes of repair functions.
 Definition 2. Given a TBox T , a background subset B of T , a set C of unsatisfiable concept names and a modification function  X  : T\B 7 X  2 A SROIQ , an admissible repair function for ( T , B , C ,  X  ) is a function r : T 7 X  2 A SROIQ such that (1)  X  C  X  C : S  X   X  X  r (  X  ) 6| = C  X  X  X  , (2)  X   X   X  X  : r (  X  ) = {  X  } , (3)  X   X   X  X  \B : r (  X  )  X   X  (  X  ) , rep( r (  X  ) , B ) = r (  X  ). An admissible repair function r is called a fine-grained re-pair function for ( T , B , C ,  X  ) if there is no admissible repair function r  X  for ( T , B , C ,  X  ) such that r  X  P T r  X  (read r is Pareto-less than r  X  w.r.t. T , and defined below).  X  r  X  P T r  X   X  X  X  r (  X  )  X  r  X  (  X  ) for all  X   X  X   X  r = P T r  X   X  X  X  r (  X  ) = r  X  (  X  ) for all  X   X  X 
In other words, an admissible repair function r for ( T , B , C ,  X  ) is a repair function that keeps axioms in B intact and modifies every axiom  X  in T \B to a representative subset of  X  (  X  ) w.r.t. B , such that every concept in C is rendered satisfiable in the repaired TBox S  X   X  X  r (  X  ). In addition, a fine-grained repair function r is a Pareto-maximal admissible repair function; i.e., there is no admissible repair function r such that (i) r (  X  )  X  r  X  (  X  ) for all  X   X  X  and (ii) r (  X  )  X  r for some  X   X  X  .

We call the result of applying a fine-grained repair func-which is a tuple whose elements express that every axiom  X  in T is either kept intact or modified to a subset of  X  (  X  ). Given a fine-grained repair function r for ( T , B , C ,  X  ) where T = {  X  i } 1  X  i  X  n , the corresponding fine-grained repair is of fine-grained repairs for ( T , B , C ,  X  ), where  X  is fixed to a modification function such that  X  (  X  ) = {  X  } . A fine-grained repair in this class amounts to a maximal subset S of T that includes B (i.e., B  X  S ) and renders all concepts in C satisfiable (i.e., S 6| = C  X   X  for all C  X  C ); in this paper, this S is called a m aximal s atisfiable-preserving s ubset ( sim-ply an MSS ) of T w.r.t. B and C . A running example for fine-grained repairs and MSSes is given below.

Example 1. Let T consist of the following axioms.  X  1 : A  X  X  X  s. ( A  X  B  X  C )  X  2 : A  X  X  X  r. ( A  X  B )  X  X  X   X  3 : A  X   X  r. ( A  X  C )  X   X   X  4 : A  X   X  r. ( B  X  C )  X   X   X  5 : s  X  r A i s unsatisfiable in T . Let the background subset B of T consist of the last axiom  X  5 . Suppose the modification func-tion  X  : T \B 7 X  2 A SROIQ is such that  X  (  X  1 ) = {  X  1  X  ,  X  9 } and  X  (  X  i ) = {  X  i } for i = 2 , 3 , 4, where  X  A  X   X  s. ( A  X  B ),  X  7 denotes A  X   X  s. ( A  X  C ),  X  8 denotes A  X   X  s. ( B  X  C ), and  X  9 denotes A  X   X  s.A  X  X  X  s.B  X  X  X  s.C . Then (  X  1 7 X  X   X  1 } ,  X  2 7 X  X  X  ,  X  3 7 X  X  X  ,  X  4 7 X  X  X  ,  X  5 7 X  X   X  a fine-grained repair for ( T , B , { A } ,  X  ). It corresponds to an MSS {  X  1 ,  X  5 } of T w.r.t. B and { A } . There are seven other fine-grained repairs for ( T , B , { A } ,  X  ), each of which con-tains some axioms not in T and has no corresponding MSS of T w.r.t. B and { A } (see Example 2). The current exam-ple shows that some fine-grained repairs may correspond to MSSes, but the set of fine-grained repairs may not have a one-to-one correspondence to the set of MSSes.
Considering that there exist efficient methods for comput-ing all MSSes, we intend to adapt these methods to comput-ing all fine-grained repairs. Although there is no one-to-one correspondence between the set of MSSes and the set of fine-grained repairs in the same TBox, we find that a one-to-one correspondence exists in two different TBoxes. Let T  X  = B  X  S the union of the background subset B and all sets of axioms that can be modified from axioms in T \B . By introduc-ing a mapping function map( T , B ,  X , S ) for any subset S of T  X  that includes B , we can establish a one-to-one cor-respondence between the set of MSSes of T  X  w.r.t. B and C and the set of fine-grained repairs for ( T , B , C ,  X  ). The mapping function map( T , B ,  X , S ) is defined as a function r : T 7 X  2 A SROIQ such that r (  X  ) = {  X  } for all  X   X  B and r (  X  ) = rep(  X  (  X  )  X  S, B ) for all  X   X  X  \B . This function has an important property given below.

Lemma 1. Let r = map( T , B ,  X , S ) where S is a subset of T  X  = B X  S  X   X  X  \B  X  (  X  ) such that B  X  S , then S  X  B X  S  X   X  X  \B {  X   X   X  (  X  ) | X   X 
Proof. Let S  X  = B X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X   X  } X  X  | =  X  } . Suppose there exists an axiom  X  in S \ S  X  Since ( S \ S  X  )  X  X  =  X  and S  X  X   X  , there must be some  X   X  T \B such that  X   X   X  (  X  ). In case  X   X  r (  X  ), then {  X  } X  X  | =  X  and thus  X   X  S  X  , contradicting  X  6 X  S  X  . In case  X  6 X  r (  X  ), then there exists an axiom  X   X  rep(  X  (  X  )  X  S, B ) = r (  X  ) such that {  X  } X  X  | =  X  , thus  X   X  S  X  , also contradicting  X  6 X  S  X  S \ S  X  =  X  , i.e., S  X  S  X  .

The above lemma shows that B  X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X   X  } X  X  | =  X  } for r = map( T , B ,  X , S ) is a superset of S that entails the same set of axioms as S does. Based on this lemma we obtain a one-to-one mapping from MSSes of T  X  w.r.t. B and C to fine-grained repair functions for ( T , B , C ,  X  ), as shown in the following theorem.
Theorem 1. Let T  X  = B X  S  X   X  X  \B  X  (  X  ) . (1) For an ar-bitrary MSS S of T  X  w.r.t. B and C , map( T , B ,  X , S ) is a fine-grained repair function for ( T , B , C ,  X  ) . (2) For an ar-bitrary fine-grained repair function r for ( T , B , C ,  X  ) , there exists a unique MSS S of T  X  w.r.t. B and C such that r = P T map( T , B ,  X , S ) .

Proof. (1) Let r = map( T , B ,  X , S ). Since S is an MSS of T  X  w.r.t. B and C , we have S 6| = C  X   X  for all C  X  C . Since S  X   X  X  r (  X  )  X  S , we also have S  X   X  X  r (  X  ) 6| = C  X   X  for all C  X  C . Moreover, since r (  X  ) = {  X  } for all  X   X  B S, B ) = r (  X  ) and r (  X  )  X   X  (  X  ) for all  X   X  T \B , r is an admissible repair function ( T , B , C ,  X  ). Suppose r is not a fine-grained repair function for ( T , B , C ,  X  ), then there exists an admissible repair function r  X  for ( T , B , C ,  X  ) such that r  X  P T r  X  . Let S  X  = B  X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X  {  X   X  } X  X  | =  X  } , then r  X  = P T map( T , B ,  X , S  X  ) and S Since r  X  is an admissible repair function for ( T , B , C,  X  ), we have S  X   X  X  r  X  (  X  ) 6| = C  X   X  and thus S  X  6| = C  X   X  , for all C  X  C . Since B  X  S  X  T  X  and r  X  P T r  X  , by Lemma 1 we have S  X  B X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X  B | =  X  }  X  S  X  . It cannot be such that S  X  S  X  , otherwise S must not be an MSS of T  X  w.r.t. B and C . Therefore S = S . But then r = map( T , B ,  X , S ) = map( T , B ,  X , S  X  r , contradicting r  X  P T r  X  . Hence r is a fine-grained repair function for ( T , B , C ,  X  ). (2) Let S = B X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X  repair function for ( T , B , C ,  X  ), we have S  X   X  X  r (  X  ) 6| = C  X   X  and thus S 6| = C  X  X  X  , for all C  X  C . Since S  X  X   X  , there must be an MSS S  X  of T  X  w.r.t. B and C such that S  X  S  X  Let r  X  = map( T , B ,  X , S  X  ). By (1) we can see that r fine-grained repair function for ( T , B , C ,  X  ). Since S  X  S we have r = P T r  X  . Since B  X  S  X   X  T  X  , by Lemma 1 we have S  X  X  X  S  X   X  X  \B {  X   X   X  (  X  ) | X   X   X   X  r  X  (  X  ) : {  X   X  } X  X  | =  X  } = B X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X   X  } X  X  | =  X  } = S . Hence S = S  X  is an MSS of T  X  w.r.t. B and C such that r = P T map( T , B ,  X , S ). Let S  X  be another MSS of T  X  B and C such that r = P T map( T , B ,  X , S  X  ). By Lemma 1 we also have S  X   X  B  X  S  X   X  X  \B {  X   X   X  (  X  ) |  X   X   X   X  r (  X  ) : {  X   X  } X  X  | =  X  } = S . Since S  X  is an MSS of T  X  w.r.t. B and C , we must have S  X  = S , hence S is the unique MSS of T w.r.t. B and C such that r = P T map( T , B ,  X , S ).
The above theorem holds for an arbitrary modification f unction  X  even when it returns an infinite set of axioms for a given axiom. Hence we obtain a general method for com-puting all fine-grained repairs for ( T , B , C ,  X  ). This method computes all MSSes of T  X  = B X  S  X   X  X  \B  X  (  X  ) w.r.t. B and C one by one. Whenever an MSS S is generated, it computes map( T , B ,  X , S ) as a non-redundant fine-grained repair func-tion for ( T , B , C ,  X  ), and then directly translates this repair function to a fine-grained repair.
We now move to a problem in the computational aspect: how to efficiently compute all MSSes of a TBox T w.r.t. a background subset B and a set C of unsatisfiable concept names? We propose a method that is different from existing methods discussed in Section 2, which either work only for unfoldable ALC TBoxes [15] or need to compute beforehand all minimal subset S of T such that at least one concept in C is unsatisfiable in B X  S [10, 19, 21]; in this paper, this S is called a m inimal un satisfiable-preserving s ubset ( simply an MUS ) of T w.r.t. B and C . Instead, we adapt the method proposed in [18] to directly computing MSSes.
The method proposed in [18] was originally designed for c omputing minimal revised subsets of a Horn theory to ren-der the theory consistent, based on a dualization property that the set of minimal inconsistent subsets and the set of minimal revised subsets are mutually minimal hitting sets [17], where a minimal hitting set H for a set S of sets is a minimal set of elements appearing in S such that H  X  S 6 =  X  for all S  X  S . By treating MUSes as minimal inconsistent subsets and MSSes as complementary sets of minimal re-vised subsets, the method can be adapted to computing all MSSes. A similar adaptation has been shown in [3]. The adapted method will take O ( m ) n MSS + n MUS satisfiability tests to compute all MSSes, where m is the cardinality of T \B , n MSS is the number of MSSes, n MUS is the number of MUSes. However, as shown in [3] that n MUS is generally smaller than n MSS . To make the computation more effi-cient, the adaptation in [3] can further be optimized to take only n MSS + O ( m ) n MUS satisfiability tests.

This optimized method is shown in Figure 1. Basically, the method exploits the minimal hitting sets (simply MH-Ses) for the set of currently computed MUSes to facilitate the computation of new MUSes. It computes MHSes and MUSes simultaneously, where an MHS for the set of all MUSes is actually the complementary set of an MSS. Let { U 0 , ..., U i  X  1 } be the set of MUSes of T w.r.t. B and C that are currently computed. We intend to compute a new MUS that differs from U 0 , ..., U i  X  1 . To this end, the method computes an MHS M for { U 0 , ..., U i  X  1 } . In case T \ M 6| = C  X   X  for all C  X  C , there must be an MHS M  X  for the set of all MUSes of T w.r.t. B and C such that M  X  M  X  . Since T \ M  X  is an MSS of T w.r.t. B and C , we must have M = M  X  and thus T \ M is output as an MSS of T w.r.t. B and C (line 2 in ConstructMUS). In case T \ M | = C  X  X  X  for some C  X  C , there must be a new MUS of T w.r.t. B and C that is included in T \ ( B X  M ) and differs from U 0 , ..., U i  X  1 , thus a new MUS is computed by calling FindMUS (line 3 in ConstructMUS). In FindMUS we adapt a divide-and-conquer algorithm [7] to computing a minimal conflict set. It requires in the worst case O ( k log( m k fiability tests, where m is the cardinality of T \ ( B X  M ) and k is the cardinality of the computed MUS.
 For computing MHSes for the set of currently computed MUSes, the method exploits an incremental strategy. Let M be an MHS for { U 0 , ..., U i  X  1 } . We intend to compute an MHS for { U 0 , ..., U i } . If M  X  U i 6 =  X  , M is also an MHS for { U 0 , ..., U i } (line 6 in ConstructMUS), otherwise we try to add an element of U i to M to form a new MHS for { U 0 , ..., U i } (line 8 in ConstructMUS).

There is an important optimization in the method: all ex-plored search paths are guided by MHSes but not by any proper supersets of them. This optimization is sound and complete [18]. As a result, the method requires n MUS calls to FindMUS (line 3 in ConstructMUS) and n MUS + n MSS satisfiability tests (line 2 in ConstructMUS). The total num-ber of satisfiability tests taken is n MSS + O ( k log( m in the worst case, where m is the cardinality of T \B and k is the cardinality of the largest MUS of T w.r.t. B and C .
The following theorem shows the correctness of the above method, which can be proved analogously as the main result in [18].
 Theorem 2. The procedure EnumerateAllMSSes( T , B , C ) given in Figure 1 outputs exactly all MSSes of T w.r.t. B and C .
 The main procedure E numerateAllMSSes( T , B , C ) Input: A TBox T , a background subset B , and a set C of Comments: T , B , C , the number n and the MUSes 1: n  X  0 2: ConstructMUS(0,  X  ) Procedure ConstructMUS( i , M ) Input: The level i and a minimal hitting set M for Comments: All MSSes of T w.r.t. B and C are output one 1: if i = n then 2: if T \ M 6| = C  X  X  X  for all C  X  C then output T \ M 3: U i  X  FindMUS( B , T \ ( B X  M )) 4: n  X  n + 1 5: end if 6: if U i  X  M 6 =  X  then ConstructMUS( i + 1, M ) 7: else 8: for each  X   X  U i such that M  X  X   X  } is a minimal hitting 9: end if Function FindMUS( S u , S c ) Input: A set S u of unchangeable axioms and a set S c of Output: A minimal subset S of S c such that S  X  S u | = C  X  1: if S c =  X  or there is some C  X  C such that S u | = C  X  X  X  2: else if | S c | = 1 then return S c 3: else 4: Divide S c into two disjoint subsets S 1 and S 2 such 5:  X  2  X  FindMUS( S u  X  S 1 , S 2 ) 6:  X  1  X  FindMUS( S u  X   X  2 , S 1 ) 7: return  X  1  X   X  2 8: end if Figure 1: The method for computing all MSSes of T w.r.t. B and C We further introduce some optimizations for the function FindMUS in Figure 1 and for computing fine-grained repair functions from MSSes. An axiom  X  is said to be weaker than another axiom  X  w.r.t. B if {  X  } X  X  | =  X  ; it is said to be model-equivalent with  X  w.r.t. B if {  X  } X  X  | =  X  and {  X  } X  B | =  X  ; it is said to be strictly weaker than  X  if it is weaker than  X  but not model-equivalent with  X  . Let  X  note the set of axioms in S that are model-equivalent with  X  w.r.t. B , and  X   X  B (  X , S ) denote the set of axioms in S that are strictly weaker than  X  w.r.t. B . To compute all fine-grained repair functions for ( T , B , C ,  X  ), by Theorem 1 we can call the procedure EnumerateAllMSSes( T  X  , B , C ) in Figure 1 for T  X  = B  X  S  X   X  X  \B  X  (  X  ). Before calling this procedure, we compute  X  by calling an existing OWL 2 DL reasoner. During a call to the function FindMUS, before computing  X  1 in line 6, we can remove all axioms in S  X   X   X  from S 1 , because these axioms cannot occur in a minimal Figure 2: The execution of EnumerateAllMSSes( T  X  , B , { A } ) in Example 2 subset S of S c such that  X  2  X  S and S  X  S u | = C  X   X  for some C  X  C . Another optimization lies in computing a fine-grained repair function for ( T , B , C ,  X  ) from an MSS S of T  X  w.r.t. B and C . In this computation rep(  X  (  X  )  X  S, B ) needs to be computed for all  X   X  X  \B . Let S  X  =  X  (  X  )  X  S , then rep( S  X  , B ) = S  X  \ S  X   X  S can be efficiently computed using the sets of strictly weaker axioms that are previously computed. We call all these op-timizations the axiom-hierarchy based optimizations .
The following example illustrates our proposed method for computing all fine-grained repairs with axiom-hierarchy based optimizations used.

Example 2. Let T , B , A,  X  be the same notations defined in Example 1. In this example we show how to compute all fine-grained repairs for ( T , B , { A } ,  X  ). We can compute that T  X  = B X  S all  X   X  X   X  ,  X   X  B (  X  1 , T  X  ) = {  X  6 ,  X  7 ,  X  8 ,  X  9 for all  X   X  X   X  \{  X  1 } . We use a hitting set tree to illustrate the execution of EnumerateAllMSSes( T  X  , B , { A } ), as shown in Figure 2, where all axioms are only denoted by their sub-scripts. In the figure, a rectangular node denotes a newly computed MUS of T  X  w.r.t. B and { A } , an octangular node denotes a previously computed MUS of T  X  w.r.t. B and { A } , the set of labels on the edges of a path from the root to a node v denotes an MHS for the set of MUSes appearing in rectangular/octangular nodes (excluding v ) along the path, a circular node marked with  X  (simply a  X  -node) denotes that the path is blocked by a non-MHS, and a circular node marked with T  X  w.r.t. B and { A } is found.

The hitting set tree is constructed from left to right using the depth-first search strategy. Every rectangular node is constructed by a call to the function FindMUS. For exam-ple, the root is constructed by calling FindMUS( B , T  X  \B ). During the execution of this function, T  X  \B is divided into two disjoint subsets S 1 = {  X  6 ,  X  7 ,  X  8 ,  X  9 } and S  X  ,  X  4 } . The recursive calling of FindMUS( B X  S 1 , S 2 ) will return a minimal subset  X  2 of S 2 such that B X  S 1  X   X  2 A  X   X  . In the case indicated by the figure,  X  2 is {  X  1 Then an axiom-hierarchy based optimization is applied to remove all axioms in S  X   X   X  from S 1 , yielding an empty S 1 . Afterwards the recursive calling of FindMUS( B X   X  2 , S 1 ) returns  X  1 =  X  . Hence an MUS  X  1  X   X  2 = {  X  1 ,  X  2 } of T  X  w.r.t. B and { A } is obtained, which forms the root.

We present some examples to show why some paths are blocked by a  X  -node while the others are blocked by a node. For the left-most full path, there are four MUSes {  X  1 ,  X  2 } , {  X  3 ,  X  7 } , {  X  4 ,  X  8 } and {  X  2 ,  X  6 Since {  X  2 ,  X  3 ,  X  4 } is a hitting set for the set of the above four MUSes, the set of axioms denoted by labels on the edges of this path (i.e. {  X  1 ,  X  3 ,  X  4 ,  X  2 } ) cannot be an MHS for the same set, thus this path is blocked by a  X  -node. For the full path next to the left-most full path, since the set of axioms denoted by labels on the edges of this path (i.e. M = {  X  1 ,  X  3 ,  X  4 ,  X  6 } ) is an MHS for the set of MUSes along this path, whether T  X  \ M | = A  X   X  is checked. The result that T  X  \ M 6| = A  X  X  X  implies that T  X  \ M is an MSS of T w.r.t. B and { A } , thus the path is blocked by a
We can collect all MSSes of T  X  w.r.t. B and { A } from the  X  -nodes in the hitting set tree. These MSSes are {  X  2 ,  X   X  ,  X  8 ,  X  9 } , {  X  2 ,  X  4 ,  X  5 ,  X  7 ,  X  9 } , {  X  2 ,  X   X  ,  X  4 ,  X  5 ,  X  9 } , {  X  4 ,  X  5 ,  X  6 ,  X  7 ,  X  9 } , {  X  {  X  3 ,  X  4 ,  X  5 ,  X  6 ,  X  9 } , and {  X  1 ,  X  5 ,  X  6 ,  X  7
By reusing the sets of strictly weaker axioms (i.e.  X   X  B for all  X   X  X   X  ) that are previously computed, we obtain the following fine-grained repairs from the above MSSes.
In [9] the authors have proposed an efficient method for c omputing all MUSes. Similar to our method, it also con-structs a hitting set tree to facilitate the computation of MUSes, but applies less optimal techniques. On the one hand, it uses a weaker condition to prune search paths. Let HS ( v ) be the set of axioms denoted by labels on the edges of a path from the root to a node v . The method blocks a node v either when there is a previously constructed  X  -node v  X  such that HS ( v  X  )  X  HS ( v ), or when all sets that HS ( v ) can be expanded to have been considered in previous paths. It does not guarantee to immediately prune a path when the last node does not correspond to an MSS. For ex-ample, consider the left-most  X  -node v in Figure 2. For this node, the above pruning condition is not satisfied since there is no full path constructed before. Hence the method needs to check whether T  X  \ HS ( v ) = {  X  5 , . . . ,  X  9 }| = A  X  X  X  . Note that T  X  \ HS ( v ) is not an MSS, implying that the method per-forms more satisfiability tests. As a result, the method can-not guarantee to compute all MUSes by n MSS + O ( m ) n MUS satisfiability tests, where m is the cardinality of T  X  \B , while our method can do. On the other hand, the method pro-posed in [9] exploits an expand-then-shrink algorithm for computing an MUS under the reasoner-independent strat-egy. In the worst case this algorithm requires O ( m ) calls to a reasoner. In contrast, the divide-and-conquer algorithm [7] adapted in our method requires only O ( k log( m k ) ) calls to a reasoner, where k is the cardinality of the computed MUS. Taking into account that in practice k is much smaller than m , the divide-and-conquer algorithm is preferred.
To fully automatize the computation of fine-grained re-pairs, there is a problem left: how to define a modification function  X  ? We propose the following five principles. 1.  X  (  X  ) should be finite, otherwise T  X  = B X  S  X   X  X  \B 2.  X  (  X  ) should contain  X  for every axiom  X  , since keeping 3.  X  (  X  ) should contain only weaker axioms w.r.t. the back-4.  X  (  X  ) should not contain two or more model-equivalent 5.  X  (  X  ) should not contain any axiom semantically equiv-
We target modification functions for SROIQ that meet all the above principles. We develop a modification function  X  which reduces the computation for arbitrary axioms to that for concept inclusion axioms if possible.  X   X  ( C  X  D ) = { C  X  D } X   X  ( C  X  D )  X   X  ( D  X  C ),  X   X  (  X  ) = {  X  } if  X  is neither a concept equivalence axiom nor a concept inclusion axiom.

To define  X  ( C  X  D ), we consider a set of concepts more specific than C , denoted by  X  ( C ), and a set of concepts more general than D , denoted by  X  ( D ). The functions  X  and  X  correspond to a downward refinement operator and an up-ward refinement operator defined in [14], respectively. It has been shown [14] that there is no finite, complete and proper refinement operator for ALC or more expressive DLs such as SROIQ , thus we only define  X  and  X  as finite refinement operators. In more details,  X  is defined in a similar way as a finite and incomplete downward refinement operator for ALCQ given in [14], but  X  ( C ) does not contain some con-cepts longer than C and compensates  X  r.C 1  X  . . .  X  X  X  r.C for C =  X  r. ( C 1  X  . . .  X  C n ); in addition,  X  is defined in a re-verse way as  X  . We give the formal definition of  X  ( C  X  D ) below, where N is the user-specified biggest integer used in cardinality restrictions.
This modification function  X  trivially satisfies the first principle. It also satisfies the second principle since C  X   X  ( C ) and C  X   X  ( C ) for an arbitrary concept C . Moreover, it satisfies the third principle since  X  ( C  X  D ) = { C  X  C  X   X   X  ( C ) , D  X   X   X  ( D ) } , where  X  ( C ) consists of concepts more specific than C and  X  ( D ) consists of concepts more general than D . However, for some axioms  X  ,  X  (  X  ) may either contain two or more model-equivalent axioms w.r.t. the background subset B or contain an axiom semantically equivalent with  X  X  X  X  . To meet the last two principles, we remove from  X  (  X  ) all axioms semantically equivalent with  X   X   X  and leave a single axiom among multiple model-equivalent axioms in  X  (  X  ) as follows: if  X  is one of these axioms, then leave  X  , otherwise leave an arbitrary axiom that has the minimum size. These treatments give our rec-ommended modification function, written  X   X  , which meets all the aforementioned principles.
 Our proposed approach to resolving an incoherent TBox T with a background subset B is to compute fine-grained repairs for ( T , B , C ,  X   X  ), where the set C of unsatisfiable concept names is determined by the strategy adopted (e.g., this strategy can be the one-by-one, the root-based or the one-off strategy mentioned in the beginning of Section 4).
We implemented the proposed approach in Java by using the Pellet [23] API to perform satisfiability tests and deter-mine which axiom is weaker than which axiom. We exploited a module-based optimization in the implementation. That is, when we compute fine-grained repairs for ( T , B , C ,  X  we first compute the syntactic locality-based module [4] for every unsatisfiable concept name in C , then compute fine-grained repairs in the union set of all these modules. This optimization is sound and complete, because the syntactic locality-based module for a concept name A has been proved [24] to contain all MUSes (thus all MSSes) for A , while the set of MUSes for a set C of concept names is a subset of the union set of the sets of MUSes for concept names in C . We collected 16 incoherent TBoxes, reported in Table 1. The first 14 TBoxes were collected from two ontology debug-ging websites (see http://www.mindswap.org/ontologies/ debugging/ [8, 12] and http://www.few.vu.nl/~schlobac/ software.html [19, 21]), the last but one was obtained from an experiment of learning concept disjointness axioms [25], and the last one was obtained from the Text2Onto project [2]. 1 For experiments on an incoherent TBox T , we uni-formly set B as the set of RBox axioms in T (recall that we simply refer to the union of the TBox and the RBox as the TBox), because RBox axioms can only be deleted or kept as a whole using our proposed modification function  X   X  while using RBox axioms as the background can yield more semantic relations between axioms, making the result-ing fine-grained repairs more concise.
Since the proposed approach incrementally computes all fine-grained repairs one by one, it is more practical to apply
T he implemented system and the test TBoxes are available at http://www.dataminingcenter.net/fgrepair/ . Table 1: The statistics for all collected TBoxes Note: | N R | i s the number of role names; | N C | is the num-ber of concept names; | U C | is the number of unsatisfiable concept names; | N A | is the number of axioms in the TBox. one of the computed repairs to restore unsatisfiability be-fore all repairs computed. Hence we verified the approach in computing a given number of fine-grained repairs other than all repairs against different strategies mentioned in Section 4. These strategies include the one-by-one strategy (repairing a single unsatisfiable concept at a time), the root-based strat-egy (repairing all root unsatisfiable concepts together) and the one-off strategy (repairing all unsatisfiable concepts at a time), where in the one-by-one strategy unsatisfiable con-cept names were selected in the alphabetical order. We did not compare our proposed method for computing MSSes (the core of our approach) with existing methods due to the following reasons. First, the method proposed in [3] is generally less efficient than ours as shown in Subsection 5.2. Second, the other methods either work only for unfoldable ALC TBoxes [15], or need to compute all MUSes beforehand [10, 19, 21], while the state-of-the-art method for computing all MUSes [9] has been shown to be less optimal than ours.
In our experiments, we set a parameter n , the number of fine-grained repairs to be computed, to experiment with each strategy. That is, in an iteration for applying a certain strategy, we first compute the top-n fine-grained repairs, then apply the last computed fine-grained repair to the cur-rently updated TBox T ; if T becomes coherent, then we finish repairing the given TBox, otherwise we enter the next iteration. All these experiments were conducted on a laptop with Intel Dual-Core 2.20GHz CPU, running Windows 7, where the maximum Java heap size was set to 1GB.

Figure 3 shows the total execution time in seconds for re-pairing an incoherent TBox against different strategies and different numbers n of fine-grained repairs that are need to be computed in one iteration, where n = 1 , 10 , 40. It can be seen that, no matter which strategy is adopted, the pro-posed approach always finishes repairing a test TBox in half an hour. It shows that the approach works well with all strategies even on large TBoxes with up to thousands of unsatisfiable concept names.

In general the proposed approach spends more time when the parameter n increases. But there exist exceptions be-cause the number of iterations taken by the one-by-one strat-egy or the root-based strategy may decrease when n in-creases. Take DICE-A or KM1500 for example, the num-Note:  X  X bo X  means the one-by-one strategy;  X  X b X  means the r oot-based strategy;  X  X o X  means the one-off strategy. Figure 3: The total execution time for repairing a TBox against different strategies and different num-bers of fine-grained repairs to be computed ber of iterations taken by the one-by-one strategy for n = 1 is larger than the number of iterations taken by the same strategy for n = 10 or n = 40, thus under the one-by-one strategy the execution time for n = 1 is longer than the execution time for n = 10 or n = 40.

Looking at the number of iterations taken by different strategies, we found without surprise that the one-by-one strategy always takes more iterations than the other two strategies. However, the number of iterations taken by the one-by-one strategy is much less than the number of unsat-isfiable concept names. For example, the case where the one-by-one strategy takes the most iterations is n = 1 on KM1500, but in this case the number of iterations (169) is less than one twentieth of the number of unsatisfiable con-cept names (3991). It shows that the one-by-one strategy, though simple and local, is rather efficient in practice. Com-pared with the one-by-one strategy, the root-based strategy is highly effective in reducing the number of iterations. For all 48 test cases (involving all the 16 test TBoxes and all the three values of n ), the root-based strategy takes at most five iterations to finish repairing a test TBox; moreover, there are 26 test cases in which the root-based strategy takes one iter-ation only. The number of iterations taken may not be in di-rect proportion to the execution time. Although the one-off strategy always takes a single iteration, it only works faster than the other two strategies in four out of 48 test cases. In contrast, the root-based strategy works faster than the other two strategies in 23 out of 48 test cases.

Based on the above results, we can conclude that for the sake of efficiency the root-based strategy is the first choice to resolve incoherence while the one-by-one strategy is the sec-ond choice. If we need to strictly meet the minimal-change principle, the one-off strategy is the only choice because only this strategy computes fine-grained repairs for all unsatisfi-able concept names in a TBox.
In order to perform user evaluation on the proposed ap-proach, we also developed a user interface for our implemen-tation of the proposed approach. This yields a user friendly Figure 4: A snapshot for Figrors which implements t he proposed approach tool for resolving incoherence, called the fi ne-gr ained o ntology r epairing s ystem ( simply Figrors ). Figure 4 gives a snapshot for Figrors in repairing a test TBox, Tambis.

The top region of the window provides functionality for loading an ontology. Only axioms in the TBox are loaded. The loaded TBox is then classified to form a concept hier-archy, shown in the left upper region of the window. Mean-while all axioms in the TBox are shown in the right upper re-gion. Afterwards, unsatisfiable concept names are extracted from the concept hierarchy and root unsatisfiable concept names are identified. All unsatisfiable concept names are shown in the left lower region of the window with root ones displayed in red. Users can select which unsatisfiable con-cept names need to be repaired. By default, all root un-satisfiable concept names are selected. After users trigger the computation of fine-grained repairs for selected concept names, the set of fine-grained repairs is computed in the background. Whenever a fine-grained repair is computed, the right lower region is updated with new information such as the new number of computed repairs. This region also shows all modification operations in the first fine-grained repair by default. The view will be changed to another re-pair when users browse through different fine-grained re-pairs. Users can at any time apply some or all modification operations in the current view and submit these operations. This will trigger Figrors to update the loaded TBox and enter the next round of user interaction.

We compared Figrors with Swoop [11] (the latest version 2.3 beta 4). To our knowledge Swoop is currently the only publicly available tool that provides a repair service. It com-putes from MUSes a certain MSS in which the sum of axiom ranks is minimized and presents the computed MSS to users as a repair plan. By default, Swoop adopts the root-based strategy and may need several rounds of user interactions to repair an incoherent TBox as Figrors.

We arranged five participants to carry out the compari-son. They were all postgraduates familiar with OWL and description logics. Unfortunately, they were not familiar with our collected TBoxes. As a result we could not con-duct user evaluation on the effectiveness or satisfaction as-pect, but only on the efficiency aspect of the two compared tools. We adopted the within-subjects experimental design and enforced the participants to conduct independent ex-Table 2: The comparison results between Figrors and Swoop Note: avg/mi/ma is the average/minimum/maximum to-t al execution time (in seconds) for repairing a TBox; p-v is the p-value for the null hypothesis  X  X woop is as efficient as Figrors X  in t-test, where a number in bold means that the difference is significant under the significance level 0.05. periments without communication, first with Figrors for all TBoxes, and then with Swoop for all TBoxes, using their own machines with the maximum Java heap size uniformly set to 1GB. Forbidding communication between participants ensures that the experiment of one participant does not im-pact that of another participant. For using Figrors, the participants were told to use the root-based strategy, and to apply and submit all modification operations in a fine-grained repair if they feel this repair is acceptable by their own judgements. For using Swoop, the participants were told to use also the root-based strategy, and to immediately execute a repair plan once it is generated. This way ensures that how a participant does with Figrors does not impact how he does with Swoop. All participants were told to stop repairing a test TBox after a time limit of one hour expires. Table 2 lists the comparison results between Figrors and Swoop. Five out of the 16 test TBoxes cannot be handled by Swoop due to either exceptions on unsupported datatypes or some input text that cannot be parsed. For any of the remaining TBoxes, the participants spent significantly less time to repair it by using Figrors than by using Swoop, ex-cept for MadCow which has only one unsatisfiable concept name. It shows that Figrors provides a more efficient way for users to repair an incoherent TBox. Moreover, Figrors is more scalable than Swoop. It scales well to the three largest TBoxes, namely DICE-A, SUMO-CYC and KM1500. All participants finished repairing any of these TBoxes in at most 15 minutes by using Figrors, but they could not repair-ing any of them in one hour or with 1GB memory by using Swoop. The main drawback of Swoop lies in that it needs to compute all MUSes before generating a repair plan (i.e. a certain MSS). In contrast, Figrors directly computes MSSes (thus fine-grained repairs) without computing all MUSes be-forehand, hence it is faster and less memory-consuming.
Currently there is a lack of fine-grained approaches to au-tomatize the task of resolving an incoherent TBox. To fill this gap we proposed a new approach to repairing unsatisfi-ab le concept names in a fine-grained way. There are several contributions in this work. Firstly, we proposed a semantics for fine-grained repairs. This semantics allows users to re-solve an incoherent TBox by modifying one axiom to zero or more axioms while keeping as much information of the original TBox as possible. Secondly, we established a one-to-one correspondence between the set of MSSes and the set of fine-grained repairs so that existing methods for comput-ing MSSes can be adapted to computing fine-grained repairs. Thirdly, for efficiently computing all fine-grained repairs, we proposed more optimal techniques than those presented in [3, 9] and some specific optimizations. Fourthly, we pro-posed some principles for defining a modification function to fully automatize the repairing task. We also presented a modification function that fulfills all the proposed princi-ples. Finally, we conducted extensive experiments to show that the proposed approach is efficient and practical for large TBoxes with up to thousands of unsatisfiable concept names, no matter which repairing mode (the automatic mode or the user-interactive mode) is used.

There are several directions that we can explore in our future work. Firstly, we plan to conduct user evaluation on the effectiveness or satisfaction aspect of our proposed approach. We will collect some real-life incoherent TBoxes that the experimental participants are familiar with to con-duct this evaluation. Secondly, as mentioned in Section 2 we will integrate our approach with the query-based selection approach [22] to develop a better tool for user-interactive on-tology repairing. Finally, we plan to investigate preferences over fine-grained repairs and to develop efficient methods for directly computing user-preferred fine-grained repairs.
Jianfeng Du is partially supported by the NSFC grants 61375056 and 61005043, the Guangdong Natural Science Foundation S2013010012928, and Business Intelligence Key Team of Guangdong University of Foreign Studies TD1202. Guilin Qi is partially supported by the NSFC grant 61272378 and the Marie Curie IRSES project SemData 612551. [1] S. Bail, B. Parsia, and U. Sattler. The logical diversity [2] P. Cimiano and J. V  X  olker. Text2onto -a framework [3] J. Du, G. Qi, J. Z. Pan, and Y. Shen. A [4] B. Cuenca Grau, I. Horrocks, Y. Kazakov, and [5] M. Horridge, B. Parsia, and U. Sattler. Laconic and [6] I. Horrocks, O. Kutz, and U. Sattler. The even more [7] U. Junker. QUICKXPLAIN: Preferred explanations [8] A. Kalyanpur. Debugging and Repair of OWL [9] A. Kalyanpur, B. Parsia, M. Horridge, and E. Sirin. [10] A. Kalyanpur, B. Parsia, E. Sirin, and B. Cuenca [11] A. Kalyanpur, B. Parsia, E. Sirin, B. Cuenca Grau, [12] A. Kalyanpur, B. Parsia, E. Sirin, and J. Hendler. [13] S. C. Lam, J. Z. Pan, D. H. Sleeman, and W. W. [14] J. Lehmann and P. Hitzler. Concept learning in [15] T. Meyer, K. Lee, R. Booth, and J. Z. Pan. Finding [16] B. Parsia, E. Sirin, and A. Kalyanpur. Debugging [17] R. Reiter. A theory of diagnosis from first principles. [18] K. Satoh and T. Uno. Enumerating minimally revised [19] S. Schlobach. Diagnosing terminologies. In Proc. of [20] S. Schlobach and R. Cornet. Non-standard reasoning [21] S. Schlobach, Z. Huang, R. Cornet, and F. van [22] K. M. Shchekotykhin and G. Friedrich. Query strategy [23] E. Sirin, B. Parsia, B. Cuenca Grau, A. Kalyanpur, [24] B. Suntisrivaraporn, G. Qi, Q. Ji, and P. Haase. A [25] J. V  X  olker, D. Vrandecic, Y. Sure, and A. Hotho. [26] Z. Zhou, G. Qi, and B. Suntisrivaraporn. A new
