 The goal of word segmentation is to segment a stream of segments, e.g. characters or phonemes, into words. For example, given the sequence  X  X ouwanttoseethebook X , the goal is to recover the segmented string  X  X ou want to see the book X . The models introduced in Goldwater (2006) solve this problem in a fully unsupervised way by defining a generative process for word sequences, making use of the Dirichlet Process (DP) prior.

Until recently, the only inference algorithm applied to these models were batch Markov Chain Monte Carlo (MCMC) sampling algorithms. B  X  orschinger and Johnson (2011) proposed a strictly incremental particle filter algorithm that, however, performed considerably worse than the standard batch algorithms, in particular for the Bigram model. We extend that algorithm by adding rejuvenation steps and show that this leads to considerable im-provements, thus strengthening the case for particle filters as another tool for Bayesian inference in com-putational linguistics.

The rest of the paper is structured as follows. Sec-tions 2 and 3 provide the relevant background about word segmentation and previous work. Section 4 de-scribes our algorithm. Section 5 reports on an ex-perimental evaluation of our algorithm, and section 6 concludes and suggests possible directions for fu-ture research. The Unigram model assumes that words in a se-quence are generated independently whereas the Bi-gram model models dependencies between adjacent words. This has been shown by Goldwater (2006) to markedly improve segmentation performance. We perform experiments on both models but, for rea-sons of space, only give an overview of the Unigram model, referring the reader to the original papers for more detailed descriptions. (Goldwater, 2006; Gold-water et al., 2009)
A sequence of words or utterance is generated by making independent draws from a discrete distribu-tion over words, G . As neither the actual  X  X rue X  words nor their number is known in advance, G is modelled as a draw from a DP. A DP is parametrized by a base distribution P 0 and a concentration param-eter  X  . Here, P 0 assigns a probability to every possi-ble word, i.e. sequence of segments, and  X  controls the sparsity of G ; the smaller  X  , the sparser G tends to be.

To computationally cope with the unbounded nature of draws from a DP, they can be  X  X nte-grated out X , yielding the Chinese Restaurant Process (CRP), an infinitely exchangeable conditional pre-dictive distribution. The CRP also provides an in-tuitive generative story for the observed data. Each generated word token corresponds to a customer sit-ting at one of the unboundedly many tables in an imaginary Chinese restaurant. Customers choose their seats sequentially, and they sit either at an al-ready occupied or a new table. The former hap-pens with probability proportional to the number of customers already sitting at a table and corresponds to generating one more token of the word type all customers at a table instantiate. The latter happens with probability proportional to  X  and corresponds to generating a token by sampling from the base dis-tribution, thus also determining the type for all po-tential future customers at the new table.

Given this generative process, word segmentation can be cast as a probabilistic inference problem. For a fixed input, in our case a sequence of phonemes, our goal is to determine the posterior distribution over segmentations. This is usually infeasible to do exactly, leading to the use of approximate inference methods. The  X  X tandard X  inference algorithms for the Uni-gram and Bigram model are MCMC samplers that are batch algorithms making multiple iterations over the data to non-deterministically explore the state space of possible segmentations. If an MCMC algo-rithm runs long enough, the probability of it visiting any specific segmentation is the probability of that segmentation under the target posterior distribution, here, the distribution over segmentations given the observed data.

The MCMC algorithm of Goldwater et al. (2009) is a Gibbs sampler that makes very small moves through the state space by changing individual word boundaries one at a time. An alternative MCMC al-gorithm that samples segmentations for entire utter-ances was proposed by Mochihashi et al. (2009). Below, we correct a minor error in the algorithm, re-casting it as a Metropolis-within-Gibbs sampler.
Moving beyond MCMC algorithms, Pearl et al. (2010) describe an algorithm that can be seen as a degenerate limiting case of a particle filter with only one particle. Their Dynamic Programming Sampling algorithm makes a single pass through the data, processing one utterance at a time by sampling a segmentation given the choices made for all pre-vious utterances. While their algorithm comes with no guarantee that it converges on the intended pos-terior distribution, B  X  orschinger and Johnson (2011) showed how to construct a particle filter that is asymptotically correct, although experiments sug-gested that the number of particles required for good performance is impractically large.

This paper shows how their algorithm can be im-proved by adding rejuvenation steps , which we will describe in the next section. The core idea of a particle filter is to sequentially approximate a target posterior distribution P by N weighted point samples or  X  X articles X . Each parti-cle is updated one observation at a time, exploiting the insight that Bayes X  Theorem can be applied re-cursively, as illustratively shown for the case of cal-culating the posterior probability of a hypothesis H given two observations O 1 and O 2 : If the observations are conditionally independent given the hypothesis, one can simply take the poste-rior at time step t as the prior for the posterior update at time step t + 1 .

Here, each particle corresponds to a specific seg-mentation of the data observed so far, or more pre-cisely, the specific CRP seating of word tokens in this segmentation; we refer to this as its history . Its weight indicates how well a particle is supported by the data, and each observation corresponds to an un-segmented utterance. With this, the basic particle filter algorithm can be described as follows: Begin with N  X  X mpty X  particles. To get the particles at time t +1 from the particles at time t , update each particle using the observation at time t +1 as follows: sample a segmentation for this observation, given the parti-cle X  X  history, then add the words in this segmentation to that history. After each particle has been updated, their weights are adjusted to reflect how well they are now supported by the observations. The set of updated and reweighted particles constitutes the ap-proximation of the posterior at time t + 1 .
To overcome the problem of degeneracy (the sit-uation where only very few particles have non-negligible weights), B  X  orschinger and Johnson use resampling ; basically, high-probability particles are permitted to have multiple descendants that can replace low-probability particles. For reasons of space, we refer the reader to B  X  orschinger and John-son (2011) for the details of these steps.

While necessary to address the degeneracy prob-lem, resampling leads to a loss of sample diversity ; very quickly, almost all particles have an identical history, descending from only a small number of (previously) high probability particles. With a strict online learning constraint, this can only be counter-acted by using an extremely large number of parti-cles. An alternative strategy which we explore here is to use rejuvenation ; the core idea is to restore sample diversity after each resampling step by per-forming MCMC resampling steps on each particle X  X  history, thus leading to particles with different his-tories in each generation, even if they all have the same parent. (e.g., Canini et al. (2009)) This makes it necessary to store previously processed observa-tions and thus no longer qualifies as online learn-ing in a strict sense, but it still yields an incremental algorithm that learns as the observations arrive se-quentially, instead of delaying learning until all ob-servations are available.

In our setting, rejuvenation works as follows. Af-ter each resampling step, for each particle the algo-rithm performs a fixed number of the following re-juvenation steps: 1. randomly choose a previously observed utter-2. resample the segmentation for this utterance
For the resampling step, we use Mochihashi et al. (2009) X  X  algorithm to efficiently sample segmenta-tions for an unsegmented utterance o , given a se-quence of n previously observed words W 1: n . As the CRP is exchangeable, during resampling we can treat every utterance as if it were the last, making it possible to use this algorithm for any utterance, irrespective of its actual position in the data. Cru-cially, however, the distribution over segmentations that this algorithm samples from is not the true pos-terior distribution P (  X | o, X ,W 1: n ) as defined by the CRP, but a slightly different proposal distribution Q (  X | o, X ,W 1: n ) that does not take into account the intra-sentential word dependencies for a segmenta-tion of o . It is precisely because we ignore these de-pendencies that an efficient dynamic programming algorithm is possible, but because Q is different from the target conditional distribution P , our algo-rithm that uses Q instead of P needs to correct for this. In a particle filter, this is done when the par-ticle weights are calculated (B  X  orschinger and John-son, 2011). For an MCMC algorithm or our rejuve-nation step, a Metropolis-Hastings accept/reject step is required, as described in detail by Johnson et al. (2007) in the context of grammatical inference. 1
In our case, during rejuvenation an utterance u with current segmentation s is reanalyzed as fol-lows:  X  remove all the words contained in s from the  X  sample a proposal segmentation s 0 for u from  X  with probability m , accept the new sample and This completes the description of our extension to the algorithm. The remainder of the paper empiri-cally evaluates the particle filter with rejuvenation. We compare the performance of a batch Metropolis-Hastings sampler for the Unigram and Bigram model with that of particle filter learners both with and without rejuvenation, as described in the previ-ous section. For the batch samplers, we use simu-lated annealing to facilitate the finding of high prob-ability solutions, and for the particle filters, we com-pare the performance of a  X  X egenerate X  1-particle learner with a 16-particle learner in the rejuvenation setting.

To get an impression of the contribution of par-ticle number and rejuvenation steps, we compare PF 16 , 100 68.05 -235.71 70.05 -251.66 PF 1 , 1600 77.06 -228.79 74.47 -249.78 the 16-particle learner with rejuvenation with a 1-particle learner that performs 16 times as many re-juvenation samples. For comparison, we also cite previous results for the 1000-particle learners with-out rejuvenation reported in B  X  orschinger and John-son (2011), using their choice of parameters to allow for a direct comparison:  X  = 20 for the Unigram model,  X  0 = 3000 ,  X  1 = 100 for the Bigram model, and we use their base-distribution which differs from the one described in Goldwater et al. (2009) in that it doesn X  X  assume a uniform distribution over segments in the base-distribution but puts a Dirichlet Prior on it.

We apply each learner to the Bernstein-Ratner corpus (Brent, 1999) that is standardly used in the word segmentation literature, which consists of 9790 unsegmented and phonemically transcribed child-directed speech utterances. We evaluate each algorithm in two ways: inference performance, for which the final log-probability of the training data is the criterion, and segmentation performance, for which we consider token f-score to be the best mea-sure, since it indicates how well the actual word to-kens in the data are recovered.Note that these two measures can diverge, as previously documented for the Unigram model (Goldwater, 2006) and, less so, for the Bigram model (Pearl et al., 2010). Table 1 gives the results for our experiments.

For both models, adding rejuvenation always improves performance markedly as compared to the corresponding run without rejuvenation both in terms of log-probability and segmentation f-score. Note in particular that for the Bigram model, us-ing 16 particles with 100 rejuvenation steps leads to an improvement in token f-score of more than 10% points over 1000 particles without rejuvenation.
Comparing the 1-particle learner with 1600 reju-venation steps to the 16-particle learner with 100 re-juvenation steps, for both models the former outper-forms the latter in both log-probability and token f-score. This suggests that if one has to trade-off par-ticle number against rejuvenation steps, one may be better off favouring the latter.

Despite the dramatic improvement over not us-ing rejuvenation, there is still a considerable gap between all the incremental learners and the batch sampling algorithm in terms of log-probability. A similar observation was made by Johnson and Gold-water (2009) for incremental initialisation in word segmentation using adaptor grammars. Their batch sampler converged on higher token f-score but lower probability solutions in some settings when initial-ized in an incremental fashion as opposed to ran-domly. We agree with their suggestion that this may be due to the  X  X reedy X  character of an incremental learner. We have shown that adding rejuvenation to a par-ticle filter improves segmentation scores and log-probabilities. Yet, our incremental algorithm still finds lower probability but high quality token f-scores compared to its batch counterpart. While in principle, increasing the number of rejuvenation steps and particles will make this gap smaller and smaller, we believe the existence of the gap to be interesting in its own right, suggesting a general dif-ference in learning behaviour between batch and in-cremental learners, especially given the similar re-sults in Johnson and Goldwater (2009). Further research into incremental learning algorithms may help us better understand how processing limitations can affect learning and why this may be beneficial for language acquisition, as suggested, for example, in Newport (1988).
