 Most previous methods for building transliteration systems were supervised, requiring either hand-crafted rules or a clean list of transliteration pairs, both of which are expensive to create. Such re-sources are also not applicable to other language pairs.

In this paper, we show that it is possible to ex-tract transliteration pairs from a parallel corpus us-ing an unsupervised method. We first align a bilin-gual corpus at the word level using GIZA++ and create a list of word pairs containing a mix of non-transliterations and transliterations. We train a sta-tistical transliterator on the list of word pairs. We then filter out a few word pairs (those which have the lowest transliteration probabilities according to the trained transliteration system) which are likely to be non-transliterations. We retrain the translitera-tor on the filtered data set. This process is iterated, filtering out more and more non-transliteration pairs until a nearly clean list of transliteration word pairs is left. The optimal number of iterations is automat-ically determined by a novel stopping criterion.
We compare our unsupervised transliteration min-ing method with the semi-supervised systems pre-sented at the NEWS 2010 shared task on translit-eration mining (Kumaran et al., 2010) using four language pairs. We refer to this task as NEWS10. These systems used a manually labelled set of data for initial supervised training, which means that they are semi-supervised systems. In contrast, our system is fully unsupervised. We achieve an F-measure of up to 92% outperforming most of the semi-supervised systems.
 The NEWS10 data sets are extracted Wikipedia InterLanguage Links (WIL) which consist of par-allel phrases, whereas a parallel corpus consists of parallel sentences. Transliteration mining on the WIL data sets is easier due to a higher percentage of transliterations than in parallel corpora. We also do experiments on parallel corpora for two language pairs. To this end, we created gold standards in which sampled word pairs are annotated as either transliterations or non-transliterations. These gold standards have been submitted with the paper as sup-plementary material as they are available to the re-search community.
Finally we integrate a transliteration module into the GIZA++ word aligner and show that it improves word alignment quality. The transliteration mod-ule is trained on the transliteration pairs which our mining method extracts from the parallel corpora. We evaluate our word alignment system on two lan-guage pairs using gold standard word alignments and achieve improvements of 10% and 13.5% in pre-cision and 3.5% and 13.5% in recall.

The rest of the paper is organized as follows. In section 2, we describe the filtering model and the transliteration model. In section 3, we present our iterative transliteration mining algorithm and an al-gorithm which computes a stopping criterion for the mining algorithm. Section 4 describes the evaluation of our mining method through both gold standard evaluation and through using it to improve word alignment quality. In section 5, we present previous work and we conclude in section 6. Our algorithms use two different models. The first model is a joint character sequence model which we apply to transliteration mining. We use the grapheme-to-phoneme converter g2p to implement this model. The other model is a standard phrase-based MT model which we apply to transliteration (as opposed to transliteration mining). We build it using the Moses toolkit. 2.1 Joint Sequence Model Using g2p Here, we briefly describe g2p using notation from Bisani and Ney (2008). The details of the model, its parameters and the utilized smoothing techniques can be found in Bisani and Ney (2008).

The training data is a list of word pairs (a source word and its presumed transliteration) extracted from a word-aligned parallel corpus. g2p builds a joint sequence model on the character sequences of the word pairs and infers m-to-n alignments between source and target characters with Expectation Maxi-mization (EM) training. The m-to-n character align-ment units are referred to as  X  X ultigrams X .

The model built on multigrams consisting of source and target character sequences greater than one learns too much noise (non-transliteration infor-mation) from the training data and performs poorly. In our experiments, we use multigrams with a maxi-mum of one character on the source and one charac-ter on the target side (i.e., 0,1-to-0,1 character align-ment units).

The N-gram approximation of the joint probabil-ity can be defined in terms of multigrams q i as: where q 0 , q k +1 are set to a special boundary symbol.
N-gram models of order &gt; 1 did not work well because these models tended to learn noise (infor-mation from non-transliteration pairs) in the training data. For our experiments, we only trained g2p with the unigram model.

In test mode, we look for the best sequence of multigrams given a fixed source and target string and return the probability of this sequence.

For the mining process, we trained g2p on lists containing both transliteration pairs and non-transliteration pairs. 2.2 Statistical Machine Transliteration System We build a phrase-based MT system for translitera-tion using the Moses toolkit (Koehn et al., 2003). We also tried using g2p for implementing the translit-eration decoder but found Moses to perform bet-ter. Moses has the advantage of using Minimum Er-ror Rate Training (MERT) which optimizes translit-eration accuracy rather than the likelihood of the training data as g2p does. The training data con-tains more non-transliteration pairs than transliter-ation pairs. We don X  X  want to maximize the like-lihood of the non-transliteration pairs. Instead we want to optimize the transliteration performance for test data. Secondly, it is easy to use a large language model (LM) with Moses. We build the LM on the target word types in the data to be filtered.
For training Moses as a transliteration system, we treat each word pair as if it were a parallel sentence, by putting spaces between the characters of each word. The model is built with the default settings of the Moses toolkit. The distortion limit  X  X  X  is set to zero (no reordering). The LM is implemented as a five-gram model using the SRILM-Toolkit (Stol-cke, 2002), with Add-1 smoothing for unigrams and Kneser-Ney smoothing for higher n-grams. Training of a supervised transliteration system re-quires a list of transliteration pairs which is expen-sive to create. Such lists are usually either built man-ually or extracted using a classifier trained on man-ually labelled data and using other language depen-dent information. In this section, we present an it-erative method for the extraction of transliteration pairs from parallel corpora which is fully unsuper-vised and language pair independent.

Initially, we extract a list of word pairs from a word-aligned parallel corpus using GIZA++. The extracted word pairs are either transliterations, other kinds of translations, or misalignments. In each it-eration, we first train g2p on the list of word pairs. Then we delete those 5% of the (remaining) train-ing data which are least likely to be transliterations according to g2p. 1 We determine the best iteration according to our stopping criterion and return the fil-tered data set from this iteration. The stopping crite-rion uses unlabelled held-out data to predict the opti-mal stopping point. The following sections describe the transliteration mining method in detail. 3.1 Methodology We will first describe the iterative filtering algorithm (Algorithm 1) and then the algorithm for the stop-ping criterion (Algorithm 2). In practice, we first run Algorithm 2 for 100 iterations to determine the best number of iterations. Then, we run Algorithm 1 for that many iterations.
 Initially, the parallel corpus is word-aligned using GIZA++ (Och and Ney, 2003), and the alignments are refined using the grow-diag-final-and heuristic (Koehn et al., 2003). We extract all word pairs which occur as 1-to-1 alignments in the word-aligned cor-pus. We ignore non-1-to-1 alignments because they are less likely to be transliterations for most lan-guage pairs. The extracted set of word pairs will be called  X  list of word pairs  X  later on. We use the list of word pairs as the training data for Algorithm 1.
Algorithm 1 builds a joint sequence model using g2p on the training data and computes the joint prob-ability of all word pairs according to g2p. We nor-malize the probabilities by taking the nth square root Algorithm 1 Mining of transliteration pairs where n is the average length of the source and the target string. The training data contains mostly non-transliteration pairs and a few transliteration pairs. Therefore the training data is initially very noisy and the joint sequence model is not very accurate. How-ever it can successfully be used to eliminate a few word pairs which are very unlikely to be translitera-tions.

On the filtered training data, we can train a model which is slightly better than the previous model. Us-ing this improved model, we can eliminate further non-transliterations.

Our results show that at the iteration determined by our stopping criterion, the filtered set mostly contains transliterations and only a small number of transliterations have been mistakenly eliminated (see section 4.2).

Algorithm 2 automatically determines the best stopping point of the iterative transliteration min-ing process. It is an extension of Algorithm 1. It runs the iterative process of Algorithm 1 on half of the list of word pairs (training data) for 100 itera-tions. For every iteration, it builds a transliteration system on the filtered data. The transliteration sys-tem is tested on the source side of the other half of the list of word pairs (held-out). The output of the transliteration system is matched against the target side of the held-out data. (These target words are ei-ther transliterations, translations or misalignments.) We match the target side of the held-out data under the assumption that all matches are transliterations. The iteration where the output of the transliteration system best matches the held-out data is chosen as the stopping iteration of Algorithm 1. Algorithm 2 Selection of the stopping iteration for the transliteration mining algorithm
We will now describe Algorithm 2 in detail. Al-gorithm 2 initially splits the word pairs into training and held-out data. This could be done randomly, but it turns out that this does not work well for some tasks. The reason is that the parallel corpus con-tains inflectional variants of the same word. If two variants are distributed over training and held-out data, then the one in the training data may cause the transliteration system to produce a correct transla-tion (but not transliteration) of its variant in the held-out data. This problem is further discussed in section 4.2.2. Instead of randomly splitting the data, we first create clusters of word pairs which have a common prefix of length 2 both on the source and target lan-guage side. We randomly add each cluster either to the training data or to the held-out data.

We repeat the mining process (described in Algo-rithm 1) to eliminate non-transliteration pairs from the training data. For each iteration of Algorithm 2, i.e., steps 4 to 9, we build a transliteration system on the filtered training data and test it on the source side of the held-out. We collect statistics on how well the output of the system matches the target side of the held-out. The matching scores on the held-out data often make large jumps from iteration to iteration. We take the median of the results from 9 consecutive iterations (the 4 iterations before, the current and the 4 iterations after the current iteration) to smooth the scores. We call this median9. We choose the iter-ation with the best smoothed score as the stopping point for the filtering process. In our tests, the me-dian9 heuristic indicated an iteration close to the op-timal iteration.

Sometimes several nearby iterations have the same maximal smoothed score. In that case, we choose the one with the highest unsmoothed score. Section 4.2 explains the median9 heuristic in more detail and presents experimental results showing that it works well. We evaluate our transliteration mining algorithm on three tasks: transliteration mining from Wikipedia InterLanguage Links, transliteration mining from parallel corpora, and word alignment using a word aligner with a transliteration component. On the WIL data sets, we compare our fully unsupervised system with the semi-supervised systems presented at the NEWS10 (Kumaran et al., 2010). In the eval-uation on parallel corpora, we compare our min-ing results with a manually built gold standard in which each word pair is either marked as a translit-eration or as a non-transliteration. In the word align-ment experiment, we integrate a transliteration mod-ule which is trained on the transliterations pairs ex-tracted by our method into a word aligner and show a significant improvement. The following sections describe the experiments in detail. 4.1 Experiments Using Parallel Phrases of We conduct transliteration mining experiments on the English/Arabic, English/Hindi, English/Tamil and English/Russian Wikipedia InterLanguage Links (WIL) used in the NEWS10. 2 All data sets contain training data, seed data and reference data. We make no use of the seed data since our system is fully unsupervised. We calculate the F-measure of our filtered transliteration pairs against the supplied gold standard using the supplied evaluation tool.
For English/Arabic, English/Hindi and En-glish/Tamil, our system is better than most of the semi-supervised systems presented at the NEWS 2010 shared task for transliteration mining. Table 1 summarizes the F-scores on these data sets.

On the English/Russian data set, our system achieves 76% F-measure which is not good com-pared with the systems that participated in the shared task. The English/Russian corpus contains many cognates which  X  according to the NEWS10 defi-nition  X  are not transliterations of each other. Our system learns the cognates in the training data and extracts them as transliterations (see Table 2).
The two best teams on the English/Russian task presented various extraction methods (Jiampoja-marn et al., 2010; Darwish, 2010). Their sys-tems behave differently on English/Russian than on other language pairs. Their best systems for En-glish/Russian are only trained on the seed data and the use of unlabelled data does not help the perfor-mance. Since our system is fully unsupervised, and the unlabelled data is not useful, we perform badly. 4.2 Experiments Using Parallel Corpora The Wikipedia InterLanguage Links shared task data contains a much larger proportion of translitera-tions than a parallel corpus. In order to examine how well our method performs on parallel corpora, we apply it to parallel corpora of English/Hindi and En-glish/Arabic, and compare the transliteration mining results with a gold standard.

We use the English/Hindi corpus from the shared task on word alignment, organized as part of the ACL 2005 Workshop on Building and Using Par-allel Texts (WA05) (Martin et al., 2005). For En-glish/Arabic, we use a freely available parallel cor-pus from the United Nations (UN) (Eisele and Chen, 2010). We randomly take 200,000 parallel sentences from the UN corpus of the year 2000. We cre-ate gold standards for both language pairs by ran-domly selecting a few thousand word pairs from the lists of word pairs extracted from the two corpora. We manually tag them as either transliterations or non-transliterations. The English/Hindi gold stan-dard contains 180 transliteration pairs and 2084 non-transliteration pairs and the English/Arabic gold standard contains 288 transliteration pairs and 6639 non-transliteration pairs. We have submitted these gold standards with the paper. They are available to the research community.

In the following sections, we describe the me-dian9 heuristic and the splitting method of Algo-rithm 2. The splitting method is used to avoid early peaks in the held-out statistics, and the median9 heuristic smooths the held-out statistics in order to obtain a single peak. 3 4.2.1 Motivation for Median9 Heuristic Algorithm 2 collects statistics from the held-out data (step 10) and selects the stopping iteration. Due to the noise in the held-out data, the transliteration ac-curacy on the held-out data often jumps from itera-tion to iteration. The dotted line in figure 1 (right) shows the held-out prediction accuracy for the En-glish/Hindi parallel corpus. The curve is very noisy and has two peaks. It is difficult to see the effect of the filtering. We take the median of the results from 9 consecutive iterations to smooth the scores. The solid line in figure 1 (right) shows a smoothed curve built using the median9 held-out scores. A compari-son with the gold standard (section 4.2.3) shows that the stopping point (peak) reached using the median9 heuristic is better than the stopping point obtained with unsmoothed scores. 4.2.2 Motivation for Splitting Method Algorithm 2 initially splits the list of word pairs into training and held-out data. A random split worked well for the WIL data, but failed on the parallel cor-pora. The reason is that parallel corpora contain in-flectional variants of the same word. If these vari-ants are randomly distributed over training and held-out data, then a non-transliteration word pair such as the English-Hindi pair  X  X hange  X  badlao X  may end up in the training data and the related pair  X  X hanges  X  badlao X  in the held-out data. The Moses system used for transliteration will learn to  X  X ransliterate X  (or actually translate)  X  X hange X  to  X  X adlao X . From other examples, it will learn that a final  X  X  X  can be dropped. As a consequence, the Moses transliterator may produce the non-transliteration  X  X adlao X  for the English word  X  X hanges X  in the held-out data. Such matching predictions of the transliterator which are actually translations lead to an overestimate of the transliteration accuracy and may cause Algorithm 2 to predict a stopping iteration which is too early.
By splitting the list of word pairs in such a way that inflectional variants of a word are placed either in the training data, or in the held-out, but not in both, this problem can be solved. 4
The left graph in Figure 1 shows that the median9 held-out statistics obtained after a random data split of a Hindi/English corpus contains two peaks which occur too early. These peaks disappear in the right graph of Figure 1 which shows the results obtained after a split with the clustering method.

The overall trend of the smoothed curve in fig-ure 1 (right) is very clear. We start by filtering out non-transliteration pairs from the data, so the results of the transliteration system go up. When no more non-transliteration pairs are left, we start filtering out transliteration pairs and the results of the system go down. We use this stopping criterion for all lan-guage pairs and achieve consistently good results. 4.2.3 Results on Parallel Corpora According to the gold standard, the English/Hindi and English/Arabic data sets contain 8% and 4% transliteration pairs respectively. We repeat the same mining procedure  X  run Algorithm 2 up to 100 itera-tions and return the stopping iteration. Then, we run Algorithm 1 up to the stopping iteration returned by Algorithm 2 and obtain the filtered data.

Table 3 shows the mining results on the En-glish/Hindi and English/Arabic corpora. The gold standard is a subset of the data sets. The En-glish/Hindi gold standard contains 180 translitera-tion pairs and 2084 non-transliteration pairs. The English/Arabic gold standard contains 288 translit-eration pairs and 6639 non-transliteration pairs. From the English/Hindi data, the mining system has mined 170 transliteration pairs out of 180 transliter-ation pairs. The English/Arabic mined data contains 197 transliteration pairs out of 288 transliteration pairs. The mining system has wrongly identified a few non-transliteration pairs as transliterations (see table 3, last column). Most of these word pairs are close transliterations and differ by only one or two characters from perfect transliteration pairs. The close transliteration pairs provide many valid multi-grams which may be helpful for the mining system. 4.3 Integration into Word Alignment Model In the previous section, we presented a method for the extraction of transliteration pairs from a parallel corpus. In this section, we will explain how to build a transliteration module on the extracted transliter-ation pairs and how to integrate it into MGIZA++ (Gao and Vogel, 2008) by interpolating it with the t-table probabilities of the IBM models and the HMM model. MGIZA++ is an extension of GIZA++. It has the ability to resume training from any model rather than starting with Model1. 4.3.1 Modified EM Training of the Word GIZA++ applies the IBM models (Brown et al., 1993) and the HMM model (Vogel et al., 1996) in both directions, i.e., source to target and target to source. The alignments are refined using the grow-diag-final-and heuristic (Koehn et al., 2003). GIZA++ generates a list of translation pairs with alignment probabilities, which is called the t-table. In this section, we propose a method to modify the translation probabilities of the t-table by interpolat-ing the translation counts with transliteration counts. The interpolation is done in both directions. In the following, we will only consider the e -to-f direction. The transliteration module which is used to calcu-late the conditional transliteration probability is de-scribed in Algorithm 3.
 We build a transliteration system by training Moses on the filtered transliteration corpus (using Algorithm 1) and apply it to the e side of the list of word pairs. For every source word, we gener-ate the list of 10-best transliterations nbestTI ( e ) . Then, we extract every f that cooccurs with e in a parallel sentence and add it to nbestTI ( e ) which gives us the list of candidate transliteration pairs candidateTI ( e ) . We use the sum of transliteration approximation for the prior probability p moses ( e ) = P joint transliteration probability into a conditional Algorithm 3 Estimation of transliteration probabili-ties, e -to-f direction probability. We use the constraint decoding option of Moses to compute the joint probability of e and f . It computes the probability by dividing the transla-tion score of the best target sentence given a source sentence by the normalization factor.

We combine the transliteration probabilities with the translation probabilities of the IBM models and the HMM model. The normal translation probability p ta ( f | e ) of the word alignment models is computed with relative frequency estimates.

We smooth the alignment frequencies by adding the transliteration probabilities weighted by the fac-tor  X  and get the following modified translation probabilities tained from the original t-table of the alignment model. f ( e ) is the total corpus frequency of e .  X  is the transliteration weight which is optimized for every language pair (see section 4.3.2). Apart from the definition of the weight  X  , our smoothing method is equivalent to Witten-Bell smoothing.

We smooth after every iteration of the IBM mod-els and the HMM model except the last iteration of each model. Algorithm 4 shows the smoothing for IBM Model4. IBM Model1 and the HMM model are smoothed in the same way. We also apply Algo-rithm 3 and Algorithm 4 in the alignment direction Algorithm 4 Interpolation with the IBM Model4, e -to-f direction f to e . The final alignments are generated using the grow-diag-final-and heuristic (Koehn et al., 2003). 4.3.2 Evaluation The English/Hindi corpus available from WA05 consists of training, development and test data. As development and test data for English/Arabic, we use manually created gold standard word alignments for 155 sentences extracted from the Hansards cor-pus released by LDC. We use 50 sentences for de-velopment and 105 sentences for test.

Baseline: We align the data sets using GIZA++ (Och and Ney, 2003) and refine the alignments us-ing the grow-diag-final-and heuristic (Koehn et al., 2003). We obtain the baseline F-measure by com-paring the alignments of the test corpus with the gold standard alignments.
 Experiments We use GIZA++ with 5 iterations of Model1, 4 iterations of HMM and 4 iterations of Model4. We interpolate translation and translitera-tion probabilities at different iterations (and different combinations of iterations) of the three models and always observe an improvement in alignment qual-ity. For the final experiments, we interpolate at every iteration of the IBM models and the HMM model except the last iteration of every model where we could not interpolate for technical reasons. 5 Algo-rithm 4 shows the interpolation of the transliteration probabilities with IBM Model4. We used the same procedure with IBM Model1 and the HMM model.
The parameter  X  is optimized on development data for every language pair. The word alignment system is not very sensitive to  X  . Any  X  in the range between 50 and 100 works fine for all lan-guage pairs. The optimization helps to maximize the improvement in word alignment quality. For our ex-periments, we use  X  = 80 .

On test data, we achieve an improvement of approximately 10% and 13.5% in precision and 3.5% and 13.5% in recall on English/Hindi and En-glish/Arabic word alignment, respectively. Table 4 shows the scores of the baseline and our word align-ment model.

We compared our word alignment results with the systems presented at WA05. Three systems, one limited and two un-limited, participated in the En-glish/Hindi task. We outperform the limited system and one un-limited system. Previous work on transliteration mining uses a man-ually labelled set of training data to extract translit-eration pairs from a parallel corpus or comparable corpora. The training data may contain a few hun-dred randomly selected transliteration pairs from a transliteration dictionary (Yoon et al., 2007; Sproat et al., 2006; Lee and Chang, 2003) or just a few carefully selected transliteration pairs (Sherif and Kondrak, 2007; Klementiev and Roth, 2006). Our work is more challenging as we extract translitera-tion pairs without using transliteration dictionaries or gold standard transliteration pairs.

Klementiev and Roth (2006) initialize their transliteration model with a list of 20 transliteration pairs. Their model makes use of temporal scoring to rank the candidate transliterations. A lot of work has been done on discovering and learning translit-erations from comparable corpora by using temporal and phonetic information (Tao et al., 2006; Klemen-tiev and Roth, 2006; Sproat et al., 2006). We do not have access to this information.

Sherif and Kondrak (2007) train a probabilistic transducer on 14 manually constructed translitera-tion pairs of English/Arabic. They iteratively extract transliteration pairs from the test data and add them to the training data. Our method is different from the method of Sherif and Kondrak (2007) as our method is fully unsupervised, and because in each iteration, they add the most probable transliteration pairs to the training data, while we filter out the least proba-ble transliteration pairs from the training data. The transliteration mining systems of the four NEWS10 participants are either based on discrim-inative or on generative methods. All systems use manually labelled (seed) data for the initial training. The system based on the edit distance method sub-mitted by Jiampojamarn et al. (2010) performs best for the English/Russian task. Jiampojamarn et al. (2010) submitted another system based on a stan-dard n-gram kernel which ranked first for the En-glish/Hindi and English/Tamil tasks. 6 For the En-glish/Arabic task, the transliteration mining system of Noeman and Madkour (2010) was best. They normalize the English and Arabic characters in the training data which increases the recall. 7
Our transliteration extraction method differs in that we extract transliteration pairs from a paral-lel corpus without supervision. The results of the NEWS10 experiments (Kumaran et al., 2010) show that no single system performs well on all language pairs. Our unsupervised method seems robust as its performance is similar to or better than many of the semi-supervised systems on three language pairs.
We are only aware of one previous work which uses transliteration information for word alignment. Hermjakob (2009) proposed a linguistically focused word alignment system which uses many features including hand-crafted transliteration rules for Ara-bic/English alignment. His evaluation did not ex-plicitly examine the effect of transliteration (alone) on word alignment. We show that the integration of a transliteration system based on unsupervised transliteration mining increases the word alignment quality for the two language pairs we tested. We proposed a method to automatically extract transliteration pairs from parallel corpora without supervision or linguistic knowledge. We evaluated it against the semi-supervised systems of NEWS10 and achieved high F-measure and performed bet-ter than most of the semi-supervised systems. We also evaluated our method on parallel corpora and achieved high F-measure. We integrated the translit-eration extraction module into the GIZA++ word aligner and showed gains in alignment quality. We will release our transliteration mining system and word alignment system in the near future.
 The authors wish to thank the anonymous re-viewers for their comments. We would like to thank Christina Lioma for her valuable feedback on an earlier draft of this paper. Hassan Sajjad was funded by the Higher Education Commission (HEC) of Pakistan. Alexander Fraser was funded by Deutsche Forschungsgemeinschaft grant Models of Morphosyntax for Statistical Machine Transla-tion. Helmut Schmid was supported by Deutsche Forschungsgemeinschaft grant SFB 732.

