 We propose a novel approach for measuring the similarity between weaving patterns that can provide similarity-based search func-tionality for textile archives. We represent textile structures using hypergraphs and extract multisets of k -neighborhoods from these graphs. The resulting multisets are then compared using Jaccard coefficients, Hamming distances, and cosine measures. We evalu-ate the different variants of our similarity measure experimentally, showing that it can be implemented efficiently and illustrating its quality using it to cluster and query a data set containing more than a thousand textile samples.
Textiles and their creation play an important part in studying history and prehistory. In fact, some cultures, such as the pre-Columbian civilizations found in the Andes, documented and com-municated complex information via textiles [28]. Although to-day many fabrics are produced using fully automated mechanical looms, traditional methods of weaving are still kept alive in com-munities around the world, including countries as diverse as the United Arab Emirates, China, and Peru. Compared to industrially produced textiles, archaeological specimens and artifacts created manually by traditional craftsmen exhibit a significantly more com-plex structure, which makes it much harder to represent, compare, and retrieve them in an information system.

In the humanities, the digitization of cultural heritage and cul-tural practices plays an ever more important role [32]. When looking at publicly accessible digital archives for textiles, we en-counter the following situation. The American Textile History Mu-seum ( http://www.athm.org/ ) and the TEXMEDIN digital library ( http://www.texmedindigitalibrary.eu/ ) of-fer keyword search over their collections, while the Textile Mu-seum of Canada ( http://www.textilemuseum.ca/ ) also supports browsing facilities according to different categories, such as textile type, region, materials, techniques, and period, and the University of Leeds International Textile Archive (ULITA) ( http://ulita.leeds.ac.uk/ ) organizes their collection by region. In an earlier project [5, 25],  X  X eaving Communities of  X  Practice X , we provided additional search functionality by applying an ontological approach to building a knowledge base for Andean textiles. However, this system, like the other archives mentioned above, does not offer a facility to search and compare textiles ac-cording to their internal structure.

Providing techniques to represent and compare textiles accord-ing to their structure would help researchers investigating them (such as archaeologists, ethnographers, and anthropologists) to search for variations of specific patterns. In turn this facilitates the process of identifying fabrics and the methods used to create them. Moreover, this can help domain experts gain deeper insights into how textiles evolved over time and spread across different regions. With our work, we contribute to this effort in the following ways.
The remainder of the paper is organized as follows. In the next section we review the related work and Section 3 covers existing methods for modeling textile structures in more detail and discusses their merits and drawbacks. We introduce our approach in Section 4 and its implementation in Section 5. An experimental evaluation and its results are presented in Section 6. A summary and outlook concludes the paper.
One of the most comprehensive and systematic expositions on classifying the structures of textiles according to basic patterns was compiled by Emery [10], who was a curator at the Textile Museum in Washington D.C. Although Emery X  X  terminology is widely used, the use of terms is not always consistent, even among domain ex-ent cultural contexts such as the South American Andes [1, 9, 33], specimens of which we were confronted with in our earlier project [5, 25]. Additionally, due to the huge diversity of textile struc-tures, it is impractical to come up with a complete natural language classification of every possible structure. Consequently, there have been several attempts to define textile structures in a formal and mathematical way [13, 14].

Textiles created by mechanical looms exhibit a very regular pat-tern and can be described using a grid structure, which can be mapped to a binary matrix representation [18, 26]. Since we set out to also describe structures originating from manual techniques, whose shape may be much more irregular, this is not an option for us. A more general approach for textile modeling is based on topology, i.e., representing fabrics with the help of elements taken from knot theory. Early research in this area specialized on specific techniques, such as knitting [21, 22] and is therefore not generally applicable. Grishanov et al. [13, 14] developed a more general method relying on tangles, which are knot fragments embedding arcs into a sphere [7]. 1 While this approach is more expressive compared to previous topological models, it is only ap-plicable to structures that are periodical in two perpendicular direc-tions. Also, certain structures that can only be created manually and multi-layered disjoint fabrics are not considered. Furthermore, the main purpose of the topological techniques described above are the enumeration and classification of textile structures, not their fast retrieval. For instance, the problem of determining whether two given structures described by knots, links, or tangles are equivalent is intractable in the general case [8].

Another way to represent textiles consists of specifying struc-tures based on image-processing techniques. Most of these tech-niques, e.g. those described in [27, 34], can only be applied to spe-cific textile structures, such as regular rectangular grids or knitting. Moreover, while image processing has the advantage that most of the preprocessing can be automated, textiles, especially complex ones, are three-dimensional objects and some of the structure may be hidden. Ma et al. introduce a special binary encoding to retain some of this information [23], however, their approach is also only applicable to regular grid-like structures. From our point of view Zheng et al. come closest to what we have in mind by developing a method for indexing and retrieving textiles based on their structure [37]. Their technique, though, is only applicable to plain, twill, and satin weave patterns and also shares most of the drawbacks of the other image-processing approaches.
Before going into details about existing techniques for model-ing textiles we have to define the term textile structure , by which we mean the spatial relationships between elements such as yarns, threads, strands, or other similar long and continuous spun pieces of fiber. Basically, given (part of) a textile structure we want to be able to find other structures in which the elements are arranged in a similar manner. In her book [10], Emery distinguishes three broad types of textile structures: interworked elements, interlaced elements, and felted fibers. The last one, felted fiber, is not of inter-est to us, as it is created by compressing, matting, and condensing fibers. This results in the fibers getting entangled with each other in a very irregular and dense pattern, which makes it virtually im-possible, not to mention irrelevant, to identify all of the relation-ships between individual fibers. In interworked elements, threads are connected by means of knotting, linking, stitching, looping, or twining, whereas in interlaced elements, they pass over and under each other without connecting in any other way. Providing all the details of Emery X  X  full classification scheme goes beyond the scope of this paper, due to the fact that our goal is to develop a formal
We provide more background on knots, links, and tangles in Sec-tion 3. mathematical model of textile structures rather than establishing natural language descriptions. Nevertheless, we show some typical examples of textile structures in Figure 1 (Fig. 1(a) and (b) illustrate interworked elements, Fig. 1(c) and (d) interlaced ones).
In the following we give a brief informal summary of topological concepts that have been used to model textile structures, in partic-ular knots , links , tangles , and their two-dimensional projections. Detailed, formal definitions can be found in [8, 13].
A knot is a one-dimensional subset of points K  X  R 3 homeo-morphic to a circle. Figure 2(a) shows a trivial knot, a circle, while Figure 2(b) depicts a so-called trefoil. We want to be able to distin-guish the different types of knots, i.e., determine whether two knots are equivalent. Intuitively, two knots are of the same type if we can continuously deform one knot into the other without breaking it or intersecting it with itself. Figure 2(c) and (d) shows an example of two knots that can be transformed into each other. (a) Trivial knot (b) Non-trivial knot (c) Knot A (d) Knot B
A knot is an embedding of a single circle into R 3 , this can be generalized to a collection of knots, which is called a link . Figure 3 shows two link examples, a trivial link in (a) and Borromean rings in (b). Similar to knots, two links are equivalent if we can transform one into the other by deforming it without cutting it.
While the theory of knots and links provides a well-established foundation and mathematical tools, it cannot be directly applied to textile structures. Rarely are textiles made up of a collection of intertwined and deformed circles. Conway introduced knot frag-ments called tangles [7], which can be used to describe knots and links as well as textile structures. Conway X  X  original intention was to develop a simpler notation for systematically enumerating and classifying knots and links. Grishanov et al. first applied this con-cept to describing textile structures [12].

In his original definition, Conway described a tangle as a knot fragment with two arcs protruding into the four corners of the tan-gle. The corners are labeled NW, NE, SW, and SE after a compass rose (see Figure 4 for examples). Conway X  X  definition of tangles has also been generalized to n -tangles containing n arcs instead of just two.
As the main interest is usually in the type of a structure and not its exact three-dimensional form, often a planar representation is applied, projecting knots and links from R 3 to R 2 . While this loses knowledge of the exact height of a point, enough information is retained to be able to identify types of links. A link is placed in general position with respect to the projection, i.e., no edge of the link is parallel to the projection direction and the projection  X  : R 3 7 X  R 2 is regular.  X  is regular if it is injective except for a finite number of points c i (these are crossings in a link) and only two points in the link are projected onto each c i . Last but not least for each crossing c i the arc that is on top needs to be distinguished from the one below. The arc passing underneath is usually indicated by a break in the line (so far we have used this convention implicitly).
Gradually deforming a link that has been projected to two di-mensions may lead to a violation of the regularity of the projec-tion  X  at certain steps during the transformation. In order to pre-vent this from happening Reidemeister introduced three types of moves, allowing the arcs of a link to  X  X ump X  across critical sec-tions of the transformation [31]; Figure 5 depicts the Reidemeister moves . Equivalence of links is then defined as a (finite) sequence of deformations and Reidemeister moves to transform one link into another.
The main problem that Grishanov et al. attack with topologi-cal methods is the classification of textile structures, i.e., deciding whether two given structures are equivalent [14]. Applying knot theory allows them to re-use results for determining knot equiva-lence. However, there is a catch: one of the first algorithms by Haken for doing so is extremely complex and was never imple-mented [16]. Hass et al. review a number of knot algorithms and conclude that they are impractical and that the exact complexity of several general problems in this area is not even clear [17]. Hotz claims to have found an efficient algorithm for the knot equivalence problem [19], but it turns out that the complexity of his algorithm is O (2 n 3 ) .

Due to the challenge of finding efficient algorithms, the devel-opment of knot invariants is pursued as well. Invariants are func-tions mapping the set of knots to some other set (e.g. integers, polynomials, or matrices). Knots from the same equivalence class get mapped to the same element in the codomain of the function. A considerable number of knot and link invariants exist, dividing knots and links into various equivalence classes. One of the sim-plest invariants for links is the multiplicity  X  ( L ) of a link L , i.e., the number of its components. Some invariants, such as the unknot-ting number , i.e., the minimum number of times a link has to cross itself to be transformed into a trivial link, are simple to formulate, but hard to compute.

In summary, this leaves us with inefficient algorithms of knot equivalence and a comprehensive overview by Grishanov et al. of invariants that can be used to classify doubly-periodic textile struc-tures [14]. However, it is not clear how these techniques can be used for textile pattern retrieval, as no similarity measures between textile structures or invariants are defined. Moreover, the methods often rely on deforming or unknotting an object, which in the con-text of textile structures would in some cases decompose a fabric into individual strands, unraveling (parts of) the structure. This would make it very difficult to compare the relative location of crossings to each other in two different textiles. Our work, which we start describing in the following section, is inspired by knot the-ory and especially the concept of tangles, but we follow a different approach taking into account efficiency and performance aspects.
In the following we first define a hypergraph representation of textile structures, then show how we can extract features, called neighborhoods, from hypergraphs that we can use for measuring the similarity of these graphs.
The basic unit we use is a crossing of two threads with four links to neighboring crossings. In principle, this is a 2-tangle, but we have exactly one crossing within this structure, breaking down a fabric into its most basic elements. We formalize the representa-tion of textile structures using hypergraphs, which we have chosen due to their better suitability (compared to traditional graphs) to represent objects, their spatial relationships, and contexts [35]. Definition 1. A textile graph is defined as a hypergraph H ( C,T,  X  ,  X  ,  X ) , where C is a set of vertices that belong to crossings, T a set of terminal nodes that end threads,  X  a set of hyperedges (of degree four) that connect vertices from C ,  X  a set of regular edges (of degree two) that indicate which thread is on top in each cross-ing, and  X  a set of edges connecting vertices to vertices from other crossings or to terminal nodes.

A textile graph has the following characteristics. | C | is a mul-tiple of four and every c i  X  C belongs to exactly one x j Every x j in turn contains only one p j  X   X  , that is only two c each crossing are connected via a so-called top edge. In addition to this, we connect every node c i to either one node from another crossing or one terminal node, i.e., each c i and each t i only one o  X   X  . Terminal nodes end threads, so every t i a degree of one. If T is empty, then the structure modeled in the hypergraph represents a knot or link. We can even represent non-textile structures such as chain mail with our approach. Here we focus on textile applications, though.
Figures 6 and 7 show two examples of simple textile structures and their hypergraph representation. The nodes c i,j belong to C , the t i to T . The solid lines are the edges in  X  , the dashed lines those in  X  , while the hyperedges in  X  are represented by circles.
Now that we have defined textile graphs, we have to formalize the notion of what it means to compare these graphs. One approach is to look for subgraph isomorphisms, which, in the general case, is a hard problem when applied to hypergraphs [2]. While it is in-teresting to know whether two textile graphs are isomorphic, we have a different goal: we want to measure the similarity of two structures, which means we need a hypergraph similarity measure. While different similarity measures have been proposed for tradi-tional graphs [30], among them graph edit distances (GED) [11], the picture looks different for hypergraphs. There are a few ap-proaches based on mathematical morphology [3] and error-tolerant hypergraph matching, including edit distance [6]. However, com-mon to these approaches is their high computational cost.
We follow an efficient two-phase approach in approximating the similarity of two textile graphs. In a first phase we extract infor-mation about the structure of a textile in the form of subgraphs, which we cover in Section 4.3, and in a second phase we measure the similarity based on the extracted information, which is the topic of Section 4.4
Star structures , which are small subgraphs, have been used to describe the internal structure of graphs [36]: every vertex in the graph is interpreted as the root of a tree with depth 2, meaning it in-cludes the vertex itself and all its neighbors. However, this method does not consider any order among the neighbors. While in prin-ciple our textile hypergraph is also unordered, we exploit the con-straints imposed by the application domain, in particular the fact that we know the relative position of threads in a crossing. (Later on, we also generalize this concept to arbitrary depths, something that Zeng et al. do not do [36].) Before defining the extracted sub-graph structure we formalize the positional information of threads, though.

Definition 2. Given a node c i belonging to crossing x i  X   X  and a node c j belonging to crossing x j  X   X  ( x i 6 = x j ) connected by an edge o i,j = ( c i ,c j )  X   X  , we say that o i,j is
Basically, an alternating thread changes from top to bottom or vice versa from one crossing to the next. For example, the edge from c 1 , 4 to c 3 , 1 in Figure 7 is alternating, the edge from c c 2 , 2 is not, while c 3 , 4 to t 1 is terminated.
The neighborhood of a crossing is defined by a 2-tuple contain-ing two sets of labels. The first set specifies whether the outgo-ing edges from the top edge vertices are alternating ( X  X  X ), non-alternating ( X  X  X ), or connect to a terminal ( X  X  X ). The second set specifies the same for the vertices on the bottom.

Definition 3. Given a crossing defined by x i  X   X  , let c c i, 2 stand for the top thread, i.e. ( c i, 1 ,c i, 2 )  X   X  and c for the bottom thread, i.e. ( c i, 3 ,c i, 4 ) 6 X   X  . B ( x { z 3 ,z 4 } ] is the neighborhood of crossing x i where and the  X  l,j are nodes from the other crossings that the c to or terminators, such as t l .

For example the neighborhood of crossing 1 in Figure 6 is de-advantages of this approach becomes evident: the representation retains all the relative spatial relationships, but at the same time is orientation invariant. Rotating the textile pattern by 90 or 180 de-grees or mirroring the structure has no effect on the textile graph and its crossing neighborhoods.

We describe a textile graph by computing the neighborhood of every crossing in the hypergraph and storing this information as a multiset of tuples. Definition 4. The fingerprint F ( H ) of a textile graph H ( C,T,  X  ,  X  ,  X ) is the multiset of the neighborhoods of its crossings: F ( H ) = { B ( x i ) | x i  X   X  }
For example, the fingerprint of the textile graph shown in Fig-the nodes of the crossings are connected to terminals or are part of alternating edges. This makes sense, as the tex-tile shown in Figure 6 is a plain weave, which is char-acteristically defined by alternating threads. The fingerprint of the textile in Figure 7, on the other hand, looks differ-[ {  X  X  X  ,  X  X  X  } , {  X  X  X  ,  X  X  X  } ] , [ {  X  X  X  ,  X  X  X  } , {  X  X  X  ,  X  X  X  } ] } .
The concept of a neighborhood can be generalized by not just looking at the immediate neighbors of a crossing, but by follow-ing a thread to further crossings and checking for each connec-tion whether it is alternating or not. Clearly, we stop tracing a thread as soon as we hit a terminator node. This schema specifies a k -neighborhood , in which we follow each of the four emerging threads to the next k neighbors:
Definition 5. Given a crossing defined by x i  X   X  , again let c i, 1 and c i, 2 stand for the top thread, i.e. ( c i, 1 c i, 3 and c i, 4 for the bottom thread, i.e. ( c i, 3 ,c thermore, let x l 1 ,j ,x l 2 ,j ,...,x l k ,j be the sequence of k crossings we encounter when following the thread leaving x i via c edges o j,h  X   X  connect nodes from different crossings, so o connects c i,j and  X  l 1 ,j 0 , and for h  X  2 o j,h connects  X  and  X  l h ,j 0 . Figure 8 illustrates this situation. Then B [ { y 1 ,y 2 } , { y 3 ,y 4 } ] is the k-neighborhood of crossing x [ y If o j,m is a terminated edge for m &lt; k , we only have m elements in tuple y j . For the example in Figure 8 the tuple y j [  X  X  X  ,  X  X  X  ,...,  X  X  X  ] .

This makes the neighborhood described in Definition 3 a spe-cial case of a k -neighborhood with k = 1 . The 2-neighborhood borhoods are computed accordingly, we just have to replace B ( x with B k ( x i ) in Definition 4.

Having defined fingerprints of textile patterns, we now have to specify how to actually measure their similarity or distance.
Typical distance metrics used for measuring the similarity of objects in non-Euclidean spaces include the Jaccard distance, the Hamming distance, and the cosine measure [20], all of which we cover in the following sections.
Since the fingerprints of our textile graphs are multisets rather than sets, we need to use the Jaccard coefficient for multisets. For every element in a multiset we store the number of occurrences of the element, so, for example, the multiset { a,a,a,b,c,c } becomes { a : 3 ,b : 1 ,c : 2 } or just (3 , 1 , 2) if we assign fixed positions to each element, position 1 representing the frequency of a, position 2 the frequency of b, and position 3 the frequency of c. Given two multisets R = ( r 1 ,r 2 ,...,r n ) and S = ( s 1 ,s 2 vector representation, R  X  S is computed as P n i =1 min( r R  X  S = P n i =1 max( r i ,s i ) . Consequently, we get the following distance measure: D J ( R,S ) = 1  X  Computing D J ( F ( H 1 ) ,F ( H 2 )) gives us the distance between two textile graphs H 1 and H 2 . For example, the fingerprint of H contains both of these tuples two times each, i.e., we can represent H 1 by (0 , 4) T and H 2 by (2 , 2) T . Applying Formula (1), we obtain
Fixing the positions of the elements within the multisets allows us to interpret them as vectors. Using a vector representation, we can apply the Hamming distance, which computes the number of components that differ in two vectors. Let f H ( r i ,s i that compares two components, such that Then a formal definition of the Hamming distance yields
Applying Formula (2) to the frequency vectors of the fingerprints of H 1 = (0 , 4) T and H 2 = (2 , 2) T gives us 1 + 1 = 2 .
There are a few issues with the Hamming distance. First, it is not normalized, the distance between two vectors ranges from 0 to n , which even varies depending on the size of the vectors. Sec-ond, if the elements of the domain used for the vector compo-nents are comparable, e.g. in the case of integers, intuitively the vector (1 , 0 , 3) T is closer to (1 , 0 , 2) T than (1 , 0 , 7) applying the original definition would give us a distance of 1 in both cases. We can redefine the function f H to consider this fact: f ( r i ,s i ) = | r i  X  s i | . Consequently, the distance measure be-comes
Applying Formula (3) to the frequency vectors of the fingerprints of H 1 = (0 , 4) T and H 2 = (2 , 2) T gives us 2 + 2 = 4 .
Formally, the cosine distance measure is defined via an inner vector product:
D c ( F ( H 1 ) ,F ( H 2 )) gives us the cosine measure distance be-tween two textile graphs H 1 and H 2 . For example, applying For-mula (4) to the frequency vectors of the fingerprints of H (0 , 4) T and H 2 = (2 , 2) T yields 1  X  0 + 8 / 4  X  8 = 1  X 
Often term frequency (TF) and inverse document frequency (IDF) are applied to the vectors when using the cosine measure. This is done to consider the fact that an increase in term frequency within an individual document has less and less impact and that terms ap-pearing less often in a document collection tend to be more impor-tant. In our case we also compare textiles using logarithmic TF-IDF factors: TF p,t = 1 + log( f p,t ) and IDF p = log N f the frequency of fingerprint p in textile t , N is the overall number of textiles in the collection, and f p is the number of textiles in the collection in which fingerprint p occurs.
Algorithm 1 shows a description of the fingerprint computation in pseudo-code. We iterate through all crossings and select all four nodes of a crossing in turn to follow a thread to the next k crossings, noting any change of position on the way. Let the first two nodes, c i, 1 and c i, 2 , denote those of the top-level thread, i.e., ( c  X  , while the other two nodes, c i, 3 and c i, 4 , belong to the bottom-level thread, i.e., ( c i, 3 ,c i, 4 ) 6 X   X  . We use the function to find the connecting node in a neighboring crossing, the function FINDLABEL to determine the label of an edge, and the function OPPOSITE to find a node X  X  counterpart within a crossing. If we reach the end of a thread before encountering k crossings, we fill up the labels with NULL values.

We have implemented our algorithm efficiently by storing the crossing nodes of a hypergraph in an array. Every node has the following structure:
The four nodes of a crossing are stored in neighboring cells of the array, i.e., the nodes at positions 4 i to 4 i + 3 belong to crossing i (for 0  X  i  X  n  X  1 , assuming we have n crossings). The com-ponent nextNode connects a node to the node of a neighboring crossing by storing the index of this node. If a node connects to a terminal, nextNode is equal to -1, which means that we do not Algorithm 1: FINGERPRINT ( H , k ) Input : hypergraph H ( C,T,  X  ,  X  ,  X ) with
Output : fingerprint for hypergraph H
FP :=  X  ; for every x i  X   X  do 3 for j := 1 to 4 do 4 let c i,j be the j -th node of crossing x i ; 5 (* j = 1 , 2 for top-level thread *) 6 l := 0, current = c i,j ; 7 repeat 8 l ++; 11 if label j,l 6 =  X  X  X  then 15 until k = l or label j,l =  X  X  X  ; 16 for s := l + 1 to k do 17 label j,s := NULL; 24 FP := FP  X  fp i ; end return FP; have to store the terminal nodes explicitly. In order to determine whether a node belongs to a top thread, we have added the Boolean variable onTop . The component oppositeNode is not strictly necessary, as we could determine the opposite node by looking at all other nodes of a crossing and then selecting the one with the same value for onTop ; it was added for efficiency reasons.
In summary this means that the k -neighborhoods of all n cross-ings of a textile can be computed in O ( nk ) .
We evaluated the variants of our similarity measure experimen-tally, clustering a data set containing over a thousand different tex-tiles and comparing the outcome to the correct classification. Ad-ditionally, we also run queries over our data set, measuring the retrieval performance. We also look at the efficiency, presenting numbers on the run time of the algorithm.
The algorithm was implemented using Java JDK 1.7.0_60 run-ning under Windows 7. All experiments were run on a computer with an Intel Core i5 CPU (2.60 GHz) and 2 GB memory.

In order to test the effectiveness of our textile similarity mea-sures, we partition a collection of n textile structures represented as hypergraphs S = { H 1 ,H 2 ,...,H n } into m clusters L = {  X  ..., X  m } and compare the outcome to the m categories of the cor-rect classification A = {  X  1 , X  2 ,...,  X  m } .

For clustering, we use hierarchical agglomerative clustering, in which each textile H i starts out in its own cluster. In every sub-sequent step, the two nearest subclusters are merged until m clus-ters remain. The Unweighted Pair Group Method with Arithmetic Mean (UPGMA) is used to calculate the distance between two sub-clusters u i and u j :
D u ( u i ,u j ) = 1 | u
For the purpose of measuring the quality of the clustering L com-pared to the correct classification A , we apply the Rand index [29]. Every pair of textiles H i ,H j  X  S,i &gt; j is categorized as a true positive (TP), true negative (TN), false positive (FP), or false nega-tive (FN), depending on the following conditions:
TP: H i and H j are in the same cluster in L and in the same class
TN: H i and H j are in different clusters in L and in different
FP: H i and H j are in the same cluster in L and in different
FN: H i and H j are in different clusters in L and in the same class The Rand index (RI) then measures the ratio of textiles placed cor-rectly within the clustering:
The Rand index assigns equal weight to false positives and false negatives and also includes true negatives. Usually, it is not very difficult to identify a large number of true negatives correctly, there-fore we also use the standard quality measures of precision P =
We evaluate the retrieval performance by using each of the tex-tile objects as a query q j  X  Q and then ranking all the other textiles according to their similarity to the query. All the textiles { h 1 ,h 2 ,...,h m j } that are in the same category  X  j as q sidered to be relevant, while those from other categories are not relevant. We measure the quality of the resulting ranked lists us-ing mean average precision (MAP), average Precision-Recall (PR), and average F-measure-Recall (FR) curves [24]. MAP provides a single value measuring the quality across all recall levels: where R jk is the ranked list from the first textile object down to h and Precision ( R jk ) is the precision of the set R jk .
A PR curve shows the change of precision with increasing recall; we calculate the standard 11-point interpolated average precision. The interpolated precision of query q j at the standard recall level r 0  X  l  X  10 , is defined as the highest precision found for any recall level r  X  r l : P j ( r l ) = max recall level r . Therefore, the average precision of Q at the standard recall level r l is defined as:
Similarly, the average F-measure of Q at the standard recall level r is equal to: q at r l .
We employ a textile editor called InaSawu [15, 25] to model the textiles in the data set and export their representations into plain text files, which we use to create the corresponding hypergraphs. With the help of a domain expert the 1200 fabrics were divided into twelve categories, each containing 100 items of a particular type of textile. On average, each textile consists of 25,352 vertices, 6,311 crossings (hyperedges) and 12,679 edges connecting crossings with each other or with terminals.

In the following, we give an overview of the different kinds of textiles found in each group. One of the simplest weaving patterns is plain weave, in which a weft thread alternates between going over and under a warp thread. 2 In each row, this pattern is shifted by one position (see Figure 9(a)). The next five groups of patterns consist of twills, in which more than one warp thread is crossed over or under. Figures 9(b) to (f) show example patterns, ranging from 2/1 twill to 4/4 twill. In the satin (also known as sateen) weave
Warp threads are longitudinal threads held in place by a frame, while the weft thread is led through the warp threads. structure (see Figure 9(g)), four or even more weft threads float over a warp thread or vice versa. The most complex patterns in our collection are taken from a collection of weavings originating in the Andes. Since they were created manually, they can exhibit a great variety of different styles in a single textile. The pattern depicted in Figure 9(h) indicates this, as the warp and weft threads cross a different number of threads in different parts of the textile. For more examples of Andean textiles, please see http://www. weavingcommunities.org/ .

For the remaining groups of textiles, shown in Figure 10 we have chosen patterns that are not actually woven. Triaxial weave, al-though called a weave, is a hybrid structure between weaving and braiding. The resulting structure, an example of which can be seen in Figure 10(a), does not follow a rectilinear pattern. Braids are cre-ated by intertwining three or more threads as shown in Figure 10(b). In knitting (see Figure 10(c)), loops are formed by connecting a row of new loops to a row of already existing loops. When done man-ually, this usually involves needles holding the thread. In the warp above weave pattern all the threads of one type are always located above the other (see Figure 10(d)). We included this group to see how our similarity measure would cope with non-textile patterns.
We have also introduced imperfections into some of the textiles in each group to test the similarity measure X  X  capability to deal with errors in a pattern. Additionally, we also rotated and mirrored some of the textile samples to check that our similarity measure can cope with differently oriented versions of the same weaving pattern.
Basically, we have two parameters with which we can calibrate our model: the size k of the neighborhoods and the distance metric used for comparing two fingerprints (JaccardDist, HammingBool, HammingFreq, CosineFreq, and CosineTfIdf; see Section 4.4 for details). In the following we investigate the impact of both param-eters on the run time and on the cluster and retrieval performance of our algorithms.
Figure 11 illustrates how the run time varies with increasing k for the different distance metrics. Every data point in Figure 11 av-erages the execution time of nine runs each generating a complete distance matrix including the results for the pairwise comparisons of all textiles. In general, the run time of each variant of our algo-rithm increases linearly with k .

Unsurprisingly, HammingBool, being the simplest formula, is fastest. HammingFreq is slower than HammingBool and slightly faster than JaccardDist, as JaccardDist needs to normalize its re-sult. Slightly surprising is the speed with which the cosine measure variants run, as this involves the most complicated computations compared to the other metrics. This is due to our implementation of the multisets. We refrained from using an explicit vector rep-resentation because of the sparsity of the vectors. For instance, although there are 97,871 different (potential) neighborhoods for k = 9 , on average only 668 appear in a given textile structure. As a consequence we can skip a large part of the inner product calcu-lation.
Figure 12 shows the Rand index, while Figure 13 presents the results for precision, recall, and F-measure for the cluster perfor-mance. For HammingBool every k -neighborhood has the same in-fluence, regardless of its frequency. This means, that an erroneous neighborhood (due, for example, to imperfections in the textile) will have the same impact as hundreds or thousands of correct iden-tical ones. Additionally, the larger the k , the more neighborhoods will be affected, which leads to the peculiar results seen in Fig-ures 12 and 13: the performance of HammingBool becomes worse with increasing k . To a lesser extent, this is also true for Ham-mingFreq, although storing the frequency of each neighborhood almost compensates for the negative impact of a growing k . In general, the cosine measure performs in a more expected way. When increasing k , the precision goes up at the price of a slightly decreasing recall. However, the cosine measure variants have a very low precision for small values of k ( k &lt; 4 ), making it much worse than JaccardDist for these cases. We found that the cosine measure tends to underestimate the distance between different ob-jects for small values of k , meaning that the wrong patterns are clustered together, leading to more false positives and therefore lower precision. JaccardDist shows the most stable behavior of all the investigated distance metrics, while exhibiting a good clus-ter performance, so we recommend using it over the others. Also, looking at the results in a general way, we can see that using neigh-borhoods with k &gt; 4 does not bring any substantial improvements, on the contrary, sometimes we observed a slightly worse perfor-mance.
Figure 14 depicts the mean average precision (MAP) of the dif-ferent techniques and indicate the overall utility of our textile pat-tern similarity measure. As for the cluster performance, there is no significant gain in using neighborhoods with a size greater than four, on the contrary, for some techniques the performance even gets worse. The Jaccard distance variant is clearly on top. For the other variants, the situation is not that clear: HammingFreq and CosineTfIdf are roughly comparable (except for very small values of k ), while HammingBool and CosineFreq trade places at k equal to four.
Figure 15 shows the PR and FR curves for neighborhoods of size four. Again, the Jaccard distance shows excellent results, in the PR curve the precision stays above 90% for recall values up to 90% and then drops to around 75%. HammingBool steadily loses ground, while HammingFreq is able to keep up with CosineTfIdf. CosineFreq loses about 20% precision within the first 10% of recall and then is able to keep this level, but is not competitive compared to some of the other techniques. Although the gaps in performance between the different similarity measures are smaller, the FR curve shows a similar picture.
Figure 15: Average PR and FR curves (4-neighborhoods)
More and more information is made available in a digitized form, this also includes areas such as the humanities and cultural heritage. A clear advantage of this approach is that digitized material is much easier to access. However, this also brings new challenges with it: users want to be able to search collections in an adequate and fast way. While text search is fairly well understood, other areas still have a lot of catching up to do. For instance, digital archives for textiles offer keyword search and arrange their content taxonomi-cally, but search functionality on the level of thread structure is still missing.

We developed a technique based on hypergraphs to represent tex-tiles using a crossing of two threads as the basic building block. De-composing such a graph into substructures called k -neighborhoods allows us to determine the similarity of the patterns created by the interwoven threads. In turn, this makes it possible to search a col-lection of textile patterns given a query pattern. We have exper-imentally tested several distance metrics for computing the simi-larity between multisets of k -neighborhoods and found that all of them can be implemented efficiently. Nevertheless, when it comes to actually distinguishing between differently made textiles, there are huge differences. The best variants are Jaccard distance and cosine measure, which are able to cluster textiles taken from a data set of 1200 samples much better than the Hamming distance. We also ran queries over the data set, measuring the retrieval perfor-mance. Here, the cosine measure loses some ground compared to the Hamming distance, but Jaccard still comes out on top. Conse-quently, we recommend using Jaccard, as it shows the best overall performance.

For future work we would like to investigate further distance measures and variations of neighborhoods to see if the technique using k -neighborhoods combined with the Jaccard distance can be further improved upon. Defining a notion of edit distances on hy-pergraphs for textile structures also looks like a promising direction to take. Finally, evaluating our similarity measure on other data sets to show that it is universally applicable is also an important point to consider. However, at the moment the modeling of the textiles used for the hypergraph representation has to be done manually, in order to automate this process, image-processing techniques for extracting a thread structure and mapping it to graphs would be an interesting topic to look into. [1] D. Arnold and P. Dransart, editors. Textiles, Technical [2] L. Babai and P. Codenotti. Isomorphism of hypergraphs of [3] I. Bloch, A. Bretto, and A. Leborgne. Similarity between [4] C. Brezine. The Oxford Handbook of the History of [5] R. Brownlow, S. Capuzzi, S. Helmer, L. Martins, [6] H. Bunke, P. Dickinson, M. Kraetzl, M. Neuhaus, and [7] J. Conway. Computational Problems in Abstract Algebra , [8] P. Cromwell. Knots and Links . Cambridge University Press, [9] R. D X  X arcourt. Textiles of Ancient Peru and Their [10] I. Emery. The Primary Structures of Fabrics . Thames and [11] X. Gao, B. Xiao, D. Tao, and X. Li. A survey of graph edit [12] S. Grishanov, V. Meshkov, and A. Omel X  X henko.
 [13] S. Grishanov, V. Meshkov, and A. Omelchenko. A [14] S. Grishanov, V. Meshkov, and A. Omelchenko. A [15] G. Gyory. Advanced Research and Trends in New [16] W. Haken. Theorie der Normalfl X chen. Acta Math. , [17] J. Hass, J. Lagarias, and N. Pippenger. The computational [18] J. Hoskins. Lecture Notes in Mathematics, Vol. 952 , chapter [19] G. Hotz. An efficient algorithm to decide the knot problem. [20] J. Leskovec, A. Rajaraman, and J. D. Ullman. Mining of [21] U. Liebscher and M. Weber. Topological studies of textiles I. [22] U. Liebscher and M. Weber. Topological studies of textiles [23] L. Ma, G. Baciu, J. Hu, and J. Zhang. A novel weave pattern [24] C. D. Manning, P. Raghavan, and H. Sch X tze. Introduction to [25] L. Martins, S. Helmer, and D. Y. Arnold. Exploring weaving [26] V. Milasius and V. Reklaitis. The principles of weave-coding. [27] T. Miyazaki, Y. Shimajiri, M. Yamada, H. Seki, and H. Itoh. [28] J. Quilter and G. Urton, editors. Narrative Threads: [29] W. M. Rand. Objective criteria for the evaluation of [30] J. Raymond, E. Gardiner, and P. Willett. Rascal: Calculation [31] K. Reidemeister. Elementare Begr X ndung der Knotentheorie. [32] D. Rosner, M. Roccetti, and G. Marfia. The digitization of [33] A. Rowe. Warp Patterned Weaves of the Andes . Textile [34] J. Valiente, F. Albert, C. Carretero, and J. Gomis. Structural [35] A. K. C. Wong, S. W. Lu, and M. Rioux. Recognition and [36] Z. Zeng, A. K. H. Tung, J. Wang, J. Feng, and L. Zhou. [37] D. Zheng, G. Baciu, and J. Hu. Accurate indexing and
