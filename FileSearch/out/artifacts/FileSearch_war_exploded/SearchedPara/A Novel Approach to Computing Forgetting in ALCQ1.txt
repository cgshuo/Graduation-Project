 The Semantic Web [1], as an extension of the World Wide Web (WWW), becomes more constantly changing and highly collaborative. KBs in Semantic Web can be used by au-tomated tools to provide advanced services such as more accurate web search, intelli-gent software agents and knowledge management. An example of large biomedical KB is SNOMED CT. KB editing and maintaining tools, such as Prot  X  eg  X  e, are supported by efficient reasoners based on tableau algorithms for description logics (DLs) [1]. How-ever, as shown in [1], the existing reasoners provide limited reasoning supports for KB modifications, which largely restricts the wide use of KBs in the Semantic Web. concepts and roles [14]. It is proven that forgetting can be applied in KB revision [14], KB repair [15], and KB reasoning [16] etc. Though there are some approaches to char-acterize the forgetting-based reasoning over KBs [15], it is still interesting to develop some algorithm to characterize the forgetting-based reasoning.
 of forgetting over KBs. Recently, there exist some works addressed this issue. For in-stance, a rewriting approach is presented to compute uniform interpolation in DL-Lite. However, this approach is not direct to treat KBs in expressive description logics even basic description logic ALC . As an attempt, Wang et al [14] have firstly defined seman-tic forgetting about concepts and roles in ALC KBs and have presented an algorithm to computing the result of forgetting where all concepts are required in disjunctive norm form (DNF). In [14], a tableau-based approach is proposed to compute the results of forgetting over ALC KBs where concepts are required in negation normal form (NNF) instead of DNF. In this sense, the efficiency of computing the result of forgetting would be improved. However, how to compute the results of forgetting over KBs in expressive description logics is still open.
 given variables with holding consistency. In this sense, the forest obtained by the algo-rithm from the original completion forest is taken as the completion forest of the result of KB after forgetting the set of variables. In the following, we compute the result of forgetting based on such forest by employing the rolling-up technique which is firstly presented in [7] to eliminate the variable between concept assertions and role assertions. lent query containing only a single concept term. The rolling-up technique is applied to compute the result of forgetting in ALC [13]. Unfortunately, the rolling-up technique proposed in ALC is not directly employed to compute the result of forgetting in ALCQ , which the number restriction ( Q ), a most expressive operator in constructing many ex-pressive description logics SHIQ [8], is allowed due to the major difference between the existential quantification and the number restrictions.
 getting over a KB ALCQ whenever it exists. Firstly, we introduce a notion of maximal set of mutually different successors to characterize the number restrictions of concepts. Secondly, based on maximal set of mutually different successors, we present a revised rolling-up technique. Finally, we develop an algorithm based on this revised rolling-up technique from each leaves in clash-free branches to roots so that we obtain the result of forgetting. We show that our proposal is sound whenever the results of forgetting exist. semantics of ALCQ . Section 2.2 introduces the notion of forgetting and develops a tableau-based approach to characterizing the forgetting-based reasoning. Section 3 presents a revised rolling-up technique and Section 4 develops an algorithm based on rolling-up technique to compute the result of forgetting. The last section summarizes this paper. In this section, we briefly recall some preliminaries of ALCQ and forgetting in ALCQ . Further details can be found in [1,8,6]. 2.1 Description logic ALCQ First, we introduce the syntax of concept descriptions for ALCQ . To this end, we as-sume that N C is a set of concept names , N R is a set of role names and N I is a set of individuals.
 concept name is also called atomic concept while a role name is also called atomic role . the domain and  X  I is an interpretation function which associates each atomic concept A with a subset A I of  X  I and each role R with a binary relation R I  X   X  I  X   X  I . This function  X  I can be naturally extended to complex descriptions as normal [1] assertion of the form C ( a ) or a role assertion of the form R ( a,b ) , where a and b are individuals, C is a concept and R is a role. An interpretation I satisfies a concept it is denoted I | =  X  . An interpretation I is a model of an ABox A , denoted by I | = A , if it satisfied all assertions in A .
 sumed by D ), where C and D are concept descriptions. The inclusion C  X  D ( C is equivalent to D ) is an abbreviation of two inclusions C v D and D v C . A terminol-ogy box , or TBox , is a finite set of inclusions. An interpretation I satisfies an inclusion C v D if C I  X  D I . I is a model of a TBox T , denoted by I | = T , if I satisfies every inclusion of T .
 interpretation I is a model of K if I is a model of both T and A , denoted by I | = K . If  X  is an axiom or an assertion, a KB K entails  X  , denoted by K | =  X  , if every model of K is also a model of  X  . Two KBs K and K 0 are equivalent , denoted by K  X  K 0 , if they have the same models. The equivalent relationship  X   X   X  can be similarly defined for ABoxes and TBoxes.
 names and role names in C . Similarly, we can define sig ( A ) for an ABox A , sig ( T ) for a TBox T , and sig ( K ) for a KB K .
 of concept names. Note that an arbitrary concept can be transformed into an equivalent one in NNF in polynomial time by applying the following rules:  X  ( C t D )  X  X  C u X  D,  X  (  X  R.C )  X  X  X  R.  X  C,  X  (  X  nR.C )  X  X  X  n  X  1 R.C,  X  ( C u D )  X  X  C t X  D,  X  (  X  R.C )  X  X  X  R.  X  C,  X  (  X  nR.C )  X  X  X  n + 1 R.C.
 to denote the NNF of  X  C .
 in NNF. 2.2 Forgetting in ALCQ Next, we briefly recall forgetting and tableau-based forgetting in ALCQ [6]. a result of forgetting about V in K if the followings hold.
 F1 K| = K 0 ; F2 for each concept inclusion C v D not containing any variables in V , K | = C v D F3 for each member assertion C ( a ) or R ( a,b ) not containing any variables in V , K| = we say V is forgettable from K if the result of forgetting about V in K is expressible as a KB.
 Lemma 1. [6] Let K be a KB in ALCQ and V a set of variables. Then  X  K is consistent iff forget( K , V ) is consistent;  X  for any  X  without variables in V , K| =  X  iff forget( K , V ) | =  X  .
 consists a labeled directed graph, each node of which is the root of a completion tree . Each node x is labeled a set of concepts L ( x ) and each edge  X  x,y  X  is labeled a set of that y is an R -successor of x ). A node y is an ancestor of a node x if they both belong to the same completion tree and either y is a predecessor of x , or there exists a predecessor z of x such that y is an ancestor of z .
 with L ( x a ) = { C | a : C  X  X } for each individual name a occurring in A , and an edge  X  x a ,x b  X  , with L (  X  x a ,x b  X  ) = { r | ( a,b ) : R  X  A} for each pair ( a,b ) of individual names for which the set { R | ( a,b ) : R  X  X  is non-empty.
 R
F ( x,C ) = { y | y is R -successor of x and C  X  L ( y ) } . The algorithm stops if it encounters a clash : a completion forest in which { A,  X  A }  X  L ( x ) for some node x and some concept name A or if there is some concept  X  n R.C  X  L ( x ) and x has n + 1 R -successors y 1 ,...,y n with C  X  L ( y i ) and y i 6 = y j for all 0  X  i &lt; j  X  n . A completion forest is clash-free if none of its nodes contains a clash, and it is closed otherwise. It is complete if no rule can be applied to it. And the algorithm answers  X  K is inconsistent X  if the completion forest contains a clash; and it answers  X  K is consistent X  otherwise.
 always terminate. However, when inclusions of TBoxes are discussed in the tableau algorithm, the algorithm might not be terminable. For instance, the algorithm for the GCI Person v  X  HasParent.Person runs perpetually. A so-called blocking technique is applied to guarantee termination of the expansion process even in the presence of GCIs. A node x is blocked if there is an ancestor y of x such that L ( x )  X  X  ( y ) (called  X  y blocks x  X ), or if there is an ancestor z of x such that z is blocked; if a node x is blocked and none of its ancestors is blocked, then x is directly blocked.
 tableau algorithm w.r.t. V on K [6]. We say the result of forgetting V in F , written by forgetting edges, written by forget( L (  X  x,y  X  ) , V ) , defined as follows:  X  for every node L ( x ) , forget( L ( x ) , V ) is obtained from L ( x ) by Step 1 delete all the form C t D or C u D or  X  R.C or  X  nR.C ;
Step 2 if { A,  X  A } X  X  ( x ) with A  X  X  , then replace A and  X  A by  X  ; Step 3 if A or  X  A or A t C or  X  A t C in L ( x ) with A  X  V , then delete A or  X  A or
Step 4 if  X  R.C  X  L ( x ) or  X  nR.C  X  L ( x ) with R  X  V , then delete  X  R.C or
Step 5 if  X  R.C  X  L ( x ) or  X  nR.C  X  L ( x ) with R 6 X  V , then replace C with Lemma 2. [6] Let K be a KB and  X  an axiom in ALCQ . For any set of variables V irrelevant to  X  , we have forget(( K , V ) | =  X  iff forget(( F , V ) is closed, where F is a completion forest of K X  X  X   X  } by applying the tableau algorithm [6].
 a fresh special individual.
 not contain any variables in V obtained by applying the forgetting forest algorithm could capture the consistency of K limited in the set of variables sig( K X  X  ) . In this section, we show that the traditional rolling-up does not always recovery forget-ting and then propose a revised rolling-up. 3.1 Traditional rolling-up is unable to characterize results of forgetting The idea of the rolling-up technique is to transform the initial query into an equivalent query containing only a single concept term [7]. For example, HasChildren ( x,y )  X  Male ( y ) be paraphrased as the single term  X  HasChildren . Male ( x ) .
 graph, handles the n -path query by transforming into the conjunction of existential quantification concepts. For instance, the result of rolling-up of HasChild  X  L (  X  x,y  X  )  X  HasDegree  X  X  (  X  y,z  X  )  X  PhD  X  X  ( z ) is  X  HasChild . HasDegree . PhD ( x ) . pute the result of forgetting from the completion forest after applying the tableau algo-rithm since there exists the following limitations.  X  The rolling-up technique does not always return the universal quantification con- X  The rolling-up technique captures the expressivity of one-of , and it can be simu- X  Another difficulty of the rolling-up technique could not capture the number restric-3.2 Improving rolling-up Based on the above discussions, we need to extend the traditional rolling-up technique in order to capture the number restrictions  X  To improve the first limitation, we would retain universal quantification concepts  X  To revise the second limitation, we introduce a collect concept of all concepts in  X  To improve the third limitation, we extend the rolling-up technique by adding new R if x is R -predecessor of y , denoted as follows: Let { x 1 ,...,x n } be a set of individuals. { x 1 ,...,x n } is called mutually different if x 6 . = x j for 1  X  i &lt; j  X  n , denoted by [ x ] n . We denote L ([ x ] n ) = T n i =1 L ( x i ) . such that (1) { y 1 ,...,y n } is mutually different; and (2) for another R -successor y of x , { y 1 ,...,y n ,y } is no longer mutually different.
 Definition 1 Let [ y ] n be a maximal set of mutually different R -successors of a node x . We say the result of rolling-up y at x is defined as where [ y i ] m = { y i 1 ,...,y i m } . rithm. Given a KB K , the following algorithm will obtain a new KB K 0 without any new individuals by applying the rolling-up technique from the completion forest of K under the tableau algorithm.
 tification  X  R.C because  X  R.C  X  X  X  1 R.C and a singleton set { x } , which contains only one individual, could be taken a mutually different set. In this sense, there is no differ-ence treatment between  X  R.C and  X  1 R.C .
 Lemma 1.
 Algorithm 1 R OLLING -UP ( F )  X  Branch o ( F ) is a collection of open branches of F ;  X  Branch o i ( F ) is the i -th element of Branch o ( F ) ;  X  Name(Branch o i ( F )) is a collection of named individuals of the i -th element of  X  Leaf(Branch o i ( F )) is a collection of leaves of the i -th element of Branch o ( F ) . the result of forgetting.
 Proposition 1 (Rolling-up equivalence). Let K be a KB and V a set of variables. If F is a completion forest by applying the standard tableau algorithm over K X  X  X   X  } , then for any axiom  X  we have forget( K , V ) | =  X  iff R OLLING -UP (forget( F , V )) | =  X . by Lemma 2 since F is a completion forest by applying the standard tableau algorithm over K X  X  X   X  } . Based on the proof of [13, Theorem 1], we only need to show that the following equation in Definition 1: Indeed, this equation (3) holds because m  X  n and, both sides of this equation are equal to the equation  X  m min R. coll( L ([ y i ] m ))( x ) . , where m min is the least number. Algorithm 1 to compute the result of forgetting about a set of variables in a KB. Proposition 2 (Computing result forgetting). Let K be a KB and V a set of variables. If F is a completion forest by applying the tableau algorithm over K , then we have all axioms of a KB K .
 Next, we employ Algorithm 1 to compute the result of forgetting in the follow three cases, namely, forgetting in a concept, forgetting in a TBox and forgetting in a KB. In this section, we develop rolling-up algorithms for computing forgetting in concept descriptions, TBoxes, and KBs. 4.1 Computing forgetting in concept descriptions Intuitively, the result C 0 of forgetting about a set of variables from a concept description C should be weaker than C but as close to C as possible.
 Definition 2 (see [10]) Let C be a concept description in ALC and V a set of variables. A concept description C 0 on the signature sig( C )  X  X  is a result of c-forgetting about V in C if the following conditions are satisfied: CF1 | = C v C 0 ; CF2 for every ALC concept description C 00 with sig( C 00 ) uV =  X  , | = C v C 00 implies node, written by s , as the start node of the algorithm. Let C ( a ) be a concept assertion, we denote Concept( C ( a )) = C , which is a concept extracted from C ( a ) . Algorithm 2 R ESULT ( C, V ) Example 1 Suppose the concept  X  X esearch Student X  is defined by C = Student u ( Master t PhD ) u X  supervised . Professor where  X  X aster X ,  X  X hD X  and  X  X rofessor X  are all concepts;  X  X upervised X  is a role and supervised ( x,y ) means that x is supervised by y . We have R ESULT ( C, Student ) = ( Master u  X  supervised . Professor ) t ( PhD u  X  supervised . Professor ) .
 distributive law . Moreover, R ESULT ( C, supervised ) = ( Student u Master ) t ( Student u PhD ) , i.e., R ESULT ( C, supervised ) = Student u ( Master t PhD ) by the distributive law . 4.2 Computing forgetting in TBoxes It easily shows that the problem of computing forgetting in TBoxes can be transformed into the problem of computing forgetting in concept descriptions. We denote Analogously considering, we need to introduce a new node, written by s , as the start node of the algorithm. Furthermore, since the result of forgetting in TBoxes is still a TBox, we need to structure an inclusion as &gt;v Concept( R ESULT ( C T , V )) . Example 2 Let T = { Master v Degree , PhD v Master, Professor v X  earn.Degree } . We have Degree )) } . Algorithm 3 R ESULT ( T , V ) 4.3 Computing forgetting in knowledge bases forgetting in ABoxes are relevant to TBoxes. Therefore, we compute the result of for-getting in TBoxes and the result of forgetting in ABoxes w.r.t. TBoxes.
 Algorithm 4 R ESULT (( T , A ) , V ) Example 3 In Example 2, if we receive a piece of information that  X  Smith  X  is known as a  X  Professor  X . In this case, the ABox A has a new assertion Professor ( Smith ) . By Algorithm 4, we have R ESULT (( T , A ) ,Professor ) = (forget( T ,Professor ) , { ((  X  PhD u  X  Master u  X  earn.Degree ) t (  X  PhD u Degree u  X  earn.Degree ) t ( Master u Degree u X  earn.Degree ))( Smith ) } ), that is, R ESULT (( T , A ) ,Professor ) = ( {&gt;v ((  X  PhD u X  Master ) t (  X  PhD u Degree ) t (  X  Master u Degree )) } , { ((  X  PhD u  X  Master ) t (  X  PhD u Degree ) t ( Master u Degree )) u (  X  earn.Degree )( Smith ) } ). algorithm, which is the key module of Algorithm 2, Algorithm 3, and Algorithm 4. Proposition 3. Algorithm 1 is polynomial.
 pends on the complexity of generating forgetting tableaus beside rolling-up, i.e., Gen-erate.Forgetting.Tableau.Algorithm [6]. In this paper, we presented a rolling-up algorithm to compute the result of forgetting for ALCQ from the complete forest obtained by applying the forgetting-based tableau algorithm. Our proposal extends the current rolling-up technique to compute the results of forgetting for ALC by characterizing the number restriction of description logics, which is an important operator for representing expressive description logics. In this sense, our rolling-up technique provides a feasible approach to computing the results of forgetting in expressive description logics consisting of the number restriction. This work is supported by the National Key Research and Development Program of China (2016YFB1000603), the National Natural Science Foundation of China (61502336), the Key Technology Research and Development Program of Tianjin (16YFZCGX00210), and the open funding project of Key Laboratory of Computer Network and Information Integration (Southeast University), Ministry of Education (K93-9-2016-05).
