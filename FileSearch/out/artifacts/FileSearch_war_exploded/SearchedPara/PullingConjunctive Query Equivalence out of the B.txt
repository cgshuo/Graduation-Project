 We present Lecqter , a tool for generating a  X  X erfect ex-ample X  database, called exemplar, for a given conjunctive query. Indeed, exemplars separate the given query from any non-equivalent query. Therefore, Lecqter reduces the query equivalence problem to an evaluation of the queries on the exemplar. Lecqter can thus be used for applica-tions ranging from testing coded conjunctive SQL queries to learning how to write sound conjunctive SQL queries, as it provides immediate feedback about the semantic correctness of a query, and not just the correctness of the query answer on some database as, e.g., other SQL tutoring systems. This key novelty of Lecqter relies on the bag semantics of SQL since exemplars do not always exist under set semantics. De-tailed experiments show that our construction of exemplars is efficient in practice, and that they can separate a number of non-equivalent user queries that is exponential in the size of the exemplar for the target query. We identify natural parameters to control the time and size of the exemplars constructed. Finally, we offer a solution that overcomes the non-existence of exemplars under set semantics.
 H.2.3 [ Database Management ]: Languages X  Query lan-guages Algorithms, Management, Performance, Theory, Verifica-tion Bag semantics; Conjunctive query; Set semantics; SQL; Test data; Query equivalence
The ability to write semantically correct SQL queries is no longer a craft reserved for specialists, but a core skill that business seeks from many of their employees. There-fore, SQL query semantics is important to be understood also by an increasing number of non-expert users working in education, engineering, entertainment, finance, government, health, science and so on, who must be able to query data to help achieve their objectives. As a technique for enabling a better understanding of SQL queries, we introduce the concept of a  X  X erfect example X  database, called exemplar, which can separate a given target query Q from each non-equivalent query Q  X  . Indeed, Q and Q  X  are equivalent if and only if Q and Q  X  have matching answers on the exemplar. This ability effectively reduces the query equivalence prob-lem between Q and every Q  X  to the evaluation problem of Q and Q  X  on the exemplar. Non-expert users are thereby em-powered to judge the semantic correctness of their queries, which makes exemplars a useful vehicle in applications rang-ing from testing to SQL tutoring systems.
 The construction of exemplars faces several challenges. Firstly, real-world data cannot be expected to form exem-plars -as illustrated later. Secondly, Mannila and R  X  aih  X  a showed that there are queries for which no exemplar exists [16]. More precisely, they investigated the language L ( Q ) that consists of all conjunctive queries without self-joins that use the same SELECT and FROM clause as the target Q , respec-tively, and where every data value in the WHERE clause also appears in that of Q . For set semantics, they showed that there are conjunctive queries Q and non-equivalent Q 1 ,Q L ( Q ) for which no L ( Q )-exemplars exist [16]. That is, no set of tuples can separate Q from both Q 1 and Q 2 . In comparison to this, our contributions are the following: (1) Our main result shows for the same language L ( Q ) of conjunctive queries under bag semantics, how to construct an L ( Q )-exemplar for every conjunctive query. (2) We provide an implementation of an automated tutoring system called Lecqter . Trainers enter an SQL schema and a target query Q in the GUI, which then generates an exem-plar in MySQL. Trainees then enter their queries Q  X  in the GUI, which retrieves both user and target answers from the exemplar, showing the difference of Q and Q  X  if and only if Q and Q  X  are non-equivalent. As the distinguishing feature of
Lecqter , its users are assured of the semantic soundness of their queries whenever query and target answers match. (3) We show how to use exemplars to test coded SQL queries. (4) We demonstrate the efficiency of our exemplar construc-tion despite well-known related challenges from the litera-ture, as outlined in Section 3. In fact, our exemplars sep-arate a number of non-equivalent queries from the target query that is exponential in their size. The size and time o f our construction are each proportional to the number of conditions in the WHERE clause of the target query. (5) We propose an alternative use of L ( Q )-exemplars for testing and for learning of conjunctive queries under set se-mantics, motivated by the SELECT DISTINCT clause in SQL. Although an exemplar db Q cannot always distinguish Q si-multaneously from all user queries in L ( Q ), for each Q L ( Q ), selecting a single tuple from each table of db Q results in a database which separates Q from Q  X  if and only if they are not equivalent. Therefore, exemplars are also instrumen-tal in automating high-quality feedback and assessment of conjunctive queries under set semantics.
 Organization. Motivating examples are presented in Sec-tion 2. The related work in Section 3 describes the state-of-the-art and research challenges. Section 4 introduces prelim-inary concepts. The construction of exemplars is detailed in Section 5, and a showcase of Lecqter is given in Section 6. Experimental results are presented in Section 7, and the use of exemplars for set semantics is discussed in Section 8. Sec-tion 9 concludes, and outlines future work.
In this section, four different motivations are provided for the need and use of Lecqter . Firstly, it is illustrated that current tutoring systems do not provide high-quality feed-back to trainees. Secondly, we argue that testing can be significantly improved by exemplars. Thirdly, a simple ex-ample illustrates convincingly that real-world data sets can-not be expected to separate a reasonably large number of non-equivalent queries. Fourthly, a natural example shows that the use of set semantics cannot even always produce exemplars that can separate three non-equivalent queries.
Automated SQL tutoring systems are seen as the sav-ior of high quality feedback and assessment, for example in MOOCs [10]. Systems such as SQLtutor [5] are interac-tive tutorials that provide helpful exercises for SQL trainees. However, their main shortcoming is the inability to pro-vide feedback on the semantic soundness of the user queries. That is, they simply verify whether the answer to a user query matches that of the target query on some given database.
For example, GNU SQLtutor contains web-based interac-tive tutorials of SQL. It includes the tutorial Olympics , in which the trainees are asked to convert the following En-glish language query into SQL syntax:  X  X or the discipline table tennis in the singles Women event, show in which city  X  X hen, Jing X  won medals of which color X . A semantically correct conjunctive SQL query is [5]: SELECT city, medal FROM olympics WHERE discipline = `Table Tennis' AND which returns the correct answer [5]: Th e semantically incorrect conjunctive SQL query SELECT city, medal FROM olympics WHERE event=`singles Women' AND surname=`Chen'; returns the same answer. Trainees who enter this query can-not conclude that their query is semantically correct. In re-ality, most trainees will think they submitted a semantically sound query. Worse, trainees who did submit a semanti-cally correct query cannot conclude that they did. Hence, the value for trainees is modest at best.

An exception is the lab tutor Gradience [18], which in-cludes on-line SQL exercises that  X  X eature immediate con-structive feedback about the correctness of the submitted queries. [...] However, the detection of semantically incor-rect queries depends on the ability of the trainer to antici-pate all potential cases. An important point is that students will tend to try to write queries that work on the sample database, even if they do not work in general. Thus, it is important to use an evaluation database that detects such attempts X  [18]. The use of exemplars overcomes this antic-ipation issue, as the sample database that is automatically constructed by Lecqter is ideal in the sense that it will detect any such attempts. Our recommendation is to auto-matically generate exemplars whenever feasible, and to use Gradience in other cases.
Testing the correctness of a coded SQL query Q  X  , i.e., de-ciding whether Q  X  is equivalent to a target query Q , is hard if large real data sets are being used. Unfortunately, even if the answers to Q  X  and Q are the same on an arbitrarily given database, a human tester is unable to conclude that the coded query Q  X  is equivalent to the target query Q , that is, returns matching answers on every database. Ideally, test datasets are small and allow a complete test, i.e., allow to find all errors. Exemplars have this property and addition-ally can be generated automatically from the coded SQL query Q  X  . As we do not know the query string of Q , while testing the correctness of the coded SQL query Q  X  , we swap the roles of Q and Q  X  and construct an exemplar db Q  X  for the same if and only if Q  X  and Q are equivalent, testing query equivalence on the exemplar is complete, that is, sufficient to guarantee the correctness of Q  X  .
The Kinship data set from the UCI Machine Learning repository [1] consists of people with 24 unique names that belong to two families with two equivalent structures. The English language query  X  X rint the names of Marco X  X  daugh-ters and their aunts that are Marco X  X  sisters X  can be written as the conjunctive SQL query: SELECT s.pname1 AS `aunt', d.pname1 AS `daughter' FROM father f, sister s, daughter d WHERE f.pname1=`Marco' AND f.pname1=s.pname2 AND Th e non-equivalent query X  X rint the names of Marco X  X  daugh-ters and their aunts X , which also includes the aunts that are sisters of Marco X  X  wife, can be written as follows: SELECT s.pname1 AS `aunt', d.pname1 AS `daughter' FROM father f, sister s, daughter d WHERE f.pname1=`Marco' AND However, for the simple reason that Marco X  X  wife does not have any sisters, both queries return the same result Th e example illustrates convincingly that real-life data can-not be expected to exhibit a structure able to separate a reasonably large number of non-equivalent queries.
Finally, we adapt the example from [16, Example 14, page 250] to a real-world setting. Indeed, there cannot be any database db Q such that the query Q : SELECT DISTINCT name FROM PATIENT p, DIAGNOSIS d WHERE name=`Smith' AND p.pid=`NHI003' produces answers different from those of the queries Q 1 and Q 2 on db Q . Here, Q 1 results from Q by removing from its WHERE clause condition=`HIV' , and Q 2 results from Q by removing from its WHERE clause name=`Smith' . Indeed, for Q ( db )  X  = Q 1 ( db ) to hold, the table over PATIENT must contain (Smith, NHI003), and the table over DIAGNOSIS must not contain (NHI003, HIV) but some (NHI003, c) where c  X  = HIV . For Q ( db )  X  = Q 2 ( db ) to hold, the table over DIAGNOSIS must contain (NHI003, HIV). Hence, there is no database db such that Q ( db )  X  = Q 1 ( db ) and Q ( db )  X  = Q 2 ( db ) both hold. Summary. Together, the examples illustrate the core con-tribution of our research in relation to the current state-of-the-art: We show how the bag semantics of SQL enables Lecqter to construct databases that can separate a large number of non-equivalent queries from any given conjunc-tive query. Therefore, Lecqter can automate high-quality feedback to trainees and automate their assessment.
Mannila and R  X  aih  X  a have initiated research on exemplars in [15, 16]. The notion was characterized using Armstrong databases [4, 13], and two constructions were given. The research in these articles was focused on set semantics only, and essentially the example from Section 2.4 was given to show their non-existence for some conjunctive queries with-out self-joins. In sharp contrast, we show that exemplars do exist for every conjunctive query without self-joins under bag semantics, and how to construct them.

The availability of an L ( Q )-exemplar db Q means that for every Q  X   X  L ( Q ), Q and Q  X  are equivalent if and only if the answer to Q on db Q is the same as the answer to Q  X  on db
Q . Therefore, the construction of exemplars is intrinsically linked to the well-studied problem of query equivalence. Un-der set semantics the problem is undecidable for relational calculus queries, and NP -complete for conjunctive queries [2]. Under bag semantics the query equivalence problem has the same complexity as the graph isomorphism problem [3], which is one of the few problems for which it is still unknown whether it is in P , or NP -complete, or neither. The com-plexity of the containment problem for conjunctive queries under bag semantics remains still open after twenty years of dedicated research [3, 7, 8, 11, 12]. Our results on the gen-eral efficiency of our construction should be viewed under the plethora of these computationally hard problems. We fix preliminary definitions required in this article. Bags. We assume a countably infinite set A of attributes . Each A  X  A has a countably infinite domain dom ( A ). A re-lation schema is a finite sequence ( A 1 ,...,A n ) of attributes together with a name R , denoted by R ( A 1 ,...,A n ). A tu-ple over R ( A 1 ,...,A n ) is an element of the Cartesian prod-uct over the associated domains. A bag B is a collection of tuples over R ( A 1 ,...,A n ) in which the same tuple may occur several times. We denote by | t | B the number of oc-currences of tuple t in bag B . For two bags B,B  X  over R ( A 1 ,...,A n ) the bag inclusion B  X  b B  X  holds iff for all tuples t over R ( A 1 ,...,A n ), | t | B  X  | t | B  X  . B and B equal, denoted by B = b B  X  iff B  X  b B  X  and B  X   X  b B both hold. The proper bag inclusion B ( b B  X  holds iff B  X  b B holds and there is some tuple t over R ( A 1 ,...,A n ) such that | t | A duplicate-preserving projection of B onto A i 1 ,...,A i m A 1 ,...,A i m . A database schema schemata, and a database db over D assigns to each relation schema in D a finite bag over the relation schema. Conjunctive SQL Queries. A conjunctive SQL query Q (without self-joins) over D is a statement of the form Here, we have relation schemata R i ( A i 1 ,...,A i n i ) i = 1 ,...,k . We assume that R 1 ,...,R k are distinct. From here on, we denote the schema over the distinct attributes as R ( A 1 ,...,A n ) where n = SQL query, we further have for each j = 1 ,...,m , A i j  X  {
A 1 ,...,A n } , and for h = 1 ,...,l , C h denotes either an attribute-attribute equality A r = A s or an attribute-constant equality A r = c for some A r ,A s  X  { A 1 ,...,A n } and some c  X  dom ( A r ). A tuple t over R ( A 1 ,...,A n ) satisfies the WHERE clause, denoted by | = t  X  Q , if and only for h = 1 ,...,l , t ( A r ) = t ( A s ), if C h := A r = A s , or t ( A r ) = c , if C A r = c . Here, ( A i 1 ,...,A i m ) is the answer schema of Q .
For a database db over D , where r 1 ,...,r k denote the bags over R 1 ,...,R k , respectively, the answer to the conjunctive SQL query Q on db is defined as using duplicate-preserving projection  X  b . As usual r 1  X  X  X  X  X  r is the bag that is the (bag) cross product of r 1 ,...,r k A conjunctive query over D is defined as a conjunctive SQL query, except that we use SELECT DISTINCT instead of SELECT . Similarly, the answer to the conjunctive query Q on db wi th relations r 1 ,...,r k is defined as before, but uses duplicate-eliminating projection  X  .

Containment and Equivalence. For a database db over D , a conjunctive SQL query Q over D with answer schema ( A i 1 ,...,A i m ), and a tuple t over ( A i 1 ,...,A Q on db . For conjunctive SQL queries Q and Q  X  over D with answer schema ( A i 1 ,...,A i m ), Q is contained in Q  X  bag semantics), denoted by Q  X  b Q  X  , iff for every database db over D , and every tuple t  X  dom ( A i 1 )  X  X  X  X  X  dom ( A | t Q ( b Q  X  , iff Q  X  b Q  X  , but Q  X   X  b Q does not hold. Q and Q  X  are equivalent , denoted by Q  X  Q SQL queries. The containment (equivalence) problem for L is to decide for any given Q,Q  X   X  L , if Q  X  b Q  X  ( Q  X  holds. Similar definitions apply to conjunctive queries, that is, under set semantics. This section develops the main foundation of Lecqter . After giving the definition of L ( Q )-exemplars for conjunctive SQL queries, the requirements on the language L ( Q ) are dis-cussed. In what follows we establish a theory for construct-ing a special class of L ( Q )-exemplars that we call canonical. Subsequently, the computation of canonical L ( Q )-exemplars is detailed, and the complexity of the computation discussed. We start with the main definition of this paper.

Definition 1. Let Q denote a conjunctive SQL query and db Q a database, both over database schema D . Let L denote a class of conjunctive SQL queries over D . We say that db Q is an L -exemplar for Q if and only if for every Q  X   X  X  , Q ( db Therefore, trainees who want to verify whether their query Q  X   X  X  is equivalent to the target query Q just need to check that Q  X  produces the same answer as Q on an L -exemplar for Q . Indeed, the answers to Q and Q  X  coincide on every database if and only if the answers to Q and Q  X  coincide just on the exemplar. Hence, the exemplar is indeed an ideal model for testing equivalence between Q and any Q  X   X  X  .
The existence of exemplars depends critically on the choice of
L . Here, we focus on the same language L as in previ-ous research [15, 16]. That is, for a conjunctive SQL query Q , L := L ( Q ) consists of those conjunctive SQL queries Q which have identical SELECT and FROM clauses as those of Q , respectively, and in which every constant that appears in an equality of the WHERE clause in Q  X  also appears as a con-stant in some equality of the satisfiable WHERE clause in Q . As explained in [15] these restrictions are reasonable: Users are unlikely to introduce incorrect attributes in the SELECT clause or incorrect table schemata in the FROM clause. Fur-thermore, users are unlikely to introduce in their queries constants which are not mentioned in the natural language description of the target query Q [15]. In sharp contrast to [15, 16] we consider indeed SELECT instead of SELECT DISTINCT statements. In fact, SELECT DISTINCT statements prevent the general existence of L ( Q )-exemplars, as shown in [15, 16] and illustrated in Section 2.
Our ultimate aim is to compute an L ( Q )-exemplar for every conjunctive SQL query Q without self-joins. For this purpose our goal is to first understand what tuples can form the elements of such an exemplar.
 The approach towards achieving this goal is embodied in the following definition of minimal proper containers.
Definition 2. Let Q be a conjunctive query without self-joins, and let Q  X   X  X  ( Q ) . We call Q  X  a container of Q if and only if Q  X  b Q  X  holds. We call Q  X  a proper container of Q if and only if Q ( b Q  X  holds. A proper container Q  X  of Q is minimal if and only if for every proper container Q  X  X   X  X  all minimal proper containers of Q .

F rom now we write M ( Q ) for a set with one representative from each equivalence class of M ( Q ) /  X  b . As L ( Q ) contains only finitely many non-equivalent elements, M ( Q ) is finite. This notation is sufficient for our construction. In particular, M ( Q ) is unique up to the equivalence of queries.
Example 1. Consider an application domain where pur-chases of products by customers are recorded. Products have an identifier pid and a name pname , customers have an identifier cid and a name cname . Customers cid purchase products pid on a date at a cost . The schema D is thus given by CUSTOMER(cid,cname) , PRODUCT(pid,pname) , and BUY(cid,pid,date,cost) . The target query Q is to  X  X rint the customer name, product name and cost of all purchases made by the customer with identifier c7 on 3/9/14  X , which can be written in SQL as follows: SELECT cname, pname, cost FROM CUSTOMER c, PRODUCT p, BUY b WHERE c.cid=b.cid AND c.cid=`c7' AND The queries Q  X  on the left, and Q  X  X  on the right: SELECT cname, SELECT cname, FROM CUSTOMER c, FROM CUSTOMER c, WHERE b.cid=c.cid WHERE b.cid=c.cid are both proper containers of Q , but only Q  X  is minimal.
Q  X   X  X  ( Q ) is equivalent to Q iff it is a container of Q but not a container of any of Q  X  X  minimal proper containers Q
Lemma 1. Let Q be a conjunctive query without self-joins, and let Q  X   X  L ( Q ) . Then, Q  X  b Q  X  if and only if Q  X  and for every Q i  X  X  ( Q ) , Q i  X  X  b Q  X  .

Proof. If Q  X  b Q  X  , then Q  X  b Q  X  and Q  X   X  b Q . If there was some minimal proper container Q i of Q for which Q which would contradict the definition of a proper container.
Assu me that Q  X  X  b Q  X  and Q  X  b Q  X  . We need to show that there is some Q i  X  M ( Q ) such that Q i  X  b Q  X  holds. From Q  X  X  b Q  X  and Q  X  b Q  X  follows that Q  X   X  X  b Q , hence Q is a proper container of Q . If Q  X   X  X  ( Q ), then we are done. Otherwise Q  X  is not a minimal proper container. Therefore, there is some proper container Q  X  X  of Q such that Q  X  X   X  and Q  X  X   X  X  b Q  X  . As every chain of proper containers is finite, Q  X  contains some minimal proper container of Q .
 The next result states an observation that holds the key to the construction of exemplars for conjunctive SQL queries.
Lemma 2. Let B,B  X  denote two bags over R ( A 1 ,...,A n ) , such that B ( b B  X  . Then  X  b A i
Proof. This follows immediately from the definition of the proper bag inclusion ( b , and the fact that the duplicate-preserving projection  X  b A i nality of the underlying bags.

Lemma 2 does not apply to duplicate-eliminating projec-tions. A simple example over R ( A ) are the bags B = { 0 and B  X  = { 0 , 0 } , i.e., B ( b B  X  holds. As  X  b  X  ( B ) = { () , () } =  X  b  X  ( B  X  ) holds, we have  X   X  ( B ) = { ()  X  ( B  X  ) under duplicate-eliminating projections. In partic-ular, there are conjunctive queries under set semantics for which no L ( Q )-exemplars exist for this reason [16]. We now reduce the containment problem of two queries in L ( Q ) to an implication problem of the two formulae derived from the WHERE clauses of the two queries. For this, we first define the equivalence of two formulae. Recall our general format of a conjunctive SQL query Q from before. For Q , let V Q := { A 1 ,...,A n } denote the attributes of R , which we view as variables , and let C Q denote the constant symbols c that appear in the WHERE clause of Q . The terms of Q are T
Q := V Q  X  C Q . An equality  X  for Q is either an attribute-attribute equality A r = A s for 1  X  r,s  X  n or an attribute-constant equality A r = c where 1  X  r  X  n and c  X  C Q . A formula  X  for Q is a conjunction of equalities for Q . We use F ( Q ) to denote the set of formulae for Q . A conjunctive SQL query for Q is a conjunctive SQL query of the form where C  X  1  X  X  X  X  X  C  X  o  X  F 0 ( Q ) is a formula for Q . We use L ( Q ) to denote the set of conjunctive SQL queries for Q . For Q  X   X  X  0 ( Q ) let  X  Q  X  = C  X  1  X  X  X  X  X  C  X  o denote the formula in F 0 ( Q ) that forms the WHERE clause of Q  X  .

Example 2. For the target query Q from Example 1, c.cid=b.cid  X  c.cid=`c7'  X  b.pid=p.pid  X  b.date=`3/9/14' denotes the formula  X  Q that forms its WHERE clause. The satisfaction of a formula  X   X  X  0 ( Q ) by a tuple t over R ( A 1 ,...,A n ), denoted by | = t  X  , is defined as follows:
For  X , X   X  F 0 ( Q ),  X  implies  X  , denoted by  X   X   X  , iff
Example 3. Let Q denote the target query from Example 1. The tuple (c0,Jimmy,p1,printer,c0,p1,3/9/2014,79) over R(c.cid,c.cname,p.pid,p.pname,b.cid,b.pid,b.date,b.cost) does not satisfy  X  Q from Example 2, which is satisfied by the tuple (c7,Jimmy,p1,printer,c7,p1,3/9/2014,79).

Let F ( Q )  X  F 0 ( Q ) denote the formulae of F 0 ( Q ) that are satisfiable. That is, those formulae  X   X  X  0 ( Q ) such that there is some tuple t over R ( A 1 ,...,A n ) that satisfies  X  . For example, c.cid=b.cid  X  c.cid=`c0'  X  b.cid=`c7' is unsat-isfiable. Let L ( Q )  X  L 0 ( Q ) denote the set of conjunctive SQL queries Q  X  for Q where  X  Q  X   X  F ( Q ) holds. We can now establish a correspondence between the containment of our queries and the implication of their associated formulae.
Lemma 3. For Q  X  ,Q  X  X   X  L ( Q ) we have Q  X  X   X  b Q  X  if and Proof. Based on our assumptions and the definition of L ( Q ), the SELECT and FROM clauses of Q  X  X  and Q  X  are identi-cal. Hence, containment Q  X  X   X  b Q  X  reduces to the problem whether every tuple that satisfies  X  Q  X  X  also satisfies  X  That is, whether  X  Q  X  X   X   X  Q  X  holds.
 For an L ( Q )-exemplar of Q we include some tuple t 0 that satisfies the equalities of Q , but does not satisfy any condi-tion not entailed by Q . That way the tuple t 0 separates Q from any query Q  X  that is not a container of Q .
Definition 3. For a conjunctive SQL query Q the tuple t over R ( A 1 ,...,A n ) represents  X   X  X  ( Q ) if and only if for all  X   X  X  ( Q ) , | = t  X  iff  X   X   X  holds.

Th e existence of some tuple that represents some given  X   X  X  ( Q ) is guaranteed: Attributes, that must carry match-ing values different from any constant of Q , are simply given the same unique value. For this reason, if  X   X   X  does not hold, then the tuple t that represents  X  can always be chosen such that | = t  X  does not hold.
 Example 4. For D with C(cid,cname) , P(pid,pname) , B(cid,pid,date,cost) and
R(c.cid,c.cname,p.pid,p.pname,b.cid,b.pid,b.date,b.cost), t =(c7,Jimmy,p1,printer,c7,p1,3/9/2014,79) represents  X  Q from Example 2, but it does not represent c.cid=b.cid  X  c.cid=`c7'  X  b.date=`3/9/14' . Indeed, t 0 also satisfies the equality b.pid=p.pid which is not implied by c.cid=b.cid  X  c.cid=`c7'  X  b.date=`3/9/14' .

Representative tuples resemble Armstrong databases [4, 6, 14]: for some tuple t that represents  X  , deciding if  X  implies  X  reduces to deciding whether t satisfies  X  .

We say the tuple t represents Q  X   X  L ( Q ) if and only if t represents  X  Q  X   X  F ( Q ). Any tuple t 0 representing Q will also be selected by any proper container of Q . Thus, ad-ditional tuples are required to separate Q from any of its proper containers. Evidently, it suffices to insert tuples that represent the minimal proper containers of Q . We now construct exemplars from the tuples that represent the target query and its minimal proper containers.
Definition 4. For a conjunctive query Q without self-joins let M ( Q ) = { Q 1 ,...,Q p } . Let t 0 be a tuple that rep-resents Q , and for j = 1 ,...,p , let t j denote a tuple that represents Q j , such that the only values that occur in more than one tuple among t 0 ,...,t j are constants from C Q . For i = 1 ,...,k , let r i =  X  b R db Q := { r 1 ,...,r k } a canonical L ( Q ) -exemplar for Q .
The following lemma establishes an important property of our canonical exemplar. We will use this property to show that a canonical exemplar is indeed an exemplar.

Lemma 4. Let db Q = { r 1 ,...,r k } denote a canonical L exemplar for Q . For all t  X   X  k i =1 r i , if | = t  X  Q Q  X   X  X  ( Q ) , then Q  X 
Proof. By definition of t 0 ,t 1 ,...,t p , for all A i ,A if t  X  ( A then t 0 ( A i ) = c . Recall that the only values that occur in more than one tuple amongst t 0 ,t 1 ,...,t p are the constants from C Q . It follows that the cross product of r 1 ,...,r not result in tuples that have equalities of attribute values that are not already present in t 0 . That is, for each tuple t t ( A i ) = t 0 ( A j ), and ii) if t ( A i ) = c  X  C Q , then t t represents  X  Q , it follows by Definition 3 that  X  Q  X   X  Q holds. This means that Q  X  b Q  X  by Lemma 3.

Theorem 5. Let Q be a conjunctive SQL query without self-joins. For all Q  X   X  L ( Q ) , Q  X  b Q  X  if and only if Q ( db Q ) = Q  X  ( db Q ) .

Proof. It follows from the definition of  X  b that Q  X  b Q entails Q ( db Q ) = Q  X  ( db Q ).

Assume now that Q  X  X  b Q  X  . That is, either 1) Q  X  X  b Q  X  2) Q ( b Q  X  . Case 1) means that  X  Q  X   X  Q  X  does not hold, by Lemma 3. As t 0  X  r 1  X  ...  X  r k represents Q it follows by Definition 3 that | = t 0  X  Q . Lemma 4 shows that for all t  X  r 1  X  ...  X  r k ,  X | = t  X  Case 2) means that there is some Q i  X  M ( Q ) such that Q Q t  X  r 1  X  ...  X  r k represents Q i it follows by Definition 3 that | =  X  { t  X  r 1  X  X  X  X  X  r k || = t  X  Q } ( b { t  X  r 1  X  X  X  X  X  r k || Consequently, Q ( db Q )  X  = Q  X  ( db Q ) by Lemma 2.
Cor ollary 6. For a conjunctive SQL query Q without self-joins, every canonical L ( Q ) -exemplar for Q is an exemplar for Q .
The construction of a canonical exemplar is founded on tuples that represent the target query Q and its minimal proper containers. Each query Q  X   X  X  ( Q ) partitions the set of terms T Q of Q into equivalence classes, induced by the equalities in the WHERE clause of Q  X  . Formally, for  X , X  we define  X   X  Q  X   X   X  if and only if  X  Q  X   X   X  =  X   X  . Evidently,  X  Let [  X  ]  X  Q  X  denote the equivalence class of  X   X  T Q , i.e., T Algorithm 1 shows the overall construction of a canonical L ( Q )-exemplar for Q . Line 1 computes the quotient S  X  Q the input query Q . Starting with the partition of singleton subsets of T Q the elements of the partition are merged as the equalities in the WHERE clause are scanned one by one.
Lines 2-9 compute the set M ( Q ) of minimal proper con-tainers for Q , represented by their quotients S  X  Q S
Q i is derived from S  X  Q by replacing one element S by an element s from one of its bi-partitions S  X  , i.e., a par-tition into two non-empty subsets. All-Bi-Partitions ( S ) returns the set of all bi-partitions of a set S [17].
Lines 10-12 compute tuples that represent Q and its min-imal proper containers Q 1 ,...,Q p . The only values that oc-cur in more than one representative tuple are the constants from Q . A representative tuple can easily be constructed from a quotient S  X  Q  X  : Two attributes A r and A s receive the same value iff they belong to the same equivalence class. This value must equal the constant if the constant is also an element of the same equivalence class. An equivalence class the algorithm will terminate in this case and return nothing.
Lines 13-15 compute a canonical L ( Q )-exemplar db Q as projections r 1 ,...,r k of db = { t 0 ,...,t p } to the participat-ing relation schemata R i ( A i 1 ,...,A i n i ) for i = 1 ,...,k . Al gorithm 1 Computation of Canonical Exemplar Re quire: Conjunctive SQL Query Q without Self-Joins Ensure: L ( Q )-canonical exemplar for Q 2: M ( Q )  X  X  X  3: for all S  X  S  X  Q do 4: S  X   X  All-Bi-Partitions ( S ) 5: for all s  X  S  X  do 6: M ( Q )  X  X  ( Q )  X  X  ( S  X  Q  X  X  S } )  X  X  s }} 7: end for 8: end for 9: M ( Q ) = { S  X  Q 10: for i = 0 ,...,p do t i  X  Representative ( S  X  Q 11: end for 12: db  X  X  t 0 ,t 1 ,...,t p } 13: for i = 1 ,...,k do r i  X   X  R 14: end for 15: db Q  X  X  r 1 ,...,r k } 16: Return ( db Q )
The complexity of Algorithm 1 is dominated by the com-putation of all bi-partitions for each element of Q  X  X  quo-tient. The number of partitions of an n -element set into k non-empty subsets is the Stirling number of the second kind , denoted by S ( n,k ). Here, the relevant case is k = 2 where S ( n, 2) = 2 n  X  1  X  1 and the maximum number of minimal proper containers is attained when S  X  Q = { T Q } . The com-putation of the bi-partitions only starts when T Q contains at T able 1: Maximum size s n of exemplar, number q n of non-equivalent queries the exemplar can separate, and the growth q n /s n for the number n = 5 ,..., 15 most one constant. Using our notation R ( A 1 ,...,A n ), T contains at most n + 1 elements and there can be at most 2 n  X  1 minimal proper containers and 2 n representative tu-ples. As query equivalence under set semantics is known to be NP-complete, it is elusive to find a PTIME -algorithm.
Proposition 7. For each conjunctive SQL query Q that has a total of n attributes in the relation schemata that occur in its FROM clause, Algorithm 1 returns a canonical L ( Q ) -exemplar for Q in time and space that is in O (2 n ) .
Let Q b e a conjunctive SQL query with a total number n of attributes and a total number k of constants. Then the number of queries an L ( Q )-exemplar can separate from Q is the m = n + k -th Bell number B m , which counts the number of partitions of an m -element set. As can be observed from Table 1 the number of pairwise non-equivalent queries that an exemplar can separate from Q is at least exponential in the size of the exemplar. For example, for n = 14 and k = 1 the maximum-sized canonical L ( Q )-exemplar has 16 , 384 tu-ples and can separate B 15 = 1 , 382 , 958 , 545 queries from Q , all pairwise non-equivalent. That is, the L ( Q )-exemplar can distinguish more than 84 , 000 times as many semantically different queries as its own size.

Proposition 8. Algorithm 1 returns L ( Q ) -exemplars db Q that can separate a number of pairwise non-equivalent queries from Q that grows at least exponentially in the size of db
This section illustrates the use of Leqcter in its primary application area as an automated lector. The case shows how Lecqter exploits its ability to test query equivalence in assisting trainees in the process of learning how to write sound conjunctive SQL queries, and in assisting trainers to provide automated feedback and marks from which trainees can confidently learn. As show case we consider the schema D and target query Q from Example 1.

Once Lecqter has created an L ( Q )-exemplar in MySQL based on the target query Q and database schema D , trainees submit WHERE clauses that shall match the description of Q . Trainee A does not specify the equality b.pid = p.pid . Re-sults of A X  X  query are shown in the bottom right with tuples not in Q being highlighted in red, as shown in Figure 1. In Figure 2 trainee B submits the WHERE clause b.pid=`c7' AND c.cid=`c7' AND b.pid=c.cid AND b.date=`3/9/14' .
As the answers match the target, trainer and trainee do not need to inspect the trainee X  X  query to conclude its cor-rectness. This is not the case for queries evaluated on any database, but the distinguishing feature of Lecqter . Lecqter is available at https://mega.co.nz/#!uJ0mgLoa! AM0ZsCSieaK9GQSi9ZpOhqrxeC3sumrXc11hV19yO00 for down-load. It can be run on Windows 7, and access to a MySQL server can easily be configured.
The worst-case complexity of constructing canonical L ( Q )-exemplars is exponential in the total number of participating attributes. We will now establish empirical evidence that L ( Q )-exemplars can be generated efficiently for the purpose of learning how to write sound conjunctive SQL queries. Note that we do not include experiments that confirm the efficiency of relational database systems in evaluating con-junctive queries. Of course, SQL systems excel at this task on much larger data sets than ours. In conclusion, exemplars are a practical tool for learning how to write sound conjunc-tive SQL queries, as they can be generated efficiently and are able to efficiently separate at least an exponential number of non-equivalent queries from the target query. Fi gure 3: Exemplar Sizes for Random, k = 0 . 25
Exp eriments were carried out on a MySQL 5.6 database server running on an Asus laptop, with 2.5 GHz i5-2450M Dual-Core processor, 4GB RAM and Windows 7 operating system. We analyzed four different classes of queries re-garding their performance in constructing canonical L ( Q )-exemplars with Algorithm 1. For three of the four classes, their performance is predictable, and their analysis is just described in brief due to lack of space. The class Con-stant had target queries Q c n of the format SELECT  X  FROM R WHERE A 1 = 0; with R ( A 1 ,...,A n ) being the only rela-tion schema. For each n = 1 ,..., 50 considered, there is one tuple that represents Q c n and one tuple that represents the only minimal proper container of Q c n . Therefore, the size of the resulting exemplar is constant for all n , and the construction times averaged 8ms. The class Linear had target queries Q l n of the format SELECT  X  FROM R 1 ,...,R WHERE R 1 .A 1 = R 2 .A 1 AND R 2 .A 2 = R 3 .A 2 AND  X  X  X  R  X  1 .A s = R n .A s ; where s = 1 when n is even, and s = 2 when n is odd, and R 1 ( A 1 ,A 2 ) ,...,R n ( A 1 ,A 2 ) form the underlying database schema. For this experiment, n also varied from 1 up to 50. For each n , there is one tuple that represents Q l n and one tuple that represents each of the n minimal proper containers of Q l n . Therefore, the size of the resulting exemplar is n , and the average times to construct a canonical exemplar for Q l n grew linearly up to 3.5s for n = 50. Average times were taken over 100 runs for each n . The class Exponential had target queries Q e n of the for-mat SELECT  X  FROM R WHERE A 1 = A 2 AND A 2 = A 3 AND  X  X  X  AND A n  X  1 = A n ; with R ( A 1 ,...,A n ) being the only rela-tion schema. For this experiment, n varied from 2 up to 15 due to memory limits. For each n , there are one tuple that represents Q e n and for each of the 2 n  X  1  X  1 minimal proper containers of Q e n one representative tuple. Therefore, the size of the resulting exemplar is 2 n  X  1 , and the maximum time to construct a canonical exemplar for Q e 15 was 22.17s.
We now direct our focus to the class Random of tar-get queries Q r n with format SELECT  X  FROM R WHERE ...; Figure 5: Exemplar Sizes for Random, k = 0 . 75 wit h R ( A 1 ,...,A n ) being the only relation schema, and the equalities in the WHERE clause are created randomly. For this experiment, n varied from 3 up to 15 due to memory limits. Minimum, average and maximum times were taken over 1,000 runs for each n . For each n , the algorithm ran-domly selects in each run the number of equalities that will form the WHERE clause. Four different experiments were con-ducted, where the maximum number of equalities to be ran-domly selected in each run for each n had an upper bound of the exemplars are shown in Figures 3, 4, 5, and 6, respec-tively. The figures confirm convincingly our intuition that the number of equalities selected is proportional to the size of the canonical exemplars constructed, and therefore also the time required to construct them.

Figure 6 for k = 1, in particular, illustrates a significant difference between the average and maximum sizes of ex-emplars when equalities are selected randomly. While the maximum size of exemplars for Q r n coincides with the size of the exemplars for Q e n , the average size is significantly smaller. Note that the minimum sizes for Q r n are zero, in-dicating that the number of runs and number of equalities are sufficient to generate at least one inconsistent input.
Figure 7 shows the minimum, average and maximum times taken for each n to create a canonical L ( Q )-exemplar given Q n . The figure illustrates the significant difference between the average and maximum times required to construct canon-ical exemplars when equalities are selected randomly.
For instance, the average and maximum sizes of the canon-ical exemplars for Q r 15 are listed in Table 2, together with the average and maximum times to construct them. The tables illustrate the impact of the maximum number of equalities permitted, and the significant differences in size and time between the average and maximum cases.

So far, all experiments in the class Random were con-ducted with a fair chance p = 0 . 5 of selecting an attribute-attribute equality and attribute-constant equality, respec-Fi gure 7: Construction Times for Random, k = 1 T able 2: Average and maximum sizes of canonical exemplars and times in ms to construct them for Q 15 and k = 0 . 25 , 0 . 5 , 0 . 75 , 1 ti vely. Intuitively, the higher the probability of selecting attribute-attribute equalities, the larger the size of an ex-emplar will be. Attribute-constant equalities may force dif-ferent constants to be the same, in which case the input is inconsistent and the size and time measured are both zero. Several attribute-attribute equalities increase the chance of a large equivalence class, resulting in larger exemplars. We have confirmed this intuition by running two further exper-iments in the class Random where the probability p of se-lecting an attribute-attribute equality was 0.25 and 0.75, respectively. Each experiment was repeated 1,000 times for each input size n . For each n , a constant could be chosen between 1 and n . While this margin may be relatively small, the outcomes already confirm the intuition above, thereby suggesting a stronger trend with bigger margins. Figures 8 and 9 show the sizes of exemplars for p = 0 . 25 and p = 0 . 75, respectively. Figure 6 shows the sizes for p = 0 . 5.
Average and maximum sizes of the canonical exemplars for Q r 15 with k = 1 and p  X  { 0 . 25 , 0 . 5 , 0 . 75 } Table 3. The table confirms that the higher the probability of selecting attribute-attribute equalities the larger the ex-emplars become. Table 3 also shows that the maximum size was not attained in any of the 1,000 runs with p = 0 . 25.
Section 2.4 has illustrated that exemplars do not always exist for conjunctive queries under set semantics [16]. Our results have shown that for conjunctive queries under bag semantics, exemplars can be constructed efficiently in prac-tice. Nevertheless, one may wonder how to handle the case where trainees are exposed to SELECT DISTINCT queries. In this section, one possible approach is outlined.

We denote by Q d the query obtained from the conjunc-tive SQL query Q by adding DISTINCT to its SELECT clause. What Section 2.4 has shown is that there are conjunctive target queries Q d for which no database can exist on which Figure 8: Exemplar Sizes for Random, k = 1 , p = 0 . 25 Fi gure 9: Exemplar Sizes for Random, k = 1 , p = 0 . 75 al l queries in L ( Q d ), that are not equivalent to Q d answers that are different from those of Q d . We suggest in this case to construct for each Q  X  d  X  X  ( Q d ) a demo database equivalence of Q d and Q  X  d by producing the same answers on on demo Q  X  constructing for each Q  X  d  X  L ( Q d ), a demo database that illustrates the (non-)equivalence between Q d and Q  X  d .
For Q d we construct an L ( Q )-exemplar db Q = { r 1 ,...,r for the conjunctive SQL query Q as before. For an ar-bitrary query Q  X  d  X  L ( Q d ) we first evaluate Q  X  ( db Q ( db Q ) = Q ( db Q ), then demo Q  X  obtained from projecting t 0 down to each of the participat-ing relation schemata. In that case, both Q  X  d ( demo Q  X  Q ( demo Q  X  guish the following two cases. The first case is where t 0 in  X   X  Q  X  ( r 1  X  X  X  X  X  r k ). Then demo Q  X  obtained from projecting t 0 down to each of the participat-ing relation schemata. In that case, Q  X  d ( demo Q  X  the empty answer and Q d ( demo Q  X  The second and remaining case is where there is some t i  X   X  minimal proper container Q i  X  X  ( Q ). In that case, demo consists of the relations obtained from projecting t i down to each of the participating relation schemata. Consequently, Q ( demo Q  X  the empty set. We thus obtain the following result that of-fers a solution to the class of conjunctive queries without self-joins under set semantics.

Theorem 9. For every conjunctive query Q without self-joins and every conjunctive query Q  X   X  X  ( Q ) , Q  X  Q  X  if and only if Q ( demo Q  X  ) = Q  X  ( demo Q  X  ) . T able 3: Average and maximum sizes of canonical exemplars for Q r 15 with k = 1 and different probabil-ities p on attribute-attribute equalities
We show that our construction is special in the sense that it cannot always produce exemplars when slightly more ex-pressive user queries are permitted. Suppose our target query Q selects the name of patients with pid=`1' . Q: Q1: SELECT name SELECT name FROM PATIENT FROM PATIENT WHERE pid=`1'; WHERE pid=`1' OR pid=name; Our canonical exemplar db Q for Q would consist of two tu-ples, say (Smith,1) and (Jones,2). If disjunctions were per-mitted in user queries, or equivalently unions of conjunctive queries, then the non-equivalent query Q1 would return the same answer as Q on the exemplar. Similarly, when arbitrary constants are permitted, Q would return the same result on db
Q as Q2 , and when inequalities are permitted, Q would return the same result on db Q as Q3 .
 Q2: Q3: SELECT name SELECT name FROM PATIENT FROM PATIENT WHERE name=`Smith'; WHERE pid=`1' AND pid&lt;&gt;name; The examples encourage future research on this topic.
This article investigated the concept of exemplars for con-junctive queries without self-joins. An L ( Q )-exemplar db for target query Q reduces the query equivalence problem for Q and any user query Q  X   X  L ( Q ) to a simple evalua-tion of Q and Q  X  on db Q . A construction of exemplars was given for bag semantics, the default semantics in SQL. In sharp contrast, L ( Q )-exemplars do not always exist under set semantics. For set semantics the new concept of a demo database shows how to use L ( Q )-exemplars to generate for each query Q  X   X  X  ( Q ) a database demo Q  X  of singleton rela-tions such that Q and Q  X  have matching answers on demo Q if and only if they are equivalent. We have implemented our exemplar construction as the GUI Lecqter . As the distin-guishing feature, users of Lecqter are assured of the seman-tic soundness of their queries whenever their answers match those of the target. A detailed performance analysis was carried out. The number of non-equivalent queries an exem-plar can separate is exponential in its size. This justifies the worst-case time and space complexity which is exponential in the number of participating attributes. The worst cases are unlikely to occur, but the time for their construction is very much feasible. In summary, the bag semantics of SQL enables Lecqter to overcome the poor quality of feedback for users of state-of-the-art tutoring systems, in the case of conjunctive queries for now. The fact that exemplars always exist under bag but not under set semantics may be viewed as a justification for the challenges that conjunctive query containment and equivalence under bag semantics present.
The most prominent open problem is to identify the exact complexity of deciding the containment problem for conjunc-tive queries under bag semantics, which has remained open for the last twenty years [3, 7, 8, 11, 12]. It would be inter-esting to study the time complexity of deciding whether a given database is an exemplar for a given conjunctive query under bag semantics. It would also be valuable to increase the expressivity of the query language for which exemplars do exist, and to extend our techniques for their construc-tion. Another challenge is to investigate these problems in the context of database constraints that put restrictions on the patterns that can occur in databases [9].
 This research was supported by the New Zealand-Germany Science &amp; Technology Programme, administered by the Royal Society of New Zealand and by BMBF under grant number FKZ 01DR12098.
