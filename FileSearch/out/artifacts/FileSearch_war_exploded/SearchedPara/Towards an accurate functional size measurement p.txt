 1. Introduction
The MDA [50,51] approach separates application and business logic from the platform technology, allowing code gener-ation by means of model transformations. In such MDA contexts, the software production processes are based on conceptual models that are used as inputs to the code generation process. These conceptual models must have the required semantic formalization to specify all the functionality of the generated application and to avoid different interpretations for the same model. The adoption of MDA-based technology has presented new challenges, such as the capability of measuring the size of the products generated in the early phases of the software development.

The Functional Size is defined as the size of the software that is derived by quantifying the functional user requirements [32]. The functional size measurement (FSM) was defined in the late 1970 X  X  mainly through the Function Point Analysis (FPA) proposal [9]; later, FPA was adapted to object-oriented models aligned with the UML standard [41,61 X 63] . However, these FPA-based approaches present limitations for the measurement of the functional size of conceptual models in MDA environments.
Even though we found approaches that measure the functional size in MDA environments in the literature [4,1], these ap-proaches are also FPA-based and have limitations, too. One such limitation is that FPA approaches only allow the measurement cation (which must be built by the developer, even though it is not seen by the human user). Another significant limitation is that the size of any elementary process (an elementary unit of functional user requirements [32]) within a model is limited to only three intervals of classifications for DET (Data Element Types), RET (Record Element Types) or FTR (File Types Referenced). fore, the functional size of a model will not vary even if some elementary processes have a very large number of DET, RET or FTR [21,39,40] .

To overcome the limitations of the initial design of the FPA measurement method, the COSMIC measurement method [7] was defined in the late 1990s as the second generation of the functional size measurement method. It has been adopted as an international standard: ISO 19761 [34]. One of the advantages of COSMIC over FPA is that it allows the measurement of the functional size from different points of view, for instance, the functionality that the users see and the functionality that the developer has to build. Another advantage is that COSMIC uses a mathematical function that is not limited by maximum values to measure the size of conceptual models. This mathematical function aggregates the functional size of the functional processes (an elementary unit of functional user requirements [5]) that are specified in the conceptual models. This helps to better distinguish the size of large conceptual models. Another advantage of COSMIC is that it allows the measurement of applications that are generated in layers, which permits the measurement of the whole application or the measurement of each layer of the application.

Currently, there are some approaches that apply COSMIC for the purpose of estimating the functional size of future soft-ware applications from high-level specifications [36,23] . As the functionality to be measured using these proposals is not sufficiently detailed to generate the final application automatically in MDA environments, some FSM procedures have been designed to measure the functional size of the application from its conceptual models, such as Diab X  X  proposal [16] and Poels X  proposal [57]. Both FSM procedures were defined by establishing a mapping between the COSMIC concepts and the prim-itives of the Real-Time Object Oriented Modeling (ROOM) specification [59] or the primitives of the MERODE conceptual models [15], respectively. The Diab and Poels proposals are based on conceptual models that allow the generation of the applications, but that do not allow the generation of fully working applications from these conceptual models. This generates a traceability problem between the generated application and the conceptual model. Moreover, the conceptual models of these proposals do not have enough expressiveness for the total specification of the application in an abstract way. Therefore, these procedures do not allow the accurate 2 [30] measure of the functional size of the applications generated from the con-ceptual models.

To avoid this problem, we have selected the OO-Method approach [54]. This approach is an object-oriented method that is based on model transformations. It provides the semantic formalization needed to define complete and unambiguous con-ceptual models, allowing the automatic generation of software products using an MDA-based technology. Although presen-tation and interaction modeling is accepted to constitute an essential part of any software development method, it is remarkable that most of the current model-based approaches do not include an explicit presentation model. OO-Method does this, and, consequently, a complete view of the software product to be built from the model is provided at the concep-tual level. This method has been implemented in a suite of industrial tools by the company CARE Technologies [13] (a soft-ware development company). Currently, CARE Technologies has a procedure to measure the functional size of conceptual models [4], but this procedure is limited to the IFPUG FPA with the limitations explained above.

In general, the Functional Size of applications is used to successfully apply prediction models [4,63] , such as effort and budget models. In an MDA context, the effort of programming the applications is substituted by a modeling effort. Thus, in this context, dealing with the cost of the applications should mean dealing with how to measure cost from the involved models. Therefore, it is very important to know the accurate functional size of the conceptual models that are built with these MDA-based approaches since this functional size is necessary to adjust the budget in order to estimate the cost of the software product that is generated automatically.

In addition, since the functional size measurement is independent of the technological platform, it allows the generation of indicators in early stages of the software development cycle. Thus, knowing the accurate functional size of software from the conceptual models is critical for evaluating risks and for obtaining early project indicators (such as productivity). More-over, given that a functional size measurement procedure analyzes all the elements of the conceptual model that fulfil the functional user requirements, the measurement procedure can be used as a very valuable tool to identify defects in the con-ceptual models.

The contribution of this work is the systematic design and application of an FSM procedure that measures the accurate size of the generated applications from their conceptual models. Thus, this paper presents the OOmCFP proposal, which is a procedure based on COSMIC to measure the functional size of the OO-Method applications from their conceptual models.
The holistic view of the OO-Method conceptual model (including the structure of the system, the behavior, the interaction between the users and the system, and the interaction among the components of the system) allows OOmCFP to take into account all the functionality of the generated applications, including the functionality related to the presentation features that other measurement procedures do not consider. Therefore, we infer that OOmCFP contributes substantially to improv-ing the measurement of applications generated from conceptual models.

The rest of the paper is organized as follows: Section 2 presents the main concepts of the COSMIC measurement method, the related work, the OO-Method approach, and a process model for software measurement. Section 3 presents the design of the OOmCFP procedure, and Section 4 presents the application of OOmCFP. Finally, Section 5 presents an analysis on the re-sults achieved, and Section 6 presents some conclusions and suggestions for further work. 2. Background and related work
Since the objective of this paper is to present a measurement procedure based on the COSMIC measurement method, in the following sub-sections, we present the COSMIC measurement method, the related work, a brief explanation of the OO-
Method approach, and a process model for software measurement. 2.1. The COSMIC measurement method
In 1997, St-Pierre et al. [60] defined the Full Function Points (FFP) method for the measurement of control systems, real-time systems, and embedded systems. This measurement procedure obtains the functional size of an application by means of the identification of functional processes and data movements that occur in these processes. The data movements are: Entry to the functional process, Exit from the functional process, Read the database, and Write the database. When all the data movements have been identified, they are aggregated to obtain the functional size of each functional process. Later, in 1999 the Common Software Measurement International Consortium (COSMIC) published the 2.0 version of the
COSMIC-FFP measurement method [6]. Since some modifications were performed to the 2.0 version of COSMIC-FFP, the 2.1 version was published in 2001 [7] and the 2.2 version was published in 2003 [8]. This version was recognized as the ISO/IEC 19761 standard [34]. In 2007, a new version of COSMIC was published [5]. This last version aggregates a phase for the def-inition of the measurement strategy. Thus, the application of the last version of the COSMIC measurement method [5] in-cludes three phases: the strategy phase, the mapping phase, and the measurement phase (see Fig. 1 ).

In the strategy phase , the purpose of the measurement exercise must be defined to explain why it is necessary to measure and what the measurement result will be used for. Next, the scope of the measurement must be defined in order to select the set of user functional requirements that will be included in the measurement task. Then, the functional users of the appli-cation to be measured must be identified. The functional users are the types of users that send (or receive) data to (from) the functional processes of a piece of software. This phase also includes the identification of the boundary, which is a conceptual interface between the functional user and the piece of software that will be measured. Finally, the level of granularity of the description of a piece of software to be measured is identified.

In the mapping phase , the functional processes must be identified (i.e., the elementary components of a set of functional user requirements). Every functional process is triggered by a data movement from the functional user, and the functional process is completed when it has executed all the data movements required for the triggering event. It should be kept in mind that a triggering event is an event that causes a functional user of the piece of software to initiate one or more func-tional processes. Next, the data groups must be identified. This is a set of data attributes that are distinct, non-empty, non-ordered, non-redundant, and that participate in a functional process. Finally, the identification of the data attributes, which comprise the smallest part of information of a data group, is optional.

In the measurement phase , the data movements (Entry, Exit, Read and Write) for every functional process must be iden-tified. When all the data movements of the functional process are identified, the measurement function for the functional process must be applied. This is a mathematical function that assigns 1 CFP (COSMIC Function Point) to each data movement of the functional process. Then, after all the functional processes are measured, the measurement results are aggregated to obtain the functional size of the piece of software that has been measured. 2.2. Related work
Many functional size measurement procedures have been developed for applying the COSMIC measurement method to particular methods of software production.

The proposals of B X vo et al. [12], Jenner [36], Azzouz and Abran [10], Habela et al. [24], and Levesque et al. [42] allow the measurement of the functional size of Management Information Systems (MIS) using UML models. As is well known, the
UML models do not allow the specification of all the functionality of the final application and can also have consistency and ambiguity problems [11,19,53] .
 The proposals of Condori-Fern X ndez et al. [14] and Grau and Franch [23] allow the measurement of the functional size of
MIS using requirements models. Both proposals have been defined systematically. However, the requirements models do not have enough expressiveness to specify all the functionality of the final application.

The proposals of Diab et al. [16] and Nagano and Ajisaka [48] allow the measurement of the functional size of real-time applications. Diab X  X  proposal measures the functional size of ROOM specifications that are used by the Rational Rose Real
Time (RRRT) tool for the design and specification of real-time systems. In Nagano X  X  proposal, the measurement of the func-tional size is performed in real-time applications that are specified using xUML [45]. These proposals do not allow the spec-ification of the presentation of the applications in an abstract way, so the functional size obtained does not accurately represent the functional size of the final applications. In addition, both proposals are defined for the real-time systems do-main, which is a different domain application with respect to the MIS domain on which we focus.

The proposal of Poels [57,58] allows the measurement of the functional size of MIS that has been specified using MERODE conceptual models. This proposal does not use conceptual models with enough expressiveness to specify all the functionality of the final application in the conceptual model since the MERODE models do not allow the specification of the presentation of the final application at a conceptual level [46]. In addition, the applications generated from MERODE models are restricted to a specific platform technology because MERODE uses the AndroMDA tool to specify the presentation of the application and to generate the final application in Java code. Therefore, the functional size obtained by the Poels proposal does not rep-resent the accurate functional size of the generated applications.

In summary, none of the proposals for measurement procedures based on COSMIC allows the accurate measurement of the functional size of MIS applications in the conceptual model. Moreover, none of them take into account the newer version 3.0 of COSMIC [5]. The main limitation of the approaches presented above comes from the lack of expressiveness of the con-ceptual model. For this reason, we have selected the OO-Method approach, which is presented in the following section. 2.3. The OO-Method approach: a development method
OO-Method is an object-oriented method that allows the automatic generation of software from conceptual models. To do that, the OO-Method approach uses a graphical language based on UML and a formal language named OASIS [55]. This method is supported by the compiler of OO-Method conceptual models, which is implemented in the OlivaNova Suite [13].
The OO-Method model compiler generates applications according to a three-tier software architecture: one tier for the client component, which contains the graphical interface; one tier for the server component, which contains the business rules and the connections to the database; and one tier for the database component, which contains the persistence aspects of the applications.
 The software production process in OO-Method is represented by three models: The Requirements Model [17,29] , which specifies the system requirements using a set of techniques such as the Mission Statement, the Functions Refinement Tree, the Use Case Model, and the Sequence Diagram Model.

The Conceptual Model, which captures the static and dynamic properties of the functional requirements of the system by means of an Object Model, a Dynamic Model, and a Functional Model. The conceptual model also allows the specification of the user interfaces in an abstract way through the Presentation Model. With all of these models, the conceptual model has all the details needed for the generation of software applications that correspond to the OO-Method domain (MIS applications). The complete definition of the elements of the conceptual model of OO-Method is described in detail in [56].
The Execution Model [22], which allows the transition from the problem space (represented by the conceptual model) to the solution space (the corresponding software product). This model fixes the mappings between conceptual primitives and their corresponding software representations in a target software development environment.

The standard IEEE 830 [26] describes a set of characteristics that must be taken into account for a good specification of the software (i.e., unambiguous, complete, verifiable, consistent, modifiable, traceable, and usable during the development and maintenance phase). Given that the OO-Method conceptual model allows the generation of fully working applications through model transformations of a MDA-based technology, we can infer that the OO-Method conceptual model is a good specification for the OO-Method applications because it achieves the characteristics of the standard IEEE 830. For example, the generated application is traceable from the conceptual model; the conceptual model is consistent because the same cri-teria are always used to generate the applications from the OO-Method conceptual model; the conceptual model is not ambiguous because the OO-Method conceptual model has a formal language for the specification of the constraints of the system; and the conceptual model is editable because it is supported by a tool that permits changes in the model. Thus, since the OO-Method conceptual model is a good specification for the OO-Method applications according to the standard IEEE 830, it facilitates: the measurement of functional size in early stages of the software development; the accuracy of the measure-ment results; the re-generation of the application; and the automated re-measurement of the functional size when a mea-surement feature is available.

In this work, we need only focus on the Conceptual Model, which has the artifacts that are required to measure the func-tional size through the corresponding measurement process. For a better understanding of the OOmCFP measurement pro-cedure, the models that compose the OO-Method Conceptual Model are briefly described. 2.3.1. The OO-Method object model
This model describes the static part of the system. The object model allows the specification of classes, attributes, derived attributes, events, transactions, operations, preconditions, integrity constraints, agents, and relationships between classes.
The main concepts of the object model are well known because they are the same as those used in the UML class diagram [52]. However, these concepts are briefly explained in the following paragraphs.

The main conceptual primitive of the object model is the class. A class describes a set of objects that share the same specifications of characteristics, constraints, and semantics. A class can have attributes, services, integrity con-straints and relationships with other classes. The attributes of a class represents characteristics of this class. The attri-butes of a class can also be derived attributes, which obtain their value from the values of other attributes or constants. The integrity constraints are expressions of a semantic condition that must be preserved in every valid state of an object.

The services of a class are basic components that are associated with the specification of the behavior of a class. The ser-vices can be events, transactions or operations. The events are indivisible atomic services, which can assign a value to an attribute. The transactions are a sequence of events or other transactions that have two ways to end the execution: either all involved services are correctly executed, or none of the services are executed. Finally, the operations are a sequence of events, transitions or other operations, which are executed sequentially independently of whether or not the involved ser-vices have been executed correctly. The services can have preconditions that limit their execution because the preconditions are conditions that must be true for the execution of a service.

The agents are active classes that can access specific attributes of the classes of the model and can execute specific ser-vices of the classes of the model. Finally, the relationships between classes can be the following: agent (that represent which object can activate which services); association; aggregation; composition; and specialization. 2.3.2. The OO-Method dynamic model
The OO-Method dynamic model is comprised of two diagrams: the state transition diagram and the object interaction diagram. The state transition diagram defines the valid lives of the objects that belong to a class. This diagram has the fol-lowing conceptual constructs: initial state, final state, intermediate states, and transitions. Most of the concepts of this dia-gram are the same as those used in the UML state transition diagram [52]. Nevertheless, these concepts are briefly explained in the following paragraph.

The initial state represents the state that objects are in immediately before they are created. The final state represents the state that objects are in immediately after they are destroyed. And, the intermediate states represent different situations that an object of a class may find itself in at any point during its life. The intermediate states have incoming and outgoing tran-sitions, which represent a change of the state of an object. The transitions are activated by an agent that executes a service and can also have a condition to execute the service when it is required.

The object interaction diagram defines the interactions among the objects of the system. To do this, the triggers of the classes of the system and the global transactions or operations of the system are defined. The triggers are defined in a specific class. Each trigger is composed by a trigger condition and a service to be executed after a successful exe-cution of a service that activates the trigger. The triggers can be executed for: (1) the same object that has been used to activate the trigger, (2) a particular object of the class, (3) several objects of the class, or (4) all the objects of the class. Each trigger service is executed in the background and is hidden from the user, who does not know the result of the execution (either success or failure).
 The global transactions and operations are sequences of services, like the transactions and operations of the object model.
The global services can involve services of any class of the system. Usually, these services are defined when it is necessary to execute services of objects that are not related. 2.3.3. The OO-Method functional model
The functional model of the OO-Method approach allows the specification of the effects that the execution of an event has over the value of the attributes of the class that owns the event. The functional model uses valuations to assign values to the corresponding attributes. The valuations can have preconditions. These preconditions and the effect of the valuation must be specified by means of well-formed, first-order logic formulas that are defined using the OASIS language.

The change that a valuation produces in the value of an attribute is classified into three different categories: state, car-dinal, and situation. The state category implies that the change of the value of an attribute depends only on the effect spec-ified in the valuation for the event, and it does not depend on the value in the previous state. The cardinal category increases, decreases, or initializes the numeric-type attributes. The situation category implies that the valuation effect is applied only if the value of the attribute is equal to a predefined value specified as the current value of the attribute. 2.3.4. The OO-Method presentation model
In order to specify the interaction between the users of an application and the system, the OO-Method approach allows the specification of views in the object model. A view corresponds to a set of interfaces, which are the communication point between agents and classes of the OO-Method object model. When the views of a system have been defined, the presentation model of each view must be specified.
 The presentation model allows the specification of the graphical user interface of an application in an abstract way [47].
To do this, the presentation model has a set of abstract presentation patterns that are organized hierarchically in three levels: access structure, interaction units, and auxiliary patterns. The first level allows the specification of the system access struc-archy action tree (HAT).

Based on the menu-like view provided by the first level, the second level allows the specification of the interaction units of the system. The interaction units are groups of functionality that allow the users of the application to interact with the system. Thus, the interaction units of the presentation model represent entry-points for the application, and they can be:
A Service Interaction Unit (SIU). This interaction unit represents the interaction between a user of the application and the execution of a system service. In other words, the SIUs do the following: allow the users of the application to enter the values for the arguments of a service; execute the service; and offer to the users the feedback of the results of the execu-tion of the service.

A Population Interaction Unit (PIU). This interaction unit represents the interaction with the system that deals with the presentation of a set of instances of a class. In a PIU, an instance can be selected, and the corresponding set of actions and/or navigations for the selected instance are offered to the user.

An Instance Interaction Unit (IIU). This interaction unit represents the interaction with an object of the system. In an IIU, as well as in a PIU, the corresponding set of actions and/or navigations for the instance are offered to the user.
A Master Detail Interaction Unit (MDIU). This interaction unit represents the interaction with the system through a com-posite interaction unit. A MDIU corresponds to the joining of a master interaction unit (which can be an IIU or a PIU) and a detail interaction unit (which can be a set of IIUs or PIUs).

The third level of the presentation model allows the specification of the auxiliary patterns that characterize lower level details about the behavior of the interaction units. Each auxiliary pattern has its own scope that states the context in which it can be applied. These auxiliary patterns are: The entry pattern, which is used to indicate that the user can enter values for the arguments of the SIUs. The defined selection pattern, which is used to specify a list of specific values to be selected by the user.
The arguments grouping pattern, which is used to group a set of arguments of the SIUs in order to facilitate the user inter-action with the system.
 The arguments dependency pattern, which is used to define dependencies among the values of the arguments of a service.
To do this, Event-Condition-Action (ECA) rules are defined for each argument of the service. The ECA rules have the fol-lowing semantics: when an interface event occurs in an argument of a service (i.e., the user enters a value), an action is performed if a given condition is satisfied. .
 The arguments preload pattern, which is used to define a set of objects that can be selected as arguments of a SIU. The introduction pattern, which is used to define masks for the introduction of values by the user.

The filter pattern, which allows a restricted search of objects for a Population Interaction Unit. A filter can have data-val-ued variables and object-valued variables. These variables can have a defined default value, a related PIU to select the value of the object-valued variables, and pre-charge capabilities for the values of the object-valued arguments.
The order criteria pattern, which allows the objects of a PIU to be ordered. This pattern consists of the ascendant/descen-dant order over the values of the attributes of the objects presented in the PIU.

The display set pattern, which is used to specify which attributes of a class or its related classes will be shown to the user in a PIU or an IIU.
 The navigation pattern, which allows the navigation from an interaction unit to another interaction unit.

The action pattern, which allows the execution of services by joining and activating the corresponding SIUs by means of actions.
 The navigational filtering pattern, which allows the navigation to related objects to be restricted using a filter condition.
The initialization of arguments pattern, which allows the argument of a SIU to be initialized when it is accessed directly from another SIU.

The conditional navigation pattern, which allows the navigation from a SIU to other interaction units, depending on the execution result (success or failure) of the SIU. 2.4. A software measurement process model
The process model for software measurement proposed by Jacquet and Abran [35] has been used in the development of other functional size measurement procedures, such as [4,1,14,23] . This process model is comprised of four steps: design of a measurement method, application of the measurement method rules, measurement results analysis, and exploitation of the measurement results.

In the first step, the concept to be measured and the rules to measure this concept must been defined. This step is divided into four sub-steps to complete the design of the measurement method: definition of the objectives, characterization of the concept to be measured, selection of the metamodel, and definition of the numerical assignment rules.

In the second step, the designed measurement method must be applied to the software or a piece of the software. This step is divided into three sub-steps: software documentation gathering, construction of the software model, and assignment of the numerical rules.

In the third step, the measurement result obtained in the second step must be documented and audited. This step is di-vided into two sub-steps: presentation of the measurement results and the audit of the results. In the fourth step, the results obtained from the application of the method are used in different ways, for instance in quality models, in estimation pro-cesses, in productivity models, etc. 3. Design of a measurement procedure
In this section, we explain every sub-step of the design of the OO-Method COSMIC Function Points (OOmCFP) measurement procedure using Jacquet X  X  software measurement process model explained above. 3.1. Definition of the objectives
The objective is to design a procedure for measuring the accurate functional size of software applications that are gen-erated using a MDA-based approach from object-oriented conceptual models developed with OO-Method. This measure-ment procedure must be defined in accordance with the COSMIC functional size measurement method. 3.2. Characterization of the concept to be measured
The input artifacts used to measure the functional size of the OO-Method applications are the conceptual models that are used to generate these applications. Therefore, the entity to be measured by the OOmCFP measurement pro-cedure will be an OO-Method conceptual model, and the attribute to be measured will be the functional size, which is defined by the ISO/IEC 14143-1 standard [32] as the size of software derived by quantifying the functional user requirements. These functional user requirements represent a sub-set of the user requirements that specifies what must be done by an application, excluding its technological features and non-functional characteristics (i.e., perfor-mance, security, etc.). 3.3. Selection of the metamodel
A metamodel is a structural definition of the model elements with their properties, and their relationships with each other. A metamodel for an FSM provides the basis for the design of the measurement rules that identify and measure the elements contained in the metamodel. Fig. 2 shows the COSMIC metamodel, which illustrates the infor-mation that should be represented by the software artifact to be measured. This metamodel was designed from the
COSMIC measurement manual version 3.0 [5]. We selected this metamodel for the design of OOmCFP because of the simplicity of the metamodel in quantifying functional size without being limited by maximum values (as occurs in IFPUG FPA).

As Fig. 2 shows, the scope of the measurement is determined by the purpose of the measurement. The purpose and the scope define the set of pieces of the software that will be measured and the level of detail of each piece of software ( gran-ularity level ). Each measurand is focused on a set of objects of interest that can be either physical or conceptual and that are related to data groups . Every data group has a set of attributes . Also, every data group participates in one or more data move-ments , which can be an entry data movement (E), an exit data movement (X), a read data movement (R), or a write data movement (W). Two or more data movements occur in a functional process that belongs to a piece of software of the layer to be measured. Each layer of the piece of software is associated to one operative software environment . Finally, every func-tional process is triggered by triggering events carried out by the functional user . The functional users are the users pieces of software that have been measured and are separated by a boundary from the pieces of software. For a measurement of application to be accurately determined.

The OOmCFP measurement procedure has been developed in accordance with the COSMIC measurement method [5]. For this reason, the OOmCFP procedure is structured using three phases: the strategy phase, the mapping phase, and the mea-surement phase. The strategy phase addresses the four key parameters of software functional size measurement that must be considered before actually starting to measure, namely the purpose of the measurement, the scope of the measurement, the identification of functional users, and the level of granularity that should be measured. Determining these parameters helps to address the questions of  X  X hich size should be measured? X  or, for an existing measurement,  X  X ow should we inter-pret this measurement? X  The mapping phase presents the rules to identify the functional processes, data groups, and data attributes in the software specification (i.e., in the conceptual model) depending on the parameters defined in the strategy phase. The measurement phase presents the rules to identify and measure the data movements that occur between the func-tional users and the functional processes. The boundary between the COSMIC phases is determined by the purpose that each phase has. Since we also follow the process model defined by Jacquet and Abran [35] to develop the OOmCFP procedure, we have determined that there is no direct correlation between the activities defined in the process model and the phases of the
COSMIC measurement method. For this reason, we present the strategy phase and the mapping phase in the selection of the metamodel activity. We separate the measurement phase into two parts: the identification of the data movements that is presented as part of the mapping phase in the selection of the metamodel activity and the rest of the measurement phase that is presented in the definition of the numerical assignment rules activity. 3.3.1. The strategy phase
The strategy phase is a relevant phase in the measurement procedure. In this phase, the purpose, the scope, and the level of granularity must be determined. The functional users and the boundaries must also be identified in this phase.
The purpose of the measurement in OOmCFP (which determines why the measurement is necessary and what the mea-surement result will be used for) is defined as measuring the accurate functional size of the OO-Method applications gen-erated in an MDA environment from the involved conceptual models. As in the specific case of CARE Technologies company [13], this functional size will be used to estimate the cost of the OO-Method applications that are specifically gen-erated by the OlivaNova Suite. Although the code of the OO-Method applications is generated automatically, it is important to note that the effort of programming is substituted by a modeling effort. Thus, for the applications generated in an MDA environment, dealing with the cost means dealing with how to measure cost from the involved models. With the OOmCFP measurement procedure, companies can use the functional size measured from the models to adjust the budget in order to prorate the cost of the software product development. CARE Technologies, which has implemented the tools that support the
OO-Method approach, based its business model on functional size to calculate the cost of the generated applications, pro-rating the cost of the development and improvement of the tools between the generated applications.

The scope of the measurement defines a set of functional user requirements that will be included in a measurement exer-cise. As stated in Section 3.1, the OOmCFP uses the OO-Method conceptual model as the input artifact for the measurement of the functional size of applications generated in MDA environments. This conceptual model formally and unambiguously specifies the functional requirements of the applications independently of the technological characteristics that the gener-ated applications will have. The applications generated using the OO-Method approach have a direct correspondence with the involved conceptual model. Thus, these applications do not need manual changes for their correct operation because their complete specification is performed at an abstract level in the conceptual model. For this reason, the scope of the mea-surement in OOmCFP is the OO-Method conceptual model, which is comprised of four models (Object, Dynamic, Functional, and Presentation), which allow a fully working software application to be generated.

Once the scope of the measurement has been determined, it is important to identify the layers, the pieces of software, and the peer components that make up the applications. In order to correctly identify the architecture of the applications, we have used the definitions of layer, 4 piece of software, 5 [5]. Since the OO-Method software applications are generated according to a three-tier software architecture, we distinguish three layers : a client layer, which contains the graphical user interface; a server layer, which contains the business logic of the application; and a database layer, which contains the persistence of the applications. In each layer of an OO-Method appli-respectively, three pieces of software in an OO-Method application: the client piece of software, the server piece of software, and the database piece of software. Fig. 3 illustrates the pieces of software and layers of an OO-Method application.
The granularity level is the level of detail that the pieces of software included in the measurement must have. Since the measurement will be performed in conceptual models that must be valid to generate the final applications in an MDA envi-ronment, the granularity level is a low level because all the details in the OO-Method conceptual model are needed to auto-matically generate the applications.

Since the functional users are the types of users that send (or receive) data to (from) the functional processes of a piece of software, in the OO-Method applications, it is possible to identify the users and the pieces of software of an application as functional users. Therefore, functional users of the OO-Method applications are the human users, the client component of the software, the server component of the software, and the legacy views (see Fig. 3 ).

The users of the OO-Method applications are represented in the conceptual model as agent classes of the object model (see the definition of agents in Section 2.3). These users are generally human users that send or receive data to the client layer of the software. From now on, we refer to this type of users as the  X  X uman functional user X . This user is a functional user of the client layer of the software and is separated by a boundary from the client layer of the software.
The client component of the software is a functional user that sends and receives data to (from) the server piece of soft-ware and is separated by a boundary from the server layer of the software.

The server component of the software sends and receives data to (from) the client layer of the software and the database of the software: the client layer and the database layer. The server functional user is separated by a boundary from the client layer of the software, and by a boundary from the database layer of the software.

The OO-Method conceptual model allows the definition of legacy views (which are classes implemented in other systems) as well as the definition of their relationships with the classes of the system. These legacy views represent functional users of the OO-Method applications and are separated by a boundary from the server layer of the software. We refer to this type of user as the  X  X egacy functional user X . 3.3.2. The mapping phase
Since our objective is to measure the OO-Method conceptual model, a mapping between the concepts used in COSMIC and the concepts used in the OO-Method conceptual model for measuring the functional size must be defined. This is prob-ably the most important contribution presented in this work: how to relate COSMIC primitives with OO-Method conceptual modeling constructs.

In general terms, a functional process corresponds to a set of Functional User Requirements comprising a unique, cohesive, and independently executable set of data movements. A functional process starts with an entry data movement carried out by a functional user given that an event ( triggering event ) has happened. A functional process ends when all the data move-ments needed to generate the answer to this event have been executed.

In the context of OOmCFP, the  X  X uman functional user X  carries out the triggering events that occur in the real world. This cesses are represented by the interaction units of the OO-Method presentation model that can be directly accessed by the  X  X uman functional user X . These interaction units correspond to the direct successors of the hierarchy action tree (HAT) of the presentation model of the OO-Method conceptual model. Therefore, every child of the HAT will be one functional pro-cess, representing either a selection of a given class population (a Population Interaction Unit (PIU)), an execution of a service (a Service Interaction Unit (SIU)), or more complex interaction units (such as a Master Detail Interaction Unit (MDIU)). Nev-ertheless, in addition to the interaction units, it is important to identify the elements that compose the interaction unit, since they are also relevant to the measurement of the functional size. Table 1 shows the elements that can be contained in these interaction units. More details of the OO-Method presentation model can be found in Section 2.3.
 The  X  X lient functional user X  activates triggering events that occur in the interaction units of the presentation model of the
OO-Method conceptual model. The  X  X lient functional user X  starts functional processes , which are the actions that carry out the server layer of the software in response to the triggering events that occur in the client layer of the software. To identify the elements that are contained in the functional processes of the server layer, it is necessary to identify the actions that this layer can perform in response to the triggering events carried out by the interactions units of the client layer. These trigger-ing events are the following:
The Instance Interaction Units (IIU) require from the server layer the values of the attributes that compose a display set, the execution of a service, or the default values of the arguments of a service.

The Population Interaction Units (PIU) require from the server layer the values of the attributes that compose a display set, the values of the filter variables that have a defined default value, the execution of a service, or the default values of the arguments of a service.

The Master Detail Interaction Units (MDIU) are comprised of combinations of IIUs or PIUs. Therefore, they require from the server layer the information that the IIUs or the PIUs require.

The Service Interaction Units (SIU) require from the server layer the default values of the arguments of a service, the values of the derived attributes used in a service, and the initialization of arguments. SIUs also require from the server layer the execution of the following: services associated to the interaction units, dependency rules of the arguments, valuations, conditional navigation for the success or failure cases of the execution of the service, navigational filtering, validation of the preconditions of the service, check of the integrity constraints, triggers activated by the service, or the change of state of an object by means of the transitions of a service.

The  X  X erver functional user X  carries out the triggering events that occur in the server layer of the software. The  X  X erver func-tional user X  starts functional processes , which are the actions that the database layer carries out in response to the triggering events of the server layer, and the actions that the client layer carries out in response to triggering events of the server layer of the software. For the database layer, the  X  X erver functional user X  starts functional processes that add, edit, and delete the persistent information of the system. On the other hand, the  X  X erver functional user X  starts functional processes in the client layer that deliver information, for instance, by means of the display set or the error messages.

The  X  X egacy functional user X  activates triggering events that occur in the legacy system. The  X  X egacy functional user X  starts functional processes , which are the actions that the server layer of the software carries out to interact with the legacy system.
The data groups correspond to a set of different attributes that describe an object of interest. The object of interest cor-responds to physical objects, conceptual objects, or even parts of conceptual objects. Taking into account that the OOmCFP uses the OO-Method conceptual model to measure the functional size, the data groups are the classes of the object model of the OO-Method conceptual model that participate in a functional process. Of course, identified data groups always corre-spond to a conceptual object of interest. Nevertheless, when a class is part of an inheritance hierarchy, the father class cor-responds to a data group, and when the child class has different attributes than the father, it will correspond to another data group.

The data attributes correspond to the smallest pieces of information of a data group. In the context of OOmCFP, the data attributes of a data group correspond to the attributes of the classes that have been identified as a data group.
With regard to the identification of data movements , every functional process has a set of data movements that can be en-try data movements (E), exit data movements (X), read data movements (R) or write data movements (W). Each single data movement must move a single data group. Fig. 4 shows the data movements that could occur in the OO-Method applications.
All the mapping rules for the data movements are structured with a concept of the COSMIC measurement method, a concept of the OO-Method approach, and the cardinalities that associate these concepts. In summary, we have defined 65 mapping rules for the data movements that can be visualized in the measurement guide of OOmCFP. data movements of all the functionality needed for the correct operation of the generated application, which is built by the model compiler of the MDA environment.

An entry data movement is a movement that moves one data group from a functional user across the boundary into the functional process where it is required. In the OOmCFP measurement procedure, we have determined 27 mapping rules: four are for entry data movements that take place between the human functional user and the functional processes that occur in the client layer; five are for entry data movements that take place between the server functional user and the functional pro-cesses that occur in the client layer; four are for entry data movements that take place between the client functional user and the functional processes that occur in the server layer; and 14 are for entry data movements that take place between the legacy functional user and the functional processes that occur in the server layer. For instance, the following mapping rule was defined to detect the data movement that occurs when the functional user enters a value for an object-valued variable of a filter of a PIU:
Mapping Rule 2: 1 entry data movement for each different object-valued variable that is associated to a filter of a PIU that participates in a functional process.

An exit data movement is a movement that moves a data group from a functional process across the boundary to the func-tional user that requires it. Thus, we have determined 15 mapping rules for the exit data movements: five are for exit data movements that take place from the functional processes that occur in the client layer to the human functional user; four are for exit data movements that take place from the functional processes that occur in the client layer to the server functional user; five are for exit data movements that take place from the functional processes that occur in the server layer to the client functional user; and one is for exit data movements that take place from the functional processes that occur in the server layer to the legacy functional user. For instance, the following mapping rule was defined to detect the data movement that occurs when the PIU of the client layer that contains a filter with object-valued variables exits the value of the object-valued variables to the server functional user:
Mapping Rule 16: 1 exit data movement for each different object-valued variable that is associated to a filter of a PIU that participates in a functional process.

A read data movement is a movement that moves a data group from the persistence storage that is in contact with the functional process that requires it. For the OO-Method applications, only the server layer of the software can read the per-sistence storage. Therefore, we defined 20 mapping rules for read data movements that take place from the functional pro-cesses that occur in the server layer of the software to the database layer of the software. For instance, the following mapping rule was defined to detect the data movements that occur when the filter formula uses values, such as attributes of the class that contains the filter, which must be recovered from the database:
Mapping Rule 33: 1 read data movement for each different class that is used in the filter formula of a filter of a PIU that participates in a functional process.
 A write data movement is a movement that moves a data group from a functional process to the persistence storage. In the
OO-Method applications, only the sever component of the software can write to the persistence storage. Thus, we have de-fined three mapping rules for the write data movements that take place from the functional processes that occur in the ser-ver layer of the software to the database layer of the software. For instance, the following mapping rule was defined to detect the write data movement that occurs when a functional process of the server layer destroys an object: Mapping Rule 50: 1 write data movement for the class that contains a destroy event or a destroy transaction related to a
SIU that participates in a functional process. 3.4. Definition of the numerical assignment rules (The measurement phase)
The measurement rules are the rules that assign a numerical value to the data movements that take place between the functional users and the pieces of software of an OO-Method application: this numerical value represents the functional size of the generated software application.

According to the COSMIC functional size measurement method, each data movement will be assigned one size unit, which is referred to as 1 CFP (COSMIC Function Point). In the OOmCFP, the measurement function is identical to the COSMIC mea-surement function. That is, OOmCFP assigns 1 CFP to each data movement. To measure the functional size of a functional process, a layer, and an OO-Method application, we have defined the measurement rules presented in Table 2 . 4. Application of the measurement procedure
In the following sub-sections, we illustrate the application of OOmCFP to the rent-a-car system following the sub-steps defined in the Jacquet X  X  process model for software measurement explained in Section 2.4. 4.1. Software documentation gathering
The documents that should be gathered to apply OOmCFP to an OO-Method application are the object, dynamic, func-tional, and presentation models, that is to say, the OO-Method conceptual model. This conceptual model has all the details needed for the generation of the fully working OO-Method application.

The mission statement for a rent-a-car system is:  X  X  X o allow the administrator to access the register of client vehicle rent-als in a location of a specific country. The vehicles can be cars or minibuses, and each vehicle has a group, which corresponds to the size of each vehicle. The group of each vehicle is used to calculate the rental price of the vehicle X . Fig. 5 shows the object model of the OO-Method conceptual model for the rent-a-car system for this mission statement.

The functional model of the OO-Method conceptual model for the rent-a-car system captures the semantics associated to the changes of state due to event execution. For instance, the event change-rent of the class Rent assigns a value to the attri-bute rate.

The dynamic model of the OO-Method conceptual model of the rent-a-car system represents the valid lives of the objects of the classes shown in Fig. 5 . This model is created automatically from the object model, specifying the services that change the state of the objects and the possible states that these objects could have.

The information of the rent-a-car system is presented to the user of the application by a menu of options that are modeled by means of a hierarchy action tree (HAT) in the presentation model. For the rent-a-car system, the options of the menu are five groups of registers called Population Interaction Units (PIU), which group instances of the classes of the object model. Fig. 6 shows the HAT of the rent-a-car system.

For each PIU defined in the menu of the rent-a-car system, the attributes, the actions, the navigations, and the filters con-tained in the interaction unit are specified. When all the models of the OO-Method conceptual model are specified, it is pos-sible to verify the conceptual model and generate the final application from that model. Hence, the conceptual model of the rent-a-car system would be the documentation needed to apply the OOmCFP measurement procedure. 4.2. Construction of the COSMIC software model The construction of the COSMIC software model for OOmCFP is performed by means of the mapping between COSMIC and
OO-Method detailed in Section 3.3. Thus, in this sub-step, all the elements that will be measured are identified. 4.2.1. The strategy phase
The purpose of applying OOmCFP is to measure the functional size of the rent-a-car application that is specifically gen-erated by the OlivaNova Suite. The scope of this purpose is the rent-a-car OO-Method conceptual model that specifies the rent-a-car application in an abstract way. The granularity level is low because all the details are available and needed for the generation of the rent-a-car application.

The pieces of software of the rent-a-car application are the client component, the server component, and the database component. Each component of an OO-Method application is built for a particular software environment (for instance, the client component will be built with C#, ASP or JSP). Since the rent-a-car system uses ASP for the client component,
EJB for the server component, and SQL for the database component, every component of the application is also one layer of the software application.

The functional users of the rent-a-car application are the users and the components of the application. The Administrator cation. In addition, the client component of the rent-a-car system is a functional user because it is a user of the server com-ponent of the application. Moreover, the server component of the rent-a-car system is a functional user because it is a user of the client component and the database component of the rent-a-car system.

Between every functional user of the rent-a-car application and its components there exists a boundary: a boundary be-tween the administrator and the client component, a boundary between the client and the server components, and a bound-ary between the server and the database components. 4.2.2. The mapping phase
The administrator carries out triggering events that occur in the real world, for instance, the registration of the rentals. To register a rental in the system, the administrator starts a set of functional processes. To identify the functional process, we use Rule 4 of the measurement guide, 7 which specifies that the direct children of the hierarchy action tree (HAT) of the pre-sentation model are functional processes of the application. Therefore, the functional processes are: PIU_RentsDetails, PIU_Vehicle, PIU_Car_Rates, PIU_Minibus_Rate, and PIU_Location (see Fig. 6 ).

The client functional user of the rent-a-car system starts the functional processes of the server layer that are actions that the server layer carries out in response to the petitions of the client functional user. For example, the server layer does the following: reads values from the database to show them to the administrator in a Population Interaction Unit (PIU); executes the formula of the services that are executed by the actions of a PIU; evaluates the preconditions of the services that are exe-layer performs in response to the petitions of the client functional user will receive the same name as the functional pro-cesses that occur in the client layer: PIU_RentsDetails, PIU_Vehicle, PIU_Car_Rates, PIU_Minibus_Rate, and PIU_Location.
Using Rule 9 of the measurement guide, 7 we identify the data groups of the rent-a-car system. This rule specifies that the data groups of each functional process are the classes that participate in this functional process. Table 3 shows the functional processes, the data groups that participate in each functional process indicating the layer where the data group participates, and the attributes of each data group.

The data movements identified for every functional process in the client and server layers of the rent-a-car system are detailed in Table 4 . 4.3. The measurement phase: assignment of numerical rules
In the sub-step of the assignment of numerical rules, 1 CFP (COSMIC Function Point) is assigned to each data movement identified in the previous sub-step (Section 4.2). Therefore, the aggregation of the identified data movements will determine the functional size of each functional process. The column Total of Table 4 shows the functional size of the functional pro-cesses of the rent-a-car system in the client and in the server layers, respectively.

The functional size of the client and the server layer of the rent-a-car system can be obtained by applying the measure-ment rule for the layers over the functional size of each functional process of the rent-a-car system. For the client layer, we have obtained 51 CFP; for the server layer, we have obtained 44 CFP. Finally, applying the measurement rule for the OO-
Method application, the functional size obtained for the rent-a-car system is 95 CFP. 5. General analysis
In this paper, we have presented OOmCFP, which is an FSM procedure for applications that are generated from object-oriented conceptual models in MDA environments. This procedure was designed in accordance with the COSMIC standard method, which is an FSM method that allows the measurement of each layer of an application as well as the whole appli-cation. This is in contrast to other FSM standard methods that only allow the measurement of the whole application.
The OOmCFP procedure has been designed to obtain accurate measures of the application that is generated from the con-ceptual models. This is feasible because we have selected a conceptual model that has enough semantic expressiveness to specify all the functionality of the final application. Therefore, the measures obtained are accurate because all the data move-ments that occur in the final application could be traceable to the conceptual model. Assuming that the conceptual model is of high quality (that is, the conceptual model is correct and complete), the OOmCFP could be completely automated, provid-ing the measurement results in a few minutes using minimal resources. Obviously, if the conceptual model has incorrect information or missing information, the application cannot be generated and the measures obtained cannot be traceable. In this case, the measurement procedure could be used to detect defects in the conceptual models.

OOmCFP has been systematically designed applying a set of steps of a software measurement process model. Since there is not consensus in the concepts and terminology used in the software measurement field, the concepts and terminology used in the design of OOmCFP have been carefully selected from the ISO VIM [30], ISO 14143 series [32,33] and ISO 19761 [34]. There exist some proposals defined to harmonize these concepts and provide a consistent terminology, such as the software measurement ontology (SMO) [20] and a framework for software measurement [25]. Both, the SMO and the framework are mainly based in the ISO VIM concepts. The SMO is comprised of four sub-ontologies: (1) software mea-surement characterization and objectives, (2) software measures, (3) measurement, and (4) measurement approaches.
OOmCFP is aligned with the first three sub-ontologies because it uses the term  X  X easure X  instead of  X  X etric X , it uses the  X  X nit of measurement X  and  X  X easurement result X  concepts, and it defines the  X  X ntity X  and the  X  X ttribute X  to be measured. The mea-surement approach sub-ontology classifies a measurement approach in  X  X easurement method X ,  X  X easurement function X , and  X  X nalysis model X . We not agree with this classification because a measurement method can have a measurement function defined, as the COSMIC measurement method. For this reason, OOmCFP is not aligned with the measurement approach sub-ontology of SMO. The framework for measurement methods defines a set of concepts and terminology for the design and verification of the measurement methods. These concepts are similar to the concepts of the SMO, for instance the frame-work defines the concepts of measure, measurement result, unit of measurement, entity, and attribute. Thus, OOmCFP is aligned with the terms and concepts defined in the framework. In contrast to the SMO, the framework defines a classification for measurement methods and measurement procedures. OOmCFP is characterized by this classification. The framework also defines the life cycle of the measurement methods: design, application, and exploitation. In this article, we are covering the two first phases of the measurement life cycle of OOmCFP.

In the design of OOmCFP, we have identified a set of mapping rules that allow the relevant primitives of the OO-Method conceptual model to be selected according to the COSMIC concepts. Moreover, a set of measurement rules has been defined to obtain the functional size of each software layer identified. Even though OOmCFP has been designed to be used specifically in the OO-Method context, many conceptual constructs of the OO-Method conceptual model can be found in other object-ori-ented methods. Moreover, the main modeling constructs used by OO-Method are basic constructs that have UML represen-tation support. That is why the OOmCFP procedure could be generalized to other object-oriented development methods and the presented results can be applied to any UML-based method where those primitives are present (for instance [18,38,49] ).
To illustrate the application of OOmCFP procedure, we have manually measured the functional size of a rent-a-car system, obtaining 95 COSMIC Function Points. However, we can identify some validation threats for the results obtained; for in-stance, one threat is the natural variation in human performance because a human may erroneously identify the data move-ments that occur in an application (duplicates, omissions, etc.). To avoid this validation threat for the results obtained, we have implemented a prototype that automates the measurement procedure [44]. Another validation threat for the results obtained is that these measurement results came from a measurement procedure that was instantiated by a single person.
To avoid this threat, a pilot study has been carried out with 12 students, and the measurement results of the students were compared with the results obtained previously [43].

In order to evaluate the accuracy of the OOmCFP measurement procedure (related to the closeness to the  X  X rue value X ), precise measures must first be obtained. In the ISO 5725 standard [31], precision is defined as the closeness of agreement of test results. To evaluate the precision of measures, the ISO 5725 presents the formulae for calculating the repeatability [33] and the reproducibility 9 [33] of the measures. The results of the pilot study confirm the reproducibility of the measures, and the results obtained by the prototype confirm the repeatability of the measures. Therefore, we can state that OOmCFP ob-tains precise measures. However, this does not imply that OOmCFP obtains accuracy measures because other factors can influ-ence the measurement (for instance, the use of models that do not completely specify the final application).
Given that the OO-Method conceptual model allows the complete specification of the final applications in an abstract way, we compare the measurement of six conceptual models using OOmCFP with the measures of the respective generated applications that were obtained directly applying the COSMIC measurement method by three experts. These OO-Method conceptual models represent the functionality of the following systems: invoice, rent-a-car, camping, publishing, photogra-phy agency, and expense report. The first three conceptual models were fully measured, obtaining a functional size of 108
CFP, 95 CFP, and 456 CFP, respectively. The remaining three conceptual models were used to measure some of the functional processes: user management (32 CFP) and publishing service (9 CFP) for the publishing conceptual model; the assignment of the request (20 CFP) and the creation of an article (18 CFP) for the photography agency conceptual model; and expense man-agement (72 CFP) and payment (48 CFP) for the expense report conceptual model. The results obtained are very close to the measures obtained by the experts (the  X  X rue value X ). However, in order to state that OOmCFP obtains accurate measurements, we need to perform more empirical studies. 6. Conclusion
In this paper, we have demonstrated the applicability of the COSMIC standard method as an accurate measure of the func-tional size of object-oriented applications generated in MDA environments. We have demonstrated this applicability by defining an FSM procedure, named OOmCFP, which allows the measurement of functional size from the conceptual models that specify the generated applications.

In MDA environments, the applications are generated by means of model transformations. Therefore, the conceptual models must have the required semantic formalization to specify all the functionality of the generated application. For this reason, all the data movements that can occur in the generated applications can be identified in the conceptual model.
The OOmCFP procedure is currently focused on a single MDA environment (OO-Method). Nevertheless, it is important to remark that the model that the OO-Method used is based on conceptual primitives that are well known and well covered by the UML notation. In fact, any model-driven development approach that is built using UML diagrams could potentially ben-efit from the ideas and results presented in the paper. It is our belief that the contributions of our work can be easily pro-jected to those MDA-based approaches. Thus, the major contribution of this work is the methodology for preparing the specifications of an FSM procedure that performs accurate measurement in the conceptual models of an MDA method.
A suggestion for future work is the definition of a validation methodology that supports the specification of FSM procedures thataredefinedtomeasureapplicationsgeneratedinMDAenvironments.Thisvalidationmethodologymustfocusonboththe-oretical and empirical validations. Some issues that must be considered in the validation methodology are explained in [4]. Further work also includes the improvement of the prototype developed to implement an industrial tool that automates
OOmCFP as well as empirical studies to evaluate the reproducibility and the repeatability of OOmCFP according to the ISO 5725 standard [31]. We use this standard in contrast to other studies [2,3] that are based on the Kemerer equation [37] be-cause this equation uses the average, which is not correct if the results of the measurements are not homogeneous.
References
