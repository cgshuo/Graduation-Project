 We focus our attention on business service engagements as realized over the Internet. In current practice, such an engagement is defined rigidly and purely in operational terms. Consequently, the software components of the business partners involved are tightly coupled with each other, and depend closely on the engagement specification. Even small changes in one partner X  X  components must be propagated to others, even when such changes are inconsequential to the business being conducted. Conversely, if the model leaves the engagements unstructured, humans must carry out the necessary interactions manually, with concomitant loss in productivity. We motivate protocols as providing a happy middle ground between rigid automation and flexible manual execution.

Specifically, in contrast with traditional approaches, we model each partner as an engagement. A protocol describes a pattern of communication between agents. Based on the foregoing, we formulate the following key requirements on a suitable formalization and received by participating agents, not how these agents are implemented. Thus, the semantics of a protocol should depend solely on the communications of the agents enacting it, not on their internal policies. Second, the semantics should capture the business meanings of the messages, thereby avoiding operational constraints, and thus enabling the agents to deal better with exceptions and opportunities [Yolum and Singh 2002]. Third, the semantics should be modular: an agent who enacts a protocol correctly may concurrently enact additional protocols. Fourth, designing engagements using protocols presupposes that we support engineering methodologies such as those based on stepwise refinement. We address the preceding criteria for protocols with an emphasis on their refinement.

We understand a protocol semantically in terms of exactly the set of runs (i.e., com-putations) that it allows. Following Mallya and Singh [2007], we posit that a putative protocol is also allowed by the superprotocol. In general, a subprotocol would include of protocols.

Consider a simple protocol Pay consisting of two actions where a payer first commits to paying a payee, and next pays. Now consider a protocol PayViaMM where the payer first pays a middleman, who in turn pays the payee. Both Pay and PayViaMM send a pay-ment from the payer to the payee. Even though PayViaMM involves an additional role (middleman) and PayViaMM uses different messages (two payment messages instead of one), we expect PayViaMM refines Pay , because PayViaMM makes a payment as Pay a service engagement design exercise where protocol designers begin by identifying the business processes [Malone et al. 2003]). The question we address is how can protocols We formulate refinement in technical terms and show how to compute it via a tool guarded messages the roles exchange, and (iii) the meaning of each message as a set et al. 2010]. Commitments between roles are central to our approach [Singh 1999]. Section 2.4 provides additional details. For now, suffice it to say that a state of a protocol is determined by what atomic propositions hold therein (some propositions specify the states of commitments).
 protocols may involve different roles and messages, the messages may have different meanings, and the meanings may be at different levels of abstraction. Hence, we define refinement only with respect to a mapping of meanings from the superprotocol to the subprotocol. For example, the payment in Pay maps to two payments in PayViaMM .
Our approach for verifying refinement takes three inputs: formal descriptions of a putative superprotocol and subprotocol, and a mapping between them. We reduce the protocol descriptions to their canonical forms, taking into account the mapping fication of a temporal logic model and (ii) temporal formulae whose truth in the model verifies refinement. Our main contributions are as follows. One, we offer the first approach that computes the refinement for protocols based on static analysis of protocol specifications. Two, we formulate a notion of the serial composition of commitments, which can have broader applications than this article, for example in the treatment of commitments in coalitions.

Further, we have implemented our approach in the Proton tool that overlays the well-known model checker MCMAS (http://www-lai.doc.ic.ac.uk/mcmas/). Figure 1 summa-rizes some protocol refinements that Proton verifies (under the obvious mappings) based on the preceding and other examples known from the literature. Section 2 overviews our syntax and semantics and briefly reviews commitments. Sec-tion 3 introduces our running examples for payment and order protocols. Section 4 ment. Section 5 describes how Proton generates input for the MCMAS model checker and the CTL formulae that must be satisfied for protocol refinement to hold. Section 6 to refine, protocol Pay under various mappings. Section 7 shows that the algorithmic implementation in Section 5 is correct with respect to the theoretical framework of Section 4. Section 8 describes the related literature and important future directions. We adopt the following terminology. A subprotocol refines a superprotocol. In hyphen-ated form, super-x and sub-x refer to element x as it occurs in the superprotocol and and a sub-commitment is a commitment defined in the subprotocol. We adopt Lomuscio and Raimondi X  X  [2006] and Cohen et al. X  X  [2009] formalization of a multiagent system as an interpreted system . Importantly, protocols involve roles, not agents. We presume no knowledge of the internals of an agent playing a role and consider all possible strategies that a role may follow in a protocol. and protocol in work by Lomuscio and colleagues.
 Definition 2.1 ( Interpreted System ). An interpreted system stands for the environment. P is a set of atomic propositions. Let i is a set of actions for each i . AP i : L i  X  L e  X  2 Act state l  X  L i , l e  X  L e , role i can perform only the actions in AP is the set of reachable global states. For any global state g component in g , that is, the local state of role i in g . G of joint actions is Act = Act 1  X   X  X  X   X  Act n  X  Act e . t progression function for role i  X  \ e ,and t e : L e  X  Act is T : G  X  Act  X  G and is defined such that T ( g , a ) = and t e ( g e , a e ) = g e . T must be serial (  X  g  X  G ,  X  is a set of Boolean fairness conditions, each of which must be true infinitely often on all legal execution paths. A path  X  in I is an infinite sequence of global states g  X  i  X  0:  X  a  X  Act : T ( g i , a ) = g i + 1 . The i -th state in path all paths starting at g  X  G is denoted ( g ).
 Given an interpreted system I , we associate with it a Kripke model ( G , G of
K , built from the set of initial states G actions. The labeling function PV is the propositional labeling function.
The grammar of the temporal language CTL is ( PropName is an atomic proposition) E (forsomepath), G (on all future states on a path), F (eventually on the path), and U (until on the path). All operators can be rewritten using standard way. The following is the semantics for CTL, specified relative to the Kripke structure K at state g . Given a model K for an interpreted system, formula  X  ifandonlyif K , g 0 |=  X  , where g 0  X  G 0 is a starting state. We write a |= b if and only if for all models K and states g , K , g |= a holds. Proton verifies whether one protocol refines another under a mapping. Figure 2 shows Proton X  X  input syntax (here | separates alternatives, A  X  A ,and A ? is an optional occurrence of A ). Notice that PropName is simply an atomic proposition name.
 A protocol declares roles, propositions, commitments, and messages. Each message m is sent from a sender ( m . snd ) to a receiver ( m . rcv ), has a guard ( m must be true before the message can be sent, a set of actions ( m true) or a commitment operation (being performed). Boolean negation ( antecedent, consequent, and guard expressions to check state, but a message meaning cannot set a proposition to false using a negated action.

The Map nonterminal describes the syntax for a mapping between two protocols (as Listing 3 exemplifies). A mapping maps individual roles, propositions, and com-mitments from the putative superprotocol to expressions in the putative subprotocol. ProtoName , MapName , RoleName , PropName , ComName , MsgName ,and Action are names.
The serial composition operator,  X  , chains two commitments together and is de-scribed in Section 2.5. We write i C i for a left-associated chain ( C Section 2.6, we compare commitments between superprotocol and subprotocol, under an abstraction mapping M , using commitment covering (  X  M from an input superprotocol, subprotocol, and mapping.

Each state g is a set of true propositions p i . All propositions are false in the model of actions, assuming actions: (i) always succeed, (ii) have definite outcomes (no uncertainty), and (iii) have no side-effects. The actions for role i , Act propositional and commitment actions Act i ={ p i  X  A } X  X  where A is the set of protocol propositions, C is the set of protocol commitments,
Operationally, messaging is point-to-point and synchronous. All protocol state is one role to execute next (interleaved execution). When scheduled, the role X  X  agent: global state and evaluating each message X  X  guard expression, (ii) chooses an enabled message to send or chooses  X  X o-operation X , (iii) performs all actions in the message X  X  meaning, in any order, and (iv) updates the protocol X  X  state.

In every global state g of the interpreted system, each commitment C C . status  X  Status can be any of the states in Figure 3. We define propositions for the expressions C . status = x in each state g . For each commitment C i , we evaluate the occurrence of the commitment operations using the following four propositions.

As Section 1.1 mentions and Definition 4.6 formalizes, refinement depends upon a a Boolean expression of subpropositions, and (iii) supercommitment to an expression of subcommitments. Proton combines two protocols and a mapping to: (i) construct an interpreted system model I from the subprotocol X  X  propositions, commitments, and guarded actions, as specified in Definition 4.2 and (ii) generate appropriate CTL for-the constructed model satisfies all the CTL formulae that Proton generates. Commitments are a formal and concise method of describing how agent roles commit to performing future actions [Singh 1999; Yolum and Singh 2002]. We extend previous commitment definitions in two ways. First, we allow both debtors and creditors to be sets of roles, enabling us to handle commitment chains with multiple debtors and multiple creditors. Second, we introduce a new TRANSFER commitment operation to unify In an active commitment whose antecedent is false, the debtors are conditionally com-mitted to the creditors. When the antecedent becomes true, we say the commitment is detached , and the debtors become unconditionally committed to the creditors.
Consider the following two example commitments drawn from the payment scenar-paying the payee via pay P (the payer X  X  payment) and pay M
Figure 3 shows the state transition diagram for a commitment. The states of a commitment are: (i) null : where the commitment does not yet exist; (ii) cond (active and conditional): after CREATE with antecedent and consequent being false, and with no other operations; (iii) detached (active and detached): after true, consequent false, and with no other operations; (iv) dis (discharged): after and consequent being true; (v) xfer (transferred): after CREATE (released): after CREATE and RELEASE ; and (vii) can (canceled): after A commitment in states cond or detached is said to be active . A commitment in states dis , xfer , rel ,or can is said to be resolved . The commitment operations are: (i) performed only by debtors, creates an active commitment; (ii) plicitly when the antecedent becomes true; (iii) DISCHARGE the consequent becomes true; (iv) TRANSFER , performed by either debtors or creditors, deactivates the current commitment and replaces it by another commitment; (v) LEASE , performed only by creditors, deactivates the commitment, thus releasing the the debtors X  commitment.

We understand a protocol Q as refining a protocol P if and only if the correct en-actments of Q are also correct enactments of P . As in previous work, in a correct enactment of a protocol each detached commitment must eventually resolve. Debtors may act before they are required to do so and the consequent may become true before the antecedent. In general, there is no guarantee that autonomous debtors do not ar-bitrarily CANCEL . In practice, the creditors would assume the debtors are trustworthy or the setting would include an external mechanism (such as penalties) to ensure the debtors X  compliance. In PayViaMM , where the payer commits to a middleman who commits to the payee, the two commitments together effectively commit the payer to the payee. We intro-duce serial composition as a general way to chain commitments over intermediaries, computing a single, resultant commitment. The serial composition of commitments is a static construct, but the resultant commitment dynamically progresses through the states in Figure 3 as the protocol progresses.
 Definition 2.2 . Let C A and C B be two commitments where C the serial composition of C A and C B is the commitment C are specified precisely as follows: The state of C  X  is defined based on the states of C A and C at least one of C A and C B is transferred, released, or canceled.

Singh X  X  [2008] formalization of commitments includes the similar idea of commitment chaining, but serial composition additionally captures the intuition of a coalition of roles. The aforesaid well-definedness condition C A . csq definition for chaining, although serial composition accommodates different roles. The second commitment becomes active ( C B . ant ) whenever the first commitment resolves ( C do so ( C A . ant always false).

Informally, we say debtors are responsible for their commitments, and creditors are beneficiaries of their commitments. In a detached commitment, the debtors are respon-sible for eventually making the consequent true. Responsibility can be several (each for the entire commitment), or joint and several (the creditors hold one debtor fully serial composition of commitments, a debtor is never compelled to assume additional commitments, but the original commitment expression, with its individual commit-ments, must be retained to determine which role(s) failed to perform if the resultant consequent is not produced.

C  X  states the union of debtors is committed to the union of creditors to bring about the consequent C A . csq  X  C B . ant  X  C B . csq when antecedent C and thus is partially responsible for discharging C  X  . Also, every debtor in C the analogous intuition for creditors.

If we order the states of a commitment as null &lt; can &lt; C than its least constituent.
 However, it creates commitments that are at least as strong as, and typically stronger than, their inputs. C A  X  C B is typically stronger than C the same antecedent ( C A . ant ), in general, C A  X  C B has a stronger consequent ( C not always stronger, because  X  is idempotent: a commitment can be usefully added to a commitment chain only once.

L EMMA 2.3. If C k is any commitment in a commitment chain posing C k again does not increase the strength.
P ROOF .If i C i is well-defined, then so is ( i C i )  X  C yield the same results for both sides. Because commitments are crucial to our semantics of protocols, commitments are also crucial to refinement. And because we need to compare two protocols, we need a mech-anism to compare two commitments. Specifically, each supercommitment must be cov-ered by, or make at least the same commitment as, another relevant subcommitment. The commitment comparison accommodates a mapping to account for the commitments being expressed at different levels of abstraction. Definition 2.4 extends Chopra and between antecedents and consequents, this definition incorporates the mapping of roles and propositions.
 Definition 2.4 ( Commitment Covering ). A stronger commitment C stronger than) a weaker commitment C W with respect to mapping M , written C C
S , if and only if where M ( x ) maps (super-) element x in C W to an expression of (sub-) elements in C
Every superdebtor is partially (severally) responsible for discharging the supercom-mitment. Each super-role is mapped to (implemented by) a set of subroles M ( d ). We Together these subdebtors assume the superdebtor X  X  responsibilities. Eq. (5) captures the requirement that every superdebtor X  X  responsibilities must pass to at least one a partial beneficiary of the supercommitment. Eq. (6) captures the requirement that every supercreditor X  X  benefit passes to at least one of its subcreditors.
In many situations, multiple subcommitments must be combined to cover a single supercommitment. In these cases, a supercommitment is covered by the serial compo-sition of multiple subcommitments.
 We visualize our explanations by diagramming a commitment as a labeled arrow. The name of the commitment is written in the top center of the arrow. Debtors and creditors are above the arrow and the antecedent and consequent below it. When multiple terms appear in a position, they are implicitly combined using the operator in parentheses.
 As a simple example, consider commitments C 1 = C Payer , C propositions as follows: (i) Payer  X  X  Buyer } , (ii) Payee and (iv) pay  X  pay . The diagram shows C 2 covers C 1 .

As another example, we obtain C ( order , ship )  X  C ( order since the stronger commitment detaches when order or freeCoupon is true. And, likewise stronger commitment requires expressDelivery in addition to ship . We introduce four running examples. Pay and PayViaMM are payment protocols whereas OrderPayShip and OrderPayViaMMShip are order protocols involving payments. Suggestive sequence diagrams are presented in Figure 4. Protocol Pay in Figure 4(a) is a basic payment protocol between a payer and a payee. The payer may commit to pay the payee by sending the promise message. Later, it sends a payment message directly to the payee.
 Listing 1 Pay Protocol 1: protocol Pay { 2: role Payer ; Payee ; 3: prop promise ; pay ; 4: commitment 5: C pay = C ( Payer , Payee , promise , pay ); 6: message 7: Payer  X  Payee : promiseMsg means { promise , CREATE ( C 8: Payer  X  Payee :[ promiseMsg ] payMsg means { pay } ; and Payee, propositions promise and pay , and the commitment. Both promiseMsg and payMsg messages are sent by Payer to Payee. A message may be sent only if its guard true. A message X  X  meaning is expressed as a set of actions after means and between { and } .

In protocol PayViaMM (pay via middleman), if the payer chooses to do so, it commits to paying the payee by sending the promise message. The middleman commits to sending payM if the payer sends payP by sending pledgeMsg . The payer then sends a payment indirectly to the payee, first paying the middleman, who in turn pays the payee. The sequence diagram in Figure 4(b) shows a typical interaction. In this case, other acceptable runs also exist: for example, the middleman may send the payM message before the payP message. The Proton specification for PayViaMM is shown in Listing 2. Middleman commits to Payer to pass along any payment it receives (line 11). Payer will not pay Middleman without this commitment (line 12). Since payMMsg has an implicit guard of true (line 14), Middleman is allowed to pay early. Protocol OrderPayShip in Figure 4(c) supports a buyer placing an order with a seller. quote along with its commitment to ship the good if the buyer orders. The buyer can accept the seller X  X  offer by placing an order, which creates its commitment to pay Listing 2 PayViaMM Protocol 1: protocol PayViaMM { 2: role Payer ; MM ; Payee ; 3: prop promise ; 4: payP ; // paymentfromPayertoMM 5: payM ; // paymentfromMMtoPayee 6: commitment 7: C payP = C ( Payer , Payee , promise , payP ); 8: C payM = C ( MM , Payer , payP , payM ); 9: message 10: Payer  X  Payee : promiseMsg means { promise , CREATE ( C 11: MM  X  Payer : pledgeMsg means { CREATE ( C payM ) } ; 12: Payer  X  MM :[ promiseMsg  X  pledgeMsg ] 13: payPMsg means { payP } ; 14: MM  X  Payee : payMMsg means { payM } ; PayViaMM for payment. Since superprotocols represent higher-level abstractions than subprotocols, comparing protocols must address differences in abstraction level. To this end, we map elements (roles, propositions, and commitments) of a putative superprotocol to elements of a putative subprotocol. We map every superelement to an expression of subelements, but a subprotocol may contain subelements that do not correspond with any superelement. Listing 3 Mapping M 1 : Pay to PayViaMM 1: map M 1 :Pay  X  PayViaMM { 2: role 3: Payer  X  X  Payer } ; 4: Payee  X  X  Payee } ; 5: prop 6: promise  X  promise ; 7: pay  X  payP  X  payM ; 8: commitment
Consider mapping M 1 in Listing 3 from Pay to PayViaMM . Each super-role is mapped to a set of subroles. Line 3 maps the Payer super-role in Pay to the Payer subrole in PayViaMM . Each superproposition in Pay is mapped to a Boolean expression of subpropositions in PayViaMM . Line 7 maps pay to the conjunction of payP and payM . Notice that payP and payM are messages sent by different roles in PayViaMM ; thus even the simple line 7 demonstrates the generality of our mapping approach. Line 9 maps supercommitment C pay to the serial composition of sub-commitments C
There can be multiple mappings between some protocol pairs. The Middleman role does not appear in mapping M 1 . We can construct alternative mappings that group the Middleman into coalitions with different super-roles. Mapping M Mapping M 3 in Listing 5 are each the same as M 1 except for their role mappings: M Listing 4 Alternative Mapping M 2 : Pay to PayViaMM 1: map M 2 :Pay  X  PayViaMM { 2: role 3: Payer  X  X  Payer , MM } ; 4: Payee  X  X  Payee } ; 5: ... Listing 5 Alternative Mapping M 3 : Pay to PayViaMM 1: map M 3 :Pay  X  PayViaMM { 2: role 3: Payer  X  X  Payer } ; 4: Payee  X  X  Payee , MM } ; 5: ... groups the Middleman into a coalition with Payer and M 3 into a coalition with Payee. PayViaMM refines Pay under all three mappings M 1 ,M 2 ,andM
We require each commitment to be explicitly mapped. A commitment mapping must not violate the role and proposition mappings, but that is not always sufficient to uniquely determine the commitment mapping. It is possible that a supercommitment cal PayViaTwoMM protocol, where the payment can be made through either Middleman or Middleman 2 , the supercommitment C 1 = C Payer , Payee either of two serial compositions (the protocol designer chooses between them based on other factors).
 Mapping B 1 in Listing 6 shows a possible mapping between Pay and PayViaMM , similar to M 1 except the serial composition in line 9 combines the commitments in the wrong order. In Section 6, we show PayViaMM does not refine Pay under mapping B Listing 6 Nonrefining Mapping B 1 : Pay to PayViaMM 1: map B 1 :Pay  X  PayViaMM { 2: role 3: Payer  X  X  Payer } ; 4: Payee  X  X  Payee } ; 5: prop 6: promise  X  promise ; 7: pay  X  payP  X  payM ; 8: commitment We assume a set of atomic propositions that describe the state of the world and states of relevant commitments. We define actions as atomic propositions (being made true) and commitment operations (being performed). Messages set propositions true, but not false.

Definition 4.1 . A protocol is a sextuple R , M , C , A , S , G tively, to: (i) a set R of roles; (ii) a set M of message names; (iii) a set (iv) a set A of Boolean propositions and commitment states; (v) a set such that  X  X  X  S and if s  X  S , gs  X  G ,and s  X  gs . guard then s set G of guarded statements of the form snd , rcv , guard guard  X  S , msg  X  M ,and actions ={ a i  X  A } X  X  Act C ( C impose the no overlap constraint:  X  gs 1 , gs 2  X  G ,if gs gs Each message corresponds to an atomic proposition recording whether the message has the messages that have been sent in that state (Item v). Each guarded statement gs has a guard gs . guard which is a set of states, and a meaning gs expression of actions. A message msg can be sent by the sender ( gs becomes true in the next state. The actions corresponding to different messages may be interleaved. The no overlap constraint ensures that if two or more superactions contain the same subaction, and both superactions are enabled in a state, then the oc-currence of the common subaction in a subrun is unambiguous as to which superaction it corresponds to, which recall is key to our notion of refinement. We introduce a run , a possible computation through our model, as a basis for our semantics. A run, notated  X  , is an alternating sequence of states and actions s , a written |  X  | .

We can now express two key intuitions. First, the semantics of a protocol is simply the set of runs it allows. Underlying each run is a coarser message enactment :ase-quence of states and messages where each message X  X  guard is true in the state where the message occurs. Second, a protocol refines another if and only if the runs of the first are also runs of the second, with the proviso that the putative subprotocol may preceding, we need to relate protocols to models. Our approach generates a model from the putative subprotocol and then verifies (using suitable mapping) whether the puta-model.

Definition 4.2 ( Proton Model ). Let P = R , M , C , A , S , G Proton model for P is I = , P , PV , L i , Act i , AP i , with e being the environment, (ii) P = A , (iii)  X  p  X  A : PV ( p ) L i ={ l } and L e = and Act e ={ sched = r | r  X  R } ,(vi)  X  i  X  R ,  X  s  X  S : AP i  X  s  X  m . guard } , (vii)  X  i  X  R : t i ( l ) = l ,and t e set of all states reachable from G 0 by transition function T in (x) F ={ C i . status = detached | C i  X  C } .

Here  X  is binary cross-product and is set cross-product. The protocol X  X  state is the cross-product of the state of each message and commitment. Since both messages and in the environment (iv). Proton supports interleaved rather than concurrent actions with the environment scheduling one role at each step (v). Every role can perform the commitment state of commitment C i as defined by Figure 3 (vii).

Through a slight abuse of notation, for simplicity, we treat guards and actions as expressions in the following.

Definition 4.3 ( Enactment ). Let P = R , M , C , A , S , G be its Proton model. Then, an alternating sequence of states and messages h 0: h j  X  S , m j + 1  X  M : I , h j |= m j + 1 . guard and
A message enactment yields one or more runs with different interleavings of each message X  X  actions. We define a function  X  that maps each index in the message enact-ment to the index in the run where the corresponding message expression m becomes true. Each message expression occurs in the same order in every run, and becomes true precisely at the state where its execution completes.
 Definition 4.4 ( Run ). Let P = R , M , C , A , S , G be a protocol and model. Then, an alternating sequence of states and actions s run of P ifandonlyif s 0 = X  and (  X  j  X  0: s j  X  S , a j + I ,
We say a run is well-defined to emphasize that it satisfies the guard and action states and actions. The empty run  X  is always well-defined, since no agent is required to perform any action.

Definition 4.5 ( Generated Runs ). Let P = R , M , C , A , S , G function on the natural numbers  X  : N  X  N such that (  X  j We write runs ( P ) for the set of all runs generated by protocol P in
Definition 4.6 ( Mapping ). M maps protocol P = R P , M P col Q = R Q , M Q , C Q , A Q , S Q , G Q ifandonlyif M =
Informally, a run  X  Q embeds arun  X  P if all of  X  P lies within everything that  X  P does, and possibly more: as Mallya and Singh [2007] propose, a
Consider the mapping from Pay to OrderPayShip . In protocol Pay , promiseMsg means { { the same, respectively, as orderMsg and payMsg in OrderPayShip .
 Pay has two message enactments: and promiseMsg , payMsg . OrderPayShip has five message enactments, which embed Pay  X  X  runs as follows. promiseMsg , payMsg : reqQuoteMsg , sendQuoteMsg , orderMsg promiseMsg , payMsg : reqQuoteMsg , sendQuoteMsg , orderMsg values for all superpropositions and supercommitments. We now compare enriched substates M ( s ) in mapped subruns with superstates in superruns. Next, we write exp x  X  y to mean the expression resulting from the uniform substitution of symbol x by expression y in exp .

Definition 4.7 ( Mapped Run ). Let  X  = s 0 , a 1 , s 1 ,...
M R , M P , M C be a protocol mapping. Then the M-map of
M ( s 0 ) , a 1 , M ( s 1 ) ,... ,isarunwhereforall s , M ( s ) for which the following conditions hold:  X (Propositions) if m , E  X  M P and s |= E ,then m  X  M ( s ).  X (Commitments) if C , i C i  X  M C and  X  i : s |= C i . status ,then C C . status = min ( C i . status ).
 Continuing with the previous discussion, we map each subrun and verify that it embeds some super-run. The following definition captures the intuition that the embedding subrun steps through each of the states of the embedded super-run, but may potentially include additional states. We ignore the transitions in each run.

To simplify the notation, we also introduce a projected mapping function M ( q )
Definition 4.8 ( Embedding ). Let P and Q be two protocols. A run q bers  X  : N  X  N such that (  X  i :0  X  i  X |  X  P | : p i = M ( q M ( q  X  ( i ) ) = M ( q j )), where M ( q ) = M ( q j )  X  A time M ( q j ) changes, the new value matches the next p i
Now we can define refinement in purely semantic terms that capture our intuition that each mapped subrun must embed some super-run. Notice that this definition implicitly uses Proton models I P and I Q , respectively, for P and Q . Definition 4.9 ( Refinement ). Let P and Q be two protocols, and M a mapping from P to Q . Then Q refines P under M if and only if (  X   X  Q  X  emb ( M (  X  Q ) , X  P ))).
 Figure 5 shows the high-level process flow for verifying protocol refinement. The Proton preprocessor reads the subprotocol, superprotocol, and mapping specifications and constructs (as Section 6 details) the input for the MCMAS model checker in the Interpreted Systems Programming Language (ISPL) [Lomuscio et al. 2009]. The input to MCMAS is a set of guarded statements for each role. Internally, MCMAS implicitly generates a state transition system such as that shown in Figure 6. The system starts in initial state s 0 .Action requestQuote transitions to state s state.
 The Proton preprocessor generates an interpreted system model for the subprotocol. There is one ISPL agent definition for each subrole, and the state of all subelements (propositions and commitments) are expressed as model state variables. The model checker simulates the subprotocol X  X  actions. Because each superelement is mapped to an expression of subelements, the state of every superelement can be inferred from the subprotocol X  X  state. As Section 5.6 shows, protocol refinement conditions are ex-pressed as CTL formulae. If all these CTL formulae are true, the subprotocol refines the superprotocol. A message can mean multiple things. To better understand and characterize a message, The meaning of a message is then the conjunction of all its constituent actions.
An action is either a Boolean proposition or a commitment operation. A propositional to false. Commitment actions are the operations CREATE , TRANSFER that change the state of a commitment.

We replace all message terms with a conjunction of their actions throughout a proto-col, decomposing protocol messages, converting from a  X  X rotocol of guarded messages X  to a  X  X rotocol of guarded actions. X  Each msg term is replaced by a conjunction of its actions in both the guard and the action expression of every guarded statement. executes actions, not action expressions. Therefore, each guarded action expression must be converted to an equivalent set of guarded actions. However, computing the equivalent guarded actions is nontrivial. For example, consider the guarded action expression can occur before the guard becomes true. Greater flexibility is needed.
Given a guarded conjunction of actions [ guard ] a 1  X  a 2 first (in time) of the a i s becomes true. We minimally constrain when the a actions, in both the superruns and the subruns. For conjunctions, all the a last, can move to any earlier point in time. For disjunctions, all the a ning (conjunction) or end (disjunction). Decomposition (Section 5.1) generates guarded action expressions with conjunctions; abstraction mappings (Section 5.4) can generate guarded action expressions with both conjunctions and disjunctions.

The recursive diffusion function dif transforms a guarded action expression to a set of guarded actions. We have where guard and exp i are Boolean expressions of actions. Diffusion transforms the guarded expression example given before, to the following. any time. Diffusion thus covers possibilities that the na  X   X ve approach omits. Diffusion can generate multiple guarded statements for the same action, but MCMAS requires a single guarded statement for each action. Therefore, we introduce the col-lection function col that converts a set of guarded statements back to canonical form, where there is a single guarded statement for each action. Consider each individual, in its input, and generates a single guarded statement for that action in its output. appears in only one guarded statement in the input, that guarded statement appears unmodified in the output.
Consider a partial protocol containing these two guarded statements. Since the mes-Definition 4.1. Diffusion transforms those to the following three guarded statements. Collection merges the two statements for ship , giving these two, final guarded state-ments.
Figure 7(a) schematically shows how the foregoing developments of decomposition, diffusion, collection, and embedding combine together to check whether one protocol refines another. However, by themselves, they do not address the fact that different protocols can be written at different layers of abstraction. Since superprotocols represent higher-level abstractions than subprotocols, comparing protocols must address differences in levels of abstraction. There is often no one-to-one correspondence between superelements and subelements. Protocol elements (roles, propositions, and commitments) must be mapped between the two protocols to compare them.

An important type of abstraction difference is the introduction of intermediaries or middlemen in lower-level abstractions. Whereas two super-roles may communicate di-tendency for message communication to pass through multiple, intermediary subroles superelements to span intermediaries. One superproposition could map to an expres-and one supercommitment could be fulfilled through multiple subcommitments and their intermediate subdebtors.

We say one protocol refines another protocol under a given mapping, because mapping functions are an essential element for protocol refinement, and must be an explicit input. A subprotocol might refine a superprotocol under one mapping, but not under a different mapping. Our approach does not determine whether it is impossible for one protocol to refine another protocol under any possible mapping.

A mapping expresses how terms in a putative superprotocol map to expressions in a putative subprotocol. The mapping function map converts guarded action expressions written with high-level abstractions x i in a putative superprotocol, to expressions e low-level terms in a putative subprotocol. (Next x i  X  e i Figure 7(b) schematically shows the transformations and comparison required to and collection ( col ). Vertical lines show the comparison between two protocols: run embedding ( emb ). The nodes in the figure show how guarded messages (gMsg) are transformed first to guarded action expressions (gExp), and then to guarded actions (gAct). In each subfigure, the top row refers to a superprotocol and the bottom row refers to a subprotocol. MCMAS checks whether an interpreted system model satisfies specified CTL formulae. overlapping messages, serial composition, and commitment covering as CTL formulae. All such formulae must be satisfied for protocol refinement to hold. 5.6.1. Verify Run Embedding by Checking Guards. Protocol comparison is fundamentally based on run embedding. Run embedding means, at every state, if the subprotocol can perform an action then the superprotocol must also be able to perform that action. embedding ignores actions not in the superprotocol, Proton generates CTL formulae for all actions that result from mapping all superactions ( 5.6.2. Verify that Messages Do Not Overlap. So that every action a in a subrun can be uniquely associated with a message, we verify the no overlap constraint of Defini-tion 4.1. For every pair of guarded statements gs 1 and gs meaning a , mitment must eventually resolve in every correct protocol enactment. We employ model to eliminate subruns in which the subroles fail to act properly and resolve their de-tached commitments. Doing so restricts our verification to correct enactments of the given protocols, thus avoiding false negatives due to incorrect enactments.
The states of supercommitments can be inferred from the states of subcommitments. state has no bearing on the enactment of a protocol, so we can replace a commitment covering, which would otherwise need to be handled separately, as indeed it was in a previous version of Proton.
 Verifying one commitment covers another under map M, C W  X  and (6)). Second, the model checker verifies the antecedent and consequent conditions (Eqs. (7) and (8)) hold in all (reachable) states with the CTL formulae. on all paths with the CTL formula In this section, we pull together the many elements: commitments, serial composition of commitments, and commitment covering; the example payment and order proto-cols, and various mappings between them; and the formal definitions. We concretely demonstrate how PayViaMM refines, or fails to refine, Pay under various mappings.
Proton verifies protocol refinement using the process flow as shown in Figure 5 and the pseudocode for refines (super, map, sub) shown in Listing 7. The inputs P and Q are protocols, which in our syntax are in terms of guarded messages. The first lines of the algorithm transform these into protocols expressed in terms of guarded actions. Proton generates an interpreted system model from the guarded actions of the subprotocol. There is one MCMAS agent definition for each subrole, and the state of the subelements (propositions and commitments) are MCMAS state variables. The MCMAS model checker then simulates the subprotocol X  X  actions. Because each su-perelement is mapped to an expression of sub-elements, the superprotocol X  X  state can be inferred from the subprotocol X  X  state. Refinement requires the model of the subpro-the superprotocol.

We now check whether PayViaMM refines Pay under map M 1 . Using the commitment diagrams from Section 2.6, this diagram demonstrates commitment C Listing 7 Calculate refines ( P , M , Q ) 1: Q gMsg = Q Input Q is a protocol of guarded messages 2: P gMsg = P Input P is a protocol of guarded messages 3: Q gAct = col ( dif ( means ( Q gMsg ))) protocol of guarded sub-actions 4: P gAct = col ( dif ( map M ( means ( P gMsg )))) protocol of guarded sub-actions 5: model = genModel( Q gAct ) generate ISPL model 6: for all act P  X  P gAct . actions do For all super-actions 7: genCTL( AG ( act P . sub  X  guard  X  act P . super  X  guard )) 8: end for 9: for all C Q  X  Q gAct . C do For all sub-commitments 10: genFairness( C Q . status = detached ) 11: end for 12: for all C P  X  P gAct . C do For all super-commitments 13: C Q = C P . coveringCommitment 14: genCTL( AG ( M ( C P . ant )  X  C Q . ant ) 15: genCTL( AG ( C Q . csq  X  M ( C P . csq )) 16: end for 17: for all C A  X  C B do For all serial composition pairs 18: genCTL( AG ( C A . csq  X  C B . ant )) 19: end for 20: for all overlapping message pairs m 1 and m 2 in P and Q do 21: genCTL( AG (  X  ( m 1 . guard  X  m 2 . guard ))) 22: end for 23: ctl = all generated CTL formulae 24: return MCMAS(model, ctl) Are all CTL formulae satisfiable? covered by the serial composition of C payP and C payM from PayViaMM under mapping M 1 in Listing 3. The bottom-left arrow states that if promise becomes true, Payer commits to making payP true. The bottom-right arrow states that if payP becomes true, MiddleMan commits to making payM true. In the serial composition (middle arrow), if promise becomes true, then Payer and MiddleMan (severally) commit to making both payP and payM true. The well-definedness condition ensures that the discharge of the first commitment entails the antecedent of the second commitment, thus detaching it. The Payee and Payer are creditors of the input commitments, and are thus creditors of the serial composition. The serial composition covers the commitment in Pay (top arrow).

Proton generates the following eight CTL formulae to verify PayViaMM refines Pay under M 1 . Eq. (13), which verifies whether subguards imply superguards, for actions antecedent and consequent conditions of C payP  X  C payM covers C directly by the Proton preprocessor, not by MCMAS).
 All of the preceding formulae are obviously true, except Eq. (21), which requires fur-ther consideration. Eq. (21) can be rewritten AG ( pay P  X  guards, ensures pay P becomes true only after promiseMsg . MCMAS verifies each gener-ated CTL formula holds in the model, so PayViaMM refines Pay under map M Proton generates exactly the same input to MCMAS when checking whether PayViaMM refines Pay under map M 2 or map M 3 , because the subprotocol models are derived from exactly the same PayViaMM protocol, the superprotocol Pay contains exactly the same propositional and commitment superelements, and exactly the same CTL conditions must be checked. Therefore, PayViaMM refines Pay under both maps M 2 and M 3 .

Proton correctly reports failures. Proton generates these CTL formulae when check-ing whether PayViaMM refines Pay under mapping B 1 in Listing 6. Recall that B because pay M has a true guard in Listing 2, so the Middleman can send pay time, even before promise . Eq. (28) comes from the antecedent of C promising and the Payer actually paying, the formula does not hold, meaning that C can become detached without C payM  X  C payP also becoming detached. The result is C in the model, and PayViaMM does not refine Pay under mapping B
As in Mallya and Singh X  X  [2007] approach, an interesting consequence of our treat-with the notion of subtype in object-oriented programming.

Proton verified all the refinements shown in Figure 1 and Table I. The first three columns are the superprotocol, subprotocol, and mapping, respectively. OrderPayShip is identical to the first NetBill scenario described by Mallya and Singh [2007]. NetBill and NetBill 3 are scenarios 2 and 3 in the same paper. PayBySpouse is a new, simple payment protocol where one person promises and then his or her spouse pays. FullPay is similar to Pay , but exercises all the commitment operations:
Each superprotocol-subprotocol pair has a unique set of mapping names, so M Pay and PayViaMM is a different mapping than M 1 for Pay and PayViaCheck . Mappings M 1 ,M 2 ,M 3 ,andB 1 for Pay and PayViaMM are shown, respectively, in Listings 3, 4, 5, and 6. Column refines is Yes if subprotocol refines superprotocol under map; column is the number of serial compositions in the mapping; column covers is the number of commitment covering checks; column formulae is the number of CTL formulae verified by the model checker; and column time is the elapsed time in seconds for the complete refinement verification, including Proton preprocessing and MCMAS model checking. Definition 4.9  X  X aps up, X  enriching the states in subruns, the algorithm  X  X aps down, X  expanding expressions and ignoring elements not in A P .
 T HEOREM 7.1. Let P and Q be two protocols, and let M be a mapping from P to Q. Then, refines ( P , M , Q ) returns true if and only Q refines P under M. P ROOF .Let I Q be the Proton model generated from Q . Define mappings M means ( Q )and M P = M ( means ( P )).  X  Assume refines ( P , M , Q ). Then all of the CTL formulae in Listing 7 are true. Because of line 7, all subguards imply their superguards. Because of the fairness valid. Because of line 21, no guarded statement pairs overlap.

Let  X  Q bearunin runs ( Q ). By Theorem A.7, there is a run runs ( col ( dif ( M Q ( Q )))). By Theorem A.2, there exists a run and, by Theorem A.7, there exists a run  X  P  X  runs ( P ). Therefore, for every a  X   X  Assume Q refines P under M . For any  X  a  X  emb ( M (  X  Q ) , X  P ) implies (  X  a i  X  A P : I , g 0 |= which implies the CTL formulae at line 7 are true.

Because all detached commitments must eventually resolve, the fairness formulae at line 10 are true. Because all commitment coverings must be valid, the formulae at lines 14 X 15 are true. Because all serial compositions must be valid, the formulae at line 18 are true. Because protocols must be well-defined, the formulae at line 21 are Commitments support finer guard granularity than propositions can. A proposition four stages: null, active and conditional, active and detached, and resolved. Rather than waiting for final resolution, a protocol can make progress sooner if an action X  X  guard is enabled after one of the first three stages. Commitments increase protocol flexibility, because guards can specify earlier stages.

For example, suppose the Buyer role in OrderPayShip decides whether to pay based on Using commitments, the protocol can guard pay based on any of the four commitment stages. A guard can enable pay as soon as the debtor commits to make ship true. Incorporating commitments can improve flexibility over traditional protocol frame-works.

A necessary prerequisite of employing protocols is that the participants of a service engagement agree on the format and meanings of the messages they exchange. Note not expressed clearly and explicitly and any agreements are hardcoded in implemen-tations.

Our definition of protocol refinement does not mean agents that can participate in a superprotocol can necessarily participate unchanged in a subprotocol. In our model, agents may need to be modified to participate in subprotocols. For example, an agent capable of participating in a basic payment protocol needs to handle the additional messages required in paying via check or credit card. Proton is the first approach for protocol refinement that incorporates mapping su-perelements to expressions of subelements. Proton supports mapping super-roles to sets of subroles, superpropositions to Boolean expressions of subpropositions, and su-percommitments to serial compositions of chains of subcommitments.

Mallya and Singh [2007] propose a definition of protocol refinement (which they call subsumption) that compares the order of state pairs in state runs. For every pair of states in the superprotocol run, there must be some matching pair of states in the when multiple state pairs in the super-run each match the same state pair in the subrun or when one superstate matches different substates. For example, all state pairs in the super-run 1 , 2 , 3 have matching state pairs in the subrun 2 though the two runs are very different. Our definition compares runs step-by-step and thereby avoids the aforesaid problems, even if protocol looping is allowed.
Our definition of commitment covering is an extension of commitment strength as defined by Chopra and Singh [2009], who identify the basic requirements in Eqs. (7) and (8). We extend Chopra and Singh X  X  [2009] definition with the role requirements in Eqs. (5) and (6), and we allow commitments to be at different levels of abstraction by including an abstraction mapping function.

Singh [2008] states rules for commitment chaining similar to those proposed here, a rule similar to serial composition. The concrete commitment created by serial com-position provides a midpoint in commitment reasoning, and can potentially make the comparison of commitments across protocols more explicit.

When we say a group of debtors are jointly and severally responsible for eventu-ally making the consequent true, we mean this in the sense of Rescher X  X  [1998] legal responsibility where  X  X ndividual agents are responsible only for their own individual acts. X  We do not mean Rescher X  X  [1998] notion of legal responsibility where the group as a whole becomes a legal person, nor his notion of moral responsibility where inten-tions are crucial (intentions are absent from our formulation). In Norman and Reed as a collective. In both cases, group imperatives imply more than just a collection of and does not impose additional responsibilities on roles that are members of a group.
Our work on protocols builds on the fundamental intuition that protocol states can be effectively characterized in terms of the commitments of the participants, and that soning. The earliest works that developed the preceding theme include the commitment machines approach of Yolum and Singh [2002] for business protocols and McBurney and Parsons X  [2002] framework for sequencing multiple dialog games, allowing one dialog game to be embedded inside another partially completed dialog game.
We do not propose specific, desirable properties of protocols, but others have. Yolum [2007], Singh and Chopra [2010], and El-Menshawy et al. [2010] describe desirable properties of protocols in general and commitment protocols in particular, including fairness, safety, liveness, operability, and transparency.
 We use Boolean guards to constrain actions, but other representations are possible. specifications constrain the execution flow using special-purpose operators on state values. Gabbay [1987] proposes using past-temporal expressions for controlling when actions can occur and future-temporal expressions for controlling which actions must occur in the future. Past-temporal expressions are more expressive than our guard expressions. Constructing a mapping function from a superprotocol to a subprotocol can be a challenging task. Advice to guide protocol designers, in the form of a basic mapping methodology, would be a valuable addition to this work. Winikoff [2006, 2007] proposed a methodology for the related task of designing commitment-based protocols. Some of these ideas could be valuably adapted into a future commitment mapping methodology. The approach begins with an easily understood, but not exhaustive, set of sequence diagrams, and then specifies specific steps to generalize the protocol and expand its set of runs.
 Our model and formulation of refinement respects intuitions similar to those of Mallya and Singh [2007]. Mallya and Singh describe protocol composition and establish in our framework, and plan to formalize and reason about composition in future work.
Model checkers have been extended to handle epistemic and strategic modal oper-ators [Alur et al. 2002; Fagin et al. 1995]. We have begun investigating the inclusion of such concepts into our definitions. Building on top of a model checker that already handles these concepts, such as MCMAS, will simplify our future extensions. Another important enhancement would be to expand the class of protocols to those that support iteration.

