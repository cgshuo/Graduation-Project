 As huge amount of XML (eXtensible Markup Language) data emerge rapidly, the use of XML is not limited to interpret and operate the documents from the Web. How to effectively store and query these XML documents becomes an important issue. A number of query languages have been proposed for querying XML documents, e.g., Lore[1], XML-QL[2], XPath[3], XQuery[4], and so on. One of their core techniques in modes to implement structure query of XML. Series of XML coding schemes have been brought forward for the query esp. structure query of XML documents [5]. Instead of traversing the whole original document, each node in the document tree is assigned a nodes and attribute nodes in the tree can be worked out directly. Therefore, query of XML can be converted to structure join by coding schemes. 
However, there are problems with these recently suggested XML coding schemes: either some of them do not support update of XML documents, which means that it has to recode again whenever XML documents change, or need huge storage. Therefore, in this paper a new update-supporting coding scheme based on binary-tree for XML documents is proposed. It not only efficiently figures out relationship of two elements, effectively. 
In brief, the major contributions of our BBTC work are as follows: 
This paper is organized as follows: section 2 introduces and analyzes related researches on XML coding techniques; in section 3, our coding scheme is addressed in details; in section 4, a hierarchical storage method based on the binary-tree, BBTC , is introduced, whose average code length is O(log(n)); in section 5, experimental analysis of our coding scheme is presented with comparisons to other existing coding schemes; a conclusion of XML coding schemes is addressed in section 6. Various kinds of coding schemes have been proposed for query processing of XML documents. Among those, a number of methods that code nodes in XML document trees construct the mainstream. And all the existing coding schemes fall into two main classes: (1) coding based on region and (2) coding based on path. Making use of the order characteristic of XML documents, the first class assigns each node a code according to its document order in the orig inal document; meanwhile, the second class focuses on the nested characteristic of XML documents, allocating a code to each path and each node which can be reached from the root of the tree. At present, coding based on region takes priority. 
Region code is one of the most popular among coding schemes. Its main idea is to assign a region code [ start , end ] to each node in the XML document tree, satisfying that a node X  X  region code contains all of its descendants X  codes. That is, node (u) is the was proposed in reference [6]. Li et al proposed the Li-Moon (XISS) coding scheme in reference [7]. Zhang et al proposed the Zhang coding scheme in reference [8]. Wan et al proposed the Wan coding scheme in reference [9]. The ideas in [6], [7], [8] and [9] are basically the same. They estimate relationship between nodes according to their region information. One of their advantages is that they are relatively simple, and the average differentiating the ancestor-descendant and parent-child relationships. A disadvantage is that complex operation, instead of equal-value estimation, is used when deciding the relationship between nodes, which means that if there are many nodes, it is not easy to decide relationship among them. Moreover, these methods cannot support XML documents update well. Some researches [9, 10, 11] have proposed a solution which pre-order traversal number so that extra space can be preserved to support future update operations. But it is difficult to decide how much space the preservation is to make, and when the preserved space is used up, the XML document has to be recoded again. 
Bit-vector coding scheme is proposed in reference [12]. Each node in the XML method can easily work out the ancestor-descendant relationship but needs O(n) code reference [13]. It directly uses code of the parent node as the prefix of the child node, which is like catalogue of a book. Since this method needs to employ the prefix when method can support the update operation. Wang et al proposed the PBiTree coding computer implementation. The main differen ce from our approach is that, it does not support the update operation and involves large storage. The coding scheme for XML documents is important for structure query, but current coding schemes have such problems that either they are disadvantageous for updating XML documents or their coding space is too large. This paper proposes a new update-supporting coding scheme which can solve these problems properly. 3.1 Coding Scheme and Algorithm position information of a node in the XML document tree, and sibling_order means the sequential number of a node among its sibling nodes. Thus query of sibling relationship is effectively supported. The method to code XML documents is: the order nodes X  order multiplying 2 plus 1,and sibling_order are their left neighboring sibling nodes X  sibling_order plus 1( order of the root is 1, sibling_order is 0). document tree. A simple example (Fig.1.) below gives more details (codes of all TEXT_NODEs are omitted). 3.2 Properties of the New Coding Scheme 3.2.1 Rules to Infer the Relationship Between Two Elements We can infer the relationship between any two elements by making use of properties of the new coding scheme through simple operations. The rules for deciding the relationship between two elements are: means shift rightward. 3.2.2 Advantages of Our Coding Scheme (1) Only shift and add operations are needed (r efer to section 3.2.1) when inferring the ancestor-descendant or parent-child relationships between two elements. For instance, if we want to identify the relationship between /Bookset/Book[1] ( order is 2) and /Bookset//Degree (1 st order is 37,2 nd is 85) in bookset.xml, (see also Fig.1. in section (2) Equal-value inference is employed when deciding the ancestor-descendant join operation of massive nodes. contains such information (refer to rule 1 in section 3.2.1). (4) It is advantageous to get the sequential number of a given node among its sibling document. In addition, s ibling_order is also in favor of update, we will introduce how to process our codes when update in next section. 3.3 Updating of XML Documents According to the basic idea, when using the new coding scheme, there is no need to recode the XML document again but only some simple processes based on existing codes when updating the XML document. The following segments about XUpdate X  X  examples are cited from the web site, http://xmldb-org.sourceforge.net/xupdate/. 3.3.1 Insert Operation There are two cases of the insert operation. Th e first case is to insert a node as sibling node of a certain node with an appointed position. e.g.: The above example means: to insert Sex information to the first Author of the first (represented as N ) whose code is &lt;N.order, N.sibling_order&gt; and its sibling node NR with the maximal order code, then insert the new node with code as ( NR.order *2+1, N.sibling_order ). At last, increase sibling_order of all sibling nodes of N (including N itself) whose sibling_order  X  X  values are not less than N.sibling_order by one. In the code of &lt; Degree &gt; changing into (37, 2). 
The second case is to add a node as a child node of a certain node but not appointing sequence among its siblings. e.g.: the maximal order code and last child node NS with the maximal sibling_order code, then insert the new node accordingly. The code of the new node can be computed by ( NR.orde r*2+1, NS.sibling_order +1). In the above example, &lt; Author &gt; node(19*2+1, new node into an XML document tree is omitted due to the space limited. 3.3.2 Delete Operation code of this node needs to be removed, and decrease the sibling_order of &lt;Name&gt; X  X  sibling nodes whose sibling_order is greater than Name.sibling_order by one. 3.3.3 Update Operation 
This example tends to change the Author name of the second Book . There is no need to change the code but simply change this node X  X  value. 
The above three sections present the new update-supporting coding scheme and its properties. How to infer the ancestor-descendant relationship also has been covered. In addition, we point out the advantages of this coding scheme and present some necessary but simple processes needed to be carried out when updating XML documents. The only disadvantage of the scheme is that it needs relatively large coding space. Hence, we will explain how to solve the problems. General XML document trees are not regular, but the binary tree has such advantages that they are hierarchical and easy to stor e, therefore general XML document trees need to be converted to ordered binary trees in order to use these advantages. 4.1 Conversion from XML Document Tree to Binary-Tree Let T be an XML document tree and BT be the correspondent converted binary tree, the corresponding conversion rules are as follows: (1) A T, if A root _ of (T) then A root _ of (BT)  X = = (2) A, D T, if D first _ child _ of (A) then D left _ child _ of (A) in BT  X  X  = = 4.2 Coding Method of Binary-Tree The binary-tree coding method makes us e of order characteristics of the XML document tree, and it codes nodes according to their positions in the complete binary tree. The detailed coding method is as follows: (1) root _ of (BT).order 1 = (2) D1, D 2, A BT  X  X 
The coding method of the binary-tree is identical with Algorithm 1 in section 3.1, we can obviously draw the conclusion from Fig. 2. 4.3 Storage Strategy coding space, we have to solve this issue. There are two feasible ways to solve it: Compression: Due to properties of binary-tree, the adjacent codes have strong similarity in that they have the same ancestor nodes. Therefore, many nodes have the same prefix, i.e., there is great redundancy in the codes. In other words, much work can be done using data compression. storage method to process these codes. In other words, we could partition the Binary-tree into different sub-blocks with nodes in each sub-block have the same sub-block. In other words, common information of a sub-block is stored in its header so that the storage space can be reduced. 
Obviously, compression of codes will reduce the storage space greatly. However compression itself and decompression will undoubtedly require extra time spending when inserting a new node. Performance of query processing is affected accordingly. Therefore, we use the hierarchical method to store codes. 4.4 BBTC Problems must to be settled when partitioning the binary-tree are, how big a sub-block should be and what structural relationship should be maintained between sub-blocks. The scale of a sub-block directly affects performance of storage. If a sub-block is too redundancy in each sub-block. Before we introduce hierarchical storage in detail, present these following definitions: Definition 1. Non-trivial leaf node If node N is a leaf node of a sub-block but not a leaf node of the whole binary tree, it is called a non-trivial leaf node. Definition 2. Non-trivial root node If node N is the root node of a sub-block but not the root of the whole binary tree, it is called a non-trivial root node. Definition 3. Inner node All nodes in each sub-block, are called this sub-block X  X  inner nodes. 4.4.1 Division of the Storage Structure and Sub-block Due to properties of the binary-tree, some descendent nodes store information of their ancestors repeatedly. Therefore, we coul d employ hierarchical storage method to sub-blocks with nodes in each sub-block having the same ancestor, and then code each node relative to the ancestor in each sub-block. Therefore, common information of a sub-block is stored in its header so that the storage space can be reduced, and we call it Blocked Binary-Tree Coding scheme ( BBTC ). The common prefix called BlockID sub-block, which is also the height of a sub-block. 
The header information of a whole block is not only helpful for inferring ancestor-descendant relationship but also avoids searching between sub-blocks. Steps for partitioning sub-blocks are: the root of the binary tree. less than B into this sub-block. Suppose that the IID of N A is C, and the BID of this sub-block which N A belongs to is D, then the BID of the new block rooted at N D can be computed by formula 1 : (3) The IID of each sub-block X  X  root is always 1, and then code other inner nodes in each sub-block using the method in section 3.1 or 4.2. 4.4.2 Example node X  X  order code in its original XML document through its IID in the sub-block and its BID . Suppose that one node with IID is C and BID is D, we can compute its order
For example, the node with IID is and BID is 10, so in the original XML document tree, its code is (10-1)*2 2 +7=43. 
Thus, we can compute the original order code of one node in original XML document tree, and then infer whether two nodes have the ancestor-descendant relationship or not. However, we do not really need these somewhat complicated identify relationship between them. Next section we will list the determining rules. 4.4.3 Decision of Relationship Between Nodes in Sub-blocks There are two definitions to make before we give the rules. Definition 4. Sibling sub-blocks Given two different sub-blocks, suppose that their BIDs are B1 and B2 respectively, if B1 and B2 satisfy Definition 5. Collateral sub-blocks Given two different sub-blocks, suppose that their BIDs are B1 and B2 respectively, if section 3.2.1, then these two sub-blocks are called collateral sub-blocks. (i.e., if B1 is ancestor-descendant relationship.) 
Rules for inferring two nodes X  relationship by their IIDs and BIDs in sub-blocks: (1) If the two nodes have the same BID , then use rules in section 3.2.1 to judge their (3) Otherwise, suppose IIDs are C1 and C2 respectively and their BIDs are D1 and between any two nodes. For instance, we infer the relationship between node 3(9) in IID =3, and so on). Since 9 and 85 have no ancestor-descendant relationship, therefore, ancestor-descendant relationship. Then we infer the relationship between node 3(10) in sub-block 10 and node 1(85) in sub-block 85. Since 10 is the ancestor of 85, so judging relationship between (10-1)*2+3=21 and 85. We conclude that these two nodes are 4(layer(1)+layer(85))-1= 1+4-1=4), so they are also parent-child relationship. 4.5 Processing of the Insert Operation When updating XML documents, the update and delete operations can be carried out cost. If the parent node of the insert node is a non-trivial leaf node of a sub-block, we construct a new sub-block taking it as the root of this sub-block and calculate its BID by formula 1, and its IID =1, then modify sibling_order according to the section 3.3. Or otherwise, the new node should be inserted into the sub-block in which its parent node is according to the section 3.3. Currently, there are mainly Region Code, Bit-Vector Code, Prefix Code and PBiTree for coding XML documents, however Region Code is the most popular presently, therefore we compare BBTC with it. BBTC rapidly infers the ancestor-descendant relationship, reduces the average code length to O(log(n)) and supports update XMark and Shakespeare data to test our approach in space performance and time performance. XMark was generated from st andard data [15] and Shakespeare used standard Shakespeare 2.00 data [16]. The experimental environment is: windows 2000 server, AMD2600 CPU, 1G RAM. We used standard C++ for programming. 5.1 Experiment 1: To Determine Value of B in BBTC present the space of the BBTC consumed with different values of B for various XML data sets. Due to the lowest point of each curve corresponding to the minimum space cost, the value of B at this point is its best choice. On the one hand, the curves with block-partitioning have observable advantages in storage size, but the stability of space cost with different values of B is another advantage revealed. 
In Fig.5. (a) and (b) illustrate the effect of different values of B on space performance for Shakespeare and XMark data sets respectively. They present the space of the BBTC consumed with different XML documents for various values of B. Obviously, the cost of space is evidently reduced with BBTC . Compare with Non-block, BBTC reduces 30% in Shakespeare data, but it reduces 73% in XMark data. 
We concluded from our analysis that the best B value has to do with the height of the binary tree converted from the XML document tr ee. And it is also related to the number of nodes in the XML document. Fig.6. indicates the relation between the best B and the number of nodes in the XML document. Due to the relation between the best B and the number of nodes meets logarithmic normal distribution, we make a conclusion that the best B for one XML document can be represented by log(n) approximately, in which n is the number of nodes in the XML document. 5.2 Experiment 2: Comparison of Several Coding Algorithms BBTC has superior storage performance to the Region Code, this is because the Region Code maintains two numbers for one region and its performance decreases. The Region Code is not as good as the BBTC in time performance either, since it has to scan the XML documents at least twice. 
We compared the BBTC to Dietz and Zhang Code experimentally. The data sets are coding schemes in space and time respectively. Compare with Region Code, BBTC reduces 16% in space and 25% in time with Shakespeare data, and reduces 8% in space and 40% in time with XMark data when its size of the data reaches 45.3M. In this paper, we propose the new update-supporting coding scheme based on binary-tree, which not only codes the XML document and infers relationship between nodes rapidly, but also solves the problem of those previous schemes that documents have to be recoded again when update. A hierarchical storage method, BBTC , is also presented, which can reduce the average code length to O(log(n)). Experiments have proved that BBTC has relatively strong query processing ability than na X ve ones. 
