 1. Introduction
In most public-key cryptosystems such as Rivest-Shamir-Adleman
ElGamal ( ElGamal, 1985 ), Digital Signature Algorithm (DSA) ( Ryabko and Fionov, 2005 ) and others, modular exponentiation or fi exponentiation is used in the process of data encryption and decry-ption. Modular exponentiation consists of calculating a natural exponentiation and then computing the modulus on a number p ( Bola X os and Bernal, 2008 )asfollows: b a e mod p  X  1  X  where a is a positive integer in range [0, 1, 2, ... , p 1], e is an arbitrary positive number, and p is a prime number.

The main bene fi t of modular exponentiation in cryptography is the use of very large exponents up to 1024 bits. However, the forlargerexponents.Therearetwomainwaystodealwithsuch problem: (1) to increase the speed of the operation by means of distributed or parallel computing with high-speed processors, or (2) to reduce the number of multiplications required to compute the exponentiation operation. This work focuses on the second way to decrease the computational co st of exponentiation, speci using addition chains ( Wu et al., 2006 ).
 positive integers U  X  u 1 ; u 2 ; ... ; u i ; ... ; u l where u two previous elements in the chain (not necessarily different) u i  X  u j  X  u k where j , k o i for i 4 2.
 sequence of numbers that satis fi es the following properties: rules of exponents, to reduce the number of multiplications in an exponentiation operation. As an example, to compute a 77 ,77 multiplications are originally required. Instead, with the following
AC:  X  1 -2 -4 -5 -9 -18 -36 -72 -77 it can be accomplished with only 8 multiplications, as follows: a -a 2  X  a a -a 4  X  a 2 a 2 -a 5 for an exponentiation operation. However, for a single exponent e different ACs can be generated. Furthermore, fi nding an AC with minimal length is considered an NP-Hard problem ( Bos and Coster, 1990; Kaya-Koc, 1994 ).

A particular type of addition chain is the Euclidean addition chain (EAC), where doubling of numbers is not allowed, i.e., a number within the EAC comes from the sum of two previous and different numbers. See Fig. 1 for a graphical example of the difference between an AC and an EAC.

EACs are useful in data encryption and decryption processes in public-key cryptosystems because they help to prevent diverse types of attacks, such as side channel attacks (e.g., simple power attacks ( Fumaroli and Vigilant, 2006; Joye, 2009; Lawson, 2009; Quisquater and Koene, 2002; Herbaut et al., 2010 ).

The methods to fi nd minimal length ACs can be roughly divided into: (1) deterministic and (2) stochastic approaches ( Cruz-Cort X s et al., 2008 ).

Among the most popular deterministic methods there are the following: The binary method consists of strategies which expand the exponent e to its binary representation. The binary chain is scanned bit by bit from left to right. For each bit scanned, the it is then added to the current value of the AC. This process is repeated until all the binary strings are covered. The binary method works with the Hamming weight of e ( Kaya-Koc, 1994; Van-Der Kruijssen, 2007 ).

Thefactormethodisbasedonthefactoringinthemultiplic-integers is constructed, in which for each parent node n ,thechild nodes are the factoring of n . The construction of the tree ends when child nodes have a value of 1. The second stage of the method consists of traversing the tree to build the AC. Further explanations can be found in Knuth (1981) , Van-Der Kruijssen (2007) .
The window method is based on k-ary expansion of the expon-ent e , where exponent bits are divided into k -bit words or windows ( Kunihiro and Yamamoto, 1998 ). Each window has a maximum length by performing consecutive squarings and a subsequent multiplication as needed. For k  X  1, 2, 3 and 4 the window method is called, binary, quaternary, octary and hexa exponentiation method, respectively. A more detailed explanation can be found in Kaya-Koc (1994) .
The sliding window method (SWM) signi fi cantly outperforms the window method mentioned before and it is useful for very large exponents. SWM splits the exponent e in zero and non-zero windows. This window separation streamlines the ACs generation as indicated by Kaya-Koc (1994) .

On the other hand, there are recen t research works on stochastic methods to fi nd minimal length ACs. Three different nature-inspired techniques are distinguished: (1) swarm intelligence, (2) arti immune system (AIS) and (3) genetic algorithm (GA). They are described below.

In Nedjah and de Macedo-Mourelle (2006) ,theauthorsadapted the Ant Colony Optimization (ACO) ( Dorigo et al., 1996 )togenerate short ACs. ACO is based on a multi-agent schema, where each agent represents an ant. To improve ACO's capabilities on this particular problem, two types of memories were added to the approach: shared memory and local memory. Only a few exponents were tested in this approach.

Particle Swarm Optimization (PSO) was also used to fi nd min-2009 ). Each particle represented an AC and the velocity vector was transformed into a velocity chain, where the value at each position in that vector represented the preceding value used to generate each number in the particle, i.e., the AC.

The Arti fi cial Immune System (AIS) was modi fi ed in Cruz-Cort X s et al. (2008) to deal with ACs. AIS algorithm emulates the pattern matching abilities between antibodies and antigens and the emer-solutions, i.e., those shorter ACs, are cloned and then mutated.
The use of GAs has been also reported in the length minimiza-tion of addition chains. In Cruz-Cort X s et al. (2005) one-point crossover and uniform mutation were employed, while in Osorio-Hern X ndez et al. (2009) two-point crossover, a local-search mutation operator and a repair mechanism used in the initialization of the population were joined in a GA. The second version ( Osorio-Hern X ndez et al., 2009 ) outperformed the results of the fi rst one ( Cruz-Cort X s et al., 2005 ). Moreover, Rodriguez-Cristerna and Torres-Jimenez (2013) proposed a GA which includes a representation based on the factorial number system, a blend of neighborhood functions and a blend of distribution functions. The approach was not tested with large exponents.

The literature review above shows that, besides deterministic methods, nature-inspired algorithms have been adapted to fi minimal length ACs. However, there are other evolutionary algo-rithms which remain unexplored. This is the main motivation of this work, where evolutionary programming (EP) is adapted to fi nd ACs with minimal length.

EP is attractive for different reasons: (1) It is a very simple evolutionary algorithm because it only uses mutation as a varia-tion operator to generate new individuals (solutions of the prob-lem being solved). Moreover, it usually does not require a parent selection mechanism, i.e., all individuals generate offspring. Finally, its replacement mechanism is very simple to implement.
A suitable solution encoding and fi tness function, an adequate initial population generation mechanism, a special mutation opera-tor, and a replacement mechanism to favor diversity in the popula-tionareaddedtoEPtotackletheminimallengthACproblem.The proposed algorithm is tested on sets of exponents with different features (including EACs) and it is also hybridized with the sliding window method to solve the problem with larger exponents.
The contents of this paper are organized as follows: in Section 2 the EP algorithm is introduced while in Section 3 the adapted EP to deal with ACs is presented. Section 4 includes the experimental design, the results obtained and the corresponding discussion. After that, Section 5 covers the combination of the proposed algorithm with a deterministic method to deal with large expo-nents and the corresponding experiment is carried out. Finally, in Section 6 some conclusions are drawn and the future work is established. 2. Evolutionary programming
EP was proposed by Fogel in 1960 to optimize fi nite state machines, where the inheritance re lationship and behavior between parents and offspring was highlighted ( Fogel, 1999 ). Adaptation in this EA is conceived as a kind of intelligence. EP simulates the evolution at species level. Therefore, no crossover operator is em-ployed.

The individual, i.e., a potential solution of the optimization problem, is the main element in EP, and a population of individuals, as in other EAs, is considered as the starting point in the optimiza-tion process. Each individual uses the mutation operator to generate are able to reproduce with an asexual variation operator.
Instead of the parent selection, the replacement process (sur-vivor selection) is implemented in EP to bias the search to promising regions of the search space. However, this process has stochastic elements. The replacement is implemented by means of stochastic encounters among the individuals in the current popu-lation and their corresponding offspring. Each individual competes in a binary tournament against q individuals chosen at random from the combination of the current population and their off-spring. The number of wins is stored for each individual. After that, all the solutions are sorted by their number of wins and the half is chosen to survive to the next generation and the other half is eliminated.

The aforementioned replacement process aims to promote diversity in the population because some solutions with an average fi tness value are able to get a signi fi cant number of wins if the encounters are with below-average solutions. Furthermore, another attractive feature found in EP is that only one variation operator is used to generate new solutions.
 An EP general pseudocode is presented in Algorithm 1 .
Algorithm 1. EP algorithm 1: Randomly generate an initial population of individuals. 2: Calculate the fi tness of each individual in the initial 3: while a stop condition is not satis fi ed do 4: Apply mutation to each individual in the population to 5: Calculate the fi tness of each offspring. 6: Select (using stochastic encounters) from the union of the 7: end while 3. Proposed approach The adapted EP version to fi nd minimal ACs (ACEP for Addition
Chain Evolutionary Programming) has four parts: (1) solution encoding and fi tness function, (2) initial population generation, (3) a special variation operator, and (4) a replacement mechanism.
In this section we describe the above mentioned parts. 3.1. Solution encoding and fi tness function
Like in other nature-inspired algorithms which solve the AC length minimization problem ( Cruz-Cort X s et al., 2008; Le X n-Javier et al., 2009; Osorio-Hern X ndez et al., 2009 ) in the proposed algorithm an individual is represented at genotype level, i.e., an individual consists of an array of integer numbers representing an the number of elements in the array. Therefore, shorter arrays are preferred. Both features are summarized in Fig. 2 . 3.2. Initial population
With the aim to keep the ACEP search within the feasible region of the search space, the initial population must contain only valid ACs. Therefore, inspired by ( Osorio-Hern X ndez et al., 2009 ), each AC in the initial population is generated by considering the following three strategies: 1. Applying the double stepping, that is: u i  X  2u i 1 . 2. Adding the two previous elements u i  X  u i 1  X  u i 2 . 3. Adding the last element plus a randomly chosen element maintained. The general process is described in Algorithm 2 , where the fi rst two elements within any feasible AC U are number 1 followed by number 2 and the third element can be 3 or 4, chosen at random. After that, a function called Complete is inv-oked. This function precisely picks, based on two parameters called f and g , among the three strategies listed above.
Flip ( prob ) returns 1 with probability prob . To generate an Eucli-dean addition chain (EAC), the parameter double stepping rate f , which indicates the probability of applying the double stepping when generating an AC, as indicated in item 1 in the list above, must be zero.
 Algorithm 2. Feasible_chain( e ) the AC U from surpassing the value of exponent e . Unlike other options proposed in previous approaches ( Cruz-Cort X s et al., 2008;
Osorio-Hern X ndez et al., 2009 ), where random values are consid-ered, in this work the search for the feasible term starts in a deterministic way from the previous position u i 1 stored in a variable called aux .
 Algorithm 3. Complete( U , k , e ) 10: end if 11: end if 12: while u i  X  1 4 e do 13: aux  X  i 1 15: aux  X  aux 1 16: end while 17: end while 18: return U 3.3. Variation operator
As mentioned in Section 2 , in EP each individual in the population offspring. On the other hand, previous works on minimal length AC optimization using nature-inspired algorithms suggest that each individual must generate more than one offspring ( Cruz-Cort X s et al., 2005, 2008; Osorio-Hern X ndez et al., 2009 ). Therefore, with the goal to get a good trade-off between multiple offspring and the one usually needed in EP, the following mutation operator is used ( Osorio-Hern X ndez et al., 2009 ): Each individual (AC) U generates a mutant by choosing a mutation position at random within the AC, quent elements of U are eliminated and the function Complete is invoked to generate a new feasible addition chain. This process is repeated t times. Finally, from the t mutants generated from U ,the ones at random. The process is depicted in Fig. 3 anddetailedin Algorithm 4 .

This variation operator is different from previous proposals because function Complete works in a different way as explained in the search made by ACEP is always maintained in the feasible region of the search space.
 Algorithm 4. Mutation( U ) Require: A feasible addition chain U
Ensure: Its corresponding offspring U 0 1: Generate ( t ) copies of individual U , called C 1 ; C 2: Generate a mutation point i  X  rnd  X  3 ; U l  X  3: for k  X  1to t do 4: Elements 1 to i 1 remain intact in C k 5: Complete  X  C k ; i ; e  X  6: end for name it U 0 8: return U 0 3.4. Replacement mechanism
The stochastic encounters to choose the individuals to remain for the next generation between the current population and their offspring are implemented by considering the following: 1. Both, current solutions and offspring are merged into one set 2. A win counter is associated with each individual in the set 3. Each individual in the set competes against q randomly chosen individuals from the set in head-to-head encounters. 4. The length of each individual, i.e., its fi tness, will be the comparison criterion in each encounter. 5. The win counter is increased by one each time the individual is better than one of the q individuals chosen at random. 6. After each individual has passed through the q encounters and its win counter is updated, all individuals in the set are sorted based on their number of wins and the fi rst half remains for the next generation while the second half is eliminated from the process.
 Algorithm 5. Replacement(Set)
Require: A Set with the combination of the n individuals in the
Ensure: The population for the next generation Pop 0 with size n . 1: for j  X  1to  X  2 n n  X  do 2: wins j  X  0 3: for k  X  1to q do 4: i  X  rnd  X  1 ; 2 n n  X  5: if Length  X  Set j  X  o Length  X  Set i  X  then 7: end if 8: end for 9: end for 10: Sort Set based on wins values 11: for j  X  1to n do 12: Pop 0 j  X  Set j 13: end for 14: return Pop 0 The pseudocode of the replacement process is presented in Algorithm 5 , where the stochastic encounters are expected to help below-average-fi tness solutions to remain in the population for the next generation as well as those high-fi tness solutions. In other words, diversity may be maintained so as to fi nd better results. Algorithm 6 shows the pseudocode of the proposed ACEP. Algorithm 6. ACEP( e ) Require: An exponent e
Ensure: A quasi-optimal Addition Chain U 1: Pop  X   X  2: for j  X  0to n do 3: Pop j  X  Feasible_chain( e ) 4: end for 5: for k  X  0to MAXGEN do 6: Offspring  X   X  7: for m  X  0to n do 8: Offspring m  X  Mutation(Pop m ) 9: end for 10: Pop 0  X  Replacement  X  Pop  X  Offspring  X  11: Pop  X  Pop 0 4. Experiments and results Four experiments were designed to test the performance of
ACEP. Different types of exponents, labeled as  X  small  X  ,  X  diverse  X  exponents (up to 64 bits) were used in the fi rst three experiments, respectively. The fourth experiment was designed to test ACEP on EACs.

The parameters setting for ACEP was de fi ned as follows. As a starting point the values suggested in Osorio-Hern X ndez et al. (2009) were adopted. It was observed that ACEP was able to obtain better results with a lower number of evaluations, then the population size and the maximum number of generations were decreased. The number of individuals for the enco unters (10% of the population size) was kept as suggested for evolutionary programming ( Fogel, 1999 ). The complete set of parameter values is the following: Population size n  X  100 Maximum number of generations MAXGEN  X  230 Number of mutants per individual t  X  4 Number of individuals for the encounters q  X  10
Double stepping rate f  X  0.7 ( f  X  0 was used in the fourth experiment).
 Previous positions rate g  X  0.2
Based on the aforementioned parameter values, ACEP com-putes 92,000 evaluations per run ( n t MAXGEN). MAXGEN and t were modi fi ed in some experiments (as pointed out later in the corresponding subsection) with the aim to test ACEP with a lower number of evaluations.

In all experiments, depending on the type of exponent treated, the results are presented in the same format as they are presented in the specialized literature ( Cruz-Cort X s et al., 2008; Le X n-Javier et al., 2009; Osorio-Hern X ndez et al., 2009 ). 4.1. Experiment on small exponents
The fi rst experiment consisted in calculating the total accumu-lated addition chains for a fi xed set of  X  small  X  exponents. An accumulated addition chain ( T ) for a maximum value Z , represents the sum of all lengths of the addition chains obtained for all the exponents [1, 2, ... , Z ], as stated in the following equation:
T  X  Z  X  X   X  Z where minimal_addition_chain(i) is the length of addition chain i (2009) , Osorio-Hern X ndez et al. (2009) , the following intervals for exponent e were tested: e A  X  1 ; 512 , e A  X  1 ; 1000 , e exponent set were computed. The parameters values adopted by ACEP were those detailed at the beginning of this section. those reported by an adapted AIS ( Cruz-Cort X s et al., 2008 ), a GA ( Osorio-Hern X ndez et al., 2009 ), and by PSO ( Le X n-Javier et al., 2009 ) is presented in Table 1 , where the t-test was used to provide statistical con fi dence to such results based on the mean and standard deviation values found by each algorithm.
 better best, mean and standard deviation values) in three out of six sets of exponents (second, third and fi fth sets). In the fourth set both, ACEP and GA, obtained the same best result but ACEP obtained better mean and standard deviation values. In the set the GA performed slightly better than ACEP, and in the sixth set the GA outperformed all the compared algorithms.
 competitive performance with respect to stochastic state-of-the-art algorithms. Another advantage of ACEP with respect to the GA is that the proposed algorithm required 92,000 evaluations, while the GA and the PSO computed 240,000 and 300,000, respectively. The AIS algorithm did not report the evaluations performed.
ACEP performing 240,000 evaluations ( n  X  200 and MAXGEN  X  300) are presented. It can be noticed that ACEP outperformed the compared algorithms in all six sets of exponents.
 4.2. Experiment on hard exponents
The second experiment included a set of exponents known as  X  hard  X  to optimize because deterministic methods usually fail to obtain their minimal length AC ( Cruz-Cort X s et al., 2008 ). A comparison of best results obtained by ACEP in 30 independent runs with respect to those found by the GA in Osorio-Hern X ndez et al. (2009) in 20 different  X  hard  X  exponents is presented in
Tables 3 and 4 . The obtained AC by ACEP is also showed in all cases. The parameter values used by ACEP in this second experi-ment were the same reported in the fi rst experiment. The other et al., 2009 ), did not report the solution of such exponents.
The results in Tables 3 and 4 show that ACEP and the GA obtained the same result in the 20 exponents. Wilcoxon tests showed no signi fi cant differences between the two algorithms.
However, it is important to highlight that ACEP required 92,000 evaluations while the GA used 240,000 to reach such results. In fact, ACEP was further tested with only 25,000 evaluations and the same results were obtained in 11 out of 20 exponents and in the remaining nine exponents, addition chains with a length of 28 were found. 4.3. Experiment on diverse exponents
In the third experiment, another set of 28  X  diverse  X  exponents was solved by ACEP and the results were compared with those obtained by the modi fi ed AIS ( Cruz-Cort X s et al., 2008 ) and PSO ( Le X n-Javier et al., 2009 ). The GA was not considered in this comparison because no results were found for this set of expo-nents. The best results found by the three algorithms in 30 independent runs and the addition chain found by ACEP are presented in Tables 5 and 6 . The parameter values used by ACEP were the same adopted in the fi rst experiment with the exception of MAX _ GEN and t , whose values were 250 and 1, respectively.
Therefore, ACEP required only 25,000 evaluations to solve this set of exponents.

The results in Tables 5 and 6 indicate that ACEP reached the same results found by AIS and PSO in 27 out of 28 exponents.
Wilcoxon tests con fi rmed such fi ndings. Furthermore, in one of them (3585), ACEP outperformed the other two algorithms. It is worth reminding that PSO used 300,000 evaluations, while ACEP required only 25,000 evaluations. 4.4. Experiment on Euclidean addition chains
In the fourth experiment, the set of  X  diverse  X  exponents was solved again with ACEP but this time Euclidean addition chains were generated. To the best of the authors' knowledge, this is the fi rst time a method based on a nature-inspired algorithm presents results for Euclidean ACs. The parameter values used in this experiment were the same as those reported in experiment 1, except for the f parameter, which took a value of zero so as to keep the ACs from doublings, and g , which was assigned a value of 0.7. Therefore, 92,000 evaluations per run were computed. The best results obtained by ACEP in 30 independent runs are reported in Tables 7 and 8 . No comparison was made due to the lack of results for EACs by other nature-inspired methods. It is interesting to note that, for the larger  X  diverse  X  exponents, the EACs have a length up to six more elements than their traditional AC counterparts. 5. ACEP for large exponents
Based on the literature review on stochastic methods to fi minimal length ACs ( Cruz-Cort X s et al., 2008; Le X n-Javier et al., 2009; Osorio-Hern X ndez et al., 2009 ), they do not provide a competitive performance by themselves when solving large expo-nents. This has been con fi rmed in preliminary experiments with ACEP.

Nevertheless, the combination of a nature-inspired algorithm with a deterministic method to deal with large exponents has been reported as a competitive approach. This is the case of the sliding window method (SWM) and the arti fi cial immune system (AIS) in Cruz-Cort X s et al. (2008) .

The sliding window method (SWM) uses the binary represen-into zero and non-zero windows or words of variable length. The partitioning process is shown in Fig. 4 .
 The complete pseudocode of the SWM is presented in Algorithm 7 . sequence of integer numbers from 1 to 2 k 1, where k is the maximum size of a window. However an improved version proposed in Bos and Coster (1990) considered the usage of addition sequences instead of the simple sequence of numbers. This imp-roved version, as indicated in Algorithm 7 ,isusedinthiswork.
An addition sequence for a set of given numbers  X  n 0 ; n is a list of numbers that satis fi es the properties of an addition chain, with the particularity that the given numbers occur in such sequence ( Bos and Coster, 1990 ). For example, for the next sets of numbers: [13, 35, 89, 97] a possible addition sequence can be;  X  1 ; 2 ; 3 ; 5 ; 8 ; 13 ; 16 ; 19 ; 35 ; 54 ; 89 ; 97 .
 Algorithm 7. Sliding Window Method using addition sequences Require: Integer e  X  X  e m 1 ... e 1 e 0  X 
Ensure: Addition Chain U  X  X  1 ; 2 ; ... ; e  X  the one detailed in Algorithm 8 , the AIS algorithm has been used to fi nd minimal length addition sequences ( Cruz-Cort X s et al., 2008 ).
This is then the way the deterministic method is combined with the stochastic one: SWM focuses on fi nding minimal length ACs while the AIS helps by providing SWM with minimal length addition sequences.
 Algorithm 8. Addition sequence generator
Require: A sorted set of n integers U  X  e 1 ; e 2 ; ... e ascending order.

Ensure: Addition sequence e 1 ; e 2 ; ... e n 1 ; e n . 1: k  X  n 2 2: Set U  X  u 1  X  e 1 ; u 2  X  e 2 ; ... ; u k  X  e n 2 3: H  X  h 1  X  e n 1 ; h 2  X  e n 4: W  X   X  5: while U a  X  do 6:  X   X  X  h 2 h 1  X  7: W  X  W [ h 2 8: h 1 ; h 2  X  max _ two _ elements  X  u k ;  X  ; h 1  X  9: if  X  o u k and  X  = 2 U then 10: U  X  sortSet  X  U [  X   X  11: end if 12: if  X  A U then 13: k  X  k 1 14: end if 15: end while 16: return W
In this work ACEP is coupled in a similar way to SWM (ACEP-SWM) as detailed in Algorithm 9 ,where max _ MSW is the maximum size of the Most Signi fi cant Window (MSW) which is always the fi ( Cruz-Cort X s et al., 2008 )and q is the maximum number of con-secutive zeros allowed to make non-zero windows. The work of the addition chain U for the decimal number representing the fi zero window (Step 5 in Algorithm 9 ). An element from U will be then chosen (step 6 in Algorithm 9 ) and combined with the decimal values of the remaining windows (step 7 in Algorithm 9 )soastogeneratean addition sequence with Algorithm 8 (step 8 in Algorithm 9 ). This to be used by the sliding window method (step 9 in Algorithm 9 ). Algorithm 9. ACEP for Addition sequences Require: Integer e  X  X  e m 1 ... e 1 e 0  X  , max _ MSW ; q
Ensure: Addition Sequence Seq  X  X  1 ; 2 ; ... ; m  X  1: Decompose e into h zero and non-zero windows W i using 2: Represent in decimal the non-zero windows 3: Set MSW  X  W 0 4: Sort non-zero windows in ascending order 5: Set U  X  ACEP ( MSW ) 6: Select a suitable element a A U such that 7: Set List  X f W 0 ; W 1 ; W NZ 1 ; a g 8: Set List  X  Addition _ sequences _ generator (List) 9: Set Seq  X  List  X  U The following experiment compares the best results obtained by ACEP-SWM, AIS-SWM ( Cruz-Cort X s et al., 2008 )(i.e.thesame
Algorithm 9 but using AIS instead of ACEP in step 5) and the SWM with the traditional addition sequence generator ( Kaya-Koc, 1994 ) m  X  128, 256, 512 and 1024. The parameters values used by ACEP are the same adopted in experiment 1 (with 92,000 evaluations). A comparison based on the best resu lts found out of 30 independent runs per exponent is presented in Table 9 ,where k is the window size required by SWM.

Based on the results both, AIS-SWM and ACEP-SWM, outper-formed SWM with the traditional addition sequence generator. Regarding the two methods based on a nature-inspired algorithm,
AIS-SWM provided slightly better results with m  X  128 with respect to ACEP-SWM. However, ACEP-SWM outperformed AIS-SWM with the largest exponent tested ( m  X  1024). In the two remaining m values (256 and 512) similar results were found by both algorithms. 6. Conclusions and future work
An adapted evolutionary programming algorithm to fi nd mini-mal length addition chains (ACEP) was introduced in this paper.
The adaptations consisted in (1) a suitable solution representation at the phenotype level (i.e., not encoded) and a simple fi function based on the length of each solution, (2) a mechanism to generate a complete feasible initial population (i.e. only feasible addition chains were generated), (3) a special mutation operator to generate new feasible solutions and (4) a replacement mechanism based on stochastic encounters to avoid premature convergence.
ACEPwastestedinthreeexperimentswithdifferenttypesof exponents: small, hard, and diverse. In the fourth experiment ACEP was used to generate Euclidean addition chains in the set of diverse exponents. Furthermore, ACEP wa s coupled with the deterministic method called sliding window method (SWM) to solve large expo-nents; ACEP was in charge of helping on the generation of minimal length addition sequences wh ile SWM used such sequences to generate minimal length addition chains.

In the fi rst experiment ACEP outperformed the compared algo-92,000 evaluations with respect to the 240,000 and 350,000 required by the other approaches. Furthermore, ACEP outperformed all algorithms in the six sets of exponents by performing 240,000 evaluations. In the second experiment, ACEP obtained similar results as those obtained with the GA but requiring only 38% of the evaluations performed by such approach. In the third experi-ment, ACEP obtained similar results in all but one diverse exponents by using only 8% of the evaluations required by PSO. Furthermore, in one exponent ACEP improved the results reported by the comp-ared approaches (PSO and AIS). The fourth experiment showed the capabilities of ACEP to deal with Euclidean addition chains on the set of diverse exponents. Finally, in the fi fth experiment, the com-bination of ACEP-SWM solved a set of large exponents where the shortest addition chains for the largest exponent were generated by ACEP.

From the overall results it can be seen that ACEP covered a wide set of exponents with respect to other n ature-inspired-based approaches to fi nd minimal length addition chains. Furthermore, its computational cost, measured by the number of evaluations computed (a well-accepted measure in the evolutionary computing literature), is sig-ni fi cantly lower with respect to the compared approaches. Finally, ACEP is easy to implement.

The future work consists of further tests of ACEP in Euclidean addition chains and a study of their parameter values. Finally ACEP will be implemented in a public-key encryption system, such as RSA or DSA with the goal of measuring its performance. Acknowledgments The fi rst author acknowledges support from the Mexican
Council for Science and Technology (CONACyT) through a scholar-ship to pursue Ph.D. studies at the University of Veracruz. References
