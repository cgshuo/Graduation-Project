 On-line data streams possess interesting computational characteristics, such as unknown or unbounded length, a possibly very fast arrival rate, the inability to backtrack over previously arrived items (only one sequential pass over the data is permitted), and a lack of system control over the order in which the data arrive[1]. The real-time analysis of network traffic has been one of the primary applications of data stream management systems, examples of which include Gigascope [2] and STREAM [3]. A problem of particular interest, motivated by traffic engineering, routing system analysis, customer billings, and the detection of anomalies such as denial-of service attacks, concerns the statistical analysis of data streams with a focus on newly arrived data and frequently appearing packet types[4, 5, 6]. For instance, an ISP may be interested in monitoring streams of IP packets originating from its clients and identifying those users who consume the most bandwidth during a given time interval. The objective of these types of queries is to return a that occur above a given frequency (called threshold queries). window model causes old items to expire as new items arrive. Initially proposed by Zhu and Shasha in [7], the objective of this method is to divide the sliding window into some sub-windows, and only store the synopsis of each sub-window in full. Thus, in the synopsis, if the sub-windows have the same or similar size, we call this kind of synopsis an Equal Synopsis; otherwise, it is an Unequal Synopsis. Usually, Top-k query is always processed over an equal synopsis, but it X  X  very hard to implement over an unequal synopsis because of the resulting inaccurate approximate answers. Therefore, in this paper, we focus on periodically refreshed Top-k queries over sliding windows on Internet Traffic Streams. We present a deterministic DSW (Dynamic Sub-Window) algorithm to support the processing of Top-k aggregate queries over an unequal synopsis and guarantee the accuracy of the approximation results. The question of how to maintain an efficient synopsis data structure is very important for unequal synopsis is good at subtractable aggregates [8] such as SUM and COUNT. An MIN and MAX. The equal synopsis basic-window synopsis was proposed by Yunyue Zhu et al. in [7]. Paned-window synopsis, which was proposed by Jin Li et al. in [10] is an extended version of the basic-window synopsis in which the sub-windows are called  X  X anes X . Compared with the unequal synopsis, the paired-window synopsis, which was proposed by Sailesh Krishnamurthy et al. in [11], improves on the paned-window synopsis by using paired-windows which chop a stream into pairs of possibly unequal sub-windows. There have also been some special synopsis structures such as the holistic error measure, given a space budget. For indexing and searching schema-less XML documents based on concise summaries of their structural and textual content, Weimin He et al. presented two data synopsis structures in [15] that correlate the textual with the positional information in an XML document and improve the query precision. 
Queries that return a list of frequently occurring items are important in the context of traffic engineering, routing system analysis, customer billing, and the detection of anomalies such as denial-of-service attacks. There has been some recent work on answering Top-K queries over sliding windows [5]. Computing top-k queries from DBMSs [17]. The main idea is to combine multiple ranked lists, which are assumed to be available in their entirety, into a single list. The difference in the DSMS context is that a window based upon limited information. In [18], the authors present a framework for distributed top-k monitoring, but their goal is to minimize the amount of data transferred from distributed sources to a central processing system. Furthermore, they do not consider the sliding window model. 
Lukasz Golab et al. in [12] proposed a FREQUENT algorithm, which identifies the frequently occurring items in sliding windows and estimates their frequencies. They answer the frequent item queries using small-size Basic-Window synopses (sub-windows), because there is no obvious rule for merging the partial information in order to obtain the final answer. They store a top-k synopsis in each Basic-window and maintain a list of the k most frequent items in each window at the same time. Finally, they output the identity and value of each global counter over the threshold,  X  . They proposed a classification of distribution models for sliding windows over data streams in [19]. They queries over multinomial-distributed sliding windows. The Synopsis Data Structure can be stored in the allotted amount of memory and used to provide approximate answers to user queries along with some reasonable guarantees on the quality of the approximation. Such approximate, on-line query answers are particularly well suited to the exploratory nature of most data-stream processing applications, such as trend analysis and fraud or anomaly detection in telecom-network data, where the goal is to identify generic, interesting or  X  X ut-of-the-ordinary X  patterns rather than provide results that are exact to the last decimal. In this section, we briefly discuss the basic scheme used for the Synopsis Data Structure. As shown in Fig.1, this synopsis contains two different size sub-windows. Generally, the processing of the Synopsis Data Structure contains three steps. In the first step, called the partial aggregate step, we apply the function, G, over all the tuples in each function, H, to these sets of sliced aggregates to compute the query results. Finally, in the windows. 3.1 Top-K over Unequal Synopsis Here, we classify the Synopsis Data Structure into two major types, Equal Synopsis and Unequal Synopsis. In the Equal Synopsis (e.g. Paned Window Synopsis), all the sub-windows have the same size. Otherwise, we call it the Unequal Synopsis (e.g. Paired Window Synopsis). The use of the synopsis can reduce both the space and computation cost of evaluating sliding window queries by sub-aggregating and sharing the computation. The Equal Synopsis is very easy to implement, but it X  X  very hard to share the overlapping windows when we solve the multi-aggregate queries over the streams, because it always leads to more slices. The Unequal Synopsis can solve this problem well. 
In this section, we use a paired-window synopsis as an example of an unequal synopsis. Fig.2 shows how paired-windows split a window into a  X  X air X  of exactly packet streams. 20 , 10 and 5 can be considered as frequency counts. In this example, this synopsis contains 7 sub-windows (such as S1, S2 ) and we apply Top-3 as the partial aggregate. In the partial aggregate step, we output the Top-3 types in each sub-window. In the final aggregate step, if we want to output the most frequent item in the result, because its frequency count is 85 . Type a is dropped in the second sub-window S2 , although its final frequency counts will be the highest in the whole first window. Window) method. The DSW method is not restricted by the form of the synopsis and resets the workload of each window, in order to ensure that false negatives occur very rarely. We propose the following simple Method, the DSW (Dynamic Sub-window) Method, which employs the Unequal Synopsis approach and stores a Top-k synopsis in each sub-window. In this section, we will explain the three phases of this method and how to implement this method in detail. 4.1 Three Phases of DSW Method The whole Dynamic Sub-window method contains three phases. The first phase, called Redefinition Phase, is shown in Fig.3. We use an unequal synopsis which contains 7 sub-windows S1, S2, S3......S7. In our method, we design a new window called the Dynamic Sub-window that redefines the Long Sub-Window (such as S2, whose size is much larger than the others) into some new small sub-windows (the shaded area in Fig. 3.). Throughout this process, we can make all of the sub-windows have a similar size in order to reduce the size difference and to improve the accuracy of the Top-k results. The second phase, called Initialization Phase, initializes the primary size of the Dynamic Sub-window. In our method, the size of the Dynamic Sub-window is maintained automatically by the attributes of the sliding window query. As mentioned above, the sliding window has two common query types, the Time-based sliding window query and Tuple-based sliding window query. The Time-based sliding Tuple-based sliding window maintains the last N packets seen at all times. Usually, a non-partitioned window specification consists of three parameters: RANGE, SLIDE and WARRT. RANGE defines the size of the window, SLIDE defines the steps at which the window moves, and WARRT represents the windowing attribute. In our case, the primary size of the Dynamic Sub-window can be initialized by the values of RANGE and SLIDE of the aggregate query, and we let the size of the Dynamic Sub-window be always equal to the greatest common divisor of RANGE and SLIDE of this query. For example, if RANGE= 250 tuples and SLIDE=200 tuples, the Dynamic Sub-window size is equal to 50 tuples. 
After the size of the Dynamic Sub-window has been initialized, the next problem is how to implement this Dynamic Sub-window in the synopsis. So, we design the third phase: Maintain Phase. We use a function to sign the timestamp * into the synopsis, which can control the end and restart of the Dynamic Sub-window. This means that when the Dynamic Sub-window has been redefined in the synopsis, it will be controlled by the timestamp *. It will be ended and restarted when it meets the timestamp *(The idea of the punctuation * was first introduced by Jin Li, David Maier, and Kristin Tufte in [10].). 4.2 Theorem In studying the implementation of the Dynamic Sub-window, we found that its size can be maintained by a useful function. That is to say, it is always controlled by three parameters which can be maintained by a useful function. timestamp * into the synopsis. The Dynamic Sub-window will be controlled by the timestamp * in that it will end or restart when it meets the timestamp *. We propose this method of maintaining the size of the Dynamic Sub-window when the sub-frequency count of Top-1 in each sub-window, N which is the number of arriving stream data and M which is the total number of types which have arrived in the synopsis. There three parameters are always changed in real-time, and when we did an analysis on the relationship among them using real data, we found that N is always streams, we don X  X  know when they will end, but we can use this function to calculate when the dynamic sub-window will have to be ended. Theorem: Suppose  X  is the frequency count of Top-K in each sub-window, N is the number of arriving stream data and M is the total number of frequency types which have arrived in the synopsis. Then these values are always changed by the balance function  X  = {(N-1) / M} + 1. Proof: Suppose each Dynamic Sub-window contains M kinds of tuple types, and the M. When M is fixed,  X  =  X   X +1, then N= N X +1 and N X =  X   X   X M. Therefore, since  X   X =  X  -1, and N X = N-1, then N-1= (  X  -1)  X M. Therefore,  X  = {(N-1) / M} + 1. This means that if  X  increases by 1, according to the saturation state, it only needs add 1. 4.3 Dynamic Sub-window Algorithm In the following DSW algorithm, we assume that a single DS-window fits in main memory, within which we may count the item frequencies exactly. We define the Dynamic Sub-window as a DS-window in our algorithm. Input: the number of arriving stream data (N), the greatest common divisor of RANGE and SLIDE (n), the frequency count of Top-1 in each sub-window (  X  ), and the total number of types (M) which have arrived in the synopsis. 
Repeat: 1. For each tuple e in the next DS-window N: Increment the local counter. 2. Initialize let N equals n and let M X  equals the M, 3. For each local counter in the next DS-window N, each Otherwise: Stop the DS-window when it meets any If the kinds of tuple types M X  exceed M: Stop the DS-window. Stop the DS-window when it reach any 4. Output the k most frequent items on each DS-window We first describe the experimental setup and then present and analyze the results. 5.1 Experimental Setup We tested the DSW algorithm on count-based windows over TCP traffic data. The trace contains 199 and 1592 distinct source IP addresses for workloads (A) and (B), respectively, which can be treated as distinct item types. We set workload (A) to contain N = 10000 and workload (B) to contain N X  = 80000. Experiments were conducted with window size is 400). The size of the top-k list, k, is varied from one to ten. 
We built a prototype TCP/IP stream data in C++, and let the entire stream data run stream data set and, at the same time, we sign the item types into each TCP/IP address. Then, we design a TCP/IP address generator. According to this method, we can process theses queries on the synopsis in memory in real time. 5.2 Experimental Results In this section, we use real data and some different performance environments to test the DSW algorithm. At the same time, we compare the accuracy rates for the 3 strategies based on the DS-window (Dynamic Sub-window) and Paired-window approaches discussed below. Same Predicates, Diff. Windows in Workload (A) 
In workload (A), we examine queries wi th identical selection predicates and different periodic windows over a real data set. We compare the execution time for 2 strategies (DS-window and Paired-window) based on the variation in the percentage performance environment and Fig.4 (a) shows the percentage of IP addresses that 80% of the IP addresses are identified. But for the Paired window, at least k  X  4, 80% identification rate of the frequent items, we not only reduce the space usage, but also improve the accuracy rate. In the figure, we can see that the DS-window can identify IP addresses from approximately k = 2. Fig.4 (b) also shows the percentage of IP addresses which were identified by the DSW algorithm, but for the performance environment defined in Table 2. In this Figure, we can see that although the size of RANGE is larger than before, from k = 7, the DS-window also keeps high accuracy, whereas the paired X  X indow can only identify half of the frequent items. Diff. Predicates, Same Windows in Workload (A) too large, it can affect the size of the DS-window, as well as resulting in low accuracy. Otherwise, if the value of  X  is too small, it will result in high space usage. The relationship between the accuracy and the value of  X  is shown in Fig.5. Workload (A) and (B) Fig.6 shows the effect of the workload on the DSW algorithm. We used the performance environment listed in Table 3. In this test, we can see that the data speed parameters can be initialized by the query only once. In the following approaches, the DS-window can be maintained by itself. This is why the DSW algorithm suits both time-based and tuple-based sliding windows. In this paper, we presented the deterministic DSW (Dynamic Sub-Window) algorithm to support the processing of Top-k aggregate queries over an unequal synopsis and guarantee the quality and accuracy of the approximation results. We classified the synopsis data structure into two major types, the Equal Synopsis and Unequal Synopsis. The Basic Synopsis (Equal Synopsis) is always applied by optimizing the sliding windows, but may incur large time and space computation costs in memory, especially for the multi-aggregates problem. Therefore, a method is needed in which the size of the synopsis is not decided based on the designers X  subjective opinion but by the queries themselves, and which can be changed in real time in response to the changing attributes of the queries. Such a method would be more effective in solving the different kinds of aggregates. Based on this idea, we presented the DSW algorithm for both the Equal Synopsis and Unequal Synopsis. 
In a future work, we intend to solve more complex synopses which contain too many small sub-windows for multi-aggregate queries. We are also working on other aspects of processing streams, including the formalization of window semantics, the evaluation of window queries and the processing of disordered streams. Acknowledgment. This research was supported by a grant (#07KLSGC02) from Cutting-edge Urban Development -Korean Land Spatialization Research Project funded by Ministry of Construction &amp; Transportation of Korean government. 
