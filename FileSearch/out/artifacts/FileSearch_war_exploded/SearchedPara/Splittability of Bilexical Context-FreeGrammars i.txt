 University of St. Andrews University of Padua under these models have running time of O ( | w | 4 ) , where w is the input string. 2-LCFGs is undecidable. 1. Introduction
Bilexical context-free grammars, or 2-LCFGs for short, are specialized context-free grammars where each nonterminal is associated with a terminal symbol representing a lexical element of the language of interest. Furthermore, no more than two symbols can the combination of predicates with their arguments or modifiers. Models based on models of the head automata of Alshawi (1996), the probabilistic projective dependency grammars of Eisner (1996), and the head-driven statistical models of Charniak (2001) and Collins (2003).
 existing dynamic programming algorithms have running time of the input string. (In this article we disregard complexity factors that depend on the input grammar, which we will consider to be constants.) In cases in which, for each extent, independent one of the other, parsing based on 2-LCFGs can be asymptotically presentation of these computational results.
 of each head has been called splittability (Eisner 1997; Eisner and Satta 1999). Testing The computability of this test has never been investigated, however. grammar in which independence between left and right arguments of each head is a 2-LCFG is in split form if it can be factorized into individual subgrammars, one for each head, and each subgrammar produces the left and the right arguments of its head through two derivation processes, one happening strictly after the other. ( R ) arguments of some head a . These structures could well result in subderivations producing sequences of the form L n aR n , for any n  X  0, which would appear to preclude the application of the O ( | w | 3 ) algorithm.

Although a subset of the rules in a grammar may generate structures such as those just discussed, there may be additional rules that make the observed dependencies between will be shown in this article.
 grammar with a center marker (to be defined later) generates a regular language. This well known in the formal language literature (Hopcroft and Ullman 1979, exercise 8.10a, page 214) and which is originally due to Hunt III and Rosenkrantz (1974). some preliminary background, and in Section 3 we define 2-LCFGs and the notion of splittability. In Section 4 we prove the main result of this article, and draw some conclusions in Section 5. 2. Preliminaries
Turing machine, and undecidability (see, e.g., Hopcroft and Ullman 1979). We briefly summarize the adopted notation now.
 of terminals, N is a finite set of nonterminals, disjoint from  X  and including the start symbol S ,and R is a finite set of rules. Each rule has the form A  X   X  (  X   X  N )  X  . A CFG is called linear if each rule A  X   X  has at most one nonterminal in the right-hand side  X  .
  X  , defined such that  X  A  X   X  G  X  X  X  if A  X   X  is a rule in R and  X  ,  X  drop subscript G from  X  G whenever it is understood from the context. The reflexive and transitive closure of  X  is denoted as  X   X  . The language generated by G is defined as L ( G ) = { w  X   X   X  | S  X   X  w } . 868 marker . The class of linear CFGs with center marker #, or lin-CFG(#) for short, is the class of CFGs in which each rule either has the form A  X  # or the form A where A , B  X  N and u , v  X  (  X  \{ # } )  X  , where symbol  X  say a grammar in lin-CFG(#) is in binary form if the total length of u and v in rules
A  X  uBv is at most 1. It is not difficult to see that there is a language-preserving transformation of grammars in lin-CFG(#) to binary form, as suggested by the following example.
 Example 1 Let  X = { a , b ,# } . One member of lin-CFG(#) is the CFG G defined by the rules:
For this grammar, strings in L ( G ) have the form u # v ,with u { # } )  X  having the same length.

S  X  aA and A  X  Sb , where A is a new nonterminal. 3. Bilexical CFGs and Splittability We start this section with the definition of 2-LCFG, which is based on Eisner and
Satta (1999). Let N D be a finite alphabet whose symbols will be called delexicalized nonterminals. We combine N D with a set  X  of terminal symbols as follows:
A bilexical context-free grammar is a CFG G = (  X  , N D (  X  ) has one of the following five forms: occurrences. Notice that the head child of a rule is always associated with the same terminal as the left-hand-side nonterminal. The nonterminal occurrence A [ a ]inthe respectively, will be referred to as maximal projection occurrences. Observe how in a parse tree generated by a 2-LCFG, each occurrence of a lexical element (represented as a terminal symbol) is also part of several head child occurrences of nonterminals above it, up to some unique maximal projection occurrence. We assume that the head child occurrence in a rule is always marked within the rule itself, in order to disambiguate cases in which the head child and the maximal projection share the same terminal ( a = b in the second rule or a = c in the third). 1 projection in some rule in R . We now define a grammar G ( A [ a ])
R ( A [ a ]) ) in lin-CFG( a ). The main idea here is that G parse trees of G from any maximal projection occurrence of A [ a ]downto a ,treatingthe maximal projection occurrences of G  X  X  nonterminals to the left and right of these paths
R ( A [ a ]) is specified as follows: tion of a string of the generated language, but this is irrelevant to the development of the results in this article.
 in the definition of splittability. As we will see, our equivalence relation is stronger than the usual weak equivalence between grammars, where the latter only requires that the languages generated by two grammars be the same. In addition to weak equivalence, we demand that two 2-LCFGs establish the same predicate X  X rgument dependencies between lexical elements in the generated sentences, as will be explained here.
 Definition 1
Two 2-LCFGs G 1 and G 2 are d-equivalent if the following conditions are all satisfied: 1. G 1 and G 2 have the same set of nonterminals that occur as maximal 2. G 1 and G 2 have the same rules rewriting the start symbol, that is, the rules 3. for each nonterminal A [ a ] that occurs as a maximal projection in G Lemma 1
If two 2-LCFGs G 1 and G 2 are d-equivalent, then L ( G 1 870 Proof We show the stronger statement that, for each maximal projection occurrence A [ a ]from
G 1 and G 2 (item 1 in Definition 1) and for each w if A [ a ]  X   X  G proceed by induction on | w | .
 tion 1 we also have A [ a ]  X   X  shown similarly.
 rewriting maximal projection occurrence A [ a ]into a through a chain of head child nonterminal occurrences. More precisely, we can write: of the previous rule and generating the maximal projection occurrences B and C j [ c j ], 1  X  j  X  r .
 item 3 in Definition 1 we have A [ a ]  X   X  clude that A [ a ]  X   X  G 1  X  j  X  r ,suchthat B inductive hypothesis and conclude that B i [ b i ]  X   X  G 1  X  j  X  r .
 argument we can show that A [ a ]  X   X  G relation guarantees that the grammars establish the same dependencies between pairs of lexical elements in the generated sentences. To explain this, we borrow subsequently the notion of dependency structure from dependency grammars.

We can associate with t a dependency structure , by considering all rule occurrences in t that link two lexical elements from w . For each rule occurrence A [ a ] in t , a link is constructed from the corresponding occurrence of b in w to the corre-sponding occurrence of a . Similarly, a rule occurrence A [ a ] a link from the corresponding occurrence of c to the corresponding occurrence of a .
Notice that a dependency structure abstracts away from some topological aspects of the parse trees. For example, two rules A [ a ]  X  B [ a ] C [ c ]and B [ a ] rise to the same dependency structures as the two rules A [ a ] E [ a ] C [ c ].
 of dependency structures they assign to strings in the common language (via the set of parse trees as sketched above) are identical. Example 2 Consider the 2-LCFG G 1 defined by the rules: and the 2-LCFG G 2 defined by the rules:
G and G 2 are d-equivalent, and thus generate the same language by Lemma 1. This language consists of all strings of the form uav , where u thermore, the set of dependency structures associated by G they can generate are the same. Figure 1 shows one instance of such a correspondence.
Note that in addition to the tree in Figure 1(a), there are two more trees generated by grammar G 1 that correspond to the dependency structure in Figure 1(c). 872 article. We first introduce a special form for 2-LCFGs, which we call split form. The intuition is that a 2-LCFG is in split form if, for each maximal projection nonterminal of all arguments on the right.
 Definition 2 occurrence of a nonterminal A [ a ]  X  N D (  X  ), the nonterminals in G into two disjoint sets N ( A [ a ]) l and N ( A [ a ]) r ,suchthat A [ a ] conditions are satisfied: 1. if D [ a ]  X  B [ b ] C [ a ]in R ( A [ a ]) , then D [ a ], C [ a ] 2. if D [ a ]  X  B [ a ] C [ c ]in R ( A [ a ]) , then D [ a ], B [ a ] 3. if D [ a ]  X  B [ a ]in R ( A [ a ]) , then D [ a ]  X  4. if D [ a ]  X  a in R ( A [ a ]) , then D [ a ]  X  N ( A [ a ])
Note that the left arguments of A [ a ] are generated via the nonterminals in N and the right arguments are generated via nonterminals in N the top X  X own generation of the arguments we can switch from nonterminals in N to nonterminals in N ( A [ a ]) r only once, through a rule of the form D [ a ] mar G 2 from Example 2 is in split form, with N ( A [ a ]) complexity O ( | w | 4 ) for arbitrary 2-LCFGs.

G 1 and G 2 are d-equivalent. Grammar G 1 from Example 2 is splittable, because it is d-equivalent to grammar G 2 in the same example, and the latter is in split form. Example 3 Consider the 2-LCFG defined by the following rules:
Note that there is an equal number of arguments on either side of the head a . No 2-LCFG in split form can achieve this dependency, and therefore this grammar is not splittable. each head are independent of its right arguments, and vice versa, in the sense that only a finite amount of information can be passed between the two sides.
 Theorem 1
A [ a ]from G , the lin-CFG( a ) G ( A [ a ]) generates a regular language. Proof
If G is splittable, then there exists a split 2-LCFG G s such that G and G
Let A [ a ] be a nonterminal of G s that occurs as maximal projection, and consider the lin-CFG( a ) G ( A [ a ]) s , whose nonterminals are partitioned into sets N
Definition 2. It is not difficult to see that L ( G ( A [ a ]) language is the finite union of the languages: for all possible distinct choices of rules of the form B [ a ] is regular. Because G and G s are d-equivalent, it follows that each G regular language as well.
 grammar in lin-CFG( a ) generating the same language as G
To this end, assume a finite automaton M accepting L ( G ( A [ a ]) and a transition relation  X  . For each transition q 1 a  X  linear rules corresponding to transitions occurring on paths from the initial state of M state q 2 to any final state of M .
 rule q [ a ]  X  B [ b ] q [ a ], and for each transition q construct rule q [ a ]  X  q [ a ] B [ b ]. We also construct rule A [ a ] state of M ,andtherule q 2 [ a ]  X  a . For each final state q strings that are accepted by M by computations that traverse the transition q Each transition q 1 a  X  q 2 gives rise to one such grammar.
 taking different copies of automaton states q in nonterminals q [ A ] for each combi-nation of q 1 and q 2 . The result is a grammar generating all strings accepted by M .
Nonterminals q [ a ] are defined to be in N ( A [ a ]) l or in N q in a transition q 1 a  X  q 2 is reachable from q or whether q is reachable from a state q transition q 1 a  X  q 2 . Naturally A [ a ]istakentobein N are now clearly satisfied. 4. Undecidability Results
This section presents the main results of this article. We start with some basic notions from computability theory and with the adopted notation for Turing machines. a Turing machine M is a string over some alphabet  X  , encoding the current content of the tape along with the position of the head on the tape and the current state. In the initial configuration, the tape contains the input to the Turing machine, the head is placed at the start of the tape, and the machine is in its (unique) initial state. An accepting configuration is any configuration of M of which the current state belongs to a distinguished set of accepting states. An accepting computation of of configurations of M starting with an initial configuration and ending with a final 874 configuration, and such that consecutive configurations are related by a valid move of the machine. Without loss of generality, we assume that any accepting computation has an odd number of moves, and at least three.
 machine M whose configurations are defined over some alphabet  X  , and assume two fresh symbols $ and # not in  X  . Following the notation of Bordihn, Holzer, and Kutrib (2005), we encode accepting computations of M as strings of the form:
Here, w 0 ,..., w 2 k + 1 are configurations of M ,with w an accepting configuration. Furthermore, for each i with 0 related to configuration w i + 1 by a valid move of M . We define VALC( by M if u occurs in an initial configuration w 0 in some computation in VALC( language L ( M ) is defined to be the set of all strings accepted by Lemma 2 For a Turing machine M , it is undecidable whether the language L ( by Hopcroft and Ullman (1979, Lemma 8.8, page 204). We provide a complete proof here because we need to adapt the result to our special encoding of valid computa-tions, which is somewhat different from that used by Hopcroft and Ullman (1979), and because Hopcroft and Ullman only report a sketch of the proof.
 Lemma 3 For a Turing machine M , the language VALC( M ) is context-free if and only if L ( finite.
 Proof If L ( M ) is finite, then VALC( M ) is also finite (because VALC( M ) is a context-free language.
 free language. To this end, we use the version of Ogden X  X  lemma presented by Hopcroft at least one marked position, vwx includes at most n marked positions, and uv in L for any i  X  0.
 the length of its strings can be arbitrarily large. Therefore there must be a string in
VALC( M ) of the form: with w 2 having length greater than n . This is so because the initial configuration w representing the input string, can be chosen with arbitrarily large length, and only two fall within w 2 .
 one or more occurrences of the symbol $, we can pump such a string in  X  and obtain a new string which is not a valid computation, which is a contradiction. More precisely, assume that v contains exactly one occurrence of $, and write v = v $ v . If we choose i = 3 in Ogden X  X  lemma, we obtain a new string with two instances of configuration v v in it. This would imply a loop in the computation of a deterministic Turing machine, and therefore the resulting string cannot be an accepting computation. Using similar arguments, we can conclude that neither v nor x contains an occurrence of symbol $. string w 2 . This means that we can pump w 2 to a new configuration of arbitrarily large length, without pumping w 0 . But this is a contradiction, because w moves apart. In the second case, x is entirely included in the string w first case, we can pump w 2 to a new configuration of arbitrarily large length, without by a single move. Therefore VALC( M ) cannot be a CFL.

We deviate from Bordihn, Holzer, and Kutrib (2005) in that we only consider those strings in the complement of VALC( M ) that contain exactly one occurrence of #. Be-cause all the operations that need to be applied to obtain INVALC( or vice versa, preserve regular languages, it follows that VALC( if and only if INVALC( M ) is a regular language.
 is, the linear context-free grammars with center marker #, introduced in Section 2. Our proof differs somewhat from proofs of similar statements in Hopcroft and Ullman (1979) for general linear CFGs, in that the center marker has a prominent role in the grammar, and the construction must ensure that # occurs exactly once.
 Lemma 4
Given a Turing machine M , one can effectively construct a grammar in lin-CFG(#) generating INVALC( M ).
 Proof
Intuitively, our grammar is the union of several subgrammars, which generate, respectively: 876
It is straightforward to construct each of these subgrammars as linear grammars with center marker #, similarly to proofs from Hopcroft and Ullman (1979, pages 203 and 215). The statement of the theorem then follows from the fact that the class lin-CFG(#) is closed under (finite) union.
 a center marker generates a regular language. This result is stronger than a similar originally obtained by Hunt III and Rosenkrantz (1974) and also reported by Hopcroft marker that unambiguously splits the string into two parts. Here we report a direct proof of the result for linear context-free grammars with a center marker, whereas the similar result for general linear context-free grammars is indirectly obtained by Hunt conditions for the undecidability of a family of general predicates. Theorem 2 It is undecidable whether a grammar in lin-CFG(#) generates a regular language. Proof
Let M be a Turing machine. We start by claiming that L ( M INVALC( M ) is regular. To show this, assume first that L ( Turing machines are deterministic, VALC( M ) is also finite, and therefore regular. From Equation (3), it follows that INVALC( M ) is regular as well. Conversely, if INVALC( is regular, then so is VALC( M ). This means that VALC( M Lemma 3, that L ( M )isfinite.
 regular language. Following Lemma 4, we can effectively construct a grammar in lin-CFG(#) generating INVALC( M ). Under our assumption, we can now decide whether INVALC( M ) is regular and hence, by our claim, whether L (
Lemma 2. Hence, it must be undecidable whether a grammar in lin-CFG(#) generates a regular language. Example 4 Consider the (unambiguous) grammar that is defined by the rules:
Despite rules such as A  X  aAa and A  X  bAb , which by themselves may appear to make the language non-regular, the generated language is in fact projection in rules from G . We then characterized splittability of G ,inTheorem1,in terms of the regularity of the languages generated by each G at a very simple type of 2-LCFG in which we can identify a given linear context-free grammar with a center marker.
 Theorem 3 Splittability of bilexical CFGs is undecidable.
 Proof
We show that the existence of an algorithm for deciding whether a 2-LCFG is splittable would imply an algorithm for deciding whether any grammar in lin-CFG(#) generates a regular language, contrary to Theorem 2.
 has a single rule S  X   X  S [#] expanding the start symbol. Each rule from G remaining rules are of the form B [ b ]  X  b for each terminal symbol B [ b ]of G
G , grammar G ( B [ b ]) 2 generates the regular language { that G 2 is splittable if and only if G 1 is regular. 5. Discussion (1997) and Eisner and Satta (1999) for the closely related formalism of head automaton grammars. In this article we gave an equivalent definition for 2-LCFGs, through the notion of d-equivalence, and we showed that splittability of 2-LCFGs is undecidable. 878
The result immediately carries over to head automaton grammars, through the standard mapping defined by Eisner and Satta (1999).
 markers, and on the regularity of these linear grammars. The same characterization has been claimed by Eisner and Satta (1999) relative to head automaton grammars, without for linear context-free grammars with center markers (Theorem 2). This strengthens an free languages.
 problem whether splittability is decidable in case the number of nonterminals in each
G this direction. Other interesting sufficient conditions for splittability are not known.
Chomsky normal form context-free grammars where each binary rule classifies its two nonterminals into functor (or predicate projection) and argument. Also in this case, one can pose the question of whether the two processes of generating the left and the right arguments of each predicate are independent one of the other. The results reported in this article can be extended to show undecidability of this question as well. Acknowledgments References
