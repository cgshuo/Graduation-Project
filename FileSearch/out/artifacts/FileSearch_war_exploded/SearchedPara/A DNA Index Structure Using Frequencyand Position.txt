 DNA sequences hold the code that determines the characteristics of living or-ganisms, and can be represented as a long list over the four-letter alphabet of A, C, G, and T known as nucleotides. DNA sequence searching is an opera-tion that finds, from a DNA database, DNA (sub-)sequences whose nucleotide arrangements are similar to a given query sequence. To cater for the evolution-ary mutations and noises in DNA sequences, approximate match queries are preferred to exact match queries for DNA sequence searching.
 use the Smith-Waterman alignment algorithm [12], a dynamic programming ap-proach for finding an optimal local alignment between two sequences. This algo-rithm, however, takes a long processing time of O ( mn ), where m and n are the lengths of the two sequences to be aligned, respectively. A natural idea to re-solve this kind of drawbacks is to employ the filtering and refinement approach . BLAST [4, 5] is a typical example that follows this approach. Due to perfor-mance reasons, it uses a heuristic algorithm based on a similarity model that is slightly different from the one adopted in the Smith-Waterman alignment algo-rithm. Recently, Kaheci et al. [10] proposed the MR-Index for efficient processing of k -difference queries. A k -difference query is to find data subsequences that can be matched to a given query sequence by performing at most k replacing, inserting, and deleting operations.
 quence searching, especially exact match queries, wildcard match queries, and k -mismatch queries. Exact match queries search a DNA database for the subse-quences that are exactly matched to a query sequence. Wildcard match queries contain wildcard characters marked as  X   X   X  in a query sequence, and find the sub-sequences that are matched to a query sequence. Note that a wildcard matches with any single nucleotide. K-mismatch queries retrieve the data subsequences that have at most k nucleotides mismatched to those of a given query sequence. These queries are widely used in various molecular biology applications such as retrieval of expressed sequence tags and DNA transcription factors [8]. The alphabet of nucleotides consists of 15 characters that can occur in DNA sequences (See Table1). Four characters, A, C, G, and T, are used to express the regions of a DNA sequence whose characteristics are discovered completely. We call these four characters as principal nucleotides .
 alphabet . | T | denotes the length of T .Weuse T to denote a contiguous subsequence of T .A window is defined as a subsequence of a fixed length taken from a DNA sequence. W and | W | denote a window and its length, respec-tively. The window beginning at the i th position of a DNA sequence is denoted as W i .
 set of characters represented by s and the set of characters represented by q is not empty. Given a DNA data sequence T and a query sequence Q ,the DNA sequence searching problem is to find all subsequences T of T that satisfy both of the following conditions: (1) | Q | = | T | , and (2) for each i between 1 and | Q | , the i th character of Q matches the i th character of T . The Boyer-Moore algorithm [7] and the Knuth-Morris-Pratt(KMP) algorithm [11] have been devised for exact match queries. Their worst-case time complexity proved to be linear to the length of data sequence. These algorithms, however, should access the entire data sequences from disk because they are based on the sequential scan.
 has been proposed for processing wildcard match queries [8]. By eliminating all the wildcards from a query sequence, this method first obtains a set of subpat-terns and their starting positions within a query sequence. Next, by using an one-dimensional array called a scan vector, it finds the data subsequences, each of which contains all those subpatterns in order. This method, however, has a large storage overhead since it maintains the scan vector as large as the data sequence. Also, it requires much processing time because it accesses the whole data sequences from disk.
 structs a suffix tree on data and query sequences. Next, it finds from the suffix tree the lowest one among the common ancestor nodes of both sequences. It then traverses down the subtree of that node until it encounters k mismatches. This method can be applied to the processing of exact match and wildcard match queries in a similar way. However, it suffers from a large storage overhead and high cost for maintaining and traversing a huge suffix tree. This section proposes a new indexing method called BSI (Basic Signature In-dex) and also suggests a query processing method based on the proposed index structure.
 possible position of data sequence T . We then extract a basic signature from each window, considering the minimum and maximum frequencies of each principal nucleotide.
 Definition 1. Basic Signature: BS Let BS ( W i )bea basic signature of window W i . BS ( W i ) is expressed as follows: Here, min A and max A denote the minimum and maximum numbers of occur-rences of character A , respectively, in W i . The meanings of min C , max C , min G , max G , min T ,and max T are analogous.
 max C ], [ min G ,max G ], [ min T , max T ]) along with the identifier i and thus can be stored in a multi-dimensional index such as the R*-tree [9] and the X-tree [6]. The total number of windows taken from a data sequence T is | T | X  X  W | +1. Since | T || W | in most cases, the index for T could be much larger than T itself.
 Rectangles) which cover the signatures for consecutive c data windows extracted from a data sequence. Note that the signatures for consecutive two data win-dows are not that different from each other and thus are located closely in the 4-dimensional indexing space. Therefore, we expect that the MBR covering con-secutive c signatures will not be enlarged much. By using this approach, we are able to reduce storage space for indexing to 1 /c . We call c the index compression coefficient .
 query sequence Q . A query rectangle is formed in a different way according to the types of a query submitted. Let us first suppose that | Q | = | W | . o Exact match query: We construct a 4-dimensional query rectangle, ([ min A , o Wildcard match query: We first construct a 4-dimensional query rectan-o K -mismatch query: We construct a 4-dimensional query rectangle by After constructing a query rectangle from a query sequence, we search the in-dex for the data rectangles overlapping with the query rectangle. We call them candidate rectangles . Then, we perform a post-processing step to discard false alarms, those candidates that are not real answers. Using the identifier of each candidate rectangle, this step reads its corresponding data window from the database, and then verifies whether the data window actually matches with the query sequence. Only the candidate rectangles which pass this verification are returned as final answers.
 consecutive c data windows. Therefore, by using the identifier of each candidate rectangle, we actually retrieve and verify the corresponding c data windows together in the post-processing step.
 query sequence Q of length | W | by appending | W | X  X  Q | wildcard characters  X   X   X  to the end of Q and then apply the above query processing procedure to Q . When | Q | &gt; | W | , we first partition a query sequence Q into p sub-query sequences, Q 1 ,Q 2 ,  X  X  X  ,and Q p , such that p = | Q | / | W | and | Q i | = | W | for every i between 1 and p . Here, the last sub-query sequence Q p canbeoverlapped with Q p  X  1 to make the constraint | Q i | = | W | satisfied. Next, we apply the above query processing procedure to every sub-query sequence, and then obtain the final answers by merging all the results. Let us first mention a couple of drawbacks of BSI. First, in BSI, the signature of a window is decided only by the number of occurrences of each principal nucleotide. Therefore, there may be a great number of windows that are dif-ferent from one another but are represented as the same signature. It causes a large number of false alarms, resulting in high index-searching and post-processing costs. Second, in most DNA sequences, the occurrence ratios of the four principal nucleotides, A , C , G ,and T , are roughly 30%, 20%, 20%, and 30%, respectively. The windows taken from such sequences also show simi-lar occurrence ratios regardless of their beginning positions. Therefore, it is likely that lots of windows are represented by the signatures close to the center (0 . 3  X | W | , 0 . 2  X | W | , 0 . 2  X | W | , 0 . 3  X | W | ).
 signatures and spread them evenly on the indexing space. 5.1 Basic Strategy The simplest way to overcome the limitations of BSI is to extract more features from windows. However, this increases the dimensionality of the underlying in-dex, and thus leads to the well-known dimension curse. To represent windows more discriminatively without increasing the dimensionality, we propose a sim-ple but effective method that assigns a weight to each position within a window. This makes it possible to express both occurrence frequencies and occurrence positions of nucleotides with a signature of the same dimensionality. To incor-porate this method into our indexing approach, we first define a weight function w ( j )(1  X  j  X | W | ) which assigns a weight to each position i within a window. We then extract a weighted signature from each window.
 Definition 2. Weighted Signature: WS Let WS ( W i ) be a weighted signature of window W i . WS ( W i ) is expressed as follows: Here, wmin A is the sum of the weights of the positions at which character A must occur in window W i ,and wmax A is the sum of the weights of the positions at which character A may occur in W i . The meanings of wmin C , wmax C , wmin G , wmax G , wmin T ,and wmax T are analogous.
 sented by the same basic signature may now be expressed by different weighted signatures. We incorporate this weighing scheme into the proposed index struc-ture, thus producing a very effective index structure called WSI (Weighted Signa-ture Index). WSI solves the problems of BSI by scattering the disparate windows, which were represented by the same basic signature, over the indexing space. BSI. However, when we construct a query rectangle for answering a k -mismatch query, we need to consider the positions at which mismatches may occur. The procedure to build a query rectangle for a k -mismatch query is skipped due to space limitation. 5.2 Weight Function Since the weight function determines the distribution of signatures in indexing space, it has to be carefully designed. Consider a set of data windows which have the same basic signature. Their weighted signatures get scattered over the indexing space by the weight function. Let us consider an MBR that covers all such weighted signatures. Larger MBR implies that the weighted signatures are scattered over larger space. However, if the weighted signatures are scattered too much, the corresponding MBR may overlap with its neighboring MBRs, producing new false alarms. Therefore, we have to choose a weight function which enlarges MBRs as much as possible without making them overlap with their neighboring MBRs.
 let R min ( X, s ) denote the minimum of all wmin X values obtained from a set of all windows in which X occurs s times. That is, R min ( X, s )= s j =1 sw ( j ) where sw ( j ) denotes the j th smallest weight in a window. Similarly, let R max ( X, s ) denote the maximum of all wmax X values obtained from a set of all windows in which X occurs s times. That is, R max ( X, s )= | W | j = | W | X  s +1 sw ( j ). ( X, s + 1) should be satisfied for every s between 0 and | W | X  1. Supposing w ( j ) = j + C , let us solve the inequality. Note that sw ( j ) is identical to w ( j ) in this case. |
W | X  1, we obtain C&gt; ( | W | X  1) 2 4  X  1. Among the values of C which satisfy the inequality, we choose | W | 2 for the sake of simplicity. That is, we use w ( j )= j + | W | 2 for a weight function. In our experiments, as a data sequence T, we used six sets of DNA sequences downloaded from NCBI [1]: human chromosome 3 (2.5Mbp), 17 (5Mbp), 1 (7.5Mbp), 2 (10Mbp), 10 (20Mbp), and 5 (40Mbp). As a query sequence, we used 1,000 DNA sequences of length 256 to 2,048. A half of them were ran-domly selected from T , and the other half were obtained from DNA sequences [2] frequently used by biologists at laboratories.
 fix. SeqScan is the sequential scan based method, and Suffix is the method that uses the suffix tree as an index structure. 6.1 Parameter Settings It is desirable to set the window size slightly smaller than a typical size of a query sequence. For determining a window size, we analyzed the lengths of 35,685 query sequences downloaded from [2]. From the results, we observed that 62% of them have the lengths of 256 to 2,048. Thus, we set the basic window size to 256 for further experiments.
 changing the index compression coefficient, we evaluated the k -mismatch query processing time of BSI and WSI using human chromosome 2 of 10Mbp as a data sequence and 1% of the length of a query sequence as the value of k .Asshown in Fig. 1, as the compression coefficient increases up to 80, the query processing time of both BSI and WSI decreases. From that point, however, their query processing time increases as the compression coefficient gets larger. Therefore, we set the base value for the compression coefficient to 80. 6.2 Results and Analyses Experiment 1: Query Processing Time with Various Query Size In this experiment, we compared query processing times of different approaches while changing the length of query sequences. We used human chromosome 2 of 10Mbp as a data sequence. Also, we set both k for k -mismatch queries and the number of wildcard characters for wildcard match queries to 10, which is 1% of the average length of query sequences. Fig. 3 depicts query processing times of all the approaches for exact match, wildcard match, and k -mismatch queries. regardless of the length of query sequences. In BSI and WSI, we observe that the query processing time shrinks until the length of a query sequence reaches a point (i.e., 512), and then grows gradually after that point.
 compared with that of exact match queries. In BSI and WSI, wildcard characters in a query enlarge the corresponding query rectangle and increase the number of candidates, which leads to a large query processing time. As a query sequence gets longer, however, the number of candidates decreases remarkably. Thus, the performance improves significantly.
 and wildcard match queries. In particular, Suffix shows performance worse than even SeqScan since the part of the index to be traversed increases explosively. In BSI and WSI, however, their performance is shown to be nearly constant, and is not that affected by the changes of the length of query sequences. fix, and BSI 19 to 44 times, 2.9 to 6.1 times, and 2.2 to 2.7 times, respectively. In wildcard match queries, WSI performs better than SeqScan, Suffix, and BSI 4 to 21 times, 1.4 to 4.5 times, and 1.5 to 1.8 times, respectively. Also, in k -mismatch queries, BSI performs faster than SeqScan, Suffix, and BSI 7 to 28 times, several thousand times, and 1.3 to 1.6 times, respectively.
 Experiment 2: Processing Time of k -mismatch with Various k Value In this experiment, we compared the processing times of k -mismatch queries of different approaches with various k values. We used human chromosome 2 of 10Mbp as a data sequence. Fig. 2 shows an average query processing time of each approach while setting k as 0%, 1%, 2%, and 3% of the length of a query sequence. We observe that the query processing time of WSI, BSI, Suffix, and SeqScan gets higher as k grows. In WSI and BSI, a higher k value makes the part of an index to be traversed increased, and thus increases the query process-ing time gradually. In Suffix, however, as k grows, the part of an index to be traversed becomes explosively larger, and thus, the query processing time grows abruptly. The results reveal that WSI shows the best performance, and performs better than SeqScan, Suffix, and BSI 3.6 to to 31 times, 3 to several thousand times, and 1.1 to 2.3 times, respectively.
 Experiment 3: Query Processing Time with Various Lengths of Data Sequences In this experiment, we measured the query processing times of different ap-proaches with various data sizes. We excluded Suffix in this experiment since its performance degradation in performing k -mismatch queries on a large database is too serious to conduct experiments. Here, we set both k for k -mismatch queries and the number of wildcard characters for wildcard match queries to 10, which is 1% of the average length of query sequences. Fig. 4 shows an average processing time of each approach for exact match, wildcard match, and k -mismatch queries. almost linearly as the data size grows. WSI performs better than the other approaches in processing all kinds of queries. In exact match queries, WSI runs faster than SeqScan and BSI 25 to 33 times and 1.8 to 2.5 times, respectively. In wildcard match queries, WSI outperforms SeqScan and BSI 15 to 19 times and 1.7 to 1.9 times, respectively. Also, in k -mismatch queries, WSI performs better than SeqScan and BSI 13 to 20 times and 1.0 to 1.5 times, respectively. Exact match queries, wildcard match queries, and k -mismatch queries are widely used in lots of molecular biology applications including the searching of ESTs (Expressed Sequence Tag) and DNA transcription factors.
 processing such queries on large DNA databases. The proposed indexing method places a sliding window at every possible location of a data sequence, and extracts its signature by considering the occurrence frequency of each nucleotide char-acter. It then stores and manages a set of signatures using a multi-dimensional index, such as R*-tree. Especially, by assigning a weight to each position of a window, it scatters the signatures over the index space and thus reduces false alarms. The experiments with real biological data sets revealed that the pro-posed method is at least 2.9 times, 1.4 times, and several orders of magnitude faster than the suffix-tree-based method in performing exact match, wildcard match, and k -mismatch queries, respectively.

