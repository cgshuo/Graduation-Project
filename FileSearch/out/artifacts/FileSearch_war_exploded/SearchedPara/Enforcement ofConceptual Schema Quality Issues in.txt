 Conceptual schemas play a critical role in information systems (IS) development. In order to perform this role effectivel y, conceptual schemas should not have defects, and they should satisfy the quality criteria required by the methods used in their development [1 X 5]. In the literat ure, there are many proposals of quality criteria of conceptual schemas [6]. Mos t of them are relevant to all conceptual schemas, and others are relevant only to conceptual schemas developed in a particular language, method, organization or project.

A conceptual schema should satisfy all relevant quality criteria. This implies that during its development (or once it is finished) it should be checked that those quality criteria are satisfied, and that the appropriate actions are taken for those that are not. In principle, this checking can be done manually, but the time and effort it requires make it difficult to do it in practice. We believe that one of the most effective ways of increasing the quality of conceptual schemas is by using an Integrated Development Environment (IDE) that automatically enforces all relevant quality criteria. Unfortunately, it is a fact that nowadays only a few quality properties have been integrated into the IDEs used by professionals and students, and thus enforced in the conceptual schemas they develop. Ideally, a conceptual modeling method should adopt all relevant quality criteria, and the method should be supported by an IDE that enforces those criteria, thus ensuring that the developed conceptual schemas have the quality level required by the method [1, 7].

In [8] we proposed a method for defining conceptual schema quality properties, based on the notion of conceptual schema quality issue. In essence, an issue is a condition, which may be an integrity constraint a schema must satisfy to be syntactically correct, a necessary condition for a schema to be satisfiable, a best practice defined as a condition that must be satisfied, and so on. We believe that having quality properties uniformly defined as quality issues eases their integration into IDEs and, therefore, th eir enforcement in conceptual schemas.
This paper aims at increasing the support given to conceptual modelers by current IDEs in the enforcement of the qu ality of conceptual schemas. The ap-proach we have taken for achieving this objective is (1) analyzing the support provided by the current IDEs, (2) determining the support that an IDE could provide given the current state of the art X  X hich would be formalized using our method X , (3) comparing the support currently provided with the one that could be provided, and (4) evaluating the effectiveness of the additional support in increasing conceptual schema quality.

We focus on conceptual schemas written in UML/OCL, although our approach could be applied to other languages. There are many IDEs based on UML/OCL 1 , but we lack an assessment of the suppor t given by them in the enforcement of conceptual schema quality. The first contribution of our work is a comprehensive review of the quality properties supported by the most widely used IDEs.
In our method [8], quality issues are d efined by the engineers of conceptual modeling methods. In principle, all quality properties proposed in the literature could be defined in terms of our method, and they could therefore be included in a unified catalog. The set of issues included in the catalog, but not supported by a particular IDE, defines the ideal additional support that could be provided by that IDE in the enforcement of conceptual schema quality. The second con-tribution of our work is an initial version of that catalog, which has been made globally accessible.

We have evaluated the effectiveness of the additional support that IDEs would provide if they included all quality issues of the catalog. The last contribution of this paper is, as expected, the conclu sion that including more quality issues in an IDE increases the quality of the developed conceptual schemas.
The structure of the paper is as follows. Section 2 briefly reviews the con-cept of conceptual schema quality issue that we presented in [8] and introduces a new classification of quality issues in to five categories. Section 3 analyzes the support given by current UML-base d IDEs in the enforcement of quality properties. Section 4 pres ents the catalog of quality issues we have developed so far and discusses how this catalog could be included in current IDEs. The catalog includes all quality issues enfo rced by current IDEs and many others. In Sect. 5 we evaluate the benefit that wou ld be gained if current IDEs included all quality issues defined in the catalog. S ection 6 summarizes the conclusions and points out future work. In this section, we review the concept o f conceptual schema quality issue that we presented in [8]. We give first an informal definition and a classification, and then we summarize its formalization. Tabl e 1 shows several examples (see [8] for more). 2.1 Informal Definition According to the dictionary, a quality issue is  X  X n important [quality] topic or problem for debate or discussion X  2 . In essence, an issue is a condition.
We distinguish between two kinds of issues: problem and checking. A problem issue is a condition over the schema that should not be satisfied. The condition can be automatically checked. The fact that the condition is satisfied is the issue. Once raised, the issue should be solved, which can only be done by changing the schema itself.

In Tab. 1, an example of problem issue is I 1 =  X  X here is a cycle in a gener-alization hierarchy X . An issue is (auto matically) raised per each cycle detected by an IDE in a schema, and it should be solved by changing the schema itself. Most issues are of this kind.

A checking issue is a condition over the schema that can be automatically evaluated. The fact that the condition is satisfied is the issue, and it requires the conceptual modeler to manually check something. If the checking points out a problem that was unnoticed, the modeler has to perform an action to solve it.
In Tab. 1, an example of checking issue is I 9 = X  X n n -ary association de-fines all non-graphical cardinality constraints that are relevant X . The rationale of this issue is that n -ary associations may be subjected to several cardinality constraints, but UML allows the graphical definition of only a few of them [10]. The others must be defined by means of invariants. This checking issue automat-ically determines whether an association is n -ary or not and, if it is, it requires the conceptual modeler to manually check that the required invariants are ef-fectively defined in the schema. If these invariants are missing, the conceptual modeler has to manually define them and mark the issue as checked.

For analysis and presentation purposes, in this paper we also use a new or-thogonal classification of issues according to their source. We distinguish the following five categories (see examples in Tab. 1): Syntactic: An integrity constraint defined in the UML metamodel. An exam-Syntactic+: A syntactic integrity constraint applicable when UML is used as a Basic property: A fundamental property that conceptual schemas should have Naming guideline: A guideline recommended by some authors to be used in Best practice: A practice (not including naming guidelines) recommended by 2.2 Formalization In this section, we summarize the formalization of issue and issue type (see [8] for the complete details).
Let S be a schema that consists of n schema elements which are an instance of the corresponding schema metatypes. We define a conceptual schema quality issue instance (for short, issue) of type I x as a fact I x ( e 1 ,...,e m )where e 1 , ..., e m are schema elements, m  X  1. In a schema there may be several distinct issues of the same issue type, and there ma y be several issues for the same tuple e 1 ,...,e m .

For example, consider the problem issue I 4 =  X  X  property derived by union does not have specific properties X  (see Tab. 1). Assume that p is the schema element corresponding to the property relative (of entity type Person )whichis derived by union, but the schema does not have at least one property defined as subset of relative (for example, parent or sibling ). In this case, relative cannot have instances and therefore it is not correct. The issue can be formalized as an issue I 4 ( p )oftype I 4 .
 Formally, an issue type I x is a tuple: where  X  S x is the scope , which consists of a tuple S x = T 1 ,...,T m , m  X  1, of schema  X   X  x is the applicability condition . In general, only a subset of the elements of  X   X  x is the issue condition . An instance of issue type I x at a given time is an  X  K x is the kind of the issue type, which may be either Problem or Checking .  X  A x is the acceptability oftheissuetype,whichmaybe True / False . An issue  X  O x is a set of issue actions . Each issue action of I x with S x = T 1 ,...,T m is  X  P x is a set of precedents , which is a set of issue types such that the instances In this paper we aim to analyze several IDEs that can be used to perform UML conceptual modeling activities. The list of tools presented in Tab. 2 has been ob-tained from the Open Directory Project (ODP) [12] mainly, and complemented with some additional tools that, according to [13], are being used by UML prac-titioners nowadays. After a quick analysis of the tools included in ODP, we decided to exclude from our analysis the tools that are not intended for concep-tual modeling tasks 3 . To our knowledge, this is the first work that provides a comprehensive review of the quality properties supported by current IDEs.
In order to determine how IDEs deal with quality issue types, we manually tested each tool, and we reviewed the feature list that is published in each tool X  X  website. Table 2 summarizes the res ults for the following criteria: Issue Types: It shows the number of issue types enforced by the IDE in each Issue Tolerance: IDEs react differently when they detect an issue. The ap-Extensibility: IDEs enforcing issue types may offer one or more mechanisms to Corrective Actions: Whenever an issue is raised in the conceptual schema, The analysis of the 29 IDEs showed very interesting X  X s well as unexpected X  results. First of all, we can see in Tab. 2 that the vast majority of the analyzed IDEs assist modelers in dealing with syntactic issue types. However, only three IDEs fully support these category of issue types, whilst the others only deal with them partially. After testing each IDE individually, we discovered that many IDEs do not control syntactic issue types like having, for example, (1) a cycle in a generalization hierarchy, (2) a property whose lower multiplicity has a greater value than the upper, or (3) a n amespace that contains two different elements that are indistinguishable.

Second, our analysis also shows that, in general, IDEs have little or no support on issue types that are not syntactic. Nonetheless, some IDEs already integrate a few issue types in their own catalogs. Table 3 shows the 21 conceptual schema quality issue types that are included in ArgoUML , SDMetrics , Generic Modeling Environment ,and Visual Paradigm .

Some authors agree that inconsistencies should be tolerated X  X hat is, model consistency has not to be preserved at all times X , and it is the IDE X  X  responsi-bility to manage the  X  X etection of inconsistencies X  [14 X 16]. In this sense, current IDEs are moving towards this behaviour; that is, they allow some or all issues to be raised. In fact, only one third of the analyzed IDEs forbid the creation of issues at any time. It is also interesting to note that the four IDEs that include non-syntactic issue types tolerate issues: they allow issues of (some or all) types to be raised.
 It is obvious that corrective actions are only useful if issues can be raised. However, solely two IDEs include corrective actions, which means that the as-sistance a modeler receives in order to solve issues is very little. ArgoUML is the most complete IDE in this sense: it is the tool that includes more corrective actions. Moreover, some of its actions can fix an issue automatically.
Finally, our analysis also shows that extension mechanisms are not widely present in current IDEs. Only four of them provide a powerful mechanism X  X hat is, OCL or a similar language X  X o define new issue types. In the next section, we discuss in-depth the extensibility of these IDEs, comparing the issue type formalization they implement to ours. In principle, all quality properties proposed in the literature could be defined in terms of our formalization [8] and included in a catalog. The main advan-tage of such a catalog could be to have a centralized and uniform definition of all available quality issue types. Once this information is openly and easily accessible, conceptual modelers, stude nts, and practitioners could use it as a reference catalog to improve the quality of their conceptual schemas, specially if IDE developers integrate them into their tools.
 The work we are presenting here includes an initial version of this catalog [17]. So far, most issues included in the catalo g deal with UML class diagrams. The cat-alog contains all UML metamodel constraints as syntactic issue types [9], and 59 non-syntactic issue types: 37 problem issu es and 22 checking issues. Specifically, it includes 11 syntactic+ issue types, 20 bas ic properties, 10 naming guidelines, and 18 best practices. These issue types are based on guidelines, recommendations, and best practices that can be found in the literature, as well as all conceptual schema quality issues that are already included in current IDEs. A few examples of the included issue types are making implicit constraints entailed by association redefinitions explicit [18], using a proper capitalization of schema element names [9, p. 50], writing class names [19 X 21] or binary association names [22] using the correct syntactic form, ensuring schema satisfiability [23, p. 88], or detecting the situation in which a refactoring would be recommended [24].

Each issue type included in our catalog is defined in XML. The XML includes the different elements of the formalization introduced in Sect. 2.2, as well as some additional meta-data like the name or the description of an issue type. The applicability and issue conditions are defined using the Object Constraint Language (OCL). The usage of an XML representation provides two key bene-fits: on the one hand, the catalog and the specification of an issue type can be downloaded and parsed by an IDE automatically; on the other hand, they can be presented in a user-friendly manner by means of XSLT sheets, which allow these XML files to be browsed by conceptual modelers and practitioners using awebbrowser.

Consider, for example, the issue type I 4 =  X  X  property derived by union does not have specific properti es X , which is formalized 4 in Fig. 1. This issue type applies to all properties in the schema that are derived by union. For each of them, the issue condition checks that there are no properties that subset it. The kind of this issue type is, as we have already stated, problem and the issue type is considered to be not acceptable.
The formalization also includes several actions that assist the conceptual mod-eler in solving this type of issues: (1) cr eating a new association and making one of its member ends a subset of the derived property, (2) making one member end of an already existing association a subset of the derived property, or (3) making it a base property. The first two actions are manual because the con-ceptual modeler has to manually create the association (only in (1)) and select which property subsets the derived-by-union property (in (1) and (2)). The lat-ter is automatic because an IDE could automatically change the value of the isDerivedUnion of the derived-by-union property to False . 4.1 Extending Current IDEs with the Catalog In general, all IDEs that include some sort of issue types describe them by means of a context , which corresponds to the type of the instances for which issues may exist, and a condition , which determines whether the issue exists or not for each instance of the context. This formalization of issue type is very similar to a UML metamodel constraint. Besides this, IDEs may also include additional elements to their formalization, such as (1) permitting the modeler to ignore issues or (2) one or more operations that solve (or help the modeler to solve) an issue instance. According to this description, IDEs implement (ideally) the following formalization of issue type: where, as we have already seen,  X  C y is the context in which the issue type has to be evaluated,  X  a condition  X  y that determines whether the issue exists or not for each in- X  a Boolean value I y that specifies whether the issue can be or cannot be  X  aset O y of operations that solve (or help solving) the issue.
 Assuming that the previous formalization r epresents the best case scenario we may currently find in an IDE (only ArgoUML includes all these elements into its defi-nition of issue types), it is clear that this formalization (2) is less expressive than ours (1). At a first glance, the major problem IDE developers would face when trying to integrate our catalog in their tools is that they cannot define checking issue types. In general, a checking issue type requires the modeler to check some-thing or perform some action manually, and then notify the tool that the check has been performed. Current IDEs do not provide any mechanisms to the modeler to perform this notification. To overcome this problem, an IDE developer may be tempted to map a checking issue type from our formalization to an ignorable is-sue type in (2). However, according to the dictionary, to ignore [an issue] means to  X  X efuse to take notice of or acknowledge [the issue]; disregard [the issue] inten-tionally X , so this mapping would be sem antically incorrect and inaccurate.
Another problem that may arise when defining an issue type from (2) to ours is adapting the scope. Our formalization allows an issue type to have more than one metatype as a scope. Using more than one metatype provides better feedback to the modeler under certain circumstances.

Consider, for example, the pull up property refactoring, which consists in removing an attribute named n from one (or more) specific classes and defining it in the general class [24]. A situation in which this refactoring would be highly recommended is when the attribute is repeated among all specific classes of a complete generalization set. This situation would be formalized as a problem issue type and, obviously, one of the i ssue actions that may fix an issue of this type would be applying the refactoring. If the scope admits only one metatype, the best candidates to be set as the scope are GeneralizationSet or Property .The former would raise an issue for any generalization set whose specific classes have one (or more) attributes with the same name, whilst the latter would raise an issue for every single attribute whose name is repeated in the generalization set. However, using a scope with more than one element such as GeneralizationSet , String , an issue would be raised only once for each attribute name n that is repeated among all specific classes of a generalization set and, thus, it would provide a more accurate and con cise feedback to the modeler.

Finally, IDEs do not allow the definiti on of precedents. Precedents filter the amount of feedback the modeler receives, because only those issues that may be triggered are actually triggered. Currently, IDEs may be able to implement a similar behaviour by duplicating the defini tion of a precedent inside their issue condition. However, duplicating information is usually a source of errors, and makes the maintenance and comprehension of their catalogs more complicated. This section describes an experiment conducted to evaluate the support given by the current IDEs to enforce the quality of conceptual schemas. We randomly selected 13 conceptual schemas devel oped by students, as part of their final projects, during the last year of their Computer Science degree. Table 4 summa-rizes the characteristics of the 13 conceptual schemas.

We defined all the conceptual schemas using the two current tools that provide better support to detect quality issues: ArgoUML and SDMetrics . As indicated in Tab. 2, ArgoUML detects 3 syntactic+ issue types, 3 basic properties, 3 naming guidelines and 5 best practices, whereas SDMetrics detects 6 syntactic+ issue types, 3 basic properties, 2 naming guidelines and 2 best practices. Both tools partially check syntactic issue types but we do not consider them in this evalua-tion. We found that all the conceptual schemas present quality issues. Tables 5 and 6 show the problem issues detected fo r each category and for all conceptual schemas by ArgoUML and SDMetrics , respectively.

ArgoUML detects, on average, 42 problem i ssues for each conceptual schema whereas SDMetrics detects 24. In the light of the results it may seem that the support given by the tools to detect qu ality issues is adequate. However, to determine what could be done ideally, we analyzed the conceptual schemas using the catalog presented in the previous section. This catalog, defined following the formalization presented in Sect. 2, d etects not only the problem issue types included in ArgoUML and SDMetrics , but also many others (including several checking issues types). When the schemas are analyzed using our catalog, the number of issues they present increases considerably. In fact, the number of detected problem issues is, on average, 8 times higher than the ones detected by ArgoUML and 15 times higher than the ones detected by SDMetrics . We also detected more than 1300 checking issues, which require the conceptual modeler to check something that may be a defect. Table 7 shows the detected issues for each category and for all conceptual schemas using our catalog.
 The results are conclusive. Although current IDEs such as ArgoUML and SDMetrics give support to detect problem issu es in conceptual schemas, this support might be much greater. The use of a broader catalog with relevant quality issue types for conceptual mode ling increases, as expected, the number of detected issues and, therefore, fost ers the improvement of the quality of the developed conceptual schemas. Although ArgoUML and SDMetrics provide ex-tension mechanisms to incorporate new issue types, they do not permit to add the 22 checking issue types defined in our catalog. Moreover, 6 of the issue types defined in our catalog have a scope with two or more metatypes and 10 have precedents. These issue types are m ore difficult to integrate into ArgoUML and SDMetrics than into our catalog. The starting point of this paper has been the view that one of the most effective ways of increasing the quality of concep tual schemas in practice is by using an IDE that enforces all relevant quality issues. With that view, we have analyzed the support provided by twenty-nine IDEs in the enforcement of quality issues, and we have seen that only two of them provide some significant support. We have put forward the idea of a catalog that includes all quality issues proposed in the literature, uniformly defined. We have presented an initial, globally-accessible version of that catalog that includes 59 non-syntactic quality issues.
We have then compared the support provided by current IDEs with the one that could be provided by those IDEs if they enforced all quality issues defined in the catalog. The conclusion has been that there is a large room for improvement. We have experimentally evaluated the benefit of the additional support in the quality of thirteen conceptual schema s developed by students as part of their final projects. We have seen that the benefit is significant.

We plan to continue this work in two directions. The first is to extend the catalog so that it includes most of (if not all) quality issues published in books, journals, and conference papers in the field of conceptual modeling of information systems. We believe that the existence of such catalog would be of great value to the information systems engineering community in general, and particularly to IDE developers. So far, we have focused on the notion of quality issues of conceptual schemas, but this could be also applied to other model-based software artifacts, as it is currently done in some IDEs. A second direction then is to explore the benefits of our approach in that context.
 Acknowledgments. This work has been partly supported by the Ministerio de Cien-
