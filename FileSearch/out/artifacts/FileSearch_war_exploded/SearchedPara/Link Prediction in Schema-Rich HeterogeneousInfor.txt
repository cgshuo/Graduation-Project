 Xiaohuan Cao 1 , Yuyan Zheng 1 , Chuan Shi 1( Nowadays, the study of Heterogeneous Information Network (HIN) become more and more popular in data mining area [ 5 ], where the network includes different types of nodes and relations. Many data mining tasks have been exploited on this kind of network, such as clustering [ 14 ], and classification [ 7 ]. Among those researches in HIN, link prediction is a fundamental problem that attempts to estimate the likelihood of the existence of a link between two nodes, based on observed links and the attributes of nodes. Link prediction is the base of many data mining tasks, such as data clearness and recommendation. Some works have been done to predict link existence in HIN. Because of the unique semantic characteristic of HIN, meta path [ 14 ], a sequence of relations connecting two nodes, is widely used for link prediction. Utilizing the meta path, these works usually employ a two-step process to solve link prediction problem in HIN. The first step is to extract meta path-based feature vectors, and the second step is to train a regression or classification model to compute the PathPredict to solve the problem of co-author relationship prediction, Cao et al. [ 3 ] propose an iterative framework to predict multiple types of links collectively in HIN, and Sun et al. [ 13 ] model the distribution of relationship building time to predict when a certain relationship will be formed. These works usually have a basic assumption: the meta paths can be predefined or enumerated in a simple HIN. When the HIN is simple, we can easily and manually enumerate some meaningful and short meta paths [ 14 ]. For example, a biboligraphic network with star schema is used in [ 12 , 13 , 15 ] and only several meta paths are enumerated. However, in many real networked data, the network structures are more com-plex, and meta paths cannot be enumerated. Knowledge graph is the base of the contemporary search engine [ 10 ], where its resource description framework the types of nodes and relations are huge. For example, DBpedia [ 2 ],akindof knowledge graph, has recorded more than 38 million entities and 3 billion facts. In this kind of network, it is hard to describe them with simple schema, so we call them schema-rich HIN. Figure 1 shows a snapshot of the RDF structure extracted from DBpedia. You can find that there are many types of objects and links in such a small network, e.g., Person, City, Country. Moreover, there are many meta paths to connect two object types. For example, for Person and Country types, there are two meta paths: Person bornin  X   X  X  X  X   X  City little part of the whole DBpedia network, and there will be huge number of meta paths can connect Person and Country in a real network. So that the meta paths in this kind of schema-rich HIN are too many to enumerate and it X  X  hard to analyze them.
 from two aspects. (1) The meta path cannot be enumerated. As mentioned above, there are tens of thousands of nodes and links in such schema-rich HIN and the meta paths in the network have the same order of magnitude. It X  X  impossible to enumerate meta paths between two node types. (2) It is also not easy to effectively integrate these meta paths. Even though masses of meta paths can be found between target nodes, most of them are meaningless or less important for link prediction. So that we need to learn weight for each meta path, where the weight represents the importance of paths for link prediction.
 the Li nk P rediction with a utomatic meta P aths method (LiPaP). The LiPaP designs a novel algorithm, called Automatic Meta Path Generation (AMPG), to automatically extract meta paths from schema-rich HIN. And then we design an supervised method with likelihood function to learn the weights of meta paths. On a real knowledge base Yago, we do extensive experiments to validate the performances of LiPaP. Experiments show that LiPaP can effectively solve link prediction in schema-rich HIN through automatically extracting important meta paths and learning the weights of paths. In this section, we introduce some basic concepts used in this paper and give the problem definition.
 mation network defined as a directed network graph G =( V, E ), which consists of either different types of nodes V or different types of edges E . Specifically, a information network can be abstracted to a network schema M =( R, L ) where R is the set of the node types and L is the set of the edge types, and there is a node type mapping function  X  : V  X  R , and an edge type mapping function  X  : E  X  L . When the number of node types | R | &gt; 1 or the number of edge types | L | &gt; 1, the network is a heterogeneous information network . For example, in bibliographic database, like DBLP [ 4 ], papers are connected together via authors, venues and terms, they can be organized as a star-schema HIN. Another example is the users and items in e-commerce website which con-stitutes a bipartite HIN [ 6 ].
 these paths are called as meta path [ 14 ]. A meta path that is defined as node types R 1 and R l +1 , is going through a series of node types R a series of link types L 1 ,  X  X  X  ,L l . Taking the knowledge base in Fig. 1 as an exam-ple, we can consider the knowledge base as an HIN, which includes many different node types (e.g., person, city, country) and link types (e.g., bornIn and locate-dIn). Two node types can be connected by multiple meta paths. For example, there are two meta paths connnecting Person and Country: Person City Traditional HIN usually has a simple network schema, such as bipartite [ 16 ] and star schema [ 9 ]. However, in some complex HINs, there are so many node types or link types that it is hard to describe their network schema. We call the HIN with many types of nodes and links as schema-rich HIN . In simple HIN, the meta paths can be easily enumerated, but it is difficult to do the same in the schema-rich HIN. Data mining in schema-rich HIN will face new challenges. Specifically, we define a new task as follows: Link Prediction in Schema-Rich HIN. Given a schema-rich HIN G and a training set of entity node pairs  X  = { ( s i ,t i ) | 1  X  paths  X  = { i | 1  X  i  X  e } which can exactly describe the pairs. With these meta paths, we design a model  X  ( s, t |  X  ) to do link prediction on the test set  X  = { ( u i ,v i ) | 1  X  i  X  r } . In order to solve the link prediction problem defined above, we propose a novel link prediction method named Li nk P rediction with a utomatic meta P aths method (LiPaP). This method includes two steps: Firstly, we design an algo-rithm called Automatic Meta Path Generation (AMPG) to discover use-ful meta paths with training pairs automatically. Secondly, we use a supervised method to integrate meta paths to form a model for further prediction. 3.1 Automatic Meta Path Generation In order to extract the appropriate and relevant meta paths as model features for link prediction, we would like to show the AMPG algorithm, which can generate useful meta paths smartly in schema-rich HIN. We would illustrate AMPG through a toy example in Fig. 2 , where the training pairs are (2,8), (3,9), (4,9) } .
 The main goal of AMPG is, given the training set of entity pairs, to find all the useful and relevant meta paths connecting them. These paths to be found would not only connect more training pairs, but also show much closer relationship to present implicit features of the training set. For example, path initially found by our method in Fig. 3 and it is not only the shortest relation but also the one connecting most training pairs. Besides, the meta paths to be found are still most relevant in the candidate paths. Basically, we start to search from the source nodes step by step to find out the useful meta paths greedily. At each step, we select the meta path that is most relevant and maybe reaching more target nodes. Then we check whether the path connects the training pairs or not. If so, we pick out the meta path, otherwise make a move forward until the unchecked meta paths are irrelevant enough. It guarantees that the generated meta paths all well describe the relationship between each training pairs and the selected paths are not too many to add noise paths.
 mal paths at each step. For judging the priority of meta paths for selection, AMPG utilizes a similarity score S as a selection criterion based on a similarity measurement Path-Constrained Random Walk (PCRW) [ 8 ], which is to calcu-late the relevance between the given entity pairs in the meta paths. The higher similarity score S is, more likely the meta path is to be chosen.
 step. The structure records a meta path passed by, a set of entity pairs reached and their PCRW values and the similarity score S of the current structure, as Fig. 3 shown. Besides, we create a candidate set to record the structure to be handled.
 priority of the structure. S measures the similarity of the whole arrival pairs in the structure. The highest S means the most relevant relationship and the most promising meta paths, so we get the structure with the highest S at every step. The definition of similarity score S is as follows: where s and t are source and reaching entity node respectively on meta path , T is the number of reaching entity nodes and  X  ( s, t | r ( s )=1  X   X   X  N is the contribution of s to the current structure for training pairs selection balance, where  X  is the decreasing coefficient of the contribution as 0.1 because of the good performance on it, and N is the number of the target nodes that s has reached through other selected paths. It means if one of source nodes in s has more target nodes matched before, N will be larger and S will be reduced due to the smaller r ( s ). So that the structure with other source nodes which have fewer matches will get high priority to be traversed greedily. we set a threshold value l to judge the structures whether being put to the candidate set or not. where is a limited coefficient, | A | is the number of entity pairs in the structure. Furthermore, we explain AMPG with a case study shown in Fig. 3 . The train-ing pairs are (1, 8), (2, 8), (3, 9), (4, 9) and sources nodes are 1, 2, 3, 4. The case starts with creating an initial structure No.1 and inserts it into the candidate set as Fig. 3 (A) shown. The entity pair is composed of the source node and itself and no meta path is generated at this step. Our algorithm will read candidate set itera-tively and choose the structure with highest S at each step. For each selected struc-ture, it will be checked if any training pairs are matched. If not, we move one step in HIN, as Fig. 3 (B) shown. We can pass by three edge types and WorkAt  X   X  X  X  X  X  X   X  . For each passed edge type, we create new structures like No.2 and No.4. Then, we check the new structures whether fit the conditions of expanding further and insert them into the candidate set. Remove the used structure No.1 and read next structure. Otherwise, as Fig. 3 (C) shown, four pairs are matched, tor is recorded. Remove the used structure No.2 and continue to read next. The algorithm terminates when the candidate set is empty.
 The detail process of AMPG is described in Algorithm 1 . Step 1 X 2 is the variable initialization step. Step 3 X 26 shows the main process of searching meta paths by greedy S in a loop. In every searching movement, we pop the structure with the largest S to handle until the candidate set is empty. Finally, the algorithm will generate a set of meta paths with the related similarity matrix of training pairs. Algorithm 1. AMPG( G ,  X  ) 3.2 Integration of Meta Path Each meta path found by AMPG is important but has different importances for further link prediction. It X  X  necessary to find a solution of measuring the importance for each meta path and integrating them into a link prediction model. use the positive and negative samples to train a model to predict whether the link exists between the given pairs or not. Positive samples are the training pairs, while negative samples are generated by replacing the target nodes of the training pairs with the same-typed nodes without the same relations. Thus positive value is the similarity value vector of each positive pair on all selected meta paths, while negative value is the vector of negative pair.
 1 ,  X  X  X  ,N ), weights, we use the log-likelihood function. The specific formula is as follows: where t ( , x ) is the Sigmoid function (i.e., t ( , x )= ity value vector of sample pair in all selected paths, x + x  X  negative. q + is similarity matrix of positive pairs made of x similarity matrix of negative pairs made of x  X  . overfitting.
 After learning weights of relevant meta paths  X  , we use a logistic regression model to integrate meta paths for link prediction. where ( s, t ) is the pair we should do link prediction, and x is each selected meta path feature, while x is the weight of x we learn above. And  X  is the set of selected meta paths. If  X  ( s, t |  X  ) is larger than a specific value, we judge they would be connected by the link predicted. In order to verify the superiority of our designed method of link prediction in schema-rich HIN, we conduct a series of relevant experiments and validate the effectiveness of LiPaP from four aspects. 4.1 Dataset In our experiments, we use Yago to conduct relevant experiments and it is a large-scale knowledge graph, which derives from Wikipedia, WordNet and GeoN-ames [ 11 ]. The dataset includes more than ten million entities and 120 million facts made from these entities. We only adopt  X  COREFact  X  of this dataset, which contains 4484914 facts, 35 relationships and 1369931 entities of 3455 types. A fact is a triple: &lt; entity, relationship, entity &gt; , e.g., &lt;NewYork, locatedin, U nitedStates &gt; . 4.2 Criteria We use receiver operating characteristic curve known as ROC curve to evaluate the performance of different methods. It is defined as a plot of true positive rate (TPR) as the y coordinate versus false positive rate (FPR) as the x coordinate. TPR is the ratio of the number of true positive decisions and actually positive cases while FPR is the ratio of the number of false positive decisions and actually negative cases. The area under the curve is referred to as the AUC. The larger the area is, the larger the accuracy in prediction is. 4.3 Effectiveness Experiments This section will validate the effectiveness of our prediction method LiPaP on accurately predicting links existing in entity pairs. Since there are no existing solutions for this problem, as a baseline (called PCRW [ 8 ]), we enumerate all meta paths, and the same weight learning method with LiPaP is employed. Because meta paths with length more than 4 are most irrelevant, the PCRW enumerates the meta paths with the length no more than 1, 2, 3, and 4, and the corresponding methods are called PCRW-1, PCRW-2, PCRW-3, and PCRW-4, respectively. Based on Yago dataset, we randomly and respectively select 200 entity pairs from two relations isLocatedIn  X   X  X  X  X  X  X  X  X  X  X   X  assume that these two types of links are not available in the prediction task. In this experiment, 100 entities pairs of them are used as the training set, the other are used as the test set. In LiPaP, we set in Eq. ( 2 ) as 0.005 and the max path length is also limited to 4.
 LiPaP has better performances than all PCRW methods, which implies that LiPaP can effectively generate useful meta paths. Moreover, the PCRW generally has better performance when the path length is longer, since it can exploit more useful meta paths. However, it will take more cost to search more meta paths, most of which are irrelevant. For example, PCRW-3 generates more than 80 paths and PCRW-4 finds more than 600 paths with lots of irrelevant paths. On the contrary, LiPaP only generates 30 meta paths for the isCitizenOf  X   X  X  X  X  X  X  X  X  X  X   X  shows the top 4 generated meta paths and the corresponding training weights the fact that a person is born in a city and the city is located in a country. It describes the citizen relationship in fact. The last one with length 4 seems not to be close, but actually has certain logistic relation with the link However, these long and important meta paths can be missed if the maximum length of meta path was limited too short, as PCRW does. While our method can automatically find these paths and assign them a high importance. 4.4 Influence of the Size of Training Set In this section, we evaluate the influence of the size of training set on the prediction performances. The size of training set are set with { since it can generate most of useful meta paths and achieve good performances compared to other PCRW methods. As illustrated in Fig. 5 , when the number of training pairs is smaller than 10, the performances of both methods improve rapidly with the size of pairs growing. However, when the size is more than 10, the size of training set has little effect on the performances of both methods. We think the reason lies in that too small training set cannot discover all useful meta paths, while large training set may introduce much noise. When the size of training set is from 10 to 20 in this dataset, it is good enough to discover all useful meta paths and avoid much noise. Furthermore, it can save space and time to learn model and make the performance of our method better. 4.5 Impact of Weight Learning To illustrate the benefit of weight learning, we redone the experiments on the or random weights, and with average weights. Figure 6 shows the performances of these methods. It is obvious that the weight learning can improve prediction performances. The model with random weight performs worst, owing to giving the more relevant paths low weights. The model with weight just has a little better performance than the model with average weight, because the meta path features generated by AMPG are all relevant and important, the most important feature also has not get a very low weight in the model with average weight. So the performance of the model with average weight is also not poor in spite of being inferior to the model with weight. Therefore, the weight learning can adjust the importance of different meta paths so as to integrate them well and make the model better. 4.6 Efficiency In this section, we choose 5 different sizes of training set, i.e., to validate the efficiency of finding meta paths of different methods. Figure 7 demonstrates the running time on different models for the is obvious that the running time of these models approximate linearly increase with the increase of the size of training set. In spite of the small running time, the short meta paths found by PCRW-1 and PCRW-2 restrict their prediction performances. Our LiPaP has smaller running time than PCRW-3 and PCRW-4, since it only finds a small number of important meta paths. In this way, LiPaP has a better balance on effectiveness and efficiency. In this paper, we introduce a novel link prediction method in schema-rich HIN named Li nk P rediction with a utomatic meta P aths (LiPaP), which proposes an algorithm called AMPG to automatically extract meta paths based on given training pairs and designs an supervised method to learn weights of the extracted meta paths to form a link prediction model. Experiments on real knowledge database, Yago, validate the effectiveness, efficiency, and feasibility of LiPaP.
