
Data mining algorithms are facing the challenge to deal with an increasing number of complex objects. For graph data, a whole toolbox of data mining algorithms becomes available by defining a kernel function on instances of graphs. Graph kernels based on walks, subtrees and cycles in graphs have been proposed so far. As a general problem, these kernels are either computationally expensive or lim-ited in their expressiveness. We try to overcome this prob-lem by defining expressive graph kernels which are based on paths. As the computation of all paths and longest paths in a graph is NP-hard, we propose graph kernels based on shortest paths. These kernels are computable in polynomial time, retain expressivity and are still positive definite. In experiments on classification of graph models of proteins, our shortest-path kernels show significantly higher classifi-cation accuracy than walk-based kernels.
Kernel methods are a popular method from statistical learning theory [18] with numerous applications in data mining. Kernels allow to perform tasks such as classifica-tion via Support Vector Machines [21], regression [5], clus-tering [1] and principal component analysis [19] using non-linear hypotheses and on a wide variety of different data types.

Early studies on kernel methods dealt almost exclusively with vector-based descriptions of input data. Haussler [10] was the first to define a principled way of designing kernels on structured objects, the so-called R-convolution kernel .
Over recent years, kernels on structured objects such as strings and trees, transducers, dynamical systems, on nodes in graphs [14] and on graphs [8, 13] have been defined. Generally spoken, graph kernels are based on the compari-son of graph-substructures via kernels. Walks [8, 13], sub-trees [17] and cyclic patterns [11] have been considered for this purpose. However, kernels on these substructures are either computationally expensive, sometimes even NP-hard to determine, or limited in their expressiveness.
These disadvantages of existing kernel methods are due to competing requirements in graph kernel design: first, the kernel should be a good measure of similarity for graphs; second, its computation should be possible in polynomial time; third, the kernel must still be positive definite; fourth, ideally, it should be applicable to all graphs, not just a small subset of graphs. Existing graph kernels have difficulties with reaching at least one of these four goals. In this article, we present a class of graph kernels that measure similar-ity based on shortest paths in graphs, that are computable in polynomial time, that are positive definite and that are applicable to a wide range of graphs.
 Outline of this paper In section 2, we will review ex-isting kernels on graphs with respect to their expressivity and efficiency. In section 3, we define a graph kernel based on all paths which is positive definite, yet its computation is NP-hard. In section 4, we define an algorithm for cal-culating shortest-path kernels on graphs which are positive definite, computationally feasible and still expressive. We then test our shortest-path kernel on a classification task on graph models of proteins in section 5. We conclude with a discussion and conclusions in section 6.
Before we will review existing graph kernels, we will state the essential definitions from graph theory necessary to follow our argumentation.
A graph G consists of a set of nodes (or vertices ) V and edges E . In this article, n denotes the number of nodes in a graph and m the number of edges in a graph.

An attributed graph is a graph with labels on nodes and/or edges; we refer to labels as attributes . In our case, attributes will consist of pairs of the form ( attribute-name , value ). The adjacency matrix A of G is defined as where v i and v j are nodes in G . A walk w of length k  X  1 in a graph is a sequence of nodes v 1 , v 2 ,  X  X  X  , v where ( v i  X  1 , v i )  X  E for 1 &lt; i  X  k . natively, walks are often referred to as paths ; paths are then named simple, unique or loopless paths , which may lead to some confusion. To clarify the difference for the remainder of this article, we define a path to be a walk without repe-titions of nodes. A cycle is a walk with v 1 = v k , a simple cycle does not have any repeated nodes except for v 1 .
A Hamilton path is a path that visits every node in a graph exactly once. An Euler path is a path that visits every edge in a graph exactly once.
Random walk kernels are based on the idea to count the number of matching walks in two input graphs. G  X  artner et al. [9] define an elegant approach to determine all pairs of matching walks in two input graphs G 1 = ( V 1 , E 1 ) and G 2 = ( V 2 , E 2 ) via a direct product graph G  X  : where A  X  is the adjacency matrix of G  X  = ( V  X  , E  X  ) , de-fined via
V  X  ( G 1  X  G 2 ) = { ( v 1 , w 1 )  X  V 1  X  V 2 :
E  X  ( G 1  X  G 2 ) = { (( v 1 , w 1 ) , ( v 2 , w 2 ))  X  V 2  X  n must be chosen appropriately for k  X  to converge.
Based on ideas in [13], this kernel is redefined in [3] to measure similarities between walks that are not identi-cally labeled. For this purpose, pairs of walks up to a fixed length k are observed in product graphs consisting of all pairs of nodes and edges -independently from their labels-from both input graphs. Node and edge labels along the walks are compared via kernel functions.

Despite its clear definition, these random walk kernels bear difficulties. The direct product graph may contain | V 1 | X | V 2 | nodes. Even if its adjacency matrix is sparse, it might become full by taking powers of this matrix. Han-dling such a huge full matrix leads to enormous runtime and memory requirements.

Besides computational issues, one observes the problem that small identical substructures in input graphs can lead to high similarity scores. As walks allow for repetitions of nodes, these graph kernels lead to the problem of  X  X otter-ing X , i.e. by iteratively visiting the same cycle of nodes, a walk can generate artifically high similarity values. Thus tottering limits the expressiveness of random walk graph kernels.

Analyzing current random walk kernels, it is obvious that the approach in [3] measuring partial similarity leads to huge product graphs. Keeping to the original random walk kernel by G  X  artner et al. [9], the ability to find partial simi-larities is lost, reducing the expressivity of the graph kernel. Both approaches suffer from tottering.
In [16], steps are undertaken to improve the expressivity and efficency of walk-based graph kernels. Additional la-bels are added to each graph to reduce the number of match-ing nodes in two graphs. This measurement reduces the ef-fort to compute their kernel values, as the number of pairs of walks that have to be considered is reduced.

As a strategy to avoid tottering, the walk-based graph kernel from [13] is redefined such that walks cannot contain sub-cycles consisting of two nodes. However, while the la-bel enrichment has a positive impact on classification accu-racy in the experimental evaluation, forbidding two-nodes-cycles did not lead to a significant improvement.
As an alternative to random walk kernels, kernels based on subtrees and cyclic patterns have been defined. The kernel in [17] compares subtree patterns in graphs. Starting from a node v , a tree is created by adding all nodes that can be reached from v in 1 , . . . , h steps where h is the height of this tree. Obviously, as there is often more than one walk between two nodes, the same node must be in-cluded several times into the subtree. These  X  X opies X  of the same node are treated as if they were distinct nodes; otherwise the pattern would not be a tree any more. This repeated visiting of the same nodes leads to tottering as in walk-based kernels. Furthermore, the number of nodes to consider grows exponentially with the height of the subtree under study. While it seems attractive to deal with more ex-pressive substructures such as subtrees, they increase com-putational costs and do not reduce tottering.

Computing kernels based on cyclic and tree patterns [11] is a further approach to define graph kernels. Instead of counting the frequency of these cycles in two input graphs, an intersection kernel is applied that counts the number of cycles that appear in both graphs. However, the computa-tion of general cycles is NP-hard. To overcome this prob-lem, only graphs are considered that do not contain more than k simple cycles. As a consequence, it is only applica-ble to datasets that fulfill this constraint.

Our approach to define an expressive and efficient graph kernel is to compare graphs based on paths instead of walks. The challenge is to ensure positive definiteness of the graph kernel and to keep its runtime complexity polynomial.
In [17], for directed graphs, a proof is given that graph kernels based on subpaths are not positive definite. In this proof, a path is -as usually -defined as a sequence of nodes, consisting of at least 1 node and without any repetitions of nodes. We will show in the following that defining paths as sequences of neighboring pairwise distinct edges allows to define kernels based on subpaths that are still positive definite.

We will first define paths as sequences of edges. Second, we will prove that our edge-based path kernel on graphs is a positive definite R-convolution kernel. Definition 1 (Edge walk and edge path) Given a graph G= ( V, E ) with { e 1 , . . . , e l } X  E and { v i 1 , v V . An edge walk w = ( e 1 , e 2 , . . . , e l ) is defined as a se-quence of edges e 1 to e l where e i with 1  X  i  X  l is a neigh-bor of e i +1 = e j , i.e. e i = ( v i 1 , v i 2 ) and e j neighbors if v i 2 = v j 1 . An edge path p is defined as an edge walk without repetitions of the same edge.

Note that in the above definition, an edge path may con-tain the same node multiple times, but every edge only once. An edge path p is an Euler path in the graph exactly consist-ing of the edges of p . In the remainder of the paper, we will refer to edge paths and edge walks as paths and walks, re-spectively, unless explicitly stated otherwise.
After redefining paths as edge paths, we are now able to define a kernel on all paths in two graphs.
 Definition 2 (All-paths kernel) Given two graphs G 1 and G 2 . Let P ( G i ) be the set of all paths in graph G i where i  X  { 1 , 2 } . Let k path be a positive definite kernel on two paths, defined as the product of kernels on edges and nodes along the paths. We then define an all-paths kernel k all paths k i.e. we define the all-paths kernel as the sum over all kernels on pairs of paths from G 1 and G 2 .

In the following lemma, we prove that the all-paths ker-nel is a valid kernel.
 Lemma 1 The all-paths kernel is positive definite. Proof:
We define a relation R ( x 0 , x 00 , x ) , where x 0 is a path and x 00 and x are graphs. R ( x 0 , x 00 , x ) = 1 iff x graph that is created when removing all edges in x 0 from x . R  X  1 ( x ) is then the set of all possible decompositions of graph x via R into x 0 and x 00 . R is finite, as there is only a finite number of paths in a graph, since their length is upper bounded by the number of edges. We define a kernel k path on paths as a product of kernels on nodes and edges in these paths; this is a positive definite tensor product kernel [18]. We also define a trivial graph kernel k one = 1 for all pairs of graphs.

We can then define an all-paths kernel as a positive defi-nite R-convolution defined as in [10] with P ( G i ) as the set of all paths in G i , i  X  X  1 , 2 } .
The computation of this kernel, however, is NP-hard, as we will prove in the following.
 Lemma 2 Computing the all-paths kernel is NP-hard. Proof: We show this result by proving that finding all paths in a graph is NP-hard. If determining the set of all paths in a graph was not NP-hard, one could determine whether a graph has a Hamilton path or not by checking whether a path exists with length n  X  1 . This problem, however, is known to be NP-complete [12]. Consequently, determining the set of all paths is NP-hard and therefore the computation of the all-paths kernel is NP-hard.

In [9] it is shown that computing kernels based on sub-graphs is NP-hard. Although we are restricting ourselves to a small subset of all subgraphs, namely to paths, kernel computation is still NP-hard in our case.
While determining all paths is NP-hard, finding special subsets of paths is not necessarily. Determining longest paths in a graph is again NP-hard, as it would allow to decide whether a graph contains a Hamilton path or not. Computing shortest paths in a graph, however, is a problem solvable in polynomial time. Prominent algorithms such as Dijkstra (for shortest paths from one source node) [4] or Floyd-Warshall [6, 22] (for all pairs of nodes) allow to de-termine shortest distances in O ( m + n  X  log n ) [7] and O ( n time, respectively.
The essential first step in our shortest-path kernel is to transform the original graphs into shortest-paths graphs. A shortest-paths graph S contains the same set of nodes as the input graph I . Unlike in the input graph, there exists an edge between all nodes in S which are connected by a walk in I . Every edge in S between nodes v i and v j is labeled by the shortest distance between these two nodes.

Any algorithm which solves the all-pairs-shortest-paths problem can be applied to determine all shortest distance edge labels in S . We propose to use Floyd X  X  algorithm (see Table 1). This algorithm has a runtime of O( n 3 ), is appli-cable to graphs with negative edge weights, but must not contain negative-weighted cycles. Furthermore, it is easy to implement. In the following, we will refer to the process of transforming a graph I into S via Floyd X  X  algorithm as Floyd-transformation .
After Floyd-transformation of our input graphs, we can now define a shortest-path kernel.
 Definition 3 (Shortest-path graph kernel) Let G 1 and G 2 be two graphs that are Floyd-transformed into S 1 and S . We can then define our shortest-path graph kernel on S 1 = ( V 1 , E 1 ) and S 2 = ( V 2 , E 2 ) as where k (1) walk is a positive definite kernel on edge walks of length 1.

In the following, we will prove the validity of our shortest-path kernel.
 Lemma 3 The shortest-path graph kernel is positive defi-nite.

Floyd-Warshall (Graph G with n nodes and adjacency matrix A) for i := 1 to n end for k := 1 to n end
Table 1. Pseudocode for Floyd-Warshall X  X  al-gorithm [6] for determining all-pairs shortest paths.
 Proof: The shortest-path kernel is simply a walk kernel run on a Floyd-transformed graph considering walks of length 1 only. We follow the proofs in [13] and [3]. First, we choose a positive definite kernel on nodes and a positive definite kernel on edges. We then define a kernel on pairs of walks of length 1, k (1) walk , as the product of kernels on nodes and edges encountered along the walk. As a tensor product of node and edge kernels [18], k (1) walk is positive def-inite. We then zero-extend k (1) walk to the whole set of pairs of walks, setting kernel values for all walks with length 6 = 1 to zero. This zero-extension preserves positive definite-ness [10]. The positive definiteness of the shortest-path ker-nel follows directly from its definition as a convolution ker-nel, proven to be positive definite by [10].
 Run time complexity The shortest-path kernel avoids tot-tering, yet it remains an interesting question how it com-pares to the known random walk kernel (measuring partial similarity) in terms of runtime complexity.

W. l. o. g. let us assume that we are dealing with two graphs with n nodes and m edges each. To compute the walk kernel, we first have to determine the direct product graph whose number of nodes is obviously upper bounded by n 2 . We then have to invert the adjacency matrix of this direct product graph; standard algorithms for inversion of an x  X  x matrix require O ( x 3 ) time. As x  X  n 2 in our case, the random walk graph kernel has a total runtime complexity of O ( n 6 ) .

The shortest-path kernel requires a Floyd-transformation which can be done in O ( n 3 ) when using the Floyd-Warshall algorithm. The number of edges in the transformed graph is n , if the original graph is connected. Pairwise comparison of all edges in both transformed graphs is then necessary to determine the kernel value. We have to consider n 2 * n 2 pairs of edges, resulting in a total runtime of O ( n 4 ) .
In favor of the walk kernel, one may argue that the num-ber of nodes in the product graph is only n 2 if all nodes in both factor graphs are equally labeled. This is true for the random walk based on total similarity, whereas the ran-dom walk based on partial similarity always leads to a prod-uct graph with n 2 nodes. Thus, only a random walk kernel which measures total similarity and which creates product graphs with n 4 3 nodes is of the same runtime complexity as our graph kernel. One method to reach this is label enrich-ment as used in [16].
Label enrichment can also be applied to our Floyd-transformed graphs to speed up kernel computation. Both edges and nodes can be enriched by additional attributes. When performing the Floyd-Warshall algorithm, one is usu-ally interested in the shortest distance between all nodes. However, if we store information about the shortest paths, i.e. the number of edges or the average length of an edge in these shortest paths, then we can exploit this extra informa-tion to reduce computational cost. This is done by setting kernels to zero for all pairs of shortest paths where e.g. the number of edges in the shortest paths is not identical, i.e. where w and w 0 are walks and steps ( x ) is the number of edges in walk x . If the steps kernel is zero for a pair of walks, we do not have to evaluate the node and edge kernel.
Even more valuable information for our kernel could be not only to know the shortest path between two nodes, but the k shortest paths. For each of the k shortest paths, one edge could then be created in the Floyd-transformed graph.
Finding k shortest walks and paths in a graph is a well-studied topic in graph theory and applied sciences [23, 15]. Many of the algorithms proposed for solving this problem, however, determine k shortest walks, not k shortest paths. Applying these algorithms would reintroduce the problem of tottering into our path-based kernel. It is therefore es-sential to chose an algorithm for finding  X  X  loopless short-est paths X  in a network. Such algorithms have been pro-posed over 30 years ago [23, 15] and any of those can be run on our input graphs, as long as there are no cycles in our graphs with negative weights. The setback of this method is the increased runtime complexity for determin-ing k shortest loopless paths. Yen X  X  algorithm in [23] re-quires O ( kn ( m + n  X  log n )) time complexity for finding k shortest loopless paths between a pair of nodes. Conse-quently, theoretical complexity would be O ( kn 5 ) for de-termining k shortest loopless paths for all pairs of nodes in a fully connected graph and pairwise comparison of all k shortest paths in two graphs would be of complexity O (( k  X  n 2 )  X  ( k  X  n 2 )) = O ( k 2  X  n 4 ) . As a result, the pre-processing step has a higher runtime complexity than the kernel computation in this case.

A simple way to determine k shortest disjunct paths be-tween two nodes, where no pair of paths shares any identical edge, is to iteratively apply Dijkstra X  X  algorithm to the same graph and to remove all edges that belong to the currently shortest path. Still, this procedure would be of runtime com-plexity O ( n 2  X  k  X  ( m + n  X  log n )) , which could become O ( k  X  n 4 ) in a fully connected graph.
To evaluate the practical performance of our shortest-path graph kernel, we chose a classification task from bioin-formatics [3]. 540 proteins, 90 per class, should be clas-sified into 6 distinct functional classes in 10-fold cross-validation, solely based on protein structure information. We obtained the protein structures from the Protein Data Bank [2] and their corresponding enzyme class labels from the BRENDA enzyme database [20]. We randomly choose 90 proteins from each of the 6 enzyme EC hierarchy top level classes. We translated these protein structures into graph models in which the secondary structure elements of a protein represent the nodes.

Every node is connected to its three nearest neighbors in space. As a simplification, distances between secondary structure elements are calculated as distances between their spatial centers. Edges are labeled by the distance they repre-sent in angstroms. Node bear labels representing their type, namely helix, sheet or loop, and their length in amino acids.
On these graph models of proteins, we ran walk kernels and shortest-paths kernels. As calculating the walk kernel for walks up to infinity results in memory problems, we Table 2. Walk kernel vs. shortest-path kernel.
 Prediction accuracy on 540 proteins from 6
EC classes in 10-fold cross-validation. (st. dev. = standard deviation, e.l. = equal length) approximate it by walks of up to length k, setting kernel values for longer walks to zero. We performed tests for k in the range from 4 to 7. We also employed our shortest-path kernel and the equal length shortest-path kernel on the same data. Furthermore, we ran a 2 shortest-path kernel de-termining the 2 shortest disjunct paths between nodes via Dijkstra X  X  algorithm.

All graph kernels use the same set of node and edge ker-nels. Node types are compared via a delta kernel, i.e. Node lengths are compared via a Brownian bridge kernel, i.e. k length ( x, x 0 ) = max (0 , c  X  X  length ( x )  X  length ( x
The same Brownian bridge kernel is applied to edges to measure their difference in length. c is set to 3 for nodes and to 2 for edges via cross-validation as in [3].
After calculating all graph kernel matrices mentioned above, we predicted enzyme class membership in 10-fold cross-validation for 540 proteins. We performed  X  X ne-class vs. rest X  Support Vector Machine classification and re-peated this for all six EC top level classes. We report results as averages across all EC classes in Table 2. 1
The shortest-path kernels outperform all walk kernels with an accuracy of at least 93.33%. The accuracy level of the worst shortest-path kernel on 540 proteins is signifi-cantly higher than that of the best kernel using walks up to length 4 (Yates- X  2 = 4.8, P = 0.028). As a result, consider-ing shortest paths instead of walks increases classification accuracy significantly.

Among the walk kernels, classification is decreasing with the length of the walks under study. This is an indicator that the longer the walks we examine, the more numerous walks created by tottering get. With an increasing number of tottering walks, classification accuracy decreases.
Among the shortest-path kernels, the 2 shortest-path ker-nels perform slightly better than the equal length shortest-path kernel and the standard shortest-path kernel. How-ever, the accuracy differences between the different types of shortest-path kernels are not significant on our test set.
We have defined graph kernels based on shortest paths, which are polynomial to compute, positive definite and re-tain expressivity while avoiding the phenomenon of  X  X ot-tering X . In experiments on classifying graphs model of proteins into functional classes, they outperformed kernels based on random walks significantly.

The shortest-path kernels prevent tottering. It is not pos-sible that the same edge appears twice in the same shortest path, as this would violate the definition of a path. Subse-quently, artifically high similarity scores caused by repeated visiting of the same cycle of nodes are prohibited in our graph kernel.

The shortest-path kernel as described in this article is applicable to all graphs on which Floyd-Warshall can be performed. Floyd-Warshall requires that cycles with nega-tive weight do not exist. If edge labels represent distances, which is the case in most molecular classification tasks, this condition generally holds.

As all and longest paths are NP-hard to compute, our graph kernel uses shortest paths. As shown in our experi-ments, shortest distances between nodes are a characteristic of graphs which is essential for graph classification in many applications such as molecular graphs or telecommunica-tion networks. However, there might be areas of applica-tion where longest paths or average path or walk lengths within a graph are more adequate and important for classi-fying graphs than shortest paths. Designing graph kernels for specific tasks therefore remains a necessity.
In our experiments, we reached the highest accuracy us-ing a kernel looking at 2 disjunct shortest paths between all nodes. Both are represented by an edge of their own in the Floyd-transformed graphs we ran our graph kernel on. An alternative approach would to model both as one joint edge which bears one label for the length of the shortest path and one for the length of the 2nd shortest path. Defining a proper kernel for combining these two attributes, maybe even giving different weights to the shortest path and the 2nd shortest path could lead to even higher classification accuracy.

An open question concerning our shortest graphs kernels is how to deal with graphs that bear more than one edge la-bel, i.e. in which edges do not represent distances only. As long as one edge attribute reflects some kind of distance between nodes, our algorithm remains applicable. The dif-ficulty is then to include the other edge attributes into the kernel computation. One could think of many different al-ternatives, either taking an average over numerical edge at-tributes along the shortest path or to apply an intersection kernel on sets of edge attributes along two paths. Analo-gously, one might think of a Floyd-transformation which preserves information about intermediate nodes in shortest paths, as in the shortest-path kernels we defined, only at-tributes of start and end node are considered. How to opti-mally include this information into a graph kernel is a ques-tion of kernel engineering. Domain knowledge from the area of application will be most beneficial in this search for a good kernel on a particular type of graphs.

Our shortest-path graph kernel is computable in polyno-mial time. In theory, its runtime complexity for fully con-nected graphs is two powers lower than that of a random walk kernel. In practice, efficient computations for matrix inversion and label enrichment which creates a sparse di-rect product graph matrix will lead to comparable run-time performances of shortest-path kernel and walk kernel.
In future studies, we will look at further connections be-tween graph theory and kernel methods. Graphs in bioinfor-matics promise to be an interesting area of application, as these graphs have particular characteristics (e.g. scale-free networks) that could be exploited in special kernel func-tions.

This work was supported in part by the German Ministry for Education, Science, Research and Technology (BMBF) under grant no. 031U112F within the BFAM (Bioinformat-ics for the Functional Analysis of Mammalian Genomes) project which is part of the German Genome Analysis Net-work (NGFN).

