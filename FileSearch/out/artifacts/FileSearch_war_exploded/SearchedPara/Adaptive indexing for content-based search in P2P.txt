 1. Introduction
Peer-to-Peer (P2P) systems have emerged as an appealing solution for distributed applications, especially for distributed file sharing systems. Many P2P file sharing systems have been successfully deployed, including [18,9,13] , etc. Since these the users can seldom tell the exact titles of published papers and they only have some ideas about the paper topic. As a result, the support of content-based search is necessary for file sharing systems in these fields. Although there are a few approaches for this type of complex search, none of them is applicable in large-scale distributed systems.
In the literature of information retrieval, content-based search has been extensively studied in centralized systems. Sev-eral methods have been proposed to support this type of search. Nevertheless, they share the same requirement that the system must maintain global knowledge, which is used to calculate importance of terms in query processing to avoid the popular term problem. This requirement brings difficulty in applying them in dynamic P2P systems. Early P2P systems sup-global knowledge, or employing the flooding technique to propagate global knowledge to all nodes in the system. The prob-lem is that the former solution is not scalable while the latter is costly.

In this paper, we propose an adaptive indexing approach to supporting content-based search in P2P systems [32]. Our method is based on a combination of a Chord ring and a balanced tree structure. The tree is used to aggregate terms and standard Information Retrieval (IR) technique [31]. According to the weights of terms, the node classifies them as either important or unimportant terms to child nodes. Important terms, which have high values and can be used to distinguish a child node from its neighbors, are indexed in the Chord ring and linked to the corresponding child node. The remaining terms, either popular or rare terms, are aggregated and passed on to the node X  X  parent. The key advantage of this method queries without the need for global knowledge. Additionally, since we only need to focus on important terms in queries, the system can process the queries at any node in the tree without starting from the root. Therefore, even though we employ a our paper are summarized as follows:
We propose a scalable adaptive indexing method to support content-based search in Peer-to-Peer systems. Our method aggregates and classifies terms based on their importance before they are indexed. As a result, our system can process queries on the fly without the need for global knowledge. By aggregating terms to be indexed together, the system also reduces the cost of term indexing compared to conventional methods that index terms separately.

Based on term classification, we design a query processing algorithm where it is not necessary to forward queries towards the root. Consequently, we can avoid the bottleneck problem at the root or nodes near the root.

We introduce several techniques for further improving the efficiency of the structure. These techniques enable the system to perform system maintenance and query processing at a low cost.

The rest of the paper is organized as follows. In Section 2, we review related work. In Section 3, we introduce some pre-liminaries and background knowledge. We present an overview of our system architecture in Section 4 and explain system operations in detail in Section 5. We discuss several improvement techniques in Section 6. Finally, we show an experimental study in Section 7, and conclude the paper in Section 8. 2. Related work
While the idea of using a combination structure of a B -tree and a Chord ring has been introduced in P -tree [6], our proposed method explored these two techniques from a different perspective. Unlike P -tree, which is designed to support range queries, our design purpose is to support content-based search. Therefore, our method is different from P -tree in the way the tree is constructed and maintained. Related work in content-based search in P2P systems mainly focuses on the way to build an efficient distributed index structure for state-of-the-art information retrieval algorithms. Accord-ing to the way indexes are constructed, P2P systems supporting content-based search can be classified into three main categories.

In the first category of P2P systems, each node collects and maintains information about indexed terms from all other node. Systems in this category generally use gossiping algorithms to distribute information among nodes in the system. They siping algorithms are in propagating information from nodes to nodes, it is still expensive to keep the summary information up-to-date with changes in the system, especially in large-scale systems.

In the second category, P2P systems employ a hierarchical summary index tree structure, in which leaf nodes keep doc-ument indexes while internal nodes keep summary indexes of their children. As a result, document indexes are accumulated step by step through internal nodes to give global knowledge at the root node. This tree structure requires queries to be the root by a super-peer network, which includes many super-peers connecting with each other. Although this solution can quires a lot of efforts for synchronizing global knowledge among super-peers in the group. Existing systems that employ hierarchical summary index include [25,20,14 X 16,4,10,30] . Among them, [25,20,14,15,30] share the same idea of using summarizes its shared documents as a leaf-peer summary index. The summary index is then sent to a super-peer in charge peer summary index. Finally, this summary index is broadcast to other super-peers so that all super-peers have the same global knowledge of indexed documents in the system. When a peer wants to issue a query, it simply sends the query to its super-peer. Based on global knowledge and leaf-peer summary indexes maintained at the super-peer, it forwards the query to other super-peers or leaf-peers containing the query results. On the other hand, instead of using only two levels, [16] used a binary tree structure. Nevertheless, the construction and maintenance of summary indexes are similar to the data source in answering a given keyword query. These systems have been shown to work well with disjoint data collections.
However, they are insufficient to cope with independent data collections, e.g., peers are autonomous and crawl the Web independently of each other.
 In the third category, P2P systems extract terms from documents and insert them directly into the overlay network. In dexed into CAN [19], a P2P system supporting multi-dimensional data indexing. Because the dimensional space of keywords in a file is often higher than CAN can support, the system has to resolve the mismatch between them. The solution for this of data. Since indexing data in multi-dimensional space is not efficient, Reynolds and Vahdat [21], Tang and Dwarkadas [28] and Zhou et al. [33] suggested that each retrieved term should be indexed separately into a Chord ring. In particular, Rey-nolds and Vahdat [21] used bloom filters to improve efficiency of query processing when a boolean  X  X  X ND X  keyword is used in queries. However, all these systems share the same property that they have to dedicate some special nodes for keeping work constructed from volunteer peers [26]. These volunteer peers are organized in a DHT structure to maintain global knowledge. Nevertheless, there are similar problems as those in super-peer networks. If the number of super-peers is small,
Chord ring based on similarity of the documents with reference vectors. Even though these systems require no global knowl-a requirement is difficult to meet. In Suel et al. [27], the system employs a two-layered search engine architecture with a global index structure distributed over all nodes. In this system, each single node holds a complete, Web-scale, index for a set of given text terms. The weakness of this system is that it causes high network traffic when indexing document meta-data into the network. Moreover, the query processing technique is only limited to queries with at most two keywords. In a different approach, Bender et al. [1] indexed terms both globally and locally. The system processes a query using local in-dexes initially. If the result is not good enough, the system then processes the query using global indexes. To bring more od to reduce network traffic by using reduced metadata together with discriminative keys. However, the use of metadata when the system is dynamic. 3. Background
In this section, we first introduce a classic information retrieval algorithm used in this paper: vector space model (VSM) [31]. Then we present Chord, which is used to form a part of our system structure. 3.1. Information retrieval algorithm
VSM represents documents as term vectors [24] in Cartesian space. Each element in a term vector represents a term and its importance to the document in a corpus of documents. The importance of a term i is measured by the weight of term w i  X  tf i idf i , in which tf i is the term frequency and idf tf reflects the importance of the term i within the document: tf and P k c k is the number of occurrences of all terms in the document. On the other hand, the inverse document frequency idf reflects the general importance of the term i within the corpus: idf ments in the whole system and N i is the number of documents containing term i . The intuition behind this formula is that a term is a good candidate for representing a document if it frequently appears in the document while it rarely appears in other documents.

In VSM, queries are also represented as vectors whose elements are keywords appearing in the queries. As a result, the tations as follows: 3.2. Chord
Chord [11] is built on a structure where nodes are ordered to form a ring  X  an identifier circle modulo 2 in which the i th entry contains the identifier of the first node s that succeeds n by at least 2 which is the immediate node before the node in the Chord X  X  ring. Fig. 1 shows the structure of a Chord ring with 8 nodes. effort, where N is the number of nodes in the system.
 effort. After that, the successor node takes responsibility for transferring to the new node all data belonging to the new be updated to reflect the possible changes. On the other hand, a node departing from the system needs to transfer all of its stored data to the successor node, which is now in charge of its range of values. Finger tables of remaining nodes need in both node join and node departure takes O  X  log 2 N  X  effort. 4. System overview 4.1. System architecture
In our system, all peers in the network form a Chord ring at the base of the tree structure, from which the tree is built bottom-up. At each level of the tree, adjacent nodes are clustered into groups with size between d and 2 d , where d is the tree order. Nodes in the same group are connected to each other. Each group of nodes has a parent node at the immediate parent node does not hold documents, to distinguish it from leaf-peer nodes that hold documents, we call it virtual node.
Each virtual node, which is an internal node, is assigned to a peer, which holds a descendant leaf node of the virtual node that has not been assigned to any other virtual nodes yet. It means that in the system, each peer maintains a Chord node that is a leaf node, and at most one internal virtual node. In Fig. 2 , nodes with the same name are maintained by the same peer. Note that since no peers can maintain more than one virtual node , there are no internal virtual nodes with the same name in the tree.
 that of B -tree. 4.2. Index structure
In the tree structure, shared documents are stored at leaf nodes, which are real peers. To build indexes for documents in the system, at first, each leaf node summarizes all terms  X  T uments, and the number of documents containing this term at the node.
 indexes of its children: e ; f ; g ; h .

From summary vectors received from child nodes, each internal (virtual) node identifies important terms for each child
Section 3.1: w i  X  tf i idf i ,withalittledifference.Here, tf c reflects the general importance of the term i within all nodes in the group: idf inversedocumentfrequency IDF ,andinformationof thehostnode N  X  X heinternalnodewheretheimportanttermcomes from.
The remaining terms classified as unimportant are aggregated to generate a new summary vector of the current node, which is then passed on to the parent node for further processing.
 the system selects suitable tree nodes to forward the query. Using the summary vectors, these tree nodes then continue to process and forward the query down the tree until leaf nodes, where documents are held. Details of the query processing algorithm will be introduced in Section 5.3.2. 5. System operations
In this section, we present the system operations in detail. First, we describe the system construction. Then, we discuss the group management and index management. Finally, we show how the system reacts to failures. 5.1. System construction 5.1.1. Node join When a node wants to join the network, it joins the Chord ring first by contacting with an existing node inside the system.
Upon receiving the information, the parent node notifies other children in the group about the existence of the new node so that they can set up links to the new node. Then, the parent node classifies terms of the new node into two categories (see
Section 4.2). One is important terms, which can be used to distinguish the new node from existing nodes in the group. These terms are then indexed into the Chord ring linked to the new node. The other is unimportant terms which include popular and rare terms. These terms are aggregated into the group summary index. Finally, if there is a significant change in the group summary index, the group parent node sends an update to its parent, which may repeat the same process. For exam-ple, Fig. 3 shows the process of updating summary indexes when a new node q joins the tree. After joining the Chord ring, q joins the group of its successor l . As a result, it needs to submit its summary index to the group parent i index of i 0 has changed significantly, i 0 updates its parent d no group splitting is triggered, it takes k efforts ( d 6 group. Otherwise, it takes some extra efforts for group splitting. The second part includes the cost of indexing important terms and the cost of updating summary indexes of ancestor nodes, which are affected by the appearance of the new node.
Usually there is only one or a few ancestor nodes involved in this process. 5.1.2. Node departure neighbor group (see Section 5.2.3). When a node receives a LEAVE request from its child, it removes indexed terms (impor-tant terms) belonging to the corresponding child from the Chord ring, and recalculates summary index of the group. If there is a significant change in the summary index of the group, the node sends an update request to its higher parent node as in the case of node join process.

The cost of this departure process also includes two parts: the cost of removing links from the Chord ring and the tree structure, and the cost of removing indexed data. The cost of the first part is O  X  log or merge groups. The second part includes the cost of removing indexed terms involved in the departure node plus the cost of updating summary indexes of ancestor nodes, which are affected by the node X  X  departure. 5.2. Group management 5.2.1. Group splitting
When a group is overloaded, group splitting is triggered. In this process, the group X  X  parent node divides the group into simple. At first, a FIND_HOLDER request is created and sent to a random child of the new virtual node. When a node receives group splitting continues to be triggered at that group. Fig. 4 shows an example of group splitting for an overloaded group managed by node a . As a result, the group is split into two smaller groups. Summary indexes of these two groups need to be calculated and sent to the higher parent node z . Old indexed terms involving a need to be removed. New important terms involving a and f are calculated and indexed into the Chord ring by z . 5.2.2. Node moving
When a group is under-loaded, its parent node can ask the parents of neighbor groups for some nodes. If a neighbor group has more than d children, some nodes in that group are moved to the under-loaded group. In this case, indexed terms involv-ing moved nodes are recalculated at the new place. Some existing important terms may be removed while new important terms may be indexed into the Chord ring. On the other hand, if all neighbor groups only have a minimum number of nodes required to form a group, and hence there are no movable nodes, group merging is performed. 5.2.3. Group merging
Group merging is performed between an under-loaded group and its neighbor group. To form a new bigger group, one group X  X  parent node becomes redundant and needs to step down. Since the number of nodes in the group of the stepped down parent node is reduced, that group may become under-loaded, and a similar process, either node moving or group merging, may be executed for that group. Fig. 5 shows an example of group merging.

Similar to group splitting, group merging requires recalculation of summary index for the reelected parent node after merging. Old indexed terms of the stepped down parent node need to be removed, while indexed terms of the reelected par-ent node need to be adjusted according to the new summary index of the group. 5.2.4. Cost of group management
The cost of group splitting includes the departure cost of one node, joining cost of two nodes, and the cost of updating links among nodes in the two groups. Similarly, the cost of node moving includes the departure cost of one node and joining cost of one node plus the cost of updating links among nodes in the two involved groups. Finally, the cost of group merging can be considered as the departure cost of two nodes and joining cost of one node plus the cost of updating links among nodes in the merged group. In all cases, the cost of updating links is k , the number of child nodes of groups involved in the process. 5.3. Index management 5.3.1. Document insertion and deletion
When a new document is open for sharing at a node or an existing shared document stops sharing, the node needs to recalculate its summary vector, and send the updated vector to the parent node. Since adding or removing a document may turn some important (unimportant) terms into unimportant (important) terms at the node, the parent node needs to reclassify terms for the node. Some existing important terms of the node, which have been indexed before, may be removed. is a significant change in the summary index at the parent node, the parent node sends an update to its higher parent, and the same process will be repeated up there.
 Note that node joining/departure and document adding/removing may change the importance of terms in the group.
However, we do not recalculate the weights of terms in existing nodes each time these operations are performed. It is be-cause term classification may turn some important terms into unimportant and vice versa, and hence these terms need to be reindexed, which may be costly. Nevertheless, without recalculating, term classification may be incorrect after a period of 5.3.2. Query processing score between each of involved tree nodes and the query is computed as follows: where Q is the query, t i is a term appearing in Q , N is a tree node containing some terms, tf quency and inverse document frequency of term i at node N , respectively, and idf i among all nodes involved in the query. Note that, here, idf flects the importance of term i compared to all other terms in the query.

The above formula does not take into account the situation when extracted terms of a peer are indexed at several nodes illustrated by the following example in Fig. 6 . Assume that a node wants to issue a query containing three terms: t
By gathering statistical information, the similarity scores and terms indexed at nodes are  X  0 : 2 ; t  X  0 : 4 ; t 3  X  at node c ,  X  0 : 5 ; t 3  X  at node d , and  X  0 : 5 ; t scores of node d and e . The reason is that c has a high possibility to store not only t terms indexed at an internal node are aggregated from lower level nodes. If a term is an important term of an internal node (hence indexed there), it should be a popular term of lower level nodes. To improve the similarity score measurement, we revise the formula to the ancestor X  X escendant relationship between nodes. As discussed in the previous section, since a new node always joins the group of its immediate successor, nodes in a group are adjacent in the Chord ring. It means that we can keep them in order by their Chord identifiers. In addition, as in B -tree structure, group splitting, node moving, and group merging can be performed in a way that such an order is still kept at higher levels. Thus, we propose a simple method to identify the imum value of the leftmost node, and the maximum value of the rightmost node (in the Chord ring, a node stores indexes tifiers covered by a node is only changed during the four operations: group splitting, node moving, group merging, and the effort is required to maintain the range of identifiers of descendant leaf nodes at each internal node.
The second phase of query processing starts when the calculation of similarity scores for tree nodes is finished. In this phase, the query requester node needs to send the query to the top k leaf nodes that are real peers having the highest similarity scores with the query. 2 Since an internal node ultimately represents a group of leaf nodes, the query received by it can eventually reach several leaf nodes. In order to make the number of leaf nodes receiving the query be k exactly, request, it behaves in the same way as the query requester node to forward the query and assign the granted distribution quester peer. The full search algorithm is described in Algorithm 1.
 tree. Consequently, the maximum number of steps taken by the search algorithm is bounded by O  X  log while higher level nodes (nodes near the root) and the root keep popular terms and rare terms. As a result, even though the querying processing is usually done with important terms, and hence it is CONSTRAINED to low level nodes. 5.4. Failure handling
One concern about P2P system is that the system may be PARTITIONED if one or some nodes fail. In this section, we intro-duce our algorithm for recovering node connections in case of failure.

Algorithm 1: Search (Node N , Query Q , Quota U ) if N is a leaf node then else endif
Failure of a node can be detected when another node tries to contact with it. Since Chord provides a good failure recovery summary index to this node. Upon receiving enough information from all nodes in the group, the new virtual node can re-cover the index data. The next step is reconnecting the new virtual node with its parent. For this job, we modify our tree structure a little bit to allow the leftmost nodes of groups to keep an additional link to their grand parent. just needs to notify its grandparent about the new virtual node so that the connection between the new virtual node and its
Since nodes in the same group have links to each other, the leftmost child of the failure node can always be found. 6. Improvement techniques
A potential problem of our system is that terms may not be classified correctly after a period of operation running. Any operation, node joining/departure or document sharing/unsharing, may change the term classification, but no action is taken acceptable. We call this improvement technique  X  X  X roup refreshment  X  and present it in the first part of this section. We use subsequent parts to introduce other improvement techniques to reduce the cost of reindexing terms, to improve effi-ciency of query processing and to balance the load of nodes in the system. 6.1. Group refreshment
Periodically, the parent node of a group needs to recalculate and reclassify terms of nodes in the group from their latest changing from popular/rare to important are indexed to the Chord ring, while terms changing from important to popular/rare are removed from it. After that, the new summary index of the group is recalculated and sent to the higher parent node. 6.2. Similarity-based grouping
Since the cost of group refreshment may be expensive if there are many terms in need of reindexing, we propose a tech-are similar to its own popular terms (or in other words, the new node and nodes in the group share a common interest), the terms) with it for actual joining. In particular, a new node joins the system in two phases as follows: (1) Trial phase : in this phase, the new node first computes its summary vector and selects the top-10 popular terms from (2) Actual phase : in this phase, the new node first calculates the similarity between its summary vector and each of sum-
In addition to reducing the cost of group refreshment, this strategy also improves the effectiveness as well as the effi-would be probably located in the same subtree whose root node has a much higher similarity score than other nodes. There-fore, the query requester node only needs to focus on sending the query to this node. Furthermore, since a node has a tendency to look up information similar to its interest (or similar to documents it is sharing), the query can be processed it first calculates the similarity score between the query and the summary index of its shared documents. If the similarity mal query processing procedure in Section 5.3.2 is executed. 6.3. Buddy cache
Since peer nodes usually do not change their interest quickly, we can further improve the process of finding a similar are still alive. The most similar interest group is selected among contacted nodes. 6.4. Load balancing
Even though terms are uniformly hashed into the Chord ring, the system may be still unbalanced because a term can be indexed several times in different groups, and hence different terms can have different number of index times. Furthermore, of nodes may not be totally uniform. As a result, a good load balancing strategy is necessary.

In our system, we apply similar load balancing techniques proposed in [3,12] with some modification. In particular, in-pretends to be several distinct peers. Each of them participates independently in the Chord ring. Among them, one is master node that keeps summary index of the peer. Others are slave nodes without shared documents. The slave nodes join the
Chord ring in heavily loaded regions for load balancing purpose only. Load balancing can also be done when an existing peer peer to balance the load. 7. Experimental study
To evaluate the performance of our system, we built a Peer-to-Peer simulator using Java JDK 1.5, and ran it over Planetlab port number. As a result, each Planetlab node can be used to simulate hundreds of peer nodes. The simulator uses several parameters to control different properties of simulated networks. Table 1 lists important parameters and their default val-at a node considered as important terms, and hence to be indexed to the Chord ring; TopK is the maximum number of leaf nodes, which can receive the query; RefreshmentTime is the total number of operations received at an internal node after which it refreshes the group (reclassifies terms for its children).

We compared our system with two other systems that represent two main categories of content-based search P2P sys-tems. One is Sipper [33] that indexes terms directly into a Chord ring. The other is a HiWaRPP-like system that employs a
We change the binary structure used in HiWaRPP to make its tree structure similar to that of our system. Another reason is while in Sipper, global knowledge is co-maintained at log N nodes.

We evaluated all systems on three datasets. The first one is the benchmark dataset containing four different types of doc-uments: MED, CISI, CACM, and TIMES used by Smart [2], with 1033, 1460, 3204, 425 documents and 30, 35, 64 and 83 que-ries, respectively. The two remaining datasets are the 2005 TREC publish spam corpus consisting of 84,053 files obtained from http://plg.uwaterloo.ca/gvcormac/treccorpus/ and the Wikipedia dataset containing 1,000,000 articles downloaded randomly from the categories of TREC and Wikipedia.

For each experiment, sample documents in the dataset were randomly distributed into nodes for indexing and queries with one to four terms were tried. Table 2 presents some characteristics of these two types of datasets. 7.1. Effectiveness of query processing ries in which precision is defined as the ratio of the number of returned documents that are relevant to the query over the total number of returned documents, recall is calculated as the ratio of the number of returned documents that are relevant to the query over the total number of relevant documents in the corpus, and query latency is represented by the average ized algorithm as the sample results to calculate precision and recall of our method. The results are shown in Fig. 7 .
As shown in Fig. 7a and b, in all datasets, our system and Sipper outperform the HiWaRPP-like system. Although both our system and the HiWaRPP-like system are built on similar hierarchical tree structures, they use different indexing and query processing strategies, which leads to their performance difference. In the HiWaRPP-like system, indexed terms are summa-of reducing correctness due to query forwarding from the root to internal nodes, and thus achieve better performance than the HiWaRPP-like system. In fact, the same argument can lead to a conclusion that the performance of our system should be worse than that of Sipper, because Sipper is constructed on a flat structure. However, our system turns out to achieve com-parable results to Sipper. The reason is that our system benefits from grouping nodes with similar interest. By doing this, once a query is sent to the right group, the results are usually good.
 processing a query, the HiWaRPP-like system takes a maximum of 2log to the root, and log d N steps for processing the query from the root to the leaf. As for Sipper, it requires log log 2 N  X  log d N steps: log 2 N for retrieving indexed important terms, and log structure. It means that if d is large enough, e.g., d &gt; 4, we have 2log like system wins. Note that even though the boundary of query processing steps in our system is O  X  log queries in our system are only forwarded to leaf nodes or nodes near the leaf in the second phase of query processing. 7.2. Efficiency of term indexing
Efficiency of term indexing is measured by two metrics: the average number of communication messages required at a node for document indexing, and the workload distribution among nodes in the system. The workload of a node is the num-ber of queries a node receives and processes. In our system, the number of communication messages required for document indexing covers both the initial indexing messages and subsequent messages required for reindexing terms due to important term reclassification at interval time during the experiment. The results are shown in Fig. 8 .

Fig. 8 a shows that in all datasets, the HiWaRPP-like system requires the smallest number of communication messages for document indexing compared to the average number of messages required by our method and Sipper. In the HiWaRPP-like system, all terms are summarized and indexed as a whole summary index vector at the parent node, while both Sipper and our method require terms to be indexed separately into the Chord ring. However, since popular terms in our system are grouped and indexed together at higher level nodes in the tree structure, we can significantly reduce the cost of indexing these terms compared to Sipper (17% for the benchmark dataset, 47% for the TREC dataset and 62% for the Wikipedia datasets is due to the fact that the more terms and documents are indexed, the greater number of popular terms are grouped and indexed together. Among the three systems, our system has the best workload distribution as shown in Fig. 8 b (based on
TREC dataset). It is because both the HiWaRPP-like system and Sipper require to keep global knowledge at some nodes in the system. As a result, the workload is very heavy at these nodes. On the contrary, our system does not need to keep global knowledge, and hence there are no nodes suffering from much heavier workload. Besides, we also note that the workload distribution of the HiWaRPP-like system is even worse than that of Sipper. The reason is that in the HiWaRPP-like system, the workload is heavy not only at nodes keeping global knowledge, which are super-peer root nodes, but also at high level nodes near the root, since queries are processed from the root to the leaf.

Although a group of nodes is used to keep global knowledge in both Sipper and the HiWaRPP-like system, bottleneck is still a potential problem in them. As shown in Fig. 8 c, the maximum query load of a node in these systems is much higher than that in our system. Such high workload can be reduced if more nodes are added to the group keeping global knowledge.
In this case, however, the cost of maintaining consistency of global knowledge among nodes in the group also becomes more expensive, since any change in global knowledge at a node needs to be broadcast to all other nodes. On the other hand, by avoiding keeping global knowledge, our system avoids the severe problems of bottleneck, single point of failure, and the expensive cost of maintaining global knowledge. The results confirm the scalability of our system. 7.3. Effect of varying TopK
In this experiment, we evaluate the effect of varying TopK on precision and recall of the three systems using the TREC creased with the increasing of TopK . This result confirms the advantages of our system and Sipper over HiWaRPP-like. An-caused by the difference in benefit obtained by nodes grouping. If nodes are well grouped that is similar interest nodes are grouped together, our system outperforms Sipper. Otherwise, Sipper is better than ours. 7.4. Effect of varying network size In this experiment, we evaluate the effect of varying network size on precision, recall, and latency of queries using the also increases while the precision and recall decrease. The query latency increases because with the increasing of network among a large bundle of nodes. However, it is interesting to realize that the performance degradation of our system is less than that of Sipper and HiWaRPP-like systems. It is because the effect of diverse content in our system is reduced signifi-cantly by grouping nodes that share similar interest. 7.5. Effect of varying tree order
Fanout of the tree or tree order is an important factor in the tree structure, which has a major impact on the communi-of a big group is more expensive than that of a small group. For example, there will be more nodes and more terms involved
On the other hand, if we set IndexPercent to 0, our system is similar to HiWaRPP-like. 7.6. Effect of varying refreshment time such as node joining/departure, data insertion/deletion, or group merging/splitting happens inside the group (if such oper-count the number of such operations for each node, and trigger term reclassification once this number reaches the
The result shows that when we increase the refreshment time, the cost of term indexing is reduced because the cost of term changes in the group, it takes a longer time to correct it, during which queries may be sent to incorrect nodes. 7.7. Experimental summary In conclusion, throughout our experiments, we have confirmed that our system is much more efficient than the Hi-
WaRPP-like and Sipper systems. In particular, without the need of maintaining global knowledge, our system can avoid the potential bottleneck problem at nodes keeping global knowledge. Hence our system has a better workload balance among nodes than the other two systems. This result also implies that our system is more scalable than the other systems.
Furthermore, by employing a combination of a hierarchical tree and a Chord ring to index terms, and by introducing a tech-nique to group nodes sharing similar interest, our system gets much better performance on precision and recall compared to the HiWaRPP-like system. On the other hand, compared to Sipper, our system significantly reduces the cost of indexing while still achieves comparable results on precision and recall. 8. Conclusion
In this paper, we proposed an adaptive indexing approach to supporting content-based search in Peer-to-Peer systems. In ing terms based on their importance, our system can process queries without the need for global knowledge. As a result, our system avoids several severe problems caused by maintaining such global knowledge. Nevertheless, it still achieves compa-on a tree structure, our search algorithm guarantees no bottleneck at the root or nodes near the root. In addition, we also introduced several techniques to further improve the system performance. Finally, our extensive experiments demonstrated the effectiveness and efficiency of the proposed approach. Acknowledgements
The work is partially supported by National Natural Science Foundation of China (Grant Nos. 60496325, 60673137 and 60673134) and National Hi-tech R&amp;D Program of China (Grant No. 2006AA01Z103).

References
