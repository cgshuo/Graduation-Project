 Getting user X  X  accurate location is the foundation of location-based service. Ex-isting localization systems[1,2,3,4] return user X  X  location by using gps , gsm , wi-fi ,etc.Using gps [4] to find the location has its own limitation because of the requirement of an unobstructed line of sight to four or more gps satellites. Some other methods use gsm [5,6,7] cellular tower, which has the drawback of a lower accuracy. Using wi-fi [8,9,1] to locate the user has been more and more popular because it can provide a more stable service than gps and achieve a much higher accuracy than gsm localization systems. A fingerprint-based wi-fi localization method[2,10] first maps the existing fingerprints (a list of signals with unique identifer and signal strength) with locat ions and generates us er X  X  location based on the similar fingerprints. In this paper, we present a fingerprint-based local-ization system called Polaris , solving three challenges: accuracy, efficiency and fingerprint database validity.
 (1) The accuracy of a fingerprint-based localization system mainly depends on the number of fingerprints. The fingerprints should cover all the regions and more fingerprints bring a higher accuracy. E xisting methods either requires care-ful deployment of access points[2] or a pro fessional crew with specialized and ex-pensive equipment to perform wardriving[3]. In our system, we use fingerprints contributed by anonymous users and give them credits. In this way, Polaris captures a large quantity of fingerprints and always keeps the database fresh. (2) In order to achieve a higher accura cy, the system needs massive finger-prints; however, the similar fingerprint candidates for a single query can be sev-eral thousand; therefore, if the raw fingerprints are not preprocessed and indexed properly, the search efficiency would be low. We introduce an effective localiza-tion model and devise a novel cluster-based indexing method to select represen-tative fingerprints, decreasing the number of candidates. Our search algorithm can effectively find the user X  X  location and the pruning technique improves the performance greatly. (3) For those changing conditions, i.e., existing wi-fi access points being moved or removed, the system has a mechanism to capture changes immediately and refresh the fingerprint data sets. Polaris maintains the coarse locations of access points and when a fingerprint comes , it first inspects the validity of the in-dex. We also give an expired time for fingerprints and index them incrementally. To summarize, we make the following contributions.  X  We design and implement an innovative metropolitan-scale localization sys- X  We develop a localization model base d on novel similarity measures of fin- X  We devise a cluster-based incremental representative fing erprint selection  X  We have conducted an extensive set of experiments and results show that The rest of this paper is organized as follows. Section 2 formulates the localization problem and gives an overview of the system. The Polaris model is presented in Section 3. We introduce the detail of search algorithm and improved repre-sentative selection algorithm in Section 4 . Experimental results are provided in Section 5. We review the related work in Section 6 and make a conclusion in Section 7. Problem Formulation. Formally, our paper considers a set of fingerprint data F . Each fingerprint f  X  X  contains a set of signal sources S and a location l , i.e., f = S ,l . The similarity value between f i and f j is denoted by Sim ( f i , f ), which will be discussed in Section 3. Specifically, each s  X  X  has a unique identifier p and a value  X  , representing the receive d signal strength, i.e., s = p,  X  . The query from a user is a fingerprint without location, denoted by f x . Giving a threshold  X  , our problem is to find all the similar fingerprints f i  X  X  such that Sim ( f i ,f x ) &gt; X  and uses f i to generate the user X  X  final location. Polaris Framework. Polaris framework contains a search part to find the accurate location and a repr esentative selection part t o cluster the fingerprints.
Our localization system first uses the collected fingerprin ts to construct a signal index in order to map each fingerprint to its location. When a user queries, system finds the fingerprints that have higher similarity values with the query and generates the location using those fingerprints. To reduce the index size and increase the search speed, our representa tive selection framework clusters the similar fingerprints and gener ates representative ones.

As an example, Figure 1( a ) shows a signal map containing eight fingerprints f , f 2 ,..., f 8 . The map is established before the search process, using the data con-tributed by users. When a query f x , the star, comes, it compares with f 1 , f 2 ,..., f 8 to find the fingerprints that have the higher similarity values with f x , for exam-fingerprints. For the similar fingerprints, we use a cluster-based representative selection method to merge them in to one fingerprint. In Figure 1( c ), the eight fin-gerprints are clustered into three regions and generate three new representative fingerprints based on our similarity function.
 System Architecture. The Polaris system includes three components: 1) Collector : This component collects the data submitted by anonymous users when they are able to access their loca tions. For example, users can submit data when they are on their way to sup ermarkets or to a park. We give them credits to encourage them to upload data; t herefore, we can automatically collect data without carrying the burden of mapping the whole world by ourselves. The quantity and quality of the data can also be guaranteed. 2) Selector : Since users can submit millions of fingerprints each day, this com-ponent is crucial to our system. For those noise and repeated data, this compo-nent first cleans them to reduce the data size. It then clusters the cleaned data to find representative fingerprints in order to further reduce the index size and decrease the search time, achieving the metropolitan-scale localization, based on the similarity function we design. Finally, it builds up a signal index for the search step. 3) Searcher : Using the signal index and a similarity function, this component finds the user X  X  location. When a query comes, system generates the fingerprint candidates from the index and calculates the similarity value of each candidate with the query. The result location is generated from those fingerprints that have higher similarity values. We present the Polaris models: a similarity model for measuring the similarity of two fingerprints and a localization model for generating the final location. Similarity Model. The similarity function is used to represent how similar two fingerprints are. It groups the signals into levels and then calculates the similarity value of each signal pair to generate the final value of two fingerprints.
The signal strength  X  , measured by dBm (decibel relative to one milliwatt), has a range from -60 dBm to -99 dBm. Values that are greater than -60 or less than -99 are considered as noise points caused by equipment mistakes or signal disturbances. P =10  X / 10 shows the relation between absolute power P and dBm. For a 3 dBm increase, the power is roughly doubled. In real experiments, we find out that although in a fixed location, the  X  from an access point may change for 4 dBm to 6 dBm from time to time caused by the disturbances of the other signals. To minimize fluctuations in the received signals, we group the signals into eight levels from 1 to 8 using Equation 1. For example, a signal with  X  =  X  72 is grouped into level 6. This level mechanism can describe the similarity value of two signals properly and precisely, taking both the number differences and the si gnal powers into consideration. Since we have already grouped the  X  into different levels, we can use Equation 2 the difference of two signals, measuring the distance between them. For ease to compare, we normalize the difference into [0 , 1] by dividing 2 8 and the normalized value is then subtracted by 1 to form the final similarity value. Here are some examples:  X  ( For two fingerprints, the number of same signal pairs takes a large weight in the function. In Table 1(a), f 1 and f x have four same signals, s 1 ,s 3 ,s 4 ,s 6 while f 4 and f x have five same signals, s 1 ,s 3 ,s 4 ,s 8 ,s 9 . Therefore, the similarity value Sim ( f 4 ,f x ) should be greater than Sim ( f 1 ,f x ). Equation 3 shows the similarity function of f i and f x ; the similarity value is the sum of  X  plus n ,thenumberof same signals.
 Suppose the example in the Table 1(a), Sim ( f 1 ,f x ). The two fingerprints have  X  3 +  X  4 +  X  6 +4=0 . 9375 + 0 . 5625 + 0 . 9766 + 0 . 875 + 4 = 7 . 3516. Localization Model. Based on the similarity model, we first find several finger-prints that have higher values. Using the locations of those fingerprints, system generates the final location for user.

The number of fingerprints used to generate the location is an important fac-tor. We sort the values first. If the value differences are greater than a threshold, we stop getting fingerprints and use those to generate the location; however, when the differences are sma ll, this process may add more fingerprints and the result location would be less accurate. Therefore, we use an alternative way, which is to use a constant number of fingerprints.
 Giving a number  X  ,weusethetop  X  fingerprints to generate the final location. A straightforward method is to use the most similar fingerprint as the result. This method is called NN method. Another way is to use  X  fingerprints, which is called  X  NN. For  X  NN, we use the locations of the  X  fingerprints to generate a mini circle and the center of the circle is the user X  X  location; however, this would bring errors since the mini circle can be large and the center may be influenced by less important fingerprints. An alternative way is to calculate the average location. In the real experiments, we find that using the average value as the final result has a better performance.
 Suppose the example in Table 1(a). We first calculate Sim ( f 1 ,f x )=7 . 3516, Sim ( f 2 ,f x )=9 . 0703, Sim ( f 3 ,f x )=7 . 6406 and Sim ( f 4 ,f x )=9 . 6797 and then sort them as f 4 ,f 2 ,f 3 ,f 1 .Fora  X  = 1, the location of f x is the location of f 4 . For  X  = 2, the location is generated by the locations of f 4 and f 2 . Algorithm 1: Basic Indexing Algorithm In this section, we introduce the detail of Polaris algorithm. In Section 4.1, we describe the Polaris index. The search algorithm and the pruning technique will be presented in Section 4.2. To further im prove the search efficiency, we devise a cluster-based representa tive fingerprint selection algorithm in Section 4.3 and an incremental improvement of it in Section 4.4. 4.1 Indexing Scanning each f , Polaris builds an inverted index for each signal s , denoted by I s . I s includes a list of f that contains s . Table 1(b) shows an inverted index example, using the raw data f 1 ,f 2 ,f 3 ,f 4 in Table 1(a). For example, for s ,itappearsin f 1 , f 2 and f 4 ; therefore, the inverted index I s 3 contains those fingerprints. We give the pseudo-code of our indexing algorithm in Figure 2. 4.2 Search Algorithm Finding Candidates. Polaris finds out all the fingerprints f i that has inter-sections with f x ( S i  X  X  x =  X  ) and puts the result in a set to avoid duplication. The finding process can be easily achieved by visiting all the I s where s  X  X  x . Sorting Candidates. For all the fingerprint candidates, Polaris calculates the similarity value using Equation 3. All the values are maintained in a max-heap. The fingerprint algorithm terminates and returns several fingerprints that have greater similarity values.
 Generating Location. The algorithm gets  X  top fingerprints that have larger similarity value, using the model mentioned in Section 3. After calculating the average location, it gives the location back to the user. Algorithm 2: Search Algorithm Pruning Technique. From Equation 3, we see the similarity value is no more than twice the number of same signals, Sim ( f i ,f x )=  X  + n  X  2  X  n . Therefore, we use 2  X  n as an upper bound and the algorithm can be terminated without calculating all the similarity values. Since we want to find the top  X  fingerprints, we first sort the fingerprint candidates using the value of n . During the query, we maintain  X  fingerprints in the heap. For the current fingerprint that we need to calculate the similarity value, if 2  X  n is less than the smallest similarity value in the heap, it means from that fingerprint, all the remaining ones cannot be greater than the least in the heap so they cannot be added. Therefore, the search process can be terminated and the finger prints in the heap are the ones we need.
For example, in Table 1(a), we set  X  = 2. We first sort the fingerprints based calculating Sim ( f 4 ,f x )=9 . 6797, the fingerprints in the heap are f 4 , f 2 .Forthe next fingerprint f 1 ,2  X  n = 8, which is less than the smallest value Sim ( f 2 ,f x ). Therefore, the algorithm is terminated and the average location of f 4 , f 2 is given to the user.

We give the pseudo-code of our search algorithm in Figure 3. Polaris first initiates a set to maintain the fingerprint candidates and a max-heap for sorting the candidates with their similarity values (line 2). Then it finds all the finger-print candidates that need to be compared with f x (line 3), sorts them based on the number of same signals (line 5), and puts the sorted results in a list. The algorithm calculates the similarity value using Equation 3 and puts the result into the heap. It terminates based on the pruning mechanism (line 6 to 11). The final location is calculated using the model we mentioned in Section 3 (line 12). 4.3 Cluster-Based Representative Selection For our metropolitan-scale localization system, the fingerprints collected each day can be more than a million. Maintaining all the fingerprints in the index lowers the search efficiency and gives burden to the server. Therefore, we present a cluster-based method to select representative fingerprints, indexing those fin-gerprints to get a better efficiency.
 For a single fingerprint f i , the system first visits all the fingerprints that have already indexed, comparing with them using Equation 4. Equation 4 is the sum of similarity values of each similar signal  X  divide the number of same signals n . It has a slight difference with the similarity function we have defined in Equa-tion 3. Using Sim , we can modify all the similarity values into [0 , 1] in order to control the selection rate. Suppose the example in the Table 1(a), Sim ( f 1 ,f 4 ). Sim ( f 1 ,f 4 )=(  X  1 +  X  3 +  X  4 ) / 3=(1+0 . 8125 + 0 . 9766) / 3=0 . 9297.
After calculating all the similarity values, we find the fingerprint f k with the greatest Sim and compare it with a threshold  X  . If the value is greater than  X  , the two fingerprints f i and f k are similar to each other and can be merged together. We modify the signals in f k and the location of f k . However, if the value is less than or equal to  X  , it means that no fingerprints are similar to f i so we index it and insert it into the fingerprint list as a new one. For example, in Table 1(a), Sim ( f 2 ,f 4 )=0 . 9395. If  X  is 0.95, then the two fingerprints cannot be merged. If  X  is 0.93, then they can be merged together.

We should also take the validity of the fingerprint into consideration since the access points are frequently modified. The basic method is to rebuild the index for every constant period t , for example, five days. During the t period, Polaris accumulates the data submitted by the users and then selects the representative fingerprints. We give the pseudo code in Figure 4.
 Algorithm 3: Cluster-Based Represent ative Selection Algorithm 4.4 Incremental Representative Selection Using the basic method has some drawbacks. First and foremost, during the t pe-riod, some existing access points may be al ready relocated or removed; therefore, the data cannot be trusted. What is more, when we rebuild the index, the service may stop for a few moment, making it inconvenient to use. Therefore, our goal is to generate the representative fingerprints using an incremental algorithm.
The difference between basic and increm ental method is that we rebuild each signal X  X  index instead of rebuilding the whole index. For every signal, we generate a coarse location to approximately repre sent the location of that access point. When a fingerprint comes, Polaris compares the coarse location of each signal in the fingerprint with the location of that fingerprint. If the location is far away from the coarse location for  X  , for example, 3 kilometers, it means that access point may have been moved. That si gnal should be elim inated from all the fingerprints and the index should also be rebuild.

We give the pseudo-code in Figure 5. For each signal in f , it tests validity of the data and modifies the index if the access point has been moved (line 4). It then compares with the existing fingerprints to calculate the similarity value (line 7). If the top value in the heap is greater than  X  , then the two fingerprints are similar and can be merged together (line 10). Otherwise, it adds f into the set and indexes it as a new one (line 12). We have implemented the Polaris system and conducted a set of experiments on real data sets. We used the data contributed by users in three different regions: a community, a commercial district and a high technology industrial area. We then collected data in thes e regions and randomly chose 50% of the data to be the test cases. Table 2 shows the detailed information of the data sets. Fingerprint Evaluation. We evaluated the effects of using different  X  to gen-erate the final location in the last step of search algorithm (Figure 3, line 12). We set the value of  X  from 1 to 10, running our algorithm on three data sets. Figure 6(a) shows the result.

We see that the average error of the final result increases with  X  from less than 5 meters to 15 meters. The reason is tha t when we choose more fingerprints to generate the final location, the less similar ones may be included; therefore, the result error increases. From the figure, we can see, when we set the  X  value to 1, that is, choosing the most similar fingerprint to be the result, our algorithm has a median accuracy less than 5 meters, whic h is better than the other localization systems.
 Method Comparison. We evaluated our fingerprint algorithm and represen-tative selection algorithm. Comparing with the state-of-the-art Google Localiza-tion System 1 and SOSO Localization System, our system has a higher accuracy. Algorithm 4: Incremental Representat ive Selection Algorithm Figure 6(b) shows that the accuracy of Polaris is at least 10 times better than Google and 15 times better than SOSO. After compressing the data with a threshold  X  =0 . 98, the accuracy is at least 4 times better than Google and 6 times better than SOSO. The reason is that they use a triangulation method, which needs to estimate the location of access points and uses the estimated locations to generate the result. Therefore, the performance is worse than our method.
 Index Evaluation. We evaluated the effectiveness and efficiency of our repre-sentative selection algorithm. The four aspects using to evaluate the algorithm are the number of fingerprints indexed, the number of candidates for each search, the search time and the result accuracy. We set  X  from 0.99 to 0.90 and set  X  =1, running the test on three data sets. Figure 7 shows the result.

We see that the size of the index, the fingerprint candidates that need to compare with f x and the search time d ecrease greatly with  X  .Since  X  is the threshold we use to verify whether the two fingerprints are similar or not, a decreasing in  X  compresses more fingerprints in to one; therefore, we reduce a great many of fingerprints and the index size decreases. As a result, when a query comes, we need to compare with less ca ndidates and the search time decreases. However, since the index is small, we cannot map all the locations to their accurate fingerprints; therefore, the median error increases a little. Choosing the best  X  has great influence to Polaris . For example, when we set  X  =0 . 96, the result accuracy is about 15 meters while th e other three factors decrease greatly.
The experimental results of Polaris show that our system has a higher accu-racy and precision than state-of-the-art systems and the incremental representa-tive selection method can compress the fing erprint data effectively and efficiently. Many location systems[1] have been prop osed for the past two decades. Some sys-tems require special equipments in order to locate the user. The Active Badge system[11] relies on infrared technology, presenting the location of the badge that emits the infrared; however, the transmission range of infrared is the lim-itation. The Bat system[12] and Cricket system[13] use ultrasonic technology for getting a higher accuracy. Receivers get the ultrasonic pulses, which can be used to calculate the distance. The systems require a large infrastructure and difficult to deploy. TRIP[14] and SurroundSense[15] use image and adja-cent contexts to help locate. With the h elp of the equipments, those systems can have a better accuracy; however, it i s impossible for them to use in a large area. Some other systems[16,5,6,7] use gsm cellular tower; however, the lower accuracy cannot reach the s tandard of an accurate loca tion. Place Lab[3] uses particle filter method to locate the user in the open area, which has the ac-curacy about 20 to 30 meters. [17] pres ents a case study of applying particle filters to location estimation; however, those methods require more computation and memory. RADAR[2,10] first proposes the fingerprint method using the pre-viously collected data. It provides an accurate localization in building but the massive deployment make it unable to use in the large area. [18,19,20] use similar method like RADAR but taking into consideration of different kinds of sources. However, they cannot be used in the open area for the complicated deployment and inefficient algorithm. In this paper, we present and implement a localization system, called Polaris . Using a motivate mechanism, our system accumulates the data contributed by anonymous users, making it easy to deploy. We design a novel localization model to measure the similarity of two fingerprints and generate the user X  X  location. Our search algorithm has a higher accuracy between 5m to 15m. To improve the performance, we present a novel increment al representative fing erprint selection schema to compress the massive raw data in order to support the metropolitan-scale localization. The result from experiments and real-world usage show that our system has a better performance than the existing state-of-the-art systems in both the accuracy and capability of dealing with the massive data.

