 With the rapid development of mobile devices, geo-positioning technologies and social network, location-based services tend to be socialized, which promote the emergence of mobile social network services (MSNS), such as Foursquare, Facebook places, etc. An essential capability of MSNS is to allow mobile users to discover and interact with potential friends who happen to be in their vicinity. There are many important applica-tions in the real world. For example, making friends with other people nearby, seeking assistance in emergency, co-shopping with others with similar demands, taxi-sharing in rush hour, etc.

As we know, trust is critical determinant to share information and establish new relationship between users in daily life becau se it can protect users from malicious at-tack and fraud. To support the aforementioned service, we propose a new type of query, users who have common interests and demands with the querying user. The potential friends returned by PTF query should satisfy following conditions: (1) they should be annotated with as many terms specified in the query as possible, (2)they should be as close to the querying user as possible in temporal and spatial dimensions, (3) the trust score should be as high as possible. We introduced a novel trust scoring model by com-bining three factors: social closeness, interest similarity and profile similarity. To the best of our knowledge, none of former literatures did it like this.

Since continuously moving users change dynamically, it causes dynamic updates of check-in histories. Therefore, it is challenging to retrieve exact query results in a timely fashion. Previous studies on friend discovery just adopt instant monitoring to detect the mobile users in the friends list, which cannot support PTF query [1, 2]. Therefore, we challenge. Based on CUHR index, we exploit a candidate ge neration-and-verification framework to process the PTF query. In candidate genera tion phase, our method not only identifies the current users in the vicinity of query users over the CU index, but also searches for the matching users and the high trustworthy users by traversing the HR index in parallel. Extensive experiments show that our algorithm achieves high performance. A potential trust friends ( PTF ) query is denoted as Q = u q , q t ,p,  X  ,where u q is the keywords expressing query demands. In order to find top-k mobile users, we have to rank the correlation between Q and these users. Before the further discussion of PT F query, several preliminary definitions should be given as follows.
 Definition 1 (Check-in Record). A check-in record cr indicates a user id visited a place loc and posted the tweets T at the timestamp ts, denoted as id , ts , loc , T . Definition 2 (Check-in History). A check-in history CH of a user u is a sequence of cr .ts &lt; cr i + 1 .ts } .
 Definition 3 (Cover Distance). If the keyword covering area CA of a user u matches the query keywords, the cover distance between Q and u is measured by maximal dis-tance between CA and query Q and denoted as Cdist ( Q , u ) = maxdist ( Q , CA ) . Auser u can be formally represented as id , P , F , CH ,where id is the identifier of u , P is u  X  X  profile information, F is the friend list. The correlation of Q and u is evaluated with following function, which take account of three essential components, i.e. current trust score TS (  X  ) between Q and u . In equation (1),  X , X   X  [0,1], which are used to balance each component X  X  influence on similarity sim T and the cover distance Cdist (  X  ) between Q and u . With this metric, PTF query can be formalised as follows.
 Definition 4 ( P otential -T rust -F riends -Q uery ,PTF). Given a user set U, PTF query Q = q not exist u R that satisfies aS core ( Q , u ) &gt; aS core ( Q , u i ) where u i  X  R. 2.1 Trust Scoring Model In our trust scoring model, it encompasses thr ee key factors: social closeness, interests similarity and profile similarity.
 Social Closeness. Friendship between two users in the social graph can be a good trust estimation metric. The more common frie nds between users, the more they trust each other. Therefore, the social closeness between query user u q and mobile user v should be is quantified by friendship similarity. We exploit the Dice coe ffi cient to compute the social closeness SC ( u q , v ). It is defined as Where F u Interest Similarity. People tend to trust others with similar interests or experiences. The historical check-ins provide rich information about a user X  X  interests and hints about when and where a user would like to go. We utilize the spatio-temporal co-occurrence to estimate the interest similarity. We firstly employ a logarithmic scale titled time frame model [5], to split the time interval of check-in histories. Then we use the distance be-tween check-in locations of two users in each tim e frame to measure interest similarity. Where maxTf is the maximal time frame among users, LS i is the union of all locations of u q and v in the i th time frame.
 Profile Similarity. To measure the similarity between users, we compare their profiles. For a query user u q and a mobile user v , we adopt the cosine measure as the profile similarity, which is defined as follows.
 where P u and P v is the profile vector of user u q and v.
 Trust Score for Queries. Finally, the trust score of a user v , relative to the PTF query user u q is obtained by the linear combina tion of the above three factors.
 where  X  ,  X   X  [0,1] are used to adjust the tradeo ff among three factors. To facilitate PTF query processing, we design a current users-historical records (CUHR) index. CUHR consists of two ingredients, as shown in Fig. 1, CU memory index (Fig. 1(a)) and HR disk index (Fig. 1(b)). CU is used to index the incoming users and latest check-in records, and HR is responsible for indexing the check-in histories of all users.
In CU index, a regular grid is exploited to index the latest users X  visit records. Each cell associates with a linked list of buckets, w hich contain the meta -data and the latest visit records of each user in ascending of arri ving time. The meta-data contains 3 items: a pointer to the next bucket, Nptr ; the number of stored current users, Unum ; the visiting changing. In order to reduce the costs caused by the frequent updates, a hash table is applied to index users on their id . When a new visit record vr of u arrives, we check whether the new cell that vr belongs to is the same as the current cell of u . If not, vr is inserted into the first bucket of the new cell and the corresponding entry in the hash table is updated. Meanwhile, the old and new check-in records are packed together and migrated into disk.

The HR index exploits an adaptive multi-level grid to partition the entire space. Each user X  X  check-in history can be partitioned into a set of sub-sequences, where each is enclosed into the corresponding cell. In order to parallelize PTF query, a UTB + -tree and a grid-inverted file ( GIF ) index is implemented in each cell. In UTB + -tree, the check-in sub-sequences are organized by the user id and time interval. The GIF index is used to index the text information of ch eck-in sub-sequences in each cell. When update occurs, a block from CU index is inserted into the historical data files. Accordingly, the UTB + -tree and GIF of corresponding cell should be updated. To answer the PTF query, a simple method called CUFinder is to retrieve the current trust users in the vicinity based on the CU index. It exploits an incremental enlarge-ment method to implement range query iteratively, then o ff er up-to-date top-k results. In contrast to its fast query response time, CUFinder is ine ffi cient for identifying more relevant results. For this purpose, we propose CanGV algorithm, which is based on a candidate generation-and-verification framework.
 4.1 Candidate Generation A PTF query involves three tasks: (1)querying top-k current users with largest spatio-temporal proximity, (2)querying top-k users with largest spatial-text similarity, q 2 ,(3) querying top-k users with highest trust score, q 3 . We denote the whole query as Q = { q q with l q task q i , we maintain an individual priority heap PH i to keep track of the users with u , l maximal entries from each PH i . At each time, the entry that matches q i is popped from the top of GH and kept in a candidate set CS . Meantime, another entry is popped from corresponding heap PH i and pushed into GH . Repeating above procedure until the CS has already contained top-k fully matching users. Next, we focus on the processing of task (2) while task(1) and (3) can be solved by adjusting existing algorithms in [3].
Top-k users retrieval with largest sim ST ( Q , u ). For the task q 2 , we exploit an incre-mental expansion algorithm to retrieve top-k users that match query keywords and have the minimum cover distance on HR index. In query processing, we utilize a priority heap PH 2 to keep track of top-k users.

At first, we implement a range keyword query within region R 0 with the radius r 0 and centered at Q . p , and obtain a set of check-in sub-sequences SSet that contain query keywords by traversing the GIF component of HR index. The sub-sequences with the same user id in SSet are merged to obtain the candidate sub-sequence CSS . The fully keyword-matching CSS push into PH 2 with l q the query range by increasing r 0 and utilize the same method to find sub-sequences ( SS ) in the region formed by range R i but not include in the region R i  X  1 .When l q CSS is smaller than the k -th entry in PH 2 , top-k mobile users are returned. 4.2 Candidate Verification Since it is possible that the partly matching users is superior to k full matching users, we need to verify further the candidate set generated in the first phase to obtain the Obviously, the computational and I / O cost are high for this task. For the missing entry, we replace the truth value with the corresponding entry in GU . Given a partly matching u and let unsat q be the unsatisfying query task, the UppB(u ,Q ) as defined as follows. users into the results and treat the k -th user X  X  aggregate score as the pruning threshold  X  .Ifthe UppB (.) of partly matching users is smaller than the  X  , these users are pruned without further computation. Otherwise, the algorithm has to retrieve the users of the corresponding query and compute the aggregate score. After processing all the partly matching users, the algorithm outputs the top-k users as the final result. Our experiments are conducted on a real data set, Gowalla check-in dataset (GCI), as the users X  check-in histories. GCI contains a total of 6,442,890 check-ins of 196,591 users and 950,327 edges of users X  social graph over the period of Feb. 2009 -Oct. 2010. In our application scenario, we simulate a certain number of mobile users moving in the city center. At each update cycle, r% of the users in the memory are evicted by replacing with equal number of fresh users, their check-ins are generated randomly by GCI data set.

We implement all the algorithms in JAVA. All our experiments were executed on a windows platform with an Intel(R) Core(TM)2 Duo CPU of T7500 @ 2.66GHZ and 4GB RAM. The responding time and accuracy ratio are used as our performance met-rics, where the accuracy ratio is defined as Aratio = | Result CanGV Result CUFinder | / k.
We compare CanGV against CUFinder and baseline algorithm . The baseline al-gorithm exploits the IR-tree to index the users X  check-in histories. The IR-tree [4] in-tegrates R-tree and the inverted file. The MBR and text of a check-in history CH is obtained by aggregating the MBR and the text information associated with each loca-tion in CH . Then, we utilize the L k T query algorithm [4] to find the top-k mobile users.
In the first set of experiments, we study the responding time of CanGV and CUFinder and the accuracy of CUFinder by varying k . As shown in Fig.2 , the responding time of two methods increase as k grows. When k is small, two methods show the similar rate of increase. However, as k increases, the performance of CanGV diminishes since CanGV needs to access more users X  check-in histories to obtain the top-k results. Fig.3 depicts the accuracy ratio of CUFinder relative to CanGV . We observe that the accuracy ratio slightly increases as k grows. This is because two methods will retrieve more same mobile users. Moreover, the average accuracy ratio can not reach 0.3. Therefore, our proposed query method is the best choice.
 In the subsequent experiment, we evaluate the update performance of HR index and IR-tree for check-in histories, while they use the CU index for the current users. Fig.4 shows that the update performance of HR index notably outperforms IR-tree for all values of r%. Due to the fact that HR index employs an adaptive multi-level grid that has an lower maintenance overhead.
 In this paper, we study the problem of top-k potential trust friends ( PTF ) query prob-lem , which aims to find top-k mobile users with the the highest demand satisfaction and trust score in the vicinity. We introduce a trust scoring model to measure users X  trust degree. Furthermore, we present an e ffi cient query processing algorithm based on CUHR index structure and exploit candidate generation-and-verification method to answer PTF query. Our experimental evaluation shows the e ffi ciency of our algorithms.
