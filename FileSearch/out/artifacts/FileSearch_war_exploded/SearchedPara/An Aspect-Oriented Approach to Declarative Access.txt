 The principal difficulty in designing secur ity concern such as access control into an application system is that it is a system-wide concern that permeates through all the different modules of an application. Although there is a generic need to enforce to each individual resource may not be the sa me. Hence in current practices it is very often to see the code for implementing acce ss control scattered over the whole system and tangled with the functional code. This is not only error-prone but also makes it difficult to verify its correctness and perform the needed maintenance; Web applications are no exceptions. Indeed,  X  X ro ken access control X  is listed as the second critical Web application security vulnerability on the OWASP top ten list [13]. 
Instead of programmatic approaches, a better way to address this problem is declarative access control where access control logic is completely decoupled from the application code and is accomplished without actual coding [14]. This will not only improve the application X  X  modularity but also make the task of enforcing comprehensive access control more tractable. In the past, the typical approach to declarative access contro l is adopting a policy-driven and centralized authorization engine [2][14]. However, such approaches are often criticized for lack of expressiveness in access control requirements and low runtime efficiency due to policy interpretation. Specifically, Web application developers often have to handle the difficult cases of data-contents-related access control. For example, in a B2B E-Commerce site, users from any registered or ganizations have the privilege to execute the  X  X iewOrder X  function, but they are allowed to view only orders of their own organization. This is called instance-level access control [8]. Furthermore, within a data record, certain fields, such as credit card number, may have to be excluded from control. Such fine-grained constraints are beyond the scope of popular declarative mechanisms such as JAAS [16][6]. 
This paper presents an aspect-oriented approach that can not only address many fine-grained access control constraints but also accomplish it in a declarative manner without incurring extra runtime overhead. Aspect-oriented programming (AOP) [10] uses separate modules, called aspects , to encapsulate system-wide concerns such as access control. Our previous work [3] has demonstrated the feasibility of implementing fine-grained access control for Struts-based Web applications [1] using automatically synthesize the desired aspect modules from access control rules defined in centrally managed XML configuration file s using some properly designed aspect templates. The generated access control aspect modules will then be compiled and integrated into designated functional modules of the underlying application using standard aspect tools. At runtime, these aspect codes will be executed like common functional codes to enforce the required access control, no runtime interpretation overhead incurred. Furthermore, management and maintenance tasks are greatly simplified since future changes in access control rules can also be effectively realized through these mechanisms without actual coding. In short, our approach can be characterized by central management and distributed enforcement. 
The rest of this paper is organized as follows. Section 2 gives a brief introduction to AOP and describes related work. Section 3 outlines our approach to declarative access control. Section 4 desc ribes our access control rules and aspect templates. Section 5 presents the design and implementation of our translation scheme. Section 6 concludes and sketches future work. In this section, we highlight the basics of AOP and review the relevant features of AspectJ. In addition, we also describe related work. 2.1 AOP and AspectJ In AOP, a program consists of many functional modules, e.g. classes in OOP, and some aspects that capture concerns that cross-cut the functional modules, e.g. security . The complete program is derived by some novel ways of composing functional modules and aspects. This is called weaving in AOP [10]. Weaving results in a program where the functional modules impacted by the concern represented by the aspect are modified accordi ngly. In languages such as AspectJ, the weaver tool is tightly integrated into the compiler and performs the weaving during compilation. 
To facilitate the weaving process, a set of program join points are introduced to specify where an aspect may cross-cut the ot her functional modules in an application. Typical join points in AspectJ are method execution and field access. A set of join advice in an aspect are tagged with a pointcut and determine how the application should behave in those crosscutting points. There are three kinds of advice: before , after , and around . The before advice and the after advice are executed before and after the intercepted method, respectively. The case for the around advice is more subtle. Inside the around advice, we can choose to resume the intercepted method by calling the special built-in method proceed() , or simply bypass its execution. The following aspect in AspectJ illustrates the power of around advice. It states that, when the update method of class Customer is about to execute, control is transferred to the around advice. If the particular constraint is false, the intercepted method will be aborted; otherwise, it will be resumed by calling proceed() . Furthermore, AspectJ also allows aspect in heritance, abstract aspect, and abstract pointcut. We can write an aspect with abstract pointcuts or abstract methods. A sub-aspect then extends the abstract aspect and defines the concrete pointcuts and methods. 2.2 Related Work Applying AOP to security concerns is pioneer ed by [4][5]. They also sketched how to build frameworks in AspectJ for handling acce ss control. However, they did not focus on Web applications, and neith er did they look into access control modeling in detail as we did. The proposed aspects check the constraint before the attempted access. In contrast, we have both pre-checking and post-filtering aspects that covered fine-grained constraints. Furthermore, we have devised a translation scheme to automatically synthesize access control aspects. 
Designing proper access control mechanisms for distributed applications have always been an active topic. A good survey on both declarative and programmatic mechanisms can be found in [2]. A strong appeal of declarative security mechanisms is presented in [14]. They also proposed a centrally managed framework called GAMMA. But they did not address data-level access control and neither did they use AOP. Sun X  X  J2EE [17] and JAAS [16] also includes a primitive form of declarative access control. However, one still needs to write tangled code to handle fine-grained constraints. 
Our work bears a closer relationship with that of Goodwin et al [8]. First, they used the four-tuple access control rules: [user gr oup, action, resource, relationship], where each resource type. The major concern is instance-level constraints, no attribute-level constraint covered, though. Second, they also adopt an MVC-like architecture for Web applications. The controller intercep ts all user commands and queries a centralized manager to make the authorization decision. Hence there will be some runtime interpretation overhead incurred by the manager. Furthermore, they did not framework. Figure 1 illustrates the system architecture and mechanisms of our approach. We worked towards declarative access control for Web applications from two opposite ends and managed to meet in the middle. At one end, the objective is to accommodate requirements. We use a flexible mode ling scheme based on user-function-data relationship that can satisfy a wide rang e of access control requi rements of various granularity levels, including both instance and attribute levels. A high-level form of system-wide crosscutting concern, we mu st impose considerable architectural disciplines on Web applications to layout a good foundation for enforcing the required access control modularly. In par ticular, we follow the well-accepted Model-View-Controller (MVC) [7] architectural pattern and adopt the popular Apache Struts framework [1] to structure our Web applications. 
Next, we apply AOP to devise a declarative implementation scheme that bridges these two ends. We developed our implementation scheme in two stages. In the first stage, we did an in-depth analysis of the structures of aspect code that we developed manually for implementing the form of access control rules we employed. These aspects are classified into a few forms accord ing to their internal structures. Basically, each access control aspect is divided into tw o parts: a generic part realized by an abstract aspects provide a solid basis to wards building a declarative mechanism. 
In the second stage, we focus on how to automatically synthesize aspect code from access control rules. Given the abstract aspects derived in the previous stage, we only need to generate the parts that are ru le-specific. Thus we prepared some aspect templates based on the derived aspect code structure to assist code generation. On the source side, in addition to the access control rules, we provide an application specification file that links the logical entities (data objects and operations) referenced current practices of Web application development, we define both of the two input files in XML format and treat them as configuration files, one of each type for every application. Together with the pre-defined aspect templates, the two XML configuration files are processed by a rule translator into concrete access control aspects. The generated aspect modules will then be compiled and woven into designated functional modules of the underlying Web application using standard aspect tools. At runtime, the aspects will be executed like common functional codes to enforce the required access control. 
Our approach has the following features. First, all the access control rules of an application are kept in a configuration file, making the management and maintenance tasks easier. Second, the enforcement of access control is consistently applied to every designated functional unit using aspect technologies without installing a centralized authorization engine. Third, th e codes that implement the required access control are automatically synthesized, compiled and linked to functional modules without actual coding. Future changes in access control rules can also be effectively realized through these mechanisms in a declarative way. Furthermore, there will be no runtime overhead due to access control policy interpretation. The main runtime overhead will be that incurred by aspect weaving and advice calls, yet, according to [9], such overhead in AspectJ is very low in general. Both are revised from our previous work [3], where more details can be found. 4.1 Access Control Rules Since RBAC [15], there have been many approaches proposed to model access control requirements for applications purposes. Here we take a simple yet generic approach that can support a wide range of access control requirements. We model the interaction between a user and a Web application as a sequence of access tuples of function on a specific type of data object(s ). The access control rules of an application determine which access tuples are allowed and which must be denied. They are derived from the application X  X  access control requirements. 
In designing the form of our access control rules, we focus on the functionalities of an application and specify the access contro l rules in a function-oriented manner. Furthermore, as authentication is required prior to authorization, we also make authentication type part of the rule; the type can be id/password (PWD), digital certificate (DC), or any other supported methods of user identification. Specifically, the access control rules take the following form: Here funName is the name of a function whos e access needs to be restricted, authType is the required user authentication type, and the constraint is a Boolean expression which must be evaluated to true to grant the attempted access. The attributeActions component is optional. When present, it specifies the attribute-level access constraints and actions we impose on the designated function. It takes the following form: where constraints are also Boolean expressions and the typical action is field masking, mask ( specified_attributes ). 
Clearly, the more data entities we can refer to in the constraint expression the wider the scope of access control requirements we can support. For generic purposes, we take an object-based approach to specify the constraints and supply five generic objects: User , Form , Data , Cxt, App, with various attributes that the constraint expression can refer to. The specific set of attributes for each object depends on individual application X  X  needs. Conceptu ally, the Form object and the Data object serve as the input and output of a function to execute, respectively. Typical attributes for the User object include user X  X  name and roles in an organization. The attributes of the Form object include the arguments passed to the protected function, while the attributes of the Data object refer to the data fields returned after executing the designated function. As will be shown later, the presences of the Data object in a constraint expression call for fine-grained access control. 
In addition, the context object ( Cxt ) provides methods to retrieve the datetime and location of any attempted access. This is th e most often used contextual information for access control. The application object ( App ) is global to an application and stores various parameters related to access control. For example, certain functions are accessible only during working days and from specific machines. The definitions of working days and designated machine addresses will be the attributes of the App object. Example: the following is a set of access control constr aints and corresponding rules for an online shopping system. ( X &amp;&amp; X  is the and operator, and  X  X | X  the or operator.) 
C1: All registered (authenticated) users can create order, but only VIP customers can create orders whose total amount exceed $100,000. 
C2: Only sales managers authenticated through digital certificates can delete 
R2: &lt;deleteOrder, DC, contains(User.getAttr( X  X oles X ),  X  X ales X ) 
C3: Registered customers can list (view) only their own orders. Moreover, the 
R3: &lt;listOrders, PWD, contains(User.getAttr( X  X oles X ),  X  X ustomer X ) 
C4: Unclassified orders can be printed in batch mode by sales from dedicated 
R4: &lt;batchPrintOrder, PWD, This form of access control rules is quite flexible and can model a multitude of requirements, from simple RBAC to sophisticated instance and attribute level constraints. For example, by referring to the attributes of Data , rules R3 and R4 require that unauthorized data instances must be filtered before returning to the user. 4.2 Aspect Templates Each access control rule will be realized by two types of aspects: authentication aspect and access control aspects. Here we focus only on access control access aspects, since authentication aspects are simpler and thus omitted. 
The access control aspect code is divided in to two parts: generic part realized by captures the common code patterns one would develop manually to enforce a rule. After some analysis, we identified three most typical generic aspects, namely, Precheck , PostfilterSingle , PostfilterCollection . The availability of function arguments and data contents, distinguishes these generic aspects. The pre-checking aspect handles the case when the constraint expression involves only the User and Form objects, whose attributes are a ll available before executing the the constraint expression also involves attributes of the Data object, which are available only after executing the protected function. 
The rule-specific part of an aspect includes the authentication type, the pointcut unauthorized data contents. Authentication type specifies which authentication aspects to use. The choice of pointcuts is crucial to obtaining all the various data entities we need to evaluate the access control constraints. As discussed in [3], we choose the execute method of user action classes as the targets for access control aspect weaving. 
The other rule-specific parts will be generated by the rule translator and put into a concrete aspect inheriting from one of the generic aspects described above. Basically, the code to be generated is the set of abstract methods declared in the generic aspects. To facilitate the translation, we have prepared three aspect templates that will be expanded to rule-specific concrete aspects. For example, Listing 1 shows the aspect template corresponding to the PostfilterCollection aspect. This section describes the design and impl ementation of our translation scheme for synthesizing access control aspects. Due to space limitation, in terested readers are referred to [12] for the complete schema and examples of synthesized aspect code. 5.1 XML Schema for Access Control Rules and Application Specification The translation tasks are greatly facilitated by an application specification file that supplies the definitions of the real entities referenced in the access control rules. We now describe the XML schemas for these two input files to our translator. 5.1.1 Access Control Rules In designing the XML schema for specifying the access control rules, we have, as much as possible, followed the structure of the rule format described in Section 4.1. A major deviation is taking out the authentication type item and grouping all the access control rules by it. In other words, all access control rules with the same authen-tication type requirement will be grouped together. This is also compliant with security practices, for different authentication types imply different security levels. Figure 2 highlights the structure of the XML schema for specifying the access control rules. their XML counterparts, we refer to them by abstract rules. Each abstract rule corresponds to an EnforcePoint element in our schema. Abstract rules requiring the same authentication types are grouped into a composite element called Enforce Domain . element. Note that here the Rule element corresponds to the constraint expression in an abstract rule, and, to prepare for future extension, we also allow more than one Rule element for an EnforcePoint. Furthermore, as stated earlier, the attributes of the Data object referenced in the constraint expression are only available after executing the protected function, so we have divided the constraint expression in an abstract rule into two constraint elements, namely, FunConstraint and DataConstraint . An AttributeAction element applies a specified action to a group of attributes if the given constraint is true. For example, the mask action sets the specified attributes to  X *** X . 
Inside the constraint elements, in addition to the five generic objects and some simple operators, we provide a special object, _Library , that supplies various expressions. The exact definitions of those operations will be provided in the application specification file. Listing 2 shows the configuration of the abstract rule R3 of Section 4.1. 5.1.2 Application Specifications The main purpose of an application specification file is to map the generic objects, User, Form, Data, Cxt, and App , and other operations to the real entities in the underlying application. Figure 3 outlines the structure of the XML schema for application specification files. We group the required mappings into four sections: AuthTypeMapping, EnforcePointMapping, AttributeGroupMpping, and FunGroupMapping . The AuthTypeMapping handles the binding of the User object, which provides user-related attributes for access control purpose. Since different authentication types need different user account objects, the mapping of User object is associated with the AuthTypeMapping element. The FunGroupMapping specifies the bindings for the operations referenced in the constraint expressions through the _Library object. 
The EnforcePointMapping is the main mapping element. It is composite and has three sub-elements: VarGroup , EnforcePoints , and MethodSignature . The VarGroup element specifies the bindings for the five generic objects. Since they have different nature in terms of applicable scope, ther e are three occurrences of the VarGroup element in the schema: one under EnforcePointMapping for specifying global objects, such as Cxt and App; another one under EnforcePoint for specifying local objects, such as Form and Data; the last one, not shown in Fig. 3, under AuthTypeMapping for specifying the User object. Every EnforcePoint element corresponds to an EnforcePoint element in the access control co nfiguration file and thus there may be many EnforcePoint instances. Each EnforcePoint may have its own bindings for the Form and Data objects, which are mapped to the corresponding inputs and outputs of the associated function. As to the MethodSignature element, it is used for specifying the bindings for the argument objects passed to the EnforcePoints. Currently, they simply follow the signature of the execute method defined in the Struts framework. In the future, they can be changed to whatever the host Web application framework requires. 
Furthermore, to reuse attribute mappings among objects, the complete bindings of a generic object are divided into two stages. First, a generic object is mapped to one or more AttributeGroup elements using a Var element. Second, the detailed attribute mappings for every AttributeGroup are collected under the AttributeGroupMapping element. The following configuration sketches a mapping between a Var element and an AttributeGroup element, where an attribute group called order is assigned to the Data object. 5.2 Rule Translator The rule translator is responsible for synthesizing the aspect codes from the two XML configuration files described above using pre-defined aspect templates. Besides parsing the XML files and cross-checking th eir data contents for binding correctness, the translator needs to perform aspect temp late selection and code generation for each EnforcePoint element. Both tasks depend mainly on the Rule element in an EnforcePoint. Recall that we have three aspect templates based on the three generic aspects: Precheck , PostfilterSingle and PostfilterCollection . For example, if no data-related constraint expressions are present in the Rule element, then the translator will select the template based on the Precheck aspect; otherwise it will select one of the post-filtering aspect templates, depending on whether a collection requirement is specified in the At tributeGroup element associated with the Data object. Once the proper aspect template is selected, the remainder of the work is to synthesize constraint evaluation codes based on the binding specifications given in the application specification file. In this paper, we have presented an as pect-oriented approach to declarative access control for Struts-based Web applicati ons. Our access control modeling scheme can satisfy a wide range of requirements with different granularity. By employing aspect-oriented technology, we have obtained a highly modular implementation of fine-grained access control and the aspect code for enforcing access control is automatically synthesized. We argue that our scheme has achieved a proper balance between expressiveness of access c ontrol and runtime efficiency. 
We plan to further explore this line of study along two directions. First, we shall extend the Rules element. Currently, each EnforcePoint allows one Rule element only. It would be more convenient if the security administrator can specify the generation step a little and may have some minor impact on runtime performance. Second, we shall extend the aspect template set to cover more sophisticated application scenarios. It is conceivable that the three aspect templates cannot handle all application scenarios. Acknowledgements. This work was supported in part by the National Science Council, Taiwan, R.O.C. under grant number NSC-94-2213-E-004-012. 
