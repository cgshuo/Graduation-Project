 Nowadays, developing web applications in a Service-Oriented Architecture (SOA) style is getting attention, since more and more services are delivered to end users [1]. These applications, called web-based SOA applications, take services as the basic constructions to provide new services in th e web. Most of such applications are de-veloped by mashup [4,5], which is a novel approach for combining data and function from multiple services. 
When developing web-based SOA applications, the features of web and SOA bring some challenges to the assurance of correctness and reliability. First, a web-based SOA application usually has many diverse and complex interactions. Implementation plicit. Services interact with each other in a GUI element or through the interaction of GUIs. The functions and interactions of the GUI elements bring extra behavior and make the service flow more complex. Finally, web-based SOA applications are run-ning in heterogeneous environments including the web browser and service platforms. It is difficult for developers to understand the execution semantics of the heterogene-ous environments and analyze their impacts on the application behavior. 
There are many work on verifying service composition [6, 8] and web applications [9,10,11]. But few of them can be directly applied to web-based SOA applications. In this paper, we propose a model-checking based approach for verifying web-based SOA applications. Our approach begins with generating the application behavior from the source code. The execution environment is abstracted as a reusable template and will be automatically combined with the previous application behavior to form a complete enough and formal behavior model. The behavior model is described using the notation of UML sequence diagram. With user-defined constraint and refinement specifications, the behavior model is translated to the formal specification (Promela for Spin) as the input of the model checker Spin [2]. If the model is flawed, the viola-tion traces generated by Spin will be visuali zed in the behavior model. This approach is illustrated and demonstrated by mashup, one of the most popular methods for de-veloping web-based SOA applications.

The remainder of the paper is organized as follows. Section 2 illustrates a sample of an incorrect mashup application. Section 3 presents the details of our approach. Section 4 discusses the scalability of the approach with experiment results. Section 5 and Section 6 discuss the related work and our future work, respectively. Fig. 1 shows a mashup application that provides travel information to users. This application has four components: (1) a travel planner, (2) a city se lector, (3) a table of beauty spots and (4) a map. These four components act as the GUI of three services, respectively. In this section, we will show an inconsistency problem found in devel-opment of this application. This sample will be used in the following sections. 
Suppose the user first chooses a travel plan provided by the USA Travel online af-ter searching by the keyword  X  X ew York X , and then he/she thinks it is better to look through all the attractions of Cairo before making a decision. So he/she clicks the  X  X ity Beauty Spots X  table shows all the beauty spots of Cairo, and the  X  X ap X  is ex-pected to display the locations of these beauty spots. But in some cases, an inconsis-tency problem may occur! The  X  X ap X  will display the locations of Denver and New York, which is the result of the previous action, i.e. choosing the travel plan. 
Due to the unpredictable network delay and server response time, the order of re-sponses may not be the same as the order of requests. This inconsistency problem is very common in mashup applications. 3.1 Generating Behavior Model Our approach begins with generating the behavior model of the applications. The behavior model includes application and environment behaviors. Aiming at support-ing the verification in a user-friendly way, we provide a behavior model using nota-tions of UML sequence diagram with formal semantics [12] as an intermediate layer. Thus, users can perceive the application behavior and specify the constraints using their familiar notations. Additionally, violations of the constraints can be traced back and animated in the behavior model to he lp users to solve the detected problems. 3.1.1 Generating Application Behavior Model from Source Code Generation of the application behavior depends on the programming model. As web-based SOA application development has not been standardized yet, different compo-nent models exist. Here, we choose a mashup component model iMashup, which is used in developing the sample application, to illustrate this process. An iMashup component has two interface types: User Interface and Programming the corresponding functions. Programming Interface is the interface by which iMashup components interact with each other. The interaction may be synchronous or asynchronous. The backend services are regarded as internal logic, and invisible to other components. Asynchronous invocations of the services and callback functions are supported by a service broker. 
Extraction of the behavior from the application implemented using iMashup com-ponent model consists of two steps:  X  Inferring component instances: There are two component types, presentation  X  Generating interaction fragments: For every interface and callback function, a 
Let us take the interface  X  X earchTravelPlan X  of the component  X  X ravelPlanner X  as a sample. Fig. 2 shows the source code extracted and the sequence diagram generated. 3.1.2 Generating Environment Behavior Model Environment modeling is a key problem in model checking open systems. In the web-based SOA applications, the environment behavior is the behavior of the user actions, service server and web browser. The user actions can be abstracted as random invoca-tions of user interfaces. The return of message from the services is in parallel with the dom selection between the executions of user actions and callback functions. 
The template and the complete behavior model of the example generated are shown in Fig. 3 . For every presentation component, each sequence diagram corre-first  X  X lternative combined fragment X . For every service component, a return message is added as an  X  X perand X  of the second  X  X lternative combined fragment X , which is event stack in the browser. We support the automatic generation of environment be-havior information using a template. 3.2 Defining Constraint and Refinement Specification The generated behavior model only includes interaction behaviors. Therefore, in the verification stage, extra constraints and refinements are needed. Developers can add them mutually. But for the properties that are required in most applications, we devel-oped a template for experts to specify. When applied, the specification will support automatic generating the constraints and refinements in the model. In the behavior model, constraints and refinements are occurrence specifications. Thus, specification should include content of the occurrence specifications and the position where they should be inserted. 
Refinements and constraints are extra calculations and assertions of the model, re-spectively. In addition, assertions and calculations may depend on initialization of some related variables. Thus, three kinds of special events: initialization events, asser-tion events and calculation events are needed. The action of an initialization event of variables for recording states. The action of an assertion event is the safety proper-change of the states of the variables in the model. 
For adding the constraints and refinements to the model, we support adding occur-rence specifications before/after invocation/return of the interfaces. The scope of interfaces for adding occurrences can be user interface/programming inter-face/callback of representation components and interface of service components. 
With the requirement, a template for specification and automatic adding of the con-straints and refinements is as follow. 
We use the consistency property in the illustrative sample to show how to use the displayed in the presentation components should be the same as the order of requests by the user actions. Its specification is defined in Table 1 . 1) Initialization event: The property requires variables for recording the version re-2) Assertion event: The safety property is that the content for updating should be the 
The template also contains tags that are place holders for the automatically gener-ated functions, such as the tag &lt;service Type&gt; for recording service type. 3.3 Verifying Behavior Model The behavior model uses the notation of UML sequence diagram with formal seman-tics, to describe the behavior of the applications. For existing model checker can ful-fill our requirement in verification, we choose to integrate a widely-used model checker Spin to perform the verification. 
The translation from behavior model with its specifications to verification model (Promela for Spin) is supported based on semantics of behavior model. After verifica-Spin to perform the verification, but the programmers do not need to know how to use Spin and Promela. The translation from behavior model to verification model consists of two steps: 
First, the specification is applied to the behavior model and occurrences of three types of events are added. For example, if the assertion event of the consistency prop-erty is defined with the scope of all programming interfaces of all presentation com-ponents, occurrences of the events will be added in all operations in the scope. Fig. 3 shows the occurrences of the added events when the consistency property is applied to the behavior model of the illustrated sample. The red and yellow dots are occurrences of the assertion and calculation events, respectively. 
Second, the behavior model is translated to Promela. After the first step, the model consists of two parts: the behavior model and its constraints and refinements. Occur-rences in the behavior model are translated to  X  X tomic X  blocks in Promela. Occur-occurrences in the behavior model, because the sentences of their action definitions translation rules are omitted. 
After the translation, the verification model can be checked by Spin. For tracing back the violation trace to the behavior model, a probe is implemented for keeping the traceability. The probe inserts  X  X rintf X  sentences in all atomic blocks corresponding to the occurrences in the behavior model. The occurrence IDs generated by the violation traces can be simulated in the behavior model. This work is under development. 
With the specification of the consistency property, we use our tool to verify our example application. Violations of the consistency property in the component  X  X ap X  and  X  X ity Beauty Spots X  are discovered. Expected animation of the trace will be the red dotted lines in Fig. 3 . After verification, users can remove the constraints or mod-ify the behavior model and its implementation to avoid the violations. Model checking has many advantages while its major limits, i.e. scalability and us-ability, do not exist when applying to web-based SOA applications. In the previous sections, we use the illustrative sample to show the usability of our approach. To evaluate the scalability, we carry out an experiment on the example behavior model. 
We use the behavior model with different setting of the numbers of service in-explore all execution traces of the model. Therefore, the experiment result indicates the worst possible performance for this model, and is independent to the assertions. 
Fig. 4 shows the memory usage and execution time in verifying the sample with different numbers of component instances on a Pentium 4 2.26GHz with 1.5G DDR memory. In fact, the scale of a web-based SOA application is small because its single page interface model and a browser cannot present too many components in one page. Therefore, the result shows that the scalability is acceptable in our approach. 
There are some limitations of our approach. The behavior generation relies on the component models. In our tool, it is based on iMashup component model. If there is a standard component model, our approach can be applied to more applications devel-port the traceability from verification results to behavior model. The traceability from behavior model to source code may be more important in fault location. Many methods and tools have been developed for the rapidly growing community of web programmers who create applications in an SOA style. Some tools focus on facili-tating end-user programming [4,7] and some emphasize component reuse[3,5]. How-ever, they do not pay enough attention to the correctness and reliability problems. 
There have been some efforts to apply model checking techniques for reliable ser-vice assembly [6,8]. Most of them are aiming at the verification of service composi-tion implemented using web services flow specification language like BPEL4WS and WSCI. Our approach differs in that our work is for applications which perform service assembly in the presentation level. Therefore, the behavior model for verifica-tion includes user actions in the UI and invocations to backend services. 
There are plentiful efforts on applying fo rmal methods to verify the web applica-tions. The work recognized the needs for modeling and verifying the user navigation [9] and instruction processing [10,11]. However, these approaches are built for classi-cal web applications, which are based on a multi-page interface model with interac-tions in a page-sequence paradigm. Our approach is for the applications based on a single page interface model, and service navigation is also considered. Nowadays, development of web applications in an SOA style is receiving attention. However, some natures of web-based SOA make the resulting applications easy to suffer incorrectness and unreliability problems. In this paper, we present a model-checking based approach for verifying the applications in an automated manner. 
In the future, we would study more cases to further demonstrate our tool. We ex-pect that these will help us identify more properties and enhance our template for specification of the constraints. We would develop the visualization of animating violation sequences in the behavior model and provide more facilities such as auto-matic faults location in the source code. Acknowledgements. This effort is sponsored by the National Key Basic Research and Development Program of China (973) under Grant No. 2005CB321805; the National Natural Science Foundation of China under Grant No. 90612011; and the IBM University Joint Study Program. 
