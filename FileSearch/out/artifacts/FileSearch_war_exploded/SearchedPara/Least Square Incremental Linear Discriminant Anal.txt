 } @lamda.nju.edu.cn
In recent years, the amount of data is experiencing an explosive growth. The scale of data becomes larger and larger with the increase of capacity of computers and other data collection devices. The huge amount of data is due to both the high dimension and large number of data items. For example, in the literature of text mining, a passage is usually expressed as a vector with thousands of dimensions, and many corpus have huge number of passages. At the same time, data often come in stream and accumulate as time passes, and thus the amount is often unlimited. To reduce the time and resource consumption, it is generally desired that the data can be reduced to low dimension for processing.
Dimension reduction can reduce the data volume largely and provide much convenience to the later processing by projecting data from high-dimension feature space into low-dimensional feature space. The projection keeps informa-tion in the high-dimensional space as much as possible. One widely used supervised dimension reduction approach is LDA (Linear Discriminant Analysis). When projecting data into the low-dimensional space, LDA seeks the best separation of data from different classes by minimizing the within-class distance and maximizing the between-class distance simultaneously [3]. LDA performs well in many applications. Owing to LDA X  X  good properties and the needs in streaming data mining, incremental LDA draws more and more interest. In situations where data come in stream, updating the solution to LDA with the incoming data is desired, since it avoids the time-consuming batch-mode re-calculation of LDA solution.

During the past few years, various incremental LDA algorithms have been developed. Most of them provide ap-proximate solutions and suffer from high computational cost. There are some studies on incremental LDA using neural networks [2], [7], yet often suffer from slow convergence and severely undermine the significance of incremental learning. Pang et al. [9] proposed an incremental version of LDA, which provides a method for updating the within-class and between-class scatter matrices, while does not give a solution to the time-consuming step of updating subsequent eigen analysis. In [12] the proposed IDR/QR algorithm applies LDA in a projected subspace, in which the between-class difference is maximized. The deficiency of this algorithm, as shown in [13], is that much information is lost in the first projection. In [6], the concept of sufficient spanning set is used to update the between-class and within-class scatter matrices, where the eigenvectors of both matrices are kept and updated and minor components are removed in every step. In the calculation of the discriminant com-ponents, the scatter matrices are projected into a much lower-dimensional space, in which the eigen decomposition is accomplished. The incremental LDA algorithm GSVD-ILDA [13] is the incremental version of the algorithm proposed to solve LDA/GSVD in [11]. The core step of GSVD-ILDA is updating the eigenvectors of the centered data matrix. In updating, minor components are removed and thus the computational cost is reduced. The incremental LDA algorithm in [6] and the GSVD-ILDA algorithm suffer from a common problem, that is, it is difficult to determine to which degree the performance should be traded off for efficiency. If too much minor components are removed, the performance will deteriorate, otherwise the efficiency will be low. Moreover, the performance is sensitive to parameter settings, while tuning the parameters is not easy.

In this paper, we propose the LS-ILDA (Lease Square based Incremental LDA) approach based on LS-LDA [10], which shapes LDA into a multivariate linear regression problem and gives the least square solution to LDA. In our LS-ILDA approach, the least square solution is updated with exactness when a new sample is inserted. Therefore, LS-ILDA does not need to trade off performance for efficiency. More importantly, LS-ILDA is very fast, since the update only involves some simple matrix manipulations, requiring far less computational cost than eigen analysis.

The rest of this paper is organized as follows. In section 2, we give a brief introduction to the least square solution to LDA. In Section 3 we propose the LS-ILDA approach. Section 4 reports on our experiments. Finally, we conclude the paper in Section 5.
 LDA solves a general eigen-problem. Suppose there are C classes and n number of d -dimensional training samples, and n c denotes the number of training samples of the class c . Let 1 denote all-one vector of proper length. The within-class scatter matrix S w , the between-class scatter matrix and the total scatter matrix S t , are respectively, where  X  X  X  R d  X  n is the data matrix in which the columns are training samples,  X  X c is the data matrix of training samples belonging to the class c , m is the mean vector of all training samples, m c is the mean vector of training samples belonging to the class c , and T denotes matrix transpose.
 LDA computes a linear transformation matrix W  X  R d  X  ( C X  1) , and usually d  X  C . The transformation matrix projects data from the original high-dimensional space into a low-dimensional space, maximizing the between-class dis-tance while minimizing the within-class distance. Traditional LDA finds the optimal transformation matrix W LDA by solving the optimization problem W LDA = arg max
According to [4], when the total scatter matrix S t non-singular, the solution W LDA consists of the top eigen-vectors of the matrix ( S  X  1 eigenvalues. When the total scatter matrix S t does not have a full rank, W LDA consists of the eigenvectors of ( S + corresponding to the nonzero eigenvalues, where S + the pseudo-inverse of S t [5].

In [10], the relationship between LDA and multi-variate linear regression problem is investigated, and LDA is put into the framework of multi-variate linear regression by adding a constraint to the optimization problem of LDA, that is, where X  X  R d  X  n is the centered matrix of  X  X , and Y is the indicator matrix to be optimized.
 By solving Eq. 2, we can obtain the indicator matrix Y 0 ,
Y and the multi-variate linear regression solution to LDA, W MLR , as shown in Eq. 4.

Ye [10] proved that one can have Eq. 5 if the mild condition shown in Eq. 6 holds, where Q is orthogonal, and thus W MLR is equivalent to W LDA since they project data into two equivalent spaces.
 Actually Eq. 6 often holds in many applications. Even when it does not hold, W MLR is very similar to W LDA in the sense of making discrimination in the low-dimensional spaces. In this paper, we will take W MLR as the solution to LDA and will focus on the design of its incremental version. A. Redefining Indicator Matrix
In this paper, the least square solution W MLR is sim-plified for convenience of updating. The new least square solution W is defined in Eq. 7 with a much simpler indicator matrix Y .
 where the indicator matrix Y is Proposition III.1. If W MLR and W are defined according to Eqs. 4 and 7, respectively, and the data matrix centered, then
X1 = 0 since X is centered. Therefore, According to Eqs. 3 and 8, Y 0 and Y have a relation shown in Eq. 10.
 Therefore,
From the proposition we can see that W is a down-scaled solution. If needed, it can be scaled back without much computation. So, in the following we only consider the update of W ; and when a variable is updated, a tilde will be added on top of the variable.
 B. Updating Indicator Matrix Y
This section will focus on the update of the indicator matrix defined in Eq. 8.

Denote the label of the new sample as p . If p has already been observed before, the number of classes does not change, i.e.,  X  C = C , and the number of samples belonging to the class p increases by 1, i.e.,  X  n p = n p + 1 ; otherwise,  X  C = C + 1 and  X  n p = 1 . The indicator vector corresponding to the new sample will be appended to the indicator matrix as a new row. The new indicator vector, denoted by defined as Eq. 12. If p has been observed before, i.e., p  X C , then the matrix Y is updated according to where and the operator  X  p means multiplying the p -th column of Y with  X  p .

If p has not been observed before, i.e., p &gt; C , then where in this case y is a vector with length of ( C + 1) .
Unifying the above two cases into one form, Y is updated according to where  X   X  p means that if p is smaller than or equal to the width of Y , the p -th column of Y will be multiplied with  X  ; otherwise, a new column with zero elements will be augmented to Y .
 It is easy to verify that C. Updating LDA Solution W
To improve efficiency, we present two methods for updat-ing W by considering whether n is smaller than d or not. In addition to updating W , either X + or ( XX T ) + will be updated as intermediate result. In the case of n &lt; d matrix X + is smaller than ( XX T ) + , and therefore we will update X + ; while when n  X  d , especially when the number of samples overwhelms the number of dimension, we will update ( XX T ) + to avoid the computational cost for one update to grow with the number of samples. 1) Updating W When n &lt; d :
In the case n &lt; d , the updating formulas will be derived from Eq. 7. In the updating process, the mean of original data matrix m , the centered data matrix X , its pseudo-inverse X + and the solution W are kept and updated after every insertion of a new sample. It is assumed that the rank of will increase by 1 when a new sample is added.

When a new sample x is inserted, the mean m is first updated according to
Then the centered data matrix is updated. After the insertion of x , X should be re-centered according to  X 
X = while its pseudo-inverse X + changes according to Theo-rem III.1.
 Theorem III.1. Assume X , X + , x ,  X  X , m , 1 , n are defined as above, and rank (  X  X )  X  rank ( X ) = 1 . The pseudo-inverse  X  X + is where h = The fact rank (  X  X )  X  rank ( X ) = 1 implies ( x  X  m )  X  XX + ( x  X  m ) 6 = 0 . Denote the denominator of h as k , k = ( x  X  m ) T ( x  X  m )  X  ( x  X  m ) T XX + ( x  X  m ) . (22) Considering that ( x  X  m )  X  XX + ( x  X  m ) is the component of X in its null space, we have:
X T h =
X + h =
X1 T = 0 , 1X + = 0 .
 Let P = equations above, we have and According to the property of pseudo-inverse, XX + = ( XX + ) T , and therefore  X  XP and P  X  X are symmetric.
We also have and P  X 
XP = Therefore  X  X + = P .

Thus, the least square solution W to LDA can be updated according to the updated matrix  X  X + and  X  Y . Applying Eqs. 16 and 20 to Eq. 7, we have  X 
W = (  X  X + ) T  X  Y (27) where h is defined as Eq. 21 and  X  p is defined as Eq. 14. There is a trick for reducing the computational load. Considering that y is a row vector and only the p -th element is nonzero, the product of hy T is a matrix with the column as h y p while all other columns are zero vectors. So, only the nonzero column needs to be added onto the column of the matrix before the plus sign.

The four steps above are the updating method for the least square solution W . In each update, m , X , X + and necessary counters are kept. Every time a new sample is inserted, the four matrices are updated in order. By these updates, Eq. 7 always holds, and thus W is always the LDA solution for the current dataset. 2) Update W When n  X  d :
When the number of samples is not smaller than the number of dimensions, it is more appropriate to store the scatter matrix T 1 , T = XX T and its pseudo-inverse T + thus the time and space complexity will not increase with n . Since X + = ( XX ) + X , W can be rewritten as Eq. 28, from which the following updating method is derived. The mean of data matrix m is updated first according to Eq. 18. Then, T is updated according to where u =
The update of T + depends on whether the new sample has components out of the space spanned by T . Theorem III.2 shows how to update T + according to the update of T . Theorem III.2. Assume T , x , m are defined as above, and  X  T is defined by Eq. 29. Denote s = T + u , t = ( I  X  TT + ) u  X  = 1 + u T T + u . Then,
According to Theorem 2.1 in [1], when a matrix M is modified from A as the pseudo-inverse of M can be calculated as where d = A + b , e = ( A + ) T c , f = ( I  X  A + A ) c ,  X  = f T f ,  X  = g T g and  X  = 1 + c T A + b Only two relevant cases are listed here.

We need to prove that the updating of T + can fit into the two cases. Let A = T , b = c = u and M =  X  T . Since T is scatter matrix, which is positive semi-definite, and T + also positive semi-definite, we have T is symmetric, and T + is also symmetric, so If ( f = g ) = 0 , then it fits into the first case; if ( then it fits into the second case. Putting M =  X  T and a = b = u into the formula of M + , we can get the conclusion.

When T has full rank, the update always takes the formula of the first case, in which it requires far less computation and does not need to keep the matrix T . After accumulation of enough samples, T always has full rank, and therefore t = ( I  X  TT + ) u is always 0 and T + is updated as the first case shown in Eq. 30. In implementation, we use a counter r to record the rank of T . The counter r is initialized with Once T has full rank (i.e. r = d ), T and r can be discarded and only T + needs to be updated in the first case of Eq. 30. This is because that t will always be 0 , and r and T become unnecessary for updating.
 Finally we can update W with  X  T + ,  X  X and  X  Y . Applying Eqs. 16, 19 and 30 to Eq. 28, we have  X 
W =  X  T +  X  X  X  Y (33) Let G =  X  T + XY and expand it, then where Eq. 35 is used in the expansion. Thus, the final updating formula of W becomes where G and  X  p are defined in Eqs. 34 and 14, respectively.
This is the final update formula for the least square solution W . The last term has only one nonzero column, i.e., needs to be added to the p -th column of the matrix before the plus sign.

Pseudo codes of the first and the second updating method are shown in Tables I and II, respectively.
 D. Complexity Analysis
The LS-ILDA algorithm has a computational complexity of O ( min ( n, d )  X  d ) . In both our two updating methods of LS-ILDA, the update of W and other intermediate matrices can be decomposed into limited number of  X  X imple oper-ations X  if appropriate order for calculation is taken. These simple operations include multiplication between a matrix and a vector, addition between matrices, multiplication and addition between vectors, and multiplication between a vector and a scalar. Note that, there are no multiplication between matrices. When two matrices are added together, the number of basic additions equals the number of elements of one matrix. When a matrix multiplies a vector, the number of basic multiplications and the number of basic additions equal the number of elements of the matrix. When a vertical vector multiplies a horizontal vector, the number of basic multiplications also equals the number of elements of the resulting matrix. Therefore, the complexity of these operations is at most O ( n  X  d ) for the first method, and O ( d  X  d ) for the second method. For each update, the number of such operations is constant. Since LS-ILDA always picks up the method with lower complexity, its complexity of one update is O ( min ( n, d )  X  d ) . The space complexity is also O ( min ( n, d )  X  d ) , since the matrix X and X + or T + have to be kept.

Indeed the first updating method can be substituted by the second one. When n &lt; d , the solution W , the scatter matrix T and its pseudo-inverse T + can also be updated as the case when n  X  d , yet the computational cost would be much higher.
 We also compare the computational complexity of LS-ILDA with that of the GSVD-ILDA [13] algorithm and the ILDA algorithm proposed in [6] (denoted as ILDA07 here). Table III summarizes the time complexity of the three incremental LDA algorithms for a single insertion.

In the complexity expression of GSVD-ILDA, k is the number of major components of the centered data matrix used in updating and h is a value larger than k and smaller than d . The value of k depends on how much the eigen-spectrum energy is used in each step. In the complexity expression of ILDA07, k T is the number of components kept for total scatter matrix and k B is the number of components kept for the between-class scatter matrix.

When the rank of the total scatter matrix is nearly full rank, if the performance of GSVD-ILDA and ILDA07 approximate the performance of batch LDA, k and k T would be close to d and the computational cost would be greatly increased. This is observed in our experiments. LS-ILDA does not have such problem. Without relying on complicated eigen-analysis, LS-ILDA has a smaller magnitude of com-plexity. Overall, LS-ILDA gives exact least square solution and requires much less computation, which is verified in our experiments.
 In the experiments we compare our LS-ILDA with GSVD-ILDA [13] and ILDA07 [6]. GSVD-ILDA has a parameter c controlling the percentage of eigen-spectrum energy kept in each update. ILDA07 has two similar parameters, that is, the threshold for significant components of the total scatter matrix and the threshold for significant components of the between-class scatter matrix. In [13], the performance of GSVD-ILDA with different parameter settings had been tested, yet the authors did not specify which setting is the best. The authors of ILDA07 did not give the best parameter setting either. In our experiments, the two parameters of ILDA07 use the same threshold t . We choose two parameter settings for the two algorithms. One setting enables the algorithms to achieve their best performance, while the other setting makes the algorithms more efficient.

Four datasets are used in our experiments. The first is individuals, 10 per individual. In our experiments, we use the version preprocessed by Cai 4 . The image size is 32  X  32. The 165 gray-scale images of 15 individuals. The image size is 32  X  32. The third dataset is the AR database [8]. The version we used contains 2,600 faces of 100 individuals. The image size is 66  X  48. The fourth dataset is the CMU-poses are included. There are overall 11,554 images, 170 per individual except for the 38th individual. These images are resized to 32  X  32. This is a relatively large dataset.
All the datasets are split by 2:1, with two thirds used for training and the other one third for testing. On each dataset, a proportion of training samples are used as the initial data, and all the other training samples are incrementally inserted in random order. For each algorithm, this process is repeated for ten times, and the average results are recorded.
On ORL, one image per individual from the training data is randomly drawn out as initial data, and the remaining training samples are added chunk by chunk for training in random order. The chunk size is set to 1 and overall there are 226 insertions. For this dataset, c is set to 100% and 99% for GSVD-ILDA, while t is set to 0.1 and 1.0 for ILDA07. Figure 1 shows that LS-ILDA achieves the highest accuracy with the lowest time cost among the compared algorithms. curves of the three algorithms superpose each other. The three curves correspond to GSVD-ILDA with c = 100% , ILDA07 with t = 0 . 1 and LS-ILDA. When GSVD-ILDA and ILDA07 include minor components in their updating, they obtain the exact solution of LDA; LS-ILDA give the exact least square solution to LDA. These solutions reach exactly the same accuracy on this dataset. This indicates that the solution given by LS-ILDA is really a solution of LDA. Yet, when GSVD-ILDA and ILDA07 use other parameter settings, their performances become lower.

On Yale, one image per individual from the training data is randomly drawn out as initial data, and the remaining training samples are inserted one by one, with 95 insertions. On this dataset, c for GSVD-ILDA and t for ILDA07 are set to the same settings as that used for ORL. Similar results are obtained on this dataset, as shown in Figure 2. LS-ILDA achieves the highest accuracy with the lowest time cost. The accuracy curve of LS-ILDA is almost as same as that of GSVD-ILDA with c = 100% and ILDA07 with t = 0 . 1 , which verifies that the solution of LS-ILDA is really a solution of LDA.

On AR, one image per individual from the training data is randomly drawn out as initial data, and the remaining training samples are added chunk by chunk for training in random order. In each insertion, the chunk size is set to 5, and there are overall 327 insertions. On this dataset, for GSVD-ILDA and t for ILDA07 are set to the same settings as that used before. From Figure 3 we can see that the highest accuracy curves of LS-ILDA, GSVD-ILDA with c = 100% and ILDA07 with t = 0 . 1 are exactly the same, which verifies the goodness of the LS-ILDA solution again. Note that to achieve such high accuracy, LS-ILDA spends far less time cost than GSVD-ILDA with c = 100% and ILDA07 with t = 0 . 1 . Although the time cost of GSVD-ILDA with c = 99% is comparable with that of LS-ILDA, its performance is much worse than LS-ILDA.

On CMU-PIE, one fifth of the training data are randomly draw out as initial data, and the remaining training samples are added chunk by chunk for training in random order. The chunk size is set to 20. The samples in one chunk is inserted one by one for the LS-ILDA algorithm. On this datset, c for GSVD-ILDA is set to 100% and 99%, and t for ILDA07 is set to 0.1 and 0.8. Figure 4 shows that LS-ILDA achieves the highest accuracy. The overall 6,932 incremental samples are inserted to the training set of LS-ILDA one by one. It is impressive that after 6,932 updates, LS-ILDA can still give very precise solution. GSVD-ILDA with c = 100% achieves a comparable accuracy, yet its time cost is much higher than that of LS-ILDA. It can be observed from Figure 4 that the time cost of LS-ILDA is the lowest; the time cost of GSVD-ILDA with c = 99% is comparable yet its accuracy is much worse than that of LS-ILDA. Note that the experimental results show that the time cost of each update does not rely on the number of samples when LS-ILDA using the second updating method.

In this paper we propose the LS-ILDA algorithm to solve the incremental LDA problem. LS-ILDA incrementally updates the least square solution to LDA with exactness. The least square solution is the multiplication of pseudo-inverse of the centered data matrix and the indicator matrix [10], which gives us a chance to update the solution without eigen-analysis. The updates of related matrices and the final solution involve only simple matrix operations, such as multiplication between matrix and vector, and multiplication between vector and scalar, and addition between matrices and between vectors. The updates are exact, and do not lead to any theoretical deviation.

To reduce the computational cost, LS-ILDA contains two updating methods. When the number of samples is smaller than the number of dimensions, the data matrix and its pseudo-inverse are kept after each update; if the number of samples is not smaller than the dimension, the pseudo-inverse of the scatter matrix is kept, and the computational cost will not increase with the number of samples. The time complexity of one update in LS-ILDA is O ( min ( n, d )  X  d ) when there are n samples in d dimensions.
 Experiments on four datasets are performed to compare LS-ILDA with two recently developed incremental LDA algorithms, GSVD-ILDA [13] and ILDA07 [6]. The results show that LS-ILDA achieves the highest accuracy with the lowest time cost. The accuracy of LS-ILDA is as exact as that of the best performance achieved by GSVD-ILDA and ILDA07, which verifies that the solution obtained by LS-ILDA is really the solution to LDA. Moreover, to achieve the highest accuracy, the time cost of LS-ILDA is much smaller than that of the compared methods.

In the future, we will try to theoretically analyze the error bounds of LS-ILDA, and apply LS-ILDA to other application domains.

This work was supported by the National Science Foun-dation of China (60635030, 60721002), the Jiangsu Science Foundation (BK2008018), the Jiangsu 333 High-Level Tal-ent Cultivation Program and the MSRA IST Program. Li-Ping Liu is now working at the Alibaba Co., Beijing, China.
