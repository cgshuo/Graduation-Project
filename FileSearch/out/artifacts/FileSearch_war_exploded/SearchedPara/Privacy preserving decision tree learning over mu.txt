 1. Introduction the algorithm to other sources is often referred to as privacy preserving data mining . over an arbitrary number of distributed data sources in a privacy preserving manner. our experimental results in Section 6 . The last section concludes the paper. 2. Related work titioned data. Our scheme is efficient and can scale up to thousands of private data sources. retrieved from the data source [10,12,11,19] . 3. Background 3.1. Decision trees assigned the category associated with the leaf node.
 training set is shown in Fig. 1 b. 3.2. ID3 algorithm all the remaining objects belong to the same category (the last node is assigned this category). the set of objects with category c i . Then the information needed to classify an object in T is:
Let us assume that the objects have n attributes A 1  X  A n sume that A can have p values a 1  X  a p . Then the information of T given A is: The information gain for each attribute A is: attributes. 3.3. Distributed ID3
A. Assume that there are k categories c 1 to c k and A can have p values a whose A attribute value is a i and T ( a i , c j ) be the set of objects with value of A is a
Eq. (1) suggests that E ( T j A ) value for an attribute A can be computed if all j T ( a known. Note that in this case, j T ( a i ) j and j T ( a i data sources D 1 to D s , then where T l ( a i ) is the set of objects whose value for attribute A is a similarly).
 the tree are constructed recursively in a similar manner. 3.4. Secure ID3 construction
In Lindell and Pinkas [24] have proposed a method for running approximate ID3 algorithm the algorithm, i.e., the resulting tree.
 the form ( v 1+ v 2)  X  ln( v 1+ v 2) where v 1 and v 2 are the values known to the first party P respectively (such as v 1= j T 1 ( a i ) j and v 2= j T 2 for privately computing x  X  ln x value. This protocol takes as input the values x respectively and outputs random shares of an approximation of x  X  ln x value where x = x puts the name of the attribute with minimum value.
 for a large number of parties due to high communication and computation costs involved. 4. Privacy preserving summation of multiple secrets 4.1. Shamir X  X  secret sharing
Shamir X  X  secret sharing method [30] allows a dealer D to distribute a secret value v { P then computes the share of each peer P i as q ( X i ) and sends it to P Algorithm 1. Shamir X  X  secret sharing algorithm executed at D Require: v s : Secret value,
P : Set of parties P 1 , ... , P n to distribute the shares, k : Number of shares required to reconstruct the secret. 1: Select a random polynomial q ( x )= a k 1 x k 1 + ... + a 2: Choose n publicly known distinct random values x 1 , ... , x 3: Compute the share of each peer, P i , where share i = q ( x 4: for i =1to n do 5: Send share i to peer P i 6: end for received. Using k shares, the polynomial q ( x ), and thus the secret value v reconstructed using Lagrange interpolation such that p ( x nomial q ( x ) of degree k 1. 4.2. Privacy preserving summation
P end of the computation, each party P i only knows its own value v secret values of all parties involved, but nothing else.

A naive way to compute the sum of secret values of 4 parties P learn the sum is as follows: P 1 chooses a random number r and sends v v + v 2 + r to P 3 , and so on. Finally, P 4 sends v 1 + v 2 number r from the results and sends the value for the sum secure since two parties could collude and learn the secret value of another party. For example, P protocol to solve the problem could consist of two rounds. During the first round, every party P v and a random number r i to the intermediate result. Therefore, P to P 3 , and so on. P 1 then receives At the end of the second round, P 1 gets the sum more secure than the first one, it still has some vulnerabilities. For example, P as follows. In the first round, P 4 would have the value v + v 2 + r 2 + v 3 + r 3 + v 4 + r 4 from P 1 , thus, P 2 and P would also know v 1 + r 1 from the first round, they could deduce the secret value v to n 1). They also agree on m P n random values X ={ x 1 , ... , x loss of generality, we will assume that the degree of the polynomial is n 1and m = n . Each party P secret value v i and chose a random polynomial q i ( x ) of degree k and q itself. P i computes the share of each party P j as sh ( v bution phase, every party P i sends out the shares such that sh ( v
Example 1. Assume that there are 4 parties P 1  X  P 4 with secret values v respectively and they want to compute v 1 + v 2 + v 3 + v decide on a polynomial degree k = 3 and m = 4 values X = {3,5,7,8}. Each party P polynomial q i ( x ) of degree k = 3 whose constant term is the secret value v and computes the shares for other parties such that the share of party P the j th element of X . Thus the shares computed by P sh ( v 1 , P 2 )= q 1 (5) = 92, sh ( v 1 , P 3 )= q 1 (7) = 267, and sh ( v and P 4 pick random polynomials q 2 ( x )= x 3 + x 2 6 x +4, q + 8, and compute the shares for other parties: share( v i , P j ) P 1 P 2 P 3 P 4 v 2 q 2 (3) q 2 (5) q 2 (7) q 2 (8) v 3 q 3 (3) q 3 (5) q 3 (7) q 3 (8) v 4 q 4 (3) q 4 (5) q 4 (7) q 4 (8) and then sends this intermediate result to all other parties. Party P sends the intermediate result, INTERRES i = q 1 ( x i )+ q
Inthefinalcomputationphase,eachparty P i cancomputethesumofsecretvaluesusingtheintermediateresults it received during the previous phase.Note that each party P and constant term v i , and therefore the sum of all these polynomials results in another polynomial v stant term of S ( x ) is equal to Example 1 , thesum polynomial S  X  x  X  X  values 2 + 4 + 6 + 8. In addition, S  X  x i  X  X  4.2.1. Summary and proof of correctness In the above algorithm, each party P j selects a random polynomial of the form a computed as sh  X  v j ; P i  X  X  a P it computes its intermediate result by summing its shares:
P i then sends its intermediate result INTERRES i  X  X  a P 1  X  a sum of secret values ( SUM  X  v P has n intermediate results:
Since there are n unknown coefficients (including SUM ) and n equations, each party P of equations and determine the value of SUM  X  whole process is summarized in Algorithm 2.

Algorithm 2. Privacy preserving summation of secrets, executed at each party P
Require: P : Set of parties P 1 , ... , P n , v : Secret value of P i ,
X : A set of n publicly known random values x 1 , ... x n k : Degree of the random polynomial 1: Select a random polynomial q i ( x )= a k 1 x k 1 + ... + a 3: Compute the share of each party, P j , where sh ( v i , P 4: for j =1to n do 5: Send sh ( v i , P j ) to peer P j 6: end for 8: Receive the shares sh ( v j , P i ) from every party P 9: Compute INTERRES i  X  10: for j =1to n do 11: Send INTERRES i to peer P j 12: end for 14: Receive the intermediate results INTERRES j from every party P 15: Solve the set of equations to find the SUM  X  with each other (stated in Lemma 1 ). The secret value v i parties might also collude to learn its own value.
 shares. 2 the corresponding polynomial, i.e., the secret value of party P not compute v i even if they combine their shares. h useful information if it does not know the selected X = x tocol over arbitrary, not necessarily secure, channels. information, such as the secret values or the sum of those values. without knowing the x values for which the intermediate results are calculated. h 4.3. Computation with malicious parties to compute the correct final result. On the other hand, P act maliciously during the intermediate computation phase.
 2 n 2 instead of n 1. In this case, the parties agree on a set of 2 n points, X ={ x
P selects a random polynomial q i ( x ) with degree 2 n 2 and constant coefficient v putes 2 shares for each of the n parties, such that the shares for party P sh
This selection can be made in (the proofs are similar) so that: such as the secret values or the sum of those values.
 correctness. of obtaining the same final result for two different equation sets is 1/ j domain j the final result they computed.
 key to other parties in the second round. 5. Privacy preserving ID3 the ID3 algorithm over multiple data sources in a privacy preserving manner. Require: R : Set of attributes to be considered, O : Set of objects to be considered,
C ={ c 1 , c 2 ,..., c k }: Set of possible categories. 1: if R is empty then 2: Return a leaf node whose category is set to the dominant category among the objects in O summation protocol described in Section 4.2 (each party uses the number of objects with category c 3: end if 4: if All objects in O have the same category c i then 5: Return a leaf node whose category is set to c i check if all but a single category c i still has objects. / * 6: end if current tree node / * For every attribute A in R , the parties compute j T ( a 8: Create a new node for every possible value a i of A , and recursively call this method on it with R 0 =( R { A }) and O 0 = O ( a i )/ * 1000  X  1) and it took approximately 2.5 s.
 a party can learn that no other party has any objects with a certain category c protocol. 6. Experimental results two datasets from [14] : instances and 8 attributes, where each instance belongs to one of the 5 classes. should build decision trees collaboratively.
 more rounds of secure summation). 7. Conclusions up to thousands of data sources.
 Acknowledgement This research is supported by the NSF Grants under CNF 04-23336, and IIS 02-23022.
References
