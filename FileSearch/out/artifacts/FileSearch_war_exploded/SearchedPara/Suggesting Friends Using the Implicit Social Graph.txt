 Although users of online communication tools rarely catego-rize their contacts into groups such as  X  X amily X ,  X  X o-workers X , or  X  X ogging buddies X , they nonetheless implicitly cluster con-tacts, by virtue of their interactions with them, forming im-plicit groups . In this paper, we describe the implicit social graph which is formed by users X  interactions with contacts and groups of contacts, and which is distinct from explicit so-cial graphs in which users explicitly add other individuals as their  X  X riends X . We introduce an interaction-based metric for estimating a user X  X  affinity to his contacts and groups. We then describe a novel friend suggestion algorithm that uses a user X  X  implicit social graph to generate a friend group, given a small seed set of contacts which the user has already la-beled as friends. We show experimental results that demon-strate the importance of both implicit group relationships and interaction-based affinity ranking in suggesting friends. Finally, we discuss two applications of the Friend Suggest algorithm that have been released as Gmail Labs features. H.5.3 [ Information Systems ]: Information Interfaces and Presentation X  Group and Organization Interfaces ; I.5.3 [ Computing Methodologies ]: Pattern Recognition X  Clustering Algorithms, Human Factors Implicit social graph, tie strength, contact group clustering.
One benefit of many online communication channels over offline methods is that they enable communication among groups of people, rather than restricting communication to be peer-to-peer. Email is just one format that supports group conversations, but there are many others, such as photo-and link-sharing, and collaborative document edit-ing. In fact, group communication is so prevalent that our analysis of the Google Mail email network shows that over 10% of emails are sent to more than one recipient, and over 4% of emails are sent to 5 or more recipients. Within en-terprise domains, group communication is even more criti-cal. An analysis of the email network of Google employees showed that over 40% of emails are sent to more than one recipient, and nearly 10% are sent to 5 or more recipients.
As opposed to broadcast-style media, such as blogs 1 and micro-blogging platforms like Twitter 2 , the information com-municated by an individual to a limited group is generally carefully targeted, and may be private. The recipient lists for small-group communications such as emails are selec-tively constructed by the message senders. We have ob-served that users tend to communicate repeatedly with the same groups of contacts. This observation has prompted many online communication platforms to provide their users with tools for creating and saving groups of contacts. Some examples are the Google Mail Contact Manager 3 , or custom friends lists on Facebook 4 .

Despite the prevalence of group communication, users do not often take the time to create and maintain custom con-tact groups. One survey of mobile phone users in Europe showed that only 16% of users have created custom contact groups on their mobile phones [12]. In our user studies, users explain that group-creation is time consuming and tedious. Additionally, groups change dynamically, with new individu-als being added to multi-party communication threads and others being removed. Static, custom-created groups can quickly become stale, and lose their utility.

In this paper, we present a friend-suggestion algorithm that assists users in the creation of custom contact groups, e.g. http://www.blogger.com, http://www.wordpress.com http://www.twitter.com http://mail.google.com/support/bin/answer.py? http://www.facebook.com/help/#/help.php?page=768 either implicit or explicit. This algorithm is based on anal-ysis of the implicit social graph , which is the social network that is defined by interactions between users and their con-tacts and groups of contacts. We differentiate the implicit social graph from explicit social graphs that are formed by users explicitly adding other individuals as  X  X riends X . The implicit social graph is a weighted graph, where edge weights are determined by the frequency, recency, and direction of interactions between users and their contacts and groups. Our measure of tie strength differs from previous work in that we consider group interactions, as well as peer-to-peer.
We use the implicit social graph to identify clusters of contacts who form groups that are meaningful and useful to each user. Unlike some previous research on contact clus-tering, we do not consider the content of interactions. Ad-ditionally, because the email network that we have studied is private, we do not consider any friend-of-friend ties, ei-ther when computing edge weights for the graph, or when computing contact clusters.

Given a user X  X  social network with weighted edges and an initial seed of a few contacts, our friend-suggest algorithm builds a custom contact group that accurately expands the seed. We evaluate the efficacy of our algorithm by com-paring to baseline approaches via precision-recall measure-ments. We show two applications of this algorithm, imple-mented as Gmail Labs features, called  X  X on X  X  forget Bob! X  and  X  X ot the wrong Bob? X  Although our discussion centers around an email network, the network analysis that we have done is applicable to any implicit social graph that is formed by interactions between users and their contacts.
The Google Mail implicit social graph is composed of bil-lions of distinct nodes, where each node is an email address. Edges are formed by the sending and receiving of email mes-sages. For the purpose of our work, we consider a message sent from a user to a group of several contacts as forming a single edge, thereby constructing a directed hypergraph. We call the hypergraph composed of all of the edges leading into or out of a single user node that user X  X  egocentric network . We call each hyperedge an implicit group , even though it may consist of a single contact. On average, a typical 7-day active user has 350 implicit groups in his egocentric network, with groups containing an average of 6 contacts. Note that this does not imply that the average user has thousands of distinct contacts. Rather, each implicit group is a unique combination of one or more contacts with whom the user has interacted.

Edges in the implicit social graph have both direction and weight. The direction of an edge is determined by whether it was formed by an outgoing email sent by the user, or an incoming email received by the user. There may be both outgoing and incoming edges joining a user and an implicit group, if the user has both sent and received email from the group. We consider a user to have received mail from a group by joining the sender of the mail and the other co-recipients into an implicit group. Thus, if a contact c 1 sent mail to the user u and contacts c 2 and c 3 , this is represented in u  X  X  egocentric network as an incoming edge from the group { c 1 ,c 2 ,c 3 } to u .

The weight of an edge is determined by the recency and frequency of email interactions between the user and the group. In Section 3.1, we propose one metric for computing edge weight, which we call Interactions Rank . We claim that edge weight is an important indicator of the strength of the relationship between the user and a particular group. In the remainder of this paper, we use the terms edge weight , group weight , and group importance interchangeably.

In our work, we draw a sharp distinction between each user X  X  egocentric network and the global or sociocentric net-work that is formed by combining the networks of all users. Although other researchers have found value in clustering contact groups by looking at friend-of-friend edges (e.g. [9]), we restrict our algorithm to look only at a single user X  X  egocentric network during friend suggestion. By showing users suggestions based only on their local data, we are able to protect user privacy and avoid exposing connections be-tween the user X  X  contacts that might not otherwise have been known to him.

The social graph studied in this paper is constructed us-ing the metadata (i.e. timestamp, sender, and recipients) of outgoing and incoming messages set or received via Google Mail; message content is not included or examined. For the purposes of this research, we used a random sample of the metadata from thousands of interactions, and data was looked at exclusively in aggregate. The experimental results in Section 4 were gathered with the same privacy protec-tions that are used in all Google software development 5 to ensure that developers do not intentionally or unintention-ally access contact information about specific users without their explicit consent.
Our algorithm is inspired by the observation that, al-though users are reluctant to expend the effort to create explicit contact groups, they nonetheless implicitly cluster their contacts into groups via their interactions with them. For example, while a user may have multiple, possibly over-lapping, subgroups of coworkers with whom he exchanges emails, he is unlikely to include his family members in those interactions. The Friend Suggest algorithm, described in this section, detects the presence of implicit clustering in a user X  X  egocentric network by observing groups of contacts who are frequently present as co-recipients in the same email threads. The input to Friend Suggest is a seed , which is a small set of one or more contacts that belong to a particular group. This seed could be labeled by the user selecting a few contacts, e.g., as an initial list in the  X  X o: X  field of an email. Given this seed, Friend Suggest finds other contacts in the user X  X  egocentric network who are related to the seed, meaning that they are present in the same implicit clusters. Friend Suggest also returns a score for each suggested con-tact, indicating the goodness of its fit to the existing seed.
The algorithm described in this section is applicable to the problem of group clustering in any interaction-based social graph. For clarity and convenience, we describe it in terms of email interactions.
The first requirement of the Friend Suggest algorithm is an implicit social graph with edges whose weights represent the relationship strength between a user and his implicit http://mail.google.com/mail/help/privacy.html groups. We wish to compute edge weights that satisfy the following three criteria: 1. Frequency: Groups with which a user interacts fre-2. Recency: Group importance is dynamic over time. 3. Direction: Interactions that the user initiates are more Regarding recency, we observe that a group with which the user is actively interacting now is more important than one with which the user last interacted a year ago. Overall, recent interactions should contribute more to group impor-tance than interactions in the past. We also note that re-ceiving an email from a contact, a passive interaction, is a weaker signal of closeness than the active interaction of sending an email to that contact. In the most extreme case, we want to be able to rank spammer contacts, from whom the user receives many emails but to whom he sends none, very low in importance.

To satisfy these criteria, we propose Interactions Rank, a metric computed by summing the number of emails ex-changed between a user and a particular implicit group, weighting each email interaction as a function of its recency. Interaction weights decay exponentially over time, with the half-life,  X  , serving as a tunable parameter. An additional parameter that can be tuned in Interactions Rank is  X  out the relative importance of outgoing versus incoming emails.
Interactions Rank (sometimes abbreviated IR ) is com-puted over a set of email interactions I = { I out ,I cording to the following equation: where I out is the set of outgoing interactions between a user and a group, and I in is the set of incoming interactions, t now is the current time, and t ( i ) is the timestamp of an interaction i  X  I . Note that according to this equation, an interaction from the current time has a contribution of 1 to a group X  X  Interactions Rank, whereas an interaction from one half-life  X  ago contributes 1 2 and so on.

Interactions Rank is related to the Recency metric pro-posed by Carvalho and Cohen [5]. However, Interactions Rank calculates the weight of each interaction according to its timestamp, while Recency sorts interactions in chrono-logical order, and weights them on an exponentially decay-ing scale computed over their ordinal rank. Additionally, Recency does not take into account the direction of each in-teraction. Ting et al. propose an edge-weight metric that considers the role of the interaction participant, but does not take into account the time of the interaction [18].
It should be noted that Interactions Ranks do not easily allow for comparisons across several users. A very active user, who sends and receives many emails per day, will have overall higher Interactions Ranks for his implicit groups than a relatively inactive user. However, within a single user X  X  egocentric network, Interactions Rank allows for a clean or-dering of the user X  X  implicit groups by estimated relationship strength. We are actively working on incorporating other signals of importance, such as the percentage of emails re-ceived from a contact that the user chooses to read.
The core routine of the Friend Suggest algorithm, Ex-pandSeed is shown in Table 1. Table 1: Core algorithm for suggesting contacts that expand a particular seed, given a user X  X  con-tact groups.

The ExpandSeed function takes as inputs a user, u , who is the mailbox owner of a single egocentric network in the implicit social graph, and a seed, S , consisting of a set of contacts that make up the group to be expanded. Expand-Seed returns a set of friend suggestions, F , which maps each suggested contact to a score. Each contact X  X  score in-dicates the algorithm X  X  prediction for how well that given contact expands the seed, relative to the other contacts in u  X  X  network. Note that not all contacts from u  X  X  network are guaranteed to be returned in F .

Friend suggestions are computed as follows: The user u  X  X  egocentric network is extracted from the implicit social graph. The network, G , is represented as a set of contact groups, where each group g  X  G is a set of contacts with whom u has exchanged emails. Each group g has an Inter-actions Rank, computed as described in Section 3.1, indi-cating the strength of u  X  X  connection to the group g . The goal of ExpandSeed is to find, among all the contacts in G , those whose interactions with u are most similar to u  X  X  interactions with the contacts in the seed S .

ExpandSeed iterates over each group g in G , computing a score for each contact c that is a member of g . The algorithm does not suggest contacts that are already members of the seed S . Scores for each contact are computed iteratively via a helper function, UpdateScore , which takes the contact being considered, the contact X  X  score so far, F [ c ], the seed S , and the group g . In the following section, we discuss several possible scoring heuristics that were considered for UpdateScore .
UpdateScore is a function template that takes a single contact, c , from a user u  X  X  egocentric network and an implicit group g to which c belongs, and returns an incremental score based on the group g  X  X  similarity to the seed group, S . The sum of UpdateScore for a contact c over all of the implicit groups to which it belongs is an estimate of c  X  X  fitness to ex-pand the seed. Because both the implicit groups making up an egocentric network and the seed group that is the input to Friend Suggest are unordered sets of contacts, they can be compared via standard measures of set similarity [19]. In this work, we look only at set member intersection, leaving more complex metrics for future exploration. We define be-low several implementations of UpdateScore . In the next section, we evaluate their relative merits.
 The most basic instantiation of UpdateScore , shown in Table 2, simply returns a group g  X  X  Interactions Rank if the group has a non-empty intersection with the seed set. Table 2: An implementation of UpdateScore that sums the scores of all of the groups to which that contact belongs, for groups that have a non-empty intersection with the seed.

Intuitively, IntersectingGroupScore finds all the con-texts in which the proposed contact c exchanged emails or was a co-recipient with at least one seed group member. However, a larger intersection between the members of the seed group and the members of a given implicit group seems to indicate a higher degree of similarity. Table 3 shows a metric, IntersectionWeightedScore , that takes this into account. Table 3: An implementation of UpdateScore that sums the scores of all groups with a non-empty in-tersection with the seed, weighted by the size of the intersection times some constant k .

We investigate the contribution of group importance to friend suggestion by comparing against a metric, Inter-sectingGroupCount in Table 4, that simply counts the number of groups a contact c belongs to that have some in-tersection with the seed S . This metric ignores Interactions Rank entirely, and treats all implicit groups as having equal value to the user.

Finally, to highlight the importance of using a seed of con-tacts that characterize a distinct friend group, we compare against an UpdateScore instantiation, shown in Table 5, that ignores the seed and always suggests the top-ranked contacts. Contact ranks are computed by summing the In-teractions Ranks of the implicit groups containing each con-tact.

In each metric, the final friend suggestion scores are nor-malized with respect to the highest-ranked contact, so that Table 4: An implementation of UpdateScore that counts the number of groups to which a contact be-longs, for groups that have a non-empty intersection with the seed. Table 5: An implementation of UpdateScore that computes the InteractionsRank of a single contact by summing the scores of all of the groups to which that contact belongs. a single threshold can be used across all users, to cut off the list of suggested contacts.
In this section, we evaluate the quality of the Friend Sug-gest algorithm on real user data. We compare the different scoring functions discussed in the previous section, and ex-plore the impact of seed size of friend prediction.
Evaluation is one of the major challenges of developing algorithms that make predictions based on online social net-work data. Often, researchers build their data sets by sur-veying a small set of users who are willing to provide the ground truth about their online social relationships [8, 9, 21]. By asking users to categorize their contacts into groups, or rate contacts as  X  X lose to me X  or  X  X ot close to me X , re-searchers can build a labeled data set that serves for both training and testing. However, the nature of this type of sur-vey necessarily limits the number and variety of users who can be included in an experiment. Small sample size and user selection bias can harm the accuracy of the evaluation.
We therefore propose a novel, alternate evaluation method-ology. From a stream of real email traffic, we randomly sam-pled 10000 email interactions with between 3 and 25 recip-ients. Each recipient list is, in essence, a group of contacts that was implicitly clustered by the user. We can test the ac-curacy of the Friend Suggest algorithm, and compare the rel-ative success of different scoring functions, by sampling a few recipients from each group, and measuring how well Friend Suggest is able to recreate the remaining recipient list. Our approach is similar to the evaluation methodology used by Pal and McCallum [15], but whereas they removed one re-cipient from each interaction and verified whether their al-gorithm could restore him, we begin with small seeds and attempt to generate multiple additional recipients per email.
To generate the 10000 random test interactions, we first sampled 100000 interactions, and then defined rules that aggressively filtered this set to produce a set of email inter-actions likely to have been generated by active human users. We define an active user as a user with a minimum of 5 im-plict groups in his social network, who has sent at least one other email in the 7 days prior to the sampled interaction. We attempt to limit our data set to human users by exclud-ing, via regular expression matching, bots and auto-reply addresses such as  X  X nfo@domain X , and  X  X oreply@domain X .
Our experiment tests the ability of our algorithm to use a user X  X  existing social graph to predict his future group in-teractions. Therefore, when testing our algorithm X  X  ability to predict the remaining recipients in a given email inter-action, we use a snapshot of the user X  X  egocentric network based only on interactions that occurred earlier than the sampled interaction. Each graph below shows precision-recall curves for the Friend Suggest algorithm using the different scoring func-tions defined in Section 3.3, with seed groups ranging in size from 1 to 5. For the purposes of our evaluation, we measure precision as the percent of correct suggestions out of the to-tal number of contacts suggested for each seed group, and recall as the percent of correct suggestions out of the total number of email recipients who were not already members of the seed group. A correct suggestion is any contact who was a recipient of the email being evaluated.
 Figure 1: Precision/recall curves for the Friend Sug-gest algorithm with a seed of 2 contacts, run over the four different scoring functions defined in Sec-tion 3.3.

Note that, for all seed sizes, the scoring functions that take into account both group membership and relative group im-portance, IntersectingGroupScore and Intersection-WeightedScore , significantly out-perform TopContact-Score , which ignores the similarity of the seed contacts to the implicit groups and always suggests the top-ranked con-tacts, and IntersectingGroupCount , which ignores the Interactions Ranks of the groups and simply counts the num-ber of groups in which a contact was a co-recipient with at least one seed contact.
 Figure 2: Precision/recall curves for the Friend Sug-gest algorithm with a seed of 3 contacts, run over the four different scoring functions defined in Sec-tion 3.3.

Overall, the scoring function with the best performance is
IntersectionWeightedScore . For small seed sizes, its performance is similar to IntersectingGroupScore . However, as the size of the seed contact group increases, tersectionWeightedScore  X  X  performance remains fairly constant, while IntersectingGroupScore  X  X  ability to cor-rectly predict email recipients decreases. Because it includes in each contact X  X  score the score of every implicit group that contains at least one member of the seed group, Intersec-tionGroupScore is noisy and prone to false positives. By taking into account the size of the intersection between each implicit group and the seed group, IntersectionWeight-edScore is able to discount the impact of spurious implicit groups that have low similarity to the seed group.
 These experimental results demonstrate that the Friend Suggest algorithm, with a correctly chosen scoring function, is able to predict the remaining recipients of an email with high accuracy, given the first few contacts who were added by the user.
We use the Friend Suggest algorithm in two Gmail Labs features,  X  X on X  X  forget Bob! X , and  X  X ot the wrong Bob? X   X  X on X  X  forget Bob X  is a straightforward user interface on top of the Friend Suggest algorithm. As seen in Figure 4,  X  X on X  X  forget Bob X  operates when a user is composing an email message. The lab treats the first contacts added by the user as the seed set, and uses them to generate a set of possible suggested recipients that the user may wish to add to the the email. Once the user has added at least two contacts, the application queries the implicit social graph to Figure 3: Precision/recall curves for the Friend Sug-gest algorithm with a seed of 5 contacts, run over the four different scoring functions defined in Sec-tion 3.3. fetch the user X  X  egocentric network, and uses Friend Suggest to generate up to four contacts who best expand the seed set of existing contacts. These contacts are displayed as clickable links below the  X  X o: X  input field. If the user clicks on a suggestion, or types in another email address, it is added to the list of recipients, and a new set of suggestions is generated.  X  X on X  X  forget Bob X  has been enabled and used by hun-dreds of thousands of users, and overall, the user response has been positive. One user posted to the lab X  X  feedback group 6 ,  X  X his is incredibly helpful for work/school/family groups without having to create contact groups. X  However, accurately measuring the performance of  X  X on X  X  forget Bob X  remains a challenge. We know that users click on a sig-nificant fraction of suggestions. Our informal user surveys suggest, though, that many users prefer to continue enter-ing contacts via the keyboard and traditional auto-complete mechanism, and find it inefficient to switch to the mouse in order to click on a suggested contact. Those users report that the displayed suggestions serve as a useful memory trig-ger, but the added value is difficult to quantify.
A more complex use of the Friend Suggest algorithm can be found in the  X  X ot the wrong Bob? X  lab, shown in Figure 5.  X  X ot the wrong Bob X  addresses the known problem of email autocompletion errors [4]. While previous approaches have relied heavily on message content,  X  X ot the wrong Bob X  uses the Friend Suggest algorithm to detect the inclusion of con-tacts in a message who are unlikely to be related to the other recipients.

The WrongBob algorithm, shown in Table 6, works as follows: From the current recipients of an email that have been entered by the user, the algorithm attempts to find a single contact whose removal and replacement with another contact from the user u  X  X  egocentric network would lead to https://groups.google.com/group/gmail-labs-help-suggest-a more coherent recipient list. For each contact c current recipient list L , WrongBob builds a seed set that includes all of the members of L except c i (lines 4-5). This seed is expanded via ExpandSeed to generate a set of con-tacts that are similar to the current members of the seed. If the excluded contact c i is a member of the suggestion set, it is considered to be related to the other recipients and unlikely to be a mistake (lines 7-8). WrongBob therefore stops searching for a replacement for c i .

If, however, c i is not returned as a suggestion from Ex-pandSeed , it is a potential mistake. WrongBob searches for another contact that could replace c i . Each contact c the result set returned by ExpandSeed is compared to the error candidate c i via a helper function IsSimilar . In our implementation, we measured similarity by checking to see if c was listed as an autocomplete suggestion at the time that the user entered the contact c i . If c i and c j are similar, and c  X  X  score as a member of the seed expansion is higher than the current maximum, c i and c j are saved as the current candidate pair (lines 10-13). After examining all contacts in L , the candidate pair with the highest score is returned and displayed to the used as  X  X id you mean Contact A instead of Contact B X ? function WrongBob ( u , L ): Table 6: The WrongBob algorithm which, based on the user X  X  egocentric network, checks if one of the existing recipients would be a good candidate for replacement with another contact.

For example, consider the recipient list L = { a,b,c } . As-sume that when removing a to create the seed list { b,c } , ExpandSeed generates the suggestion set { a,d } . In this case, because the excluded contact a is a member of the suggestion set, WrongBob determines that it is not a mis-take. Then, when removing b , if the algorithm observes { b ,d } , where b 0 is similar to b but d is not, the algorithm will consider { b,b 0 } as candidates for replacement. If, after removing c , the algorithm generates another candidate pair { c,c 0 } , then it will return the pair with the highest score.
Like  X  X on X  X  forget Bob X , the  X  X ot the wrong Bob? X  lab has  X  X neezy X , and  X  X leepy X .
 of  X  X ob Jones X . been enabled and used by hundreds of thousands of users. Additionally,  X  X ot the wrong Bob? X  has received a great deal of favorable media attention in both popular forums such as the New York Times and Esquire, and more technical fo-rums like TechCrunch [3, 17, 16]. As in the previous lab, measuring the true performance is challenging. While some users do click on many suggestions, others prefer to edit email recipient lists via the input textbox after being noti-fied by the lab that they may have made a mistake. Overall, user feedback has been positive, with many anecdotal re-ports of how the lab has helped users to avoid embarrassing mistakes. Together, the Bob labs contribute to an ongoing effort to improve the interactions between Google users and their contacts and groups.
In this section, we discuss related work in three areas: au-tomatic creation of contact groups, analysis of interactions to predict tie strength, and other explorations of communi-cation networks.
There has been some previous work on automatic clus-tering of online contacts into groups. Reto et al. present Cluestr, a clustering algorithm that groups contacts using known graph clustering algorithms [12]. They build an un-weighted social graph and cluster it based on edge density between contacts. For example, if a user u has a set of con-tacts { c 1 ... c n } who are highly connected to each other, then they are likely to form a group that is meaningful to u . However, this sociocentric algorithm can only apply to networks in which u is aware of the connections between his contacts. Recall that in our work, we use only the egocen-tric network of each user, to avoid exposing to the user the private information of his contacts.

In their work on email networks, Pal and McCallum use message content to cluster email recipients into groups [15]. For each user, they build a model that maps keywords and phrases extracted from email messages to the contents who are likely to receive an email containing those terms. They show how these models can be used to successfully predict the recipients of an unaddressed message, and even more successfully, how the  X  X C: X  and  X  X CC: X  recipients can be predicted, given the  X  X O: X  recipients. Carvalho and Cohen use a similar content-based model to solve the inverse prob-lem of finding group anti-members, or email recipients who were likely added to a message by mistake [4]. Unlike these approaches, our analysis is based only on interactions, and disregards content.

The C-Rank algorithm of Bar-Yossef et al. is the most sim-ilar to the Friend Suggest algorithm described in this paper, in that it is applied to email egocentric networks formed by creating edges between contacts if they appear as co-recipients in email messages [2]. Edges are assigned weights according to the number of email messages involving each pair of contacts. The graph is then thresholded at a num-ber of different edge weight thresholds, with edges falling below the threshold removed, to created a set of unweighted graphs. C-Rank identifies clusters of contacts within these graphs by finding vertex separators , or contacts whose re-moval from the graph creates disconnected subgraphs. The authors claim that a good cluster is one that exists in several graphs with different threshold levels.

Within enterprise networks, where expectations of privacy are lower than in consumer email networks, researchers have used sociocentric analysis to cluster and classify groups of users. For example, De Choudhury et al. use an inferred social network constructed from email interactions to assign roles to the various participants, such as  X  X tudent X ,  X  X aculty X , or  X  X irector X  [6]. They use email frequency to filter noisy and potentially spurious edges from the graph.
Another body of related work has explored the use of in-teractions as a signal for measuring the strength of social ties. Much of this work has studied the relationship be-tween Facebook users and their contacts. Gilbert and Kara-halios use a set of 70 different features to predict the strength of connection between a user and his Facebook friends [8]. These features range from demographic features of the users, such as age and religion, to interaction frequency and re-cency features such as the number of comments a user has left on his friend X  X  photos and the time elapsed since their last email exchange. They found that the strongest predic-tor of tie strength between two individuals is a short elapsed time between message exchanges.

In other work on Facebook tie strength prediction, Ka-handa and Neville compare the relative predictive value of interactions, which they call transactional features , as com-pared to graph topology or profile attribute features [9]. They found the highest predictive value in network-trans-actional features , which extend transactional features to in-clude friend-of-friend links. For example,  X  X erson X posted on Person Y X  X  wall X  is a network-transactional feature about the relationship between Person X and some other Person Z, if Y and Z are friends. Xiang et al. also build a predic-tive model of the strength of ties on Facebook, looking at interactions such as face-tagging in photos [20].

In email networks, researchers have primarily been inter-ested in tie-strength as a useful feature for predicting the emails to which a user is likely to reply [10]. Yoo et al. find that including social features along with message content-based features in the vector of classifier input led to a signif-icant reduction in prediction error when learning to identify the emails that a given user will consider important [21].
Finally, there has been significant recent interest in explor-ing and understanding the properties of communication net-works. Ting et al. propose a general-purpose architecture for extracting communication-based social networks from mul-tiple sources of interaction data [18]. Leskovec et al. sur-vey a large number of different communication networks to answer the question of whether they share a common com-munity structure [14]. An in-depth study of one particular explicit network, the social network formed by MSN Instant Messenger users, is performed by Leskovec and Horvitz [13]. They find that users tend to communicate most frequently with users who are demographically similar to themselves. Furthermore, they find that the overall network is robust to the removal of random nodes, in that it does not disturb the overall connectivity of the graph.

Email networks are the most commonly studied implicit social graphs. Dodds et al. show that email networks follow a small-world property, with an average shortest path of 4.1 steps between any two nodes [7]. Adamic and Adar fur-ther explore strategies that users can employ to exploit this dense connectivity in order to efficiently propagate infor-mation through an enterprise email network [1]. Kossinets and Watts study the social network formed by email ex-changes between students and faculty of a large university, and find that, although the local connections between indi-viduals evolve over time, the overall network structure re-mains stable [11].
In this paper, we studied the implicit social graph , a so-cial network that is constructed by the interactions between users and their groups. We proposed an interaction-based metric for computing the relative importance of the con-tacts and groups in a user X  X  egocentric network, that takes into account the recency, frequency, and direction of interac-tions. We then defined the Friend Suggest algorithm which, given a single user X  X  egocentric network with computed edge weights and a seed set of a few labeled contacts, finds other contacts who are related to the seed contacts, and therefore form a semantically meaningful group. We demonstrated the effectiveness of the Friend Suggest algorithm via a novel experimental methodology. Finally, we showed two appli-cations of the Friend Suggest algorithm, the Gmail Labs  X  X on X  X  forget Bob! X  and  X  X ot the wrong Bob? X 
Although the experimental results described in this pa-per were performed by examining email interactions from the Google Mail system, the algorithms and approaches de-scribed in this paper apply to any interaction-based social network. Some other interaction types that could form sim-ilar implicit networks are photo and document sharing, in-stant messenger chatting, online calendar meeting invita-tions, or comments on blog posts. Even offline interactions, such as mobile text messages or telephone calls, form an implicit social graph between individuals and groups. Our future research is intended to study the relative importance of different interaction types in determining the social rela-tionships between individuals. We are also interested in ex-ploring other applications of the Friend Suggest algorithm, such as identifying trusted recommenders for online recom-mendation systems, or improving content sharing between users in various online contents. [1] L. Adamic and E. Adar. How to search a social [2] Z. Bar-Yossef, I. Guy, R. Lempel, Y. S. Maarek, and [3] J. D. Biersdorfer. Tip of the week: Got the wrong [4] V. R. Carvalho and W. W. Cohen. Preventing [5] V. R. Carvalho and W. W. Cohen. Ranking users for [6] M. D. Choudhury, W. Mason, J. Hofman, and [7] P. S. Dodds, R. Muhamad, and D. J. Watts. An [8] E. Gilbert and K. Karahalios. Predicting tie strength [9] I. Kahanda and J. Neville. Using transactional [10] T. Karagiannis and M. Vojnovic. Behavioral profiles [11] G. Kossinets and D. J. Watts. Empirical analysis of an [12] M. Kuhn and M. Wirz. Cluestr: Mobile social [13] J. Leskovec and E. Horvitz. Planetary-scale views on a [14] J. Leskovec, K. J. Lang, A. Dasgupta, and M. W. [15] C. Pal and A. McCallum. CC prediction with [16] M. Siegler. Meeting with the Bobs? Gmail will now [17] M. Sullivan. Self-correcting e-mail: Because you can [18] I.-H. Ting, H.-J. Wu, and P.-S. Chang. Analyzing [19] R. E. Tulloss. Assessment of similarity indices for [20] R. Xiang, J. Neville, and M. Rogati. Modeling [21] S. Yoo, Y. Yang, F. Lin, and I.-C. Moon. Mining
