 Pattern discovery in sequences is an important problem in many ap-plications, especially in computational biology and text mining. How-ever, due to the noisy nature of data, the traditional sequential pattern model may fail to reflect the underlying characteristics of sequence data in these applications. There are two challenges: First, the mu-tation noise exists in the data, and therefore symbols may be mis-represented by other symbols; Secondly, the order of symbols in se-quences could be permutated. To address the above problems, in this paper we propose a new sequential pattern model called mutable per-mutation patterns. Since the Apriori property does not hold for our permutation pattern model, a novel Permu-pattern algorithm is de-vised to mine frequent mutable permutation patterns from sequence databases. A reachability property is identified to prune the candi-date set. Last but not least, we apply the permutation pattern model to a real genome dataset to discover gene clusters, which shows the effectiveness of the model. A large amount of synthetic data is also utilized to demonstrate the efficiency of the Permu-pattern algorithm. I.5.2 [ Design Methodology ] Algorithms Sequential Pattern, Permutation Pattern, Proximity Pattern
Mining ordering information from sequence data is an important data mining task. Sequential pattern mining [3, 5, 21, 25, 26] can be regarded as mining frequent segments of total orders from se-quences. However, due to noise in databases, the order of symbols in sequences may be permutated. Thus discovered sequential pat-terns may not reveal the real characteristics of data. For example, in genomes of different organisms, genes may relocate during evo-lution [10, 16]. On the other hand, symbols in sequences could be misrepresented by other symbols due to the presence of the symbol mutation noise. In some applications different symbols may be con-sidered the same due to their similarity. For example, in text mining, a set of synonymous words is a group of distinct symbols that should be treated as the same. Orthologous genes [10], which are different genes in various genomes with the same biological functionality, also form such groups in a biological context. This kind of mutation noise can conceal frequent sequential pattern discovery.

In this paper, we study the problem of discovering a new type of pattern, called mutable permutation patterns, in noisy environ-ments. The model of mutable permutation patterns addresses the above problems of sequential patterns in noisy environments. In these environments, the order of symbols in a pattern could be altered in sequences, and some symbols are interchangeable with other sym-bols. Member symbols of a mutable permutation pattern can appear in any order in sequences while keeping physical proximity. These patterns are of great importance in many applications. Two example applications are:
We assume that the input sequence data set is in the form &lt;s g ,s 2 ,g 2 ,...,s n &gt; where s i is the symbols and g i is the gap be-tween two consecutive symbols. As described in above examples, this form of data set may appear in text and bio-sequence domains. For instance, a genome sequence can be in this form where s gene and g i is the gap between two consecutive genes in the genome as shown in [16]. If a group of genes forms a team for a certain bio-logical function, these genes may be close to each other in a genome. Since the number of genes participating in the biological function may vary from a few to more than a couple hundred, the total portion of the genome that this group of genes spans may not be bounded. However, the gap between any two genes in this group is within a certain threshold, e.g., 300 base pairs according to [16]. By discov-ering the group of genes that always cluster together across several genomes, we may be able to identify the set of genes that participate in a biological process. Also, text can be represented in this form where s i is a keyword and g i is the gap between two keywords. In this paper, we focus on the following type of applications: (1) The order of the symbols may not be important, (2) but the gap between two symbols is important. There exist other applications where the order is important and/or the gap is not important. We will not inves-tigate these problems in this paper.

Due to the mutation noise and permutation in these sequence data, the traditional sequential pattern model may not work. However, a key observation on sequences in these applications is that: Al-though the order of pattern symbols might be permutated, the posi-tions of pattern members still remain close in those sequences where the pattern occurs. For example, in genomes, especially prokaryote genomes, functionally related genes tend to be physically clustered, i.e., they appear proximate in genomes [7, 16]. For another exam-ple, genes in one operon are controlled as a single unit and they work together. In text documents, certain words may co-appear in many sentences, while their order slightly changes. For example, one news article may say "Google bought YouTube", while another arti-cle says "YouTube was acquired by Google". Then {Google, {buy, acquire}, YouTube} represents a common pattern between these two documents, although they do not appear in the same order in two arti-cles, and one article uses "buy" while the other uses "acquire" which is a synonym of "buy". This type of pattern is useful in text clustering and classification.

Based on the above observation, the mutable permutation pattern model is proposed in this paper. To represent the mutation of se-quence symbols, each position in a pattern is a mutable set. A muta-ble set can be one single symbol or a set of symbols that are mutually interchangeable. In text mining, these mutable sets can be obtained from a dictionary such as WordNet [8]. For example, {gas, gaso-line} could be a mutable set. In genome analysis, mutable sets can be computed by sequence similarity [4].

Since in our problem the order of symbols is permutated, we loosen the definition of patterns to allow symbols in a pattern to occur in any order in sequences, as long as they occur in close enough proxim-ity. The mutable permutation pattern ,or permutation pattern for short, is a pattern whose member symbols could appear in any order in sequences, as long as they keep physical proximity. The advan-tage of the permutation pattern model over the traditional sequential model is that the permutation pattern model can capture not only the total order of symbols but also the permutated order of symbols.
This problem is not a simple association ruleApriori-based algo-rithms mining problem because of the proximity constraints applied on the patterns. Due to the loose definition of mutable permuta-tion patterns, the Apriori property for the sequential patterns does not hold. This is further explained in a later section. Therefore, the Apriori-based algorithms cannot be directly applied to mining per-mutation patterns. We invented a novel Permu-pattern algorithm to discover frequent permutation patterns from large sequence databases. Instead of using the Apriori property, a reachability property is iden-tified to prune the candidate set for frequent permutation patterns. The Permu-pattern algorithm is not a level-wised Apriori algorithm since it does not grow from short patterns to longer patterns and does not utilize the Apriori property. The advantage of the reachability property and the Permu-pattern algorithm comes from their pruning power which can reduce the size of candidate set significantly.
The remainder of this paper is organized as follows. A brief sur-vey of related work is given in Section 2. The model of mutable permutation patterns is proposed in Section 3. Section 4 describes the Permu-pattern algorithm in details. The experimental results are presented in Section 5. Then we discusse the settings and possible improvements of our model in Section 6. Finally, Section 7 draws the conclusion.
Sequential pattern mining [3, 5, 11, 14, 21, 25] has been an active research area in the data mining community for years. The problem was first introduced by the authors of [3], and two algorithms, Aprio-riAll and AprioriSome were proposed in [3]. GSP [21] was another Apriori-based algorithm for sequential pattern mining which inte-grated a time-constraint and taxonomies. Although [21] introduced a time-constraint and knowledge of taxonomies, the Apriori property still holds, which was different from the problem in our paper. Pre-fixSpan[17] described an algorithm to mine sequential patterns by prefix-projected pattern growth. SPADE [27] was an algorithm pro-posed to find frequent sequences using efficient lattice search tech-niques and simple joins. In [14], the authors outlined a more general formulation of sequential patterns, and developed a modification of the GSP algorithm [21] to discover universal sequential patterns. Re-cently [5] introduced a parallel algorithm to mine closed sequential patterns on a distributed memory system. However, all the above works require that the database is clean and neither mutation noise nor permutation exists, which is very different from the problem in this paper. The model proposed in [26] took into account the muta-tion among sequence symbols, but it still did not consider the permu-tation noise in sequences.

Mining sequential patterns with constraints has received much at-tention in different angles. [9] proposed regular expressions as con-straints for sequential pattern mining and developed a family of SPIRIT algorithms. [18] systematically studied the problem of pushing var-ious constraints into sequential pattern mining. In addition, an ef-ficient algorithm, prefix-growth, was developed to mine sequential patterns with prefix-monotone constraints. In [19], the Frecpo algo-rithm was proposed to mine frequent closed partial orders from large sequence datasets. However, the problem of mining sequential pat-terns in our paper is more complex than these proposed works: first the proximity constraint must be observed; second, the existence of mutation noise and permutation makes their models insufficient to capture the intrinsic characteristics of data. On the other hand, se-quential pattern mining for biological sequences has been explored by authors of [24]. A new sequential pattern model was proposed to treat a pattern as a list of segments. A scalable algorithm was de-vised for mining these patterns from general biological sequences. But their model is still unable to handle mutation noise and permu-tation noise in biological sequences, and thus fails to generate more meaningful results.

Given k permutations of n elements, in [12], the authors defined a common interval as a k -tuple of intervals of these permutations consisting of the same set of elements. It presented an algorithm that finds in a family of k permutations of n elements all K common inter-vals. The authors of [1] introduced a similarity measure for permu-tations, based on the concept of conserved intervals. Related genes often appear in each other X  X  neighborhoods on the genome, however the order of the genes may not be the same. [2] addressed the prob-lem of automatically discovering such gene clusters. In [22], the authors presented a gene cluster model based on common intervals that includes the notion of paralogous genes and regions of internal duplication. [15] presented a new tool for presentation and detection of gene clusters in multiple genome, using PQ trees. However, none of these directly solved the problem of discovering mutated permu-tation sequential patterns.
In this paper, we are interested in discovering patterns from a se-quence database in which both the permutation noise and the symbol mutation noise exist. We assume that a sequence is an ordered list of symbols along with their positions in the sequence, which can be represented as { s 1 ,g 1 ,s 2 ,g 2 ,... g l  X  1 , s l }, where s at the sequence, and g i are the gaps between symbols s i A sequence database is therefore a set of such sequences. How we transform sequences in different applications is discussed in a later section.

In addition, we assume that there is a symbol similarity matrix indicating which symbols are similar. Symbols with high similar-ity are likely to mutate in sequences. This similarity matrix can be obtained in different ways for different applications. For example, in text mining, the word similarity matrix can be constructed from dictionaries or lexical databases such as WordNet [8]. In biologi-cal sequence analysis, the gene similarity matrix can be constructed by sequence similarity via BLAST [4] or other tools. Currently, the COG database [23] with a large number of orthorlogs (mutation sets of genes) is publicly available. To handle this mutation noise in se-quences, we define the mutable symbol set in our model as follows:
D EFINITION 1. A mutable symbol set ,or mutable set for short, is a non-empty set of mutually mutable and exclusive symbols.
Once the symbol similarity matrix is obtained, the mutable symbol sets can be easily derived by setting a similarity threshold. A mutable symbol set can consist of a single symbol or a set of symbols. The mutable set { police, cop } means that the words police and cop are synonyms and thus interchangeable. If a mutable set contains only one symbol, it means that this symbol is not mutable to any other symbol. For example, the mutable set {politics} indicates that the word politics has no synonyms. One symbol could belong to multiple mutable sets, e.g., a word could have different meanings.

In the traditional sequential pattern model, a sequence is said to support a pattern only when the total order defined by the pattern is contained by the total order defined by the sequence. However, in the problem studied in this paper, we are interested in finding groups of symbols appearing in close proximity to each other in many se-quences. The exact order is not important since the order of symbols in sequences can be permutated by noise. To address this problem, the concept of mutable permutation pattern is introduced in our model. The mutable symbol set serves as the basic building block of mutable permutation patterns.

D EFINITION 2. A mutable order-permutation pattern ,or per-mutation pattern for short, is a collection of mutable symbol sets and in the format PP ={ MS i | 1  X  i  X  m }, where MS i are mu-table sets. The number of mutable sets in a permutation pattern, m , is called the length of the permutation pattern. An unordered sym-bol set { s i | 1  X  i  X  m } is called an unordered instance of PP if s i  X  MS i for every i (1  X  i  X  m ) . An ordered symbol set ( s | 1  X  i  X  m ) is called an ordered instance of PP if s i  X  for every i (1  X  i  X  m ) .

Example 1 : PP = {{ s 1 } , { s 2 ,s 3 } , { s 4 }} is a permutation pat-tern, which contains three mutable sets: { s 1 } , { s PP has two unordered instances: IPP 1 = { s 1 ,s 2 ,s 4 } = is a permutation of IPP 1 . PP along with all unordered instances and ordered instances of PP are illustrated in Figure 1. We use {} to represent an unordered instance and ( ) to represent an ordered instance.

Here we use mutable sets other than symbols as building blocks of the permutation pattern due to: 1. In certain context, symbols across sequences only appear in the form of mutable sets. Individ-ual symbols will not appear in multiple sequences. For example, in genomes, genes across species are all different, but orthologous gene groups exist among species. 2. In some context, individual symbols are not frequent while their mutable sets are. For example, a word in a document may not be frequent while its synonyms are frequent across multiple documents.

D EFINITION 3. A sequence S =( s 1 ,g 1 ,s 2 ,g 2 ,... g l ports a mutable permutation pattern PP ={ MS i | 1  X  i  X  m }if and only if there exist integers j 1 ,j 2 , ..., j m , such that
We call a pattern a frequent permutation pattern if at least T sequences in a sequence database support this pattern. T sup the support threshold.

That is to say, if in a sequence there exist m positions, where m is the length of a permutation pattern, the symbols at these positions in the sequence form an ordered instance of the permutation pattern, meanwhile in this sequence the distance between any two consecu-tive symbols of these m symbols is no larger than the gap threshold T gap , then this sequence is said to support the permutation pattern. Here the proximity constraint is imposed on the gap between two consecutive pattern members, rather than the gap between the first and last pattern members. This is because the number of members in a pattern is always unknown. Applying the proximity constraint on successive pattern members allows us to find longer patterns which are often more interesting.

Example 2: Given a permutation pattern PP = {{ s 1 } , { s { s 4 }} and T gap = 500 , then sequence S 1 ={ s 1 , 100 , s 300 , s 3 } supports PP , because S 1 contains an ordered instance of PP : ( s 1 ,s 4 ,s 3 ) as a subsequence, and the gaps between s s and s 3 are both below 500 . However sequence S 2 =( s 1 , 500 , s 4 , 300 , s 3 ) does not support PP because the distance between s and s 4 is 600 , which is larger than T gap .

D EFINITION 4. A mutable permutation pattern PP 1 is a super-pattern of another permutation pattern PP 2 if the mutable sets in PP 2 are super-sets of the mutable sets in PP 1 .

Example 3: Permutation pattern PP = {{ s 1 } , { s 2 ,s 3 a super-pattern of pattern PP 1 = {{ s 1 } , { s 4 }} , but is not a super-pattern of pattern {{ s 1 } , { s 2 ,s 5 } , { s 4 }} .

D EFINITION 5. A mutable permutation pattern PP is called a maximal frequent permutation pattern if PP is frequent as defined in Definition 3 and any of its super-patterns is not frequent.
Problem Statement: Given a support threshold T sup and a gap threshold T gap , we want to find all maximal frequent mutable per-mutation patterns in a sequence database.
In this section, we propose the Permu-pattern algorithm to solve the problem of finding maximal frequent mutable permutation pat-terns. As we mentioned earlier, the Apriori property for frequent sequential patterns and association rule mining does not hold for the permutation patterns. For example, given a sequence database S 1=( A, 100 ,C, 100 ,B ) and S 2=( B, 100 ,C, 100 ,A ) .Ifthe support threshold T sup =2 and the gap threshold T gap = 150 {
A, B } is not a frequent mutable permutation pattern due to the fact that the gaps (distance) in two sequences are both larger than T However, its superset { A, B, C } is a frequent permutation pattern because C appears in between A and B in every sequence and the gaps between them are below the gap threshold. Therefore, instead of using Apriori-based algorithms, we need to develop a new algo-rithm to discover the frequent permutation patterns.

In theory, any combination of mutable sets can be a candidate for frequent permutation patterns. If we enumerate all candidate patterns by combining any mutable sets, a set enumeration tree can be built. Then we can systematically search the set enumeration tree for fre-quent permutation pattern. However in the set enumeration tree the number of candidates grows exponentially with the number of the mutable sets. Thus, the exhaustive search of the set enumeration tree is not efficient or even not possible when the number of mutable sets is large. Therefore, we device a novel technique to prune the candi-dates. At a high level, the pruning process removes candidates that is definitely not frequent. The following observations can help us to prune the candidates for a frequent pattern. 1. In a frequent permutation pattern, every single mutable set has 2. If a frequent permutation pattern occurs in a sequence, for any
Based on these observations, a reachability property is identi-fied to facilitate the discovery of permutation patterns by pruning the candidate set. Only two scans of the database are needed to store information of the database in a data structure called "reach-able cases". All pruning and verification processes are conducted on this data structure.
 The flowchart of the Permu-pattern algorithm is given in Figure 2. Three main phases of the Permu-pattern algorithm are explained in details with a running example. The example sequence database is as below:
S 1 = ( s2 , 100 , s1 , 500 , s4 , 100 , s6 , 100 , s7 , 800
S 2 = ( s1 , 50 , s4 , 100 , s2 , 300 , s7 , 150 , s4 , 150
S 3 = ( s2 , 100 , s1 , 150 , s4 , 500 , s5 , 100 , s6 , 100 { s 3 ,s 7 } is a mutable set and every other symbol is in a mutable set containing only the symbol itself. The support threshold T setto3and T gap is 200.
In the first phase of our algorithm, two scans of database are con-ducted. With the first scan, the frequency of every mutable set in the sequence database is collected. I f a symbol belongs to multiple mu-table sets, its occurrence counts for all of them. Infrequent mutable sets, which will not participate in a frequent permutation pattern, can be pruned after the first scan.

Running Example: After the first scan of the example database, the support of each mutable set is collected as in Table 1.
Since { s 5 } only occurs in one sequences S 3 and the T sup { s 5 } can be pruned as an infrequent mutable set. Now mutable sets {s1}, {s2}, {s3, s7}, {s4} and {s6} are kept and may serve as mem-bers of frequent permutation patterns.
Next we define the terms of "reachable" and "reachable case" based on the given gap threshold T gap .

D EFINITION 6. In a sequence S =( s 1 , g 1 , s 2 , ... , g symbols s i and s j ( 1  X  i&lt;j  X  n ) are said to be reachable, if one of the following two cases happens:
Two mutable sets MS 1 and MS 2 are said to be reachable in a sequence if there exist s 1 ( s 1  X  MS 1 ), s 2 ( s 2  X  MS are reachable in this sequence.

A reachable case is thus a case in which two mutable sets are reachable through some mutable sets in certain sequence. The reach-able case, the two end mutable sets, their intermediate set and the sequence id in which it occurs will be recorded.

The second scan of the sequence database records all reachable cases in all sequences. The pseudo-code of scanning database for reachable cases is given in Algorithm 1: Algorithm 1 Scan for reachable cases 1: globalcases  X  empty 2: for S  X  seqs do 3: tempcases  X  empty 4: last _ symbol  X  null 5: for symbol  X  S do 8: tempcases  X  empty 9: else 10: for case  X  tempcases do 13: create a new _ case by extending case 14: add new _ case to globalcases 15: add new _ case to tempcases 16: end if 17: end for 19: add new _ case to tempcases 20: add new _ case to globalcases 21: end if 22: last _ symbol  X  symbol 23: end for 24: end for 25: Return globalcases
Running Example : Let us use sequence S 1 in the example database as an example, S 1 =( s2 , 100 , s1 , 500 , s4 , 100 , s6 , If T gap is 200, then s 4 and s 6 are reachable directly, since the dis-tance between them is 100 . Due to the same reason s 6 and s reachable as well. Meanwhile this makes s 4 and s 7 satisfy the sec-ond case of Definition 6; thus s 4 and s 7 are reachable through s addition, s 4 and s 7 also directly reachable since their distance is 200, satisfying the first case of Definition 6. However, s 1 and s reachable because their distance is larger than T gap . Figure 3 shows all reachable cases in this sequence.
For each pair of mutable sets, we only record any intermediate set once and its associated sequence ids where the reachable case occurs. This saves the memory space to store the duplicate intermediate sets. For instance, { s 1 } and { s 2 } are reachable directly in all three se-quences. The empty set {} is recorded as an intermediate set of pair { s 1 } and { s 2 } ,and { S 1 ,S 2 ,S 3 } is recorded as the sequence ids in which it occurs. Meanwhile, in sequence S 2 , symbols { s 2 } are also reachable through { s 4 } . Thus { s 4 } is recorded as an intermediate set and { S 2 } is the sequence id. All reachable cases recorded are illustrated in Table 2 in a tabular form. Note that in-frequent mutable sets pruned in the first scan will not appear in any reachable case, thus reducing the number of reachable cases.
At this phase, we prune the set of reachable cases. First we give the definition of "instance sequence", then the observations stated earlier can be expressed using the definition of "reachable" and "instance sequence".

D EFINITION 7. If a sequence supports a frequent permutation pattern, we call this sequence an instance sequence of the permuta-tion pattern.

In an instance sequence of a frequent permutation pattern, any two mutable sets of the pattern are reachable either directly or through the mutable sets of this frequent permutation pattern.

Based on this observation, a reachability property for frequent per-mutation patterns can be identified as follows:
P ROPERTY 1. Any pair of mutable sets from a frequent permuta-tion pattern, say PP , have to be reachable in at least T of sequences. And in every instance sequence of PP , any pair of mutable sets from PP are reachable using only other mutable sets from PP as the intermediate set.

P ROOF . The proof comes directly from the definitions of reach-able and permutation patterns. Assume two mutable sets MS MS j are in a frequent permutation pattern, say PP . According to the definition of frequent permutation patterns, PP occurs in at least T sup sequences. A permutation pattern X  X  occurrence in a sequence implies that in this sequence, MS i and MS j are reachable either di-rectly or through some mutable sets from PP . Therefore, in these T sup sequences, MS i and MS j are reachable through mutable sets in PP only.
Armed with the reachability property, we can prune the set of can-didate patterns as follows. First we can identify some mutable set pairs that are reachable in less than T sup sequences using any muta-ble set as intermediate sets, then these mutable set pairs cannot be in a frequent permutation pattern. This pruning is based on the first por-tion of the reachability property. Moreover, we can use these pruned pairs to further prune the remaining possible pairs. The following lemma is derived to support this pruning step.

L EMMA 1. If in one sequence, two mutable sets from a frequent permutation pattern, e.g. PP , are only reachable through certain mutable set which does not belong to PP , then this sequence cannot be an instance sequence of the permutation pattern PP .

P ROOF . We prove it by contradiction. In one sequence, two mu-table sets MS 1 and MS 2 in PP are only reachable through MS and MS 3 does not belong to PP . Assume that this sequence is an instance sequence of PP . According to the reachability property, in an instance sequence of a frequent permutation pattern, any two mutable sets of the frequent permutation pattern should be reachable using only other mutable sets in PP as intermediate sets. However, MS 1 and MS 2 in PP are only reachable through MS 3 . Thus MS is a mutable set in PP . Contradiction found.

The above lemma, which is easy to derive from the reachability property, can be used to prune the number of instance sequences for a candidate pattern. The intuition behind this pruning is: In order to confirm two mutable sets MS 1 , MS 2 are in an frequent permutation pattern PP , we need to identify at least T sup instance sequences of PP . If we know another mutable set MS 3 cannot be in a frequent permutation pattern with MS 1 , and in some sequence MS 1 reachable to MS 2 through MS 3 , then this sequence cannot be an instance sequence of PP according to the above lemma.

After pruning the reachable cases, two mutable sets may become reachable in fewer sequences. This may help us to further identify pairs of mutable sets that have no chance at forming a frequent per-mutation pattern. After identifying these pairs, we conduct the prun-ing of the reachable cases again since more pairs are known to be unable to form a frequent permutation pattern. This two-way prun-ing is iteratively conducted until no mutable set pairs can be pruned or no reachable cases can be pruned, as illustrated in the algorithm flowchart (Figure 2). {s3, s7} {s6}: S1 {}: S1, S3
Running Example: First we prune mutable set pairs that are not reachable in enough sequences. According to Table 2, {s1} and {s6} are not reachable in any sequence, thus they cannot be in a frequent permutation pattern. For the same reason, the pairs ({s1}, {s3, s7}), ({s2}, {s3, s7}) and ({s2}, {s6}) cannot be in any frequent permu-tation pattern. In addition, {s1} and {s4} are only reachable in two sequences, which is less than T sup . Therefore, {s1} and {s4} cannot form a frequent permutation pattern either. The pairs ({s2}, {s4}), ({s3, s7}, {s4}) and ({s4}, {s6}) are also pruned through the same reasoning.

Next we use the mutable set pairs pruned in last round to prune reachable cases. First we look at the upper-left cell, which records the reachable cases between {s1} and {s2}. We already know that {s1} and {s4} cannot be in a frequent permutation pattern, thus the second row of this cell, which indicates {s1} and {s2} are reachable through {s4} in sequence S 2 , can be pruned. Then we examine the reachable cases between {s3, s7} and {s6}. Now they are reachable in three sequences, however, we know that {s4} and {s6} cannot be in a frequent permutation pattern, thus the reachable case in which {s3, s7} and {s6} are reachable through {s4} can be pruned. After this pruning, {s3, s7} and {s6} are only reachable in two sequences, which is below the support threshold. Therefore, all reachable cases for the pair {s3, s7} and {s6} can be pruned. Till now no reachable cases or mutable set pairs can be pruned.
In the last verification step, for each remaining reachable case, we sort the mutable set labels by their lexical order. By sorting mutable set labels, we can transform the different permutations of a pattern into a single unique representation. For example, the case that mu-table set MS 1 is reachable to MS 2 through MS 3 and the case that MS 3 is reachable to MS 2 through MS 1 are both transformed to the same list MS 1 MS 2 MS 3 . Now we count the number of sequences that each list occurs in by traversing all reachable cases. If a list of mutable sets occurs in T sup sequences, then these mutable sets form a frequent permutation pattern.

Running Example: After the pruning in the third step, the fol-lowing reachable cases are kept: case 1: {s2} and {s1} are reachable directly in S 1 case 2: {s1} and {s2} are reachable directly in S 2 case 2: {s2} and {s1} are reachable directly in S 3
After sorting all mutable set labels in each case, we only have one sorted list ({s1}, {s2}). We know that this list occurs in three se-quences by a traversal of all reachable cases. This means that {{s1}, {s2}} qualifies as a frequent permutation pattern.
To facilitate the pruning process, instead of using a linear list to store all reachable cases, we use a multiple-level hash table. The first level is the starting mutable set of a reachable case, the second level is the ending mutable set, and the third level records the intermediate sets for each reachable case. The hash table at the third level could be pointed by multiple second level pointers, since we only store each intermediate set once. An illustrative hash map is shown in Figure 4, which records two reachable cases of MS 1 and MS 3 , one is through MS 4 and MS 5 and the other is through MS 2 , MS 4 and MS
By this data structure, after pruning a pair of mutable sets that can-not participate in the same frequent pattern, rather than scanning all reachable cases again, we can quickly index the reachable cases that contain either one of the pruned mutable set pair. Only these reach-able cases might be pruned due to the r emoval of the pair. Therefore, after pruning any pair, only a smal l portion of the reachable case set is examined, and the support of each pair is updated simultaneously, which makes the pruning step rather efficient.
In this subsection, we analyze the correctness and complexity of our algorithm. Due to space limitations, we omit the formal cor-rectness and complexity proof of our algorithm. Interested readers should refer to [13] for the form al proof. We will outline the proof as following. First, we prove that our proposed algorithm will not miss any frequent permutation pattern. Note that there are actually two types of pruning conducted iteratively during the pruning process. One is to prune the mutable set pairs that cannot be in a frequent pat-tern segment, the other one is to prune the sequences that cannot be an instance sequence of a frequent pattern segment. We then prove that the two types of pruning will not prune any frequent permutation pattern.

For the first pruning, we prune mutable set pairs that are not reach-able in at least T sup sequences. According to the reachability prop-erty, in all instance sequences of a frequent permutation pattern, any pair of mutable sets in this pattern segment is reachable. Therefore, the mutable set pairs we pruned cannot be in any frequent permuta-tion pattern, which indicates that this pruning preserves all mutable ing, to decide whether a mutable set pair is in a frequent permutation pattern, we prune reachable cases in which this mutable set pair is only reachable through some mutable set that is known not to be in a frequent pattern segment with either one of the mutable set pairs. According to Lemma 1, any such reachable case cannot be an occur-rence of a frequent permutation pattern containing the mutable set pair. Thus we do not prune any instance sequence of any frequent permutation pattern containing this mutable set pair. If this muta-ble set pair is in a frequent permutation pattern, we still can identify all instance sequences after this pruning. Thus we will not miss any frequent permutation patterns.

In the worst case, the pruning may not reduce the number of can-didate patterns significantly. Thus, in theory, the worst case time complexity still could be exponen tial with respect to the length of a sequence. However, in many real data sets, the pruning process reduces a large number of candidate patterns. For the real data sets used in the next section, our algorithm prunes more than 99 candidate patterns.
In this paper we implemented the Permu-pattern algorithm in C++ using STL(Standard Template Libraries). All experiments were run on a Linux PC with a 3.2 GHz Pentium-4 processor and 1GB main memory. We use both real and synthetical data to analyze the perfor-mance of the Permu-pattern algorithm.

First, to illustrate the usefulness of the permutation pattern model, we use the Permu-pattern algorithm to discover gene clusters from genomes of different species. A gene cluster is a frequent permuta-tion pattern whose members are genes in genomes. The discovered gene clusters are interpreted by biologists to show that the permuta-tion pattern model can reveal important biological themes hidden in genomes, thus the Permu-pattern model is of great use in compara-tive genome analysis.

Second, we use different synthetic datasets to evaluate the perfor-mance of our Permu-pattern algorithm. Two other approaches are compared with our Permu-pattern algorithm. The first approach is the  X  pattern discovery algorithm [2].The other method is adapted from the set enumeration tree search [20]. First the sequence database is scanned for dense segments, which are sequence segments in which the first and last symbol are reachable. Then we enumerate all can-didate patterns formed by symbols in these segments. A set enumer-ation tree can be built and searched for frequent permutation pattern. The size of the set enumeration tree is bounded since the maximal number of symbols in a candidate pattern can not exceed the maxi-mal size of a dense segment.
In this section, we present the experimental results on the genome dataset to demonstrate the usefulness of the permutation pattern model. 120 genome sequences of 97 species are downloaded from the NCBI (National Center for Biotechnology Information) website. Each genome contains thousa nds of genes along with their positions at the genome. Genes are classified into Cluster of Orthologous Groups (COG), which are delineated by comparing protein sequences from completely se-quenced genomes. Genes within a COG are considered as mutable, thus the COGs form the mutable sets. Genes that are not in any COG are considered non-mutable. The average number of genes in these 120 genomes is 6533, and there are 4638 cluster of orthologous groups containing more than one gene.

In this experiment, the gap threshold T gap is set to 300 [16]. When the support threshold T sup is set to 20, 209 maximal frequent gene clusters can be discovered in less than 50 seconds. Table 3 is a sum-mary of experimental results on different support thresholds.
To show the usefulness of the permutation pattern model, we ana-lyze the results by interpreting the biological meanings of discovered patterns(gene clusters). Roughly speaking the discovered gene clus-ters represent several biological themes:
On the other hand, we compare the results of our model against the traditional sequential pattern model. Since the order of genes is permuted during evolution in genomes of different organisms, our permutation pattern model is able to identify more and longer pat-terns. Table 4 shows that the average and maximal lengths of dis-covered permutation patterns are larger than those of the traditional sequential patterns.

In addition, when the support threshold is set to 20, the sequen-tial pattern model missed 184 patterns (88%) found by the permu-tation pattern model, 178 out of which are linked to various biolog-ical themes. In addition, 91% of the discovered sequential patterns are also found by the permutation pattern model, but with greater lengths. A large portion of patterns missed by the traditional sequen-tial pattern model actually have important biological meanings. For example,
To further analyze the efficiency of our permutation pattern dis-covery algorithm, two alternative methods are compared to our Permu-pattern algorithm. The efficiency of the set enumeration tree method is highly dependent on the length of the dense segments in the se-quences. If the dense segments are long and contain many different symbols, the set enumeration tree could be very large. This could render the search for frequent sets very inefficient.

First we compare the performance of the Permu-pattern algorithm on the real genome data set against the two other methods. Table 5 shows the execution time for three algorithms to mine frequent permutation patterns from 120 genomes under different settings of the support threshold. The Permu-pattern are faster than the other two algorithms in every scenario.

Next we utilize a large set of synthetic data to further analyze the scalability of our algorithm. A sequence generator is written in Perl to generate sequences of various scales. First an arbitrary gap thresh-old T gap is defined, then the synthetic data is generated according to the following parameters: the average number of symbols in a sequence L , and the number of sequences S , and the number of mu-table sets M .

A series of experiments were conducted on synthetic data to com-pare the performance (efficiency) of the Permu-pattern algorithm against the two other alternative methods. In these experiments, the default parameters are as below: the average number of symbols in a se-quence L is 5,000, the number of sequences S is 1,000, and the num-berofmutablesets M is 3,000. We also set the support threshold to 20% of the total number of sequences. The experimental results show that the Permu-pattern algorithms outperforms other approaches by awidemargin.
 Figure 5: Scalability on T sup , the support threshold
First we evaluate the performance with respect to the support thresh-old T sup . Figure 5 shows the average execution time of three al-gorithms with respect to T sup . Although the response time of the Permu-pattern algorithm and the Set-Enumeration algorithm both reduce linearly with the increase of T sup , the response time of the Permu-pattern algorithm drops at a faster pace than that of the Set-Enumeration approach for the following reason. With the increase of T sup , more mutable sets will be pruned during the first scan of sequence database, and fewer reachable cases will be recorded for further pruning. Thus the Permu-pattern algorithm is much more scalable than the Set-Enumeration algorithm as T sup decreases.
The second aspect that we investigate is the scalability with the average number of symbols in a sequence L . With the increase of L , more dense segments could be discovered for the Set-Enumeration algorithm, which makes both algorithms be inefficient. The empir-ical results from Figure 6 have shown that the time complexity of the Permu-pattern algorithm is linearly proportional to L , while the execution time of the two other algorithms increase at much faster rates.

Third, we study the effects of the number of sequences S on the mining results. As seen in Figure 7, S has similar effects on three algorithms as the average length of sequences L . The Permu-pattern clearly benefits from the pruning power of the reachability property. Figure 7: Scalability on S , the number of sequences
Last, we examine the response time with varying numbers of mu-table sets M . The increase of the number of mutable sets has a sim-ilar effect on all three algorithms since a similar approach is used to handle the mutable noise in these algorithms. However, in every case the Permu-pattern algorithm outperforms the two other.
In this section, we discuss the settings of the Permu-pattern model in different contexts and some possible improvements to the model. First, there is some difference in the setting with respect to the gap between sequence symbols. In biological sequences, the gap be-tween two genes can be computed by counting the number of base pairs from the end of first gene and the start of second gene. By ig-noring the length of genes, we can transform genome sequences into the format defined in Section 3. In text mining, the gap between two words can be defined as the number of words between them. A situ-ation in which gaps between two successive words are below the gap threshold can be avoided through the following methods: 1. remov-ing stopwords from the documents when transforming a document into a sequence, while still counting the stopwords as gaps; and 2. treating certain types of punctuation as large gaps. For example, a period can be treated as a gap larger than the gap threshold.
The settings of two parameters: T gap and T sup can be decided by the application domain. For example, in genome analysis, the gap threshold can be set to 300 base pairs, which is indicated by [16] to define the term "close" between genes. In text mining, the gap distance can be set to the average length of a sentence. The support threshold T sup is usually set by a domain expert to define what is considered significant in a specific domain. For instance, in genome analysis, T sup is often set to 20% of the total number of genomes.
The discovered permutation patterns can be ranked based on their significance or the degree of their mutation and permutation. When the mutable sets are built from the symbol similarity matrix, the cen-ters of each mutable set can be selected. The centers of mutable sets can be considered as non-permuted(true) symbols. Numerical scores computed from the distance between other symbols and the non-permutated symbols can serve as a permutation measure when computing the support of a mutable set. For example, in mutable sets { s 1 ,s 2 ,s 3 }, if s 1 is the non-permutated symbol, then we can compute the distance between s1 and all other symbols in the muta-ble sets, represented for instance as { 1 , 0 . 8 , 0 . 7 sequence, the permutation score 0 . 8 can be used to compute a per-mutation support of the mutable set. The discovered patterns can be ranked according the mutation and permutation in those patterns.
In many applications, such as bioinformatics and text mining, se-quence databases often contain different types of noise. The exis-tence of the symbol mutation noise and the permutation noise makes the traditional sequential pattern model inadequate to capture useful patterns in these data. In this paper, we are interested in finding a new type of patterns, called mutable permutation patterns, in such noisy environments. The mutable permutation pattern model is pro-posed to capture the characteristics in sequential data. A reachability property is identified for the permutation pattern, based on which, a novel Permu-pattern algorithm is devised to efficiently mine the per-mutation patterns. We applied our model on the genome dataset of 97 species to discover gene clusters. The results show that the dis-covered gene clusters represent various important biological themes, which proves the practical importance of the permutation pattern model. Lastly, a large set of synthetic data is used to demonstrate that our Permu-pattern algorithm outperforms other alternative ap-proaches by a wide margin. This work was partially supported by the grants from NSF-0551603, NSF-0820217, and the Case Presidential Research Initiative Award.
