 1. Introduction in the literature have considered group queries in location-based social networks. [2,3] aim at low.
 features of those locations, e.g., spatial object  X  starbucks spatial object  X  starbucks  X  , the user may be interested in re fl promoted. Another example is for interest-based group gathering. Query keyword budget.
 group G 2 ,group G 1 is more preferable, since the interest of G havethesamelayoutingeo-space.Consideringgroup G 1 with group G tances in G 3 is smaller than that of G 1 ,although G 1 and G themostpreferableamongthesethreegroups.

To process SIG queries, a naive method is to enumerate all possible groups of size k ,andthen algorithm.

Our contributions made in this paper can be summarized as follows: the SIG query problem is NP-complete.
The rest of the paper is organized as follows. Section 2 presents the problem de lines possible future work. 2. Problem de fi nition Let D be a set of spatial objects. Each spatial object p is associated with a set of tags p . triple ( id ,  X  , v ), where id is user's identi fi er,  X  thespatial objects checked in by theuser. The interest value for a set of tags is de value interchangeably.

De fi nition 1. Let D u be the set of spatial objects checked in by user u and let D puted as 1 :
Givena set of tags T , if user's interestvaluefor every tag t of a user u for a tag set T is de fi ned as:  X  hotel  X  than  X  sport  X  , user's interest value for tags  X  ameter. 2 It ranks a user group G k of size k with regard to a query q ,denotedby rank
Here q . T is a set of query keywords that belong to the tag space of the dataset, I ( G q . T , which is de fi ned as the minimum interest of the users in the group if G where  X  u i .  X  u j .  X   X  is the Euclidean distance between two users. Parameter group diameter.

De fi maximized.

Example 1. Fig. 2 illustrates an example SIG query with three different values of 4 that maximizes the ranking function. The gray circles are the result group when interest is considered.
 Theorem 1. The SIG query problem is NP -complete .
 (MSC). An instance of the MSC problem consists of a universe set U ={ e is a subset of U and an integer k . The decision problem of MSC is to union of S  X  fully covers U .
GivenaninstanceofMSC,weconstructaninstanceofSIGquery q =( T , k )onasetofusers.Eachelement e keyword t i in q . T ,eachset S i is a user u i , and the elements in S imizing I ( G k , q . T ).

SupposethatwehaveaPTIMEalgorithm A that returns the query answer G
Case 1: If q . T is fully covered by the interests of G k found. Case 2: If G k does not fully cover q . T , then there does not exist another group G erwise, G k  X  wouldbereturnedasananswerasinCase1.Therefore,withsucha G
A that can solve the SIG query problem. 3. Proposed approaches 3.1. Preliminary: IR-tree and its corresponding IR-tree. IR-tree is essentially an R-tree attached with inverted tain a number of entries of the form ( u , u .  X  ), where u refers to a user and u . user's location. Each leaf node also includes a pointer to an inverted in the node.
 fi nodes.

We remark that the user locations (e.g., when they are referred to home/of dated. When the user location changes, the IR-tree should be updated accordingly to support ef tunately, this can be well handled by the embedded updating mechanism of IR-tree, whose ef demonstrated in [7] . 3.2. Overview Theorem 2 .
 of size k containing user u i is
Proof. According to Eq. (4) ,wehave I ( G k ( u i ), q . T ) 3.3. Interest oriented algorithm
Interest Oriented Algorithm (IOAIR) classi fi es groups in terms of users' interests. Let set G groups of size k .Letset G k ( u i ) cover all the groups of size k that contain user u u , i.e.,  X  G  X  G k u i  X  X  IG ; q : T  X  X  X  Iu i ; q : T  X  X   X  X  .Obviously, user interest and iteratively constructs the group G k ( u rank q ( G k ( u i )) N rank q ( G k ( u m )), where k  X  i ( G k ( u i )) N rank q u ( G k ( u j ))  X  rank q u ( G k ( u Theorem 3. Algorithm IOAIR fi nds the correct answer to a SIG query . suppose there exists G  X  with the maximum ranking score such that rank minimum interest in G and u i  X  be the user with the minimum interest in G q . T ), algorithm IOAIR fi rst considers G k u 0 i ,andthen G rank q ( G ). Thus, algorithm IOAIR must return the group G we have G k u 0 i  X G k u i  X  X  . Algorithm IOAIR must return the group G q . T ), algorithm IOAIR fi rst considers G k ( u i ), and then G rank q ( G  X  ), which contradicts the assumption that rank proved.

Algorithm 1 shows the pseudo code of the IOAIR algorithm. The candidate group G function IOAIRGetnextGroup constructs a group of size k containing u diameter), denoted as G k ( u i ), where I ( G k ( u i ), q . T )= I ( u candidate group if its ranking score is higher than that of the candidate group G of the candidate group is higher than the upper bound on the ranking score of G and terminates (lines 8 and 9).

Algorithm 1. IOAIR(Integer k , Keywords T , InvertedFile invf , IRTree irtree ).
In order to fi nd group G k ( u i )suchthat I ( G k ( u i user u i , since no user in the subtree can have a larger interest than does user u termined, constructing G k ( u i ) with the maximum ranking score is equivalent to checked if it fully covers T .

Algorithm 2. IOAIRGetnextGroup(IRTree irtree ,User u i ,Integer k , Double D 3.3.1. Early stop
Let G k  X  contain all the users with higher interests than u from G k  X  . Function IOAIRGetNextGroupconsiders theusers withhigher interests than u users have been obtained, a candidate group of size k including u Example 2 ).

Theorem 4. Let S ={ u 1 , u 2 ,  X  , u m , u m +1 ,  X  , u n tances to user u i . Let G k ( u i ) be the user group of size k containing u  X  u u m +1  X   X  D ( G k ( u i )), G k ( u i ) is the user group of size k containing u
Proof. Supposewecan fi nd a group G k  X  ( u i )ofsize k containing u rank q ( G k  X  ( u i )) N rank q ( G k ( u i )). Then we have
I ( G ( u i ), q . T )andderive D ( G k  X  ( u i )) b D ( G k ( u
D ( G k ( u i )), we have D ( G k  X  ( u i ))  X   X  u i u m + j  X   X  the proof.

Example 2. We illustrate Theorem 4 in Fig. 4 .Let S ={ u 1 ascending order of their distances to user u i .Let G 4 ( u ranking score calculated from S  X  ={ u 1 , u 2 , u 3 }. The diameter is D ( G
Hence, we obtain a new group G 4 ( u i )={ u i , u 2 , u 3
D ( G 4 ( u i )) =  X  u i u 4  X  . We then consider u 5 and have D ( G user group of size 4 containing u i with the maximum ranking score calculated from S . 3.3.2. Diameter constraint group G k ( u i ) with the maximum ranking score.
Lemma 2. rank q ( G k ( u i )) N rank q ( G k ( u j ))  X  D ( G The proof can be easily derived based on Eq. (3) and thus omitted.
Theorem 5. If rank q ( G k ( u i )) N rank q ( G k ( u j )) and
Proof. We prove it by contradiction. Suppose u m  X  G k ( u
It contradicts the condition rank q ( G k ( u i )) N rank candidate group is returned (line 8 in Algorithm 2 ). The value of D found (line 7 in Algorithm 1 ).

In order to facilitate our example description, we set q . T = Fig. 3(b).

I ( u neighbor users. With the diameter constraint D c , we do not need to consider tree nodes { R query processing. 3.4. Diameter oriented algorithm
Diameter Oriented Algorithm (DOAIR) classi fi es groups in terms of group diameters. Let set G groups of size k . Let set G k u i ;  X  X  covers all the groups of size k ,takinguser u  X  and constructs the group G k ( u i ,  X  ) with the maximum ranking score in G
G ( u i ,  X  ) is higher than the upper bound on the ranking score of the next group G rectness of algorithm DOAIR is guaranteed by Theorem 6 .
 rank u ( G k ( u j ,  X  )) = rank q u ( G k ( u j )) (Eq. (6) ), we have rank rank q ( G k ( u i ,  X  )) N rank q u ( G k ( u j ,  X  ))  X  rank Theorem 6. Algorithm DOAIR fi nds the correct answer to a SIG query . suppose there exists G  X  with the maximum ranking score such that rank the groups with maximum ranking score in G k u i ;  X  X  and G q . T ) b I ( u i  X  , q . T ), algorithm DOAIR fi rst considers G rank q u ( G )  X  rank q ( G ). Thus, algorithm DOAIR must return the group G
I ( u  X  , q . T ), we have G k u 0 i ;  X G k u i ;  X  X  . Algorithm DOAIR must return the group G q . T ) N I ( u i  X  , q . T ), algorithm DOAIR fi rst considers G rank q u ( G  X  )  X  rank q ( G  X  ), which contradicts the assumption that rank DOAIR is proved.

Algorithm 3 shows the pseudo code of the DOAIR algorithm. The candidate group G
G
DOAIR is able to skip the construction of group G k ( u i than D c and the candidate group interest is also higher than u fi guarantees the correctness of this pruning step.

Algorithm 3. DOAIR(Integer k , Keywords T , InvertedFile invf , IRTree irtree ).
Theorem 7. Let G k be the candidate group and D u i be the distance between u rank q ( G k ( u i ,  X  )) where
Proof. We derive rank q ( G k ) N rank q ( G k ( u i ,  X  )) as follows:
In order to fi nd group G k ( u i ,  X  ) with the maximum ranking score in G
IR-tree to retrieve the users in ascending order of their distances to u
G of size k with diameter u i e (lines 9 and 10). To avoid enumerating all possible diameter u also applied here (line 18). 3.4.1. Early stop
Function DOAIRGetNextGroup considers the users in ascending order of their distances to u with diameter u i e . If the interest of G k equals the interest of u Algorithm 4. DOAIRGetNextGroup(IRTree irtree , User u i , Integer k ,Double Dc , Keywords T ).
Theorem 8. Let S ={ u 1 , u 2 ,  X  , u m , u m +1 ,  X  , u n be the user group with diameter u i u m and rank q ( G k ( u rank q ( G k ( u i , u m )) N rank q ( G k ( u i , u j )) where 1
Proof. Suppose we can fi nd a group G k ( u i , u j ) with diameter u
Since D ( G k ( u i , u m )) =  X  u i u m  X  b  X  u i u j  X  = D ( G rank q ( G k ( u i , u j )) that contradicts the assumption and thus complete the proof. 3.4.2. Interest constraint I c
In function IOAIRGetNextGroup, when retrieving user group G sides D c , function DOAIRGetNextGroup contains an interest constraint I
G ( u i ,  X  ) with the maximum ranking score is more ef fi cient. Speci the group with diameter u i e is lower than the current found candidate group.
Lemma 4. Suppose u m and u n are the m th and n th nearest neighbors of u
I ( G ( u i , u n ), q . T ) N I c , where The proof is trivial and thus omitted (easily derived based on Eq. (3) ).
Theorem 9. Let u m and u n be the m th and n th nearest neighbors of u ranking score . If I ( u n , q . T ) b I c , we have rank
Proof. We prove it by contradiction. Assume rank q ( G k ( u contradicts Lemma 4 . 3.4.3. Interest constraint I G Let G k ( u i , u m ) be the current found candidate group and I  X  u u n  X  , the users whose interest is lower than I G can be pruned. In other words, if group G rank q ( G k ( u i , u m )) b rank q ( G k ( u i , u n )), the users whose interest is lower than I
Theorem 10. Let u m and u n be the m th and n th nearest neighbors of u q . T )  X  I G )  X  u j  X  G k ( u i , u n ).

Proof. Assume  X  u j ( I ( u j , q . T )  X  I G , u j  X  G k I = I ( G k ( u i , u m ), q . T ), we have rank q ( G k ( u imize the search space of G k ( u i , e ) (line 1, illustrated by Example 4 ).Ifthesizeof C u returns NULL (lines 2  X  3), because it is impossible to formulate a group G segment u i e to partition the search space C u i e  X  X  into two sets G less than that of u i and e are put into G LU and G RU , respectively (lines 6 select k -2 users from G LU and G RU such that their union with { u 8  X  ing to I min { u i , e } (here, I min { u i , e } denotes the minimum interest of u less than I min { u i , e }, and G down represents the user set whose interest is less than I with the users in G down in a decreasing order of group interest (lines 13 interest, because a higher interest means a higher ranking score for group G there exists k -2 users such that the distance between any pair of users is no more than (by enumerating all possible groups of size k -2), G k  X  { u highest interest in G down will be moved into G up (lines 18
Lemma 5. Let C u i ; u i u j and C u j ; u i u j be two circles centered at u
C u ; u i u j is denoted by C u i u j . We have  X  u  X  G k u i The proof is obvious and thus omitted.

Example 4. Fig. 6 shows the two circles C u 1 ; u 1 u 11  X  X  and C u u u  X  X  covers 3 users (e.g., u 3 , u 4 and u 9 ). Group G k ( u search space of G k ( u 1 , u 11 )is C u 1 u 11  X  X  .

Lemma 6. If the number of users on one side s of diameter u
Proof. Since k -2 users are selected from s , the distance between all pair users in G
D ( G k ( u i , u j )) =  X  u i u j  X  and I ( G k ( u i , u j ), q . T )= min { I ( u
Example 5. Consider the 13 users of IR-tree in Fig. 6 .Basedon Lemma 5, the search space of G contains 2 users { u 3 , u 4 } whose interest is no less than 0.4 (the minimum interest of u to u 3 and u 4 are in one side of the diameter u 1 u 11 and 2  X  imum ranking score.
Algorithm 5. GetCurrentResult(Group G k  X  , User u i , User e , Keywords T ). 4. Performance evaluation results are presented in Section 4.3 . 4.1. Datasets and queries
We collectdata from two popular location-based social networksin China, i.e., Jiepang
Dianping contains 500 queries. Each query contains several keywords and the speci {20, 40, 60, 80, 100}. 4.2. Setup and the number of query tags are 50, 0.5, and 1, respectively. 4.3. Experimental results
We evaluate the performance of the three algorithms when varying the value of parameter k , 4.3.1. Varying group size k putation time for DOAIR. 4.3.2. Varying  X 
Parameter  X  is used to balance the group interest and the group diameter. Users can adjust searching the maximum interest group with a smaller group diameter. When priority to deal with the group with a high group interest. Thus, with a large minate the query processing early. Second, as discussed above, the performance ef when  X  = 0.9 and k =10. 4.3.3. Varying the number of query tags than IOAIR due to its stronger pruning power and reduced distance computation cost. 4.3.4. Varying buffer size pruned. 4.3.5. Varying the number of users 5. Related work 5.1. Spatial query processing closest-pair queries [19  X  21] .
 presented a novel approach using fi rst-order voronoi diagrams to ef fi ef fi
They presented a novel concept of  X  probabilistically constrained rectangle
Pagel et al. [17] proposed a probabilistic model for user-de plane-sweep techniques for k -distance join queries and incremental distance join queries. of users whose locations are close enough and who have high interest in the query keywords. 5.2. Spatial keyword query processing scheme called IR-tree, which integrates the R-tree and inverted the shortest path. An ef fi cient method based on a new hybrid index, cell-keyword conscious B [24] to process top-k queries on trajectories database. Wu et al. [25] studied the ef time with the minimum communication cost. Fellpe et al. [26] considered how to textual-based and grid-based fi ltering algorithms to ef fi and high textual similarity. Lu et al. [29] proposed a hybrid index tree called IUR-tree to ef
Zhang et al. [30] studied an m -closest-keyword ( m CK) query that 5.3. Group and team query processing
Group and team queries have been studied in the context of social networks [32 on the common interest of group members rather than their social relationships. 6. Conclusion and future work orders of magnitude.
 fi Acknowledgment and UIC research grant R201408.

References
 Location-based social networks, such as Foursquare and Face-book Places, are bridging the gap between the physical world and online social networking services through acquired user locations. Some social networks released check-in services that allow users to share their visiting locations with their friends. In this paper, users X  interests are modeled by check-in actions. We propose a new spatial-aware interest group (SIG) query that retrieves a user group of size k where every user is highly interested in the query keyword and also spa-tially close to each other. An efficient algorithm AIR based on the IR-tree is proposed for the processing of SIG queries. Furthermore, an optimization is developed and achieves a much better performance than the baseline algorithm. H.2.4 [ Database Management ]: Query Processing Algorithms, Performance Query Processing, Spatial Databases, Social Networks Location-based social networks, such as Foursquare and Facebook Places, are bridging the gap between the physical world and online social networking services through acquired user locations. Some social networks released check-in ser-vices that allow users to share their visiting locations with their friends. These locations considered as spatial objects are associated with some tags that describe their features, e.g., spatial object  X  X tarbucks X  with tags  X  X ood X ,  X  X everage X , the user may be interested in  X  X ood X ,  X  X everage X , or  X  X offee X . Such voluntary check-in actions reflecting the users X  interests can be used for marketing. As an example, a firm may want to find a location to promote its product, such that some users close to that location are interested in the product.
In this paper, users X  interests are modeled by check-in ac-tions. We propose a new kind of query that retrieves a user group of size k where every user is highly interested in the query keyword and also spatially close to each other. A sam-ple query may request a user group of size 3 such that the three users are fond of  X  X ovie X  and close to each other. We call this type of query a Spatial-aware Interest Group (SIG) query. It contains a query keyword and the size k of the re-quested user group. The answer to the query is a user group of size k that maximizes a ranking function combining the diameter (distance between the farthest pair of users) of the group and the group interest of the query keyword.
We propose an efficient algorithm AIR based on the IR-tree for the processing of SIG queries. An optimization is further developed to effectively prune the search space. Ex-periments based on a real dataset show that the proposed algorithms achieve up to 2 orders of magnitude improvement over the baseline algorithm.
Let D be a set of spatial objects. Each spatial object p is associated with a set of tags p.  X . Let U be a set of users. Each user u  X  X  is a triple ( id , X , X  ), where id is the user X  X  identification,  X  is the user X  X  home location, and  X  is a vector of the user X  X  interests of the tags that are associated with the spatial objects checked in by the user. The interest value of a tag is defined in Definition 1.

Definition 1. Let D u be the set of spatial objects checked in by user u and let D t be the set of spatial objects that are associated with tag t . Function Count ( u , p )countsthe number of check ins of a user u to the spatial object p . The interest value for tag t of user u is computed as: Table 1 shows an interest vector of a user. Higher value indicates more interest. As an example, the user is more interested in  X  X port X  than  X  X ovie X .
 Interest Value 0.10 0.20 0.36 0.14
We derive a ranking function as a weighted sum of nor-malized terms for ranking a user group G k of size k with respect to a query q , denoted by rank q ( G k ): where q.t is the query keyword that belongs to the tag s-pace of the dataset, I ( G k ,q.t )isthegroupinterestofthe query keyword q.t , defined as the minimum value of the us-er interest in the group, i.e., I ( G k ,q.t )=min { I ( u, q.t G } , D ( G k ) is the diameter of group G k , i.e., the Euclidean distance between the farthest pair of users in the group, D (
G k )=max {|| u i . X  u j . X  || | u i ,u j  X  G k } ,where || u is the Euclidean distance between two users. The maximum tag q.t , and the maximum group diameter D max , i.e., the dis-tance between the farthest pair of users in the whole dataset, are used for normalization. Parameter  X   X  [0 , 1] is used to balance the group interest and the group diameter.
A Spatial-aware Interest Group (SIG) query consists of two components: a keyword q.t and the size k of the re-quested user group. It retrieves a user group of size k ,such that the ranking function (Eq. (2)) is maximized.
Figure 1 illustrates an example SIG query with three d-ifferent values of  X  in the ranking function (Eq. (2)). The circles, squares, and triangles in the figure depict the loca-tions of a set of users. Given an SIG query q ,thesizesof those shapes indicate the user interests of the query keyword q.t . The bigger the size, the higher the user interest. Query q requests a user group of size 4 that maximizes the rank-ing function. The solid circles are the result group when  X  = 0, i.e., only the group diameter is considered. The solid squares are the result group when  X  =0 . 5. The solid tri-angles represent the query result when  X  = 1, i.e., only the group interest is considered.
 Problem Statement: We study the efficient processing of SIG queries. We aim for a solution that has short response time.
We next discuss how to exploit existing techniques for pro-cessing SIG queries. While no baseline algorithm exists for SIG queries, we propose an approach that uses an inverted file [6] to compute group interests and adopts an R-tree [3] to compute group diameters separately. Specifically, user-s X  interests of all tags are pre-computed and indexed by an inverted file, where the posting list of each tag is sorted in descending order of users X  interests. Users X  home locations areindexedbyanR-tree.

Given an SIG query, let set G k contain all possible user groups of size k . For each user group G k  X  X  k ,wederive an upper bound on the ranking score of G k ,asshownin Theorem 1.

Theorem 1. Let D min be the minimum group diameter among all possible groups, i.e., D min =min { D ( G k ) | G G } . An upper bound on the ranking score of a user group G The proof of Theorem 1 is obvious and thus omitted. The value of D min can be determined as follows. We first retrieve the closest pair of users u i and u j , and then check whether the scribing circle of u i and u j covers another k  X  2 users. If yes, the distance between u i and u j is returned as D Otherwise, the next closest pair of users is retrieved, and the process is repeated.

The basic idea of the baseline algorithm is that user group-s are processed in descending order of the upper bounds on their ranking scores. If the ranking score of the curren-t found user group is higher than the upper bound on the ranking score of the next user group, the current found user group is returned as the result, i.e., the ranking function is maximized. Since the group interest I ( G k ,q.t ) is the min-imum value of the user interests in G k , based on Eq. (3), the descending order of the upper bounds can be guaran-teed by processing user groups in descending order of the user interest. If two user groups have the same group inter-est, the user group with smaller group diameter is processed first. Algorithm 1 shows the pseudo code of the baseline algorithm. It starts from the user u i with the k th largest interest, and finds a group of size k that contains u i ,de-noted by G k ( u i ) (Line 4). The group G k ( u i ) returned by terest of u i is the smallest and (ii) the diameter of G k the minimum. The result is found when the ranking scores of unprocessed groups cannot exceed the ranking score of the current group (Line 7).
 Algorithm 1 Baseline (Int k ,Keyword t , InvertedFile invf , RTree rtree ) 1: pl  X  load the posting list of t from invf ; 2: Result G k  X  X  X  ; 3: for i from k to pl . length do ; 4: G k ( u i )  X  GetNextGroup ( rtree ,u i ,k ); 5: if rank q ( G k ( u i )) &gt; rank q ( G k ) then 6: G k  X  G k ( u i ); 7: if rank q ( G k ) &gt; rank u q ( G k ( u i + 1 )) then 8: Return G k ; 9: Return G k ;
We now present an advanced algorithm based on the IR-tree [2] (AIR) for the processing of SIG queries. To further improve the performance of AIR, we develop an optimiza-tion that involves a group diameter constraint. The group diameter constraint is effective for search space pruning.
We adopt the IR-tree [2] to index users, where users X  home locations are represented as the locations of objects and users X  interests are as the documents of objects. Based on the IR-tree, we propose an efficient version of function GetNextGroup (Algorithm 2), named AIRGetNextGroup (Al-gorithm 3). Function AIRGetNextGroup takes advantage of Algorithm 2 GetNextGroup (RTree rtree ,User u i ,Int k ) 1: Queue  X  NewPriorityQueue (); 2: Queue . Enqueue ( rtree . root , 0); 3: Add u i to G k ; 4: while Queue is not empty do 5: Entry e  X  Queue . Dequeue (); 6: if e refers to a user then 7: if the interest of e&gt; the interest of u i then 8: Add e to G k ; 9: if G k contains more than k users then 10: G k  X  select the group of size k with the 11: if D ( G k )  X || u i e || then 12: Return G k ; 13: else 14: for each entry e in the node pointed to by e do 15: Queue . Enqueue ( e , || u i e || ); 16: Return G k ; Algorithm 3 AIRGetNextGroup (RTree rtree ,User u i ,Int k 1: Queue  X  NewPriorityQueue (); 2: Queue . Enqueue ( rtree . root , 0); 3: Add u i to G k ; 4: while Queue is not empty do 5: Entry e  X  Queue . Dequeue (); 6: if e refers to a user then 7: if the interest of e&gt; the interest of u i then 8: Add e to G k ; 9: if G k contains more than k users then 10: G k  X  select the group of size k with the 11: if D ( G k )  X || u i e || then 12: Return G k ; 13: else 14: for each entry e in the node pointed to by e do 15: if the interest of e &gt; the interest of u i then 16: Queue . Enqueue ( e , || u i e || ); 17: Return G k ; the IR-tree that each entry in each node has an upper bound on the user interests contained in the subtree pointed to by the entry. If the interest of an entry e is smaller than the interest of a user u , no user in the subtree of the entry can have a larger interest than does the user u ,andthus the subtree can be pruned (Line 15). The AIR algorithm adopts Algorithm 1, but calling AIRGetNextGroup instead of GetNextGroup at Line 4.
In the baseline and the AIR algorithms, user groups are processed in descending order of their group interests. Let G ( u i ) be the current found user group. A condition of the next processed user group G k ( u i +1 ) being the query result can be presented in Theorem 2.

Theorem 2. rank q ( G k ( u i )) &lt; rank q ( G k ( u i + 1 D ( The proof is obvious and easily derived based on Eq. (2), and thus omitted. Theorem 2 tells that given two user group-s
G k ( u i )and G k ( u i +1 ) and the group interest of G is higher than that of G k ( u i +1 ), if the group diameter of G ( u i +1 )issmallerthan D c , the ranking score of G k ( u is higher than that of G k ( u i ). Thus, in the optimized al-gorithm, the group diameter constraint D c is used to prune the search space (see Algorithms 4 and 5). The value of D is updated when a user group with a higher ranking score is found (Line 8 in Algorithm 4). When processing the next user group (Algorithm 5), only the user group with diame-ter smaller than D c is considered (Line 16). Otherwise, it is impossible to have a ranking score higher than the current found user group (guaranteed by Theorem 2). Hence, some user groups are pruned and the computation cost is reduced. Algorithm 4 AIRStar (Int k ,Keyword t , InvertedFile invf , RTree rtree ) 1: pl  X  load the posting list of t from invf ; 2: Result G k  X  X  X  ; 3: D c  X  X  X  ; 4: for i from k to pl . length do ; 5: G k ( u i )  X  AIRStarGetNextGroup ( rtree ,u i ,k,D c ); 6: if rank q ( G k ( u i )) &gt; rank q ( G k ) then 7: G k  X  G k ( u i ); 8: Update D c according to Eq. (4); 9: if rank q ( G k ) &gt; rank u q ( G k ( u i + 1 )) then 10: Return G k ; 11: Return G k ; Algorithm 5 AIRStarGetNextGroup (RTree rtree ,User u i , Int k , Double D c ) 1: Queue  X  NewPriorityQueue (); 2: Queue . Enqueue ( rtree . root , 0); 3: Add u i to G k ; 4: while Queue is not empty do 5: Entry e  X  Queue . Dequeue (); 6: if e refers to a user then 7: if the interest of e&gt; the interest of u i then 8: Add e to G k ; 9: if G k contains more than k users then 10: G k  X  select the group of size k with the 11: if D ( G k )  X || u i e || then 12: Return G k ; 13: else 14: for each entry e in the node pointed to by e do 15: if the interest of e &gt; the interest of u i then 16: if || u i e || &lt;D c then 17: Queue . Enqueue ( e , || u i e || ); 18: Return G k ;
We evaluate the performance of the three algorithms for the processing of SIG queries, including the baseline, the AIR algorithm, and the AIR with optimization (AIR*).
We use a real dataset crawled from jiepang.com, which is a popular location-based social network in China. Table 2 lists the properties of the dataset.

For the sake of scalability test, we generate 6 datasets of size varied from 50,000 to 300,000 within the space of the real dataset. One query set containing 200 queries is randomly generated. We report the average elapsed time and the average I/O cost of the three algorithms.
The indexes, the R-tree, the inverted file, and the IR-tree used in this paper are disk resident. The page size is set to 4KB. The fanouts of the R-tree and the IR-tree are both 200. All the algorithms are implemented by Java programming language. The models of the CPU and RAM are AMD Athlon Dual Core Processor 2.8G Hz and 2GB DDR2 memory. The default values of k and  X  are 10 and 0.5, respectively. Varying k . Figures 2(a) and 2(b) show the average elapsed time and the average simulated I/O cost when varying the group size k . Both the elapsed time and the I/O cost in-crease as k grows. The AIR and AIR* algorithms outper-form the baseline approach for all values of k in terms of both metrics, since the IR-tree is able to prune the search space according to both the group interests and group di-ameters. Notably, the AIR* algorithm achieves 2 orders of magnitude improvement due to the effective use of the group diameter constraint. Varying  X  . Parameter  X  is used to balance the group in-terest and the group diameter. Only the group interest is considered when  X  = 1. The group diameter dominates the ranking function when  X  approaches 0. Figures 3(a) and 3(b) show the performance of the three algorithms with d-ifferent values of  X  . The AIR* algorithm again beats the other two algorithms by 2 orders of magnitude in terms of both metrics. Varying the Size of Dataset. In Figures 4(a) and 4(b), the average elapsed time and the average simulated I/O cost increase sub-linearly as the size of dataset grows. The AIR* algorithm significantly outperforms the baseline and AIR in all cases tested.
There is a stream of research on spatial query processing in the literature. Recently, spatial queries have been extended to incorporate text keywords [1, 2, 5]. Cong et al .[2]pre-sented a new indexing scheme, IR-tree, for location-aware keyword ( m CK) query that finds a set of spatially closest objects covering m specified keywords. Cao et al . [1] pro-posed a collective spatial keyword query that retrieves a group of nearby spatial objects to collectively cover the spec-ified keywords. Unlike these previous queries, the proposed SIG query explores the relationship between users X  locations and interests in the specified keywords.

Group queries have also been studied in the context of so-cial networks. In [4], Yang et al . proposed a social-temporal group query to find a group of activity attendees with the minimum total social distance to the query issuer. In con-trast, our group query is more concerned with the common interest of group members rather than their social relation-ships.
In this paper, we have identified a new SIG query arising in location-based social networks. We have proposed an ef-ficient algorithm based on the IR-tree, namely AIR, for the processing of SIG queries. An optimization has also been developed for AIR to further prune the search space. The experiments based on a real dataset have demonstrated that the optimized AIR* algorithm achieves 2 orders of magni-tude improvement over the baseline algorithm.
 Acknowledgements . This work is supported by RGC GR-F 211212, HKBU FRG2/11-12/074, and NSFC61073017. [1] X. Cao, G. Cong, C. S. Jensen, and B. C. Ooi. [2] G. Cong, C. S. Jensen, and D. Wu. Efficient retrieval of [3] A. Guttman. R-trees: A dynamic index structure for [4] D.-N. Yang, Y.-L. Chen, W.-C. Lee, and M.-S. Chen. [5] D. Zhang, Y. M. Chee, A. Mondal, A. K. H. Tung, and [6] J. Zobel and A. Moffat. Inverted files for text search
