 Inverted indexes are the most fundamental and widely used data structures in information retrieval. For each unique word occurring in a document collection, the inverted index stores a list of the documents in which this word occurs. Compression techniques are often applied to further reduce the space requirement of these lists. However, the index has a shortcoming, in that only predefined pattern queries can be supported efficiently. In terms of string documents where word boundaries are undefined, if we have to index all the substrings of a given document, then the storage quickly becomes quadratic in the data size. Also, if we want to apply the same type of indexes for querying phrases or sequence of words, then the inverted index will end up storing redundant information. In this paper, we show the first set of inverted indexes which work naturally for strings as well as phrase searching. The central idea is to exclude document d in the inverted list of a string P if every occurrence of P in d is subsumed by another string of which P is a prefix. With this we show that our space utilization is close to the optimal. Techniques from succinct data structures are deployed to achieve compression while allowing fast access in terms of frequency and document id based retrieval. Compression and speed tradeoffs are evaluated for different variants of the proposed index. For phrase searching, we show that our indexes compare favorably against a typical inverted index deploying position-wise intersections. We also show efficient top-k based retrieval under relevance metrics like frequency and tf-idf .
This work is supported in part by Taiwan NSC Grant 99-2221-E-007-123 (W. Hon) and US NSF Grant CCF X 1017623 (R. Shah and J. S. Vitter).
 H.3.1 [ Information Storage and Retrieval ]: Content Analysis and Indexing X  Indexing methods ; I.7.3 [ Document and Text Processing ]: Index Generation Algorithms, Experimentation
The most popular data structure in the field of Informa-tion Retrieval is the inverted index. For a given collection of documents, the index is defined as follows. Each word in this collection is called a term and corresponding to each term we maintain a list, called inverted list , of all the doc-uments in which this word appears. Along with each doc-ument in this list we may store some score which indicates how important the document is with respect to that word. Different variants of the inverted index sort the documents in the inverted lists in a different manner. For instance, the sorting order may be based on the document ids or the scores. Compression techniques are often applied to further reduce space requirement of these lists. However, inverted index has a drawback that it can support queries only on predefined words or terms. As a result, it cannot be used to index documents without well-defined word boundaries.
Different approaches have been proposed to support phrase searching using an inverted index. One strategy is to main-tain the position information in the inverted list. That is, for each document d in the inverted list of a word w , we store the positions at which w occurs in d . The positions corre-sponding to each d in the list can be sorted so as to achieve compression (using encoding functions like gap, gamma, or delta) [15]. To search a phrase, we first search for all the words in the phrase and obtain the corresponding inverted lists. The positions of each word within a document are ex-tracted, so that we can then apply an intersection algorithm to retrieve those documents where these words are appear-ing in the same order as in the phrase. Another (naive) approach is to store inverted lists for all possible phrases, however, the resulting index size will be very large thus pro-hibiting its use in practice [38]. Different heuristics are pro-posed in this respect, such as maintaining the inverted lists only for popular phrases, or maintaining inverted lists of all phrases up to some fixed number (say h ) of words. Another approach is called  X  X ext-word index X  [36, 3, 4, 37], such that corresponding to each term w , a list of all the terms which occurs immediately after w is maintained. This approach will double the space, but it can support searching of any phrase with two words efficiently. Nevertheless, when the phrase goes beyond two words, we have to fall back to the intersection algorithm.

In this paper, we first introduce a variant of inverted index which naturally works for string as well as phrase searching. Our index does not assume any restrictions on the length or the popularity of the phrases. In addition, by avoiding the use of the intersection algorithm we achieve provable bounds for the query answering time with respect to the output size. Furthermore, we show different heuristics and compression techniques to make our index space-efficient. For a collection of English documents, the size of our index for strings and for phrases are  X  5 times and  X  2 times, respectively, of that of the input data, while it can support document retrievals in 10-40 microseconds per document in ranked order.
Suffix trees and suffix arrays are efficient data structures which can be used to index a text and support searching for any arbitrary pattern. These data structures can be main-tained in linear space and can report all the occurrence of a pattern P in optimal (or nearly optimal) time. The space-efficient versions of suffix trees and suffix arrays are called compressed suffix trees and compressed suffix arrays, respec-tively, which take space close to the size of the indexed text. From a collection D of |D| documents { d 1 , d 2 , ..., d tal length n , the problem of reporting documents containing a query pattern P is called the  X  X ocument listing X  problem. This problem was first studied by Matias et al. [21], where they proposed a linear space index with O ( p log n + | output | ) query time; here, p denotes the length of the input pattern P and | output | denotes the number of the qualified docu-ments in the output. An index with optimal O ( p + | output | ) query time was later achieved in [24]. Sadakane [31] showed how to solve the document listing problem using succinct data structures, which take space very close to that of the compressed text. He also showed how to compute the tf-idf [2] of each document with the proposed data structures. Similar work was also done by V  X  alim  X  aki and M  X  akinen [33] where they derived alternative succinct data structures for the problem.

In many practical situations, we may be interested in only a few documents which are highly relevant to the query. Relevance ranking refers to the ranking of the documents in some order, so that the result returned first is what the user is most interested. This can be the document where the given query pattern occurs most number of times (fre-quency). The relevance can also be defined by a similarity metric, such as the proximity of the query pattern to a cer-tain word or to another pattern. This problem is modeled as top-k document retrieval, where the task is to retrieve the k highest scoring documents based on some score func-tion. An O ( n log n ) words index has been proposed in [16] with O ( p + log |D| log log |D| + k ) query time. Hon et al. [18] proposed a linear-space index ( O ( n ) words) with nearly op-timal O ( p + k log k ) query time. Yet, the constants hidden in the space bound restricts its use in practice. Culpepper et al. [8] proposed a space-efficient practical index based on wavelet trees [13], but their query algorithm is based on a heuristic, so that it does not guarantee any worst-case query performance.

The most popular ranking function in web search applica-tions is tf-idf [2]. Under the tf-idf model, Persin et al. [28] give different heuristics to support top-k ranked retrieval when the inverted lists are sorted in decreasing order of the tf score. Various generalizations of this are studied by Anh and Moffat [1] under the name  X  X mpact ordering X . In [25], Navarro and Puglisi showed that wavelet trees can be used for maintaining dual-sorted inverted lists corresponding to a word, where the documents can efficiently be retrieved in score order or in document id order. Recently, Hon et al. [17] proposed an index for answering top-k multi-pattern queries. On a related note, top-k color query problems (with applications in document retrieval) have been studied in [12, 20].
Given a text T [1 ...n ], a substring T [ i...n ] with 1  X  i  X  n is called a suffix of T . The lexicographic arrangement of all n suffixes of T in a compact trie is known as the suffix tree of T [35], where the i th leftmost leaf represents the i th lexicographically smallest suffix. Each edge in the suffix tree is labeled by a character string and for any node u , path ( u ) is the string formed by concatenating the edge labels from root to u . For any leaf v , path ( v ) is exactly the suffix corresponding to v . For a given pattern P , a node u is defined as the locus node of P if it is the node u closest to the root such that P is a prefix of path ( u ); such a node can be determined in O ( p ) time, where p denotes the length of P . The generalized suffix tree (GST) is a compact trie which stores all suffixes of all strings in a given collection D of strings. The drawback of the suffix tree is its huge space consumption, which requires O ( n log n ) bits in theory. Yet, it can perform pattern matching in optimal O ( p + | output | ) time, where | output | is the number of occurrences of P in T . Compressed suffix tree (CST) is a space-efficient version of suffix tree. Several variants of CSTs have been proposed to date [23, 14, 32, 30, 11, 27, 34, 6, 26].
Let A [1 ...n ] be an array of length n . The RMQ index is a linear-space data structure which can return the posi-tion and the value of the minimum (maximum) element in any subrange A [ i..j ] such that 0  X  i  X  j  X  n . Although solving RMQ can be dated back from Chazelle X  X  original pa-per on range searching [7], many simplifications [5] and im-provements have been made, culminating in Fischer et al. X  X  2 n + o ( n ) bit data structure [9, 10]. All these schemes can an-swer RMQ in O (1) time. We shall use RMQ data structures extensively to report the desired documents while answer-ing our query. The basic result is captured in the following lemma [18]:
Lemma 1. Let A be an array of numbers. We can pre-process A in linear time and associate A with a linear-space RMQ data structure such that given a set of t non-overlapping (or the smallest) k numbers in A [ L 1 , R 1 ]  X  A [ L 2 , R A [ L t , R t ] in O ( t + k log k ) time.
In traditional inverted indexes, phrase queries are per-formed by first retrieving the inverted list for each word in the phrase and then applying an intersection algorithm to retrieve those documents in which the words in are appear-ing in the same order as in the phrase. Unfortunately, there is no efficient algorithm known which performs this inter-section in time linear to the size of the output. Another limitation of the traditional inverted indexes is that they do not support string documents where there is no word demarcation (that is, when a query pattern can begin and end anywhere in the document). A naive approach to ad-dress these issues is to maintain inverted lists for all possible phrases (or strings). In the next subsection, we introduce a simple index that is based on a suffix tree and augments this with the inverted lists. This index can answer the queries in optimal time, however, the space is a factor of |D| away from the optimal. As phrase is a special case of a string (that is, string that starts and ends at word boundaries), we will explain our indexes in terms of strings.
Let D = { d 1 , d 2 , ..., d | D | } be the collection of documents of total length n drawn from an alphabet set  X , and  X  be the generalized suffix tree of D . Let u be the locus node of a pattern P . Now a naive solution is to simply maintain an inverted list for the pattern corresponding to path ( u ) for all internal nodes u in  X . The list associated with a node u consists of pairs of the form ( d j , score ( path ( u ) , d j = 1 , 2 , 3 , ..., |D| , where the score of a document d spect to pattern P = path ( u ) is given by score ( path ( u ) , d We assume that such a score is dependent only on the oc-currences of P in the document d j . An example of such a score metric is frequency, so that score ( P, d j ) represents the number of occurrences of pattern P in document d j . For a given online pattern P , the top-k highest scoring documents can be answered by reporting the first k documents in the inverted list associated with the locus node of P , when the inverted lists are sorted by score order. Since the inverted list maintained at each node can be of length |D| , the total size of this index is O ( n |D| ). Though this index offers op-timal query time, it stores the inverted list for all possible strings. In the next subsection we show how the inverted lists can be stored efficiently in a total of O ( n ) space.
The key idea which leads to O ( n ) storage for inverted lists is the selection of nodes in the suffix tree for which inverted lists are actually maintained. We begin with the following definitions.
Consider the following sample documents d 1 , d 2 , and d
Note that  X  This is  X  is maximal in d 1 as well as d 2 , but not in d 3 . The conditional maximal strings of  X  This is  X  in d 1 are  X  This is a cat ... donkey.  X  and  X  This is not a  X . The conditional maximal strings of  X  This is  X  in d 2 are  X  This is a  X  and  X  This is not ... gift.  X .

Lemma 2. The number of maximal strings in a document d is less than 2 | d j | .

Proof. Consider the suffix tree  X  j of document d j . Then for each maximal string P in d j , there exists a unique node u in  X  j such that path ( u ) = P . Thus the number of maximal strings in d j is equal to the number of nodes in  X  j .
Lemma 3. For a given pattern P , we have score ( P, d j ) = score ( P i , d j ) , where P i is the shortest maximal string in d with P as prefix. If such a string P i does not exist, then score ( P, d j ) = 0 .
 Proof. As P i is the shortest maximal string in d j with P as prefix, every occurrence of a pattern P in d j is sub-sumed by an occurrence of pattern P i . Hence both patterns will have the same score with respect to document d j , with score ( P, d j ) = 0 signifying that the pattern P does not occur in d j .

Lemma 4. For every maximal string Q ( 6 = empty string ) in d j , there exists a unique maximal string P such that Q is a conditional maximal string of P .

Proof. Corresponding to each maximal string Q in d j , there exists a node u in  X  j (suffix tree of document d such that Q = path ( u ). The lemma follows by setting P = path ( parent ( u )), where parent ( u ) denotes the parent of u in  X  .

The number of maximal strings in D = { d 1 , d 2 , ..., d equal to the number of nodes in  X  (Lemma 2). In the context of maximal strings, the index in Section 4.1 main-tains inverted lists for all maximal strings in D . However, score ( P, d j ) depends only on pattern P and document d This gives the intuition that, for a particular document d instead of having entries in inverted lists corresponding to all maximal strings in D , it is sufficient to include d the inverted lists of only those strings which are maximal in d j . Thus, for each document d j , there will be at most 2 | d j | entries in all inverted lists, so that the total number of such entries corresponding to all documents is at most P j =1 2 | d j | = O ( n ). However, the downside of this change is that the simple searching algorithm used in Section 4.1 can no longer serve the purpose. Therefore, we introduce a new data structure called  X  X onditional inverted lists X , which is the key contribution of this paper.

From now onwards, we refer to the maximal strings by the pre-order rank of the corresponding node in  X . That is P = path ( u i ), where u i is a node in  X  with pre-order rank i . In contrast to the traditional inverted list, the conditional inverted list maintains score ( P i , d j ) only if P i is maximal in d . Moreover score ( P i , d j ) is maintained not with P i instead with P x , such that P i is a conditional maximal string of P x in d j . Therefore, u x will be a node in the path from root to u i . Formally, the conditional inverted list is an array of triplets of the form ( string id, document id, score ) sorted in the order of string-ids, where the string-id is pre-order rank of a node in  X . A key observation is the following: The conditional inverted list of a string P x has an entry ( i, j, score ( P i , d j )) if and only if P i is a conditional maximal string of P x in document d j . From the earlier example, the conditional inverted list of  X  This is  X  has entries correspond-ing to the following strings. We assign a string id to each of these strings (for simplicity) and let the score of a string corresponding to a document be its number of occurrences in that document.  X  This is a cat ... donkey.  X  ( string id = i 1 , score in d  X  This is not a  X  ( string id = i 2 , score in d 1 = 2)  X  This is a  X  ( string id = i 3 , score in d 2 = 3)  X  This is not a ... gift.  X  ( string id = i 4 , score in d
Since the string ids are based on the lexicographical or-der, i 3 &lt; i 1 &lt; i 2 &lt; i 4 . Then the conditional inverted list associated with the string  X  This is  X  is given below. Note that there is no entry for d 3 , since  X  This is  X  is not maximal in d 3 .
We also maintain an RMQ (range maximum query) struc-ture over the score field in the conditional inverted lists so as to efficiently retrieve documents with highest score as ex-plained later in following subsection.
 Lemma 5. The total size of conditional inverted lists is O ( n ) .

Proof. Corresponding to each maximal string in d j , there exists an entry in the conditional inverted list with document id j . Hence the number of entries with document id as j is at most 2 | d j | and the total size of conditional inverted lists is O ( P |D| j =1 2 | d j | ) = O ( n ).

Lemma 6. For any given node u in  X  and any given document d j associated with some leaf in the subtree of u , there will be exactly one string P i such that (1) P imal in d j , (2) path ( u ) is a prefix of P i , and (3) the triplet ( i, j, score ( P i , d j )) is stored in the conditional inverted list of a node u x 6 = u , where u x is some ancestor of u .
Proof. Since there exists at least one occurrence of d j in the subtree of u , Statements (1) , (2), and (3) can be eas-ily verified from the definition of conditional inverted lists. The uniqueness of P i can be proven by contradiction. Sup-pose that there are two strings P 0 i and P 00 i satisfying all of the above conditions. Then path ( u ) will be a prefix of P i = lcp ( P Then from the one-to-one correspondence that exists be-tween maximal strings and nodes in suffix tree (Lemma 2), it can be observed that the lcp between two maximal strings in a document d j is also maximal. Thus P  X  i is maximal in d and this contradicts the fact that, when P 0 i (or P 00 i conditional maximal string of P x , there cannot be a maxi-mal string P  X  i , such that P  X  i is a prefix of P 0 i and P prefix of P  X  i .
Let P be the given online pattern of length p . To answer a top-k query, we first match P in  X  in O ( p ) time and find the locus node u i . Let ` = i and r be the pre-order rank of the rightmost leaf in the subtree of u i . That is, P and P r represents the lexicographically smallest and largest maximal strings in D with path ( u i ) as a prefix. Then, all maximal strings with P as prefix can be represented by P z `  X  z  X  r . From Lemmas 4 and 6, for each document d j which has an occurrence in the subtree of u i , there exists a unique triplet with score score ( P, d j ) in the conditional inverted list of some ancestor node u x of u i with string id  X  [ `, r ]. Now the top-k documents can be retrieved by first identifying such triplets and then retrieving the k highest scored documents.

Note that the triplets in the conditional inverted lists are sorted according to the string-ids. Hence by performing a binary search of ` and r in the conditional inverted list asso-ciated with each ancestor of u i , we obtain t non-overlapping intervals [ ` 1 , r 1 ] , [ ` 2 , r 2 ] , ..., [ ` t , r t ber of ancestors of u i . Using an RMQ (range maximum query) structure over the score field in the conditional in-verted lists, the k triplets (thereby documents) correspond-ing to the k highest scoring documents can be retrieved in O ( t + k log k ) time (Lemma 1). Hence the total query time is O ( p ) + O ( t log n ) + O ( t + k log k ) = O ( p log n + k log k ).
Theorem 1. The String Inverted Index for a collection of documents D = { d 1 , d 2 , ..., d | D | } of total length n can be maintained in O ( n ) space, such that for a given pattern P of length p , the top-k document queries can be answered in O ( p log n + k log k ) time.

Note that the same structure can be used for document listing problem [24], where we need to list all the documents which has an occurrence of P . This can be answered by retrieving all the documents corresponding to the intervals [ ` Hence the query time is O ( p log n + docc ), where docc is the number of documents containing P . If our task is to just find the number of such documents (counting, not listing), we may use docc = P t i =1 ( r i  X  ` i ), and can answer the query in O ( p log n ) time.

Theorem 2. Given a query pattern P of length p , the document listing queries for a collection of documents D = { d docc ) time, where docc is the number of documents contain-ing P . The computation of docc (document counting) takes only O ( p log n ) time.

The index described in this section so far is a generalized index for string documents. When word boundaries are well-defined and query patterns will be aligned with word bound-aries as well, we can build the inverted index for phrases by replacing the generalized suffix tree with a word suffix tree. A word suffix tree is a trie of all suffixes which start from a word boundary. Now we maintain the conditional inverted lists corresponding to only those strings which start from a word boundary, thus resulting in huge space savings. We call this a phrase inverted index. Theorems 1 and 2 can be rewritten for phrase inverted index as follows.

Theorem 3. The Phrase Inverted Index for a collection of documents D = { d 1 , d 2 , ..., d | D | } with total N suffixes, which start from a word boundary, can be maintained in O ( N ) space, such that for a given pattern P of length p , the top-k , document listing, and document counting queries can be answered in O ( p log N + k log k ) , O ( p log N + docc ) and O ( p log N ) time, respectively.
In Section 4, we introduced the theoretical framework for our index. However, when dealing with the practical perfor-mance, the space and time analysis has to be more precise than merely a big-O notation. Consider a collection of En-glish text documents of total length n , where each character can be represented in 8 bits (256 characters, including num-bers and symbols corresponding to all ASCII values). Then the text can be maintained in 8 n bits. The conditional in-verted list can consist of at most 2 n triplets and if each entry in the triplet is 32 bits (word in computer memory), then the total size of the conditional inverted lists can be as big as (2 n  X  3  X  32) bits = (24  X  8 n ) bits = 24  X  ( datasize ). Moreover, we also need to maintain the generalized suffix tree, which takes  X  20-30 times of the text size. Hence the total index size will be  X  50  X  ( datasize ). This indicates that the hidden constants in big-O notation can restrict the use of an index in practice especially while dealing with massive data.

In this section, we introduce a practical framework of our index when frequency is used as score metric. That is, score ( P, d j ) represents the number of occurrences of pat-tern P in document d j . However, the ideas used can also be applied for other measures. Based on different tools and techniques from succinct data structures, we design three practical versions of our index (index-A, index-B, index-C) each successively improving the space requirements. We try to achieve the index compression by not sacrificing too much on the query times. Index-C takes only  X  5  X  ( datasize ), and even though it does not guarantee any theoretical bounds on query time, it outperforms the existing indexes [8] for top-k retrieval.
Index-A is a direct implementation of our theoretical in-dex from Section 4 with one change. As suffix tree is being used as an independent component in the proposed index, we replace it by compressed suffix tree (CST) without affect-ing the index operations and avoid the huge space required for suffix tree. We treat index-A as our base index as it does not modify the conditional inverted lists which form the core of the index.
In this version, we apply different empirical techniques to compress each component of the triplets from the condi-tional inverted list separately.
In our final efforts to further reduce the space required for the index, the following two observations play an important role.
It follows from the first observation that pruning the con-ditional inverted list entries corresponding to leaf nodes would significantly reduce the index space. In particular, we do not store those triplets whose string-id field corresponds to a leaf node in  X . The downside of this approach is that, the mod-ified index will no longer be able to report the documents with frequency of one. However, this shortcoming can be justified by reductions in space, and algorithmic approach can be employed to retrieve such documents if needed.
From the second observation, we can choose to get rid of the document-id field and incur additional overhead dur-ing query time. Briefly speaking, the document-id in the triplet corresponding to an internal node (string-id = pre-order rank of that internal node) is not stored explicitly in the conditional inverted lists. The string-id of a triplet in a conditional inverted list associated with a node u i is replaced by a pointer which points to another triplet associated with the highest-descendent node in the subtree of u i with the same document-id. Now the triplets in the conditional in-verted lists are sorted according to the value of this pointers. Retrieval of the document-id can be done in an online fash-ion by chasing pointers from an internal node up to the leaf corresponding to that document. (Details are deferred to the full paper).

Index-C makes use of both ideas simultaneously. Even though the modifications do not guarantee any theoretical bounds on query time (which can be O ( n ) in worst case), we observed that index-C performs well in practice.
We evaluated our new index and its compressed variants for space and query time using english texts and protein col-lections. ENRON is a  X  100MB collection of 48619 email mes-sages drawn from a dataset prepared by the CALO Project ( http://www.cs.cmu.edu/~enron/ ). PROTEIN is a concate-nation of 141264 Human and Mouse protein sequences total-ing  X  60MB ( http://www.ebi.ac.uk/swissprot ). We im-plemented all of the above indexes using the programming language C++, compiled with the g++ compiler version 4.2. Public code libraries at http://www.uni-ulm.de/in/theo/ research/sdsl.html and http://pizzachili.dcc.uchile. cl/indexes.html are used to develop some of the compo-nents in the indexes. Our experiments were run on an Intel Core 2 Duo 2.26GHz machine with a 4GB RAM. The OS was MAC OS X using version 10.6.5. In the following, we first analyze the space-time tradeoffs for various indexes de-scribed in this paper. Then we empirically compare these indexes with the inverted index when word boundaries are well defined and query patterns are aligned on word bound-aries.
Figure 1 shows the space requirements for the original index and its compressed variants against input text size for both datasets. Reduction in the space requirements for index-B and index-C can be analyzed separately for the three key components of the indexes: Document array, score array and string-id-array. Figure 2 shows the space utiliza-tion of these components for each of the proposed indexes. For both document array and score array, even though it is possible to use the theoretically-minimal number of bits re-quired per entry, it would result in a slowdown in the query time due to the lacking of efficient mechanisms for the re-trieval of the array values. In index-B, recall that we try to keep the encoding simple and do not compress the data to the fullest extent so as to achieve reasonable compres-sion and restrict query time within acceptable limit simul-taneously. In particular, as most of the values in the score (frequency) array (  X  97% for ENRON ,  X  98% for PROTEIN ) are less than 16, the proposed heuristic for compressing the score array in index-B achieves a very good practical perfor-mance. Out of three components, string-id array is the least compressible as its values correspond to the pre-order ranks of nodes in the suffix tree with ranges from 0 to | T | = n . We can utilize the fact that string-id array entries for a node are sorted in the increasing order by using difference encod-ing (such as gap) for efficient compression. However, such a method would naturally incur a query time overhead. In-stead, as mentioned in the previous section, index-B makes use of the run-length encoding to represent the consecutive entries with the same string-id value, and was able to elim-inate  X  30% string-id array entries for ENRON and  X  25% string-id array entries for PROTEIN in our experiments. Us-ing these compression techniques, index-B is  X  10 times the text as compared to index-A (  X  20 times text).

Recall that index-C does not store the document id for each entry explicitly to achieve space savings, at the expense of a slightly longer time to report the documents. Space sav-ings are also achieved when we prune the inverted list entries corresponding to the leaf nodes, which account for 50% in ENRON and 55% in PROTEIN of the total number of entries. As a result, index-C improves further on index-B and takes only  X  5 times of the text in the space requirement.
For these experiments, 250 queries from ENRON and 125 queries from PROTEIN , which appear in at least 10 documents with frequency 2 or more, are generated randomly for pat-tern lengths varying from 3 to 10. This therefore forms a total of 2000 and 1000 sample queries for ENRON and PRO-TEIN , respectively. In addition, we ensure that the selected patterns of length 3 appear in at least 80 documents to ob-serve the practical time in reporting top-k ( k = 10, 20, ..., 80) documents. Figure 3 shows the average time required to retrieve k = 10 documents with highest score (frequency) for patterns with varying lengths. Average time required for re-trieving documents in descending order of score (frequency) for a set of patterns with length 3 is shown in Figure 4 for varying k . These figures show that space savings achieved by the successive variants of our index (with increasing level of compression) will not hurt the query time to a great extent. A nearly linear dependance of query time on pattern length and k can also be observed from these figures. Matching the pattern P in compressed suffix tree  X  and binary search to obtain intervals in conditional inverted list of nodes in compressed suffix tree during top-k retrieval dominates the query time for index-A. Occasional slight drop in the query time for the indexes for increasing pattern length can be at-tributed to the binary search as it depends on the number of documents in which the query pattern is present. Query timings for index-B closely follow to that of index-A, with decoding the score (frequency) values for possible top-k can-didates being primarily responsible for the difference. Index-C has an additional overhead of decoding the document-id for each top-k answer to be reported. As a result, the gap in the query time of index-C with the other indexes should gradually increase with k , as is observed in the Figure 4.
In this subsection, we compare our phrase indexes with the traditional inverted index, highlighting the advantages of the former ones over the latter one. For a fair compari-son, our proposed indexes in this subsection are built on the word suffix tree instead of the generalized suffix tree (Theo-rem 3) so as to support searching of only those patterns that are aligned with the word boundaries. We begin by compar-ing the query times. Traditional inverted index are known to be efficient for single-word searching. When the inverted lists are each sorted in descending order of score, ranked re-trieval of documents would simply return the initial entries from the list corresponding to the query word. However, for efficient phrase searching, sorting the document lists by document-id (instead of score) would allow faster intersec-tions of multiple lists. Figure 5 shows the time required for retrieving top-10 documents with highest score (frequency) Figure 6: Space for the inverted index up to h words for a set of phrases consisting of two and three words, respec-tively. Here, we generated 800 additional queries aligned on english word boundaries from ENRON . Traditional inverted in-dex has its inverted lists sorted according to the document ids as mentioned, and we apply finger binary search [19] for intersecting multiple lists. We do not report the results queries with 2 words and 3 words when inverted lists are sorted by score as the timings were significantly worse. Figure 5 show that our phrase indexes perform much better than the intersection-based retrieval, and the performance degradation in traditional inverted in-dex would become more serious with the increase in words in a phrase query. Query times of our string/phrase indexes show that its query time for reporting top-10 documents is in the range of 100-400 microseconds thus achieving good practical performance.

A key point behind the widespread usage of the inverted index is that it can be stored in little space when compared with the size of input document collection; 20%-60% or more depending on whether it includes the position lists. One way to avoid the intersection of position lists in the phrase queries would be to store inverted list of all phrases up to some fixed number (say h ) of words. Such an index still has to reply on intersection for phrases with more than h words. Figure 6 shows the space requirement for this variant of in-verted index without the position lists. From the figure, it is clear that the space required for such a solution gradu-ally increases with h and directly depends on the number of distinct phrases in the input text. In contrast, our phrase index supports phrase searching with arbitrary number of words. In the most space-efficient version of our phrase in-dex (index-C), it takes just under 2 times of the input text in space. With gradual increase in space required, the tradi-tional inverted index for phrases up to h words occupies more space than index-C for all h  X  5. It is important to note that the traditional inverted index is maintained as an ad-ditional data structure along with the original text, whereas our proposed indexes are self indexes and do not need origi-nal text. Thus our phrase index compares favorably against the traditional inverted index for phrase searching in prac-tice.
In web search engines, tf-idf (term frequency X  X nverse doc-ument frequency) [2] is one of the most popular metric for relevance ranking. The query consists of multiple keywords (patterns) say P 1 , P 2 , ..., P m and the score of a document d , score ( d ), is given by where a ) tf ( P i , d ) denotes the number of occurrences of P total number of documents and docc ( P i ) representing the number of documents containing pattern P i . Many other versions of this metric are available in the literature. For top-k document retrieval that is based on the tf-idf metric (with multiple query patterns), most of the existing solu-tions are based on heuristics. When the query consists of a single pattern, the inverted index with document lists sorted in score order can retrieve top-k documents in optimal time. However, for an m -pattern query (a query consisting of m patterns say P 1 , P 2 , ..., P m ), we may need the inverted lists sorted according to the document id as well. In this section, we introduce an exact algorithm and compare the results ob-tained by applying it to inverted index as well as our index (index-B). Although our algorithm does not guarantee any worst-case query bounds, the focus is to explore the capa-bilities of our index as a generalized inverted index. Along with our index, we make use of a wavelet tree [13] over the document array for its advantages in offering dual-sorting functionalities. We restrict the query patterns to be words in order to give a fair comparison between our index and the inverted index.

Suppose that N denotes the number of suffixes in the word suffix tree. Let DA [1 ...N ] be an array of document ids, such that DA [ i ] is the document id corresponding to i th small-est suffix (lexicographically) in the word suffix tree. Note that each entry in DA takes at most d log | D |e bits to store. Therefore a wavelet tree W-Tree of DA can be maintained in N log |D| (1 + o (1)) bits. Now, given the suffix range [ `, r ] of any pattern P , the term frequency tf ( P, d j ) for the doc-ument with id j can be computed by counting the number of entries in DA with DA [ i ] = j and `  X  i  X  r . This query can be answered in O (log |D| ) time by exploring the orthogonal range searching functionality of W-Tree . Since term frequency in any document can be computed using W-Tree , we do not store the score (term frequency) array in index-B. This slightly compensates for the additional space overhead due to W-Tree . Inverse document frequency idf can be computed using Theorem 3. For simplicity, we de-scribe the algorithm for two pattern queries ( P 1 and P 2 follows, and the algorithm can be easily extended for the general m -pattern queries. Let S ans and S doc be two sets of documents which are set to empty initially, and let d k 1 d 2 represents the k th highest scoring document correspond-ing P 1 and P 2 , with term frequency as the score function and score ( d ) = tf ( P 1 , d ) idf ( P 1 ) + tf ( P 2 , d ) idf ( P
S ans = S doc = {} , x = y = 1 while | S ans | &lt; k do end while Choose k documents in S ans with the highest score value
The main idea of the algorithm is to maintain a list of candidate top-k documents in the set S doc , and refine the candidate set by moving documents to the set S ans from time to time. Each document in S ans will have score higher than an imaginary score max , and the set S ans will always contain the highest scoring documents we have examined so far. The algorithm stops as soon as S ans contains k documents, in which we report the top-k documents from the set.
 We compare the performance of our index against the tra-ditional inverted index for answering 2-pattern queries us-ing the algorithm described above. In the traditional in-verted index, document lists are sorted either by score (fre-quency) or document-id. To apply the above heuristic, we need dual-sorted documents lists, where each list is sorted on both score as well as document-id. Score sorted lists sup-port ranked retrieval of documents for individual patterns but tf-idf score can not be computed efficiently. If lists are sorted by document-id, though tf-idf score computation is faster, document retrieval in ranked order is not efficient. As a result we first duplicate the document lists for each of the pattern P i and sort them as required. Figure 7 shows the mean time required for retrieving top-k documents for a set of 50 2-pattern queries for ENRON such that each pattern is highly frequent. As observed from the figure, query time for our index increases faster than that of the inverted index. Figure 7: Mean time to report top-k documents for a set of 2-pattern queries
We remark that the major part of the query time used by the inverted index is on re-sorting the the document lists in which the query patterns occur. Thus, if the patterns are not too frequently occurring, the time spent on re-sorting is reduced, and the advantages of our index over the inverted index will vanish. Finally, the size of our index is  X  3.1 times of the text size.
This paper introduces the first practical version of in-verted index for string documents. The idea is to store lists for a selected collection of substrings (or phrases) in a con-ditionally sorted manner. Succinct data structures are used to represent these lists so as to reap benefits of dual sort-ing and achieve good top-k retrieval performance. We show how top-k tf-idf based queries can be executed efficiently. Furthermore, our indexes show a space-time advantage over all of the traditional techniques for searching long phrases. While this is the first prototype, more research will certainly help in deriving structures with great practical impact. [1] V. Anh and A. Moffat. Pruned Query Evaluation [2] R. Baeza-Yates and B. Ribeiro-Neto. Modern [3] D. Bahle, H. E. Williams, and J. Zobel. Compaction [4] D. Bahle, H. E. Williams, and J. Zobel. Optimised [5] M. A. Bender and M. Farach-Colton. The Level [6] R. C  X anovas and G. Navarro. Practical Compressed [7] B. Chazelle. A Functional Approach to Data [8] J. S. Culpepper, G. Navarro, S. J. Puglisi, and [9] J. Fischer and V. Heun. A New Succinct [10] J. Fischer, V. Heun, and H. M. St  X  uhler. Practical [11] J. Fischer, V. M  X  akinen, and G. Navarro. Faster [12] T. Gagie, G. Navarro, and S. J. Puglisi. Colored [13] R. Grossi, A. Gupta, and J. S. Vitter. High-Order [14] R. Grossi and J. S. Vitter. Compressed Suffix Arrays [15] A. Gupta, W. K. Hon, R. Shah, and J. S. Vitter. [16] W. K. Hon, M. Patil, R. Shah, and S. B. Wu. Efficient [17] W. K. Hon, R. Shah, S. V. Thankachan, and J. S. [18] W. K. Hon, R. Shah, and J. S. Vitter. Space-Efficient [19] F. K. Hwang and S. Lin. A Simple Algorithm for [20] M. Karpinski and Y. Nekrich. Top-K Color Queries [21] Y. Matias, S. Muthukrishnan, S. C. Sahinalp, and [22] J. I. Munro. Tables. In FSTTCS , pages 37 X 42, 1996. [23] J. I. Munro, V. Raman, and S. S. Rao. Space Efficient [24] S. Muthukrishnan. Efficient Algorithms for Document [25] G. Navarro and S. J. Puglisi. Dual-Sorted Inverted [26] E. Ohlebusch, J. Fischer, and S. Gog. CST++. In [27] E. Ohlebusch and S. Gog. A Compressed Enhanced [28] M. Persin, J. Zobel, and R. S. Davis. Filtered [29] R. Raman, V. Raman, and S. S. Rao. Succinct [30] L. Russo, G. Navarro, and A. Oliveira.
 [31] K. Sadakane. Space-Efficient Data Structures for [32] K. Sadakane. Compressed Suffix Trees with Full [33] N. V  X  alim  X  aki and V. M  X  akinen. Space-Efficient [34] N. V  X  alim  X  aki, V. M  X  akinen, W. Gerlach, and K. Dixit. [35] P. Weiner. Linear Pattern Matching Algorithms. In [36] H. E. Williams, J. Zobel, and P. Anderson. What X  X  [37] H. E. Williams, J. Zobel, and D. Bahle. Fast Phrase [38] J. Zobel and A. Moffat. Inverted Files for Text Search
