 1. Introduction
In object-oriented environments, DAS commonly use a layer of data access objects (DAOs) to read and write data from a relational database management system (RDBMS). According to the JEE pattern catalog [43] , the DAO pattern abstracts and manages the connection with the data source to obtain and store data. 1.1. Status quo
A process-driven SOA is an architectural style for developing large business applications. Accordingly, a huge number of activities. 1.2. Basic problem code, nor with the service internal documentation, nor with the data storage schemes. Accordingly, the service internal maintaining, reusing, documenting, tracing and developing data access in a large enterprise in more detail. 1.3. Dif fi cult maintainability may be obsolete and should be not be available anymore. Due to lacking integration of DAS and the data storages, further elaboration to improve maintainability of DAS is required.
 1.4. Lack of DAS documentation and traceability
Moreover, when maintaining processes in a process-driven SOA, developers need to understand the relationships between information which database tables relate to which data objects and which data objects are used by a DAO. Unfortunately, and easy to maintain, such as test cases and inline comments [24] . 1.5. Insuf fi cient reuse of data access best practices
DAO implementations use techniques for mapping data objects to relational databases. These object relational mappings suitable DAO for reuse among hundreds of DAOs usually is a time-consuming task. 1.6. Different stakeholders have different requirements
Moreover, different stakeholders involved in a business process should be able to understand the SOA only from their 1.7. Our approach
In smaller environments, development techniques like naming conventions and documentations may be also be useful to handle the problems above. However, in larger-scale environments, when the number of software components grows, more presenting our view-based model-driven data access architecture (VMDA) built on the following basic concepts. 1.8. Four basic concepts developers can query all DAS and DAOs respectively belonging to a certain data storage schema. The other way around, all reduce the development complexity. The data-related extension of VbMF, the view-based data modeling framework (VbDMF), 1.9. Summary
To sum-up, our novel contribution combines four basic concepts (DAS, MDD, DAS repository, VbMF/VbDMF) in order to solve the problems and integration gaps described above. Basically our model-driven architecture aims at improving software development productivity and maintainability by enhancing traceability, documentation and reuse of DAS. Moreover, our our architectural view concept leading to a highly inter-operable system.
 quantitative evidences. Finally, Section 9 concludes and outlines future activities. 2. Related work
In this section we present related work from existing literature, standards, and known uses. We also emphasize the comparison. 2.1. DAS architecture approaches into the SOA. Likewise, they focus on semantic description and discovery of DAS. However, they do not describe how these a continuous approach to develop, maintain and manage DAS.

Like our approach, Resende uses DAS to manage heterogeneous data sources in a SOA environment [45] . He describes how to ef fi to-Object transformations are encapsulated by the DAS used for uniformly accessing heterogeneous data sources.
There are several approaches for semantic knowledge discovery e.g. [48,10] . Representatively, we refer to the software model-to-code and model-to-documentation transformations. 2.2. Service repositories approach,EbXMLwebserviceregistries [38] haveinterfacesthatenablesubmission,query,andretrievalofthecontentsoftheregistry. forDAS bymore sophisticatedcriteria.Knowninformation abouttheunderlyingdatabases,tables,columns,and ORM frameworkscan contingently underlying DAOs encapsulating the database queries, as well as the data storage schemes. 2.3. Model repositories
There are many model repositories that store meta models, models and model instances such as [32,35] . An interesting from a user's point of view.

Nissen and Jarke's encouraging work proposes repository support for goal-oriented inconsistency management in modeling levels. Like their approach, our repository approach stores meta models, models and model instances and manages views, our views can even be domain-speci fi cally tailored to the stakeholder requirements.
Min et al. [33] present an XML data management system using a relational database as a repository that translates a model. Hence, if the models contain embedded meta-data elements, then using XQuery to query the model elements, might be et. al. 's approach lacks usability, when stakeholders only have a limited knowledge of the meta-data within XML models. 2.4. View-based approaches managing and maintaining DAS. However, there are many approaches using views in order to enhance maintainability and approaches: the basis for model-to-documentation transformations. approach, our model instances can be transformed to other outputs such as source code and documentation. 2.5. Model-driven frameworks and other developmental related work
Nowadays, there is still a missing link between the programming components and the data storage schemes [29] . This gap certain stakeholders.
 do not know the exact name of a component to be reused, all DAS/DAOs have to be checked-out from the version management response times. 3. The view-based data modeling framework model-driven data access architecture (VMDA). 3.1. Motivation along with the number of process elements. When developing and maintaining data access services (DAS), stakeholders are DAS description elements such as DAS operations, endpoints of running services, the messages, and the data types. When themselves busy with unnecessary details [53] . 3.2. Basic overview of the view-based modeling framework
The view-based data modeling framework (VbDMF) is an extension of the view-based modeling framework (VbMF). VbDMF and VbDMF new architectural views can be designed , existing models can be extended by adding new features, views can be
VbMF basically consists of the following views:  X 
The Core View model is the basic VbMF model and is derived from the Ecore meta-model [50] .  X 
The Flow View model describes the control-fl ow of a process.  X 
The Collaboration View model basically describes the service operations.  X 
The Information View model speci fi es the service operations in more detail by de fi ning data types and messages.  X  the Information View, the ORM View, the User View, and the Data Object View to produce a combined view. 3.3. View-based Data Modeling Framework (VbDMF) only one representative for all other types of DAS implementations. As nowadays, the object-oriented programming (OOP)
Database Connection (JDBC) interface to access the data. 3.3.1. Database (DB) Connection View model connections. 3.3.2. Physical Data View model The Physical Data View integrates the Database Connection View.
 3.3.3. Data Object View model independent model integrated by the ORM View model and the DAO View model. The Data Object View is typically used by the DAO developers. 3.3.4. Object Relational Mapping View model
The Object Relational Mapping (ORM) View model is a technology-dependent model that provides the basis for specifying extension. The basic model speci fi es a mapping between the Data Object View and the Physical Data View. 3.3.5. DAO View model Object View and is typically used by the DAO developers. 3.3.6. User View model DAS. 3.3.7. DAS Repository View model The DAS Repository View model is a combined view model. The DAS Repository View integrates the Collaboration View, the operation by joining elements from different views.

To summarize, VbMF and VbDMF focus on reducing the development complexity in process-driven SOAs. By exploiting the 4. Architecture overview
In this section we present the big picture of our view-based model-driven data access architecture (VMDA). As already mentioned in Section 1 , our VMDA uni fi es the following four contributions: 1. Using DAS to be independent of the underlying data sources 2. Specifying DAS models/model instances making use of the advantages of MDD 3. Applying VbMF/VbDMF to separate the DAS models/model instances into different view models/views 4. Establishing a DAS repository to manage the DAS view models and views
In the following we explain the VMDA components depicted in Fig. 4 : There are many solutions of use based on model underlying data storage schema, and the relationships between them.

In order to manage these view models and view model instances properly, the DAS repository provides a query service to independent query languages into platform-dependent languages can be found in [6] .In Section 6.2.1 we de fi ne our own criteria.
 client or by the DAS repository's build/deploy service.

The business process application can invoke the deployed DAS running on a speci fi c DAS provider endpoint. Moreover, detail. 5. The Data Access Service (DAS) repository 5.1. Basic architectural decisions 5.1.1. Stored artifacts views.
 instances because they contain the basic elements that can be, in particular, applied to generate the runnable DAS. 5.1.2. Data redundancy and synchronization view model instances: The DAS repository can either store the view model instances redundantly in the DAS repository and and the other related repositories. 5.1.3. Version management management system has to comply with a certain version of programming language, our view model instances have to comply with certain model versions.
 view alternatively [30] .

By the way, we do not manage different versions of the Ecore meta-model [50] that is used to specify the view models, as mentioned before. If a new Ecore meta-model version shall be used, all view models and view model instances have to be upgraded to comply with this new Ecore meta-model version. 5.1.4. Version compatibility
In contrast to managing view model instances of the same model version, managing view model instances belonging to values.
 and view model instances. However we do not allow renaming and deleting view model elements, because this results in a de model version would not have been downward compatible with the previous versions. Hence, we recommend to regularly compatible with older view model versions. 5.2. Services and view model instances. 5.2.1. Query service view models and view model instances. 5.2.2. Registration service model instances on a certain DAS provider. 5.2.3. Build/deploy service via the following publication service. 5.2.4. Publication service 5.2.5. Synchronization service Likewise, related data from the other repositories need to be transferred to the DAS repository. synchronization service can actively replicate DAS repository data to other repositories. Hereto, the DAS repository the other repository services.
 fi into the DAS repository.
 concrete use cases. 5.3. The DAS repository view model the gap between these data in order to improve documentation and maintainability.

In the following we go deeper into describing the model entities of the DAS Repository View model. As already mentioned DAS implementation for object-oriented environments.
 DAO consists of one or more DAO Operations . Each DAO Operation holds an attribute that stores the type of SQL statement Parameter or Output Parameter ) can either be associated with a Data Object Type or with a simple type. A simple type is that can be used to combine a speci fi ed Collaboration View with an Information View and with a DAO View respectively. Business Objects of the Information View might go through some Transformations that convert or extract existing data to form new pieces of data. These Transformations are performed inside a DataHandling object. The source or the target of a of
Interfaces . Each Interface provides some Operations .An Operation represents an action that might need some inputs and point of view, whereas the DAO View speci fi es DAO Operations from the DAO point of view with its DAO input and output
Af fi liation can consist of zero or more User classes. 6. Tooling: the view-based repository client
Our view-based repository client prototype, shown in Fig. 7 , has been implemented as an Eclipse Plug-in to comfortably supporting developers in modeling DAS. In the following we describe our view-based repository client in more detail. 6.1. Using the view-based repository client of view.  X   X  resulting view is an Ecore XMI model instance [50] . Up-to-now, our prototype view-based repository client only supports lesser compared to the number of views ( b 0.5%).  X 
Sample Ecore Model Editor ( 4 ) in order to view models and views. When a desired view that best possibly meets their
Repository Instance View ( 1 ).  X 
Reuse : In order to reuse a view, developers have two possibilities:  X  Reuse as it is : In case of developers fi nd a desired view/model, they can reuse it without adapting it.  X  that allows developers for comfortably specifying new view model instances. We provide an overview of our modeling  X 
Request registration: Developers can register new DAS/DAO models and views by sending a service operation request with a generated from the Information View, the Collaboration View, and the Core View. The DAOs are generated from the various
VbDMF views, the DAO View, the ORM View, and the Data Object View. As the DAO interfaces contain no ORM details, DAO interfaces are automatically generated simply from the DAO View and the Data Object View.  X  views and models have to be both re-registered and re-tested.  X  respectively. 6.2. Using the query service by our prototype implementation and secondly we analyze further support of a view-based repository client required when querying the DAS repository.
 6.2.1. Query language
Traditional database query languages, such as SQL and XQuery, are highly expressive but hard to learn. On the contrary, elements and the relationships between them. For this, in the following Section 6.2.2 , we provide some GUI support. We developed our Query Language using the Eclipse ANTLR Plug-in [4] . Fig. 9 contains a visual presentation of our Query Language De fi nition to be veri fi ed.
 6.2.2. Further support: model element generator
In order to query views from the DAS repository by different search criteria, stakeholders need to know the view model elements. A common problem when querying reusable objects lies in the handling of misspelled words, synonyms and and from its view model references. The output gives an overview about all possible key words within a view model.
Ecore meta-model instead of from several related view models. 7. Case study 7.1. Business environment data, encoded in Geography Markup Language (GML) [42] , an XML grammar for expressing geographical features. Such water temperature of indoor swimming pools. According to the OpenGIS WFS implementation speci fi cation [40] , each WFS basically provides three operations: The operation GetCapabilities indicates serviceable feature types, the operation
Transaction operation in order to service feature modi fi cations. 7.2. Applying our approach to Web Feature Services
In the following we apply our architecture approach to WFS in order to enhance documentation, traceability and maintainability of data access of WFS.

At fi rst, there is a need to relate WFS terminology to the DAS terminology of this paper: 1. WFS vs. DAS: A WFS can read and write spatial and non-spatial data from an RDBMS. Consequently, we de fi ne WFS as specialization of DAS. web catalog service is a service repository managing spatial and non-spatial WFS meta-data. provider.
 reads or writes spatial and/or non-spatial data from a geographic database.
 ful these new views:  X  needs to be part of the resulting source code.  X  deploy service builds the WFS source code and deploys the resulting WFS on a certain WFS provider.  X  published.  X 
Request publication: After successfully registering new views/models, they can be published to selected persons, teams, departments, or companies (see Fig. 4 ) so that they can query them. 7.3. Making use of the DAS repository search for particular WFS by different search criteria such as tables, columns, data objects etc.: based repository client's Eclipse Query View, in example: (PhysicalDataView.table.name=schoolBuilding AND
DBConnectionView.connectionProperties.schema=GIS) . After entering the submit button, the view-based repository client invokes the DAS repository query service. returned and can be viewed in the Eclipse Query Result View. The developer can acquaint himself with the WFS and, for example, contact the WFS owner. If the desired PhysicalDataView or DBConnectionView is in the result set, the WFS can be reused. Otherwise, a new search can be started.

DAO developers by performing the following steps:
Eclipse Query View: (DBConnectionView.connectionProperties.server= http://192.168.1.11:8080 ) 2. Check result set Afterwards, the query service returns a list of DBConnectionView views matching the query.
By using the Eclipse-embedded Sample Ecore Mo del Editor, they can change the value of the DBConnectionView. connectionProperties.server model element from http://192.168.1.11:8080 to http://192.168.1.12:8080 . register service with the new DBConnectionView as SOAP attachment. 5. Test: Then, the WFS with the newly con fi gured database connection need to be tested. group as before.
 approach. 8. Evaluation GIS applications in Section 7 .
 the DAS repository's query service.

There are two main approaches in order to map models to an RDBMS [30] : an XSD model mapping approach and a domain model mapping approach. According to [30] , an XSD model mapping approach should be preferred to using a domain-based tables. However, we will show that even a common domain-model-based approach shows acceptable performance results. Thus querying for views and view models.
 environments in a large enterprise and secondly from analyzing WFS of commercial [14] and open-source [28] GIS. They the DAS repository.
 during our measurements. 8.1. Use cases use cases that, according to our experiences and studies, are most likely to be used by developers.  X  type of query does not require a table join, because only the Database table is selected.  X  two conditions should be concatenated with the boolean AND operator.  X   X 
Use Case Query 4 (Query by FeatureType, PropertyType, ORM Table, ORM Column): Database developers use this query, when insert both the name of a certain FeatureType and of a certain PropertyType into the search condition. In example, the position. The tables ORM Table and ORM Column de fi ne the mapping between a feature type and a table and the mapping
The speci fi c search conditions should be linked with the boolean AND operator.  X  the User table, the Af fi liation table and the FeatureType table.  X 
Use Case Query 6 (Query by DAO, DAO Operation, Output Parameter, Input Parameter, Data Object Type, ORM Table): Database included into the join. As a result, they get the database tables accessed by this DAO operation.  X 
PropertyType of a FeatureType they have registered and published, they can add the PropertyType table to the search condition by using the boolean operator AND or OR.  X  Use Case Query 8 (Query by DAO, DAO Operation, Output Parameter, Input Parameter, Data Object Type, ORM Table, Member as part of a certain DAO operation. In addition to Use Case Query 6, stakeholders can add the Member Variable table as table in the join.  X 
Database table and Table table into the table join. 8.2. Test requirements de fi average, and 10 em users publish and register one speci fi c WFS.
 normalized data model that does not contain any redundant column data. 8.3. Results linear functional behavior results (among others) from the following reasons:  X 
Different queries are optimized to a different degree  X 
Randomized search criteria can lead to faster or slower results  X  Different queries with different tables joining various numbers of rows as described in Table 3 acceptable. Fortunately, in practice, the number of search criteria, and thus the number of table joins, is usually low (approximately 1  X  4), therefore, resulting in a very good overall performance.
 time values increase virtually linearly with increasing number of WFS.
 indices to perform the queries. 9. Conclusion and outlook which database tables are read and written by the DAS and DAOs.

Moreover as the number of software components grows, data development complexity increases with the number of DAS. So retrieving a particular DAS can be complex and time-consuming. In order to tackle these issues and to enable better maintainability, we speci fi ed a view-based model-driven data-access architecture (VMDA) managing the views, models and relationships between them. This service-oriented architecture is composed of well-known concepts such as a model-driven by implementation, data storage schema and meta-data artifacts. However, further work is necessary to coping with other such as dynamic invocation of DAS need to be discussed and de fi ned.
 Acknowledgment This work was supported by the European Union FP7 project COMPAS, grant no. 215175.

References
