 George E. Dahl gdahl@cs.toronto.edu Ryan P. Adams rpa@seas.harvard.edu Hugo Larochelle hugo.larochelle@usherbrooke.ca The breadth of applications for the restricted Boltz-mann machine (RBM) (Smolensky, 1986; Freund and Haussler, 1991) has expanded rapidly in recent years. For example, RBMs have been used to model image patches (Ranzato et al., 2010), text documents as bags of words (Salakhutdinov and Hinton, 2009), and movie ratings (Salakhutdinov et al., 2007), among other data. Although RBMs were originally developed for binary observations, they have been generalized to several other types of data, including integer-and real-valued observations (Welling et al., 2005).
 However, one type of data that is not well supported by the RBM is word observations from a large vocabulary (e.g., 100,000 words). The issue is not one of repre-senting such observations in the RBM framework: so-called softmax units (Salakhutdinov and Hinton, 2009) are the natural choice for modeling words. The is-sue is that manipulating distributions over the states of such units is expensive even for intermediate vo-cabulary sizes and becomes impractical for vocabulary sizes in the hundred thousands  X  a typical situation for NLP problems. For example, with a vocabulary of 100,000 words, modeling n -gram windows of size n = 5 is comparable in scale to training an RBM on binary vector observations of dimension 500,000 (i.e., more dimensions than a 700  X  700 pixel image). This scalability issue has been a primary obstacle to using the RBM for natural language processing.
 In this work, we directly address the scalability issues associated with large softmax visible units in RBMs. We describe a learning rule with a computational com-plexity independent of the number of visible units. We obtain this rule by replacing the Gibbs sampling tran-sition kernel over the visible units with carefully imple-mented Metropolis X  X astings transitions. By training RBMs in this way on hundreds of millions of word windows, they learn representations capturing mean-ingful syntactic and semantic properties of words. Our learned word representations provide benefits on a chunking task competitive with other methods of in-ducing word representations and our learned n -gram features yield even larger performance gains. Finally, we also show how similarly extracted n -gram represen-tations can be used to obtain state-of-the-art perfor-mance on a sentiment classification benchmark. We first describe the restricted Boltzmann machine for binary observations, which provides the basis for other data types. An RBM defines a distribution over a binary visible vector v of dimensionality V and a layer h of H binary hidden units through an energy This energy is parameterized by bias vectors b  X  R V and c  X  R H and weight matrix W  X  R H  X  V , and is converted into a probability distribution via This yields simple conditional distributions: p ( h | v ) = Y where sigm( z ) = 1 / (1 + e  X  z ), which allow for efficient Gibbs sampling of each layer given the other layer. We train an RBM from T visible data vectors { v t } T t =1 by minimizing the scaled negative (in practice, penal-ized) log likelihood of the parameters  X  = ( b , c , W ):  X 
MLE = argmin The gradient of the objective with respect to  X   X 
L (  X  )  X  X  is intractable to compute because of the exponentially many terms in the sum over joint configurations of the visible and hidden units in the second expectation. Fortunately, for a given  X  , we can approximate this gradient by replacing the second expectation with a Monte Carlo estimate based on a set of M samples N = {  X  v
E The samples {  X  v m } are often referred to as  X  X egative samples X  as they counterbalance the gradient due to the observed, or  X  X ositive X  data. To obtain these sam-ples, we maintain M parallel Markov chains through-out learning and update them using Gibbs sampling between parameter updates.
 Learning with the Monte Carlo estimator alternates between two steps: 1) Using the current parameters  X  , simulate a fews steps of the Markov chain on the M negative samples using Eqs. (4)-(6); and 2) Using the negative samples, along with a mini-batch (subset) of the positive data, compute the gradient in Eq. (9) and update the parameters. This procedure belongs to the general class of Robbins-Monro stochastic approxima-tion algorithms (Younes, 1989). Under mild condi-tions, which include the requirement that the Markov chain operators leave p ( v , h |  X  ) invariant, this proce-dure will converge to a stable point of L (  X  ). For K -ary observations  X  observations belonging to a finite set of K discrete outcomes  X  we can use the same energy function as in Eq. (1) for the binary RBM by encoding each observation in a  X  X ne-hot X  represen-tation and concatenating the representations of all ob-servations to construct v . In other words, for n sep-arate K -ary observations, the visible units v will be partitioned into n groups of K binary units, with the constraint that each partition can only contain a sin-gle non-zero entry. Using the notation v a : b to refer to the subvector of elements from index a to index b , the i th observation will then be encoded by the group of visible units v ( i  X  1) K +1: iK . The one-hot encoding is enforced by constraining each group of units to con-tain only a single 1-valued unit, the others being set to 0. The difference between RBMs with binary and K -ary observations is illustrated in Figure 1. To simplify notation, we refer to the i th group of visible the biases and weights associated with those units as will also denote with e k the one-hot vector with its k th component set to 1.
 The conditional distribution over the visible layer is Each group v ( i ) has a multinomial distribution given the hidden layer. Because the multinomial probabili-ties are given by a softmax nonlinearity, the group of units v ( i ) are referred to as softmax units (Salakhut-dinov and Hinton, 2009). While in the binary case the size of the visible layer is equal to data dimenionality, in the K -ary case the size of the visible layer is K times the dimensionality. For language processing applications, where K is the vo-cabulary size and can run into the hundred thousands, the visible layer can become unmanageably large. The difficulty with large K is that the Gibbs opera-tor on the visible units becomes expensive to simulate, making it difficult to perform updates of the negative samples. That is, generating a sample from the condi-tional distribution in Eq. (10) dominates the stochastic learning procedure as K increases. The reason for this expense is that it is necessary to compute the activity associated with each of the K possible outcomes, even though only a single one will actually be selected. On the other hand, given a mini-batch { v t } and neg-ative samples {  X  v m } , the gradient computations in Eq. (9) are able to take advantage of the sparsity of the visible activity. Since each v t and  X  v m only con-tain n non-zero entries, the cost of the gradient es-timator has no dependence on K and can be rapidly computed. Thus the only barrier to efficient learning of high-dimensional multinomial RBMs is the complexity of the Gibbs update for the visible units.
 Dealing with large multinomial distributions is an is-sue that has come up previously in work on neural network language models (Bengio et al., 2001). For ex-ample, Morin and Bengio (2005) addressed this prob-lem by introducing a fixed factorization of the (condi-tional) multinomial using a binary tree in which each leaf is associated with a single word. The tree was de-termined using an external knowledge base, although Mnih and Hinton (2009) investigated ways of extend-ing this approach by learning the word tree from data. Unfortunately, tree-structured solutions are not appli-cable to the problem of modeling the joint distribution of n consecutive words, as we wish to do here. Intro-ducing a directed tree breaks the undirected, symmet-ric nature of the interaction between the visible and hidden units of the RBM. While one strategy might be to use a conditional RBM to model the tree-based factorizations, similar to Mnih and Hinton (2009), the end result would not be an RBM model of n -gram word windows, nor would it even be a conditional RBM over the next word given the n  X  1 previous ones.
 In summary, dealing with K -ary observations in the Boltzmann machine framework for large K is a crucial open problem that has inhibited the development of deep learning solutions NLP problems. Having identified the Gibbs update of the visible units as the limiting factor in efficient learning of large-K multinomial observations, it is natural to examine whether other operators might be used for the Monte Carlo estimate in Eq. (9). In particular, we desire a transition operator that can take advantage of the same sparse operations that enable the gradient to be efficiently computed from the positive and nega-tive samples, while still leaving p ( v , h ) invariant and thus still satisfying the convergence conditions of the stochastic approximation learning procedure.
 To achieve this, instead of sampling exactly from the conditionals p ( v ( i ) | h ) within the Markov chain, we use a small number of iterations of Metropolis X  X astings (M X  X ) sampling. Let q (  X  v ( i )  X  v ( i ) ) be a proposal distribution for group i . The following stochastic op-erator leaves p ( v , h ) invariant: 1. Given the current visible state v , sample a pro-2. Replace the i th part of the current state v ( i ) with min Assuming it is possible to efficiently sample from the proposal distribution q (  X  v ( i )  X  v ( i ) ), this M X  X  opera-tor is fast to compute as it does not require normalizing over all possible values of the visible units in group i and, in fact, only requires the unnormalized probabil-ity of one of them. Moreover, as the n visible groups are conditionally independent given the hiddens, each group can be simulated in parallel (i.e., words are sam-pled at every position separately). The efficiency of these operations make it possible to apply this transi-tion operator many times before moving on to other parts of the learning and still obtain a large speedup over exact sampling from the conditional. 4.1. Efficient Sampling of Proposed Words The utility of M X  X  sampling for an RBM with word observations relies on the fact that sampling from the proposal q (  X  v ( i )  X  v ( i ) ) is much more efficient than sampling from the correct softmax multinomial. Al-though there are many possibilities for designing such proposals, here we will explore the most basic variant: independence chain Metropolis X  X astings in which the proposal distribution is fixed to be the marginal dis-tribution over words in the corpus.
 Na  X  X ve procedures for sampling from discrete distribu-tions typically have linear time complexity in the num-ber of outcomes. However, the alias method (pseu-docode at www.cs.toronto.edu/ ~ gdahl ) of Kronmal and Perterson (1979) can be used to generate sam-ples in constant time with linear setup time. While the alias method would not help us construct a Gibbs sampler for the visibles, it does make it possible to generate proposals extremely efficiently, which we can then use to simulate the Metropolis X  X astings opera-tor, regardless of the current target distribution. The alias method leverages the fact that any K -valued discrete distribution can be written as a uniform mix-ture of K Bernoulli distributions. Having constructed this mixture distribution at setup time (with linear time and space cost), new samples can be generated in constant time by sampling uniformly from the K mixture components, followed by sampling from that component X  X  Bernoulli distribution. 4.2. Mixing of Metropolis X  X astings Although this procedure eliminates dependence of the learning algorithm on K , it is important to examine the mixing of Metropolis X  X astings and how sensitive it is to K in practice. Although there is evidence (Hin-ton, 2002) that poorly-mixing Markov chains can yield good learning signals, when this will occur is not as well understood. We examined the mixing issue using the model described in Section 6.1 with the parameters learned from the Gigaword corpus with a 100,000-word vocabulary as described in Section 6.2. We analytically computed the distributions implied by iterations of the M X  X  operator, assuming the initial state was drawn according to Q i q ( v ( i ) ). As this com-putation requires the instantiation of n 100 k  X  100k matrices, it cannot be done at training time, but was done offline for analysis purposes. Each application of Metropolis X  X astings results in a new distribution converging to the target (true) conditional.
 Figures 2(a) and 2(b) show this convergence for the  X  X econstruction X  distributions of six randomly-chosen 5-grams from the corpus, using two metrics: symmet-ric Kullback X  X eibler (KL) divergence and total varia-tion (TV) distance, which is the standard measure for analysis of MCMC mixing. The TV distance shown is the mean across the five group distributions. Fig-ures 2(c) and 2(d) show these metrics broken down by grouping, for the slowest curves (dark green) of the top two figures. These curves highlight that the state of the hidden units has a strong impact on the mix-ing and that most groups mix very quickly while a few converge slowly. We feel that these curves, along with the results of Section 6, indicate that the mixing is effective, but could benefit from further study. Using M X  X  sampling for a multinomial distribution with softmax probabilities has been explored in the context of a neural network language model by Bengio and S  X en  X ecal (2003). They used M X  X  to estimate the training gradient at the output of the neural network. However, their work did not address or investigate its use in the context of Boltzmann machines in general. Salakhutdinov and Hinton (2009) describe an alter-native to directed topic models called the replicated softmax RBM that uses softmax units over the entire vocabulary with tied weights to model an unordered collection of words (a.k.a. bag of words). Since their RBM ties the weights to all the words in a single document, there is only one vocabulary-sized multi-nomial distribution to compute per document, instead of the n required when modeling a window of consec-utive words. Therefore sampling a document condi-tioned on the hidden variables of the replicated soft-max still incurs a computational cost linear in K , al-though the problem is not amplified by a factor of n as it is here. Notably, Salakhutdinov and Hinton (2009) limited their vocabulary to K &lt; 14 , 000.
 No known previous work has attempted to address the computational burden associated with K -ary obser-vations with large K in RBMs. The M X  X -based ap-proach used here is not specific to a particular Boltz-mann machine and could be used for any model with large softmax units, although the applications that motivate us come from NLP. Dealing with the large softmax problem is essential if Boltzmann machines are to be practical for natural language data. In Section 6, we present results on the task of learning word representations. This task has been investigated previously by others. Turian et al. (2010) provide an overview and evaluation of these different meth-ods, including those of Mnih and Hinton (2009) and of Collobert and Weston (2008). We have already men-tioned the work of Mnih and Hinton (2009), who model the conditional distribution of the last word in n -gram windows. Collobert and Weston (2008) follows a simi-lar approach, by training a neural network to fill-in the middle word of an n -gram window, using a margin-based learning objective. In contrast, we model the joint distribution of the whole n -gram window, which implies that the RBM could be used to fill-in any word within a window. Moreover, inference with an RBM yields a hidden representation of the whole window and not simply of a single word. We evaluated our M X  X  approach to training RBMs on two NLP tasks: chunking and sentiment classifi-cation. Both applications will be based on the same RBM model over n -gram windows of words, hence we first describe the parameterization of this RBM and later present how it was used for chunking and sen-timent classification. Both applications also take ad-vantage of the model X  X  ability to learn useful feature vectors for entire n -grams, not just individual words. 6.1. RBM Model of n -gram Windows In the standard parameterization presented in Sec-tion 2, the RBM uses separate weights (i.e., differ-ent columns of W ) to model observations at different positions. When training an RBM on word n -gram windows, we would prefer to share parameters across identical words in different positions in the window and factor the weights into position-dependent weights and position-independent weights (word representations). Therefore, we use an RBM parameterization very sim-ilar to that of Mnih and Hinton (2007), which itself is inspired by previous work on neural language mod-els (Bengio et al., 2001). The idea is to learn, for each possible word w , a lower-dimensional linear projection of its one-hot encoding by incorporating the projection directly in the energy function of the RBM. Moreover, we share this projection across positions within the n -gram window. Let D be the matrix of this linear projection and let e w be the one-hot representation of w (where we treat w as an integer index in the vocabu-lary), performing this projection De w is equivalent to selecting the appropriate column D  X  ,w of this matrix. This column vector can then be seen as a real-valued vector representation of that word. The real-valued vector representations of all words within the n -gram are then concatenated and connected to the hidden layer with a single weight matrix.
 More specifically, let D be the D  X  K matrix of word representations. These word representations are in-troduced by reparameterizing W ( i ) = U ( i ) D , where i ) is a position-dependent H  X  D matrix. The bi-ases across positions are also shared, i.e., we learn a single bias vector b  X  that is used at all positions ( b ( i ) = b  X   X  i ). The energy function becomes
E ( v , h ) =  X  c &gt; h + with conditional distributions p ( h | v ) = Y p ( where U ( i ) j  X  refers to the j th row vector of U ( i ) gradients with respect to this parameterization are eas-ily derived from Eq. (9). We refer to this construction as a word representation RBM (WRRBM).
 In contrast to Mnih and Hinton (2007), rather than training the WRRBM conditionally to ing Metropolis X  X astings to model the full joint distribution p ( w t ,...,w n + t  X  1 ). That is, we train the WRRBM based on the objective L (  X  ) =  X  X using stochastic approximation from M X  X  sampling of the word observations. For models with n &gt; 2, we also found it helpful to incorporate ` 2 regularization of the weights, and to use momentum when updating U ( i ) . 6.2. Chunking Task As described by Turian et al. (2010), learning real-valued word representations can be used as a simple way of performing semi-supervised learning for a given method, by first learning word representations on un-labeled text and then feeding these representations as additional features to a supervised learning model. We trained the WRRBM on windows of text derived from the English Gigaword corpus 1 . The dataset is a corpus of newswire text from a variety of sources. We extracted each news story and trained only on windows of n words that did not cross the boundary between two different stories. We used NLTK (Bird et al., 2009) to tokenize the words and sentences, and also corrected a few common punctuation-related tok-enization errors. As in Collobert et al. (2011), we low-ercased all words and delexicalized numbers (replacing consecutive occurrences of one or more digits inside a word with just a single # character). Unlike Collobert et al. (2011), we did not include additional capitaliza-tion features, but discarded all capitalization informa-tion. We used a vocabulary consisting of the 100,000 most frequent words plus a special  X  X nknown word X  token to which all remaining words were mapped. We evaluated the learned WRRBM word represen-tations on a chunking task, following the setup de-scribed in Turian et al. (2010) and using the associated publicly-available code, as well as CRFSuite 2 . As in Turian et al. (2010), we used data from the CoNLL-2000 shared task. We used a scale of 0 . 1 for the word Model Valid Test CRF w/o word representations 94.16 93.79 HLBL (Mnih and Hinton, 2009) 94.63 94.00 C&amp;W (Collobert and Weston, 2008) 94.66 94.10 Brown clusters 94.67 94.11 WRRBM 94.82 94.10
WRRBM (with hidden units) 95.01 94.44 representation features (as Turian et al. (2010) recom-mend) and for each WRRBM model, tried ` 2 penal-selected the single model with the best validation F1 score over all runs and evaluated it on the test set. The model with the best validation F1 score used 3-gram word windows,  X  = 1 . 2, 250 hidden units, a learning rate of 0.01, and used 100 steps of M X  X  sampling to update each word observation in the negative data. The results are reported in Table 1, where we ob-serve that word representations learned by our model achieved higher validation and test scores than the baseline of not using word representation features, and are comparable to the best of the three word represen-tations tried in Turian et al. (2010) 3 .
 Although the word representations learned by our model are highly effective features for chunking, an important advantage of our model over many other ways of inducing word representations is that it also naturally produces a feature vector for the entire n -gram. For the trigram model mentioned above, we also tried adding the hidden unit activation probabil-ity vector as a feature for chunking. For each word w i in the input sentence, we generated features using the hidden unit activation probabilities for the trigram w i  X  1 w i w i +1 . No features were generated for the first and last word of the sentence. The hidden unit activa-tion probability features improved validation set F1 to 95.01 and test set F1 to 94.44, a test set result superior to all word embedding results on chunking reported in Turian et al. (2010).
 As can be seen in Table 3, the learned word represen-tations capture meaningful information about words. However, the model primarily learns word represen-tations that capture syntactic information (as do the representations studied in Turian et al. (2010)), as it only models short windows of text and must enforce local agreement. Nevertheless, word representations capture some semantic information, but only after sim-ilar syntactic roles have been enforced. Although not shown in Table 3, the model consistently embeds the following natural groups of words together (maintain-ing small intra-group distances): days of the week, words for single digit numbers, months of the year, and abbreviations for months of the year. A 2D vi-sualization of the word representations generated by t-SNE (van der Maaten and Hinton, 2008) is provided at http://i.imgur.com/ZbrzO.png . 6.3. Sentiment Classification Task Maas et al. (2011) describe a model designed to learn word representations specifically for sentiment analy-sis. They train a probabilistic model of documents that is capable of learning word representations and leveraging sentiment labels in a semi-supervised frame-work. Even without using the sentiment labels, by treating each document as a single bag of words, their model tends to learn distributed representations for words that capture mostly semantic information since the co-occurrence of words in documents encodes very little syntactic information. To get the best results on sentiment classification, they combined features learned by their model with bag-of-words feature vec-tors (normalized to unit length) using binary term fre-quency weights (referred to as  X  X nc X ).
 We applied the WRRBM to the problem of sentiment classification by treating a document as a  X  X ag of n -grams X , as this maps well onto the fixed-window model for text. At first glance, a word representation RBM might not seem to be a suitable model for learning features to improve sentiment classification. A WR-RBM trained on the phrases  X  X his movie is wonderful X  and  X  X his movie is atrocious X  will learn that the word  X  X onderful X  and the word  X  X trocious X  can appear in similar contexts and thus should have vectors near each other, even though they should be treated very differently for sentiment analysis. However, a class-conditional model that trains separate WRRBMs on n -grams from documents expressing positive and neg-ative sentiment avoids this problem.
 We trained class-specific, 5-gram WRRBMs on the la-beled documents of the Large Movie Review dataset introduced by Maas et al. (2011), independently pa-rameterizing words that occurred at least 235 times in the training set (giving us approximately the same vo-cabulary size as the model used in Maas et al. (2011)). Model Test LDA 67.42 LSA 83.96 Maas et al. (2011) X  X   X  X ull X  method 87.44 Bag of words  X  X nc X  87.80
Maas et al. (2011) X  X   X  X ull X  method 88.33
Maas et al. (2011) X  X   X  X ull X  method 88.89 WRRBM 87.42 WRRBM + bag of words  X  X nc X  89.23 To label a test document using the class-specific WR-RBM, we fit a threshold to the difference between the average free energies assigned to n -grams in the docu-ment by the positive-sentiment and negative sentiment models. We explored a variety of different hyperpa-rameters (number of hidden units, training parame-ters, and n ) for the pairs of WRRBMs and selected the WRRBM pair giving best training set classifica-tion performance. This WRRBM pair yielded 87.42% accuracy on the test set.
 We additionally examined the performance gain by ap-pending to the bag-of-words features the average n -gram free energies under both class-specific WRRBMs. The bag-of-words feature vector was weighted and nor-malized as in Maas et al. (2011) and the average free energies were scaled to lie on [0 , 1]. We then trained a linear SVM to classify documents based on the re-sulting document feature vectors, giving us 89 . 23% ac-curacy on the test set. This result is the best known result on this benchmark and, notably, our method did not make use of the unlabeled data. We have described a method for training RBMs with large K -ary softmax units that results in weight up-dates with a computational cost independent of K , al-lowing for efficient learning even when K is large. Us-ing our method, we were able to train RBMs that learn meaningful representations of words and n -grams. Our results demonstrated the benefits of these features for chunking and sentiment classification and, given these successes, we are eager to try RBM-based models on other NLP tasks. Although the simple proposal dis-tribution we used for M-H updates in this work is ef-fective, exploring more sophisticated proposal distri-butions is an exciting prospect for future work. P. Smolensky. Information Processing in Dynami-cal Systems: Foundations of Harmony Theory. In Parallel Distributed Processing: Explorations in the Microstructure of Cognition , pages 194 X 281. MIT Press, Cambridge, 1986.
 Y. Freund and D. Haussler. Unsupervised learning of distributions of binary vectors using 2-layer net-works. In NIPS 4 , pages 912 X 919, 1991.
 M. Ranzato, A. Krizhevsky, and G. E. Hinton. Fac-tored 3-way restricted Boltzmann machines for mod-eling natural images. In AISTATS , 2010.
 R. Salakhutdinov and G. E. Hinton. Replicated Soft-max: an Undirected Topic Model. In NIPS 22 , pages 1607 X 1614, 2009.
 R. Salakhutdinov, A. Mnih, and G. E. Hinton. Re-stricted Boltzmann machines for collaborative filter-ing. In ICML , 2007.
 M. Welling, M. Rosen-Zvi, and G. E. Hinton. Expo-nential family harmoniums with an application to information retrieval. In NIPS 17 , 2005.
 L. Younes. Parameter inference for imperfectly ob-served Gibbsian fields. Probability Theory Related Fields , 82:625 X 645, 1989.
 Y. Bengio, R. Ducharme, and P. Vincent. A neural probabilistic language model. In NIPS 13 , pages 932 X 938, 2001.
 F. Morin and Y. Bengio. Hierarchical probabilistic neural network language model. In AISTATS , 2005. A. Mnih and G. E. Hinton. A scalable hierarchical dis-tributed language model. In NIPS 21 , pages 1081 X  1088, 2009.
 R. A. Kronmal and A. V. Perterson. On the alias method for generating random variables from a dis-crete distribution. The American Statistician , 33(4): 214 X 218, 1979.
 G. E. Hinton. Training products of experts by mini-mizing contrastive divergence. Neural Computation , 14:1771 X 1800, 2002.
 Y. Bengio and J.-S. S  X en  X ecal. Quick training of proba-bilistic neural nets by importance sampling. In AIS-TATS , 2003.
 J. Turian, L. Ratinov, and Y. Bengio. Word repre-sentations: A simple and general method for semi-supervised learning. In ACL , pages 384 X 394, 2010. R. Collobert and J. Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In ICML , 2008.
 A. Mnih and G. E. Hinton. Three new graphical mod-els for statistical language modelling. In ICML , pages 641 X 648, 2007.
 S. Bird, E. Klein, and E. Loper. Natural Language Pro-cessing with Python: Analyzing Text with the Natu-ral Language Toolkit . O X  X eilly, 2009.
 R. Collobert, J. Weston, L. Bottou, M. Karlen,
K. Kavukcuoglu, and P. Kuksa. Natural language processing (almost) from scratch. Journal of Ma-chine Learning Research , 2011.
 P. Dhillon, D. P. Foster, and L. Ungar. Multi-view learning of word embeddings via CCA. In NIPS 24 , pages 199 X 207, 2011.
 L. van der Maaten and G. E. Hinton. Visualizing data using t-SNE. Journal of Machine Learning Re-search , 9:2579 X 2605, 2008.
 A. L. Maas, R. E. Daly, P. T. Pham, D. Huang, A. Y.
Ng, and C. Potts. Learning word vectors for senti-
