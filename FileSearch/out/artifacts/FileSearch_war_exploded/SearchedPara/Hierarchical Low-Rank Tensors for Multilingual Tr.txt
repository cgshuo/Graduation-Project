 The goal of multilingual syntactic transfer is to parse a resource lean target language utilizing an-notations available in other languages. Recent ap-proaches have demonstrated that such transfer is possible, even in the absence of parallel data. As a main source of guidance, these methods rely on the commonalities in dependency structures across languages. These commonalities manifest them-selves through a broad and diverse set of indi-cators, ranging from standard arc features used in monolingual parsers to typological properties
Verb-subject: { head POS= VERB } X { modifier POS= NOUN }  X { label= subj } X { direction= LEFT } X  { 82A= SV }
Noun-adjective: { head POS= NOUN } X { modifier POS= ADJ } X  { direction= LEFT } X { 87A= Adj-Noun } Table 1: Example verb-subject and noun-adjective typological features. 82A and 87A denote the WALS (Dryer et al., 2005) feature codes for verb-subject and noun-adjective ordering preferences. needed to guide cross-lingual sharing (e.g., verb-subject ordering preference). In fact, careful fea-ture engineering has been shown to play a cru-cial role in state-of-the-art multilingual transfer parsers (T  X  ackstr  X  om et al., 2013).

Tensor-based models are an appealing alterna-tive to manual feature design. These models auto-matically induce a compact feature representation by factorizing a tensor constructed from atomic features (e.g., the head POS). No prior knowledge about feature interactions is assumed. As a result, the model considers all possible combinations of atomic features, and addresses the parameter ex-plosion problem via a low-rank assumption.

In the multilingual transfer setting, however, we have some prior knowledge about legitimate fea-ture combinations. Consider for instance a ty-pological feature that encodes verb-subject pref-erences. As Table 1 shows, it is expressed as a conjunction of five atomic features. Ideally, we would like to treat this composition as a single non-decomposable feature. However, the tradi-tional tensor model decomposes this feature into multiple dimensions, and considers various com-binations of these features as well as their indi-vidual interactions with other features. Moreover, we want to avoid invalid combinations that con-join the above feature with unrelated atomic fea-tures. For instance, there is no point to construct-ing features of the form { head POS= ADJ } X { head POS= VERB } X  X  X  X  X { 82A= SV } as the head POS takes a single value. However, the traditional tensor technique still considers these unobserved feature combinations, and assigns them non-zero weights (see Section 7). This inconsistency be-tween prior knowledge and the low-rank assump-tion results in a sub-optimal parameter estimation.
To address this issue, we introduce a hierarchi-cal tensor model that constrains parameter repre-sentation. The model encodes prior knowledge by explicitly excluding undesired feature combi-nations over the same atomic features. At the bot-tom level of the hierarchy, the model constructs combinations of atomic features, generating inter-mediate embeddings that represent the legitimate feature groupings. For instance, these groupings will not combine the verb-subject ordering feature and the POS head feature. At higher levels of the hierarchy, the model combines these embed-dings as well as the expert-defined typological fea-tures over the same atomic features. The hierar-chical tensor is thereby able to capture the interac-tion between features at various subsets of atomic features. Algebraically, the hierarchical tensor is equivalent to the sum of traditional tensors with shared components. Thus, we can use standard online algorithms for optimizing the low-rank hi-erarchical tensor.

We evaluate our model on labeled dependency transfer parsing using the newly released multi-lingual universal dependency treebank (McDonald et al., 2013). We compare our model against the state-of-the-art multilingual transfer dependency parser (T  X  ackstr  X  om et al., 2013) and the direct transfer model (McDonald et al., 2011). All the parsers utilize the same training resources but with different feature representations. When trained on source languages alone, our model outperforms the baselines for 7 out of 10 languages on both unlabeled attachment score (UAS) and labeled at-tachment score (LAS). On average, it achieves 1.1% UAS improvement over T  X  ackstr  X  om et al. (2013) X  X  model and 4.8% UAS over the direct transfer. We also consider a semi-supervised set-ting where multilingual data is augmented with 50 annotated sentences in the target language. In this case, our model achieves improvement of 1.7% UAS over T  X  ackstr  X  om et al. (2013) X  X  model and 4.5% UAS over the direct transfer. Multilingual Parsing The lack of annotated parsing resources for the vast majority of world languages has kindled significant interest in multi-source parsing transfer (Hwa et al., 2005; Dur-rett et al., 2012; Zeman and Resnik, 2008; Yu et al., 2013b; Cohen et al., 2011; Rasooli and Collins, 2015). Recent research has focused on the non-parallel setting, where transfer is driven by cross-lingual commonalities in syntactic struc-ture (Naseem et al., 2010; T  X  ackstr  X  om et al., 2013; Berg-Kirkpatrick and Klein, 2010; Cohen and Smith, 2009; Duong et al., 2015).

Our work is closely related to the selective-sharing approaches (Naseem et al., 2012; T  X  ackstr  X  om et al., 2013). The core of these methods is the assumption that head-modifier attachment preferences are universal across different languages. However, the sharing of arc direction is selective and is based on typological features. While this selective sharing idea was first realized in the generative model (Naseem et al., 2012), higher performance was achieved in a discriminative arc-factored model (T  X  ackstr  X  om et al., 2013). These gains were obtained by a careful construction of features templates that combine standard dependency parsing features and typological features. In contrast, we propose an automated, tensor-based approach that can effectively capture the interaction between these features, yielding a richer representation for cross-lingual transfer. Moreover, our model handles labeled dependency parsing while previous work only focused on the unlabeled dependency parsing task.
 Tensor-based Models Our approach also relates to prior work on tensor-based modeling. Lei et al. (2014) employ three-way tensors to obtain a low-dimensional input representation optimized for parsing performance. Srikumar and Manning (2014) learn a multi-class label embedding tai-lored for document classification and POS tag-ging in the tensor framework. Yu and Dredze (2015), Fried et al. (2015) apply low-rank ten-sor decompositions to learn task-specific word and phrase embeddings. Other applications of tensor framework include low-rank regularization (Pri-madhanty et al., 2015; Quattoni et al., 2014; Singh et al., 2015) and neural tensor networks (Socher et ,  X  Figure 1: Visual representation for traditional mul-tiway tensor. al., 2013; Yu et al., 2013a). While these methods can automatically combine atomic features into a compact composite representation, they cannot take into account constraints on feature combina-tion. In contrast, our method can capture features at different composition levels, and more gener-ally can incorporate structural constraints based on prior knowledge. As our experiments show, this approach delivers higher transfer accuracy. 3.1 Background We start by briefly reviewing the traditional three-way tensor scoring function (Lei et al., 2014). The three-way tensor characterizes each arc h  X  m using the tensor-product over three feature vec-tors: the head vector (  X  h  X  R n ), the modifier vec-tor (  X  m  X  R n ) and the arc vector (  X  h  X  m  X  R l ).  X  h captures atomic features associated with the head, such as its POS tag and its word form. Simi-larly,  X  m and  X  h  X  m capture atomic features asso-ciated with the modifier and the arc respectively. The tensor-product of these three vectors is a rank-1 tensor: This rank-1 tensor captures all possible combina-tions of the atomic features in each vector, and therefore significantly expands the feature set. The tensor score is the inner product between a three-feature tensor: where vec (  X  ) denotes the vector representation of a tensor. This tensor scoring method avoids the pa-rameter explosion and overfitting problem by as-suming a low-rank factorization of the parameters Figure 2: Visual representation for hierarchical tensor, represented as a tree structure. The ten-sor first captures the low-level interaction ( H X  h , M X  m and D X  d ) by an element-wise product, and then combines the intermediate embedding with other components higher in the hierarchy, e.g. e 2 and L X  l . The equations show that we composite two representations by an element-wise sum.
 A . Specifically, A is decomposed into the sum of r rank-1 components: and W  X  R r  X  l are parameter matrices. U ( i ) de-notes the i -th row of matrix U and similarly for V ( i ) and W ( i ) . Figure 1 shows the representation of a more general multiway factorization. With this factorization, the model effectively alleviates the feature explosion problem by projecting sparse feature vectors into dense r -dimensional embed-dings via U , V and W . Subsequently, the score is computed as follows: S where [  X  ] i denotes the i -th element of the matrix.
In multilingual transfer, however, we want to incorporate typological features that do not fit in any of the components. For example, if we add the verb-subject ordering preference into  X  h  X  m , the tensor will represent the concatenation of this preference with a noun-adjective arc, even though this feature should never trigger. 3.2 Hierarchical Low-rank Tensor To address this issue, we propose the hierarchi-idea is to generate intermediate embeddings that capture the interaction of the same set of atomic features as other expert-defined features. As Fig-ure 2 shows, this design enables the model to han-dle expert-defined features over various subsets of the atomic features.

Now, we will illustrate this idea in the context of multilingual parsing. Table 2 summarizes the no-tations of the feature vectors and the correspond-ing parameters. Specifically, for each arc h  X  m with label l , we first compute the intermediate fea-ture embedding e 1 that captures the interaction be-tween the head  X  h , the modifier  X  m and the arc direction and length  X  d , by an element-wise prod-uct. where [  X  ] i denotes the i -th value of the feature em-bedding, and H , M and D are the parameter ma-trices as in Table 2. The embedding e 1 cap-tures the unconstrained interaction over the head , the modifier and the arc . Note that  X  t expert-defined typological features that rely on the specific values of the head POS, the modifier POS and the arc direction, such as the example noun-adjective feature in Table 1. Therefore, the em-bedding T u  X  t tion over the head , the modifier and the arc . Thus e 1 and T u  X  t u provide two different representations of the same set of atomic features (e.g. the head ) and our prior knowledge motivates us to exclude the interaction between them since the low-rank assumption would not apply. Thus, we combine e 1 and T u  X  t u as e 2 using an element-wise sum and thereby avoid such combinations. As Fig-ure 2 shows, e 2 in turn is used to capture the higher level interaction with arc label features  X  l , Now e 3 captures the interaction between head, modifier, arc direction, length and label. It is over the same set of atomic features as the typological features that depend on arc labels  X  t example verb-subject ordering feature in Table 1. Therefore, we sum over these embeddings as
Finally, we capture the interaction between e 4 and context feature embeddings H c  X  h c and Notation Description H, X  h M, X  m D, X  d Arc length and direction L, X  l Arc label Table 2: Notations and descriptions of parame-ter matrices and feature vectors in our hierarchical tensor model.
 M c  X  m c and compute the tensor score as
By combining Equation 1 to 5, we observe that our hierarchical tensor score decomposes into three multiway tensor scoring functions.
 S = +[ H c  X  h +[ H c  X  h
This decomposition provides another view of our tensor model. That is, our hierarchical tensor is algebraically equivalent to the sum of three mul-tiway tensors, where H c , M c and L are shared. 3 From this perspective, we can see that our tensor model effectively captures the following three sets of combinations over atomic features: f f f The last set of features f 3 captures the interac-tion across standard atomic features. The other two sets of features f 1 and f 2 focus on combin-ing atomic typological features with atomic label and context features. Consequently, we explicitly assign zero weights for invalid assignments, by ex-cluding the combination of  X  t 3.3 Lexicalization Components In order to encode lexical information in our tensor-based model, we add two additional com-ponents, H w  X  h ifier lexicalization respectively. We compute the final score as the interaction between the delexi-calized feature embedding in Equation 5 and the lexical components. Specifically: [ e
S where e 5 is the embedding that represents the delexicalized transfer results. We describe the fea-tures in  X  h 3.4 Combined Scoring Similar to previous work on low-rank tensor scor-ing models (Lei et al., 2014; Lei et al., 2015), we combine the traditional scoring and the low-rank tensor scoring. More formally, for a sentence x and a dependency tree y , our final scoring func-tion has the form S ( x , y ) =  X  where  X  ( h l  X  X  X  m ) is the traditional features for arc h  X  m with label l and w is the correspond-ing parameter vector.  X   X  [0 , 1] is the balanc-ing hyper-parameter and we tune the value on the development set. The parameters in our model are  X  = ( w ,H,M,D,L,T u ,T l ,H c ,M c ) , and our goal is to optimize all parameters given the train-ing set. Following standard practice, we optimize the pa-rameters  X  = ( w ,H,M,D,L,T u ,T l ,H c ,M c ) in a maximum soft-margin framework, using online passive-aggressive (PA) updates (Crammer et al., 2006).

For tensor parameter update, we employ the joint update method originally used by Lei et al. (2015) in the context of four-way tensors. While our tensor has a very high order (8 components for the delexicalized parser and 10 for the lexicalized parser) and is hierarchical, the gradient computa-tion is nevertheless similar to that of traditional tensors. As described in Section 3.2, we can view our hierarchical tensor as the combination of three multiway tensors with parameter sharing. There-fore, we can compute the gradient of each mul-tiway tensor and take the sum accordingly. For example, the gradient of the label component is  X  X  = where is the element-wise product and + de-notes the element-wise addition. y  X  and  X y are the gold tree and the maximum violated tree respec-tively. For each sentence x , we find  X y via cost-augmented decoding.
 Tensor Initialization Given the high tensor or-der, initialization has a significant impact on the learning quality. We extend the previous power method for high-order tensor initialization (Lei et al., 2015) to the hierarchical structure using the al-gebraic view as in computing the gradient.

Briefly, the power method incrementally com-putes the most important rank-1 component for H ( i ) , M ( i ) etc, for i = 1 ...r . In each iteration, the algorithm updates each component by taking the multiplication between the tensor T and the rest of the components. When we update the label component l , we do the multiplication for different
Feature Description 82A Order of Subject and Verb 83A Order of Object and Verb 85A Order of Adposition and Noun Phrase 86A Order of Genitive and Noun 87A Order of Adjective and Noun Table 3: Typological features from WALS (Dryer et al., 2005) used to build the feature tem-plates in our work, inspired by Naseem et al. (2012). Unlike previous work (Naseem et al., 2012; T  X  ackstr  X  om et al., 2013), we use 82A and 83A instead of 81A (order of subject, object and verb) because we can distinguish between subject and object relations based on dependency labels. multiway tensors and then take the sum. l =  X  T 0 ,h c ,m c ,  X  ,t u  X  +  X  T 1 ,h c ,m c ,  X  ,h,m,d  X  where the operator  X  T 0 ,h c ,m c ,  X  ,t u  X  returns a vector in which the i -th element is computed as P rithm updates other components in a similar fash-ion until convergence. Linear Scoring Features Our traditional lin-ear scoring features in  X  ( h l  X  X  X  m ) are mainly drawn from previous work (T  X  ackstr  X  om et al., 2013). Table 3 lists the typological features from  X  X he World Atlas of Language Structure (WALS) X  (Dryer et al., 2005) used to build the fea-ture templates in our work. We use 82A and 83A for verb-subject and verb-object order respectively because we can distinguish between these two re-lations based on dependency labels. Table 4 sum-marizes the typological feature templates we use. In addition, we expand features with dependency labels to enable labeled dependency parsing. Tensor Scoring Features For our tensor model, feature vectors listed in Table 2 capture the five types of atomic features as follows: (a)  X  h , X  m : POS tags of the head or the modifier. (b)  X  h (c)  X  l : dependency labels. (d)  X  d : dependency length conjoined with direc-(e)  X  t  X   X  Table 4: Typological feature templates used in our work. hp/mp are POS tags of the head/modifier. dir  X  { LEFT , RIGHT } denotes the arc direction. 82A-87A denote the WALS typological feature value.  X  (  X  ) is the indicator function. subj  X  l denotes that the arc label l indicates a subject rela-tion, and similarly for obj  X  l .
 We further conjoin atomic features (b) and (d) with the family and the typological class of the lan-guage, because the arc direction and the word or-der distribution depends on the typological prop-erty of languages (T  X  ackstr  X  om et al., 2013). We also add a bias term into each feature vector. Partial Lexicalization We utilize multilingual word embeddings to incorporate partial lexical information in our model. We use the CCA method (Faruqui and Dyer, 2014) to generate multilingual word embeddings. Specifically, we project word vectors in each non-English language to the English embedding space. To reduce the noise from the automatic projection process, we only incorporate lexical information for the top-100 most frequent words in the following closed classes: pronoun, determiner, adposition, conjunc-tion, particle and punctuation mark. Therefore, we
We follow previous work (Lei et al., 2014) for adding embedding features. For the linear scoring model, we simply append the head and the modi-fier word embeddings after the feature vector. For the tensor-based model, we add each entry of the word embedding as a feature value into  X  h  X  m w . In addition, we add indicator features for the English translation of words because this improves performance in preliminary experiments. For ex-ample, for the German word und , we add the word and as a feature. Dataset We evaluate our model on the newly re-leased multilingual universal dependency treebank v2.0 (McDonald et al., 2013) that consists of 10 languages: English (EN), French (FR), German (DE), Indonesian (ID), Italian (IT), Japanese (JA), Korean (KO), Brazilian-Portuguese (PT), Spanish (ES) and Swedish (SV). This multilingual tree-bank is annotated with a universal POS tagset and a universal dependency label set. Therefore, this dataset is an excellent benchmark for cross-lingual transfer evaluation. For POS tags, the gold uni-versal annotation used the coarse tagset (Petrov et al., 2011) that consists of 12 tags: noun, verb, ad-jective, adverb, pronoun, determiner, adposition, numeral, conjunction, particle, punctuation mark, and a catch-all tag X. For dependency labels, the universal annotation developed the Stanford de-pendencies (De Marneffe and Manning, 2008) into a rich set of 40 labels. This universal annota-tion enables labeled dependency parsing in cross-lingual transfer.
 Evaluation Scenarios We first consider the un-supervised transfer scenario, in which we assume no target language annotations are available. Fol-lowing the standard setup, for each target language evaluated, we train our model on the concatenation of the training data in all other source languages.
In addition, we consider the semi-supervised transfer scenario, in which we assume 50 sen-tences in the target language are available with an-notation. However, we observe that random sen-tence selection of the supervised sample results in a big performance variance. Instead, we se-lect sentences that contain patterns that are absent or rare in source language treebanks. To this end, each time we greedily select the sentence that min-imizes the KL divergence between the trigram dis-tribution of the target language and the trigram dis-tribution of the training data after adding this sen-tence. The training data includes both the target and the source languages. The trigrams are based on universal POS tags. Note that our method does not require any dependency annotations. To incor-porate the new supervision, we simply add the new sentences into the original training set, weighing their impact by a factor of 10.
 Baselines We compare against different variants of our model.  X  Direct : a direct transfer baseline (McDonald et al., 2011) that uses only delexicalized features in the MSTParser (McDonald et al., 2005).  X  NT-Select : our model without the tensor com-ponent. This baseline corresponds to the prior feature-based transfer method (T  X  ackstr  X  om et al., 2013) with extensions to labeled parsing, lexi- X  Multiway : tensor-based model where typolog-ical features are added as an additional compo-nent and parameters are factorized in the multi-way structure similarly as in Figure 1.  X  Sup50 : our model trained only on the 50 sentences in the target language in the semi-supervised scenario.
 In all the experiments we incorporate partial lexi-calization for all variants of our model and we fo-cus on labeled dependency parsing.
 Supervised Upper Bound As a performance upper bound, we train the RBGParser (Lei et al., 2014), the state-of-the-art tensor-based parser, on the full target language training set. We train the Evaluation Measures Following standard prac-tices, we report unlabeled attachment score (UAS) and labeled attachment score (LAS), excluding punctuation. For all experiments, we report results on the test set and omit the development results be-cause of space.
 Experimental Details For all experiments, we use the arc-factored model and use Eisner X  X  algo-rithm (Eisner, 1996) to infer the projective Viterbi parse. We train our model and the baselines for 10 epochs. We set a strong regularization C = 0 . 001 during learning because cross-lingual transfer con-tains noise and the models can easily overfit. Other hyper-parameters are set as  X  = 0 . 3 and r = 200 (rank of the tensor). For partial lexicalization, we set the embedding dimension to 50. Table 5 and 7 summarize the results for the unsu-pervised and the semi-supervised scenarios. Aver-aged across languages, our model outperforms all Table 6: Examples of weights for feature combinations between the typological feature 87A= Adj-Noun and different types of arcs. The first row shows the weight for the valid feature (conjoined with noun  X  adjective arcs) and the rest show weights for the invalid features (conjoined with other types of arcs). the baselines in both cases. Moreover, it achieves best UAS and LAS on 7 out of 10 languages. The difference is more pronounced in the semi-supervised case. Below, we summarize our find-ings when comparing the model with the base-lines.
 Impact of Hierarchical Tensors We first ana-lyze the impact of using a hierarchical tensor by comparing against the Multiway baseline that im-plements traditional tensor model. As Table 6 shows, this model learns non-zero weights even for invalid feature combinations.

This disregard to known constraints impacts the resulting performance. In the unsupervised sce-nario, our hierarchical tensor achieves an aver-age improvement of 0.5% on UAS and 1.3% on LAS. Moreover, our model obtains better UAS on all languages and better LAS on 9 out of 10 lan-guages. This observation shows that the multi-lingual transfer consistently benefits more from a hierarchical tensor structure. In addition, we ob-serve a similar gain over this baseline in the semi-supervised scenario.
 Impact of Tensor Models To evaluate the effec-tiveness of tensor modeling in multilingual trans-fer, we compare our model against the NT-Select baseline. In the unsupervised scenario, our ten-sor model yields a 1.1% gain on UAS and a 1.5% on LAS. In the semi-supervised scenario, the im-provement is more pronounced, reaching 1.7% on UAS and 1.9% on LAS. The relative error reduc-tion almost doubles, e.g. 7.1% vs. 3.8% on UAS.
While both our model and NT-Select outper-form Direct baseline by a large margin on UAS, we observe that NT-Select achieves a slightly worse LAS than Direct. By adding a tensor com-ponent, our model outperforms both baselines on LAS, demonstrating that tensor scoring function is able to capture better labeled features for transfer comparing to Direct and NT-Select baselines. Transfer Performance in the Context of Super-vised Results To assess the contribution of mul-tilingual transfer, we compare against the Sup50 results in which we train our model only on 50 target language sentences. As Table 7 shows, our model improves UAS by 2.3% and LAS by 2.7%. We also provide a performance upper bound When trained with partial lexical information as in our model, RBGParser gives 82.9% on UAS and 74.5% on LAS with partial lexical informa-tion. By utilizing source language annotations, our model closes the performance gap between train-ing on the 50 sentences and on the full training set by about 30% on both UAS and LAS. We further compare to the performance upper bound with full lexical information (87.3% UAS and 83.5% LAS). In this case, our model still closes the performance gap by 21% on UAS and 15% on LAS.
 Time Efficiency of Hierarchical Tensors We observe that our hierarchical structure retains the time efficiency of tensor models. On the English test set, the decoding speed of our hierarchical ten-sor is close to the multiway counterpart (58.6 vs. 61.2 sentences per second), and is lower than the three-way tensor by a factor of 3.1 (184.4 sen-tences per second). The time complexity of ten-sors is linear to the number of low-rank com-ponents, and is independent of the factorization structure. In this paper, we introduce a hierarchical tensor based-model which enables us to constrain learned representation based on desired feature interac-tions. We demonstrate that our model outperforms state-of-the-art multilingual transfer parsers and traditional tensors. These observations, taken to-gether with the fact that hierarchical tensors are efficiently learnable, suggest that the approach can be useful in a broader range of parsing applica-tions; exploring the options is an appealing line of future research.
 This research is developed in a collaboration of MIT with the Arabic Language Technologies (ALT) group at Qatar Computing Research In-stitute (QCRI) within the Interactive sYstems for Answer Search (I YAS ) project. The authors ac-knowledge the support of the U.S. Army Research Office under grant number W911NF-10-1-0533. We thank the MIT NLP group and the EMNLP reviewers for their comments. Any opinions, find-ings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding orga-nizations.

