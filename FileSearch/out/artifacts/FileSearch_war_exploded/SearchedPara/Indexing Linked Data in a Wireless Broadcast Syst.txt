 Semantic technologies aim to facilitate machine-to-machine communication and are attracting more and more interest from both academia and industry, especially in the emerging Internet of Things (IoT). In this paper, we consider large-scale information sharing scenarios among mobile objects in IoT by leveraging semantic techniques. We propose to broadcast Linked Data on-air using RDF format to allow simultaneous access to the information and to achieve bet-ter scalability. We introduce a novel air indexing method to reduce the information access latency and energy consump-tion. To build air indexes, we firstly map RDF triples in the Linked Data into points in a 3D space and build B + -trees based on 3D Hilbert curve mappings for all of the 3D points. We then convert these trees into linear sequences so that they can be broadcast over a wireless channel. A novel search algorithm is also designed to efficiently evalu-ate queries against the air indexes. Experiments show that our indexing method outperforms the air indexing method based on traditional 3D R-trees.
 H.3.5 [ Information Storage and Retrieval ]: Online In-formation Services X  Data sharing Linked Data, wireless broadcast, air indexing
In the era of the Internet of Things [8], due to a large amount of information produced by all kinds of things, one of the significant challenges is how to efficiently consume the large amount of information that is generated. In this con-text, semantic technologies such as Linked Data, which aim at facilitating machine-to-machine communications, play an increasingly important role [1]. Linked Data is taking an ac-tive role in a trend towards highly distributed systems, with potentially millions of independent sources providing small amounts of structured data [9]. Event detection and entity discovery requires an effective way of information sharing. Compared with the point-to-point communication paradigm, broadcast (or point-to-multipoint ) allows simultaneous ac-cess by an arbitrary number of listeners (or clients) without causing contention of server resources [7]. Considering infor-mation sharing among a large number of mobile and smart objects in the Internet of Things, broadcast is an attractive mechanism of information dissemination.

To further illustrate the motivation, let us consider the scenario of a future smart city, where intelligent objects will be acting as data collectors in different places of the city. They will be able to sense their vicinities (e.g., for air pollu-tion information) and produce related Linked Data that is understandable by machines. These objects send such data to a nearby base station for further processing. The base station can then integrate and process all the data from var-ious data collectors and broadcast to a much wider audience such as smart objects, which are not direct data collectors but are interested in such data. Since a smart object is nor-mally only interested in a small part of the broadcast data, blindly checking every triple on air would lead to very long access latency and unnecessary energy consumption. As the batteries of smart objects are often limited, an efficient way to reduce energy consumption and lower access latency is imperative. Our work focuses on solving this challenge by designing effective and efficient air indexes for broadcasting Linked Data on air.
 Inspired by recent work on data summaries on Linked Data using RDF format [5, 9], we adopt a similar technique to index Linked Data. This is mainly because it can be used to construct very concise indexes, which is critical in sav-ing mobile clients X  energy consumption. On the server side, we firstly map the RDF triples contained in Linked Data streams into points in a 3D space and then build indexes on these 3D points. A straightforward indexing solution is to use traditional spatial indexes, such as R-tree [4], which recursively index spatial points/objects in sub-regions. How-ever, it is shown that the performance of R-tree degrades in higher dimension space [2]. Moreover, R-tree is designed for random access while, in a wireless broadcast system, indexes can only be accessed sequentially. Therefore, the R-tree ap-proach is not suitable for indexing Linked Data on air. Mo-tivated by this, we introduce a novel method by adopting 3D Hilbert curve mappings [6] for all the points converted from RDF triples. These mappings transform the 3D points into a sequence of one-dimensional points, which are suitable for e fficient sequential access on air. We also build B + -trees [3] for the one-dimensional points to facilitate point access on air. Finally, we convert these trees into linear sequences so that they can be broadcast on a wireless channel. On the client side, a novel search algorithm is designed to efficiently evaluate queries against the air indexes. The experimental results show that our indexing method outperforms the 3D R-tree based methods.
In a wireless data broadcast system, generally there is a base station that pre-processes data before it broadcasts the data on the wireless channel. If mobile clients have regis-tered an interest in some data on the server, they can listen to the wireless channel and download the data. The wireless channel can be shared by all mobile clients. In this way, the broadcast system could be able to serve an arbitrary number of mobile clients simultaneously.

In order for clients to efficiently locate data of interest, air indexing techniques are used to facilitate the searching of data on air. Air indexes are normally lightweight and concise summaries of the data to be broadcast. Based on air indexes, mobile clients within the communication range of the base station can evaluate their queries directly and then locate requested data on the wireless channel.
Similar to the existing work in data broadcast, we use access latency and tuning time as the primary performance metrics [7]. Access latency refers to the time elapsed between the moment when a query is formed and the client starts listening to the server to the moment when all requested data has been received. Tuning time refers to the period of time that a client has to stay active in order to complete a query.
Existing light weight data summaries (e.g., [5, 9]) have been proven to be effective to index Linked Data. How-ever, they are not suitable in a wireless broadcast system. In order to develop a new index structure for broadcasting Linked Data, similar to data summaries, we choose to use hash functions 1 to map RDF triples into numerical values. These numerical values can be regarded as coordinates in a 3D space. Specifically, given a hash function f , a triple (s, p, o) can be mapped into a 3D point ( f (s), f (p), f (o)) . We call such a point mapped from a triple a data point in order to differ it from other points in the 3D space. Using this approach, a set of RDF triples can be mapped into a set of 3D data points.

Basic Graph Patterns (BGPs) [9] are adopted as queries in our system. Similar to RDF triple mappings, a single BGP containing only one RDF triple pattern can be mapped into a point, a line, or a plane in a 3D space, or even the whole 3D space, depending on the number of variables in the triple pattern. The possible triple patterns in a BGP are: 1) (#s, #p, #o) , 2) (?s, #p, #o) , 3) (#s, ?p, #o) , 4) (#s, #p, ?o) , 5) (?s, ?p, #o) , 6) (?s, #p, ?o) , 7) (#s, ?p, ?o) , and 8) (?s, ?p, ?o) . Here, ? denotes a variable while #
T here are many options of hash functions. For more details, please refer to [5, 9]. (a) F igure 1: 2D Hilbert Curves of order 1 and 2. (a) H , (b) H 1 to H 2 , (c) H 2 d enotes a constant. Clearly, pattern 1 can be mapped into a 3D data point. Patterns 2 to 4 can be mapped into lines in the 3D space and patterns 5 to 7 can be mapped into planes. It should be noted that we do not consider pattern 8 in our work, as it will be mapped into the whole 3D space and require a traversal of all the data points in the whole 3D space, where air indexing is not required.
A space-filling curve in d dimensions is a continuous, sur-jective mapping between one-dimensional space and d -dimen-sional space. A Hilbert curve is an example of a space-filling curve. It generally has good locality properties [6] and can efficiently support matching against BGPs with variables that can be mapped into lines or planes. Hence, the Hilbert curve is adopted as the foundation of our indexing method. Mapping 3D points to one-dimensional points: To simplify our discussion, we use a 2D Hilbert curve to illus-trate our ideas, which can then be generalized to 3D Hilbert curves. Figure 1 shows 2D Hilbert curves for order 1 and 2, i.e., H 1 and H 2 , respectively. Note that, a k order Hilbert curve, denoted as H k , passes all center points of 2 kd subdi-viding squares (or hypercubes) in a d -dimensional space. In Figure 1(a), each center point of a subdividing square in 2D space is assigned a Hilbert value , which can be regarded as a one-dimensional point. Note that, the mapping between center points and Hilbert values are bijective, which means for a given Hilbert curve, we can freely convert between cen-ter points and Hilbert values in constant time.

From Figure 1(b), we can see that high order Hilbert curves can be easily derived using transformation from low order Hilbert curves similar to the one shown in Figure 1(b). In order to derive H 2 from H 1 , in Figure 1(b), the 2D space is divided into 2 d ( d = 2 in this case) sub-regions, where each sub-region contains an H 1 . After rotating the lower two H 1 curves, an H 2 Hilbert curve is derived (see Figure 1(c)). Since H 1 has 2 2 subdividing squares, H 2 has totally 2 2  X  2 subdividing squares.

Figure 2 presents an example of a 3D Hilbert curve of or-der 1. Higher order 3D Hilbert curves can be derived using a similar process described above. In order to accommodate a larger 3D data space, i.e., the hashing space for RDF triples, we need to utilize higher order 3D Hilbert curves. We can e asily check that a k order 3D Hilbert curve can have up to 2 3  X  k data points. In other words, when mapping to a k order 3D Hilbert curve, all RDF triples will be mapped into at most 2 3  X  k data points (also center points of hypercubes) in a 3D space.
 Indexing one-dimensional points on air: After map-ping 3D points into one-dimensional points using 3D Hilbert curves, we can utilize B + -trees to index one-dimensional points on a 3D Hilbert curve. An example is depicted in Fig-ure 3. Each one-dimensional point in the leaf nodes contains a pointer to a real triple that will be broadcast on the wire-less channel. Such B + -trees can be serialized and broadcast on the linear wireless channel as air indexes for the Linked Data on air in the form of data packets. We adjust the fan-out of a B + -tree according to the packet capacity of the wireless channel so that a complete node of a B + -tree can fit in a packet. After downloading a part (e.g., a few packets) of an air index, mobile clients can then evaluate their queries (i.e., BGPs) against the partial index, determine which re-maining index packets should be further retrieved, and fi-nally compute the broadcast time of matched triples after all necessary index information has been acquired. Evaluating queries against an air index: In the query evaluation process, one challenging issue is how to match a one-dimensional point against BGPs. As mentioned previ-ously, BGPs could be mapped into a point, a line or a plane in a 3D space. In order to match BGPs with data points in the 3D space, we need to transform one-dimensional points in B + -tree based air indexes into 3D points. We then exam-ine whether such 3D points fall into the subspace defined by a BGP. If yes, RDF triples pointed to by these points match the BGP. Otherwise, they do not match.
 Query evaluation example: We give an example of the query evaluation process in the following. Suppose a triple (a, b, c) can be hashed as (112, 31, 92) in a 3D space and its Hilbert value is 1137. Also suppose a mobile client issues a BGP (a, b, ?o) . This BGP can be converted into a 3D line (112, 31, ?) . After receiving Hilbert value 1137 from the air index, the mobile client firstly converts it back into a 3D point (112, 31, 92) and then it finds that this point falls on the 3D line defined by its BGP. Then the client knows the triple pointed to by Hilbert value 1137 is of its interest. As mentioned earlier, the conversion between a Hilbert value and a 3D point can be calculated in constant time given a Hilbert curve of order k (here, k is a constant). Reducing search space: One issue needs to be addressed in the above query evaluation process: how to reduce the search space of Hilbert values indexed by B + -trees, thereby leading to fewer index packets required to download for a query evaluation. Given an air index like the one shown in Figure 3, the root node has three child nodes. Based on the Hilbert values in the root node, we need to determine which child node would contain triples that may match a given BGP. We observe that each child node contains multi-ple Hilbert values and the range of these values can be easily computed from the root node. For example, the value ranges of the three child nodes are [0 , 8), [8 , 12) and [12 , h (here h max refers to the maximum Hilbert value of a Hilbert curve). For each value range, we have two bounding Hilbert values. Figure 3: B + -tree for some Points on Hilbert Curve
T o reduce the search space, we compute the minimal sub-region defined by a lower order Hilbert curve that covers the range defined by both bounding Hilbert values (see Figure 4, where two dash lines represent two BGPs). If such minimal sub-region intersects with sub-space (i.e., a line) defined by a BGP, the child node with the value range may contain triples that match that BGP. Otherwise, no triples in the child node will match that BGP. The example shown in Figure 4 illustrates a minimal sub-region for the value range [8 , 12). We can see that two BGPs that are represented as two dash lines have no intersections with it. So we can infer that no triples pointed to by the second child node (triples whose Hilbert values are 8, 9, and 11) in Figure 3 will match the two BGPs shown as two dash lines in Figure 4.
The data set used in our experiment is a subset of the cur-rent version of the English DBpedia 2 . It contains resources of type dbpedia-owl:Event . Each event is a triple of the form &lt;eventURI, rdf:type, dbpedia-owl:Event&gt; . An ex-ample of an event URI is &lt; http://dbpedia.org/resource/ Battle_of_Brentford_(1642) &gt; . There are approximately 400,100 triples in the dataset.

As an initial work, we used simple BGPs as queries in the experiment and we leave extending our system to support complex BGPs or join queries as our future work. We ran-domly generated BGPs using the seven patterns mentioned in Section 2 based on our dataset. We generated 100,000 queries and reported the average experimental results.
We compared our B + -tree HC (Hilbert Curve) indexes with traditional R-tree indexes which can be used to index 3D points directly. In the experiment, we varied the packet capacity of the wireless broadcast channel from 128 bytes to 2048 bytes. For each packet capacity setting, we assigned appropriate fan out and leaf order parameters for R-trees and B + -trees to ensure that each packet was able to accom-modate a complete node of a tree. h ttp://downloads.dbpedia.org/3.8/en/
Figure 5 shows the results of average access latency and tuning time under different packet capacities. From Figure 5(a), we can see that the access latency for our Hilbert Curve (HC) based method is slightly better than the R-tree based method. The reason is that the index size is much smaller than the content (Linked Data stream) on air and hence the dominant factor of access latency is the content but not the index. Nevertheless, the size of HC based index is smaller (see also Figure 6(b)) than R-tree based method, resulting in lower access latency.
 Figure 5(b) shows the comparisons of the tuning time. From the figure, we can clearly identify that HC based in-dex outperforms R-tree based index. The reason for this is two-fold: firstly, by using our novel search algorithm, the searching space of the HC based index is smaller than the R-tree based index; secondly, the size of each index entry for the HC based index is smaller than the R-tree based index. This result confirms the effectiveness and efficiency of our search algorithm and HC based indexing technique.
The percentage of index tuning time is presented in Fig-ure 6(a). Here, we define the percentage of index tuning time as the ratio between the index tuning time (caused by downloading necessary parts of the index on air) and the total tuning time (the sum of index tuning time and content tuning time). This metric is a good indicator for the effec-tiveness and efficiency of an index. The lower percentage we get, the better effectiveness we can achieve. Figure 6(a) shows that the HC-based index has a much lower percentage of index tuning time when compared with the R-tree based index. To be specific, the percentage of index tuning time of the HC-based index is below 20% under different packet capacities while that of the R-tree based index is above 60%.
The index sizes are compared in Figure 6(b). We can see that the number of packets required to accommodate the whole index for HC based index is only about half of that for R-tree based index. The main reason is that R-tree index has to store 3D points in its nodes while the HC based index only stores one-dimensional points.
In this paper, we have proposed an effective and efficient air indexing method for broadcasting Linked Data on air, which can be used in data sharing among a large num-ber of mobile and smart objects in the era of Internet of Things. Our method is based on 3D Hilbert curve map-pings. Firstly we map RDF triples into points in a 3D space and then adopt 3D Hilbert curve mappings to convert all the 3D points into one-dimensional points. We build B + -trees upon these one-dimensional points and serialize these trees in order to accommodate them on the linear wireless chan-nels. An efficient search algorithm has also been devised to facilitate query processing over the Linked Data on air. We have conducted experiments and compared our method with the traditional R-tree based spatial indexing method. Our method has shown better performance over the R-tree based method in various aspects, including access latency, tuning time, and index size.

In the future, we are going to extend our work to support join queries and to investigate the scalability of our method in terms of real-time construction of air indexes for broad-casting Linked Data streams with high stream rates, which we believe would be a challenging issue in the context of Internet of Things. [1] P. M. Barnaghi, W. Wang, C. A. Henson, and [2] S. Berchtold, D. A. Keim, and H.-P. Kriegel. The [3] D. Comer. The Ubiquitous B-Tree. ACM Computing [4] A. Guttman. R-Trees: A Dynamic Index Structure for [5] A. Harth, K. Hose, M. Karnstedt, A. Polleres, K.-U. [6] H. J. Haverkort. An Inventory of Three-dimensional [7] T. Imielinski, S. Viswanathan, and B. R. Badrinath. [8] Y. Qin, Q. Z. Sheng, N. J. G. Falkner, S. Dustdar, [9] J. Umbrich, K. Hose, M. Karnstedt, A. Harth, and
