 } @tsinghua.edu.cn; tankl@comp.nus.edu.sg Many real-world applications have requirements to support moving spatial keyword queries. For example a tourist look-sfortop-k  X  seafood restaurants  X  while walking in a city. She will continuously issue moving queries. However exist-ing spatial keyword search methods focus on static queries and it calls for new effective techniques to support mov-ing queries efficiently. In this paper we propose an effective method to support moving top-k spatial keyword queries. In addition to finding top-k answers of a moving query, we also calculate a safe region such that if a new query with a location falling in the safe region, we can directly use the answer set to answer the query. To this end, we propose an effective model to represent the safe region and devise efficient search algorithms to compute the safe region. We have implemented our method and experimental results on real datasets show that our method achieves high efficiency and outperforms existing methods significantly.
 H.2.8 [ Database Applications ]: Spatial databases Algorithms, Design, Experimentation, Performance Moving Top-k Spatial Keyword Queries, Safe Region
Location based services (LBS) have attracted significant attention from both industry and academic communities in recent years, thanks to the modern mobile phones and new Internet technologies. Many existing systems provide users with location-aware search experiences based on users X  loca-tion which can be easily gotten from GPS devices equipped in modern mobile phones.

Recently there are many studies on location based services and most of them address the spatial keyword search prob-lem [9, 4, 2, 7], which, given a set of spatio-textual objects with a location and textual description (e.g., points of inter-est and geo-tagged documents) and a top-k spatial keyword query with a location and a set of keywords, finds top-k rele-vant answers. However they focus primarily on static queries and cannot support moving queries efficiently. Notice that many real-world applications have requirements to support moving spatial keyword queries. For example, a housewife is driving to a supermarket and may want to find the top-3 X  car parking places  X  near the supermarket. Since she is driving, her query location is continuously changing. As another example, a tourist looking for the top-2  X  seafood restaurants  X  while walking in a city will require a moving query. Although we can extend existing methods to support moving queries by repeatedly issuing multiple queries, these methods have the following limitations. First, it increases the communication cost between the client (the user who is-sues the query) and the server (the system that provides the search service), and also wastes the bandwidth in transmis-sion. Second, it aggravates the system burden due to issuing multiple repeated queries.

To address this problem, in this paper we emphasize on efficiently supporting moving top-k spatial keyword queries. We adopt a client-server model. The client is moving and continuously issues a spatial keyword query to the server. The server returns the top-k answers of the query, as well as a safe region of the answer set (We will formally define the safe region in Section 2). Then before the client issues a new query at another location, it will first check whether the new location is still in the safe region .Ifyes,itcan reuse the answer set; otherwise the client needs to issue a query with the new location to the server. Obviously our method not only avoids unnecessary communication cost but also reduces the system burden. Notice that although Wu et al. [17] studied the moving top-k spatial keyword query, they used an ad-hoc ranking function (see Section 2). In contrast, we use a widely adopted ranking function [2, 11].
Different from existing studies [2, 4] which focus on com-puting the answer set of a query, we emphasize on how to compute the safe region. There are several research chal-lenges. First, how to represent the safe region? Tradition-al studies on spatial data (without textual description) use Voronoi diagrams to represent the safe region, which can be pre-computed and materialized for efficient online query processing. However safe region in our problem depends on query keywords and cannot be materialized. To address this issue, we propose an effective representation model in Section 3. Second, how to compute the safe region? For a query issued to the server, we need to find its answer set and compute the safe region simultaneously. Thus the time for computing the safe region cannot be large. To address this issue, we develop efficient algorithms in Section 4. To summarize, we make the following contributions.
The rest of the paper is organized as follows. We first formulate our problem in Section 2. A model to represent the safe region is discussed in Section 3. We devise efficient algorithms to compute the safe region in Section 4. Section 5 extends our techniques to support moving top-k queries. We conduct experimental results in Section 6 and review related work in Section 7. Section 8 concludes the paper.
We adopt a client-server model. The server contains a set of spatio-textual objects, O .Eachobject o  X  O contains a location o s and textual description o t , denoted by o =( o o ). In the paper we consider two-dimensional space, and use x -coordinate o s .x and y -coordination o s .y to denote a location o s . We use a set of terms to denote o t . The client is moving and continuously issues a top-k spatial keyword query q to the server. Query q consists of a query location q , a set of keywords q t , and an integer k to restrict the result size, denoted by q =( q s ,q t ,k ). For ease of presentation, we first define the answer of a top-k spatial keyword query.
Definition 1 (Top-k Spatial Keyword Query). Given an object set O and a query q , the answer of a top-k spatial keyword query is a subset of O , A , such that (1) The size of A is k , i.e., |A| = k ,and (2)  X  o  X   X  X  ,  X  o  X  O  X  X  , score ( q,o  X  )  X  score ( q,o ) , where score is a ranking function to evaluate the relevance between a query and an object. The smaller the value is, the more relevant is the object to the query. We will define the ranking function in Section 2.2.
 For example, there is a dataset O as shown in Figure 1 and atop-k spatial keyword query q = ((0 . 515 , 0 . 294) , { restarant } , 1 ). We can get A = { o 4 } under the ranking function defined in Section 2.2. If k = 2 with the same q and q t , then the answer set A = { o 4 ,o 9 } .

For a moving top-k spatial keyword query q , in addition to finding the answer set A , we also need to find a safe region for query q . Note that the safe region depends on the keyword set q t and k , and we denote it by R ( q t ,k ). For a query q =( q s ,q t ,k ) with a new location q s ,if q s  X  X  the answer set of q isthesameasthatof q .Thuswecan use the answer set A to answer q .Ifthecontextisclear, R ( q t ,k )and R are used interchangeably. Next we formally define the safe region R .

Definition 2 (Safe Region). Given an object set O and a query q , the safe region of query q is R = { q s | X  o  X   X  X  ,  X  o  X  O  X  X  , score ( q ,o  X  )  X  score ( q ,o ) Figure 1: Dataset( k 1 : Chinese , k 2 : Franch , k 3 : restarant , k : seafood , k 5 : pastry , numbers in brackets are tf ) where q =( q s ,q t ,k )and q s is any location.

For example, in Figure 1, the shadow region in the center is the safe region for q t = { Chinese , restarant } and k =1.
Then based on the answer set A and the safe region R ,we define the answer of a moving top-k spatial keyword query. Definition 3. (Moving Top-k Spatial Keyword Query) Given an object set O and a moving top-k spatial keyword query q =( q s ,q t ,k ) . As the query is moving, for each new location q s , its answer is A , R ,where A is the top-k result set of q =( q s ,q t ,k ) and R is the corresponding safe region.
In the client-server model, for a query q , the client first checks whether q s  X  X  .Ifyes, A is the answer of query q ; otherwise the client submits the query q to the server which returns the answer set and the safe region of the query. In our example in Figure 1, the server will return the answer set A = { o 4 } and a safe region R (shaded in the Figure). Next the client updates its location and checks whether it is still in
R .Ifyes, { o 4 } is still the answer; otherwise the answer changes and the client issues a new query to the server.
Existing studies [2] focus on top-k spatial keyword queries and they propose efficient algorithms to compute the answer set A . In this paper we emphasize on how to compute the safe region R and address the research challenges as dis-cussed in Section 1.
Given a query q and an object o , to compute their rank-ing score score ( q,o ), we combine their spatial proximity be-tween o s and q s , denoted by dist ( o s , q s ), and their textual relevancy between o t and q t , denoted by text ( o t , q ranking function is defined as follows. score ( q,o )=  X   X  dist ( q s ,o s )+(1  X   X  )  X  (1  X  text ( q where  X  is a tuning parameter to trade-off the importance between the spatial distance and textual relevancy. Notice that in the ranking function, we normalize dist ( q s , o text ( q t , o t )to[0 , 1] using their possible maximum values. In the paper, we use the Euclidean distance (function dist )to compute the spatial distance ( dist ) between two locations, and adopt the well-known TFIDF function to evaluate the textual relevancy ( text ) as follows. where tf ( t, o t ) is the term frequency of term t in o t idf ( t ) is the inverse document frequency of term t , i.e., the ratio of the number of objects in O to that of objects whose textual descriptions contain t . For ease of presentation, if dist ( q t , o t )and dist ( q , o ) interchangeably.
For the example in Figure 1, assume  X  = 2 3 . dist ( q,o 1 0 . 49, text ( q,o 1 )=0 . 1, and score ( q,o 1 )=0 . 63; dist ( q,o 0 . 21, text ( q,o 4 )=0 . 75 and score ( q,o 4 )=0 . 22; dist ( q,o 0 . 27, text ( q,o 9 )=0 . 85 and score ( q,o 9 )=0 . 23. The top-1 answer is { o 4 } and the top-2 answer is { o 4 ,o 9 } .
Notice that our ranking function is widely adopted in ex-isting studies [2, 11]. Although Wu et al. [17] studied the moving top-k spatial keyword query problem, they used a very ad-hoc ranking function as defined below.
Obviously our ranking function is more general. We will discuss how to support their ranking function and experi-mentally compare with their method in Section 6.
In this section, we first introduce a concept dominant re-gion in Section 3.1, and then based on the definition we discuss how to represent the safe region in Section 3.2.
Given a query q and two objects, o  X  and o ,the dominant region of o  X  to o is a region such that if q is in the region, o is a better answer than o , as defined below.

Definition 4. Given a query q =( q s ,q t ,k ) , the domi-nant region of o  X  to o is: where q =( q s ,q t ,k ).

For example, in Figure 1, the dominant region of o 4 to o is the region outside the dashed line. That is if a query q is in the region, o 4 is a better answer than o 6 .
 Next we deduce how to represent the dominant region. We first introduce two notations.
 Based on Equation 1, score ( q ,o  X  )  X  score ( q ,o )ifandonly if  X  d  X   X  t .Thuswehave D o  X  ,o = { q s |  X  d  X   X  t } , according to Definition 4. Based on the relationship between  X  t and dist ( o  X  , o ), we can determine the shape of the dominant region as follows (also shown in Table 1 and Figure 2). Case 1:  X  t  X  dist ( o  X  ,o ). Based on the triangle inequal-ity,  X  d = dist ( q ,o  X  )  X  dist ( q ,o )  X  dist ( o  X  ,o ). If  X  t dist ( o  X  ,o ),  X  d  X   X  t is always true, thus the dominant re-gion is the whole plane.
 Case 2:  X  t&lt;  X  dist ( o  X  ,o ). Based on the triangle in-equality,  X  dist ( o  X  ,o )  X   X  d = dist ( q ,o  X  )  X  dist ( q ,o ). If  X  t&lt;  X  dist ( o  X  ,o ),  X  d  X   X  t is always false, thus the dominant region is empty.
 Case 3:  X  t =  X  dist ( o  X  ,o ). Based on Case 2, only the points on the half-line starting from o  X  andwithdirection from o to o  X  (denoted by H o  X  ,  X  X  X  oo  X  )satisfy  X  dist ( o (a) -dist ( o  X  ,o ) &lt;  X  t&lt; 0 (b) 0 &lt;  X  t&lt; dist ( o  X  d  X   X  t =  X  dist ( o  X  ,o ), thus the dominant region is half-Case 4:  X  t = 0. Obviously the locus of  X  d =0isthe perpendicular bisector of segment o  X  o which partitions the space into two half planes. The dominant region for  X  d  X   X  t is the half plane that contains o  X  .
 Case 5: 0 &lt;  X  t&lt; dist ( o  X  ,o ). The locus of points satisfy-ing |  X  d | = | dist ( q,o  X  )  X  dist ( q,o ) | = |  X  t | with o  X  and o as its two focuses as proved in Lemma 1. Let H denote the hyperbola satisfying |  X  d | = |  X  t | , H o  X  denote the branch nearby the focus o  X  (i.e., satisfying  X  d =  X  and H o denote the branch nearby the focus o (i.e., satisfying  X  d = X  t ). L  X  is the perpendicular bisector of segment o L  X  , H o  X  , H o divide the plane into four regions I,II,III,IV , as shown in Figure 2. Obviously in this case, the dominant region for  X  d  X   X  t is the region outside H o (i.e., region II  X  III  X  IV in Figure 2).
 Case 6:  X  dist ( o  X  ,o ) &lt;  X  t&lt; 0. Similar to Case 5, the dominant region for  X  d  X   X  t is the region inside H o  X  (i.e., region IV in Figure 2).

Lemma 1. If 0 &lt;  X  t&lt; dist ( o  X  ,o ) or  X  dist ( o  X   X  t&lt; 0 , the locus of points satisfying |  X  d | = |  X  t perbola with o  X  and o as its two focuses. The locus of points satisfying  X  d = X  t is the branch H o and that for  X  d =  X  is the branch H o  X  .
 Proof. Due to space constraints, we omit all proofs.
As illustrated in Figure 2, H is the hyperbola derived from o  X  and o . m is the the center of H , i.e., the midpoint of segment o  X  o . Next we give the basic parameters and their values of hyperbola H .
 Focuses : o  X  and o .
 Vertices : The two nearest points located at the two branch-Semi-focal Length : The distance from one focus to the Semi-major Length : The distance from one vertex to Eccentricity : The parameter determines the shape of a In this section, we discuss how to represent the safe region. Given a query q , suppose its top-1 answer is o  X  . Based on the definition of the dominant region, obviously the safe region is the intersection of the dominant region of o  X  to all other objects, i.e., R =  X  o = o  X  D o  X  ,o as formalized in Lemma 2.
Lemma 2. Given a query q , suppose its top-1 answer is o
In this way, after finding the top-1 answer o  X  , we compute the dominant region of o  X  to each object o  X  O  X  X  o  X  } . Then we compute the intersection of these dominant regions. Notice that the safe region is always not empty and q s is in R as formalized in Lemma 3.

Lemma 3. For a query q , the safe region R is always not empty and q s is in R .

Some readers may find that in Case 3 ( X  t&lt;  X  dist ( o  X  the dominant region is empty. Interestingly, we can prove that for the best answer o  X  , there is no such case, that is,  X  t  X  X  X  dist ( o  X  ,o ).

Lemma 4. Given a query q and its best answer o  X  ,for any object o  X  O  X  X  o  X  } ,  X  t  X  X  X  dist ( o  X  ,o ) .
Next we discuss how to represent the safe region. Recall the different shapes of the dominant regions. It is easy to represent planes, half-planes, and half-lines. However it is not easy to represent a hyperbola. A hyperbola is a type of conic section. In a Cartesian coordinate system, it is usual-ly represented by a second-degree polynomial or a matrix. However it is very expensive to use such methods and it is also inefficient to compute the intersection. To address this issue, we introduce two alternative methods.
 Using Polygons to Approximate a Hyperbola: Since the distance between a hyperbola and its asymptotes tends to 0 when they approach infinity, we can use asymptotes to approximate hyperbola.
 For the dominant region inside H o  X  (the shaded region in Figure 2(a)), consider the two half-lines starting from the Let H a o  X  denote the region inside the two half-lines (the shad-ed polygon region in Figure 2(a)). Obviously H a o  X  is in the dominant region and we use it to approximate the region (the shaded region in Figure 2(b)), consider the two half-lines starting from the center m with directions the same as the two asymptotes. Let H a o denote the region outside the two half-lines (the shaded polygon region in Figure 2(b)). Obviously H a o is in the dominant region and we use it to approximate the region outside H o .
 Using Polar Coordinates to Denote Hyperbola: We propose to use the polar coordinate to represent a hyperbola. Consider two objects o and o  X  . Suppose the corresponding dominant region D o  X  ,o is a hyperbola, denoted by H .Let H  X  ( H o ) denote the branch nearby o  X  ( o ). Let l + d and l denote the two directrices. We construct a coordinate sys-tem where the origin is the midpoint between o and o  X  ,and the x -axisisthelinepassing o and o  X  ,the y -axis is the perpendicular bisector of segment between o  X  and o .The distance from l + d ( l  X  d )to y -axis is a e (  X  a e ).
Consider any point p in branch H o  X  .Let d = dist ( p, l denote the distance from p to directrix l + d and r = dist ( p, o ). as discussed in Section 3.1. Let  X  denote the angle between  X  X  X  o p and x -axis. We have p.x = r  X  cos  X  + c .As d = p.x  X  a deduce that where  X  arccos( 1 e )  X   X   X  arccos( 1 e ).

In this way, we can use this polar coordinate representa-where  X   X  arccos( 1 e )  X   X   X   X  + arccos( 1 e ).

Similarly we can also use the polar coordinate to represent the plane, half-planes, and half-lines. The key to use polar coordinate to represent plane, half-planes or half-lines is to use it to represent lines. Considering line s , we draw its perpendicular s  X  from o  X  . s and s  X  intersect at f . For any point p on s , the distance from o  X  to p can be represented as r = dist ( o  X  ,f ) cos  X  ,where  X  is the angle between lines o o f . Note that we need to transfer the coordinate. In the polar coordinate, the new origin is o  X  . For all other objects, the origin is always o  X  . We need to prove that o  X  is in
Lemma 5. Given a query q ,if o  X  is the best answer, the location of o  X  must be in the safe region R .

To compute the intersection among multiple polar equa-tions, we use a piecewise function in a polar coordinate with the origin of o  X  . The safe region can be represented by f (  X  )[  X  1  X   X &lt; X  2 ] ,f 2 (  X  )[  X  2  X   X &lt; X  3 ] ,  X  X  X 
In this section we study how to calculate the safe region.
A naive method to compute the safe region is to first calcu-late the dominant regions of o  X  to all other objects and then compute their intersection. To improve the performance, we propose an effective pruning technique. The basic idea is as follows. Consider two objects o i and o j .If D o  X  D D  X  ,o i . Notice that it is usually hard to determine whether D  X  ,o i  X  D o  X  ,o j . To utilize this idea, we propose an alterna-tive method. Consider a region R  X  X  . For any object o , if
R  X  D o  X  ,o ,wecanpruneobject o since R X  X   X  D o  X  ,o and object o will not affect the safe region.

To achieve our goal, there are two challenges. The first one is how to find such R . The second one is how to check whether R  X  D o  X  ,o . To address the first challenge, we propose an incremental computation method. First, we ini-tialize the safe region R as the minimum bounding rect-angle of all points. Next for each object o , we compute D  X  ,o .If R  X  D o  X  ,o , we prune object o ; otherwise we up-date R = R  X  D o  X  ,o .

Next we discuss how to check R  X  D o  X  ,o . We introduce two functions. As o  X   X  X  ,let d max = MaxBD ( o  X  , R )denote the maximum distance from o  X  to any point in R .Given an object o ,let d min ( o )= MinBD ( o  X  ,D o  X  ,o ) denote the min-imum distance from o  X  to the boundary of D o  X  ,o . Notice that if d min ( o )  X  d max ,wehave R  X  D o  X  ,o as formalized in Lemma 6, and thus we can prune object o .

Lemma 6. Given a region R  X  X  and object o ,if d min ( o ) d
Given an object o , next we discuss how to compute the function d min ( o )= MinBD ( o  X  ,D o  X  ,o ).
 Case 1:  X  t  X  dist ( o  X  ,o ). D o  X  ,o is the whole plane, and ary of the plane; Case 2: 0 &lt;  X  t&lt; dist ( o  X  ,o ). d min ( o ) is the distance from o  X  to the left vertex and MinBD ( o  X  ,D o  X  ,o )= c + a = Case 3:  X  t =0. D o  X  ,o is a half-plane, and MinBD ( o  X  is Case 4:  X  dist ( o  X  ,o ) &lt;  X  t&lt; 0. d min ( o ) is the distance from o  X  to the right vertex and MinBD ( o  X  ,D o  X  ,o )= c Case 5:  X  t =  X  dist ( o  X  ,o ). MinBD ( o  X  ,D o  X  ,o )=0. Case 6:  X  t&lt;  X  dist ( o  X  ,o ). There will be no such case as formalized in Lemma 4.

Here we discuss how to compute MaxBD ( o  X  , R ). Let I = {
I 1 ,I 2 ,  X  X  X  ,I m } denote the intersections in R among domi-nant regions D o  X  ,o for each object o that has been added into R (also including the intersections with the boundary of the whole plane and the four vertexes of the plane if they are in the region). We have MaxBD ( o  X  , R )=max I t  X  X  dist ( o as stated in Lemma 7. We can easily compute the intersec-tions using the polar coordinate.

Lemma 7. Given a region R computed in the incremen-tal algorithm, we have
To facilitate the pruning, we access objects in ascending order sorted by d min (o). If d min ( o )  X  d max , we can prune all objects after object o . Based on this idea, we introduce our framework to compute the safe region and the pseudo-code is shown in Figure 1. We first initialize R as the whole plane and d max (line 3-4). Then we sort the objects by d min ( o ) and create a priority queue (line 5). We dequeue and get the object o with the minimal value. If d min ( o )  X  d max algorithm terminates (line 8); otherwise we update R and d max (line 10-11).

For example, in Figure 1, to get the safe region of the query, we initialize R as the whole plane and d max as the distance from o 4 to the top-right corner of R , i.e., d max = 0.84. Then we calculate MinBD ( o , D o 4 ,o ) for every o O  X  X  o 4 } and insert o into the priority queue Q in order. The first element in Q is o 7 with d min ( o 7 )=0 . 12 &lt;d We dequeue it and update R = R  X  D o 4 ,o 7 . d max is stil-l 0.84 as the top-right corner is still the farthest point to o . Next we process objects o 3 ,o 15 ,o 14 ,o 9 ,o 13 in the same way and get d max =0 . 27. For the next object o 10 ,since Algorithm 1 : Sense -NoIndex( O , q )
Input : O : A collection of objects
Output :SafeRegion R Figure 3: Sense (No-Index) Algorithm (S afe-re gion con struction for moving s patial ke yword queries) d min ( o 10 )=0 . 28 &gt;d max , the algorithm terminates. Thus we only compute the dominant regions for 6 objects and prune the other 9 objects.
It is usually time-consuming to compute d min (o) for all objects since there may be large numbers of objects. To address this issue, we utilize spatial structures to alleviate the problem. Without loss of generality, we use the IR-tree [2] as an example, which is the state-of-the-art index to answer top-k spatial keyword queries. Our method can be easily extended to support other indexing structures. IR-tree incorporates inverted indexes into R-tree nodes. For each leaf node, in addition to keeping a set of objects in the minimum bounding rectangle (MBR) of this node, for each keyword contained in these objects, it also maintains an inverted list of objects in the node that contain the keyword. For each internal node, besides keeping a set of objects under this node, for each keyword, it also maintains an inverted list which keeps a list of its children which contain the keyword. Figure 4 shows the IR-tree structure.

The basic idea to use the spatial index to do pruning is as follows. Each IR-tree node n contains a group of objects under this node. We can estimate the lower bound of the dominant regions of objects under this node. If the esti-mated dominant region covers R , we can prune the whole subtree. As the IR-tree uses a hierarchical structure, we can prune many unnecessary nodes. Next we discuss the details.
Given a node n , we define the minimal bound distance for node n and object o  X  , denoted by MinBD ( o  X  ,n ). If MinBD ( o min { MinBD ( o  X  ,D o  X  ,o ) | o is an object under node n because for each object o under node n ,wehave MaxBD ( o  X  MinBD ( o  X  ,D o  X  ,o )as R is inside D o  X  ,o .Thenwediscusshow to define the function MinBD ( o  X  ,n ).

Let mindist ( o  X  ,n )and maxdist ( o  X  ,n ) respectively denote the minimal and maximal distance from node o  X  to the M-BR of node n .Let n t denote the set of terms under this node. Notice that for each term t in n t , its term frequen-cy is the largest term frequency of objects under this n-ode and its inverse document frequency is still idf ( t ). Let  X  t under node n ,wehave (1) mindist ( o  X  ,n )  X  dist ( o  X  ,o )  X  maxdist ( o  X  ,n ); and (2)  X  t  X   X  t min where  X  t = 1  X   X   X  ( text ( q ,o  X  )  X 
Based on these two notations, we can define MinBD ( o  X  ,n ) as follows.
 Case 1:  X  t min  X  maxdist ( o  X  ,n ). MinBD ( o  X  ,n )isthemini-mal distance from o  X  to the boundary of the whole plane, denoted by D min .
 Case 2: 0 &lt;  X  t min &lt; maxdist ( o  X  ,n ).
 Case 4:  X  mindist ( o  X  ,n ) &lt;  X  t min &lt; 0. MinBD ( o  X  ,n ) = min(max(0 , Case 5:  X  t min &lt;  X  mindist ( o  X  ,n ). MinBD ( o  X  ,n )=0.
Lemma 8. Given an object o  X  and a node n , the above-defined function MinBD ( o  X  , n )satisfies MinBD ( o  X  ,n ) min { MinBD ( o  X  ,D o  X  ,o ) | o is an object under node n
We can prove that MinBD ( o  X  ,n )  X  min { MinBD ( o  X  ,D is an object under node n } . Based on this function, we can use indexes to prune nodes (groups of objects) and pro-pose an index-based method. The pseudo-code is shown in Figure 5. We first initialize R and d max similar to the non-index algorithm (line 3-4) and create an empty priority queue Q (line 5). Then we insert the root of the IR-tree in to Q (Line 6). We dequeue the top element n in Q until MinBD ( o  X  ,n )  X  d max (line 8). If MinBD ( o  X  ,n )  X  d algorithm terminates (line 9) since all dominant regions of remaining objects contain the safe region. If n is a node, we get each of its children n , calculate its dominant region D  X  ,n and d min ( n ), and insert n into Q with its corre-sponding d min ( n ) (line 10-13). If n is an object, we update R using the intersection between R and its dominant region (line 15) and also update d max (line 16).
Note that before finding the safe region R ,wemustcom-pute the answer set A . When computing A ,wehavealready traversed the IR-tree and visited some nodes and object-s. To compute the safe region, we may still need to visit some of these nodes and objects. For example, in Figure 4, nodes N 13 ,N 14 ,N 15 will be visited twice. More important-ly, to compute the answer set and the safe region, we use the same keyword set. Based on these observations, we can cache some information to avoid unnecessary computation Algorithm 2 : Sense -Index( O , q )
Input : O : A collection of objects
Output :SafeRegion R and facilitate the safe region computation. To this end, we cache the following information. (1) Inverted lists: When visiting a node, the answer compu-tation step needs to load the inverted lists of query keywords. In the safe region computation step, we may still use such inverted lists, and thus we can cache them. (2) Keyword MBR: In order to get MinBD ( o  X  ,n )foranode n , we have to use mindist ( o  X  , n )(and maxdist ( o  X  , n )). The most direct way is to use the object which is nearest (and farthest) to o  X  . However this method is inaccurate since some objects in the MBR may contain no query keyword and this kind of objects will not affect the safe region. To improve the accuracy, for a visited node in the answer computation step, we compute and store the MBR that contain at least one keyword, called keyword MBR . We use the keyword MBR to estimate the spatial information of this node. (3) Score bounds: For a visited node in the answer compu-tation step, for each node we can cache its virtual textual information n t and  X  t .

Thus during the answer computation step, we cache the above information. Then in the safe region computation step, we can utilize such information for pruning and thus can improve the efficiency. The cache-based method has the following two advantages. First, as IR-tree is a disk-based structure, it is expensive to access nodes multiple times from the disk and the cache-based method can reduce the num-ber of disk accesses. Second, we can estimate the dominant region for each object more accurately. Checking Safe Region in the Client: In the client, we need to check whether the current location is in a safe region. As we use a piecewise function to represent a safe region, it is very efficient to do the checking as follows. Assume the current location is q s , A = { o  X  } and R = f i (  X  )[  X   X  +1 ](1  X  i  X  m,  X  m +1 =  X  1 ). First, we compute  X  for q which is the angle from line o  X  q to the x -axis. Suppose  X   X  [  X  j , X  j +1 ) , 1  X  j  X  m .Wecalculate r = f j (  X  )whichis the distance from o  X  to the boundary of R with this angle. Therefore, if dist ( o  X  ,q s )  X  r , q s is inside A , and thus o is still the best answer. Otherwise, the client should send a new query to the server.
 Supporting other functions: Our framework can be ex-tended to support the ranking function in Equation 3 which was used in [17]. Different from our ranking function, the shape of the safe region of this function is composed of cir-cles and lines. We can extend our techniques to compute the dominant region and the safe region. Notice that in their work, they only use polygons to approximate circles and they cannot find the exact safe region. However we can use the polar coordinate to efficiently compute the exact safe region. Due to space constraints, we omit the details.
In this section, we extend our techniques to support top-k queries. We propose an intersection-based method in Sec-tion 5.1 and an approximate method in Section 5.2.
To compute the safe region for a top-k query, an intu-itive way is to first compute the safe region for each objec-t o  X   X  X  to the object set O  X  X  (denoted by R o  X  ,O  X  X  ) and then compute their intersection ( R =  X  o  X   X  X  R o  X  ,O We can compute R o  X  ,O  X  X  by intersecting the dominant re-gion of o  X  to every object o  X  O  X  X  .Thuswehave R
Lemma 9. Given a query q and its answer set A ,thesafe region can be computed as:
For example, in Figure 6(a), assume k =2. Theshaded safe region for { o 4 ,o 9 } . Obviously the safe region of
Based on Lemma 9, for each object o  X  in A , we first com-pute R o  X  ,O  X  X  and then intersect R o  X  ,O  X  X  for every o A . For the no-index based algorithm (Algorithm 1), we can easily compute R o  X  ,O  X  X  by replacing O with O  X  X  .Forthe index-based algorithm (Algorithm 2), during the traversal of the indexing structure, if we encounter an object in A ,we just ignore the object. If we encounter a node, we use the same method, regardless of whether the node contains an object in A . The main reason is as follows. If we prune a n-ode n , all objects under the node cover the safe region. Thus we can use the two algorithms to support top-k queries.
For example in Figure 6(a), consider A = { o 4 ,o 9 } .We first compute the safe region for o 4 , i.e., R o 4 ,O  X  X  ifferent from finding the safe region for top-1 answer, we do not need to compute D o 4 ,o 9 . Then, based on the safe region for o 4 , we traverse the IR-tree again to compute R R Next we discuss how to compute the intersection of regions R  X  ,O  X  X  for o  X   X  X  . Aseachregioniscomposedbyaset of hyperbolas, it is expensive to compute the intersection. Although we use the polar coordination, different regions have different origins and we have to transfer coordinates. To alleviate this problem, we use a polygon to approximate the region as follows. For each curve of the region, if it is convex, we use the segment between its two end points to approximate it; if the curve is concave, we use tangents inside the safe region to approximate it. Notice that if we use the index-based algorithm, this method needs to access the index k times. If k is large, the performance will be poor. To address this issue, we propose an alternative method. The basic idea is to compute the intersection during the traversal of the index, we only access the index once. Before introducing our idea, we first define the dominant region of an answer set A to an object o  X  X  .

Definition 5. Given a query q =( q s ,q t ,k ) , the domi-nant region of A to o ( o/  X  X  )is: where q =( q s ,q t ,k ) .

Obviously R =  X  o/  X  X  D A ,o . Based on this concept, we pro-pose two incremental algorithms. For the no-index method, we only need to use D A ,o to replace D o  X  ,o . For the index-based method, besides replacing D o  X  ,o with D A ,o for an ob-ject o , we need to redefine how to prune an object o (node n ). As o  X  may not be in R , we need to reselect a location which must be in R . Based on Lemma 3, q must be in R . Thus we use MinBD ( q,D A ,o )and MaxBD ( q, R ) to do pruning. We can easily deduce a lower bound of the distance from q to the boundary of D A ,o based on the triangle inequality, i.e., we set MinBD ( q,D A ,o )= MinBD ( o  X  ,D A ,o )  X  dist ( o MaxBD ( q, R ) is the maximal distance from q to the boundary of
R . Then, we can use our framework to compute the safe region. As D A ,o and R are complex regions composed by a set of hyperbolas, it is expensive to compute the region. To address this issue, we use polygons to approximate the regions as described in Section 3.

For example, in Figure 6(a), the dashed lines represent the boundary of D o 4 ,o 1 and D o 9 ,o 1 respectively and their in-tersection is D A ,o 1 . In the intersection method, we compute the safe region first for o 4 and then for o 9 . Instead, our in-cremental method first computes D A ,o for o/  X  X  ,andthen calculates their intersection to get the safe region.
The previous methods compute the global safe region, and in this section we compute a local safe region (denoted by which is a subset of the exact global safe region ( R ). As the client X  X  locations are usually not far away from the current query, we can use the local safe region to approximate the safe region. This method has a big advantage that it is very efficient to compute the local safe region and outperforms the methods in Section 5.1. Next we discuss the details.
We can transfer our ranking function in Equation 1 into the following form: score ( q,o )=  X   X  dist ( q,o )+
In this way we can model each object o as a circle C o with center o and radius of r o = 1  X   X   X  (1  X  text ( q,o )). Then,
Let r q =max { dist ( q,o  X  )+ r o  X  | o  X   X  X } and C q denote the circle centered at q and radius of r q . For an object o  X   X  X  ,wehave score ( q,o  X  )  X   X r dist ( q,o  X  )+ r o  X   X  r q ,thus o  X   X  X  if and only if the circle C  X  are inside C q . Similarly an object o  X  O  X  X  if and only if the circle C o are not inside C q .

Then suppose the client moves to location q .Let C q denote the circle centered at q and radius of r q  X  dist ( q,q ). As C q is inside C q , for each object o  X   X  X  ,if C o  X  is inside C , o  X  is still a top-k answer of q . C o  X  is inside C q only if which can be written as
Obviously the locus of such points is an ellipse with q and o  X  as the two focuses, denoted by E dist ( q,q )  X  r q  X  r o  X  } . Obviously E =  X  o  X   X  X  E o safe region, that is if q  X  X  , A is still the answer set. Since q  X  X  as stated in Lemma 10, E is not empty.

Lemma 10. Given a query q and its answer set A , E is not empty and q  X  X  .
 We can use the polar coordinate to represent an ellipse. As q is in each ellipse, we can take q as the origin of the polar coordinate and thus can efficiently compute the intersection of the k ellipses. Due to space constraints, we omit the details about how to use polar coordinates to compute the intersection. As the local safe region is small, we can enlarge it as follows. Based on Equation 8, if r q increases, the eclipse E increase r q to enlarge the safe region as follows (Figure 6(b)).
Let  X  = r q + and C  X  q denote the circle centered at q and radius of  X  . We compute the ellipse E  X  o  X  = { q s | dist ( o dist ( q,q )  X   X   X  r o  X  } , and region E  X  =  X  o  X   X  X  E  X  E X  X   X  . Obviously A dominates the objects outside C  X  Since there may be other objects involved in C  X  q  X  X  q ,we need to determine whether A dominates these objects. Let inside circle C  X  q but not inside C q and D A , C  X  dominant region of A to C  X  q  X  X  q which is  X  o  X   X  X  D o  X  region since  X  R X  X  as formalized in Lemma 11.

Lemma 11. For any  X  , we have (2) If  X  is  X  ,  X  R  X  = R .
 There are two challenges. The first one is how to compute D tial index structures (which is the objects with distance to q between  X  and r q ). Then based on these objects, we can efficiently compute D A , C  X  algorithm. The second one is how to select  X  .If  X  is smal-l, the local safe region is small, and the client queries have large probabilities outside the region. If  X  is large, there will be more objects in C  X  q  X  X  q , and it will take more time propriate  X  . We can determine the value based on the client moving speed (e.g., m meter/per second). If we expect the query location to be still in the safe region after s seconds, we set  X  = r q + k  X  m  X  s .
We implemented our proposed techniques and compared with the state-of-the-art method MSK [17]. We used disk-based IR-tree [2] as the index to compute the answers and safe regions. We fixed the page size at 4KB. We used two real spatial data sets composed of POIs in California and Beijing. The details are listed in Table 2. We randomly generated 100 query trajectories and each query had 2-5 keywords. Each trajectory consisted 1,000 points and the distance between two consecutive points were 100 meters. All the experiments were implemented in Java and conducted on a Linux server with Intel(R) Xeon(R) 2.27GHz CPU and 4GB RAM.

In this section, we evaluate the cache-based technique. We implemented two algorithms, Sense -Index without cache and Sense -index with cache, where we used the incremental intersection methods. Figure 7 shows the results. We can see that the cache-based technique can significantly improve the performance. For example, on the California dataset, when k = 20, the cache-based time reduces the time from 1228 milliseconds to 55 milliseconds. This is because we can reduce large numbers of IOs by using cached information.
We first evaluate our different methods to compute the safe region. We implemented tree algorithms, intersection based method ( Sense-Intersection ), incremental intersection-based method ( Sense-IncreIntersection ), and approximate-based method ( Sense-Approximate ). Figure 8 shows the experimental results. We can see that Sense-IncreIntersection and Sense-Approximate outperform Sense-Intersection . This is because Sense-Intersection has to traverse the IR-tree k times. If k =1, Sense-IncreIntersection and Sense-Intersection achieved nearly the same performance. Sense-Approximate was better than the other two meth-ods as it reduces the number of dominant regions and esti-mates the safe regions using smaller numbers of dominan-tregions. As Sense-IncreIntersection is always better than Sense-Intersection ,nextweonlycompare Sense-IncreIntersection and Sense-Approximate .
Figure 7: Evaluation on cache-based technique Figure 8: Evaluation of computing model on server 6.3 Sense-IncreIntersection vs. Sense-Approximate We further compare Sense-IncreIntersection and Sense-Approximate in terms of average server elapsed time, aver-age client elapsed time, average communication cost (bytes) and the update frequency which is the ratio of the num-ber of queries issued to the server to the total number of queries. The client issued a query for each point in a tra-jectory. For Sense-Approximate ,tocalculate A and R , we set s = 1000. Figure 9 shows the results by varying k . Due to the space constraints, we only show the results on the California dataset. On the Beijing dataset, we got similar re-sults. We can see that Sense-Approximate took less server time as it uses an approximate method to compute the safe region. Although Sense-Approximate involved more client time, it only took about 0.006 milliseconds which is negli-gible. Sense-Approximate involved more communication overhead since it needs to intersect hyperbolas and ellipses which results in more vertexes. Sense-Approximate had larger update frequency as it estimated the safe region which is much smaller than the real safe region.

To further compare the two methods, we evaluate the server time and communication cost in a time window (We do not compare the client time as it is negligible). In our experiments, the time windows is 10 minutes. We com-pared the total server elapsed time to answer the queries in the window. Figure 10 shows the results. We can see that Sense-Approximate took less server time than Sense-IncreIntersection , especially for larger k values. This is because Sense-Approximate estimates the safe regions and reduces the computation time. Sense-Approximate in-volved nearly the same communication overhead with Sense-IncreIntersection , especially for a large k .Thisisbe-cause our approximate method has better approximation ratio for larger k , since it enlarges the space for larger k .
As the state-of-the-art method MSK [17] only support-s the ad-hoc ranking function as discussed in Section 2.2, we extend Sense-IncreIntersection to support the same ranking function and compare with it. Figure 11 shows the results by varying k . We can see that our method signifi-cantly outperforms MSK in terms of server time, client time, and communication cost. The main reason is as follows. For server time, we use polar coordinates to represent the safe Figure 10: Sense-IncreIntersection vs. Sense-Approximate (for 10 minutes, California) region, which is much more efficient than the approximate based method. For the communication cost, MSK needs to return some objects to avoid involving false negatives. That is also why the client time of MSK is much larger than Sense : besides checking whether the current location is in safe region, the client has to examine every returned objects. Sense and MSK nearly achieve the same update frequency as they generate similar safe region. The only difference is that MSK approximates the safe regions using polygons and our method computes the exact ones. Figure 12 shows the results by varying velocity. We can see that our method still significantly outperforms MSK in terms of the server time, client time, and communication cost.
There have been many studies on spatial keyword search [9, 7,22,19,18,10,13,1,3,21]. Felipeetal.[4]addressed a k -nearest-neighbor problem which returns k objects that contain the query keywords and are near to the query loca-tion. They proposed IR 2 -tree by adding signature files to R-tree nodes. Cong et al. [2] proposed the IR-tree which can support IR-based ranking functions. Zhou et al. [22] and Hariharan et al. [7] studied range-based spatial key-word search, which, given a rectangle and a set of keywords, finds all relevant answers that are located in the rectangle. Zhang et al. [19] studied collective keyword search, which finds a set of objects that contain all the query keywords. Lu et al. [10] studied reverse spatial and textual k nearest neighbor search. Li et al. [9] studied direction-aware search by considering directions. Obviously these problems are d-ifferent from ours.
 Wu et al. [17] studied moving spatial keyword search. However they only supported ad-hoc ranking functions (Sec-tion 2.2). Instead our method adopts a general ranking func-tion. When we adapted our method to support their func-tions, our method significantly outperforms their approach in terms of both efficiency and communication cost.
Continuous queries have attracted much attention with the popularity of location-based services. For a continuous query, the query position was moving while the objects can be static [15, 14, 16] or moving [6, 8, 5]. We consider the former case. To avoid repeatedly issuing queries, the safe region based method was proposed [20, 12]. However these studies only considered spatial information and did not take into account textual descriptions.
In this paper we have studied the moving top-k spatial keyword search problem. For each query submitted to the server, besides generating top-k answers we also constructed its safe region. We proposed to use hyperbolas to represen-t the safe region. To efficiently calculate the safe region, we devised effective pruning techniques and utilized index-(c) Communication Cost (c) Communication Cost (c) Communication Cost ing structures to improve the performance. We also devel-oped incremental algorithms to efficiently compute the safe region. We have implemented our proposed techniques and experimental results show that our method significantly out-performs state-of-the-art approaches.

