 This paper proposes a prefix-tree structure, called CPS-tree (Compact Pattern Stream tree) that efficiently discovers the exact set of recent frequent patterns from high-speed data stream. The CPS-tree introduces the concept of dynamic tree restructuring technique in handling stream data that allows it to achieve highly compact frequency-descending tree structure at runtime and fac ilit ates an efficient FP-growth-based [1] mining techn iqu e. [ Database Management ]: Database Applications  X  data mining . Keywords: Data mining, frequ ent patterns, data strea m. Recently, finding frequent patterns from data streams has become one of the important and challenging problems, since capturing the stream content memory efficiently with a single-pass and efficient mining have been major issues. The FP-growth mining technique [1] is one of the efficient algorithms where the achieved performance gain is mainly based on the highly compact frequency-descending FP-tree structure that ensures the tree to maintain as much prefix sharing as possible. However, the two database scans and prior threshold knowledge requirements of the FP-tree restrict its use in data stream. DSTree [3] uses the FP-growth mining technique to mine exact set of recent frequent patterns from stream data with a single-pass. However, it provides poor compactness in tree structure and inefficient mining phase, since it uses frequency-independent canonical order tree structure. Therefore, in this paper, we propose a novel tree structure, called CPS-tree (Compact Pattern Stream tree), that constructs an FP-tree like compact prefix-tree structure with a single-pass over stream data and provide the same mining performance as the FP-growth technique through the efficient tree restructuring process. To capture the recent stream contents CPS-tree uses the sliding window mechanism. To facilitate the window sliding and tree updating, each window W is decomposed into a number of equal-sized non-overlapping batches of transaction, called pane P . Let the window slides pane-by-pane. The CPS-tree follows the FP-tree construction mechanism to insert transactions into tree. At first, the transactions are inserted ( Insertion phase ) according to a predefined item order (e.g., lexicographic item order). The item order of CPS-tree is maintained by a list, called I , with respective frequency count of each item. After inserting a part of transactions, if the item order of I deviates from the current frequency-descending item order to a degree, CPS-tree is dynamically restructured ( Restructuring phase ) by the current frequency-descending item order I During the next Insertion phase transactions are inserted in I order. The pane-wise information is separately maintained into the tree in a list, called pane-counter in the last node, called tail-node of each transaction. The step-by-step CPS-tree construction and restructuring phases are shown in Figures 1(b) to 1(c) for the database of Figure 1(a) with W = 2 panes and P = 2 transactions. Consider the tree restructuring is performed after each pane. We refresh the CPS-tree at each window slide in order to provide a ready-to-mine platform with the exact content of the current window. Upon sliding of window the first value in the pane-counter in each tail-node and same value from the count value of each node up to the root in the path are removed, and the other remaining values in the list are shifted left by one slot to reflect the expiration of oldest pane. The CPS-tree after deleting the expired pane and inserting a new pane (i.e., at window 2) is shown in Figure 1(f). The DSTree for windows 1 and 2 requires comparatively higher nodes (as in Figures 2). Moreo ver, the tree at window 2 is overburdened with some  X  garbage  X  nodes that are generated since DSTree does not update the tree at each window. In order to restructure the CPS-tree, we use our pr oposed efficient tree restructuring mechanism, called Branch sorting method (BSM) [4], and the Path adjusting method proposed i n [2]. We refer interested readers to [4] and [2] for getting detail about the BSM and Path adjusting method respectively. Once th e CPS-tree is constructed on current window, we use the bottom -up FP-growth mining technique to generate the exact set o f recent frequent patterns. The mining operation is highly e fficient due to the frequency-descending tree structure. We compare different performance issues of our CPS-tree with those of the DSTree, since it has been reported in [3] that DSTree outperforms other related algorithms to find recent frequent patterns from data stream. All programs are written in Microsoft Visual C++ 6.0 and run with Windows XP on a 2.66 GH z CPU and 1 GB memory. Runtime includes tree construction , tree restructuring (for CPS-tree only) and mining time. Several real and synthetic datasets are used. In the experiments , the size of window is indicated by the two parameters W and P . The results on memory consumption on different data sets are shown in the form of the number of nodes in Figure 3. It is clear from the figure that the total number of nodes the CPS-tree requires is significantly less compared to that the DSTree does in each dataset. The reason is that CPS-tree X  X  dynamic tree Restructuring phase enables it to obtain as much prefix sharing as possible that remarkably reduces the number of node s compared to any frequency-independent tree. In addition, the CPS-tree is free from the  X  X urse X  of  X  garbage  X  nodes. Moreover, it further reduces the size by maintaining only a few tail-node s compared to ordinary nodes in the tree structure. The runtime comparison between the CPS-tree and DST ree over datasets of different types has been performed by v arying the threshold ( min_sup ,  X  ) values and widow parameters. In Table 1 we report the runtime of both trees for two (one hi gh and one low) min_sup values over different datasets. The runtime distri bution for tree construction, tree restructuring (only for CPS-tree), tree update (expired pane deletion time for CPS-tree and  X  garbage  X  node deletion time for DSTree), mining time (for tw o min_sup values) and total time are shown explicitly. The da ta in the table clearly demonstrate that CPS-tree outperforms DSTre e in overall execution time by multiple orders of magnitudes on both high and low min_sup values over all types of datasets used in the experiment, which is due to the remarkable improvem ent CPS-tree achieves in mining time on the dynamically-obt ained frequency-descending tree structure. Therefore, from the above experiments we summarize that despite additional tree restructuring cost, our CPS-tree co nsistently outperforms state-of-the-art algorithms on both run time and memory consumption in mining exact set of recent fr equent patterns from data stream. We propose the prefix-tree structure CPS-tree that introduces dynamic tree restructuring mechanism in data stream and efficiently finds recent frequent patterns from hig h-speed data stream with a single-pass. This study was supported by a grant of the Korea He alth 21 R&amp;D Project, Ministry For Health, Welfare and Family Af fairs, Republic of Korea (A020602). [1] Han, J., Pei, J., and Yin Y. 2000. Mining frequent patterns [2] Koh, J.-L., and Shieh, S.-F. 2004. An efficient app roach for [3] Leung, C. K.-S., and Khan, Q. I. 2006. DSTree: A tr ee [4] Tanbeer, S. K., Ahmed, C. F., Jeong, B.-S., and Lee , Y.-K. 
