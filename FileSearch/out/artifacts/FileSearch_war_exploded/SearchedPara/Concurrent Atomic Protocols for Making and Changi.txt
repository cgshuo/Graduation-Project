 We study a novel data management scenario, in which social networks participants use protocols in order to manage their activities and the ever-growing data available to them in the network. In particular, we study protocols which oper-ate on a consistent network (that we define), and transform it into another consistent state by atomically performing a set of changes. Multiple protocol instances, which work on intersecting parts of the network graph, are able to operate concurrently.
 H.2.1 [ Information Systems ]: Logical Design X  Data Mod-els Algorithms, Design Social Networks, Protocols, Concurrency
Social networks have become a central web application, and are still gaining enormous popularity with new audi-ences. This popularity has also brought very large amount age manually. The abundance of social (as well as busi-ness) opportunities in social networks makes users spend large amounts of time using them. Automation features are therefore necessary in order to manage these large amounts social networks have been recently made [3], [6], [7], [11]. In this work, we formalize and study automation in social networks using protocols . Protocols coordinate changing of statuses regarding entities in the network (e.g., positive and negative RSVPs to an event). The protocols we present  X 
The authors were funded in part by ISF grant 1104/05 and by MOST grant 3/6472.
 ensure atomicity of sets of status changes, and preserve net-work consistency (to be defined). Unlike the protocols pre-sented in [8], this work is not restricted to the case where communication is such that messages can be sent only one-way (from a participant to his followers).
 Example. Consider the social network illustrated in Fig-ure 1. Next to each node, a decision whether or not ( t rue decisions are consistent with the following requirements on followed participants:  X  Chris attends if Eve does not attend.  X  David attends if none of Bob, Alice attend.  X  Frank attends if one of David, Chris does not attend. Suppose that Alice would like to change her mind and at-tend, but only if a new consistent state can be reached. In order to coordinate a set of status changes that is likely to be needed, Alice starts the following protocol :  X  Alice notifies David and Chris that she wants to her change status to true .  X  If Alice changes status, David wants to change status. Chris remains with true .  X  David notifies Frank, Chris sends commit to Alice.  X  Frank also wants to change status. Frank has no followers to notify, and he sends commit to David.  X  David sends commit to Alice.
 David subsequently changes status (to false ) and Frank to true . If only some of the statuses had been changed, but not all, the network would have had inconsistent participants. Our protocols ensure an atomic installment of multiple sta-tus changes. In addition, we develop methods for executing multiple protocol instances concurrently.
We use a directed graph based model for the social net-work (similar to Twitter [10] and Google Buzz [4]). Adopt-ing the Twitter terminology, given an edge (u,v) we shall say that v follows u . As demonstrated in the example, par-ticipants in the model make decisions, which are status deci-sions regarding entities (events, offers) in the social network. We assume that a participant v chooses to follow at least all the participants whose decisions influence v  X  X  decisions. For ease of presentation, we restrict decision values to be true or false (go to an event or not, accept an offer or not etc.). Decisions are made in accordance with consistency tables , which are an abstraction of the conditions under which par-ticipants will determine a true or false status regarding the entity under discussion. Each participant p is associated status values combinations, of a participant p and of followed participants, that p considers consistent. Another ingredi-ent of the model is the network administration (or simply, the system ), which is a global component that administrates some aspects of the execution of protocols. In particular, the system maintains information about relationships between distinct protocol instances for concurrency control needs. The model that we use is interpreted . That is, we use the values that protocol instances read and write, and our meth-ods take advantage of this knowledge. This is in contrast to the traditional database transaction model (thoroughly cov-ered in [13] and [12]), which is generally uninterpreted , and is oblivious to the semantics of the operations.
 Contributions. We formalize the problem of using a pro-tocol to coordinate consistency-preserving status changes in social networks, without the one-way restriction that ap-pears in [8]. We present algorithms for executing such proto-cols, in one-instance mode and in concurrent mode, in which multiple protocol instances operate over the same nodes.
Directed Social Network Graph. A social network is a directed graph (V,E) . V is a set of nodes, each repre-senting a network participant. E is a set of directed edges, representing connections between participants. If a partici-(called tweets in Twitter or status updates in Facebook). As discussed in Section 1, decisions that p makes in a pro-tocol instance are based on inputs from participants that p follows. We assume, for simplicity, that decisions related to distinct entities in the social network are not dependent on each other. Therefore, we restrict the discussion to networks in which only one such entity, e , exists.
 Status Values. Every participant p is associated with a values are { true , false } .
 Stability Value. Every participant is associated with a bi-nary stability value, which can be either stable or unstable . This stability value determines whether the status value is final (stable), or depends on the outcome of a protocol in-stance that is currently attempting to reach a consistent state, in which case it may be reverted (unstable). We dis-cuss this instability issue further in Section 3.
 Automatic Updates. If p follows q , p automatically re-ceives a notification immediately on every change of status or stability values of q .
 Local Consistency. Each participant p has a table T p . T has an attribute for each participant that p follows (i.e., for possible status decisions, for combinations of true or false statuses of participants that p follows. We say that p is in a consistent state if T p contains a tuple which corresponds to p  X  X  status and to the statuses of participants that p fol-it is possible that two tuples differ only in the value of the bination, either decision by p is consistent. For example, in Section 1, David X  X  consistency table has the schema (Al-Global Consistency. Given a network and status values for all participants, we say that the network is consistent if all participants are in a consistent state. That is, if the sta-tuses of participants correspond to a tuple in ./ v | v  X  V Combinations of statuses which do not appear in T p for some participant p can therefore not occur in a consistent network. This join operation defines consistency, but is too large to order of magnitude of the data). Moreover, the tables are only an abstraction of what participants would decide, and are not necessarily available in a processable form, due to complexity and/or privacy issues.
 Communication In a Directed Network. Directed so-cial networks, such as Twitter, use a one-way communica-tion architecture, which allows participants to send messages and updates only to their followers (the protocols in [8] are designed for this communication architecture). However, in this work, we use a communication architecture which al-lows a more natural flow of information, which is needed in directed networks that need to run protocols. In this archi-tecture, a participant p who follows q , and receives a message from q , may respond to q even if q does not follow p . The reason is that while q may not want to follow p  X  X  updates, a message from q to p implies that input from p influences q , directly or indirectly. Therefore, even in a directed network, it is natural to allow p to respond.
 The System. Another model ingredient is the system , which is a global component that maintains the message counter and the commit dependency graph (CDG) that are useful in order to provide atomicity and concurrency. These are defined in the context in which they are used. The Problems. We address the following problems:  X  Formalize a framework and protocols which provide sta-tus changes coordination in consistent networks, by ensuring that sets of changes are performed atomically.  X  How to allow multiple instances of consistency-preserving protocols, which operate on common parts of the social net-work graph, to operate concurrently without adversely in-terfering with each other. Next, we present the stability-preserving protocols. Consistency Preserving Protocol -A Single Instance. with two values, status and stability . A change in either re-sults in a notification to following participants. We consider this notification to be a protocol message.
 Message Counter. The system has a message counter for each protocol instance, which keeps track of the number of protocol messages that are being processed, or are to be processed, by their receivers. The counter is incremented before a protocol message is sent. When the processing of a message is complete (including the possible sending of ad-ditional messages), the counter is decremented. Therefore, when this counter is decremented to zero, no more messages related to the protocol instance will be sent. This informa-tion is used in order to determine whether it is necessary to wait for messages, or if all messages in a particular instance have already been received and processed.
 The Initiator. The initiator starts a protocol instance. Pseudo-code for the initiator X  X  algorithm appears as Algo-maintenance of the message counter from pseudo-codes. The stability value to unstable . The initiator X  X  followers receive an update on this. The initiator then waits for the time-wise last commit or abort message received from each of its fol-lowers (whose algorithm as participants is discussed shortly). If all last messages are commit , the initiator starts an atomic commit process by toggling its status and becoming stable . Otherwise, the initiator becomes stable without toggling its status (i.e., an abort process).
 Participants. A participant in a protocol instance, say v , starts participating in the protocol instance when it receives a (stability) update from an initiator or another participant u . As can be seen in Algorithm 2, v can make one of three de-cisions. One of yes and no , which do not change the partic-ipant X  X  status or stability, or change . change means that in order to preserve consistency, if u changes status, v also has to change status. A yes (respectively, no ) decision is imple-mented by sending a commit (respectively, abort ) message to followed participants that sent v a message in the current protocol instance (i.e., have taken part in this protocol in-stance). A change decision is implemented by changing the stability value to unstable (and by this further activating the protocol). Participants also receive commit and abort mes-sages from following participants, which in turn, they resend to instance participants that they follow. In addition (Lines 16 through 24 in Algorithm 2), participants implement an atomic commit or abort process started by the initiator, by changing statuses, if necessary.
 Cycles and Decisions. Cycles in the directed or under-lying undirected social network graph may result in cases where the same protocol instance reaches a participant more than once. According to the protocol, participants make a new decision upon the receipt of each protocol message. Note however, that once a participant decides change and becomes unstable, subsequent decisions may only be yes or no (Line 7). Each such decision is made based on all the in-formation gathered by the participant so far, and assuming eventual commit of the instance.
 Algorithm 1 Initiator X  X  Algorithm 1: change stability to unstable 2: wait for last commit/abort message from each follower 3: if all (last messages) are commit then 4: toggle status ; 5: change stability to stable ; 6: else 7: change stability to stable ; /*abort*/ 8: end if 9: end wait for
Consistency Preserving Protocol -Concurrent In-stances. The distributed nature of activities and decision-making in social networks requires that multiple protocol instances should be able to operate concurrently, while pre-serving consistency. For this, we develop initiator and par-Algorithm 2 Participant X  X  Algorithm ( v ) 1: wait for stability and status changes from followed par-2: if message is from a followed participant then 3: if sender u is unstable then 4: if v is stable then 5: decide yes , no or change ; 6: else 7: decide yes or no (assuming eventual commit); 8: end if 9: if decision is yes (respectively, no ) then 10: send commit (respectively, abort ) to u 11: end if 12: if decision is change then 13: change stability to unstable ; 14: end if 15: end if 16: if sender u is stable /*commit or abort*/ then 17: if v is unstable then 18: if sender toggled status then 19: toggle status and change stability to sta-20: else 21: change stability to stable ; /*abort*/ 22: end if 23: end if 24: end if /*end of stable u */ 25: end if /*end of followed participant msg*/ 26: if message is from a participant following v ( X  X p-going X  27: if message is commit then 28: send a commit message to all instance participants 29: else 30: send an abort message to all instance participants 31: end if 32: end if 33: end wait for ticipant algorithms in concurrent mode . The system main-tains a commit dependency graph (CDG), which records de-pendencies between distinct protocol instances operating on common parts of the social network. Such a dependency means that an instance I1 operates under the optimistic as-sumption that another instance, say I2 , will commit. I1 and I2 operate concurrently. If I2 indeed commits, I1 may also commit, since the assumption turned out to be true. Initiator. The initiator starts the protocol instance by changing its status to unstable . Then, the initiator waits for three types of messages: commit , abort and an ok/not-ok message from the system. commit and abort have the same meaning as in the non-concurrent case, which is to carry  X  X p-wards X  information on participants X  decisions. If all  X  X pward X  messages are commit , the initiator sends a ready message to the system. The system then verifies that all the instances on which this instance X  X  commit depends actually commit-ted (see participant algorithm). If all indeed committed, the system sends ok to the initiator (otherwise, not-ok ). The ini-tiator then preforms commit or abort. Pseudo-code for the initiator appears as Algorithm 3. Algorithm 3 Initiator X  X  Algorithm in Concurrent Mode 1: change stability to unstable 2: wait for last commit/abort message from each follower 3: if all (last messages) are commit then 4: send ready to system; 5: wait for response from system 6: if response is ok /*commit*/ then 7: toggle status ; 8: change stability to stable ; 9: else 10: change stability to stable ; /*abort*/ 11: end if 12: end wait for 13: else 14: change stability to stable ; /*abort*/ 15: end if 16: end wait for Participant. The algorithm for a participant in concur-rent mode appears as Algorithm 4. An unstable participant v (in, say instance I1 ) that receives a status changing mes-sage from a participant u in instance I2 , may decide yes or no , or to add u to the set v.R . This means that v waits for I1 to finish before sending its decision to u . When messages go  X  X pwards X  (Lines 26 through 33), participants receives com-mit / abort messages. However, at this point, it is still un-known whether I1 would commit. Therefore, participants in v.R that receive a commit message may be in a protocol instance, such as I2 , whose commit depends on the commit of another protocol instance. This dependency is recorded in the CDG by sending a message to the system (Line 28). The rest of the algorithm is self explanatory.
 The system X  X  simple algorithm is omitted due to lack of space, and is informally described above.
In [8], so-called  X  X egret protocols X  operating under the re-striction of the one-way communication architecture are pre-networks. The Facebook Query Language [3] is an SQL-like language used by Facebook participants to query their friends X  data. In [5], the Semantic Web vision is generalized to encompass e-mail, without referring to a social network. Conceptually, they work on one hop in the social graph. Transactions and concurrency control are thoroughly cov-ered in [13] and [12]. The transaction model is an uninter-preted model, whereas the model in this work is interpreted. In [2], uninterpreted concurrency of transactions on graphs is studied. The Query Network [6] [9] is a model for so-cial networks over which friends can be automatically found using query-based algorithms, but does not use protocols. [1] R. Agrawal et. al. The Claremont Report on Database [2] G. N. Buckley, A. Silberschatz: Concurrency control [3] Facebook Query Language. [4] Google Buzz. http://www.google.com/buzz, 2010. [5] L. McDowell, O. Etzioni, A. Halevy, H. Levy.
 Algorithm 4 Participant X  X  Algorithm ( v ) in Concurrent Mode 1: wait for stability and status changes from followed par-2: if message is from a followed participant then 3: if sender u is unstable then 4: if v is stable then 5: decide yes , no or change ; 6: else 7: decide yes or no (assuming eventual commit) or 8: end if 9: if decision is yes (respectively, no ) then 10: send commit (respectively, abort ) to u 11: end if 12: if decision is change then 13: change stability to unstable ; 14: end if 15: end if 16: if sender u is stable /*commit, abort*/ then 17: if v is unstable then 18: if sender toggled status then 19: toggle status and change stability to sta-20: else 21: change stability to stable ; /*abort*/ 22: end if 23: end if 24: end if /*end of stable u */ 25: end if /*end of followed participant msg*/ 26: if message is from a participant following v ( X  X p-going X  27: if message is commit then 28: send a conditional-commit (on v X  X  instance) to sys-29: send a commit message to all instance participants 30: else 31: send an abort message to all instance participants 32: end if 33: end if 34: end wait for [6] R. Ronen, O. Shmueli. Evaluating Very Large Datalog [7] R. Ronen, O. Shmueli. SoQL: A Language for [8] R. Ronen, O. Shmueli. Concurrent One-Way Protocols [9] R. Ronen, O. Shmueli. Automated Interaction in [10] Twitter. http://twitter.com/, 2010. [11] Twollow. http://twollow.com/, 2010. [12] G. Weikum, G. Vossen: Transactional Information [13] P. A. Bernstein, V. Hadzilacos, N. Goodman:
