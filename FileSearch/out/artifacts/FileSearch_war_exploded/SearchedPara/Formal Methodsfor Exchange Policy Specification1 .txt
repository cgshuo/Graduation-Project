 Today, it is clear that organisations are increasingly interconnected and exchange ever larger amounts of information. As a n example, we can consider the extended enterprise, which is actually a group of firms sharing a common purpose, usually the manufacture and marketing of a product and which, through alliances, share resources and knowledge. In this context, information exchange occurs between the different companies, either through in terconnected information systems, or federated platforms that serve as bridges between systems, or sometimes, even more trivially, by simple file sharing between agents. In addition, each organisa-tion can belong to subsystems based on agr eements, partnerships, subsidiaries belonging to the same group, etc.; depending on the subsystem, information exchange takes place according to differen t and potentially contradictory rules. In this world of exchange, controlling the information flow appears essential. As a consequence, organisations need regulation norms to define rules that sys-tems must follow for the information exchange. These rules ensure properties such as the fact that a particular agent is always informed of specific topics, the fact that no information can be released without prior consent of its owner, etc. A particular set of rules of this kind forms what we call an exchange policy .
Before considering the implementation of an information system, and all the problems that stem from the application of the exchange policy to the system, we need to define the notion of exchange policy itself and provide automatic analysis means to support the specification designer. The design errors that are not detected before the implementation phase of a policy increase development costs and risks of uncontrolled dissemination of information. In the more general field of specification engineering, recen t works like [2], [6] or [13] propose to introduce formal methods in model-driven engineering processe s, at early stages of model design and requirement formalisation. The proposed approaches mostly consist in using automatic constraint satisfaction techniques to perform various generic verification tasks on a given mod el and associated logical specification. Following the same line of thought, we propose to offer support to the designer of an exchange policy in order to verify that his formalisation correctly captures all aspects of the original problem without error, contradiction or redundancy, by offering a validation approach in the policy specification phase. In addition, a lightweight analyser based on state of the art pseudo-Boolean solving engines allows to analyse easily a policy when the specification of the system environment evolves, or when policy rules are added, removed or modified.

The goal of the proposed formal analyses is to support exchange policy speci-fication. These analyses consist in establishing that the regulation of information exchange guarantees a set of properties that we call generic , namely: complete-ness, consistency, minimality and applicability. By  X  X eneric X  we mean that these properties can be reasona bly expected to hold for any policy specification, and somehow capture a simple form of best practices of policy engineering. As we will see, the completeness of a policy is t he property that there are no situations not covered by the policy; the consisten cy of a policy is the property that rules do not contradict one another; the applicability of a policy is the property that it does not attempt to handle situations ruled out by domain constraints. Last, the minimality is the property that no rule of the policy can be deduced from the others.

The paper is structured as follows. In S ection 2, we review existing logic rep-resentations of normative concepts. In Section 3, we give a definition of a formal modelling framework suitable to express exchange policies without ambiguities. In Section 4, we give an explanation of our implementation. In Section 5, we define the notion of completeness for a policy. In Section 6, we define the notion of consistency for a policy. Section 7 deals with notions of policy applicability and minimality. Last, Section 8 concludes the paper and outlines perspectives to this work. The notion of exchange policy is closely linked to the notion of norm. A norm in a multi-agent system is a set of statements that regulates the behavior of agents. It expresses which actions are mandatory, permitted or forbidden, for whom and under which conditions. According to the definition of Information Technology Security Evaluation Criteria ,  X  X  System Security Policy specifies the set of laws, rules and practices that regulate how sensitive information and other resources are managed, protected and distributed within a specific system X  [18]. This definition is very general, and many studies have attempted to formally de-fine norms for information access, more precisely by defining formal frameworks for expressing rules on actions that enab le an agent to access information, such as: reading a file, accessing a database [4][5][12][9][19]. All these studies have in common the use of a modal operator to m odel the deontic normative aspects inherent in any policy.

In the literature, one also finds a large body of work in which various temporal logics are used to model the actual implementation of multi-agent systems. In this paper, we decide to focus only on the normative aspect of policies, adopting the notions provided by deontic logic.

Deontic logic is a formal framework dedicated to the expression of obligation and related concepts and to reasoning on them [7]. To enable this, deontic logic defines the notion of obligation through a modal operator. A key property of this type of logic is that a proposition may be required to hold by the norms, without actually holding in the real world. If modal logic provides a formal framework, together with a semantics, which allows us to model and reason clearly and without ambiguity, it is not without limitations. One problem, raised by [21], is that even though modal logic helps to manipulate concepts and their associated rules, it is difficult to handle by ordinary people, and remains a tool limited only to logicians. One might however object to this argument that only natural language can be understood by everybody, bringing us back to all issues related to natural language ambiguities. We emphasise that one of the problems of modal logic is the current limitations in tool support for evaluating the satisfiability of a formula. Since our goal is to provide automatic analyses to support the design and validation of an exchange policy, we need to be able to use efficient formal checking tools. At the present time, tools dedicated to modal logic are less efficient than standard logic solver tools [22].

In order to use plain first order logic rather than modal logic with a de-ontic modality, some works suggest to use a predicate to model the notion of obligation [1] [10] [17]. In particular, [11] defines a model for Role-Based Ac-cess Control [15], named OrBAC (Organizatio n Based Access Control). They introduce three predicates for obligation, permission and prohibition, which give abstract rights in an organisation, for a role, to perform an action for a view in a context. From there, they deduce what they call concrete permissions that model normative obligation, permission and prohibition, for a role to perform an action with an object. A simple example of this type of representation is the  X  X rohibition for the role secretary to perform the action modify file on the object medical record  X .

Note that, in frameworks such as OrBAC, normative predicates have three places: subject, action and object. Their policies hence model actions represented by transitive verbs (divalent verb). This choice is motivated by the purpose of access control policies, which is to model the conditions under which agents can perform actions such as reading or writing data on various data sources. In our context, we are not interested in modelling actions in general, but rather in modelling actions of information exchange between two agents. Here, the information exchange actions correspond to ditransitive verbs (trivalent verbs), for instance:  X  X o exchange X ,  X  X o say X ,  X  X o give X  or  X  X o send X . In conclusion, if we follow the idea of representing deontic notions using predicates, it is not possible to represent an exchange policy using existing access control logical modelling frameworks.

Among all variants of first order logic, we chose many sorted first-order logic ( msfol ) [16] over unsorted first-order logic as a background theory in which to model policies, simply because the use of sorts allows to express models with better compacity than in the unsorted case.

Of course, finding the right modelling methodology for multi-agent systems and defining the right ontologies for cer tain classes of systems is a research sub-ject in its own right. At the present time, we have not yet addressed system mod-elling in such depth. The work presented here consists in providing a minimalist yet extensible modelling framework featuring automatic analysis supported by state of the art SAT/pseudo-Boolean solvers. The many-sorted first order logic is a good candidate general logical framework for modelling policies. Its signatures, syntax and semantics are described in the first subsection. The logical framework peps 1 is defined in the second subsection. peps syntax and semantics are directly inherited from msfol , but it offers a minimalist set of built-in sorts and predicates dedicated to policy modelling, and policy rules are logic formulas which must satisfy syntactical restrictions. The third subsection introduces an example of specification. 3.1 Many-Sorted First Order Logic A many-sorted first order logic signature is defined as a quadruple where:  X  Sort is a set of sorts identifiers , containing at least the sort Bool ;  X  Var is a set of variables identifiers ;  X  Fun is a set of functions identifiers ;  X   X  : Fun  X  Sort  X   X  Sort associates a prototype with each function f  X  Fun . The prototype of a function f specifies the sort expected for each argument of f together with its return sort, and is written (( S 1 ,...,S N ) S ), where N is called the arity of f .If N =0, f is called a constant of sort S . If the return sort is Bool , f is called a predicate . Const  X  Fun is the subset of constants of the signature, and Pred  X  Fun is the subset of predicates of the signature. A func-tion identifier and its prototype declaration can be combined using the notation to function arguments is helpful for documentation purposes. The return sort is often omitted for predicates, usually declared as p ( a 1 : S 1 ,...,a n : S n ).
Well sorted terms and formulas are defined inductively as usual: a constant c of sort S is a term of sort S ; assuming terms t 1 ,...,t n of sorts S 1 ,...,S n and a function f ( S 1 ,...,S n ): S ,then f ( t 1 ,...,t n ) is a term of sort S .Termsofsort Bool are called formulas .If t 1 , t 2 are terms of the same sort, then t 1 = t 2 is a formula. If p and q are formulas, then so are  X  p , p  X  q , p  X  q , p =  X  q and p  X  q (representing logical negation, conjunction, disjunction, implication and equivalence, respectively).

Variable identifiers of the signature are used with quantifiers. A universally quantified formula (respectively existentially quantified formula) has the form  X  x : S, p (respectively  X  x : S, p )where: x is a variable identifier said to be bound to the quantifier, p is a formula in which x is regarded as a term of sort S and must be free in p (i.e., not enclosed in the scope of any other quantifier found in p ). The sort declaration for the variable can be omitted when it can be easily inferred by the reader from the use of the variable. A term or formula is closed when it does not contain any free variables, i.e. when all variables it contains are bound to some quantifier within the formula. For instance,  X  x : s 1 ,f ( x )  X  f ( y ) formula.

The semantics of many-sorted first ord er logic will not be detailed here, yet the usual truth conditions can be found in [16]. Logical consequence through models is noted | =, i.e. we note F | = G when each model of formula F is also a model of formula G and | = F when F is a tautology. 3.2 Exchange Policies Specification Now that the underlying logical framework is introduced, we can define the peps policy modelling framework with greater detail. A peps signature is essentially an msfol signature satisfying a few extra requirements. Since the goal of peps is to express what information items must, must not or can be exchanged, between whom and on what topic, we first assume that at least the following sorts are present in a peps signature:  X  A , which represents the agents of the system;  X  I , which represents information items;  X  T , which represents information topics.
 In addition, the following domain-predicates , called D-predicates from now on, are assumed to be part of the signature:  X  Know ( a : A ,i : I ), which models the fact that an agent knows a piece of  X  Topic ( i : I ,t : T ), which expresses that a piece of information is relevant to peps is not a locked-down language. It is possible to declare additional sorts and D-predicates in a peps signature besides those presented here. In this paper, we only give the core language to illustrate our automatic analyses. We will only use the D-predicates and sorts introdu ced so far in subsequent examples, but for realistic applications, the modelling framework can be easily extended with extra sorts and functions to capture finer details of domains and information exchange policies, such as: a predicate Link ( a 1 : A ,a 2 : A ) to model that a communication link exists between agents a 1 and a 2 ;asort L to model the different accreditation levels, a predicate Ilevel ( i : I ,l : L ) to model that information item i requires accreditation level l for access, a predicate Alevel ( a : A ,l : L )tomodelthat agent a has the accreditation level l ,etc.

Well sorted peps terms, formulas and their semantics are defined just as in msfol .

The concept of obligation, more specifically the obligation for an agent to send an information item to another agent , must be readily available in the modelling framework. Unlike standard deontic logic, we will not have a generic obligation operator, but only the concept of obligation to send information item i from agent a 1 to agent a 2 . We hence assume that three normative-predicates , called N-predicates from now on, are always present in a peps signature: OSend ( a 1 : A represent respectively the obligation, permission and prohibition for an agent a 1 to send a information item i to another agent a 2 .

A peps formula is called an objective formula if and only if it does not contain any N-predicates , in which case it only describes objective knowledge or facts about the domain rather than a normative requirement.

In standard deontic logic, the axiom (D) [8] expresses that if p is obligatory then p must be permitted. In peps we do not have obligation in the general sense but the obligation for some agent to send something to some other agent, so we translate this axiom to a logical property, that we call also (D).
 Definition 1 (D) The property (D) expresses that if it is obligatory for an agent to send an infor-mation item to another agent, then it is also permitted for this agent to send this information item to this other agent. Next, we define the notion of information exchange rule in peps .
 Definition 2 (Exchange rule) An exchange rule is a closed peps formula of one of the following syntactical forms: where:  X  x 1 ,...,x n are all the variables identifiers occurring in  X  , t 1 , t 2 and t 3 ;  X   X  is a quantifier-free objective formula ;  X  t 1 , t 2 arequantifier-freetermsofsort A ;  X  t 3 is a quantifier-free term of sort I .
 In definition 2, the formula  X  is without quantifiers and without normative pred-icates, but besides these restrictions all operators, constants, functions and vari-ables (necessarily bound to one of the rule X  X  quantifiers) are allowed. Moreover, t , t 2 and t 3 are not necessarily closed, so they can contain constants, functions and variables . Of course, the rule formula being closed, the variables in these terms are necessarily bound to one of the rule X  X  quantifiers.

Each rule expresses under what condition it is obligatory, permitted or forbid-den for an agent to send a piece of information to another agent. For instance, Know ( a, i 2 )) =  X  OSend ( a, b, i 3 ) is a correct exchange rule, but the formula  X  a on the right hand side of the implication.
 Definition 3 (Exchange policy) An exchange policy EP is a collection of exchange rule formulas.
 Definition 4 (Exchange policy specification) An Exchange Policy Specification EPS is a pair  X , EP where:  X   X  is a satisfiable set of objective formulas describing facts and knowledge  X  EP is an exchange policy as described in Definition 3; 3.3 Example Consider this simple example: an Earth O bservation System composed by several observing systems sharing environmental data, for the purpose of disaster preven-tion and management (this example is strongly inspired by GEOSS: Global Earth Observation System of Systems). Each observing system is owned by a nation and exchanges observations with others in order to build a global picture of the Earth X  X  condition. Because the system is civilian and is open to all nations, and because some of the observing systems are military and some are civilian, nations do not want any information with potential military utility to get disseminated through this system. Moreover, in the context of climate disaster awareness, this system has a distinguished agent, the Tsunami Warning Center or TWC .

This system has rules which specify in what context, under what conditions, who has the obligation, prohibition or permission to release any information, to whom. For the moment, let us assume that the policy consists of only two rules: (a)  X  X s part of the tsunami prevention, all information about the topic tsunami (such as a submarine landslide) must be sent to the Tsunami Warning Center X  ; (b)  X  X he system should not disclose information relating to military topics X  . These two rules are expressed in the peps framework as follows (with constants TWC : A , tsunami : T and mili : T ): Note that peps provides a minimalist and extensible modelling language with only three sorts but, even if specifying topic taxonomies is not the issue dis-cussed here, it is possible to express simple notions like a parent relationship among topics using the logical implication and extra constraints. In our exam-ple, if military is the parent topic of troop , we would write Topic ( i, troop )=  X  Topic ( i, mili ) which means all information about the topic troop is also about the troop )  X  Know ( a 1 ,i )=  X  FSend ( a 1 ,a 2 ,i ), the action of sending information about the topic troop is prohibited. 4.1 Bounded Model Checking Our aim is to provide automatic tool support to users defining exchange policy specifications. Analyses should be simple to configure and to use and as auto-matic as possible. In order to do so, we harness the power of automated model finding techniques for logical constraints.

In approaches such as [2], [6] or [13], the addressed verification problems are formalised in (many-sorted) first ord er logic and are hence undecidable in the general case, i.e. it is not possible to determine if an arbitrary msfol (or peps , by extension) formula is valid in finite time. So, in the mentioned approaches, authors used a bounded model checking approach: for an analysis, instances which satisfy the formulas under analysis are searched for in a bounded universe and the cardinality is increased by the user from iteration to iteration. Even though each bounded instance can be arbitrarily large, it remains decidable. A key feature of model finding approaches is that, when a required property does not hold on a specification, a counter example is produced, which helps the user understand the problem and fix the specification. 4.2 The PEPS Implementation Because of the decidability issue, we also adopt a bounded model checking ap-proach to analyse peps specifications. By doing so, we lose the ability to prove genuine first order theorems about peps specifications. Indeed, the proposed analyses are only valid on systems up to a certain number of agents, information items, topics, etc. But on the other hand, we obtain a higher degree of automa-tion and simplicity for the user. Our analyser is just a black box to which logical queries about the policy specification can be addressed with minimal parameter configuration.
The analyses detailed in the next sections are implemented using our own grounding tool for msfol formulas [13], which interprets sorts over finite discrete domains.

With our tool, the only way to conduct an analysis is by transforming a given msfol formula into an equivalent pseudo-Boolean logic formula and by checking its satisfiability using a compatible solver. For instance, given two formulas F and G , if the goal is to verify that F | = G ,then F  X  X  G is translated and checked for unsatisfiability. Whenever the pseudo-Boolean solver returns a model of the given formula, the tool translates it back into the peps specification language to help debug the specification.

The pseudo-Boolean satisfiability problem can be seen as an extension of the SAT problem. A pseudo-Boolean instance is a conjunction of constraints of the form  X  i a i l i  X  k ,where a i and k are integer coefficients, and l i a literal (a boolean variable or its negation). Today X  X  pseudo-Boolean solvers use a standard file format named OPB and periodically the international PB-Eval competition 2 allows to benchmark the latest evolutions of the field.

The main ideas behind the grounding and propositional encoding procedure we implemented follow. First, the grounding operation works by representing sorts using finite sets of constants, introducing as many fresh constants 3 as needed by the sorts cardinalit ies. For instance, the sort S of cardinality n is represented by the set of fresh constants { S 1 ,...,S n } . Then, domain constants are substituted for variables and propagated in all quantified expressions. Uni-versal quantifiers are expanded as conjunctions and existential quantifiers as disjunctions. After this step, there are no quantifiers or variables left in the chal-lenge formula, only constants, predicate and function applications and logical operators.

Second, the grounded formula is transformed into a propositional formula using a bitvector encoding (bitvectors are vector s of propositional variables): identifiers for constants of given sorts are encoded using bitvectors of appropri-ate size; predicates are encoded using a propositional variable for each point of their domain of definition; functions returning a given sort are encoded using a bitvector of appropriate size for each point of their domain of definition; function and predicate applications are encoded using advanced bitvector constructs.
Last, bitvector expressions are transformed into clauses (in pseudo-Boolean form) using standard Tseitin rules [23]. Obviously, only clausal encodings are generated by following this approach, but we plan on allowing cardinality con-straints and generic pseudo-Boolean constraints in the peps language in the future, hence the use of pseudo-Boolean logic as target language. After this translation we obtain a pseudo-Boolean formula that can be analysed using any solver supporting the OPB format. One important feature to notice about the tool is that each translation step is cached and reversible, meaning the tool is able to translate a model returned by a solver back to the peps level. For solving, we favor Sat4j [3], yet alternatives are available, like WBO [20] or Minisat+ [14]. Most of these solvers are open source. 5.1 Definition A policy specification is not complete whenever there are situations in which agent behavior is not explicitly constrained by the policy, that is to say, when at least one non liquet 4 exists. This notion of completeness shall not be mistaken for that of completeness for a formal system such as msfol . On the one hand, if the policy says nothing about the dissemination of a piece information, an agent could choose a permissive approach 5 , everything that is not specified is allowed, and in this case the agent could send sensitive information. On the other hand, if the agent chooses a prohibitive approach, in which everything that is not specified is prohibited, then communication in the system could be forbidden. The incompleteness of a policy may hence become a major issue if it relates to sensitive systems where a non liquet gives the possibility for agents to act with important consequences.

Here, we give a simple formal definition for policy specification completeness: a policy specification EPS =  X , EP is complete if and only if, for any agent who knows a piece of information, the policy rules state whether or not to send it to any another agent, in any situation allowed by the domain model  X  .In other words, the policy specification is complete if it is possible to deduce from  X  and EP that each agent, for any piece of information, in any situation, is either allowed, obligated or forbidden to send it to any other agent. Definition 5 (Completeness of a policy specification) Let EPS =  X , EP be an exchange policy specification, EPS is complete if and only if Please note that a policy EP on its own could be incomplete and only become complete once conjoined with domain constraints  X  , which can precisely rule out non liquets . 5.2 Example In the Earth Observation System example (setion 3.3), analysing the policy specification  X  , { a, b } with the peps analyser reports that it is not complete. A simple counter example is returned, in which information is linked to no topic, and hence does not fall under any of the policy rules.

A possible solution to this problem is, for example, to suppose that in the system, there is no information without topic. This should be expressed not in the policy, but rather in the domain constraints. Therefore, we add the following formula (r) (for relevancy) which says  X  X ny information is relevant to at least one topic X  : Despite this addition, { r } , { a, b } is still not complete. Indeed, the analyser returns a new counter example in which information is tsunami related. It reveals that the policy has no rules specifying what an agent is supposed to do with information about the topic tsunami when dealing with an agent that is not the TWC agent. We extend the policy with the rule (c):  X  X tispermittedtoexchange information on the topic tsunami X  , which is formalised as follows: At this point a remark is necessary. As already mentioned, our analyser only proves the existence or absence of a model in a finite universe, which cardinality is specified by the user. In our example, if we choose the cardinality of the sort T to be equal to two, then the policy specification appears complete. Indeed,  X  X ll possible topics X  is reduced to two topics tsunami and mili , and the policy does cover all possible cases assuming only these two topics. But, if more than two topics are allowed, our policy specification no longer appears complete. In this case, the analyser returns a model in whi ch information is relevant neither to the topic tsunami , nor to the topic mili and for which no rule applies. Choosing sort cardinalities when analysing the model is left to the user.

To obtain completeness for the example policy, we must add a rule (d) which is:  X  X here is no particular constraint on the exchange of information not relevant to the military topic X  . This rule corresponds to the following formula: Now, we can check with our analyser that the specification { r } , { a, b, c, d } is complete. If we increase sort cardinalities, for example to 10 agents, 10 topics and 10 pieces of information, the specificatio n is still complete. Of course, we do not prove the completeness of the specification for an infinite universe. Nevertheless, we are more confident after analysing the specification than without any analysis, and the analyser has been of great help in the task of writing and fine tuning the specification.
 6.1 Definition In logic, a theory is the collection of all truths that can be derived from a core set of assumptions. A theory is consisten t if it does not contain a contradiction. In the context of confidentiality policies, in [5] two policies are consistent when conjoined if no user can have the permission, according to the first policy, to know something and the prohibition, according to the second, to know it. For us, an exchange policy is not consistent when some situation exists in which it is both obligatory and forbidden, or permitted and forbidden, for an agent to send a piece of information to another agent. The policy inconsistency is an important issue because both authorising and prohibiting a same behavior for-bids the application of the policy as a whole. The Algorithm 1 yields, given a policy, a set of situations exhibiting inconsistency between pairs of rules, shall any such situation exist. For each possible pair of rules having conflicting nor-mative predicates as conclusions, the algorithm generates a formula which, if satisfiable, indicates a situation in which the premises of both rules are satisfied, and in which the terms used as arguments of the conflicting predicates unify, hence showing that conflicting normative requirements must be applied to the same agents and same information item. Not mentioned in this algorithm is the implicit variable renaming performed on elements taken from r to avoid variable clashes when forming the satisfiability objective.
 Definition 6 (Consistency of a policy specification) Let EPS =  X , EP be an exchange policy specification, EPS is consistent if and only if the result of Search for Non-Consistent rules SNC (  X , EP ) is empty. 6.2 Example In our example, the exchange policy { r } , { a, b, c, d } is not consistent. Indeed, the analyser discovers two contradictions, one between rules (a) and (b) and another between rules (b) and (c).

For the first contradiction, a counter example is returned, in which an infor-mation item is relevant of to two topics, both tsunami and mili , and the agent who receives the information is TWC . A very naive solution is to suppose that each information item is relevant of one and only one topic. More realistic, with peps , we could also consider that information related with mili has an accredi-tation level M , it is permitted to exchange this kind of information with agents whose accreditation level is M ,andthat TWC is accredited at level M . To keep things simple, we decided to replace the rule (b) with (b X )  X  X n agent should not disclose information related to mili topics to an agent other than TWC  X  : Algorithm 1 Search for Non-Consistent rules (SNC) In the same way, we replace the rule (c) with (c X )  X  X n agent should not disclose information related to mili topics but not related to tsunami topics X  : Yet, with this modification, the analyser informs us that the specification { r } , { a, b ,c ,d } is not complete. To obtain completeness we must add one more rule (e)  X  X ilitary information not related to tsunami should not be sent between agents X  : In this section, we define two new properties for policies, aiming at detecting cases of over-specification: applicability and minimality . An applicable and min-imal policy is such that each rule can be applied in at least one situation allowed by domain constraints, and contains no redundant rule with respect to others. 7.1 Definitions A policy is applicable under domain constraints  X  if and only if for each of its rules, there exists a situation in which the rule applies. The underlying idea is that in an applicable policy, there are no rules which premises are contradicted by the domain constraints.
 Definition 7 (Applicability of a rule) Let  X  be a set of domain constraints and r an exchange rule as defined in Definition 2, section 3, i.e. r =  X  x 1 ...  X  x m (  X   X   X  ) . r is applicable relatively to  X  if and only if Definition 8 (Applicability of a policy) Let EPS =  X , EP be an exchange policy specification, EPS is applicable if and only if for each rule r of EP, r is applicable relatively to  X  .
 So, the applicability of a rule is defined as a satisfiability problem for each rule X  X   X  component under assumptions  X   X  D . The unsatisfiability of the rule X  X  premises under environment constraints reveals the non-applicability of the rule, i.e. proves that no situation can satisfy the premises.

Another interesting notion for a policy is that of minimality. A policy is said to be minimal if none of its rules can be deduced from the others under the domain constraints.
 Definition 9 (Minimality of a policy) Let EPS =  X , EP be an exchange policy specification with EP = { r 1 ,...,r n } . EPS is minimal if and only if there is no i such that: In the same way as for applicability, showing the minimality of a policy is achieved by solving a series of satisfiability problems, each exhibiting a situ-ation in which a certain rule is the only rule of the policy whose premises are satisfied, hence showing its independence with respect to the other rules. 7.2 Example Coming back to our example, the analyser allows to prove that all rules are applicable: the policy specification { r } , { a, b ,c ,d,e } is applicable.
However, the analyser reports that the specification is not minimal. Indeed, it can be proved that the rule (c X ) can be deduced from the others. If we choose to reduce the policy specification by removing the rule (c X ), we can successfully check with the analyser that the specification is still complete and consistent.
Finally, the exchange policy specification { r } , { a, b ,d,e } is complete, con-sistent, applicable and minimal. In this paper we proposed a logical modelling framework suitable to express information exchange policies. We also defined essential generic properties such as completenes, consistency, applicability and minimality, and provided proce-dures for checking these properties using currently available logic solvers. The proposed framework is extensible, as it is possible for the user to declare any additional sort, function, or predicate needed for modelling, such as the roles played by an agent in an organisation, or the accreditation level of information or agents, etc.

The bounded model checking approach and the pseudo-Boolean solvers back-ends used in the analyses proposed in this paper have already passed with great success scalability tests on real world instances in many different application domains like software verification or hardware verfication. Therefore, we are confident in their performance for policy verification.

Our future work will cover two compleme ntary aspects of policy verification and specification. First, on the technica l side of formal verification, we will study if and how the latest features of logic solvers can be used to help the verification of policies. In particular minimal unsat core generation may allow to discover the details of why a rule is unapplicable under a given set of environment constraints. Concerning the completeness of an exchange policy, future work could focus on the possibility to support the specification. Automatic model enumeration features will be studied in relation with the abduction reasoning principle to try to automatically extend an incomplete policy and make it complete.

Second, we intend to apply the proposed approach to model a real-world information exchange policy in the domain of space situation awareness. The targeted application being somewhat complex, we will investigate and develop the methodology of domain modelling and policy specification further. Dealing with information systems of this kind already brings new questions to mind, such that of defining and studying other generic properties of policies. For example, we might be interesed to verify that vital inf ormation can always reach the relevant agents for appropriate action. For eac h new generic property, we shall proceed in the same way and give it a formal definition in our modelling framework, and define associated verification procedures. Also, supporting a variant of msfol with subsorting could allow for a better and more concise way of modelling of complex application domains. Subsorting indeed allows to model hierarchies of concepts or entities with greater ease. We also plan on allowing the specifica-tion and verification of user-specified properties, in addition to the four generic properties discussed in this paper.

