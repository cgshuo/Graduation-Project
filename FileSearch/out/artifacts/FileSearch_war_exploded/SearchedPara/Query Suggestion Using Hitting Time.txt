 Generating alternative queries, also known as query sugges-tion, has long been proved useful to help a user explore and express his information need. In many scenarios, such sug-gestions can be generated from a large scale graph of queries and other accessory information, such as the clickthrough. However, how to generate suggestions while ensuring their semantic consistency with the original query remains a chal-lenging problem.

In this work, we propose a novel query suggestion algo-rithm based on ranking queries with the hitting time on a large scale bipartite graph. Without involvement of twisted heuristics or heavy tuning of parameters, this method clearly captures the semantic consistency between the suggested query and the original query. Empirical experiments on a large scale query log of a commercial search engine and a scientific literature collection show that hitting time is effec-tive to generate semantically consistent query suggestions. The proposed algorithm and its variations can successfully boost long tail queries, accommodating personalized query suggestion, as well as finding related authors in research. Categories and Subject Descriptors: H.3.3 [Informa-tion Search and Retrieval]: Text Mining General Terms: Algorithms Keywords: Hitting time, bipartite graph, query sugges-tion, personalized query suggestion
The explosive growth of web information has not only created a crucial challenge for search engine companies to handle large scale data, but also increased the difficulty for a user to manage his information need. It has become in-creasingly difficult for a user to compose a succinct and pre-cise query to present his search need. Instead of pushing this burden to the users, it is common practice for a search engine to provide some types of query suggestions.  X  This work was done when the first author was on a summer internship at Microsoft Research.
 Copyright 2008 ACM 978-1-59593-991-3/08/10 ... $ 5.00.
When a user types a query  X  X sg X  to the search engines, he will be provided with quite a few alternative potential queries. For example, he will be suggested  X  X sg chinese food, X   X  X sg health, X  and  X  X ther names for msg X  by Google, and  X  X sg error, X   X  X sg network, X  and  X  X sg seating chart X  by Yahoo 1 . There are also other query suggestion mecha-nisms which could automatically complete a query [7], and automatically correct spelling mistakes [10].

Such query suggestion mechanisms are usually developed based on morphological information of queries, or cooccur-rence of one query word with other queries (e.g., in the same query, or in the same working session). Although such query suggestions are proved useful in different ways, there is usu-ally no guarantee that the suggested queries convey close semantic information with the original query. Indeed, it is usually annoying for a researcher who searches for  X  X hris Burges X  but is suggested with  X  X hris burgess 2  X  or  X  X hris Burge Ministries 3 . X  Similarly, it is not very helpful to suggest  X  X DD X  with  X  X BB X ,  X  X ddi, X   X  X tt 4 , X  and  X  X arry Shum X  with  X  X arry Potter 5 . X  People searching for  X  X arry page X  maybe interested in  X  X ergey brin X  but not  X  X ellow page. X  A good query suggestion system should consider a handful of features, but in most cases it is important to en-sure that the semantics of the suggested query do not drift too much from the original one.

The problem becomes more challenging when personaliza-tion is taking into consideration. Some users will issue the query  X  X sg X  to search for the sports center in New York and others use it to search the food additive.  X  X sr X  could mean  X  X icrosoft research, X  but also  X  X ountain safety research,  X  or even  X  X ortgage servicing rights. X  Without the constraint of semantics, a general suggestion to such ambiguous queries would easily be off the track.

Another big challenge and opportunity for the current query suggestion systems lies in the suggestion of infrequent queries. It has been a well known theory in business that a company could  X  X ell less of more X  by boosting the long tail of the power law distribution [2]. Netflix spends millions to look for an effective way to suggest hard-to-find movies. The same question lies in search engine business, especially in ad-vertising where customers bid for query terms. Frequently clicked queries cost more and long tail queries cost less. If a well designed query suggestion system could route the traf-
All real examples are collected on Feb. 25th, 2008. http://search.yahoo.com/search?p=chris+burges http://search.live.com/results.aspx?q=chris+burges http://search.live.com/results.aspx?q=KDD http://search.live.com/results.aspx?q=harry+shum fic and boost the clickthrough of long tail queries, there is a huge opportunity to maximize the benefits for both a search engine company and customers of its advertising system.
Is there a principled way to suggest semantically similar queries while also boosting long tail queries? Can such a method also provide a natural solution to personalization? It is challenging because  X  X emantics X  is hard to define and both long tail queries and personalization usually suffer from data sparsity.

In this paper, we propose a unified approach to query suggestion, by computing the hitting time on a large scale bipartite graph of queries and clickthrough. Despite its sim-plicity, this novel approach introduces quite a few benefits to query suggestion: 1) the suggestions generated with the proposed algorithm are semantically similar to the original query; 2) the suggestions generated do not have to occur with the original query; 3) this approach boosts the long tail queries as suggestions; and 4) this model provides a natural treatment for personalized query suggestion. Empirical ex-periments on a large scale query log of a commercial search engine, as well as a public available scientific bibliography dataset show that our proposed algorithm is effective for semantically coherent query suggestion, which provides a potential new framework, or an important and novel feature for building a real query suggestion system. The approach of using hitting time is quite general, which could provide potential solutions to many other search related problems other than query suggestion. We will discuss these possibil-ities later in Section 6.

The rest of the paper is organized as follows. In Section 2, we formally introduce the concept of hitting time on a bi-partite graph. In Section 3, we propose the algorithm of query suggestion using hitting time. We show our experi-ments and results in Section 4, introduce the related work in Section 5, and conclude in Section 7.
A bipartite graph is a graph G = ( V, E ) in which there exists an partition V = V 1  X  V 2 such that every edge in E connects a vertex in V 1 and one in V 2 ; that is, there is no edge between two vertices in the same set. Let w : V 1  X  V 2  X  R denote the weight function. Given i  X  V 1 and j  X  V 2 , if there is an edge connecting i and j, then w ( i, j ) is positive; otherwise, w ( i, j ) = 0 .

Given a bipartite graph, a random walk can be formed as follows. Assume the current position is at a vertex in V . Then an edge connected to this vertex is chosen with the probability proportional to the weight of the edge. By following this edge, the random walk arrives at a vertex in V . Then, similarly, an edge connected to V 2 is chosen to follow and the random walk goes back to V 1 . Given i  X  V and j  X  V 2 , the transition probability is defined as vertices in one side, such as V 1 , then a new random walk based on the above one can be introduced by It is easy to check that the stationary probability  X  i is pro-portional to d i . In what follows, we discuss hitting time on a graph G = ( V, E ) . All materials are self-contained. For readers who are familiar with this concept, they can skip the discussion.

Let A be a subset of V. Let X t denote the position of the random walk at discrete time t. The hitting time T A is the first time that the random walk is at a vertex in A, thus T
A = min { t : X t  X  A, t  X  0 } . It is obvious that T A is a random variable. From the definition of the hitting time, given i /  X  A, we immediately have
P [ T A = m | X 0 = i ] = X The mean hitting time h A i is the expectation of T A under the condition X 0 = i, that is, h A i = E [ T A | X 0 = i ] . Thus Obviously, For computing the second term, it is necessary to notice that Thus, Consequently, In addition, it is obvious that Combining all pieces together, we obtain the linear system for computing the hitting time: This linear system has a unique solution. This fact can be elegantly verified by using Maximum Principle and Unique-ness Principle in the discrete potential theory.
Based on the formal definition of hitting time, we now pro-pose our algorithm of query suggestion using hitting time.
Let us begin with a query log dataset, from each record of which we can extract a pair  X  Query, U RL  X  . By summarizing all such pairs, we can construct a bipartite graph G =  X  V, E  X  , where V = V 1  X  V 2 . Clearly, V 1 corresponds to all queries, and V 2 corresponds to all URLs. Each edge e = ( i, j )  X  E corresponds to a pair  X  Q i , U j  X  with positive frequency. We weight each edge with w ( i, j ) = C ( Q i , U j ), which is the number of records where this pair appears.

There are also other variations to this setup, e.g., by nor-malizing the edge weights, constructing a k-Nearest-Neighbor graph, or using a Query-Query graph, Query-IP graph, etc. In this section, we use the undirected Query-URL bipartite graph as a representative case to illustrate our algorithm. A simple example of such a graph is shown in Figure 1. Figure 1: Example of an undirected Query-URL bi-partite graph
From Figure 1, we see that every query is connected with a number of URLs, on which the users clicked when sub-mitting this query to the search engine. The weights on the edges present how many times the users used this query to access this URL. Please note that there is no edge connect-ing two queries, or two URLs.

The labeled query indicates the query for which we want to generate suggestions. Intuitively, if for all URLs that we use a query to access, other people exclusively use another query to access, that query is a good suggestion to the orig-inal query, e.g.,  X  X merican airline X  to  X  X a X  in Figure 1.
Let Q T be the original (target) query. In principle, we can set A = { Q T } and compute the Hitting time h A ( i ) for all other queries Q i based on this graph, use this measure to rank Q i s , and select the top-k queries as suggestions to Q
T . However, there are two concerns for using the straight-forward and formal solution we presented in Section 2.
To overcome these two concerns, we propose the following efficient algorithm for query suggestion using hitting time: Algorithm 1 Query Suggestion Using Hitting Time A bipartite graph G = ( V 1  X  V 2 , E ) consists of query set V and URL set V 2 . There is an edge in E from a query i to an URL k if this URL is clicked, and the edge is weighted by the click frequency w ( i, k ) . 1. Given a query s in V 1 , a subgraph is constructed by us-2. Form a random walk on the subgraph by defining tran-3. For all queries except the given one, iterate 4. Let h  X  i be the final value of h i ( t ). Output the queries
A good selection of k would control that the ranking of top k queries stays stable in future iterations. In Section 4, we will show that k does not need to be large, which ensures the efficiency of this algorithm. In some scenarios, a different initialization of W can be used. For example, one can use mutual information of a query and a URL instead of the clickthrough frequency to initialize w ij . One can also use a weighting schema such that w ij 6 = w ji , which naturally generalizes this method to directed graphes.

Please note that since we are interested in query sugges-tions, we fold the bipartite graph into a general graph in the algorithm above. In general, we can easily unfold the graph in the algorithm, by setting p ij = w ( i,j ) d
Personalization is desirable for many scenarios where dif-ferent user has different information need. People in New York are likely to use  X  X sg X  to access the sports center, thus a suggestion like  X  X adison square garden X  is quite useful. People in other states, on the other hand, may use  X  X sg X  to access the food additive, and a suggestion like  X  X onosodium glutamate X  is desirable.

There has been quite a few work on personalized search [11]. However, how to generate personalized query sugges-tion is still an unsolved problem. [8] presents automatical query completion with local information, but that method is based on query morphology and cannot be applied to gen-erate personalized semantic suggestions.

We now present that our method using hitting time on bi-partite graph can be easily adapted to generate personalized query suggestions. Intuitively, when we know the identity of the user (e.g., his IP address), we should update our knowl-edge about the information need of this query.

One may say that a simple method is to construct the bi-partite graph solely based on the history of that user. How-ever, that could easily fall into the problem of data sparsity. The simple treatment also loses the opportunity of using common wisdom. If a user already knows what query to use (e.g., learning from his history), it is not clear how much query suggestion could help.
  X  X a X  + user
Figure 2 illustrates an intuitive treatment of personalized query suggestion. Once we know the user, we need to up-date what we know about the query. This can be viewed as equivalent to replacing the original query (e.g.,  X  X a X ) with a pseudo query, which is user specified (e.g.,  X  X a X  + user).
Once we know the user, we adjust the URLs that he would click with this query based on the history of this user. Now the pseudo query connects to some URLs instead of others. And different suggestions will be generated comparing with the non-personalized suggestions. In Figure 2,  X  X merican airline X  is now a better suggestion than  X  X lcoholics anony-mous X  to  X  X a X  given the user.

The remain problem is how to adjust the weights on the edges between the pseudo query and the URLs. In principle, giving the original query Q T , in computing the hitting time we only cares about p i j where v j = Q T and v i is a URL, or simply as p ( Q T | U RL ). p ( Q T | U RL ) is computed with larly, giving the pseudo query Q P , we are only interested in p ( Q P | U RL ), or p ( Q T | U rl, U ser ).

A simple computation is However, it could still fall into the problem of data sparsity. Interestingly, one can notice that many probabilistic person-alized search algorithms proposed nowadays are essentially computing  X  p ( U rl | Q, U ser ) [20, 17, 16]. This means that we can easily adopt any such personalized search algorithm, and compute p ( Q T | U rl, U ser ) =  X  p ( U RL | Q T , U ser ) p ( Q
This suggests that without twisting the algorithm struc-ture or the whole graph, we can easily embed personalization into query suggestion, by adjusting w ij at step 2 in the al-gorithm in Section 3. Specifically, if v j = Q T (the original query) and v i is a URL, we assign new weights for W ij by The rest of the algorithm remains the same with the non-personalized query suggestion.

As a concrete example, if we use the IP address to identify a user, we can adopt the personalization with backoff model in [16] and embed in Equation 2 with Here IP i means the first i bytes of IP.

An alternative treatment for personalized query sugges-tion is to add some related vertices (queries or URLs) into the target set A based on the user interest. We leave this as a direction in the future.
In Section 3, we introduced the algorithm of query sugges-tion using hitting time, and its natural adaptation to per-sonalized query suggestion. In this section, we use empirical results to show the effectiveness of the proposed algorithms.
We collect a large scale query log dataset from a commer-cial search engine of about 1.5 years up to July 2007. This 1.5 years data contains 637 million unique queries, and 585 million unique URLs. We use IP address to identify users in personalized query suggestion. This dataset contains 193 million unique IP addresses.

To make it easier for others to reproduce our results, we also collected a publicly available dataset of authors and titles from DBLP 6 , as of Feb. 2008. We extract 110k papers in computer science and around 580k unique authors from that dataset.

The experiments and results from the two datasets are presented in the following sections. We use the Query-URL bipartite graph extracted from the 18 month data and generate suggestions for all queries. We selectively show the results in Table 1.

We present the comparison of suggestions generated from our algorithm and those from Google, Yahoo, and Live. Clearly, we can see that the suggestions generated with hit-ting time focus on different aspects than suggestions cur-rently provided by the three major search engines. Specifi-cally, there are several major differences: 1. The suggestions generated with our method are more 2. Our method generates suggestions that are morpholog-3. Our method generates useful suggestions even for in-http://www.informatik.uni-trier.de/  X  ley/db/
The system generated suggestions for  X  X sg X  are compara-ble with those suggested by the major search engines. Our method captures the food additive in the suggestions, which is the most commonly known semantics of msg. We also see another meaning of msg, madison square garden, ranked lower in top 10 suggestions. When people use  X  X riends X  as a query instead of  X  X riend, X  it usually carries a special se-mantics (i.e., the Friends TV series). The query suggestions generated using our system well captured this special se-mantics, while the major search engines mostly return sug-gestions about the common sense of friend. Indeed, the three search engines generate mostly the same suggestions for  X  X riend X  and  X  X riends, X  while our system generate quite different suggestions for  X  X riend, X  such as  X  X riend to friend shelter, X   X  X riend dictionary, X  and  X  X eb friend. X 
From the suggestions for  X  X a, X  we see that our system not only captures the most common sense, the  X  X merican airline,  X  it also successfully boosts infrequent queries as suggestion ( X  X lcoholics anonymous X  and  X  X utomobile asso-ciation X ). The major search engines, however, captured the most common meaning but lost the opportunity of visiting the long tails.

On the rightmost column of Table 1, we show three exam-ple queries for which our system generates good suggestions while the search engines do not. All such queries are  X  X ong tail X  queries in search business. We see that using hitting time on the Query-URL graph, we generate meaningful sug-gestions even if the suggested terms do not co-occur with the original query.

For example, the query  X  X anknet X  is a learning-based rank-ing algorithm used in web IR based on  X  X airwise tests. X   X  X earning to rank X  is a nice generalization of the query, while  X  X dcg X  is the key performance measure used in web search, which such an algorithm tries to optimize. Chris Burges is one of the inventors of RankNet, and  X  X ambdarank X  is their following work. Such suggestions are all semantically relevant to the original query.
 In another example,  X  X he long tail X  is a famous book by Chris Anderson, the theory of which is well applied in out-sourcing better quality at a lower cost.

All experiments presented above show that our algorithm effectively generates semantic consistent query suggestions, and provides a way of treating and boosting long tail queries. As discussed in Section 3.2, the algorithm of query sugges-tion with hitting time can be easily adapted to personalized query suggestion. As an illustrative example, we use an IP address to identify a user, and embed the personaliza-tion with backoff model (Equation 4) in computing Equa-tion 2. The personalized query suggestion compared with non-personalized query suggestion are shown in Table 2.
From Table 2, we see that given the IP address of the user, the system generates quite different query suggestions than if the IP is unknown. If the query is from Microsoft, the system will suggest  X  X icrosoft research X  related queries for  X  X sr X  instead of  X  X ountain safety research, X  and  X  X dd conference X  related queries for  X  X dd. X   X  X DDI X  is a Japanese corporation on telephone business which is used to be called  X  X okusai Denshin Denwa (KDD), X  and is more interesting to the common audience. Similar treatments can be found for the query  X  X sg, X  where  X  X adison square garden X  related queries are suggested to people who live near New York.
Another interesting example is the query  X  X ootball X , which means American football in the States but usually means soccer in Europe. When the query is from the United States, the system suggests American football related concepts, as well as the  X  X ox nfl X , where  X  X ox X  is a well-known television network in the States. If the query is from United King-dom, the systems suggests soccer related concepts, as well as  X  X bc X , a broadcasting corporation located in UK.
Search log data is associated with privacy concerns as well as Intelligence Property issues, and is usually not accessible to people outside the search engine companies. To generate reproducible results for the common audience, we design similar experiments on a publicly available dataset, DBLP. The most commonly explored graph on the bibliography data is the coauthor graph. In this experiment, we con-structed a coauthor graph from the DBLP data, by making a vertex for every author, and an edge between two authors if they coauthored in a paper. The weight on each edge cor-responds to how many papers that the two researchers have coauthored.

The method of query suggestion using hitting time is gen-eralized, and can be applied on both bipartite graph, or a general graph (e.g., a query-query graph). Indeed, with the notion introduced in Section 2, we can fold a bipartite graph into a graph with only one group of vertices, but with a dif-ferent weighing function for the folded edges. We use such a coauthor graph to demonstrate that our algorithm can generate interesting suggestions with a general coocurrence graph.

In Table 3, we present the suggestions generated based on computing the hitting time on the coauthor graph. The middle three columns presents the suggestions based on the hitting time computation. By default, for each author name query (shown in column 1), we construct the subgraph by including all authors that are less or equal to distance 6 to the target author. The six degrees of separation 7 is well known in social network analysis that the average distance of a vertex to all others is around 6. Indeed, such a subgraph usually contains 410  X  450k authors, which covers more than 70% of the entire graph. We vary the number of iterations and the size of the subgraph to show the robustness of our method.

From Column 3 through 5, we see that our system tends to suggest authors that collaborate intensively with the tar-get query (e.g., students of a professor, and collaborators who works exclusively with the author). It is interesting to http://en.wikipedia.org/wiki/Six degrees of separation see that the system suggests  X  X awrence Page X  for  X  X ergey Brin X . When we use 10 iterations for our algorithm in Sec-tion 3, it already achieves similar ranking to the exact solu-tion, which we get from solving the linear system completely.
Can we use a smaller subgraph? We present the experi-ments on smaller subgraphs, where all authors are at most 2 steps away from the original author query. From the 4 th column of Table 3, we see that a smaller graph captures most of the values of the larger one in terms of query sug-gestion. This experiment shows that without much loss of performance, the algorithm of query suggestion using hitting time can be made more efficient by using a smaller subgraph (  X  1000 vertices) and a few iterations.

Since our work is also based on a random walk on a large scale graph, it is interesting to show how different are our results from other random walk methods. For example, per-sonalized PageRank [11] is a method that is usually used to rank vertices on the graph in a query dependant way. The corresponding linear system of personalized PageRank can be shown as: where R (0) i is a personalized (or query dependent) initial values for vertex i . We may set R (0) i = 1 if v i = Q T 0 otherwise. It is easy to show that if s = 1, R will be the stationary distribution of random walking on the graph, which is proportional to the degree of vertices. We expect that personalized PageRank would still favor authors who published a lot of papers and have a lot of coauthors.
We present the query suggestions ranked by personal-ized PageRank in the rightmost column in Table 3. We also present the nearest neighbors of Q T (i.e., v j  X  X  with the largest w ( Q T , j )).

We see that personalized PageRank generates quite dif-ferent suggestions to hitting time. It indeed favors authors with higher degrees, e.g.,  X  X ndrew Tomkins X  and  X  X ridhar Rajagopalan X  for  X  X on M. Kleinberg, X  and  X  X onika R. Hen-zinger X  for  X  X ergey Brin. X  In fact, we can see that using personalized PageRank does not gain much different top-k suggestions compared with using just the k nearest neigh-bors. Although  X  X ig X  authors are more visible, putting them in the query suggestions blocks the  X  X maller X  authors to be seen, and also causes a topic drift. One could imagine that when a user want to find a Ph.D student whose name he couldn X  X  remember, he is likely to begin with searching his advisor (and a query suggestion of his students would be very helpful). On the other hand, there are way many better directions to find a  X  X ig X  name than beginning with another  X  X ig X  name. Please note that our method does not have a model parameter to tune.

The experiments above suggest that our proposed method applies well on query-query graphs, generates better sugges-tions than other random walk method, and can be made quite efficient.
 We then constructed a bipartite graph from the bibliography data by segmenting the titles of every paper into all unigram and bigram words it contains. We made a vertex for every author and every keyword. We then connected an author and a keyword with an edge if the author used that keyword. The weight on each edge corresponds to the frequency that the user used that keyword. We removed the stop words from the title, and no domain knowledge has been applied. In this way, we get a bipartite graph G = ( V, E ). V = V  X  V 2 where V 1 are the set of all authors and V 2 is the set of all unigram and bigram title terms. As a result, this provides us a bipartite graph of 1.6M vertices, in which around 1M vertices are unigram and bigram keywords. We then sim-ulate that a user would type a keyword (either a unigram or a bigram) as a query, and use our proposed algorithm to generate suggestions to the keyword query. The sample results are presented in Table 4.

It can be easily discovered from Table 4 that our sys-tem generates very reasonable suggestions to those keyword queries. All suggestions for the six given queries are seman-tically close the original query.

Another interesting question on the DBLP data is whether we can suggest keywords for a query of author. Indeed, we can apply our algorithm by computing the hitting time from every keywords to the original query (an author). We then select the top ranked keywords as keyword suggestions for an author query. The results are selectively shown in Table 5.
Presumably, the suggestion keywords should well capture the semantics of the author, or the research topics that the author mostly works on. We first present the k nearest neighbor keywords of each author in the Author-Keyword bipartite graph. For both queries, we see that all such near-est neighbor terms are too broad. They tend to be too gen-eral to capture the author X  X  specific research topics. We also used personalized PageRank to generate suggestions (as in column 4), but unfortunately it still improves tiny over the k nearest neighbors. From the column 3 of Table 5, however, we clearly see that we get much better suggestions using hitting time. Indeed, the suggestions generated are general enough to convey coherence meanings, and also tight enough to represent the special interest of the author query. Inter-estingly, because we segment unigrams and bigrams in a to-tally unsupervised way, a huge number of bigrams are non-meaningful segments, such as  X  X ased approach, X   X  X uided mining, X  and  X  X lusters among, X  the suggested bigrams us-ing hitting time are all meaningful phrases.

In this Section, we use experiments on two different datasets to show that query suggestion using hitting time is effective to generate semantically consistent query suggestions, long tail suggestions, as well as personalized suggestions.
Query suggestion has been a well-accepted utility used by many search engines to help user explore and express their information need. While there are quite a few work on gener-ating different types of query suggestions, such as query auto completion [7, 8], query spelling correction [10, 15], query expansion [21, 22, 3], and query rewriting [1, 13]. While most early query suggestion methods explore document in-formation, query log data has been widely used recently.
Query frequency [15, 7, 8], term coocurrence [4, 13, 19], query clickthrough [12, 23, 9, 18], and query chains [17] are among the most used types of information in query log. In this paper, we adopt the query clickthrough information, but the proposed method of query suggestion using hitting time does not rely on such information. Indeed, our algorithm can be applied with all such types of information, as long as an undirected graph of queries, or a bipartite graph of queries and other types of entities, can be constructed.
There are different ranking methods proposed using ran-dom walk on a Query-URL graph. PageRank [5] is basi-cally computing the stationary distribution of a smoothed Markov chain. Personalized PageRank generalizes PageR-ank by smoothing the Markov chain with a user (or query) specific jumping probability vector instead of a uniform vec-tor, thus is often used for query-dependent ranking [11]. HITS [14] is an alternative query-dependent ranking algo-rithm which computes two different scores (hub and author-ity) in an alternating way. [9] proposed a ranking function which is basically computing the n-step transition probabil-ity from the original vertex to the target.

However, all such methods are essentially computing  X  X ow much weights can be distributed to a vertex from its neigh-bors X . This ends up with favoring vertices with large degree and usually results in topic drift. Indeed, topic drift has been a well discussed problem of HITS [6]. Instead, our algorithm computes  X  X ow soon can I reach the original query if I be-gin at a suggestion, with an average of all possible paths X . This guarantees that the semantics of the top ranked sugges-tion will be coherent with the original query. Unlike other random walk methods, it also boosts infrequent queries. An-other advantage of the hitting time is that it does not have a parameter to tune, while all the self-jump based methods (e.g., PageRank, personalized PageRank, and n-step transi-tion) all has one or more critical parameters to tune.
In terms of updating the original query, our work is also relevant to feedback [24, 20, 17] in information retrieval. However, both pseudo-feedback and implicit-feedback could easily add in irrelevant terms into the query, especially when the feedback documents has a rich content. Our method utilizes the common wisdom and control the relevance of suggested queries.
As a ranking function on a graph, hitting time is gen-eral and does not rely on the specific type of graphs. We illustrated its power by generating query suggestions from a Query-URL bipartite graph, but there are many other pos-sibilities. On the other hand, the Query-URL relation (i.e., clickthrough) is not the only information conveyed in a large scale search log. Indeed, one can extract Query-IP graphs, Query-Query relations considering session information, etc.
Ranking search-related entities on a graph using hitting time can be regarded as a general treatment of a lot of inter-esting problem. For example, ranking URLs given a query (by computing h A ( U RL  X  Q )) suggests a method of rank-ing web pages without looking at their content. h A ( U RL  X  U RL ) leads to finding similar pages, h A ( Q  X  U RL ) sug-gests search terms for a webpage, and h A ( IP  X  IP ) pro-vides a way to find people who have similar interests like you. All these are interesting directions to apply the method proposed in this paper.
 There are many interesting future directions to this work. A real query suggestion system should balance many differ-ent features. It is interesting to embed our method as a new feature into a real query suggestion system, and quantita-tively evaluate how much our method can benefit the current system. Another possible future work is to apply the gen-eral algorithm on other types of graphs, for example graphs built from query-session data, query-user graphs, as well as directed graphs. It will then be interesting to generate query suggestions using multiple types of graphs.
In this paper, we proposed a novel query suggestion ap-proach based on the computation of hitting time on large scale bipartite graphs. Unlike existing query suggestion meth-ods, our proposed method controls the semantic consistency of the suggestions to the original query. The proposed method has several advantages over existing methods: 1) the gener-ated suggestions are semantically consistent to the original query; 2) the method boosts long tail queries as suggestion, and also generates suggestions for long tail queries despite of sparsity of data; 3) the method extracts suggestions that did not cooccur with original query; and 4) our method can be generalized to personalized query suggestion by simply em-bedding in any probabilistic personalized search methods. Experiments show that our method effectively generates se-mantic query suggestions as well as personalized query sug-gestions. The hitting time based method does not have a model parameter to tune, and can be easily transformed as a feature in existing query suggestion systems. [1] E. Agichtein, S. Lawrence, and L. Gravano. Learning [2] C. Anderson. The Long Tail: Why the Future of [3] R. A. Baeza-Yates, C. A. Hurtado, and M. Mendoza. [4] D. Beeferman and A. Berger. Agglomerative clustering [5] S. Brin and L. Page. The anatomy of a large-scale [6] S. Chakrabarti, M. Joshi, and V. Tawde. Enhanced [7] K. Church and B. Thiesson. The wild thing! In [8] K. W. Church and B. Thiesson. The wild thing goes [9] N. Craswell and M. Szummer. Random walks on the [10] S. Cucerzan and E. Brill. Spelling correction as an [11] T. Haveliwala, S. Kamvar, and G. Jeh. An analytical [12] T. Joachims, L. Granka, B. Pan, H. Hembrooke, and [13] R. Jones, B. Rey, O. Madani, and W. Greiner. [14] J. M. Kleinberg. Authoritative sources in a [15] M. Li, Y. Zhang, M. Zhu, and M. Zhou. Exploring [16] Q. Mei and K. Church. Entropy of search logs: how [17] F. Radlinski and T. Joachims. Query chains: learning [18] F. Radlinski and T. Joachims. Active exploration for [19] D. Shen, T. Walkery, Z. Zhengy, Q. Yangz, and Y. Li. [20] X. Shen, B. Tan, and C. Zhai. Implicit user modeling [21] J.-R. Wen, J.-Y. Nie, and H.-J. Zhang. Clustering user [22] R. W. White and G. Marchionini. Examining the [23] G.-R. Xue, H.-J. Zeng, Z. Chen, Y. Yu, W.-Y. Ma, [24] C. Zhai and J. Lafferty. Model-based feedback in the
