 This paper investigates techniques for detecting indepen-dence of SPARQL queries from updates. A query is inde-pendent of an update when the execution of the update does not affect the result of the query. Determining independence is especially useful in the context of huge RDF repositories, where it permits to avoid expensive yet useless re-evaluation of queries. While this problem has been intensively studied for fragments of relational calculus, very few works exist for the standard query language for the semantic web. We re-port on our investigations on how a notion of independence can be defined in the SPARQL context.
The Resource Description Framework ( RDF ) is a graph data format for the representation of information in the Web. An RDF statement is a subject-predicate-object struc-ture, called RDF triple, intended to describe resources and properties of those resources. Due to their homogeneous structure, RDF databases can be considered as labeled di-rected graphs, where each triple defines an edge from the subject to the object node under label predicate [6]. With SPARQL [7], the W3C has recommended a query language for RDF . SPARQL comes with a powerful graph matching facility, whose basic constructs are called triple patterns. During query evaluation, variables inside these patterns are matched against the RDF input graph. The solution of the evaluation process is then described by a set of mappings, where each mapping associates a set of vari-ables with graph components.
 With the introduction of a standard update language for RDF in SPARQL 1.1. Update [7], the query-update inde-pendence problem has been introduced.
 A query and an update are independent when the query result is not affected by update execution, on any possible input database. Detecting query-update independence is of crucial importance in many contexts, for example to min-c  X  imize view re-materialization or to ensure isolation, when queries and updates are executed concurrently. Benefits are amplified when query-update independence can be checked by analyzing only the structure of the query against the structure of the update, hence avoiding the costs of (even partial) reevaluation of queries on large datasets. This paper formulates and investigates the problem of SPARQL query-update independence. To the best of our knowledge, it is the first work in this direction.
 We present some necessary background on RDF and SPARQL in Section 2. We formalize a notion of query-update inde-pendence for SPARQL in Section 3. This is the first formal-ization of the SPARQL query-update independence prob-lem. We discuss characteristics desired for algorithms that effectively check for independence. We introduce a simple condition for detecting independence, which admits an effi-cient implementation. We discuss the difficulties introduced by SPARQL  X  X  open world assumption and draw perspec-tives for further research in Section 4. Finally we conclude in Section 6. RDF . RDF is a graph data format for the representation of information in the Web. An RDF statement is a subject-predicate-object structure, called RDF triple, intended to describe resources and properties of those resources. Let U,B,L be three disjoint infinite sets denoting the set of URI s (identifying a resource), blank nodes (denoting an unidentified resource) and literals (a character string or some other type of data) respectively. We abbreviate any union of these sets as for instance, UBL = U  X  B  X  L . More for-mally, an RDF triple t is a tuple ( s,p,o )  X  UB  X  U  X  UBL , where s is the subject, p the predicate and o the object. A set of RDF triples is often referred to as an RDF graph.
Example 1 (Rdf Graph). Consider 10 triples about employers and their informations (all identifiers correspond to
URI s):
The authors are supported in part by ANR TYPEX ANR-11-BS02-00. SPARQL . SPARQL is a W3C recommended query lan-guage for RDF . We restrict ourselves to the core fragment of
SPARQL over simple RDF graph, which is sufficient for our purposes.

Syntax . SPARQL is based on the notion of query pat-terns defined inductively from triple patterns. A triple pat-tern is a tuple tp  X  UBV  X  UV  X  UBLV , with V a set of variables disjoint from UBL . Triple patterns grouped together using SPARQL operators (like and , opt , union ) form query patterns (or graph patterns).

Definition 1 (Query Pattern). The syntax of a query pattern q is inductively defined as follows: SPARQL provide several kind of queries. We focus on SELECT queries which are the core of SPARQL queries.
Definition 2 (Select query). A SELECT Query is a V which are called distinguished variables, and q is a query pattern.
 Example 2 (Select query). . Consider the query: that queries an RDF graph for an email ? e of a person ? a and, if available, for a web page ? p of ? a , where ? a ,? are distingueshed variables and email and web are URI s. Semantics . The standard semantics of SPARQL queries is given by a partial mapping function  X  : V  X  UBL , that assigns RDF terms of an RDF graph to variables of a SPARQL query. For a triple pattern t , we denote by  X  ( t ) the triple obtained by replacing the variables in t according to  X  . For a query pattern q , we denote by  X  ( q ) the set of ground triples (triples not containing any variables) obtained by replacing the variables in q according to  X  . The set of all possible mapping-sets, each of which represents a SPARQL query solution, is denoted by  X .

Example 3 (Query solution). Consider the query pattern in Example 2: that queries the RDF graph in Example 1, the query pattern solution  X  is represented as the set of {  X  1 , X  2 } where:
Two mappings  X  1 and  X  2 are said to be compatible (writ-ten  X  1  X   X  2 ) when  X  ? x  X  dom (  X  1 )  X  dom (  X  2 ) we have  X  (? x ) =  X  2 (? x ). Mappings with disjoint domains are al-ways compatible. Let  X  1 and  X  2 be sets of mappings, the following operators are defined: Evaluation . Now, we can formalize the evaluation of query patterns over an RDF graph G as a function J . K G , induc-tively defined as follows: J q 1 union q 2 K G = J q 1 K G  X  J q 2 K G where var ( t ) is the set of variables occurring in t , dom (  X  ) is the domain of  X  , and the projection operator  X   X  X  X   X  selects only those part of the mapping relevant to variables in  X  X  X  SPARQL Updates . We now define the syntax and seman-tics of the SPARQL Update language [7] whose purpose is to modify a RDF database.

Syntax . SPARQL Update uses a syntax derived from the SPARQL query language introduced previously. Up-date operations are performed on a collection of graphs. Possible operations include updating, creating and remov-ing RDF graphs in a collection. In this paper, we consider the operations performed on a single graph such as:
We focus mostly on insert/delete operations that con-stitute the fundamental pattern-based actions for graph up-dates. The specifiation of triples is based on quad patterns.
Definition 3 (Quad pattern). A quad pattern q u is inductively defined as follows: where tp  X  UV  X  UV  X  ULV . A quad pattern is a query pattern that doesn X  X  allow blank nodes.

The insert/delete operation can be used to remove or add triples from/to a graph based on bindings for a quad pattern specified in a where clause.

Definition 4 (sparql update operation [1]). Let q , q i , and q w be quad Patterns, then u( q d , q i , q w operation, has the form
Semantics . Intuitively, the semantics of the execution of u ( q d ,q i ,q w ) on G , denoted as G u ( q d ,q i ,q is defined interpreting both q d and q i as  X  X emplates X  to be instantiated with the solution  X  = J q w K G
Definition 5 (Na  X   X ve Update Semantics [1]). Let G be a triple store, and u ( q d ,q i ,q w ) an update operation, then, a na  X   X ve update of G with u ( q d ,q i ,q w ) , denoted G is defined as ( G \ A d )  X  A i , where A d = S  X   X  A
In this section we introduce and formalize the query-update independence problem for SPARQL . Intuitively, a query q is independent of an update u , if evaluating q after or before u returns the same result. In other terms, independence holds whenever solutions of query patterns remain unchanged dur-ing the addition or deletion of triples from the RDF graph. We first recall the closest notion that we have found in the literature: Proposition 1 (Query Solution Invariance[11]).
 respect to an RDF graph G and for a triple t , there exists no mapping  X  from query variables to RDF terms such that t  X   X  ( q ) , then  X  is also the set of all solutions for G and G  X  = G \{ t }
We generalize this proposition below, taking into consid-eration an update u that defines a set of triples to add or to delete from a graph G.
Proposition 2. Let q be a select query and u be an up-date. We say that q and u are independent iff
Independence between queries and updates is thus ex-pressed as the equivalence of two evaluations: one evaluation that computes the answer to the query before the update, and a second evaluation that computes the answer after the update.
 Detecting independence is important for several reasons. It can be used in view maintenance to identify that some views are independent of certain updates. We can provide greater flexibility by identifying that one query is independent of up-dates made by another program or person. Finally. We can use independence in query optimization by ignoring parts of the RDF dataset for which updates do not affect a specific query (to ensure isolation). Costs . Obviously, we can verify at runtime whether an up-date impacts a query: we simply run the update after a first query evaluation, then re-run the query, and finally compare the results. The overall cost c of such a check is dominated by the cost of evaluating the query (twice) on the whole RDF dataset and the update (once). Thus, a method for testing independence makes sense only if its cost is lower than c . A first class of interesting methods regroups all purely static analysis methods, whose cost depends only on the size of the query and on the size of the update, and not on the size of the RDF dataset. A second class of interest-ing methods regroups hybrid static/dynamic methods that might involve evaluation or partial evaluation of the query on a fraction of the RDF dataset, and whose cost lower than c nevertheless depends on the RDF dataset size.
 Dealing with the Open-World Assumption . While similar query-update independence problems have been in-tensively studied for other query languages (in particular for fragments of the relational calculus), very few works exist for SPARQL . We believe that one reason for this is due to SPARQL  X  X  underlying open world assumption (a.k.a OWA ). We recall that OWA applies to a system that has incomplete information. The web, for instance, is tradition-ally considered as a system with incomplete information. The absence of some information on the web does not mean that this information is false, but simply that this informa-tion has not been made explicit: it is unknown. SPARQL , as a query language for RDF , inherits from this assump-tion. It thus constitutes an open-world framework that al-lows anyone to make statements about any resource. Any independence analysis method should thus consider this as-sumption at its core.
 In the next section, we propose a simple condition for testing independence, in the presence of OWA .
We define a condition for checking query-update indepen-dence, as follows:
Theorem 1 (Condition for independence). Let Q be the set of all triple patterns that appear in the query pat-tern of the query q and U be the set of all quad patterns that appear in the DeleteClause and InsertClause of an update u : where Q X  X  =  X  is defined as follows: and t q 6 = t u  X  X  X  % q  X  J t q K G ,  X  % u  X  J t u K ,% q Proof. (Sketch) (  X  ) By contradiction.
 least a triple t that is added or deleted from G 0 such that t is a triple in the path or in the solution of the query q . We can easily check that t  X  X  X  X  6 =  X  . In fact, t  X  X  holds because t is a triple added to or deleted from G 0 , so  X  t u  X  U .t = t and t  X  Q holds because the result of applying q after u changes, so  X  t q  X  X  .t = t q . (  X  ) By contradiction.
 Suppose Q X  X  6 =  X  , by definition,  X  t u  X  U ,t q  X  Q .t u Let t u = t q , there always exists a ground triple t that matches both t q and t u (i.e. replacing variables by blank nodes). Starting from t we can easily construct a graph G , such that J q K G 6 =  X  and J q K 6 = J q K G \{ t } or J
Our condition above can be checked statically with the query and the update, independently from any particular RDF dataset. Such a test fits in the category of purely static analysis methods. It can easily be implemented in linear time with respect to the size of the query and the update. When independence is detected, it allows to avoid the cost of re-evaluation of queries on large datasets.
We identify two main research directions for the further development of methods aimed at detecting query-update independence: Hybrid static/dynamic methods. The condition that Methods supporting schema constraints. One per-
In order to understand the impact of schema constraints, let us consider the following example.

Example 4 (Schema example). Let q be a query and u be an update defined as follows: q and u are dependent under OWA. For example, if we add the triple t = ( a,phone,A 3 ) in the graph of Example1, the resulting graph G is such that J q K G 6 = J q K u ( G ) .
However, the situation changes completely if we add schema constraints stating that phone has a domain  X  X erson X  and a range  X  X umber X  and in addition that  X  X erson X  is disjoint from  X  X umber X  (which can be easily formulated in OWL for instance). In this case, we can see that the variable ? of q belongs to  X  X erson X , while the ? x of u belongs to  X  X um-ber X , so the update does not affect the query result. In the presence of such constraints q and u are independent.
To the best of our knowledge, our work is the first to for-malize and investigate the query-update independence prob-lem for the SPARQL language. Several techniques have been developed for the static analysis of SPARQL , mainly focusing on containment and equivalence of queries [12, 4, 9], possibly in the presence of schemas [4, 5]. Such tech-niques aim at detecting relations (typically inclusions) be-tween two queries, both evaluated using the same seman-tics. This common semantics is a key ingredient that these techniques exploit. These techniques hardly extend to the present context where the semantics of an update is signif-icantly different from the semantics of the query. In the presence of schema constraints, as pointed out in [1] several semantics can be provided for SPARQL Update and, there is no  X  X ne-size-fits-all X  update semantics.
 This work is partly inspired by the works on SPARQL query caching [11], where a first notion of query solution invari-ance for caching is defined. We formalized the notion of query-update independence and made this notion more pre-cise and more general. Outside the SPARQL context, the query-update independence problem has been intensively studied, in particular in the relational context [3, 10] and in the setting of XML structures [2, 8]. However, due to the SPARQL / RDF  X  X  open world assumption, these results do not transfer to the SPARQL context.
We present a first formalization of the SPARQL query-update independence problem. We motivate the interest of searching for methods that solve this problem. We also explain difficulties and discuss characteristics desired for al-gorithms that effectively check for independence. We intro-duce a simple condition for detecting independence, which admits an efficient implementation. We identify more gen-eral classes of interesting methods and draw perspectives for further research. [1] A. Ahmeti and A. Polleres. SPARQL update under [2] M. Benedikt and J. Cheney. Destabilizers and [3] J. A. Blakeley, N. Coburn, and P.-A. Larson.
 [4] M. W. Chekol, J. Euzenat, P. Genev`es, and [5] M. W. Chekol, J. Euzenat, P. Genev`es, and [6] C. Gutierrez, C. A. Hurtado, and A. O. Mendelzon. [7] S. Harris and A. Seaborne. SPARQL 1.1 query [8] M. Junedi, P. Genev`es, and N. Laya  X   X da. XML [9] A. Letelier, J. P`erez, R. Pichler, and S. Skritek. Static [10] A. Y. Levy and Y. Sagiv. Queries independent of [11] M. Martin, J. Unbehauen, and S. Auer. Improving the [12] G. Serfiotis, I. Koffina, V. Christophides, and
