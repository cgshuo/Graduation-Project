 Entity extraction (also known as entity recognition) extracts entities (e.g., person names, locations, companies) from text. Approximate (dictionary-based) entity extraction is a re-cent trend to improve extraction quality, which extracts substrings in text that approximately match predefined en-tities in a given dictionary. In this paper, we study the problem of approximate entity extraction with edit-distance constraints. A straightforward method first extracts all sub-strings from the text and then for each substring identifies its similar entities from the dictionary using existing methods for approximate string search. However many substrings of the text have overlaps, and we have an opportunity to utilize the shared computation across the overlaps to avoid unnecessary duplicate computations. To this end, we pro-pose a heap-based framework to efficiently extract entities. We have implemented our techniques, and the experimen-tal results show that our method achieves high performance and outperforms existing studies significantly.
 H.2.8 [ Database Applications ]; H.3.3 [ Information Stor-age and Retrieval ]: Information Search and Retrieval Algorithms, Experimentation, Performance Approximate Entity Extraction, Edit Distance, Heap
Dictionary-based entity extraction extracts all the sub-strings from given text that match predefined entities in a dictionary. For example, consider text  X  Maros Hadjilefthe-riou, Nick Koudas, Divesh Srivastava: Incremental main-tenance of length normalized indexes for approximate string matching  X , and a dictionary with two entities  X  Marios Had-jieleftheriou  X  X nd X  Nick Koudas  X . Dictionary-based en-tity extraction extracts the predefined entity  X  Nick Koudas  X  from the text. It has many real applications in the fields of information retrieval, molecular biology, bioinformatics, and natural language processing. However, usually text may contain typographical or orthographical errors [5], especially the text crawled from the Web. For example, the substring  X  Maros Hadjileftheriou  X  in the above text has typograph-ical errors. However the traditional (exact) entity extraction cannot extract this substring from the text, since the sub-string does not exactly match the predefined entity  X  Marios Hadjieleftheriou  X . Approximate (dictionary-based) en-tity extraction is a recent trend to address this problem, which can extract substrings from the text that approxi-mately match the predefined entities.

Many similarity functions have been proposed to quantify the similarity between two strings, such as jaccard similar-ity, cosine similarity, and edit distance. In this paper, we study the problem of approximate entity extraction with edit-distance constraints, which, given a dictionary of enti-ties, text, and an edit-distance threshold, finds all the sub-strings from the text that have edit distances to an entity in the dictionary no larger than the given threshold. For in-stance, in the above example, approximate entity extraction can extract the substring  X  Maros Hadjileftheriou  X  X hich is similar to a predefined entity X  Marios Hadjieleftheriou  X .
A straightforward method to this problem first extracts all the substrings from the text, and then for each substring identifies its similar entities in the dictionary using existing methods for approximate string search [4]. As many such substrings have overlaps, this method involves unnecessary duplicate computations across the overlaps. For example, consider the above text, we first generate its substrings, such as  X  Maros Hadjileftheriou  X ,  X  aros Hadjileftheriou nick  X ,  X  ros Hadjileftheriou nick koudas  X , then we find their similar en-tities from the predefined dictionary. We observe that these substrings have many overlaps, and we have an opportunity to utilize the shared computation across overlaps to elim-inate the unnecessary duplicate computations. Although there have been recent studies on approximate entity ex-traction [5, 2, 1], they do not focus on using the shared computation across overlaps to improve performance. To address this problem, in this paper we propose heap-based methods which can fully utilize the shared computation.
In this section, we first formalize the problem of approxi-mate entity extraction with edit-distance constraints. Then we introduce two existing methods to address this problem. Edit Distance: In this paper, we use edit distance to quan-tify the similarity between two strings. Formally, the edit distance between two strings r and s , denoted as ed ( r, s ), is the minimum number of single-character edit operations (i.e., insertion, deletion, and substitution) needed to trans-form r to s . For example, ed ( marios , maras )=2. Inthis paper two strings are similar if their edit distance is no larger than a given edit-distance threshold  X  . Based on this notation, we formalize the problem of approximate entity extraction with edit-distance constraints as follows. Definition 1 (Approximate Entity Extraction).
 Given a dictionary of entities E = { e 1 ,e 2 ,...,e n } ,text S , and an edit-distance threshold  X  , approximate entity extrac-tion finds all pairs s, e i such that ed ( s, e i )  X   X  ,where s is a substring of S and e i  X  E .
 For instance, consider text S and dictionary E in Table 1. Suppose the edit-distance threshold  X  =2.  X  maros hadji  X ,  X  marios hadji  X  ,and  X  nic kouds  X ,  X  nick koudas  X  ,  X  dievesh criva  X ,  X  divesh sriva  X  are three example results. Es-pecially, although the substring of the text  X  sigmodmaros hadji  X  X isses a space between X  sigmod  X  X nd X  maros  X (atypo-graphical error), our method still can extract X  maros hadji  X . ID Entities Length 1 nick koudas 11 2 marios hadji 12 3 divesh sriva 12 4 dievemaros 10 5 rivakoudieva 12 q -gram: A q -gram of a string s is a substring of s with length q .The q -gram set of s , denoted as G ( s ), is the set of all of s  X  X  q -grams. For example, the 3-gram set of  X  nick_koudas  X  X s { nic , ick , ck_ , k_k , _ko , kou , oud , uda , das } . Two strings r and s are similar only if they share enough common q -grams [3]. Formally if ed ( r, s )  X   X  ,then must hold, where | G ( r )  X  G ( s ) | is the size of G ( r ) | r | is the length of string r . This is called count filtering [3]. Based on this concept, we discuss two existing methods. Approximate String Search based Method: Based on count filtering, q -gram-based methods [4] are proposed to address the approximate string search problem, which, given a set of strings, a query string, and an edit-distance thresh-old, finds all similar strings of the query string from the set. Existing methods usually employ a filter-and-refine frame-work and we also use this framework to address our problem. Firstly we construct q -gram-based index structures for all entities. For each q -gram, we use an inverted list to main-tain those entities that contain the q -gram. For example, consider the entities in Table 1(a), we can build its q -gram index structures as shown in Table 2. For instance, the in-verted list of gram  X  kou  X  X s { 1,5 } . This denotes that entity 1 and entity 5 contain the gram. Secondly, given text S ,we extract all of its substrings from S . For each substring s ,we generate s  X  X  q -grams, and then find the entities that contain at least  X q -grams in G ( s ) using the q -gram indexes, where  X  = | s | X  q +1  X   X   X  q . That is we find the entities that have at least  X  occurrences in the inverted lists of q -grams of s , and all such entities are taken as candidates. Finally we verify the candidates and get the final results. For instance, consider a substring s = X  dievesh  X , the inverted lists of its  X  = | s | X  3+1  X  1  X  3 = 2. As entities 3, 4, 5 have at leat two occurrences, they are candidates.
 Similarity Join based Method: We can also model the substrings of the text as a set, and then we can join the set of entities and the set of substrings to generate the similar pairs using existing similarity-join based methods. Traditional methods [6] usually employ a prefix-filter-based framework and we can also use this framework to address our problem. We first sort the q -grams of each entity and each substring, for example based on IDF or in dictionary order. Then we keep  X   X  q +1 q -grams for each string and each entity (Xiao et al. proposed to reduce the prefix length in [6]). Consider a string s ,let G p ( s )denotethesetof s  X  X  first  X   X  q +1 q -grams. Given an entity e and a substring s , they are similar only if G ( e )  X  G p ( s ) =  X  . Based on this feature, we can use the prefix set to find similar pairs.

Obviously many substrings share common q -grams, and the two methods cannot utilize the shared computation across the common grams. To address this problem, we propose ef-ficient algorithms to improve performance.
In this section, we propose a heap-based framework to address the problem of approximate entity extraction.
We have an observation that some substrings of S will not produce any results, and we define valid substrings that are potentially similar to some entities.
 Valid Substring: Let L min and L max respectively denote the minimal entity length and the maximal entity length in the dictionary. Obviously all the substrings of text S with length smaller than L min  X   X  or larger than L max +  X  can be pruned based on length filtering. We call the substrings of text S with length between L min  X   X  and L min +  X  valid substrings , which may have similar entities in the dictionary. For instance, consider the dictionary and text in Table 2. L min =10and L max = 12. Suppose  X  = 1. The substrings of the text with length between L min =10  X  1and L max = 12 + 1 could have similar entities in the dictionary, and all other substrings will not produce any results. For instance, the substring  X  maros hadjileftheriou  X  cannot be similar to any entity, and we can prune it.
 A Filter-and-Refine Framework: We employ a filter-and-refine framework to check whether each valid substring has similar entities in the dictionary. In the filter step, we generate the candidate pairs; and in the refine step, we ver-ify the candidates to get the final results, by computing their real edit distance using dynamic programming. In this pa-per, we focus on the filter step. We employ the gram-based method to address this problem. Given a valid substring s and an entity e i ,if e i  X  X  occurrence number in the inverted lists of q -grams in G ( s ) is no smaller than  X  = | s | X  s, e i is a candidate as discussed in Section 2. In this section, we propose a multi-heap based method. Firstly, we construct q -gram-based index structures for all entities. Secondly for each substring of the text, we generate its q -grams, construct a heap on top of the inverted lists of its q -grams, and adjust the heap to find similar entities for the substring. Formally, let S [ i, l ] denote a substring of S with length l , starting with the i -th character (including the i -th character). Obviously S [ i, l ] is a valid substring if L min  X   X   X  l  X  L max +  X  . For each valid substring S [ i, l ], we first generate its q -gram set G ( S [ i, l ]) and get inverted lists of every gram in G ( S [ i, l ]). Then we construct a min-heap H ( S [ i, l ]) using the first element of each inverted list. Obviously the top element on the heap is the minimal entity among all entities in the inverted lists. Next, we adjust the heap, get the next top element, and count the occurrence numbers of each entity. Finally, we output the entities that have at least  X  =max( L min  X   X ,l )  X  q +1  X   X   X  q occurrences. For example, consider a valid substring  X  dievesh criva  X . Suppose  X  =2.Wehave  X  =max(10  X  2 , 13)  X  3+1  X  2  X  3=5. We first generate its gram set { die , iev , eve , ves , esh , sh_ , h_c , _cr , cri , riv , iva } and get the inverted lists of the q -grams as shown in Figure 1. Then, we construct a heap on top of the first elements of each inverted list. Next, we adjust the heap and get the entities { 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5 } , in ascending order. We count the occurrence numbers of each entry and report the entities that have at least  X  = 5 occurrences. Here we get a candidate (entity 3). Finally, we verify the candidates and get the final result. Figure 1: A heap structure for the valid substring  X  dievesh criva  X .
In this section, we propose a new heap based method, which only needs to construct a single heap on top of in-verted lists of q -grams in G ( S ), denoted as H ( S ). For each valid substring, we use a occurrence pair e v ,o v to main-tain the entity ( e v ) and its occurrence numbers in the sub-string ( o v , initialized as 0). We use the heap H ( S )tocount the occurrence numbers of each entity in each valid sub-string. Firstly consider the top element e h ,g i on heap H ( S ), where e h is an entity from the inverted list of gram g Next we discuss how to find valid substrings that contain the gram and then increase the occurrence number of e h in these valid substrings. Without loss of generality, we first consider the valid substrings with length l . Obviously the valid sub-string S [ i, l ] contains the gram, and all the valid substrings S [ j&gt;i,l ] cannot contain gram g i . In addition, note that the number of q -grams of a valid substring with length l is l  X  q + 1, thus the valid substring taking g i as the last gram is S [ i  X  ( l  X  q +1)+1 ,l ] as shown in Figure 2. Accordingly, the valid substrings with length l that contain gram g i are S [ i  X  ( l  X  q +1)+1 ,l ] ,S [ i  X  ( l  X  q +1)+2 ,l ] ,...,S [ i, l ]. Figure 2: Valid substrings with length l that contain gram g i .

For any length l ( L min  X   X   X  l  X  L max +  X  ), we update the occurrence numbers of e h in the corresponding valid substrings as follows. For each valid substring s that con-tains gram g i , if its kept entity e v isthesameas e h ,we increase its occurrence number o v by one, and if the occur-rence number ( o v ) is larger than or equal to the threshold max( | s | ,L min  X   X  )  X  q +1  X   X   X  q , we return it as a candi-date; otherwise, we set the current entity e v = e h and set its occurrence number o v = 1. Note that we only need to use a tuple for each valid substring to maintain the information.
Next, we delete the top element e h ,g i from heap H ( S ), adjust the heap to get the next top element e h ,g i ,and update the occurrence numbers of e h in the corresponding valid substrings as discussed above. Interactively, we can get all the similar substrings. We give a running example to walk through the single-heap-based method.

For example, in our running example, consider text  X  nic kouds dievesh criva  X , we construct a single heap on top of the text as shown in Figure 3. We have L min =10and L max = 12. Suppose  X  = 2. For the first entity 1 selected from g 0 , we only need to increase its occurrence number in valid substrings S [0 ,l ]for L min  X   X   X  l  X  L max +  X  , i.e., S [0 , 8] ,S [0 , 9] ,...,S [0 , 14]. For the next entity 1 selected from g 3 , we need to increase its occurrence number in valid substrings S [0 ,l ] ,S [1 ,l ] ,S [2 ,l ] ,S [3 ,l ]for L L max +  X  . Similarly, we can count the occurrence numbers of each entity in every valid substring. For instance, the occurrence number of entity 1 ( X  nick koudas  X ) in S [0 , 8] is 4. As the occurrence number of entity 1 is larger than  X  = 11 + 1  X  q  X   X   X  q = 3, the valid substring S [0 , 8] ( X  nic kouds  X ) is a candidate for entity 1 ( X  nick koudas  X ).
We compared our algorithms with state-of-the-art meth-ods, approximate-string-based methods ( AppSearch ) [4], similarity-join-based methods ( ED-Join )[6],and NGPP [5]. For AppSearch Figure 3: A single-heap-based method for text  X  nic kouds dievesh criva  X . Figure 4: Performance comparison of multi-heap-based methods and single-heap-based methods. we modified the implementation of q -gram-based listmerger algorithms in Flamingo Project 1 to support approximate en-tity extraction. We also extended state-of-the-art similarity-join algorithm ED-Join to support approximate entity ex-traction. We downloaded the binary codes of ED-Join [6] and NGPP [5] from  X  X imilarity Joins X  project website 2 .We varied the gram length q and reported the best performance of each method. All the algorithms were implemented in C++ and compiled using GCC 4.2.3 with -O3 flag. All the experiments were run on a Ubuntu machine with an Intel Core 2 Quad X5450 3.00GHz processor and 4 GB memory. We used two real datasets, DBLP 3 and PubMed 4 .DBLPis a computer-science publication dataset. We selected 95,293 author names as entities and 10,000 papers with author and title as text. PubMed is a medical publication dataset. We selected 152,096 commonly used medical terms as entities and 10,000 publications with title and author names as text.
We first compared the multi-heap-based method and the single-heap-based method by varying edit-distance thresh-olds. Figure 4 shows the experimental results. We see that the single-heap-based method outperforms the multi-heap-based method by an order of magnitude, and even two or-ders of magnitude in some cases. There are two reasons that http://flamingo.ics.uci.edu/ http://www.cse.unsw.edu.au/  X  weiw/project/simjoin.html http://www.informatik.uni-trier.de/  X  ley/db http://www.ncbi.nlm.nih.gov/pubmed/ the single-heap-based method is better than the multi-heap-based method. Firstly, the multi-heap-based method needs to scan each gram inverted list of the text many times and the single-heap-based method only needs to scan them once. Secondly the multi-heap-based method needs to construct and adjust larger numbers of heaps, and the single-heap-based method only adjusts a single heap.

Then we compared our best method AERHeap (using length pruning techniques) with existing methods, AppSearch , ED-Join ,and NGPP . Figure 5 shows the results. We see that our method AERHeap achieved the highest performance. This is because our method can use the shared computation across overlapped grams, but the existing methods cannot.
In this paper, we have studied the problem of approxi-mate entity extraction with edit-distance thresholds. We proposed a heap-based framework to address this problem. The single-heap-based method only needs to construct a sin-gle heap and can extract all entities by scanning each gram inverted list of text only once. We have implemented our al-gorithms, and tested our method on three real datasets. The experimental results show that our method achieves high performance and outperforms state-of-the-art studies. This work is partly supported by the National Natural Science Foundation of China under Grant No. 60873065, the National High Technology Development 863 Program of China under Grant No. 2009AA011906, and the National Grand Fundamental Research 973 Program of China under Grant No. 2006CB303103. [1] K. Chakrabarti, S. Chaudhuri, V. Ganti, and D. Xin. [2] S. Chaudhuri, V. Ganti, and D. Xin. Mining document [3] L. Gravano, P. G. Ipeirotis, H. V. Jagadish, N. Koudas, [4] C. Li, J. Lu, and Y. Lu. Efficient merging and filtering [5] W. Wang, C. Xiao, X. Lin, and C. Zhang. Efficient [6] C. Xiao, W. Wang, and X. Lin. Ed-join: an efficient
