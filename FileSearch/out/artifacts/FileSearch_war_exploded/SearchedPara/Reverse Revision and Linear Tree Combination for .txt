 Deterministic transition-based Shift/Reduce depen-dency parsers make often mistakes in the analysis of long span dependencies (McDonald &amp; Nivre, 2007).
Titov and Henderson (2007) address this accuracy drop by using a beam search instead of a greedy al-gorithm for predicting the next parser transition.
We propose a parsing method that allows reduc-ing several of these errors, although maintaining a quasi linear complexity. The method consists in two steps: first the sentence is parsed by a determinis-tic Shift/Reduce parser, then a second deterministic Shift/Reduce parser analyzes the sentence in reverse using additional features extracted from the parse trees produced by the first parser.

Right-to-left parsing has been used as part of ensemble-based parsers (Sagae &amp; Lavie, 2006; Hall et al., 2007). Nivre and McDonald (2008) instead use hints from one parse as features in a second parse, exploiting the complementary properties of graph-based parsers (Eisner, 1996; McDonald et al., 2005) and transition-based dependency parsers (Ya-mada &amp; Matsumoto, 2003; Nivre &amp; Scholz, 2004).
Also our method uses input from a previous parser but only uses parsers of a single type, determin-istic transition-based Shift/Reduce , maintaining an overall linear complexity. In fact both the en-semble parsers and the stacking solution of Nivre-McDonald involve the computation of the maximum spanning tree (MST) of a graph, which require algo-rithms of quadratic time complexity (e.g. (Chu &amp; Liu, 1965; Edmonds, 1967)).

We introduce an alternative linear combination method. The algorithm is greedy and works by com-bining the trees top down. We tested it on the de-pendency trees produced by three parsers, a Left-to-Right ( LR ), a Right-to-Left ( RL ) and a stacked Right-to-Left parser, or Reverse Revision parser ( Rev2 ). 1 The experiments show that in practice its output often outperforms the results produced by calculating the MST. In the reported experiments we used DeSR (Attardi at al., 2007), a freely available implementation of a transition-based parser. The parser processes in-put tokens advancing on the input with Shift actions and accumulates processed tokens on a stack with Reduce actions. The parsing algorithm is fully de-terministic and linear.

For the LR parser and the Rev2 parser we em-ployed an SVM classifier while a Maximum Entropy classifier, with lower accuracy, was used to create the training set for the Rev2 parser. The reason for this appears to be that the output of a low accuracy parser with many errors provides a better source of learning to the stacked parser.

The Rev2 parser exploits the same basic set of features as in the LR parser plus the additional fea-tures extracted from the output of the LR parser listed in Table 1, where: PHLEMMA is the lemma of the predicted head, PHPOS is the Part of Speech of the predicted head, PDEP is the predicted depen-dency label of a token to its predicted head, PHDIST indicates whether a token is located before or after its predicted head, PHHLEMMA is the lemma of the predicted grandparent and PHDEP is the pre-dicted dependency label of the predicted head of a token to the predicted grandparent. s 0 refers to a to-ken on top of the stack, w i refers to word at the i -th relative position with respect to the current word and parsing direction. This feature model was used for all languages in our tests.

We present experiments and comparative error analysis on three representative languages from the CoNLL 2007 shared task (Nivre at al., 2007): Ital-ian, Czech and English. We also report an evaluation on all thirteen languages of the CoNLL-X shared task (Buchholz &amp; Marsi, 2006), for comparison with the results by Nivre and McDonald (2008).

Table 2 shows the Labeled Attachment Score (LAS), for the Left-to-right parser ( LR ), Right-to-Left ( RL ), Reverse Revision parser ( Rev2 ), linear parser combination (Comb) and MST parser combi-nation (CombMST).

Figure 1 and 2 present the accuracies of the LR and Rev2 parsers for English relative to the depen-dency length and the length of sentences, respec-tively. For Czech and Italian the RL parser achieves higher accuracy than the LR parser and the Rev2 parser even higher. The error analysis for Czech showed that the Rev2 parser improves over the LR parser everywhere except in the Recall for depen-dencies of length between 10 and 14. Such an im-provement has positive impact on the analysis of sentences longer than 10 tokens, like for Italian. 2.1 CoNLL-X Results For direct comparison with the approach by Nivre and McDonald (2008), we present the results on the CoNLL-X corpora (Table 3): MST and MST Malt are the results achieved by the MST parser and the MST parser using hints from Maltparser, Malt and Malt MST the results of the opposite stacking. 2.2 Remarks The Rev2 parser, informed with data from the LR parser, achieves better accuracy in twelwe cases, sta-tistically significantly better in eight.

The error analysis confirms that indeed the Rev2 parser is able to reduce the number of errors made on long dependency links, which are a major weakness of a deterministic Shift/Reduce parser. The accuracy of the Rev2 parser might be further improved by more sophisticated feature selection, choosing fea-tures that better represent hints to the second parsing stage. Our final improvements arise by combining the out-puts of the three parser models: the LR parser, the RL parser and the Rev2 parser.

Instead of using a general algorithm for calcu-lating the MST of a graph, we exploit the fact that we are combining trees and hence we developed an approximate algorithm that has O ( kn ) complexity, where n is the number of nodes in a tree and k is the number of trees being combined.

The algorithm builds the combined tree T incre-mentally, starting from the empty tree. We will ar-gue that an invariant of the algorithm is that the par-tial result T is always a tree.

The algorithm exploits the notion of fringe F , i.e. the set of arcs whose parent is in T and that can be added to T without affecting the invariant. Initially F consists of the roots of all trees to be combined. The weight of each arc a in the fringe is the number of parsers that predicted a .

At each step, the algorithm selects from F an arc a =( h, d, r ) among those with maximum weight, having h  X  T . Then it: 1. adds a to T 2. removes from F all arcs whose child is d 3. adds to F all arcs ( h 0 , d 0 , r 0 ) in the original trees Step 3 guarantees that no cycles are present in T . The final T is connected because each added node is connected to a node in T . T is a local maximum because if there were another tree with higher score including arc ( h, n, r ) , either it is present in T or its weight is smaller than the weight for node ( h 0 , n, r 0 ) in T , as chosen by the algorithm.

The algorithm has O ( kn ) complexity. A sketch of the proof can be given as follows. Step 3 guarantees that the algorithm is iterated n times, where n is the number of nodes in a component tree. Using appro-priate data structures to represent the fringe F , in-sert or delete operations take constant time. At each iteration of the algorithm the maximum number of removals from F (step 2) is constant and it is equal to k , hence the overall cost is O ( nk ) .

Table 2 shows the results for the three languages from CoNLL 2007. With respect to the best results at the CoNLL 2007 Shared Task, the linear parser combination achieves the best LAS for Czech and Italian, the second best for English.

The results for the CoNLL-X languages (Table 3) show also improvements: the Rev2 parser is more accurate than MST, except for Bulgarian, Dutch, German, and Spanish, where the difference is within 1%, and it is often better than the Malt MST stacking. The improvements of the Rev2 over the LR parser range from 0.38% for Chinese to 3.84% for Dutch.
The column CombMST shows the results of com-bining parsers using the Chu-Liu-Edmonds MST al-gorithm and the same weighting scheme of Lin-ear Combination algorithm. For most languages the Linear Combination algorithm leads to a bet-ter accuracy than the MST algorithm. The some-what surprising result might be due indeed to the top down processing of the algorithm: since the algo-rithm chooses the best among the connections that are higher in the parse tree, this leads to a prefer-ence to long spanning links over shorter links even if these contribute higher weights to the MST.
Finally, the run time of the linear combination al-gorithm on the whole CoNLL-X test set is 11.2 sec, while the MST combination requires 92.5 sec.
We also tested weights based on the accuracy score of each parser for the POS of an arc head, but this produced less accurate results. We presented a method for improving the accuracy of a dependency parser by using a parser that ana-lyzes a sentence in reverse using hints from the trees produced by a forward parser.

We also introduced a new linear algorithm to per-form parser combination.

Experiments on the corpora of languages from the CoNLL-X and the CoNLL 2007 shared tasks show that reverse revision parsing improves the ac-curacy over a transition-based dependency parser in all the tested languages. Further improvements are obtained by using a linear parser combination algo-rithm on the outputs of three parsers: a LR parser, a RL parser and a Rev2 parser.

The combination parser achieves accuracies that are best or second best with respect to the results of the CoNLL 2007 shared task. Since all the indi-vidual parsers as well as the combination algorithm is linear, the combined parser maintains an overall linear computational time. On the languages from the CoNLL-X shared task the combination parser achieves often the best accuracy in ten out of thirteen languages but falls short of the accuracy achieved by integrating a graph-based with a transition based parser.

We expect that further tuning of the method might help reduce these differences.

