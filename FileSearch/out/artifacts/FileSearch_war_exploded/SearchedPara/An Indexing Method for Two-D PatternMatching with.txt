 The two-dimensional pattern matching problem is: given an n  X  n matrix T [0 ..n  X  1 the pattern) over a finite alphabet  X  , m  X  n , find all occurrences of P in T .In recent years, there has been growing interest in two or higher dimensional pattern matching, largely motivated by its applications in low-level image processing and in image database searches.
 for the problem, which use Aho and Corasick X  X  one-dimensional dictionary match-ing algorithm [AC75] and run in O ( n 2 log |  X  | ) time. Amir, Benson and Farach O ( m 2 log |  X  | ) time to process the pattern. Galil and Park [GP92] improved the time bound to O ( n 2 + m 2 ), which is truly independent of the alphabet size. two classes, based on whether they process the pattern first ( Class 1 ) or process the text first ( Class 2 ). All the algorithms mentioned above belong to the first class. They are inappropriate when we wish to search for many different and relatively small patterns in a large fixed text, since each search still takes time proportional to the size of the text. The only algorithms known to us that first process the text are due to Zhu and Takaoka [ZT89] and Giancarlo [Gia93, GG97].
 a combination of Knuth, Morris and Pratt X  X  algorithm [KMP77] and Karp and Rabin X  X  algorithm [KR87], uses O ( n 2 ) time and space to process the text. After preprocessing the text, the search can be done in O ( n 2 + m 2 ) time in the worst and average cases. Their second algorithm uses Boyer and Moore X  X  algorithm [BM77] to search the preprocessed text and runs in O ( n 2 log m/m + m 2 ) time on the average.
 suffix tree LT and (since the outdegree of a node in LT can be very large) then three arrays can be computed in O ( n 2 (log n + log |  X  | )) time. The arrays allow a search query to be answered in O ( m 2 + log n ) time. The Giancarlo algorithm requires that both the text and the pattern should be square matrices. structure and therefore belongs to the second class (The same class as Zhu-Takaoka and Giancarlo X  X  algorithms). It applies to rectangular matrices includ-ing, of course, square matrices (Giancarlo X  X  algorithm can only deal with square matrices). It is conceptually simple and easy to implement. It preprocesses the sense that during the running time it may produce false matches, i.e., it may claim a  X  X atch X  between the pattern and some submatrix of the text while they are actually not equal (the  X  X onte-Carlo X  type algorithm). However, as will be seen later, the probability that a false match can occur is negligible. All occur-rences of the pattern in the text, probably with a few false matches, can be found in
O ( m 2 ) time, regardless the distribution of the letters in the pattern and the text.
 where there is no error and the randomization is on the running time only. Under the assumption that at each position in T and P , each letter of the alphabet occurs equally likely, after preprocessing the text, our  X  X as-Vegas X  version algorithm can find all occurrences of P in T in O ( m + log n ) expected time. To the best of our knowledge, this algorithm is the average-case fastest one in its class (Class 2).
 rithms in Table 1 need O ( n 2 ) extra space for preprocessing the text and Algo-rithm ours-1 is a probabilistic algorithm.
 for images that contain given patterns. We will report on the experimental results in Section 6. The two main tools applied in our algorithm are Karp and Rabin X  X  hashing tech-nique [KR87] and the generalized suffix arrays [Shi96]. To simplify the presen-tation, we assume that both the text and pattern are square matrices, although our approach applies to rectangular matrices as well. Let the text T and pattern P be and Elements of T and P are from some sorted finite alphabet  X  = { c 1 ,c 2 ,  X  X  X  ,c a } .
 integer to be specified later.
 That is, v fingerprint string of the m  X  n submatrix T i .
 denote the i -th column of P , viewed as a string. P is transformed into the string have W = w 0 w 1  X  X  X  w m  X  1 . We call W the fingerprint string of the pattern P . Basic Idea. The basic idea of our approach is as follows. If P matches a part of submatrix T i of T then the fingerprint string W of P must match a substring of the fingerprint string V i of T i . A match between W = w 0 w 1  X  X  X  w m  X  1 and a possible match between P and the m  X  m submatrix of T whose upper left corner lies on position ( i, j )of T . We then test whether the corresponding matrix elements are really equal.
 not equal to the submatrix of T corresponding to V i ( j ). We will show in the next section that the probability that a false match occurs is negligible if the integer p in the fingerprint function H p ( . ) is chosen at random from a set S = { q | q is a prime and q  X  M } and the integer M is sufficiently large.
 of
T can be computed in O ( n 2 ) time and in O ( n 2 ) space. Our two dimensional pattern matching problem is then reduced to a one-dimensional string matching problem. We will use a data structure, called the generalized suffix array, to store the set of fingerprint strings V = { V 0 ,V 1 ,  X  X  X  ,V n  X  m } of T . Manber and Myers X  suffix array for a single string [MM93]. Informally, a gener-alized suffix array of a given set S of strings consists of three arrays, Pos , Llcp and Rlcp . Pos is a lexicographically sorted array of all suffixes of strings in S . Llcp and Rlcp are two arrays of the information about the lengths of the longest common prefixes of the suffixes in Pos . Let N denote the sum of the lengths of all strings in S and n the length of the longest string in S . Then the generalized suffix array of S can be constructed in time O ( N log n ) in the worst case using O ( N ) storage. Given the suffix array, on-line string search query of the type  X  X s X a substring of any strings in S ? If so, where does it occur within strings of S ? X  in O ( m + log N ) time in the worst case where m is the length of X .For more detailed information on the generalized suffix array, see [MM93, Shi96]. rences of W in V in O ( m + log n ) time.
 Constructing index 1. We represent every m  X  n submatrix T i of the text T with its fingerprint 2. Build the suffix array for V .
 Searching 1. Transform the pattern into a fingerprint string W ; 2. Search the suffix array for the occurrences of W . Each occurrence of W in of one-dimensional fingerprint strings. Define H ( X ) of string X = x 0 x 1 ...x m  X  1 as follows: and a = |  X  | . Then, H ( X ) represents string X uniquely.
 for some positive integer p to be specified later. We call H p ( X ) the fingerprint of string X . And we call m the fingerprint height of H p (). H p ( X ) may not represent string X uniquely, as it is possible that H p ( X 1 )= H p ( X 2 ) for two different strings X 1 and X 2 .
 T Thus where  X  =  X  a m mod p .
 and then applying Eq(9) for i =0 , 1 ,...,n  X  m  X  1, we obtain the fingerprints of all length m substrings of column j of T .
 submatrix T i of T whose first row is the i -th row of T (see Eq(4)). Assuming that each application of Eq(9) takes constant time (we can keep constants  X  , p and the last computed fingerprint in fast registers), the time needed to compute the fingerprints of all length m substrings of column j of T is O ( n ). Thus the total time needed to compute V = { V 0 ,V 1 ,...,V n  X  m } is O ( n 2 ). Let X and Y be any two m  X  m matrices. Let X ( i ) denote the i -th column of X , viewed as a string. Let to a false match if V = W but X = Y .
 and Rabin X  X  results [KR87]. Let  X  ( u ) denote the number of primes  X  u . Lemma 1 (Karp and Rabin [KR87]). If u  X  29 and b  X  2 u , then b has fewer than  X  ( u ) different prime divisors.
 Lemma 2 (Rosser and Schoenfeld [RS62]). For al l u  X  17 Proof. The result is established by Corollary 1 to Theorems 1 and 2 of [RS62]. Lemma 3 (Rosser and Schoenfeld [RS62]). For al l u  X  59 Proof. The result is established by formulas (3.1) and (3.4) of [RS62]. Theorem 1. Let X and Y be any two m  X  m matrices over  X  .Let X ( i ) denote the i -th column of X , viewed as a string. Let prime p in H p (  X  ) is chosen at random from the set S = { q | q is a prime and q  X  M } , then the probability that a false match occurs (i. e. X = Y ) is less than provided m 2 log 2 a  X  29 where a = |  X  | .
 prime p , the event that V = W and X = Y is equivalent to each of the following statements: 1. For some r  X  R , H p ( X ( r )) = H p ( Y ( r )) but X ( r ) = Y ( r ). 2. For some r  X  R such that X ( r ) = Y ( r ), p | H ( X ( r ))  X  H ( Y ( r )). 3.  X  than  X  ( m 2 log 2 a ) different prime divisors. Thus, p is chosen at random from  X  (
M ) primes, of which fewer than  X  ( m 2 log p is chosen at random from S = { q | q  X  M and q prime } , the probability that a false match occurs is less than Theorem 2. Suppose the prime p in H p (  X  ) is chosen at random from the set S = { q | q is a prime and q  X  M } .Let M = log 2 a  X  mn 3 . Then the probability that a match is a false one is less than Proof. Apply Lemma 2 to Theorem 1.
 a = |  X  | =2 8 , m =2 9 and n =2 12 . We choose M =2 48 . Then for any prime p  X  M , the range of the fingerprint function H p is { 0 , 1 ,  X  X  X  ,p  X  1 } and each fingerprint can be represented by a 6-byte word. The probability that a match is false is less than height of P . One restriction of our approach presented in the previous sections is that the heights of pattern matrices should be known to the preprocessing portion of the algorithm before the preprocessing begins. We now sketch a way (the text) in the same manner as was described in the previous sections for a presented with an m 1  X  m 2 matrix P [0 .. m 1  X  1 , 0 .. m 2  X  1] (the pattern), we choose m 1 =2 i such that 2 i  X  m 1 &lt; 2 i +1 .Wepickany m 1  X  m 2 submatrix P of P . We first look for all occurrences of P in T in the same way as was described before. Then, for each such occurrence found, we check if it is really an occurrence of P in T using symbol by symbol comparisons.
 the preprocessed text, this simple algorithm can find all (correct) occurrences of P in T in O ( m + log n ) expected time assuming both the text and pattern are random matrices (A matrix A over some finite alphabet  X  is called a random matrix if at each position of A each element of  X  can occur with the same probability). This is perhaps the average-case fastest algorithm known in its class.
 details about this filtering approach in this paper. We have implemented our technique and used it to search digital images. Our program, which is written in C, was tested on a (old and slow) PC (Pentium III 450MHZ with 256 MB RAM) that run Redhat Linux.
 The size of the text array tested was 480  X  640 and three different pattern sizes were tested: 15  X  200, 150  X  200, and 300  X  200.
 time is broken down into the time for converting the text into fingerprint strings and the time for building the suffix array.
 for constructing the suffix array which takes O ( N 2 ) time in the worst case-we did not use more efficient algorithms that can construct a suffix array in only O ( N log N ) time in the worst case ( N denotes the total length of the strings). is acceptable in most cases; once the index is available subsequent searches can be done very quickly. We plan to compare empirically our algorithm with other known algorithms such as Zhu-Takaoka algorithm [ZT89] and Giancarlo algorithm [Gia93, GG97]. 1
