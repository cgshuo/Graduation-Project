 Universidade de Santiago de Compostela Centro de Informa  X  tica e Tecnologias de Informa Z a  X  o
This article describes an unsupervised strategy to acquire syntactico-semantic requirements of requirement underlying this strategy is based on two specific assumptions. First, it is assumed that two words in a dependency are mutually required. This phenomenon is called here corequirement . Second, it is also claimed that the set of words occurring in similar positions identifying the words that define their requirements extensionally. This strategy allows us to learn the syntactic and semantic requirements of words in different positions. This information is used to solve attachment ambiguities. Results of this particular task are evaluated at the end of the article. Extensive experimentation was performed on Portuguese text corpora. 1. Introduction
Word forms, as atoms, cannot arbitrarily combine with each other. They form new composites by both imposing and satisfying certain requirements. A word uses a linguistic requirement (constraint or preference) in order to restrict the type of words with which it can combine in a particular position. The requirement of a given word is characterized by at least two different objects: the position occupied by the words that can be combined with the given word and the condition that those words must location loc , the pair b loc, w  X  represents a position with regard to w . In addition, condition cond represents the set of linguistic properties that words must satisfy in order to be in position b loc , w  X  . So a linguistic requirement of w can be represented as the pair:
Consider, for instance, position b of_right, ratification  X  , where of_right is a location described as being to the right of preposition of . This position represents the argument slot nominal phrase (np) whose head denotes a legal document (abbreviated by doc ), then the pair bb of_right, ratification  X  , doc  X  means that the particular position ratification of [_ ] selects for nouns denoting legal documents. In other words, ratification requires nominal arguments denoting legal documents to appear after preposition of . Suppose that there exist some words such as law , treaty , and constitution that are nouns denoting legal documents. Then it follows that they fill the condition imposed by ratification in the of_right location. An expression like the ratification of the treaty is then well-formed, because treaty satisfies the required condition.
 important to characterize the notion of linguistic requirement: extensionality/ intensionality, soft/hard requirements, the scope of a condition, syntactic/semantic requirements, and corequirements.
 two specific properties being the head of an np and being a legal document are used to define intensionally the condition imposed by position b of_right, ratification  X  . However, it is also possible to define it extensionally by enumerating all those words that actually possess such properties: for example, law, treaty , and constitution. producing a Boolean (yes/no) value. From this point of view, a word either satisfies or does not satisfy the condition imposed by another word in a specific location. This is a hard requirement. By contrast, the satisfaction process can also be viewed as a soft requirement, in which some words are  X  X  X referred X  X  without completely excluding other possibilities. In Beale, Niremburg, and Viegas (1998), hard requirements are named constraints , whereas the term preferences is employed necessary to distinguish between hard and soft requirements. Otherwise, require-ment is taken as the default term.
 specific condition on the words that can appear in that position. Yet a specific condition is generally imposed not by only one position, but by a large set of them. If a condition were bound only to a particular position, every combination of words would be a noncompositional idiomatic expression. So speakers could not combine words easily, and new composite expressions would be difficult to learn. The scope of a condition embraces the positions that use it to restrict word combination. For instance, the condition imposed by ratification of [_ ] seems to be the same as the one imposed by addition, these positions also share the same conditions as to approve [_ ], to sign [_ ], or condition, namely, being an np whose head denotes a legal document. In this article, we assume that every linguistic condition is associated with a set of similar positions. This 108 larger the condition scope, and the more general the property used to characterize the condition.
 characterized by both a position and a morpho-syntactic condition. For instance, which selects for a nominal phrase. Note that the different syntactic requirements of a word can serve to identify the set of subcategorization frames of that word. Note also that, in some cases, a particular position presupposes a particular morpho-syntactic condition. In our example, position b of_right, ratification  X  requires only a np . So we can use this position as a shorter form of the syntactic requirement bb of_right, ratification  X  , np  X  . We call a syntactic position a position that presupposes a specific morpho-syntactic condition. On the other hand, a semantic requirement (also known as selection restriction ) is characterized by both a position and a semantic condition, which presupposes a syntactic one. So bb of_right, ratification  X  ,doc  X  means that position b of_right, ratification  X  selects for the head of a np denoting a legal document. Condition doc presupposes then a np . Identifying a particular semantic requirement entails the identification of the underlying syntactic one.
 corequirements . It is assumed that each syntactic dependency between two words (which are the heads of two phrases) is composed of two complementary requirements. For instance, it seems that two different requirements underlie the filled by words like treaty , while b of_left, treaty  X  ( [_ ] of the treaty ) needs to appear with words such as ratification .
 learning syntactic and semantic requirements from large text corpora. For instance, our method discovers that the word secretary is associated with several syntactic positions defined by a word can be used to characterize a set of subcategorization frames. The precise characterization of these frames remains, however, beyond the scope of this article. In addition, for each syntactic position, we assess the specific semantic condition a word needs to fill in order to appear in that position. Another important objective of the article is to use the semantic requirements to capture contextually relevant semantic similarities between words. In particular, we assume that two words filling the same semantic requirement share the same contextual word sense. Consequently, learning semantic requirements also leads us to induce word senses.
Suppose that the word organization fills the condition imposed by secretary of [_ ] . In this syntactic context, the word denotes a social institution and not a temporal process or an abstract setup.
 positions (and not words) are compared according to their word distribution. Similar syntactic positions are put in more clusters following some constraints that are defined later. Each cluster of positions represents a semantic condition. The features of each cluster are the words that can fill the common condition imposed by those positions: They are the fillers. They are used to extensionally define the particular condition they can fill. That is, a condition is defined by identifying those words likely to appear in positions considered similar. Given that a condition is extensionally defined by the words that are able to fill it, our method describes the process of satisfying a condition as a Boolean constraint (yes/no) and not as a probabilistic preference. The similar positions defining a cluster are within the scope of a particular semantic condition. The association between each position of the cluster and that condition characterizes the semantic requirement of a word. This learning strategy does not require hand-crafted external resources such as a WordNet-like thesaurus or a machine-readable dictionary.
 disambiguation tasks: selecting contextual senses of words (word sense disambigu-ation) and solving structural ambiguity (attachment resolution). This article is focused on the latter application.
 information we learn for each lexical word. Given a word, we acquire, at least, three types of information: (1) an unordered set of syntactic positions, which is a first approximation to define the set of subcategorization frames of the given word, (2) the semantic requirements the word imposes on its arguments, and (3) the different contextual senses of the word. By contrast, related work focuses only on one or two aspects of this linguistic information. Another contribution is the use of corequire-ments to characterize the arguments of a word.
 next section, we situate our approach with regard to related work on acquisition of linguistic requirements. Later, in sections 3 and 4, we describe in detail the main linguistic assumptions underlying our approach. Special attention will be paid to both the relativized view on word sense (i.e., contextual sense) and corequirements. Then, section 5 depicts a general overview of our strategy. Two particular aspects of this strategy are analyzed next. More precisely, section 6 describes both how syntactic positions are extracted and how they are clustered in larger classes (section 7). Finally, in section 8, we evaluate the results by measuring their performance in a particular
NLP task: syntactic-attachment resolution. 2. Statistics-Based Methods for Learning Linguistic Requirements
During the last years, various stochastic approaches to linguistic requirements acquisition have been proposed (Basili, Pazienza, and Velardi 1992; Hindle and Rooth 1993; Sekine et al. 1992; Grishman and Sterling 1994; Framis 1995; Dagan, Marcus, and Markovitch 1995; Resnik 1997; Dagan, Lee, and Pereira 1998; Marques, Lopes, and
Coelho 2000; Ciaramita and Johnson 2000). In general, they follow comparable learning strategies, despite significant differences observed. In this section, we present first the common strategy followed by these approaches, and then we focus on their differences. Special attention is paid to lexical methods. At the end, we situate our strategy with regard to the related work. 2.1 A Common Strategy
The main design of the strategy for automatically learning requirements is to compute the association degree between argument positions and their respective linguistic conditions. For this purpose, the first task is to count the frequency with which bb loc , w  X  , cond  X  occurs in a large corpus: 110 where F counts the frequency of co-occurring b loc , w  X  with cond . Then this frequency is used to compute the conditional probability of cond given position b loc , w  X  :
This probability is then used to measure the strength of statistical association between b loc , w  X  and cond . Association measures such as mutual information or log-likelihood are used for measuring the degree of (in)dependence between these two linguistic objects.
Intuitively, a high value of the association measure is evidence of the existence of a true requirement (i.e., a type of linguistic dependence).
 for NLP disambiguation tasks such as attachment resolution in probabilistic parsing and sense disambiguation. 2.2 Specific Aspects of the Common Strategy
Despite the apparent methodological unanimity, approaches to learning requirements propose different definitions for the following objects: association measure, position b loc , w  X  , and linguistic condition cond . Many approaches differ only in the way in which the association measure is defined. Yet such differences are not discussed in this article.
 definitions. First, it can be considered as a mere word sequence (Dagan, Marcus, and Markovitch 1995): For instance, b right , w  X  , where right means being to the right of .
Second, a position can also be defined in terms of co-occurrence within a fixed window (Dagan, Lee, and Pereira 1998; Marques, Lopes, and Coelho 2000). Finally, it can be identified as the head or the dependent role within a binary grammatical relationship such as subject, direct object, or modifier (Sekine et al. 1992; Grishman and Sterling characterization of syntactic positions.
 a linguistic condition: syntactic, semantic, and lexical information. The approaches to learning requirements are easily distinguished by how they define cond .
Table 1 displays three different ways of encoding the condition imposed by verb approve to the nominal the law in the expression to approve the law .
 for the linguistic information underlying the nominal expression the law when it appears to the right of the verb approve . 1 The properties np , doc , and law are situated at different levels of abstraction. The morpho-syntactic tag np conveys more abstract information than the semantic tag doc (document), which, in turn, is more general than the lemma law . Some conditions can be inferred from other conditions. For instance, doc is used only to tag nouns, which are the heads of nominal phrases. So the semantic tag doc entails the syntactic requirement np . Likewise, the lemma law is associated only with nouns. It entails, then, an np .
 and Rooth 1993; Marques, Lopes, and Coelho 2000). They count the frequency of pairs like bb right, approve  X  , np  X  in order to calculate the probability of an np occurring given b right, approve  X  . This probability is then used to compute the degree of association between approve and an np located to the right. This association value may be useful in different linguistic tasks. For instance, it may serve to solve structural ambiguities (Hindle and Rooth 1993) or to build a subcategorization lexicon (Marques, Lopes, and
Coelho 2000). Most approaches to learning syntactic requirements assume that syntactic properties can be identified by means of some specific morphological  X  X  X ues X  X  appearing in the corpus. For instance, the article a following a verb is a clear evidence for an np appearing at the right of the verb; the preposition of following a verb is evidence for an of_right complement; and the conjunction that after a verb introduces a that_clause . Morphological cues are used to easily identify syntactic requirements. This technique allows raw text to be worked on directly. Let us note that these techniques do not allow the acquisition of complete subcategorization frames (Brent 1991;
Manning 1993). They are able to acquire that, for instance, approve subcategorizes an np on two locations: both right and of_right locations (e.g., to approve the laws, to approve of the decision ). So they associate that verb with two syntactic arguments. However, they are not able to learn that the two arguments are incompatible and must belong to two different subcategorization frames of the verb. We return to this issue in section 8.1.
 semantic terms by means of specific tags (Basili, Pazienza, and Velardi 1992; Resnik 1997; Framis 1995). In order to calculate the degree of association between tag doc and position b right, approve  X  , these approaches count the frequency of pairs like bb right, other related cases, then one might learn that the verb approve requires nominal phrases denoting doc entities to appear at the right.
 characterize requirements may be situated at the lexical level (Dagan, Lee, and Pereira 1998; Dagan, Marcus, and Markovitch 1995; Grishman and Sterling 1994;
Sekine et al. 1992). A pair like bb right, approve  X  , law  X  matches those expressions containing a form of lemma law (e.g., law, laws, Law, Laws ) appearing to the right of the verb approve (to be more precise, to the right of any form of lemma approve ). The frequency of this pair in the corpus serves to compute the degree of association between law and the verb approve at the right. In these approaches, then, conditions are learned from lexical co-occurrences. From now on, when it is not necessary to distinguish between lemmas and word forms, we use the term  X  X  X ord X  X  for both objects.
 behavior regarding different quantitative aspects: (1) the continuum between supervised and unsupervised learning, (2) the continuum between knowledge-poor and knowledge-rich methodology, and (3) the continuum between general-and specific-information acquisition. 112 2.2.1 Supervised/Unsupervised Learning. The first continuum ranges over the degree of human supervision that is needed to annotate the training corpus. Among the works cited above, Basili, Pazienza, and Velardi (1992) has the highest degree of supervision.
This semantic approach requires hand-tagging text nouns using a fixed set of semantic labels. The other approaches involve close to total nonsupervision, since they do not require a training corpus to be annotated by hand. However, some degree of human supervision could be involved in building automatic tools (e.g., a neural tagger in Marques, Lopes, and Coelho [2000]) or linguistic external sources (e.g., WordNet in
Resnik [1997]; Framis [1995]; Ciaramita and Johnson [2000]), which are used to annotate the corpus. 2.2.2 Knowledge-Rich/Knowledge-Poor Methods. The second continuum refers to the notions introduced by Grefenstette (1994). He distinguishes the learning methods according to the quantity of linguistic knowledge they require. The most knowledge-rich approaches need a handcrafted thesaurus (WordNet) to semantically annotate nouns of the training corpus (Resnik 1997; Framis 1995; Ciaramita and Johnson 2000).
At the opposite end of the continuum, the most knowledge-poor methods are introduced in Dagan, Marcus, and Markovitch (1995) and Dagan, Lee, and Pereira (1998); these merely need to identify lemmas in the corpus. 2.2.3 General/Specific Conditions. As regards the general/specific continuum, syn-tactic methods , that is, approaches to learning syntactic requirements, are the learning methods that use the most general linguistic information. At the opposite end of the continuum, we find the lexical methods , that is, those strategies situated at the lexical level. Methods using tags like doc, human, and institution are situated at an interme-diate level and are known as semantic methods . One of the most difficult theoretical problems is to choose the appropriate generalization level for learning requirement information.

Concerning the parsing task, syntactic information is not always enough to produce a single parse. Consider the following analyses:
In order to decide which analysis, either (4) or (5), is correct, we must enlist the aid of our world knowledge concerning cutting actions, use of knives, and the properties of potatoes. In general, we know that knives are used for cutting and that potatoes are objects likely to have holes. So the parser is able to propose a correct analysis only if the lexicon is provided not only with syntactic requirements, but also with information on semantico-pragmatic requirements (i.e., with selection restrictions). Selection restric-tions are typically used to capture facts about the world that are generally, but not necessarily, true (Androutsopoulos and Dale 2000). So the main goal of semantic and lexical methods is precisely the acquisition of selection restrictions.
 linguistic knowledge such as WordNet. There are several disadvantages associated with these knowledge-rich approaches: Manually created thesauri contain many words either having rare senses or missing domain-specific meanings. In sum, the level of semantic information provided by handcrafted thesauri is either too specific or too general, and it is usually incomplete. It seems not to be appropriate for most
NLP tasks (Grefenstette 1994). By contrast, lexical methods are able to acquire information at the level of detail required by the corpus domain. They are domain-dependent approaches. However, they are very sensitive to the problem of data sparseness. 2.3 Lexical Methods and the Data Sparseness Problem
Most word co-occurrences (for instance, the co-occurrence of agreement with approve at location right ) have very small probabilities of occurring in the training corpus. Note that if they were not observed in the corpus, they would have identical probabilities (i.e., probability 0) to those of incorrect co-occurrences such as cow appearing to the right of approve . This is what is known as the data sparseness problem. To solve this problem, many lexical methods estimate the probabilities of unobserved pairs by taking into account word similarity. Suppose that the pair bb right , approve  X  , agreement  X  is not observed in the training corpus. To obtain an appropriate measure of the association between agreement and b right , approve  X  , the degree of association between b right , approve  X  and each word most similar to agreement is computed. The main criterion for measuring word similarity is comparing the context distribution of words.
The total association value for the specific lexical co-occurrence is the average of these association values.
 corpus and to smooth their co-occurrence probabilities. That is, very specific requirements described at the lexical level can be generalized by means of word similarity information.
 associates the information MOST SIM  X  agreement  X  with the position b right , approve  X  , where MOST SIM  X  agreement  X  represents the most similar words to agreement : for example, law , treaty , accordance , and conformity . The use of word similarity allows the probabilities computed at the lexical level to be smoothed (generalized). Computations involving similar words minimize the data sparseness problem to a certain extent.
Lexical methods provided with similarity-based generalizations are found in Sekine et al. (1992), Grishman and Sterling (1994), and Dagan, Lee, and Pereira (1998). Later, in section 8.3.4, we use a lexical method with similarity-based generalization to solve syntactic attachments. The results obtained using this method are explicitly compared to those obtained by our clustering strategy.

Harris X  X  (1985) distributional hypothesis on word meaning. According to this hypothesis, words occurring in similar syntactic contexts (i.e., in similar syntactic positions) are semantically similar. A simple way of implementing this hypothesis is to compute the similarity between words by comparing the whole information concerning their context distribution. Allegrini, Montemagni, and Pirrelli (2003) call this strategy the absolute view on word similarity. The absolute view leads to the characterization of 114 word similarity as an intransitive relation (Dagan, Lee, and Pereira 1998). Let us examine expressions (7) X (10), which show that even if treaty is similar to agreement , and agreement is similar to conformity , it does not mean that treaty is similar to conformity :
Intransitivity makes this type of word similarity rather inefficient for identifying contextual word senses. For instance, it does not help show that agreement is similar to treaty in quite a different way than it is similar to conformity . Expressions (7) and (8) introduce the linguistic contexts in which agreement denotes a document containing legal information. This word is considered to be semantically similar to treaty with regard to the contexts introduced by verbs approve and ratify. By contrast, (9) and (10) introduce different linguistic contexts. There, agreement conveys a different sense: the verbal act of agreeing. In these contexts, it becomes similar to conformity . Word similarity methods based on the absolute view seem to be unable to distinguish such contextual meanings. This shortcoming may disrupt the smoothing process defined above. As conformity and accordance are part of the most similar words to agreement , they are involved in the process of computing the degree of association between this word and b right, approve  X  . Yet this is counterintuitive, since they are not semantically required by the verb in such a particular position. 2.4 General Properties of Our Method
The objective of this article is to propose a new strategy for learning linguistic requirements. This strategy is designed to overcome the main drawbacks underlying the different approaches introduced above. Our method can be characterized as follows: appropriate only if the acquired requirements are useful for solving disambiguation problems such as those illustrated above by parses (4) and (5). So our acquisition method is focused on more specific information than that contained in syntactic requirements. Given a word, our aim is to learn not only the syntactic positions in which that word appears, but also the semantico-pragmatic constraints (i.e., what are broadly called selection restrictions associated with each syntactic requirement.
Selection restrictions are extracted from position-word co-occurrences. We thus follow a lexical method. However, selection restrictions are defined in accordance with a theory of word sense that is not based on the absolute view on word similarity. We use a more relativized viewpoint on word senses. In sum, we follow a strategy slightly different from that described in section 2.3. In the next section, we describe our basic assumptions on word sense and word similarity.
 strategy), our method does not rely on external structured sources of lexical information (e.g., WordNet) or on a training corpus built and corrected by hand.
Unlike the semantic methods outlined above (in section 2.2), ours attempts to reduce human intervention to a minimum. 3. The Foundations of Our Learning Strategy
In this section, we outline the basic assumptions underlying our learning strategy. This strategy relies on a particular definition of semantic condition (sections 3.1 and 3.2) and a relativized view on word similarity (section 3.3), as well as a specific viewpoint on word sense (section 3.4). 3.1 Extensional Definition
Given a requirement bb loc , w  X  , cond  X  , we define a semantic condition, cond , as the set of words that can occur in position b loc , w  X  . This means that linguistic conditions are defined extensionally. For instance, consider again position b right , approve  X  and one of its possible conditions, namely, doc , which, as has been shown, means being a noun denoting a legal document . This condition is extensionally defined by enumerating the set of words likely to occur with both b right , approve  X  and their similar positions. extensions, since it can be modified as time, domain, or speaker change. The aim of our method is to learn, for each argument position, the open set (or sets) of words it requires. Each word set represents, in extensional terms, a specific linguistic condition. For this purpose, we opt for the following learning strategy.
 actually appearing in this position in the training corpus. For instance, let X  X  suppose that b right , approve  X  occurs with four different words: law, agreement, convention, and oil (to simplify the explanation, frequencies are not taken into account). For the present, we know only that these words are mere candidates to satisfy the condition imposed by that position. In order to actually know whether or not the candidate fillers satisfy such a condition, we select the most similar positions to b right , approve  X  . So we get clusters of similar positions imposing the same condition. Consider, for instance, the following cluster: which is made of positions sharing features such as
So, cluster features in (12) are the words that may fill the specific condition imposed by the similar positions in (11). These words can be viewed as fillers satisfying the 116 intensional property being a noun denoting a legal document . Note that (12) contains some words (e.g., article and treaty ) that do not actually occur with position b right , approve  X  in the corpus. However, as these words actually occur with most of the positions that are similar to b right , approve  X  , we may assume that they satisfy the condition of this particular position. This is the technique we use to generalize (smooth) occurrences of position-word pairs that are not observed in the training corpus. Details of our method of clustering are given in section 7.2. Notice also that the set of fillers does not include the word oil . This word does not belong to the set of shared features because it does not occur with any of the positions similar to b right , approve  X  . This is the method we use to identify and remove invalid associations between a position and a word. It is explained in section 7.1.
 the same condition (i.e., they share the same selection restrictions). As has been noted earlier, similar positions are within the scope of one common requirement. The set of words that characterize the extension of such a condition. 3.2 Hard Requirements
We assume that the process of condition satisfaction may be defined as a Boolean function and not as a probabilistic one. The value of the association between, for instance, the word treaty and the position b right , approve  X  is either yes or no. Our method merely attempts to learn whether or not there is a true association between them. If the association is actually true, then we learn that the word satisfies the condition. Hard requirements can easily be used to constrain the grammar of a symbolic parser. In particular, we use them to improve the parser described in Rocio, de la Clergerie, and Lopes (2001). Although linguistic constraints are defined in
Boolean terms, they are open to potential changes. Clusters and their features are supposed to be modified and extended as the training corpus grows and is progressively annotated with more trustworthy syntactic information. Moreover, a new domain-specific corpus can lead us not only to create new clusters, but also to tune old ones. From this viewpoint, Boolean constraints cannot be considered necessary and sufficient conditions. They evolve progressively. 3.3 Relativized Word Similarity
Our learning strategy relies on a specific assumption on word similarity. We are interested in computing similarity between words with regard to a set of similar positions. So we must first compute similarity between positions. As has been mentioned before, similar positions impose the same linguistic condition. Hence, they are likely to be filled by the same set of words. Statistically, this means that they have similar word distribution. A definition of this similarity is given in section 7.1. Unlike in the absolute view stated above, we are not interested in measuring similarity between words on the basis of the distribution of all their corpus-based positions (their whole context distribution). Our aim is, first, to compute the similarity between positions via their word distribution. Positions are in fact less ambiguous than words.
Then, we consider two words to be similar if they occur with at least a pair of similar positions. This way of using similar positions allows all possible dimensions of similarity of a given word to be captured. This is close to the  X  X  X elativized view X  X  on word similarity offered by Allegrini, Montemagni, and Pirrelli (2003).
 3.4 Contextual Hypothesis on Word Sense
Behind this account of similarity, there is a particular view of word sense that is not far from that of Schu  X  tze (1998): ment of similar positions such as to approve [_ ] or ratification of [_ ] . By contrast, this word denotes a verbal act when it appears in positions such as in [_ ] with your proposal or [_ ] to the rules.
 similar positions (i.e., types of contexts). The noun book, for instance, can denote at least three different contextual senses provided it appears in three context types: for example, physical actions (carrying the book, putting it on the table, etc.), symbolic processes (writing or reading books), and economic transactions (selling or buying books). This notion of word sense is dependent on the ability to grasp classes of contexts, that is, the ability to learn clusters of similar positions. The more accurate is this ability, the more precise are the senses identified in a particular corpus. This means that the set of senses associated with a word cannot be predefined by an external lexical resource like WordNet or any machine-readable dictionary. Word senses are dynamically learned as the text is processed and positions are organized in semantically homogenous clusters. Each cluster of similar positions (or context type) represents a particular word sense. From this viewpoint, the set of contextual senses of a word represents its whole meaning. Such a notion of word meaning is in accordance with the encyclopedic hypothesis on lexical meaning within the cognitive grammar framework (Langacker 1991). According to this hypothesis, every word or lexical unit is associated with a continuum of encyclopedic knowledge (the word meaning). The use of the word in a particular context makes a partial aspect of this continuum more salient (a specific word sense).
 the context types that organize the different positions of the word. In other words, a word X  X  meaning is described by identifying the types of requirements the word fulfills.
In the next section, we explore the notions of requirement and syntactic position. 4. Syntactic Positions and Corequirements
This section discusses the general properties of syntactic positions and their role in extracting linguistic requirements. Syntactic positions are defined here as internal elements of binary dependencies. Two aspects of dependencies are retained: the head-dependent distinction and the predicate-argument structure. Special attention is paid to corequirements. 4.1 Head-Dependent Distinction
The head-dependent pattern takes over the process of transferring morpho-syntactic features to higher grammatical levels. A composite expression inherits the features of 118 the headword. There are two different locations (or grammatical roles) within a binary dependency: the head and the dependent . Consider the binary dependencies shown in the first column of Table 2, which represent the expressions to ratify the law and long dinner. The grammatical relations between the two words are expressed by both robj, which stands for the nominal object appearing to the right of the verb, stands for the noun-adjective dependency. The word indexed by plays the role of head, whereas the word indexed by j ( up location) plays the role of dependent. Since a binary dependency is constituted by two grammatical locations, we can split the dependency into two complementary syntactic positions.
 dependency. We show below that the two positions extracted from a dependency are associated with specific semantic conditions. Hence, they can be used to characterize syntactico-semantic requirements. In our work, the different types of binary relations prepname, and mod . Relation lobj designates the nominal object appearing to the left of verb, robj represents the nominal object appearing to the right of the verb, iobj_ prepname introduces a nominal after a verb and a preposition, aobj_ prepname represents a nominal after an adjective and a preposition, prepname corresponds to a nominal following a noun and a preposition, and mod refers to the adjective modification of nouns. Note that each relation conveys not only two argument positions, but also specific morpho-syntactic conditions. robj, for instance, signals that there is an np to the right of a vp .So b robj_down, ratify  X  contains the same information as the syntactic requirement bb robj_down, ratify  X  ,np  X  , while b robj_up, law  X  is equivalent to bb robj_up , law  X  , vp  X  . 4.2 Predicate-Argument Structure
Besides the head-dependent pattern, binary dependencies are also organized as predicative structures: Predicate (Argument). While the former pattern drives the process of inheriting morpho-syntactic information throughout grammatical levels, the latter is directly related to semantic requirements. This section starts by introducing the standard account concerning the role of the Predicate (Argument) structure in the process of imposing linguistic requirements. Then we make new assumptions about what we consider to be a more accurate notion of requirement information. This notion is modeled by means of what we call corequirements. Corequirements are used later, in sections 6 and 7, to elaborate our learning method.
 4.2.1 Simple Requirements. It is broadly assumed that a binary syntactic dependency is constituted by both the word that imposes linguistic constraints (the predicate) and the word that must fill such constraints (its argument). In a syntactic dependency, each word is considered to play a fixed role. The argument is perceived as the word specifying or modifying the syntactico-semantic constraints imposed by the predicate, while the predicate is viewed as the word that is specified or modified by the former.
Notice that a predicate is not defined here in model-theoretic terms. We inherit the intuitive definition assumed in the linguistic tradition of dependency grammar (Hudson 2003). According to this tradition, a predicate is the semantic representation of one of the two words taking part in a binary dependency. More precisely, it is the representation of one word (either head or dependent) that actually imposes semantic requirements on the other word.
 mantic counterpart of the head-dependent pattern. The former relates to the latter in the following way. Typically, the dependent word playing the role of Argument is conceived as the complement or object of the head (see Figure 1). By contrast, when it plays a more active role, behaving more like a Predicate, it is viewed as a modifier or the adjunct of the head (Figure 2). In other words, the dependent of a head-dependent structure is described either as a passive complement, if it satisfies the linguistic requirements of the head (Argument role), or as an active modifier, when the dependent itself requires a specific type of head (Predicative role).
 a direct-object dependency. The noun is viewed here as a complement, that is, as a dependent expression fulfilling the conditions imposed by the verbal predicate. The most typical case of a dependent taken as a predicate is the standard use of an selection restrictions on the noun (or verb), which is the head of the dependency. possible to distinguish between a complement and a modifier, unless we have access to the specific semantico-pragmatic information conveyed by words. However, there are many cases in which the borderline between complement and modifier is not clear.
In these cases, even semantico-pragmatic knowledge is not enough to enable a decision to be made in favor of one particular predicative structure. For instance, consider the expression to play with a doll . Which is the word that can be taken as the predicate, and which as the argument? and modifiers (= adjuncts). The complement/modifier distinction is probably one of the most unclear issues in linguistics (Langacker 1991). No linguistic proposal is able to distinguish in absolute terms complements from external adjuncts; for example, in the previous expression, is with a doll an internal complement or an adverbial modifier of play ? In other words, is position b iobj_with_down,play  X  one that requires as argument the noun doll (complement construction)? Or, on the contrary, is position b iobj_with_up, doll  X  one that requires as argument the verb play (modifier structure)? There is no reliable evidence on which to choose between the two possible requirement structures. Most 120 linguistic proposals may be situated in one of two general trends: (1) Some linguists interpolate finer distinctions between the two extremes (Pustejovsky 1995). So between true or basic complements and completely optional adjuncts, it is possible to find default complements, shadow complements, and so on which share properties of both complements and adjuncts. (2) A more radical view is to consider the complement/ modifier opposition as a continuum in which it is not easy to fix borderlines between what is entirely optional and what is obligatory (Langacker 1991).
 in absolute terms. All binary dependencies always contain a certain degree of both complementarization and modification. That is, given a dependency, the head requires the dependent (complementarization), and conversely, the dependent requires the head (modification). We assume in this article that such corequirements underlie any binary dependency. 4.2.2 Corequirements. Recent linguistic research assumes that two words related by a syntactic dependency are mutually constrained (Pustejovsky 1995; Gamallo 2003).
Each word imposes linguistic requirements on the other. There does not exist a single, pre-fixed predicate-argument pattern. Each related word is at the same time both a predicate and an argument. We call such a phenomenon corequirement structure.
 hole is the complement or the modifier of potato within the with dependency. If it is considered the complement, then it is the head potato that should be provided with the appropriate requirements. Otherwise, it should be the modifier hole, the word imposing specific requirements on the head. Following recent research, we claim, requirements. It is assumed here that two syntactically related expressions presuppose two complementary requirements. In other words, every binary dependency is constituted by two compatible predicate-argument structures.
 potatoes to appear in the with_down location. The noun hole satisfies such a requirement.
On the other hand, the noun hole is also provided with selective requirements in the with_up location. Indeed, in this location, it requires nouns denoting material objects that can have holes. The noun potato fulfills such a condition. Note that the expressions cut with a knife and play with a doll could also be considered borderline cases. they are also pertinent for typical complement structures (e.g., the direct-object relation between verbs and nouns), as well as for typical modifier constructions (i.e., adjective-noun and verb-adverb dependencies). In long dinner , for instance, the noun seems to behave as a predicate constraining the adjective to denote a temporal dimension (and not a spatial one). So not only does the adjective disambiguate the noun, but the noun also disambiguates the adjective.
 pendent expressions are no longer interpreted as a standard predicate-argument pair, in which the predicate is the active function imposing semantic conditions on a passive argument, which matches these conditions. On the contrary, each word of a binary dependency is perceived simultaneously as both a predicate and an argument. That is, each word both imposes semantic requirements and matches semantic requirements in return. Figure 3 depicts a standard syntactic dependency between two words, the head and the modifier, with two Predicate (Argument) structures. Figure 4 illustrates the two specific Predicate (Argument) structures extracted from the modifier relation be-tween the noun dinner (the head) and the adjective long (the dependent).
 the corequirement structure. 5. System Overview
To evaluate the hypotheses presented above, a software package was developed to support the automatic acquisition of syntactic and semantic requirements. The sys-tem is constituted by six main processes, which are displayed as rectangles with solid lines in Figure 5. They are organized as a linear sequence of data transformations. In Figure 5, solid ellipses are used to display the data transformed by these processes.
Two local subprocesses (dotted rectangles) build extra data (dotted ellipses), in order to constrain some of the main transformation processes. In the remainder of this section, we merely outline the overall functionalities of these processes. Then in subsequent sections, we describe them in detail.
 122
EC. 4 The experiments that were conducted are described and some results given in section 7.3. 6. Extracting Dependencies and Positions
In this section, we describe two modules of the method: the attachment heuristic RA candidate binary dependencies and syntactic positions. 6.1 Attachment Heuristic RA
Attachment heuristic RA takes as input parses constituted by sequences of chunks. It uses the right-association strategy. That is, a new chunk is preferentially attached to the preceding chunk. The headwords of two attached chunks form a possible binary dependency. Consider the expression ::: a lei citada em o anterior parecer :::  X  the law cited in the previous opinion  X 
The RA heuristic allows us to identify three candidate dependencies, which are illustrated in the left column of Table 3. These dependencies are not considered at this point to be actual attachments, but only potential candidates. Later, the parser will be provided with the learned requirements stored in the lexicon, in order to propose new dependencies, which will be the output of the parsing strategy. Note that lobj denotes a nominal object appearing to the left of the verb. This cannot be identified with the subject grammatical function. The order of verbal objects is not the main feature by means of which to identify the subject and direct-object functions in Portuguese (and in most Latin languages). The position of verb complements is quite free in these languages. We consider then that grammatical functions are semantic-dependent objects, since we need semantico-pragmatic knowledge to identify them.
 information. For instance, verb citar ( to cite ) is annotated using the past participle ( vpp ) tag. This morpho-syntactic information is relevant for defining the semantic requirements of dependencies. As we show later, only semantic information enables us to consider the dependency underlying a lei citada ( the law that was cited )as being semantically similar to the one underlying citar a lei ( to cite the law ). These dependencies are not merely merged into one single relation using morpho-syntactic rules. Such rules pose some important problems: First, they require specific knowledge 124 on particular languages; and second, they introduce a great amount of noise. In our approach, these two dependencies are merged in one cluster only if our learning process provides us with semantic evidence to justify such merging. In fact, one of the objectives of our learning method is to use information on semantic requirements for ministro/o ministro citou ( cited by the Minister/the Minister cited ); mencionar a lei/mencionou-se a lei ( to mention the law/the law was mentioned ); ratificar a lei/ratificac $ a  X  o da lei ( to ratify the law/ratification of the law ). If two morpho-syntactic alternations are considered to share the same semantic requirements, then they will automatically occur in the same cluster. This strategy allows us to reduce language-dependent knowledge to a minimum.
 left position with regard to the modified noun (i.e., in the mod relation). We distinguish three different adjective relations: the left modifier, the right modifier, and the prepositional object. It is assumed here that these three dependencies can stress different semantic aspects of an adjective. For instance, our strategy led us to learn that anterior ( previous ) is semantically similar to primeiro ( first )and seguinte ( following ) when it takes the role of left modifier. However, when the adjective is to the right of a noun and is followed by a prepositional object ( anterior a , previous to ), it is clustered together with inferior ( inferior ) and igual ( equal ), which also appear within prepositional dependencies: equal to , inferior to .
 give rise to a substantial amount of odd syntactic dependencies (25%), including those caused by POS-tagging errors. The overall precision of the tagger is 96.2%. Yet considering only those tags we use in the learning strategy (i.e., nouns, adjectives, articles, verbs, etc.), the precision is close to 90%. To overcome such a noisy input, we need a reliable learning method. 6.2 Position Vectors
Given that each dependency contains two complementary grammatical locations (head and dependent), we split dependencies into two syntactic positions: the position associated with the head (or down) location and the one associated with the dependent (or up) location. The positions extracted from expression (13) are illustrated in the right column of Table 3. Following the assumption on corequirements, each position must be provided with a particular linguistic requirement.
 to a word occurring in the position. The value of the feature is the frequency of the word in that position. A position is thus defined by means of its word distribution. As has been mentioned before, those words appearing in a particular position can be used to represent, in extensional terms, a first approximation of the semantic condition the scope of each condition. In Table 4, we illustrate the word distribution of the two complementary positions underlying citada no parecer ( be cited in the report ) .
This allows us to minimize the data sparseness problem. Linguistic corpora are sparse in the sense that most co-occurrences occur few times in a given corpus. So, if co-occurences with lower frequencies were not used by the learning strategy, pertinent linguistic information would be missing, and coverage would remain low. In order to minimize missing information and coverage reduction, we retain infrequent words in position vectors.
 thus may disturb the learning task. There are a number of noise sources: words missing from the dictionary, words incorrectly tagged, wrong attachments, etc. The position shown in the first line of Table 4 occurs with at least two words that are not syntactically required: apoio ( support ) and sentido ( sense ). have frequency 1 in that position. Retaining requirements with frequency 1 enables us to retain other words that are syntactically and semantically appropriate for that position, such as artigo ( article ) and regulamento ( regulation ), which also occur only once. The next step of our method (Clustering 1) focuses on the automatic removal of odd features introduced in position vectors. 7. Clustering of Positions
Positions that share similar features are combined into clusters. Clustering is divided into two different agglomerative processes: Clustering 1 and Clustering 2. 7.1 Clustering 1
Clustering 1 builds pairs of similar positions called basic clusters. A basic cluster is the result of merging two positions considered to be similar. The features associated with a basic cluster are only those words appearing in both similar positions. This allows us 126 to filter out odd features from clusters. Features defining a basic cluster are, then, the most reliable fillers of the semantic condition imposed by the two similar positions.
Those words that are not required by both positions are removed from the cluster. The algorithm of this process is the following:
As a result of this process, we obtain a set of basic clusters, each augmented by reliable features. The aim is to automatically filter out noisy features from each pair of similar syntactic positions. Many incorrectly tagged words are removed at the filtering step. distribution is similar to that of the following positions:
Then, b iobj_em_down, citar : vpp  X  is merged with each one of the above positions. Note that this position is similar to the position associated with the active form, citar .
Finally, each pair of similar positions (i.e., each basic cluster) is defined by the words they have in common. For instance, take the basic cluster shown in (15): f b iobj em down, citar : vpp  X   X  b iobj em down, mencionar : vpp  X  g X 
Looking at those words appearing as prepositional objects of both cited in [_ ] and mentioned in [_ ] , one can see that they are semantically homogeneous. The filtered features no longer include odd words such as support and sense (see Table 4). Indeed, the process of selecting the words shared by two similar positions relies on the contextual hypothesis stated above in section 3.4, as well as on the following corpus-based observation: Those words whose appearance in a particular position would be incorrect are not likely to occur in similar positions.
 condition to be associated with two positions. In (15), a single set of words is associated with the two positions, since the positions have in common the same semantic condition (or selection restrictions). However, the scope of the condition is still too narrow: It merely embraces two positions. In order to extend the scope of semantic conditions, we cluster them using a less restrictive clustering process that allows us to build more general classes of words and positions.
 used to calculate the similarity between syntactic positions. We use a particular weighted version of the Lin (1998) coefficient. Our version, however, does not use pointwise mutual information to characterize the weight on position-word pairs. As
Manning and Schu  X  tze (1999) argued, this does not seem to be a good measure of the strength of association between a word and a local position. When the similarity between two positions is computed using our method, higher scores are assigned to rare attributes (i.e., words in our case) of compared objects (positions). By contrast, the pointwise mutual information measure is not sensitive to the fact that frequent pairs can have a strong association. In order to resolve this problem, we use a weight very similar to that proposed in Grefenstette (1994). Consequently, we employ, on the one hand, the general structure of the Lin coefficient, and on the other, the weight proposed by Grefenstette.
 ditional probability given a position (local weight). The weight Assoc , measuring the degree of association between word w and position p , is computed by equation (16):
On the other hand, the conditional probability P MLE maximum likelihood estimate (MLE), which is calculated in (17): where f  X  p, w  X  represents the frequency of word w appearing in position p , and F  X  p  X  is defined, for a particular position, as the total sum of its word frequencies:
On the other hand, word dispersion, disp , is defined as the following mean: where F  X  w  X  is defined as the total sum of position frequencies of w : values are assigned by equation (18) to those words that are not dispersed, that is, to 128 those words frequently appearing in few positions. disp measures the ability of a word between two positions is computed using equation (19):
In the numerator of (19), the condition of the summation indicates that each word w must be found with both positions p 1 and p 2 . In the denominator, w varies over all words found in p 1 and p 2 . 7.2 Clustering 2
Basic clusters are the input objects of the second process of clustering. We use an agglomerative (bottom-up) clustering for aggregating basic clusters into larger ones.
The clustering algorithm is described in Table 5. According to this algorithm, two objects are clustered if they satisfy the following restrictions: (1) they have the same number of features (i.e., words), (2) they share more than 80% common features, and common features. In order to provide words with thesaurical relations, we automatically build a thesaurus of similar words. Details of the thesaurus design are given in section 7.5.
 positions. For two basic clusters such as CL_00013, which contains the features note , article , dispatch , document , and text , and CL_03202, whose features are article , dispatch , document , text , and opinion , we obtain the more general cluster CL_04447, which is constituted by all the different positions and words of its basic components. Note that the two basic clusters are different with regard to two features: note and opinion .
According to our clustering restrictions, the two clusters can be merged if each common features: article , dispatch , document , and text . A word is thesaurically related to generated and entered in our thesaurus. The thesaurus, then, is used to control and constrain the construction of abstract classes of positions. In addition, the larger class,
CL_04447, allows us to induce collocation data that does not appear in the corpus. For instance, we induce that the word parecer ( opinion ) may appear in position b iobj_em, mencionar : vpp  X  ( mentioned in [_ ] ). Similarly, we also learn that word nota ( note ) can occur with b iobj_em, referenciar : vpp  X  ( made reference to in [_ ] ). 7.3 Tests and Results
We tested our learning strategy over two training corpora, PGR and EC. concerning the information extracted from these two corpora are presented in Table 6. with their syntactic and semantic requirements. Each corpus has its own lexicon. Later, in section 8.1, we describe how this information is stored in the lexicon entries. smaller set of general syntactico-semantic roles, such as Agent, Patient, Theme, and
Instrument. On the other hand, they cannot be associated with word-specific roles like, for instance, Reader, Eater, and Singer. The level of elaboration of these clusters ranges domain-specific level, which is considered more appropriate for use in computational tasks (Gildea and Jurafsky 2002). However, given the too-restrictive constraints of the algorithm, the clustering method also overgenerates redundant clusters. In future work, we will attempt to reduce redundancy using clustering algorithms based on concept lattices (Kovacs and Baranyi 2002). 130 whether they are useful in a parsing task. The degree of efficiency in such a task (parsing) may serve as a reliable evaluation for measuring the soundness of the learning strategy. 7.4 Related Clustering Methods
There are other approaches to acquisition of word senses by clustering words according to context-sensitive information. Similarly to our work, these approaches assume, on the one hand, that a word can appear in different clusters (soft clustering), and on the other hand, that each cluster represents a particular sense distinction of the words that are elements of it. Different clustering methods can be distinguished. (and not pair of words) in order to generate clusters of syntactic positions, whose features are set of words (Allegrini, Montemagni, and Pirrelli 2003; Faure and Ne  X  dellec 1998; Reinberger and Daelemans 2003). Similarly to our approach, these methods follow both the relative view on word similarity and the assumption on contextual word sense, which were introduced above in sections 3.3 and 3.4, respectively. However, these methods differ from ours in several aspects. That of Reinberger and
Daelemans (2003) does not use any kind of filtering process. So given a cluster of positions, the set of its features is basically defined as the union of their co-occurring words. This method turns out not to be appropriate when extracted co-occurrences are noisy. The cooperative system Asium presented in Faure and Ne  X  dellec (1998) filters out incorrect words from clusters of positions. However, unlike in our work, this task is not automatic. It requires manual removal of those words that have been incorrectly tagged or analyzed. Similarly to our approach, Allegrini, Montemagni, and Pirrelli (2000) developed an automatic procedure to remove odd words from clusters. It consists in defining a first clustering step in which positions are aggregated in basic clusters, which are called substitutability islands . As in Clustering 1 (section 7.1), each basic cluster selects only those words occurring in all positions of the cluster.
However, Allegrini, Montemagni, and Pirrelli (2000) define a second clustering step involving significant differences with regard to our Clustering 2. Given a position p , they define a list of basic clusters containing p . This list is ranked and then used as the input to a clustering strategy that aggregates only basic clusters belonging to that list. So a cluster containing p cannot be aggregated with a cluster that does not contain p. generalizations.
 similarity of their whole distributions (Pantel and Lin 2002; Lin and Pantel 2001). These methods, then, follow both the absolute view on word similarity and Harris X  X  distributional hypothesis, which we introduced in section 2.3. However, in order to make the absolute view more relative, a collection of small and tight clusters (called committees ) is proposed in a first step. These tight clusters are supposed to represent different word senses. Then in a second step, each word is assigned to a set of committees.
 on semantic similarity, absolute and relative. Given a word w occurring in position p , generates classes of contextually similar words. A contextual class results from the intersection of the words occurring in p and the words similar to w. The definition of a contextual class contains the two views on word similarity. On the one hand, the words occurring in p are called the cohorts of w. The cohorts are similar to w only with regard to position p (relativized view). On the other hand, a corpus-based thesaurus is used to select words similar to w with regard to its whole position distribution (absolute view). Note that a contextual class is not far from what we call a basic cluster. In a second step, contextual classes are used to compute attachment association scores.
The aim of the method is not to discover word senses (as in the methods outlined above), but to solve syntactic ambiguities. No clustering strategy is proposed to generate more general contextual senses.
 hypothesis and the relative view, we also take into account the absolute view on word similarity to design a corpus-based thesaurus. 7.5 Automatic Thesaurus Construction
Clustering 2 uses a thesaurus of similar words to avoid undesirable aggregations. To design a corpus-based thesaurus, we follow the absolute view on word similarity: The similarity between two words is computed by comparing their whole context distribution. Our thesaurus is not specifically designed to be involved in the clustering process. It is designed primarily with the aim of measuring the discriminative capabilities of syntactic positions defined on the basis of corequirements (Gamallo et al. 2001). In particular, we check whether corequired positions are semantically more selective than those used by Grefenstette (1994), which were defined in terms of simple requirements. Experimental tests showed that corequirements permit a finer-grained characterization of  X  X  X eaningful X  X  syntactic positions.
 measure defined in Grefenstette (1994). The weighted Jaccard similarity ( WJ ) between two words, w 1 and w 2 , is computed by
In (20), the weight Assoc is the result of multiplying a local and a global weight, whose definitions are analogous to those given in formulas (17) and (18).
The major difference is that in (20), positions are taken as attributes and words as objects.

PGR corpus, we produced 42,362 entries: 20,760 nouns, 16,272 verbs, and 15,330 132 adjectives. For each entry w, the thesaurus provides a list containing the 20 words most similar to w . This is the list that was later used in the clustering process. 8. Application and Evaluation
The acquired classes are used to solve attachment ambiguities. For this purpose, first, a lexicon is designed by using the linguistic information contained in the learned clusters. Then a particular heuristic uses this information to propose correct attachments. Some experiments are performed on two text corpora. The results are evaluated in section 8.3.
 8.1 Design of a Lexicon with Corequirements
The learning method provides a lexicon with syntactic and semantic information. A word entry is divided into two types of information (see Table 7). SUBCAT is the repository of syntactic and semantic requirements. SENSE contains the different word sets to which the entry belongs. Each word set corresponds to a particular sense distinction. However, only the SUBCAT information is used here for the purpose of entry is associated with a SUBCAT repository with six requirements and a SENSE repository containing two word senses.

Concerning the nominal positions, we learn that secretary selects for nouns such as post or rank in the de_up location, whereas it requires a class of nouns denoting institutions or functions in the de_down location. Concerning the verbal positions, we also learn that secretary requires various verb classes in different verbal positions: two classes in location iobj_a_up , one class in iobj_ por_up , and one more in lobj_up . the SUBCAT repository in Table 7. This pattern can be represented as follows:  X  X where X , Y , Z , . . . stand for variables of subcategorized words, while a is the subcategorizer. If a is secreta  X  rio , then the specific values of X , Y , Z , . . . can be found in Table 7. For example, according to Table 7, the noun cargo instantiates Z , while the verb pertencer instantiates X . The symbol  X  stands for Boolean disjunction. We take into consideration that at least in Portuguese, all word arguments are optional. Even the subject of a verb may be omitted. Note, however, that the syntactic pattern in (21) does not allow it to be distinguished whether arguments are compatible or not. For instance, it is not able to predict that ( Y v por positions that cannot appear in the same sentence. Moreover, there are no restrictions on the linear order of arguments. As we do not learn this type of syntactic information, the pattern depicted in (21) can be viewed merely as a set of potential arguments of a word. So our method does not allow a set of entirely organized subcategorization frames to be captured for each word.
 of requirement positions that are not usual in most standard approaches. Five positions of secretary require not standard dependent complements, but different types of heads. This is a significant novelty of our approach. Consider the positions that impose nonstandard requirements (i.e., nonstandard predicates). According to the standard definition of predicate given in section 4.2.1 (simple requirement definition), only locations robj_down, lobj_down, and mod_up give rise to positions with requirements. 8 By contrast, positions defined by the complementary locations ( robj_up, lobj_up, mod_down ) are considered mere complements of verbs or objects modified by adjectives. So they cannot impose any requirement, and thereby they are not semantically defined as predicates. In opposition to this viewpoint, our system learns more classes of requirements imposed by positions considered nonstandard predicates (5,192) than classes of requirements imposed by positions considered standard 134 predicates (4,600). These experimental results seem to prove that nonstandard predicates correspond to positions with requirements. In sum, we may infer that binary dependencies are structured by corequirements.
 should represent two senses of secreta  X  rio . Unfortunately, our clustering algorithm generates some redundancy. In this case, the two clusters should have been merged into one, since they seem to refer to the same concept. Cluster redundancy is the major problem of our learning strategy. 8.2 Attachment Heuristic CR
The syntactic and semantic requirements provided by the lexical entries are used to improve a parser and the DCG grammar it is based on. The description of the parser remains beyond the scope of this article; it has been described in Rocio, de la Clergerie, and Lopes (2001). Details of a symbolic DCG grammar with information on linguistic corequirements can be found in Gamallo, Agustini, and Lopes (2003). In this article, we only outline how the grammar uses this information to resolve syntactic attachments.
Corequirements are at the center of attachment resolution. They are used to characterize a particular heuristic on syntactic attachment. This heuristic referred to as CR, is supposed to be more precise than RA. It states that two chunks are syntactically and semantically attached only if one of the following two conditions is verified: Either the dependent is semantically required by the head or the head is semantically required by the dependent. Take the expression
This expression is analyzed as a vp X  X p construction only if at least one of the two following requirements is satisfied: symbolic grammar. Attachments are then solved by using Boolean, and not purely probabilistic, constraints. According to the lexical information illustrated in Table 7, expression (22) can be analyzed as a vp  X  pp construction because at least the up requirement is satisfied. Note that even if we had no information on the verb re-quirements, the attachment would be allowed, since the noun requirements in the dependent ( up ) location were learned. So we learned that the noun secreta has as argument the verb competir in location b iobj_a_up  X  . As we show in the evaluation procedure, corequirements are also used to resolve long-distance attachments. 8.3 Evaluating Performance of Attachment Resolution We evaluated the performance of CR, that is, the attachment heuristic based on Boolean corequirements. The general aim of this evaluation was to check whether the linguistic requirements we learned were adequate for use in a parsing task. The degree of efficiency in such a task may serve as a reliable evaluation for measuring the soundness of our learning strategy. 8.3.1 Test Data. The test data consisted of sequences of basic phrases (i.e., chunks).
The phrase sequences selected belong to three types: vp X  X p X  X p , vp X  X p X  X p , and np X  X p X  pp . They were randomly selected from two different (and already chunked) test corpora: a group of 633 sequences was selected from the EC corpus and another group of 633 was selected from PGR. Each group of 633 sequences was constrained to have three equal partitions: 211 vp X  X p X  X p sequences, 211 vp X  X p X  X p sequences, and 211 np X  pp X  X p sequences. The test corpus from which each group was selected had previously been separated from the training corpus, so the sequences used for the test were excluded from the learning process. Then the annotators (the coauthors) manually proposed the correct attachments for each phrase sequence, using the full linguistic context. Some specific instructions were given to the annotators for the most controversial cases. The following excerpts from these instructions are illustrative: (1) if a pp seems to be a modifier of the verb, then it is attached to the vp ; (2) if a pp is a modifier of the sentence, no attachment is proposed; (3) if an np following a vp is either the direct object or the subject of the verb, then the np is attached to the vp ; (4) if a pp seems to be attached to two phrases, two attachments are proposed (we retain the attachment is proposed. Note that verbal modifiers and verbal complements are treated in the same way (see subsection 4.2.2). Moreover, we consider a robj (i.e., an np following a vp ) as being able to be instantiated by two different functions: both a direct object and a subject (section 6.1).
 type vp X  X p X  X p (Sekine et al. 1992; Hindle and Rooth 1993; Ratnaparkhi, Reymar, and Roukos 1994; Collins and Brooks 1995; Li and Abe 1998; Niemann 1998; Grishman and
Sterling 1994). These approaches consider each sequence selected for evaluation as having the potential to be syntactically ambiguous in two ways. For instance, the seuqence of chunks can be elaborated either by the parse which represents a syntactic configuration based on proximity ( phrase2 is attached to phrase1 and phrase3 is attached to phrase2 ), or by long-distance attachment: phrase2 is attached to phrase1 and phrase3 is attached to phrase1 . 136 generalized to other syntactic sequences and ambiguity configurations. On the one hand, we evaluated not only one, but three types of phrase sequences: vp X  X p X  X p , vp X  X p X  X p , and pp X  X p X  X p . On the other hand, these sequences cannot be reduced to only two syntactic configurations (two parses). They can be syntactically ambiguous in different ways. These ambiguities are introduced by adjective arguments and sentence adjuncts (see Table 8).
 standard configurations underlying parses (24) and (25). None of the sequences in that table match the two standard configurations. For instance, a o decreto ( to the decree ), which is the phrase2 of the first example, is not attached to the head of phrase1 , but to the adjective relativo ( referring ). Similarly, in the second expression, a o citado diploma ( to the referred diploma ) is attached to the adjective anexos ( appended ) and not to the head of phrase2 . Subcategorization of adjectives introduces a new type of structural ambiguity, which makes it more difficult to make attachment decisions.
Finally, in the third sequence, em a medida ( insofar as ) is the beginning of an adverbial sentence, so it is not attached to one of the individual phrases but to the whole previous sentence. In sum, resolving structural ambiguity cannot be reduced to a binary choice between the two configurations depicted in (24) and (25). We return to this matter below.
 words. We do not remove these cases, since they can give us significant information about how (in)dependent of noisy data our learning method is. 8.3.2 The Evaluation of Protocol. Each sequence selected from the test corpus con-tains three phrases and two candidate attachments. So given a test expression, two different attachment decisions are evaluated: two attachment decisions, the total number of decisions that we evaluated was 2,532.
By contrast, in most related approaches, test expressions are ambiguous in only two senses: phrase3 is attached to either phrase2 or phrase1 . Such approaches do not consider the attachment between phrase2 and phrase1 . So in these approaches, Decision A is not taken into account. Moreover, they do not evaluate those cases in which phrase3 is not attached to phrase2 or to phrase1 . In sum, only one decision per expression is evaluated, namely, the decision concerning the PP-attachment. This type of evaluation, however, is not appropriate to measure the capability of the system to identify the nonstandard structural ambiguities described above (section 8.3.1). For instance, we expect the system not to propose that the pp ao diploma (to the [referred] diploma) is attached to the previous np , headed by estatutos , in the second example of Table 8. The correct decision is to propose no attachment between the pp ( phrase3 ) and either of the two previous phrases taking part in the sequence vp X  X p X  X p . The attachment is actually to a word, namely, the adjective anexo , which is not a direct constituent of the abstract sequence vp X  X p X  X p .
 attachments. There are several cases in which the three phrases of a sequence are semantically related. In those cases, CR often proposes three attachments even if only two of them are syntactically allowed. For instance, take the following np X  X p X  X p sequence: which would be correctly analyzed by using the same configuration as in parse (24), that is,
Note that there exists a strong semantic relationship between phrase3 ( de secre-(27). Taking into account the semantic requirements stocked in the lexicon (see
Table 7), CR is induced to propose, in addition to the two correct attachments, a long-distance dependency, which seems not to be syntactically correct in this particular case. We call this phenomenon attachment overgeneration . When a sequence contains two semantically related phrases that are not actually syntactically dependent, CR overgenerates an additional attachment. Attachment overgeneration overcome this problem, we use a default rule based on right association. The default rule removes the long-distance attachment and proposes only the two contiguous ones. This simple rule has an accuracy of more than 90% with regard to the 15% of sequences containing overgeneration.
 problem. The semantic interpretation of sequence (26) needs to account for all conceptual relations underlying the sequence. So the semantic requirements that are useful for building a semantic representation of the sequence. 8.3.3 Baseline (RA). Concerning the ability to propose correct syntactic attachments, we made a comparison between CR and a baseline strategy. As a baseline, we used the 138 attachments proposed by right association. For each sequence of the test data, RA always proposes the configuration underlying parses (27) and (24); that is, phrase2 is attached to phrase1 , and phrase3 is attached to phrase2 . 8.3.4 Similarity-Based Lexical Association. We also compared CR to a very different learning strategy: the similarity-based lexical method (Sekine et al. 1992; Grishman and
Sterling 1994; Dagan, Marcus, and Markovitch 1995; Dagan, Lee, and Pereira 1998), described in section 2.3. We simulated here a particular version of this strategy. First, we used the log-likelihood ratio as a score of the association between pairs of syntactic positions and words. We restricted the lexical association procedure to suggest attachments only in cases in which the absolute value of the ratio was greater than an empirically set threshold ( 3.00). Then, in order to generalize from unobserved pairs, a list of similar words was used to compute nonzero association scores. For this purpose, the thesaurus described in section 7.5 turned out to be useful.
 association LA sim between position p and word w is obtained by computing the average of the likelihood ratios between p and the k most similar words to w : where LA  X  p , w i  X  is the likelihood ratio between p and one of the k most similar words to w . NZ represents the number of nonzero values among LA  X  p , w LA  X  p , w k  X  .
 ( ratify the law ), we compute the two following lexical associations: The scores of these two associations are taken into account in the evaluation procedure.
In particular, the sum of the two scores (if each of them is greater than the empirically set threshold) will be used to make a decision on the attachment between an np headed by lei and a vp headed by ratificar . 8.3.5 Precision and Recall. The evaluation of each attachment decision made by the system can be
We refer to both tp and tn as true decisions ( td ). The evaluation test measures the ability of the system to make true decisions. As far as our strategy and the similarity-based approach are concerned, a false negative ( fn ) is interpreted as the situation in which the system lacks sufficient subcategorization information to make a decision. By contrast, the baseline always proposes an attachment.
 decisions suggested by the system divided by the number of total suggestions. That is:
Recall is computed as the number of true decisions suggested by the system divided by all the decisions that have been made (i.e., the total number of ambiguities):
To clarify the evaluation procedure, Table 9 displays the different attachment decisions made on the following test sequence:  X 
The two correct attachments in (32), proposed by the human annotator, are compared against the attachment decisions proposed by the three methods at stake: heuristic with Boolean corequirements, similarity-based lexical association, and right associa-tion, which is the baseline. Table 9 assesses the two different decisions (A and B) made by each method. Note that both CR and LA sim take advantage of corequirements.
Indeed, each decision is made after two types of subcategorization information have been considered: the requirements the dependent word must satisfy and the requirements that the headword must satisfy.
 of the three methods. LA sim incorrectly suggests that there is no attachment. The score of two internal requirements is zero, so the final decision is a false negative: fn . The system has no information on requirements because on the one hand, the two phrases at stake do not co-occur in the training corpus, and on the other, co-occurrences of phrases with similar words were not attested (and then no generalization was allowed). CR, by contrast, is endowed with the appropriate requirements to correctly suggest an attachment ( tp ) between the two phrases, even though they are not attested in the training corpus. The clustering strategy allowed the system to learn both that b iobj_ por_D , assistir  X  requires representante and that requires assistir . Note that in order to suggest the attachment, it is not necessary that the two complementary requirements be learned. As has been noted in section 8.2, the learning of only one of them is enough to make the suggestion. Finally, RA also suggests the correct attachment. Indeed, the two phrases in (32) are related by right association. 140 attachment ( tp ) between [ np o representate ] and [ pp de o Estado-Membro ]. 8.3.6 Results. Table 10 reports the test scores in regard to the precision and recall from the experiments performed. These scores concern three methods, namely RA,
LA sim , and CR, two text corpora (EC and PGR), and three types of phrase sequences. There are no significant differences between the scores obtained from corpus EC and those from PGR, CR, for instance, obtains very similar F -scores over the two corpora. However, there are important differences among the precision values associated with the three phrase sequences. In particular, the scores on sequence vp X  X p X  X p are significatively higher than those on the other sequences, regardless of the method employed. This is motivated by the fact that in most vp X  X p X  pp sequences ( , 95%), there is a true attachment between np and vp . So the precision score achieved by the three methods with regard to this particular attachment decision is very high. Prepositional-phrase attachments, by contrast, are more ambiguous, which causes sequences vp X  X p X  X p and np X  X p X  X p to be less predictable.
Indeed, such sequences have two prepositional phrases involved in the attachment decisions.
 of the three methods over the two corpora and the three phrase sequences. The total precision of our method (CR) reaches 0.89, that is, four percentage points higher than
LA sim . Note that the precision value of LA sim is not far from the values reached by other approaches to attachment resolution based on the similarity-based lexical association strategy. For instance, the method described in Grishman and Sterling (1994) scores a precision of , 0.84. Concerning recall, CR also reaches a level of precision that is four points higher than that achieved by LA sim . This entails that on the one hand, the ability of CR to learn accurate subcategorization information is higher than that of LA on the other hand, the ability of CR to learn from sparse data and to generalize is at least no lower than that of LA sim .
 proximity. The remainder (24%) are either long-distance attachments between phrase3 and phrase1 , other types of attachments such as adjective complements, and sentence modifiers, or finally, tagger errors. Note that there is no difference between the baseline method X  X  precision and recall scores. Since RA always makes a (true or false) positive decision, there cannot be (true or false) negative decisions. 142 training corpus, have a negative influence on the precision of both LA methods are sensitive to noisy data.
 process over six partitions (25%, 40%, 55%, 70%, 85%, and 100%) of the EC corpus.
Figure 7 shows that recall improves with corpus size. However, recall growth is more significant in smaller partitions. In this particular corpus, recall stability seems to be achieved when the corpus contains three million words. It follows that in order to improve recall, we would have to use not only a bigger training corpus, but also a more efficient clustering strategy, that is, a strategy that would be able to make additional correct generalizations. Finally, note that precision neither increases nor decreases with corpus size. 9. Conclusion and Future Work
This article has presented a particular unsupervised strategy to automatically acquire syntactic and semantic requirements. Our aim was to learn two types of information about a given word: the syntactic positions in which the word appears and the semantic requirements associated with each syntactic position. Besides that, this strategy also allowed us to discriminate word senses. The strategy is based on several linguistic assumptions. First, it was assumed that not only does the syntactic head impose restrictions on its dependent word, but also that the dependent word may select for a specific type of head, a phenomenon referred to as corequirement. Second, we claimed that similar syntactic positions share the same semantic requirements. So we measured not similarity between words on the basis of their syntactic distribution, but similarity between syntactic positions on the basis of their word distribution. It was assumed that the latter kind of similarity conveys more pertinent information on linguistic requirements than the former one. The learning process allowed us to provide a lexicon with, among other information, both syntactic subcategorization and selection restrictions. This information was used to constrain attachment heuristics. attachment resolution. They are being used to automatically select word senses in context (word sense disambiguation task). For this purpose, we are performing new experiments on less domain-specific text corpora, since such corpora increase the number of senses per word. On the other hand, these clusters turn out to be very useful for checking whether two or more different morphological forms of a word are semantically related. For instance, if ratification of [_ ] is similar to ratify [_ ] , we may infer that the verb ratify and the noun ratification are semantically related. the parser. To do this, parsing and learning can be involved in a bootstrapping process.
The dependencies proposed by heuristic CR will be used as input to discover new linguistic requirements. This new information will enable us to update the lexicon, and then to propose new dependencies. At each cycle, the lexicon will be provided with new requirements, and thereby the parser coverage will be higher. The successive  X  X  X earning + parsing X  X  cycles will stop as no more new information is acquired and no more new dependencies are proposed. 144 Acknowledgments References
