 Dept. of Computer and Information Sciences
Most traditional learning systems assume that the class distribution in data sets is balanced, an assumption that is often violated. There are many real-world applications where the data sets are highly imbalanced, such as oil spill detec-tion from satellite images [1], credit card fraud detection [2], medical diagnostics [3], and predicting telecommunication equipment failure [4]. In these data sets, there are many examples of the  X  X ormal X  (the majority/negative class), and very few examples of the  X  X bnormal X  (the minority/positive class). But often it is the rare occurrence, the  X  X bnormal X , which is the interesting or important occurrence, e.g. an oil spill. In data mining, the rare occurrence is usually much more difficult to identify since there are so few examples and most traditional learning systems are designed to work on balanced data. These learning systems are biased towards the majority class, focus on improving overall performance, and usually perform poorly on the minority class. If a data set has say 999 examples of the normal event and only one example of the abnormal event, a learning system that predicts all examples as  X  X ormal X  will be 99 . 9% accurate, but misclassify the very important abnormal example.

Mining imbalanced data sets has been the focus of much research recently [5] X  X 7], and one important direction is sampling strategies. Sampling methods may include remov-ing majority class data points (under-sampling) or inserting minority class data points (over-sampling) in order to im-prove accuracy. Two well-known techniques for increasing the number of minority examples are random resampling and SMOTE (Synthetic Minority Over-sampling TEchnique) [8]. In random resampling, minority class examples are ran-domly replicated, but this can lead to overfitting. The SMOTE algorithm inserts synthetic data into the original data set to increase the number of minority class examples. The synthetic points are generated from existing minority class examples by taking the difference between the corre-sponding feature values of a minority class example x and one of its nearest neighbors in the minority class, multiplying each feature difference by a random number between 0 and 1, and then adding these amounts to the feature vector of x .
SMOTE and its variations (for example [9] X  X 11]) have shown that they can improve overall classification accuracy and also improve the learning of the rare event. But SMOTE and its variations work only in feature space, i.e., each example is represented as a point in n -dimensional space where n is the number of features of each example. However, for some fields such as bioinformatics, image analysis, and cognitive psychology, often the feature vectors are not available. Instead, in these domains the data may be repre-sented as a matrix of pairwise comparisons where typically each element of the matrix is the distance (similarity or dissimilarity) between the original data points. This matrix represents the distance space of the data. Often, this distance space is non-metric because the distance function used to calculate the similarities or dissimilarities between the pairs of data points does not satisfy the mathematical requirements of a metric function. For example, the distances between time series are often non-metric due to warping. When only pairwise scores are available, the vector space based approaches to adding synthetic points cannot be used. In our experiments, we do not compare ghost points with SMOTE or random resampling because SMOTE and random resampling do not work in distance spaces, while the distinct advantage of using ghost points is that they can be used in distance spaces.

Our approach to balancing the data sets is to use super-vised learning to increase the size of the minority class by inserting synthetic points directly into the distance space. Our synthetic points do not have any coordinates, i.e., they are not points in any vector space, which is why we call our synthetic points ghost points . But our ghost points are points in distance space. Fig. 1 shows the Wafer training set before and after adding ghost points. The training set has 903 examples of the majority class and 97 examples of the minority class for a total of 1000 examples. To create Fig. 1a, we first took the original 1000  X  1000 distance matrix and used PCA to reduce the dimensionality. For Fig. 1b we then add 9 ghost points per minority example to the distance matrix (to create a 1873  X  1873 matrix) and again run PCA. The majority class is plotted as red circles, the minority class as blue squares, and the ghost points as green squares. In Fig. 1a, without ghost points, it is impossible to distinguish the minority class from the majority class since the minority class forms no cluster and many of the minority class points overlap the majority class clusters. In Fig. 1b, after ghost points are added to the training set, the underlying shape of the data changes to form five discernable clusters. It is clear that two of the clusters belong to the minority class (the upper-left cluster and the lower-right cluster).
To show the flexibility of our approach, we inserted ghost points into the distance spaces induced by two different distance measures, Dynamic Time Warping (DTW) [12], [13] and Optimal Subsequence Bijection (OSB) [14]. For a nice overview of elastic sequence matching algorithms, see [15]. The DTW distance between two sequences is the sum of distances of their corresponding elements. Dynamic programming is used to find corresponding elements so that this distance is minimal. The DTW distance has been shown to be superior to the Euclidean distance in many cases [16], [17]. However, DTW is particularly sensitive to outliers, since it is not able to skip any elements of the sequences. In DTW, each element of the query sequence must correspond to some element of the target sequence and vice versa. Thus, the optimal correspondence computed by DTW is a relation on the set of indices of both sequences, i.e., a one-to-many and many-to-one mapping. The fact that outlier elements must participate in the correspondence optimized by DTW often leads to an incorrect correspondence of other sequence elements. OSB computes the distance value between two sequences based directly on the distances of corresponding elements just as DTW does, but unlike DTW, OSB can skip outlier elements of the query and target sequences when computing the correspondence. This makes the performance of OSB robust in the presence of outliers. Moreover, OSB defines a bijection on the matched subsequences, which means that we have a one-to-one correspondence of the matched elements.

We chose support vector machines (SVMs) to perform the classification because they are a fundamental machine learn-ing tool and they have a strong theoretical foundation [18]. SVMs have been very successful in pattern recognition and data mining applications on balanced data sets. But when data sets are unbalanced, the SVM X  X  accuracy on the minority/positive examples is poor. This is because the class-boundary learned by the SVM is skewed towards the majority/negative class [19]. This may lead to many posi-tive examples being classified as negative (false negatives), which in some situations can be very costly (e.g. missing an oil spill, missing a cancer diagnosis). There are cost-sensitive SVMs, but often, the misclassification costs are unknown. Our experimental results (see Sec. IV) show that inserting ghost points in both DTW distance spaces and OSB distance spaces can significantly increase the SVM X  X  ability to learn the rare events. Furthermore, in most cases, the addition of ghost points increases the SVM X  X  overall classification accuracy.
 In Section II, we introduce the definition of ghost points. We discuss evaluating performance on imbalanced data sets in Section III. Section IV presents our experimental results. In Section V we summarize and discuss our future work.
In many applications, only distance (or equivalently sim-ilarity) information is available, in which case operations in vector space cannot generate synthetic points. This is the case when the data points do not have any coordinates, or if the data points do have coordinates, the Euclidean distance does not reflect their structure. Consequently, a distance measure is used that is not equivalent to the Euclidean distance, e.g., [12], [14]. For this kind of data, researchers usually utilize embeddings to low dimensional Euclidean spaces. However, embedding implies distance distortion. It is known that not every four point metric space can be isometrically embedded into an Euclidean space R k e.g., see [20]. A simple example where distances are not preserved when mapping to R k is presented in [21]. Given the metric space X defined in Fig. 2, and the mapping  X  : X = { a, b, c, d } X  R k for some k where  X  preserves the distances, the triangle inequality holds for the elements a , b , and d and thus the mapped points are collinear in the space collinear in R k . But then ||  X  ( b )  X   X  ( c ) || 2 =0 contradicting the fact that the original distance between b and c is 2.
Instead of embedding, we propose to add synthetic data points directly to a given distance space. In this paper, a distance space is a pair ( X,  X  ) , where X is a set and  X  X  X  R is a distance function. We require only positivity,  X  ( x, y )  X  0 for all ( x, y )  X  X  X  X , and symmetry,  X  ( x, y  X  ( y, x ) for all ( x, y )  X  X  X  X . Clearly, we would like  X  to be as close as possible to a metric, but this is not always possible, e.g., there are clear arguments from human visual perception that the distances induced by human judgments are often non-metric [22].

The key observation of the proposed approach is that although not every four point metric space can be embedded into a Euclidean space, every three point metric space can be isometrically embedded into the plane R 2 .Let ( X  where  X = { x, a, b } X  X , be a metric space with three distinct points. Then it is easy to map  X  to the vertices of a triangle on the plane. For example, we can construct an isometric embedding h : X   X  R 2 by setting h ( a )=(0 , 0) and h ( b )=(  X  ( a, b ) , 0) . Then h ( x ) is uniquely defined as a point with nonnegative coordinates such that its Euclidean distance to h ( a ) is  X  ( x, a ) and its Euclidean distance to h is  X  ( x, b ) . h : X   X  R 2 is an isometric embedding, since for any two points y, z  X   X  ,  X  ( y, z ) 2 = || y  X  z || 2 , where is the standard L 2 norm that induces the Euclidean distance on the plane. We stress that we do not require that is a metric space, but we require that the three point space ( X  , X  ) is a metric space.

Let  X  ( a, b ) denote the mean of two points a, b .If a, b then we have the usual formula  X  ( a, b )= 1 2 ( a + Fig. 3a, where red points are original data, green point e is the ghost point and e =  X  ( a, b ) ).

Our first key contribution is the definition of  X  ( any two points a, b in a distance space X . To define  X  ( in a distance space X , we need to specify  X  ( x,  X  ( a, b every x  X  X . We first isometrically embed the three point metric subspace  X = { x, a, b } X  X into the plane R 2 by h . We define  X  ( a, b )= h  X  1 ( 1 2 ( h ( a )+ h ( b )) defines vertices of a triangle on the plane, we can easily derive that || h ( x )  X  h || h ( x )  X  h ( a ) || 2 Since h is an isometry and  X  ( a, b )= h  X  1 ( 1 2 ( h ( a we obtain (see Fig. 3a)  X  ( x,  X  ( a, b )) 2 = Consequently, Eq. 1 defines the distance of every point x X to the new point  X  ( a, b ) , which we call the mean of a and b . By computing the distances of  X  ( a, b ) to all points in X , we define a new point  X  ( a, b ) , and the augmented set X = X  X  X   X  ( a, b ) } is also a distance space. We stress that to add a new point  X  ( a, b ) to X we do not need to compute the embedding h .Weuse h only to derive Eq. 1. Moreover, since the embedding h is an isometry, Eq. 1 defines correct distances from  X  ( a, b ) to all points in X .
If the space X is finite, i.e., X = { x 1 ,...,x n } , then the distance function  X  : X  X  X  X  R  X  0 is represented by a square matrix M  X  ( X ) . Each row of the square distance matrix M  X  ( X ) is the distance of one data point x to all data points in the data set, i.e., for all y  X  X , M  X  ( x, y ) . The matrix for X  X  X   X  ( a, b ) } is obtained by simply adding one row and one column to M  X  ( X ) , with each entry computed using Eq. 1.

In Eq. 1 we assumed that the three point space ( X  is a metric space. Thus, we assume that the local structure of any distance space X can be locally approximated by the metric space, which is also the assumption for em-bedding approaches [23], [24]. However, for a relatively small fraction of point triples, it happens for some triples  X = { x, a, b } X  X that ( X  , X  ) is not a metric space, which may lead to a negative distance in Eq. 1. This is the case if  X  ( x, a )+  X  ( x, b ) &lt; X  ( a, b ) . Then a triangle with vertices h ( a ) ,h ( b ) ,h ( x ) cannot be constructed on the plane, as illustrated in Fig. 3b. Since a single point h on the plane does not exist, we map h ( x ) to two different points denoted x a and x b such that  X  ( x, a )= || h ( a and  X  ( x, b )= || h ( b )  X  x b || . Without loss of generality we assume that  X  ( x, a ) &gt; X  ( x, b ) . Then it is possible to position points x a and x b on the plane such that (see Fig. 3c):  X  ( x, a )= || h ( a )  X  x a || ,  X  ( x, b )= || h ( || h (  X  ( a, b ))  X  x a || = || h (  X  ( a, b ))  X  x b || .
Thus, both points x a and x b are the same distance away from h (  X  ( a, b )) , and this distance is equal to h ( b ) || X  X | x b  X  b || . Therefore, we define h ( x )= { and Formally, h maps x to a single point in a quotient space / { x a ,x b } , and h remains an isometric embedding but to the quotient space. Thus, the proposed approach can be applied to non-metric distance spaces, and our construction guarantees that the distances to all ghost points are nonneg-ative. The obtained distances also preserve symmetry.
However, it may happen that two different points have distance zero, and this is possible even if X is a metric space. For example, assume that X is a sphere of radius 1 and that points a and b are on the north and south poles. For any point x  X  X on the equatorial line the distance between  X  ( and x becomes  X  ( x,  X  ( a, b )) 2 =0 . 5(  X / 2) 2 +0 . 5( 0 . 25  X  2 =0 . Therefore, every point on the equatorial line has a distance of 0 to the ghost point  X  ( a, b ) . This example also shows that adding ghost points to a metric space may lead to a non-metric space. We stress however that the intended application of the proposed method is to densify distance spaces that are non-metric, since such spaces are common in many cognitively motivated tasks such as distances between images, shapes, text documents, and so on.

In many real-world situations, the minority class, the class with the fewest examples, is by far the most im-portant class. Take for example the Mammography data set [25], which consists of non-calcification (non-cancerous) and calcification (cancerous) examples. The data set has 11 , 183 examples of which only 260 ( 2 . 32% ) are examples of cancer. A trivial classifier that classifies all examples as non-cancerous will achieve an accuracy of 97 . 68% , though its error rate for the minority class is 100% . For this data set, there are also uneven costs associated with misclassifying a normal example and misclassifying a cancerous example. If a healthy patient is incorrectly diagnosed with having breast cancer, there is a cost associated with this error (fear, unnecessary tests) but eventually the misdiagnosis will be found. On the other hand, if a patient who does have breast cancer is incorrectly diagnosed as being healthy, then the cost could be her life since she will not get appropriate treatment. When the performance on the minority class is as important or more important than overall accuracy, other performance measures must be used. A common measure is F -measure [26] which is defined below.

Most studies on the class imbalance problem concentrate on two-class problems since multi-class data sets can easily be reduced to two classes (see Sec. IV). In an imbalanced data set, one class, the majority class or the negative class, has many examples, while the other class, the minority class or positive class, has few examples. These imbalances in real world data sets can be 2:1, 1,000:1, or even 10,000:1. When a data set is imbalanced, the usual forms of evaluating performance do not work. For classification, generally the overall accuracy (the fraction of examples that are correctly classified) or error rate ( 1  X  accuracy ) is reported, but this does not have much value if the interest lies in the minority class. It has been empirically shown that accuracy can lead to poor performance for the minority class [27]. Another problem with using accuracy as the performance metric is that different classification errors are given the same importance, whereas in actuality their costs might differ significantly.

For imbalanced data sets when the minority class is the important class, performance metrics borrowed from the information retrieval community [26] are often used. They are based on a confusion matrix (see Table I), that reports the number of true positives ( TP ), true negatives ( TN ), false positives ( FP ), and false negatives ( FN ). These are then used to define metrics that evaluate the performance of a learner on the minority class, such as recall , precision , and F  X  -measure . The formulas for these metrics are given below. The precision of a class (Eq. 4) is the number of TPs divided by the total number of examples predicted as positive. A precision score of 1 . 0 means that every example predicted as a positive example is a positive example, though there may be some positive examples that were labeled as negative. The recall of a class (Eq. 3) is the number of TPs divided by the number of examples that are actually positive. A recall score of 1 . 0 means that every positive example is labeled correctly, though some negative examples may have also been labeled as positive. There is always a trade-off between precision and recall, but for data sets where the cost of false negatives is high, a high recall value is preferable. The F  X  -measure [26] (Eq. 6) is the weighted harmonic mean of precision and recall and merges recall and precision into a single value. The best F  X  score is 1 the worst is 0 .The  X  parameter controls the relative weight given to recall and precision. F  X   X  X easures the effectiveness of retrieval with respect to a user who attaches  X  times as much importance to recall as precision X  [26]. If correct classification of the minority class is important, when false negatives have similar costs to false positives, then the F measure (  X  =1 ) is used because precision and recall are weighted equally. When the cost of false negatives is more than that of false positives, then the F 2 -measure (  X  =2 better because it weights recall twice as heavily as precision.
Unlike other techniques that add synthetic points, ghost points have the advantage that they can be added in distance space. To show that they will work with different distance measures, we use both Dynamic Time Warping (DTW) and Optimal Subsequence Bijection (OSB) as distance measures on the UCR Time Series data sets [28] for our experiments. The UCR Time Series data repository has available 20 data sets from various domains. The time series length ranges from 60 (Synthetic Control data set) to 637 (Lightning-2 data set) and the number of classes in a data set ranges from 2 to 50. Each data set is divided into a fixed training set and testing set. The number of examples in a training set ranges from 24 (Face(four) data set) to 1,000 (Wafer), and the number of testing examples ranges from 28 (Coffee) to 6,174 (Wafer). In our experiments, we use fourteen of the used).
 A. Methodology
We add ghost points to the minority class of the training and testing set and perform classification in the following way: 1) The training set 2) The testing set
There are two critical parameters to set when we convert the distance matrices to kernels, A and K , that modify the  X  for the Gaussian Kernel function. As stated in [30], the scaling parameter  X  is some measure of when two points are considered similar. It is common for  X  to be chosen manually, but sometimes a single value of  X  does not work well for an entire data set. Therefore, we use the method in [29] to calculate the local scaling parameter  X  ij for each pair of data points x i and x j . The affinity between a pair of points can be written as: where  X  ij = A  X  mean { k nn d ( x i ) ,k nn d ( x j ) } , mean { k nn d ( x i ) ,k nn d ( x j ) } is the the mean distance of the K -nearest neighbors of points x i , x j , and A is an extra scaling parameter. For the SVM, there is a third parameter to set, which is the cost parameter C . For all experiments we used A =0 . 5 , K =5 , and C =0 . 5 . We run SVM on the four matrices (after converting them to kernels): OSB score matrix without ghost points; OSB score matrix with ghost points; DTW score matrix without ghost points; and DTW score matrix with ghost points.

The final parameter to set is the number of ghost points to add per minority example, as the final results can be sensitive to the number of ghost points added. If the data set is highly imbalanced, a good heuristic is to balance the the classes, but this does not always give the best results. How to choose the optimal number of ghost points is an open question that we will be addressing in the future.
 B. Results
Of the 20 UCR time series data sets, there are only four that have a true minority class (the smallest class is at most 50% of the size of the next smallest class). These data sets are OSU Leaf, Wafer, Lightning-2, and ECG. OSU Leaf has 6 classes, and the other three have 2 classes each. We compare the results of SVM on OSB with and without ghost points on the four data sets in Fig. 4 and the results of SVM on DTW with and without ghost points on the four data sets in Fig. 5. Because we are interested in the performance on minority classes, specifically minimizing the number of false negatives, we measure the overall accuracy (Eq. 5), the F measure (Eq. 6 with  X  =1 ) which weights precision and recall equally, and the F 2 -measure (Eq. 6 with  X  =2 ) which weights recall twice as heavily as precision.

As the results show in Fig. 4, for the OSB score ma-trix, adding ghost points increases, for all four data sets, the overall accuracy, the F 1 -measure and the F 2 -measure. Adding ghost points to the OSU Leaf data set increases the overall accuracy by only 4 . 1 percentage points, but the F -measure and the F 2 -measure increase by 37 . 9 and 36 . percentage points respectively. For the ECG data set, adding ghost points increases the overall accuracy by 9 . 8 percentage points, and the F 1 -measure and the F 2 -measure by 16 . 23 . 9 percentage points respectively.

When using the DTW score matrix (Fig. 5), adding ghost points increases the overall accuracy, the F 1 -measure, and the F 2 -measure for three of the four data sets. For OSU Leaf, adding ghost points increases the overall accuracy by only percentage points, but the F 1 -measure and the F 2 -measure increase by 36 . 2 and 38 . 5 percentage points respectively. The only decrease in performance is for the ECG data set, where the accuracy decreases 1 percentage point when ghost points are added, but even here the F 1 -measure and the F measure increase.

In order to evaluate ghost points further, we also create artificially imbalanced data sets. Using ten other data sets from the UCR repository that have more than two classes, we keep the class with the least number of examples as the minority class, and then collapse the remaining classes into one, giving us imbalanced data sets with two classes each. If there is more than one  X  X east X  class, we choose randomly among them the class that will be the minority class. We then perform the same steps described above. See Fig. 6 and Fig. 7 for the results.
 With the OSB score matrix (Fig. 6), ghost points improve SVM X  X  overall accuracy rate on eight of the ten data sets (on the other two data sets, the accuracy remains the same). On nine of the ten data sets, the F 1 -measure and the F measure improve with ghost points. For the Face Four data set, the overall accuracy increases 17 percentage points by adding ghost points, and the F 1 -measure and the F 2 -measure increase 44 . 6 and 54 percentage points respectively. On the Lightning-7 data set, ghost points increase the overall accuracy by 8 . 2 ,the F 1 -measure by 64 . 2 , and the F measure by 62 . 3 percentage points. For the Beef data set, though the accuracy does not change by adding ghost points, without them the F 1 -measure and the F 2 -measure are zero since SVM does not classify any of the six positive examples as positive. Adding ghost points increases the F 1 -measure and the F 2 -measure by 40 and 35 . 7 percentage points respectively. The Swedish Leaf data set is the only data set that does not improve in any of the performance measures because the overall accuracy, recall, and precision are 100% both with and without ghost points.

The results are similar for DTW, as seen in Fig. 7. On nine of the ten data sets, the overall accuracy improves with ghost points (on the tenth data set the accuracy is unchanged). On all ten data sets the F 1 -measure and the F 2 -measure increase. The most dramatic increase is on the Face Four data set. Overall accuracy increases 22 . 8 percentage points with ghost points, the F 1 -measure increases 77 . 4 percentage points and the F 2 -measure increases 77 . 9 percentage points. For four of the data sets, without ghost points the F 1 -measure and the F 2 -measure are zero, i.e., SVM does not classify any of the positive examples correctly. Adding ghost points allows the SVM to correctly identify at least some of the positive examples.

We introduce an innovative method for over-sampling the minority class of imbalanced data sets. Unlike other feature based methods, our synthetic points, which we call ghost points, are added in distance space. The experimental results on standard time series data sets show that adding ghost points to the minority class can significantly improve the overall accuracy, and especially the F 1 -measure and F -measure. In our future work, we will explore optimal strategies for adding ghost points.

