 } This paper shows a scheme for incremental evaluation of XPath queries. Here, we focus on a monotone fragment of XPath, i.e., when a data is deleted from (or inserted to) the database, only deletion (insertion, resp.) may occur to query answers. For effi-ciently processing deletions, we store information on partial match-ings, i.e., which elements were participating in matchings for which query answers, and also store counters showing how many match-ings each query answer had. We use the information on the partial matchings also for skipping a part of computation upon data inser-tion. We investigate properties of the XPath fragment in order to keep the amount of information we store as small as possible. Categories and Subject Descriptors: H.2.4 [Database Manage-ment]: System X  X uery processing General Terms: Algorithms, Performance Keywords: XML, XPath, query, view, incremental evaluation, con-tinuous query, view maintenance, materialized view
This paper shows a scheme for incremental evaluation of XPath [2] queries, which is indispensable to view maintenance. It is also important for directly computing only the changes to the answers to continuous queries. We focus on a monotone fragment of XPath, i.e., when we delete data from (or insert data to) the database, only deletion (insertion, resp.) may occur to the query answers.
Our basic idea is to store information on partial matchings, i.e., which elements were participating in matchings for which query answers. We also store counters showing how many matchings each query answer had. When some element is deleted from the database, we identify the query answers to which the deleted el-ements was contributing, and decrement their counters. If some counter reaches 0, we delete that element from the query answer.
We use the same information on partial matchings also for skip-ping a part of computation when determining if a newly inserted element causes new query answers. We first test if the new element matches any subexpressions in the given queries, and if it does, then we go upward and test if its parent element satisfies the par-ent subexpression. We repeat this process, and during that, if we find stored partial matching information that says the element be- X 
Currently at Tokio Marine &amp; Nichido Systems Co., Ltd., hidetaka.matsumura@grp.tmnf.co.jp  X  Currently at Kyoto University, tajima@i.kyoto-u.ac.jp ing tested was matching the subexpression in question, we can skip the rest of the computation.
 This evaluation strategy is a kind of the bottom-up strategy [3]. In the ordinary XML query evaluation, an advantage of the bottom-up strategy is that going upward is easier because each element has only one parent, and an advantage of the top-down strategy is that there is only one starting point, i.e., the root. Here, however, we have the advantage of the bottom-up approach, while we have only one starting point, i.e., the newly inserted element.

To reduce the size of information we store, we analyze properties of the query language, and store information on partial matchings only for terminal steps and branching steps in the given queries.
The syntax of a XPath fragment we use here is defined as below: The semantics of expressions follows the ordinary definition in [2].
We define the following terminologies for XPath: unit steps are subexpressions delimited by / , // ,or [] , i.e., those of the form a ,  X  , a =  X  text  X  ,or  X  =  X  text  X  ; target steps are steps corresponding to query answers; descendant predicates are predicates, i.e., [] , fol-lowing target steps (not including nested ones in them); branching predicates are predicates which are not descendant predicates; we call the step preceding a branching predicate its joint step ; and we also call steps at the tails within predicates terminal steps .
We also classify elements contributing to query answers into the following categories: (1) elements matching steps occurring out-side any predicates, (2) elements matching terminal steps within predicates, and (3) elements matching steps other than those nor the target step. Notice that one element can match more than one steps in a query, and may belong to many categories.

Elements in the first category are always ancestors of the cor-responding answer elements, which means when they are deleted, the answer elements are also deleted. Therefore, we do not need to monitor elements in the first category. Similarly, when elements in the third category are deleted, there always exist their descendants contributing to the same answers by matching some terminal steps. Therefore, only if we monitor deletion of elements in the second category, we do not need to monitor elements in the third category.
Elements matching a terminal step in a branching predicate con-tribute to answers indirectly through elements matching the joint step of that branching predicate, and the matchings for that termi-nal step are equally shared by all the answers contributed by the elements matching that joint step. This suggests that we can reduce the information we store by having many answer elements share in-formation on matchings for branching predicates. In addition, ele-ments matching terminal steps in conjunctive branching predicates contribute to query answers not independently but in combination. Therefore, we should be aware of such conjunctive predicates.
Based on the observations above, we monitor two kind of el-ements: those matching terminal steps and those matching joint steps. We call those steps key steps . We organize key steps in one query into a forest structure, where parent-child relationship corresponds to direct contribution relationship, and siblings cor-respond to conjunctive predicates. For example, key steps in the query Q 1 below are organized into a forest shown below on the right. s 1 ,...,s 6 are IDs assigned to those key steps.
Q 1 : /a/b[  X  //d][e[f][g]]/h[i]
Some XPath expressions have simpler equivalent expressions, e.g., / p 1 [ p 2 [ p 3 ]] is equivalent to / p 1 [ p 2 / p vation, we define normal forms of XPath expressions, which is not explained in detail here. In our scheme, the normalization of ex-pressions is not mandatory, but it reduces the number of key steps, and therefore reduces the amount of information we store.
Suppose we have Q 1 above and a XML data shown below: Numbers beside elements are element IDs. In the rest of the paper, e denotes the element with the ID i . We store the following match-ing data showing which elements contribute to which elements. ( e 3 ,e 2 ,Q 1 ,s 3 ) ( e 4 ,e 3 ,Q 1 ,s 4 ) ( e 2 ,e 11 ,Q 1 ,s 1 ) means e 2 contributes to e 11 by matching s Notice that information on the matching of the elements 3, 4, 5, 7, 8, 9, 10 and steps in branching predicates is shared by e through e 2 that matches a joint step as explained previously.
Next, for each query answer, we maintain a set of counters, one counter for each key step that is a root in the key step forest: ( e 11 ,Q 1 , s 1 =1 ,s 6 =1 )( e 13 ,Q 1 , s 1 =1 ,s 6 =2 ) The latter means that one contributor matching s 1 and two contrib-utors matching s 6 make e 13 be the answer to Q 1 . We also store a set of counters for each element contributing to answers by match-ing a joint step. Each set of counters includes one counter for each child key step of that joint step. For the data above, we store: The first one means e 2 matches s 1 in Q 1 by the support of one contributor (i.e., e 7 ) for s 2 and two contributors (i.e., e
Suppose e 4 was deleted from the database. We search the match-ing information, and find e 4 was contributing to e 3 by matching s . Therefore, we decrement the counter s 4 =1 for e 3 cause the counter reaches 0, we know that e 3 no longer matches s . We search the matching information again, and find that e contributing to e 2 by matching s 3 . Therefore, we decrement the counter s 3 =2 for e 2 . Because it does not reach 0, we stop. After that, if e 10 was deleted, the counter for e 8 is decremented to 0, then the counter for e 2 is decremented to 0, and then the counters for e and e 13 is decremented to 0, so we know e 11 and e 13 should be re-moved from the answer to Q 1 . During this process, we also remove matching information and counters that have become obsolete.
Notice that when e 4 and e 5 was deleted instead of e 4 and e know that e 11 and e 13 are still the answers. That is, we can handle the conjunctive predicates correctly.

In the implementation, we use prime numbers for key step IDs, and merge a set of counters into one integer. For example, suppose we use 5 as s 2 and 7 as s 3 . Then, we merge s 2 =3 , s 3 s by dividing this merged number by the ID s 2 , i.e., 5. If we have a remainder, it means the counter has reached 0.

Next, suppose a h element with a i child is inserted as a child of e 2 . We first need to identify which steps in which queries that element may match. For this computation, we use a hash table, but we do not explain the detail here because it is a problem orthogonal to the techniques we propose in this research.

Once we found that the new element matches the step h[i] in Q we go upward and examine if the parent element e 2 matches the parent step in Q 1 . Here, however, we find a matching information on e 2 and the step s 1 . Therefore, we can know that the new element match Q 1 without evaluating the rest of the query.
We showed a method of the incremental evaluation of a mono-tone XPath fragment. There have been researches on incremental evaluation of XQuery and XSLT, but only a few researches focus on XPath part. [1] is proposing a scheme which stores the information on partial matchings, but their method periodically reevaluates the queries for potentially the whole data. The idea proposed in [4] is to narrow the scope of the reevaluation based on where the update occurred, so it is completely different from our approach.
We implemented a prototype system where we store XML data, matching information, and counters in a relational database system. We conducted experiments on that system, and the result showed that the extra space cost for our data structure is roughly propor-tional to the size of query answers, and 40-80 bytes for one answer, which is manageable. In return of this space cost, we could sig-nificantly reduce the processing time for deletion compared with the reevaluation approach. We could also significantly reduce the processing time for insertion when we can skip some expensive steps. Even when we could not skip any steps, the processing time of our approach is at worst only 104.7% of that of the ordinary ap-proach. That is, the overhead for processing steps one-by-one and for searching matching information is small enough compared with the total computation cost. [1] L. Chen and E. A. Rundensteiner. Aggregate path index for [2] J. Clark and S. DeRose, editors. XML Path Language (XPath) [3] J. McHugh and J. Widom. Query optimization for XML. In [4] M. Onizuka, F. Y. Chan, R. Michigami, and T. Honishi.
