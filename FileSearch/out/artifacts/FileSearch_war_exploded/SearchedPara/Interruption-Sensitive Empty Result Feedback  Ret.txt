 The usability of visual querying schemes for tree and graph-structured data can be greatly enhanced by providing feedback during query construction, but feedback at inopportune times can hamper query construction. In this paper, we rethink the traditional way of provid-ing feedback. We describe a novel vision of interruption-sensitive query feedback where relevant notifications are delivered quickly but at an appropriate moment when the mental workload of the user is low. Though we focus on one class of query feedback, namely empty result detection , where a user is notified when a partially constructed visual query yields an empty result, our new paradigm is applicable to other kinds of feedback. We present a framework called i serf that bridges the classical database problem of empty-result detection with intelligent notification management from the domains of hci and psychology. Instead of immediate notification, i serf considers the structure of query formulation tasks and break-points when reasoning about when to notify the user. We present an hci -inspired model to quantify the performance bounds that i serf must abide by for checking for an empty result in order to ensure interruption-sensitive notification at optimal breakpoints. We im-plement this framework in the context of visual xml query formu-lation and highlight its e ff ectiveness empirically.
 H.2.4 [ Database Management ]: Systems -Query processing Algorithms, Experimentation, Human Factors, Performance c Visual querying; query formulation; graphs; XML; query feedback; empty result detection; interruption; notifications; breakpoints
Formulating queries over semistructured databases ( e.g., xml , json , graphs) using database query languages ( e.g., XQuery, sparql , Cypher) often demands considerable cognitive e ff ort from users and requires  X  X rogramming X  skill that is at least comparable to sql . Providing a visual query interface ( gui ) is a popular approach to making query construction user-friendly [1, 6, 7, 10, 30]. Typi-cally, these interfaces enable visual query formulation involving a sequence of tasks ranging from primitive operations such as point-ing and clicking a mouse button to higher-level tasks such as selec-tion of a menu item.
A user-friendly visual query system is expected to interactively guide users into constructing correct queries. A non-exhaustive list of the kinds of guidance such a system may employ is given below.
There are two common threads in the above scenarios. First, without the aid of a visual query feedback mechanism, users would be unaware of these cases, since each case requires comprehensive knowledge of the underlying data or query language. Feedback about various problems encountered during query construction as well as possible solutions is critical to enhancing the usability of a visual querying system. Second, as query conditions in a vi-sual querying environment are typically constructed iteratively, it is often critical to detect and notify the aforementioned issues op-portunely . It is ine ff ective to provide feedback at the end of query formulation. For instance, consider the empty result problem. It is ine ff ective to provide feedback after the query formulation as a user may have wasted her time and e ff ort in formulating additional query conditions. Similarly, it is ine ff ective if the visual querying scheme fails to alert the user opportunely when a  X  X ong-running X  query fragment is detected. Such opportune notification is also im-portant in the context of query fragment suggestion as it is not ben-eficial if suggestions are made after the query has been visually constructed.
Feedback during visual query construction can be intuitively mod-eled as an alert or notification for a secondary task ( e.g., handling the empty result problem) when a user is working on a primary task (query formulation). It is desirable to build an intelligent no-tification system that can e ffi ciently detect issues and notify users e ff ectively. Such notification systems play a pivotal role in visual query systems, as well as in many software systems. Research in hci demonstrates that there are numerous benefits of notifications such as quick availability of important and relevant information ( e.g., long-running query fragment, empty answer) as well as ac-cess to nearly instantaneous communication [18].

A notification can be intrusive or non-intrusive [19]. Non-intrusive notifications are usually less disruptive to user activities as they are often presented in the periphery of a user X  X  attention. In general, non-urgent information can be presented to a user in a non-intrusive fashion. Intrusive notifications are for urgent messages. They de-mand immediate action from the user and hence they need to grab a user X  X  attention. For instance, an empty result problem that arises during visual query formulation might generate an intrusive notifi-cation since an immediate response is needed by the user.
Notifications, however, come with a cost: they interrupt a pri-mary task ( i.e., query formulation). This is because notifications divert attention [15, 25]. Intuitively, an interruption is a distrac-tion that causes one to stop a scheduled task to respond to a stim-ulus. Many studies in the cognitive psychology and hci commu-nities have reported that interrupting users engaged in tasks by delivering notifications inopportunely can negatively impact task completion time, lead to more errors, and increase user frustra-tion [3, 5, 9, 12, 15, 16, 21, 22]. In summary, three key findings are reported in these studies. First, interruptions slow and degrade per-formance on the primary task. In particular, interruptions lead to resumption lag , which is the additional time needed to resume the primary task after interruption [22]. Second, the timing of the inter-ruptions can adversely impact performance. It has been observed that notifications occurring at points of higher mental workload are more disruptive in nature compared to those that occur during lower mental workload [3, 9, 15, 16]. The former may lead not only to larger resumption lags but also increase frustration. Third, inter-ruptions with similar content with the main task could be quite dis-ruptive even if they are very short [12].

For instance, suppose a user is notified intrusively ( e.g., invoking a pop-up dialog box, highlighting a condition) of an empty result (due to previously formulated condition) when she is dragging an attribute from one panel and preparing to drop it in to another panel to construct a new condition. This interruption may frustrate her as mental resources allocated for the current task are disrupted. Such inopportune, intrusive feedback adversely a ff ects the usability of the system.

It is worth noting that recent research [28] in the hci community has demonstrated that acceptability of a notification is essentially a tradeo ff between the cost of interrupting the user X  X  activities and the value of receiving the notification message. Specifically, accept-ability of low-urgency and medium-urgency messages ( e.g., query fragment suggestions) improves when presented in a non-intrusive manner. This is because this type of notification is expected to be less disruptive of the primary task ( e.g., visual query formulation) in comparison to its intrusive counterpart. Furthermore, recent re-search has suggested that users typically delay processing of a non-intrusive interruption, when it is sent to them at points of higher mental workload, until they have reached a point of lower mental workload [26]. On the other hand, acceptability of high-urgency messages ( e.g., empty results, syntax error) is expected to be low when presented non-intrusively as immediate user response is ex-pected for such notifications. In other words, a user would typically like to see urgent messages in an immediate and intrusive way ( e.g., modal boxes, highlighting query conditions).
Classical visual query feedback strategies are  X  X nterruption-insensitive X . These strategies have historically focused on speed and scalability, often devoting very little attention to the cognitive aspect of a solution. Hence, we need to make our visual query feed-back mechanism  X  X ognitive-aware X  by devising models and tech-niques to deliver a notification (especially an intrusive one) quickly but at an appropriate moment when the mental workload of the user is minimal. Detecting such an opportune moment should be transparent to the user and must not seek explicit input from her.
In this paper, we rethink the classical interruption-insensitive query feedback paradigm and lay down the vision of interruption-sensitive visual query feedback by taking the first step to mitigate the problem of inopportune interruptions made by intrusive 2 query f eedback notifications. Specifically, we focus on one class of visual query feedback problem to illustrate this novel paradigm, namely empty result ( er ) feedback 3 , where a user is notified when a par-t ially constructed visual query yields an empty result. Note that an empty result is not always undesirable to an end user especially in an exploratory querying environment. However, whenever a visual query fragment returns an empty result, it is particularly important to notify the user about 4 the following: (a) The e r problem re-sulted from the constructed query fragment opportunely so that she can avoid wasting time and e ff ort in continuing constructing new conditions; (b) Identify the constructed query condition(s) that is responsible for an empty result; and (c) Optionally, suggest a query modification to mitigate the er problem.

Hence our proposed paradigm bridges the classical visual query feedback problem with intelligent notification management from the domains of hci and cognitive psychology . We propose a novel psy-chology and hci -inspired model for delivering intrusive notifica-tion of an empty result for visual queries, the theory based on this model, and a framework for detecting empty results e ffi ciently and delivering notifications at opportune times. Although as we shall see later, our proposed paradigm can be realized on visual query interfaces for tree or graph-structured databases, to demonstrate its e ff ectiveness we realize it on top of a visual xml query formulation framework. Specifically, we make the following contributions.
We begin by laying out the generic structure of a visual query interface for tree or graph-structured data. Then, we formally de-fine the empty result feedback problem. Lastly, we discuss related research in this arena.
Most visual query interfaces for tree or graph-structured data are comprised of at least three key panels: (a) a Schema Panel to dis-play the structural summary ( e.g., xml schema or DataGuide [13]) or distinct set of node and edge labels of the underlying tree or graph data, respectively, (b) a Query Panel for iteratively construct-ing the query conditions (value and structural constraints) graphi-cally, and (c) a Results Panel (Panel 4) that displays the query re-sults. Figure 1: A visual interface for formulating xml queries.
E xample 1. Figure 1 depicts a screen dump of a visual interface for querying xml data [31]. Observe that Panels 1, 3, and 4 in this gui correspond to the Schema , Query , and Results Panel, respec-tively. In addition it has an Output Panel (Panel 2) that displays the item(s) to be returned by the query. Note that this panel may not appear in other interfaces for querying xml data as di ff erent inter-faces may visually specify the result nodes di ff erently. A new xml query can be formulated using the interface as follows. 1. Specify the output item(s) by dragging selected item(s) from 2. Move the mouse pointer to Panel 1. 3. Scan and select an item in Panel 1. 4. Drag the item to Panel 3 and drop it. Each such action repre-5. A Dialog Box will automatically appear for users to fill (op-6. Combine two or more conditions in Panel 3 using and/or 7. Repeat Steps 2 X 6 for each new condition. 8. Execute the query by clicking on the Run icon. Panel 4 dis-
Very similar visual query interfaces for graph queries are de-scribed elsewhere [6, 30]. Hence we treat tree and graph query interfaces as the same for the purposes of this paper.
Given a visual query Q (tree or graph query), we denote the re-sult set of Q as R ( Q ). A visual query fragment Q  X  of Q c onsists of a subset of conditions C  X   X  C o f Q . Then the result set satisfying C  X  is d enoted as R ( C  X  ). A visual query fragment Q  X  (query Q ) returns an empty result i ff R ( C  X  ) =  X  ( R ( Q ) =  X  ) . In this paper, we present a framework for (a) detecting if R ( C  X  ) =  X  f or a partially-constructed visual query Q  X  ; (b) identifying the condition(s) in Q  X  responsible f or an empty result, and (c) notifying the user intrusively at an op-portune time so that the  X  X nterruption cost X  is minimized. Observe that traditional er feedback techniques typically focus on (a) and (b) but not (c).
To the best of our knowledge, none of the state-of-the-art visual querying schemes [1,6,7,10,30] are interruption-sensitive. In [17], an empty-result detection method is proposed for sql queries. The key idea is to reuse the evaluation results from prior empty-result queries by leveraging lowest-level query fragments from the query plans that lead to an empty result. In our proposed paradigm, we operate in a visual querying environment where the entire query is available only at the end of query formulation. Hence, the afore-mentioned technique is inapplicable here. Importantly, i serf sup-ports interruption-sensitive notification which is absent from [17].
Research in non-interactive [8] and interactive [20,23] query re-laxation solutions propose solutions to the empty-result problem. However, none of these e ff orts focus on opportune notification de-livery of the relaxation solutions. In fact, the work reported in this paper complements these e ff orts as it automatically determines the opportune time to notify users about relaxation suggestions.
Research in cognitive psychology and hci has investigated intel-ligent notification management [5,9,15,21,24], focusing on visual tasks such as document editing, diagram editing, image manipula-tion, and programming. However, prior to our work, it has not been studied in the context of database query feedback.
The hci community has shown that the negative e ff ects of inter-ruption (recall from Section 1.3) can be mitigated by deferring in-terruptions until more opportune moments in a task sequence [5,15, 16]. The argument being that when a user completes a task, mental resources allocated to perform the task are released, momentarily reducing workload before the cycle of allocation and deallocation occurs again in the next task. One particular approach for deferring interruptions is to schedule them at breakpoints .

Defer-to-breakpoint strategy. A breakpoint represents the mo-ment of transition between two observable, meaningful units of task execution, and reflects a change in perception or action [24]. Re-cent research in the hci community identified three granularities (types) of breakpoints during interactive tasks -Coarse , Medium , and Fine [14]. Coarse exists between the largest units while Fine exists between the smallest. For example, consider the task of edit-ing documents. Fine may be switching paragraphs, Medium may be switching documents, and Coarse may be switching to an activ-ity other than editing ( e.g., checking emails).

Iqbal and Bailey have recently shown that the best moment to interrupt a user is on breakpoints between tasks [15]. That is, to defer the notification to appear at the next breakpoint detected in the user X  X  task-sequence. We shall adopt this defer-to-breakpoint-based strategy for interrupting query formulation tasks.

Our decision to choose the above strategy is bolstered by the fol-lowing interesting results demonstrated by the hci community [5, 15]. First, the interruption cost is reduced and users are less frus-trated when intrusive notifications are scheduled to occur at break-points rather than when delivered immediately. Second, users pre-fer having notifications scheduled at breakpoints and they react faster to notifications that were scheduled at breakpoints. Third, ap-plications that generate notifications that are relevant to the user X  X  ongoing activity should request that they be delivered at Medium or Fine breakpoints. This ensures that notifications are delivered when they have most utility, and are least disruptive. In contrast, notifica-tions of general interest should be delivered at Coarse breakpoints.
Generic Breakpoints in Visual Query Formulation. Recon-sider the generic structure of the gui s for tree or graph query con-struction tasks as described in Section 2.1. The di ff erent types of breakpoints for these tasks are shown in Table 1. Observe that for each of the tasks related to Medium and Fine breakpoints, mental resources allocated to perform the task are released at the end of the task, thus momentarily reducing the workload. For instance, consider the task of selecting an item or node label in the Schema Panel . The mental resource of a user is allocated to scanning it and selecting an item / label. Upon completion the resource is released which reduces the mental workload. The mental resource alloca-tion cycle begins again when the subsequent task of dragging the selected item / label to the Query Panel begins.

E xample 2. Reconsider the steps for formulating xml queries using the gui in Example 1. The Fine breakpoints according to Table 1 are at the end of Steps 2, 3, 4, 5, 6, and 8. In addition, there is another Fine breakpoint at the end of Step 1, which is specific to this interface.

Observe that for a given query there is only one Medium break-point. Hence, in the subsequent sections we shall combine Medium and Fine breakpoints as a single type of breakpoint. Specifically, our objective is to ensure delivery of intrusive notifications at Fine breakpoints .
We now present a quantitative model for estimating the optimal notification time ( ont ) so that the defer-to-breakpoint notification scheme can be e ff ectively realized for the query feedback problem. We first discuss it w.r.t the er problem and then highlight how it can also be used to model other types of query feedback.
Let C  X  be a non-empty set of currently constructed conditions r epresenting a twig pattern or a subgraph pattern and R ( C  X  ) L et C new be a new condition ( i .e., a new edge in a subgraph query fragment, a new XPath condition in an XQuery fragment) drawn by a user (drawn after the construction of C  X  ). For each C p roposed framework takes two key steps. First, it checks whether R ( C  X   X  C new ) =  X  . If so then the query formulated thus far does not produce any results and the next available breakpoint to deliver the empty-result notification is found. Clearly, e ffi cient checking for an empty result is pivotal as breakpoint selection can only pro-ceed after detection. Consequently, ine ffi cient execution of the first step can result in inopportune notification delivery, which may in-crease user frustration. Ideally, we should be able to deliver empty-result notification before the construction of the succeeding condi-tion C next ( e .g., the next edge in a subgraph query fragment) is fin-ished. In this situation, a user does not need to waste her time and e ff ort in constructing additional conditions before realizing that the query produces an empty result. Hence, notifications should be de-livered at fine breakpoints FB1 and FB2 (Table 1). We refer to these breakpoints as optimal breakpoints . Observe that construction of C next is already completed after F B3 .
Given the most recent constructed condition C new and a set of pre-v iously constructed conditions C  X  , the o nt , denoted as T t o the amount of time available for checking if R ( C new that notification can be delivered at optimal breakpoints. We now present an hci -inspired quantitative model to estimate this time.
Given C  X  , adding a new condition C new in a tree or graph query i nvolves tasks related to the breakpoints FB1-FB5 in Table 1. Let us now refer to the times taken to complete tasks that end with fine breakpoints FB1 , FB2 , and FB3 as movement time (denoted by T s election time ( T s ), and d rag time ( T d ), respectively. Then, T b e bounded by the following equation. T hat is, as long as the check for an empty result of ( C  X   X  C b e finished before the breakpoint FB2 of C next , notification can be e asily delivered at an optimal breakpoint. Observe that we did not include T d in the right-hand side of the above equation. When a u ser starts dragging a selected item or label, C next is in the process o f materialization. Hence, the notification related to the conditions ( C  X   X  C new ) will be displayed only when she drops C next Panel (breakpoint FB3 ). This may confuse the user as the notifica-tion related to C new appears only after the creation of C t ionally, she may have wasted her time in constructing C E quation 1 enforces a tighter bound on T ont . Note that the values o f T m and T s vary with end users. For a given g ui , how can we theoretically quantify ( T m + T s )? We now address this question.
Estimating movement time T m . R econsider the task ending with breakpoint FB1 . It involves acquisition of a target from the Schema Panel at a distance D from the mouse cursor which is in the Query Panel . Note that typically the Schema Panel is a rect-angular two-dimensional target. Consequently, the item selection is constrained by both the width and height of the panel and the cursor must travel along a two-dimensional vector to it. Hence, we adopt the model proposed by Accot and Zhai [2] that focuses on ac-quiring targets having rectangular, square, or circular shapes. The movement time T m is quantified as follows.
 where D is the Schema Panel  X  X  distance to the cursor, H and W de-note Schema Panel  X  X  height and width, respectively. The parameter a varies approximately in the range of [-50, 200], b in [100, 170], and  X  in [1 / 7, 1 / 3]. Note that  X  allows the model to weight the e ff ect of the height di ff erently from the e ff ect of the width. Estimating selection time T s . T he above model for computing T can only be applied if the mouse movement is one-directional a nd involves a single target which is rectangular, square, or circu-lar in shape. Consequently, selection of a label or item cannot be modeled using it. Observe that searching for a label involves mov-ing the cursor over multiple targets to select an item. In fact, the Schema Panel is similar to a hierarchical menu and one needs to select an item during query formulation by navigating the cursor through the hierarchy using predominately vertical movements to select the desired label.

Note that we assume the labels or items are organized vertically and hence ignore horizontal movements in this panel as the hori-zontal width is negligible here. Furthermore, we assume that they are organized in a specific order ( e.g., lexicographically ordered). Hence, a user can move to the direction of the target item rapidly using an  X  X pen loop X  movement. Consequently, we adopt the fol-lowing logarithmic model proposed by Ahlstr X m [4] for modeling selection time of an item, which integrates both the time to find the item and the time to move to the target.
 where p is the position number of the target item, and m and n are empirically-determined constants. For xml or graph data, p can be computed as the total number of items below or above the item selected in the preceding condition.

Remark. Observe that Equation 1 demands empty result check should consume less than ( T m + T s ) time. Although, as we shall see i n Section 7, it is possible to realize this for a variety of queries, certain framework may possibly take more than ( T m + T s c ertain scenario. Can our proposed model be easily extended to handle such scenario? We posit that it is indeed the case as addi-tional times ( e.g., T d ) to complete tasks related to breakpoints F B3 , FB4 , etc. can easily be added to the right hand side of Equation 1 and notifications can then be delivered during corresponding break-points. Although such delivery is not at optimal breakpoints, it is still delivered opportunely when the mental workload is low.
Equation 1 can also be used to model other kinds of query feed-back problems (discussed in Section 1.1). We answer to this ques-tion a ffi rmatively for the following reason. Consider the long-running query feedback or the query fragment suggestions problem. Given C  X  and C new already constructed in the g ui , the long-running query feedback problem aims to detect if this query fragment will take a long time to run and notify the user opportunely. Similarly, the query fragment suggestions problem aims to provide top-k sugges-tions based on conditions C  X  and C new constructed by the user. Ob-s erve that these notifications must be delivered to the user before the construction of C next for reasons identical to the e r problem. For instance, it is ine ff ective to provide suggestions when the user has already constructed C next . Hence, similar to the e r problem, no-tifications for these problems must also be delivered at breakpoints FB1 and FB2 . That is, Equation 1 is applicable for these scenar-ios as well. This is also the case for the query syntax feedback problem. Hence, our proposed model is applicable for a variety of interruption-sensitive query feedback problems .
We now present the i serf framework to e ffi ciently detect the empty-result ( er ) phenomenon during query construction and to e ff ectively deliver appropriate notification by realizing our defer-to-breakpoint-based notification scheme. It is comprised of two key modules, which are described below.

Empty results detection module. The goal of this module is to e ffi ciently detect if the partially constructed query fragment re-turns an empty result. If it does, then the interruption-sensitive notification module is invoked to deliver intrusive notification at an opportune time. Specifically, there are two scenarios for empty re-sult. Scenario 1: a newly constructed condition C new does not have a ny match in the underlying database ( i.e., R ( C new ) = 2: the constructed conditions are connected by and connectives and each has a non-empty result match but there does not exist any data instance that satisfies all constructed conditions ( i.e., R ( C  X  ) = a nd  X  C i  X  C  X  , R ( C i ) ,  X  ) . Observe that e ffi cient implementation of this module depends on the type of database (graphs or xml ).
Interruption-sensitive notification module. Algorithm 1 out-lines a generic implementation framework of this module. It takes as input parameters nullCond and allCond (output from the above module representing Scenarios 1 and 2 of empty-result queries, re-spectively) and are set to true if the query returns an empty result. The reason we use two separate parameters to represent the two scenarios is because we intend to deliver two di ff erent notifications with di ff erent content to explain these scenarios. The values of the remaining input parameters a , b , m , n , and  X  (Equations 2 and 3) are empirically determined. The hasCoarseBreakpoint procedure in Line 3 detects Coarse breakpoints (Table 1). Lines 4 -21 are executed if there are no Coarse breakpoints. The getCursorDirec-tion procedure checks if the user is moving the cursor towards the Schema Panel (Panel 1). One approach to determine this move-ment is to use the following heuristic. Consider Figure 2(a). Let the cursor be at point A in the Query Panel and the rectangular box represents the Schema Panel with height H . Let the perpendicular distance from the cursor to the Schema Panel be Z . Then, where tan(  X  1 ) = H 1 Z , tan(  X  2 ) = H 2 Z , and H 1 + H
L et the angle of motion of the mouse be  X  . Then, as long as the direction of motion of the mouse is on the left of A and  X  is within (  X  1 +  X  2 ), the cursor is moving towards the S chema Panel . That is, given the angle of movement  X  , we can determine whether the cursor is moving towards the Schema Panel using (  X  1 +  X 
I f the mouse pointer is moving towards the Schema Panel , the movement time T m is computed using Equation 2 (Line 6) and the n otification delivery is suspended by T m time (Line 7) to allow the c ursor to move to the Schema Panel . Note that T m is not constant f or a given query as the distance D varies with each constructed condition. A keen reader may observe that we estimate T m m ine the waiting time instead of waiting until the cursor reaches the Schema Panel . This is due to two key reasons. First, the theoretical estimate of T m has been proven to have high real-world accuracy [2] a nd as a result it simulates the time to reach the Schema Panel with high degree of accuracy. Second, the mouse movement may be dis-rupted or stalled half way as a user may be distracted with other non-query activities ( e.g., phone call, discussion with a colleague). Consequently, it will prevent the notification to be delivered to the user even when she has stalled query formulation temporarily.
Lines 10 -17 capture the case when the mouse pointer is already in the Schema Panel searching for an item. The selection time T is computed in Line 13. The notification delivery is suspended by T time (Line 14) to allow the item to be selected (for reasons jus ti-fied above). Finally, Lines 22 -26 display appropriate notification message identifying condition(s) C  X  responsible for empty result.
O bserve that the above strategy delivers interruption-sensitive notifications by considering only optimal breakpoints ( FB1 or FB2 ). However, as remarked in Section 4.2, it can be easily augmented to deliver such notifications when empty result checking time exceeds ( T m + T s ) by simply adding the wait times associated with tasks re-l ated to FB3 , FB4 , etc.

Generality of the framework. Observe the two notable features of the i serf framework. First, it is orthogonal to the expressiveness of the gui as well as the underlying query processor. Hence, i serf can easily be built on top of any xml or graph query processor. Fur-thermore, it does not impact query evaluation time as it is only in-voked during query formulation. Second, the interruption-sensitive notification module is not tightly coupled to the er detection mod-ule. Hence, it can be easily incorporated to support other types of interruption-sensitive query feedback problem.
In the preceding section we have presented the generic imple-mentation of i serf on tree or graph-structured data. To demonstrate its e ff ectiveness, we have implemented it on top of XB lend [27,31], Algorithm 1: I nterruption -sensitive notification module a visual xml query processor built on top of a relational framework. XB lend interleaves visual query construction and query processing to prune false results and prefetch partial query results by exploiting the latency o ff ered by the gui -based query formulation. Note that we chose XB lend as it supports materialization of intermediate re-sults synopsis during visual query construction, which we leverage for realizing the i serf framework. However, the techniques we de-velop in the rest of the paper are largely independent of this choice, and we can replace XB lend with another visual querying system that supports such a query processing paradigm.

Next, we introduce the visual xml query model that we use to demonstrate the i serf framework. Then, we briefly elaborate on the XB lend gui for formulating visual queries. We propose a data structure called a condition-results tree ( cr -tree) to support e ffi cient detection of the er phenomenon in XB lend . Lastly, we present the algorithm for realizing i serf .
For ease of presentation, we primarily focus on a special type of visual xml query prevalent in many applications. Specifically, it can be textually represented by an XQuery query Q = ( F , where F is a set of for clause items, W is a set of predicates logically connected by and or or operators in the where clause, and R contains the output expression specified in the return clause. The predicates in W can be categorized into two types, namely join expressions and non-join expressions . A join expression captures value-based join between elements (attributes) of single or multiple data sources. On the other hand, a non-join expression expresses a non-join filtering condition on a single data source. In the sequel, we refer to each expression in the where clause as a condition . We denote a set of conditions as C . Finally, the return clause has a single output expression r representing the output node .
Remark. The above query model can easily be extended to sup-port a wider variety of features such as di ff erent location steps 5 and qualifiers ( e .g., position predicate, not-predicate) as long as the underlying xml database engine can support their evaluation. For instance, if a user visually specifies a condition c involving a path expression containing descendant and preceding axis at a par-ticular formulation step, then this visual action will be translated to a corresponding textual query and forwarded to the underlying query engine for execution. The result set of c is then used by i serf to detect whether the partially-constructed query yields an empty result. Having said this, it is paramount to balance expressiveness and usability in a visual querying environment as a wide variety of xml queries ( e.g., queries with nested for s) are not easy to formu-late even visually as it requires a deep understanding of the lan-guage which many end-users do not possess [7]. Nevertheless, as we shall see later, our strategy to realize the i serf framework on an xml querying system is orthogonal to the expressiveness of its visual querying environment.
A visual xml query interface can be classified into two types, namely, node-based and path-based . In a node-based interface an xml query is constructed by taking a node-at-a-time approach. On the other hand, in a path-based interface, a query is formu-lated by taking a path-at-a-time strategy. The visual interface of XB lend belongs to the latter type. Figure 1 depicts a screen dump of the XB lend visual interface. Specifically, the DataGuide [13] is adopted to construct the structural summary of an xml document in Panel 1. When a user drags a vertex from Panel 1, the path expression corresponding to this vertex is automatically built. To formulate a query, a user takes the steps described in Section 2.1.
A condition-results tree ( cr -tree), denoted as U , describes the set of currently constructed conditions that are connected by and or or connectives and corresponding sets of intermediate results that satisfy these conditions. Specifically, each internal node of U rep-resents an and or or connective. Each leaf node of U contains a set of non-join conditions that are processed together 6 and the v er-tex identifier set M in which the prefetched vertices 7 satisfying the c onditions are stored. Figure 3 depicts examples of cr -trees. Note that we only materialize the vertex identifiers of an xml document  X  in M instead of entire content of xml subtrees because it is more space-e ffi cient. Furthermore, the identifier scheme is not tightly coupled to any specific system as any numbering scheme that can uniquely identify vertices in an xml tree can be deployed. D efinition 1. The condition-results tree ( cr -tree) is a 2-tuple U = ( V u , E u ) , where V u is a set of nodes in U and E e dges. A leaf node v  X  V u is a 2-tuple v = ( C nj , M ) , where C s et of non-join conditions that are processed together and M is the vertex identifier set that stores the prefetched data satisfying C v  X  X  u is an internal node then label ( v i )  X  { AND , OR } . Algorithm 2: i serf on XB lend
Note that for practical cases the number of leaf nodes in a cr -tree is small as users typically do not formulate a large number of conditions using a visual interface. Furthermore, each leaf node is associated with an identifier set and not a set of xml subtrees. Hence, a cr -tree can easily fit in the main memory of a modern commodity desktop machine.

Observe that the cr -tree can be leveraged to e ffi ciently detect the two scenarios of empty results (recall from Section 5). Consider the cr -tree with an and node in Figure 3(a) and the vertex identi-fier sets M 1 , M 2 , and M 4 . Here, M 1 = R ( C 1 ), M 2 M 4 = R ( C 3 , C 5 ). Let C 1 be the most recent condition constructed b y a user. Then, the query represented by this ct -tree returns empty result if any one of the following conditions is satisfied: (a) Sce-nario 1 : M 1 =  X  ; (b) Scenario 2 : M 1 ,  X  , M 2 ,  X  , M M 1  X  M 2  X  M 4 =  X  . On the other hand, when the subtree root is an or node, all vertex identifier sets associated with its leaf nodes have to be empty to qualify as an empty result. These conditions for and and or nodes of a cr -tree can be combined to determine whether a query fragment returns an empty result. Algorithm 2 outlines the implementation of i serf on top of XB lend . Since XB lend uses a path-based visual interface that leverages struc-tural summaries, we assume that the path expression in each for-mulated condition has at least one match in the xml document  X  . R represents the set of vertex identifiers matching the output e x-pression (generated by XB lend ) which is specified in Step 1 during query formulation (Section 2.1).

The variable A represents the query condition formulation ac-tion in the Query Panel . When a user drags a new query condition C new and drop it on an existing condition C t (Line 7), Lines 7 X 14 a re executed in two concurrent threads. In the first thread, the algo-rithm invokes the prefetching technique of XB lend [27, 31] (Line 10) to materialize the vertex identifiers in R o that satisfy C a temporary relation T new . Details of this technique, which is or-t hogonal to this work, can be found in [27]. Next, it adds C t he vertex identifiers in T new into the c r -tree U (Line 12). Then, the algorithm invokes the checkEmpty procedure which detects if Algorithm 3: check E mpty the query fragment returns an empty result. Concurrently, in the second thread Lines 1 X 21 of Algorithm 1 are executed to deter-mine the breakpoint for notifications. If the query result is empty (Line 16), then Lines 22 X 26 of Algorithm 1 are executed to deliver interruption-sensitive notification at an opportune time. checkEmpty procedure. This procedure (Algorithm 3) encapsu-lates the checking of Scenarios 1 and 2. Note that our goal is to check both these scenarios e ffi ciently so that for practical cases T satisfies the bounds in Equation 1. Hence, we take several opti -mization strategies towards this goal. We first check if R empty (before traversing to other nodes) and it is not connected by the or operator with other existing conditions. If it is then Scenario 1 is satisfied. Consequently, nullCond is set to true , C C new , and the algorithm terminates early (all these steps are enca p-sulated in Line 1). Otherwise, an empty result is only possible due to Scenario 2. Hence, it traverses U in a depth-first fashion. If an internal node is an  X  AND  X  node, then the vertex identifier sets as-sociated with its child nodes are intersected to determine if some vertices are shared by all, indicating a non-empty result for the constructed query fragment. Otherwise, the vertex identifiers are combined (union). We use the adaptive set-intersection algorithm in [11] which aims to use a number of comparisons as close as pos-sible to the minimum number of comparisons ideally required to establish the intersection. After traversing U , the set of vertex iden-tifiers idSet that are shared by M new and rest of the identifier sets is r eturned. Lastly, allCond is set to true if Scenario 2 is satisfied (Lines 2-3). Additionally, the conditions C  X  which are responsible f or an empty result are identified and returned as well.
A keen reader may observe the three notable features of the i serf framework on xml . First, the interruption-sensitive empty-result detection and notification scheme is orthogonal to the underlying visual xml query processor. Hence, it can easily be built on top of any xml query processor that supports such incremental query pro-cessing paradigm . Second, the solution is not limited to the visual xml query model in Section 6.1, but can be applied to richer variety of xml queries. To elaborate further, reconsider the steps for visual query formulation in Section 2.1. Now suppose that the visual in-terface enables us to formulate richer variety of queries by enabling specification of various XPath axis, qualifiers, order-by clause, aggregation functions, etc. Then the visual construction of these features in a query condition(s) will often take place during Steps 4 or 5 ( after the selection of an attribute or element). For instance, if a user wishes to specify a descendant axis then she may do it on the dropped condition after Step 4 or in the Dialog Box that ap-pears in Step 5. Once formulated, the time to detect an empty result for such a query condition is still bounded by Equation 1 . Hence, as long as the underlying xml query processor is e ffi cient to evalu-ate these complex conditions, the i serf framework is amenable to richer variety of queries. Third, the i serf framework can easily in-corporate more advanced features related to the er problem such as top-k query modification or relaxation suggestions [20,23] as the latter is orthogonal to the framework. Note that such suggestions also need to be delivered to the user (along with the empty results problem) using intrusive notifications at opportune times. i serf is implemented in Java JDK 1.7. In this section, we investi-gate its performance in the context of visual xml query formulation using XB lend (Section 6). The experiments were conducted on an Intel Core 2 Quad 2.66GHz processor and 3GB ram . The operat-ing system was Windows XP Professional SP3. A Logitech Mouse was used and its acceleration was set to its default settings (accel-eration: 2 / 1). We compare i serf (denoted by isf ) against XB lend (denoted by xb ), which is interruption-insensitive.

Specifically, we investigate the following issues. (a) Can the empty-result check be e ffi ciently realized in a visual querying frame-work like XB lend ? (b) Is the defer-to-breakpoint notification scheme the most e ff ective strategy for notification in i serf ? (c) Can i serf deliver notification at optimal breakpoints (Equation 1) in most practical cases? (d) What is the impact of interruption-sensitive notifications on the query formulation time ?
Data and Query Sets. We use the xml representations of uniprot , pdb , and interpro downloaded from their o ffi cial websites. The features of these datasets are given in Figure 2(b). We chose the representative queries in Figure 4 that join up to three data sources. Although our approach can support conditions which are connected by and / or connectives, here we chose queries with and connectives as they are more likely to generate empty answers. The numbers with labels in curly braces in the where clause represent the de-fault sequence of steps for formulation of conditions. Note that if a join (denoted by J i ) and a non-join condition (denoted by C s ame subscript then it means that the join condition is formulated c ondition J 2 in Q 1 and the non-join condition C 2 share same sub-script. That is, J 2 is specified immediately after the formulation of C 2. Unless mentioned otherwise, we shall be using the default query formulation sequence.

Observe that we did not choose XQuery queries that are too com-plex as it is observed by Augurusa et al. that a visual XQuery inter-face is useful when it serves the needs of the majority of the users in expressing their queries, which are typically simple [1].
Furthermore, observe that the above queries return a non-empty result. Hence, we create modified versions of these original queries
Figure 5: Modifications for creating empty-result queries. to generate 11 empty-result queries. Each original query is modi-fied one condition-at-a-time and is identified by Qi [ C j ] indicating that it is created by modifying condition C j in Qi ( e.g., Q 1[ C 1] means that the condition C 1 of Q 1 is modified to make Q 1 return an empty result). The set of actual modifications to the conditions is given in Figure 5.

Participants Profile. Ten unpaid volunteers with varying de-grees of familiarity with xml participated in the experiments to for-mulate visual queries. At the start, participants were trained to use the gui . For every query the participants were given some time to determine the steps that are needed to formulate it visually. This is to ensure that the e ff ect of thinking time is minimized during query formulation. Note that if a user quickly formulates a query, less time is available for delivering notification at optimal breakpoints. The participants were given one query at a time. If an error was committed by a participant then that particular formulation e ff ort is ignored and he had to start afresh.

Query formulation by participants. The participants were asked to formulate two categories of queries. (a) Empty-result queries: Each participant first formulates the modified queries (Figure 5) without being aware of the fact that these queries return empty re-sult. For example, a participant constructs the modified condition Q [ C 1 ] instead of C 1 while formulating Q 1 . Note that when he / s he formulates a condition that results in empty result ( e.g., Q t he er problem is notified and suggestion to the participant is pro-vided to modify the query by incorporating the original condition ( e.g., the condition C 1 in Figure 4). The participant then modifies t he query and continues constructing remaining conditions in the query until completion. (b) Nonempty-result queries: After for-mulating all the modified queries, each participant formulates the original queries in Figure 4. Each query was formulated five times by each participant.

Values of Parameters a , b , m , n , and  X  . In order to empirically determine the parameter values of Equations 2 and 3, the partici-pants were tasked to formulate three queries ( Q 1, Q 3, Q 4) accord-ing to the above setup. The movement and selection times ( T T ) were recorded for all participants and for all trials. Then, the average movement time T m = 1 071 . 2 ms with  X  = 7 . 17. Hence, we use T m as movement time for the XB l end gui . We set  X  = 0 according to [2]. Then, we compute a and b that best fits this movement time using Equation 2. It turns out that for a =  X  30 and b = 106, T m = 1 061 . 8 ms . Similarly, the average selection time T = 1 802 ms with  X  = 52 . 12. Note that high  X  is expected as some users may be unfamiliar with the structural summaries and might expand and collapse the subtrees several times before selecting a vertex. Using these values and Equation 3, m = 586 and n = 140 give us selection time that is closest to T s ( T s = 1 846 ms ).
E ff ect of Empty Result Check. Before we investigate the im-pact of interruption-sensitive notification during query formulation, we would like to investigate the cost of accommodating a query feedback technique (in our case, empty-result check) in a visual querying framework like XB lend . Specifically, we compare the execution cost of Lines 10-11 ( xb [27]) and Lines 10-13 ( isf ) in Algorithm 2. Note that Line 13 is not executed if the visual query-ing framework does not support the check for an empty-result ( e.g., XB lend ). Also, in this set of experiments Lines 14 and 16 are not executed as we use the original queries in Figure 4. We shall study the impact of the notification service later.

Figure 6 shows the execution times for prefetching ( xb ) and (ad-ditionally) checking an empty result ( isf ). Each column labeled Step i represents the running time associated with corresponding query condition C i in a query. The values in parenthesis represent t he size of the materialized relations (vertex identifier set). Note that here we do not report times taken by xb to retrieve the final query results as it is orthogonal to the problem. It is evident that the cost of accommodating an empty result check is su ffi ciently low as execution time of each step is not significantly increased for all queries. Also, it is robust to large size of intermediate results ( e.g., Step 2 of Q 1 and Q 5) as isf only retrieves vertex identifiers. In other words, the checkEmpty procedure is e ffi ciently realized by isf . Justification for Defer-to-Breakpoint Notification Scheme. Next, we design a user study to justify the defer-to-breakpoint no-tification scheme realized by isf and its impact on users. All par-ticipants were tasked to formulate any four empty-result queries (Figure 5). Measurements were taken on frustration level of the participants at the timing of notification (interruption). The rat-ing was made using a 7-point Likert scale, ranging from 1 being very pleasing to 7 being very frustrating. Three types of notifica-tion schemes were presented to participants to experience, namely,  X  X mmediate notification X  ,  X  X ixed duration notification X  and our proposed  X  X efer-to-breakpoint-based notification X  . Note that the  X  X mmediate notification X  scheme delivers notification as soon as a query is detected to generate an empty result. In the  X  X ixed dura-tion notification X  scheme, the notification is triggered after a fixed 2 seconds delay. Figure 7(a) reports the results. Clearly, participants find our proposed approach most e ff ective. On the other hand, they found the  X  X ixed duration notification X  scheme most annoying.
Optimal Notification Time ( ont ). Given the superiority of defer-to-breakpoint notification strategy, we now investigate whether no-tifications can be delivered at optimal breakpoints (Equation 1). Specifically, we study whether ont satisfies the upper bound in Equation 1 in practice. In our experiments, T m = 1 061 T = 1 846 ms (see Section 7.1). Hence, 0 &lt; T ont &lt;
Figure 7(b) reports the execution times for checking for an empty result for Scenario 1 cases. We plot the execution times (Lines 10-13 in Algorithm 2) of the original condition Ci in the nonempty-result query Qi (denoted by isf ) and the modified condition in the empty-result query Qi [ Ci ]. Observe that the time taken to execute these steps is less when the condition does not have a match in the dataset. This is beneficial as necessity to deliver notification at optimal breakpoints only arises when the query returns empty answer. Note that the execution times include the prefetching times for partial matches in xb .
 Figure 7(c) reports the performance due to Scenario 2 for queries Q 3[ C 1] and Q 5[ C 1]. Note that in both these modified queries each condition has non-empty result matches ( R ( C i ) ,  X  ) but together they return an empty result. For each modified query, we plot the time for checking for an empty result after formulation of each con-dition (denoted by isf -c i ). For Q 5[ C 1], we create two variants; one with the original query formulation sequence C1-C2-C3 (denoted by Q 5[ C 1]  X  D ) and the other following the sequence: C1-C3-C2 (denoted by Q 5[ C 1]  X  M ). Note that the former becomes empty af-ter formulation of the three conditions whereas the latter becomes empty after formulating the second condition C 3. In all cases, the empty-result check can be completed within a second or less.
Importantly, the time taken to prefetch partial results in xb (Line 10) and check for an empty result (Lines 11-13) is significantly less than ( T m + T s ). This is highly desirable as n otifications can be de-livered at optimal breakpoints ( FB1 and FB2 in Table 1) . Note that the movement and selection times may vary with di ff erent users, i.e., users familiar with the gui and structural summary may move their mouse faster than others. Observe that T ont &lt; 0 f or all modified conditions. That is, even if a user moves twice as fast as normal users, the notification will still be delivered at opti-mal breakpoints. Only, when the speed of movement is less than 0 . 4( T m + T s ), the notification has to be suspended until the construc-t ion of the next condition. However, such speed is highly unlikely from typical end users as seen in Section 7.1.

E ff ect on Query Formulation Times. Lastly, we study the im-pact of interruption-sensitive notifications on the query formulation time ( qft ), which is the time taken to formulate each query. Each query is formulated by all participants in its original and modified forms. Specifically, the qft of a modified query includes time to acknowledge the notification and continue formulation of all re-maining conditions (if any). Figure 7(d) plots the average qft of the original query (denoted by xb ) and its modified versions (de-noted by isf -c i for queries generated by modifying Ci ). Obviously, modified queries require higher qft s than the original ones due to resumption lag (recall from Section 1.3). However, the increase is very modest primarily due to the deferred notification scheme and the time users take to acknowledge notifications. Since the notifica-tions are delivered only at breakpoints, the participants react faster to notifications as reported in several hci studies such as [15].
There is increasing interest in enhancing the usability of database systems. This paper improves usability by contributing a novel paradigm of interruption-sensitive visual query feedback. Specifi-cally, we present a framework called i serf for detecting and schedul-ing notifications of empty-result queries at breakpoints in a vi-sual environment. A key feature of our framework is its multi-disciplinary flavor, integrating principles from hci and cognitive psychology with data management. First, we drew upon the litera-ture in cognitive psychology to establish that i serf needs to con-sider the structure of visual query formulation tasks and break-points when reasoning about when to notify the user. Second, we leveraged work in hci to quantitatively model the time available to i serf to detect empty-result queries in order to ensure notifica-tion delivery at optimal breakpoints that lower the interruption cost. Lastly, we showed the usefulness and e ff ectiveness of i serf in e ffi -ciently checking for an empty result and delivering notification at optimal breakpoints in a visual xml querying environment. Acknowledgement: Sourav S Bhowmick is supported by the Singapore-MOE AcRF Tier-1 Grant RG24 / 12. Byron Choi is partially sup-ported by the Hong Kong RGC GRF12201315.
