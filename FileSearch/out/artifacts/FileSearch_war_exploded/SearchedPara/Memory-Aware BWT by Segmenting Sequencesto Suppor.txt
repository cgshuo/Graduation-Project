 Recently long sequence data is growing at an exponential rate, such as web data, record data, genome data, etc. Subsequence matching on these long sequences is ex-tremely common application in commercial business and scientific research. Burrows-Wheeler transform (BWT) is an algorithm a lready been applied in data compression techniques [1]. It can also be used as a full text index for providing fast substring search over text collections. The advantage of BWT index is that the compact structure can save storage space to the same size of the sequence. However, building BWT with long sequences consumes too much memory. In this paper, we solve the problem by seg-menting sequences.
 Challenge. The challenge of searching long sequence is the enormous memory cost while building BWT. BWT needs to be constructed from suffix array (SA). Since the SA keeps all the start positions of the source sequence, every item in SA will take log n bits space, where n is the size of the source sequence. The space cost of storing SA is n log n bits. Compared to SA, BWT saves much more space. It takes about log  X  bits for every character, where  X  is size of the alphabet. Space of n log  X  bits will be enough to keep the whole BWT. The whole space cost of building BWT is n log n + n log  X  bits. We expect to search a longer sequence in limited memory, and the query process should be as fast as possible.
 Contribution. In this paper, we propose a novel variation of BWT called S-BWT. We separate the source sequence into segments, and build BWT respectively on each seg-ment. The set of all the BWTs is the S-BWT, which can get rid of storing the whole suffix array. The method can save the memory cost of constructing BWT greatly to n (log  X  +log n  X  log k ) /k ,where k is the number of segments. We can control the memory cost by adjusting option k . Segmenting the source sequence can also acceler-ate the process of building index.

We also propose two methods for query searching based on the S-BWT index. For long sequence with billion characters, our methods are better than traditional BWT method. We analyze the time complexity of our algorithms. Let the length of a sequence be n , and the number of the query occurrences be occ . The time complexity of the BWT back search algorithm is  X  ( occ + m ) ,where m is the length of the query. Searching on shorter sequence earns a speed-up rate according to principle of locality. The lower bound of time complexity for searching on S-BWT is  X  (( occ + mk ) /r ) ,where k is the number of segments of the sequence, and r is the speed-up rate. Time complexity of our methods are close to the lower bound.

We conduct experiments with our method and BWT backward search method. For long sequence of hundreds and thousands MB, our method is better than BWT back-ward search method. Notice that our method is a generalization of BWT method, when k =1 , our method is the same as BWT backward search method.
 Related Work. The process of computing BWT from SA is simple and fast. However, constructing SA for a long sequence is a challenging job. Much work focused on re-searching about constructing SA [2,3,4,5,6,7]. However, all these methods had to keep the text and suffix array in memory. When the main memory is not enough, some work in [8,9] chose to use external memory. Another work in [10] chose to sample the text to distribute the SA to small blocks. There are also some space efficient algorithms to construct compressed text indices [11,12].

The BWT backward search algorithm can provide fast substring search. It was first proposed in paper [13], and the method was further discussed in latter pa-pers [14,15,16,17]. This method had been used to solve the sequence alignment prob-lem for genome data [18,19]. Work in paper [20] proposed a four-stage algorithm to update the Burrows-Wheeler Transform.

We introduce all associated vocabularies a nd structures and the problem definitions in Section 2 and give an BWT structure on overlap segmented text and query algo-rithm in Section 3. BWT structure on disjoint Segmented text and query algorithm are proposed in Sections 4. There are the experimental results and comparisons of the two methods and the original BWT method in Section 5. Finally, we summarize our con-clusion in Section 6. Let T [0 ..n  X  1] be a text, where n is the length of the text. For every 0  X  i&lt;n , T [ i ] belongs to a finite ordered alphabet  X  of size  X  . To ease the process of subsequence comparison, we add another character $ to the end of the text. Let T [ n ]=$ .The character $ does not belong to the  X  , and it is smaller than any character of  X  .
The subsequence T [ i..j ] is a sequence starting at i position and ending at j position, where 0  X  i, j  X  n .If i&gt;j , T [ i..j ] is an empty sequence. If j equals to n ,wecallita suffix. If i equals to 0 , we call it a prefix.

Burrows-Wheeler transform of a sequence T is denoted by BWT ( T ) .Itisalsoa sequence with n +1 characters. The only difference is the order of characters. The cyclic shifts of T construct a ( n +1)  X  ( n +1) matrix M . Sorting the rows in lexico-graphical produces the BWT ( T ) , which is the last column of M . BWT [ T [ i ]] cyclicly precedes BWT [ i ] in T . For example, BWT of mississippi$ is ipssm$pissii . The detail of BWT transform is available in the original paper.

BWT can revert to T , which is called LF-mapping. Let LF[ i ]=C[ BWT [ i ] ]+ r i , where C[ BWT [ i ] ] is the number of occurrences of characters smaller than BWT [ i ] , and r i equals to the occurrences of character BWT [ i ] in the prefix BWT [0 ..i ] .We can revert T from T [ n  X  1] to T [0] by setting t = 0, and looping j from n -1 to 0, T [ j ]= BWT [ t ] , t =LF[ t ].

The backward search algorithm searches the query backward, one step a character. It refines an interval [ l,h ) .Atstep i , SA [ j ]( l  X  j  X  h ) is the start positions of occurrences of the query X  X  suffix P [ i..p  X  1] .

Actually, BWT is constructed from suffix array, which is an array with start po-T [ SA [ j ] ..n ] if 0  X  i&lt;j  X  n . The formulas transform SA to BWT is depicted in Equation 1.
 Problem Definition. Given a text and a query, subsequence matching problem is to find all occurrences of the subsequence in the text. Definition 1 defines the problem more formally.
 Definition 1 Let T [0 ..n  X  1] be a text, and P [0 ..m  X  1] be a query. Subsequence match-ing problem is to find all the start positions of occurrences of P in T, i.e. { i | 0  X  i  X  n, T [ i..i + m -1] = P [0 ..m -1] } .
 This problem can be solved by BWT back sear ch algorithm. In this paper, we take the memory cost into account. The space cost is an extra restriction. The process should guarantee the efficiency of query and memory cost at the same time. In this section, we propose a BWT structure on overlapped segments of the text T and a query processing algorithm based on the proposed structure. 3.1 Decompose a Text into Overlapped Segments Given a text T , we decompose T into a set of overlapped segments T 1 ,...,T k and construct BWT for each segment T i ( 1  X  i  X  k ). Let BWT ( T i ) be the transformation from segment T i .Weuse S -BWT O ( T ) to denote the BWT transformation for these segments T 1 ,...,T k , denoted S -BWT O ( T )= { BWT ( T 1 ) ,...,BWT ( T k ) } .
Fig. 1 shows the sketch of decomposing a text T into overlapped segments. Let k be the number of segments and l be the overlapping length b etween any two adjacent segments. Let L i be the length of segments T i and r =( n + l  X  k  X  l )% k .Thevalue L i can be computed using Equation 2.
 Ta ke mississippi as an example. Let k =2 and l =4 , the text can be decomposed to mississi and issippi ,where issi is the overlapped substring. Since we work on each segment with L i characters, the memory cost of transforming T to S -BWT O ( T ) is at most ( n + l + k )  X  (log  X  + log( n + l + k )  X  log( k )) /k bits, where  X  is size of the alphabet. 3.2 Query Processing Using B WTs on Overlapped Segments Given a query P with length m , we want to find all occurrences of P in the text T using S -BWT O ( T ) . In this section, we assume that a query length is less than or equal to l . In Section 4 we relax this assumption. Fig. 2 shows the two cases that the query P could appear in the segments.
 Case 1: An answer to the query only appears in an individual segment T i .
Case 2: An answer to the query appears in the overlapped region of two adjacent
Querying on S -BWT O ( T ) , the order of characters in segment T i is different from the order in T i . It causes a problem that it is not easy to find the overlap area between T
If an occurrence of a query is in the overlapped region, it must start at range [0, l -m ]. We call the range a filter interval . All the occurrences starting at positions in a filter interval should be ignored, since it is already found in T i . Fig. 3 shows the filter method. P 1 in Fig. 3(a) starts in filter interval, so it should be filtered. While P 2 in Fig. 3(b) starts out of the filter interval, which is valid and it can not appear in the overlapped region.
The process of answering the query using S -BWT O ( T ) is listed in Algorithm 1. We search the query on each segment with procedure backwardSearch [13] (line 3). As we introduced in Sections 2, each step of the backwardSearch algorithm reports an SA interval [ l,h ) , and each SA value SA [ j ]( l  X  j  X  h ) is the start positions of occur-rences of the query X  X  suffix P [ i..m  X  1] , where m is the length of given query. Therefore, step m of backward search algorithm reports the interval [ l,h ) ,and SA [ j ]( l  X  j  X  h ) is the start positions of occurrences of the query. We then filter the results (line 5). We collect all the filtered results to get the answer (line 6).

The time complexity of Algorithm 1 is  X  ( occ +  X  + mk ) ,where  X  is the query occur-rences in the overlapped region. The method is fast, since searching on shorter sequence earns a speed-up rate according to the principle of locality. However, the method does not apply to the situation when the query is l onger than overlapping length. In order to solve this problem, we have to rebuild S -BWT O ( T ) using a longer overlapping length. Obviously, it is not desirable. In Section 4, we propose another segment structure to solve this problem. In this section, we propose another BWT structure on disjoint segments of the text T and two query processing algorithms based on this proposed structure. 4.1 Decompose a Text into Disjoint Segments Given a text T , we decompose T into a set of disjoint segments T 1 ,...,T k . We build a BWT for each segment. We utilize S -BWT D ( T ) to denote the BWT transformation for these segments T 1 ,...,T k , denoted S -BWT D ( T )= { BWT ( T 1 ) ,...,BWT ( T k ) } .
S -BWT D ( T ) is similar to S -BWT O ( T ) except that the segments do not have over-lap. We try to decompose T into segments of same length L ,where L = n/k .We handle the remainder the same as S -BWT O ( T ) . The memory cost is n (log  X  +log n  X  log k ) /k bits. Take mississippi for example. Let segmented number be 2. The text is decomposed into missis and sippi . 4.2 Query Processing Using BWTs on Disjoint Segments Given a query P with length m , we want to find all the occurrences of P in the text T using S -BWT D ( T ) .

Case 1: An answer to the query only appears in an individual segment. The process can find it. This case is the same as case 1 depicted in Fig. 2.

Case 2: An answer to the query is crossing two adjacent neighbor segments. If we search answers in each BWT ( T i ) in S -BWT D ( T ) separately, it will lose answers. In this section, we focus on this case and propose two algorithms to guarantee to find all the answers.

In order to find the query with backward searching, we need to find the suffix of the query as the prefix of a segment. The rest prefix of the query needs to be verified on the left segment. As we discussed in Sections 2, each step of BWT backward search algorithm reports an interval [ l,h ) ,and SA [ j ]( l  X  j  X  h ) is the start positions of occur-rences of the query X  X  suffix P [ i..m  X  1] . The naive method is to check all the positions at every step. If a position is the start of the segment, we find the suffix of the query as the prefix of the segment. However, this will take  X  ( nm ) time. Notice that if the interval covers the position of $ , which means that the next left characters include $ . Notice that $ is the only character cycle before the first character, since BWT is the last column of matrix with sorted cyclic shifts of the text as introduced in Section 2. Therefore, we find the suffix of the query as the prefix of the segment. Theorem 1 explains the checking method more formally. Time complexity of this checking is  X  ( m ) .
 Theorem 1 (BWT suffix checking). Consider matching the query P [0 ..m  X  1] on segment T i using BWT ( T i ) .Let endPos be the position of $ in BWT ( T i ). Step j of backward search BWT ( T i +1 ) with P reports an interval [ l,h ) .Ifthe l  X  endPos &lt; h , the suffix P [ m  X  j..m  X  1] is the prefix T i [0 ..j  X  1] .
 We collect all the positions which need to be ve rified in a check array. The verification of the rest prefixes of the query is on the left segment.

The process of querying on S -BWT D ( T ) is depicted in Algorithm 2. We initialize the checkArray to be  X  . We get the end position (line 3). We verify each position in checkArray of its right segment (lines 4  X  15). When a query spans more than two segments, the prefix will be verified iteratively on its left segment (line 8). If the suffix of the query is the prefix of the segment, the position will be collected in checkArray (line 16). For the convenience of the verification, we loop the S -BWT D ( T ) from the right to left.

Algorithm 2 can search query on S -BWT D ( T ) , and the query process is fast. How-ever, the method wastes larger index space, since it needs the source sequence. Time complexity of the verification of a query is  X  ( m ) . Time complexity of Algorithm 2 is  X  ( occ +(  X  + k ) m ) ,where  X  is the number of query crossing to neighbor segments.
Instead of verifying on the source sequence using Algorithm 2, we revert the parts of the source sequence to verify the query on the fly, denoted by backWalk .The process of query on S -BWT D ( T ) is depicted in Algorithm 2. The verification process in Algorithm 3 does not need the source sequence. We revert parts of sequence to do the verification (lines 4  X  15).

Procedure backWalk needs to compute r i , as depicted in Section 2. The naive method to capture the number is to count the characters one by one, but this method consumes too much time.Our backWalk method uses a bucket structure. This is trading space for time. The back walk method is depicted in Procedure backWalk .

Compared to Algorithm 2, this back walk will take a little more time. However, the space is saved to about 1 / 2 of the size. It is trading time for space. Actually, the speed of back walk is acceptable. Time complex ity of Algorithm 2 and Algorithm 3 are the same. Our algorithms were implemented as two pairs of programs: S-BWT on overlapped seg-ments (OSBWT) and S-BWT on disjoint segments (DSBWT). Every pair of programs contained a program buildIndex to build according index from a text file and an-other program querySearch to search a query from the index. We also implemented the BWT backward search algorithm for comparison.

Our programs were written in C++ and compiled by g++ with O3 option. The g++ version is 4.4.5. All the tests were running on PC with 2.93 GHz Intel Core CPU, 4 GB main memory, and Ubuntu operating system (Linux distribution).

In order to evaluate the memory cost and efficiency of our proposed methods, we have conducted extensive experiments on real datasets. We tested on two data sets: (1) English, which is the concatenation of English text files selected from etext02 to (2) DNA sequence, which contains 24 different chromosomes in human reference We randomly selected 100 subsequences from our data set as queries, and we took the average query time as the result. For English data, the length of each query was 10 . The average occurrences of each query were 1855 . For genome data, the length of each query was 20 , and the average occurrences of each query were 2749 .

Fig. 4 compares performance of building different indices with varied segmented number.Thedatasizeis 500 MB. Fig. 4(a) shows the ratio of our indices X  memory cost to BWT X  X  for English data. Fig. 4(b) shows the case for genome data. We var-ied segmented number k from 2 to 4096 . Our algorithms X  memory cost is close to 1 /k of BWT X  X , and is stable for different datasets. The memory cost of our two in-dices is almost the same, becau se the only difference of two indices is the overlapping length. With the increase of k , memory cost of OSBWT and DSBWT decreased lin-early. Fig. 4(c) and Fig. 4(d) show the build time of different algorithms. With the increasing of b , time cost of building both OSBWT and DSBWT decreased stably for English data and genome data.

Table 1 compares the performance of differ ent algorithms with varied data size. The length of overlapped region of OSBWT was still 2000 . We compare the memory cost of building OSBWT and DSBWT with BWT. We change data size from 200 MB to 1000 MB. We let k = 256 , which is the best value we got from Fig. 5. With the increase of the data size, the memory cost of OSBWT and DSBWT is stably close to 1 /k of original BWT X  X , 1 / 256 in this setting. When data size is 600 MB, BWT consumed 3000 MB, while OSBWT and DSBWT only consumed about 12 MB, which is only about 0.4% of the BWT X  X  size. The memory cost of building OSBWT and DSBWT is equal. When data size lager than 600 MB, BWT fail to build for the huge memory cost.

Fig. 5 compares the query time for OSBWT and DSBWT. We can find that the query time of both algorithms decreased with the variation of k from 2 to 256 . The reason is that the algorithms earned a speed-up with the decreasing of memory cost. With the further increasing of k , the query time of both algorithms increased according to our analysis of time complexity in Sections 3 and 4.

Table 2 shows the query time of BWT, OSBWT and DSBWT using different data size. The efficiency of our three algorithms is better than BWT backward search al-gorithm. When the data size was small, all the algorithms performed without much difference. However, when the data size w as large, our algorithms performed better than BWT. For larger data size, OSBWT is the f astest one according to analysis of time complexity in Section 3 and 4.

Fig. 6 shows the query time for OSBWT with varied overlapping length. With in-creasing of overlapping length, the query time increased. OSBWT with larger seg-mented number increased faster.
 In this paper, we propose a novel variation of BWT, called S-BWT. Compared to the original BWT, S-BWT saves much more memory. Based on the S-BWT, we propose two methods for searching query on S-BWT.

Searching on shorter sequence earns a speed -up rate according to principle of local-ity. The time complexity lower bound of S-BWT is  X  (( occ + mk ) /r ) ,where k is the segmented number, and r is the speed-up rate. Time complexity of our methods is close to the bound. Time complexity of the algorithm on S -BWT O ( T ) is  X  ( occ +  X  + mk ) , where  X  is query occurrences in the overlapped region. Time complexity of the algo-rithm on S -BWT D ( T ) is  X  ( occ +(  X  + k ) m ) ,where  X  is the number of query crossing to neighbor segments.

We conduct experiments with our method and original BWT method. Compared to original BWT method, our method can build index with less memory and less time. Our query algorithms are faster than the origin al BWT backward search algorithm on large text of hundreds and thousands MB.

Our method can be used for searching subsequence in large text collections, which are common in the field of information retrieval in web data, record data and genome data, etc. We will combine our S-BWT with compressi on techniques to increasingly reduce the space cost of the index. Our method has good scalability. It can be easily expanded to work under parallel computing environment, which will further improve the performance.
