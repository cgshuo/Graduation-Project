 Mining maximal frequen t itemsets is one of the most fun-damen tal problems in data mining. In this pap er we study the complexit y-theoretic asp ects of maximal frequen t item-set mining, from the persp ectiv e of coun ting the num ber of solutions. We presen t the rst formal pro of that the problem of coun ting the num ber of distinct maximal frequen t item-sets in a database of transactions, given an arbitrary sup-port threshold, is #P-complete , thereb y pro viding strong theoretical evidence that the problem of mining maximal frequen t itemsets is NP-hard. This result is of particular in-terest since the asso ciated decision problem of chec king the existence of a maximal frequen t itemset is in P.

We also extend our complexit y analysis to other similar data mining problems dealing with complex data structures, suc h as sequences, trees, and graphs, whic h have attracted intensiv e researc h interests in recen t years. Normally , in these problems a partial order among frequen t patterns can be de ned in suc h a way as to preserv e the downward closure prop erty, with maximal frequen t patterns being those with-out any successor with resp ect to this partial order. We in-vestigate sev eral varian ts of these mining problems in whic h the patterns of interest are subsequences, subtrees, or sub-graphs, and sho w that the asso ciated problems of coun t-ing the num ber of maximal frequen t patterns are all either #P-complete or #P-hard .
 F.2.2 [ Analysis of Algorithms and Problem Complex-ity ]: Nonn umerical Algorithms and Problems Theory data mining, maximal frequen t itemset, maximal frequen t pattern, #P-complete , #P-hard Cop yright 2004 ACM 1 X 58113 X 888 X 1/04/0008 ... $ 5.00.
Since the introduction of the Apriori algorithm about a decade ago [2], the eld of data mining has ourished into a researc h area of signi can t technological and social imp or-tance, with applications ranging from business intelligence to securit y to bioinformatics. However, in spite of the mul-titude of data mining algorithms dev elop ed, not much ef-fort has been made on the theoretical fron tend to study the inheren t complexit y nature of data mining problems them-selv es. A thorough investigation of these fundamen tal prob-lems is greatly needed since it will not only pro vide invalu-able insigh ts into man y data mining problems but will also shed new ligh ts on the characteristics of di eren t data min-ing algorithms and benc hmark datasets.

In this pap er we seek to pro vide a theoretical accoun t of the computational dicult y of a genre of data mining problems that deal with maximal frequen t patterns. These problems can be view ed as instances of the theory extr action problem [10] | they are mainly concerned with enumer at-ing all frequen t patterns (describ ed using some language) whic h satisfy some prop erty and are presen t in a sucien tly large num ber of transactions (records) in a database. Exam-ples of this sort include frequen t itemsets, asso ciation rules, induced subgraphs, etc. Normally , a partial order, , can be de ned among all frequen t patterns in suc h a way as to preserv e the downwar d closur e prop erty, i.e. , given any pat-terns p 1 and p 2 , if p 1 p 2 and p 2 is frequen t, so is p maximal frequen t patterns are those frequen t patterns that do not have any successor with resp ect to this partial order. Mining maximal frequen t patterns has become an imp ortan t problem because the set of maximal frequen t patterns not only uniquely de nes a theory given an interestingness cri-terion, but the num ber of maximal frequen t patterns can be signi can tly smaller than the num ber of frequen t patterns as well [10].

We study the complexit y of data mining problems from the persp ectiv e of counting the num ber of solutions. It is natural to assume that any algorithm whic h can enumerate (compute) all (maximal) frequen t patterns should be able to coun t them as ecien tly as well. This coun ting asp ect rev eals the inheren t complexit y nature of data mining prob-lems rather deeply | the exp ected output is merely a num-ber instead of a presen tation of all solutions; and even an exp onen tial num ber only requires a polynomial num ber of bits of storage space in binary notation. Therefore, given an enumeration problem, its asso ciated coun ting problem may have \lower" time and/or space complexit y.

We use the notion of #P-completeness as a theoretical analysis tool to study the complexit y of coun ting problems. The class #P was rst introduced in [22] to include all coun ting problems for whic h any single solution can be com-puted by a nondeterministic Turing mac hine in polynomial time [8]. The notion of #P-completeness is therefore used to capture the \hardest" problems in #P (see Section 3.2 for details). These #P-complete problems pro vide natural candidates for the type of problems that may still remain intr actable even if P=NP [8], since under this computation mo del, an \ecien t" algorithm for solving a #P-complete problem would beha ve as if it could, by magic, guess the ex-act num ber of correct solutions and sim ultaneously validate all of them in polynomial time. 1
Our theoretical investigation begins with the problem of mining maximal frequen t itemsets | one of the most fun-damen tal problems studied in data mining [28, 10, 15, 5, 1, 7, 9]. We presen t the rst formal pro of (see Section 4) that the problem of coun ting the num ber of maximal fre-quen t itemsets in a database of transaction, given an arbi-trary supp ort threshold, is #P-complete , thereb y pro viding strong theoretical evidence that the problem of mining max-imal frequen t itemsets is NP-hard , i.e. , intractable in the worst case. Since the existence of a maximal frequen t item-set can be chec ked in polynomial time, this result iden ti es the problem of coun ting the num ber of maximal frequen t itemsets as one of the few kno wn coun ting problems whose asso ciated decision problems are \easy", i.e. , belong to P.
Note that num ber of maximal frequen t itemsets can be exp onen tially smaller than the num ber of frequen t item-sets [28, 10]. In con trast to mining frequen t itemsets, sev eral algorithms have been sho wn to be able to gain computa-tional eciency substan tially for mining maximal frequen t itemsets [28, 10, 15, 5, 1, 7, 9]. Giv en that the problem of coun ting the num ber of frequen t itemsets has also been sho wn to be #P-complete [10], our new complexit y result implies a rather unexp ected analogy: the problem of mining maximal frequen t itemsets is of as great worst-case com-putational complexit y as the problem of mining frequen t itemsets.

Having established the #P-completeness of the coun ting problem for maximal frequen t itemsets, we also extend our complexit y analysis to other similar problems that deal with complex data structures, suc h as sequences [3, 25], trees [26, 4, 24], and graphs [12, 13], whic h have attracted intensiv e researc h interests in recen t years. We investigate sev eral varian ts of these mining problems in whic h the patterns of interest are subsequences, subtrees, or subgraphs, and sho w that their asso ciated problems of coun ting the num ber of maximal frequen t patterns are all either #P-complete or #P-hard (our complexit y results are summarized in Table 2).
The rest of this pap er is organized as follo ws. Section 2 in-troduces the basic concepts and notions to be used through-out this pap er. In Section 3 we introduce the theory of #P-completeness . Section 4 presen ts our formal pro of that the problem of coun ting the num ber of maximal frequen t itemsets is #P-complete . The complexit y results concerning other maximal frequen t patterns, including subsequences, subtrees, and subgraphs, are presen ted Section 5. Finally ,
All the complexit y results presen ted in this pap er should be interpreted as worst-c ase time complexit y. we discuss related work in Section 6 and conclude this pap er in Section 7.
In this section we introduce the imp ortan t concepts and notations that will be used throughout the pap er. First we describ e how to represen t databases using bipartite graphs and binary matrices (see [27] for a more detailed surv ey). Then we formalize sev eral notions of itemsets with di eren t supp ort characteristics. Table 1 summarizes the notations that will be used in this pap er and their meaning. Table 1: Summary of Notations and Their Meaning
A database comprises a set of transactions. Eac h transac-tion has a unique transaction iden ti er ( tid ) and con tains a set of items. For simplicit y we will normally omit the tid of a transaction and just list the set of items that it con tains. A set of items is often called an itemset . Let I be an itemset and t a transaction. We will use the notation, I t , to denote that I is a subset of the set of items that t con tains. When the con text is clear, we will often directly refer to a transaction as the set of items that it con tains.
Giv en a set S , we will use the notation, j S j , to denote the cardinality of S , i.e. , the num ber of elemen ts in S . Let I be an itemset and D a database of transactions. We will use the notation, D ( I ), to represen t the set of transactions of D that are a sup erset of I , i.e. , D ( I ) def = f t j I t; t 2 D g .
A bipartite graph , G , can be represen ted as a triple, G = ( U; V; E ), where U and V are disjoint sets of vertices and E is the set of edges between vertices in U and V suc h that E U V .

A bipartite graph G = ( U; V; E ) is called a bipartite clique if there is an edge between every pair of vertices in U and V , i.e. , E = U V . Usually we will omit the set of edges when we represen t a bipartite clique. Giv en a bipartite clique, G = ( U; V ), where j U j = m and j V j = n , we will call it a bipartite ( m; n )-clique, or a bipartite ( m; )-clique (if the cardinalit y of V is of no imp ortance), or a bipartite ( ; n )-clique (if the cardinalit y of U is of no imp ortance).

We will say that a bipartite graph, G 0 = ( U 0 ; V 0 ; E pears in another bipartite graph, G = ( U; V; E ), if U U; V 0 V; E 0 E . Of particular interest are those bipar-tite cliques that app ear in a given bipartite graph. We will say that a bipartite clique, G 0 = ( U 0 ; V 0 ), is a maximal bi-partite clique in a given bipartite graph G , if G 0 app ears in G and there exists no other bipartite clique, G 00 = ( U 00 in G suc h that U 0 U 00 and V 0 V 00 .
One can easily establish a one-to-one corresp ondence be-tween bipartite graphs and databases of transactions. Giv en a database D , its corresp onding bipartite graph, denoted G
D = ( U; V; E ), can be constructed as follo ws: U comprises all database transactions in D ; V comprises all items ap-pearing in D ; for all u 2 U , v 2 V , ( u; v ) 2 E i v 2 u , i.e. , transaction u con tains item v . Giv en a a bipartite graph G , we will use D G to denote its corresp onding database of transactions.

A binary matrix is a matrix in whic h eac h entry has value either 0 or 1. A one-to-one corresp ondence between binary matrices and databases of transactions can also be estab-lished rather straigh tforw ardly . Giv en a database D , we num ber its transactions as t 1 ; t 2 ; ; t m (corresp onding to rows 1 to m of a matrix) and all the items as x 1 ; x 2 ; ; x (corresp onding to columns 1 to n of a matrix). Then D cor-resp onds to an m n matrix, denoted A D , in whic h its entry a ij has value 1 i transaction t i con tains item x j ; otherwise, its value is 0. Giv en a binary matrix A , we will use D denote its corresp onding database of transactions. Example 1 Consider a database D that consists of the follo wing transactions, t 1 ; t 2 ; t 3 ; t 4 ; t 5 , where t t = f x 1 ; x 2 ; x 3 g , t 3 = f x 1 ; x 2 ; x 3 ; x 4 g , t f x 3 ; x 4 g . Here x 1 ; x 2 ; x 3 ; x 4 denote di eren t items in D . The corresp onding bipartite graph, G D , and binary matrix, A are illustrated in Figures 1 and 2, resp ectiv ely. 2 Figure 1: Bipartite Graph Represen tation of the Database in Example 1 Figure 2: Binary Matrix Represen tation of the Database in Example 1
In the sequel, we will use either binary matrices or bipar-tite graphs to represen t databases of transactions.
Classical Data mining problems are usually concerned with itemsets that frequen tly occur in a database of transactions. The num ber of occurrences of an itemset in a database is commonly referred to as the supp ort of this itemset, formal-ized as follo ws. 2
The supp ort of an itemset can be also de ned as the per-centage of transactions that are a sup erset of it. For con ve-nience here we use an integer value to de ne the supp ort of an itemset, since it can alw ays be computed by multiplying the percen tage num ber by the total num ber of transactions. De nition 1 (Supp ort) Let I be an itemset and D a database of transactions. The supp ort of I in D , denoted f ( I ), is the num ber of transactions of D in whic h I occurs as a subset, i.e. , f D ( I ) def = jD ( I ) j .
 Lemma 1 Let D be a database of transactions, I and J two itemsets. If I J , then D ( I ) D ( J ) and f D ( I ) f D
Note that even if two database transactions con tain the same set of items they are still di eren t from eac h other, since eac h transaction has its own unique tid. Therefore, they will eac h con tribute one coun t towards the supp ort of an itemset that they con tain.
 De nition 2 ( -Occurren t Itemset) For 1, we will say that an itemset I is -occurr ent in a database D , if the supp ort of I in D is , i.e. , f D ( I ) = .
 De nition 3 ( -Frequen t Itemsets) For 1 jD j , an itemset I is called -frequent in a database D , if f D , i.e. , the supp ort of I in D is at least .
 Lemma 2 Let D be a database of transactions, I and J two itemsets. If I J and both I and J are -occurren t itemsets, then D ( I ) = D ( J ).

In the sequel, when we discuss prop erties of itemsets with resp ect to a database D , for simplicit y we will usually omit the database D , esp ecially when D is xed or its existence is clear from the con text.

Having de ned the notion of -frequen t itemsets, now we can formally state the problem of mining frequen t itemsets as follo ws: Given a datab ase of transactions D and an arbi-trary inte ger value such that 1 jD j , enumer ate all -frequent itemsets in D .

We should point out the di erence between -occurren t and -frequen t itemsets. If an itemset is -occurren t, then its supp ort must be exactly . The supp ort of a -frequen t itemset, however, can be any value greater than or equal to . Clearly , if an itemset is -frequen t, then it must be -occurren t for some .
 Example 2 Consider again the database D in Example 1. Its corresp onding bipartite graph and binary matrix rep-resen tations are illustrated in Figures 1 and 2, resp ectiv ely. One can easily validate the follo wing: f x 2 ; x 3 g is a 2-o ccurren t itemset ( D ( f x 2 ; x 3 g ) = f t 2 ; t 3 g ); f x 1 ; x and 2-frequen t itemset ( D ( f x 1 ; x 2 g ) = f t 1 ; t
If we consider subset inclusion as de ning a partial order for itemsets, then we can introduce the notions of maximal -occurren t and maximal -frequen t itemsets, as follo ws. De nition 4 (Maximal -Occurren t Itemsets) Let I be a -occurren t itemset in a database D . We say that I is a maximal -occurren t itemset in D , if there exists no itemset J suc h that J I and J is -occurren t in D . 3
A maximal -occurren t itemset is essen tially a frequen t closed itemset with supp ort [23], if is not less than the supp ort threshold. This explicit notation will be handy for our complexit y analysis. De nition 5 (Maximal -Frequen t Itemsets) Let I be a -frequen t itemset in a database D . We say that I is a maximal -frequen t itemset in D , if there exists no itemset J suc h that J I and J is -frequen t in D .

Now that we have introduced maximal -frequen t item-sets, we can formally state the problem of mining maximal frequen t itemsets as follo ws: Given a datab ase of transac-tions D and an arbitr ary inte ger value such that 1 jD j , enumer ate all maximal -frequent itemsets in D .
One can easily see that if an itemset I is -frequen t, then any (nonempt y) subset J I is also -frequen t. On the other hand, if J I is not -frequen t, then I cannot be -frequen t either. Note that once all the maximal -frequen t itemsets have been computed, then all the -frequen t item-sets can be directly enumerated from them without having to read from the database any more. Conceptually the in-formation about -frequen t itemsets can be \summarized" using maximal -frequen t itemsets | the num ber of max-imal -frequen t itemsets can be signi can tly smaller than the num ber of -frequen t itemsets.

Note that if I is a -occurren t itemset, it does not nec-essarily mean that any subset J I is also -occurren t. It must be true, however, that J is -occurren t for some .
The notion of maximal occurren t itemsets plays an im-portan t role in our complexit y analysis of mining maximal frequen t itemsets. In the follo wing Section 4 we will dev elop lemmas to establish sev eral connections between maximal occurren t and maximal frequen t itemsets. The follo wing ex-ample illustrates the idea of maximal -occurren t and max-imal -frequen t itemsets.
 Example 3 Con tinue with the previous database example in Example 1. One can easily validate the follo wing: f x is a 2-o ccurren t itemset but not maximal, since f x 1 ; x is also a 2-o ccurren t itemset; f x 1 ; x 2 ; x 3 g is a maximal 2-frequen t itemset; f x 1 ; x 2 g is a maximal 3-o ccurren t item-set but not a maximal 2-frequen t itemset; f x 3 ; x 4 g is a max-imal 3-o ccurren t and maximal 2-frequen t itemset. 2
Let D be a database and G D its corresp onding bipartite graph. In Section 2.2 we sho w that there is a one-to-one corresp ondence between bipartite graphs and databases of transactions. In fact, there is also a one-to-one corresp on-dence between maximal occurren t itemsets in D and max-imal bipartite cliques in G D . Their relationship is formally stated in the follo wing lemma.
 Lemma 3 Let D be a database of transactions and G D the bipartite graph corresp onding to D . Then every maximal -occurren t itemset in D corresp onds to a unique maximal bipartite ( ; )-clique in G D .
 Example 4 Consider the bipartite graph sho wn in Figure 1 whic h corresp onds to the database in Example 1. Note that f x 1 ; x 2 g is a maximal 3-o ccurren t itemset and corresp onds to the unique bipartite (3 ; 2)-clique, ( f t 1 ; t 2 ; t in Figure 1. 2
Most data mining problems esp ouse two di eren t but in fact closely related persp ectiv es: enumeration of all solutions and coun ting the num ber of solutions. In this section we will rst discuss the coun ting asp ect of the problem of mining maximal frequen t itemsets and then introduce the notion of #P-completeness as a complexit y analysis tool for the class #P of coun ting problems.
The problem of mining maximal frequen t itemsets, as for-mally de ned in Section 2.3, is to enumer ate all maximal frequen t itemsets whose supp ort is no less than a preset threshold. A natural question that one may ask is: What is the (worst-c ase) computational complexity of enumer ating all maximal frequent itemsets?
Since all the maximal frequen t itemsets must be enumer-ated, clearly the computational cost must be prop ortional to at least the numb er of all maximal frequen t itemsets. So it is natural to ask the follo wing question: Is the numb er of maximal frequent itemsets always polynomial in the size of the datab ase? 4
Unfortunately the answ er to the question above turns out to be \No". In the follo wing example we will sho w a database of transactions with an exp onen tial num ber of maximal frequen t itemsets at a certain supp ort threshold. Example 5 Let X = f x 1 ; x 2 ; ; x 2 n 1 ; x 2 n g denote a set of 2 n items. We will construct a database D with 2 n trans-actions, t 1 ; t 2 ; ; t 2 n 1 ; t 2 n , as follo ws: t i all 1 i 2 n , i.e. , transaction t i comprises all the items in X except item x i . Now we can claim that the num ber of maximal n -frequen t itemsets in D is exactly 2 n n . To see why, rst we can sho w that for any itemset I X , f ( I ) (the supp ort of I in D ) is exactly 2 n k . Therefore any itemset I must be maximal n -frequen t i j I j = n , since for any itemset J , if J I then it must be true that f D ( J ) &lt; n . Clearly , there are exactly 2 n n num ber of di eren t itemsets of size n . So the num ber of maximal n -frequen t itemsets is n . The size of D is O ( n Hence the num ber of maximal n -frequen t itemsets in D is exp onen tial in the size of D . 2
Example 5 above pro vides a strong indication that no al-gorithm can ecien tly enumer ate all maximal frequen t item-sets in the worst case, given an arbitrary supp ort threshold. The reason is just downrigh t straigh tforw ard | the num-ber of maximal frequen t itemsets may be exp onen tial in the worst case | one would just need to spend at least an ex-ponen tial amoun t of time to \prin t" them out, let alone the additional cost to \compute" them! However, the argumen t above is still not con vincing enough. First, it does not constitute a formal pro of that the prob-lem of mining (en umerating) all maximal frequen t itemsets is \hard". Second, one may, alb eit arguably , claim that only \prin ting" but not \computing" of all the maximal frequen t itemsets tak es an exp onen tial amoun t of time | an algo-rithm smart enough migh t be able to \compute" and \com-press" all maximal frequen t itemsets using some ecien t data structure in polynomial time. Indeed, suc h discrepancy between \prin ting" and \computing" is not uncommon. For
Here we will use the size of its corresp onding binary ma-trix (num ber of entries) to refer to the size of a database. Although in practice this is not the most ecien t way of storing data, suc h generalization does not a ect our com-plexit y analysis. instance, it tak es quadr atic time to prin t out all the suxes of a string; but an ecien t data structure, the so-called suf-x tree, can be constructed in line ar time whic h enco des all the suxes of a given string [20].

Note that if an algorithm can enumerate all maximal fre-quen t itemsets then it should be able to count them also. This coun ting asp ect of data mining problems is imp ortan t because in con trast to enumeration, the asso ciated coun ting problem migh t have \lower" complexit y. In fact, an exp o-nen tial num ber requires only a polynomial num ber of bits to store. For instance, the num ber 2 n n needs just O ( n log bits to enco de in binary notation. Moreo ver, arithmetic op-erations, suc h as addition, subtraction, multiplication, divi-sion, etc., only tak e a polynomial (in the sizes of the two operands) num ber of steps to nish. Therefore, if an al-gorithm is claimed to be able to \compute" all maximal frequen t itemsets in polynomial time, then it is natural to assume that it should be able to coun t them as ecien tly as well; otherwise, suc h a claim is not justi ed.

In ligh t of this intrinsic connection between computing and coun ting, from now on we will focus on the coun ting asp ect of data mining problems. First we revise our original problem de nition accordingly as follo ws: Given a datab ase of transactions D and an arbitr ary inte ger value such that 1 jD j , count the numb er of all maximal -frequent itemsets in D . In the rest of this pap er, we will dev elop the-orems to sho w that the \easier" coun ting problem above is in fact computationally dicult, thereb y presen ting a formal pro of that its asso ciated problem of enumerating (comput-ing) all solutions is hard.
The theory of NP-completeness is mainly concerned with decision problems asking about the existenc e of a solution. On the con trary , whereas enumeration problems require ex-plicit output of all solutions, coun ting problems need to cal-culate the numb er of solutions only . 5 Clearly , if a decision problem is NP-complete , then its asso ciated enumeration or coun ting problem must be NP-hard , because being able to enumerate all solutions or kno wing the num ber of solutions is enough to answ er the question of whether there is one.
The class #P of coun ting problems was rst introduced by Valian t to give a complexit y-theoretic characterization of the computational dicult y of coun ting [22]. Here we follo w the same de nitions as in [22].
 De nition 6 (Coun ting Turing Mac hines) A counting Turing machine is a standard nondeterministic Turing ma-chine with an auxiliary output device that (magically) prin ts in binary notation on a special tap e the num ber of accept-ing computations induced by the input. It has (worst-case) time complexit y f ( n ) if the longest accepting computation induced by the set of all inputs of size n tak es f ( n ) steps (when the Turing mac hine is regarded as a standard nonde-terministic mac hine without the auxiliary device). De nition 7 (#P) A coun ting problem belongs to #P if this problem can be solv ed by a counting Turing machine of polynomial time complexit y.
Note that the coun ting problems we describ e here are termed as enumeration problems in [8]. But we follo w the terminology in [16].

A problem is said to be #P-har d if all problems in #P reduc e to it. Note that the notion of reduction used here is polynomial time Turing reduction (or simply Turing reduc-tion; see [8] and [22] for more details). More speci cally , a Turing reduction from one problem to another problem 0 is an algorithm that solv es using a hypothetical oracle for solving 0 suc h that, if this oracle solv es 0 in polynomial time, then the overall algorithm would be a polynomial-time algorithm for .

Just as the concept of NP-completeness is introduced for the \hardest" problems in NP , #P-completeness is used to capture the notion of the \hardest" problems in #P . For-mally , we have the follo wing de nition.
 De nition 8 (#P-Completeness) A coun ting problem is called #P-c omplete if all problems in #P Turing reduce to it and it belongs to #P .

It is easy to see that #P is the set of coun ting prob-lems naturally asso ciated with the decision problems in NP . Therefore, for NP-complete problems, their asso ciated coun t-ing problems are #P-complete 6 | the hardness of coun t-ing the num ber of solutions for suc h problems originates from the computational dicult y of searc hing for just one! For instance, the problem of coun ting the num ber of satis-fying truth assignmen ts for an arbitrary 3CNF form ula is #P-complete [8].

However, there are very hard coun ting problems whose as-sociated decision problems can actually be solv ed in polyno-mial time. The rst suc h problem was pro ved by Valian t [22] | the problem of coun ting the num ber of perfect matc hings in a bipartite graph is #P-complete . In the follo wing Sec-tion 4 we will sho w that the problem of coun ting the num ber of maximal frequen t itemsets falls into this same category . Clearly , if a coun ting problem is #P-complete or #P-hard, then its asso ciated problem of enumerating (mining) all so-lutions must be NP-hard [8, 16].
In this section we will presen t a formal pro of that the problem of coun ting the num ber of maximal frequen t item-sets is #P-complete . First we introduce the new notations to be used here.

Let D be a database of transactions. We will use the no-tation F ( D ) to denote the set of all -frequen t itemsets, M ( D ) to denote the set of all maximal -frequen t item-sets, and C ( D ) to denote the set of all maximal -occurren t itemsets.

Since our focus is on the num ber of maximal frequen t itemsets, it is imp ortan t to see how this num ber changes with resp ect to di eren t supp ort thresholds. We will begin with the num ber of frequen t itemsets.
 Lemma 4 If &gt; , then F ( D ) F ( D ).

From the lemma above, we can immediately infer that if &gt; , then jF ( D ) j jF ( D ) j , i.e. the num ber of frequen t itemsets decreases with increase in supp ort thresholds. How-ever, this nice antimonotonicity prop erty of frequen t item-
Strictly speaking, this claim is still a conjecture. But the asso ciated coun ting problems of man y kno wn NP-complete problems have been formally pro ved to be #P-complete . sets does not hold for maximal frequen t itemsets in general, as illustrated by the example below.
 Example 6 Consider the database D that is sho wn in Fig-ure 1. We have the follo wing maximal frequen t itemsets at di eren t supp ort thresholds.
 So jM 1 ( D ) j = 1 ; jM 2 ( D ) j = 2 ; jM 3 ( D ) j = 2 ; jM Clearly , the aforemen tioned antimonotonicit y prop erty does not hold here. 2
From the example above, we can see that maximal fre-quen t itemsets beha ve rather \randomly" and this adds much dicult y to our searc h of a complexit y-theoretic characteri-zation for them. Next we need to establish lemmas to rev eal the connections between maximal frequen t and maximal oc-curren t itemsets. Our nal formal pro of builds on these lemmas.
 Lemma 5 Let I and J be two di eren t maximal -occurren t itemsets in a database D . Then neither I nor J is a subset of the other, i.e. , I 6 J and J 6 I .
 Prop osition 6 Let I be a maximal -occurren t itemset and J a maximal -occurren t itemset in a database D . If I J , then &gt; .
 Lemma 7 If I is a maximal -frequen t itemset in a database D and f D ( I ) = , then I is a maximal -occurren t itemset. Prop osition 8 If I is a maximal -occurren t itemset in a database D , then I is a maximal -frequen t itemset in D . Prop osition 9 Let D be a database of transactions. Then M ( D ) C ( D ) and jM ( D ) j jC ( D ) j . Furthermore,
Note that Prop osition 9 above gives an upp er bound on the num ber of maximal frequen t itemsets. However, the claim in Prop osition 9 does not alw ays hold with equalit y, as illustrated by the example below.
 Example 7 Consider the database D in Figure 1. We have the follo wing di eren t categories of itemsets.
 Clearly , jM 1 ( D ) j = 1 but P jD j i =1 jC i ( D ) j = 5; jM but jC 2 ( D ) j = 1 and P jD j i =2 jC i ( D ) j = 4. 2
We will now presen t our pro of that the problem of coun t-ing the num ber of maximal frequen t itemsets is #P-complete . We will reduce the problem of coun ting the num ber of max-imal bipartite cliques in a bipartite graph, whic h has been sho wn to be #P-complete , to the problem of coun ting the num ber of maximal frequen t itemsets in a database of trans-actions.
 Theorem 10 ([18]) The problem of coun ting the num ber of maximal bipartite cliques in a given bipartite graph is #P-complete . 7 Corollary 11 Let D be a database of transactions. It is a #P-complete problem to coun t the num ber P jD j =1 jC ( D ) j .
Let D be a database of transactions. First we transform D to a new database W D as follo ws. Let T = f t 1 ; t 2 ; ; t be the set of transactions of D , where m = jD j , and X = f x 1 ; x 2 ; ; x n g the set of all items app earing in D . We will introduce a set, Y = f y 1 ; y 2 ; ; y m g , of m new items into W D . The new database W D is the union of two databases,
D = f r 1 ; r 2 ; ; r m g , and W S D = f s 1 ; s 2 ; ; s transactions of W R D and W S D are constructed as follo ws: (i) r i = t i [ Y for all 1 i m , i.e. , the transactions of
D are obtained by extending eac h transaction in T with the entire set Y of new items; (ii) s i = X [ ( Y f y i g ) for all 1 i m , i.e. , eac h transaction s i of W S D con tains all the items in X and Y except item y i . This transformation is illustrated schematically in Figure 3. Note that we can establish a one-to-one corresp ondence between transactions in R and T . Clearly , if the size of D is O ( d ), then the size of W D is O ( d 2 ).
 Example 8 The database sho wn in Figure 4 is transformed from the database sho wn in Figure 2. 2 Lemma 12 Let D be a database of transactions, W D =
D [ W S D the new database transformed from D , X the set of items app earing in D , Y the set of new items introduced into W D . Then for all I; J X and Y k ; Y z Y : Y k = Y i W S D ( I [ Y k ) = W S D ( J [ Y z ).
This result is not explicitly stated in [18], but follo ws read-ily from the results and reductions in [18]. Note that al-though a similar claim is also made in [14], the pro of pre-sen ted in [14] is not correct.
This is in fact the num ber of all closed itemsets in D [23]. Figure 4: The New Database Transformed from the One in Figure 2 Prop osition 13 Let D be a database of transactions, jD j = m , W D = W R D [ W S D the new database transformed from D , X the set of items app earing in D , and Y the set of new items introduced into W D . If I X is a maximal ( + k )-occurren t itemset in D , where 1 m , 0 k m , then I [ Y k is a maximal ( + m )-occurren t and maximal ( + m )-frequen t itemset in W D , where Y k is an arbitrary itemset suc h that Y k Y and j Y k j = k . Prop osition 14 Let D be a database of transactions, jD j = m , W D = W R D [ W S D the new database transformed from D , X the set of items app earing in D , Y the set of new items introduced into W D , U = I [ Y k , where I X , Y k Y , j Y k j = k . If U is a maximal ( + m )-frequen t itemset in W
D , where 1 m , then 0 k m and I is a maximal ( + k )-occurren t itemset in D . Moreo ver, U is a maximal ( + m )-occurren t itemset in W D .
 Prop osition 15 Let D be a database of transactions, jD j = m , W D the new database transformed from D , and 1 m . Then U is a maximal ( + m )-frequen t itemset in W D i U is a maximal ( + m )-occurren t itemset in W D . Prop osition 16 Let D be a database of transactions, jD j = m , W D the new database transformed from D . Then for all 1 m : Theorem 17 Let D be a database of transactions, j D j = m . The problem of coun ting the num ber of all maximal -frequen t itemsets in D , where 1 m , is #P-complete . Pro of. Chec king whether an itemset is maximal fre-quen t or not can be done in polynomial time. Therefore, the problem of coun ting the num ber of maximal frequen t itemsets is in #P . We kno w that the problem of coun ting the num ber P m =1 jC ( D ) j is #P-complete , by Corollary 11. We will sho w how this coun ting problem can be Turing re-duced to the problem of coun ting the num ber of maximal frequen t itemsets, thereb y pro ving that the latter problem is #P-hard.

First, we transform the database D into its corresp onding new database W D . We will assume binary matrix represen-tation for databases. Therefore, if the size of D is O ( d ), then the size of W D is O ( d 2 ), and the running time of the transformation algorithm is also O ( d 2 ).

Let C = jC ( D ) j , M = jM + m ( W D ) j , for 1 m . Then by Prop osition 16, we can construct the follo wing linear equations, represen ted in matrix notation: Clearly , the linear equations above have a unique solution for ( C 1 ; C 2 ; ; C m ), given the values of ( M 1 ; M 2
For all 0 k m 1, m k m m and so m k can be stored using O ( m log 2 m ) bits in binary notation and computed in time polynomial in m . Let the size of D be O ( d ). Then m = O ( d ) and so all m k can be stored using O ( d log 2 in binary notation and computed in time polynomial in d . For all 1 m , C = jC ( D ) j = O (2 d ). So all C can be stored using O ( d ) bits in binary notation. Moreo ver, the size of W D is O ( d 2 ) and so M = jM + m ( W D ) j = O (2 d 2 1 m . It follo ws that all M can be represen ted using O ( d 2 ) bits in binary notation. Therefore, given the values of ( M 1 ; M 2 ; ; M m ), the linear equations above can be solv ed and hence the values of ( C 1 ; C 2 ; ; C m ) can be calculated in time polynomial in d , the size of D . Note that the size of W D is O ( d 2 ). So if there is a polynomial-time algorithm for coun ting the num ber of maximal frequen t itemsets, then the values of ( M 1 ; M 2 ; ; M m ) can be computed in time polynomial in d . Hence the values of ( C 1 ; C 2 ; ; C m the num ber P m =1 jC ( D ) j = P m =1 C can be computed in time polynomial in d . 2
A large num ber of data mining problems dealing with fre-quen t patterns can be view ed as instances of the theory ex-traction problem [10]. In general, every transaction in a database D is considered as a (large) pattern. A partial order, , can be de ned on all patterns suc h that the sup-port of a pattern p can be formalized as follo ws: f D ( p ) jf t j p t; t 2 D gj . 9 A pattern whose supp ort exceeds a user-speci ed threshold is called a frequen t pattern. Note that this partial order, , preserv es the downwar d closur e prop-erty, i.e. , given any patterns p 1 and p 2 , if p 1 p 2 and p is frequen t, so is p 1 . We will write p 1 p 2 if p 1 p p 6 = p 2 . Hence a frequen t pattern p is maximal if there is no frequen t pattern q suc h that p q .

Man y problems of mining maximal frequen t patterns fall into this line of generalization above. For example, in the problem of mining maximal frequen t itemsets, the patterns are sets of items and the partial order is de ned on sub-set inclusion. In this section, we will extend our complex-ity analysis to sev eral problems of mining maximal frequen t
This kind of supp ort is called unweighte d supp ort, in whic h every database transaction con tributes at most one coun t to the supp orted of a pattern. However, our complexit y results can be easily extended to data mining problems that use weighte d supp ort [24], whic h tak es into accoun t multiple occurrences of a pattern in a database transaction. patterns studied recen tly in the literature, in whic h the pat-terns of interest are subsequences, subtrees, or subgraphs. In the follo wing, we will just de ne the data structures used in these problems and specify the partial orders on patterns. Supp ort and maximalit y of patterns will be de ned in the same way as in Section 2.3. Our goal is to sho w the complex-ity of the asso ciated coun ting problems for these maximal frequen t patterns.
In problems of mining frequen t sequences [3, 25], eac h database transaction is considered as a sequence (string) in-stead of a set, in whic h the order of sym bols app earing in this sequence is imp ortan t. Normally the patterns of in-terest are subse quenc es . The partial order, , on any two sequences, s 1 and s 2 , is de ned as follo ws: s 1 s 2 i s is a subsequence of s 2 , i.e. , s 1 can be obtained from s remo ving zero or more sym bols from s 2 . For example, ac is a subsequence of abc . Our complexit y result about min-ing maximal frequen t subsequences is stated in Theorem 18 below.
 Theorem 18 Let D be a database of sequences, j D j = m . The problem of coun ting the num ber of maximal -frequen t subsequences in D , where 1 m , is #P-complete .
In recen t years mining frequen t patterns from trees [26, 4, 24] and graphs [12, 13] has attracted a lot of researc h interests. Normally , the patterns of interest are subtrees or subgraphs. Note that trees are just a special form of connected, acyclic graphs. A graph, G = ( V; E ), consists of a set of vertices, V , and a set of edges, E V V . Subgraph isomorphism can be view ed as de ning a partial order among graphs. Giv en two graphs, G 1 = ( V 1 ; E 1 ) and G 2 = ( V 2 ; E 2 ), G 1 is called a subgraph of G 2 , denoted G G , if there is an inje ctive function : V 1 7! V 2 suc h that for any ( a; b ) 2 E 1 , ( ( a ) ; ( b )) 2 E 2 . Moreo ver, G called an induc ed subgraph of G 2 if satis es the follo wing additional condition: for all ( ( a ) ; ( b )) 2 E 2 , ( a; b ) 2 E The complexit y results to be presen ted here apply to either subgraphs or induced subgraphs. But for simplicit y we will only men tion subgraphs.

The de nition of subgraph isomorphism can be readily used to de ne subtree isomorphism on tree data structures, even though de nitions of trees usually need to tak e into ac-coun t sev eral factors: rooted or unro oted (called free trees); ordered or unordered (the order of sibling nodes is not im-portan t); lab eled (edge-lab eled or node-lab eled or both) or unlab eled. Next we presen t the complexit y results on la-beled trees and graphs, follo wed by unlab eled trees and graphs.
 Theorem 19 Let D be a database of (rooted) unordered lab eled trees, j D j = m . The problem of coun ting the num ber of maximal -frequen t subtrees in D , where 1 m , is #P-complete .
 Theorem 20 Let D be a database of (rooted) ordered la-beled trees, j D j = m . The problem of coun ting the num ber of maximal -frequen t subtrees in D , where 1 m , is #P-complete .

We should point out that our complexit y results can be readily extended to pro ve the #P-hardness of coun ting max-imal frequen t embedded subtrees [26] in a database of la-beled trees. Moreo ver, we can also immediately deriv e the follo wing corollary for lab eled graphs. Note that Corol-lary 21 below applies to lab eled graphs that are either di-rected or undirected, ordered or unordered.
 Corollary 21 Let D be a database of lab eled graphs, j D j = m . It is #P-hard to coun t the num ber of maximal -frequen t subgraphs in D , where 1 m .

We will now extend our complexit y results to unlab eled trees and graphs. First we will state the result for unlab eled trees. Extending this result to unlab eled graphs is rather straigh tforw ard. To pro ve the #P-completeness of the prob-lem of coun ting the num ber of maximal frequen t unlab eled subtrees, we will reduce to it the problem of coun ting the num ber of maximal frequen t itemsets. Here the pro of is rather tric ky and omitted for want of space.
 Theorem 22 Let D be a database of (rooted) unlab eled trees, j D j = m . The problem of coun ting the num ber of maximal -frequen t subtrees in D , where 1 m , is #P-complete .

It is worth pointing out that the claims in Theorems 19, 20, and 22 still remain valid even if binary trees are supplied as input. From Theorem 22 we can immediately deriv e the follo wing claim about unlab eled graphs.
 Corollary 23 Let D be a database of unlab eled graphs, j D j = m . The problem of coun ting the num ber of maximal -frequen t subgraphs in D , where 1 m , is #P-hard.
Valian t introduced the class #P of coun ting problems and pro ved that coun ting the num ber of distinct perfect matc hings in a bipartite graph is #P-complete [22] | the rst coun ting problem kno wn to be #P-complete whose asso ciated decision problem can be solv ed in polynomial time. In [18], man y coun ting problems on bipartite graphs, suc h as vertex cover, indep enden t set, were pro ved to be #P-complete . The #P-completeness of coun ting the num-ber of maximal bipartite cliques in a bipartite graph follo ws readily from the results in [18], although it was not explic-itly stated there. A similar claim was also made in [14], but its pro of was not correct. However, in [14] it was sho wn that it is NP-complete to decide whether there is a maximal bipartite ( k; )-clique in a bipartite graph. More recen tly, Hun t et al. pro ved the #P-hardness of man y graph coun t-ing problems when restricted to planar instances [11]. Some of these results were later extended by Vadhan to even more restricted bipartite graphs of bounded degree [21].
Man y algorithms have been prop osed in the literature for mining maximal frequen t itemsets, suc h as MaxClique [28], Dualize and Adv ance [10], Pincer-Searc h [15], Max-Miner [5], DepthPro ject [1], MAFIA [7], and GenMax [9]. These al-gorithms exploited di eren t heuristics for optimization and were sho wn to have di eren t good scaleup characteristics on certain benc hmark datasets. However, theoretical analy-sis was not the main focus of these works and none of them pro ved that the problem of coun ting the num ber of maximal frequen t itemsets is #P-complete .

There is a large body of work in the literature on min-ing frequen t and maximal frequen t patterns from complex data structures, suc h as sequences [3, 25], trees [26, 4, 24], and graphs [12, 13]. Our complexit y results (summarized in Table 2) can be easily extended to problems studied in these works. Speci cally , in [26] the patterns of interest are embedded subtrees. Our pro of of Theorem 19 implies that it is #P-hard to coun t the num ber of maximal fre-quen t embedded subtrees in a database of lab eled trees. The #P-completeness of coun ting the num ber of frequen t closed itemsets [23] also readily follo ws our complexit y results here.
The problem of coun ting the num ber of frequen t item-sets was rst sho wn to be #P-complete in [10]. In [10] it was sho wn that it is NP-complete to decide if there is a maximal -frequen t itemset with at least k items. The NP-hardness of mining maximal frequen t itemsets was also recen tly established in [6] by pro ving the follo wing claim: given a set of maximal frequen t itemsets, it is NP-complete to decide whether this set can be gro wn with a new maxi-mal frequen t itemset. These results do not lend themselv es to the #P-completeness of coun ting the num ber of maximal frequen t itemsets. In con trast, our result asserts a much stronger claim about the hardness of mining maximal fre-quen t itemsets | it is #P-complete to decide the exact num-ber of all maximal frequen t itemsets | there is no clear clue that this problem would belong to NP!
Finally , the work of [27] aimed at pro viding a lattice-theoretic framew ork for mining frequen t itemsets and asso-ciation rules. Interesting work was also recen tly rep orted in [19] on characterization of length distributions of fre-quen t and maximal frequen t itemset collections, with a fo-cus on computing tigh t bounds for feasible distribution. We should point out that neither of these two works subsumes any of the complexit y results pro ved in this pap er. More-over, our results on the complexit y of coun ting maximal fre-quen t itemsets pro vide theoretical underpinnings for the al-gorithms prop osed in [19] for computing distribution.
In this pap er we study the complexit y of mining maxi-mal frequen t patterns, from the persp ectiv e of coun ting the num ber of solutions. We presen t the rst formal pro of that the problem of coun ting the num ber of maximal frequen t itemsets is #P-complete , thereb y pro viding a complexit y-theoretic explanation for the (worst-case) computational dif-cult y of this problem. We also extend our complexit y anal-ysis to other data mining problems dealing with complex data structures, in whic h the patterns of interest are max-imal frequen t subsequences, subtrees, or subgraphs. The complexit y results pro ved in this pap er are summarized in Table 2. To the best of our kno wledge, our work is the rst comprehensiv e study of the complexit y of mining maximal frequen t patterns.

We should point out that there are four di eren t but closely related computational asp ects of data mining prob-lems: 1. Enumeration Problem (Column 2 of Table 2). Explicit 2. Coun ting Problem (Column 3 of Table 2). The goal is 3. Searc h Problem (Column 4 of Table 2). Output of only 4. Decision Problem (Column 5 of Table 2). The primary Take as an example the problem of mining maximal frequen t itemsets. Its asso ciated searc h problem is to output one maximal frequen t itemset, if there is any, while the decision problem is to answ er the question of whether a maximal frequen t itemset exists.

These four di eren t asp ects of data mining problems in fact exhibit di eren t levels of computational complexit y (see Table 2). For all the problems we study in this pap er, their asso ciated decision problems (whether a maximal frequen t pattern exists) can all be solv ed in polynomial time (ev en for lab eled graphs). Their searc h problems can also be solv ed in polynomial time except the searc h for a maximal frequen t subgraph. This is due to the computational dicult y of testing for subgraph isomorphism, whic h is NP-complete [8]. Nev ertheless, one can easily design a deterministic polyno-mial time algorithm to compute a maximal frequen t sub-graph, given an oracle for solving subgraph isomorphism: start with a graph with one node and gro w it until the sub-graph isomorphism test fails. This implies that the complex-ity of searc hing for a maximal frequen t subgraph is FP NP For the same reason, it is unlik ely that the coun ting prob-lem for maximal frequen t subgraphs would belong to #P; but we have pro ved that it is #P-hard. Finally , we should point out that the NP-hardness of enumeration problems can be readily deriv ed from the #P-hardness of their asso-ciated coun ting problems [8]. Also note that the problem of mining maximal frequen t substrings can be ecien tly solv ed in polynomial time, utilizing the data structure of general-ized sux trees [20] | this is not really surprising since substrings do not manifest a com binatorial nature.
The complexit y results presen ted in this pap er should be interpreted as worst-c ase time complexit y only | the impli-cation being there is little hop e a data mining algorithm can execute eciently on any dataset (if the problem is #P-hard or NP-hard ). In recen t years man y data mining algorithms have been dev elop ed for imp ortan t applications. Most of them have been sho wn to be ecien t or even exhibit linear scaleup prop erty with resp ectiv e to various test datasets, ei-ther syn thetic or from real applications. A di eren t analysis tool will be needed to pro vide a complexit y-theoretic expla-nation for the eciency of these algorithms and datasets. Recen tly interesting work was rep orted in [19] on charac-terization of length distributions of frequen t and maximal frequen t itemset collections. We believ e researc h along this line will pro vide us with good guidance on understanding the algorithms themselv es as well as the datasets tested.
Another imp ortan t problem is concerned with data min-ing algorithms that can \adapt" ecien tly | if the size of the output is polynomial, then the algorithm runs in polyno-mial time | the so-called output polynomial algorithms [17]. Recen tly, in [10], a mildly sub exp onen tial algorithm was de-velop ed for mining maximal frequen t itemsets. But cur-ren tly it is still an open problem whether an output polyno-mial algorithm exists for mining maximal frequen t itemsets. Our complexit y results do not address this problem and we believ e that di eren t complexit y analysis techniques will be needed. The author would like to thank Leslie G. Valian t, Alan Selman, Mitsunori Ogihara, Heikki Mannila, Mohammed Javeed Zaki, Jian Pei, Yongqiao Xiao, and the anon ymous referees for their helpful commen ts. [1] R. C. Agarw al, C. C. Aggarw al, and V. V. V. Prasad. [2] R. Agra wal and R. Srik ant. Fast algorithms for mining [3] R. Agra wal and R. Srik ant. Mining sequen tial [4] T. Asai, K. Ab e, S. Kawaso e, H. Arim ura, [5] R. J. Bayardo Jr. Ecien tly mining long patterns [6] E. Boros, V. Gurvic h, L. Khac hiy an, and K. Makino. [7] D. Burdic k, M. Calimlim, and J. Gehrk e. MAFIA: A [8] M. R. Garey and D. S. Johnson. Computers and [9] K. Gouda and M. J. Zaki. Ecien tly mining maximal [10] D. Gunopulos, R. Khardon, H. Mannila, S. Saluja, [11] H. B. Hun t III, M. V. Marathe, V. Radhakrishnan, [12] A. Inokuc hi, T. Washio, and H. Moto da. An [13] M. Kuramo chi and G. Karypis. Frequen t subgraph [14] S. O. Kuznetso v. Interpretation on graphs and [15] D.-I. Lin and Z. M. Kedem. Pincer-Searc h: An [16] C. H. Papadimitriou. Computational Complexity . [17] C. H. Papadimitriou. NP-completeness: A [18] J. S. Pro van and M. O. Ball. The complexit y of [19] G. Ramesh, W. Maniatt y, and M. J. Zaki. Feasible [20] E. Ukk onen. On-line construction of sux trees. [21] S. P. Vadhan. The complexit y of coun ting in sparse, [22] L. G. Valian t. The complexit y of computing the [23] J. Wang, J. Han, and J. Pei. CLOSET+: Searc hing [24] Y. Xiao, J.-F. Yao, Z. Li, and M. H. Dunham.
 [25] M. J. Zaki. SPADE: An ecien t algorithm for mining [26] M. J. Zaki. Ecien tly mining frequen t trees in a [27] M. J. Zaki and M. Ogihara. Theoretical foundations of [28] M. J. Zaki, S. Parthasarath y, M. Ogihara, and W. Li.
