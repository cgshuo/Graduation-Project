 Vijil Chenthamarakshan 1 , Ramakrishna Varadarajan 2 , Prasad M. Deshpande 1 , Information in web pages is laid out in a way that aids human perception using specification languages that can be understood by a web browser, such as HTML, CSS, and Javascript. The visual layout of elements in a page contain valuable clues that can be used for extracting information from the page. Indeed, there have been several efforts to use layout information for specific tasks such as web page segmentation [1] and table extraction [2]. There are two ways to use layout information: 1. Source Based Approach: Map the layout rule to equivalent rules based 2. Layout Based Approach: Use the layout information (coordinates) of var-Both these approaches achieve the same end result, but the implementations are different as illustrated in the example below.
 Example 1. Figure 1 shows the system requirements page for an IBM software product. The IE task is to extract the set of operating systems supported by the product (listed in a column in the table indicated by Q3). In the source based approach, the rules need to identify the table, its rows and columns, the row or column containing the word  X  X perating Systems X , and finally a list of entities, all based on the tags that can be used to implement them. In the layout based approach, the rule can be stated as:  X  From each System Requirements page, extract a list of operating system names that appear strictly 1 to the south of the word  X  X perating Systems X  and are vertically aligned  X . The higher level layout based rule is simpler, and is more robust to future changes in these web pages.
Source based rules have several serious limitations, as listed below:  X  An abstract visual pattern can be implemented in many different ways by  X  Proximity of two entities in the HTML source code does not necessarily  X  Specification languages are becoming more complex and difficult to analyze.  X  Rules based on HTML tags and DOM trees are often sensitive to even minor Layout based approaches overcome these limitations since they are at a higher level and independent of the page source code. Previous efforts at using lay-out based approaches were targeted at specific tasks such as page segmentation, wrapper extraction, table extraction, etc and are implemented using custom code. Existing rule based information extraction frameworks do not provide a mechanism to express rules based on the visual layout of a page. Our goal is to address this gap by augmenting a rule based information extraction frame-work to be able to express layout based rules. Rule based system can be either declarative [5,6] or procedural [7]. It has been shown that expressing information extraction (IE) tasks using an algebra, rather than procedural rules or custom code, enables systematic optimization s making the extraction process very ef-ficient [5,6]. Hence, we focus on an algebraic information extraction framework described in [5] and extend its algebra with a visual operator algebra that can ex-press rules based on spatial layout cues. One of the challenges is that not all rules can be expressed using layout cues alon e. For some rules, it may be necessary to use traditional text X  X ased matching such as regular expressions and dictionaries, and combine them with spatial layout based rules. The framework thus needs to support rules that use both traditional textual matching and high X  X evel spatial layout cues. In summary, our contributions are as follows:  X  We have developed an algebraic framework for rule X  X ased information ex- X  We implement the system using a relational database and demonstrate how  X  We demonstrate the simplicity of the visual rules compared to source based Information Extraction(IE): IE is a mature area of research that has re-ceived widespread attention in the NLP, AI, web and database communities [8]. Both rule based and machine learning based approaches have been proposed and widely used in real life settings. In this paper, we extend the operator algebra of System T [5] to support rules based on spatial layout.
 Frameworks for Information Extraction: The NLP community has devel-oped several software architectures for sharing annotators, such as GATE [9] and UIMA [10]. The motivation is to provide a reusable framework where annotators developed by different providers can b e integrated and executed in a workflow. Visual Information Extraction: There is a lot of work on using visual in-formation for specific tasks. We list some representative work below. The VIPS algorithm described in [1] segments a DOM tree based on visual cues retrieved from browser X  X  rendering. The VIPS algorithm complements our work as it can act as a good preprocessing tool performing task-independent page structure analysis before the actual visual extract ion takes place -thereby improving ex-traction accuracy. A top-down approach to segment a web page and detect its content structure by dividing and merging blocks is given in [11]. [12] use visual information to build up a  X  X -tree X , a concept similar to the DOM tree enhanced with screen coordinates. [2] describe a completely domain-independent method for IE from web tables, using visual information from Mozilla browser. All these approaches are implemented as monolithic programs that are meant for specific tasks. On the other hand, we are not targeting a specific task; rather our frame-work can be used for different tasks by allowing declarative specification of both textual and visual extraction rules.

Another body of work that is somewhat related is automatic and semi-automatic wrapper induction for information extraction [13].

These methods learn the a template expression for extracting information based on some training sets. The wrapper based methods work well on pages that have been generated using a template, but do not work well on human authored pages. 3.1 Overview of Algebraic Information Extraction We start with a system proposed by Reiss et al [5] and extend it to support visual extraction rules. First, we give a quick summary of their algebra. For complete details, we request the reader t o refer to the original paper.
 Data Model. A document is considered to be a sequence of characters ignoring its layout and other visual information. The fundamental concept in the algebra is that of a span, an ordered pair begin, end that denotes a region or text within a document identified by its  X  X egin X  and  X  X nd X  positions. Each annotator finds regions of the document that satisfy a set of rules, and marks each region with an object called a span.

The algebra operates over a simple rel ational data model with three data types: span, tuple, and relation. A tuple is an finite sequence of w spans s 1 , ..., s w ;where w is the width of the tuple. A relation is a multiset of tu-ples, with the constraint that every tuple in the relation must be of the same width. Each operator takes zero or more relations as input and produces a single output relation.
 Operator Algebra. The set of operators in the algebra can be categorized broadly into relational operators, span extraction operators, and span aggrega-tion operators as shown in Table 1. Relational operators include the standard operators such as select, project, join, union, etc. The span extraction operators identify segments of text that match some pattern and produce spans corre-sponding to these matches. The two common span extraction operators are the regular expression matcher re and the dictionary matcher d .Theregularex-pression matcher takes a regular expression r , matches it to the input text and outputs spans corresponding to these matches. The dictionary matcher takes a dictionary dict , consisting of a set of words/phrases, matches these to the input text and outputs spans corresponding to each occurence of a dictionary item in the input text.

The span aggregation operators take in a set of input spans and produce a set of output spans by performing certain aggr egate operations over the input spans. There are two main types of aggregation operators -consolidation and block . The consolidation operators are used to resolve overlapping matches of the same concept in the text. Consolidation can be done using different rules. Containment consolidation (  X  c ) is used to discard annotation spans that are wholly contained within other spans. Overlap consolidation (  X  o ) is used to produce new spans by merging overlapping spans. The block aggregation operator (  X  ) identifies spans of text enclosing a minimum number of input spans such that no two consecutive spans are more than a specified distance apart. It is useful in combining a set of consecutive input spans into bigger spa ns that represent aggregate concepts. The algebra also includes some new selection predicates that apply only to spans asshowninTable1. 3.2 Extensions for Visual Information Extraction We extend the algebra described in order to support information extraction based on visual rules. In addition to the span, we add two new types in our model  X  Region and V isualSpan .A Region represents a visual box in the layout of the page and has the attributes: x l ,y l ,x h ,y h .( x l ,y l )and( x h ,y h )denotethe bounding box of the identified region in the visual layout of the document. We assume that the regions are rectangles, which applies to most markup languages such as HTML. A V isualSpan is a combination of a text based span and a visual region with the following attributes: s, r ,where s is a text span having attributes begin and end as before and r is the region corresponding to the span.
The operators are also modified to work with visual spans. The relational operators are unchanged. The span extraction operators are modified to return visual spans rather than spans. For example, the regular expression operator re matches the regular expression r to the input text and for each matching text span s it returns its corresponding visual span. Similarly, the dictionary matcher d outputs visual spans corresponding to occurences of dictionary items in the input text. The behavior of the span aggregation operators (  X  c and  X  o ) is also affected. Thus containment consolidation  X  c will discard visual spans whose region and span are both contained in the region and span of some other visual span. Overlap consolidation (  X  o ) aggregates visual spans whose text spans overlap. It produces a new visual span whose text span is the merge of the overlapping text spans and bounding box is the region corresponding to the closest HTML element that contains the merged text span.

There are two flavors to the block aggregation operator (  X  ). The text block operator (  X  s ) is identical to the earlier  X  operator. It identifies spans of text enclosing a minimum number of input spans such that no two consecutive spans are more than a specified distance apart. The region block operator (  X  v )takes as input a X distance x and Y distance y . It finds visual spans whose region contains a minimum number of input visual spans that can be ordered such that the X distance between two consecutive spans is less than x and the Y distance is less than y . The text span of the output visual spans is the actual span of the text corresponding to its region.

The predicates described in Table 1 ca n still be applied to the text span part of the visual spans. To compare the region part of the visual spans, we need many new predicates, which are described in the next section. 3.3 Visual Operators We introduce many new operators in the algebra to enable writing of rules based on visual regions. The operators can be classified as span generating, scalar or grouping operators and a subset has been listed in Table 2. Many of these operators are borrowed from spatial (GIS) databases. For example, the operators Contains, Touches and Intersects are available in a GIS database like DB2 Spatial Extender 2 . However, to our best knowledge this is the first application of using these constructs for Information Extraction.
 Span Generating Operators. These operators produce a set of visual spans as output and include the # ( d ), Ancestors and Descendents operators. Scalar Operators. The scalar operators take as input one or more values from a single tuple and return a single value. Boolean scalar operators can be used in predicates and are further classified as directional or containment operators. The directional operators allow visual spans to be compared based on their positions in the layout. Due to lack of space, we have listed only NorthOf , however we have similar predicates for other directions. Other scalar operators include the generalization/specialization operators and the geometric operators. Grouping Operators. The grouping operators are used to group multiple tuples based on some criteria and apply an aggregation function to each group, similar to the GROUP BY functionality in SQL. 3.4 Comparison with Source Based Approach If visual algebra is not supported, we would have to impelement a given task using only source based rules. The visual algebra is a superset of the existing source based algebra. Expressing a visual rule using existing algebra as a source based rule can be categorized into one of the following cases: 1. Identical Semantics: Some of the visual operators can be mapped directly 2. Approximate Semantics: Mapping a visual rule to a source based rule 3. Alternate Semantics: In some cases, it is not possible to obtain even This section describes the architectur e and our implementation of the visual extraction system. There are two models typically used for information extrac-tion  X  document level processing, in which rules are applied to one document at a time and collection level processing, in which the rules are matched against the entire document collection at on ce. The document at a time processing is suitable in the scenario where the docu ment collection is dynamic and new doc-uments are added over time. The collectio n level processing is useful when the document collection is static and the rules are dynamic, i.e. new rules are being developed on the same collection over tim e. Previous work has demonstrated an order of magnitude improvement in perfo rmance by collection level processing compared to document level processing with the use of indices for evaluating reg-ular expression rules [14]. The visual algebra can be implemented using either a document level processing model or a collection level processing model. We implemented a collection level processi ng approach using a relational database with extensions for inverted indices on te xt for efficient query processing. Fig-ure 2 depicts the overall system architect ure. Collection level processing has two phases: (a) Preprocessing phase comprising computations that can be done of-fline and (b) Query phase that includes the online computations done during interactive query time.
 Preprocessing Phase. In the preprocessing phase, web pages from which in-formation is to be extracted are crawled and a local repository of the web pages is created. Along with the HTML source of the web page, all components that are required to render the page accurately, such as embedded images and stylesheets, should also be downloaded and appropriately linked from the local copy of the page. We use an open source Firefox extension called WebPageDump 3 specifi-cally designed for this purpose. Each page is then rendered in a browser and for each node in the DOM tree, its visual region and text is extracted (using the Chickenfoot Firefox extension 4 ) and stored in a relational database (IBM DB2 UDB). We also use the indexing and text search capabilities of DB2 Net Search Extender 5 to speed up queries that can benefit from an inverted index. Query Phase. During the interactive query phase, the user expresses the infor-mation extraction task as operations in the visual algebra. The visual algebraic operations are then translated to standard SQL queries and executed on the database. 4.1 Implementing Visual Algebra Queries Using a Database Schema. The visual regions computed in the pre-processing stage are stored in table called Regions with the following schema: &lt;Pageid,Regionid,x l ,y l ,x h ,y h , TextStart, TextEnd, Text, HtmlTag, MinimalRegion, MaximalRegion &gt; .
The Pageid uniquely identifies a page. The html DOM tree is a hierarchical structure where the higher level nodes comprise lower level nodes. For example, a &lt;td&gt; maybenestedinsidea &lt;tr&gt; tag,whichisnestedinsidea &lt;table&gt; ,andso on. The Regionid uniquely identifies a region in a page annd is a path expression that encodes the path to the corresponding node. This makes it easy to identify the parents and descendants of a region. For example, a node 1 . 2 indicates a node reached by following the second child of the first child of the root node. The x l ,y l ,x h ,y h denote the coordinates of the region. The Text field stores the text content of the node with TextStart and TextEnd indicating the offsets of the text within the document. The text content of higher level nodes is the union of the text content of all its children. However, to avoid duplication, we associate only the innermost node with the text content while storing in the Regions table. The MinimalRegion and MaximalRegion fields are used to quickly identify a descendant or ancestor that has the identical text content as this node. Implementation of Operators. The visual algebra is implemented using a combination of standard SQL and User Defined Functions (UDFs). Due to space constraints, we mention the mapping of only some representative operators with-out going into complete detail in Table 3. For simplicity, we have shown the SQL for each operator separately. Applying th ese rules for a general algebra expres-sion will produce a nested SQL statement that can be flattened out into a single SQL using the regular transformation rules for SQL sub-queries. We also ex-perimented with using a spatial database to implement our algebra, but found that it was not very efficient. Spatial databases can handle complex geometries, but are not optimized for the simple rectangular geometries that the visual re-gions have. Conditions arising from simple rectangular geometries can be easily mapped to simple conditions on the region coordinate columns in a regular re-lational database.
 Visual Span Producing Operators: The re and d operators are imple-mented using UDFs that implement regular expression and dictionary match-ing respectively. Anscestors ( v )and Descendants ( v ) are implemented using the path expression in the region id of vs . Searching for all prefixes of the Regionid returns the ancestors and searching for all extensions of Regionid returns the descendants.
 Span Aggregation Operators: The span aggregation operators (  X  o ,  X  c and  X  ) cannot be easily mapped to existing operators in SQL. We implement these in Java, external to the database.
 Other Visual Operators: The scalar visual operators include the directional predicates, containment predicates, generalization/specialization operators and geometric operators. The predicates map to expressions in the WHERE clause. The generalization/specialization pre dicates are implemented using the pre-computed values in the columns MinimalRegion and MaximalRegion .The grouping operators map to GROUPBY clause in SQL and the aggregate func-tions can be mapped to SQL aggregate functions in a straightforward way as shown for HorizontallyAligned and MinimalBoundingRegion .
 Use of Indices. Indices can be used to speed up the text and region predicates. Instead of the MatchesRegex UDF, we can use the CONTAINS operation provided by the text index. We also build indices on x l ,x l ,x h ,y h columns to speed up visual operators. Once the visual algebra query is mapped to a SQL query, the optimizer performs the tas k of deciding what indices to use for the query based on cost implications. Example of a mapping is shown in Table 4. The goal of the experiments is two fold -to demonstrate the simplicity of visual queries and to study the effectiveness of m apping the visual algebra queries to database queries. We describe the visual algebra queries for a representative set of tasks, map them to SQL queries in a database system and study the effect of indexing on the performance. 5.1 Experimental Setup The document corpus for our experiments consists of software product informa-tion pages from IBM web site 6 . We crawled these pages resulting in a corpus of 44726 pages. Our goal was to extract the system requirements information for these products from their web pages (see Figure 1). Extracting the system re-quirements is a challenging task since the pages are manually created and don X  X  have a standard format. This can be broken into sub-tasks that we use as rep-resentative queries for our experiments. The queries are listed below. The visual algebra expression and the equivalent SQL query over the spatial database are listed in Table 4. For ease of expression, the visual algebra queries are specified using a SQL like syntax. The functions RegEx and Dict represent the operators r and d respectively. For each of these sub-tasks, it is possible to write more precise queries. However, our goal here is to show how visual queries can be used for a variety of extraction tasks without focusing too much on the precision and recall of these queries.  X  Filter the navigational bar at the left e dge before extracting the system re-quirements.

Q1: Retrieve vertically aligned regions with more than n regions such that the region bounding the group is contained within a virtual region A ( x l ,y l ,x h ,y h ).
For our domain, we found that a virtual region of A (0 , 90 , 500 ,  X  ) works well.  X  Identify whether a page is systems req uirements page. We use the heuristic that system requirement pages have the term  X  X ystem requirements X  men-tioned near the top of the page.

Q2: Retrieve the region in the page contai ning the term  X  X ystem requirements X  contained in a region A . In this case, we use a virtual region, A (450 , 0 ,  X  , 500)  X  To identify various operating systems that are supported, the following query can be used.

Q3: Find all regions R, such that R contains one of the operating systems mentioned in a dictionary T and are to the strict south or to the strict east of a region containing the term  X  X perating Systems X .  X  To find the actual system requirements for a particular operating system, the following query can be used.

Q4: Find a region that contains the term  X  X indows X  that occurs to the strict south of a region containing the term  X  X perating Systems X  and extract a region to the strict right of such a region.
 Due to lack of space, we show the visual algebra expression and the equivalent SQL query (Section 4.1) for only query Q4 in Table 4. For ease of expression, the visual algebra queries are specified using a SQL like syntax.
 5.2 Accuracy of Spatial Rules We measured the accuracy of our spatial rules using manually annotated data from a subset of pages in our corpus. The test set for Q2 and Q4 consists of 116 manually tagged pages. The test set for Q1 and Q3 contains 3310 regions from 10 pages with 525 positive examples for Q1 and 23 positive examples for Q3. Please note that for Q1 and Q3 we need to manually tag each region in a page. Since there are few hundred regi ons in a page, we manually tagged only 10 pages. The rules were developed by looking at different patterns that occur in a random sample of the entire corpus. The results are reported in Figure 4. Since our tasks were well suited for extraction using spatial rules, we were able to obtain a high level of accuracy using relatively simple rules. 5.3 Performance We measured the performance of these que ries on the document collection. Since the queries have selection predicates on the text column and the coordinates ( x l ,y l ,x h ,y h ), we build indices to speed them up. We also index the text column using DB2 Net search extender. The running time for the queries are shown in Figure 3. We compare various options of using no indices, using only text index and using both text index and indices on the region coordinates. For Q 1, the text index does not make a difference since there is no text predicate. The region index leads to big improvement in the time. Q 2, Q 3and Q 4 have both text and region predicates and thus benefit from the text index as well as the region indices. The benefit of the text index is found to be compartively larger. In all the cases, we can see that using indices leads to a three to fifteen times improvement in the query execution times.
 We have demonstrated an extension to the traditional rule based IE framework that allows the user to specify layout based rules. This framework can be used for many information extraction tasks that require spatial analysis without hav-ing to use custom code. The WYSIWYE algebra we propose allows the user to seamlessly combine traditional text based rules with high level rules based on spatial layout. The visual algebra can be systematically mapped to SQL statements, thus enabling optimization by the database. We have evaluated our system in terms of usability and performance for a task of extracting software system requirements from software web pages. The rules expressed using the visual algebra are much simpler than the corresponding source based rules and more robust to changes in the source code. The performance results show that by mapping the queries to SQL and using text and region indexes in the database, we can get significant improvement in t he time required to apply the rules.
Layout based rules are useful for certain types of pages, where the layout information provides cues on the information to extract. A significant source of variation in web pages (different source code, same visual layout) can be ad-dressed by rule based information extraction systems based on a visual algebra, leading to simpler rules. Visual rules are not always a replacement for the text based rules, rather they are complementary. In our system, we can write rules that combine both text based and layout based rules in one general framework.
