
Active learning may hold the key for solving the data scarcity problem, i.e., the lack of labeled data, in supervised learning. Indeed, labeling a large set of data is often a costly and time-consuming process, but necessary to build an accurate classification model. For example, in webpage (image, news article, or face) classification, labels are often given by human experts, and thus, it is costly and time-consuming. Active learning, on the other hand, is able to actively request labels of a small number of selected or constructed examples, and thus, reducing the labeling cost significantly.

However, all previous works of active learning (see Sec-tion II for a detailed review) can only ask specific queries with all attribute values provided, and assume that the oracle could only answer such specific queries. For example, if the task is to predict osteoarthritis based on a patient dataset with 30 attributes, the previous active learners could only ask the specific queries as: does this patient have osteoarthritis, if ID is 32765, name is Jane, age is 35, gender is female, weight is 85 kg, blood pressure is 160/90, temperature is 98F, no pain in the knees, no history of diabetes, and so on (for all 30 attributes). Many of these 30 attributes may not be relevant to osteoarthritis in this case. Not only could specific queries like this confuse the oracles, but the answers returned are also specific: each label given is only for one specific query.
In real-world situations, the oracles (usually human ex-perts) are often more readily to answer generalized queries, such as  X  X re people over 50 with knee pain likely to have osteoarthritis? X  Here only two relevant attributes (age and type of pain) are mentioned, and the other 28 are don X  X -care X  X . We have discussed with some experts in heart-disease diagnosis and used-car sale, and they regard this type of generalized queries intuitive and easy to comprehend. Thus, in this paper, we assume that the oracle is more powerful; it can answer generalized queries by returning probabilistic labels. Not only are such generalized queries more natural and relevant, answers from the oracle also provide much more information, as one generalized query is often equivalent to many specific queries. In this example, the answer for this query is for all people over 50 with knee pain. This allows the active learner to improve learning effectively and quickly.

The difficulty of the generalized queries is that the an-swers from the oracle can often be uncertain. 1 For example, the answer to the above generalized query can be  X  X es with a 90% probability X . An overly general query, such as  X  X re people over 50 likely to have osteoarthritis? X  (age only), might receive yes with only a 60% probability. Indeed, the experts in the heart-disease diagnosis and used-car sale also sometimes have to reply with low certainties in their an-swers. Highly uncertain answers can make learning difficult as they may introduce noise into the training data; or, they can cause a waste of queries if these answers are directly discarded.

In general, the more general a query is (with more don X  X -care attributes), the more powerful it is (representing more specific instances), but usually the more uncertain the answer is from the oracle. Our task is to design an active learner that attempts to ask generalized queries with highly certain answers from the oracle. The task is not trivial. As far as we know, no previous work of active learning can deal with such generalized queries. See Section II for details.
In this paper we assume that the oracle is capable of answering generalized queries, and we propose a novel active learning paradigm in which such generalized queries can be asked and answered. We design a new algorithm called AGQ, for Active learner with Generalized Queries. AGQ can construct generalized queries with don X  X -care attributes, for either the pool-based or the membership-query active learner. See Section III for details. Experiments on synthetic and real-world datasets show that AGQ asks significantly fewer queries compared with the traditional active leaner. See Sections IV for details. To the best of our knowledge, this is the first work proposing active learning with generalized queries, and showing that it is highly effective.

Most previous works of active learning can be divided into two paradigms: the pool-based active learning and the membership query. 2 In the pool-based active learning, a pool of unlabeled examples is given, and the learner can only choose examples to label from the pool [3]. Briefly speaking, the pool-based active leaner first evaluates each example in the pool, to decide which one can maximumly improve the performance of the current model. Then the learner acquires its label from oracle to update the labeled training set and the learning model, and the process repeats. On the other hand, active learning with membership queries (or direct query construction) can construct examples (without the need of the pool) and request labels [4], [5]. Previous experiments show that both of these active learning methods reduce the number of labeled examples needed, compared with labeling examples randomly.

The essence of active learning lies in the  X  X oodness X  measurement of the unlabeled examples with respect to the current model. Many criteria have been proposed in the literatures. Uncertainty sampling [3] considers the most un-certain example as the most valuable one, and has been thor-oughly studied and widely used in many previous researches [6], [7], [2], [8], [9]. Query-by-committee (QBC) [10] is a more theory-based approach, and considers the example minimizing the version space as optimal. [11] implements QBC by constructing committees from ensemble methods (bagging, boosting, etc.), thus essentially transforms it to a variant of uncertain sampling. Besides, other criteria, such as variance reduction [12], Fisher information ratio [13], and estimated error reduction [14], are also elaborately designed and well accepted in active learning research area. In this paper, the proposed AGQ algorithm can be integrated with any of the above criteria, and the most widely used uncertain sampling is chosen for illustration and empirical study in the rest of the paper.

All previous works of active learning assume that the oracle could only answer specific queries, with all attribute values provided. To the best of our knowledge, our AGQ algorithm in this paper is the first work proposing active learning with generalized queries. Previously, [15] proposed active learning with feature labeling, which queries the label for one specific feature (for example,  X   X  X  X  X  X  X   X   X  X  X   X   X  X  X  X  X  X  X  X  X   X  ), and is mainly used in natural language pre-cessing. Although feature labeling is considered similar to the generalized query, our AGQ algorithm is significantly different in the following three aspects. First, instead of querying label for one specific feature, our AGQ could query the labels for multi-feature combinations (for example,  X   X  X  X  X  X  X   X + X   X  X  X  X   X + X   X  X  X  X  X  X  X  X  X   X   X  X  X   X   X  X  X  X  X  X  X  X  X   X  ). Thus, feature labeling is essentially a special case of our AGQ. In other words, our generalized query is a generic paradigm for both instance-based queries and feature-based queries. Second, AGQ always finds the most uncertain example (when in-tegrated with uncertain sampling) and generalizes it to a query. Labeling such uncertain examples has been proved to be very effective in improving predictive accuracy (see Section IV-B for details). On the other hand, feature labeling generally finds the most predictive (or most frequent) feature for querying, thus the answer from the oracle may not provide much new information to improve the model. Third, and most importantly, as feature labeling always queries label for only one feature, the answer from the oracle could be very uncertain. To deal with this problem, it is assumed in [15] that the oracle could  X  X kip X  the uncertain queries. But in fact, the oracle has  X  X orked X  on those queries, and the oracle X  X  effort is wasted. On the other hand, AGQ makes a minimal generalization of a specific query, thus the answers from the oracle tend to be certain. Our experiments show that the average certainty of the replies is 90% (see Section IV-B for details). In any case, every query of AGQ is counted, regardless of the certainty of the reply.

In this paper we propose a new active learning paradigm in which the learner can ask generalized queries, and we assume that the oracle can answer such generalized queries. In this section, we will describe a novel active learning algorithm called AGQ (Active learning with Generalized Queries). AGQ can generalize attributes (nominal or nu-meric) with specific values to don X  X -care attributes.
As most previous works of active learning are pool-based, and use uncertain sampling to choose the most valuable unlabeled examples, in this paper, we will also describe AGQ using uncertain sampling in pool-based paradigm. However, as our AGQ is a meta-learning method, it can be equally applied to the membership query active learning, or integrated with any other query strategy. We assume that examples are described by  X  nominal or numeric attributes  X  1 , X  2 ,..., X   X  and the label  X  of examples is binary, with values positive (1) and negative (0). The active learner is given an initial labeled training set  X  , and an unlabeled set  X  , from which the learner may choose examples to query for their labels from an oracle. A test set  X  is given but set aside to evaluate the accuracy of the learner during label acquisition.

The AGQ algorithm can be broken down into the follow-ing four major steps: 1) The first step is the same as in the previous pool-based 2) AGQ then finds irrelevant attributes in the most un-3) AGQ submits this generalized query to the oracle, 4) AGQ will utilize the label and the probability distri-
We will discuss each step in detail in the following subsections.
 A. Finding the Most Uncertain Example
Similar to the previous works of the pool-based active learning, AGQ first builds a predictive model based on the current set of labeled examples, and uses it to predict each example in the pool. The most uncertain example from the pool, the one with the probability of the majority class closest to 50%, is chosen as the result of this first step.
As the probability of the prediction is crucial in choosing the most uncertain example, we use an ensemble of decision trees in AGQ. Specifically, the bagging [19] of 100 j48 decision trees (implemented in Weka [20]) is used. The probability distribution of the prediction is estimated by the prediction of the 100 trees in the ensemble. Such an ensemble of many trees improves the probability estimation, compared with a single tree [21]. The standard decision tree algorithm is chosen because it tends to build small trees; this facilitates us to find irrelevant attributes in the next step. B. Constructing the Generalized Query
After finding the most uncertain (specific) example from the pool in the first step, AGQ needs to discover the irrelevant attributes (don X  X -care attributes).

If the set of  X  attributes are irrelevant, then the examples with any combination of their values would have the same prediction with similar probability estimation. The reverse may not be true, but it can be used as a heuristic to find the set of irrelevant attributes. However, there are of  X  attributes (given a total of  X  attributes), and for each subset, 2  X  value combinations (for binary attributes) must be tested. The task is clearly computationally expensive.
A heuristic, similar to the process of finding the largest itemsets in mining association rules [22], [23], is designed. More specifically, let  X  be the current don X  X -care attribute list, and let  X   X  be the current most uncertain example. We gradually expand  X  by adding more irrelevant attributes via greedy search, as follows. For each attribute  X   X  not currently in  X  , we generate a fixed number (100 in our experiments) of examples with randomly assigned values for attributes in  X  and  X   X  , all based on  X   X  . The number of examples is fixed to prevent combinatorial explosion of attribute values when  X  grows. The attribute value is randomly chosen according to the distribution of that attribute values in the original data set. This most accurately reflects the distribution of examples Algorithm 1 : find don X  X -care attributes
Input :  X   X  , the most uncertain example;  X  , predefined Output :  X  , don X  X -care attribute list.
 Initialize  X  =  X  ; Initialize  X   X  = probability of majority class for  X   X  ;
Initialize  X  X  X  X  X  X  X  X  X  X  X  X  =  X  X  X  X  X  X  ; repeat until  X  X  X  X  X  X  X  X  X  X  X  X  is  X  X  X  X  X  X  X  ; in the domain. 4 The attribute  X   X  with the smallest change in the probability distribution of all 100 examples is then regarded as irrelevant, and added into  X  if the smallest change is less than a pre-defined threshold. The process continues until  X  cannot be grown further. The generalized query is the one with don X  X -care (i.e.,  X   X   X ) for all attributes in  X  . This process is depicted with the pseudo code in Algorithm 1.

Clearly, this can generate most general queries (i.e., queries with most don X  X -care attributes) based on the current learning model. However, queries with too many don X  X -care attributes can be overly general, and labels from the oracle can be highly uncertain. Thus, we demand the threshold  X  in Algorithm 1 to be a very small number (0.0001 in our case). This would allow AGQ to find the most general queries that, hopefully, also include all relevant attributes. Still, as the initial labeled training set can be very small, the current learning model can be inaccurate. Thus, AGQ may produce generalized queries with don X  X -care for relevant attributes (see Table I in Section IV-A). This will be especially true when the initial labeled training set is very small. This would increase the uncertainty of the labels given by oracle. It would be an interesting future research to see how this can be prevented. C. Asking Generalized Queries to Oracle
In our work, we assume that the oracle can answer generalized queries with don X  X -care attributes just as easily as specific queries (without don X  X -care attributes). We be-lieve that in most real-world situations, human experts can easily answer such generalized queries with an estimated probability.

In Section IV-B we will test AGQ on the UCI datasets [24], comparing it with the traditional pool-based active learner. An interesting question arises: as we do not know the target functions of the UCI datasets, nor do we have human oracles for them, how can such generalized queries be answered?
We design the following method to simulate human oracles to answer the generalized queries. We first train a model based on the original dataset to represent the target function. This is the best model we can get as it is built from the whole dataset. Specifically, we use the bagging of 100 j48 decision trees on the whole dataset to represent the target model. But still, this target model, as a black-box, cannot answer generalized queries directly. Since each generalized query effectively represents a set of specific queries, a set of such specific queries (in which the don X  X -care attributes are replaced with specific values sampled randomly) is generated. To avoid combinatorial explosion when the generalized query has too many don X  X -care attributes, the size of the set is fixed at 100. The target model then returns the predicted probability distribution of these 100 examples in the set.

One may argue that the generalized queries could be unrealistic thus hard to be answered by oracle (as in mem-bership query). In the pool-based paradigm, AGQ chooses a specific example from the pool and generalizes it to a query. If the example is realistic, the generalized query is always realistic as well, so the oracle should be able to answer. For example, if the specific example is [  X  X  X  X  X  X  =  X  X  X  X  X  X , X  X  X  X  X  X  X  X  X  =  X  X  X  X  X  X  X  X  X , X  X  X  X  X  X  X  X  X  X  X  X  =  X  X  X  X , X  X  X  X  =30 ,... ] , then the generalized query could be [  X  X  X  X  X  X  =  X  , X  X  X  X  X  X  X  X  X  =  X  , X  X  X  X  X  X  X  X  X  X  X  X  =  X  X  X  X , X  X  X  X  =  X  ,... ] . Unrealistic generalized queries (such as [  X  X  X  X  X  X  =  X  , X  X  X  X  X  X  X  X  X  =  X  X  X  X  X  X , X  X  X  X  X  X  X  X  X  X  X  X  =  X  X  X  X , X  X  X  X  =  X  ,... ] ) will never be constructed.

The next key step of AGQ is to utilize the generalized queries and their labels from the oracle to further improve learning.
 D. Updating the Training Dataset
Given the probability distribution to the generalized query from the oracle, we need to utilize it to expand the training dataset and to build a better classifier. Again, because each generalized query effectively represents a set of specific queries, more than one specific example can be added into the original labeled training set. There are two issues to be resolved, however. One is how large the set of specific queries should be; the second is how to label those examples in the set.

The first question is relatively easy to answer. Again to avoid combinatorial explosion, a set with a fixed size (100 in our experiments) of specific examples is generated first, in which each don X  X -care attribute is replaced randomly by a specific value of that attribute. However, experiments (Section IV-B) indicate that the number of new examples added may influence adversely the distribution of the initial training set. If the initial training set is too small, then the new examples added may be overwhelming, and thus changing the distribution of examples in the training set. Thus, the number of examples added into the training set is the minimum of 100, half of the size of the initial training set, and the number of value combinations of all don X  X -care attributes.

How should each specific query be labeled? As the oracle returns probability distribution of labels (such as 0.9 for positive, 0.1 for negative) for the generalized queries, specific examples can simply carry weighted labels if the learning model (bagging of 100 j48 trees here) can take weighted examples directly. Most learning algorithms (such as decision trees, naive Bayes, instance-based learning) can indeed take weighted examples naturally. Thus, in the above situation, every specific example carries a positive label with weight 0.9, and a negative label with weight 0.1.

Thus in AGQ, the labeled training set is usually increased by adding multiple labeled examples (with probability la-bels), rather than by adding just one labeled example in the traditional pool-based active learning. If examples added are mostly valid, and the probability of the majority class is near 1 (a highly certain label), the learning can be improved dramatically, as we will show in the experiments.

In this section, we conduct experiments on a synthetic dataset and 14 UCI [24] datasets to compare AGQ with the previous active learning algorithm that asks specific queries. A. AGQ on Synthetic Dataset
In this subsection, we use synthetic data to empirically study the performance of AGQ, compared with the tradi-tional pool-based active learning with uncertain sampling.
In addition, we also present the performance of the optimal AGQ, which represents the best performance that AGQ could possibly achieve. Specifically, for each gen-eralized query, the optimal AGQ gradually specifies the original attribute values for the don X  X -care attributes, till the oracle provides a certain answer (  X  (  X  =1  X   X  )  X  0 . 95  X  (  X  =0  X   X  )  X  0 . 95 in our experiments). The training set is thereafter expanded according to this query and the answer. That is, the training set is only updated when the oracle returns highly certain labels (  X  0 . 95 ). However, some extra queries may still be asked to the oracle when the answer is not highly certain, which makes optimal AGQ not realistic. Here, we simply do not count those extra queries, and only count the  X  X ffective X  ones  X  those with certainty great than (or equal to) 0.95. Thus, it could reflect the fewest number of queries that AGQ can ask, which indicates the best performance AGQ can ever achieve.

We choose the target function as a decision tree with five relevant attributes,  X  1 - X  5 , and six leaves,  X  1 - X  6 Figure 1. To simulate the real-world dataset, we add another five irrelevant attributes,  X  6 - X  10 , to generate the synthetic data. We assume that all these attributes are binary, so is the class label. Therefore, with 10 binary attributes, we can generate 2 10 =1024 different examples, and label them with the target function. With this synthetic data, we know what the target function is and what the irrelevant attributes are. We can also directly use the target function as the oracle to answer the generalized queries.
The experiment is repeated on the synthetic dataset 20 times. Each time, the whole dataset is randomly split into three disjoint subsets: the training set, the unlabeled set, and the test set. The training set and the test set are always 2% and 25% of the whole dataset respectively, and the rest is the unlabeled set.

Figure 2 plots the average error rates of the optimal AGQ ( X  X GQ-Opt X  in short), AGQ and the traditional pool-based active learning ( X  X ool X  in short). We can see clearly from Figure 2 that, AGQ X  X  performance is quite close to the (unrealistic) optimal AGQ, and is much better than  X  X ool X . This indicates that the strategies we designed for AGQ (Section III) is quite effective  X  AGQ asks generalized queries with certain labels; that is, they are not overly general.

To further compare AGQ and  X  X ool X , we extract a typical series of queries from them during the active learning pro-cess. Table I tabulates these queries (Query in the table), as well as leaf(ves) in the target tree that these queries fall into (Classified by Leaf(ves)), ideal query according to the target tree (Ideal Query), answer from the oracle (Answer), number of specific examples generated to update the training set (No. of Examples), and error rate of the updated classifier (Error Rate). We can see from Table I that AGQ always constructs generalized queries with don X  X -care attributes while  X  X ool X  can only choose the most specific queries. These generalized queries from AGQ may not be as general as the ideal queries (constructed directly from the target tree; see Figure 1), but they still contain most irrelevant attributes. Only one query (Query 2) is overly general (falling into two leaves), thus the answer to this query is highly uncertain (54%). However, such overly general queries rarely occur in AGQ learning. (Thus, the performance of AGQ is quite similar to the optimal AGQ, as we showed earlier.) In this case, answers for the other four queries from the oracle are highly certain (100%). Thus, AGQ can often include more examples with correct labels into the training set in each iteration, and obtain significantly lower error rates (compared with  X  X ool X ).
 To summarize from the experiment on the synthetic data, AGQ can often identify correctly the irrelevant attributes and construct correctly the generalized queries with highly certain answers from the oracle. Thus the performance of the classifier is significantly improved when the corresponding multiple specific examples (with correct labels) are included into the training set. This yields the outstanding performance of AGQ (similar to the optimal AGQ) on the synthetic dataset, compared with the traditional pool-based active learning.
 B. AGQ on UCI Datasets In this subsection, we use 14 real-world datasets from the UCI Machine Learning Repository [24] to compare AGQ with the optimal AGQ and the pool-based active learning algorithm. All of these datasets have binary class and no missing values. Information on these datasets is tabulated in Table II.

Each whole dataset (  X  ) is first split randomly into three disjoint subsets: the training set (  X  ), the unlabeled set ( and the test set (  X  ). The test set  X  is always 25% of To make sure that active learning can possibly show im-provement when the unlabeled data are labeled and included into the training set, we choose a small training set for each dataset such that the  X  X aximum reduction X  of the error rate is large enough (greater than 10%). The training sizes of the 14 UCI datasets range from 1/200 to 1/5 of the whole datasets, also listed in Table II. The unlabeled set ( the whole dataset (  X  ) taking away the test set (  X  ) and the training set (  X  ).

The experiment is repeated on each dataset 20 times (i.e., each dataset is randomly split 20 times), when comparing  X  X GQ-Opt X , AGQ and  X  X ool X . We stop training when the error rate of  X  X ool X  is reduced by 3/4 of the  X  X aximum reduction X .

Figure 3 plots the average error rates of  X  X GQ-Opt X , AGQ and  X  X ool X  on a typical UCI datasets ( X  X epatitis X ), and the comparison on all the 14 datasets will be presented later. We can see from Figure 3 that, AGQ performs only slightly worse than  X  X GQ-Opt X  but significantly better than  X  X ool X , similar to the result on the synthetic dataset. This again clearly demonstrates the advantage of AGQ: AGQ performs almost as well as  X  X GQ-Opt X , and significantly outperforms  X  X ool X .
In addition, the t-test (the paired two-tailed t-test with a 95% confidence level) on the average error rates based on the 14 UCI datasets shows that, AGQ wins on 9, ties on 4, and loses on 1 dataset, compared with  X  X ool X . This clearly indicates that, with the same number of queries (same number of iterations), the error rate of AGQ decreases much faster than  X  X ool X .

To further analyse the performance of AGQ and  X  X ool X , we extract some important statistics during the active learn-ing process. They include the average number of don X  X -care attributes (and its percentage of the total attributes) in each query (Don X  X -care Attributes in the table), the average certainty of the oracle (Certainty of Oracle) 7 , average num-ber of specific examples generated to update the training set in each iteration (Number of Examples), the average number of iterations of AGQ and  X  X ool X  when their error rates are reduced by 3/4 of the  X  X aximum reduction X  (Iteration of AGQ and Iteration of  X  X ool X ), percentage of iteration reduction between AGQ and  X  X ool X  (% of Iteration Reduction), and AGQ wins/ties/loses compared with  X  X ool X  (AGQ w/t/l). Table III presents these statistics based on the 14 UCI datasets.

From Table III we can see that, on average, AGQ discov-ers 12.5 don X  X -care attributes, and includes 16.5 examples into the training sets in each iteration. Moreover, the cer-tainty of the oracle for the constructed generalized queries is as high as 90.21% on average. This explains the good performance of AGQ: it can ask generalized queries, most with certain answers from the oracle. In the three datasets ( X  X reast-w X ,  X  X onosphere X  and  X  X onar X ) where AGQ ties with  X  X ool X , we can notice that the certainties of the oracle are relatively low (87%, 86% and 73% respectively); this probably introduces more noise in the training sets, thus degrading the performance. In the dataset  X  X ic-tac-toe X  where AGQ also ties with  X  X ool X , though the certainty of the oracle is high (100%), AGQ could only discover 0.07 don X  X -care attribute (on average), and include only 1.3 examples (on average) in each iteration. This is probably why AGQ is not much different from the traditional pool-based active learner. For the dataset  X  X r-vs-kp X  where AGQ loses, the certainty of the oracle is relatively high (94%), and 39% of the attributes are discovered as don X  X -care in each query. So why does AGQ still lose to  X  X ool X ? A detailed study shows that,  X  X r-vs-kp X  is the Chess end-game board-positions, thus the attributes are highly constrained. As there are a total of 36 attributes, the dataset (containing about 3,000 examples) is very sparse; that is, only a small fraction of the attribute value combinations is valid. Thus, the examples generated by AGQ from the generalized queries and included into training set (Section III-D) are mostly invalid examples (i.e., meaningless board positions). These invalid examples may severely change the distribution of the original dataset thus degrading the performance of AGQ. We will study this issue further in our future work.

From Table III we can compare the number of iterations (queries) that AGQ and  X  X ool X  have required to achieve 3/4 of the  X  X aximum reduction X  on the error rate. We notice that, on the four datasets where AGQ ties with  X  X ool X , the two methods require almost the same number of iterations (queries). However, on the nine datasets where AGQ wins over  X  X ool X , AGQ asks 61% fewer queries compared with  X  X ool X . Over all 14 datasets, AGQ asks, on average, 36% fewer queries compared with  X  X ool X . This clearly shows the advantage of AGQ: it requires much fewer queries than  X  X ool X  on the tested UCI datasets.

To summarize, AGQ performs significantly better than  X  X ool X  on most UCI datasets (9 out of 14). Moreover, on those datasets where AGQ wins, it requires 61% fewer queries needed for  X  X ool X  to achieve the same error rate reduction. This clearly demonstrates the power of the gen-eralized queries and the advantage of AGQ.

Previous active learning algorithms assume that the or-acle can only answer specific queries that represent single examples. However, in real-world applications, the oracles are often more readily to answer  X  X eneralized queries X  with don X  X -care attributes. Answers to such generalized queries can provide more information to improve learning. The difficulty of generalized queries is that the answers from the oracle can be uncertain, thus noisy labels might be introduced and performance might be degraded. This easily happens especially when the initial labeled training set is small. In this paper, we propose a novel active learning algorithm (AGQ) to ask as general queries as possible with still highly certain labels. Our experiments show that, compared with the traditional pool-based active learning, AGQ can achieve the same error rates with significantly fewer queries (36% fewer on average). We also show that AGQ X  X  performance is similar to the (unrealistic) optimal AGQ. AGQ can be readily deployed in real-world data mining tasks where obtaining labeled examples is costly. In our future research, we will study the performance of AGQ with different base learning algorithms (we only use the bagging of decision trees in this paper). Strategies for dealing with highly uncertain answers from the oracle, and for preventing dramatic changes of data distribution when new examples are included in the training set are also in-teresting research issues to further improve the performance of AGQ.

The authors acknowledge the valuable assistance of other members of the Data Mining and E-Business Lab of The University of Western Ontario in this research.

