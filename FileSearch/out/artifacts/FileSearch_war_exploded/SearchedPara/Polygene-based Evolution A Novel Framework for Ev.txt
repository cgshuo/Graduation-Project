 In this paper, we introduce polygene-based evolution, a novel frame-work for evolutionary algorithms (EAs) that features distinctive operations in the evolution process. In traditional EAs, the prim-itive evolution unit is gene , where genes are independent compo-nents during evolution. In polygene-based evolutionary algorithms (PGEAs), the evolution unit is polygene , i.e., a set of co-regulated genes. Discovering and maintaining quality polygenes can play an effective role in evolving quality individuals. Polygenes general-ize genes, and PGEAs generalize EAs. Implementing the PGEA framework involves three phases: polygene discovery, polygene planting, and polygene-compatible evolution. Extensive experi-ments on function optimization benchmarks in comparison with the conventional and state-of-the-art EAs demonstrate the potential of the approach in accuracy and efficiency improvement.
 Categories and Subject Descriptors: H.2.8 [Database Manage-ment]: Database Applications X  Data mining General Terms: Algorithms, Experimentation, Performance. Keywords: Polygene, Evolutionary algorithms, Optimization, Data mining
Evolutionary algorithms (EAs) [4] was derived from Darwinian evolutionary principles and widely applied in computationally dif-ficult optimization and classification problems [2, 6]. In conven-tional EAs, the primitive evolution unit is gene, where genes are independent components during evolution.

In this paper, we introduce a novel polygene-based evolution framework. In polygene-based evolutionary algorithms (PGEAs), the primitive evolution unit is polygene. We consider a group of genes co-regulated and forming a polygene if they frequently occur in a population. As polygenes generalize genes, PGEA algorithms generalize EAs.

In biology, a trait , such as height, eye color or body mass, is a distinct variant of a phenotypic character of an organism. A poly-gene is a group of nonallelic genes that together influence a pheno-typic trait [5]. Over evolutionary time, organisms evolve adaptive traits that enable them to survive [3].

In EAs, we do not have explicit, observable traits. However, inspired by the biological phenomenon, we speculate that there can be polygenes, each being a group of co-regulated genes, that have direct influence to the goodness of individuals. Thus, in the PGEA framework, we discover and maintain those quality poly-genes throughout the evolution process in order to evolve quality individuals.

Using polygene instead of gene as the primitive evolution unit can significantly reduce the search space while retaining quality individuals. For optimization problems, a larger search space con-tains more feasible solutions and may lead to better results if the search is exhaustive. However, search heuristics such as EAs only search a very small part of the search space. PGEAs allow search to be done within a significantly reduced space that retains quality individuals, having increased probability to find good solutions.
In principle, PGEAs are highly promising as a new optimization tool. Implementation can also play a critical role in materializing the potential of the framework. In this study, we use a three-phase approach: (I) polygene discovery, (II) polygene planting, and (III) polygene-compatible evolution. For Phase I, we adopt an associa-tive classification-based approach to discover quality polygenes. For Phase II, we perform probabilistic planting to maintain the diversity of individuals. For Phase III, we incorporate polygene-compatible crossover and mutation in producing next generation of individuals. Association rules. The association rule mining problem [1] was first introduced in the context of mining transaction databases.
Let A be a set including all items. A set X = { i 1 ,i 2 ,...,i A is called an itemset ,or k -itemset because X contains k items. A transaction over A is a tuple T =( tid, I ) where tid is the transac-tion identifier and I is an itemset. T is said to support X if X A transaction database D over A is a set of transactions over A .
The support of an itemset X in D is the probability that X occurs in D , which is estimated by the proportion of the transactions in D containing X , formally, sup ( X )= |{ T | T =( tid,I )  X  An association rule is an implication X  X  Y ,where X, Y  X  and X  X  Y =  X  . The support of X  X  Y is calculated as the probability that a transaction in D contains both X and Y , formally, sup ( X  X  Y )= sup ( X  X  Y ) . The confidence of X  X  Y is calculated as the conditional probability that a transaction having X also contains Y , formally, conf ( X  X  Y )= Prob ( Y | X Classification based on associations (CBA). CBA is the first al-gorithm for associative classification with ruleitems . A ruleitem is a frequent and accurate association rule X  X  y ,where X is an itemset, and y  X  Y is a class label. Let Y = { y 1 ,y 2 ,...,y be the set of the class labels. According to the definitions of the association rules, the support of the ruleitem X  X  y 1 is calculated as sup ( X  X  y 1 )= sup ( X  X  X  y = y 1 } ) , and the confidence k -ruleitem denote a ruleitem X  X  y where X has k items. An ruleitem is frequent if its support is no less than a given minimum frequency threshold  X  . An ruleitem is accurate if its confidence is no less than a given minimum accuracy threshold  X  .
D EFINITION 1. Gene. In an individual, a gene is a tuple ( where i is the position of the gene in the individual, and v is the value.

An individual is a set of such tuples. Since the position infor-mation is redundant, for simplicity, an individual can also be rep-resented as a sequence v 1 v 2 ...v m . For example, 0001101010 represents the same gene as { (1 , 0) , (2 , 0) ,..., (9 , the literature, sometimes  X  X hromosome" is used for  X  X ene".
In the PGEA framework, we consider a group of genes co-regulated and forming a polygene if they frequently occur in a population.
D EFINITION 2. Polygene. In a population P , a set of genes  X   X   X  times in P .

For example, in individual 0 0 01 1 01010 , suppose  X  = { (2 (5 , 1) } (the bold font genes) satisfies the frequency threshold, then  X  forms a polygene. A polygene with length l =1 is a singleton polygene . Polygenes can overlap, i.e., a same gene may occur in two or more different polygenes.

We are particularly interested in the quality polygenes. A ba-sic observation is that good individuals often contain many quality polygenes, medium individuals usually contain some of them, but bad individuals generally contain few of them. Thus, quality poly-genes, referring to elite polygenes ( elites for short), can be used to distinguish good individuals from bad ones.

D EFINITION 3. Elite Polygene. Let P be the population set containing all possible individuals. Each individual in P labeled as high , medium and low respectively based on their fit-ness scores. This way, P can be divided into 3 subsets: high-quality P , medium-quality P m , and low-quality P l . A polygene  X  is an elite polygene if the ruleitem  X   X  high is a class association rule for P h  X  X  l , i.e., sup (  X   X  high ) &gt; X  s  X  conf (  X   X  where 0 &lt; X  s , X  c &lt; 1 .
 Unfortunately, cannot traverse all possible individuals in get P h and P l exactly, but can only use the current population to estimate them approximately. Due to the inaccuracy of the training data, the quality of the generated elites with associative classifica-tion cannot be guaranteed. Thus, a further verification is necessary for elite generation.
Our PGEA framework uses polygenes as the primitive evolution unit. Its evolution process is similar to that of EAs. After initializa-tion, it iterates from generation to generation.

There are three phases within each generation: (I) polygene dis-covery, (II) polygene planting, and (III) polygene-compatible evo-lution. Algorithm 1 summarizes them in pseudocode. Line 1 per-forms initialization, i.e., randomly generating an initial population of individuals, evaluating their fitness scores, and selecting the best individual from them based on their fitness scores. Lines 2 X 6 show the iterative evolution process of PGEA from generation to gener-ation. In particular, line 3 is for Phase I, polygene discovery; line 4 is for Phase II, polygene planting; line 5 is for Phase III, polygene-compatible evolution.
 Algorithm 1 : PGEA Framework
Input : fitness function f , termination criteria tc , planting Output : best individual b
P 0  X  Initialize (); // initial population 1 repeat until tc are met
In Phase I, we mine polygenes using frequent pattern mining techniques and select elite ones with a CBA-based approach. Database transformation. Let P be the current population con-taining N individuals. Let P h be the best  X   X  N individuals in P with highest fitness scores, where each is labeled as high ,and 0 &lt; X &lt; 1 is called high-quality proportion .Let P l be the worst  X   X  N individuals with lowest fitness scores in P , where each is labeled as low ,and 0 &lt; X &lt; 1 is called low-quality proportion . Other individuals are labeled as medium .

For database transformation, each gene ( i, v ) in p is transformed into an item. Let A be the itemset containing all potential items. Since for conventional EA, there are m positions in each individual, and for each gene position there are 2 potential values 0 and 1, there are totally 2 m items in A .

Each individual p = v 1 v 2 ...v m is transformed into a trans-action X p =( tid p ,I p ) ,where I p = { (1 ,v 1 ) ,..., way, the population P are transformed into a transaction database D , where each transaction is also labeled as high , medium ,or low .
 Polygene mining. According to Definition 2, polygenes P can be mined from the transaction database D with pattern mining. Since efficiency has remained as a major challenge for pattern mining, to improve efficiency, we effectively reduce the number of mined polygenes without loss of quality by adding constraints on poly-genes. (1) Only the polygenes where genes represent the same vari-able are considered because these genes are directly related to each other in forming a value of a variable. (2) The longest length of the frequent patterns (polygenes) is controlled by a predetermined parameter  X  in order to reveal the main interdependency between genes but ignore the trivial cases.
 Candidate elite selection. We consider quality polygene frequently occurring in high-quality individuals but seldom in low-quality ones, and candidate elite polygenes can be selected with associative clas-sification. In our framework, a CBA-based approach is adopted to generate candidate elites based on the mined polygenes P .
Let  X  be a polygene mined from the transaction database D .A ruleitem  X   X  high is generated as a candidate elite polygene. Let D hl be the transaction set containing all transactions with labels high and low in D . According to the definition 3,  X  is an elite if sup (  X   X  high ) &gt; X  s  X  conf (  X   X  high ) &gt; X  c based on D where 0 &lt; X  s , X  c &lt; 1 .
 Elite verification. As mentioned in Section 3.1, a further verifica-tion is necessary for elite generation because of the inaccuracy of the training data. In our framework, a testing-based validation is adopted.

Let  X  be a candidate elite polygene. Let N be the number of individuals in the population. Let  X  be the sample proportion , i.e.,  X   X  N individuals are sampled for verification. Let S { p s 1 ,p s 2 ,...p s  X   X  N } be the set of sampled individuals, where each individual p s i is associated with a fitness score f ( p ing  X  into S (see Section 3.4), S is transformed into S  X  = { p dividuals can be generated after planting, formally,  X  f (
In Phase II, we plant the discovered quality polygenes to the cur-rent population to  X  X agnify" their presence for their survival from evolution operations. For diversity, we adopt a probabilistic plant-ing approach, where each polygene is selected for planting with a probability  X  , called planting probability .

Let  X  = { ( i 1 ,v 1 ) , ( i 2 ,v 2 ) ,..., ( i l ,v l ) } gene. Let p be an individual. The planting process of  X  in p is to convert the gene values of p at position i 1 ,i 2 ,...,i v ,v 2 ,...,v l respectively if a random generated number is less than  X  .

E XAMPLE 1. Let individual p = 00000101 be represented gene for planting. After planting, the individual becomes p 00000 0 0 0 .
For Phase III, polygene-compatible crossover and mutation are incorporated, where polygene is the unit of operation.

For polygene-compatible single-point crossover, the most impor-tant issue is to guarantee that polygenes in parent individuals can be inherited as a whole by offsprings without being broken.
D EFINITION 4. Polygene-Compatible Crossover. A crossover for a pair of individuals p 1 and p 2 is polygene-compatible if their polygenes can be inherited as a whole in their offspring individuals p and p 2 .

E XAMPLE 2. Let p 1 and p 2 be 2 individuals and they contain polygenes  X  = { (2 , 0) , (5 , 1) } and  X  = { (3 , 1) , (5 crossover point can be selected at position 7 (genes in italic font). As a result, offsprings p 1 (inheriting  X  ) and p 2 (inheriting  X  )can be generated by crossover.
Mutation of a polygene can be defined in various ways, where 1 or more genes in a polygene can be mutated. In our study, all genes in the polygene are mutated simultaneously during a polygene-compatible mutation operation.

D EFINITION 5. Polygene-Compatible Mutation. In a polygene-compatible mutation, each gene ( i j ,v j ) in polygene  X  ( i ,v 2 ) ,..., ( i l ,v l ) } is mutated to ( i j , v j ) .
Although the PGEAs proposed in this study are based on the binary representation, it is possible to implement PGEAs with non-binary representations such as real number and tree. For the real number representation, instead of considering ( i, v ) as an item, a mapping function f : R X  L can be used to map the infi-nite gene value set R into a finite discrete label set L , e.g., L { low , medium , high } . Then, we consider ( i, f ( v )) as an item. For the tree representation, we can use frequent tree/graph pattern mining for the discovery of polygenes. Comparison partner. We chose conventional EA as our main comparison partner. Our implementation of PGEAs was based on conventional EAs. A direct comparison of the two will provide valuable and irreplaceable insights.

In addition, we also used two state-of-the-art EAs including a diploid EA [6] and a classic EDA, named population-based incre-mental learning (PBIL) [2].
 Benchmark functions. We performed experiments on functional optimization problems to validate the PGEA framework. The bench-mark functions are listed as follows [7].
 F ( x )= n F ( x )=max 1  X  i  X  n {| z i |} + f b ,where z = x  X  o .
 F x  X  o +1.
 F ( x )= n F ( x )= 1 x  X  o .
 F ( x )=  X  20 exp  X  0 . 2 1 20 + e + f b ,where z = x  X  o .

Since most benchmark functions were proposed for EAs with real number representations, without loss of generality, the follow-ing restrictions were applied in our experiments: (1) According to traditional experimental settings for EAs with binary representa-tion, each variable x i was represented by 10 binary genes, i.e., the functions, o and f b were predetermined as [1 . 28 ,..., 1 2.56 respectively.

Table 1 shows the properties of these benchmark functions, in-cluding whether they are multi-model, shifted or non-separable func-tions, whether they have multiple local minimums, the global opti-mum point x  X  , and the global optimization value F ( x  X  ) Parameter settings. For each function, 30 variables were used. In each generation 100 individuals were maintained. PGEA ter-Items Algs F 1 F 2 F 3 F 4 F 5 F 6 E ( x ) minated if the best solution cannot be improved for more than 50 generations or the maximum number of generations of 1000 was reached. These parameters were used for all algorithms in compar-ison.

The following parameter settings were used only for PGEA. In the polygene discovery phase, for each generation the best  X  and worst  X  =5% individuals were considered as high-quality and low-quality individuals respectively. An itemset with maxi-mum length  X  =2 was frequent if its support was no less than  X  = 50% . A ruleitem was a class association rule if its support and confidence were no less than  X  s = 30% and  X  c = 70% respec-tively.  X  =5% of individuals were sampled for elite verification. In polygene planting phase, each elite was selected for planting with a probability  X  = 10% .
 Performance. We ran each algorithm 25 times. The results are summarized in Table 2 and Fig. 4. Table 2 presents the error val-benchmarks. From the table we can see that PGEA significantly gains in accuracy.

PGEA returned the most accurate optimization results for almost all benchmarks. For many functions, PGEA significantly outper-formed the conventional EA. For example, for F 2 , F 5 and F mean error values by the conventional EA are 2.2909, 1.0385 and 2.5053 while those by PGEA are 0.0016, 0.0097 and 0.0307 re-spectively. Besides, although PGEA ignored the polygenes cross-ing different variables (see Section 3.3), PGEA still significantly outperformed the conventional EA for 4 ( F 2 , F 3 , F 5 , F non-separable benchmark functions.

Fig. 2 shows the convergence rates within the first 100 genera-tions. Fig. 4 shows the number of generations before convergence. From the figures we can see that PGEA significantly gains in effi-ciency. PGEA converged with the least number of generations for 5 out of 6 functions. Note that for F 1 , F 2 , F 5 and F the conventional EA converged the fastest, it failed to return rea-sonable results (see Table 2) and thus not considered. In general, PGEA converges significantly faster than the conventional EA. For example, for F 3 and F 4 , PGEA took on average 316.56 and 450.6 generations to converge while conventional EA failed to converge within 1000 generations.
This research was supported in part by the Natural Science Foun-dation of China (60970047, 61070097, 71171122), the Humanity and Social Science Foundation of Ministry of Education of China (12YJC630211), the Natural Science Foundation of Shandong Province of China (BS2012DX012), and the National Science Foundation (OCI-1062439, CNS-1058724).
