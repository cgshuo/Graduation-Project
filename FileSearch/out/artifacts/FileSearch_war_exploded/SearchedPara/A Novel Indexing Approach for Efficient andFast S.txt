 Continuous motion data can be generated by many real-time and off-line appli-cations in life sciences and animations, and can be employed for gesture recogni-tion, gait analysis and rehabilitation, sports performance, film and video games [8]. To decide whether a motion segment in a motion stream is a known motion in a large motion database, or to recognize motions in the continuous motion data, not only is a motion similarity measure needed [5], but also an efficient and fast pruning algorithm is necessary. The pruning algorithm should prune most impossible motions in a large database for a motion query in real time. To prune motions efficiently and fast need s to address several challenges:  X  Datasets of motions have multiple attributes. Each attribute describes the  X  Datasets of motions are high dimensional and even similar motions can have Due to these issues, direct indexing of motion data is difficult and inefficient.
This paper proposes a new method for indexing motion data with dozens of attributes. The feature vectors are extracted by obtaining the equal-length dominating vectors from singular value decompositions (SVD) of motion data and by reducing vector dimensionalities. Corresponding feature values of all mo-tion patterns are partitioned into several intervals. Motion or feature vector IDs are inserted into a tree of feature intervals by using the corresponding feature values. To take into consideration motion variations, a feature ID is allowed to be inserted into multiple neighboring feature intervals. Hence a feature vector ID can be in multiple leaf nodes instead of in only one leaf node. Searching for possible similar motions of a query needs only one node traversal at each tree level and takes only several microseconds. Equal length multi-attribute sequences are considered in [2]. A CS-Index struc-ture is proposed for shift and scale transformations. In [4], multi-attribute se-quences are partitioned into subsequen ces, each of which is contained in a Min-imum Bounding Rectangle (MBR). Every MBR is indexed and stored into a database by using an R-tree or any of its variants.

Dynamic time warping (DTW) and longest common subsequence (LCSS) are extended for similarity measures of multi-attribute data in [9]. Before the exact LCSS or DTW is performed, sequences ar e segmented into MBRs to be stored in an R-tree. Based on the MBR intersectio ns, similarity esti mates are computed to prune irrelevant sequences.

Attributes of the data indexed in the previous work are less than ten. In contrast, our proposed indexing structure can handle dozens or hundreds of data attributes without loss of good performances. This work proposes a novel indexing approach which is different from that in [6], making it possible to search the indexing tree for similar motions in only several microseconds. In this section, we give the definition and geometric interpolation of SVD for its application to the indexing of multi-attribute motion data.

SVD exposes the geometr ic structure of a matrix A . If the multi-dimensional row vectors or points in A have different variances along different directions and columns of A have zero means, the SVD of matrix A can find the direction with the largest variance. If columns of A do not have zero means, the direction along which row vector projections have the largest 2-norm or Euclidean length can be revealed by SVD. Figure 1 illustrates the data in an 18  X  2matrix.The18 points in the 18  X  2 matrix have different varian ces along different directions, hence data have the largest variance along v 1 as shown in Figure 1.

Along the direction of the first right singular vector, the projections of row vectors in A have the largest 2-norm, and along the second right singular vector direction, the projection 2-norm is the second largest, and so on. The singular values reflect the Euclidean lengths or 2-norms of the projections along the corresponding right singular vectors.

Asshownin[1],anyreal m  X  n matrix A can be decomposed into A = U X V T , where U =[ u 1 ,u 2 ,...,u m ]  X  R m  X  m and V =[ v 1 ,v 2 ,...,v n ]  X  R n  X  n are two orthogonal matrices, and  X  is a diagonal matrix with diagonal entries being the singular values of A :  X  1  X   X  2  X  ...  X   X  min( m,n )  X  0. Column vectors u i and v i are unit vectors and are the i th left and right singular vectors of A , respectively.
For similar motions with different lengths, their left singular vectors are of different lengths, but their right singular vectors are of the equal length. The singular values of matrix A are unique, and the singular vectors corresponding to distinct singular values are uniquely determined up to the sign, or a singular vector can have opposite signs [7]. For convenience, we will refer to the right singular vectors as singular vectors. Motion matrices should have similar geometric structures if the corresponding motions are similar. Since the geometric similarity of matrix data can be cap-tured by SVD, we propose to exploit SVD to generate representative vectors or feature vectors for motion matrices, and use these feature vectors for indexing the multi-attribute motion data.

As Figure 2 shows, the first singular values are the dominating ones among all singular values. Since the singular values reflect lengths or magnitudes of the row vector projections along their corresponding singular vectors, we can say that the first singular vectors are the dominating vectors. If two motions are similar, their corresponding first singular vectors u 1 and v 1 should be mostly parallel to each other geometrically, so that | u 1  X  v 1 | = | u 1 || v 1 || cos (  X  ) | =1,where  X  is the angle between the two right singular vectors u 1 and v 1 ,and | u also very likely to be different from eac h other when two motions are different. Other corresponding singular vectors may not be close to each other even if two motions are similar as shown in Figure 3. This suggests that the first right singular vectors can be used to index multi-attribute motions for pruning the majority of different motions.
It is worth noting that for motions to be similar, other singular vectors and singular values should also be consider ed as shown in [5]. Although being neces-sary conditions for similarity measure, similar first singular vectors are sufficient for indexing purpose as to be demonstrated in Section 6.

Since the lengths or dimensions of the first singular vectors of multi-attribute motion data are usually larger than 15, dimensionality reduction needs to be performed on them first in order to avoid the so-called  X  X urse of dimensionality. X  We use SVD further to reduce the dimensionality of the first singular vectors to be indexed. Let A be the matrix composing the first singular vectors of the motions to be indexed, and then AZ = W X  gives the projected/transformed first singular vectors of motion patterns in the coordinate system spanned by the column vectors of Z [3], and for a singular vector u 1 of a query motion, u 1 Z gives a corresponding transformed singular vector of u 1 in the system spanned by the column vectors of Z .
Due to singular value decomposition, the component variations of the trans-formed first singular vectors are the largest along direction z 1 , and decreases along directions z 2 ,...,z n as shown in Figure 4. The differences among the first singular vectors are optimally reflected in the firs t several dimensions of the transformed first singular vectors, hence we can index the first singular vectors by indexing only the first several components of the tra nsformed singular vectors. Differences among all the other corresponding compon ents are small even if motions are dif-ferent, so the other components can thus be truncated and the dimensionalities are reduced to the first several ones. We r efer to the transformed singular vec-tors after dimensionality reduction as the featurevectors of the motions. If the first component of a feature vector is negative, all components of this vector are negated to obtain a consistent sign for feature vectors of similar motions [6]. Let r be the dimension of th e feature vectors, r&lt;n . We designate one level of the index tree to each of the r dimensions. Let level 1 be the root node, level i includes nodes for dimension i , i =1 , 2 ,...,r ,andlevel r + 1 contains leaf nodes. Leaf nodes contain motion identifiers P k , and non-leaf nodes contain entries of the form where I i is a closed interval [ a, b ] describing the component value ranges of the feature vectors at level i ,  X  1  X  a, b &lt; 1. Each entry has the address of one child node, and cp is the address of the child node in the tree.
The width and boundary of interval I i depend on the distribution of i th component values of feature vectors and the possible variations of the i th feature vector components of similar motions. Let  X  i be the maximum difference of the i th feature vector components of any similar motions, let x i and y i be the respective minimum and maximum values of the i th components of all feature vectors, and let be the entry interval factor for adjusting entry intervals. Then the width of entry intervals at the i th level is  X  i , and the number of entries of a node at level i is ( y i  X  x i ) / (  X  i ) , limited by maximum number of entries per node allowed. 5.1 Insertion and Searching Let the root node of the tree be T . The unique ID of a feature vector is in-serted into the tree by comparing the i th component c i of the feature vector and the entry interval [ a, b ] of the node traversed and can be inserted into multiple neighboring intervals:  X  Subtree Insertion: If T is a non-leaf node, find all entries whose I i  X  X  overlap  X  Leaf Node Insertion: If T is a leaf node, insert the motion pattern iden-
Figure 5 illustrates how to insert an example feature vector into the first three levels of an example index tree. Root node at level 1 has four entries, each of which has a child node at level 2. Each node at level 2 and level 3 has three entries, and each of which has a child node at one lower level. Given a feature vector f = (0.65, 0.15, -0.1, ... ), and let  X  1 = 0.04,  X  i =0.08for i  X  2, and =1.0. Only the third entry overlaps with it, hence the vector f is forwarded only to node n 3 of level 2. At level 2, the feature vector covering range is [0.15-0.08, 0.15+0.08] or [0.07, 0.23]. The second and third entries of node n 3 overlap with the feature vector covering range [0.07, 0.23], hence the feature vector will be forwarded to node n 5 and to node n 6 at level 3. At level 3, the feature vector covering range is [-0.1-0.08, -0.1+0.08] or [-0.16, -0.02]. Only the second entries of nodes n 5 and n 6 overlap with this range, so the nodes pointed by the second entries of nodes n 5 and n 6 will be traversed for insertion. This process goes on until the leaf nodes are traversed for holding P k of the feature vector f .
A query searching can be very simple: find the entry of the node whose interval [ a, b ]coversthe i th component c i of the query feature vector and traverse to the corresponding chile node pointed by the entry. When a leaf node is reached, all the motion identifiers included in that leaf node are returned for the query. Since a node entry contains all possible similar motions in neighboring entries of the same node, only one entry is needed to be traversed for a search at each level of the tree, rather than multiple entries to be traversed as in [6]. 5.2 Similarity Computation After the index tree has been searched for a query, the majority of irrelevant motions should have been pruned, and similar motions and a small number of irrelevant motions are returned as the result of the query. To find out the motion most similar to the query, a similarity measure shown below as defined in [5] can be used to compute the similarity of the query and all the returned motions, and the motion with the highest similarity is the one most similar to the query. where  X  i and  X  i are the i th singular values corresponding to the i th right singular vectors u i and v i of square matrices of Q and P , respectively, and 1 &lt;k&lt;n . Integer k determines how many singular vect ors are considered and depends on the number of attributes n of motion matrices. Experiments with hand gesture motions ( n = 22) and human body motions ( n = 54) show that k = 6 is large enough without loss of pattern recognition accuracy in streams. Let N pr be the number of irrelevant motions pruned for a query by the index tree, and N ir be the total number of irrelevant motions in the database. We define the pruning rate P as 6.1 Motion Data Generation Motion data was generated for hand gestu res by using CyberGlove and for dances and other human motions captured by us ing 16 Vicon cameras. There are 22 at-tributes for the CyberGlove data, and each attribute is for the angular values of one joint of the glove. There are 54 attributes for the motion capture data, and each attribute is for the positional values of one joint of a moving subject. The captured motion data had been transformed so that similar motions performed at different locations, following different paths, or at different orientations have  X  X imilar X  data matrices. One hundred and ten different hand gestures were gen-erated, and each one was repeated for 3 times, resulting in 330 data matrices of 22 columns. Sixty two different motions, including Taiqi and dances were per-formed, and each one was repeated for 5 times, resulting in 310 data matrices of 54 columns. 6.2 Index Struction Building We experimented with different tree configurations for CyberGlove data and motion capture (MoCap) data. For CyberGlove data of 22 attributes, feature vectors have 5 to 10 components, or trees of 5 to 10 levels were tested. For MoCap data of 54 attributes, trees of 5 to 12 level s were tested. The entry interval factors we tested were 1.5, 1.2, 1.0, 0.9, 0.8, 0.7, 0.6 and 0.5. The smaller the entry interval factors, the smaller the entry intervals, and the more the number of entries in a node at all levels. 6.3 Pruning Efficiency We issued one query for every one of the 330 CyberGlove motions and the 310 MoCap motions. Figure 6 shows that when all similar motions were retrieved and the feature vectors have 9 features, 95.7% irrelevant CyberGlove motions and 91% irrelevant MoCap motions could be pruned. When the entry interval factor is no less than 1.0, all similar motions can be retrieved, and when is less than 1.0, the most similar motions can still be retrieved and only a small number of less similar motions can be pruned as indicated by the high recalls as shown in Figure 7. 6.4 Computational Efficiency We tested the average CPU time taken by a query using different tree config-urations. All experiments are performed on one 3.0 GHz Intel processor of a GenuineIntel Linux box.

The search time of a query by using the proposed index structure takes less than 3  X s as shown in Figure 8. As a comparison, the search time of a query by the algorithm in [6] can take several milliseconds as shown in Figure 9. As a tradeoff, the proposed approach in this paper takes a little longer for inserting feature vectors. Nevertheless, each insertion still takes less than 35 milliseconds as shown in Figure 10 and is usually done off-line. This paper has proposed a novel approach for indexing multi-attribute motion data of different lengths. Feature vectors are extracted from motion data matrices by using SVD properties, and an interval -based tree structure is proposed for indexing the feature vectors. Feature vector IDs can be inserted into multiple neighboring feature value intervals to cope with motion variations and can be in multiple leaf nodes. As an advantage of this design, search of similar motions can be done in several microseconds by tr aversingonlyonenodeonceateach tree level, and up to 95.7 % different CyberGlove motions and 91% captured human motions can be pruned.

