 Tree Substitution Grammar (TSG) is a compelling grammar formalism which allows nonterminal rewrites in the form of trees, thereby enabling the modelling of complex linguistic phenomena such as argument frames, lexical agreement and idiomatic phrases. A fundamental problem with TSGs is that they are difficult to estimate, even in the supervised scenario where treebanked data is available. This is because treebanks are typically not annotated with their TSG derivations (how to decompose a tree into elementary tree fragments); instead the derivation needs to be inferred.
In recent work we proposed a TSG model which infers an optimal decomposition under a non-parametric Bayesian prior (Cohn et al., 2009). This used a Gibbs sampler for training, which re-peatedly samples for every node in every training tree a binary value indicating whether the node is or is not a substitution point in the tree X  X  deriva-tion. Aggregated over the whole corpus, these val-ues and the underlying trees specify the weighted grammar. Local Gibbs samplers, although con-ceptually simple, suffer from slow convergence (a.k.a. poor mixing). The sampler can get easily stuck because many locally improbable decisions are required to escape from a locally optimal solu-tion. This problem manifests itself both locally to a sentence and globally over the training sample. The net result is a sampler that is non-convergent, overly dependent on its initialisation and cannot be said to be sampling from the posterior.
 In this paper we present a blocked Metropolis-Hasting sampler for learning a TSG, similar to Johnson et al. (2007). The sampler jointly updates all the substitution variables in a tree, making much larger moves than the local single-variable sampler. A critical issue when developing a Metroplis-Hastings sampler is choosing a suitable proposal distribution, which must have the same support as the true distribution. For our model the natural proposal distribution is a MAP point esti-mate, however this cannot be represented directly as it is infinitely large. To solve this problem we develop a grammar transformation which can suc-cinctly represent an infinite TSG in an equivalent finite Context Free Grammar (CFG). The trans-formed grammar can be used as a proposal dis-tribution, from which samples can be drawn in polynomial time. Empirically, the blocked sam-pler converges in fewer iterations and in less time than the local Gibbs sampler. In addition, we also show how the transformed grammar can be used for parsing, which yields theoretical and empiri-cal improvements over our previous method which truncated the grammar. A Tree Substitution Grammar (TSG; Bod et al. (2003)) is a 4-tuple, G = ( T,N,S,R ) , where T is a set of terminal symbols , N is a set of non-terminal symbols , S  X  N is the distinguished root nonterminal and R is a set of productions (rules). The productions take the form of tree fragments, called elementary trees (ETs), in which each in-ternal node is labelled with a nonterminal and each leaf is labelled with either a terminal or a nonter-minal. The frontier nonterminal nodes in each ET form the sites into which other ETs can be substi-tuted. A derivation creates a tree by recursive sub-stitution starting with the root symbol and finish-ing when there are no remaining frontier nonter-minals. Figure 1 (left) shows an example deriva-tion where the arrows denote substitution. A Prob-abilistic Tree Substitution Grammar (PTSG) as-signs a probability to each rule in the grammar, where each production is assumed to be condi-tionally independent given its root nonterminal. A derivation X  X  probability is the product of the prob-abilities of the rules therein.

In this work we employ the same non-parametric TSG model as Cohn et al. (2009), which we now summarise. The inference prob-lem within this model is to identify the posterior distribution of the elementary trees e given whole trees t . The model is characterised by the use of a Dirichlet Process (DP) prior over the grammar. We define the distribution over elementary trees e with root nonterminal symbol c as where P 0 (  X | c ) (the base distribution ) is a distribu-tion over the infinite space of trees rooted with c , and  X  c (the concentration parameter ) controls the model X  X  tendency towards either reusing elemen-tary trees or creating novel ones as each training instance is encountered.

Rather than representing the distribution G c ex-plicitly, we integrate over all possible values of G c . The key result required for inference is that the conditional distribution of e i , given e  X  i , = e ...e n \ e i and the root category c is: p ( e been used to rewrite c in e  X  i , and n  X  i  X  ,c = P e n  X  i is the total count of rewriting c . Henceforth we omit the  X  i sub-/super-script for brevity. A primary consideration is the definition of P 0 . Each e i can be generated in one of two ways: by drawing from the base distribution, where the probability of any particular tree is proportional to  X 
P 0 ( e i | c ) , or by drawing from a cache of previ-ous expansions of c , where the probability of any particular expansion is proportional to the number of times that expansion has been used before. In Cohn et al. (2009) we presented base distributions that favour small elementary trees which we ex-pect will generalise well to unseen data. In this work we show that if P 0 is chosen such that it decomposes with the CFG rules contained within each elementary tree, 1 then we can use a novel dy-namic programming algorithm to sample deriva-tions without ever enumerating all the elementary trees in the grammar.

The model was trained using a local Gibbs sam-pler (Geman and Geman, 1984), a Markov chain Monte Carlo (MCMC) method in which random variables are repeatedly sampled conditioned on the values of all other random variables in the model. To formulate the local sampler, we asso-ciate a binary variable with each non-root inter-nal node of each tree in the training set, indicat-ing whether that node is a substitution point or not (illustrated in Figure 1). The sampler then vis-its each node in a random schedule and resamples that node X  X  substitution variable, where the proba-bility of the two different configurations are given by (1). Parsing was performed using a Metropolis-Hastings sampler to draw derivation samples for a string, from which the best tree was recovered. However the sampler used for parsing was biased because it used as its proposal distribution a trun-cated grammar which excluded all but a handful of the unseen elementary trees. Consequently the proposal had smaller support than the true model, voiding the MCMC convergence proofs. We now present a blocked sampler using the Metropolis-Hastings (MH) algorithm to perform sentence-level inference, based on the work of Johnson et al. (2007) who presented a MH sampler for a Bayesian PCFG. This approach repeats the following steps for each sentence in the training set: 1) run the inside algorithm (Lari and Young, 1990) to calculate marginal expansion probabil-ities under a MAP approximation, 2) sample an analysis top-down and 3) accept or reject using a Metropolis-Hastings (MH) test to correct for dif-ferences between the MAP proposal and the true model. Though our model is similar to John-son et al. (2007) X  X , we have an added complica-tion: the MAP grammar cannot be estimated di-rectly. This is a consequence of the base distri-bution having infinite support (assigning non-zero probability to infinitely many unseen tree frag-ments), which means the MAP has an infinite rule set. For example, if our base distribution licences the CFG production NP  X  NP PP then our TSG grammar will contain the infinite set of elemen-tary trees NP  X  NP PP, NP  X  (NP NP PP) PP, NP  X  (NP (NP NP PP) PP) PP, . . . with decreas-ing but non-zero probability.

However, we can represent the infinite MAP us-ing a grammar transformation inspired by Good-man (2003), which represents the MAP TSG in an equivalent finite PCFG. 2 Under the transformed PCFG inference is efficient, allowing its use as the proposal distribution in a blocked MH sam-pler. We represent the MAP using the grammar transformation in Table 1 which separates the n e,c and P 0 terms in (1) into two separate CFGs, A and B. Grammar A has productions for every ET with n e,c  X  1 which are assigned unsmoothed proba-bilities: omitting the P 0 term from (1). 3 Grammar B has productions for every CFG production li-censed under P 0 ; its productions are denoted using primed ( X ) nonterminals. The rule c  X  c 0 bridges from A to B, weighted by the smoothing term excluding P 0 , which is computed recursively via child productions. The remaining rules in gram-mar B correspond to every CFG production in the underlying PCFG base distribution, coupled with the binary decision whether or not nonterminal children should be substitution sites (frontier non-terminals). This choice affects the rule probability by including a s or 1  X  s factor, and child sub-stitution sites also function as a bridge back from grammar B to A. In this way there are often two equivalent paths to reach the same chart cell using the same elementary tree  X  via grammar A using observed TSG productions and via grammar B us-ing P 0 backoff; summing these yields the desired net probability.

Figure 2 shows an example of the transforma-tion of an elementary tree with non-zero count, n e,c  X  1 , into the two types of CFG rules. Both parts are capable of parsing the string NP, saw, NP into a S, as illustrated in Figure 3; summing the probability of both analyses gives the model prob-ability from (1). Note that although the probabili-ties exactly match the true model for a single ele-mentary tree, the probability of derivations com-posed of many elementary trees may not match because the model X  X  caching behaviour has been suppressed, i.e., the counts, n , are not incremented during the course of a derivation.

For training we define the MH sampler as fol-lows. First we estimate the MAP grammar over the derivations of training corpus excluding the current tree, which we represent using the PCFG transformation. The next step is to sample deriva-tions for a given tree, for which we use a con-strained variant of the inside algorithm (Lari and Young, 1990). We must ensure that the TSG derivation produces the given tree, and therefore during inside inference we only consider spans that are constituents in the tree and are labelled with the correct nonterminal. Nonterminals are said to match their primed and signed counter-parts, e.g., NP 0 and NP { DT,NN { car }} both match NP. Under the tree constraints the time complex-ity of inside inference is linear in the length of the sentence. A derivation is then sampled from the inside chart using a top-down traversal (Johnson et al., 2007), and converted back into its equiva-lent TSG derivation. The derivation is scored with the true model and accepted or rejected using the MH test; accepted samples then replace the cur-rent derivation for the tree, and rejected samples leave the previous derivation unchanged. These steps are then repeated for another tree in the train-ing set, and the process is then repeated over the full training set many times.
 Parsing The grammar transform is not only use-ful for training, but also for parsing. To parse a sentence we sample a number of TSG derivations from the MAP which are then accepted or rejected into the full model using a MH step. The samples are obtained from the same transformed grammar but adapting the algorithm for an unsupervised set-ting where parse trees are not available. For this we use the standard inside algorithm applied to the sentence, omitting the tree constraints, which has time complexity cubic in the length of the sen-tence. We then sample a derivation from the in-side chart and perform the MH acceptance test. This setup is theoretically more appealing than our previous approach in which we truncated the ap-proximation grammar to exclude most of the zero count rules (Cohn et al., 2009). We found that both the maximum probability derivation and tree were considerably worse than a tree constructed to maximise the expected number of correct CFG rules (MER), based on Goodman X  X  (2003) algo-rithm for maximising labelled recall. For this rea-son we the MER parsing algorithm using sampled Monte Carlo estimates for the marginals over CFG rules at each sentence span. We tested our model on the Penn treebank using the same data setup as Cohn et al. (2009). Specifi-cally, we used only section 2 for training and sec-tion 22 (devel) for reporting results. Our models were all sampled for 5k iterations with hyperpa-rameter inference for  X  c and s c  X  c  X  N , but in contrast to our previous approach we did not use annealing which we did not find to help general-isation accuracy. The MH acceptance rates were in excess of 99% across both training and parsing. All results are averages over three runs.

For training the blocked MH sampler exhibits faster convergence than the local Gibbs sam-pler, as shown in Figure 4. Irrespective of the initialisation the blocked sampler finds higher likelihood states in many fewer iterations (the same trend continues until iteration 5k). To be fair, the blocked sampler is slower per iteration (roughly 50% worse) due to the higher overheads of the grammar transform and performing dy-namic programming (despite nominal optimisa-tion). 4 Even after accounting for the time differ-Blocked minimal init 77.98 78.40 Blocked maximal init 77.67 78.24 ence the blocked sampler is more effective than the local Gibbs sampler. Training likelihood is highly correlated with generalisation F1 (Pearson X  X  cor-relation efficient of 0.95), and therefore improving the sampler convergence will have immediate ef-fects on performance.

Parsing results are shown in Table 2. 5 The blocked sampler results in better generalisation F1 scores than the local Gibbs sampler, irrespective of the initialisation condition or parsing method used. The use of the grammar transform in parsing also yields better scores irrespective of the underlying model. Together these results strongly advocate the use of the grammar transform for inference in infinite TSGs.

We also trained the model on the standard Penn treebank training set (sections 2 X 21). We ini-tialised the model with the final sample from a run on the small training set, and used the blocked sampler for 6500 iterations. Averaged over three runs, the test F1 (section 23) was 85.3 an improve-ment over our earlier 84.0 (Cohn et al., 2009) although still well below state-of-the-art parsers. We conjecture that the performance gap is due to the model using an overly simplistic treatment of unknown words, and also a further mixing prob-lems with the sampler. For the full data set the counts are much larger in magnitude which leads to stronger modes. The sampler has difficulty es-caping such modes and therefore is slower to mix. One way to solve the mixing problem is for the sampler to make more global moves, e.g., with table label resampling (Johnson and Goldwater, 2009) or split-merge (Jain and Neal, 2000). An-other way is to use a variational approximation in-stead of MCMC sampling (Wainwright and Jor-dan, 2008). We have demonstrated how our grammar trans-formation can implicitly represent an exponential space of tree fragments efficiently, allowing us to build a sampler with considerably better mix-ing properties than a local Gibbs sampler. The same technique was also shown to improve the parsing algorithm. These improvements are in no way limited to our particular choice of a TSG parsing model, many hierarchical Bayesian mod-els have been proposed which would also permit similar optimised samplers. In particular mod-els which induce segmentations of complex struc-tures stand to benefit from this work; Examples include the word segmentation model of Goldwa-ter et al. (2006) for which it would be trivial to adapt our technique to develop a blocked sampler. Hierarchical Bayesian segmentation models have also become popular in statistical machine transla-tion where there is a need to learn phrasal transla-tion structures that can be decomposed at the word level (DeNero et al., 2008; Blunsom et al., 2009; Cohn and Blunsom, 2009). We envisage similar representations being applied to these models to improve their mixing properties.

A particularly interesting avenue for further re-search is to employ our blocked sampler for un-supervised grammar induction. While it is diffi-cult to extend the local Gibbs sampler to the case where the tree is not observed, the dynamic pro-gram for our blocked sampler can be easily used for unsupervised inference by omitting the tree matching constraints.
