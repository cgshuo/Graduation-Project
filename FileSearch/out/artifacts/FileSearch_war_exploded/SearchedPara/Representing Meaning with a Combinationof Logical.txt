 The University of Texas at Austin The University of Texas at Austin The University of Texas at Austin The University of Texas at Austin The University of Texas at Austin
NLP tasks differ in the semantic information they require, and at this time no single seman-structure, but do not capture the graded aspect of meaning. Distributional models give graded similarity ratings for words and phrases, but do not capture sentence structure in the same detail as logic-based approaches. It has therefore been argued that the two are complementary. components of a practical system: 1 1) Logical representation focuses on representing the input problems in probabilistic logic; 2) knowledge base construction creates weighted inference approach, we use the task of textual entailment, which can utilize the strengths of both logic-based and distributional representations. In particular we focus on the SICK data set, where we achieve state-of-the-art results. We also release a lexical entailment data set of 10,213 rules extracted from the SICK data set, which is a valuable resource for evaluating lexical entailment systems. 2 1. Introduction
Computational semantics studies mechanisms for encoding the meaning of natural language in a machine-friendly representation that supports automated reasoning and that, ideally, can be automatically acquired from large text corpora. Effective semantic representations and reasoning tools give computers the power to perform complex applications like question answering. But applications of computational semantics are very diverse and pose differing requirements on the underlying representational for-malism. Some applications benefit from a detailed representation of the structure of complex sentences. Some applications require the ability to recognize near-paraphrases or degrees of similarity between sentences. Some applications require inference, either exact or approximate. Often, it is necessary to handle ambiguity and vagueness in meaning. Finally, we frequently want to learn knowledge relevant to these applications automatically from corpus data.
 fulfills all of these requirements, but there are representations that fulfill some of them. Logic-based representations (Montague 1970; Dowty, Wall, and Peters 1981; Kamp and
Reyle 1993), like first-order logic, represent many linguistic phenomena like negation, quantifiers, or discourse entities. Some of these phenomena (especially negation scope and discourse entities over paragraphs) cannot be easily represented in syntax-based representations like Natural Logic (MacCartney and Manning 2009). In addition, first-order logic has standardized inference mechanisms. Consequently, logical approaches have been widely used in semantic parsing where it supports answering complex natural language queries requiring reasoning and data aggregation (Zelle and Mooney 1996; Kwiatkowski et al. 2013; Pasupat and Liang 2015). But logic-based representations often rely on manually constructed dictionaries for lexical semantics, which can result in coverage problems. And first-order logic, being binary in nature, does not capture the graded aspect of meaning (although there are combinations of logic and proba-bilities). Distributional models (Turney and Pantel 2010) use contextual similarity to predict the graded semantic similarity of words and phrases (Landauer and Dumais 1997; Mitchell and Lapata 2010), and to model polysemy (Sch  X  utze 1998; Erk and Pad  X  o 2008; Thater, F  X  urstenau, and Pinkal 2010). But at this point, fully representing structure and logical form using distributional models of phrases and sentences is still an open problem. Also, current distributional representations do not support logical inference that captures the semantics of negation, logical connectives, and quantifiers. Therefore, distributional models and logical representations of natural language meaning are com-plementary in their strengths, as has frequently been remarked (Coecke, Sadrzadeh, and Clark 2011; Garrette, Erk, and Mooney 2011; Grefenstette and Sadrzadeh 2011; Baroni, Bernardi, and Zamparelli 2014).
 system that provides in-depth representations of sentence meaning amenable to au-tomated inference, but that also allows for flexible and graded inferences involving word meaning. Therefore, our approach combines logical and distributional methods.
Specifically, we use first-order logic as a basic representation, providing a sentence representation that can be easily interpreted and manipulated. However, we also use distributional information for a more graded representation of words and short phrases, providing information on near-synonymy and lexical entailment. Uncertainty and gradedness at the lexical and phrasal level should inform inference at all levels, so we rely on probabilistic inference to integrate logical and distributional semantics. Thus, our system has three main components, all of which present interesting challenges. 764
For logic-based semantics, one of the challenges is to adapt the representation to the assumptions of the probabilistic logic (Beltagy and Erk 2015). For distributional lexical and phrasal semantics, one challenge is to obtain appropriate weights for inference formulating the problems to allow for efficient Markov Logic Network (MLN) inference (Beltagy and Mooney 2014).
 and Beltagy et al. (2013). We have demonstrated the generality of the system by applying it to both textual entailment (RTE-1 in Beltagy et al. [2013], SICK [preliminary results] and FraCas in Beltagy and Erk [2015]) and semantic textual similarity (Beltagy, Erk, and Mooney 2014), and we are investigating applications to question answering. We have demonstrated the modularity of the system by testing both MLNs (Richardson and Domingos 2006) and Probabilistic Soft Logic (Broecheler, Mihalkova, and Getoor 2010) as probabilistic inference engines (Beltagy et al. 2013; Beltagy, Erk, and Mooney 2014).
 all the nuts and bolts necessary to bring together the three distinct components of our approach X  X nd to showcase some of the difficult problems that we face in all three areas, along with our current solutions.
 approach and apply it to a specific task X  X ere, textual entailment (Dagan et al. 2013) X  adding task-specific aspects to the general framework in such a way that the model achieves state-of-the-art performance. We chose the task of textual entailment because it utilizes the strengths of both logical and distributional representations. We specifically use the SICK dataset (Marelli et al. 2014b) because it was designed to focus on lexical knowledge rather than world knowledge, matching the focus of our system.
 uses, and in this article we utilize PPDB (Ganitkevitch, Van Durme, and Callison-Burch 2013) and WordNet, along with distributional models. But we are specifically interested in distributional models, in particular, in how well they can predict lexical and phrasal entailment. Our system provides a unique framework for evaluating distributional models on recognizing textual entailment (RTE) because the overall sentence represen-tation is handled by the logic, so we can zoom in on the performance of distributional models at predicting lexical (Geffet and Dagan 2005) and phrasal entailment. The eval-uation of distributional models on RTE is the third aim of our article. We build a lexical information, and present an in-depth evaluation of the distributional components.
Beltagy et al. 2013). Our framework is three components. The first is the logical form, which is the primary meaning representation for a sentence. The second is the distri-butional information, which is encoded in the form of weighted logical rules (first-order formulas). For example, in its simplest form, our approach can use the distributional similarity of the words grumpy and sad as the weight on a rule that says if x is grumpy, then there is a chance that x is also sad: where ~ grumpy and ~ sad are the vector representations of the words grumpy and sad , sim is a distributional similarity measure, like cosine, and f is a function that maps the similarity score to an MLN weight. A more principled, and in fact, superior, choice is to use an asymmetric similarity measure to compute the weight, as we discuss subsequently.
 using MLNs (Richardson and Domingos 2006), a Statistical Relational Learning tech-nique (Getoor and Taskar 2007) that combines logical and statistical knowledge in one uniform framework, and provides a mechanism for coherent probabilistic infer-ence. MLNs represent uncertainty in terms of weights on the logical rules, as in this example: which states that there is a chance that ogres are grumpy, and friends of ogres tend to be ogres too. Markov logic uses such weighted rules to derive a prob-ability distribution over possible worlds through an undirected graphical model. ences.
 running on SICK, along with gold standard annotations. The training and testing sets are extracted from the SICK training and testing sets, respectively. The total number of rules (training + testing) is 12,510 X  X nly 10,211 are unique with 3,106 entailing rules, 177 contradictions, and 6,928 neutral. This is a valuable resource for testing lexical en-tailment systems, containing a variety of entailment relations (hypernymy, synonymy, antonymy, etc.) that are actually useful in an end-to-end RTE system.
 and Mooney (2011) and Beltagy et al. (2013) (including improvements that improve the scalability of MLN inference [Beltagy and Mooney 2014] and adapt logical constructs for probabilistic inference [Beltagy and Erk 2015]), this article makes the following new contributions: 766 2. Background guistic semantics (Montague 1970; Dowty, Wall, and Peters 1981; Alshawi 1992; Kamp and Reyle 1993) and computational semantics (Blackburn and Bos 2005; van Eijck and Unger 2010), and are commonly used in semantic parsing (Zelle and Mooney 1996;
Berant et al. 2013; Kwiatkowski et al. 2013). They handle many complex semantic phenomena, such as negation and quantifiers, and they identify discourse referents along with the predicates that apply to them and the relations that hold between them.
However, standard first-order logic and theorem provers are binary in nature, which prevents them from capturing the graded aspects of meaning in language: Synonymy seems to come in degrees (Edmonds and Hirst 2000), as does the difference between senses in polysemous words (Brown 2008). van Eijck and Lappin (2012) write:  X  X he case for abandoning the categorical view of competence and adopting a probabilistic model is at least as strong in semantics as it is in syntax. X  Copestake and Flickinger (2000), Bos (2008), and Lewis and Steedman (2013). We use
Boxer (Bos 2008), a wide-coverage semantic analysis tool that produces logical forms, using Discourse Representation Structures (Kamp and Reyle 1993). It builds on the C&amp;C
CCG (Combinatory Categorial Grammar) parser (Clark and Curran 2004) and maps sentences into a lexically based logical form, in which the predicates are mostly words in the sentence. For example, the sentence An ogre loves a princess is mapped to:
As can be seen, Boxer uses a neo-Davidsonian framework (Parsons 1990): y is an event variable, and the semantic roles agent and patient are turned into predicates linking y to the agent x and patient z .
 perform probabilistic inference. Lewis and Steedman (2013) also integrate logical and distributional approaches, but use distributional information to create predicates for a standard binary logic and do not use probabilistic inference. Much earlier, Hobbs et al. (1988) combined logical form with weights in an abductive framework. There, the aim was to model the interpretation of a passage as its best possible explanation. tics on contextual data from large corpora to predict semantic similarity of words and phrases (Landauer and Dumais 1997; Mitchell and Lapata 2010). They are motivated by the observation that semantically similar words occur in similar contexts, so words can be represented as vectors in high dimensional spaces generated from the contexts in which they occur (Lund and Burgess 1996; Landauer and Dumais 1997). Therefore, distributional models are relatively easier to build than logical representations, auto-matically acquire knowledge from  X  X ig data, X  and capture the graded nature of linguistic meaning, but they do not adequately capture logical structure (Grefenstette 2013). tions for larger phrases, for example, by adding the vectors for the individual words (Landauer and Dumais 1997) or by a component-wise product of word vectors (Mitchell and Lapata 2008, 2010), or through more complex methods that compute phrase vec-tors from word vectors and tensors (Baroni and Zamparelli 2010; Grefenstette and Sadrzadeh 2011).
 ful at this point to speculate about phenomena that either a distributional approach or a logic-based approach would not be able to handle in principle, as both frameworks are continually evolving. However, logical and distributional approaches clearly differ in the strengths that they currently possess (Coecke, Sadrzadeh, and Clark 2011; Garrette,
Erk, and Mooney 2011; Baroni, Bernardi, and Zamparelli 2014). Logical form excels at in-depth representations of sentence structure and provides an explicit representation of discourse referents. Distributional approaches are particularly good at representing the meaning of words and short phrases in a way that allows for modeling degrees of similarity and entailment and for modeling word meaning in context. This suggests that it may be useful to combine the two frameworks.
 a theoretical point of view to address meaning, a complex and multifaceted phe-nomenon, through a combination of representations. Meaning is about truth, and logical approaches with a model-theoretic semantics nicely address this facet of meaning.
Meaning is also about a community of speakers and how they use language, and distributional models aggregate observed uses from many speakers.
 and we discuss some of them here.
 inference rules that are combined with logic-based sentence representations, and use probabilistic inference over both. This is the approach that we build on in this article.
Lewis and Steedman (2013), on the other hand, use clustering on distributional data to infer word senses, and perform standard first-order inference on the resulting logical 768 forms. The main difference between the two approaches lies in the role of gradience.
Lewis and Steedman view weights and probabilities as a problem to be avoided. We believe that the uncertainty inherent in both language processing and world knowl-edge should be front and center in all inferential processes. Tian, Miyao, and Takuya (2014) represent sentences using Dependency-based Compositional Semantics (Liang,
Jordan, and Klein 2011). They construct phrasal entailment rules based on a logic-based alignment, and use distributional similarity of aligned words to filter rules that do not surpass a given threshold.
 encode model-theoretic structures rather than observed co-occurrences (Clark 2012;
Grefenstette 2013; Sadrzadeh, Clark, and Coecke 2013; Herbelot and Vecchi 2015), even though they are not strictly hybrid systems as they do not include contextual distributional information. Grefenstette (2013) represents logical constructs using vectors and tensors, but concludes that they do not adequately capture logical structure, in particular, quantifiers.
 et al. (2012) (among others), we also consider perceptual context as part of distributional models, then Cooper et al. (2015) also qualifies as a hybrid logical/distributional ap-proach. They envision a classifier that labels feature-based representations of situations (which can be viewed as perceptual distributional representations) as having a certain probability of making a proposition true, for example smile ( Sandy ). These propositions function as types of situations in a type-theoretic semantics.
 information, we utilize MLNs (Richardson and Domingos 2006). MLNs are well suited for our approach because they provide an elegant framework for assigning weights to first-order logical rules, combining a diverse set of inference rules and performing sound probabilistic inference.

Equation 1 above shows sample weighted rules: Friends of ogres tend to be ogres and ogres tend to be grumpy. Suppose we have two constants, Anna ( A ) and Bob ( B ). Using these two constants and the predicate symbols in Equation 1, the set of all ground atoms we can construct is:
If we only consider models over a domain with these two constants as entities, then each truth assignment to L A , B corresponds to a model. MLNs make the assumption of a one-to-one correspondence between constants in the system and entities in the domain. We discuss the effects of this domain closure assumption below.
 ability P ( X = x ) of an assignment x of values to the sequence X of all variables in the model based on clique potentials, where a clique potential is a function that assigns a value to each clique (maximally connected subgraph) in the graph. Markov Logic
Networks construct Markov Networks (hence their name) based on weighted first order logic formulas, like the ones in Equation (1). Figure 1 shows the network for Equation (1) with two constants. Every ground atom becomes a node in the graph, and two nodes are connected if they co-occur in a grounding of an input formula. In this graph, each clique A variable assignment x in this graph assigns to each node a value of either True or
False, so it is a truth assignment (a world). The clique potential for the clique involving otherwise. This allows for nonzero probability for worlds x in which not all friends of ogres are also ogres, but it assigns exponentially more probability to a world for each ground rule that it satisfies.

F , ... , F n and a set C of constants, and constructs an undirected graphical model in which the set of nodes is the set of ground atoms constructed from F and C . It computes the probability distribution P ( X = x ) over worlds based on this undirected graphical model. The probability of a world (a truth assignment) x is defined as: where i ranges over all formulas F i in F , w i is the weight of F normalizes the values to probabilities). So the probability of a world increases expo-nentially with the total weight of the ground clauses that it satisfies.

In addition, an MLN takes as input an evidence set E asserting truth values for some ground clauses. For example, ogre ( A ) means that Anna is an ogre. Marginal inference for MLNs calculates the probability P ( Q | E , R ) for a query formula Q .
 software package that contains implementations of a variety of MLN inference and learning algorithms. However, developing a scalable, general-purpose, accurate infer-ence method for complex MLNs is an open problem. MLNs have been used for various
NLP applications, including unsupervised coreference resolution (Poon and Domingos 2008), semantic role labeling (Riedel and Meza-Ruiz 2008), and event extraction (Riedel et al. 2009).
 et al. 2013), the task of determining whether one natural language text, the Text T , entails , contradicts , or is not related ( neutral ) to another, the Hypothesis H .  X  X ntailment X  here does not mean logical entailment: The Hypothesis is entailed if a human annotator 770 judges that it plausibly follows from the Text. When using naturally occurring sentences, both logic-based and distributional semantics. Here are examples from the SICK data set (Marelli et al. 2014b): T: A man and a woman are walking together through the woods.

H: A man and a woman are walking through a wooded area. T: Nobody is playing the guitar
H: A man is playing the guitar T: A young girl is dancing H: A young girl is standing on one leg use for evaluation in this article, was designed to foreground particular linguistic phe-nomena but to eliminate the need for world knowledge beyond linguistic knowledge.
It was constructed from sentences from two image description data sets, ImageFlickr and the SemEval 2012 STS MSR-Video Description data. 4 Randomly selected sentences from these two sources were first simplified to remove some linguistic phenomena that the data set was not aiming to cover. Then, additional sentences were created as variations over these sentences, by paraphrasing, negation, and reordering. RTE pairs were then created that consisted of a simplified original sentence paired with one of the transformed sentences (generated from either the same or a different original sentence).

The first is Lai and Hockenmaier (2014), which was the top-performing system at the original shared task. It uses a linear classifier with many hand-crafted features, including alignments, word forms, POS tags, distributional similarity, WordNet, and a unique feature called Denotational Similarity. Many of these hand-crafted features are later incorporated in our lexical entailment classifier, described in Section 5.2. The
Denotational Similarity uses a large database of human-and machine-generated image captions to cleverly capture some world knowledge of entailments.

SICK shared task, and achieved 81.6% accuracy. The RTE system uses Boxer to parse input sentences to logical form, then uses a theorem prover and a model builder to check for entailment and contradiction. The knowledge bases used are WordNet and
PPDB. In contrast with our work, PPDB paraphrases are not translated to logical rules the rule is applied at the text level before parsing the sentence. Theorem provers and model builders have high precision detecting entailments and contradictions, but low recall. To improve recall, neutral pairs are reclassified using a set of textual, syntactic, and semantic features. 3. System Overview
This section provides an overview of our system X  X  architecture, using the following RTE example to demonstrate the role of each component: T : A grumpy ogre is not smiling.
 H : A monster with a bad temper is not laughing.
 Which in logic are: T :  X  x . ogre ( x )  X  grumpy ( x )  X  X  X  y . agent ( y , x )  X  smile ( y )
H :  X  x , y . monster ( x )  X  with ( x , y )  X  bad ( y )  X  temper ( y )  X  X  X  z . agent ( z , x )  X 
This example needs the following rules in the knowledge base KB : r : laugh  X  smile r : ogre  X  monster r : grumpy  X  with a bad temper MLNs constructed by our system for the given RTE example.
 772 1. Logical Representation (Section 4), where input natural sentences T and 2. Knowledge Base Construction KB (Section 5), where the background 3. Inference (Section 6), which uses MLNs to solve the resulting inference mantic representation is that it allows for a highly modular system. Therefore, the most recent advancements in any of the system components, in parsing, in knowledge base resources and distributional semantics, and in inference algorithms, can be easily incorporated into the system.
 logic. Then, we show how to map the three-way RTE classification (entailing, neutral, or contradicting) to probabilistic inference problems. The mapping of sentences to logic differs from standard first order logic in several respects because of properties of the probabilistic inference system. First, MLNs make the Domain Closure Assumption (DCA), which states that there are no objects in the universe other than the named constants (Richardson and Domingos 2006). This means that constants need to be explicitly introduced in the domain in order to make probabilistic logic produce the expected inferences. Another representational issue that we discuss is why we should make the closed-world assumption, and its implications on the task representation. from a variety of sources. We add rules from existing databases, in particular WordNet (Princeton University 2010) and PPDB (Ganitkevitch, Van Durme, and Callison-Burch 2013). To integrate distributional semantics, we use a variant of Robinson resolution to align the Text T and the Hypothesis H , and to find the difference between them, which we formulate as an entailment rule. We then train a lexical and phrasal entailment classifier to assess this rule. Ideally, rules need be contextualized to handle polysemy, but we leave that to future work.
 form the RTE task. We implement an MLN inference algorithm that directly sup-ports querying complex logical formula, which is not supported in the available
MLN tools (Beltagy and Mooney 2014). We exploit the closed-world assumption to help reduce the size of the inference problem in order to make it tractable (Beltagy and Mooney 2014). We also discuss weight learning for the rules in the knowledge base. 4. Logical Representation
The first component of our system parses sentences into logical form and uses this to represent the RTE problem as MLN inference. We start with Boxer (Bos 2008), a rule-based semantic analysis system that translates a CCG parse into a logical form.
The formula is an example of Boxer producing discourse representation structures using a neo-
Davidsonian framework. We call Boxer X  X  output alone an  X  X ninterpreted logical form X  because the predicate symbols are simply words and do not have meaning by 774 themselves. Their semantics derives from the knowledge base KB we build in Section 5.
The rest of this section discusses how we adapt Boxer output for MLN inference. 4.1 Representing Tasks as Text and Query understanding task consists of a text and a query , along with a knowledge base . The text describes some situation or setting, and the query in the simplest case asks whether a particular statement is true of the situation described in the text. The knowledge base encodes relevant background knowledge: lexical knowledge, world knowledge, or both. In the textual entailment task, the text is the Text T , and the query is the Hypothesis
H . The sentence similarity (Semantic Textual Similarity; STS) task can be described as two text/query pairs. In the first pair, the first sentence is the text and the second is the query, and in the second pair the roles are reversed (Beltagy, Erk, and Mooney 2014).
In question answering, the input documents constitute the text and the query has the form H ( x ) for a variable x ; and the answer is the entity e such that H ( e ) has the highest probability given the information in T .
 to both RTE and STS: Given a text T and query H , does the text entail the query given the knowledge base KB ? In standard logic, we determine entailment by checking whether
T  X  KB  X  H . (Unless we need to make the distinction explicitly, we overload notation and use the symbol T for the logical form computed for the text, and H for the logical form computed for the query.) The probabilistic version is to calculate the probability
P ( H | T , KB , W T , H ), where W T , H is a world configuration, which includes the size of the domain. We discuss W T , H in Sections 4.2 and 4.3. Although we focus on the simplest form of text/query inference, more complex tasks such as question answering still have the probability P ( H | T , KB , W T , H ) as part of their calculations.
 categories: entailment, contradiction, and neutral. A decision about entailment can be made by learning a threshold on the probability P ( H | T , KB , W tiate between contradiction and neutral, we additionally calculate the probability
P (  X  H | T , KB , W T ,  X  H ). If P ( H | T , KB , W T , H dicates entailment. The opposite case indicates contradiction. If the two probability values are close, this means T does not significantly affect the probability of H , indicat-ing a neutral case. To learn the thresholds for these decisions, we train an SVM classifier with LibSVM X  X  default parameters (Chang and Lin 2001) to map the two probabilities to the final decision. The learned mapping is always simple and reflects the intuition described here. 4.2 Using a Fixed Domain Size
MLNs compute a probability distribution over possible worlds, as described in Sec-tion 2. When we describe a task as a text T and a query H , the worlds over which the MLN computes a probability distribution are  X  X ini-worlds, X  just large enough to describe the situation or setting given by T . The probability P ( H | T , KB , W describes the probability that H would hold given the probability distribution over the worlds that possibly describe T . 5 The use of  X  X ini-worlds X  is by necessity, as MLNs can only handle worlds with a fixed domain size, where  X  X omain size X  is the number of constants in the domain. (In fact, this same restriction holds for all current practical probabilistic inference methods, including probabilistic soft logic [Bach et al. 2013].) can be described by the Domain Closure Assumption (DCA; Genesereth and Nilsson 1987; Richardson and Domingos 2006): The only models considered for a set F of formulas are those for which the following three conditions hold: (a) Different constants that can be represented using the constant and function symbols in F : and (c) for each function f appearing in F , the value of f applied to every possible tuple of arguments is known, and is a constant appearing in F . Together, these three conditions entail that there is a one-to-one relation between objects in the domain and the named constants of F . When the set of all constants is known, it can be used to ground predicates to generate the set of all ground atoms, which then become the nodes in the graphical model. Different constant sets result in different graphical models. If no constants are explicitly introduced, the graphical model is empty (no random variables).
 consisting of a text T and query H , we need to introduce a sufficient number of constants explicitly into the formula: The worlds that the MLN considers need to have enough constants to faithfully represent the situation in T and not give the wrong entailment for the query H . In what follows, we explain how we determine an appropriate set of constants for the logical-form representations of T and H . The domain size that we determine is one of the two components of the parameter W known technique of skolemization (Skolem 1920). It transforms a formula  X  x to  X  x 1 ... x n . F  X  , where F  X  is formed from F by replacing all free occurrences of y in F by otherwise a Skolem function . Although skolemization is a widely used technique in first-order logic, it is not frequently used in probabilistic logic because many applica-tions do not require existential quantifiers.
 represents the sentence T: An ogre loves a princess , will be skolemized to: where O , L , N are Skolem constants introduced into the domain.
 versal quantifiers to Skolem functions. For example, for the text T: All ogres snore function appeared in a formula, we would have to know its value for any constant in the domain, and this value would have to be another constant. To achieve this, we introduce 776 a new predicate Skolem f instead of each Skolem function f , and for every constant that is an ogre , we add an extra constant that is a loving event. The example then becomes:
If the domain contains a single ogre O 1 , then we introduce a new constant C atom Skolem f ( O 1 , C 1 ) to state that the Skolem function f maps the constant O constant C 1 .
 any variables for the universally quantified x . We still introduce a constant O an ogre . This can be justified by pragmatics because the sentence presupposes that there are, in fact, ogres (Strawson 1950; Geurts 2007). We use the sentence X  X  parse to identify the universal quantifier X  X  restrictor and body, then introduce entities representing the fectively changes to T: All ogres snore, and there is an ogre . At this point, skolemization takes over to generate a constant that is an ogre . Sentences like T: There are no ogres is a special case: For such sentences, we do not generate evidence of an ogre . In this case, the non-emptiness of the domain is not assumed because the sentence explicitly negates it. it affects the behavior of universal quantifiers in the query. Suppose we know that T:
Shrek is a green ogre , represented with skolemization as ogre ( SH )  X  green ( SH ). Then we can conclude that H: All ogres are green , because by the DCA we are only considering models with this single constant, which we know is both an ogre and green . To address this problem, we again introduce new constants.
 all ogres will be green , no matter how many ogres there are in the domain. So H should follow from T 2 : All ogres are green but not from T 1 : There is a green ogre . Therefore we introduce a new constant D for the query and assert ogre ( D ) to test if we can then conclude that green ( D ). The new evidence ogre ( D ) prevents the query from being judged true given T 1 . Given T 2 , the new ogre D will be inferred to be green , in which case we take the query to be true. Again, with a query such as H: There are no ogres , we do not generate any evidence for the existence of an ogre . 4.3 Setting Prior Probabilities
Suppose we have an empty text T , and the query H: A is an ogre , where A is a constant in the system. Without any additional information, the worlds in which ogre ( A ) is true are going to be as likely as the worlds in which the ground atom is false, so ogre ( A ) will have a probability of 0.5. So without any text T , ground atoms have a prior probability in MLNs that is not zero. This prior probability depends mostly on the size of the set F of input formulas. The prior probability of an individual ground atom can be influenced by a weighted rule, for example, ogre ( A ) | X  3, with a negative weight, sets a low prior probability on A being an ogre. This is the second group of parameters that we encode in W T , H : weights on ground atoms to be used to set prior probabilities.
 guage understanding problems. As a reminder, we probabilistically test for entail-ment by computing the probability of the query given the text, or, more precisely, entailment depends on the prior probability of H , P ( H | KB , W a high prior probability, then a high conditional probability P ( H | T , KB , W add much information because it is not clear if the probability is high because T really entails H , or because of the high prior probability of H . In practical terms, we would not want to say that we can conclude from T: All princesses snore that H: There is an ogre just because of a high prior probability for the existence of ogres.
 imately zero, P ( H | KB , W T , H )  X  0, so that we know that any increase in the conditional probability is an effect of adding T . For the task of RTE, where we need to distinguish entailment, neutral, and contradiction, this inference alone does not account for contra-dictions, which is why an additional inference P (  X  H | T , KB , W such that P ( H | KB , W T , H )  X  0 by enforcing the closed-world assumption (CWA). This is the assumption that all ground atoms have very low prior probability (or are false by default).
 assumption that everything is false unless stated otherwise. We translate it to our probabilistic setting as saying that all ground atoms have very low prior probability.
For most queries H , setting the world configuration W T , H have low prior probability is enough to achieve that P ( H | KB , W
H s, and this case is discussed subsequently). For example, H: An ogre loves a princess , in logic is:
Having low prior probability on all ground atoms means that the prior probability of this existentially quantified H is close to zero.
 means for a query to follow from a text: that H should be entailed by T not because of general world knowledge. For example, if T: An ogre loves a princess , and H: Texas is in the USA , then although H is true in the real world, T does not entail H . Another example:
T: An ogre loves a princess , H: An ogre loves a green princess , again, T does not entail H because there is no evidence that the princess is green , in other words, the ground atom green ( N ) has very low prior probability.
 domain size (number of constants in the domain). In logical forms for typical natural language sentences, most variables in the query are existentially quantified. Without the CWA, the probability of an existentially quantified query increases as the domain size increases, regardless of the evidence. This makes sense in the MLN setting, because in larger domains the probability that something exists increases. However, this is not what we need for testing natural language queries, as the probability of the query should depend on T and KB , not the domain size. With the CWA, what affects the probability of H is the non-zero evidence that T provides and KB , regardless of the domain size. 778
Logic Networks first compute all possible groundings of a given set of weighted formu-las, which can require significant amounts of memory. This is particularly striking for problems in natural language semantics because of long formulas. Beltagy and Mooney (2014) show how to utilize the CWA to address this problem by reducing the number of ground atoms that the system generates. We discuss the details in Section 6.2.
H ). Assuming that everything is false by default and that all ground atoms have very low prior probability (CWA) means that all negated queries H are true by default. The result is that all negated H are judged entailed regardless of T . For example, T: An ogre loves a princess would entail H: No ogre snores . This H in logic is:
As both x and y are universally quantified variables in H , we generate evidence of an ogre ogre ( O ) as described in Section 4.2. Because of the CWA, O is assumed to be does not snore , and H ends up being true regardless of T .
 T is just uninformative, we construct a new rule A that implements a kind of anti-CWA.
A is formed as a conjunction of all the predicates that were not used to generate evidence before, and are negated in H . This rule A gets a positive weight indicating that its ground atoms have high prior probability. As the rule A together with the evidence generated from H states the opposite of the negated parts of H , the prior probability of H is low, and H cannot become true unless T explicitly negates A . T is translated into unweighted rules, which are taken to have infinite weight, and which thus can overcome the finite positive weight of A . Here is a neutral RTE example, T: An ogre loves a princess , and H: No ogre snores . Their representations are: T :  X  x , y , z . ogre ( x )  X  agent ( y , x )  X  love ( y )  X  patient ( y , z )  X  princess ( z ) H :  X  x , y . ogre ( x )  X  X  ( agent ( y , x )  X  snore ( y )) E : ogre ( O ) A : agent ( S , O )  X  snore ( S ) | w = 1 . 5
E is the evidence generated for the universally quantified variables in H , and A is the weighted rule for the remaining negated predicates. The relation between T and H is neutral, as T does not entail H . This means, we want P ( H | T , KB , W but because of the CWA, P ( H | T , KB , W T , H )  X  1. Adding A solves this problem and P ( H | T , A , KB , W T , H )  X  0 because H is not explicitly entailed by T . cates, they need to be universally quantified in A for H to have a low prior probability. For example, H: There is an ogre that is not green :
If one variable is universally quantified and the other is existentially quantified, we need to do something more complex. Here is an example, H: An ogre does not snore : that is entailed by T , then T (which has infinite weight) will contradict A , allowing H to be true. Any weighted inference rules in the knowledge base KB will need weights high enough to overcome A . So the weight of A is taken into account when computing inference rule weights.
 for making the inference. For example, take T: No monster snores , and H: No ogre snores , which in logic are: T :  X  X  x , y . monster ( x )  X  agent ( y , x )  X  snore ( y ) H :  X  X  x , y . ogre ( x )  X  agent ( y , x )  X  snore ( y ) A : ogre ( O )  X  agent ( S , O )  X  snore ( S ) | w = 1 . 5 KB :  X  x . ogre ( x )  X  monster ( x )
Without the constants O and S added by the rule A , the domain would have been empty and the inference output would have been wrong. The rule A prevents this problem. In addition, the introduced evidence in A fits the idea of  X  X vidence propagation X  men-tioned earlier (detailed in Section 6.2). For entailing sentences that are negated, as in the example here, the evidence propagates from H to T (not from T to H as in non-negated examples). In the example, the rule A introduces an evidence for ogre ( O ) that then propagates from the LHS to the RHS of the KB rule. 4.4 Textual Entailment and Coreference
The adaptations of logical form that we have discussed so far apply to any natural language understanding problem that can be formulated as text/query pairs. The adaptation that we discuss now is specific to textual entailment. It concerns coreference between text and query.
 speaking T and H are not contradictory because it is possible that the two sentences are referring to different ogres . Although the sentence uses an ogre not the ogre , the annotators make the assumption that the ogre in H refers to the ogre in T . In the
SICK textual entailment data set, many of the pairs that annotators have labeled as contradictions are only contradictions if we assume that some expressions corefer across
T and H . 780  X  H :
Notice how the constant O representing the ogre in T is used in the updated  X  H instead of the quantified variable x .
 ering both coreference between entities and coreference of events. Two items (entities or events) corefer if they (1) have different polarities, and (2) share the same lemma or share an inference rule. Two items have different polarities in T and H if one of them is embedded under a negation and the other is not. For the example here, ogre in T is not negated, and ogre in  X  H is negated, and both words are the same, so they corefer.
 an inference rule. In the example of T: A monster does not snore and H: An ogre snores , we need monster and ogre to corefer. For cases like this, we rely on the inference rules found using the modified Robinson resolution method discussed in Section 5.1. In this case, it determines that monster and ogre should be aligned, so they are marked as coreferring.
Here is another example: T: An ogre loves a princess , H: An ogre hates a princess . In this case, loves and hates are marked as coreferring. 4.5 Using Multiple Parses
In our framework that uses probabilistic inference followed by a classifier that learns thresholds, we can easily incorporate multiple parses to reduce errors due to mispars-ing. Parsing errors lead to errors in the logical form representation, which in turn can lead to erroneous entailments. If we can obtain multiple parses for a text T and query
H , and hence multiple logical forms, this should increase our chances of getting a good estimate of the probability of H given T .
 parser can be configured to produce multiple ranked parses (Ng and Curran 2012); however, we found that the top parses we get from C&amp;C are usually not diverse enough and map to the same logical form. Therefore, in addition to the top C&amp;C parse, we use the top parse from another recent CCG parser, EasyCCG (Lewis and Steedman 2014). each, say S T 1 and S T 2 for T and S H 1 and S H 2 for H , which are transformed to logical representations of N T and N H : the probability of H given T 2 , and conversely also the probabilities of H 2 given either T is textual entailment with the three categories: entailment, neutral, and contradiction, then, as described in Section 4.1, we also compute the probability of  X  H
T 1 or T 2 , and the probability of  X  H 1 2 given either T parses in this manner, the thresholding classifier is simply trained to take in all of these parsers. 5. Knowledge Base Construction
This section discusses the automated construction of the knowledge base, which in-cludes the use of distributional information to predict lexical and phrasal entailment. the Introduction. The first is to show that a general-purpose in-depth natural language understanding system based on both logical form and distributional representations can be adapted to perform the RTE task well enough to achieve state-of-the-art re-sults. To achieve this aim, we build a classifier for lexical and phrasal entailment that includes many task-specific features that have proven effective in state-of-the-second aim is to provide a framework in which we can test different distributional approaches on the task of lexical and phrasal entailment as a building block in a general textual entailment system. To achieve this second aim, in Section 7 we provide an in-depth ablation study and error analysis for the effect of different types of distributional information within the lexical and phrasal entailment classifier.
 network, we do not want to add a large number of inference rules blindly to a given text/query pair. Instead, we first examine the text and query to determine inference rules that are potentially useful for this particular entailment problem. For pre-existing rule collections, we add all possibly matching rules to the inference problem (Sec-tion 5.3). For more flexible lexical and phrasal entailment, we use the text/query pair to determine additionally useful inference rules, then automatically create and weight these rules. We use a variant of Robinson resolution (Robinson 1965) to compute the list of useful rules (Section 5.1), then apply a lexical and phrasal entailment classifier (Section 5.2) to weight them.
 context in which the words appear. After all, the ability to take context into account in a flexible fashion is one of the biggest advantages of distributional models. Un-fortunately the textual entailment data that we use in this article does not lend itself to contextualization X  X olysemy just does not play a large role in any of the existing
RTE data sets that we have used so far. Therefore, we leave this issue to future work. 5.1 Robinson Resolution for Alignment and Rule Extraction
To avoid undo complexity in the MLN, we only want to add inference rules specific to a given text T and query H . Earlier versions of our system generated distributional rules matching any word or short phrase in T with any word or short phrase in H . This includes many unnecessary rules, for example for T: An ogre loves a princess and H:
A monster likes a lady , the system generates rules linking ogre to lady . In this article, we use a novel method to generate only rules directly relevant to T and H : We assume that
T entails H , and ask what missing rule set KB is necessary to prove this entailment. We use a variant of Robinson resolution (Robinson 1965) to generate this KB . Another way of viewing this technique is that it generates an alignment between words and phrases in T and words or phrases in H guided by the logic. 782 testing unsatisfiability that has been used in some previous RTE systems (Bos 2009). It assumes a formula in conjunctive normal form (CNF), a conjunction of clauses, where a clause is a disjunction of literals, and a literal is a negated or non-negated atom. More formally, the formula has the form  X  x 1 , ... , x n C 1  X  ...  X  C has the form L 1  X  ...  X  L k where L i is a literal, which is an atom a
The resolution rule takes two clauses containing complementary literals, and produces a new clause implied by them. Writing a clause C as the set of its literals, we can formulate the rule as: where  X  is a most general unifier of L 1 and  X  L 2 .

T and query H that the two sentences have in common. Instead of one set of clauses, we use two: one is the CNF of T , the other is the CNF of  X  H . The resolution rule is only applied to pairs of clauses where one clause is from T , the other from H . When no further applications of the resolution rule are possible, we are left with remainder formulas rT and rH . If rH contains the empty clause, then H follows from T without inference rules.
Otherwise, inference rules need to be generated. In the simplest case, we form a single inference rule as follows. All variables occurring in rT or rH are existentially quantified, all constants occurring in rT or rH are un-skolemized to new universally quantified variables, and we infer the negation of rH from rT . That is, we form the inference rule where { y 1 ... y m } is the set of all variables occurring in rT or rH , { a of all constants occurring in rT or rH and  X  is the inverse of a substitution  X  : { a x , ... , a n  X  x n } for distinct variables x 1 , ... , x n
This gives us the following two clause sets. Note that all existential quantifiers have been eliminated through skolemization. The query is negated, so we obtain five clauses for T but only one for H .

The resolution rule can be applied four times. After that, C has been unified with z (because we have resolved love ( C ) with love ( z )), B with y (because we have resolved princess ( B ) with princess ( y )), and A with x (because we have resolved agent ( C , A ) with generate is: The modified Robinson resolution thus does two things at once: It removes words that
T and H have in common, leaving the words for which inference rules are needed, and it aligns words and phrases in T with words and phrases in H through unification. content predicates that correspond to content words (nouns, verbs, and adjectives) in the sentences from non-content predicates such as Boxer X  X  meta-predicates agent ( X , Y ).
Resolving on non-content predicates can result in incorrect rules X  X or example, in the case of T: A person solves a problem and H: A person finds a solution to a problem , in CNF:
If we resolve patient ( B , C ) with patient ( y , z ), we unify the problem C with the solution z , leading to a wrong alignment. We avoid this problem by resolving on non-content predicates only when they are fully grounded (that is, when the substitution of variables with constants has already been done by some other resolution step involving content predicates).
 unify two literals only if they are fully grounded or if the literal in T has a unique literal in H that it can be resolved with, and vice versa. This works for most pairs in the SICK data set. In future work, we would like to add search to our algorithm, which will help produce better rules for sentences with duplicate words.
 text/query pair. This rule needs postprocessing, as it is sometimes too short (omitting relevant context), and often it combines what should be several inference rules. the difference between text; and query is too short and needs context to be usable rule is correct, it does not carry enough information to compute a meaningful vector representation for each side. What we would like instead is a rule that infers  X  X un through snow X  from  X  X un in snow. X  example, rT : in ( R , S ) and rH : through ( R , S ). We extend the rule by adding the content words that contain the constants R and S . In this case, we add the running event through ( x , y )  X  snow ( y ).
 we have no general algorithm for when to extend a rule, which would have to take context into account. At this time, we extend all rules as described here. As discussed next, the entailment rules subsystem can itself choose to split long rules, and it may choose to split these extended rules again.
 pair rT and rH , which often conceptually represents multiple inference rules. So we split rT and rH as follows. First, we split each formula into disconnected sets of predicates.
For example, consider T: The doctors are healing a man , H: The doctor is helping the patient, split into heal ( x ) and man ( y ) because the two literals do not have any variable in common and there is no relation (such as agent ()) to link them. Similarly, rH is split into help ( x ) 784 and patient ( y ). If any of the splits has more than one verb, we split it again, where each new split contains one verb and its arguments.
 has at least one variable in common. So, for our example, we obtain  X  x heal ( x )  X  help ( x ) and  X  y man ( y )  X  patient ( y ).
 crucial context information. So we do not perform those additional splits at the level of the logical form, though the entailment rules subsystem may choose to do further splits.
Rules as Training Data. The output from the previous steps is a set of rules { r for each pair T and H . One use of these rules is to test whether T probabilistically entails H . But there is a second use, too: The lexical and phrasal entailment classifier that we describe below is a supervised classifier, which needs training data. So we use the training part of the SICK data set to create rules through modified Robinson resolution, which we then use to train the lexical and phrasal entailment classifier. For simplicity, we translate the Robinson resolution rules into textual rules by replacing each Boxer predicate with its corresponding word.
 individual rules from the labels on RTE pairs (entailment, contradiction, and neutral).
The entailment cases are the most straightforward. Knowing that T  X  r then it must be that all r i are entailing. We automatically label all r as entailing rules.
 entailing. We experimented with automatically labeling all r adds much noise to the training data. For example, if T: A man is eating an apple and H: A guy is eating an orange , then the rule man  X  guy is entailing, but the rule apple  X  orange is non-entailing. So we automatically compare the r i from a neutral pair to the entailing rules derived from entailing pairs. All rules r i found among the entailing rules from entailing pairs are assumed to be entailing (unless n = 1, that is, unless we only have one rule), and all other rules are assumed to be non-entailing. We found that this step improved the accuracy of our system. To further improve the accuracy, we performed a manual annotation of rules derived from neutral pairs, focusing only on the rules that do not appear in entailing. We labeled rules as either entailing or non-entailing. From around 5,900 unique rules, we found 737 to be entailing. In future work, we plan to use multiple instance learning (Dietterich, Lathrop, and Lozano-Perez 1997; Bunescu and Mooney 2007) to avoid manual annotation; we discuss this further in Section 8. such pairs in the SICK data set. In most of the contradiction pairs in SICK, one of the two sentences T or H is negated. For pairs where T or H has a negation, we assume that this negation is negating the whole sentence, not just a part of it. We first consider the case where T is not negated, and H =  X  S h . As T contradicts H , it must hold that T  X  X  H , so T  X  X  X  S h , and hence T  X  S h . This means that we just need to run our modified
Robinson resolution with the sentences T and S h and label all resulting r
H , it must hold that  X  S t  X  X  H , so H  X  S t . Again, this means that we just need to run the modified Robinson resolution with H as the  X  X ext X  and S label all resulting r i as entailing.
 empty and full are antonyms. As before, we run the modified Robinson resolution with
T and H and obtain the resulting r i . Similar to the neutral pairs, at least one of the r contradictory rule, whereas the rest could be entailing or contradictory rules. As for the neutral pairs, we take a rule r i to be entailing if it is among the entailing rules derived so far. All other rules are taken to be contradictory rules. We did not do the manual annotation for these rules because they are few. 5.2 The Lexical and Phrasal Entailment Rule Classifier
After extracting lexical and phrasal rules using our modified Robinson resolution (Section 5.1), we use several combinations of distributional information and lexical resources to build a lexical and phrasal entailment rule classifier ( entailment rule classifier for short) for weighting the rules appropriately. These extracted rules create an especially valuable resource for testing lexical entailment systems, as they contain a variety of entailment relations (hypernymy, synonymy, antonymy, etc.), and are actually useful in an end-to-end RTE system.

Section 5.2.2 describes the lexical resources used. In Section 5.2.3, we describe how our previous work in supervised hypernymy detection is used in the system. In
Section 5.2.4, we describe the approaches for extending the classifier to handle phrases. 5.2.1 Lexical Entailment Rule Classifier. We begin by describing the lexical entailment rule classifier, which only predicts entailment between single words, treating the task as a supervised classification problem, given the lexical rules constructed from the modified
Robinson resolution as input. We use numerous features that we expect to be predictive of lexical entailment. Many were previously shown to be successful for the SemEval 2014 Shared Task on lexical entailment (Marelli et al. 2014a; Bjerva et al. 2014; Lai and
Hockenmaier 2014). Altogether, we use four major groups of features, as summarized in Table 1 and described in detail here.
 LHS and RHS in their original sentences. We extract features for whether the LHS and
RHS have the same lemma, same surface form, same POS, which POS tags they have, and whether they are singular or plural. Plurality is determined from the POS tags. known synonymy, antonymy, hypernymy, or hyponymy relations. We disambiguate between multiple synsets for a lemma by selecting the synsets for the LHS and RHS that minimize their path distance. If no path exists, we choose the most common synset for the lemma. Path similarity, as implemented in the Natural Language Toolkit (Bird, Klein, and Loper 2009), is also used as a feature.
 spaces, one which models topical similarity (bag of words; BoW), and one which models syntactic similarity (Dependency; Dep). We use cosine similarity of the LHS and RHS in both spaces as features.
 binning of the cosines. We create 12 additional binary, mutually exclusive features, which mark whether the distributional similarity is within a given range. We use the ranges of exactly 0, exactly 1, 0.01 X 0.09, 0.10 X 0.19, . . . , 0.90 X 0.99. Figure 4 shows the importance of these histogram features: Words that are very similar (0.90 X 0.99) are much less likely 786 to be entailing than words that are moderately similar (0.70 X 0.89). This is because the most highly similar words are likely to be cohyponyms. 5.2.2 Preparing Distributional Spaces. As described in the previous section, we use dis-tributional semantic similarity as features for the entailment rules classifier. Here we describe the preprocessing steps to create these distributional resources.

Wikipedia. All corpora are preprocessed using the Stanford CoreNLP parser. We collapse particle verbs into a single token, and all tokens are annotated with a (short)
POS tag so that the same lemma with a different POS is modeled separately. We keep only content words (NN, VB, RB, JJ) appearing at least 1,000 times in the corpus. The final corpus contains 50,984 types and roughly 1.5B tokens.
 create one sentence per line. We use Skip-Gram Negative Sampling to create vectors (Mikolov et al. 2013). We use 300 latent dimensions, a window size of 20, and 15 negative samples. These parameters were not tuned, but chosen as reasonable defaults for the task. We use the large window size to ensure the BoW vectors captured more topical similarity, rather than syntactic similarity, which is modeled by the dependency vectors. of the Stanford Collapsed CC Dependency graphs. We filter tuples with lemmas not in our 51k chosen types. Following Baroni and Lenci (2010), we model inverse relations and mark them separately. For example,  X  X ed/JJ car/NN X  will generate tuples for both (car/NN, amod, red/JJ) and (red/JJ, amod  X  1 , car/NN) . After extracting tuples, we discard all but the top 100k (relation, context/POS) pairs and build a vector space using lemma/POS as rows, and (relation, context/POS) as columns. The matrix is transformed with Positive Pointwise Mutual Information, and reduced to 300 dimensions using Singular Value
Decomposition (SVD). We do not vary these parameters, but chose them as they per-formed best in prior work (Roller, Erk, and Boleda 2014). 5.2.3 Asymmetric Entailment Features. As an additional set of features, we also use the representation previously utilized by the asymmetric, supervised hypernymy classifier described by Roller, Erk, and Boleda (2014). Previously, this classifier was only used on artificial data sets, which encoded specific lexical relations, like hypernymy, co-hyponymy, and meronymy. Here, we use its representation to encode just the three general relations: entailment, neutral, and contradiction.
 found that differences between distributional vectors often encode certain linguistic uses two sets of features, &lt; f , g &gt; , where: that is, the vector difference between the LHS and the RHS, and this difference vector squared. Both feature sets are extremely important to strong performance.
 choose the Dep space because we previously found that spaces reduced using SVD 788 outperform word embeddings generated by the Skip-gram procedure. We do not use both spaces, because of the large number of features this creates.
 (2015), and Kruszewski, Paperno, and Baroni (2015) could have also been used in place of these asymmetric features, but we reserve evaluations of these models for future work. scribed in previous sections is limited to only simple rules, where the LHS and RHS are both single words. Many of the rules generated by the modified Robinson res-olution are actually phrasal rules, such as little boy  X  child , or running  X  moving quickly . In order to model these phrases, we use two general approaches: First, we use a state-of-the-art compositional model, in order to create vector representations of phrases, and then include the same similarity features described in the previous section. The full details of the compositional distributional model are described in Section 5.2.5.
 word aligner, similar to the one described by Lai and Hockenmaier (2014). This aligner works by finding the pair of words on the LHS and RHS that are most similar in a distributional space, and marking them as  X  X ligned. X  The process is repeated until at least one side is completely exhausted. For example,  X  X ed truck  X  big blue car, X  we would align  X  X ruck X  with  X  X ar X  first, then  X  X ed X  with  X  X lue, X  leaving  X  X ig X  un-aligned.
 based on the results of the alignment procedure. These include values like the length of the rule, the percent of words unaligned, and so forth. We also compute all of the same features used in the lexical entailment rule classifier (Wordform, WordNet,
Distributional) and compute their min/mean/max across all the alignments. We do not include the asymmetric entailment features as the feature space then becomes extremely large. Table 2 contains a listing of all phrasal features used. 5.2.5 Phrasal Distributional Semantics. We build phrasal distributional space based on the practical lexical function model of Paperno, Pham, and Baroni (2014). We again use as the corpus a concatenation of BNC, ukWaC, and English Wikipedia, parsed with the Stanford CoreNLP parser. We focus on five types of dependency labels (amod, nsubj, dobj, pobj, acomp) and combine the governor and dependent words of these dependencies to form adjective X  X oun, subject X  X erb, verb X  X bject, preposition X  X oun, and verb X  X omplement phrases respectively. We only retain phrases where both the governor and the dependent are among the 50K most frequent words in the corpus, resulting in 1.9 million unique phrases. The co-occurrence counts of the 1.9 million phrases with the 20K most frequent neighbor words in a 2-word window are converted to a Positive Pointwise Mutual Information matrix, and reduced to 300 dimensions by performing
SVD on a lexical space and applying the resulting representation to the phrase vectors, normalized to length 1.
 the contexts in which the word can appear, along with a number of matrices, one for would be one matrix for subjects, and one for direct objects. The representation of the phrase chases dog is then where  X  is matrix multiplication, and when the phrase is extended with cat to form cat chases dog , the representation is
For verbs, the practical lexical function model trains a matrix for each of the relations nsubj , dobj, and acomp , for adjectives a matrix for amod , and for prepositions a matrix for pobj . For example, the amod matrix of the adjective  X  X ed/JJ X  is trained as follows. We collect all phrases in which  X  X ed/JJ X  serves as adjective modifier (assuming the number of such phrases is N ), like  X  X ed/JJ car/NN, X   X  X ed/JJ house/NN, X  and so on, and construct two 300  X  N matrices M arg and M ph , where the i th column of M of the noun modified by  X  X ed/JJ X  in the i th phrase (  X  X  X  car ,
M ph is the vector of phrase i minus the vector of  X  X ed/JJ X  ( etc.), normalized to length 1. Then the amod matrix red can be computed via ridge regression. Given trained matrices, we compute the composition vectors by applying the functions recursively starting from the lowest dependency.
 into multiple rules. We use the dependency parse to split long rules by iteratively 790 searching for the highest nodes in the dependency tree that occur in the logical rule, and identifying the logical rule words that are its descendants in phrases that the practical lexical functional model can handle. After splitting, we perform greedy alignment on phrasal vectors to pair up rule parts. Similar to Section 5.2.4, we iteratively identify the pair of phrasal vectors on the LHS and RHS that have the highest cosine similarity until one side has no more phrases. 5.3 Precompiled Rules
The second group of rules is collected from existing databases. We collect rules from WordNet (Princeton University 2010) and the paraphrase collection PPDB (Ganitkevitch, Van Durme, and Callison-Burch 2013). We use simple string matching the rule is added, and likewise for rules with LHS in H and RHS in T . Rules that go from H to T are important in case T and H are negated (e.g., T : No ogre likes a H to T .
 grouped into sets of synonyms. In addition to grouping synonyms, it lists semantic relations connecting groups. We represent the information on WordNet as  X  X ard X  logical rules. The semantic relations we use are:
One advantage of using logic is that it is a powerful representation that can effectively represent these different semantic relations.
 person riding a bike  X  a biker ). We translate paraphrase collections, in this case PPDB (Ganitkevitch, Van Durme, and Callison-Burch 2013), to logical rules. We use the Lexical, One-To-Many, and Phrasal sections of the XL version of PPDB.

First, we can make the assumption that the translation of a PPDB rule is going to be a conjunction of positive atoms. PPDB does contain some rules that are centrally about negation, such as deselected  X  not selected , but we skip those as the logical form analysis already handles negation. As always, we want to include in KB only rules pertaining to a particular text/query pair T and H . Say LHS  X  RHS is a rule such that LHS is a substring of T and RHS is a substring of H . Then each word in LHS gets represented by a unary predicate applied to a variable, and likewise for RHS  X  X ote that we can expect the same predicates to appear in the logical forms L ( T ) and L ( H ) of the text and
Boxer meta-predicates to the logical form for LHS , and likewise for RHS . Say that L ( T ) riding ( r )  X  patient ( r , b )  X  bike ( b ) and L ( RHS ) = biker ( k ).
 ample above, the variable k in the RHS should be matched with the variable p in the LHS . We determine these bindings using a simple rule-based approach: We man-ually define paraphrase rule templates for PPDB, which specify variable bindings. A rule template is conditioned on the part-of-speech tags of the words involved. left to the first N on the right, unifying the variables p and k . The final paraphrase some variables in the RHS remain unbound, they are existentially quantified (e.g.,  X  p . pizza ( p )  X  X  X  q . slice ( p )  X  of ( p , q )  X  pizza ( q )).
 single MLN weight. We use the simple log-linear equation suggested by Ganitkevitch,
Van Durme, and Callison-Burch (2013) to map the scores into a single value: where r is the rule, N is number of the similarity scores provided for the rule r ,  X  value of the i th score, and  X  i is its scaling factor. For simplicity, following Ganitkevitch,
Van Durme, and Callison-Burch, we set all  X  i to 1. To map this weight to a final MLN rule weight, we use the weight-learning method discussed in Section 6.3.
 get from other resources. For the SICK data set, we only add several lexical rules where one side of the rule is the word nobody , for example, nobody  X  X  somebody and nobody  X  X  person . 6. Probabilistic Logical Inference
We now turn to the last of the three main components of our system, probabilistic logical inference. MLN inference is usually intractable, and using MLN implementations  X  X ut of the box X  does not work for our application. This section discusses an MLN imple-mentation that supports complex queries and uses the CWA to decrease problem size, hence making inference more efficient. Finally, this section discusses a simple weight-learning scheme to learn global scaling factors for weighted rules in KB from different sources. 6.1 Complex Formulas as Queries
Current implementations of MLNs like Alchemy (Kok et al. 2005) do not allow queries to be complex formulas; they can only calculate probabilities of ground atoms. This section discusses an inference algorithm for arbitrary query formulas.
 culate probabilities of ground atoms, they can be used to calculate the probability of 792 a complex formula through a simple work-around. The complex query formula H is added to the MLN using the hard formula where result ( D ) is a new ground atom that is not used anywhere else in the MLN. Then, inference is run to calculate the probability of result ( D ), which is equal to the probability of the formula H . However, this approach can be very inefficient for the most common form of queries, which are existentially quantified queries, for example:
Grounding of the backward direction of the double-implication is very problematic because the existentially quantified formula is replaced with a large disjunction over all possible combinations of constants for variables x , y , and z (Gogate and Domingos 2011). Converting this disjunction to clausal form becomes increasingly intractable as the number of variables and constants grow.
 late the probability of complex query formulas. In MLNs, the probability of a formula is the sum of the probabilities of the possible worlds that satisfy it. Gogate and Domingos (2011) show that to calculate the probability of a formula H given a probabilistic knowl-edge base KB , it is enough to compute the partition function Z of KB with and without H added as a hard formula:
Therefore, all we need is an appropriate algorithm to estimate the partition function Z of a Markov network. Then, we construct two ground networks, one with the query and one without, and estimate their Z s using that estimator. The ratio between the two Z s is the probability of H .

SampleSearch is an importance sampling algorithm that has been shown to be effective when there is a mix of probabilistic and deterministic (hard) constraints, a fundamental property of the inference problems we address. Importance sampling in general is problematic in the presence of determinism, because many of the generated samples violate the deterministic constraints, and they are rejected. Instead, SampleSearch uses a base sampler to generate samples and then uses a backtracking search with a SAT solver to modify the generated sample if it violates the deterministic constraints. We use an implementation of SampleSearch that uses a generalized belief propagation algorithm called Iterative Join-Graph Propagation (Dechter, Kask, and Mateescu 2002) as a base sampler. This version is available online (Gogate 2014).
 large disjunction because of the existentially quantified variables. So we replace H with its negation  X  H , replacing the existential quantifiers with universals, which are easier to ground and perform inference upon. Finally, we compute the probability of the query P ( H ) = 1  X  P (  X  H ). Note that replacing H with  X  H cannot make inference with the standard work-around faster, because with  X  H , the direction  X  H  X  result ( D ) suffers from the same problem of existential quantifiers that we previously had with
H  X  result ( D ). 6.2 Inference Optimization Using the Closed-World Assumption
This section explains why our MLN inference problems are computationally difficult, and then explains how the CWA can be used to reduce the problem size and speed up inference. For more details, see Beltagy and Mooney (2014).
 query H . The number of ground clauses of a first-order formula is exponential in the number of variables in the formula; it is O ( c v ), where c is the number of constants in the domain and v is the number of variables in the formula. For a moderately long formula, the number of resulting ground clauses is infeasible to process.
 natural language text/query pairs, it makes sense to make the closed-world assump-tion: If we want to know if the query is true in the situation or setting laid out in the text, we should take as false anything not said in the text. In our probabilistic setting, the CWA amounts to giving low prior probabilities to all ground atoms unless they can be inferred from the text and knowledge base. However, we found that a large fraction of the ground atoms cannot be inferred from the text and knowledge base, and their probabilities remain very low. As an approximation, we can assume that this small probability is exactly zero and these ground atoms are false, without significantly affecting the probability of the query. This will remove a large number of the ground atoms, which will dramatically decrease the size of the ground network and speed up inference.
 from the text and the knowledge base T  X  KB . For example: from T . Ground atom monster ( O ) is also not false because it can be inferred from T  X  KB . All other ground atoms are false.
 the inferred ones, then simplifying the expression, we obtain: H : monster ( O )  X  agent ( S , O )  X  snore ( S ). Notice that most ground clauses of H are removed because they are false. We are left just with the ground clauses that potentially have a non-zero probability. Dropping all false ground clauses leaves an exponentially smaller number of ground clauses in the ground network. Even though the inference problem remains exponential in principle, the problem is much smaller in practice, such that inference becomes feasible. In our experiments with the SICK data set, the number of ground clauses for the query ranges from 0 to 19,209 with mean 6. This shows that the CWA effectively reduces the number of ground clauses for the query from millions (or even 794 billions) to a manageable number. With the CWA, the average number of inferrable ground atoms (ignoring ground atoms from the text) ranges from 0 to 245 with an average of 18. 6.3 Weight Learning
We use weighted rules from different sources, both PPDB weights (Section 5.3) and the confidence of the entailments rule classifier (Section 5.2). These weights are not necessarily on the same scale X  X or example, one source could produce systematically larger weights than the other. To map them into uniform weights that can be used within an MLN, we use weight learning. Similar to the work of Zirn et al. (2011), we learn a single mapping parameter for each source of rules that functions as a scaling factor:
We use a simple grid search to learn the scaling factors that optimize performance on the RTE training data.
 dence scores, and PPDB weights can be scaled), we also try the following mapping:
This function assures that for an MLN with a single rule LHS  X  RHS | MLNweight , it is the case that P ( RHS | LHS ) = ruleWeight , given that scalingFactor = 1. 7. Evaluation
This section evaluates our system. First, we evaluate several lexical and phrasal dis-tributional systems on the rules that we collected using modified Robinson resolution.
This includes an in-depth analysis of different types of distributional information within the entailment rule classifier. Second, we use the best configuration we find in the first step as a knowledge base and evaluate our system on the RTE task using the SICK data set.
 and 4,927 for testing. Pairs are annotated for RTE and STS tasks. We use the RTE annotations of the data set. 7.1 Evaluating the Entailment Rule Classifier
The entailment rule classifier described in Section 5.2 constitutes a large portion of the full system X  X  end-to-end performance, but consists of many different feature sets providing different kinds of information. In this section, we thoroughly evaluate the entailment rule classifier, both quantitatively and qualitatively, to identify the individual and holistic value of each feature set and systematic patterns. However, this evaluation may also be used as a framework by future lexical semantics research to see its value in end-to-end textual entailment systems. For example, we could have also included features corresponding to the many measures of distributional inclusion that were developed to predict hypernymy (Weeds, Weir, and McCarthy 2004;
Kotlerman et al. 2010; Lenci and Benotto 2012; Santus 2013), or other supervised lexical entailment classifiers (Baroni et al. 2012; Fu et al. 2014; Weeds et al. 2014; Levy et al. 2015; Kruszewski, Paperno, and Baroni 2015).
 entailment rule classifier on all rules, both lexical and phrasal. We then break down these results into performance on only lexical rules and only phrasal rules. Finally, we look at only the asymmetric features to address concerns raised by Levy et al. (2015).
In all sections, we evaluate the lexical rule classifier on its ability to generalize to new word pairs, as well as the full system X  X  performance when the entailment rule classifier is used as the only source of knowledge.
 rule classifier and the end-to-end system, especially when word relations are not explic-itly found in WordNet. The introduction of syntactic distributional spaces and cosine binning are especially valuable, and greatly improve performance over our own prior work. Contrary to Levy et al., we find the asymmetric features provide better detection of hypernymy over memorizing of prototypical hypernyms, but the prototype vectors better capture examples which occur very often in the data; explicitly using both does best. Finally, we find, to our surprise, that a state-of-the-art compositional distributional method (Paperno, Pham, and Baroni 2014) yields disappointing performance on phrasal entailment detection, though it does successfully identify non-entailments deriving from changing prepositions or semantic roles. 7.1.1 Experimental Set-up. We use the gold standard annotations described in Section 5.1.
We perform 10-fold cross-validation on the annotated training set, using the same folds in all settings. Because some RTE sentence pairs require multiple lexical rules, we ensure that cross-validation folds are stratified across the sentences, so that the same sentence cannot appear in both training and testing. We use a Logistic Regression classifier with an L2 regularizer. 6 Because we perform three-way classification, we train models using one-vs-all.
 classifier performs in the cross-validation setting on the training data. This corresponds to treating lexical and phrasal entailment as a basic supervised learning problem. RTE accuracy is accuracy on the end task of textual entailment using the predictions of the entailment rule classifier. For RTE accuracy, the predictions of the entailment rule clas-sifier were used as the only knowledge base in the RTE system. RTE training accuracy uses the predictions from the cross-validation experiment, and for RTE test accuracy the entailment rule classifier was trained on the whole training set. 7.1.2 Overall Lexical and Phrasal Entailment Evaluation. Table 3 shows the results of the
Entailment experiments on all rules, both lexical and phrasal. In order to give bounds on our system X  X  performance, we present baseline score (entailment rule classifier always predicts non-entailing) and ceiling score (entailment rule classifier always predicts gold standard annotation).
 tion) does not achieve perfect performance. This is because of a number of different 796 issues including misparses, imperfect rules generated by the modified Robinson resolu-tion, a few system inference timeouts, and various idiosyncrasies of the SICK data set. task. This is unsurprising, as synonymy and hypernymy information from WordNet gives nearly perfect information for much of the task. There are some exceptions, such as woman 9 man , or black 9 white , which WordNet lists as antonyms, but which are not considered contradictions in the SICK data set (e.g.,  X  X : A man is cutting a tomato X  and  X  X : A woman is cutting a tomato X  is not a contradiction). However, even though exhaustive: About a quarter of the rules have at least one pair of words for which WordNet relations could not be determined.
 accuracy of 77.7 (Table 3). This indicates that, even with only distributional similarity, we do well enough to score in the upper half of systems in the original SemEval shared task, where the median test accuracy of all teams was 77.1 (Marelli et al. 2014a).
Two components were critical to the increased performance over our own prior work: first, the use of multiple distributional spaces (one topical, one syntactic); second, the binning of cosine values. When using only the BoW cosine similarity as a feature, the classifier actually performs below baseline (50.0 intrinsic accuracy [IA]; compare to Table 4). Similarly, only using syntactic cosine similarity as a feature also performs poorly (47.2 IA). However adding binning to either improves performance (64.3 and 64.7 for BoW and Dep), and adding binning to both improves it further (68.8 IA, as reported in Table 4).
 art Paperno, Pham, and Baroni (2014) compositional vector space, perform somewhat disappointingly on the task. We discuss possible reasons for this below in Section 7.1.4. in Tables 1 and 2) do not do particularly well on their own. This is encouraging, as it means the data set cannot be handled by simply expecting the same words to appear on the LHS and RHS. Finally, we note that the features are highly complementary, and the combination of all features gives a substantial boost to performance. 7.1.3 Evaluating the Lexical Entailment Rule Classifier. Table 4 shows performance of the classifier on only the lexical rules, which have single words on the LHS and RHS. In these experiments we use the same procedure as before, but omit the phrasal rules from the data set. On the RTE tasks, we compute accuracy over only the SICK pairs that require at least one lexical rule. Note that a new ceiling score is needed, as some rules require both lexical and phrasal predictions, but we do not predict any phrasal rules.
 rules still perform better than the baseline, but the gap between distributional features and WordNet is much more apparent. Perhaps most encouraging is the very high per-formance of the Asymmetric features: by themselves, they perform substantially better than just the distributional features. We investigate this further below in Section 7.1.5. complementary, and intrinsic accuracy is greatly improved by using all the features together. It may be surprising that these significant gains in intrinsic accuracy do not translate to improvements on the RTE tasks; in fact, there is a minor drop from using all features compared to only using WordNet. This most likely depends on which pairs the system gets right or wrong. For sentences involving multiple lexical rules, errors become disproportionately costly. As such, the high-precision WordNet predictions are slightly better on the RTE task.
 tures to a classifier with the full feature set, we found that, as expected, the distributional features miss many hypernyms and falsely classify many co-hyponyms as entailing:
We manually analyzed a sample of 170 pairs that the distributional classifier falsely classifies as entailing. Of these, 67 were co-hyponyms (39%), 33 were antonyms (19%), and 32 were context-specific pairs like stir/fry . On the other hand, most (87%) cases of entailment that the distributional classifier detects but the all-features classifier misses are word pairs that have no link in WordNet. These pairs include note  X  paper , swimmer  X  racer , eat  X  bite , and stand  X  wait . 7.1.4 Evaluating the Phrasal Entailment Rule Classifier. Table 5 shows performance when looking at only the phrasal rules. As with the evaluation of lexical rules, we evaluate the
RTE tasks only on sentence pairs that use phrasal rules, and do not provide any lexical inferences. As such, the ceiling score must again be recomputed.
 none of the feature sets on their own provide dramatic improvements over the baseline, 798 together does better than any of the feature groups by themselves, indicating again that the feature groups are highly complementary.
 that possibly the Distributional features may simply be proxies for the same lemma and same POS features. A qualitative analysis comparing the predictions of Wordform and Distributional features shows otherwise though: the Wordform features are best at correctly identifying non-entailing phrases (higher precision), and the distributional features are best at correctly identifying entailing phrases (higher recall).
Baroni do not perform as well as just the alignment-based distributional lexical features; in fact, they do not perform even as well as features that make predictions using only
Wordform features. We qualitatively compare the Paperno, Pham, and Baroni features (or phrasal features for short) to the features based on word similarity of greedily aligned words (or alignment features). We generally find the phrase features are much more likely to predict neutral, and the alignment-based features are much more likely to predict entailing. In particular, the phrasal vectors seem to be much better at capturing non-entailment based on differences in prepositions ( walk inside building building ), additional modifiers on the RHS ( man 9 old man , room changing semantic roles ( man eats near kitten 9 kitten eats ). Surprisingly, we found the lexical distributional features were better at capturing complex paraphrases, such as teenage  X  in teens , ride bike  X  biker , or young lady  X  teenage girl . 7.1.5 Evaluating the Asymmetric Classifier. Levy et al. (2015) show several experiments suggesting that asymmetric classifiers do not perform better at the task of identifying hypernyms than when the RHS vectors alone are used as features. That is, they find that the asymmetric classifier and variants frequently learn to identify prototypical hypernyms rather than the hypernymy relation itself. We look at our data in the light of the Levy et al. study, particularly as none of the entailment problem sets used by Levy et al. were derived from an existing RTE data set.
 Asymmetric features with a classifier using only cosine similarity, we found that the
Asymmetric classifier does substantially better at distinguishing hypernymy from co-hyponymy. This is what we had hoped to find, as we had previously found an Asym-metric classifier to perform well at identifying hypernymy in other data (Roller, Erk, and Boleda 2014), and cosine is known to heavily favor co-hyponymy (Baroni and Lenci 2011). However, we also find that cosine features are better at discovering synonymy, and that Asymmetric frequently mistakes antonymy as an entailing. We did a quantita-tive analysis comparing the predictions of a classifier using only Asymmetric features to a classifier that tries to learn typical hyponyms or hypernyms by using only the LHS vectors, or the RHS vectors, or both. Table 6 shows the results of these experiments. some learning of the entailment relationship by the asymmetric classifier (particularly on the intrinsic evaluation), as opposed to the prototypical hypernym hypothesis. We believe this is because the data set is too varied to allow the classifier to learn what an entailing RHS looks like. Indeed, a qualitative analysis shows that the asymmetric features successfully predict many hypernyms that RHS vectors miss. On the other hand, the RHS do manage to capture particular semantic classes, especially on words that appear many times in the data set, like cut, slice, man, cliff, and weight . components: It is given freedom to nearly memorize rules that appear commonly in the data. Still, using all three sets of features (Asym + LHS + RHS) is most powerful by a substantial margin. This feature set is able to capture the frequently occurring items, while also allowing some power to generalize to novel entailments. For example, by using all three we are able to capture some additional hypernyms ( beer  X  drink , pistol  X  gun ) and synonyms ( couch  X  sofa , throw  X  , hurl ), as well as some more diffi-cult entailments ( hand  X  arm , young  X  little ).
 the features in the system. In particular, it seems to do particularly poorly on antonyms ( strike 9 miss ), and items that require additional world knowledge ( surfer  X  man ). It also occasionally misclassifies some co-hyponyms ( trumpet 9 guitar ) or gets the entailment direction wrong ( toy 9 ball ). 7.2 RTE Task Evaluation
This section evaluates different components of the system, and finds a configuration of our system that achieves state-of-the-art results on the SICK RTE data set.
 MLN-based logic system that computes two inference probabilities (Section 4.1). This 800 includes the changes to the logical form to handle the domain closure assumption (Section 4.2), the inference algorithm for query formulas (Section 6.1), and the in-ference optimization (Section 6.2). The component cws deals with the problem that the closed-world assumption raises for negation in the hypothesis (Section 4.3), and coref is coreference resolution to identify contradictions (Section 4.4). The component multiparse signals the use of two parsers, the top C&amp;C parse and the top EasyCCG parse (Section 4.5).
 the rules from the best performing entailment rule classifier trained in Section 7.1. This is the system with all features included. The ppdb component adds rules from
PPDB paraphrase collection (Section 5.3). The wlearn component learns a scaling factor for ppdb rules, and another scaling factor for the eclassif rules that maps the clas-sification confidence scores to MLN weights (Section 6.3). Without weight learning, (infinite weight). The wlearn log component is similar to wlearn but uses Equation (11), which first transforms a rule weight to its log odds. The wn component adds rules from WordNet (Section 5.3). In addition, we have a few handcoded rules (Section 5.3).
Like wn , the components hyp and mem repeat information that is used as features for entailment rules classification but is not always picked up by the classifier. As the classifier sometimes misses hypernyms, hyp marks all hypernymy rules as entailing (so this component is subsumed by wn ), as well as all rules where the left-hand side and the right-hand side are the same. (The latter step becomes necessary after splitting long rules derived by our modified Robinson resolution; some of the pieces may have equal left-hand and right-hand sides.) The mem component memorizes all entailing rules seen in the training set of eclassif .
 inference run. If inference does not finish processing within the time limit, we terminate the process and return an error code. About 1% of the data set times out. 7.2.1 Ablation Experiment without eclassif. Because eclassif has the most impact on the system X  X  accuracy, and when enabled suppresses the contribution of the other compo-nents, we evaluate the other components first without eclassif . In the following section, we add the eclassif rules. Table 7 summarizes the results of this experiment. The results show that each component plays a role in improving the system accuracy. Our best accuracy without eclassif is 80.4%. Without handling the problem of negated hypothe-ses ( logic alone), P (  X  H | T ) is almost always 1 and this additional inference becomes use-less, resulting in an inability to distinguish between neutral and contradiction. Adding cwa significantly improves accuracy because the resulting system has P (  X  H | T ) equal to 1 only for contradictions.
 of false negatives. We also note that applying weight learning ( wlearn ) to find a global scaling factor for PPDB rules makes them more useful. The learned scaling factor is 3.0. When the knowledge base is lacking other sources, weight learning assigns a high scaling factor to PPDB, giving it more influence throughout. When eclassif is added in the following section, weight learning assigns PPDB a low scaling factor because eclassif already includes a large set of useful rules, such that only the highest weighted
PPDB rules contribute significantly to the final inference. false negatives are due to misparses. Using two different parses reduces the impact of the misparses, improving the system accuracy. 7.2.2 Ablation Experiment with eclassif. In this experiment, we first use eclassif as a knowl-edge base, then incrementally add the other system components. Table 8 summarizes the results. First, we note that adding eclassif to the knowledge base KB significantly improves the accuracy from 73.4% to 83.0%. This is higher than what ppdb and wn achieved without eclassif . Adding handcoded still improves the accuracy somewhat. previous experiment (without eclassif ). The improvement on the test set decreases from 1.6% to 0.7%. Therefore, the rules in eclassif help reduce the impact of misparses. Here is an example to show how: T: An ogre is jumping over a wall , H: An ogre is jumping over the fence which in logic are: T :  X  x , y , z . ogre ( x )  X  agent ( y , x )  X  jump ( y )  X  over ( y , z )  X  wall ( z ) 802
T should entail H (strictly speaking, wall is not a fence but this is a positive entailment example in SICK). The modified Robinson resolution yields the following rule:
F :  X  x , y . jump ( x )  X  over ( x , y )  X  wall ( y )  X 
Note that in T , the parser treats over as a preposition, whereas in H , jump over is inference because of this inconsistency in the parsing. The rule F reflects this parsing inconsistency. When F is translated to text for the entailment classifier, we obtain jump over wall  X  jump over fence , which is a simple phrase that the entailment classifier addresses without dealing with the complexities of the logic. Without the modified
Robinson resolution, we would have had to resort to collecting  X  X tructural X  inference rules like  X  x , y . over ( x , y )  X  over ( x )  X  patient ( x , y ).
 should not add anything over eclassif , but they do add some accuracy because of noise in the training data of eclassif .
 components help improve the system X  X  accuracy. It is interesting to see that even though the SICK data set is not designed to evaluate  X  X egree of entailment, X  it is still useful to keep the rules uncertain (as opposed to using hard rules) and use probabilistic inference. Results also show that wlearn log performs slightly better than wlearn .
 captures all the useful rules that we were getting from ppdb . It is interesting to see that simple distributional information can subsume a large paraphrase database like PPDB. Adding wn (not shown in the table) leads to a slight decrease in accuracy.
 wlearn log , and mem achieves a state-of-the-art accuracy score of 85.1% on the SICK test set. The entailment rule classifier eclassif plays a vital role in this result. 8. Future Work
One area to explore is contextualization. The evaluation of the entailment rule classifier showed that some of the entailments are context-specific, like put/pour (which are entailing only for liquids) or push/knock (which is entailing in the context of  X  X ushing a toddler into a puddle X ). Cosine-based distributional features were able to identify some of these cases when all other features did not. We would like to explore whether contextualized distributional word representations, which take the sentence context into account (Erk and Pad  X  o 2008; Thater, F  X  urstenau, and Pinkal 2010; Dinu, Thater, and Laue 2012), can identify such context-specific lexical entailments more reliably.
 known that cosine similarity gives high ratings to co-hyponyms (Baroni and Lenci 2011), and our evaluation confirmed that this is a problem for lexical entailment judgments, as co-hyponyms are usually not entailing. However, co-hyponymy judgments can be used to position unknown terms in the WordNet hierarchy (Snow, Jurafsky, and Ng 2006).
This could be a new way of using distributional information in lexical entailment: using cosine similarity to position a term in an existing hierarchy, and then using the relations in the hierarchy for lexical entailment. Although distributional similarity is usually used only on individual word pairs, this technique would use distributional similarity to learn the meaning of unknown terms, given that many other terms are already known. system to other tasks, in particular, the question answering task. This task is interesting because it may offer a wider variety of tasks to the distributional subsystem. Existing logic-based systems are usually applied to limited domains, such as querying a specific database (Berant et al. 2013; Kwiatkowski et al. 2013), but with our system, we have the potential to query a large corpus because we are using Boxer for wide-coverage semantic analysis. The general system architecture discussed in this article can be ap-plied to the question answering task with some modifications. For knowledge base con-struction, the general idea of using theorem proving to infer rules still applies, but the details of the technique would be a lot different from the modified Robinson resolution in section 5.1. For the probabilistic logic inference, scaling becomes a major challenge. probabilistic logic. Some determiners, such as  X  X ew X  and  X  X ost, X  cannot be represented in standard first-order logic, and are usually addressed using higher-order logics. But it could be possible to represent them using the probabilistic aspect of probabilistic logic, sidestepping the need for higher-order logic. 9. Conclusion
Being able to effectively represent natural language semantics is important and has many important applications. We have introduced an approach that uses probabilistic logic to combine the expressivity and automated inference provided by logical represen-tations, with the ability to capture graded aspects of natural language captured by distri-butional semantics. We evaluated this semantic representation on the RTE task, which requires deep semantic understanding. Our system maps natural-language sentences to logical formulas, uses them to build probabilistic logic inference problems, builds a knowledge base from precompiled resources and on-the-fly distributional resources, then performs inference using Markov logic. Experiments demonstrated state-of-the-art performance on the recently introduced SICK RTE task.
 Acknowledgments References 804 806
