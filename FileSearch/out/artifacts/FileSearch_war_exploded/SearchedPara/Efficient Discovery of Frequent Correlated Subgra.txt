
The use of graph-based representation has gained increas-ing popularity in various application domains, including bio-informatics [1], [2], chemistry [3], [4], drug design [5], [6], social network analysis [7], and many more. As a result, graph pattern mining has become an important research problem. Existing studies on graph pattern mining mainly focus on finding frequent subgraphs [8], [9], [10], [11], [12] and its closed or maximal variations [13], [14], [15], while little attention has been paid to finding other types of useful graph patterns.

In traditional pattern mining, correlated patterns have also been recognized as an important type of patterns. Correlated pattern mining has been extensively studied in market-basket data [16], [17], [18], [19], [20], [21] and recently introduced to the context of graph data [22], [23]. A pair of subgraphs are correlated if their occurrence distributions are similar, which means that they are often co-present and co-absent, and thus have mutual implication on their occurrences. Given a query graph , existing work CGSearch [22] (or its top-k version [23]) returns all (or top-k) correlated graphs with respect to the query graph . Both of the studies assume the existence of an interesting subgraph to be served as the query graph. In practice, however, such apriori knowledge may not always be available.

In this paper, we study a new problem of discovering all frequent correlated subgraph pairs. Unlike the existing work, the new problem does not require the specification of a query graph. Instead, it aims to discover all correlations, which is a more general setting and more practical. The problem is formulated as follows: Given a graph database D that contains a set of graphs, a minimum correlation threshold  X  , and a minimum support threshold  X  , find all pairs of frequent subgraphs whose correlation is at least  X  .The usage of  X  allows a user to control the occurrence probability (also called support ) of an interesting subgraph, while  X  is used to specify how similar the occurrence distribution of a pair of correlated subgraphs is wanted. Thus, a frequent correlated subgraph pair is also called a (  X ,  X  )-subgraph pair . The correlation between two graphs is measured by a function of the individual support of the two graphs and their joint support. In this paper, we use the well-known Pearson X  X  correlation coefficient  X  [24] as the correlation measure.

The (  X ,  X  )-subgraph pairs are very useful in a wide range of applications. The following gives a concrete example in medicinal chemistry.
 Example 1. Fig. 1(a) and (b) show a pair of correlated submolecules discovered from a real chemical compound structure database in the National Cancer Institute. Each vertex in the figure represents a carbon atom and each edge represents a single bond. Being a (  X ,  X  )-subgraph pair, it means that these two submolecules often accompany with each other in a specific set of compounds in the database. Interestingly, we find that these two submolecules represent a class of biologically active compounds, which is depicted in Fig. 1(c). This class contains Dihydrocholesterol analogues, which are cholesterol derivatives found in human feces, gallstones, eggs, and other biological matter.
Example 1 shows several usages of (  X ,  X  )-subgraph pairs in medicinal chemistry. First, a (  X ,  X  )-subgraph pair is able to indicate the existence of a class of interesting compounds, of which may be unaware by the chemist. Therefore, it can direct the attention of the chemist to these hidden classes, which may lead to the discovery of new substances or drugs. Second, the (  X ,  X  )-subgraph pair captures the active structures of its represented compound class and thus can serve as building blocks (representative / functional sub-molecules) of the compound class, which is particularly useful in compound synthesis. Third, the set of all (  X ,  X  )-subgraph pairs can automatically form clusters of biologi-cally active or well-investigated structures. This can be used as a summarization of the database so that the chemist can gain a biological insight of how the compounds are medically connected. Furthermore, the whole set of (  X ,  X  )-subgraph pairs can also guide chemists about their choices of submolecules when synthesizing new compounds. The co-occurrences of correlated submolecules indicate that they are relatively easy to synthesize. Therefore, chemists can be saved from a tremendous number of laboratorial tests by using correlated submolecules.

Being aware of the usefulness of graph correlations, re-searchers in medicinal chemistry have tried to discover cor-related submolecules from compound databases [25]. How-ever, the lack of efficient mining techniques hinders them from investigating more general structured submolecules, which inspires our work of discovering all (  X ,  X  )-subgraph pairs.

However, finding all (  X ,  X  )-subgraph pairs is a challenging problem. First, the number of frequent subgraphs in D can be large due to the high diversity in the structure of graph data. Second, for a specific subgraph f , every frequent subgraph is a candidate to form a (  X ,  X  )-subgraph pair with f . That is, the candidate set of f , C f , is equal to the set of all frequent subgraphs, F . This results in an explosion in the number of candidates for subgraph pairs, which is |F| X |F| .Third, unlike the support measure, the correlation measure does not have the anti-monotone property. That means if a graph g is found to be uncorrelated with f , we cannot prune all supergraphs of g as does in frequent subgraph mining, since they may still be correlated with f . As a result, the size of the candidate set, |C f | , cannot be effectively reduced. The lack of this powerful pruning property makes the design of an efficient algorithm very difficult.

There are two straightforward solutions to the problem based on the existing work of frequent subgraph mining [8], [9], [10], [11], [12] and query-based correlation mining [22].
The first one is a naive solution, which is a frequent-subgraph-mining-based approach. The idea is to first mine the set of all frequent subgraphs F using an existing mining algorithm and then check the correlation values among all pairs of frequent subgraphs. However, this approach has several drawbacks. First, mining all frequent subgraphs can be expensive. Second, checking pairwise correlations among all frequent subgraphs is usually infeasible since the number of all possible pairs can be prohibitively large, especially when  X  is small. Furthermore, the joint support of each pair of subgraphs needs to be computed during correlation checking, which takes at least (  X   X |D| ) number of intersec-tions on the projected databases of the two subgraphs. Here, the projected database of a subgraph is defined to be the set of graphs in D that contain the subgraph. Therefore, the computational complexity of this naive approach is extremely high.

Another more feasible solution, which is a CGSearch-based approach, is to explore the subgraph space and feed each frequent subgraph into the query-based correlation min-ing algorithm, CGSearch [22]. This approach is inefficient as well since each invocation of CGSearch involves an expensive operation to mine the projected database of the query graph. Moreover, every correlated subgraph pair is computed twice by this approach since each of the subgraph in the pair is feeded as a query once.

In this paper, we propose an approximate but efficient solution to the problem. Given a frequent subgraph f ,we define its answer set , denoted as A f ,tobethesetof subgraphs that form (  X ,  X  )-subgraph pairs with f .Themain idea of our approach is to compute the exact answer sets of only a small number of frequent subgraphs by CGSearch and use these exact answer sets to approximate the answer sets of the remaining frequent subgraphs. In this way, our approach is able to skip invoking CGSearch for most of the frequent subgraphs, which saves tremendous computational costs compared with the above-mentioned CGSearch-based approach. Furthermore, our approach significantly reduces the size of the candidate sets from the whole set F to a much smaller set, which is far superior to the frequent-subgraph-mining-based approach.

The mechanism of skipping the processing of most fre-quent subgraphs has its theoretical foundations. We inves-tigate the characteristics of correlated subgraphs and find that correlativeness tends to have the  X  transitive  X  property. More specifically, if two subgraphs f 1 and f 2 are found to be correlated with the same subgraph f , they are likely to be correlated as well. This observation is verified theoretically by deriving a tight lower bound of the correlation  X  ( f 1 The lower bound guarantees that an arbitrary pair of graphs f 1 and f 2 has a high correlation as long as they are both correlated with a third graph f , i.e., they appear in the answer set of the same graph f . Therefore, it is theoretically sound to approximate the answer sets of f 1 and f 2 using the answer set of f .

Based on the theoretical results, we develop an effi-cient algorithm to mine Frequent Correlated subgraph Pairs, namely FCP-Miner . The algorithm traverses the subgraph space in a depth-first manner. It processes a new subgraph f by CGSearch to obtain its exact answer set A f . Then, all graphs in A f are marked to be  X  skipped  X . Thus, FCP-Miner processes only those new frequent subgraphs that are not marked as  X  skipped  X , while for each newly processed frequent subgraph FCP-Miner adds a bunch of graphs to the skip list. For each skipped graph f i  X  X  f , FCP-Miner uses A f as the candidate set of f i . Its approximated answer set is then computed from this much smaller candidate set. In this way, FCP-Miner is able to skip most of the graphs from processing CGSearch and thus significantly improves the mining efficiency. However, it is possible for FCP-Miner to miss some subgraph pairs due to the approximation on the answer sets of the skipped graphs.

Our extensive experiments show that the number of miss-ing pairs by FCP-Miner is very small. More importantly, we find that the correlation values of the missing pairs are close to  X  , which means that they are just boundary pairs. This result indicates a high-quality of the approximation and the effectiveness of FCP-Miner. Furthermore, compared with the CGSearch-based approach that processes every frequent subgraph, FCP-Miner is over an order of magnitude faster because of the effective skipping mechanism. On average, about 80% of the frequent subgraphs can be skipped by FCP-Miner and the average candidate set size of the subgraphs is reduced by over 98%. This result demonstrates the efficiency of FCP-Miner.

The contributions of the paper are as follows.
The rest of the paper is organized as follows. Section II gives some preliminaries on graph database and frequent subgraphs. Section III defines the problem of frequent cor-related subgraph pair discovery. Section IV presents our solution and its theoretical foundations. Section V evaluates the performance of our approach. Section VI reviews some related work. Finally, Section VII concludes the paper.
Graphs studied in this paper are undirected, labeled and connected. A graph g is defined as a triple ( V, E, l ), where V is the set of vertices, E is the set of edges and l is a labeling function that assigns a label to each vertex and edge.
Given two graphs, g =( V, E, l ) and g =( V ,E ,l ) , g is called a subgraph of g (or g is a supergraph of g ), denoted as g  X  g (or g  X  g ), if there exists an injective function f : V  X  V , such that  X  ( u, v )  X  E , ( f ( u ) ,f ( v ))  X  E , l l ( f ( u )) , l ( v )= l ( f ( v )) , and l ( u, v )= l ( f ( injective function f is called a subgraph isomorphism from g to g . Testing subgraph isomorphism between two graphs is known to be NP-complete [26].
 A graph database D is a collection of graphs, denoted as D = { g 1 ,g 2 ,...,g N } .Given D and a graph g , we define the projected database of g as the set of graphs in D that are supergraphs of g , denoted as D g = { g : g  X  X  ,g  X  g } . The size of the projected database is called the frequency of g in D , denoted as freq ( g )= |D g | .The support of g in
D is further defined as supp ( g )= freq ( g ) probability of a graph in D being the supergraph of g .A graph g is called a Frequent subGraph ( FG )[8]in D if supp ( g )  X   X  , where  X  ( 0  X   X   X  1 ) is a user-specified minimum support threshold .Weuse F to denote the set of all FGs in D with respect to  X  .

Given two graphs g and g , we define their joint frequency as the number of graphs in D that are common supergraphs of g and g , denoted as freq ( g, g )= |D g  X  X  g | .The joint support of g and g is defined as supp ( g, g )= freq ( g,g The support measure is anti-monotone , that is, g  X  g im-plies that supp ( g )  X  supp ( g ) . We also have the following properties of the joint support: supp ( g, g )  X  supp ( supp ( g, g )  X  supp ( g ) .

In this paper, we adopt Pearson X  X  correlation coefficient [24] as the correlation measure, defined as follows. Definition 1. (Pearson X  X  Correlation Coefficient) Given a pair of graphs g 1 and g 2 ,the Pearson X  X  correlation coeffi-cient of g 1 and g 2 , denoted as  X  ( g 1 ,g 2 ) , is defined as When supp ( g 1 ) or supp ( g 2 ) is equal to 0 or 1 ,  X  ( defined to be 0 .

It is easy to see that  X  is symmetric. The value of  X  ( g is in the range of [  X  1 , 1] . When supp ( g 1 ,g 2 )= supp ( the occurrences of g 1 and g 2 are independent to each other. The positive value of  X  ( g 1 ,g 2 ) indicates that the occurrences of g 1 and g 2 are positively correlated, i.e., they are often co-present and co-absent. On the other hand, the negative value shows negative correlation, i.e., g 1 often occurs without g and vice versa. In this paper, we focus on finding positive correlations.

We now present two useful properties of the  X  function, which can be proved easily by taking the derivative of  X  . Property 1. If both supp ( g 1 ) and supp ( g 2 ) are fixed,  X  ( g 1 ,g 2 ) is monotonically increasing with supp ( g 1 ,g Property 2. If both supp ( g 1 ) and supp ( g 1 ,g 2 ) are fixed,  X  ( g 1 ,g 2 ) is monotonically decreasing with supp ( g 2 ) .
The problem of finding frequent correlated subgraph pairs can be formalized as follows.
 Frequent Correlated Subgraph Pair Discovery Given a graph database D = { g 1 ,g 2 ,...,g N } , a minimum corre-lation threshold  X  ( 0  X   X   X  1 ), and a minimum support threshold  X  ( 0  X   X   X  1 ), find all pairs of subgraphs f and f 2 in D such that supp ( f 1 )  X   X  , supp ( f 2 )  X   X  ( f 1 ,f 2 )  X   X  .
 We call such a pair of subgraphs a (  X ,  X  ) -subgraph pair. Given a frequent subgraph f , we call the set of subgraphs that form (  X ,  X  ) -subgraph pairs with f the answer set of f , denoted as A f = { f : supp ( f )  X   X ,  X  ( f, f )  X   X  } . Thus, the problem of frequent correlated subgraph pair discovery is essentially to find the A f for each frequent subgraph f . We also use C f to denote the set of candidate graphs that may potentially form (  X ,  X  ) -subgraph pairs with f .
In this section, we first derive the lower bound of the correlation among all subgraph pairs in the same answer set and then present our mining algorithm, FCP-Miner.
 A. Correlation Lower Bound of Subgraph Pairs
Given a frequent subgraph f , we aim to derive a corre-lation lower bound of an arbitrary pair of graphs f 1 and f in
A f , denoted as lower and useful, the lower bound should be a function of the two known variables, supp ( f ) and the minimum correlation threshold  X  . For clarity of presentation, we let a = supp (
We first review two useful lemmas proposed in CGSearch [22]. One lemma gives the bounds on the support of a graph f  X  X  f , while the other gives the bounds on the joint support of f and f  X  X  f .
 Lemma 1. Given a graph f  X  X  f , the following lower and upper bounds of supp ( f ) , denoted respectively as Lemma 2. Given a graph f  X  X  f , the following lower and upper bounds of the joint support supp ( f, f ) , denoted
The above two lemmas specify only the bounds with respect to a single graph f  X  X  f , while the relationship between two graphs in A f is still lacking, which is exactly what we try to get.

Given an arbitrary pair of graphs f 1 and f 2 in A f ,bythe definition of  X  , we need to know the values of their indi-supp ( f 1 ,f 2 ) , in order to obtain the value of  X  ( f cording to Property 1,  X  ( f 1 ,f 2 ) is monotonically increasing with supp ( f 1 ,f 2 ) . Therefore, in order to get the lower bound of  X  ( f 1 ,f 2 ) , we first derive a lower bound of supp ( which is stated in the following theorem.
 Theorem 1. Given a graph f and two graphs f 1 , f 2 in A f the following lower bound of supp ( f 1 ,f 2 ) holds: supp ( f 1 ,f 2 )  X  supp ( f, f 1 )+ supp ( f, f 2 )  X  supp ( The equality holds when ( D f 1  X  X  f 2 )  X  X  f  X  ( D f 1  X  D support, (6) holds if and only if the following inequality holds.
To prove (7), we decompose |D f | as follows. |D f | X |D f  X  ( D f
Equation (8) holds since the intersection of D f with any set is a subset of D f . Equation (9) is by the distributive law of the set intersection over the set union. Equation (10) is by the inclusion-exclusion principle. Equation (11) holds since ( D follows.
 The equality holds when ( D f 1  X  X  f 2 )  X  X  f for (8) and D f  X  ( D f 1  X  X  f 2 ) for (11). Therefore, the equality holds
Theorem 1 serves as a bridge between supp ( f 1 ,f 2 the two joint support supp ( f, f 1 ) and supp ( f, f 2 bounds are known in Lemma 2.

By Property 1 and the definition of  X  , we can replace supp ( f 1 ,f 2 ) with the results in Theorem 1 into  X  and obtain the following inequality.
Although (12) already specifies a lower bound of  X  ( f 1 ,f 2 ) , it is not a useful one since all the variables except a in this lower bound are unknown. Therefore, we need to make further derivations.

The right side of (12) is monotonically increasing with supp ( f, f 1 ) and supp ( f, f 2 ) and is monotonically decreas-ing with supp ( f 1 ) and supp ( f 2 ) if other variables are fixed. Therefore, we can simply replace these variables in (12) respectively with lower supp ( f,f 1 ) , lower mas 1 and 2. However, the lower bound of  X  derived in this way is not tight. This is because the joint support supp ( f, f 1 ) is dependent on the individual support supp ( f 1 ) . As a result, lower supp ( cannot be achieved simultaneously. The case is the same for of  X  ( f 1 ,f 2 ) derived in this simple way is a loose one and has no guarantee.

Based on the above analysis, we need to resolve the dependency of the joint support and the individual support in (12) so as to obtain a tight bound. This can be accomplished as follows. Recall that both f 1 and f 2 are in A f , which implies that  X  ( f, f 1 )  X   X  and  X  ( f, f 2 )  X   X  . By the definition of  X  , we have the following inequality: supp ( f, f 1 )  X   X  a (1  X  a ) supp ( f 1 )(1  X  supp ( f 1
The right hand side of (13) is a function of supp ( which can be used to resolve the dependency problem. The equality holds when  X  ( f, f 1 )=  X  . We have similar results for supp ( f, f 2 ) . By replacing supp ( f, f 1 ) and supp ( with (13) in (12), we obtain the following inequality of  X  ( f 1 ,f 2 ) . For clarity, we let x = supp ( f 1 ) and y supp ( f 2 ) .  X  (
The equality holds when ( D f 1  X  X  f 2 )  X  X  f  X  ( D f 1  X  X  and  X  ( f, f 1 )=  X  ( f, f 2 )=  X  .

The right hand side of (14) is a function of x and y , denoted as h ( x, y ) . More importantly, the variables x and y can take independent values in the function h . In order to utilize the bounds in Lemma 1 to obtain a tight lower bound of  X  ( f 1 ,f 2 ) , we need to know the monotonicity of x and y in h ( x, y ) . Since x and y are symmetric in h ( x, y only consider the monotonicity of x , which is given in the following lemma.
 Lemma 3. Let t = a (1  X  y ) (1  X  a ) y . The following two statements about the monotonicity of x in h ( x, y ) are true: (1) The function h is monotonically increasing with x in (2) The function h is monotonically decreasing with x in apply the differentiation to the function h with respect to x and obtain the following equality.
The sign of h ( x ) is the same as the sign of the numerator in (15), denoted as M =( a  X  y )+ a (1  X  y )(  X  (1  X  a ) y  X  a (1  X  y ))(2  X  x
We first show that (  X  (1  X  a ) y  X  a (1  X  y ))  X  0 .It is easy to see that the left hand side of this inequality monotonically increases with y . The inequality follows when we replace y with its upper bound upper supp ( f 2 ) as given in Lemma 1.

In order to have M  X  0 , it is equivalent to have the following inequalities.

By taking the derivative of the function t = a (1  X  y ) (1  X  find that t is monotonically decreasing with y . By Lemma 1, the bounds of y in t , we have  X   X  t  X   X   X  1 . Therefore, (16) is always positive.

By (16), it follows that M  X  0 or equivalently h ( x )  X  0 if and only if Following the similar derivation, we can get that M  X  0 or equivalently h ( x )  X  0 if and only if the monotonicity of x in h thus follows.

According to Lemma 3, when y is fixed, the minimum value of h ( x, y ) can be achieved at either x = lower supp ( or x = upper supp ( f 1 ) . Since the variable y is independent of x , the minimum value of h ( x, y ) can only occur at four points, which are combinations of x and y taking their lower and upper bounds. Since x and y are symmetric, there are essentially three possible points. We summarize the lower bound of  X  ( f 1 ,f 2 ) in the following theorem.
 Theorem 2. Given a graph f and two graphs f 1 , f 2 in its answer set A f , the following two statements of the lower bound of  X  ( f 1 ,f 2 ) , denoted as lower  X  ( f 1 ,f 2 ) (1) If a  X  1 2 , then (2) If a&lt; 1 2 , then h ( x, y ) , which can only be achieved in either of the following three cases as discussed above.
 Lemma 1 and (14), we have
Since the second term (  X   X  1  X   X  ) 2 (1  X  a ) in (17) is non-negative, we have (  X  2  X  (  X   X  1  X   X  ) 2 (1  X  a ))  X   X  2 indicates that (18) does not specify a minimum value of h .
We now consider (17) and (19) and have the following derivations.  X  1  X  a  X  a  X  a  X  1
Thus, when a  X  1 2 , (19) serves as the lower bound of h . By (14),  X  ( f 1 ,f 2 ) is equal to h if and only if ( D D The condition of (19), i.e., x = y = upper supp ( f 1 ) , implies that  X  ( f, f 1 )=  X  ( f, f 2 )=  X  holds. By replacing the values of x and y in (6), we have supp ( f 1 ,f 2 )= a , which ensures
Accordingly, when a&lt; 1 2 , (17) is the lower bound of  X  ( f 1 ,f 2 ) . By (6), this lower bound is achieved when x = y
Theorem 2 provides a tight lower bound of the correlation between two arbitrary graphs f 1 and f 2 in the same answer set A f of a graph f . It indicates that all the graphs in have a correlation guarantee, which is not very far away from the threshold  X  . For example, if  X  =0 . 9 and a =0 . the lower bound computed by Theorem 2 is 0 . 79 , which is still pretty high.
 B. Our Algorithm We first describe an exact algorithm that utilizes CGSearch for all FGs to mine the set of all (  X ,  X  ) -subgraph pairs. Then, we make use of the theoretical results we obtain in the previous section to design an efficient approximate algorithm.

The exact algorithm has the following two components: (1) FG-Enumerator : the algorithm for enumerating all FGs; and (2) CGSearch [22]: an existing algorithm for mining the set of all correlated subgraphs of a given query graph f .The exact algorithm operates as follows. For each FG f returned by FG-Enumerator, find the set of all correlated subgraphs of f using CGSearch, and return those correlated subgraphs that have support at least  X  .

The FG-Enumerator in the exact algorithm is used to enumerate the subgraphs in the pattern space in a depth-first manner similar to an FG mining algorithm such as gSpan [11]. However, it is different from an FG mining algorithm in the sense that it does not count the support of every FG, which is a very costly operation since it involves many subgraph isomorphism tests. FG-Enumerator works with CGSearch closely as follows. When the correlated subgraphs of f are returned by CGSearch, their support is obtained as well. Therefore, FG-enumerator does not need Algorithm 1 FCP-Miner Input: D ,  X  and  X  .
 Output: A set of (  X ,  X  ) -subgraph pairs. to re-calculate the support of these subgraphs when they are explored later. Thus, FG-enumerator is more efficient than an FG mining algorithm to be incorporated with CGSearch for the purpose of mining (  X ,  X  )-subgraph pairs.

Since pairwise correlation is symmetric, the exact al-gorithm at least processes each same (  X ,  X  ) -subgraph pair twice. In fact, a careful investigation will find that such redundant processing extends to sets of mutually correlated FGs. For example, if k FGs are mutually correlated, the exact algorithm needs to process k ( k  X  1) pairs. If duplicate pairs are processed only once, then we only process k ( k pairs, but we still need to invoke CGSearch k times, which is still very expensive.

According to our finding in Theorem 2, given an FG f and the set of its correlated subgraphs A f computed by CGSearch, the correlated subgraphs in A f have high correlation with each other. Thus, we can utilize the answer set A f of a discovered FG f as the candidate sets of all the subgraphs in A f . That is, we make C f i = A f ,  X  f i  X  X  this way, we reduce the candidate sets of many subgraphs from the whole set of all FGs F to a much smaller set A f We describe our algorithm, FCP-Miner , as follows.

FCP-Miner operates in a similar way to the exact algo-rithm except that we apply a skipping mechanism in Line 4 of Algorithm 1. That is, for all FGs returned by FG-Enumerator, we skip those FGs that already appear in the answer set of some previously processed FGs. These skipped FGs are kept in a hashtable once they are discovered to be correlated with some FG during the mining process (Lines 10-12), and they are skipped in Line 4 by checking the hashtable. The FGs are hashed into the hashtable by their canonical label (we use the minimum DFS code in gSpan [11]).

In other words, in Algorithm 1, we apply a heuristic implied by Theorem 2 which approximates the answer set of a skipped FG by the union of all its correlated subgraphs found in the answer sets of those processed FGs (Line 14). Therefore, if the FGs in the answer set of an FG indeed share high mutual correlation, then a huge amount of redundant processing can be avoided. For example, in the example of the k mutually correlated FGs mentioned earlier, we only need to invoke CGSearch once to obtain all the (  X ,  X  subgraph pairs among these k subgraphs.
 Complexity Analysis. We analyze the complexity of FCP-Miner with comparison to the exact algorithm. For the exact algorithm, the complexity is O ( h 1 ( F )+ |F| h 2 ( n h ( F ) is the complexity of exploring the set of FGs F using FG-Enumerator, and h 2 ( n ) is the complexity for obtaining n correlated subgraphs using CGSearch, assuming that n is the average number of correlated subgraphs of an FG in F .
For FCP-Miner, due to the use of the skipping mechanism, the complexity is reduced to O ( h 1 ( F )+ mh 2 ( n )) m is the number of those FGs that are not skipped. In general, m is significantly smaller than |F| and therefore tremendous saving is obtained, since the dominant factor in the complexity of the exact algorithm is |F| h 2 we show in the following section, m is only a very small percentage of |F| in our experiments.

We evaluate the performance of our FCP-Miner algorithm on various metrics. The algorithm was implemented in C++. We ran all experiments on an AMD Opteron 248 with 8GB RAM, running Linux 64-bit.
 Baseline of Comparison. Since this is the first proposal to mine (  X ,  X  ) -subgraph pairs, we compare with the exact algorithm described in Section IV-B, denoted by Exact in our experiments. By comparing with Exact, we can demonstrate the effectiveness of the skipping mechanism in FCP-Miner as well as the approximation quality of FCP-Miner. We note that we do not compare with the frequent-subgraph-mining-based approach described in Section I because its complexity is
O ( h 3 ( F )+ |F| 2  X  |D| ) , where h 3 ( F ) is the complexity of mining F using an FG mining algorithm. This computational complexity is higher than that of Exact since FG-Enumerator is faster than an FG mining algorithm for the purpose of pattern enumeration in mining (  X ,  X  ) -subgraph pairs, and n is significantly smaller than |F| . The frequent-subgraph-mining-based algorithm runs extremely slow for some of the datasets we test, especially when |F| is large and/or |D| large.
 Graph Databases. We test two real datasets most popularly used in the literature for evaluating FG and correlated-subgraph mining algorithms: AIDS and NCI . AIDS is the AIDS antiviral screen dataset , which contains 10K graphs. The NCI dataset contains 100K graphs, which we obtain from the National Cancer Institute database. Table I lists some characteristics of the datasets and more details can be found in their webpages 1 .
 A. Effect of  X 
For the two parameters in a (  X ,  X  ) -subgraph pair, we first test the effect of the first parameter  X  on the performance of FCP-Miner. We decrease  X  from 0.1 down to 0.005, by fixing  X  at 0.8. We use the AIDS dataset for this experiment.
Fig. 2 reports the total running time and the peak memory consumption of mining (  X ,  X  ) -subgraph pairs using FCP-Miner and Exact, respectively. The result clearly shows that FCP-Miner is significantly faster than Exact and more scalable as we lower the value of  X  . FCP-Miner is almost an order of magnitude faster than Exact at a moderate  X  of 0.025 and the improvement increases to 17.6 times when  X  =0 . 005 . The memory consumption of the two algorithms is comparable, which is proportional to the number of FGs mined.

We further analyze the effectiveness of our approach by recording the following experimental findings, as reported in Table II: (1) %ofskip : the percentage of FGs skipped by the skipping mechanism in FCP-Miner, calculated as (  X ,  X  ) -subgraph pairs not found by FCP-Miner, calculated as the average  X  value of the missing pairs; (4) avg  X  of all : the average  X  value of all (  X ,  X  ) -subgraph pairs; (5) cand reduced : the percentage of the candidates reduced by FCP-Miner from the whole set of FGs, computed as average size of the answer set of an FG.
We now analyze the effectiveness of FCP-Miner by the results reported in Table II. First, the performance improve-ment shown in Fig. 2(a) can be explained by %ofskip , which shows that on average about 80% of the FGs are skipped by the skipping mechanism of FCP-Miner. It also shows that the percentage of FGs being skipped is higher for smaller  X  , which is due to the fact that the average size of the answer set of an FG, avg ans size , is also larger for smaller  X  . In addition, cand reduced indicates that FCP-Miner is very effective in reducing the correlation search space. Over 98% of the FGs are pruned from the candidate set so that a large number of correlation checking are successfully avoided.
Although the percentage of FGs being skipped is high, % of miss shows that the percentage of (  X ,  X  ) -subgraph pairs missed by FCP-Miner is small, which is about 4% in most cases. Importantly, avg  X  of miss shows that the missing (  X ,  X  ) -subgraph pairs have the lowest  X  values, which is close to  X  =0 . 8 , while avg  X  shows that the average  X  value of all (  X ,  X  ) -subgraph pairs is much higher than  X  .
In summary, these results reveal that FCP-Miner is effi-cient since most of the FGs are skipped, and effective since the percentage of missing (  X ,  X  ) -subgraph pairs is small and the missing pairs are barely correlated with respect to the minimum correlation threshold  X  .
 B. Effect of  X 
We now test the effect of the second parameter in a (  X ,  X  subgraph pair,  X  , on the performance of FCP-Miner. We lower  X  from 0.9 down to 0.6, by fixing  X  at 0.025. We use the AIDS dataset for this experiment.

Fig. 3 reports the total running time and the peak memory consumption of FCP-Miner and Exact for the different values of  X  . Again, the result shows that FCP-Miner is significantly faster than Exact, and also more scalable to the change of  X  , especially when  X  is smaller. The improvement of FCP-Miner over Exact is about an order of magnitude faster at  X  =0 . 8 , and the difference doubles when  X  is lowered to 0.6. The memory consumption of FCP-Miner is also lower.
 The effectiveness of FCP-Miner is assessed in Table III. When  X  is high, the number of correlated subgraphs of each FG is small, as confirmed by avg ans size . Since FCP-Miner skips those FGs that appear in the answer set of the non-skipped FGs, the percentage of skipped FGs is also relatively smaller at higher values of  X  , as shown by %of skip . However, this does not indicate that FCP-Miner is not effective for high values of  X  . In fact, the percentage of candidates reduced by FCP-Miner is high for a high  X  of 0.9.

Table III also verifies that the percentage of the missing pairs remains to be low for all  X  values. The missing (  X ,  X  subgraph pairs are minimally correlated since their  X  values are merely above the minimum correlation threshold  X  .Note that the average  X  value of all (  X ,  X  ) -subgraph pairs is much greater than the respective  X  .
 C. Effect of Database Size
We also test the effect of database size on the performance of FCP-Miner. We create six NCI datasets, with sizes ranging from 10K to 100K graphs. The values of  X  and  X  are fixed at 0.05 and 0.8, respectively.

Fig. 4 shows that both the running time and the peak memory consumption of FCP-Miner and Exact increase linearly when the size of the database increases. The result shows that in all cases, FCP-Miner is almost an order of magnitude faster than Exact, though the memory con-sumption is comparable. The speed-up ratio of FCP-Miner over Exact remains rather stable when the database size increases, which is due to the fact that the number of all (  X ,  X  ) -subgraph pairs does not vary significantly for different database sizes (this is also true with the number of FGs). This is further confirmed by the stable values of avg ans size over the different database sizes as shown in Table IV.
The results in Table IV show that FCP-Miner is able to skip most of the FGs during the mining process, while keeping a low percentage of missing (  X ,  X  ) -subgraph pairs. The  X  values of the missing pairs are also low as compared with the average  X  value of all pairs. Therefore, we conclude that FCP-Miner is also both efficient and effective for mining (  X ,  X  ) -subgraph pairs with varying database sizes.

In the literature, correlated pattern mining has been widely studied in various types of databases. For market-basket data, a correlated pattern [16], [17], [18], [19], [20], [21] is composed of two or more basket items. Efficient algorithms were proposed to discover all correlated itemsets defined by various correlation measures such as the  X  2 test [16], [17], the m -pattern measure [18], h-confidence [19], Pear-son X  X  correlation coefficient [20], [21], etc. For stream data [27], [28], lagged correlation based on Pearson X  X  correlation coefficient was proposed to study the lead-lag relationship between two time series. For multimedia data [29], corre-lation between multimedia objects was investigated for the task of automatic captioning of media data. Our work is incomparable to these studies due to different natures of data types.

In the context of graph databases, there are only three existing studies on correlation discovery, the stepwise cor-related pattern mining [30], CGSearch [22], and the top-k version of CGSearch [23]. The work of [30] discovered top-k subgraphs that are correlated to a class attribute and used them as features for graph classification. CGSearch and its top-k version studied the correlation between a subgraph and a given query graph. Our work, on the other hand, does not require the user to specify a class attribute or a query graph but aims to discover all frequent correlated subgraph pairs, which is a more general and harder problem.

In this paper, we study the new problem of mining the set of frequent correlated subgraph pairs from a graph database, which finds potential usage in many important applications. We propose an efficient algorithm, FCP-Miner, to solve the problem. The algorithm employs a very effective skipping mechanism, which is devised based on a tight theoretical bound established on the minimum correlation between any two subgraphs in the answer set of a graph. We conduct extensive experiments, which verify that FCP-Miner is able to skip the processing of about 80% of the frequent subgraphs. Our algorithm is approximate, but it achieves a high quality of approximation, since the rate of missing results is very low (around 2-4% in most cases) and the missing pairs are shown to be marginally correlated. However, the efficiency gained from the approximation is that FCP-Miner is over an order of magnitude faster than the exact algorithm in most cases and it is also more scalable for various metrics.

The project was supported by the grant of RGC (No. 419008), Hong Kong SAR, China.

