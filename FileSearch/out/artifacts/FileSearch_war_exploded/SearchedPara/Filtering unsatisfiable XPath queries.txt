 1. Introduction XSLT, XQuery, XLink and XPointer) for specifying node sets in XML documents. An important issue in the satisfiability test of XPath queries with or without respect to schemas, e.g. [2,10,11,14,17,18] . inconsistent with the XML data model (e.g. [14] ). For example, the XPath query Q1 = /parent::a is unsatisfiable, because the document node has no parent node according to the XML data model. The query
Q2 = //regions/america is tested as a satisfiable XPath query without respect to a schema. However, according to a given schema, e.g. the schema given in [8] , the element regions can have children, which are called namerica and samerica , but does not have children with name america . Therefore, Q2 is unsat-
The most widely used schema languages are XML Schema (see [31,32] ) and DTD (see [28] ). In this paper, and semantics on XML documents as DTDs do, the XML Schema language provides powerful capabilities for specifying data types on elements and attributes, most of which are not expressible in DTDs. The XML inition, the XPath query selects an empty set of nodes for any valid XML document. For example, the query meeting[@date = 0 01-05-06 0 ] does not retrieve anything if the type of the attribute date is more restrictions than a DTD, a DTD can be easily transformed into an XML Schema representation, but in general, an XML Schema definition cannot be transformed into a DTD without loosing information. To the
Our schema-based approach checks whether or not an XPath query Q conforms to the structure, semantics, ity test for the XPath subset supported by our approach in the presence of the schemas supported by our elements and arbitrary nesting of model groups; by supporting the type-checking of values of elements and new contributions into the prototype of [11] and by additional experiments (see Section 6 ). The rest of the paper is organized as follows: Section 2 describes the supported subsets of XPath and XML
Schema. Section 3 develops a data model for XML Schema. This data model for XML Schema is the basis for our XPath X  X Schema evaluator (see Section 4 ), which evaluates XPath queries on XML Schema definitions in order to compute the schema paths of the queries. Section 4 also includes a complexity analysis of the prehensive performance analysis in Section 6 . Section 7 deals with further related work. We end up with the summary and conclusions in Section 8 . 2. XPath and XML Schema
In this section, we present the subset of the XPath language and the subset of XML Schema language sup-ported in this work. 2.1. XPath XPath language, and the abstract syntax of the supported XPath subset is defined in EBNF as follows: Pattern e :: = e j e j / e j e / e j e [ q ] j a :: n .

Predicate q :: = e j e = C j e = e j q and q j qorq j not ( q )
Axis a :: = child j attribute j descendant j self j following
Nodetest n :: = label j * j node () j text (). write DoS for descendant-or-self , AoS for ancestor-or-self , FS for following-sibling and PS for preceding-sibling .
 q , ... , q i , e.g. child::title and descendant::section[child:: location step.
 sents / descendant-or-self::node() /. Whenever possible, we will use the abbreviated syntax in this paper as more compact representation. 2.2. XML Schema
XML Schema (see [31,32] ) is a language for defining a class of XML documents, called instance documents of the schema. We call a schema, which is formulated in the XML Schema language, an XML Schema defi-and attributes. In this paper, we support a significant subset of the XML Schema language, where a given
XSchema must conform to the following EBNF rules. where QName (see [32] ) is an XML qualified name, NCName (see [32] ) is an XML non-colonized name, Bool-acter string, and Value is a value, e.g. a number or a string.
 Example 1. Fig. 1 presents an example of an XML Schema definition bib.xsd , which describes a schema for
XML documents containing information about journal articles. Fig. 2 contains an example XML document, which conforms to the XML Schema definition of Fig. 1 . 3. Data model for the XML Schema language Based-on the data model for the XML language given by Waddler [24] , we develop a data model for XML Schema for identifying the navigation paths of XPath queries on an XML Schema definition. 3.1. Notations
The following notations on sets, relationships and sequences are used to model the XML Schema definition, for membership and [ for the union of sets. We express the signature of a function f by f : T
XSchema node (Node) , an XPath expression (XPath) or a node test (NodeTest) . Furthermore, T can be the type of a set the entries of which are of a type T are of a type T 1 , i.e. Sequence(T 1 ), or the cross-product of two or more types, e.g. T closure f + and reflexive transitive closure f * of a function f : T ! Set(T) are defined as follows:
We write ( x 1 , ... , x m ) for a sequence of entries x 1 quences, e.g. ( x 1 , ... , x m )+( y 1 , ... , y n )=( x s[1] indicates the first entry of s and s[ j s j ] indicates the last entry of s , s[ entry of s , and so on. Furthermore, we also call a node in an XML Schema definition an XSchema node . 3.2. Concepts An XML Schema definition is a set of nodes of type Node . There are three specific Node types in an XML
XML Schema definition: iElement, iAttribute and iText . Accordingly, we define three functions with signature Node ! Boolean to test the type of a node: isiElement , isiAttribute , and isiText , which return true if the type of the given node is of type iElement , iAttribute or iText , respectively, otherwise false.

Definition 1 ( instance nodes ). The instance nodes of an XML Schema definition are  X  h element name = N ... i (which is an instance element node of type  X  h attribute name = N ... i (which is an instance attribute node of type  X  attribute node type = T of nodes h element type = T ... instance text node of type iText ,if T is a built-in simple type),  X  h simpleType ... i (which is an instance text node of type  X  h complexType mixed = 0 true 0 ... i (which is an instance text node of type  X  h simpleContent ... i (which is an instance text node of type  X  h complexContent mixed = 0 true 0 ... i (which is an instance text node of type node of x .
 then y is an instance text node of x .
 element defined in x , then y is an instance attribute node of x . following sibling node, respectively, of y .
 the XML Schema definition if  X 
N2 is a child node of N1 ,or  X 
N1 = h element type = N ... i and N2 = h simpleType name = N ...  X 
N1 = h attribute type = N ... i and N2 = h simpleType name = N ...  X 
N1 = h element type = N ... i and N2 = h complexType name = N ...  X 
N1 = h element ref = N ... i and N2 = h element name = N ...  X 
N1 = h attribute ref = N ... i and N2 = h attribute name = N ...  X  N1 = h group ref = N ... i and N2 = h group name = N ... i with the same  X 
N1 = h attributeGroup ref = N i and N2 = h attributeGroup name = N  X 
N1 = h restriction base = N i and N2 = h simpleType name = N ...  X 
N1 = h extension base = N i and N2 = h simpleType name = N ...  X 
N1 = h extension base = N i and N2 = h complexType name = N ...
XML Schema definition if N2 is a succeeding node of N1 . 3.3. Functions
Fig. 3 defines the data model of the XML Schema language, which consists of a group of functions. These functions relate an XSchema node to a set of XSchema nodes or to a set of sequences of XSchema nodes, or relate a sequence of XSchema nodes to a set of sequences of XSchema nodes, represented in comprehension notation (see [24] ).

The function child: Node ! Set(Node) relates an XSchema node to all its child nodes; the function succeeding: Node ! Set(Node) relates an XSchema node to all its succeeding nodes; the function pre-ceding : Node ! Set(Node) relates an XSchema node to all its preceding nodes. iChild : Node ! Set(Sequence(Node)) , which is defined to find the instance child nodes of type iElement of an XScheme node N , relates the XSchema node N to a set of XSchema node sequences, i.e. if y mediate nodes visited when searching for y[ j y j ] of y[1] , i.e. ones that belong to both succeed-ing + ( y[1]) and preceding + ( y [ j y j ]). Some of them may be the declaration nodes of model groups, in an instance XML document. iAttributeChild : Node ! Set(Sequence(Node)) , which is defined i.e. if y 2 iAttribueChild(N) , then y[1] = N and y[ j y j ] is an instance attribute node of N . Other both succeeding + ( y[1] ) and preceding + ( y[ j y j ] ). The auxiliary function iChild-helper : Node !
Set(Sequence(Node)) helps iChild(N) and iAttributeChild(N) to find the corresponding nodes, and returns all the node sequences visited before the instance child nodes and instance attribute nodes of the XSchema node N .
 iTextChild : Node ! Set(Sequence(Node)) is defined to find the instance text nodes of an XSche-ma node N , and relates the node N to a set of node sequences. Let y 2 iTextChild(N) , then y[1] = N and y[ j y j ] is an instance text node of N . The nodes between y[1] and y [ when searching for y[ j y j ] of y[1] , i.e. the nodes that belong to both succeeding ing + ( y[ j y j ] ). The auxiliary function attributeNode ( N attribute node type = T of the node N 0 . The XML data model defines that an element of simple type must have and only has a text node, and that an element of complex type can either have one or more text nodes but does not specify the number of the text nodes. Therefore, we only need to take care whether or not an text nodes of an XSchema node. We achieve these goals by using the auxiliary function iText-helper: Node ! Set(Sequence(Node) ) .

If N of iText-helper(N) declares an element of simple type, then N must have instance text nodes, not an instance text node of N , but D has a child node of h simpleContent ... i or h complexContent in iText-helper(N) tests whether or not the type T is a built-in simple type.

Different from the XML data model, where a node has only a parent node, in XML Schema definitions, a node may have several instance parent nodes. Thus, the function iPS : Sequence(Node) ! Set(Sequen-ce(Node)) for finding the instance preceding sibling nodes and the function iFS : Sequence(Node)
Set(Sequence(Node)) for finding the instance following sibling nodes relate a sequence x of nodes to text node of y[1] and an instance preceding sibling node of x[ j x j ] .

Since the XML Schema does not specify the position of the instance text nodes of a node N that defines children of the element e in any instance XML document. If y[ j y j ] = h complexType mixed = dren of the element in any instance XML document. However, if N defines an element e of complex type, defines an element of simple type has no instance sibling nodes. If y[ j y j ] = h simpleContent ... i or y[ j y j ] =@ h type = T i or y[y] = h simpleType ... i , then and thus y[ j y j ] has no instance preceding and following sibling nodes.
 x [ k ]if " i 2 { 1 , ... , k }: x [ i ]= y [ i ] ^ x [ k + 1 ] 5 y [ k + 1 ] j y j ) returns the minimum of j x j and j y j . Among these common ancestor nodes, i 2 { 2 , 3 , ... , j x j }: attribute ( x [ i ], 0 maxOccurs 0 )&gt; 1 , then x[ following sibling node of itself.
 content model of an all group consists of element declarations, i.e. h all ... i elementD maxOccurs = 1 , then the element declared in x [ j x j ] and the element declared in and N2 be two nodes in an XML Schema definition, then N1 N2 indicates that N1 appears before N2 in attribute ( N , 0 maxOccurs 0 ) retrieves the value of the attribute with the name maxOccurs in node N .
The function NT : Node  X  NodeTest ! Boolean , which tests an instance XSchema node N against a node test of XPath, is defined as: 4. XPath X  X Schema evaluator
A common XPath evaluator is typically constructed to evaluate XPath queries on XML instance docu-ments. Our approach evaluates XPath queries on XML Schema definitions rather than on the instance doc-
XPath evaluator XPath X  X Schema evaluator. 4.1. Schema paths
Instead of computing the node set of XML documents specified by an XPath query, our XPath X  X Schema by a common XPath evaluator on XML instance documents. If an XPath query cannot be evaluated com-pletely, the schema paths for the XPath query are computed to an empty set of schema paths. records h e i where  X 
XP 0 is an XPath expression,  X 
S is a set of sequences of XSchema nodes,  X  z is a set of pointers to schema path records,  X  lp is a set of schema paths,  X  f is a set of sets of schema paths,  X  e is a predicate expression self::node ()= C , where C is a literal, i.e. a number or a string, and  X  o is a keyword and o 2 {=, or , and , not }.

Let Q be an XPath query, which is the input of our XPath X  X Schema evaluator, and Q = XP where XP e is the part, which has been evaluated, XP c is the part, which is being evaluated, and XP which has not been evaluated so far by the XPath X  X Schema evaluator. In a schema path record, XP
XP when evaluating XP c , and which is also a context node to compute the following nodes. The first node N is an instance parent node of N l , and other nodes in s are ones that are visited when searching for N some of which may be the nodes of model groups and are useful for consistency checking of occurrence a schema path record. lp represents loop schema paths; f represents the schema paths computed from the
Example 2. Our XPath X  X Schema evaluator evaluates the XPath query Q of Fig. 4 on the XML Schema def-entire record for simplicity of presentation and readability.

Q selects the parent node refs of the node article , which is a descendant node of the document node bib . The node article has two predicates. The first predicate qualifies that the node article must have article may have children editor , but the children editor cannot have bib nodes as ancestor nodes. between D13 and D4 are D14 , D15 , D2 , D3 in this order. The instance child nodes of D4 are D7 , D8 , D9 and D10 , and thus the following schema paths are computed: {( R1 , R2 , R3 , h S2 ,{( D4 , D5 , D6 , D7 )}, { R3 }, -, -i ), ( R1 , R2 , R3 , h S2 ,{( D4 , D5 , D6 , D8 )}, { R3 }, -, -i ), ( R1 , R2 , R3 , h S2 ,{( D4 , D5 , D6 , D9 )}, { R3 }, -, -i ), ( R1 , R2 , R3 , h S2 ,{( D4 , D5 , D6 , D10 )}, { R3 }, -, -i )}.
 is D4 and the corresponding node sequence is D10 , D11 , D12 , D2 , D3 , D4 . The schema paths are now ( R1 ){( h Q , {(/)}, -, -, -i , ( R2 ) h S1 ,{( D1 , D13 )}, { R1 }, -, -i , ( R3 ) h S2 ,{( D13 , D14 , D15 , D2 , D3 , D4 )}, { R2 }, -, -i ( R4 ) h S2 ,{( D4 , D5 , D6 , D10 )}, { R3 }, -, -i , ( R5 ) h S2 ,{( D10 , D11 , D12 , D2 , D3 , D4 )}, { R4 }, -, -i )}.

The resultant schema paths of // article are ( R1 ){( h Q , {(/)}, -, -, -i , ( R2 ) h S1 ,{( D1 , D13 )}, { R1 }, -, -i , ( R3 ) h S2 ,{( D13 , D14 , D15 , D2 , D3 , D4 )}, { R2 }, -, -i ( R4 ) h S2 ,{( D4 , D5 , D6 , D10 )}, { R3 }, -, -i , ( R5 ) h S2 ,{( D10 , D11 , D12 , D2 , D3 , D4 )}, { R4 }, -, -i ), ( R6 ) h S2 ,{( D4 , D5 , D6 , D10 )}, { R5 }, -, -i , ... )}
A loop occurs when evaluating // article , i.e. D10 is an instance child node of D4 and D4 is an instance paths are modified as follows: ( R1 ){( h Q , {(/)}, -, -, -i , ( R2 ) h S1 ,{( D1 , D13 )}, { R1 }, -, -i , ( R3 ) h S2 ,{( D13 , D14 , D15 , D2 , D3 , D4 ), ( D10 , D11 , D12 , D2 , D3 , D4 )}, { R2 , R4 }, ( R4 ){( h S2 ,{( D4 , D5 , D6 , D10 )}, { R3 }, -, -i , ( R5 ) h S2 ,{( D10 , D11 , D12 , D2 , D3 , D4 )}, { R4 }, -, -i )}, -i )} We present the detection of loops and the constructions of loop schema paths in Section 4.3 . schema paths of the predicate consists of the schema path record h o ,{ f 1, f 2} i , where o = schema paths f1 and f2 are computed from two predicate expressions, respectively. The first record of the computed to empty (see (R10) in Fig. 5 ). We present the method to evaluate predicates in Section 4.4 . 4.2. Evaluating XPath expressions
We use the semantics technique to describe our XPath X  X Schema evaluator, and define the following nota-record to which the k th pointer points) of the schema path p , and thus p [ j p j ]. XP the concatenation of two XPath expressions, e.g. XP1/XP2 .
 The semantics of the XPath X  X Schema evaluator is specified by a function L (see Fig. 7 ). The function L :
XPath x schema _ path x XPath ! Set ( schema _ path ) takes two XPath expressions and a schema path evaluated when calling this function. Thus, Q = XP1/XP2 . L(XPath, schema _ path, XPath) is defined recursively on the structure of XPath expressions (see Fig. 7 ). 4.3. Evaluating axis and node-test
For evaluating each location step of an XPath expression, our XPath X  X Schema evaluator first computes is computed from the part of the XPath query, which has been evaluated by the XPath X  X Schema evaluator. ones visited when searching for r of s[1] . The function L then constructs a pointer e to a new schema path record, i.e. e !h xp 0 , { s } ,z ,-,-i and extends p to p schema path p , denoted by p 0 = p + e .In Example 2 , the new schema path record e !h S4 ,{ (D4, D5, D6,
D10) }, { R3 }, -, -i is generated when evaluating the part end of p (see (R11) in Fig. 5 )by L(parent::refs , p , parent::refs ). If no node is selected by the cur-location step editor and this causes that the corresponding main schema paths are computed to empty (see (R10) in Fig. 5 ).

L ( a :: n , p , xp 0 ). If there exists a record p[k] in p such that S(1)[ added to the field of the loop schema paths in the schema path record p[k] , where the loop occurs (e.g. (R4) and (R5) in Fig. 5 ). A loop might occur when an XPath query contains the axis descendant, ances-tor , preceding or following , which are boiled down to the recursive evaluation of the axis child or parent , respectively. For computing L(descendant :: n , p , xp 0 ), we first compute p node (), p i 1 , xp 0 ) ^ p i 1 2 L ( child :: node (), p is detected in the path p i , i.e. " k 2 { 1 , ... , j p i (1) j ] ^ S 1 = p i [k].S ^ S 2 = p i [ j p i j ]. S ), then let p construct a possible new path from p i . If a loop path segment ( p in the path p i , i.e. $ k 2 { 1 , ... , j p i j 1 }: p 2(1) j ] ^ S 1 = p i [k].S ^ S 2 = p i [ j p i j ]. S , then the schema path record p ter, i.e. h p i [k].XP 0 , p i [ k ]. S [ p i [ j p i j ].
 p also aware of this modification. When a loop is detected, instead of setting p a loop is detected in p i , p i will not contribute to the further computation of schema paths anymore. 4.4. Evaluating predicates record, where the last node of the field of the node sequences is the context node of the predicate, e.g.
L ( e [ q ], p , xp 0 )= {( p 0 ][ 1 ], p 0 [2] , ... , p 0 [ fp , q ) ij p 0 2 L ( e , p , xp 0 ) ^ L ( q , fp , q ) 5 text node of the predicate such that we compute the schema paths of the predicate from fp . When L(q, fp, q) is computed to empty, the main schema paths are computed to an empty set of schema paths, i.e.
L ( e [ q ], p , xp 0 )= ; if L ( q , fp , q )= ; . When q =( q path with only one record for the predicate expression q 1 that consists of a keyword or and two sets of schema paths computed from q of the node sequences is the context node of [ q 1 or q 2 to empty, the schema paths of the predicate q 1 or q 2 are computed to the empty set, i.e. L ( q or q 2 )= ; if L ( q 1 , fp , q 1 )= ;^ L ( q 2 , fp , q 2 4.5. Integrating data type checking
The XML Schema language defines 44 built in simple types, and allows users to define new simple types. If element or the attribute specified in the given XML Schema definition, the XPath query selects an empty integration of data type checking, when evaluating XPath queries on an XML Schema definition, can detect more unsatisfiable queries.

The data type checking is involved in the computation of the schema paths of the predicate expression the element, and thus, e.g. two predicate expressions child::mark = 1.0 and child :: mark/child ::-we evaluate child :: text ()/ self :: node ()= C rather than self :: node ()= C in order to make the node schema paths is added to the field of the predicate schema paths of the record, the last node of the node straints, the predicate expression self :: node ()= C is computed to the empty set of schema paths, i.e. puted to the empty set of schema paths. The auxiliary function typeChecking(type, C) validates whether or not the constant C conforms to the given type; the auxiliary function valueType(N) returns the type of the value of the element or the attribute declared in the node N and the restricting facets of the value.
Whenever an element contains elements and text nodes for its value, i.e. declared as h complexType mixed = 0 true 0 ... i or h complexContent mixed = 0 true 0 ... no restricting facet either, i.e. we do not check the data type of values in this case. of the derivations. The function computeType(N, facets) computes the type of value of an element or an that declares the attribute.

Whenever an instance text node is the attribute node type = T of an element declaration node N , then T
If N = h attribute type = T ... i and built-in(T) , then T is defined by a node N1 = h simpleType by the function computeType(N1, facets) . If an instance attribute node N does not contain a named type, by the function computeType ( N1 , facets ).

Algorithm 1 ( computeType ( N , facets )) describes how to retrieve the type of values of attributes and elements according to the syntax for simpleTypeD and simpleContentD (see Section 2.2 ). XML Schema Algorithm 1 ( computeType(N, facets) ) In Algorithm 1 , node N1 = h extension base = QName i is a child node of h simpleContent ... i ; node
N2 = h restriction base = QName i is a child node of h simpleType ... built-in simple type, there is a node h simpleType name = QName i with the same QName , which defines facets, i.e. we compute the type of value of the element or the attribute. 4.6. Integrating occurrence constraints checking
XML Schema specifies some constraints that control the occurrence of elements and attributes and their values. When an element is declared with maxOccurs = 0 (and minOccurs = 0 , because it is an error if minOccurs 5 0 ) or a model group of the element is declared with maxOccurs = 0 , or when an attribute ment. When an element or an attribute is declared to have a fixed value, e.g. fixed = element or the attribute in all instance documents must be 100 .

In order to integrate the occurrence constraints checking, we modify the data model of XML Schema, espe-cially, the functions iChild ( x )and iAttribute ( x )in Fig. 3 ,asin Fig. 11 .
The function iChild(N) first computes a set S of node sequences using the auxiliary function iChild-de ()= C , p , self :: node ()= C ) is modified as in Fig. 12 .
 node (), N can carry the attribute fixed .If N contains the attribute fixed, i.e. N = compute {( h self::node()=C i )} from the predicate self :: node ()= C ;if C does not conform to the type h the corresponding node sequences.
 4.7. Complexity analysis
We first analyze the complexity of our approach in the worst case. Different from instance XML docu-in an XML Schema definition S in the worst case, each node in S is an instance node and each node is a the instance nodes in S .
 one existing schema path record is modified by integrating the new loop schema path, and N 1 new schema paths with length of s + 2 are computed. Therefore, there are N + N schema paths with length from s + 1 to s + 2 computed so far. From each of N path, and N 2 new schema paths with length s + 3 are computed. N + N ited and N + N * ( N 1 )+ N * ( N 1 ) * ( N 2 ) schema paths with length from s + 1 to s + 3 are computed
N  X  N N  X  N  X  N 1  X  N  X  X  N  X  N 1  X  X  N 2  X  ... 2 N  X  N and N  X  N  X  N 1  X  X  N  X  N 1  X  X  N 2  X  X  X  N  X  N 1  X  X  N 2  X  2 1  X  schema paths are computed with length from s + 1 to s + N .
 Let X  X  N first two location steps, X + P * X nodes are visited and P N + N ; having evaluated Q , X  X  P X  X  P 2 X  X  X  P a 1 X  X  schema paths are created with length from a to a * N N N ! 2 at most O ( N * N ! * a * ( N ! * 3) a 1 ) nodes, and creates at most O (( N ! which contains at most O ( a * N ) pointers, and thus O (( N !
O ( a * N * ( N ! * 3 ) a ) pointers to at most O ( N * N
Therefore, the worst case complexity of our approach in terms of runtime and space is O ( a
The XML Schema definitions of the worst case, where each node has all the nodes as succeeding nodes and / descendant-or-self::node() . Other queries with multiple location steps each of which selects up to all cases.

Therefore, the complexity of runtime and space of our approach is O ( a real-word schemas and queries, the complexity of our approach in terms of runtime and space is O ( a for typical cases. 5. Satisfiability tester
Schema definition XSD , if there exists an XML document D , which is valid according to XSD , and the evaluation of Q on D returns a non-empty result. Otherwise, Q is unsatisfiable according to XSD . definition XSD by the XPath X  X Schema evaluator generates an empty set of schema paths, then Q is unsatis-fiable according to XSD .

Proof. The XPath X  X Schema evaluator is constructed in such a way that the XPath X  X Schema evaluator butes specified in XSD , or the attributes and elements specified in Q instance XML documents. Thus, there does not exist a valid XML document according to XSD , where the application of Q returns a non-empty result. h
If an XPath query is computed to a non-empty set of schema paths by our XPath X  X Schema evaluator on given in the XML Schema definition, but our approach does not check whether or not two or more location steps in Q contradict each other. For example, the query Q1 = a[b/c][b/d] and Q2 = a[not(b)] / occur only one time and c and d cannot appear in any valid XML document simultaneously; the query Q2 is unsatisfiable if the schema specifies that b is the only children of a . 6. Performance analysis
We have implemented a prototype of our approach in order to verify the correctness of our approach and these satisfiable queries by common XPath evaluators, in order to prove the usability of our approach. 6.1. Test system and data The test system for all experiments is an Intel Pentium 4 processor 2.4 GHz with 512 MB RAM, Windows
XP as operating system and Java VM build version 1.4.2. We use the XQuery evaluators Saxon version 8.0 benchmark (see [8] ) as the source of our experimental data, and generate data from 0.116 MB to 11.597 MB by using the data generator of [8] . An XML Schema definition benchmark.xsd (see Appendix
A ) is manually adapted according to the DTD benchmark.dtd of the XPathMark benchmark (see [8] ) ify more specific data types for values of elements and attributes, which are all declared as # PCDATA in benchmark.dtd . We design two groups of unsatisfiable queries and two groups of satisfiable queries. The straints. Furthermore, the queries in these groups are also designed to contain as many constructs of the
XPath language as possible in order to test how the different constructs of the XPath language influence the processing performance. We present the average results of 10 executions of these queries. 6.2. Filtering queries with incorrect semantics or structure
Fig. 13 presents the time of evaluating the queries Q1 X  X 11 on benchmark.xsd by our XPath X  X Schema evaluator, when returning an empty set of schema paths. Our evaluator can evaluate XPath queries Q1 X  X 4 age when evaluating the queries with recursive axes at 12 MB in comparison with the evaluation of the unsatisfiable queries when using the Saxon evaluator (and the Qizx evaluator, respectively). 6.3. Filtering queries not conforming to data-types or occurrence constraints Fig. 18 presents the time of evaluating the XPath queries Q12 X  X 26 on benchmark.xsd by our XPath X  evaluator, respectively, when evaluating these queries. Likewise, the experimental results show that our tively) at 12 MB in comparison with the evaluation of the unsatisfiable queries. 6.4. Measuring the overhead of evaluating satisfiable queries
Fig. 23 presents the time of evaluating the satisfiable XPath queries Q1
XPath X  X Schema evaluator, when it returns an un-empty set of schema paths, and the time of evaluating the uating the satisfiable XPath queries Q12 0  X  Q26 0 on benchmark.xsd by our XPath X  X Schema evaluator, when of the time by our approach over the time used by Saxon and Qizx, respectively, for the evaluation of Q1 12 MB. However, when the size of XML documents is very small (&lt;100KB), the overhead of evaluating sat-uators. When the size of XML data is 100KB, the ratio of the time of evaluating the XPath queries Q1 with at most one recursive axis (excluding // * ) by our approach over Saxon (and Qizx) is 25% (and 200%, respectively); the ratio of the time of evaluating XPath queries Q9 one // * location step, which selects all the nodes of XML documents) by our approach over the time used the time of evaluating Q1 0  X  Q11 0 by our approach over the time used by Saxon is 10% when the size of
XML data is 1 MB, 5% when the size of data is 4 MB, and 2.5% when the size of data is 6 MB. In the worst size of XML data is 1 MB, 23% when the size of data is 2.3 MB, 10% when the size of data is 6.2 MB.
Although the ratio of the time of evaluating satisfiable XPath queries by our approach over common XPath i.e. 0.12 s in the worst case when evaluating Q1 0  X  Q11 0 7. Further related work ability test to optimizations for XML query reformulation and shows how to reduce the containment and intersection test of XPath expressions to the satisfiability test.
There has been work on physical optimization of XPath expressions, i.e. efficient algorithms for XPath steps to speedup XPath evaluation. 8. Summary and conclusions We have proposed a data model for the XML Schema language, which identifies the navigation paths of
XPath queries on XML Schema definitions. Based on the data model, we have developed an XPath X  X Schema evaluator, which evaluates XPath queries on an XML Schema definition in order to check whether or not the typing capabilities of XML Schema. When an XPath query does not conform to the constraints in a given Otherwise, the XPath query is maybe satisfiable.

The experimental results of our prototype show that our approach has very low overhead, that our approach ries by filtering unsatisfiable XPath queries. A speed-up factor up to several magnitudes is possible. ferring our results for XPath to XQuery and XSLT.
 Appendix A. Benchmark.xsd
In this section, we present the XML Schema definition benchmark.xsd , which we use for the perfor-mance analysis. This schema is manually adapted according to the DTD benchmark.dtd of the XPathMark many constructs of XML Schema as possible and specify more specific data types for values of elements and attributes, which are only declared as # PCDATA in benchmark.dtd .

References
