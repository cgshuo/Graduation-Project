
KDD technology is based on a well-defined, multistep KDD process for discover-ing knowledge from massive data sets (Fayyad et al. 1996; Reinartz 1999) (Fig. 1).
KDD systems are designed to manage the KDD process by providing various pre-mining, mining and presentation tools in an integrated platform. Management of the discovered knowledge is as important as the discovery of knowledge nuggets from the databases. There is a need to integrate the two tasks to ensure effective utilization of discovered knowledge in decision-support systems.
 tions) have not grown as anticipated (Stodder 2000). Some of the factors responsible for lack of penetration of this technology are:  X  Current data mining systems/packages require the end-user of the KDD technol- X  These systems do not allow inherent sharing of either intermediate results or dis- X  Lack of power to handle continuity in KDD process makes knowledge discovery  X  Lack of flexibility for (i) dynamically settin g mining goals, (ii) driving innova-
These limitations restrict the functionality of the KDD systems and dissuade the end users from experimenting creatively with the KDD process. The usage of KDD technology, which has fallen short of the expectations and sentiments that reigned during the second half of the pre vious decade, bears a testimony.
 data mining systems, reflects the predatab ase approach for data management. Charac-terized by one objective X  X ne data set X  X ne process (Gupta et al. 2003), the current data mining systems provide an environment analogous to hard-wired environment of COBOL era for electronic data processing. The application programs were then required to be intricately tie d to the underlying file structu re, with the binding taking place typically at compile time. This restrict ed sharing of data by different applica-tions. Related problems and resulting ineffici encies led to introduction of three levels of data abstraction in CODASYL DBTG report (DBTG 1971; Fry et al. 1976; Tay-lor and Frank 1976). The observations of the ANSI/SPARC study group regarding necessity of standardizing interfaces to da tabase systems later led to ANSI/SPARC three-tier architecture for databases (Study Group on DBMS 1978). This architecture for databases has since become the de facto s tandard. Its advantages far outweigh the disadvantages. The architecture capture s and stores the data needs of all the users in an organization in an integrated and holistic manner and gives complete control to the organization for any data-related activ ity. It also provides intermediate layer(s) between the user and data, thereby permitting data independence and ease of use. well-documented and controlled process from an ad hoc approach based on file sys-tems.
Contemporary scene in KDD technology is a strong reminder of the COBOL era and therefore entails the problems of that ( predatabase) era (Im ielinski and Mannila 1996). Full potential of the technology is im possible to be realized with the current approach toward design of KDD systems.

We believe that KDD systems should cater to abstraction of the complete KDD process and encapsulation of user requirements so that the premining operations do not interfere with the conceptual mining at the user level. This would allow mining analysts to restrict focus on the logic of the applications, and the end user to cre-atively solve business questions using knowledge discovery techniques. Premining functions should be structurally and functi onally independent of actual mining. The
KDD systems should inherently allow discreet sharing of intermediate results and previously discovered knowledge while supporting continuity of the KDD process.
Privacy issues arising out of sharing need to be addressed in totality. Design of KDD systems must consider human interaction and creativity as crucial components of the
KDD process, leading to mix -initiative mining (Gherke 2001). We believe that the resulting encouragement for developing applications with wider functionality will catalyze the growth of the technology.

In this paper, we present an architecture for a knowledge discovery and man-agement system based on a user-centric model of KDD process (I-MIN model).
Analogous to ANSI/SPARC model (Study Group on DBMS 1978), the proposed three-level architecture facilitates development of applications using well-defined in-terfaces. These applications are designe d by the end users or data mining analysts to discover new knowledge from the evolving data archives that are possibly being fed by data streams. Such evolving databases are open ended and are characterized by continuity, rapid growth and infrequent access. Our proposal also supports ex-ploration of already discovered knowledge with perspectives, which are dynamically defined by the end user. The proposed architecture insulates the mining applications from the details of the KDD process and provides mining operators for facilitating knowledge management. Continuity in the KDD process supported by the underly-ing mining model keeps the knowledge current. As with the ANSI/SPARC three-tier architecture, the proposed architecture pro vides total control of mining activities, striving toward standardization and systematic documentation practices. tecture of some popular KDD systems and an intension mining scheme. Section 3 describes the I-MIN model. Section 4 proposes a three-level architecture of I-MIN model. Section 5 discusses the operators used for mining and knowledge manage-ment. Section 6 describes the user interface of the system. Section 7 reports the experiences during implementation, and issues arising out of it. Finally, Sect. 8 con-cludes the paper.
Most of the currently available packages pr esent a structured interface to the user for completing all the steps of the KDD process. However, there is a need to address issues related to data independence, abst raction of mining needs, development of new applications, etc., which are anal ogous to the fundamental issues successfully handled by ANSI/SPARC architecture in databases (Study Group on DBMS 1978). We present here architectural models fo r some KDD systems related to our work. the way its components handle the requirements for knowledge discovery in real-life applications. DBMiner by Han et al. (1996) is a multitier system for KDD that supports query-based, interactive on-line analytical mining (OLAM) on relational databases and data warehouses (Fig. 3 from Klosgen and Zytkow (1999)). Mine-set, conceptualized by Brunk et al. (1997) is based on a three-tier architecture and supports complete KDD process (Fig. 4 fro m (Silicon Graphics)) using powerful
GUI tools. The architecture integrates dat abase access, analytical data mining tools and visualization tools. The three tiers in Mineset, however, differ in functionality compared with those proposed in this paper (Fig. 7).
 bodies the interdisciplinary nature of dat a mining by exploiting useful techniques from areas of statistics, machine learning, da tabase technology, artificial intelligence and visualization. Discovery Board proposed by Virmani (1998) and AMORE pro-posed by Psaila (1998) systems explicitly address the issues related to human inter-action with the KDD systems.

Virmani (1998) proposes design of Discovery Board X  X  second generation data mining system, proposed by Imielinski and Mannila (1996). The system follows a database-centric, query-based approach to KDD and inherently reuses earlier (discov-ered) knowledge for exploratory purposes. The proposal strives to provide a frame-work for a DBMS-like environment supporting query language to satisfy basic data mining needs, and APIs for developing data mining applications to satisfy complex mining requirements. A framework for storage and reuse of discovered knowledge, backed up by graphic tools, makes this system data-miner friendly.
 The architecture for a data mining system called AMORE has been proposed by
Psaila (1998). This system is built over SQL server and exhibits tight coupling of data mining and SQL. The main objective of the design is seamless integration of data mining techniques and systems with the SQL server. The architecture integrates the steps of the KDD process and insulates users from premining and postmining operations by providing SQL-like mining operators.

A comparative study of AMORE, Discovery Board and the proposed I-MIN sys-tem is presented in Table 1.
Intension Mining strives to provide continuity to the KDD process in an environ-ment that supports experimentation and allows monitoring of discovered knowledge in evolving databases (Bhatnagar 2001). Mining requirements of users are speci-fied in the form of a knowledge discovery schema ( mining intension to the database schema ( database intension ) in DBMS (Date 2000; Silberschatz et al. 2001). quirements (KDD process), just as the database intension contains the specification of relations in the database. The ultimate goal of the schema design is to facili-tate a view that is of interest to the user and enhance productivity, ease of use and comprehension at the user level.
 incremental database is processed automatically at regular intervals, with the peri-odicity specified in the schema. This processing consists of premining of data fol-lowed by preliminary analysis and/or aggreg ation. Because the mining requirements are available in the schema, the system is capable of carrying out premining-cum-aggregation operation in off-line mode. This periodic operation on the incremental database is termed as accumulation . The resulting aggregates, called knowledge con-centrates , constitute an intermediate form of the intended knowledge and are pre-served in secondary storage.
 phase and mining phase . Table 2 summarizes the functions of these phases. knowledge discovery schema (KDS). This phase requires close collaboration between the data mining analyst, domain expert and the end user. The schema is compiled and the meta-data and data structures 2 are created to be used during the later two phases.
 until the user decides to drop the mining requirement (schema) altogether. During the accumulation phase, the incremental database is premined and aggregated in consultation with the meta-data to yield knowledge concentrates (KCs). The KCs store the intermediate form of intended knowledge (as per the KDS) and serve as windows of condensed knowledge for future mining.
 the system or a mining application is executed. KCs are processed by the mining algorithm to discover the intended knowledge during this phase.
Intension mining splits the mining algorithm into two phases (Table 2). The first phase is executed once on each increment during the accumulation phase and re-sults in generation of KCs. The second phase of the algorithm is executed during the mining phase to satisfy a mining query or application. An important character-istic of intension mining is that it perceives KDD as a continuous process. Periodic accumulation of incremental databases at regular intervals gives rise to a sequence of knowledge concentrates providing nonoverlapping windows in the database. These windows form the basis of the ongoing knowledge renewal and knowledge sharing, which are two important functions of knowledge management.

A knowledge discovery administrator (KDA) is responsible for the overall KDD operations in the organization, analogous to the DBA for database operations. The overall approach allows systematic and complete documentation of the KDD op-erations in an organization and helps i n proficient management of knowledge and enforcement of standards in the organization. For details of the intension mining scheme, please refer to Bhatnagar (2001).
We present a user-centric model for the KDD process, which is b ased on the concept of intension mining (Sect. 2.1) and is designed to support interactive exploration and experimentation. The model, called I-MIN Model ( intension mining model), is shown in Fig. 5. The model is downward compatible with the traditional KDD process model and provides full functionality for it. In the I-MIN model, the KDD process consists of six steps (numbered IM x , x = 1 ,... , 6) as shown in the figure. The functionality of each step is also indicated . The model can be realized by designing and integrating the components for each of the process steps.

The KDD process begins with data understanding and formalizing the mining requirements during Step IM1. This corresponds to the planning phase of intension mining (Sect. 2.1). During this step, discove ry goals are identified and the specifi-cations of the generic KDD process are stored as knowledge discovery schema .The schema is compiled and the resulting meta-data is stored for future use ( accumulation and mining phases).

The second step, IM2, performs premining-cum-aggregation and corresponds to the accumulation phase. Step IM2 is a compound step in which steps IM2a X  X M2c can be mapped to selection, cleaning and tran sformation tasks, respectively, in the traditional KDD process model. Analysis/aggregation of the premined data, which is carried out during the data mining step of the traditional KDD process model is carried out during Step IM2d. This particular step signifies execution of the first phase of the mining algorith m. Because the functions for premining and aggregation operations (mining algorithm) are already specified in KDS, they are performed au-tomatically without human intervention. The outcome of this process step is a know-ledge concentrate . Step IM2 is periodically repeated on incremental database as per the frequency specified by the KDA in the schema.
 and applications are developed by the end users during this step. These are compiled by a suitable compiler in consultation with the appropriate schema. This user-initiated step is asynchronous, and it invokes the data mining algorithm.
 the schema is invoked. Recall that the first phase of the mining algorithm is invoked during step IM2d, where partial aggregation of the target data results in KCs. During this step, the second phase of the algorithm is invoked and intended knowledge is mined from the KCs (Table 2). Merging of the KCs, as specified in the query or application, is performed before invocation of phase 2 of the mining algorithm.
KCs extracted during step IM2 can be restrictively shared for experimentation and monitoring of the desired subset of th e database. The discovered knowledge can be preserved and reused by developing applications to meet complex knowledge needs. Secondary operators (Sect. 5) are used to meet these knowledge management functions.
 IM6, respectively, like the traditional KDD process model.

Note: A KDD system based on the I-MIN model is referred to as the I-MIN system in the rest of the paper. Careful examination of the proposed model r eveals that it subsumes the traditional
KDD process model. I-MIN model completely captures the functionality of tradi-tional KDD process model. This is a usefu l and important feature because it is not always possible to foresee exhaustive mining requirements. Unforeseen mining re-quirements can also be supported by the I-MIN model for KDD processes. In case one needs to mine the entire datab ase on an on-the-fly basis, one can accumulate the entire database in a single shot and straight away carry out mining. Thus, min-ing requirements that cannot be anticipated at intension time can always be mined outside intension mining .
In the traditional KDD process model (Fig. 1), several independent and loosely coupled processes are involved. The I-MIN model integrates premining operations tightly and even binds the data aggregation and analysis (partial mining) to an ex-tent. This tight coupling during the accumulation phase imparts a formalism and continuity to the entire process of knowledge discovery. In certain situations, these characteristics may prove to be rigid. Such situations may be handled using the traditional knowledge discovery approach, which is also supported by the I-MIN model.

In the traditional KDD process model, documentation and control are external and are independent of the model. However, in the I-MIN model, documentation and control of the KDD process are an inte gral part of the process itself and are captured before the process actually begins. This provides more control to the KDA for access control, privacy and ot her security-related issues.

An interesting contrast between the two models is that, in the traditional KDD process model, the functionality is defined at the beginning of the process by the data miner, while in the I-MIN model, it is decided dynamically by the end user at the time of actually mining the database.
Implementation of the I-MIN model for the KDD process essentially requires devel-oping components to accumulate, mine, e xperiment and monitor. These components need to be developed for each type of knowledge, e.g. association rules, classifica-tion models, clustering schemes, etc. 3 . Each component effectuates either one step or a functionality of the I-MIN model. However, a combination of more than one components may be required to accomplish diverse functionality. We propose five components necessary to achieve desired functionality of the I-MIN model.
Where K is the type of knowledge to be discovered using algorithm, (say) A ,  X 
M is the merge operator required to engineer the user-specified subset of the database, F M acc is the accumulation component, F M min ent. F M exp and F M mon support experimentation and monitoring, respectively, and may
As shown in Fig. 6, the core of a fully implemented I-MIN system is a collec-tion of components for different types of knowledge for different mining algorithms.
Each component consists of a set of executa ble functions for each implemented algo-rithm in the system. There is a unique functional component for accumulation and merging of data, for each algorithm implemented in the I-MIN system. However, for mining basic knowledge in different formats, there may be more that one sub-component. The experimentation and mon itoring components for each implemented algorithm consist of multiple subcomponents. This is so because these two functional components represent the enhanced and div erse mining functionality required by the data miners for answering new busin ess questions. Though each of the subcompo-nents provides specific functionality, t here may be some subcomponents that can be used both for experimentation and monitoring. The following example illustrates the functional components of the I-MIN system.

Example 3.1. Consider Fig. 6, which shows various components of I-MIN system that implements several algorithms. If the user intends to use Algo 2 for the discovery process, then the KDS takes care to coordinate the discovery process to execute the functions corresponding to Algo 2 in each phase. That is, Algo 2 tion , Algo 2  X  mer for merging the windows , Algo 2  X  min for mining, Algo 2 etc. for experimenting, Algo 2  X  mon m etc. for monitoring.
 1. Accumulation component: This component performs analysis and partial ag-2. Merge component: The Intension mining scheme allows a user to dynamically 3. Mining component: This component consists of the Phase II of the actual mining when the user invokes a mining query/application (Table 2). The mining param-eters and constraints are supplied to the mining algorithm at this stage. There may be more than one executable function in the mining component for an algo-rithm. Each function may discover intended knowledge with a different flavor or format. For example, in the classification task there may be different subcompo-nents for mining: one for inducing classification tree , the other for classification rules . This component forms the basis for F M exp and F 4. Experimentation component: This component of I-MIN model supports user-centric data exploration and experimentation. Repeating experiments with dif-ferent constraints, subsets of data repository, focus or other relevant parameters, provide functionality for experimentation with the KDD process. By meaningfully embedding the desired functionality with the basic services provided by
F M min , it is possible to design new experiments in the form of user applications and install them as subcomponents. As evident from the overlapping lower rect-angles of Fig. 6, some experimentin g subcomponents may provide functionality for monitoring and vice versa.

This component is a composite component, in the sense that for a single mining algorithm, there may be several subcomponents to provide varied experimentation capabilities to the users (dotted rectangle i n experimenting component in Fig. 6). 5. Monitoring component: The monitoring component of the I-MIN system sup-ports auditing of data characteristics by facilitating comparison and contrast of the knowledge discovered in different windows . Multiple subcomponents may be tailored to meet user-specific monitoring requirements. Execution of the moni-toring component is subject to authorization checks
This component is very powerful and has tremendous potential for revealing the patterns of change. The windows created by the KCs naturally accommodate FO-
CUS framework developed by Ganti et al. (1999) for quantifying the deviation in the patterns discovered from two windows or data sets.

Monitoring can be automatic or manual as desired by the user. Automatic moni-toring can be specified in the schema e ither at the time of schema design ( plan-ning phase) or later. Automatic monitoring is carried out by executing the mon-itoring application immediately after accumulation of the incremental database. Manual monitoring is possible using subc omponents defined for experimentation.
The strength of the model stems from the last two components, which are instru-mental for the user-centric nature of the model. Note that the omission of F mon reduces the I-MIN model to the traditional KDD process model.
The three-layered architecture proposed for I-MIN system is shown in Fig. 7. The architecture is inspired by the DBMS three-layered ANSI/SPARC architecture (Study
Group on DBMS 1978) and described in several DBMS books (Date 2000; Silber-schatz et al. 2001). Chief motivation for I-MIN architecture has been to abstract the complete KDD process and provide a convenient environment for knowledge management. Independent of the type of underlying database, domain and platform, the architecture supports knowledge discovery, knowledge preservation, knowledge renewal and sharing, which are considered to be significant aspects of knowledge management (Gupta et al. 2001; Macintosh 1998).
 functionality at the planning and mining phases 5 . The middle layer, which is the core layer, is instrumental in carrying out the accumulation and mining phases. The functional components of the I-MIN system are located in this layer. A library of the premining functions is also present. The bottom layer is the storage schema layer, which takes care of the storage of KCs an d mappings between KCs and the schemas. It plays an important role during accumulation and mining phases.
 the other components of the layer. All the three layers access and share meta-data stored corresponding to each schema. The data exchange interface provides mech-anisms to access the data source on which mining is sought.
 knowledge aggregated from the evolving database increments is stored on the sec-ondary storage as units of condensed (partial) knowledge ( knowledge concentrates ).
The storage schema layer provides abstraction at the lowest level by describing how this condensed knowledge is physically stored in data structures and files. The know-ledge discovery schema abstracts these units of condensed knowledge as knowledge concentrates (KC) or windows (Sect. 2.1). The schema for a KDD process provides conceptual abstraction of this partial knowledge by providing mapping to all the
KCs for that process. Applications mining the KCs provide abstraction at the user level by allowing the user to define the subset of the target database to be mined in terms of window sdefinedbyKCs. Data exchange interface hides the database and access-related details from the end user. This permits modification in the phys-ical data structure or the files of KC without affecting either the mapping or the applications, thereby providing physical data independence.

The user X  X  KDD process is derived from the generic KDD process defined by the schema. Each knowledge discovery schema points to a collection of KCs and defines one generic KDD endeavor. The complex details regarding premining and aggrega-tion, storage and mapping of KCs are hidden from the user by the schema. Formu-lation of a mining query or application at the top layer connotes the KDD process in the end user X  X  context. Each mining query realizes a specific KDD (sub)process.
At an instance, the generic process supports as many subprocesses as the number of mining queries or applications using the schema. All the users sharing the schema share the same generic KDD process. An application completes the KDD process.
The ability to modify the KDD process by altering premining functions or mining algorithm without affecting the applications provides logical data independence.
Figure 8 shows the abstraction provided by the proposed architecture. The middle layer contains three different schemas for mining: (i) association rules , (ii) classi-fication models and (iii) cluster schemes from possibly different data sources. The storage schema layer is populated by various data structures and files storing the con-densed knowledge from increments of the corresponding data sources. These units are logically mapped to knowledge concentrates by each schema. The dotted closed figure represents a generic KDD process for mining classification rules. The files and data structure in the referred closed figure denote the sequence of KCs. The top layer contains the user queries and app lications, each defining the users view of the KDD process. The query/application corresponding to  X  X SER VIEW 1 X , realizes the KDD (sub)process, involving the schema for classification rules. The following subsections describe each of the three layers.
The front-end layer provides the user interface for the I-MIN system. The user in-teraction takes place on account of schema design during the planning phase, for-mulation and processing of user application during the mining phase and system administration. The layer consists of a front-end engine and the following compo-nents: i) Intension Mining Query Processor  X  X o accept a mining query/application, vali-ii) Knowledge Discovery Schema Compiler  X  X o enter and validate the knowledge iii) Presentation Manager  X  X o allow maintenance and upgrading of presentation tools. iv) Component Manager  X  X o maintain the database of the functional components of v) Library Manager  X  X o maintain the library of executable premining functions in vi) Data Exchange Interface Manager  X  X o allow maintenance and upgrading of the all the components of this layer. It coordinates actions of all the components of this layer. The engine also supports the concept of a session and maintains a session log for each user. The core layer implements the accumulation and mining phases of intension mining . compiled schemas and executes t he user KDD (sub)processes. The accumulation phase of the KDD process is executed by an accumulation process and a mining query is executed by a mining process . These processes are created and managed by the data mining engine . At an instance, this layer is populated by exactly one accumulation process corresponding to each compiled schema entry and one mining process corresponding to each mining applica tion/query invoked by the user. cumulation component and responds to the user queries and applications by invok-ing appropriate mining components. This engine is also responsible for creating and managing the accumulation and mining processes in the core layer. Data mining engine dynamically links premining functions from the library during accumulation and the functional components from the functional module during execution of the mining application. It communicates with a data exchange interface , on behalf of the accumulation processes, in order to retrieve data from the target database. Both accumulation and mining processes are independent of each other and can usually run simultaneously for the same schema.

The functional module present in the core layer consists of five functional compo-nents of the I-MIN system described in Sect. 3.2. Each component is an independent collection of executable functions corresponding to the mining algorithms supported by the system (Fig. 6). All subcomponents of a functional component provide similar functionality.

The library of premining functions for selection, cleaning and transformation op-erations is available in the core layer. With the growth of the KDD operations in an organization, new KDD requirements may arise and new functions for data cleaning, data selection and data transformations may be added to the library.
The function of the storage schema layer is to provide efficient access to the data requirements of various accumulation and mining processes in the core layer .The services of this layer are used by accumulation process for storing the KC and by the mining process for retrieving KCs while merging and mining. This layer is in-strumental in providing physical data independence to the user applications.
Meta-data for all the compiled knowledge discovery schema the system. It is used for knowledge discovery and, restricted reuse and sharing of knowledge. Because the stored schemas document the entire set of KDD operations in the organization, the meta-data becomes an important asset and a point of control for knowledge management.

The data exchange interface is instrumental in achieving the goal of independence of the KDD process with respect to the d ata sources. For supporting mining of new data types, the interface can be augmented with new access methods with the help of DEI manager in the front-end layer.
Other issues that need to be addressed for smooth execution of the KDD processes in the I-MIN system include privacy and security-related policies, backup and recovery, etc. Privacy and security of the discovered knowledge can be managed by restricting access to schemas. KDA handles all suc h issues in accordan ce with the domain requirement.
In the I-MIN system, each functional compone nt described in the previous section is implemented as a set of functions specific to the knowledge type and mining algorithm. These functions are accessible to t he users as operators in a declarative query language, called intension mining query language , and as corresponding APIs in user applications (Bhatnagar 2001).
 otherwise mentioned .
 have multiple operators to provide diverse functionality. F map to more than one operator, each provid ing unique functionality (Sect. 3.2). Op-erators are logical in nature and are mapped to appropriate functions during compi-lation of either schema (for accumulation ) (as shown in Fig. 9) or application/query (for merging and mining ). This mapping is required in view of the support for dis-covering diverse knowledge types using different algorithms.
A set of primary operators provides basic functionality for constructing windows, i.e. accumulation , resizing the windows as per the user requirement, i.e. merging and discovering knowledge, i.e. mining . The ACCUMULATE operator is not accessible to the user and is invoked by the system process during the accumulation phase.
The MERGE operator is invoked at the system level to construct the window of size specified in the user applications and is transparent to the user. Mining operators are the only primary operators that can be explicitly addressed by the user in queries and applications, subject to authorization.
Secondary operators provide functionality fo r exploring arbitrary subsets of a database and comparing or contrasting characteristics of two or more subsets of the same.
Some of the secondary operators allow storage and retrieval of previously discovered knowledge, while others provide processing capabilities. These operators are instru-mental in creating the environment for user-centric mining and sharing the knowledge by multiple users simultaneously, and provide functionality for knowledge manage-ment. Like primary operators, they can be invoked either through a query command or embedded in the applications using APIs. A framework for design of intension mining query language and mining applications based on this language is given in Bhatnagar (2001).

Primary and secondary operators for association rule mining have been reported in Gupta et al. (2000). A user interacts with the I-MIN system during planning and mining phases (Sect. 2.1).
The system accepts the user command and ret urns back the desir ed results. During the planning phase, the interaction is primarily focused around administrative needs, mining schema specification and maintenance of the system. These functions fall under the purview of the KDA. The end users interact with the system during the mining phase. The functionality required during this phase is knowledge discovery and knowledge management. End users can either use declarative query language for mining or develop applications in a procedural language for knowledge discovery and management.
Analogous to the data definition language for c reation of database schema, a suitable mechanism is required to accept the mining requirements of the end users. The input at this stage is accepted through a form and is compiled to output meta data. An example form for defining a schema for association and classification rules can be found in Bhatnagar (2001). However, language issues analogous to those of data definition language of databases still need to be addressed here.

Installation of new components/presentation tools/ premining functions and up-grading of the existing modules constitute some of the system maintenance tasks. Three categories of end users have been identified in database environment (Codasyl
Systems Committee 1971; Silberschatz et al . 2001). The database interfaces are corre-spondingly developed to suit their functional needs and sophistication levels. Though the number of end users of data mining is rel atively small, the categorization of the end users and their sophistication level can be assumed to be similar (Fig. 10). Simi-lar interfaces are desirable for each categor y. The three categories of end users are: (i) Naive or parametric user: A naive user is certainly not a data mining expert (ii) Sophisticated user: A sophisticated user may be knowledgeable about data min-(iii) Data mining analyst: Is capable of developing applications to meet the require-
A framework for a declarative SQL-like query language (IMQL) has been developed to enable sophisticated users to formulate their mining requirements. Mining require-ments that can be anticipated and possibl y parameterized can be satisfied by mining analysts who develop applications in either procedural language or query language. These applications can be subsequently used by naive users.

IMQL is an SQL-like declarative query language that allows users to formulate queries for mining new knowledge as well as exploration from already discovered knowledge, proposed in Bhatnagar (2001). The schema name in the query identifies the context. The user specifies the time span to identify the subset of database, the constraints and the parameters.

Three simple queries are listed below. User-given input is shown in boldface letters.

Example 6.1. Discover and store all association rules in my-file , for time-span Jan99 to Jun99 , which have antecedent as subset of items {I1, I7, I8} , and large item-set size  X  k . Use support  X  x and conf  X  y and the context is KDS-ASSOC schema DO GETRULES ON SCHEMA KDS-ASSOC SPAN FROM Jan99 TO Jun99 WITH CONSTRAINTS ANTE  X  {I1, I7, I8} AND LITSIZ  X  k USING PARAMETERS SUPPORT  X  x AND CONF  X  y STORE IN my-file
Example 6.2. Generate classification rules in CL96-00 for the training set that evolv-ed between Jan96 to Jan00 using only top K rules from each class, with acceptable misclassification error and misclassification cost matrix MM1 DO GENCRULE ON SCHEMA KDS-CLASS SPAN FROM Jan96 to Jan00 WITH CONSTRAINTS M C  X  ERR &lt; AND HIRULE = K USING PARAMETER MCM = MM1 STORE IN CL96-00
Example 6.3. Classify the data set Data-01 using the classifier CL96-00 and store the result in MY-FILE DO CLASSIFY ON SCHEMA KDS-CLASS USING PARAMETER DATA = Data-01 AND CLASSIFIER = CL96-00
STORE IN MY-FILE
I-MIN system supports development of mining applications to satisfy mining needs of the end users. Such needs may be either generalized, i.e. required by a number of end users for different parameters, or too complex to be formulated in IMQL. Mining analysts design such applications in th e context of specific KDS and the end user can satisfy their knowledge needs by invoking the application with suitable parameters.
The application programming interfaces for t he mining operators are available, which can be embedded in the logic of the applications.

In this subsection, we present two examples of applications that satisfy complex mining needs.

Example 6.4. Compare the large item-sets in periods Jan95 to Jun95 and Jan98 to Jun98 with support value  X  x and identify those large item-sets that are either new or missing in a later window. Store the result in two different files. Example 6.5. Generate classifiers for periods Jan96 to Jan97 and Jan98 to Jan99 .
Use function MY-FUNC and deviation limit to identify deviation in the rules for classes C1 and C4 . Display the result on standard output device.
 in classification rules for desired classe s. MY-FUNC reads the classification rules of the classifier into memory and applies a predefined deviation function. By varying the deviation limit , the ad hoc user can experiment with the KDD process. the objective, can be found in Bhatnagar (2001).
Implementation of the complete I-MIN data mining management system is a gigantic task. It involves issues regarding communica tion (between the layer s), scheduling (for accumulation processes), query processing (during mining phase), data storage (for
KCs), etc., which would normally arise in design and development of any software package of this magnitude and complexity. In order to evaluate the feasibility of the design and data mining/knowledge management functionality, we chose to concen-trate on core issue viz. designing mining algorithms, which constitute the functional module (Fig. 7). In this section, we present our observations and experiences in research and development ca rried out in this direction.
 quired to be phased and incremental in nature (Table 2). Design of data structures for knowledge concentrates is automatically implied during design of algorithms. Re-call that a knowledge concentrate (KC) is a condensed unit of intermediate form of intended knowledge, abstracted from the database, and can be independently mined for intended knowledge. The aggregate to be computed has to be suitably defined de-pending on the mining algorithm intended to be used. KCs should essentially contain sufficient information to rule out any loss in trend, howsoever insignificant. Further, the information should be unbiased by any user-specified parameter to ensure com-pleteness of the discovered knowledge.
 responding KCs, we characterize additive property as an essential property of KCs.
This property is fundamental to the merge operator described in Sect. 5. It is the responsibility of the designer of the algorithm to design the KCs in such a way that the additive property is guaranteed. Generation of knowledge concentrates requires extra secondary storage, which apparently is an overhead. However, the benefits that accrue outweigh the expense. The storage requirement is largely data driven and depends on the data structures used.
 plementation of intension mining . The design issues are analogous to those arising during design of synopsis data structure (Gibbons and Matias 1999). The design is influenced by not only the type of knowledge to be discovered but also by the functionality sought and the mining algor ithm intended to be used. KCs should be quick to be swapped in and out of memory to ensure acceptable performance of the mining algorithms.
We summarize, in the following subsections, the design of KC for some of the commonly performed mining tasks.
We chose the Seq algorithm proposed by Meo (1999) for implementation of our ap-proach because of its natural a menability to incremental imp lementation (Bhatnagar 2001).
 We enhanced the selected algorithm to IM-SEQ algorithm to fit in our framework.
IM-SEQ consists of four modules, one each for accumulation, merging, and two for mining (p. 318). One of the mining modules generates frequent item sets and the other generates strong rules. The accumulation module generates trees ( T a sequence tree for item I ) for the incremental database. The data structure ( T constructed by this module stores the knowledge concentrates . Each T the support counts of all the lexicographic sequences that begin with item in the database. After accumulation , all the sequence trees are stored as files. Further, a his-tory file is also updated, in which certain statistics are saved after each accumulation . The primary and secondary operators operate on the KCs. During the mining phase,
T can yield the support counts of all item-se ts in the database without scanning the database.

For the database shown in Fig. 11, Fig. 12 shows the data structure of the know-ledge concentrate for database increments  X  D 1 , X  D 2 tively.

We generated a synthetic database usin g Srikant (in press). Experiments were carried out to evaluate the feasibility of the scheme and performance of the algorithm.
The results led us to following conclusions. (a) The space occupied by the KCs is related to the window size, besides data char-acteristics. Smaller sized windows are more expensive in terms of storage, though they provide more flexibility in mining. The trade-off between the required flexi-bility and the storage available must be resolved at the time of schema design. (b) The time required for merging the windows scales with the size of the target window and the number of merged windows (Fig. 13). The speed of the user applications will therefore depend not only on the number of windows merged but also on the size of the target window. (c) Time required to mine on a window using KC is considerably less compared with Apriori algorithm (Fig. 14). For smaller windows and support levels, the improvement is substantial.

By choosing a suitable window size, the KDA can optimize the extra space re-quired and the response time of the mining queries.
We have experimented with the rule-ba sed approach (Dasgupta 2000; Bhatnagar 2001) and decision tree approach (Gupta et al. 2002; Suresh 2001) for classifica-tion in the intension mining framework. For performing the task of clustering, we found BIRCH clustering algorithm (Zhang et al. 1996) to be naturally fitting in our framework. This algorithm also identifies with our basic principle of condensing data. discovering classification rules in the intension mining environment. Generalized re-lations for incremental database serve as KCs. A merge sort algorithm is used to merge these KCs to produce consolidated generalized relations from which rules are discovered. In Bhatnagar (2001), association rule-based classification in the inten-sion mining framework has been studied. Algorithm IM-CBA has been developed as an enhancement of the CBA algorithm (Liu et al. 1998). The KCs constructed during accumulation store association rules in addition to the data structure of the
IM-SEQ algorithm. During mining, the rules in different windows are merged as per the ordering criteria specified in Liu et al. (1998), and the classifier is generated. has been studied. The work uses a Trie structure to store KCs, which holds the common information as prefixes that are sto red only once. The leaf of the trie rep-resents the class value and the class count 7 . This feature of tries enables compression of data and encourages faster transfer to and from the memory. To achieve a better compression ratio, the data set attributes are arranged in the increasing order of the cardinality of domain during preprocessing ( accumulation phase ). Use of this heuris-tic further optimizes the space requirement of KCs. An example of this data structure for an example database is shown in Fig. 15. Tries are merged in pairs just before mining. Sequences along with the class count are read from one trie and followed in the other. If the sequence is present, the class count and probability is updated; otherwise, the sequence is added. It is trivial to show that merging preserves the class counts and probabilities. The resultant merged trie holds the entire information for the user-specified window under consideration for mining. Subsequently, the ID3 (Quinlan 1986) algorithm implemented in Weka software is used to process the trie and construct a decision tree classifier.

The scheme has been implemented and subsequently evaluated for Congress data-set downloaded from the ML Repository (University of California at Irvine 1998).
It was found that there was a significant decrease in the modeling time for decision trees from the KCs than the training set directly. This is because the KCs contain data that is already preprocessed. The response time perceived by the user is only the time for merging the KCs and modeling. However, this advantage gets diminished with decreasing redundancy in the dataset. It has also been found that the KC input to the modeling algorithm results in smaller and more compact trees, with negligible reduction in accuracy.

The BIRCH algorithm (Zhang et al. 1996) for clustering is inherently incremental and identifies with our basic principle of c ondensing data. The cluster feature trees (CFT) constructed during the (only) scan of the database naturally map to the cu-mulative knowledge concentrate (Gupta et al. 2000). The idea has been extended in the intension mining framework. The algorithm has been enhanced to three distinct modules that perform accumulation, merg ing and mining. The accumulation module constructs CFTs for incremental databa ses and stores them as KCs. Because the KC summarizes a subset of the dat abase instead of the compl ete database, the memory limitation encountered during summarization in BIRCH is automatically overcome.
At the time of actual mining, the CFTs ( windows ) are first merged and subsequently mined using any clustering algorithm.
 heshwari (2000). The Iris dataset (University of California at Irvine 1998) is used in this study. It was found that the clustering patterns obtained over different window sizes were quite similar. The work reports that the discovered clustering scheme was marginally better than that obtained using Mineset.
We have presented a user-centric model (I-MIN model) for KDD processing and an architecture for a data mining managem ent system based on it. The I-MIN system reinforces an iterative, interactive and operator-based approach to facilitate a dynam-ically changing search focus during exploration, at the end user level. Motivated by the three-tier architecture of DBMS, it is an endeavor toward a mining platform ex-tending support for knowledge management, cataloging all the KDD endeavors in the organization. Mining operators are provided to develop applications to meet ongoing knowledge needs of the organization. The architecture permits knowledge discovery in a platform-and domain-independent manner and knowledge preservation, know-ledge renewal and knowledge sharing for effective knowledge management.
