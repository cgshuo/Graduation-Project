 The proliferation of the Internet, Web technology, and sensor networks highlight the need for treating data as a continuous data stream. One major challenge is the devel-opment of techniques for providing continuously updated answers to aggregate queries over potentially unbounded streams. A general approach for addressing this challenge is by means of windows queries, which add window clauses to continuous queries and thus allow aggregate queries to be evaluated over a segment of the input data stream rather than over the entire stream. There has been a great deal of research on develop-ing algorithms for windowed aggregate queries [2,5,6,9,10,12,13].
 languages over streams do not have the necessary constructs to support condensative query processing over streams, as is the case in traditional DBMS s . We call aggregate query processing in a traditional DBMS condensative , since the answer to an aggregate query is usually much smaller than the answer to its non-aggregate counterpart. Having a declarative stream language that supports condensative query processing is crucial since data streams are potentially unbounded, while main memory and secondary stor-age have fixed limits; new query results shoul d therefore be generated whenever the window contents change. Secondly, the focus of previous work has mainly been on query evaluation while fundamental questi ons in connection with data models and for-mal semantics for queries have not yet been thoroughly addressed. This lack makes it difficult to reason about aggregate queries and compare different languages in a uni-form semantics. The situation is aggravated when one moves to the realm of distributed computation, as is usually the case when dealing with data streams.
 Scenario and Example Queries. In practice there has been an increasing need for aggregate queries. To illustrate this, consider a scenario of Grid monitoring where one wants to know the current state of the Grid and its status in the past. Suppose we have a core relation cpu that publishes the results of monitoring CPU workload. The relation has the following schema: cpu id, site, load, timestamp ,where id denotes a unique machine identifier, site denotes where the machine is located, and load records the current CPU load of the machine. Consider the following queries: Aggregate query: For every 1000 new measurements and for each node (site) N in the Nested aggregate query: On a per-hour basis and for machines located at Heriot-Watt The above queries demand  X  X umping X  between two different granularities: a tuple-based granularity and a time-based granularity, respectively. We term such a query a mixed jumping window query. In addition, the second query requires nested aggregation to be computed w.r.t the nested jumping window. Note that neither the current stream data model, nor window aggregate operators support such queries  X  not even in the case of a centralized DSMS (Data Stream Management System).
 Prior Work. To the best of our knowledge, the most expressive language for specify-ing window queries is StreaQuel, implem ented in TelegraphCQ [7]. In StreaQuel, each query is defined in terms of a for-loop construct that specifies (1) the set of windows over which the query is to be executed, and (2) how often the query should be run. gregate queries. Their window definition has three parameters: RANGE specifies the window size, SLIDE the window movement, and WATTR the granularity, i.e. ,whether RANGE and SLIDE are defined in terms of timestamps or sequence numbers of tuples. All these patterns were defined with respect to window identifiers. Such semantics de-fine a function to uniquely identify each wi ndow extent for a given window aggregate query; also, they require an inverse function t hat, for each tuple, it determines the ex-tents of the window to which the tuple belongs. Window identifier semantics was imple-mented in an extended version of the Niagara Query Engine [8] for evaluating aggregate window queries over data streams. Note that none of those approaches can express the example queries given above. The reasons are that (a) frequency and window length need to be defined in terms of the same granularity, and (b) the frequency over the input stream cannot be differentiated from the frequency over the result stream. Widely differing approaches employing, e.g. , hashing, sampling, sketches and wavelets, just to name a few, have been proposed in the literature [4,11,12,14]. All those ap-proaches, however, are workload-driven, as opposed to being user-driven. In more de-tail, it is desirable to give the user considerable freedom in how windows are defined and handled by the system. In other words , the user should be in a position to declare window semantics at the language level, rather than rely on the system to deduce trade-offs between accuracy and resource consump tion, as is usually the case. This is what we term condensative query evaluation : the user should be able to merely declare how fre-quently sampling should take place and the system should perform aggregation based on the user X  X  instruction.
 Contribution and Overview. In order to make existing stream query languages more expressive and support user-driven condensative processing over data streams, we in-troduce a new model, referred to as the sequence model , and novel operators, termed frequency operators . Our model and stream operators have a solid theoretical founda-tion, and are capable of expressing previous models and operators. As a result they provide cleaner semantics, allowing us to better understand and reason about aggregate queries over streams. More specifically, our main contributions are the following:  X  We present a formal semantics that models time-varying stream data as a function  X  We introduce a novel operator, termed the frequency operator , along with its for- X  Based on the previous two ideas, we have implemented our conceptual operators Organization. Section 2 reviews sequence databases and the time-based data model. Sections 3 and 4 introduce the formal semantics of our language. Section 5 presents our experimental results, while S ection 6 concludes the paper. In this section we review two previous data models from which our model draws some features.
 2.1 Sequence Database Model The SEQ sequence model and algebra were introduced by Seshadri et al .in[17],which defines sequences as an ordering function from the set of integers to each item in the sequence. The SEQ model separates the data from the ordering information, and it can deal with different types of sequence data by supporting an expressive range of se-quence queries.
 and aggregation (including moving windows) are carried over from the relational data model. There are also many new operators developed specifically for manipulating se-quences. The SEQ model has been implemented in SRQL (Sorted Relational Query Lan-guage) [16]. 2.2 Time-Based Stream Model In a streaming environment, data items appear in a time-varying, continuously arriving, and append-only fashion. In order to capture its constantly changing essence, a for-mal semantics, in the form of the time-based stream model , and the Continuous Query Language [3] ( CQL ) were introduced in [1]; CQL has been implemented in the STREAM system [15]. Continuous queries can be registered against a data stream S or relation R . More formally, one can give the precise semantics for streams and relations as follows: Let D R be the set of all tuples that satisfy the schema R .Let T be the set of all times-tamps. Then, a stream S with schema R is a subset S X  X  R  X T , such that for every  X   X  X  the bag { e | e,  X   X  X } is finite. With P ( D of D such that each set R (  X  ) is finite. With these definitions, we can have transformation from a stream to a relation w.r.t. time. In a time-based model the order of tuples is not uniquely defined. This drawback leads to ambiguous semantics for continuous queries involving tuple-based sliding windows or moving aggregation. To address this issues, we draw features from sequence databases and construct a sequence-based model for streams. In this section we introduce our model and a well-defined formal semantics. As will be seen, our model is more ex-pressive than the time-based model. An abstract relational stream has the following characteristics:  X  A stream consists of tuples;  X  A stream has a relational schema and all its tuples adhere to that schema;  X  A stream develops over time. Therefore, it is assumed that there is a set T to rep-Relational Schema. A relational schema has the form: where R is a relation symbol, a 1 ,...,a k are attributes, and T 1 ,...,T k are types as in SQL . In the time-based model, the timestamp is an optional attribute. It is used only if there is a need to separate the generation time and arrival times of a tuple. In the se-quence model, however, we say that a timesta mp attribute should be present by default and it records a tuple X  X  arrival time.
 Time Domain. Although there is no restriction on whether the time domain is modeled after real clock time or natural numbers, it is still required to define its general proper-ties. A time domain should be ordered .Let : X  X  X be an ordering ( i.e. , is reflexive, antisymmetric and transitive). For every ordering we define the strict version of by x y iff x y and x = y . A binary relation is: Linear: if for all x, y  X  X we have either x y or y x .

Dense: if for all x, y  X  X where x y , there exists a z  X  X such that x z and
Discrete: if for every two elements x, y  X  X there are only a finite number of elements If a linear ordering is discrete, then for every element x  X  X , there is either a least element that is greater than x , or there is no element greater than x . We specify that a time ordering should have following properties: Definition 1 (Time Domain Properties). (1) Any two timestamps must be comparable, discrete.
 A time domain with these properties is essentially identical with either the set of all window. A window of length n consists of the starting point plus the next ( n  X  1 ) elements. An unbounded window can be modeled by only specifying its starting point. the set of all tuples that satisfy relational schema R . By default, every relational schema has an attribute  X  , called the timestamp attribute, which is of type D AT E T IME .Weuse N to denote the set of natural numbers and model a stream S for a relation R as a partial function from the natural numbers to D R .
 Definition 2 (Sequence Stream). A stream for a relation R is a partial function S : N  X  X  R , such that whenever S ( n ) is defined for some n  X  N ,then S ( m ) is defined for every m&lt;n , as well. For every stream tuple S ( n ) we denote the value of its timestamp attribute as S  X  ( n ) .
 According to the definition, a stream S is either defined for all numbers, or there is a number n  X  N such that S ( n ) is defined and S ( m ) is undefined for all m&gt;n .A special case is the empty stream, denoted as  X  , which is undefined for every n  X  N . Observe that our definition does not make any assumption as to whether the timestamps of tuples and the order in which tuples arrive are compatible. However, some stream operators only make sense over streams where the tuples arrive in the order of their timestamps.
 Definition 3 (Ordered Stream). Astream S is ordered if for all m , n  X  N we have that S  X  ( m )  X S  X  ( n ) whenever m  X  n .
 In this way, we allow different tuples to have the same timestamp, but they will still be ordered among them. Note that our model does not make assumptions about how often tuples arrive. In this section we shall use our model to define the existing sliding window operators, as well as the novel frequency operator. We show that queries expressible in the time-based model can also be specified in the sequence model. Furthermore, as will be seen in Section 4.5, it is possible to use the sequence model and associated operators to express queries that go beyond the capabilities of previ ous models and query languages. 4.1 Sliding Window Operators We express the bound of the sliding window either as W n for a tuple-based sliding window or W t for a time-based window. (1) Tuple-based Sliding Window: A tuple-based sliding window will slide whenever a new tuple arrives. For every n  X  N , we have a tuple-based sliding window W n over stream S , which produces a sequence of sets W n S ( j ) : (2) Time-based Sliding Window: A time-based sliding window W t is bounded only by time t , while we do not know how many tuples are exactly within the window. However, it slides as time progresses. The sliding rate obviously depends on the time granularity. More formally, we define the output stream W t S of a time-based sliding window as a sequence of sets W t S ( j ) for a given j in stream S .Wesay W t S ( j ) is not defined if S ( j ) is not defined, otherwise we have 4.2 Frequency Operator The frequency operator F will pick the stream tuple based on a defined frequency. Depending on the unit used to set the frequency ( i.e. , number of tuples, or time) we can have either (a) the tuple-based frequency operator F n , or (b) the time-based frequency operator F t respectively. (1) Tuple-based Frequency Opera tor: For every natural number n  X  N we have a tuple-based frequency operator F n , which selects every n -th tuple of a stream. Formally: (2) Time-based Frequency Operator: For every time instance t , we have the time-based frequency operator F t , which selects tuples with timestamp j  X  t as a new stream F t S , where j  X  N . If there is no tuple with timestamp j  X  t , then we will output the last tuple within that time slot. We say F t S ( j ) is a subsequence of tuples with order j over order n j of stream otherwise it is undefined. Now, F t S ( j )= S ( n j ) ,forall j  X  N if n j is defined, other-wise F t S ( j )=  X  . 4.3 Jumping Window Sometimes, we want our window to move faster than the rate at which it is sliding. In-stead of posing the frequency operator over a sequence of tuples, we can also pose the frequency operator over a sequence of sets. We term such kind of a window a jumping window . Depending on how we set the frequency length, we classify the jumping win-dow into two different types: tuple-based jumping windows and time-based jumping windows. (1) Tuple-based Jumping Window: For every number n  X  N , and a sequence of sets W
S that are produced by the sliding window operators W based jumping window F n ( W S ) , which selects every n -th set of W S as follows: (2) Time-based Jumping Window: For a sequence of sets W S that are produced by the sliding window operators, we have a time-based jumping window F t ( W S ) by selecting a subsequence of sets with index j over index n j of W S w.r.t. every time instance t . We d e fi n e F t ( W S )( j ) for an arbitrary stream S and a window operator W n or W t recursively by saying what it is the set F t ( W S )( j ) for an arbitrary number j .Wefirst define the set of indices I 1 as If I 1 =  X  ,thenlet n 1 =min I 1 , and define ( F t ( W S ))(1) := W S ( n 1 ) , otherwise let F ( W S )=  X  . Now, suppose n j is defined for some j  X  N .Thenlet otherwise ( F t ( W S ))( j +1)=  X  . However, it is possible that ( F t ( W S ))( j +1) is not defined because S  X  ( k ) = j  X  t. For this case, we will output the latest set W S ( n j ) within time [( j  X  1)  X  t, j  X  t ] where 4.4 Local and Non-local Semantics A stream operator is a function  X  that takes a stream S as input and outputs a stream  X 
S . There should be a simple semantics to categorise all stream operators beyond the differences of the various stream data models. To this end, we introduce the semantics of local and non-local operator types for stream languages.
 the set of all tuples that satisfy the schema R .Let  X  denotes the value of the timestamp attribute of the tuples and T be the set of all existing timestamps. A stream S in the sequence model can map to time-based model for all existing values of  X  : Suppose we have an operator Q that transfers a data stream S from a sequence model to a time based model QS ,and QS (  X  ) represents a bag of the tuples that have a timestamp equal to  X  .
 Definition 4. We s a y  X  is local if: otherwise it is non-local.
 Such semantics provide the theoretical foundation of evaluating the operators in a uni-form data model. Using it, we can easily define the semantics of the frequency operators in the time-based model. Note that as a time-based model is not aware of the order of tuples, we can only rewrite the semantics of our time-based operators within the time-based model.
 Time-Based Frequency Operator. For every time instance t ,wehaveatime-based frequency operator F t . Conceptually, it selects sets with timestamp ( j  X  t ) as a new stream F t S . We then define ( F t S )(  X  ) for all j  X  N : Time-Based Jumping Operator. For every time instance t , and a stream W S that is produced by a sliding window operator, we have a time-based Jumping window F ( W S ) obtained by selecting a bag for every t instance from stream W S .Wethen define ( F t ( W S ))(  X  ) for an arbitrary time t ,where t  X  X  as: 4.5 Example Queries In a SQL -based language, a frequency operator can be expressed by adding to the range variable of a stream, say S , the expression [Frequency F ] ,where F denotes as in [Frequency n Tuples] ( i.e. , X  X very n tuples X ), or in terms of a time pe-riod, e.g. , [Frequency t Minutes] ( i.e. , X  X very t minutes X ). The operator picks tu-ples based on the predefined frequency length from the stream. To denote group-based sampling, we use [Frequency F Partitioned By A 1 ,...,A k ] . The operator par-titions S into different substreams based on the grouping attributes A 1 ,...,A k ; then, for each substream, the operator picks tupl es based on the predefined frequency. We separate the frequency over an input stream and a result stream by putting the frequency expression in either the FROM clause or the SELECT clause respectively.
 denote jumping windows. Saying Frequency = 1 Tuple is equivalent to a normal sliding window. Depending on how the frequency length is defined, we distinguish be-tween tuple-based and time-based jumping windows. Instead of computing the answer whenever a new tuple arrives, the frequency operator requires a computation only after an interval of the frequency length. This means that, the operator will  X  X leep X  between any two computations. A jumping window has two parameters:
The window size W . All tuples that arrive from the start during a period of length W ,
The  X  X leep X  length F . A new window is only output after the system sleeping for the A jumping window is always defined by a sliding window operator followed by a fre-quency operator expression, as in [Range W , Frequency F ] . Our semantics sup-ports the mixing of tuple-based frequencies with time-based window bounds and vice versa. Such windows are called  X  X ixed jumping windows X .
 languages by giving the example queries into extended SQL with the proposed language construct.
 Query 1. For every 1000 new measurements and for each node (site) N in the Grid, and for machines located in N in the last hour, how many of those machines currently have a CPU load less than 30%? This mixed jumping window query will count , for each site and after every 1000 tuples, the total number of computers that currently have a CPU load of less than 30% in the last hour X  X  worth of CPU tuples. It returns all the results obtained by evaluating the relational query over the window, at the end of each sleeping period.
 Query 2. On a per-hour basis and for machines located at Heriot-Watt University, what is the average number of machines that had a CPU load less than 30% during the last hour? The previous aggregate query could be used to evaluate the nested aggregate one. This query contains a nested frequency. Note that the nested frequency synchronizes the inner and the outer queries so as to avoid duplicate answers. Although the inner frequency is bounded in terms of tuples, it can still be controlled by the outer frequency (every minute). Finally, note that it is possi ble to register the inner query independently and use it as a primary source for answering the outer query. To evaluate the effectiveness of our seman tics, we implemented our conceptual opera-tors in a prototype query engine and conducted a preliminary experimental study. Our framework was implemented in Java and our experiments were executed on a Pentium IV 2.4Ghz with 512M of physical memory. We report wall clock timings and calcu-late execution time by measuring the average cost of 10000 answer tuples. Streaming behavior was simulated by using a pull-based execution model: the more effective the algorithm, the more tuples it is able to process. A frequency operator typically spends its time sampling and aggregating, so there is a clear division of work. We are interested in showing how it is possible to optimize the sampling cost in such an environment, as we want to treat the efficiency of the aggregation algorithm as an orthogonal issue. Therefore, we used the same aggregation in all experiments, and have calculated the ex-ecution time as the sum of scanning the input stream and producing the aggregate. As a result, any performance gain we observe w ill be due to the efficiency of the sampling methodology, which is directly tied to how well the semantics of the operators can be implemented.
 pushed down frequency operators in contra st to the window identifier approach for a tuple-based jumping window ( AVG ) query. Note that we consider the case where one tuple may be in the contents of multiple windows. The efficiency of evaluating queries without or with a GROUP BY -clause is shown in Figures 1(a) and 1(b) respectively. The horizontal axis is the frequency length measured in tuples. The vertical axis is the performance ratio between the execution time using a pushed down frequency opera-tor, over the execution time of the window identifier approach. The window length is represented as a percentage of the frequency length. For example a 30% W/F ration for a frequency length F of 1000 tuples will evaluate the query over a window length bounded by 300 tuples. As an independent opera tor, the frequency operator can be eas-ily pushed down in a query plan to avoid unnecessary computation. This allows us to split aggregate query processing in two levels: (i) tuple sampling, and (ii) aggregation evaluation; this modeling provides a flexible mechanism to interact with different ad-vanced aggregate operators. Our experiment showed that pushing down the frequency operator is an effective technique and it significantly outperforms the window identifier approach. Secondly, we evaluate the efficiency of processing mixed jumping window queries, which cannot be handled by existing approaches. Figure 2 shows the upper bound performance time of a mixed jumping window ( AVG ) query that has a frequency length specified on a tuple basis and a window length specified on a time basis. The horizontal axis is the frequency length (measured in tuples) which the window length is measured in seconds. The vertical axis is the total execution time (per answer tuple ap-pearing in the average) meas ured in milliseconds. Note that performance can be further improved if a more efficient aggregation algorithm is employed. We have studied stream queries from a theore tical angle. More specifically, we have incorporated sampling in a declarative fashion to a query language. We have also in-troduced a formal semantics for both the new data model and proposed the frequency frequency operator for extending stream query languages with more expressibility, i.e. , allowing for user-defined sampling and condensative query processing. Our new fre-quency operator can be combined with the existing sliding window operators, a frame-work that yields the powerful  X  X umping window X  operators. Those allow for mixed window specification ( i.e. , both tuple-based and time-based) that can not be handled by existing query languages. We have tested the viability of the appr oach by performing an experimental study based on the optimization heuristic of pushing down such oper-ators closer to the input streams. The preliminary results verify the effectiveness of the approach.
 ing advanced aggregation algorithms with the proposed operators and providing a more thorough experimental study. Second, we would like to extend the semantics to address information integration scenarios that require the ability to automatically construct dis-tributed query plans, based on techniques of answering continuous queries using con-tinuous views. A key operation in creating such plans is determining whether a query is contained in another query. While this problem has been thoroughly investigated for queries over static databases, it is still open f or continuous queries. F requency operators may play an interesting role in this research, since they will give rise to further possibil-ities of containment. As the frequency operator is a declarative way of describing how to transform streams into smaller result streams, it will be useful for queries in large distributed applications.
 Acknowledgments. The authors would like to thank Werner Nutt and Alasdair J. G. Gray for valuable discussions and comments. Werner Nutt played a significant role in shaping the main idea of the paper.

