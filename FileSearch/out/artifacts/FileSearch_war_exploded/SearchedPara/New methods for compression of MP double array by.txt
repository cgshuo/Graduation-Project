 1. Introduction
Trie is an ordered tree data structure used to store strings. The term  X  X  X rie X  was coined by Fredkin from the word  X  X  X e-
Traditionally, a trie was represented either by a two-dimensional array called the matrix form or by a two-dimensional list called the list form. The matrix form uses an array of pointers to access subtrees directly. The list form relies upon fast.

Aoe (1989) presented a new method called the  X  X  X ouble array X  that combines the fastness of the matrix form with the compactness of the list form. The double array for a reduced trie is called a Minimal Prefix (MP) double array. A MP double array uses two one-dimensional arrays called BC and TAIL. The array BC represents trie nodes and the array TAIL stores suffix strings. Aoe, Morimoto, and Sato (1992) demonstrated that the double array not only uses smaller space than the list form, but also makes deletion and retrieval faster than that of the list form.

As the trie is a very efficient and popular data structure for storing strings, it has been widely studied and many other researchers have also proposed various improved methods of implementations for different applications ( Bentley &amp; Sedge-1999 ). However, the MP double array is found to be more compact than other state-of-the-art dynamic implementations of 2007; Heinz et al., 2002 ).

The original double array ( Aoe, 1989 ) offered fast retrieval at time complexity of O (1), but its major drawbacks were that the insertion was not so fast and the deletion produced empty elements that degraded space efficiency. Therefore, Morita,
Fuketa, Yamakawa, and Aoe (2001), Morita, Tanaka, Fuketa, and Aoe (2001) and Oono, Atlam, Fuketa, Morita, and Aoe (2003) presented improvements that made insertion and deletion faster. Further Yata, Oono, Morita, Fuketa, and Aoe (2007) pre-sented a compact deletion method for Minimal Prefix (MP) double array. These methods have not only made dynamic up-dates on the double array faster, but also made the MP double array more compact.

However, the major drawback of the existing MP double array is that its space efficiency is degraded by the presence of empty spaces in the array TAIL that holds the suffixes of keys. Empty spaces in TAIL are produced during the insertion and deletion of keys in the MP double array. For an application requiring many insertions and deletions, this drawback will be major disadvantage for the MP double array. Therefore, we present three methods to overcome this problem through com-pact management of suffixes. The first two methods are: (1) accommodation of short suffixes of three bytes or less inside the leaf nodes, and (2) pruning of leaf nodes corresponding to the end marker symbol. These methods not only make the MP double array more compact, but also makes dynamic updates faster. The third method is the elimination of empty spaces from TAIL. It achieves further reduction in size but it slows down insertion time.

This paper is organized as follows: Section 2 presents the state of the art in compressed trie implementations. Section 3 presents the background of the double array structure including the state of the art and the existing drawbacks. Section 4 presents the new methods. Section 5 presents the results of experimental evaluation, and Section 6 presents the conclusion and future work. 2. State of the art in compressed trie implementations
To satisfy the need for storing larger key sets efficiently, researchers have made attempts to reduce trie space require-ments, many of them providing a different set of operations and complexities.

A popular implementation of the trie that supports dynamic updates is a Ternary Search Tree (TST) which is discussed recently by Flajolet (2006) , Broutin and Devroye (2007), Suri and Goel (2008), and Shani, Meek, Paek, Thiesson, and Venolia (2009) . Bentley and Sedgewick (1997) first presented the TST following early ideas of Clampett (1964) . TST combines the attributes of binary search trees and digital search tries. Like tries, they proceed character by character. Like binary search trees, they are space efficient, though each node has three children, rather than two. Searching for a string of length k in a described by Clement, Flajolet, and Vallee (1998) as the method of choice for managing textual data, since they offer the best time X  X pace trade-off of the hybrid trie structures.

Andersson and Nilsson (1993) introduced level-compressed (LC) trie which is a new technique for compressing parts of improvement in the LC trie for IP-address lookup is proposed by Fu et al. (2007) . Although LC trie supports the dynamic implementation of a trie, updates are not very efficiently supported as the data structure needs to be rebuilt every time the table is updated ( Pao &amp; Li, 2003 ).

More recently, Heinz et al. (2002) proposed a new data structure called the burst trie, which is a collection of small data space efficiency by selectively collapsing chains of trie nodes into small containers of strings that share a common prefix.
Askitis and Sinha (2007) proposed an improvement called the HAT-trie which uses cache-conscious hash tables. Compared to a Ternary Search Tree, the burst trie is claimed to be around 25% faster and uses only 50% of the memory, though it was found to be slower than TST with genomic data ( Heinz et al., 2002 ).

For applications that do not require dynamic updates, more compact static implementations of trie have been proposed such as the Lempel X  X iv (LZ) Trie ( Ristov &amp; Laporte, 1999 ), and the trie implementation based on the Level-Order Unary De-gree Sequence (LOUDS) representation ( Delpratt et al., 2006 ). 3. Double array 3.1. Double array structure
Double array is generally applied to a reduced trie ( Aoe et al., 1992 ) as it leads to a more compact representation. In a reduced trie, only the minimal unique prefixes of keys are maintained as nodes, and the suffixes are maintained separately as strings. The double array applied to a reduced trie is specifically referred to as MP double array. A MP double array uses two one-dimensional arrays called BC and TAIL. The array BC represents trie nodes and the array
TAIL stores suffix strings. An element of BC consists of two members called BASE and CHECK which are integers. The follow-ing are important concepts for the double array:  X  Except for empty elements, every element corresponds to a trie node. An empty element of double array is one that does not correspond to any key and is therefore not useful for retrieval.  X  The BASE of a leaf node indicates the position in TAIL array where the suffix is stored. But the BASE of a non-leaf node indicates offset to its child-nodes.  X  The CHECK is used to store the index of the parent node.  X  For instance, an element s of BC consists of BC[ s ].BASE and BC[ s ].CHECK corresponding to the node s in the trie. The fol-lowing equations represent an arc from node s to node t with a character  X  c  X : index of the source node s is stored in BC[ t ].CHECK.  X  A trie node without any sibling is called a single node and an element corresponding to such a node is called a single element.  X  A space in the TAIL array that does not contain any character corresponding to a key in the double array is called an empty space.
 Example 1. Fig. 1 shows the reduced trie structure and the state-of-the-art MP double array ( Yata, Oono, Morita, Fuketa, &amp; question mark is used to denote an empty space.
 In Fig. 1 , elements 11, 12 and 14 are empty elements because they do not correspond to any nodes in the reduced trie in
Fig. 1 , and are identified by negative values of both BASE and CHECK. An empty element is linked to the previous empty ele-ment by the absolute value of its BASE and it is linked to the next empty element by the absolute value of its CHECK ( Morita the parent node of a single node is identified by negative CHECK value. Hence, the CHECK of node 3 which is the parent node of single node 7, is negative.

Nodes 2, 4, 8, 10 and 13 are leaf nodes and are identified by the negative value of BASE. The absolute value of BASE of a leaf node correspond to the index position in TAIL where the remaining suffix is stored. For instance, the value of BC[4]. BASE is 12. It means that remaining suffix  X  X  X a# X  is stored in TAIL starting at the index position 12. The spaces occupied by the question marks in TAIL denote empty spaces created during insertion of keys in the key set K . 3.2. Basic operations on the double array 3.2.1. Retrieval
Consider searching for the key  X  X  bebra  X . First, the arc from the root node 1 to node 3 is established by BASE[1] + co-de( X  b  X ) = 1 + 2 = 3. CHECK[3] = 1. Similarly, other arcs with  X  e  X  and  X  b  X  are established as follows:
Since BASE[4] = 12, it means the remaining characters of the key are found in TAIL starting from the index position 12 till the end marker symbol  X  #  X . Thus retrieval is complete. The retrieval speed of a key does not depend on the total size of the 3.2.2. Insertion
During insertion, new nodes are defined by using the minimum possible value of BASE so that the length of double array remains compact. BASE can take any positive integer as its value. The new BASE values are calculated in such a way that the new nodes land on one of the empty elements within the double array if available. If it is not possible to use existing empty elements, the length of double array is extended. 3.2.3. Deletion
During the deletion of a key, the leaf node and the suffix corresponding to the key are undefined at first. Next, the parent node of the leaf node that was just undefined is examined. If it becomes a leaf node without any sibling, it is undefined. This continues until a valid leaf node is defined for the remaining key. In the process, some characters belonging to the remaining key get transferred to the TAIL array. 3.3. State of the art in double array implementation 3.3.1. Dynamic double array
The initial double array presented by Aoe (1989) suffered from two main disadvantages: (1) insertion and deletion were not very fast, and (2) empty elements created by key deletions degraded space efficiency. Morita et al. (2001) presented the  X  X  X ink Method X  to link empty elements of the double-array that made insertion faster by 6 X 320 times faster. This method provided a faster way to locate empty elements during insertion. Empty elements are denoted by the negative sign of both
BASE and CHECK, and they are linked through the absolute values of their BASE and CHECK. The absolute value of an empty element X  X  BASE corresponds to the index of the previous empty element, while the absolute value of its CHECK corresponds to the index of the next empty element. It forms a cyclic list with the last empty element, MAX + 1 linking to the first empty element as its next link, where MAX is the rearmost non-empty element. For example, in Fig. 1 , the empty elements 5, 11, 12 and 14 are linked in this way.

This method improved insertion time, but the problem of degrading space efficiency due to the empty elements created by key deletions persisted. Morita et al. (2001) presented methods to eliminate empty elements at each key deletion by relo-cating the rearmost non-empty element MAX and its siblings, termed  X  X  X ompression elements X  to empty elements inside the double array. While this helped improve the space efficiency, it had one inherent problem  X  compression would not be pos-sible if there are less empty elements than compression elements.

Oono et al. (2003) improved Morita X  X  method ( Morita et al., 2001 ) by using the properties of single nodes  X  nodes having no siblings. Oono X  X  method (Oono et al., 2005) moves the compression elements to not only empty elements but also single-elements appearing in large numbers in a non-reduced trie.

However, Oono X  X  method assumes single-nodes to be in the majority which is not the case for the MP double array. There-fore, Yata, Oono, Morita, Fuketa, and Aoe (2007) presented an adaptive deletion method which not only uses the empty ele-ments and single elements, but also elements that have fewer siblings than the element MAX for relocating compression elements. They reported that for MP double array, Oono X  X  method decreases the percentage of non-empty elements to under 60% while the adaptive method keeps the percentage of non-empty elements over 97% in a MP double array for English and
Japanese key sets. 3.3.2. Static double array Yata, Oono, Morita, Fuketa, Sumitomo, et al. (2007) presented a compact structure for a static MP double array. Further,
Yata, Morita, Fuketa, and Aoe (2008) applied the compact static double array to the implementation of a directed acyclic word graph (DAWG) for string matching and showed that it was superior in both time and space efficiency compared to tra-ditional DAWGs based on linked list and matrix forms. 3.4. Drawbacks of the existing MP double array
Representing trie in its non-reduced form leads to the formation of too many empty elements. Therefore, representing the arate array called TAIL is preferred. However, the appearance of empty spaces in TAIL degrades the space efficiency.
In the existing MP double array ( Yata, Oono, Morita, Fuketa, &amp; Aoe, 2007 ), empty spaces in TAIL are formed during the update operations of insertion and deletion. When the key being inserted has common prefix with an existing key which has part of the common prefix stored in TAIL, the part of common prefix located in TAIL gets shifted to the nodes of double array and leaves empty spaces behind in TAIL.

During deletion, empty spaces are created inside TAIL for two reasons: (1) the suffixes belonging to the key being deleted are removed, and (2) some part of the suffix of a remaining key get transferred to TAIL from BASE and CHECK arrays and this necessitates relocation of the entire suffix in TAIL.

For a dynamic MP double array requiring many insert and delete operations, the degradation of space efficiency due to the empty spaces in the TAIL array can be quite substantial.

A more compact management of suffixes in MP double array would not only overcome these problems, but also make some update operations faster. One of the obvious solutions is to enable re-use of empty spaces in the TAIL array, but it is complicated by the fact that the empty spaces are not contiguous and are sparsely distributed. Also, rearrangement would not be simple for a double array with thousands of keys. Therefore, we propose three methods for the compact management of suffixes in the MP double array in this paper. 4. New methods for compression of MP double array
In this section, we describe the three new methods that we propose for the compact management of suffixes to overcome the drawbacks of the existing MP double array ( Yata, Oono, Morita, Fuketa, &amp; Aoe, 2007 ). 4.1. Compression of short suffixes refer to as Method 1 stores short suffixes inside the BASE of a leaf node using bit manipulation, instead of storing them in TAIL.
 Although the idea is straightforward, its implementation requires some big changes to the existing program ( Yata, Oono, changed from 32-bit signed integer in the  X  Old Method  X  to 32-bit unsigned integer. Leaf nodes, single nodes and empty ele-ments are no longer identified by the signs of BASE and CHECK. Instead they are identified using bits in BASE and CHECK as bit flags as shown in Fig. 2 . In BASE, the two most significant bits are used as LEAF and SHORT flags. In CHECK, the two most significant bits are used as EMPTY and SNODE flags.

LEAF flag indicates whether a node is a leaf node or not, EMPTY indicates whether it is empty or not, SNODE indicates whether the node is the parent node of a single node or not, and SHORT indicates whether a leaf node stores a short suffix 1. The length of suffix is indicated by bits 3 X 8 of BASE. By using this method, up to 4 bytes including the end marker symbol can be stored as a short suffix and the storage space in TAIL can be saved.

Example 2. Fig. 3 shows the result of applying Method 1 to Example 1 . The tree structure has not been reproduced as there is bits 9 X 32. This new method has reduced the length of TAIL from 14 to 8, and helped compress the double array in this example. 4.2. Pruning leaf nodes defined by the end marker symbol
An end marker symbol  X # X  is used to distinguish between keys such as  X  X  be#  X  and  X  X  bed#  X . This symbol is replaced by the null character in implementation using C. Let us look at the nodes 2 and 10 in the tree structure of Fig. 1 . These nodes are defined only by the end marker symbol  X  #  X . Such nodes can be pruned to achieve further compression and substituted for with a single bit flag called END. The third most significant bit of BASE will be set aside as an END flag as shown in Fig. 4 . We will call this method as Method 2 .

Using Method 2 , there are two important changes in the original algorithm for insertion and deletion. When we insert a new key that has common prefix up to the leaf node of an already inserted key, inserting  X  X  bedecking#  X  when  X  X  bedeck#  X  al-ready exists for instance, we have to check if there are any more common characters between the suffix of the inserted key in
TAIL or short suffix and the suffix of the new key being inserted. While common characters exist between the two suffixes, new nodes are defined for the common characters. If it reaches the end of any one of the suffixes before the common char-defined for each suffix after the common characters run out.

During deletion, a change in the algorithm is necessary to handle the situation where the key being deleted corresponds the nodes and appending the corresponding character label to the end of str [].

Example 3. Fig. 5 shows the result of applying Method 2 to Example 2 . First, consider pruning node 10 in Fig. 1 . When we prune node 10, node 13 is left without a sibling. So, it has to be pruned as well. Thus node 9 becomes the new leaf node as node 7 to 1. The remaining nodes 4 and 6 are not pruned because we only prune the remaining node if it is single and leaf, and does not have its END flag set to 1. Elements of double array are reduced from 14 in Figs. 1 X 10 in Fig. 5 , thus achieving compression. 4.3. Elimination of empty spaces from TAIL
The spaces occupied by the question marks in the TAIL of Fig. 1 denote empty spaces created during insertion of keys in the key set K .In Fig. 1 , empty spaces occupy 4 bytes out of 14 bytes in TAIL.

Empty spaces in TAIL are formed during insertion and deletion. When the key being inserted has common prefix with an existing key which has part of the common prefix stored in TAIL, the part of common prefix located in TAIL gets shifted to the nodes of double array and leaves empty spaces behind in TAIL. During deletion, empty spaces are created inside TAIL as the suffixes belonging to the key being deleted are removed. In the Old Method , these empty spaces are never reused.
Our empty spaces elimination method, which will be referred to as Method 3, basically involves inserting new suffixes in the consecutive empty spaces in TAIL if sufficiently available, instead of extending the TAIL length by appending to its end.
This method marks any empty space, created during insertion or deletion, with a  X  X hite space X  for its identification. It then eliminates the empty spaces from TAIL by going through the following steps during insertion and deletion.  X  Step 1. If the length of suffix to be written to the TAIL is larger than the predefined length, EMPTY_SPACES, it is directly appended to the end of the TAIL. This is based on the experimental observation that it is hard to find a large number of consecutive empty spaces. It speeds up the insertion and deletion processes by omitting the search for empty spaces when the suffix is longer than EMPTY_SPACES. In our experimental results, setting EMPTY_SPACES to about the same length as the average length of a key in the key set was found to be the optimum value, although it can be best determined by trial and error for any particular key set.  X  Step 2. A modified version of sequential search is used to locate empty spaces. Search in TAIL begins from the index where the last successful search ended. If the last search was unsuccessful, the search starts from the beginning of TAIL. If the length of the suffix to be inserted is n , the search proceeds by skipping every n 1 array elements until an empty space is encountered. Then, consecutive empty spaces are searched for on either side of the empty space just located. The suffix is then inserted there if the number of consecutive empty spaces is equal to n or more.

Example 4. Fig. 6 shows the result of applying Method 3 to Example 1 . Tree structure is not reproduced as there is no significant change. However, there are changes in TAIL and the leaf nodes that point to a TAIL position because empty spaces have been reused. Keys in the key set K are inserted one by one sequentially. Each insertion goes through the steps mentioned above. For instance, when inserting the key  X  X  X edeck#  X , a suitable position for the suffix  X  X  X #  X  is found in the consecutive empty spaces 2 and 3 in TAIL. But for the suffix  X  X  X a#  X  of the keyword  X  X  X ebra#  X , no sufficient consecutive empty spaces are found in the TAIL. Hence it is appended at the end of the TAIL.

Compared with Fig. 1 , BASE[4] has changed to 9 from 12 and BASE[13] has changed to 2 from 10 because of the change in TAIL structure. TAIL length has reduced to 11 from 14 by reusing the empty spaces created during insertion itself. 5. Experimental evaluation
We implemented the new methods in C and evaluated them using Intel Core2 Duo 2.13 GHz CPU, with five key sets of different content, language and key length. 5.1. Information about key sets and their double array using the Old Method
Table 1 shows the information about the key sets and their double array using the Old Method . Each element of a double array consists of two members BASE and CHECK which are integers requiring 4 bytes each, and the length of the TAIL is equal length. 5.2. Experimental evaluation of the new methods
Table 2 shows that when Method 1 and Method 2 are combined, maximum size reduction becomes 20.63% compared with the Old Method. The comparisons of search, insertion and deletion times are shown in Figs. 7 X 14 , using key sets K1, K2 and
K4. Method 1 and Method 2 are indicated in the figures by M1 + M2. M1 + M2 + M3 indicate the implementation of all the three methods.

As we can see from Figs. 9 X 11 , after applying Method 1 and Method 2, insertion time has increased by 43 X 49% for K2, but remained almost the same for K1 and K4. Figs. 12 X 14 show that deletion has become faster for K1 by 6 X 26%, and for K4 by 8 X  20%. In case of the Japanese key set K2, deletion has become faster by 50 X 54%.

The improvement in insertion and deletion time can be attributed to the fact that there are fewer nodes to be defined during insertion and undefined during deletion after some nodes have been pruned.

Method 3 attempts to improve the space efficiency of the double array by reusing the empty spaces in the TAIL. Table 3 shows the result of applying Method 3 in addition to Method 1 and Method 2 for insertion only. Maximum size reduction achieved is 25.34%, an increase of 4.71% from 20.63% achieved by Method 1 and Method 2 together. Experimental evaluation with random insertions and deletions showed that maximum size reduction achieved could be increased to 30.80% as shown in Table 4 .

The disadvantage of this method is that it slows down insertion as shown in Figs. 9 and 11 . The slower insertion time is due to the time taken by searching for empty spaces within the TAIL for inserting suffixes. However, insertion time for the
Japanese key set K2 and the deletion times for the key sets K1, K2 and K3 are improved compared to the Old Method . 5.3. Comparison with other state-of-the-art trie implementations
Many compressed trie implementations have been proposed by researchers in order to meet the needs of storing large key sets efficiently. However, some of them are implementations for static tries ( Delpratt et al., 2006; Ristov &amp; Laporte, 1999), and hence cannot be compared with MP double array which is a dynamic implementation. The state of the art in dy-son, 1993; Fu et al., 2007 ) and Brust Trie ( Askitis &amp; Sinha, 2007; Heinz et al., 2002 ).

In this paper, we compare the MP double array with TST because TST is often used as the benchmark against which the performance of new implementations of dynamic trie are measured ( Clement et al., 1998; Heinz et al., 2002 ). TSTs are de-scribed by Clement et al. ( Clement et al., 1998 ) as the method of choice for managing textual data, since they offer the best Hence an indirect comparison between the MP double array and the burst trie is possible from the results.
A comparison with the LC-trie is not given because LC trie is generally applied to IP-address lookups ( Fu et al., 2007; Nils-son &amp; Karlsson, 1999 ) rather than general purpose string processing. Moreover, LC-tries do not support updates very effi-ciently as the data structure needs to be rebuilt every time the table is updated ( Pao &amp; Li, 2003 ).
In order to carry out the experimental evaluations, a TST implementation in C was used. Each node of the TST consists of three pointers and a single-byte character. On a 32-bit computing platform, each pointer takes up 32 bits or 4 bytes. Hence each node would take up 13 bytes. But in practice, each node would require 16 bytes due to the computer memory X  X  data structure alignment. Therefore, the total size of TST in bytes is given by the number of nodes multiplied by 16.
As Table 2 shows, the MP double array is much more compact compared to a TST. For the key set of postal codes K3 con-having average length of 52.8 bytes, the size of TST is 6.23 times bigger than that of the new MP double array.
The retrieval time for a key is compared between the TST and the MP double array in Figs. 7 and 8 . The retrieval in the MP double array is faster by 40 X 50% compared with that of the TST. This is in line with the theoretical expectation which shows that searching for a string of length k in a TST with n keys will require at most O ( log ( n )+ k ) comparisons compared to MP double array X  X  O ( k ).

However, the insertion and deletion are faster in TST compared to that in MP double array as shown in Figs. 9 X 14 . Dele-tion is faster by 60 X 97%, while insertion is faster by 17 X 86%. Yet, the MP double array X  X  superiority in compactness and re-trieval speed is a big advantage over the TST.

Askitis and Sinha (2007) claims that the burst-trie ( Heinz et al., 2002 ) is  X  X  X he most successful procedure for reducing the space of a trie structure X . The burst trie was found to use 50% of the memory of TST, and its speed was found to be around 25% faster than the TST ( Heinz et al., 2002 ). However, the burst-trie was found to be slower than TST with genomic data. On the other hand, in our tests the MP double array uses only 16 X 29% of the memory of TST, and its retrieval speed is faster than that of TST by 40 X 50%. 6. Conclusion
This paper has presented three methods for the compact management of suffixes for a MP Double Array. The first two methods are effective in achieving compression without making updates slower. Method 1 compresses short suffixes of 3 bytes or less in length by accommodating them inside the BASE, and Method 2 compresses the double array by pruning leaf nodes defined by the end marker symbol.

When these two methods, Method 1 and Method 2 are combined together, maximum compression of 20.63% can be achieved. Except for certain cases, both insertion and deletion become faster. The original retrieval time of O (1) is not af-fected. When compared with Ternary Search Tree (TST), it was found that the resulting MP double array uses only 16 X  29% of the memory of TST, and its retrieval speed is faster than that of TST by 40 X 50%.

Further, the third method, Method 3 , is proposed to eliminate empty spaces from the TAIL. This method when combined with the first two methods increases the maximum size reduction up to 30.80%. But it makes insertion slow.
The first two methods proposed in this paper would make a useful contribution to the compression of double array since these methods improve compression by making insertion and deletion faster at the same time in most cases. Future research could focus on making Method 3 faster, or finding an alternative method to get rid of empty spaces from TAIL. References
