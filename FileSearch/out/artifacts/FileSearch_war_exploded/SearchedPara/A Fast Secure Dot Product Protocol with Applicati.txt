 Data mining, which generally means the process of discovering interesting knowledge from large amounts of data, has become an indispensable part of scientific research, business analytics, and government decisi on making. Privacy has always been a concern over data mining. Regulations on data privacy become tighter and tighter. Legislation includes various US privacy laws (HIPAA, COPPA, GLB, FRC, etc.), European Union Data Protection Directive, and more specific national privacy regulations. Since the groundbreaking work [4,21], there have been a lot of research in privacy preserving data mining (PPDM). However, privacy is not cost free. The overhead of privacy preserving protocols is often too high when a large amount of data needs to be protected. Therefore, how to make protocols secure and also e fficient becomes a major challenge to PPDM.
The focus of this paper is association rule mining [2], which discovers association patterns from different sets of data and this is one of the most popular and powerful data mining methods. There have been several privacy preserving solutions for association rule mining. According to [27], those solutions can be divided into two approaches: randomization-based and cryptography-base d. In the randomization-based approach [10,24,32] , there is a centralized server who aggregates data from many clients and dis-covers association rules. To protect privacy, data owners (the clients) use some statistical methods to distort the data before sending it to the server. In the distortion procedure, noise is added to the data in order to mask the values of the records while still allow the distribution of the aggregation data to be recovered. The goal is to prevent the server from learning the original data while still be able to discover the rules. However, it has been shown in [20,17] that in many cases, t he original data can be accurately estimated from the randomized data using techniques bas ed on Spectral Filtering, Principal Com-ponent Analysis and Bayes estimate. In recen t years, the cryptography-based approach becomes very popular. This is because cryptogr aphy provides well-defined models for privacy and also a large toolset. In this approach, data is usually split among multi-ple parties horizontally [19,25] or vertically [28,29]. In general, associate rule mining on vertically partitioned data is much more computationally intensive than on horizon-tally partitioned data because little data summarization can be done locally. Therefore performance is a more acute problem when dealing with vertically partitioned data.
As we will see in section 2, the core of the algorithm for association rule mining on vertically partitioned data is a secure dot pr oduct protocol. Therefore the key to make privacy preserving association rule mining practical is to improve the efficiency of the underlying dot product protocol. Many secure dot product protocols have been devel-oped in the past [8,9,28,18,1,13,11,29,5,6,26]. However, [8,28,18] have been shown to be insecure or incorrect, [9] requires an additional third party, and the others require at least O ( n ) modular exponentiation operations, where n is the size of the input vectors. Modular exponentiation is a costly operation, thus those protocols are very inefficient and cannot be used in real applications that handle large datasets.

The main contribution of this paper is a very efficient secure dot product proto-col, which can significantly accelerate privacy preserving association rule mining. Our analysis and implementation show that our dot product protocol is orders of magnitude faster than previous ones. The efficiency co mes from the fact that the protocol relies mostly on cheap cryptographic operations, i .e. hashing, modular multiplication and bit operations. The efficiency can be further increased by parallelization. It is worth men-tioning that in addition to association rul e mining, secure dot product has also been shown to be an important building block in many other PPDM algorithms such as naive Bayes classification [30], finding K-Near est Neighbors (KNN) [31] and building deci-sion trees [9]. Therefore our protocol can also be used to boost the performance of those PPDM tasks. We also provide a informal security analysis. We have proved the protocol to be secure in the semi-honest model in ter ms of multiparty secure computation [14]. For space reason, the proof is omitted here and will appear in the full version.
The paper is organized as follows: in Section 2, we briefly review the privacy pre-serving Apriori algorithm for association rule mining on vertically partitioned data; in Section 3, we describe our secure dot product protocol and the underlying crypto-graphic building blocks; in Section 4, we r eport the performance measurements based on the prototype we have implemented, and compare it against the most widely used secure dot product protocol; in section 5, we conclude the paper and discuss possible future work. Association rules show attribute values that appear frequently together in a given dataset. The problem can be formalized as follows [2]: let I = { i 1 ,i 2 ,...,i m } be a set of items.
Algorithm 1. Privacy Preserving Apriori Algorithm [28] Let D be a set of transactions and T be a transaction. Each transaction T is a set of items such that T  X  I .Wesay T contains X if X  X  T . An association rule is of the form X  X  Y where X  X  I , Y  X  I and X  X  Y =  X  .Arule X  X  Y holds in the transaction set D with confidence c if c % of transactions in D that contain X also contain Y .A rule X  X  Y has support s in the transaction set D if s % transactions in D contain X  X  Y . The goal of association rule mining is to find all rules having high support and confidence. One classic algorithm for association rule mining is the Apriori algorithm [3]. The Apriori algorithm can find all frequent itemsets, i.e. itemsets that appear in the transaction set at least minsup times, where minsup is a threashold. After all frequent itemsets have been found, association rules can be generated straightforwardly.
The computation model we consider is two parties each holds part of the transaction set that is vertically partitioned, i.e. one party holds some attributes and the other party holds the rest attributes. In [28], a secure algorithm for finding association rules on vertically partitioned data was proposed. The algorithm (see Algorithm 1) is a straight-forward extension of the Apriori algorithm. For each attribute, the party holding it can create a binary vector whose length is the size of the transaction set: the absence or presence of the attribute can be represented as 0 and 1. As shown in [28], we can reduce privacy preserving association rule mining to securely computing the dot products of the binary vectors. Candidate itemsets can be generated as in the Apriori algorithm.In the simplest case where the candidate itemset has only two attributes, for example an attribute X 1 held by P 1 and X 2 held by P 2 , the two parties can compute the dot product of the corresponding vectors X 1  X  X 2 = n i =1 X 1 [ i ]  X  X 2 [ i ] . Then the dot product is the support count, i.e. how many times the itemset appears in the transaction set, and is tested against a predefined threshold minsup . If the dot product is greater or equal to the threashold, then the candidate itemset is a frequent itemset. This approach can be easily extended to itemsets that have more attributes. Most of the steps in Algorithm 1 can be done locally. The only step that needs to be computed securely between the two parties is step 10, where a dot product needs to be calculated. Being the only crypto-graphic step, step 10 is the most time consuming part of the algorithm, and its running time dominates the total running time of the algorithm. Therefore improving the per-formance of the secure dot product protocol is key to improving the performance of the entire mining algorithm. To make privacy preserving association rul e mining efficient, we need an efficient se-cure dot product protocol. In this section, we present such a protocol and analyze its security. The protocol is built on two well-defined cryptographic primitives: the Goldwasser X  X icali Encryption and the Oblivious Bloom Intersection. 3.1 Cryptographic Building Blocks Goldwasser X  X icali Encryption. The Goldwasser X  X icali (GM) encryption is a se-mantically secure encryp tion scheme [15]. The algorithms are as follows:  X  Key generation algorithm G : it takes a security parameter k , and generates two large  X  Encryption algorithm E : to encrypt a bit b  X  X  0 , 1 } , it takes b and the public key  X  Decryption algorithm D :ittakesaciphertext c and the private key as input, and
There are two reasons why we use the GM encryption in our protocol: it is efficient for our purpose and it is homomorphic. The inputs to our protocols are bit vectors and they must be encrypted bit-by-bit in the protocol. Notice that the GM encryption and decryption operations involve only m odular multiplications and Legendre symbol computation. Both are very efficient and the computational costs are on the same order of symmetric key operations. This is in contrast to the public key encryption schemes required by the other secure dot product protocols. Those encryption schemes require modular exponentiations, which is usually thousands of time slower. Therefore using the GM encryption makes our protocol much more efficient. The GM encryption is known to be homomorphic and allows computation to be carried out on ciphertexts. More specifically, for two ciphertexts c 1 = E ( pk,b 1 ) and c 2 = E ( pk,b 2 ) , their product c c 2 is a ciphertext of b 1  X  b 2 ,where  X  is the bitwise exclusive or (XOR) operator. This property will be used in our protocol to allow a party to blindly randomize ciphertexts generated by the other party.
 Oblivious Bloom Intersection. Oblivious Bloom Intersection (OBI) [7] is an efficient and scalable private set inters ection protocol. A private set intersection protocol is a protocol between two parties, a server and a client. Each party has a private set as input. The goal of the protocol is that the client learns the intersection of the two input sets, but nothing more about the server X  X  set, and the server learns nothing. In Section 3.3, we will see how to convert the computation of the dot product of two binary vectors into a set intersection problem. Previously, the private set intersection protocols are equally, or even more, costly as secure dot product protocols. Therefore PSI based secure dot product protocols have no advantage in terms of performance. This situation is changed by the recently proposed OBI protocol. The OBI protocol adapts a very different ap-proach for computing set intersections. It mainly bases on efficient hash operations. Therefore it is significantly faster than prev ious private set intersection protocols. In addition, the protocol can also be paralle lized easily, which means performance can be further improved by parallelization. The protocol is secure in the semi-honest model and an enhanced version is secure in the malicious model.

Briefly, the semi-honest OBI protocol works as follows: the client has a set C and the server has a set S . Without loss of generality, we assume the two sets have the same size, i.e. | C | = | S | = w . The protocol uses two data structures: the Bloom filter and the garbled Bloom filter. Both data struct ures can encode sets and allow membership queries. The two parties agree on a security parameter k and choose k independent uniform hash functions. The hash functions are used here to build and query the filters. The client encodes its set into a Bloom filter, which is a bit vector. The server encodes its set into a garbled Bloom filter, which is a vector of k -bit strings. The size of the Bloom filter (and also the garbled Bloom filter) depends on the security parameter k and the set cardinality w . More precisely, the filter size is k  X  w  X  log 2 e . The client then runs an oblivious transfer protocol with the server. The oblivious transfer protocol can be implemented efficiently with hash functions. The number of hash operations required by the oblivious transfer protocol is linear in the filter size. The result of the oblivious transfer protocol is that the server learns nothing and the client obtains another garbled Bloom filter that encodes the set intersection C  X  S . The client can query all elements in C against this garbled Bloom filter to find the intersection.

We refer the readers to [7] for more details regarding OBI. We will show in Section 3.3 that by combining OBI with the GM encryption, we can get a much more efficient secure dot product protocol. 3.2 Security Model We study the problem within the general framework of Secure Multiparty Computation. Briefly, there are multiple parties each has a private input, they engage in a distributed computation of a function such that in the end of the computation, no more informa-tion is revealed to a participant in the comput ation than what can be inferred from that participants input and output [14]. Several security models have been defined in this framework. In this paper, we consider the semi-honest model [14]. In this model, ad-versaries are honest-but-curious, i.e. they will following the protocol specification but try to get more information about honest party X  X  input. Although this is a weak model, it is appropriate in many real world scenarios where the parties are not totally untrusted. Besides, semi-honest protocols can be upgraded to full security against malicious ad-versaries using a generic technique [14].
 3.3 The Protocol
A method [16] that converts the binary vector dot product problem into computing the cardinality of set intersection is as follows: given two binary vectors X 1 and X 2 both of cardinality n , we can construct two sets S i ( i  X  X  1 , 2 } ) such that j is an element of S i if the X i [ j ]=1 ,i.e. S i = { j | X i [ j ]=1 } . Then the dot product X 1  X  X 2 = |
S product protocol that works by estimatin g the cardinality of the set intersection.
Our protocol is also based on this set intersection cardinality idea, but can com-pute the exact intersection cardinality rather than just an approximation. The protocol is shown in Fig. 1. We now explain the rationale behind the design and discuss the security informally. Our insight is that we can build a secure binary vector dot product protocol on top of a private set intersection protocol. It seems trivial: let the two parties convert their private vectors into sets as described ab ove, then run a private set intersection pro-tocol between them, the protocol outputs the set intersection S 1  X  S 2 thus | S 1  X  S 2 | can be obtained as a by-product. This solution, however is flawed. The main problem is that it leaks more information than desired. In fact, the party who obtains the intersection as the output of the private set intersection protocol learns not only the dot product, but also some bits in the other party X  X  vector: for any j in the intersection, the j th-bit of the other party X  X  vector must be 1. To prevent this, in our protocol, we do not use the sets S 1 and S 2 directly, but map them into T 1 and T 2 such that the following two properties which it can obtain | S 1  X  S 2 | , but no other information.

The first property ensures the correctness of our protocol. To see why this property holds, observe that in step 1.3, P 2 maps each 1  X  j  X  n to a random number R [ j ] .The mapping is used by both parties to map S i to T i : for each j  X  S i , or equivalently for is guaranteed. The difficulty here is how to let P 1 correctly generate T 1 .For P 2 , it can easily generate T 2 because it knows the mapping. However, to maintain privacy, P 1 is not allowed to know the mapping. In order to allow P 1 to generate T 1 , P 2 creates a labelled permutation of the vector R (step 1.4, 1.5). For each R [ j ] , the label assigned to it is a ciphertext of X 1 [ j ] .Instep1.6, P 1 can decrypt the label, if it encrypts 1, then P 1 knows the corresponding vector element should be put into T 1 .

The second property ensures the privacy of our protocol. It is easy to see why P 2 gets no more information: the only message P 2 gets in phase 1 is the encrypted version of X 1 , then by the security of the GM encryption, P 2 gets no information about X 1 . Phase 2 is essentially a PSI execution and P 2 plays the role of the PSI server, thus by the security of the PSI protocol, it learns nothing. For P 1 , it receives C in step 1.6 and T 1 but no more than that. Since C =  X  ( C ) and  X  is a random permutation, the order of an element in the set i does not leak any information. Also u i = R [ j ] for some j is a random number generated independently of j , and the mapping from j to R [ j ] is known only by P 2 , thus u i leaks no information. On the other hand v i = E ( pk,X 1 [ j ])  X E ( pk, 0) , so v i incorporates randomness generated by P 2 , therefore P 1 cannot link it back to the ciphertext E ( pk,X 1 [ j ]) generated by itself. D ( sk,v i ) gives only 1 bit information, i.e. there exists a j such that X i [ j ]=1 . That is exactly what P 1 should know. At the end of phase 1, P 1 holds a set T 1 which it knows is a equivalent of S 1 but cannot link the elements in T 1 back to elements in S 1 : any element in T 1 can be any element in S 1 with equal likelihood. A consequenc e is that the output in step 2.1 T 1  X  T 2 gives P 1 no more information about S 1  X  S 2 other than the cardinality of the intersection.

The protocol in Fig. 1 has only one output: P 1 gets the dot product and P 2 gets nothing. In some applications, it is pre ferable to have two outputs such that P 1 gets a number a and P 2 gets a number b and a + b is the dot product. This can be done by executing the protocol in Fig. 1 twice and let the parties switch roles in the two executions. Suppose Alice has a vector Y 1 and Bob has a vector Y 2 , both are of size n . Bob first splits Y 2 randomly into two n -bit vectors Y 3 and Y 4 , such that Y 2 = Y 3 + Y 4 . In the first round, Alice plays the role of P 1 and uses Y 1 as her input. Bob plays the role of P 2 and uses Y 3 as input. Alice gets an output a after the execution. Then in the second round, Alice plays the role of P 2 and still uses Y 1 as her input. Bob plays the role of P 1 and uses Y 4 as his input. Then Bob receives an output b . The outputs satisfy that a + b = Y 1  X  Y 2 . To see that, observe that a = Y 1  X  Y 3 and b = Y 1  X  Y 4 ,so a + b = Y 1  X  ( Y 3 + Y 4 )= Y 1  X  Y 2 .
 3.4 Efficiency From the description of the protocol in Fig. 1 we can see that the computational and communicational complexities of phase 1 are both O ( n ) ,where n is the size of the vector. Phase 2 is a single execution of the OBI protocol. Therefore the computational and communicational complexities of this phase are also O ( n ) .

More specifically: in phase 1 the total computational cost is 3 n modular multipli-cations plus computing n Legendre symbols, in phase 2 the total computational cost is 2 d  X  k  X  n (1 + log 2 e ) hash operations, where d is the density of the vectors, k is the security parameter (e.g. 80 or 128) and e is the natural logarithm constant. As a comparison, the protocol in [13], which is based on Paillier homomorphic encryption, requires n modular exponentiations and n modular multiplications. At first glance it seems that our protocol is not as efficient as the protocol in [13]. However a closer anal-ysis shows the opposite. This is because modul ar exponentiation, required by [13], is much more expensive than the operations requires by our protocol. To better illustrate the difference, we show the running time of the cryptographic operations at 80-bit se-curity in Table 1. The modulus used is 1024-bit. The time was measured on a Mac Pro with 2.4 GHz Intel Xeon CPUs. For the cheap operations, the time shown is the aver-age of 1,000,000 executions and for modular exponentiation, the time is the average of 1,000 executions. We can see the difference is 3 orders of magnitude. At higher security levels, the difference is even bigger.

Communication wise, our protocol in phase 1 transfers 2 n element in group Z  X  N and in phase 2 transfers 2  X  d  X  k  X  n  X  log 2 ek -bit strings. On the other hand, the communi-cation cost of the protocol in [13] is n element in group Z  X  N 2 . Our protocol consumes more bandwidth than the protocol in [13]. The bandwidth consumption of our protocol depends on d , the density of the vector. In the worst case where d =1 , the bandwidth consumed by our protocol is about 10 times as much as the protocol in [13], but when d =0 . 1 , the bandwidth consumption of our protocol is only twice that of the protocol in [13]. In real applications the density is often small thus the difference is not significant. We implemented our protocol in Figure 1 an d measured the perform ance. The protocol was implemented in C. The implementation uses OpenSSL [22] and GMP [12] for the cryptographic operations. We used the Oblivious Bloom Intersection as the underlying PSI protocol. We obtained the source code of the OBI protocol, which is also in C, and incorporated it in our implementation. As a r eference, we also impl emented Goethals et al X  X  protocol [13] in C. Goethals et al X  X  protocol relies on additive homomorphic encryption and we use the Paillier public ke y scheme [23] as the building block of the protocol. We tested the protocols with 80 bits symmetric keys and1024 bits public keys. The experiments were conducted on two Mac computers. P 1 ran on a Macbook Pro laptop with an Intel 2720QM quad-core 2.2 GHz CPU and 16 GB RAM. P 2 ran on a Mac Pro with 2 Intel E5645 6-core 2.4GHz CPUs and 32 GB RAM. The two computers were connected by 1000M Ethernet. The two parties communicate through TCP socket. In all experiments, we use randomly generated bit vectors as inputs. We use synthesized data rather than real data becau se of the following two reasons: firstly the performance is not affected by the nature of the input data; secondly the performance of our protocol varies with the density of the vectors and it is hard to demonstrate the worst case performance with real data.
 We first show the overall running time of the protocols with different vector sizes. The performance of our protocol depends on density of the vectors. In this experiment we measured the worst case performance by setting the density of the vectors used in our protocol to 1. In the experiment, each pa rty uses one thread for computation and another one for network communication. The result is shown in table 2. As we can see in the table, our protocol is more than 20 times faster than Goethals et al X  X  protocol.
In real world applications, the density of the vectors is less than 1 and our protocol can be more efficient. The performance of our protocol has been further improved by exploiting parallelization. Oblivious Bloom Intersection, the unde rlying PSI protocol, is highly parallel. The implementation of the Oblivious Bloom Intersection protocol has a parallel mode which allows the program to utilize all available CPU cores and distribute the computation among them. The total running time can be significantly shortened if the program is running on multi-core systems. In the next experiment, we measured the performance of our protocol running in non-parallel and parallel modes with different densities. In the experiment, we set the vector size n =1 , 000 , 000 and varied the density from 0.1 to 1. The result is shown in Figure 2. As we can see in the figure, the parallel mode does increase the performance significantly. The total running time in the non-parallel mode is 1 . 8  X   X  4 . 2  X  of that in the parallel mode. On the other hand, the total running time in each mode in creases linearly with the vector density. When the density is 0.1, the total running time is 18.9 and 34.1 seconds in the parallel and non-parallel modes respectively, while when the density is 1 the numbers become 57 and 238 seconds. To compare, we also plot the total running time of Goethals et al X  X  protocol when the vector size is set to 5 , 000 and 50 , 000 . The running time of Goethals et al X  X  protocol is not affected by the vector density. As we can see, the total running time of our protocol in all cases is less than that of the Goethals et al X  X  protocol with n =50 , 000 . The total running time of Goethals et al X  X  protocol is linear in n . That means our protocol is at least 20 times faster. Our protocol is more than100 times faster than Goethals et al X  X  when running in the non-parallel mode and when the vector density is 0.1, and is 200 times faster when running in the parallel mode and with a vector density below 0.2.

We also measured the bandwidth consumption. In the experiment, we set the vector size n =1 , 000 , 000 and varied the density. The bandwidth consumption of Goethals et al X  X  protocol with n =1 , 000 , 000 was measured for comparison. The result is shown in Figure 3. Goethals et al X  X  protocol consumes about 266 MB bandwidth. The bandwidth consumption of our protocol is about 1.9  X  and 9.5  X  of that when the density is 0.1 and 1 respectively. The number is quite close to our estimation in section 3.4. If the network connection is very slow, then Goethals et al X  X  protocol can be faster than ours because the bottleneck is the network speed. Given the above measurements, we can roughly estimate when to switch. For example, if the vector size is 1,000,000 and density is 1, then when the network speed is less than 3.8 Mbps, Goethals et al X  X  protocol should be used; if the density becomes 0.1, then Goethals et al X  X  protocol becomes faster only when the network speed is less than 0.4 Mbps. In this paper we investigated how to accelerat e association rule mining on big datasets in a privacy preserving way. To this end, we developed a provably secure and very effi-cient dot product protocol. The protocol is based on the Goldwasser X  X icali Encryption and Oblivious Bloom Intersection. The security of the protocol can be proved in the semi-honest model. By avoiding expensive cryptographic operations such as modular exponentiation, the performance of our protocol is much better than previous ones. We implemented the protocol and compared the performance against the currently most widely used secure dot product protocol. The results show that our protocol is orders of magnitude faster.

As future work, we would like to extend the protocol to multiple parties. We would also like to investigate how to improve the efficiency of other PPDM tasks. As we mentioned, our protocol can be used as a sub-protocol in many other PPDM tasks. We need also efficient constructions for other building blocks in the PPDM tasks. Another future direction is to implement the protocol in frameworks such as MapReduce, so that we can take advantage of the processing power provided by large scale distributed parallel computing, e.g. cloud computing.
 Acknowledgements. We would like to thank the anonymous reviewers. Changyu Dong is supported by a Science Faculty Starter Grant from the University of Strathclyde.
