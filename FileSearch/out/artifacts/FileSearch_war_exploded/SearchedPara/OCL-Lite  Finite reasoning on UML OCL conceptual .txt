 1. Introduction user-defined constraints, which are usually specified in OCL [34] . [7,35,39,8,24,36,1,37] .
 either does not have any siblings, or it has a sibling without a sponsor. valid instance of Person that satisfies Constraint 1 and, since each and an inspector (Constraint 2), neither this class can be populated. one: context Person inv: organized-N exists(oclIsTypeOf(CriticalEvent)) populated.
 following ways: nation in some specific cases after analyzing each particular schema [36,37] . check unrestricted satisfiability (i.e., they allow for infinite instantiations of a schema). of this paper can be summarized as follows:  X  properties of OCL had not been studied before, except that full OCL leads to undecidability.  X  the correctness of a schema.  X  complete problem.  X  this fragment of OCL.
 point out future research directions. 2. Related work completeness, and those looking for decidable fragments.
 propose a method to check whether the reasoner will terminate. consistent constraints can be displayed as potentially inconsistent. the range of attributes.
 and covering constraints (in particular, NP and NLOGSPACE case, do not guarantee the FMP.
 mentioned above, our encoding enjoy the FMP. 3. OCL-Lite syntax and semantics to [34,41] .
 the corresponding class.
 For instance, referring to the UML class diagram in Fig. 1 , the association corresponds to the class Company , which plays the role of the role of event in this association.

An OCL constraint (or invariant) has the form: context C inv: OCLExpr which the contextual class participates. The rest of the navigation path is defined analogously. For instance, referring again to Fig. 1 , and assuming that the context is events sponsored by an arbitrary instance of Company , by means of the association self.event or equivalently event The following expression returns the persons that organize an arbitrary instance of assuming that the context is Event : self.organizer or equivalently organizer And the following one gives the events that are organized by a person, assuming that the context is self.organized or equivalently organized 3.1. OCL-Lite syntax we call OCL-Lite. An OCL-Lite constraint has the form: context C inv: OCL-LiteExpr to obtain new ones.
 or can be the condition specified as a parameter in a select or Boolean combinations of these OCL-Lite expressions.
 be specified first). Otherwise, when OCL-LiteExpr is inside a tion of objects reachable along a path, then:  X  col -N select( OCL-LiteExpr ) : returns the subset of elements of col that satisfy OCL-LiteExpr ;  X   X  col -N forall( OCL-LiteExpr ) : returns true iff all the elements of col satisfy OCL-LiteExpr ;  X  col -N size() : returns the number of elements of col ;  X  col -N isEmpty() : returns true iff col is empty;  X  col -N notEmpty() : returns true iff col is not empty;  X  o .oclIsTypeOf( C ) : returns true iff o is an instance of the class C ; collection to which the operation is applied. For instance, for the operation where o is called the iterator , and is a reference to an object from the collection col . When the  X  r -N exists( r 2 . r 3 -N size() N 0) or, equivalently: self. r 1 -N exists( o | o . r 2 . r 3 -N size() N 0) ,  X  r .oclAsType( C 2 ). r 2 -N select( r 3 -N isEmpty())-N forall(oclIsTypeOf( or, equivalently: self. r 1 .oclAsType( C 2 ). r 2 -N select( o | o . r 3 - X  r -N select( r 2 -N isEmpty())-N select( r 3 . r 4 -N exists( -
N forall(oclIsTypeOf( C ) and r 6 -N size()=0) or, equivalently: self. r 1 -N select( o | o . r 2 -N isEmpty())-N select( forall( o | o .oclIsTypeOf( C ) and o . r 6 -N size()=0) 3.2. OCL-Lite normal form
OCL-Lite operations, except for oclIsTypeOf and oclAsType isEmpty ,and notEmpty , and the Boolean operator not only appears before the expression we get after applying the rules in Table 1 are:  X 
Constraint 1. We apply rule a) to the original constraint and we get the normalized expression: context Person inv:  X 
Constraint 2. We apply rule d) and we get the normalized expression: context CriticalEvent inv: inspector-N notEmpty()  X 
Constraint 5. We first apply rule b) and we get: context Person inv: audited-N select(not sponsor-N notEmpty())-
We then apply rule g) to obtain the normalized expression: context Person inv: audited-N select(sponsor-N isEmpty())- X 
Constraint 6. We apply rule f) and we get: context CriticalEvent inv: responsible.organized-N notEmpty()  X 
Constraint 8. We apply rule a) and we get: context Company inv: event-N select(oclIsTypeOf(CriticalEvent))-either by isEmpty or notEmpty . Also, the expression may include the operation expression or an intermediate one contains a sequence of select the normalization rules. 3.3. OCL-Lite semantics as also argued in [5] , using formulas is preferable when dealing with sets, as in our case.
We start by formalizing the semantics of an OCL-Lite constraint
Its interpretation is: where C is the unary predicate corresponding to class C .
 a navigation path p n ... p 1 in an OCL-Lite expression, where each p nary) association A i , we introduce a binary predicate, A
A ) and whose second argument represents an instance of range ( A to navigate from one object to a another one belonging to the class C . Thus, in the following, p name attached to the range ( A i )-end of A i , and, viceversa, p
A . Similarly, p i f ( x , y )= C i ( x )  X  A i ( x , y ), when p p ( x , y )= C i ( x )  X  A i ( y , x ), when p i = oclAsType( expressions. 1. OCL-LiteExpr = p n ... p 1 -N select( OCL-LiteExpr 0 )-The semantics of this expression is
Importantly, a particular case of this kind of expression is when no the navigation, which corresponds to the expression In this case, the semantics is 2. OCL-LiteExpr = p n ... p 1 -N select( OCL-LiteExpr 0 )-The semantics of this expression is
Again, we have a particular case of this kind of expression in the absence of And then, the semantics of the expression is 3. OCL-LiteExpr =[ not ] oclIsTypeOf( C ) where the brackets denote optionality. The semantics of the expression is 4. OCL-LiteExpr = OCL-LiteExpr 1 and OCL-LiteExpr 2 The semantics of this expression is 5. OCL-LiteExpr = OCL-LiteExpr 1 or OCL-LiteExpr 2 The semantics of this expression is 6. OCL-LiteExpr = OCL-LiteExpr 1 implies OCL-LiteExpr 2 The semantics of this expression is
In our running example, the semantics of Constraints 1 and 2 is the following:  X 
The OCL-Lite normal form of Constraint 1 is and its semantics is  X 
The OCL-Lite normal form of Constraint 2 is and its semantics is
De fi nition 1. Satis fi ability of OCL-Lite constraints Let  X  be a set of OCL-Lite constraints and  X  f the resulting FOL theory. Then, interpretation I X   X  I ;  X  I that satisfies  X  f . I is called a model of 4. The Description Logic ALCI community.
 by currently existing tools in this area, not necessarily by techniques based on DLs. can be used with the guarantee of termination.
 formed according to the following syntax rules: where C denotes an atomic concept , and A an atomic role , i.e., simply a concept or role symbol.
An ALCI knowledge base is constituted by a finite set of inclusion assertions of the form D concept expressions. 1 The semantics of ALCI is specified through the notion of interpretation. An interpretation I X  base is constituted by an interpretation domain  X  I and an interpretation function and to each role R a subset R I of  X  I  X   X  I , such that the following conditions are satisfied: An interpretation I satisfies an inclusion assertion D 1  X  there is a model I of K such that D I is nonempty.
 ( R ). Roles can be seen as binary associations in UML, and the inverse role, denoted A event (range). Then, Organizes  X  relates the event (domain) to the persons (range) organizing it. includes those objects that are not related by R to any object of the domain. For instance, the individuals that organize some critical event, and  X  Organizes
ALCI concepts. 5. Encoding UML/OCL-Lite in ALCI in together with its encoding, and then we provide an encoding for the OCL-Lite fragment, too. 5.1. Encoding UML in ALCI modeling, namely:  X  hierarchical relations between classes;  X  disjointness and covering between classes;  X  cardinality constraints for participation of entities in relationships; and  X  multiplicity and typing constraints for attributes.
 clarified in Section 6 , they can also be captured in the ALCI encoding. themselves and from classes, the following disjointness assertions are enforced:  X 
A hierarchy constraint expressing a generalization of a class C  X   X 
A covering constraint involving classes C , C 1 , ... , C  X  A typing constraint for an attribute a of a class C is encoded as where T is a class representing the type of the attribute.
 inclusion assertion to specify the domain and range of A : assertion that encodes the multiplicity 1.. * of an attribute a of C is:
A cardinality 1..* attached to the association end corresponding to C and, viceversa, the following inclusion assertion captures the cardinality to C 2 :
According to the above rules, the class diagram in Fig. 1 is encoded in ALCI as follows: 1.  X  X  X  X  Organizes . Event  X  X  X  Organizes  X  . Person 2.  X  X  X  X  Audits . Event  X  X  X  Audits  X  . Person 3.  X  X  X  X  ResponsibleFor . CriticalEvent  X  X  X  ResponsibleFor  X  . Person 4.  X  X  X  X  HeldWith . Event  X  X  X  HeldWith  X  . Event 5.  X  X  X  X  SponsoredBy . Company  X  X  X  SponsoredBy  X  . Event 6. Person  X  X  X  Organizes .  X  7. CriticalEvent  X  X  X  ResponsibleFor  X  .  X  8. CriticalEvent  X  Event via reification (see Section 6 for more details).
 The encoding, starting from an UML class diagram  X  , generates an ALCI knowledge K preserves satisfiability (  X  is satisfiable if and only if K knowledge base K  X  can be viewed as an instantiation of the UML class diagram 5.2. Encoding OCL-Lite constraints in ALCI translate OCL-Lite constraints into ALCI .

An OCL-Lite constraint, which has the general form is encoded as the following ALCI inclusion assertion: form, as provided in Section 3.2 , and define OCL-LiteExpr 1. OCL-LiteExpr = p n ... p 1 -N select( OCL-LiteExpr 0 )-base case n =0, and in this case we set OCL-LiteExpr  X  = OCL-LiteExpr For the inductive case, let OCL-LiteExpr n = p n ... p 1 -item, and let OCL-LiteExpr n +1 = p n +1 . OCL-LiteExpr n ious cases of p n +1 , cf. OCL syntax in Section 3.1 ) is an abbreviation
A , and dom ( A ) and range ( A ) denote respectively the domain and range of A ):
Note that the ALCI concept corresponding to OCL-LiteExpr has the form when there is no select operation, i.e., the OCL expression has the form p the constraint is encoded as that is, no condition is imposed on those instances reachable through the path. normalized, the constraint has the form Thus, the ALCI assertion that encodes this constraint is: CriticalEvent  X  X  X  ResponsibleFor  X  :  X  Organizes :  X   X  X  Note that, the ALCI encoding of the OCL-Lite expression responsible.organized-(  X  Organizes.  X  ). The fi rst DL role, ResponsibleFor  X  , is inverted since the association
CriticalEvent ,andtherolename responsible is attached to Person role name in the OCL-Lite expression is organized , which is attached to imposed on the instances reached at the end of the path. 2. OCL-LiteExpr = p n ... p 1 -N select( OCL-LiteExpr 0 )- X OCL-LiteExpr 0  X  . For the inductive case, let OCL-LiteExpr ditional path item, and let OCL-LiteExpr n +1 = p n +1 . OCL-LiteExpr that  X  X C is equivalent to C , the ALCI concept corresponding to OCL-LiteExpr has the form the path p n ... p 1 to any object that satisfies the condition specified by OCL-LiteExpr operation in the OCL expression, i.e., the OCL expression has the form p constraint is encoded as
As an example, let us consider Constraint 5 in its normal form: context Person inv: audited-N select (sponsor-N isEmpty())-The overall OCL-Lite expression is encoded in ALCI as  X (  X  constraint is: 3. OCL-LiteExpr = oclIsTypeOf( C ) , and OCL-LiteExpr = not oclIsTypeOf( The ALCI concept OCL-LiteExpr  X  corresponding to these OCL-Lite expressions is respectively 4. OCL-LiteExpr = OCL-LiteExpr 1 and OCL-LiteExpr 2 The corresponding ALCI concept OCL-LiteExpr  X  is
As expected, the ALCI encoding is the conjunction of the two concepts encoding each sub-expression. 5. OCL-LiteExpr = OCL-LiteExpr 1 or OCL-LiteExpr 2 The corresponding ALCI concept OCL-LiteExpr  X  is
The ALCI encoding is the union of the two concepts encoding each subexpression. 6. OCL-LiteExpr = OCL-LiteExpr 1 implies OCL-LiteExpr 2 The corresponding ALCI concept OCL-LiteExpr  X  is Note that in ALCI implication is formulated in terms of negation and disjunction. ALCI expression is: subexpression. The resulting ALCI expression is: 5.3. Correctness of the encoding and complexity results then show that reasoning on UML/OCL-Lite is an E XPTIME -complete problem. Theorem 1. Correctness of the OCL-Lite encoding Let  X  be a set of OCL-Lite constraints and K  X  its ALCI encoding. Then, and viceversa, i.e., for every OCL-LiteExpr , for every interpretation I , and for every object o where [ x / o ] denotes the variable assignment that assigns object o to variable x .
We proceed by induction on the structure of OCL-LiteExpr . 1. [ not] oclIsTypeOf( C ) The FOL formula representing its meaning is [  X  ] C ( x ).
 The corresponding ALCI concept is: [  X  ] C .

Then, Cx  X  X   X  X  I x = o  X  is true iff o  X  C I . The case of negation easily follows by induction. 2. OCL-LiteExpr 1 and OCL-LiteExpr 2
The FOL formula representing its meaning is OCL -LiteExpr
The corresponding ALCI concept is OCL -LiteExpr 1  X   X  OCL -LiteExpr By induction, the claim easily follows.

The cases of disjunction and implication are analogous. 3. p n ... p 1 -N select(OCL-LiteExpr 0 )-N notEmpty()
The FOL formula representing its meaning is
The corresponding ALCI concept is p n  X  .( p n +1  X  .(  X  ( p We prove the claim by induction on the length n of the navigation path. o  X  OCL LiteExpr  X 
Inductive case ( n  X  n +1): Let OCL-LiteExpr n = p n ... p path item, and let OCL-LiteExpr = p n +1 . OCL-LiteExpr n ( x n +1 )), and OCL -LiteExpr  X  = p n +1  X  .( OCL-LiteExpr  X  Let p n +1 be a role name attached to the range ( A )-end of some association A .Then, p  X  Let p n +1 be a role name attached to the dom ( A )-end of some A . Then, p
In all four cases, by inductive hypothesis, OCL LiteExpr f lows.

Thecasewherethereisno select operation, i.e., the OCL-Lite expression has the form p analogously. 4. p n ... p 1 [-N select(OCL-LiteExpr 0 )]-N isEmpty()
The FOL formula representing its meaning is
The corresponding ALCI concept is  X  ( p n  X  .(  X  ( p n  X  .( OCL-LiteExpr use. On the other hand, we show that reasoning over UML/OCL-Lite is E constraint language.
 Theorem 2. Complexity of UML/OCL-Lite Checking the satisfiability of UML/OCL-Lite conceptual schemas is an E assertions of the form where C 1 , C 2 , C 3 are atomic concepts and A is an atomic role. Satis in [7] .
 To encode inclusion assertions of the form we use the Boolean operators of OCL-Lite. Let us show how to encode the binary association, A , with both domain and range untyped (i.e., dom ( A )= range ( A )= range. Then:  X 
C 1  X  X  X  A . C 2 is encoded as:  X 
C 1  X  X  X  A . C 2 is encoded as: class is a sub-class of  X  (thus, C 2 is reachable from C 1 6. Incorporating identi fi cation constraints n-ary associations, also very common in conceptual modeling, cannot be encoded in this DL. they can safely be ignored when checking satisfiability in UML/OCL-Lite. formly by means of reification. More precisely, an association A of arity n , with n classes C 1 , ... , C n .
 instance of A participates at most once in each of the binary associations R supposed to be functional, then, for each possible concept C ,if o satisfies sufficient to enforce the instances of this axiom schema in which C belongs to a finite set of
OCL constraints, and they are polynomially many. In our case, the roles R each role R i and for each relevant concept C , aninclusion assertion of theform that all individuals connected to an instance of the reified association (class) through a role R show the correctness of reification. Intuitively, consider a model I containing two instances o that are connected to exactly the same individuals via roles R can construct the model that is the union of I with a copy I to o 1 and o 2 .By  X  swapping  X  the two objects connected to o o  X  , o 2 , o again finite, without any violations.
 any kind of approach that admits this expressiveness. 7. Reasoning on UML/OCL-Lite schemas using current reasoners guarantees completeness and decidability by limiting expressiveness of the constraints, and SVT constraints.
 SVT E , reasoning on UML/OCL-Lite schemas guarantees termination in all cases. the following quality criteria for an UML/OCL-Lite schema:  X 
Class and schema satisfiability;  X 
OCL-Lite constraint redundancy/entailment;  X  explanation of inconsistencies and redundancies/entailments.
 tools on our running example is very similar, despite following completely different approaches. 7.1. Using a Description Logics reasoner Fig. 2 is shown in Fig. 4 (see Sections 5.1 and 5.2 ).
 in turn, divided into three parts, called Annotations , Asserted Conditions ,and Disjoints . two properties correspond to the roles Audits and Audits  X  t X g X  in the Properties tab, not shown in Fig. 5 .
 5, the second is Constraint 4, the third encodes Constraint 1, and the last one is the cardinality the ALCI formalization of the schema given in Fig. 4 ).

Constraint 1 with the following one: the whole UML/OCL-Lite model. Then, the constraint is redundant iff K
As can be checked, the concept notIC7 is inconsistent w.r.t. K is consistent).
 7.2. Using SVT E the SVT E tool [20] , which is the one we will use to reason on our running example. SVT i.e., the set of constraints that do not allow the property to be satisfied. this case is company ( C ) and this is the question we pose to SVT instances of SponsoredBy . Clicking on event or on company , we get the other two instances of I . In a similar way we check in SVT E the consistency of class explanation is the following. According to Constraint 1, each Constraint 7 forces all events (critical or not) with an organizer to have a ensure that the second argument of the association Organizes by clicking on the button  X  Compute all minimal explanations because of the cardinality constraints 1..* of the roles responsible its semantics.
 ( Fig. 9 ). 7.3. On the performance of current reasoners of them have been successfully checked by both reasoners. The time spent that the current technology can be used in practice to check properties of UML/OCL-Lite schemas. 8. Conclusions and further work straints in DLs.
 it is guaranteed that Pellet is able to check finite satisfiability, while SVT incorporated into existing CASE tools to extend their functionalities. E currently developed to check schema properties of both UML and OCL constraints. Acknowledgments co-funded by the European Union.

References
