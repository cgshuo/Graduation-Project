 1. Introduction objects. Gaede and Gunther [4] classified spatial objects in d -dimensional Euclidean space ( E types. For each k  X  0 6 k 6 d  X  , the set of k -dimensional polyhedra forms a data type. For instance, a two-dimensional graph may contain a zero-dimensional polyhedron (points), a one-dimensional polyhedron well-organized indexing structure, and enables the easy retrieval interested objects for user queries. need to support this dynamic behavior without deteriorating over time. Third, spatial databases tend to be large, making the integration of secondary and tertiary memory essential for efficient processing.
Two-dimensional objects can be categorized according to their space occupancies. Points with zero spatial methods. A line segment does not enclose any area, so cannot be categorized as a nonzero-size object. How-or MBR s (minimum bounding rectangles). Such methods represent line segments using nonzero-size objects condition at higher levels. The resulting indexing structure suffers from many problems, such as the heavy building overhead cost of index structures, poor system execution performance, low retrieval accuracy and the incapability of processing certain types of query.

The rest of this paper is organized as follows. Section 2 reviews pertinent literature on point and region ment and retrieval performance of the proposed system are compared with those of the R -tree indexing scheme. Conclusions are finally drawn in Section 8 . 2. Overview of previous methods
Many methods for handling point and region data have been proposed during the last two decades. The points or regions. The R -tree proposed by Guttman [5] is probably the most popular structure for indexing nonzero-size objects. An R -tree adopts MBR s to enclose nonzero-size objects, and then represent them as such as the GIS application [15] .

Although the above-mentioned structures can efficiently process a large number of point objects, uniform laps between MBR s at each level in an indexing tree. Fig. 1 shows MBR tively. Lines l 1 and l 2 do not intersect, yet MBR 1 and MBR can cross its underlying space and intersect with many other objects. Fig. 2 shows examples of these relationships.

Many researchers have utilized data transformations to deal with line segments. Orenstein and Merrett [14] ous problem with this transformation is that it does not preserve proximity. Another method [18] conceptu-dimensional space.

Hoel and Samet [6,7] performed a qualitative comparison on the performance of three spatial indexing methods, R * -tree, R  X  -tree and PMR quad-tree, in processing spatial queries in large line segment dat-abases. They believed that adopting data structures to preserve spatial occupancy is the best way to over-come the above-mentioned problems. However, since a line segment does not enclose any area, it does not have any spatial occupancy and its representation as any nonzero-size geometric shape still introduces dead space.

Lindenbaum et al. [12] addressed the geometric properties inherent from the line segments generated from the proposed random image model when analyzing the relative qualitative behavior of the various quad-trees between various options in a way that is neither experimental nor domain-dependent. tional B  X  -tree [11] is presented to compact the inserted data. Rather than appealing any other geometric shapes or spatial objects to index line segments, a new technique based on the new version of B posed to handle line segments directly. The proposed indexing structure uses economic space for database storage and performs fast queries over a large scale of line-based database. 3. Compressed B  X  -trees
Handling and organizing a tremendous amount of endpoints of line segments in a large scale of line-based database requires efficient indexing. A traditional B not only consumes a lot of time and space resources in the building process, but also suffers from the poor retrieval performance. This study first proposes a variant of B points of line segments. This new B  X  -tree, called compressed B
A compressed B  X  -tree has the high space efficiency in data storage, and the high time efficiency in data retrieval.
 into a target node, the load status of the target may become under-full, full or overflowed. No adjustment example is given below to illustrate the differences between constructing a traditional B pressed B  X  -tree.

Suppose a data sequence {8,5,1,7,3,12,9,10} is adopted to build a traditional B
B -tree. Fig. 3 shows the procedure and resulting structure of a traditional B building procedure of a compressed B  X  -tree. Both structures have the node capacity of 2 and the fan-out Consider the following four scenarios (A to D):
C. [Attempting to insert a new datum into a full target leaf while at least one of its siblings has free
The most significant improvement resulting from the use of compressed B make leaves bear much more data before appealing splits. (The traditional B than traditional B  X  -trees. Hence, space and time efficiencies are successfully achieved by compressed B
The improvements of storage space and retrieval performance are essential for the design of developing an index scheme. The following sections reveal the superior performance of compressed B objects. 4. New indexing method
A line-based database (denoted by LDB ) comprises a collection of line segments. A line segment is defined as l  X  p i ; p j  X  where p i  X  X  x i ; y i  X  and p j  X  X  x j
For simplicity, denote l  X  p i ; p j  X  by l ij . Assume that line segments are non-directional, then l a simple LDB with 10 line segments, LDB  X f l 12 ; l 15 ; l
I and I y , which contain linearly ordered indexing numbers. Based on the new inserting technique of com-pressed B  X  -trees, the elements in I x and I y are adopted to build two independent compressed B line segments in a LDB into a well-organized index structure. Compressed B the joint hierarchy.

The two distinct x -coordinates of each line l ij in a LDB are collected into I points have the same x -coordinate, which is not included into I of l ij . Then I x is defined as follows: endpoints in common. The point p 4 is a common endpoint shared by lines l l are not parallel to the y -axis, numbers x 3 , x 4 , x 5 and x and the number y 6 in I y is derived from l 48 or l 78 but not from l in I x and 7 numbers in I y . That is, j I x j X  9 and j I y j X  7.
 coordinate, and (3) all line segments have nonzero lengths, we can infer j I endpoint can be shared by several line segments and then the magnitudes of j I 2 j LDB j . As a result, the proper range of the magnitudes of j I
To maintain the correct orders in I x and I y , these elements are sorted every time when new elements are appended to the sets. Suppose that the insertion order of line segments in Fig. 5 is f l and the compressed B  X  y -tree are f x 1 ; x 2 ; x 5 ; x 3 6 and 7 show the resulting compressed B  X  x -tree and compressed B 13 data entries and its space utilization is 13 =  X  8 2  X  X  81 : 25 % . Conversely, a traditional B same data insertion order involves 7 splits, and allocates 10 nodes to complete the index as shown in Fig. 8 . This tree has 14 data entries and its space utilization is 14 =  X  10 2  X  X  70 % . them is 10 =  X  7 2  X  : 11 =  X  8 2  X  X  71 : 43 %: 68 : 75 % .

Let x i denote an arbitrary number on the x -axis, which may be an element in I defined as the numbers before and after x i in I x , respectively, so that x x 2 I x exists where x i &lt; x m &lt; x i or x i &lt; x m &lt; x
In our design, an entry associated with the indexed number x form [ x k , bp ], where bp denotes an array pointer referring to the array C  X  x into C  X  x k  X  if their vertical projections overlap  X  x k Restated, C  X  x k  X  and C  X  x y  X  can be defined as follows:
Taking p 4 in Fig. 5 for illustration, the spatial proximity near coordinate  X  x information preserved in C  X  x 4  X  , C  X  x 4  X  , C  X  y 4  X  and C  X  y
The number of identifiers preserved in arrays grows significantly when LDB  X  X  data size grows. Fortu-predecessor arrays. Using the LDB as shown in Fig. 5 , and taking x
C  X  x 2  X  X f l 23 ; l 15 g is replaced by the tuning array C from C  X  x 1  X  , and  X  l 23 means that l 23 is included into C  X  x &amp; B  X  y -trees are shown as follows: entries from the leaf X  X  leftmost entry, where M denotes the maximum capacity of a leaf node. Fig. 10 (a) are completely indexed at the leaf level of the compressed B 5. Maintaining indexing structures and query processing
Adding a new line segment with nonzero length into a LDB may insert a new index record into the com-pressed B  X  x -tree and/or compressed B  X  y -tree. Inserting such a new index record into a compressed B compressed B  X  y -tree is similar to inserting one into a compressed B their contents.

When inserting a segment with one or two x -coordinates not listed in I inserted into the compressed B  X  x -tree. Some arrays referred by the leaves in the compressed B
B
I Algorithm. Insertion
Input: A segment l ab  X  l  X  p a ; p b  X  with p a  X  X  x a ; y &amp; B  X  y -trees.

Output: The roots of the new compressed B  X  x &amp; B  X  y 1. Let x 1 min  X  x a ; x b  X  , x 2 max  X  x a ; x b  X  , y 1 2. Search the compressed B  X  x &amp; B  X  y -trees for x 1 insert x 1 and/or x 2 into the compressed B  X  x -tree. Apply similar operations in y -direction (i.e. y are/is not found and y 1 6  X  y 2 ) to the compressed B  X  y 3. In the compressed B  X  x -tree, 4. Apply the same operations as those in step 3 in y -direction to the compressed B 5. Return the roots of the new compressed B  X  x &amp; B  X  2D space causes some indexed entries to be deleted from compressed B is required for compressed B  X  x &amp; B  X  y -trees. The deletion algorithm is described as follows: Algorithm. Deletion
Input : A segment l ab  X  l  X  p a ; p b  X  with p a  X  X  x a ; y compressed B  X  x &amp; B  X  y -trees.

Output: The roots of the new compressed B  X  x &amp; B  X  y 1. Let x 1 min  X  x a ; x b  X  , x 2 max  X  x a ; x b  X  , y 1 2. Search the compressed B  X  x &amp; B  X  y -trees for x 1 found X  X  and exit. 3. In the compressed B  X  x -tree, 4. Apply the same operations as those in step 3 to the compressed B 5. Return the roots of the new compressed B  X  x &amp; B  X 
Queries on a LDB are categorized into three types: point, interval and window queries. A point query is the candidates. A segment l ij is regarded as a candidate if D  X  l distance between l ij and P . A query interval QI  X  x 1 ; x query is easily implemented by performing two rounds of point query on the compressed B the outputs of the two interval queries.
 Algorithm. Point_Query( P ) Input: A point P  X  x a ; y a  X  and a threshold j .

Output: A set S contains the segments that are near P . 1. S / . 2. Search the compressed B  X  x -tree for x a , if found, then set S x p  X  x a . Then set S 1  X  C  X  x p  X [ C  X  x p  X [ C  X  x  X  p 3. The same operations as step 2 regarding the y -axis are applied in the compressed B found, let S 2  X  C  X  y a  X [ C  X  y a  X  . Otherwise, find y [ C  X  y p  X [ C  X  y  X  p  X  . 4. S 3 S 1 \ S 2 . 5. For each l ij 2 S 3 ,if D  X  l ij ; P  X  6 j , then 6. Return S .
 Algorithm. Interval_Query( QI )
Input: An interval QI  X  x a , x b  X  along the vertical direction, x
Output: A set S contains segments whose vertical projections intersect QI . 1. S / . 2. Search the compressed B  X  x -tree for x a , if found, then let x 3. Search the compressed B  X  x -tree for x b , if found, then let x 4. For every x i 2 I x that satisfies x s 6 x i 6 x e , 5. Return S .
 Algorithm. Window_Query( W )
Input: A window W has the query intervals QI  X  x a , x b  X  and QI  X  y
Output: A set S contains segments that intersect W . 1. S / . 2. S 1 Interval Query  X  QI  X  x a ; x b  X  X  . 3. S 2 Interval Query  X  QI  X  y a ; y b  X  X  . 4. S S 1 \ S 2 . 5. Return S .

Assume the node capacity of the compressed B  X  x -tree and the compressed B number of involved pages (visited nodes) in the compressed B
One round of single-path searching is performed on each of the compressed B is  X  D x  X  D y  X  . Hence, the time complexity of a point query is O  X  log the x -axis, two rounds of point queries are performed on the compressed B dow queries can be completed by applying one round of interval query on each of the compressed B the compressed B  X  y -tree, and the time complexity is similar to that of an interval query. 6. Experimental results
Line-based databases were tested in six sizes  X  N  X  2 10 ; 2 tables contain the measurements of the magnitude of j I x compressed trees, the depths of two compressed trees and the average number of elements in each array  X  N olution, was also considered. In a sparse case, I x  X  I y
Interestingly, the tree organization changed little when the data size N was doubled. This can be observed overhead cost of storage space used in maintaining compressed B proportional to the magnitude of N .

For further comprehension of the entire indexing structures, the number of line segments preserved in each pressed B  X  x -tree (or compressed B  X  y -tree), all N b values were averaged to obtain the measurement N in the final column of Tables 1 and 2 . The result N b  X  2 : 4 in the case of N  X  2 information is added to the arrays, even when the data size N grows significantly.
Elementary probability demonstrates that N b is approximately equal to 2 N divided by j I end-points of line segments are evenly distributed over the 2D domain. That is
In sparse cases, N b is normally between 1 and 2 since the magnitude of j I 2 N . However, if the data quantity N rises, or if dense cases are considered, then the magnitude of j I of this analysis, and is shown in Fig. 11 . 7. Application to GIS database
Several experiments were also performed on a GIS map to evaluate the performance of the proposed system and to demonstrate the improvement of the proposed method over the system based on the R -tree indexing scheme. One thousand line segments were chosen from the traffic network of a digital map of Taipei city in
Taiwan, as shown in Fig. 12 . The size of this map was 774 618, and all 1000 line segments were stored in the data files so that both the proposed index method and the R -tree indexing scheme could adopt the same set of line segments for performance comparison. This application was written in MatLab and in C language.
A personal computer with an Intel Pentium 1400 MHz processor was used with CPU executing at 1000 ticks per second.
 was 1000, and the maximum number of entries in a node ( M ) varied from 4 to 10. Since N and M were both
The number of nodes generated at each level in all cases indicates that the sizes of the compressed B may contribute the same indexing numbers to I x or I y . Hence, the magnitudes of j I fewer leaves than the R -tree. Our compressed B  X  x -tree and compressed B for each level in all three cases. Notably, the tiny difference between compressed B tree was caused by the different resolutions of X and Y .
 external or internal node of the compressed B  X  x &amp; B R -tree to the compressed B  X  x &amp; B  X  y -trees was about 8:1.

To measure query performance, the number of nodes involved, the number of segments compared and the access time during the query process were evaluated. Tables 5 and 6 show the measurement results. The mea-surements were averaged after applying 100 point queries over the digital map. The R -tree involved more multiple paths. In contrast, each point query in the compressed B path. An upper MBR can enclose many lower MBR s, and a multiple path retrieves several target MBR s, thus an R -tree retrieves many more candidate segments than the compressed B
B -trees not only take less time to finish its search, but also take much less time to compare the candidate segments to the query position. These two significant improvements make the proposed method better than on average to complete a point query, while the compressed B the final experimental results of 100 window queries. The size of each query windows was 1/25 of the whole digital map. Both the average number of nodes involved and the average number of segments compared in the dow queries on compressed B  X  x &amp; B  X  y -trees have the lower time efficiency than point queries. 8. Conclusion
Compressed B  X  -trees in collaboration with new indexing techniques can efficiently arrange line segments into compressed hierarchical directories. The application of compressed B influenced by the size of the data.

References
