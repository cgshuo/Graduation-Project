 In this work, we concentrate on subgraph query processing in a large general graph. In this model, each vertex/edge can be associated with any content. We integrate off-the-shelf systems with graph databases as the underlying storage. Meanwhile, the graph structure is stored in a native graph system. Furthermore, for speeding up the query processing, we propose an simple but efficient index structure, which does not rely on vertex contents.

Besides the index, we design a holistic subgraph matching algorithm . Generally speaking, we design a distance-based vertex coding strategy. In query processing, we maintain a priority queue (according to vertex codes) for each query vertex. When a vertex v needs to be dequeued, we find subgraph matches containing v directly. In order to speed up this step, we propose some pruning rules to reduce the search space.
Last but not the least, we evaluate our methods on graphs which have more than 100 millions edges. To the best of our knowledge, this is the largest data graph in the literature about subgraph query problem in a single machine. In this section, we review the terminology that we use throughout this paper. is a set of content; and (4)  X  : V ( G )  X  denotes the content assignment function, where  X  v  X  V ( G ) ,  X  ( v ) is v X  X  corresponding content.
 F = { f Definition 3. Subgraph Match. Given a data graph G = { V ( G ) , E ( G ) , , X  } and a conditions hold: 1.  X  ( v i ) satisfies the criterion f i in query vertex u i ,i = 1 ,..., n. 2.  X  u i , u j  X  V ( Q ) , u i u j  X  E ( Q )  X  v i v j  X  E ( G ) , 1  X  i , j  X  n. 1  X  i  X  n.
 Definition 4. (Problem Statement) Given a data graph G and a query graph Q, where | 3) of Q in G. %vspace-0.3in In this section, we introduce a novel index only based on distance information. In par-pivot is discussed in Section 3.2. 3.1 Pivot-Based Encoding Strategy tion 5.
 denotes the shortest path distance between the two vertices.
 u we find subgraph matches containing v .
 (i j).
 | L ( v ) | &gt; dist ( u i , u j ), v and v cannot form a match. 3.2 Pivot Selection possible. Second, the number of vertices in each layer should be as small as possible. According to Theorem 1, the search space is small in the above case. Considering the above two conditions, we introduce the vertex entropy (Definition 6) to evaluate the goodness. The vertex with the largest entropy is selected as the pivot v  X  . Definition 6. Vertex Entropy. Given an vertex v, according to the vertex codes, there defined as follows: Based on vertex codes, we propose a holistic subgraph matching (HSM) algorithm. We discuss the data structures used in HSM algorithm in Section 4.1, followed by the algorithm in Section 4.2. 4.1 Data Structures Each query vertex u i is associated with three data structures in HSM: candidate list TL ( u i ), cursor C ( u i )and queue T Q ( u i ).
 u . Note that all candidate vertices are sorte d according to the non-descending order of vertex codes (see Definition 5) in TL ( u i ).
 one among all vertices C ( u i ) moves one step forward to the next vertex in the list. the search space for finding subgraph matches containing v is bounded by Theorem 1. The dequeuing rule is discussed in Section 4.2 in details. When a vertex v is dequeued from TQ ( u ), we perform a graph exploration algorithm to find all subgraph matches containing v . 4.2 Algorithm graph matches with some vertices that ar e close to each other. During query execution, any vertex in any queue (as discussed in Theorem 1), it dequeue from its queue.
When a vertex v dequeue from a queue, we employ graph exploration to search all queues and find subgraph matches containing v . Essentially, the graph exploration function is the same with VF2 subgraph isomorphism algorithm. The only difference is that our algorithm is beginning the search process from vertex a given vertex v i . In this section, we evaluate our method over two real datasets. In our experiments, We We conducted all experiments on a computer with 2.0 GHz Intel Core 2 Duo processor and 32 GB memory running Linux. In experiments, we use MySQL (version 5.5.15.0) as the vertex content management system, i.e., using MySQL for finding candidate vertices satisfying the criteria in each query vertex.

Since most subgraph match algorithms can only work on vertex-labeled graphs, we only compare our solution with SQLs and the graph exploration method [4]. For SQLs, graph query can be modeled as a SQL query. In order to speed up query processing, we cache the whole graph in memory.

Over US Patent dataset, Fig. 1(a) shows our method is faster than SQLs by an order of magnitude. As well, our method is twice as fast as graph exploration. Note that SQL as shown in Fig. 1(b). As well, SQL over Yago2 is too slow to finish the query when |
E ( Q ) | X  4. This is because that SQL involves too manu expensive join steps. Ullmann [5] and VF2 [1] are the two early efforts for subgraph isomorphism problem. In order to speed up query response time, rencent subgraph search methods [6,7] pre-compute some structural indexes to reduce the search space. They assume that the data graph is a vertex-labeled graph, i.e., each vertex has a single label. Obviously, these methods cannot be adopted in a data graph with various kinds of vertex-specific con-tent. Jinsoo Lee et al. [3] re-implements some of the above methods and provide a fair comparison of them. Then, they present a solution, called Turbo ISO [2]. Turbo ISO di-vides all query vertices into some classes. When Turbo ISO find subgraph matches, only combinations for each class are generated. In this work, we study subgraph search problem over a large general graph. We propose a distance-based vertex code and an associated holistic subgraph matching algorithm to handle subgraph search problem.
 Acknowledgments. Peng Peng and Lei Zous work were supported by NSFC under grant No.61370055. Lei Zou was also supported by Beijing Higher Education Young Elite Teacher Project under grant No. YETP0016. Dongyan Zhao was supported by NSFC under grant No. 61272344 and 863 project under grant 2012AA011101.

