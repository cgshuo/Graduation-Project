 Instructional language describes how to achieve a wide variety of goals, from traveling successfully to a desired location to cooking a particular dish for dinner. Despite the fact that such language is important to our everyday lives, there has been rel-atively little effort to design algorithms that can automatically convert it into an actionable form. Existing methods typically assume labeled train-ing data (Lau et al., 2009; Maeta et al., 2015) or access to a physical simulator that can be used to test understanding of the instructions (Branavan et al., 2009; Chen and Mooney, 2011; Bollini et al., 2013). In this paper, we present the first approach for unsupervised learning to interpret instructional recipes using text alone, with application to cook-ing recipes.

Given a recipe, our task is to segment it into text spans that describe individual actions and con-struct an action graph whose nodes represent ac-tions and edges represent the flow of arguments across actions, for example as seen in Fig. 1. This task poses unique challenges for semantic anal-ysis. First, null arguments and ellipses are ex-tremely common (Zwicky, 1988). For example, sentences such as  X  X ake for 50 minutes X  do not explicitly mention what to bake or where. Second, we must reason about how properties of the phys-ical objects are changed by the described actions, for example to correctly resolve what the phrase  X  X he wet mixture X  refers to in a baking recipe. Al-though linguistic context is important to resolving both of these challenges, more crucial is common sense knowledge about how the world works, in-cluding what types of things are typically baked or
These challenges seemingly present a chicken and egg problem  X  if we had a high quality se-mantic analyzer for instructions we could learn common sense knowledge simply by reading large bodies of text. However, correctly understand-ing instructions requires reasoning with exactly this desired knowledge. We show that this con-flict can be resolved with an unsupervised learn-ing approach, where we design models to learn various aspects of procedural knowledge and then fit them to unannotated instructional text. Cook-ing recipes are an ideal domain to study these two challenges simultaneously, as vast amounts of recipes are available online today, with significant redundancy in their coverage that can help boot-strap the overall learning process. For example, there are over 400 variations on  X  X acaroni and cheese X  recipes on allrecipes.com, from  X  X hipotle ( e macaroni and cheese, X  to  X  X heesy salsa mac. X 
We present two models that are learned with hard EM algorithms: (1) a segmentation model to extract the actions from the recipe text, and (2) a graph model that defines a distribution over the connections between the extracted actions. The common sense knowledge is encoded in the sec-ond model which can, for example, prefer graphs that model implicit verb arguments when they better match the learned selectional preferences. The final action graph is constructed with a local search algorithm, that allows for global reasoning about ingredients as they flow through the recipe.
Experiments demonstrate the ability to recover high quality action graphs, gaining up to 8 points in F1 over a strong baseline where the ingredients flow sequentially through the verbs. The learned models are also highly interpretable, specifying for example that  X  X ough X  likely contains  X  X lour X  and that  X  X dd X  generally requires two food argu-ments, even if only one is mentioned in the sen-tence. Procedural text such as a recipe defines a set of actions, i.e. predicates , applied to a set of objects, i.e. arguments . A unique challenge in procedu-ral text understanding is to recover how different arguments flow through a chain of actions; the re-sults of intermediate actions (e.g.,  X  X oil the pasta until al dente. X ) provide the inputs for future ac-tions (e.g.,  X  X rain. X ). We represent these corre-spondences with an action graph . In this section, we first describe our structured representation of recipe text, then we define how components of the recipe connect. Finally, we will show how given a recipe and a set of connections we can construct an action graph that models the flow of ingredi-ents through the recipe. Fig. 1 provides a detailed running example for the section. 2.1 Recipe R A recipe R is a piece of text that describes a list of instructions and a (possibly-empty) set of raw ingredients that are required to perform the in-structions. The first step is to segment the text into a list of verb-argument tuples, called actions , E will describe an unsupervised approach for learn-ing to segment recipes. Each action e i pairs a verb v with a list of arguments a i , where a ij is the j th argument of verb v i . In Fig. 1, each row contains an action with a verb in the white oval and its ar-guments in the yellow and gray ovals.

Each argument is a tuple a ij = ( t syn with a syntactic type t syn ( a )  X  T syn = { DOBJ, P P } , a semantic type t sem ( a )  X  T sem = { f ood, location, other } , and a list of text string spans S ij = { s 1 ij , . . . , s | S ij | ij is the k th span in the j th argument of verb v i . In Fig. 1, the spans of each argument are repre-sented by the white ovals inside of the argument ovals. For example, a 21 contains a span for each raw ingredient being mixed in the second action (e.g., s 1 21 =  X  X round beef, X  s 6 21 =  X  X rown sugar X ). The syntactic type determines whether the argu-ment is the direct object or a prepositional phrase argument of the verb in the recipe text. All other syntactic constructs are ignored and left for future work. The semantic types include food, location, and other. In Fig. 1, yellow ovals represent foods and gray ovals represent locations. Arguments of other semantic types are marked as other (e.g.,  X  X ash using a fork  X ).

We also augment the set of arguments for each verb to include implicit arguments with empty string spans. This allows making connections to arguments that the author does not mention explic-itly (e.g., the elided direct object of  X  X ake X  in e 5 ). Every verb is assigned one implicit P P argument, and, if a verb has no argument with syntactic type DOBJ , an implicit direct object. These argu-ments have indeterminate semantic types, which are to be determined based on how they connect to other actions. For example, in Fig. 1, when the implicit object of  X  X ake X  is connected to the out-put of the  X  X ay X  action, it is inferred to be of type f ood since that is what is created by the  X  X ay X  ac-tion. However, when the implicit P P argument of  X  X ake X  is connected to the output of the  X  X re-heat X  action, it is inferred to be a location since  X  X reheat X  does not generate a food. 2.2 Connections C Given a segmented recipe, we can build graph con-nections. A connection identifies the origin of a given string span as either the output of a previ-ous action or as a new ingredient or entity being introduced into the recipe. A connection is a six-tuple ( o, i, j, k, t syn , t sem ) indicating that there is a connection from the output of v o to the argu-and semantic type t sem  X  T sem . We call o the origin index and i the destination index . For ex-ample, in Fig. 1, the connection from the output of the  X  X ress X  verb ( e 3 ) to  X  X ver the top X  ( s 1 42 ) would be (3 , 4 , 2 , 1 , P P, f ood ) . If a span introduces raw ingredient or new location into the recipe, then o = 0 ; in Fig. 1, this occurs for each of the spans that represent raw ingredients as well as  X  X ven X  and  X  X nto loaf pan. X 
Given a recipe R , a set of connections C is valid for R if there is a one-to-one correspondence be-tween spans in R and connections in C , and if the origin indexes of connections in C are 0 or valid verb indexes in R ,  X  ( o, i, j, k, t syn , t sem )  X  C, o  X  X  Z | 0  X  o  X | E R |} . 2.3 Action graph G A recipe R and a set of connections C define an action graph , which is a directed graph G = ( V, E ) . Each raw ingredient, verb, and argu-ment span is represented by a vertex in V . Each argument span vertex is connected to its asso-ciated verb vertex, and each connection c = ( o, i, j, k, t syn , t sem ) adds a corresponding edge to E . Edges from connections with seman-tic type f ood propagate ingredients through the recipe; edges from connections with semantic type location propagate a location. Fig. 1 shows an ac-tion graph. By following the edges, we can tell that the implicit food entity that is being baked in the final action has been formed from the set of ingredients in the mixing action and the bacon from e 4 and that the baking action occurs inside the oven preheated in e 1 . Our goal is, given a segmented recipe R , to deter-mine the most likely set of connections, and thus the most likely action graph. We model (1) a prior probability over C , P ( C ) (Sec. 3.1), and (2) the probability of seeing a segmented recipe R given a set of connections C , P ( R | C ) (Sec. 3.2). The most likely set of connections will maximize the joint probability: P ( R | C ) P ( C ) . A summary of this model is presented in Fig. 2, and the details are described in the this section. 3.1 Connections prior model The probability of a set of connections C depends on features of the incoming set of connections for each action. Let a destination subset d i  X  C be the subset of C that contains all connections that have i as the destination index. In Fig. 1, d 3 con-tains the connection from v 2 to the implicit object as well as a connection to  X  X nto loaf pan X  with an origin index of 0. Using the chain rule, the proba-bility of C is equal to the product of the probability of each of the destination subsets: The probability of each destination subset de-composes into two distributions, a verb signature model and a connection origin model: We define each of these distributions below. 3.1.1 Verb signature model A destination subset d i deterministically defines a verb signature g i for verb v i based on the syntac-tic and semantic types of the connections in d i as well as whether or not each connection has a non-zero origin index. If the origin index is 0 for all connections in d i , we call v i a leaf . (In Fig, 1, v 1 (preheat) and v 2 (mix) are leafs.) The formal definition of a verb signature is as follows: Definition 1 The verb signature g i for a verb v i given a destination set d i consists of two parts: 1. type: { t syn | X  ( o, i, j, k, t syn , f ood )  X  d i } 2. leaf: true iff ( o, i, j, k, t syn , t sem )  X  d i  X  For example, in Fig. 1, the signature for the  X  X ix X  action is g 2 = ( { DOBJ } , true ) and the signature for the  X  X ay X  action is g 4 = ( { DOBJ, P P } , f alse ) . Given that there are two syntactic types (i.e., DOBJ and P P ) and each verb signature can either be labeled as a leaf or not, there are eight possible verb signatures.
We define a deterministic function that re-turns the verb signature of a destination subset: vs ( d i ) = g i . P ( vs ( d i )) is a multinomial distri-bution over the possible verb signatures. 3.1.2 Connection origin model We define 1 ( o  X  s k ij ) as an indicator function that is 1 if there is a connection from the action with in-dex o to the span s k ij . The probability that a string span has a particular origin depends on (1) the verb signature of the span X  X  corresponding verb, and (2) the previous connections. If, for example, g i has leaf = true , then the origin of s k ij must be 0. If an origin has been used in a previous connection, it is
We assume that a destination subset is a list of connections: if c p  X  d i , we define c p  X  1 nections that are prior to c p in the list. Similarly, d The connection origin model is a multinomial dis-tribution that defines the probability of an origin for a span conditioned on the verb signature and all previous connections: where c p = ( o, i, j, k, t syn , t sem ) . 3.2 Recipe model Given a set of connections C for a recipe R , we can determine how the actions of the recipe inter-act and we can calculate the probability of gen-erating a set of recipe actions E R = { e 1 = ( v 1 , a 1 ) , . . . , e n = ( v n , a n ) } . Intuitively, R is more likely given C if the destinations of the con-nections are good text representations of the ori-gins. For example, a string span  X  X ven X  is much more likely to refer to the output of the action  X  X reheat the oven X  than  X  X ix flour and sugar. X 
We define the history h i of an action to be the set of all previous actions: h i = ( e 1 , . . . , e i  X  1 The probability of a recipe R given a set of con-nections C can be factored by the chain rule: Given C and a history h i , we assume the verb and arguments of an action are independent: P ( e i | C, h i ) = P ( v i | C, h i ) Since the set of connections deterministically de-fines a verb signature g i for a verb v i , we can sim-plify P ( v i | C, h i ) to the multinomial distribution P ( v i | g i ) . For example, if g i defines the verb to have an ingredient direct object, then the probabil-ity of  X  X reheat X  given that signature will be lower than the probability of  X  X ix. X 
The probability of an argument a ij = ( t decomposes as follows: 3.2.1 Argument types model The first distribution, P ( t syn that the syntactic and semantic types of the argu-ment match the syntactic and semantic type of the incoming connections to spans of that argument. The probability is 1 if all the types match, 0 oth-erwise. For example, in Fig. 1, this distribution would prevent a connection from the  X  X reheat X  ac-tion to the food argument a 42 , i.e.,  X  X ver the top, X  since the semantic types would not match. 3.2.2 String span models The second distribution, P ( S ij | t syn models how likely it is to generate a particular string span given the types of its encompassing ar-gument, the connections, and history. We assume the probability of each span is independent:
We break this distribution into three cases. To help describe the separate cases we define the function origin ( s, C ) to determine the origin in-dex of the connection in C to the span s . That is, origin ( s k ij , C )= o  X  X  X  ( o, i, j, k, t syn , t sem )  X  C . Part-composite model When the encompassing argument is a food and the origin is a previous verb 0 , C, h i ) ), then the probability of the span depends on the ingredients that the span represents given the connections in C. For example,  X  X ressing X  is more likely given ingredients  X  X il X  and  X  X inegar X  than given  X  X hicken X  and  X  X oodles X . We use IBM Model 1 (Brown et al., 1993) to model the prob-ability of a composite destination phrase given a set of origin food tokens. Let f ood ( s k ij , C ) be the set of spans in food arguments such that there is Model 1 defines the probability of a span given the propagated food spans, P ( s k ij | f ood ( s k ij , C )) . 3 Raw food model When the encompassing ar-gument is a food but the origin index is 0 0 , C, h i ) ), then there is no flow of ingredients into the span. A span that represents a newly intro-duced raw ingredient (e.g.,  X  X acon X  in e 4 of Fig. 1) should have a high probability. However, spans that denote the output of actions (e.g,  X  X atter, X   X  X a-nana mixture X ) should have low probability. We use a na  X   X ve Bayes model over the tokens in the span P ( s | is raw ) = the ` th token in s (e.g.,  X  X ixture X  would have a very low probability but  X  X lour X  would be likely). Location model When the encompassing ar-gument is a location (i.e., t sem ij = location ), Figure 3: The three types of search operators. For swaps, one of the origins can be 0.
 ness of the origin action X  X  location for the destina-tion. If the string span is not implicit, the model deterministically relies on string match between the span and the location argument of the verb at the origin index. For example, the probability of  X  X he preheated oven X  conditioned on an origin with location  X  X ven X  is 1, but 0 for an origin with location  X  X owl. X  If the span s k ij is empty, we use a multinomial model P ( loc ( origin ( s k ij , C )) | v that determines how likely it is that an action v i occurs in the location of the origin verb. For ex-ample, baking generally happens in an oven and grilling on a grill, but not vice versa. For example, in Fig. 1, the probability of the location span of  X  X ake X  is determined by P (  X  X ven X  |  X  X ake X  ) . Connections among actions and arguments iden-tify which ingredients are being used by which action. For example, in Fig. 1, we know that we are baking something that contains all the ingre-dients introduced in e 2 and e 4 because there is a path of connections from the introduction of the raw ingredients to the implicit object of  X  X ake X . We cannot make decisions about the origins of argu-ments independently; the likelihood of each edge depends on the other edges. Identifying the most likely set of connections is, therefore, intractable.
We adopt a local search approach to infer the Algorithm 1 Pseudocode for learning P ( C, R ) Input : Initialized P ( C, R ) , recipe dataset R Repeat until convergence:
Return P ( C, R ) connections using a sequential algorithm that con-nects the output of each event to an argument of the following event, which is a strong baseline as shown in Sec. 8. We score potential local search operators that can be applied to the current set of connections C and make a greedy selection that improves P ( C, R ) the most until no search opera-tor can improve the probability. We constrain the search so all verbs have a direct object (i.e., im-plicit direct objects connect to a previous action). We employ three types of search operators (see Fig. 3 for details). O P A DD changes the origin in-dex of a connection in C from 0 to the index of an event. O P 2S WAP swaps the origin indexes of two connections. This works even if one of the origin indexes is 0. O P 3S WAP rotates the origin indexes of three connections. This works even if one of the origin indexes is 0. For efficiency rea-sons, we only allow 3-way swaps with destination indexes within 4 events of each other. We use hard EM to learn the probabilistic mod-els. Pseudocode is given in Alg. 1. At each itera-tion, we use our local search algorithm and the cur-rent probabilistic models to annotate each recipe in the data set with its most likely set of connec-tions C (Sec. 4). Then, we re-estimate the param-eters of the probabilistic models using the recipe-connections pairs as training data. A small (33 recipes) development set was used to determine when to stop the iterations. Experimental details and model initialization are described in Sec. 7. Our inference and learning algorithms assume as input a recipe segmented into a set of events E R = tation system that could be trained on our un-annotated data set of mostly imperative sentences. Our system achieves an F1 score of 95.6% on the Segmentation model We define a generative model for recipes as:
P ( R ) = P ( n ) We first select a number of verbs n in the recipe from a geometric distribution. Given the number of verbs, we select a set of verbs V = { v 1 , . . . , v n using a multinomial distribution. For each verb v i , we select a number of arguments m from a sep-arate multinomial distribution that has the prob-ability of 0, 1, 2, or 3+ arguments given the verb, P ( m | v i ) . For each argument, we gen-erate a string using a bigram model, P ( a ij ) = Q Inference Given tokenized sentence T = ( w 1 , . . . , w k ) , we enumerate all possible segmen-tations and choose the one with the highest prob-ability. To keep this efficient, we use a closed set of possible verbs and assume a closed set of words (e.g., prepositions, adverbs) can only follow the start token in the argument bigram model. Thus, annotating the verbs in a sentence determines a unique set of argument strings. Despite scoring the segmentations for all possible sets of verbs, we found the process to be very efficient in practice. Learning For unsupervised learning, we again employ a hard EM approach. We initialize our models, segment all of the training data, re-estimate the parameters, and iterate these steps un-til performance on a development set converges.
We estimate the initial verb multinomial model using counts from the first word of each sentence in the dataset, which are normally verbs in imper-ative sentences, and filter out any words that have no verb synsets in WordNet (Miller, 1995). All other models are initialized to be uniform. Data Set We collected 2456 recipes (with over 23,000 sentences) from allrecipes.com by search-ing for 20 dish names (e.g., including  X  X anana muffins X , and  X  X eviled eggs X ). We randomly sam-pled, removed, and hand labeled 33 recipes for a development set and 100 recipes for test. All mod-els were trained on the unannotated recipes; the dev set was used to determine the stopping point for training. Each recipe in the test set has 13 ac-tions on average.
 Recipe pre-processing To pre-process each recipe, we first use the segmentation system de-scribed in Sec. 6. Then, we use a string classifi-cation model to determine the semantic type (e.g., f ood , location , or other ) of an argument based on its spans. We identify spans as raw ingredients based on string match heuristics (e.g., in Fig. 1, the span  X  X rushed crackers X  represents the ingredients  X  X rushed butter-flavored crackers X ). We stem all words and ignore function words.
 Sequential Baseline Because most connections are sequential  X  i.e., argument spans are most of-ten connected to the output of the previous verb  X  sequential connections make a strong baseline; we connect the output of each predicate to the first available argument span of the following predi-cate. If no argument exists, an implicit argument is created. We run this baseline with and without first identifying raw ingredients in the recipe; if raw in-gredient spans are identified, the baseline will not connect the previous event to those spans. Perfor-mance suffers significantly if the raw ingredients are not identified beforehand.
 Evaluation metrics We report F-measure by comparing the predicted connections from actions to spans (i.e., where the origin index &gt; 0) against gold standard annotations. We don X  X  evaluate con-nections to raw ingredients as we create those con-nections during pre-processing (see Sec. 7). Model initialization The verb signature model (Sec. 3.2) is initialized by first identifying f ood arguments using string overlap with the ingredi-ent list. All other arguments X  types are considered unknown, and partial counts were awarded to all verb signatures consistent with the partial infor-mation. The first verb in each recipe was assumed to be the only leaf. The string classification model for the pre-processing step was initialized by us-ing the initialized verb signature model to identify the types of DOBJ arguments. The string classi-fication model was estimated using the argument tokens given the types. We initialized the part-composite model (Sec. 3.2.2) so that exact string matches between ingredients and spans are given Table 1: Performance of our algorithm against the sequential baselines.
 Table 2: The top scoring location token for exam-ple verbs. The percentage is the percent of times the verb has that as a visible location token. high probabilities and those without are given low probabilities. Given the initialized string classifi-cation model, the raw food model (Sec. 3.2.2) is initialized counting whether or not tokens in food arguments occur in the ingredient list. The proba-bility of an implicit location (Sec. 3.2.2) is initial-ized to a hand-tuned value using the dev set. Quantitative Results We trained our model for four iterations of hard EM until performance con-verged on the development set. Table 1 presents our results on the test set. We compare our model to the sequential baselines using both the output of our segmentation system and oracle segmen-tations. We perform significantly better than the sequential baselines, with an increase in F1 of 8 points over the more competitive baseline us-ing our segmentation system and an increase of 8 points using the oracle segmentations.
 Qualitative Results We find that the learned models demonstrate interpretable cooking knowl-edge. Table 3 shows the top composite tokens for different ingredients as learned by the part-composite model (Sec. 3.2.2). The composite tokens show parts of the ingredient (e.g., after  X  X ggs X  can be split into  X  X hites X  or  X  X olks X ) or Table 4: The top verb signatures for example verbs. The syntactic types identify which argu-ments of the verb are foods and  X  X eaf X  means no arguments of the verb connect to previous actions. composites that are likely to contain an ingredi-ent (e.g.,  X  X lour X  is generally found in  X  X atter X  and  X  X ough X ). Unsurprisingly, the word  X  X ixture X  is one of the top words to describe a combina-tion of ingredients, regardless of the ingredient. The model also learns modifiers that describe key properties of ingredients (e.g., flour is  X  X ry X  but bananas are  X  X et X ) which is important when eval-uating connections for sentences such as  X  X old the wet mixture into the dry ingredients. X 
Table 2 shows the location preferences of verbs learned by the location model (Sec. 3.2.2). Some verbs show strong preferences on locations (e.g.,  X  X ake X  occurs in an oven,  X  X ix X  in a bowl). The top location for a  X  X oil X  action is in  X  X ater, X  but in other recipes  X  X ater X  is an ingredient.
 Finally, Table 4 shows learned verb signatures. For example,  X  X dd X  tends to be a non-leaf action, and can take one or two food arguments (e.g., one food argument:  X  X eat the pan. Add onions. X  vs. two food arguments:  X  X dd the wet mixture to the dry mixture. X ) We learn that the most likely verb signature for  X  X dd X  has two food arguments; since over 74% of the occurrences of  X  X dd X  in the dataset only have one visible argument, the seg-mentation alone is not enough to determine the signature.
 Errors Finally, we performed an error analysis on the development set. 24% of the errors were due to missing or incorrect actions caused by seg-mentation errors. Among the actions that were segmented correctly, 82% of the outgoing connec-tions were sequential. Of those, our system missed 17.6% of the sequential connections and 18.3% of the non-sequential connections. Our work relates to a substantial body of research that transforms natural language instructions into actionable plans (Artzi and Zettlemoyer, 2013, Chen and Mooney, 2011, Branavan et al., 2011, Branavan et al., 2009, McMahon et al., 2006). Most of these approaches do interactive learning in virtual environments or simulations, while we learn from the redundancy seen in the text of dif-ferent instances of similar recipes.

There is also significant related work on su-pervised learning for instructions. A recent se-ries of studies have explored parsing of cook-ing recipes (Mori et al., 2012; Mori et al., 2014; Maeta et al., 2015). However, they assume anno-tated data, study Japanese recipes, and make edge connections independently without taking into ac-count the flow of ingredients. Tasse and Smith (2008) develops annotation for English recipes, but do not mark connections from implicit roles, and only studied segmentation models. Lau et al. (2009) develop models to interpret how-to in-structions, but also assume supervision, and do not make connections between different actions.

Data-driven extraction of cooking knowledge has been explored in the context of building a cooking ontology (Gaillard et al., 2012; Nanba et al., 2014). In contrast, our work induces prob-abilistic cooking knowledge as part of unsuper-vised learning process for understanding recipes. Cooking knowledge is also closely related to script knowledge, but most prior work focus on newswire and children X  X  books rather than proce-dural language (Fujiki et al., 2003; Chambers and Jurafsky, 2009; Pichotta and Mooney, 2014; Bala-subramanian et al., 2013) or rely on crowdsourced descriptions to learn procedural knowledge (Reg-neri et al., 2010; Regneri et al., 2011; Frermann et al., 2014). There is work on related, but dis-tinct, tasks that use recipes, including identifying actionable refinements from online recipe reviews (Druck and Pang, 2012) and extracting structured information from ingredient lists (Greene, 2015)
Cooking recipes have also been studied in the context of grounded language learning, e.g., to build robots that can cook (e.g., Bollini et al., 2013, Beetz et al., 2011), or to align cooking videos to natural language descriptions of actions (Regneri et al., 2013) or recipe texts (Malmaud et al., 2014; Malmaud et al., 2015). Our work com-plements these efforts by recovering fine-grained procedural semantics from text alone.

Finally, detection and resolution of implicit ar-guments is an instance of zero anaphora detec-tion and resolution (Silberer and Anette, 2012, Tetreault 2002, Whittemore et al., 1991, Palmer et al., 1986). We present an empirical approach for understanding these phenomena in instructions. We presented unsupervised methods for segment-ing and identifying latent connections among ac-tions in recipe text. Our model outperformed a strong linear baseline, while learning a variety of domain knowledge, such as verb signatures and probable ingredient components for different com-posites. Future work includes learning a more comprehensive model of locations (e.g., identify-ing nested locations such as an oven and a pan in the oven), enriching action graphs with greater se-mantic coverage (e.g., durations, tools, amounts), and training and evaluating on larger datasets. We also plan to use our techniques to support related tasks, such as instructional recipe generation. We thank the anonymous reviewers, Mike Lewis, Dan Weld, Yoav Artzi, Antoine Bosselut, Kenton Lee, Luheng He, Mark Yatskar, and Gagan Bansal for helpful comments, and Polina Kuznetsova for the preliminary work. This research was sup-ported in part by the Intel Science and Technol-ogy Center for Pervasive Computing (ISTC-PC) and the NSF (IIS-1252835 and IIS-1524371).
