 XML query languages typically allow the specification of structural patterns of elements. Finding the occurrences of such patterns in an XML tree is the key operation in XML query processing. Many algorithms have been presented for this operation. These algorithms focus mainly on the evalu-ation of path-pattern or tree-pattern queries. In this paper, we define a partial path-pattern query language, and we ad-dress the problem of its efficient evaluation on XML data.
In order to process partial path-pattern queries, we intro-duce a set of sound and complete inference rules to charac-terize structural relationship derivation. We provide neces-sary and sufficient conditions for detecting query unsatisfi-ability and node redundancy. We show how partial path-pattern queries can be equivalently put in a canonical di-rected acyclic graph form. We developed two stack-based algorithms for the evaluation of partial path-pattern queries, PartialMJ and PartialPathStack . PartialMJ computes answers to the query by merge-joining the results of the root-to-leaf paths of a spanning tree of the query. Partial-PathStack exploits a topological order of the nodes of the query graph to match the query pattern as a whole to the XML tree. The experimental evaluation of our algorithms shows that PartialPathStack is independent of intermedi-ate results and largely outperforms PartialMJ .
 H.2.3 [ Database Management ]: Languages X  Query lan-guages ; H.2.4 [ Database Management ]: Systems X  Query processing Algorithms, Languages, Experimentation The author is partially supported by the Alexander S. Onassis Public Benefit Foundation scholarship.
 tree-structured data, partial path-pattern query, query eval-uation
XML query languages typically allow the specification of structural patterns of elements. Finding the occurrences of such patterns in an XML tree is the key operation in XML query processing. Many algorithms have been presented for this operation. These algorithms focus mainly on the eval-uation of path-pattern or tree-pattern queries. A restrictive feature of these queries is that they determine a total order for the elements in every path of the query. For instance, the path query in XPath //year//author//title retrieves title nodes from a bibliographic XML document. In this query, node year can only be an ancestor of node author , and node author can only be an ancestor of node title .
However, the standard query language for XML, XQuery, and even its core language, XPath, allow for structural pat-terns that do not form a complete path or tree. Consider, for instance, the following XPath query that involves reverse axes: //title[descendant-or-self::*[ancestor-or-se-lf::year][ancestor-or-self::author]] . This query asks for title nodes in paths that also involve year and author nodes, but no specific order is required for those nodes in the path. In this sense, this is a path-pattern query where the structure of a path is partially specified in the pattern. Olteanu et al. [20, 19] show that XPath queries with reverse axes like the one shown above can be equivalently rewritten as a set of tree-pattern queries. However, they also show that this transformation may lead to an exponential blowup of the number of tree-pattern queries. Gottlob et al. [11] show that the combined complexity of XPath is P-hard.
Further, in practice, there is a need to query XML data when the structure is not fully known to the user, or to query XML data sources with different structures in an in-tegrated way [7, 12, 16, 21]. In order to deal with these prob-lems, query languages are adopted that relax the structure of a path in a tree pattern. An extreme case are keyword-based languages for XML [9, 7, 12, 16]. Clearly, these query languages need to be accompanied with efficient evaluation techniques.
 Partial path query language. In this paper, we define a query language that allows a partial specification of path patterns. Queries in this language do not require a total order for the nodes in the pattern. The language is general enough to encompass on the one side path-pattern queries and on the other side queries without structural relation-ships (nodes lying on the same path without order). This language can express different types of XPath expressions as, for instance, those mentioned above. It is also the con-stituent component of partial tree-pattern queries [21, 22]. The problem. We address the problem of efficiently eval-uating partial path-pattern queries. A partial path-pattern query can be expressed equivalently by a set of path-pattern queries. There are several algorithms for evaluating path-pattern queries. For instance, Bruno et al. [2] provide an algorithm which is asymptotically optimal for path-pattern queries without repetitions of the same node label in the pattern for the stream data model. However, as mentioned earlier, this equivalent set may contain a number of path pat-terns, which is exponential on the number of query nodes. Clearly, this drawback does not suggest for efficient evalua-tion techniques through the generation of an equivalent set of path patterns. Therefore, we focus on techniques that can directly process and match the partial path pattern to the XML data tree.
 Contribution. The main contributions of this paper are the following:  X  Because the structure of a path may not be fully specified in a partial path-pattern query, new structural expressions can be derived from those explicitly specified in the query.
These structural expressions are important in query pro-cessing. We define a sound and complete set of inference rules to fully characterize structural relationship deriva-tion.  X  Unlike path-pattern queries, partial path-pattern queries can be unsatisfiable. We provide necessary and sufficient conditions for detecting query unsatisfiability. Detecting unsatisfiable queries prevents accessing the data, which can be very large, at a small overhead.  X  Partial path-pattern queries can contain redundant nodes, i.e., nodes that can be removed without affecting the mean-ing of the query. We provide conditions for efficiently identifying redundant nodes. We show how partial path-pattern queries can be equivalently put in a canonical form, which is a directed acyclic graphs (dag). We exploit the canonical form of queries to design query evaluation algorithms.  X  We developed a stack-based algorithm PartialMJ for the evaluation of partial path-pattern queries. PartialMJ ex-tracts a spanning tree from the query dag. It uses an extension of algorithm PathStack [2] to compute the re-sults of the root-to-leaf paths of the spanning tree. These results are produced in root-to-leaf order in the XML tree and are merge-joined to compute the answer of the query.
PartialMJ may generate intermediate results for the root-to-leaf paths of the spanning tree that cannot contribute to the answer of the query.  X  To overcome the intermediate result problem, we devel-oped a novel holistic stack-based algorithm PartialPath-Stack for the evaluation of partial path-pattern queries.
PartialPathStack exploits a topological order of the nodes in the query dag, and matches the query dag as a whole to the XML tree. We analyze the complexity of Par-tialPathStack , and we show that it is independent of intermediate results.  X  We implemented both algorithms, and we performed an extensive experimental evaluation. The experimental re-sults confirm the dependence of PartialMJ on intermedi-ate results and the superiority of PartialPathStack . Paper outline. The next section discusses related work. Section 3 presents the XML data model and our language for partial path queries. Section 4 addresses query processing issues. In Section 5, we present our two algorithms. Section 6 shows the experimental results. We conclude and discuss future work in Section 7.
Previous papers focus on finding matches of binary struc-tural relationships (a.k.a. structural joins). In [25], the au-thors presented the Multi-Predicate Merge Join algorithm (MPMGJN) for finding such matches. Al-Khalifa et al. [1] introduced a family of stack-based join algorithms, which are more efficient compared to MPMGJN, as they do not require multiple traversals of the XML tree. Algorithms for structural join order optimization were introduced in [23]. Structural join techniques can be further improved using various types of indexes [6, 14, 24].

One can exploit the above techniques to evaluate a path-pattern query or a tree-pattern query. The task involves the following phases: decomposing the query into binary structural relationships, then, finding their matches, and, finally, stitching together these matches. This is inefficient due to the large number of intermediate results. To deal with this problem, Bruno et al. [2] presented two stack-based join algorithms ( PathStack and TwigStack ) for the evaluation of path-pattern queries and tree-pattern queries, respectively. PathStack is optimal for path-pattern queries, while TwigStack is optimal for tree-pattern queries without child relationships.
 Several researchers have worked on extending TwigStack . For example, in [17], algorithm TwigStackList evaluates ef-ficiently tree-pattern queries in the presence of child relation-ships. Also, in [4], algorithm Twig2Stack can evaluate gener-alized tree-pattern queries including optional relationships. Chen et al. [3] proposed algorithms that handle queries over dag-structured data. Evaluation methods of tree-pattern queries with OR predicates are developed in [13]. In [15], the XR-tree index [14] is used to avoid processing input that does not participate in the answer of the query. Finally, [10] introduces algorithm TwigOptimal , which applies the notion of virtual cursors [24] to enhance the traversal of the XML tree during tree-pattern query evaluation.

All the above tree-pattern query evaluation techniques as-sume that there are access mechanisms, i.e., indexes, that efficiently return a stream of nodes in the XML tree that satisfy a given node predicate. Nodes within streams are usually represented by their positional representation [25] (see Section 3.1). Other types of streaming, e.g., Tag+Level Streaming and Prefix-Path Streaming, are suggested in [5]. In [18], instead of the region encoding positional representa-tion, the authors used an extended Dewey labelling scheme to facilitate query evaluation.

Partially specified tree-pattern queries were introduced in [21, 22]. In these papers, partial tree-pattern queries are evaluated by generating a set of complete tree-pattern queries based on index graphs (structural summaries of data). Here, we focus on the evaluation of partial path-pattern queries. These queries are dags in their canonical form. To the best of our knowledge, no previous holistic algorithms exist for their evaluation.
In this section, we discuss about the XML data model and the region encoding positional representation technique, and we introduce the partial path query language.
An XML database is commonly modelled by a tree struc-ture. Tree nodes represent and are labelled by elements, at-tributes, or values. Tree edges represent element-subelement, element-attribute, and element-value relationships.
Without loss of generality, we assume that the root node of an XML tree represents an element labelled by r , and no other node is labelled by r . Such a root node can always be added to a tree if not initially there.

Figure 1 shows an XML tree. The triplets next to the nodes encode their position in the tree, and they are ex-plained below. Positional representation. XML query processing algo-rithms require an efficient technique for representing the po-sition of nodes in an XML tree. A commonly used technique is the so called region encoding [8, 25, 1, 2, 15], where tree nodes are represented by triplets of the form ( begin , end , level ).

The begin and end values of a node can be determined through a depth-first traversal of the XML tree, by sequen-tially assigning numbers to the first and the last visit of the node. The level value represents the level of the node in the XML tree. For simplicity, we assume that one XML tree is processed at a time. If the database comprises multiple trees, a fourth field, treeID , can be used to denote its XML tree in the database.

Region encoding simplifies checking structural relation-ships between two nodes: node n 1 is an ancestor of node n is the parent of node n 2 iff n 1 .begin &lt; n 2 .begin , n n .end , and n 1 .level = n 2 .level  X  1.
We now introduce the syntax and semantics of partial path queries.
 Syntax. A partial path query specifies a path pattern where the structure may not be fully defined.

Definition 3.1. Let a i denote a variable ranging over nodes in an XML tree labelled by a , a 6 = r . A structural relationship is an expression of the form r/a i , a i /a j a /b j ( child relationship), or of the form r//a i , a i //a a //b j ( descendant relationship). A partial path query is a nonempty set of structural relationships. 2
Figure 2 shows four partial path queries.
We can represent a query as a node-labelled graph. The nodes of the graph correspond to the variables of the query. There is a single (resp. double) arrow from node a i to node b iff the structural relationship a i /b j (resp. a i //b j to the query. Figure 3 shows the graph representation of the queries of Figure 2. Notice that a query graph can be disconnected, e.g. query q 4 in Figure 3(d). In the following, we identify queries with their graph representation.
The user can flexibly specify the structure of a path in a query fully, partially, or not at all.
 Semantics. The answer of a partial path query on an XML tree is a set of tuples. Each tuple consists of tree nodes that lie on the same path and preserve the child and descendant relationships of the query. More formally:
Definition 3.2. An embedding of a partial path query Q into an XML tree T is a mapping M from the nodes of Q to nodes of T such that: (a) any node a i in Q is mapped by M to a node of T labelled by a , and node r in Q is mapped by M to the root of T ; (b) the nodes of Q are mapped by M to nodes that lie on the same path in T ; (c)  X  a i /b j (resp. a //b j ) in Q , M ( b j ) is a child (resp. descendant) of M ( a in T . 2 We call image of Q under an embedding M , denoted M ( Q ), a tuple that comprises all the images of the nodes of Q under M .

Definition 3.3. The answer of Q on T is the set of the images of Q under all possible embeddings of Q to T . 2
Consider, for instance, query q 3 in Figure 3(c). The an-swer of q 3 on the XML tree of Figure 1 is: { X  a 1 :(5,18,2), c :(6,16,3), e 1 :(11, 11,5)  X  ,  X  c 1 :(6,16,3), a 1 :(10,12,4), e 11,5)  X  X  .

Notice that a query may include two distinct nodes a i and a , e.g., c 1 and c 2 in query q 4 in Figure 3(d). The images of two such nodes under an embedding may coincide unless this is prevented from the structural relationships of the query.
Query q 1 is the only partial path query in Figure 3 which is also a mere path query, since the structural relationships in the query induce a total order for the query nodes. Query q is syntactically similar to a tree-pattern query (twig). How-ever, the semantics is different: when query q 2 is a partial path query, the images of the query nodes a 1 and c 1 should lie on the same path on the XML tree.

A partial path query may contain more than one source node (i.e. a node without incoming edges). Since, by as-sumption, every XML tree is rooted at a node labelled by r , we can add a node r (if not already there) and double arrows to any source node of a query without altering its meaning. This way, every query can be represented as a rooted directed graph. Figure 4 shows the four queries of Figure 3 after this transformation.
As the structure of the path is partially specified in partial path queries, new structural relationships may be inferred from those explicitly specified in a query. Further, unlike path queries, partial path queries may be unsatisfiable and have redundant nodes. Derived structural relationships are necessary in detecting unsatisfiable queries and redundant nodes. In this section, we address these issues and we show how a query can be processed and put in a canonical form, which is convenient for evaluation.
Consider query q 0 4 in Figure 4. Since a 2 is a parent of c and an ancestor of a 3 , we can infer that c 2 is an ancestor of a 3 as well. Indeed, since c 2 is a child of a 2 , a 3 can not be placed between a 2 and c 2 . Next we formalize the inference of structural relationships.

Definition 4.1. A structural relationship p is derived from a query Q iff for every embedding M of Q to any XML tree, M satisfies p . The closure of Q is the set that comprises all the structural relationships that can be derived from Q . 2
In order to characterize the derivation of structural rela-tionships and compute closures of queries, we introduce a set of inference rules shown in Figure 5. Let a i and b j query nodes, and x , y , z , and w be variables ranging over query nodes. Recall that r denotes the root node of a query. We use the symbol ` to denote that the relationships that precede it infer the relationship that follows it. The absence of expressions that precede ` denotes an axiom.

The next theorem states that the inference rules correctly and completely characterize the derivation of structural re-lationships. Let Q be a query, and p be a structural relation-ship not in Q . A set of inference rules is sound if whenever (IR1) ` r//a i (IR2) x/y ` x//y (IR3) x//y, y//z ` x//z (IR4) x/a i , x//b j , ` a i //b j (IR5) a i /x, b j //x, ` b j //a i (IR6) x/y, y/w, x//z, z//w ` x/z (IR7) x/y, x//z, w/z, w//y ` x/z (IR8) x/y, y/w, x/z ` z/w (IR9) x//y, y//w, x/z ` z//w (IR10) x/y, x/z, w/z ` w/y (IR11) x//y, x/z, w//z ` w//y (IR12) x/y, y/w, z/w ` x/z (IR13) x//y, y//w, z/w ` x//z p can be produced from Q using the inference rules, p can also be derived from Q . It is complete if whenever p can be derived from Q , p appears in Q or can be produced from Q using the inference rules.

Theorem 4.1. The set of inference rules of Figure 5 is sound and complete. 2
Based on the closure of a query, we define the full form of a query.

Definition 4.2. A query is in full form if it is equal to its closure. 2
Clearly, the number of structural relationships in the clo-sure of a query is, in the worst case, a square polynomial in the number of its nodes. In practice, only a small per-centage of these relationships appears in the closure of the query. Since usually a query is much smaller than the data, the cost of computing its closure is insignificant.
Detecting an unsatisfiable query saves execution time at a small overhead. It prevents accessing the data to get an empty answer.

Definition 4.3. A partial path query is called satisfiable iff it has a non-empty answer on some XML tree. Otherwise, it is called unsatisfiable . 2
In contrast to path queries, partial path queries can be unsatisfiable. Consider, for instance, the query q 5 of Fig-ure 6(a). Clearly, this query is unsatisfiable since no XML tree path can satisfy all four structural relationships in it. The following proposition provides necessary and sufficient conditions for query satisfiability.

Theorem 4.2. A partial path query is unsatisfiable iff its full form comprises a trivial cycle, i.e. two structural relationships of the form a//b and b//a .

Consider the queries q 5 and q 6 of Figure 6. These queries are unsatisfiable. One can see that the full form of both queries comprises trivial cycles. For instance, they both comprise the trivial cycle r//a 1 and a 1 //r .

Checking query satisfiability amounts to checking the full form of the query for trivial cycles. This is in the worst case a square polynomial in the number of the query nodes. Given that the size of a query is not expected to be comparable to the size of the XML database, the cost of checking query satisfiability is insignificant.
Some nodes in a query can be removed without affecting the meaning of the query. We call these nodes redundant:
Definition 4.4. A node in a partial path query is redun-dant iff in any tuple of any answer of the query it has the same value as another (not necessarily the same) node of the query. 2
Redundant nodes can be detected based on the following theorem:
Theorem 4.3. A node w in a partial path query is re-dundant iff the full form of the query comprises one of the following sets of structural relationships: (a) x/w and x/y , where x and y are query nodes and w (b) w/x and y/x , where x and y are query nodes and w
Figures 7(a), 7(b), and 7(c) graphically display the three conditions of Theorem 4.3. Figure 7: Query patterns with redundant node w
Clearly, identifying redundant nodes in a query can be performed efficiently.
For query evaluation purposes, it is convenient to intro-duce a  X  X ormal form X  for queries called canonical form .
Definition 4.5. A partial path query Q is in canonical form iff its set P of structural relationships contains exactly all the structural relationships of the closure of P except those that can be inferred by P using inference rules IR2 and IR3. 2
Since a satisfiable query does not comprise cycles in its full form, it has a unique canonical form. This canonical form can be represented as a rooted directed acyclic graph. form. Figure 8(a) repeats query q 0 4 of Figure 3 and Figure 8(b) shows its canonical form.
Computing a canonical form for a query can be done ef-ficiently by removing from its full form edges in any order that can be inferred from other edges using IR2 or IR3, until no more edges can be removed.

In the following, we assume that queries are satisfiable, in canonical form, without redundant nodes. A notable feature of this representation is that there is a topological ordering of the nodes of a query that satisfies its structural relationships (both child and descendant). We exploit this feature in the next section in designing the PartialPathStack algorithm.
In this section, we present two stack-based algorithms for the evaluation of partial path queries: PartialMJ and Par-tialPathStack .
Let q be a partial path query in canonical form and n be a node in q . Function nodes( q ) returns all nodes of q . Func-tion isRoot( n ) returns true if n does not have incoming edges in q , and false otherwise. Function isSink( n ) returns true if n does not have outgoing edges in q , and false oth-erwise. Function parents( n ) returns all nodes in q with outgoing edges to n .
 Each query node n labelled by l is associated with a stream T n of all nodes (positional representation) labelled by l in the XML tree. To sequentially access the nodes in T n , we maintain a cursor C n , initially pointing to the first node in T . For simplicity, C n may alternatively refer to the node pointed by pointer C n in T n . Operation advance( C n ) moves C n to the next node in T n . Function eos( C n ) returns true if C n has reached the end of T n . C n .begin denotes the begin field in the positional representation of node C n (see Section 3.1).

A stack S n is associated with each query node n . In the case of algorithm PartialMJ , each entry of S n is a pair of a node from stream T n and a pointer to an entry in the stack of a parent of n in the query. In the case of algorithm Par-tialPathStack , each entry of S n is a pair of a node from stream T n and a set of pointers to entries in the stacks of all the parents of n in the query.

Function empty( S n ) returns true if stack S n is empty, and false otherwise. Operation push( S n , entry ) pushes entry on top of stack S n . Operation pop( S n ) pops the top entry from stack S n . Functions bottom( S n ) and top( S n ) return the position of the bottom and top entry in stack S n , respec-tively. At every point during the execution of the algorithms (a) each node in a stack entry is a descendant in the XML tree of all nodes in the entries below it, and (b) all nodes in a stack lie on the same root-to-leaf path in the XML tree.
Given a partial path query, algorithm PartialMJ extracts a spanning tree of the query graph. Then, it finds matches for all root-to-leaf paths of the spanning tree in the XML tree by using an extension of the path matching algorithm PathStack [2]. The results for each path of the spanning tree are tuples produced in a sorted root-to-leaf order in the XML tree. These tuples are merge-joined by guaranteing that (a) they lie on the same path in the XML tree, and (b) they satisfy the structural relationships that appear in the query graph and not in the spanning tree.

Figure 9(b) shows the graph of a query q and Figure 11(a) shows a spanning tree q s of q . Edge c//d of q is missing from q s . Any two results from the two root-to-leaf paths of q s that are on the same path of the XML tree can be merged to produce a result for q if they satisfy the identity conditions on r and a and the structural condition c//d (see Figure 11(b)).
Algorithm PartialMJ is shown in Figure 10. In this al-gorithm, each entry of a stack S n is a pair of (a) a node from stream T n and (b) a pointer ptr to the entry of its low-est ancestor in the XML tree appearing in S m , where m is the parent of n in the spanning tree of the query. Function isLeaf( n ) returns true if n is a leaf node in q s , and false otherwise.

In lines 01-08, the algorithm scans the streams, and finds matches for the root-to-leaf paths in the spanning tree of the query. Line 02 determines the next query node n to be processed. Line 03 pops out of the stacks all nodes that do not lie on the same root-to-leaf path in the XML tree as the stream node C n currently processed. Stream node C n is pushed on stack S n only if the stacks of the parents of node n in the query are not empty (lines 04-05). This way, we avoid stacking and processing stream nodes which do not contribute results to the answer. When we push a node C n on stack S n , we also add a pointer to the top entry in stack S m , where m is the parent of n in the spanning tree of the query. Line 06 checks if node n is a leaf in the spanning tree. If this is the case, line 07 calls procedure showRe-sultsWithBlocking to produce the results for the path of q : partial path query q s : a spanning tree of q E : the set of edges in q which do not appear in q s
Algorithm PartialMJ() 01 while (  X  end()) 02 n = getNextQueryNode() 03 cleanStacks( C n ) 04 if (isRoot( n ) or  X  m  X  parents( n ):  X  empty( S m )) 05 moveToStack( n ) 06 if (isLeaf( n )) 07 showResultsWithBlocking( S n , top( S n )) 08 advance( C n ) 09 joinPathSolutions()
Function end()
Function getNextQueryNode()
Procedure cleanStacks( C n ) 01 for m in nodes( q ) 02 pop all entries in S m whose nodes are not
Procedure moveToStack( n ) 01 ptr = pointer to top of S m , where m is 02 push( S n , ( C n , ptr ))
Procedure joinPathResults() 01 order the root-to-leaf paths of q s in descending order 02 merge-join the results of the root-to-leaf paths of q s the spanning tree ending to node n . These results must be sorted in a root-to-leaf order in the XML tree so that they can be easily merge-joined to compute results for the query. For this reason, procedure showResultsWithBlock-ing uses a blocking technique to produce results for a path, similar to procedure showSolutionsWithBlocking [2]. The results for all paths of the spanning tree are merge-joined in line 09. This join involves checking that (a) the results are on the same path in the XML tree, (b) matchings for the common nodes of the paths in the query are identical, and (c) structural relationships in the query that do not appear in the spanning tree are satisfied. All these conditions can be checked in a straightforward way using the positional representation for the nodes in the XML tree.

Figure 11(c) shows the state of the stacks after the evalu-ation of query q of Figure 9(b) on the single-path XML tree of Figure 9(a). Figure 11(a) shows the spanning tree q s of q used in the evaluation of q . Since the structural relationship c//d of q does not appear in q s , there are no pointers from stack S d to stack S c . The results for the left root-to-leaf path from the four possible pairs of results of the two paths only two can be merge-joined, and are shown in Figure 11(d). Child relationships. The algorithm presented in Figure 10 is designed for the evaluation of queries that do not include child relationships. In the presence of child relationships, two changes need to be done. First, whenever a node C b from stream T b is processed, and a/b is a child relationship in the query, C b is pushed on stack S b only if its parent node in the XML tree appears in (the top position of) stack S . Second, in the computation of the results of a root-to-leaf path of the spanning tree of the query (using procedure showResults ), a node in stack S b appears only in results for this path that also include from S a its parent in the XML tree.
 Analysis of PartialMJ. Algorithm PartialMJ fills the stacks in a single pass of the input streams. Further, it uses procedure showResults to produce results for every root-to-leaf path in the spanning tree of the query. This procedure is shown to be asymptotically optimal for the evaluation of path queries [2]. However, there may be combinations of results from the root-to-leaf paths in the spanning tree that cannot be merged to form a result of the query. We call these combinations intermediate results . Because of the interme-diate results, the algorithm is not asymptotically optimal. Clearly, if the query is a path-pattern query, algorithm Par-tialMJ is asymptotically optimal.
To overcome the problem of intermediate results of Par-tialMJ , we developed a novel holistic stack-based algorithm for the evaluation of partial path queries. In contrast to PartialMJ , PartialPathStack does not decompose a query into paths, but tries to match the query graph to an XML tree as a whole.

The key feature of algorithm PartialPathStack is that it employs a topological order of the query nodes, i.e., a linear ordering of nodes which respects the partial order induced by the structural relationships of the query. Algorithm Pa-rtialPathStack is shown in Figure 12.

Algorithm PartialPathStack manages streams and stacks as PartialMJ . The only difference is that, in the case of Par-tialPathStack , each entry in a stack S n is a pair of a node from stream T n and a set of pointers to entries in the stacks of all the parents of n in the query.

Whenever a stream node C n of a query sink node n is pushed on a stack, the algorithm checks whether results can be generated. Output is produced in a reverse topological order, so that the stack of a query node is processed af-ter the stacks of its children nodes in the query have been processed. To avoid redundantly reproducing results, the algorithm outputs at this point only results that include the stream node C n . Procedure outputResults combines nodes from all stacks to produce the query results. No other node from the stack S n of node n is used at this point to produce new results for the query (lines 07-08). In contrast, all nodes from the other sink node stacks can be used to form results (lines 09-11). All the nodes can be used from non-sink node stacks if they (or nodes higher in the stack) are pointed by q : partial path query with N nodes
Algorithm PartialPathStack() 01 extract a topological order 1.. N of the query nodes 02 while (  X  end()) 03 n = getNextQueryNode() 04 cleanStacks( C n ) 05 if (isRoot( n ) or  X  m  X  parents( n ):  X  empty( S m )) 06 moveToStack( n ) 07 if (isSink( n ) and  X  m  X  nodes( q ): 08 if ( n == N ) 09 outputResults( n , N , top( S N )) 10 else 11 for i = bottom( S N ) to top( S N ) 12 outputResults( n , N , i ) 13 advance( C n )
Procedure moveToStack( n ) 01 ptrs = pointers to top of all parents( n ) in q 02 push( S n , ( C n , ptrs ))
Procedure outputResults( n , m , stackPos ) 01 solution[ m ] = stackPos 02 if ( m = 1) //node m is the root of the query 03 output ( S 1 [solution[1]],..., S N [solution[ N ]]) 04 else 05 if ( m  X  1 == n ) 06 outputResults( n , n , top( S n )) 07 else if (isSink( m  X  1)) 08 for i = bottom( S m  X  1 ) to top( S m  X  1 ) 09 outputResults( n , m  X  1, i ) 10 else 11 for c in children( m  X  1) 12 ptrFrom[ c ] = S c [solution[ c ]]. ptrs [ m  X  1] 14 for i = bottom( S m  X  1 ) to maxPos 15 outputResults( n , m  X  1, i ) nodes in the stacks of all the children of n in the query (lines 12-15).

Figure 13(b) shows the state of the stacks after the evalu-ation of query q of Figure 9(b) on the single-path XML tree of Figure 9(a). When node d 1 is pushed on stack S d , new re-sults can be produced that include d 1 , which are produced according to the topological order shown in Figure 13(a). The results of the query are shown in Figure 13(c).
To process queries with child relationships, we need to modify the stacking of the nodes and the output of solutions as we did with PartialMJ . (a) Topological order Analysis of PartialPathStack. Here, we show the cor-rectness and completeness of PartialPathStack and discuss on its complexity. Proofs are omitted due to lack of space. They will be included in the full version of the paper.
Theorem 5.1. Given a partial path query q and an XML tree T , algorithm PartialPathStack correctly returns all the results of q on T . 2
Let input denote the sum of sizes of the input streams, output denote the size of the results of q on T , indegree denote the maximum number of incoming edges to a query node, outdegree denote the maximum number of outgoing edges from a query node, and maxpath denote the maximum length of a root-to-leaf path in T .

Theorem 5.2. Algorithm PartialPathStack has worst-case I/O and CPU time complexities O( indegree * input + outdegree * output ). The worst-case space complexity of PartialPathStack is O( indegree * min( input , maxpath )).
Based on the previous theorem, PartialPathStack is a-symptotically optimal if the indegree and outdegree of the query are bound by a constant. Clearly, for the case of queries whose graph is a tree, only the outdegree needs to be bound by a constant. In any case, PartialPathStack does not generate any intermediate results.
We ran a comprehensive set of experiments to measure the performance of PartialMJ and PartialPathStack . In this section, we report on their experimental evaluation. Setup. We evaluated the performance of the algorithms on both benchmark and synthetic data. For benchmark data, we used the Treebank XML document 1 . Treebank X  X  XML tree consists of around 2 . 5 million nodes having 250 distinct http://www.cis.upenn.edu/ treebank element tags and its maximum depth is 36. It also has deep recursive data. Synthetic data is random XML trees. We generated such trees using IBM X  X  AlphaWorks XML gener-ator 2 . In all the experiments, the parameter MaxRepeats (that determines the maximum number a node appears as a child of its parent node) was set to 4, and the parameter numLevels (that determines the maximum number of tree levels) was set to 14. The number of distinct element tags used in all trees was fixed to 11. For each measurement on synthetic data, 10 different XML trees of the same number of nodes were used. Each displayed value in the plots is the average over these 10 measurements.

Figure 14 shows the types of queries used in our experi-ments. Queries Q 1 to Q 4 include only descendant relation-ships, while queries Q 5 to Q 8 include child relationships as well. The labels of the query nodes, however, are appropri-ately modified so that the queries can always produce results in the different XML trees used in the experiments. Our query set comprises a full spectrum of partial path queries, from path-pattern queries to non-tree graph queries.
We implemented all algorithms in C++, and ran our ex-periments on a dedicated Linux PC (AMD Sempron 2600+ ) with 2 GB of RAM. (a) Q 1 ( Q 5 ) Figure 14: Types of partial path queries used in the experiments.
 Execution time on fixed datasets. We measured the ex-ecution time of PartialMJ and PartialPathStack for eval-uating all queries in Figure 15 on both Treebank and syn-thetic data. For queries Q 1 and Q 5 , which are path-pattern queries, we also measured the execution time of algorithm PathStack [2]. The synthetic XML trees used in this exper-iment consist of 2 . 5 million nodes.
 Figures 15(a) and 15(b) present the evaluation results. Figure 15(c) shows the number of results obtained per query. PartialPathStack is more efficient than PartialMJ .
Regarding queries Q 1 and Q 5 , PartialPathStack per-forms as fast as PathStack . This is expected, since Parti-alPathStack reduces to PathStack in case of path-pattern queries.
 Execution time varying the input size. We measured the execution time of PartialMJ and PartialPathStack for www.alphaworks.ibm.com/tech/xmlgenerator evaluating queries Q 2 , Q 3 and Q 7 of Figure 14 over synthetic XML trees of various sizes. Figures 16, 17 and 18 present the results obtained for XML trees whose node stream sizes vary from 1 to 3 million nodes. Clearly, in every case, Par-tialPathStack is more efficient than PartialMJ .

In the experimental evaluation of query Q 2 , an increase in the input size results in an increase in the output size (Figure 16(b)). When the input and the output size goes up, the ex-ecution time of PartialMJ and PartialPathStack increases (Figure 16(a)). This confirms the complexity results that show dependency of the execution time on the input and output size. However, the increase in the execution time of PartialMJ is slightly sharper than that of PartialPath-Stack . The reason is that PartialMJ is also affected by the increase in the number of the intermediate results shown in Figure 16(c). In contrast, PartialPathStack is independent of the size of the intermediate results.

In the experimental evaluation of query Q 3 , the output size (Figure 17(b)) is comparable to the output size of query Q 2 (Figure 16(b)). The execution time of PartialPath-Stack for the evaluation of Q 3 (Figure 17(a)) is comparable to the execution time for the evaluation of Q 2 (Figure 16(a)). This again confirms the worst-case complexity results. The number of intermediate results in Q 3 (Figure 17(c)) is larger than the number of intermediate results in Q 2 (Figure 16(c)) for all input sizes used in the experiments. This increase is reflected in the execution time of PartialMJ which increases sharper than PartialPathStack .

Query Q 7 used in the experiment shown in Figure 18 is more restrictive than query Q 3 since it involves two child relationships not present in Q 3 . Clearly, the number of in-termediate results (Figure 18(c)) and the output size (Figure 18(b)) from the evaluation of Q 7 is less than those of Q and the same holds for the execution time of both algorithms (Figure 18(a)). The reduction is more intense for PartialMJ due to the strong decrease in the number of intermediate re-sults. In all cases, PartialPathStack largely outperforms PartialMJ .
We defined a partial path-pattern query language which represents a class of XPath expressions, and is useful for querying multiple XML data sources with unknown or dif-ferent structures. We studied the problem of efficiently eval-uating partial path-pattern queries. In order to process par-tial path-pattern queries, we introduced a set of sound and complete inference rules to characterize structural relation-ship derivation, we provided necessary and sufficient con-ditions for detecting query unsatisfiability and node redun-dancy, and we showed partial path-pattern queries can be equivalently put in a canonical dag form. We developed two stack-based algorithms for the evaluation of partial path-pattern queries, PartialMJ and PartialPathStack . Parti-alMJ evaluates a query dag by decomposing it while Parti-alPathStack is a holistic one. An analysis and experimental evaluation showed that PartialPathStack is independent of intermediate results and largely outperforms PartialMJ . We plan to extend out work, studying partial tree-pattern queries and developing techniques for their evaluation. [1] S. Al-Khalifa, H. Jagadish, N. Koudas, J. M. Patel, [2] N. Bruno, N. Koudas, and D. Srivastava. Holistic twig [3] L. Chen, A. Gupta, and M. E. Kurul. Stack-based [4] S. Chen, H.-G. Li, J. Tatemura, W.-P. Hsiung, [5] T. Chen, J. Lu, and T. W. Ling. On boosting holism [6] S.-Y. Chien, Z. Vagena, D. Zhang, V. J. Tsotras, and [7] S. Cohen, J. Mamou, Y. Kanza, and Y. Sagiv.
 [8] M. P. Consens and T. Milo. Algebras for querying text [9] D. Florescu, D. Kossmann, and I. Manolescu.
 [10] M. Fontoura, V. Josifovski, E. Shekita, and B. Yang. [11] G. Gottlob, C. Koch, and R. Pichler. The complexity [12] V. Hristidis, Y. Papakonstantinou, and A. Balmin. [13] H. Jiang, H. Lu, and W. Wang. Efficient processing of [14] H. Jiang, H. Lu, W. Wang, and B. C. Ooi. Xr-tree: [15] H. Jiang, W. Wang, H. Lu, and J. X. Yu. Holistic twig [16] Y. Li, C. Yu, and H. V. Jagadish. Schema-Free [17] J. Lu, T. Chen, and T. W. Ling. Efficient processing [18] J. Lu, T. W. Ling, C.-Y. Chan, and T. Chen. From [19] D. Olteanu. Forward node-selecting queries over trees. [20] D. Olteanu, H. Meuss, T. Furche, and F. Bry. Xpath: [21] D. Theodoratos, T. Dalamagas, A. Koufopoulos, and 2 , varying the size of the XML tree. 3 , varying the size of the XML tree. 7 , varying the size of the XML tree. [22] D. Theodoratos, S. Souldatos, T. Dalamagas, [23] Y. Wu, J. M. Patel, and H. V. Jagadish. Structural [24] B. Yang, M. Fontoura, E. Shekita, S. Rajagopalan, [25] C. Zhang, J. F. Naughton, D. J. DeWitt, Q. Luo, and
