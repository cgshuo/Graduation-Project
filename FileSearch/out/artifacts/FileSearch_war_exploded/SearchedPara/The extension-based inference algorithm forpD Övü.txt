 1. Introduction  X  an explicit specification of a conceptualization.  X  complexity.
 approximately 395 million RDF links.
 (see Section 2 , for if/iff semantics see [8] ).
 ing too much expressive power.
 reasoning. In Section 3 , we focus on our modified knowledge representation formalism, techniques. Finally, we offer our conclusions and future directions in Section 9 . 2. Background knowledge follows:  X  resistant to change compared to extensional knowledge of the ABox.  X  frequent changes [5] .
 Appendix A .
 strategies into two groups, as follows:  X  which reuse existing DL algorithms, such as tableaux-based algorithms [12] .  X  implicit knowledge.
 programs.

De fi nition 1. An entailment rule for an ontology graph G is of the form, where n  X  1, m  X  1, s i , s  X  i , p i and p  X  i are RDF URI references or blank nodes, and o entailment).

There are two types of rule-based reasoning algorithms, which are defined in [18] , as follows:  X  and computes the inferred closure of a KB. The advantages (+) and the disadvantages ( below: + Query performance is relatively better, because no reasoning is required at the time of query answering.  X  The inference process requires considerable additional space (RAM, disk, or both).  X  for free variables), using deductive reasoning.
 be efficient in many contexts [18] .
 ditions  X  , and extends RDFS with datatypes and a property-related fragment of OWL (see Appendix B ). [25] and Sesame, manage different types of triples using different tables. reasoning engines need to only process the knowledge bases of the relevant modules (e.g., [26] ). 3. Extension-based knowledge model 3.1. Extension-based knowledge model constructs tension or denotation of the concept . In this model, we define four types of grouping constructs: individuals) of the class. A class extension is related to each of its members via a constitutes the individuals, which belong to the subclasses of the class.
Fig. 1 shows three classes and their explicit extensions. C
E 2 holds the explicit individuals of C 2 , and E 3 holds the explicit individuals of C relations between C 1 and E 1 , C 2 and E 2 , and C 3 and E extensions E 2 and E 3 are inferred from hasExplicitClassExtension relations. hasSubjectExtension / hasObjectExtension relates every property (except subject/object extensions constitutes the individuals, which belong to the subproperties of the property.
Fig. 2 shows three properties and their explicit extensions. P individuals of P 1 . S 2 holds the subjects of explicit individuals of P ilarly, O 1 holds the objects of explicit individuals of P and S 1 / O 1 , P 2 and S 2 / O 2 , and P 3 and S 3 / O 3 tween property P 1 and extensions S 2 / O 2 and S 3 / O 3 relations. hasPropertyExtension relates every property (except  X  type crease in the triple count, after transformation. 3.2. Extension-based knowledge model transformation algorithm transformation and does not change the semantics of the ontology language.
Algorithm 1. The transformation algorithm. for each triple (spo) in ontology { } 3.3. Extension-based knowledge model database schema in Section 4.2.3 . 4. Extension-based reasoning and querying backward chaining (via a query rewriting mechanism, which will be described in Section 4.3 ). 4.1. Extension-based knowledge model entailment rules additional rules that involve relationships between concepts and their extensions. 4.1.1. pD* Entailment rules pD* Semantics extends the  X  if-semantics  X  of RDFS to a subset of the OWL vocabulary. guideline to transform pD* entailment rules into their equivalents in the extension-based knowledge model. Fig. 4 shows rule patterns ( P1 through P9 ) that are used to classify pD* entailment rules.
A pattern is the conjunction of the following statements ( s condition of R , subj c is the subject of c , pred c is the predicate of c , obj right-hand-side of R , Cond ABox is the set of all possible conditions involving ABox, and Cond involving TBox:  X 
S :  X  c  X  lhs R (c  X  Cond TBox : all conditions in the LHS (left hand-side) of the rule involve TBox.  X 
S :  X  c 1  X  lhs R ( pred c  X 
S :  X  c  X  lhs R (c  X  Cond ABox ): all conditions in the LHS of the rule involve ABox.  X 
S :  X  c 1  X  lhs R (c 1  X  Cond ABox  X  pred c the rule.  X 
S :  X  c  X  rhs R ( pred c = rdf : type ): the condition on the RHS (right hand-side) of the rule has  X  s :  X  c 1  X  lhs R ( pred c tion involving property restrictions in the LHS of the rule.  X  s 7 :  X  c 1  X  lhs R ( obj c 1 = owl : TransitiveProperty  X  obj
InverseFunctionalProperty  X  pred c of the rule.
 ward chaining process ( F t means that the rule is transformed, during expanding the extensions ( E ); or during the query answering process ( in Tables 3 and 4 .
 each superclass of c . Let n I be the number of individuals of c , and let s formation, n I  X  s c (the number of  X  type  X  relations derived by the rule rdfs9 ) is reduced to s erty p and each superproperty of p . Let n t be the number of individuals of p , and let s after rule transformation, n t  X  s p (the number of relations derived by the rule rdfs7x ) is reduced to s main/range class of p . Let n t be the number of individuals of p , and let s of the set containing the subjects of individuals of property p and let n individuals of property p ; then, after rule transformation, n tension to the Resource class). that each ontology resource having a class extension is a subclass of the Resource class. are, without any transformation.
 reasoning process as they are, without any transformation.
  X  resource x has a class/property extension and x is related to another resource y with preserve the completeness and the soundness of the reasoning.
 rules matching P6, which are executed in the phase of query answering . Property and its property extension.
 of t extension.

The p entailment rules rdfp8ax and rdfp8bx derive that if a property p erty p 2 is derived by switching the subject and the object of every individual of p rdfp8ax-I , rdfp8ax-II , rdfp8bx-I and rdfp8bx-II . This new rule set:  X 
Links the property extensions of p 1 to property p 2 with hasInversePropertyExtension , and vice versa.  X 
Links the inverse property extensions of p 1 to property p 4.1.2. Additional rules pD* rules and the rewritten queries in the query answering process (see Section 4.3 ). 4.2. Reasoning process 4.2.1. Filtering triples remains fixed even if the size of the instance data increases. 4.2.2. Applying the forward-chaining algorithm are inferred. 4.2.3. Processing the extensions steps:  X 
Step-I: storing data about property restrictions and set operators on class extensions,  X  Step-II: storing data about property characteristics.

ClassExtensions tables. These tables are defined as follows:  X  which the range of property is constrained ( classOrValueUri ).  X  the operator ( setOperator ) and the classes to which the set operator is applied ( listOfClasses) .  X  sion ( extensionType ), whose value may be either  X  extensionWithPropertyRestriction whose values are determined according to the characteristics of the property. 4.2.4. Expanding the extensions the query answering process . In this phase, we compute this data in the following three steps:  X 
Step-I: expanding related extensions with inferred instance data relying on the owl:hasValue restriction,  X  characteristics,  X  Step-III: deriving sameAs relations relying on Functional and InverseFunctional properties. well as to the subject and object extensions of the related properties. ing them on each extension separately. Assume that p is a transitive property having extensions e hand, if we apply the transitivity characteristic on the union of these extensions ( e ( cpe ) is derived.
 p , p 3 , p 4 and p 5 ,withextensions e 1 , e 2 , e 3 , e 4 applying the property characteristics. Let S be a triple set, p be a transitive property, t the object of t 1 be the subject of t 2 . Then, for each t object of t 2 . Let S be a triple set, p be a symmetric property and t new triple to S by switching the subject and the object of t pairs in its individual1 and individual2 fields. 4.3. Query answering process three kinds of nodes:  X  tions involve the common variables of these conditions.  X  Resource Nodes : each resource node ( r ) contains a query component ( nodes are classified into three node groups according to their query components: extensions in an memory of a property node belong to named properties.
If there are other individuals that are related to the individual via an are also stored in the memory .  X 
Connector Nodes : for each anonymous class extension in a complex class node ( to the OWL construct that is used to identify the corresponding anonymous class ( Value nodes .

For each class, property, individual or value, which is referred to in the definition of node is added to the children of the connector node.
 subsections.
 4.3.1. Initial phase created and added to the children of the root node in the following way:  X  the results of the following query: hasClassExtension ( C ,?  X 
For each query condition with a predicate other than  X  type is filled with the results of the following queries:  X  hasPropertyExtension ( ?p,?  X  ): the relation between the property and the ?  X  hasInversePropertyExtension ( ?p,?  X  ): the relation between the property and the ? 4.3.2. Growth phase anonymous class extension (  X  ) in the memory , a connector node is added to the children of sions table.
 added  X  node by removing all anonymous class extensions in the memory of this node. 4.3.3. Final phase nodes are class or property nodes, which are computed by the following methods:  X  If the node is a basic class node (  X  C ), then the  X  (  X  unifies the results. Each basic class extension (  X  basic  X   X 
Q
Q  X  basic class extensions in the memory (using Q  X  puted using the corresponding SQL query ( S 1 )in Table 7 .If S nodes, these nodes are computed using Q  X  corresponding SQL query ( S 2 )in Table 7 is created and nested in query S is no complex class node to compute. 5. Running example known LUBM (Lehigh University Benchmark) [27] ontology schema.
 class/property individuals.
 5.1. Transforming an example ontology into the extension-based ontology model number of contains relations to be added is reduced by n  X  then the number of contains relations to be added is reduced by n 5.2. Filtering triples of the example ontology and the forward chaining process
Filtering triples of the example ontology prevents instance data from participating in reasoning. Let class individuals, 28 property individuals). After applying the model, only triples of ontology schema ( the inferred triples are reduced by 84.5 % . 5.3. Processing the extensions in the example in the corresponding database tables, as shown in Tables 10 sions and the classes, whose definition refers to these anonymous classes. 5.4. Expanding the extensions in the example 5.5. Example queries added to the root node about the constraints and relations between query conditions.  X  ,
In the growth phase, the children of the anonymous class extensions in the memory of the node ( the query tree. The first anonymous class extension is  X   X 
Person  X  {  X  headOf Department }. Fig. 7 shows the query tree after expanding the children of The children of the connector node  X   X  contain the class node node ( Fig. 8 ).
 children of  X  Person with the results of the basic class extensions in the memory of
Q 1 (SQL 1), Q 2 (SQL 2), Q 3 (SQL 3), and Q 4 (SQL 4) compute the complex class extensions involves the computation of a connector node  X   X  . One of the children ( SQL query of this node is reduced to Q  X  tyExtension or a hasInversePropertyExtension predicate.

Example Query 2 is as follows:(? X type Chair )  X  (? Y type Department ) University0.edu  X  ).
 The root node has four children nodes, including two class ( is given in SQL 5. Query S-Ex1 is given in the previous example and is also not repeated here. 6. Complexity analysis
We use the RETE algorithm to implement our forward chaining inference. RETE takes O ( n chaining rules [28] . The total time for a forward chaining inference is O ( n number of states and f i is the newly available data items in each state in the composition schema. participating in reasoning and the number of facts inferred in each cycle. Let O be an ontology, n O  X  X  be the number of triples, R type all of the properties except for the type property; then, to two new relations to the ontology ( contains ( S E A ; U ), contains ( other than type ( R P O ) is tripled (3 R P O ) in the transformed ontology. Let namely n O  X  X  , is the number of facts in the ontology (see Algorithm 1).
Let O  X  be the transformed version of ontology O and let  X  difference between n O  X  X  and n O  X  ; then, the ontology and contain the relations between concepts and their extensions ( ward chaining before applying the extension-based inference algorithm: be negligible. The number of these additional facts ( n ( f inferred subclass relations, n ( f subpropertyOf ) is the number of inferred subproperty relations, n ( f of symmetric properties, n ( f transitiveProperties ) is the number of transitive properties, and n ( f ties that are the subject or object of the  X  owl:inverseOf creases. The utility of the approach increases with increasing amounts of instance data. 7. Evaluation gine is a version of the standard inference engine, which applies the extension-based inference algorithm. ipating in the inference (  X  tpi ), the number of inferred triples ( number of triples participating in the inference (  X  tpi ), the number of inferred triples ( 7.1. Experiment 1 if the size of the instance data increases. The utilization rate for the loading time
Fig. 12 (a) shows the number of triples loaded per second ( of  X 
Table 16 shows the effect of the algorithm on the performances of 14 LUBM queries ( Q1 7.2. Experiment 2 university do not have relations with individuals from other universities. parallel with the results of Experiment 1 ( Tables 17, 18 , Figs. 13 longer in comparison to a LUBM dataset of the same size. 7.3. Experiment 3 number of inferred triples.

For example, increasing the data set by 60 times results in an increase in the utility by 1000 times. 7.4. Experiment 4 reduced with further optimizations (see Section 9 ).
 engine is slower but scales better for larger data sets. 8. Comparison with other approaches ing example shows the difference between two approaches with an instance retrieval query: tion for why [35] provides no results from evaluation with the original UOBM queries. and the query answers are incomplete.
 type relations. Therefore, the space consumption of ABox reasoning is reduced dramatically. can be performed on the system.
 able to perform inference based on universal restrictions and cardinalities ( Table 22 ) [37] . formance tests using LUBM and UOBM benchmarks.
 extension-based inference algorithm are both in-memory and in-database reasoners. 9. Conclusions and future work knowledge model reduces the complexity (number of constraints) of the queries. future work would be to integrate  X  vertical partitioning ing to improve the query performances significantly.
 (similar to the  X  node sharing  X  of the Rete algorithm [30] ).
 improving query performance further will be an interesting piece of future work. Acknowledgments and Technical Research Council of Turkey) under grant reference 3070489. Appendix A. OWL constructs
Property characteristics  X   X 
SymmetricProperty : if a property P is tagged as symmetric, then P ( x , y ) implies P ( y , x ).  X   X  inverseOf : if a property P 1 is tagged as the  X  owl:inverseOf  X 
Property restrictions  X  allValuesFrom, someValuesFrom : the  X  owl:allValuesFrom  X  this Wine class only. Makers of Cheese are not constrained by this local restriction. The case of
If we replaced  X  owl:allValuesFrom  X  with  X  owl:someValuesFrom hasMaker properties of a Wine must point to an individual that is a Winery .  X   X  member of such a class whenever at least one of its property values is equal to the hasValue resource.
Complex classes  X 
Set operators  X  equivalently, all elements of B that also belong to A ), but no other elements.  X   X   X  oneOf construct.  X 
Disjoint Classes : the disjointness of a set of classes can be expressed using the Appendix B. pD* Language puted in polynomial time.

The expressivity or complexity of pD* is between RDFS and OWL Lite. pD* Extends RDFS in two steps [18] :  X 
The D* (see Table 24 ) adds entailment support for literal data-types  X  directions (i.e., there is no full support for the iff-semantics of these OWL primitives). Appendix C. Test queries
References
