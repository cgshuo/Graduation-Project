 WS-BPEL [4], or simply BPEL, is the de facto standard for services composition based on the process technology. Individual web services are composed into BPEL processes. Today, orchestration of BPEL processes is typically carried out by central BPEL engines that are faced with scalability and reliability challenges. In view of these challenges, several research groups have proposed approaches to decentralized process orchestration. They are based on st atic definitions of processes for decentrali-zation: they either pre-allocate resources in the distributed environment, even for the parts that will not be executed [1-3], or involve central repositories for process man-agement tasks that cannot be properly planned in advance [7, 8]. 
Our approach is fully decentralized. It doe s not involve static process instantiation or a central repository. We further identify and address some consistency issues that are more challenging for decentralized or chestration. Our performance result shows high scalability of the approach [9]. In BPEL, processes and composite services are synonymous. A BPEL process con-sists of activities that are either basic or structured. Basic activities include activities for providing and invoking services, for assignments, etc. A service is provided through an invokable operation at a site with a receive activity. There are two types of invocations, a synchronous request-response invocation with an invoke activity and an asynchronous invocation with a send (an invoke without output parameter in the BPEL standard) and a receive ( callback) activity pair. A structured activity con-order in which the constituent activities are executed, such as in sequence ( se-quence) or in parallel ( flow) ; some allow selective execution of one of its constituent activities based either on the incoming message ( pick ) or on the outcome of a Boo-lean expression ( if-else ). Fig 1 shows an example process adapted from the purchase-order process in the BPEL standard specification [4]. The process consists of two parallel branches. 
The standard BEPL specification assumes a central engine at which the executions of the activities are conducted. The proce ss-aware data variables are shared by all activities in all branches. In Fig 1-a, the s_to_i link synchronizes two activities in the two branches so that send( i , sendShippingPrice) , the target activity of the link, cannot be executed before invoke( s ) , the source activity of the link. This assures that the shipping_price value sent to the asynchronously running getInvoice service is the one returned by the arrangeShipping service. 
Decentralized composition assumes no central engine. Activities are carried out at the involvement of a central engine. In Fig 1-b, the second branch sends ship-ping_price directly after the return of the arrangeShipping service. The synchroni-zation between the two branches is achieved by the message (rather than the link). Since the invoking branch (i.e., the first branch) does not interact with the getInvoice service, it does not have to invoke the service asynchronously. The getInvoice ser-vice now does not have to send a return message to the central engine. BPEL processes are block structured extended with synchronizations between parallel can be arbitrarily nested. 
We can represent a process as a directed graph where the nodes are blocks, and the directed edges are the order in which the blocks are executed. A block with constitu-ent blocks can either be represented unexpanded with a single node, or expanded with nodes for the constituent blocks. 
The graphical representation of a block must be structurally sound (also called node; every node is reachable from the start node; and the end node is reachable from every node. The execution of a process can generally be regarded as progressively marking the graph from the start node to the end node. A block for a selective struc-tured activity is undecided if a selection of a constituent activity has not been made. If undecided blocks are represented as unexpanded nodes, all nodes will be marked when the execution terminates. 
The graph of a process may change during the process execution. Fig 2 illustrates the changing structure of the example decentralized process. Fig 2-a is the process structure (fully expanded) at the start of an execution. In Fig 2-b, after the invocation of the external service getInvoice , the node for the invoke activity is replaced by the having been executed after the invocation). Notice that the synchronization between the two branches (dashed line) becomes visible only after the invocation. 
It is sometimes useful to graphically represent the remaining activities of a process executed block with parallel branches, we add a virtual start node preceding the first Fig 2-c is the continuation graph after th e synchronization message is delivered. The flow node is the virtual node of the partially executed block with two parallel branches. Traditionally, a message for services orchestration contains only a basic activity. Information like activity execution order is maintained at the central engine. With continuation passing messaging, information like activity execution order is carried in messages in terms of continuations. The service sites can interpret the messages and conduct the execution of services without consulting a central engine. More specifi-cally, a message contains a control activity, a continuation and an environment. The stack of activities that will be carried out after the control activity. This corresponds to the path from the current node to the end node in the continuation graph. The envi-ronment contains information of run-time status and process-aware data variables. Expressions can be evaluated within an environment. Fig 3 illustrates the messages for the orchestration of the example process starting at site p . The environment parts of messages are not shown in the figure. 
This basic messaging scheme is also extended with process management and re-covery support [9]. Process management is achieved through scope management. In a scope with multiple branches, the scope manager functions like the virtual start node in the continuation graph. An important property is that the current location of any branch can be obtained at its scope manager. Recovery support is achieved with a second continuation (called failure continuation ) that is automatically generated dur-ing message interpretation. We deal with two consistency issues for the orchestration of BPEL processes. Both are related with the dynamic nature of the process structure. Although none of the issues are specific to decentr alized process orchestration, they are more challenging when only partial information about a process is available at branches. 5.1 Consistent Activity Pairing When a message arrives at a site, it is possible that there is no matching receive ac-tivity awaiting. A na X ve way to handle this situation is to throw a  X  X ervice unavail-process. This could be inappropriate in some cases. In Fig 3, if message 6 arrives at site i before i reaches the corresponding receive activity, i should wait till the match-ing receive activity is in place. On the other hand, it is possible that a site is waiting for a message that will never be sent, because, for example, the other branch selects a constituent part other than the one containing the expected send activity. In this situa-tion, the site should throw an exception rather than waiting for ever. 
We refer to this issue as consistent pairings of activities for communication be-tween parallel branches. The BPEL standard requires that pairings are declared at flow activities in terms of links, so that they are visible by static analysis tools. How-ever, consistent activity pairing is a dynamic issue (due, for instance, to selective static analysis. The BPEL standard therefore further assumes that the established correlations should enable the central engine to handle this, though the specification does not mandate any specific form of handling. Activity pairing in a distributed set-ting is closely related to consistency issues in process choreography. [6] gives a con-sistency criteria for potentially successful interactions between partner processes. 
To facilitate dynamic support for consistent activity pairing, we register additional information in the environment parts of messages. This includes potential pairings visible at the start of multiple branches. When a site receives a message with a poten-tial pairing activity of that site, it waits for that pairing activity if it has not been avail-able yet. When a site executes a selective activity like pick and if-else and excludes a informs the corresponding branch (via the sc ope manager) to invalidate the registered exception. 5.2 Consistent Updates The BPEL standard allows concurrent update s of process-aware variables at different parallel branches. This may leave the values of variables non-deterministic. 
Deterministic variable values require consistent updates . Basically, if two parallel branches update the same variable, the updates must be synchronized with either a message or a link. Generally with multiple parallel branches, for every data variable, there is exactly one update path across the branches. 
This seemingly obvious requirement for consistent update of process-aware vari-ables has been surprisingly overlooked. The BPEL standard leaves this as an issue to be addressed at the application level. The closest related work seems to be ADEPT flex [5] where it states that  X  X ifferent branches are not allowed to have write access to the same data element, unless they are synchronized X . We do not know of any work on consistent update that takes into account the dynamic nature of process structuring during execution. 
To support consistent updates, we associate every variable with an update token and devise a mechanism that guarantees that, at any time, there is at most one branch update the variable. Our mechanism has the property that, in normal cases, tokens are passed around with orchestration messages and no extra communication for coordina-tion is needed. Our contributions presented in this paper ar e twofold. First, we present decentralized composition and orchestration of services with changing structures. It addresses the pre-allocate resources or involve central repos itories as in most of the existing decen-tralized approaches. The continuation-passing approach is novel for distributed com-puting. Second we identify and address some consistency issues that take into account the dynamic nature of process structures at run time. 
