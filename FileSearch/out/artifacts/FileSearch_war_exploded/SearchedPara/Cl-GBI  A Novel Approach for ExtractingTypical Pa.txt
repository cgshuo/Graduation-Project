 In recent years, discovering frequent patterns of graph-structured data, i.e., fre-quent subgraph mining or simply graph mining, has attracted much research interest because of its broad application areas such as bioinformatics [2, 12], cheminformatics [8, 10, 15], etc. Moreover, since these patterns can be used as input to other data mining tasks (e.g., clustering and classification [6]), the graph mining algorithms play an important role in further expanding the use of data mining techniques to graph-based datasets.
 FFSM [7], etc.) have been developed for the purpose of enumerating all frequent subgraphs of a graph database. However, the computation time increases ex-ponentially with input graph size and minimum support. This is because the kernel of frequent subgraph mining is subgraph isomorphism, which is known to be NP-complete [5].
 to find the complete set of frequent subgraphs, such as SUBDUE [4] and GBI (Graph-Based Induction) [16], tend to find an extremely small number of pat-terns. Both the two methods use greedy search to avoid high complexity of the subgraph isomorphism problem. GBI extracts typical patterns from graph-structured data by recursively chunking two adjoining nodes. Later an improved version called B-GBI (Beam-wise Graph-Based Induction) [12] adopting the beam search was proposed to increase the search space, thus extracting more discriminative patterns while keeping the computational complexity within a tolerant level.
 are extracted by GBI depends on which pairs are selected for chunking. There can be many patterns which are not extracted by GBI. B-GBI can help alleviate this problem, but cannot solve it completely because the chunking process is still involved.
 from graph-structured data, which does not employ the pair-wise chunking strat-egy. Instead, the most frequent pairs are regarded as new nodes and given new node labels in the subsequent steps but none of them is chunked. In other words, they are used as pseudo nodes, thus allowing extraction of overlapping subgraphs. This algorithm, now called Chunkingless Graph-Based Induction (or Cl-GBI for short), was evaluated on two datasets, the promoter dataset from UCI repos-itory [1] and the hepatitis dataset provided by Chiba University, and shown successful in extracting more typical substructures compared to the B-GBI al-gorithm. 2.1 Principle of GBI GBI employs the idea of extracting typical patterns by stepwise pair expansion as shown in Fig. 1. In the original GBI, an assumption is made that typical patterns represent some concepts/substructures and  X  X ypicality X  is characterized by the pattern X  X  frequency or the value of some evaluation function of its frequency. We can use statistical indices as an evaluation function, such as frequency itself, Information Gain [13], Gain Ratio [14] and Gini Index [3], all of which are based on frequency. In Fig. 1 the shaded pattern consisting of nodes 1, 2, and 3 is thought typical because it occurs three times in the graph. GBI first finds the 1  X  3 pairs based on its frequency, chunks them into a new node 10, then in the next iteration finds the 2  X  10 pairs, chunks them into a new node 11. The resulting node represents the shaded pattern.
 above three steps. Note that the search is greedy and no backtracking is made. This means that in enumerating pairs no pattern which has been chunked into one node is restored to the original pattern. Because of this, all the  X  X ypical patterns X  that exist in the input graph are not necessarily extracted. The prob-lem of extracting all the isomorphic subgraphs is known to be NP-complete. Thus, GBI aims at extracting only meaningful typical patterns of a certain size. Its objective is not finding all the typical patterns nor finding all the frequent patterns.
 quency of paired nodes. However, for finding a pattern that is of interest any of its subpatterns must be of interest because of the nature of repeated chunking. In Fig. 1 the pattern 1  X  3 must be typical for the pattern 2  X  10 to be typical. Said differently, unless pattern 1  X  3 is chunked, there is no way of finding the pattern 2  X  10. Frequency measure satisfies this monotonicity. However, if the criterion chosen does not satisfy this monotonicity, repeated chunking may not find good patterns even though the best pair based on the criterion is selected at each iteration. To resolve this issue GBI was improved to use two criteria, one for frequency measure for chunking and the other for finding discriminative pat-terns after chunking. The latter criterion does not necessarily hold monotonicity property. Any function that is discriminative can be used, such as Information Gain [13], Gain Ratio [14] and Gini Index [3], and some others. 2.2 Beam-Wise Graph-Based Induction (B-GBI) Since the search in GBI is greedy and no backtracking is made, which patterns (subgraphs) are extracted by GBI depends on which pair is selected for chunking. There can be many patterns which are not extracted by GBI. In Fig. 2, if the pair B X  X  is selected for chunking beforehand, there is no way to extract the substructure A X  X  X  X  even if it is a typical pattern.
 of greedy search in order to relax this problem, increase the search space, and extract more discriminative patterns while still keeping the computational com-plexity within a tolerant level. A certain number of pairs ranked from the top are selected to be chunked individually. To prevent each branch from growing exponentially, the total number of pairs to be chunked (the beam width) is fixed at every time of chunking. Thus, at any iteration step, there is always a fixed number of chunking performed in parallel.
 GBI assigns a new label to each newly chunked pair. Because it recursively chunks pairs, it happens that the new pairs that have different labels happen to be the same pattern. A simple example is shown in Fig. 3. They represent the same pattern but the way they are constructed is different. To identify if two pairs represent the same pattern, each pair is represented by canonical label [5] and they are regarded identical only when the label is the same. As described in Section 2.2, B-GBI increases the search space by running GBI in parallel. As a result, B-GBI can help alleviate the problem of overlapping subgraphs, but cannot solve it completely because the chunking process is still involved. It happens that some of the overlapping patterns are not discovered by B-GBI. For example, suppose in Fig. 2 the pair B X  X  is most frequent, followed by the pair A X  X . When b = 1, there is no way that the pattern A X  X  X  X  is discovered because the pair B X  X  is chunked first, but by setting b = 2, the pair A X  X  can be chunked in the second beam and if the substructure A X  X  X  X  is frequent enough, there is a chance that the pair (A X  X ) X  X  is chunked at next iteration. However, setting b very large is prohibitive from the computational point of view. Thus, it happens that a pattern found in one input graph is unable to be found in the other input graph even if it does exist in the graph. An example is shown in Fig. 4, where even if the pair A  X  B is selected for chunking and the substructure D  X  A  X  B  X  C exists in the input graphs, we may not find that substructure because an unexpected pair A  X  B is chunked (see Fig. 4(b)). This causes a serious problem in counting the frequency of a pattern.
 gSpan[15], FFSM [7], etc. do not face the problem of overlapping subgraphs since they can find all frequent patterns in a graph database. However, these methods are designed to find existence or non-existence of a certain pattern in one transaction and not to count how many times a certain pattern appear in one transaction. They also cannot give information on the positions of each pattern in any transaction of the graph database which is required by domain experts. GREW [11], on the other hand, are designed for the purpose of enumerating typical patterns in a single large graph. Specially, B-GBI [12] can find (not all) typical patterns in either a single large graph or a graph database. However, all of them are not designed to detect the positions of patterns in any graph transaction. In Section 4, we will introduce a novel algorithm that can overcome the problem of overlapping subgraphs imposed on both GBI and B-GBI. The proposed algorithm, called Cl-GBI (Chunkingless Graph-Based Induction), em-ploys a  X  X hunkingless chunking X  strategy, where frequent pairs are never chunked but used as pseudo nodes in the subsequent steps, thus allowing extraction of overlapping subgraphs. It can also give the positions of patterns present in each graph transaction as well as be applied to find frequent patterns in either a single large graph or a graph database. 4.1 Approach The basic ideas of Cl-GBI are described as follows. Those pairs that connect two adjoining nodes in the graphs are counted and a certain fixed number of pairs (the beam width) ranked from the top are selected. In B-GBI, each of the selected pairs is registered as one node and this node is assigned a new label. Then, the graphs in the respective state are rewritten by replacing all the occurrences of the selected pair with a node with the newly assigned label (pair-wise chunking). labels to them. But those pairs are never chunked and the graphs are not  X  X om-pressed X  nor copied into respective states as in B-GBI. In the presence of the pseudo nodes (i.e., newly assigned-label nodes), we count the frequencies of pairs consisting of at least one new pseudo node. The other is either one of pseudo nodes including those already created in the previous steps or an original one. In other words, the other is one of the existing nodes. Among the remaining pairs (after selecting the most frequent pairs) and the new pairs which have just been counted, we select the most frequent pairs, with the number equal to the beam width specified in advance, again and so on.
 is referred to as a level. Those pairs that satisfy a typicality criterion (e.g., pairs whose information gain exceeds a given threshold) among all the extracted pairs are the output of the algorithm. ered to be typical patterns. Another possible method to reduce the number of pairs is to eliminate those pairs whose typicality measure is low even if their frequency count is above the frequency threshold. The two parameters, beam width and number of levels, control the search space. Frequency threshold is another important parameter.
 graphs as well as both general and induced subgraphs. It can also extract typical patterns in either a single large graph or a graph database. 4.2 Algorithm of Cl-GBI Given a graph database, two natural numbers b (beam width) and N e (number of levels), and a frequency threshold  X  , the new  X  X hunkingless chunking X  strategy repeats the following three steps.

Step 1. Extract all the pairs consisting of two connected nodes in the graphs, Step 2. Select the b most frequent pairs from among the pairs extracted at
Step 3. Assign a new label to each pair selected at Step 2 but do not rewrite Step 1 in all the levels (i.e. level 1 to level N e ), including those that are not used as pseudo nodes, are ranked based on a typicality criterion using a discriminative function such as Information Gain, Gain Ratio or Gini Index. It is worth noting that those pairs that have frequency count below a frequency threshold  X  are eliminated, which means that there are three parameters b , N e ,  X  to control the search in Cl-GBI.
 which comes together with the positions of every occurrence of the pattern in each transaction of the graph database (given by the node id sets) as well as the number of occurrences. 4.3 Implementation Issues of Cl-GBI The first issue concerns with frequency counting. To count the number of oc-currences of a pattern in a graph transaction, the canonical labeling employed in [12] is adopted. However, only canonical labeling cannot solve the problem completely as shown in Fig. 5. Suppose that the pair A  X  B is registered as a pseudo node N in the graph shown in Fig. 5(a). How many times the pair N  X  B should be counted here? If only the canonical label is considered, the answer is 2 because there are two pseudo nodes N 1 and N 2 as shown in Fig. 5(b), and both N 1  X  B and N 2  X  B are counted separately. However, the pair N  X  B should be counted once. Our solution is to incorporate the canonical label with the node id set. If both the canonical label and the node id set are identical for two subgraphs, we regard that they are the same and count once.
 which are embedded inside. Think of the pseudo node C and two embedded nodes A, B in Fig. 6(a). What are the relations between C and A or C and B? In the case of enumerating frequent induced subgraphs, there is not any relation between C and A nor C and B. This is because a pair in this case must consist of two nodes and all links between them. However, in the case of extracting frequent general subgraphs, there is still a link between C and A as well as a link between C and B. To differentiate between the graphs shown in Fig. 6(a) and Fig. 6(b), a flag indicating whether it is a self-loop or not is required. the link between them, information of which two nodes inside the pair the link is connected to, and a self-loop flag. In the case of enumerating frequent induced subgraphs, all links between two nodes should be considered. 4.4 Unsolved Problem of Cl-GBI We found that there is still a problem in frequency counting that the use of both the canonical label and the node id set cannot solve. Think of the graph in Fig. 7(a). The three subgraphs A X  X  X  X  illustrated in Figs. 7 (b), (c), and (d) share the same canonical label and the same node id set. Our current Cl-GBI cannot distinguish between these three. However, this problem arises only when extracting general subgraphs. It causes no problem in the case of enumerating frequent induced subgraphs. To assess the performance of the Cl-GBI approach, we conducted some experi-ments on both synthetic and real-world graph-structred datasets. The proposed Cl-GBI algorithm was implemented in C ++ . Since the current implementation is very naive, we did not evaluate the computation time. It should be noted that all graphs/subgraphs reported here are connected ones.
 frequent patterns in a single graph that other graph mining algorithms cannot. An example of such a single graph is shown in Fig. 8(a). Suppose that the problem here is to find frequent induced subgraphs that occur at least 3 times in the graph. Fig. 8(c) shows an example of frequent induced subgraph which has the support of 3.
 in a single graph such as GBI [16], B-GBI [12], SUBDUE [4], or GREW [11], etc. cannot discover the pattern shown in Fig. 8(c) because three occurrences of this pattern are not disjoint, but overlapping. Meanwhile, the complete graph mining algorithms like AcGM [9], FSG [10], gSpan [15], FFSM [7], etc., in case that they are adapted to find frequent patterns in a single graph, also cannot find that pattern because of the monotonic nature. Since the pattern shown in Fig. 8(b) occurs only once in the graph and thus cannot be extracted, the pattern shown in Fig. 8(c) which is one of its super-graph is also unable to be found. The proposed Cl-GBI algorithm, on the other hand, can find all 36 frequent induced subgraphs, including the one shown in Fig. 8(c), with b =3 ,N e =5.
 promoter dataset from UCI repository [1] and the hepatitis dataset provided by Chiba University. Since only the number of frequent induced subgraphs discov-ered by Cl-GBI is evaluated in this experiment, it is not required to use the whole datasets. Therefore, we used only positive instances of the two datasets, i.e.,  X  X romoter sequences X  in the case of promoter dataset and  X  X atients who have response to interferon therapy X  in the case of hepatitis dataset. These pro-moter and hepatitis datasets were converted to undirected and directed graph database, respectively. The former contains 53 undirected graphs having the same size of 57, while the latter has 56 directed graphs having the average size of 75.4. It should be noted that the promoter dataset is usually converted to directed graphs [12] since information on the order of nucleotides is important. We compared the number of frequent induced subgraphs discovered by Cl-GBI with B-GBI [12] and AcGM [9] given the frequency threshold of 50%. B-GBI is an improved version of GBI, while AcGM can extract all frequent induced subgraphs.
 It is shown that Cl-GBI can find more frequent patterns than B-GBI given the same beam width. Also, as is easily predicted, this algorithm can find all the frequent patterns by setting b and N e large enough. One of the nice aspects of B-GBI is that the size of the input graph keeps reducing progressively as the chunking proceeds, and thus the number of pairs to be considered also progres-sively decreases accordingly. In the case of Cl-GBI, the number of pairs to be considered keeps increasing because the number of pseudo nodes keeps increas-ing as the search proceeds. Thus, it is important to select appropriate values for b and N e .
 extracts 4439 frequent patterns with b =5, N e = 10 and B-GBI finds 870 frequent patterns with b = 5. Meanwhile, since the current version of AcGM [9] has not been implemented to handle directed graphs, we cannot use it to find frequent patterns in this graph dataset. However, even if we consider the graphs in this dataset as undirected graphs, AcGM cannot give the results due to the large graph size and the large number of links.
 lowing way. The frequency threshold  X  is used for selecting b (the beam width) most frequent pairs only and those pairs that have frequency count below  X  are now not eliminated. The promoter dataset (both promoter and non-promoter sequences) were converted to directed graphs as in [12] and we obtained 106 directed graphs having the same size of 57 which were classified equally into 2 classes: positive class and negative class.
 formation gain [13] is greater than or equal to 0.01, i.e., the typicality measure is information gain and the typicality threshold is set as 0.01. Cl-GBI finds 3269 typical patterns in 5 levels, including 8 patterns having information gain greater than 0.19. Meanwhile, the number of typical patterns discovered by B-GBI is 3045 in 18 levels, however, and only 4 patterns among them have information gain greater than 0.19. Within 10 levels, Cl-GBI finds 13407 typical patterns which include 35 patterns having information gain greater than 0.19. This jus-tifies the fact that Cl-GBI can find more typical patterns than B-GBI. A novel algorithm, Chunkingless Graph-Based Induction (Cl-GBI), was intro-duced for the purpose of discovering typical patterns in either a single large graph or a graph database. The proposed method employs a  X  X hunkingless chunking X  strategy which helps overcome the problem of overlapping subgraphs. Also, Cl-GBI can give the correct number of occurrences of a pattern as well as their positions in each transaction of the graph database. Experiments conducted on both synthetic and real-world graph-structured data confirm its effectiveness. For future work we plan to employ some heuristics to speed up the Cl-GBI al-gorithm in order to extract larger typical subgraphs and apply the method to some application domains.

