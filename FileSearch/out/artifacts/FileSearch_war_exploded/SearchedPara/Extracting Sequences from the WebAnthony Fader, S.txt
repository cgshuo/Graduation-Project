 Classical IE systems fill slots in domain-specific frames such as the time and location slots in sem-inar announcements (Freitag, 2000) or the terror-ist organization slot in news stories (Chieu et al., 2003). In contrast, open IE systems are domain-independent, but extract  X  X lat X  sets of assertions that are not organized into frames and slots (Sekine, 2006; Banko et al., 2007). This paper reports on S EQ  X  X n open IE system that leverages a domain-independent frame to extract ordered se-quences of objects from Web text. We show that the novel, domain-independent sequence frame in S
EQ substantially boosts the precision and recall of the system and yields coherent sequences fil-tered from low-precision extractions (Table 1).
Sequence extraction is distinct from set expan-sion (Etzioni et al., 2004; Wang and Cohen, 2007) because sequences are ordered and because the ex-traction process does not require seeds or HTML lists as input.

The domain-independent sequence frame con-sists of a sequence name s ( e.g. , presidents of the United States), and a set of ordered pairs ( x, k ) where x is a string naming a member of the se-quence with name s , and k is an integer indicating Table 1: Examples of sequences extracted by S EQ from unstructured Web text. its position ( e.g. , (Washington, 1) and (JFK, 35)). The task of sequence extraction is to automatically instantiate sequence frames given a corpus of un-structured text.

By definition, sequences have two properties that we can leverage in creating a sequence ex-tractor: functionality and density . Functionality means position k in a sequence is occupied by a single real-world entity x . Density means that if a value has been observed at position k then there must exist values for all i &lt; k , and possibly more after it. Sequence extraction has two parts: identify-ing possible extractions ( x, k, s ) from text, and then classifying those extractions as either cor-rect or incorrect. In the following section, we describe a way to identify candidate extractions from text using a set of lexico-syntactic patterns. We then show that classifying extractions based on sentence-level features and redundancy alone yields low precision, which is improved by lever-aging the functionality and density properties of sequences as done in our S EQ system. Table 2: The patterns used by S EQ to detect ordi-nal phrases are noun phrases that begin with one of the part-of-speech patterns listed above. 2.1 Generating Sequence Extractions To obtain candidate sequence extractions ( x, k, s ) from text, the S EQ system finds sentences in its input corpus that contain an ordinal phrase (OP). Table 2 lists the lexico-syntactic patterns S EQ uses to detect ordinal phrases. The value of k is set to the integer corresponding to the ordinal number in the OP. 1
Next, S EQ takes each sentence that contains an ordinal phrase o , and finds candidate items of the form ( x, k ) for the sequence with name s . S EQ constrains x to be an NP that is disjoint from o , and s to be an NP (which may have post-modifying PPs or clauses) following the ordinal number in o .
For example, given the sentence  X  X ith help from his father, JFK was elected as the 35th Pres-ident of the United States in 1960 X , S EQ finds the candidate sequences with names  X  X resident X ,  X  X resident of the United States X , and  X  X resident of the United States in 1960 X , each of which has can-didate extractions (JFK, 35), (his father, 35), and (help, 35). We use heuristics to filter out many of the candidate values ( e.g. , no value should cross a sentence-like boundary, and x should be at most some distance from the OP).

This process of generating candidate ex-tractions has high coverage, but low preci-sion. The first step in identifying correct ex-tractions is to compute a confidence measure localConf ( x, k, s | sentence ) , which measures how likely ( x, k, s ) is given the sentence it came from. We do this using domain-independent syn-tactic features based on POS tags and the pattern-based features  X  x { is,are,was,were } the k th s  X  and  X  X he k th s { is,are,was,were } x  X . The features are then combined using a Naive Bayes classifier.
In addition to the local, sentence-based features, we define the measure totalConf that takes into account redundancy in an input corpus C . As Downey et al. observed (2005), extractions that occur more frequently in multiple distinct sen-tences are more likely to be correct. totalConf ( x, k, s |C ) = 2.2 Challenges The scores localConf and totalConf are not suffi-cient to identify valid sequence extractions. They tend to give high scores to extractions where the sequence scope is too general or too specific. In our running example, the sequence name  X  X resi-dent X  is too general  X  many countries and orga-nizations have a president. The sequence name  X  X resident of the United States in 1960 X  is too spe-cific  X  there were not multiple U.S. presidents in 1960.

These errors can be explained as violations of functionality and density. The sequence with name  X  X resident X  will have many distinct candi-date extractions in its positions, which is a vio-lation of functionality. The sequence with name  X  X resident of the United States in 1960 X  will not satisfy density, since it will have extractions for only one position.
 In the next section, we present the details of how S
EQ incorporates functionality and density into its assessment of a candidate extraction.

Given an extraction ( x, k, s ) , S EQ must clas-sify it as either correct or incorrect. S EQ breaks this problem down into two parts: (1) determining whether s is a correct sequence name, and (2) de-termining whether ( x, k ) is an item in s , assuming s is correct.

A joint probabilistic model of these two deci-sions would require a significant amount of la-beled data. To get around this problem, we repre-sent each ( x, k, s ) as a vector of features and train two Naive Bayes classifiers: one for classifying s and one for classifying ( x, k ) . We then rank ex-tractions by taking the product of the two classi-fiers X  confidence scores.

We now describe the features used in the two classifiers and how the classifiers are trained. Classifying Sequences To classify a sequence name s , S EQ uses features to measure the func-tionality and density of s . Functionality means that a correct sequence with name s has one cor-rect value x at each position k , possibly with ad-ditional noise due to extraction errors and synony-mous values of x . For a fixed sequence name s and position k , we can weight each of the candi-date x values in that position by their normalized total confidence: w ( x | k, s, C ) = For overly general sequences, the distribution of weights for a position will tend to be more flat, since there are many equally-likely candidate x values. To measure this property, we use a func-tion analogous to information entropy: H ( k, s |C ) =  X  X Sequences s that are too general will tend to have high values of H ( k, s |C ) for many values of k . We found that a good measure of the overall non-functionality of s is the average value of H ( k, s |C ) for k = 1 , 2 , 3 , 4 .

For a sequence name s that is too specific, we would expect that there are only a few filled-in po-sitions. We model the density of s with two met-rics. The first is numF illedP os ( s |C ) , the num-ber of distinct values of k such that there is some extraction ( x, k ) for s in the corpus. The second is totalSeqConf ( s |C ) , which is the sum of the scores of most confident x in each position: totalSeqConf ( s |C ) =
The functionality and density features are com-bined using a Naive Bayes classifier. To train the classifier, we use a set of sequence names s labeled as either correct or incorrect, which we describe in Section 3.
 Classifying Sequence Items To classify ( x, k ) given s , S EQ uses two features: the total con-fidence totalConf ( x, k, s |C ) and the same total confidence normalized to sum to 1 over all x , hold-ing k and s constant. To train the classifier, we use a set of extractions ( x, k, s ) where s is known to be a correct sequence name. This section reports on two experiments. First, we measured how the density and functionality fea-tures improve performance on the sequence name Figure 1: Using density or functionality features alone is effective in identifying correct sequence names. Combining both types of features outper-forms either by a statistically significant margin (paired t-test, p &lt; 0 . 05 ). classification sub-task (Figure 1). Second, we report on S EQ  X  X  performance on the sequence-extraction task (Figure 2).

To create a test set, we selected all sentences containing ordinal phrases from Banko X  X  500M Web page corpus (2008). To enrich this set O , we obtained additional sentences from Bing.com as follows. For each sequence name s satis-fying localConf ( x, k, s | sentence )  X  0 . 5 for some sentence in O , we queried Bing.com for  X  X he kth s  X  for k = 1 , 2 , . . . until no more hits were returned. 2 For each query, we downloaded the search snippets and added them to our cor-pus. This procedure resulted in making 95 , 611 search engine queries. The final corpus contained 3 , 716 , 745 distinct sentences containing an OP.
Generating candidate extractions using the method from Section 2.1 resulted in a set of over 40 million distinct extractions, the vast majority of which are incorrect. To get a sample with a significant number of correct extractions, we filtered this set to include only extractions with totalConf ( x, k, s |C )  X  0 . 8 for some sentence, resulting in a set of 2 , 409 , 211 extractions.
We then randomly sampled and manually la-beled 2 , 000 of these extractions for evaluation. We did a Web search to verify the correctness of the sequence name s and that x is the k th item in the sequence. In some cases, the ordering rela-tion of the sequence name was ambiguous ( e.g. , Figure 2: S EQ outperforms the baseline systems, increasing the area under the curve by 247% rela-tive to L OCAL and by 90% relative to R EDUND .  X  X argest state in the US X  could refer to land area or population), which could lead to merging two dis-tinct sequences. In practice, we found that most ordering relations were used in a consistent way ( e.g. ,  X  X argest city in X  always means largest by population) and only about 5% of the sequence names in our sample have an ambiguous ordering relation.

We compute precision-recall curves relative to this random sample by changing a confidence threshold. Precision is the percentage of correct extractions above a threshold, while recall is the percentage correct above a threshold divided by the total number of correct extractions. Because S
EQ requires training data, we used 15 -fold cross validation on the labeled sample.
 The functionality and density features boost S
EQ  X  X  ability to correctly identify sequence names. Figure 1 shows how well S EQ can iden-tify correct sequence names using only functional-ity, only density, and using functionality and den-sity in concert. The baseline used is the maximum value of localConf ( x, k, s ) over all ( x, k ) . Both the density features and the functionality features are effective at this task, but using both types of features resulted in a statistically significant im-provement over using either type of feature in-dividually (paired t-test of area under the curve, p &lt; 0 . 05 ).

We measure S EQ  X  X  efficacy on the complete sequence-extraction task by contrasting it with two baseline systems. The first is L OCAL , which ranks extractions by localConf . 3 The second is R EDUND , which ranks extractions by totalConf . Figure 2 shows the precision-recall curves for each system on the test data. The area under the curves for S EQ , R EDUND , and L OCAL are 0.59, 0.31, and 0.17, respectively. The low precision and flat curve for L OCAL suggests that localConf is not informative for classifying extractions on its own.
R EDUND outperformed L OCAL , especially at the high-precision part of the curve. On the subset of extractions with correct s , R EDUND can iden-tify x as the k th item with precision of 0.85 at re-call 0.80. This is consistent with previous work on redundancy-based extractors on the Web. How-ever, R EDUND still suffered from the problems of over-specification and over-generalization de-scribed in Section 2. S EQ reduces the negative ef-fects of these problems by decreasing the scores of sequence names that appear too general or too specific. There has been extensive work in extracting lists or sets of entities from the Web. These extrac-tors rely on either (1) HTML features (Cohen et al., 2002; Wang and Cohen, 2007) to extract from structured text or (2) lexico-syntactic pat-terns (Hearst, 1992; Etzioni et al., 2005) to ex-tract from unstructured text. S EQ is most similar to this second type of extractor, but additionally leverages the sequence regularities of functionality and density. These regularities allow the system to overcome the poor performance of the purely syn-tactic extractor L OCAL and the redundancy-based extractor R EDUND . We have demonstrated that an extractor leveraging sequence regularities can greatly outperform ex-tractors without this knowledge. Identifying likely sequence names and then filling in sequence items proved to be an effective approach to sequence ex-traction.

One line of future research is to investigate other types of domain-independent frames that ex-hibit useful regularities. Other examples include events (with regularities about actor, location, and time) and a generic organization-role frame (with regularities about person, organization, and role played). This research was supported in part by NSF grant IIS-0803481, ONR grant N00014-08-1-0431, DARPA contract FA8750-09-C-0179, and an NSF Graduate Research Fellowship, and was carried out at the University of Washington X  X  Tur-ing Center.

