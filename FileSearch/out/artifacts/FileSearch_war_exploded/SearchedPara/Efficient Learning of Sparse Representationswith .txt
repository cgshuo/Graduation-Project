 Unsupervised learning methods are often used to produce pre -processors and feature extractors for image analysis systems. Popular methods such as Wavelet dec omposition, PCA, Kernel-PCA, Non-Negative Matrix Factorization [1], and ICA produce compact representations with somewhat uncor-related (or independent) components [2]. Most methods prod uce representations that either preserve or reduce the dimensionality of the input. However, several recent works have advocated the use of sparse-overcomplete representations for images, in whi ch the dimension of the feature vector is larger than the dimension of the input, but only a small number of com ponents are non-zero for any one image [3, 4]. Sparse-overcomplete representations present several potential advantages. Using high-dimensional representations increases the lik elihood that image categories will be easily (possibly linearly) separable. Sparse representations ca n provide a simple interpretation of the input data in terms of a small number of  X  X arts X  by extracting the st ructure hidden in the data. Further-more, there is considerable evidence that biological visio n uses sparse representations in early visual areas [5, 6].
 It seems reasonable to consider a representation  X  X omplete  X  if it is possible to reconstruct the input from it, because the information contained in the input woul d need to be preserved in the represen-tation itself. Most unsupervised learning methods for feat ure extraction are based on this principle, and can be understood in terms of an encoder module followed by a decoder module. The encoder takes the input and computes a code vector, for example a spar se and overcomplete representation. The decoder takes the code vector given by the encoder and pro duces a reconstruction of the in-put. Encoder and decoder are trained in such a way that recons tructions provided by the decoder are as similar as possible to the actual input data, when thes e input data have the same statistics as the training samples. Methods such as Vector Quantizatio n, PCA, auto-encoders [7], Restricted Boltzmann Machines [8], and others [9] have exactly this arc hitecture but with different constraints on the code and learning algorithms, and different kinds of e ncoder and decoder architectures. In other approaches, the encoding module is missing but its rol e is taken by a minimization in code space which retrieves the representation [3]. Likewise, in non-causal models the decoding module is missing and sampling techniques must be used to reconstru ct the input from a code [4]. In sec. 2, we describe an energy-based model which has both an encoding and a decoding part. After tr aining, the encoder allows very fast inference because finding a repr esentation does not require solving an optimization problem. The decoder provides an easy way to re construct input vectors, thus allowing the trainer to assess directly whether the representation e xtracts most of the information from the input.
 Most methods find representations by minimizing an appropri ate loss function during training. In order to learn sparse representations, a term enforcing spa rsity is added to the loss. This term usually penalizes those code units that are active, aiming to make th e distribution of their activities highly peaked at zero with heavy tails [10] [4]. A drawback for these approaches is that some action might need to be taken in order to prevent the system from alwa ys activating the same few units and collapsing all the others to zero [3]. An alternative approa ch is to embed a sparsifying module, e.g. a non-linearity, in the system [11]. This in general forces a ll the units to have the same degree of sparsity, but it also makes a theoretical analysis of the alg orithm more complicated. In this paper, we present a system which achieves sparsity by placing a non-li nearity between encoder and decoder. Sec. 2.1 describes this module, dubbed the  X  Sparsifying Logistic  X , which is a logistic function with an adaptive bias that tracks the mean of its input. This non-l inearity is parameterized in a simple way which allows us to control the degree of sparsity of the re presentation as well as the entropy of each code unit.
 Unfortunately, learning the parameters in encoder and deco der can not be achieved by simple back-propagation of the gradients of the reconstruction error: t he Sparsifying Logistic is highly non-linear and resets most of the gradients coming from the decoder to ze ro. Therefore, in sec. 3 we propose code vectors as variables over which the optimization is per formed. Exploiting the fact that 1) it is fairly easy to determine the weights in encoder and decoder w hen  X  X ood X  codes are given, and 2) it is straightforward to compute the optimal codes when the p arameters in encoder and decoder are fixed, we describe a simple iterative coordinate descent opt imization to learn the parameters of the system. The procedure can be seen as a sort of deterministic version of the EM algorithm in which the code vectors play the role of hidden variables. The learn ing algorithm described turns out to be particularly simple, fast and robust. No pre-processing is required for the input images, beyond a simple centering and scaling of the data. In sec. 4 we report e xperiments of feature extraction on handwritten numerals and natural image patches. When the sys tem has a linear encoder and decoder (remember that the Sparsifying Logistic is a separate modul e), the filters resemble  X  X bject parts X  for the numerals, and localized, oriented features for the natu ral image patches. Applying these features for the classification of the digits in the MNIST dataset, we h ave achieved by a small margin the best accuracy ever reported in the literature. We conclude b y showing a hierarchical extension which suggests the form of simple and complex cell receptive fields , and leads to a topographic layout of the filters which is reminiscent of the topographic maps foun d in area V1 of the visual cortex. The proposed model is based on three main components, as show n in fig. 1: The energy of the system is the sum of two terms: The first term is the code prediction energy which measures the discrepancy between the output of the encoder and the code vector Z . In our experiments, it is defined as: The second term is the reconstruction energy which measures the discrepancy between the recon-structed image patch produced by the decoder and the input im age patch X . In our experiments, it Figure 1: Architecture of the energy-based model for learni ng sparse-overcomplete representations. The input image patch X is processed by the encoder to produce an initial estimate of the code vector. The encoding prediction energy E Z and its estimate. The code vector Z is passed through the Sparsifying Logistic non-linearity which produces a sparsified code vector  X  Z . The decoder reconstructs the input image patch from the sparse code. The reconstruction energy E the input image patch. The optimal code vector Z  X  for a given patch minimizes the sum of the two energies. The learning process finds the encoder and decoder parameters that minimize the energy for the optimal code vectors averaged over a set of training s amples. Figure 2: Toy example of sparsifying rectification produced by the Sparsifying Logistic for different choices of the parameters  X  and  X  . The input is a sequence of Gaussian random variables. The output, computed by using eq. 4, is a sequence of spikes whose rate and amplitude depend on the parameters  X  and  X  . In particular, increasing  X  has the effect of making the output approximately binary, while increasing  X  increases the firing rate of the output signal. is defined as: where  X  Z is computed by applying the Sparsifying Logistic non-linea rity to Z . 2.1 The Sparsifying Logistic The Sparsifying Logistic module is a non-linear front-end to the decoder that transfo rms the code vector into a sparse vector with positive components. Let us consider how it transforms the k -th training sample. Let z output, with i  X  [1 ..m ] where m is the number of components in the code vector. The relation between these variables is given by: where it is assumed that  X   X  [0 , 1] .  X  to previous training samples n , with n  X  k . The weights in this sum are exponentially decaying as can be seen by unrolling the recursive equation in 4. This non -linearity can be easily understood as a weighted softmax function applied over consecutive sampl es of the same code unit. This produces a sequence of positive values which, for large values of  X  and small values of  X  , is characterized by brief and punctuate activities in time. This behavior is r eminiscent of the spiking behavior of neurons.  X  controls the sparseness of the code by determining the  X  X idt h X  of the time window over which samples are summed up.  X  controls the degree of  X  X oftness X  of the function. Large  X  values yield quasi-binary outputs, while small  X  values produce more graded responses; fig. 2 shows how these parameters affect the output when the input is a Gaussi an random variable.
 Another view of the Sparsifying Logistic is as a logistic fun ction with an adaptive bias that tracks the average input; by dividing the right hand side of eq. 4 by  X e  X z i ( k ) we have: Notice how  X  directly controls the gain of the logistic. Large values of t his parameter will turn the non-linearity into a step function and will make  X  Z ( k ) a binary code vector.
 In our experiments,  X  this case, the Sparsifying Logistic reduces to a logistic fu nction with a fixed gain and a learned bias. For large  X  in the continuous-time limit, the spikes can be shown to foll ow a homogeneous Poisson process. In this framework, sparsity is a  X  X emporal X  proper ty characterizing each single unit in the code, rather than a  X  X patial X  property shared among all the u nits in a code. Spatial sparsity usually requires some sort of ad-hoc normalization to ensure that th e components of the code that are  X  X n X  are not always the same ones. Our solution tackles this probl em differently: each unit must be sparse when encoding different samples, independently fro m the activities of the other components in the code vector. Unlike other methods [10], no ad-hoc resc aling of the weights or code units is necessary. Learning is accomplished by minimizing the energy in eq. 1. I ndicating with superscripts the indices referring to the training samples and making explicit the de pendencies on the code vectors, we can rewrite the energy of the system as: This is also the loss function we propose to minimize during t raining. The parameters of the system, W It is easy to minimize this loss with respect to W for our experiments where encoder and decoder are a set of lin ear filters, this is a convex quadratic optimization problem. Likewise, when the parameters in the system are fixed it is straightforward to minimize with respect to the codes Z i . These observations suggest a coordinate descent optimiza tion procedure. First, we find the optimal Z i for a given set of filters in encoder and decoder. Then, we update the weights in the system fixing Z i to the value found at the previous step. We iterate these two steps in alternation until convergence. In our experime nts we used an on-line version of this algorithm which can be summarized as follows: where the superscripts have been dropped because we are refe rring to a generic training sample. Since the code vector Z minimizes both energy terms, it not only minimizes the recon struction energy, but is also as similar as possible to the code predict ed by the encoder. After training the de-coder settles on filters that produce low reconstruction err ors from minimum-energy, sparsified code vectors  X  Z  X  , while the encoder simultaneously learns filters that predi ct the corresponding minimum-energy codes Z  X  . In other words, the system converges to a state where minimu m-energy code vectors not only reconstruct the image patch but can also be e asily predicted by the encoder filters. Moreover, starting the minimization over Z from the prediction given by the encoder allows conver-gence in very few iterations. After the first few thousand tra ining samples, the minimization over Z requires just 4 iterations on average. When training is compl ete, a simple pass through the encoder will produce an accurate prediction of the minimum-energy c ode vector. In the experiments, two regularization terms are added to the loss in eq. 6: a  X  X asso X  term equal to the L W localize and to suppress noise.
 Notice that we could differently weight the encoding and the reconstruction energies in the loss function. In particular, assigning a very large weight to th e encoding energy corresponds to turning the penalty on the encoding prediction into a hard constraint. The code vector would be assigned the value predicted by the encoder, and the minimization would r educe to a mean square error minimiza-tion through back-propagation as in a standard autoencoder . Unfortunately, this autoencoder-like Figure 3: Results of feature extraction from 12x12 patches t aken from the Berkeley dataset, showing the 200 filters learned by the decoder. learning fails because Sparsifying Logistic is almost alwa ys highly saturated (otherwise the repre-sentation would not be sparse). Hence, the gradients back-p ropagated to the encoder are likely to be very small. This causes the direct minimization over encode r parameters to fail, but does not seem to adversely affect the minimization over code vectors. We s urmise that the large number of degrees of freedom in code vectors (relative to the number of encoder parameters) makes the minimization problem considerably better conditioned. In other words, t he alternated descent algorithm performs a minimization over a much larger set of variables than regul ar back-prop, and hence is less likely to fall victim to local minima. The alternated descent over cod e and parameters can be seen as a kind of deterministic EM . It is related to gradient-descent over parameters (standa rd back-prop) in the same way that the EM algorithm is related to gradient ascent f or maximum likelihood estimation. of sec. 4.1 it takes less than 30 minutes on a 2GHz processor to learn 200 filters from 100,000 patches of size 12x12, and after just a few minutes the filters are already very similar to the final ones. This is much more efficient and robust than what can be ac hieved using other methods. For example, in Olshausen and Field X  X  [10] linear generative mo del, inference is expensive because minimization in code space is necessary during testing as we ll as training. In Teh et al. [4], learning is very expensive because the decoder is missing, and sampli ng techniques [8] must be used to provide a reconstruction. Moreover, most methods rely on pr e-processing of the input patches such as whitening, PCA and low-pass filtering in order to improve r esults and speed up convergence. In our experiments, we need only center the data by subtracting a global mean and scale by a constant. In this section we present some applications of the proposed energy-based model. Two standard encoder and decoder learn linear filters. As mentioned in sec . 3, the input images were only trivially pre-processed. 4.1 Feature Extraction from Natural Image Patches In the first experiment, the system was trained on 100,000 gra y-level patches of size 12x12 extracted from the Berkeley segmentation data set [12]. Pre-processi ng of images consists of subtracting the global mean pixel value (which is about 100), and dividin g the result by 125. We chose an overcomplete factor approximately equal to 2 by representi ng the input with 200 code units 1 . The Sparsifying Logistic parameters  X  and  X  were equal to 0.02 and 1, respectively. The learning rate for updating W training. The coefficients of the L for the minimization in code space was set to 0.1, and was mult iplied by 0.8 every 10 iterations, for at most 100 iterations. Some components of the sparse code mu st be allowed to take continuous values to account for the average value of a patch. For this re ason, during training we saturated the running sums  X  to allow some units to be always active. Values of  X  were saturated to 10 9 . We verified empirically that subtracting the local mean from each patch eliminates the need for this saturation. However, saturation during training makes tes ting less expensive. Training on this data set takes less than half an hour on a 2GHz processor.
 Examples of learned encoder and decoder filters are shown in fi gure 3. They are spatially localized, and have different orientations, frequencies and scales. T hey are somewhat similar to, but more localized than, Gabor wavelets and are reminiscent of the re ceptive fields of V1 neurons. Interest-Figure 4: Top: A randomly selected subset of encoder filters l earned by our energy-based model when trained on the MNIST handwritten digit dataset. Bottom : An example of reconstruction of a digit randomly extracted from the test data set. The reconst ruction is made by adding  X  X arts X : it is the additive linear combination of few basis functions of the decoder wit h positive coefficients. ingly, the encoder and decoder filter values are nearly ident ical up to a scale factor. After training, inference is extremely fast, requiring only a simple matrix -vector multiplication. 4.2 Feature Extraction from Handwritten Numerals The energy-based model was trained on 60,000 handwritten di gits from the MNIST data set [13], which contains quasi-binary images of size 28x28 (784 pixel s). The model is the same as in the previous experiment. The number of components in the code ve ctor was 196. While 196 is less than the 784 inputs, the representation is still overcomplete, b ecause the effective dimension of the digit dataset is considerably less than 784. Pre-processing cons isted of dividing each pixel value by 255. Parameters  X  and  X  in the temporal softmax were 0.01 and 1, respectively. The ot her parameters of the system have been set to values similar to those of the pr evious experiment on natural image patches. Each one of the filters, shown in the top part of fig. 4, contains an elementary  X  X art X  of a digit. Straight stroke detectors are present, as in the prev ious experiment, but curly strokes can also be found. Reconstruction of most single digits can be achiev ed by a linear additive combination of a small number of filters since the output of the Sparsifying L ogistic is sparse and positive. The bottom part of fig. 4 illustrates this reconstruction by  X  X ar ts X . 4.3 Learning Local Features for the MNIST dataset Deep convolutional networks trained with backpropagation hold the current record for accuracy on the MNIST dataset [14, 15]. While back-propagation produc es good low-level features, it is well known that deep networks are particularly challenging for gradient-descent learning. Hinton et al. [16] have recently shown that initializing the weight s of a deep network using unsupervised learning before performing supervised learning with back-propagation can significantly improve the performance of a deep network. This section describes a simi lar experiment in which we used the proposed method to initialize the first layer of a large convo lutional network. We used an architecture essentially identical to LeNet-5 as described in [15]. However, because our model produces sp arse features, our network had a considerably larger number of fe ature maps: 50 for layer 1 and 2, 50 for layer 3 and 4, 200 for layer 5, and 10 for the output layer. T he numbers for LeNet-5 were 6, 16, 100, and 10 respectively. We refer to our larger network as th e 50-50-200-10 network. We trained this networks on 55,000 samples from MNIST, keeping the rema ining 5,000 training samples as a validation set. When the error on the validation set reached i ts minimum, an additional five sweeps training loss). Then the learning was stopped, and the final e rror rate on the test set was measured. When the weights are initialized randomly, the 50-50-200-10 achieves a test error rate of 0.7%, to be compared with the 0.95% obtained by [15] with the 6-16-100 -10 network.
 In the next experiment, the proposed sparse feature learnin g method was trained on 5x5 image patches extracted from the MNIST training set. The model had a 50-dimensional code. The encoder filters were used to initialize the first layer of the 50-50-20 0-10 net. The network was then trained in the usual way, except that the first layer was kept fixed for the first 10 epochs through the training set. The 50 filters after training are shown in fig. 5. The test error rate was 0.6%. To our knowledge, this is the best results ever reported with a method trained on the original MNIST set, without deskewing nor augmenting the training set with distorted samples.
 The training set was then augmented with samples obtained by elastically distorting the original training samples, using a method similar to [14]. The error r ate of the 50-50-200-10 net with random initialization was 0.49% (to be compared to 0.40% reported i n [14]). By initializing the first layer with the filters obtained with the proposed method, the test e rror rate dropped to 0.39%. While this is the best numerical result ever reported on MNIST, it is not statistically different from [14]. Figure 5: Filters in the first convolutional layer after trai ning when the network is randomly initial-ized (top row) and when the first layer of the network is initia lized with the features learned by the unsupervised energy-based model (bottom row).
 Table 1: Comparison of test error rates on MNIST dataset using convolutional n etworkswith various training 4.4 Hierarchical Extension: Learning Topographic Maps It has already been observed that features extracted from na tural image patches resemble Gabor-like filters, see fig. 3. It has been recently pointed out [6] that th ese filters produce codes with somewhat uncorrelated but not independent components. In order to ca pture higher order dependencies among code units, we propose to extend the encoder architecture by adding to the linear filter bank a second layer of units. In this hierarchical model of the encoder, th e units produced by the filter bank are now laid out on a two dimensional grid and filtered according t o a fixed weighted mean kernel. This assigns a larger weight to the central unit and a smaller weig ht to the units in the periphery. In order to activate a unit at the output of the Sparsifying Logi stic, all the afferent unrectified units in the first layer must agree in giving a strong positive respons e to the input patch. As a consequence neighboring filters will exhibit similar features. Also, th e top level units will encode features that are more translation and rotation invariant, de facto modeling complex cells. Using a neighborhood of size 3x3, toroidal boundary conditions, and computing co de vectors with 400 units from 12x12 input patches from the Berkeley dataset, we have obtained th e topographic map shown in fig. 6. Filters exhibit features that are locally similar in orient ation, position, and phase. There are two low frequency clusters and pinwheel regions similar to what is experimentally found in cortical topography.
 Figure 6: Example of filter maps learned by the topographic hi erarchical extension of the model. The outline of the model is shown on the right. An energy-based model was proposed for unsupervised learni ng of sparse overcomplete representa-tions. Learning to extract sparse features from data has app lications in classification, compression, denoising, inpainting, segmentation, and super-resoluti on interpolation. The model has none of the inefficiencies and idiosyncrasies of previously proposed s parse-overcomplete feature learning meth-ods. The decoder produces accurate reconstructions of the p atches, while the encoder provides a fast prediction of the code without the need for any particul ar preprocessing of the input images. It seems that a non-linearity that directly sparsifies the co de is considerably simpler to control than adding a sparsity term in the loss function, which generally requires ad-hoc normalization proce-dures [3].
 In the current work, we used linear encoders and decoders for simplicity, but the model authorizes non-linear modules, as long as gradients can be computed and back-propagated through them. As briefly presented in sec. 4.4, it is straightforward to exten d the original framework to hierarchical architectures in encoder, and the same is possible in the dec oder. Another possible extension would stack multiple instances of the system described in the pape r, with each system as a module in a multi-layer structure where the sparse code produced by one feature extractor is fed to the input of a higher-level feature extractor.
 Future work will include the application of the model to vari ous tasks, including facial feature extrac-tion, image denoising, image compression, inpainting, cla ssification, and invariant feature extraction for robotics applications.
 Acknowledgments
