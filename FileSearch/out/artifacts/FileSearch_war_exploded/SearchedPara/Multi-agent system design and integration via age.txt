 1. Introduction
Design and implementation of m ulti-agent systems (MAS) and holonic systems are usually very complex tasks due to their dis-tributed nature. Design of components or agents that deal with partial knowledge about the whole system and are responsible for specific sections of this system can be an advantage and disadvantage at the same time. Let us briefly summarize the most important ones. Major advantages are:
An agent can act on its own when it is disconnected from the rest of the system (or from its part).

An agent can be replaced or backed up by another agent; there can be multiple implementations even using different lan-guages to enhance fault tolerance.

Agents can flexibly enter or leave the system as necessary according to demand (i.e., the system can be scaled and adapted automatically as necessary).
 One implementation of an agent can be reused multiple times. 2. Agent development environment
The software part of a multi-agent system is typically devel-oped ad hoc in a target programming language, usually Java or C  X  X  , and this process can be error-prone and time consuming.
Therefore, the utilization of a development environment that guides the development process is essential.

Currently there exist multiple development environments that are used to develop agents for given MAS platforms, such as the JACK Development Environment described in Evertsz et al. (2003) ,
AgentBuilder (2011) , and Cybele in Manikonda and Satapathy (2004) . Very detailed reviews of these systems can be found, for example, in Bitting et al. (2008) . These development environ-ments either only guide the user during the development of agents or provide more elaborate support when the user pro-grams the agents as Belief X  X esire X  X ntention (BDI) models devel-oped by Bratman (1999) , for example in JACK. The resulting runtime code is either interpreted or automatically generated and then directly executed.
 The Agent Development Environment (ADE) prototype that
Rockwell Automation, Inc. developed not only supports the development of agents that can be used for high-level decision-making, but also for distributed low-level control. The low-level control guarantees real-time execution (both the soft and the hard real-time). This is important especially in industrial applica-and Ma  X  r X   X  k (2008) , or where fault-tolerance is one of the most important aspects as described in Tichy  X  et al. (2006b) .
The following section further details the low-level versus high-level distinction and the next section summarizes the main characteristics of ADE. 2.1. High-level versus low-level
To deploy agents at the lowest control levels but still preserve the ability of the control system to work under hard real-time constraints is the main characteristic of the architecture that we call a holonic agent as described, for example, in Christensen (1994) . It is an encapsulation of a high-level control part (HLC), low-level control subsystem (LLC), and the control interface for interactions between the HLC and LLC (see Fig. 1 ).

The LLC module is a common control program running in a programmable logic controller (PLC) in a classical scan-based manner. The PLC reads the input values from the sensors in a controlled process through the analog or digital I/O cards; the control programs perform a computation including calculation of new output values; and finally the output values are propagated again via the I/O cards to the actuators in the controlled system.
After the TL, F, and CS parts are completed, the user assigns agents and components to the execution units via agent assign-ment , which are usually PCs and PLCs.

The user also assigns inputs and outputs of agents and components to real I/O points that are connected to real hardware or to the simulation of this hardware via I/O assignment .

With all this information available, it is now possible to generate and compile the control code.

The last step is to download the code to the execution units and execute it.

Since the TL, F, and CS editors are independent, it is possible to change only the necessary parts when the system needs to incorporate changes. For example, a new PLC can be added by the CS editor and subsequently can have some agents assigned to it. The system is regenerated in a manner consistent with all modifications.

In a similar way the Agent Assignment and I/O Assignment are semi-independent from other parts of the system and thus if agent and component templates in a library and their Java, C  X  X  , and relay ladder logic implementation, creation of a facility (i.e., an application) that contains agent and component instances populated from this library and specifically configured, creation of a control system by describing all the PLCs, I/O cards, and networks, plus their interconnections, assignment of agents and components to the execution units specified in the control system, and assignment of inputs and outputs of components to real I/O points. Then the ADE can generate and compile the control code and assist the user in downloading the code to the execution units and executing it. 2.3. MAS architecture The agent code generated from ADE is executable by the
Autonomous Cooperative System described in Tichy  X  et al. (2002) . This agent runtime environment is available in both a
C  X  X  version, which allows running the C  X  X  agents on either a PC or a ControlLogix PLC, and the Java version available only for a PC.
Additionally, it is possible to extend the agent code generation engine to support other target multi-agent systems such as JADE (2004) without changing the way that templates of agents and their capabilities are defined within ADE.

The inter-agent communication is based on sending messages compliant with the FIPA-ACL standard, described in FIPA (2000) .
Other important attributes of a message are the information about the conversation protocol that applies to the current message (e.g., FIPA-Request) and the conversation ID that uniquely identifies which context (conversation thread) this message belongs to. This is useful for keeping track of multiple conversations, which might be happening between two agents at the same time following the same protocol.
 For the content language of ACL we use our proprietary Job Description Language (JDL) described in Ma  X  r X   X  k et al. (2005) , with Bit-Efficient encoding. The FIPA messages are encapsulated inside
Common Industrial Protocol (CIP) packets standardized by ODVA (2011) . This encapsulation enables communication on different types of industrial networks, e.g., EtherNet/IP, ControlNet, and DeviceNet.

The agents are grouped into high-level organizational struc-tures called agent platforms. Members of each platform are usually geographically  X  X  X lose X  X   X  for example, they may be run on one computer or PLC, or be located on a local area network. Each platform must provide its agents with the two following
FIPA mandatory services: the Agent Management System (AMS) and Directory Facilitator (DF); see FIPA (2000) .
 Negotiation among agents in our application is based on the
Contract Net protocol described in Smith (1980) . Any member of an agent group can temporarily become a manager that initiates a negotiation process and contacts other agents. When the generate agents for them, but for other runtimes direct changes to the ADE design would be needed.

Despite the fact that ADE generates generic Relay Ladder Logic code as discussed before, most of the other aspects of this code generation are tied to the use of Rockwell Automation X  X  Logix family of controllers. 3. Low-level code generation
To support object-oriented features like instantiation, inheri-tance, or virtuality, all of which are useful for the definition of agents, it is required to enrich the low-level control languages accordingly to enable the definition of the LLC part of the agent template. A major issue is that the LLC code cannot be dynami-cally  X  X  X reated X  X  at runtime in the PLC as are the instances of the
HLC. All the LLC instances have to be generated in advance before deployment in the PLC. This complicates the creation of the LLC template, where the system library designer needs, for example, to iterate over a collection of LLC instances although he/she does not know how many of them will be really created. Additionally, the attribute values of all LLC instances are stored in PLC tags, each of which must have a unique name. For example, a LLC for a valve contains a generic I/O point called close . If there are two valves V1 and V2 , their attributes have to be stored in two different tags, e.g. V1_close and V2_close . Again, it is not known at design time what the actual name of the LLC instance will be; however, there must be support for working with the attributes in the LLC template.

To solve these issues we have developed unique enhance-ments of the IEC 61131-3 that are summarized in the following sections. 3.1. Indirect references
Indirect references represent a technique to access attributes of the LLC templates. A special character  X $ X  is introduced with a notion of this from typical object-oriented (OO) languages. For example, the construct $.close in the valve LLC template is used to make a reference to the close attribute value of this class. If this special character is not used then the user references the close attribute (tag) of common attribute space. This technique is similar to public static variables that are unique and can be accessed by all components. 3.2. Containment
Another technique supported in the LLC definition, which is particularly applicable for hierarchical systems, is the use of containment rules. They allow a designer to specify that a component (e.g., conveyor) contains subcomponent(s) (e.g., motor). The construct $.motor1.run can be used in the LLC of the conveyor to access the run attribute of its subcomponent motor1 . References in the opposite direction, i.e., to a compo-nent X  X  parent, is also possible using the  X  b  X  character. A notation b . ready in the LLC of the motor means the reference to my parent component X  X  (conveyor) ready attribute. A complementary fea-ture is the specification of the default attribute value that is set when the LLC instance is created. 3.3. Macro instructions
Yet another technique is the use of macro instructions that give the system developer the ability to specify basic operations over a collection of components. The macro instruction contains (i) the operation type (e.g., AND, OR), (ii) the definition of the collection of ADE and then reimplemented with improved functionality in the new version of ADE. The application is based on the Reduced
Scale Advanced Demonstrator (RSAD) model, a reconfigurable fluid system test platform. The physical layout is a scaled-down version from a real U.S. Navy ship. 4.1. General CWS application description
The CWS (see Fig. 6 ) consists of 2 chillers, 11 services, and 32 valves that are connected via a water piping system (pipes and pipe connectors called routers). The basic purpose of the CWS is to provide cooling from chillers to services (e.g., sonar) via a redundant system of piping sections.

A service has to be connected to get cooling from a chiller with a path for cold water transportation to the service and with another path for hot water transportation from the service back to the chiller. Hot water needs to be returned to the same chiller to avoid the lack or overflow of water in its limited capacity reservoir, and to avoid large pressure differences in the piping system.

There are a number of other detailed requirements that, for the sake of simplicity, are not described in this manuscript. 4.2. Description of MAS control system for CWS
In the CWS application each chiller, service, and valve has its own agent counterpart. Agents of the type  X  X  X hiller X  X  provide cooling,  X  X  X ervice X  X  agents require cooling, and  X  X  X alve X  X  agents connect or split segments of the water piping system. Agents take actions to dynamically create cooling paths, which enable  X  X  X ervice X  X  agents to stay within their operational temperature range.
Paths are composed of pipe sections connected by opening the relevant valves. Every valve has its own opening price that can change dynamically (as described further), and each chiller has its price for switching on. The total cost of a path is the sum of all the involved agent costs. Since the cooling requirements of different services might differ, they are described with a parameter called  X  X  X oad X  X . In a similar way, chiller agents have a parameter called  X  X  X apacity X  X  that describes the maximum amount of cooling the chiller is able to produce. The  X  X  X apacity X  X  of a chiller limits the number of services that can be cooled simultaneously.
The planning to provide cooling can be generally described as shown in Fig. 7 . The service that requires cooling (SVC) sends a message (arrow marked with 1) to all available chillers (e.g., ACP 1).
There is only one illustrated in Fig. 7 for simplicity; however, there will most likely be more of them and each of them will follow the same message pattern. Each chiller starts the search concurrently for components on the fly even during simulation and save the resulting positions back to ADE. 4.3. CWS control application development remarks
The development process has been performed in cycles. First, a small prototype system was designed, implemented, and tested starting from the definition of agent templates up to the creation of application and simulation agents. Then, in the next cycle, the functionality was enhanced an d tested again and this process continued up to the final additions and full final testing. In this way, the application has been developed efficiently since identifica-tion of problems is narrowed down usually to recent additions only.
It is usually not possible or it can be even dangerous to test the control system being developed on real hardware. Thus, to avoid major problems, especially when the development is in its early stage, it is beneficial to have a simulation of the given hardware available (see Fig. 8 ).

During the main development of the CWS application we used the RSAD CWS test platform, but for early stage development a tabletop hardware simulator was developed and used. For off-site development and for non-real-time testing we developed both a
Matlab/Simulink simulation of the CWS system and the corre-sponding synchronization between simulation and control; see Tichy  X  et al. (2006a) and Vrba et al. (2011) .

The advantage of having the template library in ADE has been utilized in the transfer of the MAS control system between the
RSAD, the tabletop, and Matlab applications. The RSAD and tabletop were not exactly the same from the control point of view, for example, since there were different types of valves used.
But it was possible to easily switch between different ADE component templates to change control behavior for all valves at the same time. Also, it is very easy to add or remove some components if the CWS topology is not the same, which was also true for the RSAD and tabletop systems. 5. Conclusions
The described use of an environment that guides the develop-ment process of MAS has proven to be very valuable from multiple perspectives.

It has provided us with the ability to reuse our work on multiple projects, primarily supported by the library of agents and compo-nents. We can expect that the temp late library can significantly help to develop multiple applications that have common building blocks or that differ only by configuration or by scale.
It helped to speed up development of the control systems since much code is automatically generated.

Debugging and testing time have been shortened since errors from data entry are minimized by requiring the user to only enter any piece of information once.

