 Standard memory-based collaborative filtering algorithms , such as k -nearest neighbor, are quite vulnerable to profile in-jection attacks. Previous work has shown that some model-based techniques are more robust than k -nn. Model abstrac-tion can inhibit certain aspects of an attack, providing an algorithmic approach to minimizing attack effectiveness. I n this paper, we examine the robustness of a recommendation algorithm based on the data mining technique of association rule mining. Our results show that the Apriori algorithm of-fers large improvement in stability and robustness compare d to k -nearest neighbor and other model-based techniques we have studied. Furthermore, our results show that Apriori can achieve comparable recommendation accuracy to k -nn. H.2.8 [ Database Management ]: Database Applications X  data mining ; K.6.5 [ Management of Computing and Information Systems ]: Security and Protection Algorithms, Human Factors, Security Recommender systems, collaborative filtering, associatio n rule mining, data mining, security
Model-based algorithms are widely accepted as a way to alleviate the scaling problem presented by memory-based algorithms in data-intensive commercial recommender sys-tems. Building a model of the dataset allows off-line process -ing for the most rigorous similarity calculations. However ,  X  This work was supported in part by the National Science Foundation Cyber Trust program under Grant IIS-0430303. in some cases, this is at the cost of lower recommendation accuracy [13].

A positive side effect of a model-based approach is that it may provide improved robustness against profile injectio n attacks. A model-based approach is an abstraction of de-tailed user profiles. We hypothesize that this abstraction minimizes the influence of an attack, because attack profiles are not directly used in recommendation.

Previous work has shown the vulnerability of the basic k -nearest neighbor algorithm to attack [10]. Model-based algorithms that cluster similar users have shown different degrees of improvement with respect to robustness. Two successful approaches include k -means clustering and, par-ticularly, probabilistic latent semantic analysis (PLSA) [11].
In this paper we explore the robustness of a recommenda-tion algorithm based on association rule mining. Associati on rule mining is a technique common in data mining that at-tempts to discover patterns of products that are purchased together. These relationships can be used for myriad pur-poses, including marketing, inventory management, etc. We have adapted the Apriori algorithm [1] to collaborative fil-tering in an attempt to discover patterns of items that have common ratings.

The primary contribution of this paper is to demonstrate that an association rule based recommender provides an al-gorithmic approach to robust recommendation. Our imple-mentation shows significant improvement in stability com-pared to the standard memory-based k -nearest neighbor, and achieves comparable accuracy.

Furthermore, experimental results suggest that the asso-ciation rule based recommender is more robust than other model-based techniques we have studied, particularly agai nst non-focused attacks and attack profiles with large numbers of ratings. This provides further evidence that model-base d algorithms are more robust than k -nn.
We assume that an attacker intends to bias a recom-mender system for some economic advantage. This may be in the form of an increased number of recommendations for the attacker X  X  product, or fewer recommendations for a com-petitor X  X  product.

A collaborative recommender database consists of many user profiles, each with assigned ratings to a number of prod-ucts that represent the user X  X  preferences. A malicious use r may insert multiple profiles under false identities designe d to promote or demote the recommendation of a particular item. We call such attacks profile injection attacks (also known as shilling [9]).
Consider an example recommender system that identifies interesting books for a user. The representation of a user profile is a set of product / rating pairs. A rating for a par-ticular book can be in the range 1-5, where 5 is the highest possible rating. Alice, having built a profile from previous visits, returns to the system for new recommendations. Fig-ure 1 shows Alice X  X  profile along with that of seven genuine users.

An attacker, Eve, has inserted three profiles (Attack1-3) into the system to mount an attack promoting the target item, Item6. Each attack profile gives high ratings to Eve X  X  book, labeled Item6. If the attack profiles are constructed such that they are similar to Alice X  X  profile, then Alice will be recommended Eve X  X  book. Even without direct knowledge of Alice X  X  profile, similar attack profiles may be constructe d from average or expected ratings across all users.
Disregarding Eve X  X  attack profiles for a moment, we can compute Alice X  X  predicted preference for Item6. Assuming 1 -nearest neighbor, Alice will not be recommended Item6. The most highly correlated user to Alice is User6, who clearly does not like Item6. Therefore, Alice is expected to dislike Item6.

After Eve X  X  attack, however, Alice receives a very differ-ent recommendation. As a result of including the attack profiles, Alice is most highly correlated to Attack1. In this case, the system predicts Alice will like Item6 because it is rated highly by Attack1. She is given a recommendation for Item6, although it is not the ideal suggestion. Clearly, thi s can have a profound effect on the effectiveness of a recom-mender system. Alice may find the suggestion inappropri-ate, or worse; she may take the system X  X  advice, buy the book, and then be disappointed by the delivered product.
An attack type is an approach to constructing attack pro-files, based on knowledge about the recommender system, its rating database, its products, and/or its users. In a push at -tack, the target item is generally given the maximum allowed rating. The set of filler items represents a group of selected items in the database that are assigned ratings within the attack profile. Attack types can be characterized according to the manner in which they choose filler items, and the way that specific ratings are assigned.

A variety of attack types have been studied for their ef-fectiveness against different recommendation algorithms [ 10, 11]. In this paper, we focus on three attack types that have been shown to be very effective against standard user-based collaborative filtering recommenders.

The random attack is a basic attack type that assigns random ratings to filler items, distributed around the globa l rating mean [9, 10]. The attack is very simple to implement, but has limited effectiveness.

The average attack attempts to mimic general user pref-erences in the system by drawing its ratings from the rating distribution associated with each filler item [9, 10]. An av-erage attack is much more effective than a random attack; however, it requires greater knowledge about the system X  X  rating distribution. In practice, the additional knowledg e cost is minimal. An average attack can be quite successful with a small filler item set, whereas a random attack usually must have a rating for every item in the database in order to be effective.

An attacker may be interested primarily in a particular set of users  X  likely buyers of a product. A segment attack attempts to target a specific group of users who may already be predisposed toward the target item [10]. For example, an attacker that wishes to push a fantasy book might want the product recommended to users expressing interest in Harry Potter and Lord of the Rings . A typical segment attack profile consists of a number of selected items that are likely to be favored by the targeted user segment, in addition to the random filler items. Selected items are expected to be highly rated within the targeted user segment and are assigned the maximum rating value along with the target item.
We first present a collaborative recommendation algorithm based on association rule mining. We next provide back-ground information on several user-based recommenders in-cluded as baseline algorithms. This includes the standard memory-based k -nn and two model-based algorithms that cluster user profiles.
Association rule mining is a common technique for per-forming market basket analysis. The intent is to gain insigh t into customers X  buying habits and discover groups of prod-ucts that are commonly purchased together. As an example, an association rule may show that 98% of all customers that purchase frozen pizza also purchase soda.

Association rules capture relationships among items based on patterns of co-occurrence across transactions. In [12], as-sociation rules were applied to personalization based on we b usage data. We have adapted this approach to the context of collaborative filtering. Considering each user profile as a transaction, it is possible to use the Apriori algorithm [1] and generate association rules for groups of commonly liked items.

Given a set of user profiles U and a set of item sets I = { I 1 , I 2 , . . . , I k } , the support of an item set I i  X  I is defined as  X  ( I i ) = |{ u  X  U : I i  X  u }| / | U | . Item sets that satisfy a minimum support threshold are used to generate association rules. These groups of items are referred to as frequent item sets . An association rule r is an expression of the form X =  X  Y (  X  r ,  X  r ), where X and Y are item sets,  X  r is the support of X  X  Y , and  X  r is the confidence for the rule r given by  X  ( X  X  Y ) / X  ( X ). In addition, association rules that do not satisfy a minimum lift threshold are pruned, where lift is defined as  X  r / X  ( Y ).

If there is not enough support for a particular item, that item will never appear in any frequent item set. The im-plication is that such an item will never be recommended. The issue of coverage is a tradeoff. Lowering the support threshold will ensure that more items can be recommended, but at the risk of recommending an item without sufficient evidence of a pattern.

Before performing association rule mining on a collabora-tive filtering dataset, it is necessary to discretize the rat ing values of each user profile. We first subtract each user X  X  average rating from the ratings in their profile to obtain a zero-mean profile. Next, we give a discrete category of  X  X ike  X  or  X  X islike X  to each rated item in the profile if it X  X  rating value is &gt; or  X  zero, respectively.

Discretizing the dataset effectively doubles the total num-ber of features used in analysis, but is necessary for inferr ing recommendable items. In classic market basket analysis, it is assumed that a customer will not purchase an item they do not like. Hence, a transaction always contains implicit positive ratings. However, when dealing with explicit rat-ing data, certain items may be disliked. It is clear that a collaborative recommender must take such preference into account or risk recommending an item that is rated often, but disliked by consensus.

To make a recommendation for a target user profile u , we create a set of candidate items C such that an association rule r exists of the form X  X  u =  X  i  X  C where i is an unrated item in the profile u . In practice, it is not neces-sary to search every possible association rule given u . It is sufficient to find all frequent item sets X  X  u and base rec-ommendations on the next larger frequent itemsets Y  X  X where Y contains some item i that is unrated in u .
A caveat to this approach is the possibility of conflicting recommendations in the candidate set C . For example, one association rule may add item i to the candidate set with a confidence of 90% whereas another rule may add the same item with a confidence of 5%. In this case, we simply use the rule with the highest confidence.

Another possibility is that one association rule may add item i to the candidate set with a  X  X ike X  label, whereas an-other rule may add the same item with a  X  X islike X  label. There is not an ideal solution in this case, but we have cho-sen to assume that there are opposing forces for the recom-mendation of the item. In our implementation, we subtract the confidence value of the X  X islike X  X abel from the confidenc e value of the  X  X ike X  label.

To facilitate the search for item sets, we store the frequent item sets in a directed acyclic graph, called a Frequent Item-set Graph [12]. The graph is organized into levels from 0 to k , where k is the maximum size among all frequent item sets. Each node at depth d in the graph corresponds to an item set I of size d and is linked to item sets of size d + 1 that contain I . The root node at level 0 corresponds to the empty item set. Each node also stores the support value of the corresponding frequent item set.

Given a target user profile u , we perform a depth-first search of the Frequent Itemset Graph. When we reach a node whose frequent item set I n is not contained in u , the item i  X  I n not found in u is added to the candidate set C and search at the current branch is ceased.

Note that the item set of the parent node I p to I n must be contained in u by definition, and because I n is of size d + 1 where I p is size d , there can be only one item i  X  I n that is not contained in u . It follows that I n = I p  X  X  i } and the two nodes correspond to the rule I p =  X  X  i } . We calculate the confidence of the rule as  X  ( I n ) / X  ( I p ). The candidate i  X  C is stored in a hashtable along with it X  X  confidence value. If i t already exists in the hashtable, the highest confidence valu e takes precedent.

After completion of the depth-first search, all possible can -didates for the target user u are contained in C , including items labeled  X  X islike X . In order to properly represent an estimated negative connotation, items labeled  X  X islike X  a re given a recommendation score that is the negation of the confidence value. If there is a corresponding  X  X ike X  label fo r the item in C , it X  X  recommendation score is decreased by the confidence of the  X  X islike X  label. As a final step, the candi-date set C is sorted according to the recommendation scores and the top N items are returned as a recommendation.
User-based collaborative filtering algorithms attempt to discover a neighborhood of user profiles that are similar to a target user. A rating value is predicted for all missing item s in the target user X  X  profile, based on ratings given to the item within the neighborhood. A ranked list is produced, and typically the top 20 or 50 predictions are returned as a recommendation.
The standard k -nearest neighbor algorithm is widely used and reasonably accurate [3]. Similarity is computed us-ing Pearson X  X  correlation coefficient, and the k most simi-lar users that have rated the target item are selected as the neighborhood. This implies a target user may have a differ-ent neighborhood for each target item. It is also common to filter neighbors with similarity below a specified thresh-old. This prevents predictions being based on very distant or negative correlations. After identifying a neighborhoo d, we use Resnick X  X  algorithm to compute the prediction for a target item i and target user u : where V is the set of k similar neighbors that have rated i ; r v,i is the rating of i for neighbor v ;  X  r u and  X  r average ratings over all rated items for u and v , respectively; and sim u,v is the Pearson correlation between u and v .
A standard model-based collaborative filtering algorithm uses k -means to cluster similar users. Given a set of user profiles, the space can be partitioned into k groups of users that are close to each other based on a measure of similarity. The discovered user clusters are then applied to the user-based neighborhood formation task, rather than individual profiles.

To make a recommendation for a target user u and target item i , we select a neighborhood of user clusters that have a rating for i and whose aggregate profile v k is most similar to u . This neighborhood represents the set of user segments that the target user is most likely to be a member, based on a measure of similarity. For this task, we use Pearson X  X  correlation coefficient. We can now make a prediction for item i as described in the previous section, where the neigh-borhood V is the set of user cluster aggregate profiles most similar to the target user.
Probabilistic latent semantic analysis (PLSA) models [4] provide a probabilistic approach for characterizing laten t or hidden semantic associations among co-occurring objects. In [8, 7] PLSA was applied to the creation of user clusters based on web usage data. We have adapted this approach to the context of collaborative filtering [11].

Given a set of n users, U = { u 1 , u 2 ,  X  X  X  , u n } , and a set of m items, I = { i 1 , i 2 ,  X  X  X  , i m } the PLSA model associates an unobserved factor variable Z = { z 1 , z 2 ,  X  X  X  , z l } with obser-vations in the rating data. For a target user u and a target item i , the following joint probability can be defined: In order to explain a set of ratings ( U, I ), we need to estimate the parameters P r ( z k ), P r ( u | z k ), and P r ( i | z imizing the following likelihood L ( U, I ) of the rating data: where r u,i is the rating of user u for item i .

The Expectation-Maximization (EM) algorithm [2] is used to perform maximum likelihood parameter estimation. Based on initial values of P r ( z k ), P r ( u | z k ), and P r ( i | z rithm alternates between an expectation step and maximiza-tion step. In the expectation step, posterior probabilitie s are computed for latent variables based on current estimates: In the maximization step, Lagrange multipliers [5] are used to obtain the following equations for re-estimated parame-ters: Iterating the expectation and maximization steps monoton-ically increases the total likelihood of the observed data L ( U, I ), until a local optimum is reached.

We now identify clusters of users that have similar under-lying interests. For each latent variable z k , we create a user cluster C k and select all users having probability P r ( u | z exceeding a certain threshold  X  . If a user does not exceed the threshold for any latent variable, it is associated with the user cluster of highest probability. Thus, every user profil e will be associated with at least one user cluster, but may be associated with multiple clusters. This allows authoritat ive users to have broader influence over predictions, without ad -versely affecting coverage in sparse rating data.

To make a recommendation for a target user u and target item i , we select a neighborhood of user clusters that have a rating for i and whose aggregate profile v k is most similar to u . This neighborhood represents the set of user segments that the target user is most likely to be a member, based on a measure of similarity. For this task, we use Pearson X  X  cor-relation coefficient. We can now make a prediction for item i as described in previous sections, where the neighborhood V is the set of user cluster aggregate profiles most similar to the target user.
To evaluate the robustness of our recommendation algo-rithm based on association rule mining, we compare the re-sults of push attacks using different parameters. In each case, we report the relative improvement over the k -nearest neighbor, k -means, and PLSA approaches. In our experiments, we have used the publicly-available ratings on 1682 movies by 943 users. All ratings are integer values between one and five, where one is the lowest (dis-liked) and five is the highest (liked). Our data includes all users who have rated at least 20 movies.

To conduct attack experiments, the full dataset is split into training and test sets. Generally, the test set contain s a sample of 50 user profiles that mirror the overall distribu-tion of users in terms of number of movies seen and ratings provided. The remaining user profiles are designated as the training set. All attack profiles are built from the training set, in isolation from the test set.

The set of attacked items consists of 50 movies whose ratings distribution matches the overall ratings distribu tion of all movies. Each movie is attacked as a separate test, and the results are aggregated. In each case, a number of attack profiles are generated and inserted into the training set, an d any existing rating for the attacked movie in the test set is temporarily removed.

For every profile injection attack, we track attack size and filler size . Attack size is the number of injected attack pro-files, and is measured as a percentage of the pre-attack train -ing set. There are approximately 1000 users in the database, so an attack size of 1% corresponds to about 10 attack pro-files added to the system. Filler size is the number of filler ratings given to a specific attack profile, and is measured as a percentage of the total number of movies. There are approximately 1700 movies in the database, so a filler size of 10% corresponds to about 170 filler ratings in each attack profile. The results reported below represent averages over all combinations of test users and attacked movies.
There has been considerable research on the accuracy and performance of recommender systems [6]. Our overall goal is to measure the effectiveness of an attack; the X  X in X  for the attacker. In the experiments reported below, we measure hit ratio -the average likelihood that a top N recommender will recommend a pushed item, compared to all other items [14].
Hit ratio measures the effectiveness of an attack on a pushed item compared to other items. Let R u be the set of top N recommendations for user u . For each push attack on item i , the value of a recommendation hit for user u de-noted by H ui , can be evaluated as 1 if i  X  R u ; otherwise H ui is evaluated to 0. We define hit ratio as the number of hits across all users in the test set divided by the number of users in the test set. The hit ratio for a pushed item i over all users in a set can be computed as P H ui / | U | . Average hit ratio is calculated as the sum of the hit ratio for each push attack on item i across all pushed items divided by the number of pushed items:
Hit ratio is useful for evaluating the pragmatic effect of a push attack on recommendation. Typically, a user is only interested in the top 20 to 50 recommendations. An attack on an item that significantly raises the hit ratio, regardles s of prediction shift, can be considered effective. Indeed, an attack that causes a pushed item to be recommended 80% of the time has achieved the desired outcome for the attacker.
We first analyze the accuracy of our association rule rec-ommender compared to k -nearest neighbor. To evaluate the recommendations, we performed 10-fold cross-validation o n the entire dataset and no attack profiles were injected.
Determining a suitable evaluation metric was challenging because the two algorithms are based on fundamentally dif-ferent approaches. The k -nn algorithm predicts a rating value for each target item and ranks all items based on this score. However, the association rule algorithm produces a ranked list, such that the recommendation score is the con-fidence that a target user will like the recommended item.
It is not obvious how to directly compare the recommen-dation scores of the two algorithms, because k -nn uses a pre-dicted value and association rules use a confidence measure. It is also not possible to make a prediction of the rating valu e from the association rule recommendation list. However, th e association rule recommender does make a more general pre-diction; it predicts a binary  X  X ike X  or  X  X islike X  classifica tion for a recommended item if the confidence value is positive or negative, respectively.

In order to compare the accuracy of our association rule recommender and k -nn, we transform both recommendation lists into binary  X  X ike X  and  X  X islike X  categories for each i tem. For the association rule recommender, it is simply a matter of using the sign of the confidence value, as discussed in the previous paragraph. For k -nn, we categorize an item as
Figure 2: Average attack hit ratio at 5% filler size  X  X ike X  if the predicted rating is greater than the user X  X  mea n rating, and  X  X islike X  otherwise.

It is now possible to compare the accuracy of the two algorithms. We use the normalized mean absolute error (NMAE) metric. For the Apriori algorithm, we use a min-imum support of 0.1 and a maximum of 6000 rules with the greatest lift. In neighborhood formation for k -nn, we achieved optimal results using k = 20 users.

As shown in Table 1, the difference in accuracy between the association rule recommender and k -nn is statistically insignificant. This is a very promising result, as the scala-bility of model-based algorithms often come at the cost of lower recommendation accuracy [13].

Because Apriori selects recommendations from only among those item sets that have met the support threshold, it will by necessity have lower coverage than our baseline algo-rithms. There will be some items that do not appear in the Frequent Itemset Graph, and about which the algorithm cannot make any predictions. This problem may occur in a k -nn algorithm as well, since there may be no peer users who have rated a given item. However, this is a relatively rare occurrence as Table 2 shows. We see that the coverage of the k -nn algorithm is near 100%, while Apriori is consis-tently around 47%.

The Apriori algorithm would therefore lend itself best to scenarios in which a list of top recommended items is sought, rather than a rating prediction scenario in which the rec-ommender must be able to estimate a rating for any given item. The selectivity of the algorithm may be one reason to expect it will be relatively robust -it will not make rec-ommendations without evidence that meets the minimum support threshold.
To evaluate the robustness of our association rule recom-mender, we compare the results of push attacks on k -nearest neighbor, k -means clustering, and PLSA.
Figure 2 presents hit ratio results for top 10 recommenda-tions at different attack sizes, using a 5% filler. All model-based techniques show notable improvement in stability ove r k -nn. However, the performance of Apriori and PLSA are superior to k -means at large attack sizes. Under a 15% at-Figure 3: Average attack hit ratio at 2% attack size tack, an attacked movie is almost guaranteed to be in a user X  X  top 10 recommended list for k -nn and will be in the top 10 list over 60% of the time for k -means. However, the attacked movie only shows up in a user X  X  top 10 recommen-dations slightly greater than 5% of the time for Apriori or PLSA.

Robustness of the Apriori algorithm may be partially due to lower coverage. However, this does not account for the flat trend of hit ratio with respect to attack size. At a 5% attack, we observed only 26% coverage of the attacked item. But at a 10% attack, we observed 50% coverage, and at 15% attack, we observed a full 100% coverage of the attacked item.
It is precisely the manner in which an average attack chooses filler item ratings that causes the combination of multiple attack profiles to short-circuit the attack. Recal l that filler item ratings in an average attack are distributed around their mean rating. When an average attack profile is discretized, there is equal probability that a filler item will be categorized as  X  X ike X  or  X  X islike X . Therefore, mult iple attack profiles will show little more than chance probabilit y of having common itemsets. The lack of mutual reinforce-ment between filler items prevents the support of itemsets containing the attacked item from surpassing the threshold .
To evaluate the sensitivity of filler size, we have tested a full range of filler items. The 100% filler is included as a benchmark for the potential influence of an attack. How-ever, it is not likely to be practical from an attacker X  X  poin t of view. Collaborative filtering rating databases are often extremely sparse, so attack profiles that have rated every product are quite conspicuous [15]. Of particular interest are smaller filler sizes. An attack that performs well with few filler items is less likely to be detected. Thus, an attack er will have a better chance of actually impacting a system X  X  recommendation, even if the performance of the attack is not optimal.

Figure 3 depicts hit ratio for top 10 recommendations at the full range of filler sizes with a 2% attack size. Surpris-ingly, as filler size is increased, hit ratio for standard k -nn goes down. This is because an attack profile with many filler items has greater probability of being dissimilar to the ac-tive user. On the contrary, hit ratio for k -means and PLSA tend to rise with larger filler sizes. Eventually, both algo-rithms are surpassed by k -nn and actually perform worse with respect to robustness.
 Figure 4: Segment attack hit ratio at 5% filler size
Only the Apriori algorithm holds steady at large filler sizes and is essentially unaffected. As with attack size, the rea-son that filler size does not affect the robustness of the algo-rithm is because adding more filler items does not change the probability that multiple attack profiles will have common itemsets. The fact that a profile X  X  ratings are discretized t o categories of  X  X ike X  and  X  X islike X  means that an attack pro-file with 100% filler size will cover exactly half of the total features used in generating frequent itemsets. Therefore, it is very unlikely that multiple attack profiles will result in mutual reinforcement.

We have shown results for average attack because it is more effective than random or bandwagon attacks; however, Apriori has also exhibited improved robustness compared to the other algorithms against these attacks. We next present results for segment attack.
The segment attack is designed to have particular impact on likely buyers, or  X  X n-segment X  users. These users have shown a disposition towards items with particular charac-teristics, such as movies within a particular genre. For our experiments, we selected popular horror movies (Alien, Psy -cho, The Shining, Jaws, and The Birds) and identified users who had rated all of them as 4 or 5. This is an ideal target market to promote other horror movies, and so we measure the impact of the attack on recommendations made to the in-segment users.

Figure 4 depicts hit ratio for top 10 recommendations at different attack sizes, using a 5% filler. Clearly, the attack is extremely effective against the k -nn algorithm. A meager 1% attack shows a hit ratio of nearly 80%. By contrast, a segment attack has little effect on k -means and PLSA.
The Apriori algorithm appears to have the same robust-ness as the other model-based algorithms at small attack sizes. However, beyond a 5% attack, Apriori performs quite poorly with respect to robustness. Hit ratio reaches 100% at a 15% attack. The cause of such dramatic effect is precise targeting of selected items by the attacker. This is the op-posing force to the phenomena witnessed against an average attack. A segment attack profile consists of multiple select ed items, in addition to the target item, where the maximum rating is assigned. Clearly, all such items will always be categorized as  X  X ike X . Therefore, the mutual reinforcemen t of common item sets is a given, and a user that likes any permutation of the selected items receives the attacked ite m as a recommendation with high confidence.

Although the performance of Apriori is not ideal against a segment attack, certain scenarios may minimize the per-formance degradation in practice. In particular, a recom-mender system with a very large number of users is some-what buffered from attack. The algorithm is quite robust through a 5% attack, and is comparable to both k -means and PLSA. The robustness of Apriori is not drastically re-duced until attack size is 10% or greater. Certainly it is feasible for an attacker to inject the necessary number of profiles into a recommender with a small number of users, but it may not be economical for a commercial recommender such as Amazon.com, with millions of users.
The standard user-based collaborative filtering algorithm has been shown quite vulnerable to profile injection attacks . An attacker is able to bias recommendation by building a number of profiles associated with fictitious identities. In this paper, we have demonstrated the relative robustness and stability of model-based algorithms over the memory-based approach. In particular, we have introduced a robust recommendation algorithm based on association rule mining that attempts to capture relationships among items based on patterns of co-occurrence across user profiles.
Frequent item sets are generated for the association rules by first discretizing all user profiles such that an item ratin g is classified as  X  X ike X  or  X  X islike X . This level of abstracti on from the original user profiles acts to short-circuit the mu-tual reinforcement property found in average and random attacks. It allows the algorithm to make recommendations that are relatively accurate, while removing much of the in-fluence of biased attack profiles.

Overall, the association rule recommender far outperforms the standard k -nearest neighbor algorithm with respect to robustness. However, it is not robust against a segment at-tack compared to other model-based algorithms. This issue is slightly offset because a segment attack must be relativel y large before having an effect on the algorithm. It is un-likely that a malicious user could mount a successful segmen t attack against a commercial recommender with millions of users.

Future work will study in greater detail the mutual re-inforcement of common item sets. We will attempt to dis-cover the ideal attack size threshold necessary for mountin g a successful segment attack against the association rule re c-ommender. In addition, we will design an extension to the algorithm that is suitable for recommender systems with a small number of users. We will also compare the accuracy of Apriori with k -nn at lower coverage levels. This might be accomplished by filtering out weak recommendations or weak neighbors in the k -nn algorithm, for example. [1] R. Agrawal and R. Srikant. Fast algorithms for mining [2] A. Dempster, N. Laird, and D. Rubin. Maximum [3] J. Herlocker, J. Konstan, A. Borchers, and J. Riedl. [4] T. Hofmann. Probabilistic latent semantic analysis. In [5] T. Hofmann. Unsupervised learning by probabilistic [6] J.Herlocker, J. Konstan, L. G. Tervin, and J. Riedl. [7] X. Jin, Y. Zhou, and B. Mobasher. A unified approach [8] X. Jin, Y. Zhou, and B. Mobasher. Web usage mining [9] S. Lam and J. Riedl. Shilling recommender systems for [10] B. Mobasher, R. Burke, R. Bhaumik, and C. Williams. [11] B. Mobasher, R. Burke, and J. Sandvig. Model-based [12] M. Nakagawa and B. Mobasher. A hybrid web [13] M. O X  X onner and J. Herlocker. Clustering items for [14] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl. [15] C. Williams, R. Bhaumik, R. Burke, and
