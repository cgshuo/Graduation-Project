 INRIA -Universit  X  eParis7 LIFO -Universit  X  ed X  X rl  X  eans CNRS -LORIA, Nancy LIPN -Universit  X  eParisNord LIFO -Universit  X  ed X  X rl  X  eans
In this article, we introduce eXtensible MetaGrammar (XMG), a framework for specifying tree-based grammars such as Feature-Based Lexicalized Tree-Adjoining Grammars (FB-LTAG) and Interaction Grammars (IG). We argue that XMG displays three features that facilitate both grammar writing and a fast prototyping of tree-based grammars. Firstly, XMG is fully from the procedural lexical rules often used to specify tree-based grammars. Secondly, the XMG how this architecture naturally supports the design of three linguistic formalisms, namely,
FB-LTAG, IG, and Multi-Component Tree-Adjoining Grammar (MC-TAG). We further show how it permits a straightforward integration of additional mechanisms such as linguistic and of XMG, we describe the methodology used to specify an FB-LTAG for French augmented with a unification-based compositional semantics. This illustrates both how XMG facilitates the modeling of the tree fragment hierarchies required to specify tree-based grammars and of a syntax/semantics interface between semantic representations and syntactic trees. Finally, we briefly report on several grammars for French, English, and German that were implemented using XMG and compare XMG with other existing grammar specification frameworks for tree-based grammars. 1. Introduction
In the late 1980s and early 1990s, many grammar engineering environments were developed to support the specification of large computational grammars for natural language. One may, for instance, cite XLE (Kaplan and Newman 1997) for specifying
Lexical-Functional Grammars (LFG), LKB (Copestake and Flickinger 2000) for speci-fying Head-driven Phrase Structure Grammars (HPSG), and D et al. 2007) for specifying Combinatory Categorial Grammars (CCG). Concretely, such environments usually rely on (i) a formal language used to describe a target com-putational grammar, and (ii) a processor for this language, which aims at generating a parser).
 share a number of features. Firstly, they are expressive enough to characterize subsets
Secondly, they are notationally expressive enough to relatively easily formalize important theoretical notions. Thirdly, they are rigorous , that is, the semantics of their underlying language is well defined and understood. Additionally, for an environment to be useful in practice, it should be simple to use (by a linguist), and make it possible to detect errors in the described target grammar.
 grammars X  X hat is, grammars where the basic units are trees (or tree descriptions) of arbitrary depth, such as Tree-Adjoining Grammar (TAG; Joshi, Levy, and Takahashi 1975), D-Tree Grammar (DTG; Rambow, Vijay-Shanker, and Weir 1995), Tree Description
Grammars (TDG; Kallmeyer 1999) or Interaction Grammars (IG; Perrier 2000) X  environments sharing all of the listed features are lacking. As we shall see in Section 7 of this article, there have been some proposals for grammar engineering environments for tree-based grammar (e.g., Candito 1996; Xia, Palmer, and Vijay-Shanker 1999, formalisms offer an extended domain of locality where one can encode constraints giving a modular and incremental specification of the grammar, one needs a high level Section 4).
 specifying tree-based grammars. Focusing mostly on Feature-Based Lexicalized Tree-Adjoining Grammars (FB-LTAG) (but using Interaction Grammars [IG] and Multi-Component Tree-Adjoining Grammars [MC-TAG] to illustrate flexibility), we argue that
XMG departs from other existing computational frameworks for designing tree-based grammars in three main ways: 592 to FB-LTAG, the grammar formalism we used to illustrate most of XMG X  X  features. The next three sections then go on to discuss and illustrate XMG X  X  three main features X  on declarativity and show how XMG X  X  generalized disjunction permits a declarative encoding of diathesis. We then contrast the XMG approach with the procedural methods previously resorted to for specifying FB-LTAG. Section 4 addresses notational expressiv-ity. We present the syntax of XMG and show how the sophisticated identifier handling and (ii) of the unification-based syntax/semantics interface often used in FB-LTAG. In
Section 5, we concentrate on extensibility. We first describe the operational semantics of XMG and the architecture of the XMG compiler. We then show how these facilitate the adaptation of the basic XMG language to (i) different grammar formalisms (IG, dimensions. In Section 6, we illustrate the usage of XMG by presenting an XMG specification for the verbal fragment of a large scale FB-LTAG for French augmented based grammars implemented using XMG. Section 7 discusses the limitations of other approaches to the formal specification of tree-based grammars, and Section 8 concludes with pointers for further research. 2. Tree-Adjoining Grammar trees and of two tree composition operations, namely, substitution and adjunction.
Initial trees are trees whose leaves are either substitution nodes (marked with terminal symbols (words). Auxiliary trees are distinguished by a foot node (marked with ) whose category must be the same as that of the root node. Substitution inserts a tree onto a substitution node of some other tree and adjunction inserts an auxiliary tree into a tree. Figure 1 shows a toy TAG generating the sentence Marie a vu Jean  X  X ary has seen John X  and sketches its derivation. 1 ized FB-LTAG (Vijay-Shanker and Joshi 1988). A lexicalized TAG is such that each an FB-LTAG, tree nodes are additionally decorated with two feature structures (called top and bottom). These feature structures are unified during derivation as follows. On substitution, the top features of the substitution node are unified with the top features of the root node of the tree being substituted in. On adjunction, the top features of the root of the auxiliary tree are unified with the top features of the node where adjunction takes place; and the bottom features of the foot node of the auxiliary tree are unified with the bottom features of the node where adjunction takes place. At the end of a derivation, the top and bottom feature structures of all nodes in the derived tree are unified.
Implementation of Tree-Adjoining Grammars. Most existing implementations of TAGs fol-low the three-layer architecture adopted for the X TAG grammar (XTAG Research Group 2001), a feature-based lexicalized TAG for English. Thus the grammar consists of (i) a set of so-called tree schemas (i.e., elementary trees having a leaf node labeled with a referring to where to anchor lexical items 2 ), (ii) a morphological lexicon associating words with lemmas, and (iii) a syntactic lexicon associating lemmas with tree schemas with transitive verbs in the X TAG grammar. The tree corresponds (a) to a declarative sentence, (b) to a WH-question on the subject, (c) to a passive clause with a BY-agent, and (d) to a passive clause with a WH-object. As can be seen, each tree schema contains an anchor node (marked with ). During parsing this anchor node can be replaced by any word morphologically related to a lemma listed in the syntactic lexicon as anchor-ing the transitive tree family.
 between words having common syntactic properties (e.g., sub-categorization frames).
There still remains a large redundancy within the grammar because many elementary tree schemas share common subtrees (large coverage TAGs usually consist of hun-dreds, sometimes thousands, of tree schemas). An important issue when specifying 594 (a) (b) (c) (d) such grammars is thus structure sharing. Being able to share structural information is necessary not only for a faster grammar development, but also for an easier grammar maintenance (modifications to be applied to the tree schemas would be restricted to shared structures). In the next section, we will see how XMG declarativity can be efficiently used to factorize TAGs. In addition, Section 4 will show how XMG notational expressivity facilitates the specification of another commonly used tree sharing device, namely, inheritance hierarchies of tree fragments.

Extending TAG with a Unification-Based Semantics. To extend FB-LTAG with a compo-sitional semantics, Gardent and Kallmeyer (2003) propose to associate each elementary tree with a flat semantic representation. For instance, in Figure 3, the trees and often are associated with the semantics l 0 :name(j,john) respectively. Importantly, the arguments of semantic functors are represented by uni-fication variables which occur both in the semantic representation of this functor and on some nodes of the associated syntactic tree. Thus in Figure 3, the semantic index s occurring in the semantic representation of runs also occurs on the subject substitution node of the associated elementary tree. The value of semantic arguments is then deter-mined by the unifications resulting from adjunction and substitution. For instance, the semantic index s inthetreefor runs is unified during substitution with the semantic index j labeling the root node of the tree for John . As a result, the semantics of John often nomena (Kallmeyer and Romero 2004a, 2004b, 2008). Its implementation, however, semantic formulae while allowing for shared variables between trees and formulae. In the following sections, we will show how XMG notational expressivity makes it pos-sible to specify an FB-LTAG equipped with a unification-based semantics. 3. Declarativity
In this section, we show how a phenomenon which is often handled in a procedural way by existing approaches can be provided with a declarative specification in XMG.
Concretely, we show how XMG supports a declarative account of diathesis that avoids lexical rule approach. We then contrast it with the XMG account. 3.1 Capturing Diathesis Using Lexical Rules
Following Flickinger (1987), redundancy among grammatical descriptions is often han-the inheritance hierarchy permits us to encode the sharing of common substructures, lexical rules (sometimes called meta-rules) permit us to capture relationships between trees by deriving new trees from already specified ones. For instance, passive trees will be derived from active ones.
 approaches have been put forward for FB-LTAG (Vijay-Shanker and Schabes 1992;
Becker 1993; Evans, Gazdar, and Weir 1995; XTAG Research Group 2001). One important drawback of these approaches, however, is that they are procedural in that the order in in Figure 2. In the meta-rule representation scheme adopted by Becker (1993), the base the derived trees (b, c, d) would be generated by applying one or more meta-rules on this base tree. Figure 4 sketches these meta-rules. The left-hand side of the meta-rule is a matching pattern replaced with the right-hand side of the meta-rule in the newly generated tree. Symbol  X ? X  denotes a meta-variable whose matching subtree in the input is substituted in place of the variable in the output tree. Given these, the tree family in
Figure 2 is generated as follows: (b) and (c) are generated by application to the base tree (a) of the Wh-Subject and Passive meta-rules, respectively. Further, (d) is generated by applying first, the Wh-Subject meta-rule and second, the Passive meta-rule to the base tree. 596 generates a new tree instance by adding, suppressing (hence possibly substituting) however, there is no guarantee that the trees they derive are linguistically appropriate and that the derivation process terminates. Thus, to ensure termination and consistency,
Prolo needs to additionally provide rule ordering schemes (expressed as automata). 3.2 XMG: Capturing Diathesis Using Disjunction
XMG provides an alternative account for describing tree sets such as that of Figure 2 without lexical rules and without the related ordering constraints. In essence, the approach consists of enumerating trees by combining tree fragments using conjunction and disjunction.
 some of the tree fragments sketched in Figure 5 using the following conjunctions and disjunctions: 4
TransitiveVerb family as a disjunction of the two verb forms (passive or active). In sum, conjunctions of tree fragments.
 ad hoc meta-rules are needed, for a unified tree transformation cannot be defined. In done relatively easily. Let us imagine that we now want to extend the trees of Figure 2 with feature equations for subject X  X umber agreement. We can for instance do so by defining the following tree fragment (the dashed line indicates that the VP node can be a descendant, not only a daughter, of the S node): 5 define the elementary fragments Wh-NP-Object and Wh-By-Object (see Figure 5), and then define the following additional combinations: 6
PassiveTransitiveVerb  X  CanonicalSubject  X  PassiveVerb  X  Wh-By-Object (7) 598 grammatical description based on two arguments: (i) morphology is irregular and has to be handled by a non-monotonic device and (ii) erasing rules such as the agentless passive ( John eats an apple / An apple is eaten ) are needed to erase an argument from the canonical base tree. Neither of these arguments holds here, however: The first argument because we describe tree schema hence lexical and morphological issues are ruled out; the second because agentless passive and, more generally, argument erasing constructions can simply be defined by an additional clause such as: an adequate level of control on the structures being described while avoiding having to deal with ordering and termination issues. It facilitates grammar design and mainte-nance, by providing an abstract view on grammar trees, uniquely made of monotonic (no information removal) combinations of tree fragments. 4. Notational Expressivity
We now focus on notational expressivity and show how XMG supports a direct encoding of (i) distinct linguistic dimensions (here syntax, semantics and the syntax/ semantics interface) and (ii) the various types of coreferences opment of tree-based grammars.

Content :: = SYN, SEM, DYN | Name | Content  X  Content | Content DYN :: = f 1 :v 1 ,...,f n :v n (13) variables over class names; x i , x ,and y are variables ranging over tree nodes or feature values; n i refer to node variables; f , f i are features and v , v cates, and predicate arguments in flat semantic formulae, respectively. associate a node variable with some feature constraint. ( ) are used to associate a node variable with some property constraint (e.g., node colors, see Section 5). c a property constraint and a property constraint value, respectively. C variable declared in class C i and = is unification;  X  and immediate dominance relations between nodes. Finally, + , transitive-reflexive closure of a relation, respectively.
 combine. The next three clauses define the languages supported for describing three lin-guistic dimensions, namely, syntax ( SYN ), semantics ( SEM ), and the syntax/semantics interface (called DYN for dynamic interface). We now discuss each of these in more detail starting bottom X  X p with the three linguistic dimensions and ending with the control language that permits us to combine basic linguistic units into bigger ones.
SYN. The XMG formalism for syntax (copied here for convenience) is a tree description logic similar to that proposed by Vijay-Shanker and Schabes (1992) and Rogers and Vijay-Shanker (1994) to describe tree-based grammars.

SYN :: = n 1  X  n 2 | n 1  X  + n 2 | n 1  X   X  n 2 | n 1  X  n 2
Tree node variables can be related by equality (node identification), precedence (imme-diate or non-immediate), and dominance (immediate or non-immediate). Tree nodes pairs where feature values are either variables, constants (e.g., syntactic category), or non-recursive feature structure (e.g., top and bottom feature structures). tree fragments: The depicted tree fragment is a model satisfying the given formula. and negative node markings. Concretely, node constraints are attribute-value matri-ces, which contain information to be used when solving tree descriptions to produce node annotations in FB-LTAG (foot node, substitution node, null-adjunction, etc.). Such annotations can be used as node constraints to allow the description solver to apply well-formedness constraints (e.g., there is at most one foot node).
 which permits us to identify variables across classes in cases where name sharing cannot be resorted to. When a variable y is declared in a class C , the latter being instantiated within a class D , y can be accessed from D by C . y (the identifier y still being available in D  X  X  namespace). 600
SEM. The semantic dimension supports a direct encoding of the flat semantic formulae used by Gardent and Kallmeyer (2003): where l i : p ( E 1 ,..., E n ) represents a predicate p with label l l  X  h ments E i ) can refer to semantic holes, constants (atomic values), or unification variables (written x , y hereafter).
 meaning of the sentence  X  X very dog chases a cat X : l
This formula denotes the following two first-order logic formulae, thereby describing the two possibles readings of this sentence. 9
DYN. The DYN dimension generalizes Kinyon X  X  hypertag (Kinyon 2000) which is unified whenever two tree fragments are combined. Similarly, in XMG the DYN dimension is a feature structure that is unified whenever two XMG classes are com-bined through inheritance or through conjunction (see the discussion on XMG control language, subsequently).
 occurring in the syntactic dimension and the argument X occurring in the semantic dimension ( index subject and arg 1 are feature names, and E , I , X ,and V local unification variables).

More generally, the DYN dimension permits us to unify nodes and feature values that belong to distinct classes and dimensions, and are thus often not related within the inheritance hierarchy. As we shall see in Section 6, the DYN dimension permits a modular account of the syntax/semantics interface in which linking constraints can be stipulated separately and reused to specify the various diatheses.
 in some other classes of the metagrammar. This concept of scope extension can be compared with that of hook in Copestake, Lascarides, and Flickinger (2001).
Control language. The linguistic units (named Content here) defined by the linguist can be abstracted and combined as follows:
Content :: = SYN, SEM, DYN | Name | Content  X  Content | Content
The first clause states that the linguistic information encoded in Content is abstracted in a class named Name and that this class inherits classes C x statements extend the scope of a variable to all sub-classes, however. An exported variable can also be accessed from outside its class in case of class instantiation (using
XMG class consists of a syntactic, a semantic, and a dynamic description (each of them possibly empty), and that XMG classes can be combined by conjunction and disjunc-tion and reused through class instantiation. The notation SYN, SEM, DYN represents simultaneous contributions (possibly empty) to all three dimensions. based grammars (Vijay-Shanker and Schabes 1992; Xia et al. 1998; Candito 1999) in two main ways. First, it supports generalized conjunctions and disjunctions of diathesis.
 common way to share structure within a tree-based grammar is to define an inheritance hierarchy of either tree fragments (Evans, Gazdar, and Weir 1995) or tree descriptions (Vijay-Shanker and Schabes 1992; Candito 1996; Xia 2001). When considering an FB-
LTAG augmented with unification semantics, the hierarchy will additionally contain semantic representations and/or tuples made of tree fragments and semantic represen-tations. In all cases, the question arises of how to handle identifiers across classes and, more specifically, how to share them.
 multiple occurrences of the same node constant refer to the same node. As pointed out in Gardent and Parmentier (2006), global names have several non-trivial shortcomings.
First, they complicate grammar writing in that the grammar writer must remember the names used and their intended interpretation. Second, they fail to support multiple uses of the same class within one class. For instance, in French, some verbs sub-categorize for two prepositional phrases (PP). A natural way of deriving the tree for such verbs would be to combine a verbal tree fragment with two instances of a PP fragment. If, appropriate tree. 11 (1992), where each tree description can be associated with a set of declared node variables and subsets of these node variables can be referred to by descriptions in the 602 hierarchy that inherit from the description in which these node variables were declared.
For instance, if entity A in the hierarchy declares such a special node variable X and B inherits from A , then X can be referred to in B using the notation A . X . class B inherits from class A and class A exports variable X , then X is visible in B these inherited classes export the same variable name X , then X is not directly visible from B . It can be accessed though using the dot operator. First A is identified with a by A .
 as for prefixed variables X  X hat is, variables that are prefixed (using the dot operator) troduced by global names are avoided while providing enough expressivity to handle variable coreference (via the definition of variable namespaces). Section 6 will further illustrate the use of the various coreference devices made available by XMG showing how they concretely facilitate grammar writing.

Recall that we define the trees of Figure 2 as the conjunctions and disjunctions of some tree fragments of Figure 5, such as:
CanonicalSubject can be defined as a tree description formula as follows (only variables n 2 and n 3 are exported):
CanonicalSubject n
The class Wh-NP-Subject is defined accordingly (i.e., by means of a slightly more complex tree description formula using the n 2 and n the nodes involved in subject agreement). The class SubjAgreement is defined slightly differently (we do not impose any tree relation between the node concerned with number agreement): We can then explicitly control the way the fragments combine as follows: given syntactic nodes to be labeled with feature structures defined somewhere else in the metagrammar. We use XMG X  X  flexible management of variable scope to deal with node coreference. Compared with previous approaches on metagrammars such as those of Candito (1996), Xia (2001), having the possibility of handling neither only global nor only local variables, offers a high level of expressivity along with a precise control on the structures being described. 5. Extensibility
A third distinguishing feature of XMG is extensibility. XMG is extensible in that (i) dimensions can be added and (ii) each dimension can be associated with its own interpreter. In order to support an arbitrary number of dimensions, XMG relies on a device permitting the accumulation of an arbitrary number of types of literals, namely,
Extensible Definite Clause Grammar ( EDCG ) (Van Roy 1990). Once literals are accumu-lated according to their type (i.e., each type of literals is accumulated separately), they compute models satisfying the accumulated formulas.
 levels of language (not only syntax, but also semantics and potentially morphology, etc.), and (ii) to define linguistic principles (well-formedness constraints to be applied on the structures being described). These principles depend either on the dimension (e.g., scope constraints in flat semantics), the target formalism (e.g. cooccurrence predicate-arguments in FB-LTAG), or the natural language (e.g., clitic ordering in Romance lan-guages) being described.
 from each other introducing EDCG (Section 5.1). We then summarize the architecture of the XMG system (Section 5.2). We finally show how different solvers can be used to implement various constraints on each of these dimensions (Section 5.3). In partic-ular, we discuss three kinds of extensions implemented in XMG: extension to several grammar formalisms, integration of explicit linguistic generalizations, and inclusion of color-based node marking to facilitate grammar writing. 5.1 XMG: Accumulating and Interpreting an Arbitrary Number of Descriptions
Accumulating (tree) descriptions. First, let us notice that XMG is nothing other than a logic language ` ala Prolog (Duchier, Parmentier, and Petitjean 2012). More precisely, an XMG 604 specification is a collection of Horn clauses, which contribute a declarative description of what a computational tree grammar is.

SYN , SEM , DYN . An XMG class can thus describe, in a non-exclusive way, any of these three levels of description. If one wants to add another level of description (i.e., another dimension), one needs to extend the arity of this tuple. Before discussing this, let us first see how such tuples are processed by XMG.

A common way to represent Horn clauses is by using Definite Clause Grammar (
DCG ) (Pereira and Warren 1980). Concretely, a DCG is a rewriting system (namely, a context-free grammar), where the symbols of the rewriting rules are equipped with (Blackburn, Bos, and Striegnitz 2006, page 100). As an illustration, consider the follow-ing toy example. s(X,[]) where X is a unification variable to be bound with lists of facts (these being the sentences belonging to the string language). As we can easily see, this language contains the sentences  X  X  cat eats, X   X  X he cat eats, X   X  X  mouse eats, X   X  X he mouse eats, X   X  X  cat eats a mouse, X   X  X  mouse eats a cat, X  and so on.
 tions of syntactic fragments given in relations (1) X (4) can be rewritten as as follows: tical heads and conjunctions (e.g., activeTransitiveVerb ) to a clause body. tuples of descriptions. In other words, the DCG clause whose head is adequate descriptions, these can contain unification variables, whose scope is by default local to the clause): instead of compiling XMG classes into a DCG whose accumulator stores tuples with a fixed arity, these classes are compiled into an EDCG (Van Roy 1990).
 with multiple accumulators. In XMG, each dimension is thus allocated a dedicated accumulator in the underlying EDCG .
 dimensions may nevertheless share information either via local unification variables ables (in case of class instantiation or inheritance), or via the shared unification variables supported by the DYN dimension.
 (i.e., for each class name to be valuated), a list of description formulas per accumulator. number of dimensions, and consequently of accumulators):
Each element (i.e., list Li ) of such a tuple is a complete description of a given dimension, where shared variables have been unified (via unification with backtracking).
Solving (tree) descriptions. As illustrated earlier, interpreting XMG X  X  control language in terms of an EDCG yields tuples whose arity is the number of dimensions defined by the linguist, that is, triples of the form SYN , SEM , DYN if syntax, semantics, and the dynamic interface are described.
 minimal models M D = S D ( d D ) satisfying the description ( d words, each dimension is interpreted separately by a specific solver. For instance, the syntactic dimension is handled by a tree description solver that produces, for a given tree description, the set of trees satisfying that description, whereas the solver for the semantic dimension simply outputs the flat semantic representation (list of semantic literals) built by the EDCG through accumulation.
 may nonetheless be coupled through shared variables. In that case, these variables can constrain the models computed by the respective solvers. For instance, shared variables can be used for the syntactic tree description solver to be parametrized by some value coming from the semantic input description. Note that the output of the solving process is a Cartesian product of the sets of minimal models of each solver. As a consequence, the worst case complexity of metagrammar compilation is that of the various solvers associated with relevant dimensions.
 approach used in XMG permits us to modularize a given solver by combining different the description of a given dimension. For instance, for the syntactic dimension of an compiler are trees, and that these conform to the FB-LTAG formalism (e.g., there is no tree having two foot nodes). 606 5.2 Architecture The XMG compiler 14 consists of the following three modules: can be added by specifying additional dedicated accumulators to the underlying
The second part is a unification engine that interprets EDCG unification and polarized unification (i.e., unification of polarized feature structures, as defined by Perrier [2000], and discussed in Section 5.3.1). This extended unification is the reason why XMG does not merely recourse to an existing Prolog engine to process EDCG , but relies on a specific VM instead.
 plugged in depending on the requirements set by the dimensions used, and the chosen grammatical framework. For instance, the SYN dimension is solved in terms of tree models, and the SEM dimension is solved in terms of underspecified flat semantic formulae (i.e., the input semantics remains untouched modulo the unification of its shared variables).

XMG specification for an FB-LTAG using linguistic principles such as those defined in the next section (i.e., clitic ordering principle) or not. 5.3 Three Extensions of XMG
We now show (i) how the modular architecture of the XMG compiler permits us extended to enforce language specific constraints on the syntactic trees; and (iii) how additional formal constraints (namely node marking) can be integrated to simplify node identifications (and consequently grammar writing). 5.3.1 TAG, MC-TAG, and IG: Producing Trees, Tree Sets, or Tree Descriptions. XMG in-tion logic formulae built on the language SYN introduced in Section 4. This solver integrates the dominance solving technique proposed by Duchier and Niehren (2000) and can be summarized as follows. A minimal tree model is described in terms of of node ids (i.e., sets of integers) Down n , Up n , Left node ids.
 from the input formula (built on the tree description language introduced in Section 4) into constraints on the sets of node ids that must hold in a valid model. For instance, the sub-formula n 1  X  + n 2 , which states that node n translated into: where 15 EqDown x = Eq x Down x for x  X  X  n 1 , n 2 } . In other words, in a valid minimal tree model, the set of nodes below or equal to n 1 is included in the set of nodes (strictly) on the left of n 2 , the set of nodes below or equal to n (strictly) on the right of n 1 , the set of nodes on the right of n nodes on the right of n 1 , and finally the set of nodes on the left of n set of nodes on the left of n 2 .
 set of consistent partitions. Finally, the nodes of the models are obtained by considering nodes with distinct Eq n . 608
FB-LTAG trees. To support the specification of FB-LTAG trees, the XMG compiler extends the generic tree solver described here with a set of constraints ensuring that the trees are well-formed TAG trees. In effect, these constraints require the trees to be linear ordered trees with appropriate decorations. Each node must be labeled with a syntactic category.
Leaf nodes are either terminal, foot, or substitution nodes. There is at most one foot node per tree and the category of the foot node must be identical to that of the root node. Finally, each tree must have at least one leaf node that is an anchor.
MCTAG tree sets. Where FB-LTAG consists of trees, MC-TAG (Weir 1988) consists of sets of trees. To support the specification of MC-TAG, the sole extension needed concerns node variables that are not dominated by any other node variable in the tree description.
Whereas for FB-LTAG, these are taken to denote either the same root node or nodes that are connected to some other node (i.e., uniqueness of the root), for MC-TAG they can be treated as distinct nodes, thereby allowing for models that are sets of trees rather than trees (Parmentier et al. 2007). In other words, the only modification brought to the tree description solver is that, in MC-TAG mode, it does not enforce the uniqueness of a root node in a model.

IG polarized tree descriptions. IG (Perrier 2000) consist of tree descriptions whose node variables are labeled with polarized feature structures. A polarized feature structure is values, respectively, and p is a polarity value in { X  guide parsing in that a valid derivation structure must neutralize polarities. ability to output tree descriptions rather than trees, and (ii) the ability to write polarized feature structures. The first extension is trivially realized by specifying a description second point, the SYN language is extended to define polarized feature structures and feature will unify with a neutral ( = ) feature to yield a 5.3.2 Adding Specific Linguistic Constraints: The Case of Clitics. XMG can be extended order), which make it possible to describe linguistic-dependent phenomena, such as, for instance, clitic ordering in French, at a meta-level (i.e., within the metagrammar). ples 25a and 25b). 16 Second, two different clitics in front of the verb cannot have the same rank (Example 25c). (25) a. Jean le 3 lui 4 donne. node uniqueness principle and a node ordering principle . The latter allows us to label nodes with some property (let us call it rank ) whose value is an integer (for instance, further requires that in a valid tree model, (i) there are no two nodes with the same rank and (ii) sibling nodes labeled with a rank are linearly ordered according to their rank.
 category is also labeled with a numerical node property representing its rank. ordering principle then ensures that the ill-formed tree crossed out in Figure 7 is not produced. Note that in Figure 7, every type of clitic is defined locally (i.e., in a separate class), and that the interactions between these local definitions are handled by XMG using this rank principle, to produce only one valid description (pictured to the right of the arrow).
 interaction between clitics. This again contrasts with systems based on lexical rules. As noted by Perlmutter (1970), if clitics are assumed to be moved by transformations, then the order in which lexical rules apply this movement must be specified.
 constraint, here the value of the rank node property ). This can be done by introducing, for each node n of the description, a Boolean variable p n denoting n in the model has this property or not (i.e., are there two nodes of identical rank?). Then, if we call V  X  p the set of integers referring to nodes having the property p in a model, we have: p n  X  ( Eq n  X  V  X  p ) =  X  . Finally, if we represent p p being false with 0, 18 and we sum p n for each n in the model, we have that in a valid model this sum is strictly lower than 2: n  X   X  p n &lt; 2.
 model  X  , two sibling nodes n 1 and n 2 having a given property p of type integer and nodes conform to the natural order between p 1 and p introducing, for each pair of nodes n , m of the description, a Boolean variable b indicating whether they have the same ancestors: b n , m  X 
For each pair of nodes that do so, we check whether they both have the property p , 610 and if this is the case, we add to the input description a strict precedence constraint on these nodes according to their respective values of the property p : 5.3.3 Adding Color Constraints to Facilitate Grammar Writing. To further ease grammar development, XMG supports a node coloring mechanism that permits nameless node identification (Crabb  X  e and Duchier 2004), reminiscent of the polarity-based node iden-tification first proposed by Muskens and Krahmer (1998) and later used by Duchier and Thater (1999) and Perrier (2000). Such a mechanism offers an alternative to explicit node identification using equations between node variables. The idea is to label node variables with a color property, whose value (either red, black, or white) can trigger node identifications.
 tree models must satisfy some color constraints, namely, they must only have red or black nodes (no remaining white nodes; these have to be identified with some black nodes). As shown in the following table, node identification must observe the following constraints: A white node must be identified with a black node; a red node cannot be identified with any other node; and a black node may be identified with one or more white nodes. 20 extended to support colors. As mentioned previously, in valid models all white nodes are identified with a black node (at most one black node per white node). Consequently, there is a bijection from the red and black nodes of the tree description to the nodes of the model. In order to take this bijection into account, we add a node variable RB the five sets already associated with a node variable n from Section 5.1. RB either n if n is a black or red node, or the black node identified with n if n is a white node. Note that all the node variables must be colored: the set of node variables in a tree description can then be partitioned into three sets: Red , Black ,and White . Basically, we translate color information into constraints on node sets (these constraints help the generic tree solver by reducing the ambiguity for the Eq n advantage of this particular identification mechanism is its economy: Not only is there no longer any need to remember node identifiers, there is in fact no need to choose a name for node variables.
 leveled by Cohen-Sygal and Wintner (2007, 2009) against non-associative constraints on node unification do not apply.
 polarity-based tree description formalism is not associative. In other words, when describing trees in terms of combinations of polarized structures, the order in which the structures are combined matters (i.e., the output structures depend on the combi-nation order). This feature makes such formalisms not appropriate for a modular and collaborative grammar engineering, such as that of Cohen-Sygal and Wintner (2011) for Unification Grammar.
 rely on any specific fragment combination order. It computes all possible combination orders. In this context, the grammar designer cannot think in terms of sequences of node identifications. This would lead to tree overgeneration.
 independently of any specific sequence of node identifications (all valid node identifica-tions are computed). In this context, non-associativity of color-based node identification is not an issue, but rather a feature, as it allows for a compact description of a large number of node identifications (and thus of tree structures). 6. Writing Grammars with XMG
In this section, we first provide a detailed example showing how XMG can be used to specify the verbal trees of a large FB-LTAG for French extended with unification-based semantics. We then give a brief description of several large-and middle-scale grammars that were implemented using XMG. 6.1 S EM T AG : A large FB-LTAG for French Covering Syntax and Semantics We now outline the XMG specification for the verbal trees of S for French. This specification further illustrates how the various features of XMG (e.g., combined use of disjunction and conjunction, node colors) permit us to specify compact and declarative grammar descriptions. We first discuss the syntactic dimension ( SYN ).
We then go on to show how the semantic dimension ( SEM ) and the syntax/semantic interface ( DYN ) are specified. 6.1.1 The Syntactic Dimension. The methodology used to implement the verbal fragment of S EM T AG can be summarized as follows. First, tree fragments are defined that rep-resent either a possible realization of a verb argument or a possible realization of the verb. The verbal elementary TAG trees of S EM T AG are then defined by appropriately combining these tree fragments.
 tree fragments describing verb or verb argument realizations are defined. Second, gram-diathesis alternatives are defined as conjunctions of verb realizations and grammatical 612 paragraphs, we explain each of these levels in more detail.
 Tree fragments. Tree fragments are the basic building blocks used to define S
These are the units that are shared and reused in the definition of many elementary trees. For instance, the fragment for a canonical subject will be used by all FB-LTAG elementary trees involving a canonical subject.
 by defining tree fragments which describe the possible syntactic realizations of the verb arguments and of the verb itself. Figure 8 provides some illustrative examples of these fragments. Here and in the following, we omit the feature structures decorating the trees to facilitate reading. 21 fragments are organized in an inheritance hierarchy. 22 Figure 9 shows a partial view of this hierarchy illustrating how the tree fragments for argument realization depicted in
Figure 8 are organized to maximize the sharing of common information. The hierarchy classifies the verbal arguments depicted in Figure 8 into four categories: 1. The canonical subject is a noun realized in front of the verb. 2. Canonical complements occur after the verb. The canonical object is a 3. Wh-arguments (or questioned arguments) occur in front of a sentence 4. Finally, the relativized subject is a relative pronoun realized in front
Syntactic functions. The second level of abstraction uses syntactic function names such function can be realized. For instance, if we make the simplifying assumption that the possible argument realizations are limited to those given in Figure 8, the Subject, Object,
ByObject ,and IndirectObject classes would be defined as follows.
That is, we define the Subject class as an abstraction for talking about the set of tree fragments that represent the possible realizations of a subject argument X  X amely, in 614 our restricted example, canonical and relativized subject. Thus, the simplified Subject class defined in Equation (31) characterizes contexts such as the following: (35) a. Jean mange. (canonical subject) extracted position (possibly realized at an unbounded distance from the predicate) as illustrated by the following examples: (36) a. Jean parle ` aMarie . (canonical indirect object)
French syntactic functions presented by Iordanskaja and Mel X   X  cuk (2009) whereby each syntactic function is associated with a set of possible syntactic constructions.
Diathesis alternations. In this third level, we take advantage of the abstractions defined in the previous level to represent diathesis alternations. Again, we are interested here in describing alternatives. Diathesis alternations are those alternations of mapping between arguments and syntactic functions such as for instance the active/passive alternation. In a diathesis alternation, the actual form of the verb constrains the way predicate arguments are realized in syntax. Thus, in the following example, it is con-sidered that both Examples (37a) and (37b) are alternative realizations of a predicate argument structure such as send(John, a letter) . (37) a. Jean envoie une lettre. active form, its two arguments are realized by a subject and an object whereas if the verb is in the passive form, then the arguments consist of a subject and a by-object. without agent) can be expressed in our language by adding an additional alternative where the by-object or agentive complement is not expressed. Thus Equation (39) is an augmentation of (38) where we have added the agentless passive alternative (indicated in boldface).

This methodology can be further augmented to implement an actual linking in the manner of Bresnan and Zaenen (1990). For the so-called erasing cases, one can map the  X  X rased X  predicative argument to an empty realization in syntax. We refer the reader to Crabb  X  e (2005) for further details.

Tree families. Finally, tree families are defined X  X hat is, sets of trees capturing alternative realizations of a given verb type (i.e., sub-categorization frame). Continuing with the verbs taking a nominal subject, a nominal object, and an indirect nominal object (i.e., ditransitive verbs) as follows: contexts: 25 (41) a. Jean offre des fleurs ` aMarie. subject and a nominal object) and Equation (43), the intransitive one (alternatives of a verb sub-categorizing for a nominal subject).
 616 using the abstraction over grammatical functions defined for verbs. For instance, the ex-amples in (44a X 44b) can be captured using the adjectival trees defined in Equations (46) and (47), respectively, where Subject extends the definition of subject given above with a
Wh-subject, PredAdj combines a subject tree fragment with a tree fragment describing a predicative adjective, and PredAdjAObj extends a PredAdj tree fragment with a canonical ` a-object. (44) a. Jean est attentif. Qui est attentif ? L X  X omme qui est attentif 6.1.2 The Semantic Dimension and the Syntax/Semantic Interface. We now show how to unification-based compositional semantics. Three main changes need to be carried out: 1. Each elementary tree must be associated with a semantic formula. This is 2. The nodes of elementary trees must be labeled with the appropriate 3. Syntax and semantics need to be synchronized X  X hat is, variable sharing
Informing the semantic dimension. To associate each elementary tree with a formula rep-resenting the meaning of the words potentially anchoring that tree, we use the SEM dimension to specify a semantic schema. For instance, the TransitiveFamily class defined in Equation (42) for verbs taking two nominal arguments is extended as follows: where TransitiveDiathesis is the XMG class defined in Equation (39) to describe the set of trees associated with transitive verbs and BinaryRel the class describing the following semantic schema:
In this semantic schema, P , Theta 1 ,and Theta 2 are unification variables that become ground when the tree is anchored with a specific word. For instance, P , Theta pieces of information X  X redicate, thematic roles X  X re associated with lemmas, located equations). Further, X , Y , E , L are unification variables representing semantic arguments.
As illustrated in Figure 3, these become ground during (or after) derivation as a side is worth noting that by combining semantic schemas with diathesis classes, one such specification assigns the specified semantic schema to many trees, namely, all the trees described by the corresponding diathesis class. In this way, the assignment of semantic formulae to trees is relatively economical. Indeed in S EM assigned a semantic schema using a total of 75 schema calls.

Co-indexing trees and formulae indices. Assuming that tree nodes are appropriately deco-rated with semantic indices by the specification scheme described in the next paragraph, we now show how to enforce the correct mapping between syntactic and semantic arguments. This is done in two steps.
 are used to enforce the identification of the semantic index ( index node with grammatical function F (e.g., F := subject) with the index ( arg the i -th argument in a semantic schema. For instance, the following constraints ensure a subject/arg 1 mapping, that is, a coreference between the index labeling a subject node and the index representing the first argument of a semantic schema:
Given such interface constraints, we refine the diathesis definitions so as to ensure the correct bindings. For instance, the specification in Equation (38) is modified to: and the passive diathesis is specified as:
Labeling tree nodes with semantic indices. This scheme relies on the assumption that tree nodes are appropriately labeled with semantic indices (e.g., the subject node must be must denote the parameter representing the first argument of a binary relation and index subject the value of the index feature on a subject node). As suggested by Gardent (2007), a complete semantic labeling of a TAG with the semantic features necessary 618 to enrich this TAG with the unification-based compositional semantics sketched in the previous section can be obtained by applying the following labeling principles :
Argument labeling: In trees associated with semantic functors, each argument node
Controller/Controllee: In trees associated with control verbs, the semantic index of the Anchor projection: The anchor node projects its index up to its maximal projection.
Foot projection: A foot node projects its index up to the root. As we shall now see, XMG permits a fairly direct encoding of these principles. node) should be labeled with a semantic index named after the grammatical function of that node (e.g., index subject ). 29 { sociates with an (exported) node variable called FunctionNode the feature value pair [index : I] and a DYN constraint of the form index Function
SubjectSem associates the node SubjectNode with the feature value pair [index : I] and the DYN constraint index subject : I .

Additionally, in the tree fragments describing the possible realizations of the grammat-ical functions, the (exported) variable denoting the argument node is systematically named ArgNode .
 to import the appropriate semantic class and identify ArgNode and FunctionNode . For instance, the Subject specification given above is changed to:
As a result, all ArgNode nodes in the tree descriptions associated with a subject realiza-tion are labeled with an index feature I whose global name is index complement) is enforced using linking constraints between the semantic index labeling the controller node and that labeling the sentential argument node of the control verb.
Control verb definitions then import the appropriate (object or subject control) linking constraint.
 semantic indices from the anchor (respectively, foot) node up to the maximal projection (respectively, root). Concretely, this means that the top and bottom features of the nodes located on this path between the anchor (respectively, foot) and the maximal projection (respectively, root) all include an index feature whose value is shared between adjacent nodes (see variables E i in Figure 10). 30 Once the top and bottom structures are unified, so are the semantic indices along this path (modulo expected adjunctions realized on the projection).
 { skeletons onto the relevant syntactic trees by importing the skeletons in the syntactic tree description and explicitly identifying the anchor node of the semantic projection classes with the anchor or foot node of these syntactic tree descriptions. Because the will deterministically be identified with those dominating the anchor or foot node of the trees being combined with. For instance, for verbs, the class specifying the verbal spine (e.g., ActiveVerbForm , see Figure 10) equates the anchor node of the verbal spine the root. 6.1.3 Some Figures About S EM T AG . As mentioned previously, S for French equipped with semantics (Gardent 2008); it extends the purely syntactic F
TAG of Crabb  X  e (2005) with a unification based compositional semantics as described by Gardent and Kallmeyer (2003). 31 The syntactic F TAG in essence implements Abeill  X  e X  X  (2002) proposal for an FB-LTAG-based modeling of French syntax. F around 6,000 elementary trees built from 293 XMG classes and covers some 40 basic 620 verbal sub-categorization frames. For each of these frames, F argument alternations (active, passive, middle, neuter, reflexivization, impersonal, passive impersonal) and of argument realizations (cliticization, extraction, omission, permutations, etc.) possible for this frame. Predicative (adjectival, nominal, and prepositional) and light verb constructions are also covered as well as some common sub-categorizing noun and adjective constructions. Basic descriptions are provided for the remaining constructions namely, adverbs, determiners, and prepositions. cessing (T SNLP ) (Lehmann et al. 1996), using a lexicon designed specifically on the test suite, hence reducing lexical ambiguity (Crabb  X  e 2005; Parmentier 2007). This test suite focuses on difficult syntactical phenomena, providing grammatical and ungrammatical sentences. These competence grammars accept 76% of the grammatical items, reject 83% of the ungrammatical items, and have an average ambiguity of 1.64 parses per sentence.
To give an idea of the compilation time, under architectures made of a 2-Ghz processor with 1 Gb of RAM, it takes XMG 10 minutes to compile the whole S there is no semantic description solving, hence the compilation times between F and S EM T AG do not differ). 32 when combined with an FB-LTAG parser and a semantic construction module as de-scribed by Gardent and Parmentier (2005, 2007). 33 Conversely, it can be used to verbalize the meaning denoted by a given semantic representation when coupled with the GenI surface realizer described by Gardent and Kow (2007). 6.2 Other Grammars Designed with XMG
XMG has been used mainly to design FB-LTAG and IG for French or English. More MC-TAG for German. We now briefly describe each of these resources.
 SemXTAG. The English grammar, S EM XT AG (Alahverdzhieva 2008), reimplements the FB-LTAG developed for English at the University of Pennsylvania (XTAG Research
Group 2001) and extends it with a unification-based semantics. It contains 1,017 trees and covers the syntactic fragment of XTAG, namely, auxiliaries, copula, raising and structions, noun X  X oun modification, extraposition, determiner sequences, genitives, negation, noun X  X erb contractions, sentential adjuncts, imperatives, and resultatives.
The grammar was tested on a handbuilt test-suite of 998 sentences illustrating the various syntactic constructions meant to be covered by the grammar. All sentences in the test suite can be parsed using the grammar.

FrenchIG. The extended XMG framework was used to design a core IG for French resulting grammar is lexicalized, and its coverage was evaluated using the previously mentioned T SNLP . The French IG accepts 88% of the grammatical sentences and rejects 85% of the ungrammatical sentences, although the current version of the French IG does not yet cover all the syntactic phenomena presented in the test suite (for example, causative and superlative constructions).

Vietnamese TAG. The XMG language was used by Le Hong, N X  X uyen, and Roussanaly (2008) to produce a core FB-LTAG for Vietnamese. Their work is rather a proof of con-cept than a large-scale implementation. They focused on Vietnamese X  X  categorization frames, and were able to produce a TAG covering the following frames: intransitive (tree family N0V), transitive with a nominal complement (N0VN1), transitive with a clausal complement (N0VS1), transitive with modal complement (N0V0V1), ditransi-tive (N0VN1N2), ditransitive with a preposition (N0VN1ON2), ditransitive with a ver-bal complement (N0V0N1V1), ditransitive with an adjectival complement (N0VN1A), movement verbs with a nominal complement (N0V0V1N1), movement verbs with an adjectival complement (N0V0AV1), and movement ditransitive (N0V0N1V1N2).
 GerTT. Another XMG-based grammar corresponds to the German MC-TAG of Kallmeyer et al. (2008). This grammar, called GerTT , is in fact an MC-TAG with
Tree Tuples (Lichte 2007). This variant of MCTAG has been designed to model free word order phenomena. This is done by imposing node sharing constraints on MCTAG derivations (Kallmeyer 2005). GerTT covers phenomena such as scrambling, coherent constructions, relative clauses, embedded questions, copula verbs, complementized sentences, verbs with various sub-categorization frames, nouns, prepositions, determin-ers, adjectives, and partly includes semantics. It is made of 103 tree tuples, compiled from 109 classes. 7. Related Work
We now compare XMG with existing environments for designing tree-based grammars and briefly report on the grammars designed with these systems. 7.1 Environments for Designing Tree-Based Grammars Candito X  X  Metagrammar Compiler. The concept of metagrammar was introduced by
Candito (1996). In her paper, Candito presented a compiler for abstract specifications of FB-LTAG trees (the so-called metagrammars). Such specifications are based on three dimensions, each of them being encoded in a separate inheritance hierarchy of linguistic descriptions. Dimension 1 describes canonical sub-categorization frames (e.g., transitive), the Dimension 2 describes redistributions of syntactic functions (e.g., active to passive), and Dimension 3 the tree descriptions corresponding to the realizations of the syntactic functions defined in Dimension 2. This three-dimensional metagrammatical description is then processed by a compiler to compute FB-LTAG tree schemas. In essence, these tree schemas are produced by associating a canonical sub-categorization frame (Dimen-sion 1) with a compatible redistribution schema (Dimension 2), and with exactly one function realization (Dimension 3) for each function required by the sub-categorization frame.
 and Schabes (1992) and Evans, Gazdar, and Weir (1995) in that it provides a linguistically 622 the XMG definition of S EM T AG uses similar principles. Candito X  X  approach differs, however, from the XMG account in several important ways:
The LexOrg system. An approach similar to Candito X  X  was presented by Xia et al. approach, a TAG abstract specification relies on a three-dimensional description made of, namely, sub-categorization frames, blocks, and lexical redistribution rules. To com-frame, and applies some lexical redistribution rules to derive new frames and finally select blocks corresponding to the resulting frames. These blocks contain tree descrip-tions using the logic of Rogers and Vijay-Shanker (1994).
 guistic knowledge is embedded in the compiling algorithm, making it difficult for linguists to extend the grammar description and to handle exceptions. Unlike in Can-dito X  X  framework, the tree description language uses local node variables and lets the tree description solver determine node identifications. Although this avoids having to memorize node names, this requires that the descriptions be constrained enough to impose the required node identifications and prevent the unwanted ones. In practice, this again complicates grammar writing. In contrast, XMG provides an intermediate solution which, by combining local variables with export declarations, avoids having to memorize too many node variable names (only those local to the relevant sub-hierarchy need memorizing) while allowing for explicit node identification.
 The Metagrammar Compiler of Gaiffe, Crabb  X  e, and Roussanaly. Gaiffe, Crabb  X  e, and
Roussanaly (2002) proposed a compiler for FB-LTAG that aims to remedy both the lack of a clear separation between linguistic information and compilation algorithm, and the lack of explicit control on the class combinations prevalent in Candito (1996), Xia et al. (1998), and Xia (2001). In their approach, the linguistic specification consists of a single inheritance hierarchy of classes, each class containing a tree description. The description logic used is similar to Candito X  X . That is, global node names are used. To trigger class combinations, classes are labeled with two types of information: needs and combinations, and only keeps those combinations that neutralize the stated needs and resources. The tree descriptions contained in these neutral combinations are then solved to produce the expected trees.
 tion and compilation algorithm, the fully automatic derivation of FB-LTAG trees from contrast, XMG X  X  explicit definitions of class combinations by conjunction, disjunction, compiler from the grammar specification. Additionally, the issues raised by global variables remain (no way to instantiate twice a given class, and cumbersome definition of variables in large metagrammars).

The MGCOMP System. More recently, Villemonte de la Clergerie (2005, 2010) proposed a compiler for FB-LTAG that aims at preserving a high degree of factorization in both the abstract grammar specification and the grammar which is compiled from it. Thus, the MGCOMP system does not compute FB-LTAG elementary trees, but factorized trees. grammar consists of a single hierarchy of classes. The classes are labeled with needs and resources, and final classes of the hierarchy are combined to compute tree descriptions.
The main differences with Gaiffe, Crabb  X  e, and Roussanaly (2002), lies in the fact that (i) a description can include new factorizing operators, such as repetition ( Kleene-star namespaces to specify the scope of variables. MGCOMP X  X  extended tree descriptions are not completely solved by the compiler. Rather, it compiles underspecified trees (also called factorized trees). With this approach, a large grammar is much smaller in terms of number of grammatical structures than a classical FB-LTAG. As a result, the grammars it compiles are only compatible with the DyALog parsing environment (Villemonte de La
Clergerie 2005). And, because the linguist designs factorized trees and not actual TAG trees, debugging the metagrammar becomes harder. 7.2 Resources Built Using Candito, Xia, and De La Clergerie X  X  Systems
Candito X  X  system has been used by Candito (1999) herself to design a core FB-LTAG for French and Italian, and later by Barrier (2006) to design a FB-LTAG for adjectives in French. Xia X  X  system (LexOrg) has been used to semi-automatically generate XTAG (Xia 2001). De La Clergerie X  X  system (MGCOMP) has been used to design a grammar for French named FRMG (FRench MetaGrammar) (Villemonte de la Clergerie 2010).
FRMG makes use of MGCOMP X  X  factorizing operators (e.g., shuffling operator), thus producing not sensu stricto a FB-LTAG, but a factorized FB-LTAG. FRMG is freely available, contains 207 factorized trees (having optional branches, etc.) built from 279 metagrammatical classes, and covers 95% of the T SNLP . 8. Conclusion
In this article, we presented the eXtensible MetaGrammar framework and argued that, contrary to other existing grammar writing environments for tree-based grammar, 624
XMG is declarative, extensible, and notationally expressive. We believe that these fea-tree-based grammars that are used in applications requiring high precision in gram-mar modeling (e.g., language teaching, man/machine dialogue systems, data-to-text generation).
 ware, freely available under the terms of the GPL-compliant CeCILL license. grammars designed with XMG (FB-LTAG and IG for French and English, TT-MCTAG for German) are also open-source and available on-line. 35 based grammars for different languages. We plan to extend XMG to handle other types of formalisms 36 such as dependency grammars, and to support dimensions other than syntax and semantics such as for instance, phonology or morphology. As mentioned here, XMG offers a modular architecture, making it possible to extend it relatively easily.
Nonetheless, in its current state, such extensions imply modifying XMG X  X  code. We are exploring new extensions of the formalism, which would allow the linguist to dynam-ically define her/his metagrammar formalism (e.g., which principles or descriptions to use) depending on the target formalism.
 the metagrammar allows for dealing with structural redundancy. As pointed out by
Kinyon et al. (2006), a metagrammar can be used to capture generalizations across languages and is surely worth further investigating.
 velopment Environments (IDE) for programming languages. Designing a grammar is, in some respect, similar to programming an application. Grammar environments should benefit from the same tools as those used for the development of applications (incremental compilation, debugger, etc.).
 Acknowledgments References 626 628
