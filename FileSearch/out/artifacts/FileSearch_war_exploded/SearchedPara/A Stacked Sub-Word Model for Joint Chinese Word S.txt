 Word segmentation and part-of-speech (POS) tag-ging are necessary initial steps for more advanced Chinese language processing tasks, such as pars-ing and semantic role labeling. Joint approaches that resolve the two tasks simultaneously have re-ceived much attention in recent research. Previous work has shown that joint solutions led to accu-racy improvements over pipelined systems by avoid-ing segmentation error propagation and exploiting POS information to help segmentation. A challenge for joint approaches is the large combined search space, which makes efficient decoding and struc-tured learning of parameters very hard. Moreover, the representation ability of models is limited since using rich contextual word features makes the search intractable. To overcome such efficiency and effec-tiveness limitations, the approximate inference and reranking techniques have been explored in previous work (Zhang and Clark, 2010; Jiang et al., 2008b).
In this paper, we present an effective and effi-cient solution for joint Chinese word segmentation and POS tagging. Our work is motivated by several characteristics of this problem. First of all, a major-ity of words are easy to identify in the segmentation problem. For example, a simple maximum match-ing segmenter can achieve an f-score of about 90. We will show that it is possible to improve the ef-ficiency and accuracy by using different strategies for different words. Second, segmenters designed with different views have complementary strength. We argue that the agreements and disagreements of different solvers can be used to construct an inter-mediate sub-word structure for joint segmentation and tagging. Since the sub-words are large enough in practice, the decoding for POS tagging over sub-words is efficient. Finally, the Chinese language is characterized by the lack of morphology that often provides important clues for POS tagging, and the POS tags contain much syntactic information, which need context information within a large window for disambiguation. For example, Huang et al. (2007) showed the effectiveness of utilizing syntactic infor-mation to rerank POS tagging results. As a result, the capability to represent rich contextual features is crucial to a POS tagger. In this work, we use a representation-efficiency tradeoff through stacked learning, a way of approximating rich non-local fea-tures.

This paper describes a novel stacked sub-word model. Given multiple word segmentations of one sentence, we formally define a sub-word structure that maximizes the agreement of non-word-break positions. Based on the sub-word structure, joint word segmentation and POS tagging is addressed as a two step process. In the first step, one word-based segmenter, one character-based segmenter and one local character classifier are used to produce coarse segmentation and POS information. The results of the three predictors are then merged into sub-word sequences, which are further bracketed and labeled with POS tags by a fine-grained sub-word tagger. If a string is consistently segmented as a word by the three segmenters, it will be a correct word prediction with a very high probability. In the sub-word tag-ging phase, the fine-grained tagger mainly considers its POS tag prediction problem. For the words that are not consistently predicted, the fine-grained tag-ger will also consider their bracketing problem. The coarse-to-fine scheme significantly improves the ef-ficiency of decoding. Furthermore, in the sub-word tagging step, word features in a large window can be approximately derived from the coarse segmentation and tagging results. To train a good sub-word tagger, we use the stacked learning technique, which can ef-fectively correct the training/test mismatch problem. We conduct our experiments on the Penn Chinese Treebank and compare our system with the state-of-the-art systems. We present encouraging results. Our system achieves an f-score of 98.17 for the word segmentation task and an f-score of 94.02 for the whole task, resulting in relative error reductions of 14.1% and 5.5% respectively over the best system reported in the literature.

The remaining part of the paper is organized as follows. Section 2 gives a brief introduction to the problem and reviews the relevant previous research. Section 3 describes the details of our method. Sec-tion 4 presents experimental results and empirical analyses. Section 5 concludes the paper. 2.1 Problem Definition Given a sequence of characters c = ( c 1 , ..., c # c the task of word segmentation and POS tagging is to predict a sequence of word and POS tag pairs y = (  X  w 1 , p 1  X  ,  X  w # y , p # y  X  ) , where w i is a word, p is its POS tag, and a  X  #  X  symbol denotes the number of elements in each variable. In order to avoid error propagation and make use of POS information for word segmentation, the two tasks should resolved jointly. Previous research has shown that the inte-grated methods outperformed pipelined systems (Ng and Low, 2004; Jiang et al., 2008a; Zhang and Clark, 2008). 2.2 Character-Based and Word-Based Two kinds of approaches are popular for joint word segmentation and POS tagging. The first is the  X  X haracter-based X  approach, where basic process-ing units are characters which compose words. In this kind of approach, the task is formulated as the classification of characters into POS tags with boundary information. Both the IOB2 representa-tion (Ramshaw and Marcus, 1995) and the Start/End representation (Kudo and Matsumoto, 2001) are popular. For example, the label B-NN indicates that a character is located at the begging of a noun. Using this method, POS information is allowed to inter-act with segmentation. Note that word segmentation can also be formulated as a sequential classification problem to predict whether a character is located at the beginning of, inside or at the end of a word. This character-by-character method for segmentation was first proposed in (Xue, 2003), and was then further used in POS tagging in (Ng and Low, 2004). One main disadvantage of this model is the difficulty in incorporating the whole word information.

The second kind of solution is the  X  X ord-based X  method, where the basic predicting units are words themselves. This kind of solver sequentially decides whether the local sequence of characters makes up a word as well as its possible POS tag. In partic-ular, a word-based solver reads the input sentence from left to right, predicts whether the current piece of continuous characters is a word token and which class it belongs to. Solvers may use previously pre-dicted words and their POS information as clues to find a new word. After one word is found and classi-fied, solvers move on and search for the next possi-ble word. This word-by-word method for segmenta-tion was first proposed in (Zhang and Clark, 2007), and was then further used in POS tagging in (Zhang and Clark, 2008).

In our previous work(Sun, 2010), we presented a theoretical and empirical comparative analysis of character-based and word-based methods for Chi-nese word segmentation. We showed that the two methods produced different distributions of segmen-tation errors in a way that could be explained by theoretical properties of the two models. A system combination method that leverages the complemen-tary strength of word-based and character-based seg-mentation models was also successfully explored in their work. Different from our previous focus, the diversity of different models designed with different views is utilized to construct sub-word structures in this work. We will discuss the details in the next section. 2.3 Stacked Learning Stacked generalization is a meta-learning algorithm that was first proposed in (Wolpert, 1992) and (Breiman, 1996). The idea is to include two  X  X evels X  of predictors. The first level includes one or more predictors g 1 , ...g K : R d  X  R ; each receives input x  X  R d and outputs a prediction g k ( x ) . The second level consists of a single function h : R d + K  X  R that takes as input  X  x , g 1 ( x ) , ..., g K ( x )  X  and outputs a final prediction  X  y = h ( x , g 1 ( x ) , ..., g K ( x )) .
Training is done as follows. The training data S = { ( x t , y t ) : t  X  [1 , T ] } is split into L equal-sized dis-joint subsets S 1 , ..., S L . Then functions g 1 , ..., g (where g l =  X  g l 1 , ..., g l K  X  ) are seperately trained on S  X  S l , and are used to construct the augmented dataset  X  S = { (  X  x t ,  X  y 1 t , ...,  X  y K t  X  , y t ) :  X  y and x t  X  S l } . Finally, each g k is trained on the origi-nal dataset and the second level predictor h is trained on  X  S . The intent of the cross-validation scheme is that y k t is similar to the prediction produced by a predictor which is learned on a sample that does not include x t .

Stacked learning has been applied as a system en-semble method in several NLP tasks, such as named entity recognition (Wu et al., 2003) and dependency parsing (Nivre and McDonald, 2008). This frame-work is also explored as a solution for learning non-local features in (Torres Martins et al., 2008). In the machine learning research, stacked learning has been applied to structured prediction (Cohen and Carvalho, 2005). In this work, stacked learning is used to acquire extended training data for sub-word tagging. 3.1 Architecture In our stacked sub-word model, joint word segmen-tation and POS tagging is decomposed into two steps: (1) coarse-grained word segmentation and tagging, and (2) fine-grained sub-word tagging. The workflow is shown in Figure 1. In the first phase, one word-based segmenter ( Seg W ) and one character-based segmenter ( Seg C ) are trained to produce word boundaries. Additionally, a local character-based joint segmentation and tagging solver ( SegTag L ) is used to provide word boundaries as well as inaccu-rate POS information. Here, the word local means the labels of nearby characters are not used as fea-tures. In other words, the local character classi-fier assumes that the tags of characters are indepen-dent of each other. In the second phase, our system first combines the three segmentation and tagging results to get sub-words which maximize the agree-ment about word boundaries. Finally, a fine-grained sub-word tagger ( SubTag ) is applied to bracket sub-words into words and also to obtain their POS tags.
In our model, segmentation and POS tagging in-teract with each other in two processes. First, al-though SegT ag L is locally trained, it resolves the two sub-tasks simultaneously. Therefore, in the sub-word generating stage, segmentation and POS tag-ging help each other. Second, in the sub-word tag-ging stage, the bracketing and the classification of sub-words are jointly resolved as one sequence la-beling problem.

Our experiments on the Penn Chinese Treebank will show that the word-based and character-based segmenters and the local tagger on their own pro-duce high quality word boundaries. As a result, the oracle performance to recover words from a sub-word sequence is very high. The quality of the fi-nal tagger relies on the quality of the sub-word tag-ger. If a high performance sub-word tagger can be constructed, the whole task can be well resolved. The statistics will also empirically show that sub-words are significantly larger than characters and only slightly smaller than words. As a result, the search space of the sub-word tagging is significantly shrunken, and exact Viterbi decoding without ap-proximately pruning can be efficiently processed. This property makes nearly all popular sequence la-beling algorithms applicable.

Zhang et al. (2006) described a sub-word based tagging model to resolve word segmentation. To get the pieces which are larger than characters but smaller than words, they combine a character-based segmenter and a dictionary matching segmenter. Our contributions include (1) providing a formal definition of our sub-word structure that is based on multiple segmentations and (2) proposing a stacking method to acquire sub-words. 3.2 The Coarse-grained Solvers We systematically described the implementation of two state-of-the-art Chinese word segmenters in word-based and character-based architectures, re-spectively (Sun, 2010). Our word-based segmenter is based on a discriminative joint model with a first order semi-Markov structure, and the other seg-menter is based on a first order Markov model. Ex-act Viterbi-style search algorithms are used for de-coding. Limited to the document length, we do not give the description of the features. We refer readers to read the above paper for details. For parameter estimation, our work adopt the Passive-Aggressive (PA) framework (Crammer et al., 2006), a family of margin based online learning algorithms. In this work, we introduce two simple but important refine-ments: (1) to shuffle the sample orders in each itera-tion and (2) to average the parameters in each itera-tion as the final parameters.
 Idiom In linguistics, idioms are usually presumed to be figures of speech contradicting the principle of compositionality. As a result, it is very hard to recognize out-of-vocabulary idioms for word seg-mentation. However, the lexicon of idioms can be taken as a close set, which helps resolve the problem well. We collect 12992 idioms 1 from several on-line Chinese dictionaries. For both word-based and character-based segmentation, we first match every string of a given sentence with idioms. Every sen-tence is then splitted into smaller pieces which are seperated by idioms. Statistical segmentation mod-els are then performed on these smaller character se-quences.

We use a local classifier to predict the POS tag with positional information for each character. Each character can be assigned one of two possi-ble boundary tags:  X  X  X  for a character that begins a word and  X  X  X  for a character that occurs in the mid-dle of a word. We denote a candidate character to-following features are used:  X  character uni-grams: c k ( i  X  2  X  k  X  i + 2 )  X  character bi-grams: c k c k +1 ( i  X  2  X  k  X  i + 1 ) To resolve the classification problem, we use the lin-ear SVM classifier LIBLINEAR 2 . 3.3 Merging Multiple Segmentation Results A majority of words are easy to identify in the seg-mentation problem. We favor the idea treating dif-ferent words using different strategies. In this work we try to identify simple and difficult words first and to integrate them into a sub-word level. Inspired by previous work, we constructed this sub-word struc-ture by using multiple solvers designed from differ-ent views. If a piece of continuous characters is con-sistently segmented by multiple segmenters, it will Answer: [P] [JJ] [ NN ] [ CD ] [M] [VV] [ JJ ] [ NN ] Seg W : [] [] [ ] [ ] [ ] [ ] [ ] [ ] Seg C : [] [] [ ] [ ] [] [ ] [ ] not be separated in the sub-word tagging step. The intuition is that strings which are consistently seg-mented by the different segmenters tend to be cor-rect predictions. In our experiment on the Penn Chi-nese Treebank (Xue et al., 2005), the accuracy is 98.59% on the development data which is defined in the next section. The key point for the interme-diate sub-word structures is to maximize the agree-ment of the three coarse-grained systems. In other words, the goal is to make merged sub-words as large as possible but not overlap with any predicted word produced by the three coarse-grained solvers. In particular, if the position between two continu-ous characters is predicted as a word boundary by any segmenter, this position is taken as a separation position of the sub-word sequence. This strategy makes sure that it is still possible to re -segment the strings of which the boundaries are disagreed with by the coarse-grained segmenters in the fine-grained tagging stage.

The formal definition is as follows. Given a se-quence of characters c = ( c 1 , ..., c # c ) , let c [ i : j ] denote a string that is made up of characters between c i and c j (including c i and c j ), then a partition of the sentence can be written as c [0 : e 1 ] , c [ e 1 + 1 : e ] , ..., c [ e m : # c ] . Let s k = { c [ i : j ] } denote the set of all segments of a partition. Given multiple partitions of a character sequence S = { s k } , there is one and only one merged partition s S = { c [ i : j ] } s.t. 1.  X  c [ i : j ]  X  s S ,  X  s k  X  S ,  X  c [ s : e ]  X  s k , s  X  2.  X C 0 satisfies the above condition, |C 0 | &gt; |C| . The first condition makes sure that all segments in the merged partition can be only embedded in but do not overlap with any segment of any partition from S . The second condition promises that segments of the merged partition achieve maximum length.
Figure 2 is an example to illustrate the proce-dure of our method. The lines Seg W , Seg C and SegTag L are the predictions of the three coarse-grained solvers. For the three words at the begin-ning and the two words at the end, the three predic-tors agree with each other. And these five words are kept as sub-words. For the character sequence  X   X   X  X  X  X  X  X  X   X   X   X , the predictions are very differ-ent. Because there are no word break predictions among the first three characters  X   X  X  X  X   X , it is as a whole taken as one sub-word. For the other five characters, either the left position or the right po-sition is segmented as a word break by some pre-dictor, so the merging processor seperates them and takes each one as a single sub-word. The last line shows the merged sub-word sequence. The coarse-grained POS tags with positional information are de-rived from the labels provided by SegTag L . 3.4 The Fine-grained Sub-Word Tagger Bracketing sub-words into words is formulated as a IOB-style sequential classification problem. Each sub-word may be assigned with one POS tag as well as two possible boundary tags:  X  X  X  for the begin-ning position and  X  X  X  for the middle position. A tagger is trained to classify sub-word by using the features derived from its contexts.

The sub-word level allows our system to utilize features in a large context, which is very important for POS tagging of the morphologically poor lan-guage. Features are formed making use of sub-word contents, their IOB-style inaccurate POS tags. In the following description,  X  X  X  refers to the content of the sub-word, while  X  X  X  refers to the IOB-style POS tags. For convenience, we denote a sub-word the current token. We denote l C , l T as the sizes of the window.  X  Uni-gram features: C( s k ) (  X  l C  X  k  X  l C ),  X  Bi-gram features: C( s k )C( s k +1 ) (  X  l C  X  k  X   X  In order to better handle unknown words, we
Take the sub-word  X   X  X  X  X   X  in Figure 2 for ex-ample, when l C and l T are both set to 1, all features used are listed in Table 1.

In the following experiments, we will vary win-dow sizes l C and l T to find out the contribution of context information for the disambiguation. A first order Max-Margin Markov Networks model is used to resolve the sequence tagging problem. We use the SVM-HMM 3 implementation for the experiments in this work. We use the basic linear model without applying any kernel function.
Algorithm 1 : The stacked learning procedure for the sub-word tagger. input : Data S = { ( c t , y t ) , t = 1 , 2 , ..., n }
Split S into L partitions { S 1 , ...S L } for l = 1 , ..., L do end
Train the sub-word tagger SubTag using S 0 . 3.5 Stacked Learning for the Sub-Word Tagger The three coarse-grained solvers Seg W , Seg C and SegTag L are directly trained on the original train-ing data. When these three predictors are used to produce the training data, the performance is per-fect. However, this does not hold when these mod-els are applied to the test data. If we directly apply Seg W , Seg C and SegTag L to extend the training data to generate sub-word samples, the extended training data for the sub-word tagger will be very different from the data in the run time, resulting in poor per-formance.

One way to correct the training/test mismatch is to use the stacking method, where a K -fold cross-validation on the original data is performed to con-struct the training data for sub-word tagging. Algo-rithm 1 illustrates the learning procedure. First, the training data S = { ( c t , y t ) } is split into L equal-sized disjoint subsets S 1 , ..., S L . For each subset S the complementary set S  X  S l is used to train three coarse solvers Seg W l , Seg C l and SegTag L l , which process the S l and provide inaccurate predictions. Then the inaccurate predictions are merged into sub-word sequences and S l is extended to S 0 l . Finally, the sub-word tagger is trained on the whole extended data set S 0 . 4.1 Setting Previous studies on joint Chinese word segmenta-tion and POS tagging have used the Penn Chinese Treebank (CTB) in experiments. We follow this set-ting in this paper. We use CTB 5.0 as our main corpus and define the training, development and test sets according to (Jiang et al., 2008a; Jiang et al., 2008b; Kruengkrai et al., 2009; Zhang and Clark, 2010). Table 2 shows the statistics of our experi-mental settings.
 Data set CTB files # of sent. # of words
Training 1-270 18,089 493,939 Devel. 301-325 350 6821 Test 271-300 348 8008
Three metrics are used for evaluation: precision (P), recall (R) and balanced f-score (F) defined by 2PR/(P+R). Precision is the relative amount of cor-rect words in the system output. Recall is the rela-tive amount of correct words compared to the gold standard annotations. For segmentation, a token is considered to be correct if its boundaries match the boundaries of a word in the gold standard. For the whole task, both the boundaries and the POS tag have to be correctly identified. 4.2 Performance of the Coarse-grained Solvers Table 3 shows the performance on the development data set of the three coarse-grained solvers. In this paper, we use 20 iterations to train Seg W and Seg C for all experiments. Even only locally trained, the character classifier SegTag L still significantly out-performs the two state-of-the-art segmenters Seg W and Seg C . This good performance indicates that the POS information is very important for word segmen-tation.
 4.3 Statistics of Sub-Words Since the base predictors to generate coarse infor-mation are two word segmenters and a local charac-ter classifier, the coarse decoding is efficient. If the length of sub-words is too short, i.e. the decoding path for sub-word sequences are too long, the decod-ing of the fine-grained stage is still hard. Although we cannot give a theoretical average length of sub-words, we can still show the empirical one. The av-erage length of sub-words on the development set is 1.64, while the average length of words is 1.69. The number of all IOB-style POS tags is 59 (when using 5-fold cross-validation to generate stacked training samples). The number of all POS tags is 35. Empir-ically, the decoding over sub-words is 1 . 69 1 . 64  X  ( 59 times as slow as the decoding over words, where n is the order of the markov model. When a first order markov model is used, this number is 2.93. These statistics empirically suggest that the decoding over sub-word sequence can be efficient.

On the other hand, the sub-word sequences are not perfect in the sense that they do not promise to recover all words because of the errors made in the first step. Similarly, we can only show the em-pirical upper bound of the sub-word tagging. The oracle performance of the final POS tagging on the development data set is shown in Table 4. The up-per bound indicates that the coarse search procedure does not lose too much.

One main disadvantage of character-based ap-proach is the difficulty to incorporate word features. Since the sub-words are on average close to words, sub-word features are good approximations of word features. 4.4 Rich Contextual Features Are Useful Table 5 shows the effect that features within differ-ent window size has on the sub-word tagging task. In this table, the symbol  X  X  X  means sub-word con-tent features while the symbol  X  X  X  means IOB-style POS tag features. The number indicates the length of the window. For example,  X  X :  X  1  X  means that the tagger uses one preceding sub-word and one suc-ceeding sub-word as features. From this table, we can clearly see the impact of features derived from neighboring sub-words. There is a significant in-crease between  X  X :  X  2  X  and  X  X :  X  1  X  models. This confirms our motivation that longer history and fu-ture features are crucial to the Chinese POS tagging problem. It is the main advantage of our model that making rich contextual features applicable. In all previous solutions, only features within a short his-tory can be used due to the efficiency limitation.
The performance is further slightly improved when the window size is increased to 3 . Using the labeled bracketing f-score, the evaluation shows that the  X  X :  X  3 T:  X  1  X  model performs the same as the  X  X :  X  3 T:  X  2  X  model. However, the sub-word clas-sification accuracy of the  X  X :  X  3 T:  X  1  X  model is higher, so in the following experiments and the fi-nal results reported on the test data set, we choose this setting.

This table also suggests that the IOB-style POS information of sub-words does not contribute. We think there are two main reasons: (1) The POS infor-mation provided by the local classifier is inaccurate; (2) The structured learning of the sub-word tagger can use real predicted sub-word labels during its de-coding time, since this learning algorithm does in-ference during the training time. It is still an open question whether more accurate POS information in rich contexts can help this task. If the answer is YES , how can we efficiently incorporate these features? 4.5 Stacked Learning Is Useful Table 6 compares the performance of  X  X :  X  3 T:  X  1  X  models trained with no stacking as well as differ-ent folds of cross-validation. We can see that al-though it is still possible to improve the segmenta-tion and POS tagging performance compared to the local character classifier, the whole task just benefits only a little from the sub-word tagging procedure if the stacking technique is not applied. The stacking technique can significantly improve the system per-formance, both for segmentation and POS tagging. This experiment confirms the theoretical motivation of using stacked learning: simulating the test-time setting when a sub-word tagger is applied to a new instance. There is not much difference between the 5 -fold and the 10 -fold cross-validation.
 Devel. Task P(%) R(%) F No stacking Seg 95.75 96.48 96.12 K = 5 Seg 96.42 97.04 96.73 K = 10 Seg 96.67 97.11 96.89 4.6 Final Results Table 7 summarizes the performance of our final system on the test data and other systems reported in a majority of previous work. The final results of our system are achieved by using 10 -fold cross-validation  X  X :  X  3 T:  X  1  X  models. The left most col-umn indicates the reference of previous systems that represent state-of-the-art results. The comparison of the accuracy between our stacked sub-word system and the state-of-the-art systems in the literature in-dicates that our method is competitive with the best systems. Our system obtains the highest f-score per-formance on both segmentation and the whole task, resulting in error reductions of 14.1% and 5.5% re-spectively. This paper has described a stacked sub-word model for joint Chinese word segmentation and POS tag-ging. We defined a sub-word structure which maxi-mizes the agreement of multiple segmentations pro-vided by different segmenters. We showed that this sub-word structure could explore the complemen-tary strength of different systems designed with dif-ferent views. Moreover, the POS tagging could be efficiently and effectively resolved over sub-word sequences. To train a good sub-word tagger, we in-troduced a stacked learning procedure. Experiments showed that our approach was superior to the exist-ing approaches reported in the literature.

Machine learning and statistical approaches en-counter difficulties when the input/output data have a structured and relational form. Research in em-pirical Natural Language Processing has been tack-ling these complexities since the early work in the field. Recent work in machine learning has pro-vided several paradigms to globally represent and process such data: linear models for structured pre-diction, graphical models, constrained conditional models, and reranking, among others. A general expressivity-efficiency trade off is observed. Al-though the stacked sub-word model is an ad hoc so-lution for a particular problem, namely joint word segmentation and POS tagging, the idea to em-ploy system ensemble and stacked learning in gen-eral provides an alternative for structured problems. Multiple  X  X heap X  coarse systems are used to provide diverse outputs, which may be inaccurate. These outputs are further merged into an intermediate rep-resentation, which allows an extractive system to use rich contexts to predict the final results. A natu-ral avenue for future work is the extension of our method to other NLP tasks.
 The work is supported by the project TAKE (Tech-nologies for Advanced Knowledge Extraction), funded under contract 01IW08003 by the German Federal Ministry of Education and Research. The author is also funded by German Academic Ex-change Service (DAAD).
 The author would would like to thank Dr. Jia Xu for her helpful discussion, and Regine Bader for proofreading this paper.

