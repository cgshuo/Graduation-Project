 Searching data streams has been traditionally very limited, either in the complexity of the search or in the size of the searched dataset. In this paper, we inve stigate the design and optimization of constructs that enable SQL to express complex patterns. In particular we propose the RSPS (recursive sequential pattern search) algorithm which exploits the inter-dependencies between the elements of a sequential pattern to minimize repeated passes over the same data. Performance gains derived experimental results show impressive speedup up to 100 times. H.3 [ Information Systems ]: INFORMATION STORAGE AND RETRIEVAL, Information Search and Retrieval, Search process Algorithms, Performance, Theory. Complex Pattern Search, SQL-TS, Time Series, Pattern Search Many applications in the commercial or scientific domains share the need for search for patterns of interest in sequential or stream data. Examples include analysis of data gathered from sensor networks, the stock market, telecommunications networks, seismic activity, and remote sensi ng. An extension of SQL with the ability to query time-series proposed in [2]. Specifically in [2] Sadri et al introduce an extension of SQL, SQL-TS, to express sequential patterns, and study how to optimize search queries for this language. They exploit the inter-dependencies between the elements of a sequential pattern to minimize repeated passes over the same data. While the technique outlined in [2] is powerful enough to find many types of patterns, it lacks the power necessary for expressing some key interesting queries. In this paper we extend the Optimal Pattern Search (OPS) algorithm [2] (termed RSPS) and present a general algorithm which gives SQL-TS the capability to look for more complex patterns such as nested-star patterns. RSPS provides a general framework to search for any pattern in SQL level. SQL for Time Series (SQL-TS), introduced in Sadri et al [2], adds a number of simple and us eful constructs to SQL for specifying complex sequential patterns. SQL-TS is identical to SQL, except for the following a dditions to the FROM clause:  X  a SEQUENCE BY clause specifying the sequencing  X  a CLUSTER BY clause specifying the grouping attributes, A key feature of SQL-TS is its ability to express recurring patterns by using a star operator. However, the star operator can be applied only to simple patte rns and not to complex patterns that contain sub-patterns. Our approach here will improve the power of SQL-TS by supporting recurring complex patterns. The Optimal Pattern Search algorithm (OPS) was proposed by Sadri et al [2] for optimization of se quential queries in SQL-TS, via extending the KMP text matching algorithm [1]. Following is a brief summary of OPS: Given an input stream and a sequential query, suppose that while searching for the sequential pattern on an input stream, a mism atch occurs at the j th position of the pattern. Speedup is achieved by tracking two items, shift ( j ) and values after the mismatch. Shift ( j ) determines how far the pattern should be advanced in the input, and next ( j ) determines from which element in the pattern the checking of conditions should be resumed after the shift. To compute shift ( j ) and next ( j ), OPS begins by capturing all the logical relations among pairs of the pattern elements using a positive precondition logic matrix a negative precondition logic matrix  X  . These matrices are both of size m , where m is the length of the search pattern. The elements of these matrices are only defined for k j  X  ; thus they are lower-triangular matrices .  X  jk and  X  jk are defined as follows: Logical relationships between w hole patterns are derived from the matrices  X  and  X  , and next and shift are calculated accordingly. An important advantage of the RSPS algorithm is that it can be easily generalized to handle input patterns which, in SQL-TS, are expressed using the star. In general, a star such as * p denotes a maximal sequence of one or more tuples that satisfy all the applicable conditions and *(* p 1 ,* p 2 ) matches the sequences of records with recurring patterns of decreasing prices followed by a period of increasing prices. The calculation of logic matrices and  X  remains unchanged in the presen ce of nested stars patterns. However, the calculation of the arrays next and shift must be generalized for nested star pa tterns as described below. At runtime we maintain an array of counters (one per pattern element) to keep track of the cumulative number of input objects that have matched the pattern sequence so far. For instance, if the first pattern element is a star that matched five elements in the input and the second pattern element is a non-star, matching only one input element, and the third element is a star matching two input elements we will have count 1 = 5, count 2 = 6, and count 8. At runtime we maintain an array of counters to keep track of the cumulative number of input objects that have matched the pattern sequence so far. Each element of this array is an array itself, since the star pattern can match different parts of the input stream in a single run. As such, we need a counter to keep track of the number of matched elements for each part. We represent a pattern as a finite state model in which elements of the pattern are the states of the model. Stars and nested stars are coded in state transitions. To develop the RSPS algorithm, the next step will be creating an adjacency matrix based on the state model of the pattern. The difference between state models in OPS and RSPS is that the RSPS model may include right to le ft transitions; however in the OPS state model we only face left to right or self loop transitions. Note that in both OPS and RSPS, le ft to right transitions are only between adjacent states. To complete the RSPS algorithm, we must now specify the computation of shift ( j ) and next ( j ) in the presence of nested stars. Consider the following sample graph based on the matrix (excluding the main diagonal): The entry  X  jk in our matrix correlates pattern predicates p k &lt; j , when these are evaluated on the same input element. Therefore, we can picture the simultaneous processing of the input on the original pattern, and on the same pattern shifted back by j  X  k . Thus the arcs between nodes in our matrix above show the combined transitions in the or iginal pattern and in the shifted pattern. In particular, consider  X  jk where neither p p in the original pattern, and to 1 + k p in the shifted pattern. This transition is represented by an arc  X  jk  X   X  j +1 ,k +1 is not a star predicate, while p k is, then the success of both will move p , to p k ,+1 , but leave p j unchanged. This is represented by the arc  X   X  j,k +1 . Using above mentioned algor ithm we calculate shift and next to perform RSPS Table 1 illustrates RSPS performance for double bottom pattern. We perform a comparison here between RSPS, OPS and na X ve search. To assess performance, we count the number of passes over the same input element while tested against a pattern element for both algorithms. The speedups obtaine d range from modest (simple search pattern without any recurring sub-pattern), to dramatic (more than two orders of magnitude obt ained on complex patterns found in actual applications). The following are interesting observations from our experiment.  X  RSPS speedup depends on the nature of the pattern query and  X  RSPS improves search speed even when there is no match for a This research was supported in part by the IMSC, A NSF Eng. Research Center, Cooperative Ag reement No. EEC-9529152, and in part by the United States Depart ment of Homeland Security through CREATE, grant number EMW-2004-GR-0112. [1] Knuth, D.E., Morris, J. H., and Pratt, V. R., Fast pattern [2] Sadri, R., Zaniolo, C., Zarkesh, A., Adibi, J. Optimization of 
