 1. Introduction
There have been many efforts towards providing agile business process management (BPM) support in recent years. Busi-ness process management systems (BPMS) have been recognized as a substantial extension to the legacy of workflow man-agement systems (WFMS). While a typical WFMS supports process design, deployment and enactment, an extension of
WFMS functionality provided by BPMS is the facilitation of process diagnosis activities [1]. Furthermore, new requirements emerging from the flexibility and dynamism of business processes require support for instance adaptation, which further evolution and improvement (cf. Fig. 1 ).

The process diagnosis phase refers to a wide range of BPM activities, including business process analysis (BPA) and pro-problems, discover preferred work practices, and provide business intelligence. Instance adaptation is an emerging paradigm due to various reasons such as changes in underlying business objectives and operational constraints, and unexpected events that cannot be handled by pre-defined exception handling policies. Consequently, the execution of process instances needs to be changed at runtime causing different instances of the same business process to be handled differently.
Over the last several years of developments in BPM research and industry, we see two equally strong but often conflicting forces impacting on the developments. Where as one fundamental aspect of BPMS and its predecessor WFMS, is to provide not prohibit the operational flexibility, to unacceptable levels.

There are many use cases for such requirements. For example, in in-patient hospital administration processes, where pa-tient admission procedures are predictable and repetitive, however, in-patient treatments such as X-rays, pathology tests, etc. are prescribed uniquely for each case, but none-the-less have to be coordinated and controlled. Another example can be found in higher education and professional training, where students with diverse learning needs and styles are working towards a common goal (degree program). Study paths taken by each student need to remain flexible to a large extent, time providing study guidelines and enforcing course level constraints is necessary to remain compliant with curriculum require-ments and maintain a certain quality of learning.

Similarly, consider an engineering firm that provides maintenance and advisory services for telecommunication faults and inquiries. Service plans for individual customer inquiries will be quite diverse, even though basic administration may ious concepts and methods.

Many research prototypes (MOBILE [18], ADAPT flex [30], Pocket of Flexibility [34], Worklets [5], DECLARE [29]) have instance-specific conditions, possibly some invariant process constraints, and their expertise. Current BPM solutions only process modeling notations (BPMN) [28] offers a concept called ad-hoc sub-process (AHS) that provides certain level of sup-port for instance adaptation requirements. AHS is a group of activities that have no pre-defined execution dependencies. A mined by the performers of the activities and cannot be defined at design time. Based on the runtime conditions and their domain expertise, the performers determine how to execute the activities within the AHS, namely the order of execution many potential execution possibilities of the AHS. 1
The sub-process illustrated in these figures can be considered part of a process that manages maintenance and advisory services for telecommunication faults and inquiries in a telecommunications company. Below we detail a typical scenario in tute a running example throughout the paper.

A telecommunications company receives customer enquiries about network connection problems, where each complaint case is assigned to a system engineer who is responsible for designing a service plan and solving the problem. The inquiry ically by a domain expert, such as a senior engineer, based on case specific properties and the experts knowledge and experience.
 There are eight diagnostic tests T 1 ; T 2 ; ... ; T 8 available in the process, as shown in Fig. 2 : Send Test Message ( T 1); Test Hub201 ( T 2); Test ExchangeA30 ( T 3); Reboot Srv59 ( T 4); Test ExchangeA37 ( T 5); Loop1078 ( T 6); Test Hub709 ( T 7); Test Hub544 ( T 8).
 ibility to design a service plan that best suits the individual case. The design decisions can only be made at runtime when case specific conditions are available and thus cannot be fully anticipated at design time.

Although constructs such as BPMN AHS can be flexibly configured to execute contained activities sequentially or in par-allel, there is no means for controls such as restricting the number of selectable activities, nor defining complex/partial dependencies among them. Techniques are required where part of the modeling effort is transferred to domain experts or knowledge workers who make design decisions at runtime under meaningful, domain-relevant constraints. In Section 3, we will provide an approach capable of capturing a large number of selection and scheduling constraints, thus providing a meaningful context for runtime instance adaptations.

At the same time, it can be observed that the typical consequence of an effective instance adaptation environment is the constraints, and provides valuable knowledge of work organization at the operational level. There is evidence that work practices at the operational level are often diverse, incorporating the creativity and individualism of knowledge workers and potentially contributing to the organization X  X  competitive advantage. Such resources can provide valuable insight into work practice, help externalize previously tacit knowledge, and provide valuable feedback on subsequent process design, improvement, and evolution.

Nevertheless, the way that domain experts reason about the situation during instance adaptation cannot be truly recon-structed using computational techniques. Building a repository to systematically capture, structure and subsequently delib-erate on the decisions that led to a particular design is a more pragmatic way to approach the problem. We observe that a process variant at least contains information from the following dimensions:
Structural dimension contains the process model based on which the process instance is executed. For process variants, the structural dimension is represented by the process model that is adapted from the design time model for the particular process variant during instance adaptation.

Behavioral dimension contains executional information such as the set of tasks involved in the process execution (may differ from structural dimension due to choice constructs), the exact sequence of task execution, the performers and their roles in executing these tasks, the process-relevant data, and execution duration of the process instance.
Contextual dimension contains descriptive information (annotations) from the process modeler about the reasoning behind the design of a particular process variant.

There are various occasions in the BPM life-cycle when precedents of process variants need to be retrieved. For example, preferred/successful work practice, and consequently contribute to the design of a given instance and subsequently to pro-cess improvements.

In this paper we will address both the above issues, namely techniques for supporting instance adaptation , and the utili-instance adaptation to support flexible business process management based on the notion of process constraints . This ap-proach transfers part of the process modeling effort to domain experts who make execution decisions at runtime. Instance adaptation is supported by techniques for specifying instance-specific process models and constraint checking in different Section 3.

We then introduce the key technique for managing process variants, namely a query formalization and progressive-refine-is a hard problem in general due to the informal nature of commonly adopted process description languages, and more so due to the subjectivity in process model conceptualization. Questions such as how to measure the similarity between two process variants having different process models but same sequence of task execution can come forth. From the behavioral perspec-tified, i.e., to be able to define a metric space to indicate the degree of similarity or dissimilarity.
The rest of the paper is organized as follows. Section 2 will provide background concepts for the underlying framework for supporting instance adaptation. In Section 3, we introduce the core concept of process constraints, based on which the in-stance adaptation framework is developed. Section 4 discusses how a repository of process variants manages a large number also provide a quantitative measure for defining similarity between process variants, covering structural, behavioral and tion 6, followed by the conclusion and future work in Section 7. 2. Framework for managing business process variants
The framework for constraint-based flexible business process management comprises of two major components, namely framework is presented, which shows how this framework can be applied to BPMS, and the relationship between BPCN and cycle.

The rationale of BPCN is to provide a descriptive way to build models for business processes where the complete process cannot be prescribed at design time. Essentially, BPCN captures the set of available tasks in a given business process, and approach relaxes rigid process descriptions into a set of minimal constraints, such that a variety of process models can be designed for different process instances, provided the relevant constraints are satisfied. The basic intuition and working of BPCN is described below.
 ing how these tasks can be selected and executed. This may be part of a larger process model defined in a conventional or model, the specification of process constraints reflects the process logic and hence the template and model become synon-ymous. However, the constraint representation of the process logic has a descriptive nature, which specifies what must be done but not how . The quality of the process constraints is then checked by constraint reasoning techniques, such that the is now ready for execution.
 now ready for execution. The available process activities of the newly created instance are assigned to performers through work lists and activity execution takes place as usual, until the instance needs to be dynamically adapted to particular requirements arising at runtime.

Instance adaptation takes place when a domain expert wishes to create an instance-specific variant of the process. The domain expert undertakes the task of dynamically adapting the instance template with available pool of activities, while to as a process variant .

The next step is to verifythe new modelrepresentingthe process variant,to ensure that it conformsto the correctness prop-function, in which case instance adaptation will be performed again.

BPCN is essentially a design approach, but is supported by an execution environment in which process instances can be tomized process variants, each of which has been constructed with the help of a domain expert utilizing expert knowledge as well as case-specific requirements.

After the process variant has been executed, the adapted process model and its runtime properties are acquired by PVR, which is a structured repository of storing executed process variants. PVR also provides support for reusing the retained information. Thus, PVR provides the support for process diagnosis and subsequent process improvement activities. These functions of the PVR will be discussed in Sections 4 and 5 . 3. Business process constraint network (BPCN)
The foremost factor in designing business processes is achieving improvements in the business outcomes [17]. However, tified that at least four sources of constraints have impact on a business process design: certain value.

Operational constraints are determined through physical limitations of business operations, e.g., minimum time for warehouse offloading.

Regulatory constraints are prescribed by external bodies and warrant compliance, e.g., financial and accounting practices (Sarbanes-Oxley Act), or batch identification for FDA in the pharmaceutical industry.

Contractual constraints define the contractual obligations of an organization towards its business partners, e.g., maxi-mum response time for a service.

In order to harness the full power of BPM techniques, each of these constraints should eventually be translated into con-
In BPCN, constraints can be modeled according to specific business requirements in some business domain by a process modeler, and a constraint network is then formulated according to the properties of the related business domain. This can be referred to as constraint modeling . In this approach, the process modelers manually transform the process knowledge into the executable form (as BPCN constraints). However, in the application areas where business process requirements are represented in a well-defined format, such as business contract or regulatory obligations, it is desirable for a systematic methodology for transforming well-defined contractual expressions to a set of executable constraints. This transformation process is referred to as constraint acquisition .

BPCN primarily provides the environment for constraint modeling in order to facilitate the instance adaptation frame-work introduced in the previous section. In BPCN, business process specification is undertaken through the specification of process constraints. Under the same process template, the selection, and the subsequent modeling of selected tasks can be largely different from instance to instance. When adapting a process variant at runtime, the first step is to choose instance, while some others may be optional and can be included/excluded for execution according to user preference and for expressing such restrictions on task selection.

Furthermore, there are constraints that define how the selected activities are performed, both in terms of ordering as well which constitute the specification of task selection restrictions and the dependencies within these tasks including control dependencies (such as sequence, alternative, parallel, etc.) and inter-task temporal dependencies (such as relative dead-lines). Such constraints are defined in graphical notations provided by BPCN, which can be used to conceptually express requirements for instance adaptation by general process modelers who have little or no formal background. With the help of examples, this section briefly introduces how to apply business process constraints to achieve flexibility in process management.

Consider the process given in the figure. This represents the scenario introduced in Section 1. Recall that any number of service plan that best suits the individual case. The design decisions can only be made at runtime when case specific con-ditions are available and thus cannot be fully anticipated at design time. At the same time, some dependencies and restric-tions among the available tests can be abstracted beforehand, such as below: T 1, T 4 and T 8 are basic tests and must be performed for all testing cases;
Based on operational guideline, minimal four tests have to be performed to guarantee accuracy, while maximal six tests can be selected for efficiency; Testing ExchangeA30 ( T 3) depends on the result of test data of Hub201 ( T 2), and must be performed after Hub201; Either Hub709 ( T 7) or Hub544 ( T 8) needs to be tested as they are located on the same communication bus; ExchangeA30 can only be tested ( T 3) when Srv59 is rebooting ( T 4).

The abovementioned restrictions and dependencies can be considered as constraints on tests selection (i.e., the require-ments on mandatory selection, and the number of tests) and scheduling (the order of execution). However, it is obvious that there are three mandatory tests that have to be chosen all the time, the engineer can still choose to perform exactly four, five or up to six tests. In combinatorial terms, there are C ditions for the alternative branches.
 supports a typical graph-based process model and a state-based execution model. Such process models support typical con-available, commenced, suspended, and completed. This is a common environment for many commercial process manage-ment systems, and therefore our approach has minimal impact on underlying systems. For the subsequent discussion on pro-cess constraints, we first introduce some basic terms.
 tween the properties of tasks in T . 3.1. Selection constraints
We now define various selection constraints and their graphical notations that can be used to conceptually express task selection requirements. The notations are developed for process modelers who have little or no background in constraint semantics.
 The following classes of selection constraints have been identified:
Mandatory constraint man defines a set of tasks that must be executed in every process variant, in order to guarantee that intended process goals will be met.
 Prohibitive constraint pro defines a set of tasks that should not be executed in any process variant.
Cardinality constraint specifies the minimal min and maximal max cardinality for selection among the set of available tasks.

Inclusion constraint inc expresses the dependency between two tasks T restriction that T y must also be included. Prerequisite pre constraint is the inverse of an inclusion constraint.
Exclusion constraint exc prohibits T y from being included in the process variant when the T
Substitution constraint sub defines that if T x is not selected, then T former.

Corequisite constraint cor expresses a stronger restriction in that either both T be selected, i.e., it is not possible to select one task without the other.

Exclusive-Choice constraint xco is also a more restrictive constraint on the selection of alternative tasks, which requires at most one task can be selected from a pair of tasks  X  T visual representation for selection constraints, as indicated by the labels.

Below we provide the formal consideration for selection constraints. Let T  X f T process template PT . Each task T i is considered as a propositional variable ranging over domain D for the presence of task T i in a process variant V and T
Mandatory, prohibitive and cardinality constraints can be defined by restricting the domains of respective tasks. A man-datory task T i 2 T is denoted by man  X  T i  X  , where man is a property of T datory tasks in a process template PT is given by: hibitive task T x can be denoted by pro  X  T x  X  , where pro is a property of T a process template PT is given by:
A minselect constraint is denoted by R min  X  m  X  # T , such that j R restricts that every process variant V should contain all tasks in R constraint is denoted by R max  X  n  X  # T , such that j R max  X  n  X 
The mandatory, prohibitive and cardinality constraints are defined by restricting the domain of a single task. On the other ment constraints. For example, An inclusion constraint R inc only if ( iff ):
An inclusion constraint R inc defined on tasks T x ; T y reads T tion, it expresses that when T x is selected, T y must also be selected ( T narios are permitted: neither T x nor T y is selected, i.e., (0, 0);
T y is selected without T x , i.e., (0, 1); both T x and T y are selected, i.e., (1, 1).

The scenario  X  1 ; 0  X  is prohibited where T x is selected without T of T x and T y .

Similarly, an exclusion constraint R exc is a binary relation on a pair of variables T
An exclusion constraint prohibits the selection scenario  X  1 ; 1  X  where both T for the definition of the containment constraints. 3.2. Scheduling constraints
Scheduling constraints take advantage of the temporal property of each task in a process template, namely the execution duration . Suppose each task T i is given an expected execution duration dur  X  T by its execution duration (as an interval), the inter-dependencies between these tasks can be modeled [6]. The following classes of scheduling constraints have been identified [22]:
Before constraint expresses that tasks T x and T y should be arranged sequentially, but not in adjacency in the process model.

Meet constraint expresses that T x and T y are to be arranged sequentially, and in adjacency, i.e., T in adjacent to each other (consecutive placement).

Order constraint is less restrictive that expresses T x and T cency). If a pair of tasks  X  T x ; T y  X  satisfies either Before or Meet , it also satisfies Order constraint.
Starts constraint expresses a restriction on commencement time of executing tasks T arranged in parallel, and commence execution at the same time. In addition, T
Finishes constraint expresses a restriction that T x and T time. In addition to both tasks completing execution at the same time, T
During constraint expresses that T x and T y are arranged in parallel, and T commenced, and must complete execution before T y completes.

Equals constraint restricts that T x and T y are arranged in parallel, and commence and complete execution at the same time.

Parallel constraint is also less restrictive that expresses T either Starts , Finishes , During ,or Equals constraint, it also satisfies Parallel constraint.
The set of scheduling constraint notations is summarized in Fig. 7 . 3.3. Validation of constraints
We now use the running example introduced previously to demonstrate constraint specification and validation. Suppose constraints: Mandatory task T 1, T 4 and T 8; Minimal selection of 4 and maximal selection of 6 tasks; T 2 is the prerequisite of T 3; T 7 and T 8 are of exclusive-choice ; Order between T 2 and T 3; T 3 starts T 4.
 straint set must firstly ensure that any hidden facts in the constraint specifications are explicitly shown. This makes the constraint specification non-redundant and understandable, and is particularly useful for domain experts when concretizing nario where no constraint is violated. In other words, to avoid contradicting constraint specifications. For example,
T ically satisfied from a given set of constraints.

In order to provide a means of validating the constraints, the constraint specification is transformed into respective con-underlying theory to formally model and reason about process constraints. Selection (SCN) and scheduling constraint net-works (TCN) are defined to provide formal semantics to validate the constraint specifications. SCN and TCN can also be used to check for the conformance of the adapted process variants at runtime. This is ensured through the enforcement of network consistency in SCN and TCN. SCN is a binary Boolean constraint network, and TCN is a qualitative temporal constraint net-work. The complexity of the consistency checking algorithm is bound by the number of constraints in the network. Formal and process variant verification techniques are discussed in detail.

Below we present the basic intuition behind the validation procedure using the running example, where in there are some made explicit. 3.4. Runtime verification for variant design
The process constraints in BPCN express minimal restrictions on task selection and scheduling for all business process design process variants during instance adaptation. This section demonstrates how instance adaptation is supported at runtime.

Instance adaptation is generally performed in two steps, namely task selection and task scheduling. A domain expert first chooses from the task pool, the set of tasks to be performed in the current process variant. Based on which, the domain ex-pert can then assign an expected execution duration for each task and then define the flow dependencies for the selected tasks.

As a result, each process variant contains a complete process model (cf. Definition 1 in Section 4). A process variant is executable in that the process model with flexible components have been concretized, i.e., the set of tasks to be executed, and the assignment of exactly one temporal relation between each pair of tasks are defined in the process model. Any user task selection and schedule satisfy the constraint specification.

Fig. 10 shows four concretized process variants for the example process template (cf. Fig. 5 ). For ease of discussion, the uling constraints.

In Fig. 10 , variants V 2 , V 3 and V 4 satisfy all relevant selection and scheduling constraints. In particular, variant V the only applicable scheduling constraint T 3 starts T 4 is satisfied. Variants V tasks which also include all mandatory tasks. All three scheduling constraints are applicable and satisfied. viously violated constraints can be satisfied. The complexity of the verification algorithms is bound by the number of con-straints in the constraint network. 3.5. Summary tively. This section further demonstrates the applicability of BPCN, which aims at presenting how instance adaptation is supported at runtime . Different process models can be built/tailored for individual process instances at runtime. Such in-stance-specific process models (process variants V ) contain a complete process model that is defined by domain experts at runtime during instance adaptation. With the possibility for generating a large number of such process variants from the execution environment, the following section on process variant repository will demonstrate how such valuable infor-mation can be managed and reused. 4. Process variant repository framework, process variants and their properties will be retained in a repository, called process variant repository (PVR). Over time, PVR can build into an immense corporate resource.

The fundamental goal of PVR is to provide an appropriate characterization to describe the preferred work practices rep-resented through process variants, and subsequently generalize the conditions contributing to the preference. PVR provides query requirements. 4.1. Reference architecture
The capture of executed process variants and the subsequent retrieval of preferred process variants are the two major functions of PVR [23]. Fig. 11 presents an overview of the PVR reference architecture.
 the instance adaptation mechanism of BPCN. Later, a query is formulated to specify variant retrieval requirements (Step 3).
The query requirement is formulated with the help of the query processing component. In Step 4, the repository is searched the degree of similarity relevant to the query. The further selection involves a ranking process. Step 4 X 5 will be repeated tive set of results. 4.2. Process variant schema from a common design time process templates and hence can have a significant overlap as well. Before we present the sche-ma of process variant, we first define two important concepts, including process model and execution sequence. Merge , where Begin node represents the beginning of the process model; End node represents the end of the process model; Choice node represents the divergence of a single path into two or more mutually exclusive alternative paths (cf. XOR-Split, Exclusive Choice); Merge node represents the convergence of two or more mutually exclusive alternative paths into a single path (cf. XOR-Join, Simple Merge); Fork node represents the divergence of a single path into two or more parallel paths (cf. AND-Split, Parallel split);
Sync node represents the convergence of two or more parallel paths into a single path (cf. AND-Join, Synchronization). are excluded from its coordinator nodes. Task nodes represent atomic manual or automated activities or sub processes (rep-resenting nesting) that must be performed to satisfy the underlying business process objectives. Coordinator nodes allow us to build control flow structures ( fork ; choice ; loop , etc.) to manage the coordination requirements.
An execution sequence of a process variant is referred to as the trace of execution in a process model, which reflects the h T 1 ; T 3 ; T 4 ; T 6 ; T 5 i and h T 1 ; T 3 ; T 4 ; T 5 ; T 6 i are four possible execution sequences in W actly one execution sequence resulting from execution.

We follow the general mathematical definition to define an execution sequence: a finite sequence s  X f s function with the domain 1 ; 2 ; ... ; n , for some positive integer n . The i th element of s is denoted by s
Definition 2 ( execution sequence ). An execution sequence s W of a process model W is a finite sequence of tasks T which is defined by the sequence h T 1 ; T 2 ; ... ; T n i , n P 1.

W The superscript W of an execution sequence s W for a process model W can be omitted if no ambiguity is caused.
We now provide a definition for the process variant schema. A retained process variant in PVR is referred to as a case and represents the complete design and runtime properties of a variant.

Definition 3 (process variant schema). A case V is defined by  X  id ; W ; s W ; Res ; Dat ; T ; Com ; Mod  X  , where id is the identifier for the process variant V ;
W is the process model  X  N ; E  X  for V defined on the task set T # N ; s W is the execution sequence of tasks T in V based on W ; Res  X f Res 1 ; ... ; Res m g is a finite set of resource instances allocated to execute V ; Dat  X f Dat 1 ; ... ; Dat k g is a finite set of workflow-relevant data items related to V ;
T  X f T 1 ; ... ; T n g is the set of tasks in V , 8 T i 2 T , T  X  n i is the identifier of T i ;  X  Res i 2 Res is the resource instance allocated to T i ;  X  T i and T  X  i are the time stamps when T i commenced and completed execution; Com is an annotation that textually describes the design of the variant; Mod is the set of modeler(s) who participated in the instance adaptation for V .
 cess variants, that is PVR  X f V 1 ; ... ; V n g .

PVR is expected to contain a large number of process variants. Table 2 shows some example process variants in PVR based on the graphical process models presented in Fig. 12 . Only the variant id , model W and execution sequence s is shown for in the same way), while the execution sequences may still be different.

For example, V 1 and V 8 have the same process model W a , while due to instance-specific runtime conditions, the execu-tion sequences are different. However, V 1 and V 5 have the same execution sequence although their process models differ. be discussed in the next section. 5. Query processing
PVR uses queries to express requirements for process variant retrieval. Based on different retrieval requirements, a query variants. Many of such features can be expressed by a typical structured query language, and can mostly be satisfied using of execution ( j T  X  i T i j &lt; 3 h) and the allocated resource instance ( Res
Unlike traditional query systems however, the search criteria for process variants may also include reference to complex (T7) , etc. (cf. W c in Fig. 12 ), or simply having the same process model as given in the query.
For queries containing structural features, we propose that the query requirement be expressed in a way similar to the query-by-example (QBE) paradigm, where a process model W Q features, and the objective is to retrieve all cases with a process model W similar to W tures to be retrieved.

Besides structured feature, a query may also include multi-dimension features found in the process variant schema. For example, tasks T1, T2 and T3 were performed by a senior engineer in sequence, and finished execution within 1 day ( W Fig. 12 ).
 process variant similarity, however, are focus on the more complex structural features ( W and s W ). Definition 4 ( query ). Let F be the set of all features in PVR. A query Q is defined by the set of query features f F process variant features, i.e., Type : F # TYPE , where TYPE  X f id ; W ; s W ; Res ; Dat ; T ; Com ; Mod g . 5.1. Similarity of process variants
In order to determine the degree of match between the desired process variant as described by query features and the potential match, the notion of similarity measure needs to be defined.
 Given a query Q with one or more query features f F Q 1 ; ... ; F f F 1 ; ... ; F different feature F i , a similarity function sim should be defined according to the specific semantics of the type of F all similarity score Sim  X  V ; Q  X  is the average of the similarity score for each pair of comparable features  X  F and Type  X  F V i  X  X  Type  X  F Q i  X  .

We define the metric space for process variant similarity in the interval of real numbers between 0 and 1, where 0 indi-cates complete dissimilarity, and 1 indicates complete matching, and a number between 0 and 1 for partial matching. In or-der to distinguish different similarity functions, the feature type is appended to the function symbol sim , e.g., sim the similarity function defined for feature F 1 . Note that we refer to sim  X  F Definition 5 ( generalized similarity ). Let Q  X f F Q 1 ; ... ; F similarity ( Sim ) between the process variant V and the query Q is given as: wherein  X  F V i ; F Q i  X  is a pair of comparable features.
 defined based on known techniques. For example, simple set membership can be used to compare resources specified in the sequences [38]. Case based reasoning has been used to match variants against textual descriptions [35]. 5.2. Structural similarity
The structural feature of process variants is described by a complete or partial process model. Structural aspect is argu-fying the degree of match for structural feature, especially for ranking partial matching process models.
Nevertheless, it is argued that graph-based similarity measure alone is inadequate for determining complex matching can be quantified to some extent. Such that, when the closeness of the query process model and process variant model can-not be visually observed, partial matching variants can be presented using a ranking function to produce a similarity score base on the metric space.

Furthermore, as discussed in previous example (cf. Table 2 ), it is often the case that exact matching execution sequences may result from different process models. While from the same process model, different execution sequences can be derived.
There has been study towards the interplay between the similarity of design time process models and actual execution se-more weight towards the overall structural similarity score.

Based on this observation, it is proposed to define the structural similarity according to both the structural and the exe-cution behavior of the process model, i.e., the execution sequence. Given the structural feature (as described by a process model) W Q of a query Q , it is used to retrieve all process variants V in which their process model W is similar to W approach is to first qualify the initial structural matches between a particular W and W where complete and (near perfect) partial matches can be visually identified. A ranking algorithm (similarity function) is then applied for the (not so perfect) partial matching process models to produce a similarity score between each such model W .
 Definition 6 (structural similarity). Let W  X  X  N ; E  X  be the process model of a process variant V , and W process model.

W is said to be structurally equivalent to W Q if N  X  N Q
W is said to structurally subsume W Q if N Q 2 N , and W Q ified in W ; W is said to structurally imply W Q if N Q  X  N , and W Q preserves the structural constraints between nodes N W .

Additionally, if W and W Q conform to equivalent relationship, they also conform to subsume and imply relationship. Given a query process model W Q , a variant process model variant W is said to be a complete match to W relationship holds between W and W Q .( Imply relationship holds means near prefect partial matches.) The technique to determine complete match is by SELECTIVE-REDUCE [21], which applies graph reduction techniques to determine the match and secondly to reduce redundant flow relations in E using reduction rules.

The algorithm is provided in Appendix A for completeness. Fig. 14 shows the result of applying SELECTIVE-REDUCE to process variant models W a to W e (cf. Fig. 12 ) according to structural query process model W cess models consist of only tasks f T 1 ; T 2 ; T 3 ; T 4 ; T 5 g as in W turally equivalent to W Q a , which is considered as a complete match.

In the rest of this section, the progressive-refinement approach for query execution including the ranking technique for partial matches is presented. 5.3. Process variant retrieval based on progressive-refinement In the query processing approach, given a query Q  X f F CV
Q  X f V 1 ; V 2 ; ... ; V m g is first chosen from PVR, where each V f F 1 ; ... ; F F j that is comparable to F
V will remain in the candidate set CV Q . While for those containing partial matching features can be ranked according to CV Q . The process variants  X  X  X ot similar enough X  are removed from CV compared, or the ideal result set is obtained. The overall similarity score can be calculated for each process variant V the result set by applying Sim  X  V i ; Q  X  . Fig. 15 provides an illustration for this approach.
For simple matching features, applying similarity function sim produces a ranking for partial matches. The filtering step for complex matching involving structural features however, is to apply SELECTIVE-REDUCE (Section 5.2), which qualifies the structural relationship between the reduced process variant models and the query process model, when complete matches result that fits in the metric space for ranking partial matches. 5.4. Ranking partial matches quantitative measure for ranking partial matching variants, we take into consideration both the model similarity and the execution behavior of the models. To evaluate two given process models, we take a list of typical task execution sequences, and evaluate how similar the two models behave in terms of the possibility to produce the whole or partial sequences as in the list. The more sequences the two models support in common, the more similar they are. As a result, a similarity measure is produced. We complete the ranking procedure when this comparison has been repeated between the query process model and each different process model among the partial matching process variants. Which means, the process variants sharing the same process model will be assigned the same ranking.

In particular, the ranking technique, called RANK-STRUCTURAL, calculates the structural similarity between a reduced variant process model RW and the query process model W Q , with reference to a set of execution sequences S . When given S is the collection of all different execution sequences ( s W ) from each process variant V in CV ibrated with the number of times it appears or appearance count  X  s  X  in CV The algorithm repetitively compares the two models according to how well each different execution sequence fits in both models. In this way, applying RANK-STRUCTURAL for RW and W reduced variant models RW in CV Q . After applying this algorithm to each different process model in CV partial matching process variant can be produced.
 The algorithm as shown in Fig. 16 takes as inputs a reduced process variant model RW , the query process model W
D , and produces a similarity score sim between RW and W Q
Trigger  X  W ; T i  X  denotes the set of tasks that can be triggered by task T tasks after the coordinator can be triggered, e.g., Trigger  X  W
Disable  X  W ; T i  X  denotes the set of tasks disabled as the consequence of executing T tics of the Choice coordinator. For example, Disable  X  W b T 3 is executed but not both.

The algorithm repetitively takes a unique sequence s from D for comparison (Step 3). Then for every task T ferent sequence s (Step 4), TW is given the current set of triggered tasks as the result of executing task T
Similarly, TQ is given the current set of triggered tasks as the result of executing task T in s , the proportion of tasks in W Q triggered by T j , which are also triggered by T similarity score (resulting from counter ) for RW and W Q
Discussion : The algorithm is adapted from the so-called behavioral precision and recall approach from [4] for ranking par-iant similarity. The list of common execution sequences that is extracted from the reduced process models is used as a benchmark for the comparison. The complexity of the algorithm is bound by the number of tasks in W However, it can be naturally extended to support other graphical model definitions such as BPMN [28] with exclusive because (1) any execution of arbitrary loop in the process variant model is reflected by the logged execution sequence, and (2) the algorithm compares the two models by trying to reproduce the same sequence on both models and check for the priate location, which would reproduce similar execution sequences with repeated tasks. Note that the measure is asymmet-ric, i.e., sim  X  RW ; W Q  X   X  sim  X  W Q ; RW  X  . 5.5. Example
Suppose it is required to retrieve process variants that any performer of role senior engineer was involved in executing a process model similar to W Q a , and its execution duration is less than 3h . A query Q  X f F sion features is formulated. F Q 1 = f senior engineer g is the resource feature. F the task level features in T . Lastly, F Q 3  X  W Q a is the structural feature of Q , as defined by the query user.
The initial candidate set CV Q  X f V 1 ; V 2 ; ... ; V m g is first chosen from PVR. 8 V F 1  X  role  X  Vi  X  , F cation-specific way, e.g., duration  X  V  X  X j T  X  n T l j , where T and T l is the start time stamp of the first task in its execution sequence. It can start filtering process variants in CV Applying sim F 1  X  V i ; Q  X  for each V i 2 CV Q the set of complete matching variants can be identified, i.e., sim F 1 = F variants having complete matching feature F V i 1 (when all partial matching variants are removed from CV is further filtered by applying sim F 2  X  V i ; Q  X  for each remaining V and for all F V i 3 in CV Q there are five common process models f W
To filter by the structural feature F Q 3 , we first aggregate all V
Table 4 ). Then applying SELECTIVE-REDUCE to each different W (cf. Fig. 14 ). The equivalent relationship between RW c and W complete matches to F Q 3 , and the rest are partial matches. Applying RANK-STRUCTURAL to the partial matches against W provides the similarity ranking. The collection of execution sequences S and counters D from all W as shown in Table 3 . In this case S contains seven different execution sequences, from 150 process variants.
Table 4 shows the structural similarity ranking after applying RANK-STRUCTURAL to the each partial matches W W
V 2 CV Q where F V i 3 2f W c ; W a ; W d g , e.g., f V 2 ; V 6. Related work
The requirements for providing flexibility in process models and execution stem from the need for change in business ible workflows and has been receiving much attention in recent years. Industrial standard modeling language BPMN [28] proach [18]. Since then, there have been many proposals offering various solutions [3,5,7,8,12,19,25,27,30,34] . modeling and late composition [36].

Late selection is the approach that allows for selecting the implementation for a particular process step at runtime either (repertoire) containing a number of different worklets is maintained for a worklet-enabled activity, such that at runtime a rules which associates a worklet with a series of instance-specific conditions.

Late modeling is the approach where parts of the process schema have not been defined at design time, but are modeled at runtime for each process instance. For this purpose, placeholder activities are provided, which are modeled and executed during runtime. The modeling of the placeholder activity must be completed before the modeled process fragment can be of unstructured inner activities. A fundamental feature is specification of build constraints which essentially control the modeling of the unstructured activities. Late modeling starts when the pocket is instantiated. Then a domain expert defines number of instance-specific process models. The BPCN framework presented in this paper is its natural extension, which fur-ther provides a richer taxonomy of process constraints with rigorous support for verification based on an underlying formal theory.

Recently, there have been further developments in such declarative approached to process modeling [29], which further re-enforces the need for transferring some of the modeling effort to domain experts at runtime.
Late composition is the paradigm where the instance-specific process model is composed at runtime. This is realized by on-the-fly definition of the control flow dependencies between a set of process fragments at runtime time.
The issue of managing business processes as an information resource was first brought into attention by [20], and has become an important and challenging problem in the field of advanced BPM techniques. Leymann and Altenhuber [20] point out that process models containing constraints, procedures and heuristics of cooperate knowledge should be regarded as operations.

Traditionally this corporate knowledge is represented in process models in various cooperate information systems. How-ever, it is quite often nowadays that a large amount of variances are produced during business process execution. Managing such process variants and subsequently reusing the knowledge from the variants needs to be supported explicitly. In many executions. As a result, various process mining techniques [2] have been proposed, aiming at reconstructing meaningful pro-cess models from executional data. The reconstructed process models can then be used to facilitate a range of process rede-sign and auditing activities such as to compare with the design models such that the runtime behaviors such as exception handling and derivations can be discovered and diagnosed. In addition, more specific techniques have been proposed to rep-to the process model.

The proposed approach is different from the process mining approach, with the emphasis on supporting knowledge schema defined to provide an appropriate characterization to describe the preferred work practices represented through process variants, and subsequently facilitate processing queries with complex requirements for process variants retrieval. ilarity between two given process models. There have been many proposals for defining process equivalence based on single cess variant properties in multiple dimensions.

Similarity continues to pose several challenges in a number of areas such as string matching, document matching, audio/ video matching, etc. Noteworthy contributions that enable a better understanding of the notion of similarity from a process based on so-called causal footprints, and [15] that tackles the problem from a metadata perspective. Complementary work pact on the complexity of similarity detection computations. Recently introduced re-factoring [37] of process models may assist in this regard, although further research is warranted before practical solutions can be fully supported. 7. Conclusion and future work
Variations in work practice often represent the competitive differentiation within enterprise operations. In this paper we have argued for acknowledging the value of variants in business process management platforms. We have presented how geted business process. The selection and scheduling constraints are specified at design time, through intuitive constraint to design compliant process variants during instance adaptation. We have also presented an approach for managing such process variants as an information resource, thus providing a whole-of-cycle solution. The presented methods provide effec-tive means of searching and matching process variants against a given query from simple to complex aspects, and generate result sets that can be conveniently ranked, thereby empowering process designers to tap into effective precedents. In our future work we are planning to implement the query processing approach so that empirical evaluation can be performed and scalability and complexity analysis can be rigorously conducted.
 Appendix A. SELECTIVE-REDUCE algorithm
The goal of the original algorithm in [32] is to reduce a process graph into an empty graph in order to verify structural correctness. In our approach, the algorithm is modified to reduce a variant that has an equivalent or subsume relationship be found in [32].

The following terms and functions will be used to present the method. For a given process model W  X  N ; F  X  : size  X  W  X  size  X  N  X  size  X  F represents the total number of nodes  X  N  X  and flows  X  F  X  in W .
For each flow f 2 F , following basic attributes are defined: fromNode  X  f  X  n where n 2 N represents from node of f . toNode  X  f  X  n where n 2 N represents to node of f .

For each node n 2 N , following basic attributes are defined: nodeType  X  n 2f task ; coordinator g represents type of n . coordinatorType  X  n 2f fork ; synchronizer g . dout  X  n  X  out degree of n , i.e., number of outgoing flows from n . din  X  n  X  in degree of n , i.e., number of incoming flows to n .
 OutFlows  X  n  X f f : f 2 F ; fromNode  X  f  X  n g , i.e., the set of outgoing flows from n .
 InFlows  X  n  X f f : f 2 F ; toNode  X  f  X  n g , i.e., the set of incoming flows to n .
 F  X  W  X f f : f 2 W g , i.e., the set of flows in process model W .

N  X  W  X f n : n 2 N g , i.e., the set of nodes in process model W . delete n is a procedure that removes n from N  X  W and the set of outgoing flows OutFlows  X  n from n . The algorithm is presented as follows: Procedure SELECTIVE-REDUCE Input: Process model W , query graph Q Output: Reduced process model RW
Method: end while /*Closed -reduces redundant flow from fork to sync*/ if lastsize  X  size  X  W then
References
