 ORIGINAL PAPER Liu Wenyin  X  Wan Zhang  X  Luo Yan Abstract An interactive example-driven approach to graphics recognition in engineering drawings is pro-posed. The scenario is that the user first interactively provides an example of a graphic object; the system instantly learns its graphical knowledge and uses the ac-quired knowledge to recognize the same type of graphic objects. The proposed approach represents the graphical knowledge of an object in terms of its structural compo-nents and their syntactical relationships. We summarize four types of geometric constraints for knowledge rep-resentation, based on which we develop an algorithm for knowledge acquisition. Another algorithm for graphics recognition using the acquired graphical knowledge is also proposed, which is actually a sequential examina-tion of these constraints. In the algorithm, we first guess the next component X  X  attributes (e.g., size, position and orientation) by reasoning from an earlier found compo-nent and the constraint between them, and then search for this hypothetical component in the drawing. If all of the hypothetical components are found, a graphic object of this type is recognized. For improving the system X  X  recognition accuracy, we develop a user feed-back scheme, which can update the graphical knowledge from both positive (missing) and negative (mis-recog-nized) examples provided by the user for subsequent recognition. Experiments have shown that our proposed approach is both efficient and effective for recognizing various types of graphic objects in engineering drawings. Keywords Graphics recognition  X  Interactive graphics recognition  X  Engineering drawings interpretation 1 Introduction Conversion from paper-based engineering drawings to electronic drawings (especially, CAD format) is in great demand in many engineering domains since the elec-tronic engineering drawings have many advantages over the paper-based drawings, including less storage space, lower environment requirements, and easier manipula-tion and management. The problem of converting engi-neering drawings to a CAD format has been referred to as CAD conversion. It is quite easy for human engineers to do CAD conversion. However, machines do not (at least by now) have most of the human capabilities of vision, imagination, reference, and knowledge of engi-neering drawings. They therefore have great difficulties in understanding engineering drawings.

The CAD conversion problem can be specified in detail as the following three sequential levels: (1) basic primitive recognition, (2) composite graphics recogni-tion, (3) entire document analysis and recognition. For the first level, the usual solution is transforming a ras-ter image to a vector form and obtaining the low-level graphic primitives, such as lines, circles, arcs, etc. The sec-ond level performs recognition of high-level composite graphic objects, which are composed of low-level prim-itives. In general, a significant part of many engineering drawings is made of entities that can be classified as composite graphic objects. Therefore, graphics recogni-tion is a kernel problem for automatic interpretation of engineering drawings. At the third level, much more intelligent interpretation and analysis can be carried out, such as 3D reconstruction, indexing, browsing, content-based retrieval, etc.

As we mentioned, the second level, composite graph-ics recognition is one of the key problem. It is not a new problem but has been studied for more than 20 years. Actually, graphics recognition has received and contin-ues to receive much attention from many researchers. There is a wealth of papers published and studies carried on this subject since the 1970s. In a sense, graphic objects are simpler than those arbitrary-shaped patterns, such as face and fingerprint, however, it seems that complete graphics recognition has not been done satisfactorily, as Tombre [23] commented,  X  X one of these methods works. Actually, the methods do work, but none of them is perfect. X  Main reasons include that there are so many types of graphic objects in so many domains and they can appear at any position, in various scales and orienta-tions, and they are often interwoven with one another. There is no single method suitable for recognizing all types of graphic objects.

Existing graphics recognition techniques can be cat-egorized as statistical methods and structural/syntacti-cal methods according to their paradigms. The former class, e.g., [4], uses statistical methods to extract various features from enormous samples to train the models, and then recognizes graphic objects by comparison with the existing models. While the latter class, e.g., [7], first defines the structural knowledge of particular graphic objects in terms of the constitutional components and their relationships, and then employs syntactical algo-rithms to produce the final recognition results. Both clas-ses claim that they overcome the difficulties of the other class; however, they also suffer from their own unsolved difficulties. Actually, both classes do have made signifi-cant progress in recent years. Hence, the most promising way is perhaps to explore a new paradigm which inte-grates well with their advantages and avoids their weak-nesses. The statistical methods can automatically learn from large numbers of training samples to achieve rea-sonable recognition ability. Structural/syntactical meth-ods utilize higher level knowledge than pixel level but they rely on predefined semantic knowledge. Engineer-ing drawings contain numerous types of graphic objects, so producing templates or defining knowledge for each type of graphic object is nearly impossible and unaccept-able. Hence, an incremental learning strategy is strongly desired. That is, the system should automatically learn the knowledge of a particular class of graphic objects from a limited number of samples. When a new sample of the same graphic object is provided, the system should instantly and incrementally update the earlier learnt knowledge, such that high recognition accuracy can be achieved. A strategy that seems to satisfy these require-ments is interactive, example-driven recognition, which can efficiently and flexibly control the graphics recogni-tion process in all phases, including learning new knowl-edge, applying knowledge to recognition, and maintain-ing old knowledge. Liu [14] has explored and proposed a basic framework for this purpose, which is based on a generic graphics recognition algorithm [11, 12].
In this work, we follow and extend the basic frame-work proposed by Liu [14] and apply it to the recognition problem of composite graphic objects in engineering drawings. The scenario is that the user interactively pro-vides an example of the graphic object, which can be selected in an engineering drawing, and then the sys-tem automatically and immediately learns the graphi-cal knowledge of this type of graphic object from the example and uses this learnt knowledge to recognize or search for other similar graphic objects in this or other engineering drawings. The user can further indi-cate some mis-recognized and non-recognized examples and/or confirm some correctly recognized examples, and the system then refines the knowledge of this type based on these feedback examples.

We summarized four types of geometric constraints to represent the generic graphical knowledge of graphic objects. They are Intersection, Parallelism, Perpendic-ularity, and Arc/Circle; based on these geometric con-straints, we developed an algorithm for knowledge acquisition. The algorithm first obtains an attributed graph, in which the nodes represent the components and the edges represent their relationships. A spanning tree is then constructed from this graph and a fixed tra-versal path is finally determined, in which the sequence of geometric constraints is stored as the graphical knowl-edge for this type of graphic object. Another algorithm for graphics recognition using the acquired graphical knowledge is also proposed, which is actually a sequen-tial examination of these constraints along the fixed tra-versal path. In the algorithm, we first guess the next component X  X  attributes (e.g., size, position and orien-tation) by reasoning from an earlier found component and the constraint between them, and then search for this hypothetical component in the drawing. If all these hypothetical components are found, a graphic object of this type is recognized/found.

A user feedback scheme is developed for refining the graphical knowledge from multiple feedback examples, which can be either positive (confirmed as correct, or indicated as missing in the last round of recognition) or negative (mis-recognized). Actually, each parameter in the graphical knowledge is associated with a tolerance, whose allowed values are also learnt from the examples and are therefore different for each graphic object type. The user feedback scheme just updates the old graphi-cal knowledge for later recognition. Using this feedback scheme, the system obtains an incremental learning abil-ity and much more powerful recognition ability.
The rest of the paper is organized as follows. In Sect. 2, we briefly review related works. In Sect. 3, the system architecture of our proposed approach is presented and the submodules of the system are described in detail in Sects. 4, 5, 6, and 7, respectively. Finally, experimental results and concluding remarks are presented in Sect. 8 and Sect. 9, respectively. 2 Related works Literature on graphics recognition comes from many sources. For example, Kasturi and Tombre [9] launched the series of LNCS books on graphics recognition. Many works can be found on engineering drawings vectoriza-tion (e.g., general line detection and/or arc detection from line drawing images [6, 13]), which is usually the first step of engineering drawing interpretation. There are also quite a lot of approaches developed for recog-nition of various types of graphic symbols or objects, as reviewed by Llados et al. [15]. Many of these approaches, e.g., [17] and [22], assume that symbols or objects have been previously segmented. However, it is not always feasible to break the drawing into unique constituent components. For example, it is quite hard to do seg-mentation when objects touch and/or overlap with oth-ers, especially at the pixel level. At the vector level, the case is simpler since vectors carry more semantics than pixels. At least in some application domains, the symbols can be separated from the rest of the draw-ing in terms of knowledge (i.e., structural and syntactic descriptions) of the notation. For example, Vaxiviere and Tombre [24] predefined the knowledge for recog-nizing shafts in mechanical drawings as follows: starting from a threaded block or a block containing a partial section and located on only one dot X  X ashed line.
Learning representation (i.e., graphical knowledge) of graphic objects from examples is not new. Conceptual clustering is a well-known approach to this traditional AI problem. The knowledge of a type of object is actu-ally a concept. Winston [25] is probably the first one who attempts to learn structural descriptions from graphic examples. Starting from the ideas of structural learn-ing, some promising approaches have been proposed to learn pattern representation from examples. Wong and You [26] propose a statistical and structural combined approach. They define random graphs as a particular type of graphs which convey a probabilistic description of the data. A process is defined to infer a synthesized random graph minimizing an entropy measure. Segen [21] develops a graph-based learning method that can learn a set of common relations between the compo-nents among a set of examples. Cordella et al. [5] de-scribe the graph that represents the objects with a set of logic predicates and employ inductive logic program-ming to modify these predicates from a set of examples. Although there are plenty of contributions in the liter-ature on this symbolic learning problem, few of them have applied their proposed algorithms to recognition of non-isolated graphical symbols, just like what we want to do in this paper on engineering drawings.

Intuitively, example-based graphics recognition could also be implemented using case-based reasoning (CBR) approaches, which have attracted many attentions from AI researchers and application researchers since it was first proposed by Schank and Abelson [20]. However, example-based graphics recognition is not a CBR prob-lem, as we will explain immediately. First, the CBR was proposed to solve those problems that are diffi-cult or impossible to model. The key idea of CBR is that it remembers previous encountered problems (or cases/examples) and their solutions, and then solves the new problems by adapting successful solutions to simi-lar problems. The CBR uses significant features instead of explicit models to represent the knowledge of the problems. To learn new knowledge in the CBR is sim-ply to extract the features and to remember the cases. In this sense, template matching can be considered as a simple CBR approach to object recognition at the pixel level. On the contrary, graphic objects can be mod-elled in terms of components and their relationships, as structural/syntactical approaches do. The graphic ob-jects are usually clear in structures and can be described in models. Hence, our approach can learn a graphic model/pattern (knowledge) from its examples rather than keep all the examples (or cases). Second, the CBR is actually a reasoning and problem solving method, which is different from model-based approaches. Our problem is just to recognize similar objects from an engi-neering drawing and no reasoning or problem solving problem is involved.

In the sense of finding similar objects, another similar problem to example-based graphics recognition is con-tent-based image retrieval (CBIR) [8] or content-based retrieval of other types of objects [16]. Like content-based reasoning, the CBIR also represents objects by their statistical features, which are simpler to remember and handle than the objects (or models) themselves. For example, Samet and Soffer [19] use statistical shape features to describe and recognize geographic symbols that are learnt from the legends of the maps. Tabbone et al. [22] have tried to index architectural drawings using F-signature, which is a kind of feature based on a particular histogram of forces of the graphic objects in the drawings. However, applying the CBIR on example-based graphics recognition also needs pre-segmentation, as done in [19] and [22]. 3 The proposed approach In this paper, we follow the idea of Liu [14] but use different approaches to implement the procedures in the framework. Our approach automatically analyzes and learns an object X  X  knowledge (its component X  attri-butes and relations), and use the learnt knowledge to recognize or search for similar graphic objects indepen-dently and immediately.

We start our work at the vector level, where an object is composed of a few lines, arcs, or even triangles, rect-angles, circles, and so on. We focus our effort more on the knowledge representation, acquisition, and graphics recognition problems. We propose an attributed graph to represent the generic graphical knowledge of graphic objects. In the graph, nodes represent the components of the object and edges represent the relationships between components. Since the graphic objects can appear in all positions and in various scales and orientations, and the knowledge representation for modeling graphic objects should be invariant to geometric transformations and independent of positions, we use geometric constraints to represent the relationships between components. An efficient and effective format of defining the geometric constraints is in great need. We carefully analyzed and summarized all kinds of generic geometric constraints and defined our particular efficient format for represent-ing the knowledge of graphic objects. We will discuss this definition in Sect. 4.

For the purpose of learning knowledge from exam-ples, wedevelopour ownalgorithm for knowledgeacqui-sition, which finds all components and theirs constraints from the examples and represent them in an attribute graph. Our recognition algorithm is just to find one by one all of these components based on these constraints by traversing the graph. For each object type, a fixed traversal path is actually obtained in the knowledge acquisition step as part of the graphical knowledge for frequent use during recognition. We also explored a user feedback scheme to update the old graphic knowledge from user X  X  interactive correction of both positive and negative examples.

Figure 1 illustrates a flowchart of our proposed ap-proach, which consists of four modules: pre-processing, knowledge acquisition, run-time recognition, and knowledge update (maintenance). The pre-processing module deals with converting a raster image to a vector form and does some refinements. After pre-processing, the user can interactively select a desired graphic ob-ject or just a known object type from the knowledge database to indicate that he wants the system to recog-nize this type of object. The system first uses its exist-ing graphical knowledge to attempt to recognize it. If the system does not recognize it, the system treats this graphic object as a new type and learns its knowledge using the knowledge acquisition module. Otherwise, the system can recognize the example as a known type. Once the type of objects to be recognized is known, the sys-tem continues to recognize all objects of the same type on the drawing and mark the recognized objects on the drawing. The user can give feedback to the system to indicate some recognized objects as correct or wrong. Here, the user is assumed to be well trained and expe-rienced. He can also provide new examples of the same type. Based on the user feedback, the system automat-ically updates the old knowledge in the database and performs recognition again. We present the proposed approach in detail in the following sections. 4 The knowledge representation scheme All graphic objects are composed of low-level primitives constrained by certain relationships among them. In this section, we present the representation schemes for the primitive components and their relations. 4.1 Primitive components We define two types of primitive components for engineering drawings: Line and Arc , of which almost all frequently used, regular graphic objects in engineer-ing drawings can be composed. In future work, we can add more primitive components, such as free curve, to our definition to describe those irregular, less frequent objects. In our definition, a Line has two endpoints in the following order: P 1 , P 2 , and an Arc has four attributes: Center , Radius , Start-Angle , and End-Angle . Since a cir-cle is a special type of an arc, we can use an Arc to describe a circle.

To obtain the primitive components of engineering drawings, a vectorization procedure (i.e., raster-to-vec-tor conversion) is required. Many vectorization methods have been designed throughout the years and a number of software packages are available. We have selected a free software named Ras2Vec [3] for our vectoriza-tion task. Although the basic raster-to-vector conver-sion problem is considered as solved, solutions are far from perfection in terms of precision, robustness, and stability. For example, the same object can be vector-ized very differently when slight changes (e.g., resiz-ing and/or rotation) are applied to the object. Hence, we do the following post-processing steps to refine the results of basic vectorization: remove very short lines, connect points to their closest points or lines if the distances are very small, straighten lines, and adjust lines X  directions to horizontal or vertical if they are nearly so. Figure 2 shows the effect of these simple post-processing:
Figure 2a is the original raster graphic object and 2b is the result of the vectorization by Ras2Vec . Figure 2b contains many tiny and broken line segments and other distortions. Figure 2c is the refined vector representa-tion of the object after post-processing, from which we can extract the knowledge for this type of object. 4.2 Relationships between components As discussed above, the graphic objects in engineering drawings can be at any position, of various scales and ori-entations, and even overlap each other. Their segmen-tation is almost impossible before they are recognized. Their knowledge representation should be invariant to size, orientation, and location. Geometric constraint is a classical and systematic method for this purpose, which was first used in CAD systems (e.g., [10]). However, in CAD systems, the geometric constraints are defined, ex-tracted, and specified by professional and experienced users for designing engineering drawings. Our scheme aspires to extract and learn the knowledge completely and automatically. Hence, we attempt to use geometric constraints as few types as possible for representing the graphical knowledge as completely as possible. We ana-lyzed more than 300 types of different graphic objects and came up with four types of geometric constraints, three ( Intersection , Parallelism , and Perpendicularity ) for lines, and one for circles/arcs. Next, we present their representations in detail. 4.3 Intersection Usually, the point of intersection is at the middle of a line, but this is not convenient for our proposed algo-rithms in the later recognition stage. Hence, we first decomposethelines bytheir intersectionpoints, as shown in Fig. 3. After decomposition, the points of intersection are all at the end points of the lines. Thus, two lines intersect only in four types by considering the lines X  directions, as illustrated in Fig. 4.

We use a parameter type to represent this informa-tion and use another parameter angle to store the angle between the two lines. angle = cos ( X ) = L 1  X  L 2 /( | L 1 | L 2 | )
In this definition, the parameter angle itself is not sufficient to fully specify the spatial relationship of two intersecting lines since the angle has a direction. Thus, we use another parameter direction to describe this information. Assume two end points of L 1 are L 1 . P 1 , L . P 2 , x 1 = L 1 . P 2 . x  X  L 1 . P 1 . x , y 1 = L 1 . P and define x 2 , y 2 of L 2 in the same way. Consider L ( x the 3D space, their cross product ( L )isasfollows. L = L L is perpendicular to the plane formed by L 1 and L 2 , and its direction complies with the Right Hand Rule . Thus we can determine the direction by calculating L z , which can be &gt;0 , &lt;0 ,or =0 . Another parameter, length ,is used to describe the length of L 2 relative to L 1 : length |
L as a four-tuple ( type, angle, direction, length ). 4.4 Parallelism Similar to Intersection , we also use four parameters to describethe Parallelism constraint. Thefirst is distance = D ( L and L 2 relative to the length of L 1 . The second one, direction , is used to describe whether L 2 is on the left-hand side or right-hand side of L 1 and its computing method is similar to that of direction in the Intersec-tion constraint. Two additional parameters, startpoint-ratio and endpoint-ratio , specify the relative position and length of L 1 and L 2 . These parameters are described based on a common concept, cross ratio , which is defined as sign ( B-C, A-C ) |B-C|/|A-C| , for any three distinct, col-linear points A , B , and C , where B-C denotes the vector from C to B and so does A-C .Sign( B-C, A-C )is+veif A, B are at the same side of C, otherwise it is  X  X e. Cross ratio is invariant to scaling, translation, and rotation, or to their combinations.

In Figure 5, L 1 and L 2 are parallel; sp and ep are the projections of the endpoints of L 2 on L 1 .Weset: start-point-ratio = sign ( sp  X  L 1 . P 1 , L 1 . P 2  X  L 1 . P L endpoints of L 1 . Hence a Parallelism constraint is de-scribed as a four-tuple ( distance, direction, startpoint-ratio, endpoint-ratio ). 4.5 Perpendicularity Perpendicularity is used to describe the constraint be-tween two lines that are perpendicular to each other but not intersecting. The Intersection constraint can be used to represent two lines that are both perpendicular to each other and are also intersecting. The following four parameters are used to describe a Perpendicularity constraint:  X  Length =| L  X  Per-point-ratio is the perpendicular point of L  X  Start-point-ratio =D( per-point , L  X  End-point-ratio =D( per-point , L
The start-point-ratio and end-point-ratio has a positive sign if the point is on the left-hand side of L 1 and nega-tive if it is on the right-hand side. The computing method of the sign is similar to that of computing direction in Intersection and Parallelism . In Fig. 6, the values of start-point-ratio and end-point-ratio are both positive. 4.6 Arcs and circles We use the following six parameters to represent an arc (A) constrained by a line ( L ), as illustrated in Fig. 7. Since a circle is a special kind of an arc, it does not require any special representation.  X  Center  X  Point  X  Ratio = ( cp  X  L  X  P  X  Distance = D ( center-point, cp )/ | L |  X  Radius  X  ratio = radius / | L |  X  Direction : center-point is on the left or the right to L  X  Start  X  angle : start-angle of A  X  End  X  angle : end-angle of A 5 The knowledge acquisition algorithm This section introduces our Knowledge Acquisition Algorithm (KAA), which is used to learn the graphi-cal knowledge, i.e., to extract the useful geometric con-straints from the graphic object examples represented in vector-form components (which can be lines [6] and arcs [13] and are referred to as vectors). The knowl-edge of this type of object is represented in a graph G(V,E), in which each vertex is a vector represented by two endpoints, and each edge is a geometric constraint between two vectors. The algorithm first extracts the Intersection geometric constraints, since the frequency of Intersection in graphic objects is the highest and its computation is simpler than other constraints. Figure 8 illustrates knowledge representations at different stages in the KAA for the window symbol in Fig. 15.

Figure 8a is a raster image of a graphic object, Fig. 8b is its vector representation resulting from vectorization and refinement, Fig. 8c is the initial constraint graph G ( V, E ) after extracting all Intersection geometric con-straints. Figure 8c is a connected graph, whose edges store all the Intersection geometric constraints among the vectors. However, Intersection geometric constraints alone cannot always connect all the vector components of a graphic object in the constraint graph G ( V, E ). If the graph is not connected, our algorithm will attempt to discover Parallelism or Perpendicularity constraints to make it connected. If all attempts to connect the graph fail, the knowledge of the graphic object cannot be represented by our geometric constraints. In fact this chance is very low, since most graphic objects are regu-lar and we also further regularize their components by refinement.

In order to efficiently traverse the graph to find all components of an object to be recognized in the recogni-tion process, we reduce G(V,E) to a Spanning Tree . After the reduction, all edges are necessary (non-redundant) for graphical knowledge representation, as in Fig. 8d. By designating a root, the traversal sequence (e.g., accord-ing to the breadth-first scheme) can be fixed, as in Fig. 8d. The edges of the tree will be frequently traversed dur-ing recognition. Hence, in order to save the recognition time, we traverse them once, prior to recognition, and store the sequence of edges together with the knowledge tree. This is done at the end of our knowledge acquisition algorithm. Table 1 presents the detail of the Knowledge Acquisition Algorithm. If we use E ( i , j ) to represent an edge between node i and j , the edge traversal sequence in the knowledge K of the symbol in Fig. 8 is: E (0,5), E (0,1), E (0,3), E (0,2), E (1,4), E (1,6), and E (2,7). 6 The graphics recognition algorithm The proposed recognition algorithm works in two sce-narios: segmentedandnon-segmented. Inthesegmented case, we need to confirm if an isolated object is of a given class. In the non-segmented case, we need to find (and segment) in a large drawing all objects of a given class. As discussed in Sect. 5, our acquired knowledge is essentially a tree containing all the necessary and non-redundant geometric constraints of a graphic object. If another graphic object can be represented by the same tree, it can be classified as belonging to the same class. However, we cannot use the matching method for rec-ognition since there may be more than one Spanning Tree for the same graph. This means that the knowledge of the same graphic object can be represented in differ-ent trees. Our recognition algorithm is a hypothesis-test scheme. Taking the non-segmented scenario as an exam-ple, we first assume there is an object of the given class in the drawing. If we can find all required components of this object according to the class X  X  knowledge, we can confirm that the assumed object is found. Our recogni-tion method is to find the object X  X  components one by one following the traversal sequence in the knowledge of the given object class. We find the required compo-nents using the hypothesis-test scheme, too. A compo-nent X  X  attributes (or specification, especially, type, and possible location) is assumed based on reasoning/cal-culation from its parent node in the knowledge tree and the edge (constraint) between them. It is confirmed if a similar vector is found there. The segmented sce-nario works similarly, which is used to illustrate our recognition algorithm formally. Suppose a graphic ob-ject is composed of a set of vectors SV and we want to know whether it belongs to the class represented by a knowledge tree K . We randomly select a vector V from SV as the root vector to start with. We then select the first edge E from the edge traversal sequence in K . Since E is a geometric constraint between V and its child, we can use V and E to calculate the child of V , which is de-noted as V . Then, we try to find a vector V in SV , which is the most similar to V X  in terms of a preset threshold. For matching two primitive components, we define the following similarity measures, in which a smaller value means a larger similarity. 1. First, we calculate SIM L to define the similarity of 2. For Arc vectors, denoted as P 1 -P 12 -P 2 and P 3 -P 3. Sometimes, an arc can be represented by a few lines, where C is the  X  X enter-point X  and R is the  X  X adius X .
Take the window symbol in Fig. 15 as an example, whose knowledge is acquired and shown in Fig. 8, with its edge traversal sequence in its knowledge K being: E ( 0, 5 ) , E ( 0, 1 ) , E ( 0, 3 ) , E ( 0, 2 ) , E ( 1, 4 ) E ( 2, 7 ) . We can take any vector line from Fig. 15 to start with the hypothesis-test process. Based on the similarity we mentioned above, any of the two vertical vectors can be matched with vector 0 in Fig. 8d, since only its attri-butes including length and width can be used for match-ing and no other constraints like position can be used. Suppose we find the correct vector 0 for 0 (otherwise, the hypothesis will be proved as false and finally every vector has an opportunity to match with 0), we take the first constraint E ( 0, 5 ) from the traversal sequence and construct vector 5 based on 0 and E ( 0, 5 ) . Then we test all vectors in Fig. 15 and try to find 5 which is similar to 5 .

If a matching vector V (e.g., 5 ) is found, we set it as the child of V (e.g., 0) and continue to find other children of V by selecting the next edge in the traversal sequence and following the same procedure. Hopefully, we can find 1 ,3 , and 2 successfully. We then try to find 4 and 6 based on 1 and E (1,4), and 1 and E (1,6), respec-tively, and so on. If all edges in K have been traversed and all similar vectors have been found in SV, then we are confident that SV is (or contains) a graphic object of the class specified by K . The algorithm presented above deals with ideal situations. In practice, however there may be some problems. First, the directions of vectors are arbitrary. Thus, when selecting a vector to start the search procedure, we have to test both direc-tions. We also set some attribute tolerances for matching vectors, e.g., length, angle, and number of components. For example, we can allow for some extent of absence or redundancy of some vectors during matching of the components. See Sect. 7 for more detail about the tol-erances. Table 2 describes the Graphics Recognition Algorithm. 7 The user feedback scheme Using the above two algorithms, the Knowledge Acqui-sition Algorithm and the Graphics Recognition Algo-rithm, the approach can learn the graphical knowledge of the specified graphic object at run time and apply the learnt knowledge to recognize similar graphic objects immediately. However, the recognition results are usu-ally not 100% correct. In general, the recognition errors can be classified into two main classes:  X  WR, wrong recognition: the graphic objects recog- X  MR, missing recognition: the graphic objects that
These incorrect recognition results, as well as the correct recognition results, if known, contain useful and important knowledge for improving the recognition accuracy in the future. Traditionally, the algorithms or the graphical knowledge must be manually adjusted many times to cover more different cases in order to achieve higher recognition accuracy. This requires much human involvement and professional knowledge. The efficiency of this manual operation is usually too low to satisfy the requirements of rapid industrial produc-tion. Thus, we proposed an interactive user feedback scheme to provide the system with an incremental learn-ing ability such that higher recognition accuracy can be efficiently achieved.

The basic procedure of the scheme is that the user first gives an example of the graphic object to the system, which can be done either by inputting a single graphic object to the system or selecting a region in an engi-neering drawing. The selected region is assumed to only contain exactly the components the user wants. The problem of inclusion of extra components in the exam-ple is beyond the scope of this paper. The system then learns its graphical knowledge at run time and stores it into the knowledge database. Using the learnt graphi-cal knowledge, the system can recognize other similar graphic objects immediately. For many cases, the recog-nition results may not be 100% correct since the system only learnt the graphical knowledge form one single example. In the next step, we collect the user feedback about the current recognition results. The user can give feedback to the system by marking the results as correct, wrong, or missing.  X  Correct results are those that the user expects. The  X  Wrong results are those that the user does not ex- X  Missing results are those that the user expects but
From these feedbacks, the system updates the graph-ical knowledge of the corresponding object type and uses this new graphical knowledge for future recogni-tion. Through this semi-automatic update procedure, the system can refine the graphical knowledge from both positive and negative examples. With this incremen-tal learning ability, the system can acquire more accu-rate graphical knowledge and achieve better recognition results. In our current work, we explore a tolerance-based method to implement the proposed user feedback scheme based on multiple examples. We allow certain tolerances for the parameters (e.g., of length, angle, and the number of vectors) in the constraints during recogni-tion. In the initial Graphics Recognition Algorithm, we use the same tolerances to recognize different graphic objects, but different graphic objects should have differ-ent tolerance levels. The tolerance is a very important knowledge for graphics representation and recognition. As a simple example, a rectangle should have exactly four edges and four right angles, so the tolerance for the number of vectors and the tolerance for the right angle should be strict, while the tolerance for edges X  length may be loose. We propose the following three basic types of tolerances:  X  Length tolerance: for the length of a line or a radius,  X  Angle tolerance: for the angle between two lines or  X  Number tolerance: for thenumber of absent or redun-
We associate these sets of tolerances with each constraint in the graphical knowledge. That is, every constraint has a few tolerances for length and angle, and the graphical knowledge of a whole graphic object has a tolerance for the number of vectors. The system learns the tolerances for different graphic objects from examples. Initially, a set of default tolerances is assigned to every constraint. For example, the default tolerance for angle is 5%, the default tolerance for length is 10%, and the default tolerance for the number of vectors is 0. When the user provides feedback about the recognition results, the system first detects the difference between the old knowledge and the new knowledge, and then adjusts the associated tolerances such that the knowledge can cover both the old and the new objects. Thus, more objects can be recognized correctly in the future. The rules for adjusting the tolerances are as follows:  X  Positive examples do not affect the tolerance since  X  Additional positive example is processed according  X  Negative examples are first compared with 8 Experimental results We have implemented a prototype system based on the proposed approach. In this section, we first present the UI of the system and a typical user scenario, and then show the detail experiments and results we have done. 8.1 UI and user scenario of the prototype system Figure 9 illustrates the UI and a user scenario of the prototype system with a real drawing. Figure 9a X  X  shows the steps of using the system to recognize all hexagon symbols in the drawing. Figure 9f shows another way to recognize symbols by selecting an existing symbol from the knowledge database. The general scenario is: the first step is to load the knowledge database to initialize the system. The second one is to decompose the loaded drawing into vectors. The third has two choices: learn-ing knowledge from user X  X  selected example or choosing a knowledge template from the left panel. Finally, the recognition results are shown in the right panel of the window. 8.2 Recognition of single graphic objects To test our prototype system we have done experiments on a collection of 325 graphic objects, which are se-lected from an online graphic objects database [2] and the test images for the GREC X 03 symbol recognition contest sample images [1]. Figure 10 shows some exam-ples of the graphic objects in this collection.
First, we trained the system to acquire the knowl-edge of every graphic object and construct an original knowledge database. The average knowledge acquisi-tion time for each object is 43  X  10  X  6 s(onaPCwith P-II 450 MHz CPU and 128M SDRAM, the same con-figuration is used throughout the experiments in this paper). The knowledge of 323 (99.38%) graphic objects was acquired successfully. There were two objects in which the system could not successfully acquire knowl-edge since their knowledge graphs are disconnected. We then randomly input the graphic objects into the system for recognition. Experimental results show that the rec-ognition rate is 100% for the 323 original graphic objects and the average recognition time is 74 ms per object. We also added some simple geometric transformations and common noises (e.g., scaling, rotation, Gaussian random noise, as shown in Fig. 11) to the original graphic objects and tested recognition again. The recognition rate we obtained was still as high as 98.34%.

Second, we also did experiments on all of the test-sets of the GREC X 03 contest, including sets with scaling, rotation, deformation, degradation, and their combina-tions. There are totally 72 tests and 6,900 test images. From Tables 3 and 4, it is easy to see that generally the algorithm performs well and most of the accuracies are above 80%. However, we can also see that the over-all performance of the algorithm drops a little bit as the number of model symbols, test symbols, and level of distortion/degradation increase. Part of the reason is that the vectorization result is poor. We also record the recognition accuracies on the sets with five model sym-bols andthreedifferent distortionlevels, whichare100% for each level of deformation. It shows that the algorithm is robust to deformation. We summarize all the results above and obtain the average recognition accuracy of all the 6,900 test symbols as 88.1%. 8.3 Recognition of graphic objects from real-life Having obtained promising experimental recognition results for individual graphic objects, we also tested our prototype system on a number of real-life engineering drawings. Figures 12, 13, 14, 15 and 16 show some exam-ples of our experiments.

Figure 12 is a mechanical engineering drawing containing three concentric circles and five similar hex-agonal graphic objects. In the experiment, the user spec-ified the rightmost one of these five similar objects. The system learned and recognized all five similar graphic objects (including the selected example) successfully, despite the existence of translation, scaling, and con-nectivity with other lines.

Figure 13 is an electronic engineering drawing which consists of some basic electronic components. The sys-tem successfully recognized all of them by acquiring their knowledge at run-time.

Figure 14 is a utility drawing (in vector format) se-lected from the UWIII database [18]. Based on the knowledge of the selected examples, the system recog-nized all of the similar objects and marked them. We also tested to use the existing knowledge from the knowledge database and obtained the same result.

In Figure 15, which is an architecture engineering drawing, the system missed some graphic objects. One reason is that the current system cannot handle mir-ror transformation (such as the missed door in Fig. 15). Other reasons include non-perfect vector representa-tion even after our post-processing (such as the missing big window on the top-right corner of Fig. 15). To solve these problems, we plan to further enhance our knowl-edge representation and algorithms in the future.
Figure 16 is an example of electronic engineering drawingcontainingseveral electroniccomponents. From the experimental results, we can see that the system suc-cessfully recognized almost all of these components by learning their graphical knowledge at run time. How-ever, there were some graphic objects for which the sys-tem could not recognize successfully by learning their knowledge from only one example. For instance, the resistor labeled as  X  A  X  in Fig. 16 is an example specified by the user for the first time. The knowledge learnt from  X  X  X  could recognize only four similar resistors which are marked by  X # X  and missed the other three resistors (marked by  X + X ). In this case, the user randomly selected another resistor from the three missed ones, e.g., the one labeled  X  B  X  and asked the system to carry out the recog-nition again. The system learned the knowledge of  X  B  X  and compared it to the existing knowledge learnt from  X  A  X . By adjusting the associated tolerances, the system updated the graphical knowledge of this type of graphic object. Using the updated knowledge, the system then successfully recognized all the resistors, including the three missed ones in the first round. Figure 17 displays the details of resistors  X  X  X  and  X  X  X , from which we can see they are slightly different in terms of lengths and angles. More details of these differences can be seen from Table 5.

Table 5 shows the graphical knowledge for the symbol in Fig. 17 before and after the user feedback. In Table 5, C# is the constraint ID, V 1 and V 2 are the vector IDs involved in a constraint, T is the constraint type (which is defined to identify four types of Intersec-tion geometric constraint and other three types of geo-metric constraints, as discussed in Sect. 4), D is direction (defined in Sect. 4.3), A(A) is the cosine of the Angle in a constraint in object A . and A(B) is the cosine of the Angle in a constraint in object B , L(A) and L(B) are the relative Length-ratios in a constraint in object A and B . In the last two columns of Table 5, A is angle tolerance and L is length tolerance. In each column, the one on the left is the initial default value and the one on the right is the new value after the system updated the graphical knowledge. In this example, the tolerance for the number of vectors remained 0.

Table 6 shows the statistical information of the ob-jects and recognition results of the real life drawing of Fig. 16. L is the number of lines, A is the number of arcs in the graphic object example specified by the user, GC is the number of geometric constraints generated by our Knowledge Acquisition Algorithm, RN is the total number of recognized objects, BF and AF are the numbers of recognized objects before and after user feedback update, AT is the knowledge acquisition time in microseconds (10  X  6 s), and RT is the recognition time in milliseconds (10  X  3 s). The speed should be suffi-ciently fast for interactive recognition systems. In all of experiments on real life drawings, which contain 126 connected symbols of 11 types, we can correctly recog-nize 116 (92.1%) symbols based on the first example, and 6 additional ones after user feedback, which make the overall recognition rate increase to 96.8%. 9 Conclusions and future work In this paper, we proposed an approach to graphics rec-ognition in engineering drawings that combines learn-ing and user interaction. A knowledge representation scheme is proposed for graphic objects in engineering drawings. Four types of geometric constraints repre-sent the relationships between the objects X  components. From the examples provided by the user interactively at run-time, the system can automatically acquire its graph-ical knowledge using our proposed Knowledge Acquisi-tion Algorithm. Based on the acquired graphical knowl-edge, we also developed a Graphics Recognition Algo-rithm, which locates an object in the drawing by guessing and confirming the attributes of its components. Exper-imental results on both individual graphic objects and real-life engineering drawings are promising. However, there are some cases of missed recognition and wrong recognition. A user feedback scheme improved the rec-ognition accuracy and better experimental results have been achieved.

Some problems still remain open. The first one is that the vectorization results greatly affect the performance of the knowledge acquisition and the graphics recogni-tion. Although some post-processing methods for vec-torization have been proposed, they still need to be improved. The second open problem is that the knowl-edge representation method cannot represent all the types of graphic objects, especially not those with free-curves. For example, in our experiment on single object recognition, thereweretwographicobjects whose graphical knowledge could not be represented using our approach. More research on graphical knowledge representation (e.g., the effect of adding Line Style and Line Width ) is needed to improve our approach. The third one is the validation of the user feedback scheme. We plan to collect negative examples, do more exper-iments and investigate more methods for this purpose. The fourth one is to further explore the strategies to process the selected region, which not only includes the target object, but also includes part of its neighboring object.
 References
