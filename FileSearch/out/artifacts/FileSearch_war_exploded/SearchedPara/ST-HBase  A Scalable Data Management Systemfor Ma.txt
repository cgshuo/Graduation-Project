 With the development of positioning technology and the widely usage of smart-phones, many objects on the web are being geo-tagged, such as the images in the Flickr, the tweets from Twitter, many sp atial objects are al so being associated with text descriptions. The combination of location and text results in a new kind of query: spatial keyword query. A spatial keyword query is like the follows: given a location or location area and a set of keywords, return a set of objects that satisfy the spatial requirements a nd are relevant to the query keywords. Such as finding the restaurants selling Peking Duck that are within 2 km from my current location or photos near by a gi ven place whose text descriptions are similar to the query keywords.

Spatial keyword query processing has been studied in many literatures, the state-of-the-art approaches mainly employ a hybrid index combing R-tree index with textual inverted index. To the best of our knowledge, the existing R-tree based hybrid index mainly focuses on the static and medium-sized object collec-tion. Although the hybrid index can improve the query performance by utilizing the spatial and textual pruning strategy, when the number of the targeted geo-tagged objects becomes vary large, the overlap between R-tree nodes increases which make the query performan ce decrease dramatically.

Figure 1 shows the insert throughput and query performance of the R-tree like index at different data size. Figure 1-(a) shows the performance of R-tree index, it just uses R-tree to index the spatial information but neglects the textual information. Figure 1-(b) shows that the performance of the Hybrid index S2I[1]. S2I[1] took both spatial and textual information into consideration and proposed a hybrid index. From Figure 1, we can observe that the insert throughput is very slow and decreases with the data size in creasing, because t he R-tree like index needs additional cost to adjust the R-tree node and the inverted index file; the response time increases with data size i ncreasing, because the overlap between the R-tree nodes increases as the data size becomes bigger and bigger.
In this paper, we propose spatial textual HBase(ST-HBase) which has good scalability and is capable of dealing with large scale dataset, ST-HBase can also support high insert rates and efficient spatial keyword queries. In ST-HBase, we use HBase to store the geo-tagged objects and combine spatial textual index with HBase, we propose two different approaches: Spatial and Textual Based Hybrid Index(ST b HI) and Term Cluster Based Inverted Spatial Index(TC b ISI). In summary, the main contributions of the paper are:  X  We propose spatial textual HBase(ST-HBase) which is a scalable data man- X  We propose two spatial textual index approaches: Spatial and Textual Based  X  We implement a prototype using HBase and perform comprehensive exper-The rest of the paper is organized as follows. In section 2, we review the related works about spatial keyword queries; in section 3, we give the problem statement; section 4 and 5 describe Spatial and Textual Based Hybrid Index(ST b HI) and term cluster based inverted spatial index(TC b ISI) respectively; in section 6, we perform detailed experiments an d section 7 concludes this paper. Many research works have been done to exploit spatial keyword queries problem. Zhou et al. [2] were the pioneers to try to improve the performance of spatial keyword queries in search engines. They proposed three approaches by combing the inverted index and R-trees:(1) Buildin gbothR-treesandinvertedindexesfor the web documents from spatial and textual perspectives respectively; (2)Build-ing the inverted indexes firstly and then cr eating a R-tree for every distinct term; (3)Creating a R-tree index for all the web documents and then creating one in-verted index for the documents that are contained in each R-tree leaf node. Their experiments showed that the second approach achieved better performance.
Cong et al. [3] proposed a new hybrid indexing framework for top-k spatial keyword queries, the index framework combines the inverted indexes for text retrieval and the R-tree for spatial query. Several index approaches were explored within the framework. In the baseline approach, they index the web documents with R-tree and simply attach the inverted index to each R-tree node to obtain an Inverted file R-tree called IR-tree. For eac h leaf node, an inverted index is created for the documents that are contained in the leaf node, while the inverted index for each internal node represents all the documents in the sub-trees of the internal node. In addition to the baseline method, Cong et al. also proposed other two advanced approaches: DIR-tree and CDI R-tree. In DIR-tree, they incorporated document similarity when computing Minimum Bounding Rectangles(MBR) and made sure that the textual descriptions of the objects that are in the same R-tree node are also similar. In CDIR-tr ee, Cong et al. clustered the documents attached to spatial objects and employ ed a pseudo-document to represent each cluster. So more tighter and precise te xtual relevance bound can be estimated and the query performance can be further improved.

Rocha-Junior et al. [1] proposed another novel method that can process top-k spatial keyword query more efficiently. Differently from [3], Rocha-Junior et al. proposed a new index structure called Spatial Inverted Index (S2I). They adopted different organization methods for the te rms based on their frequency. It is well known that the distribution of terms is very skewed, the document frequency of terms in a corpus follows the Zipf X  X  law, which means that only a small number of terms occur frequently, while most of the t erms occur infrequently[1][4]. So S2I mapped each more frequent term to a distinct aggregated R-tree (aR-tree) that stores the objects with the given term, if the number of the objects corresponding to one given term does not exceed a given threshold, the objects are just stored in a file. Based on the S2I index, they also proposed two efficient algorithms(Single Keyword Algorithm: SKA and Multiple Keyword Algorithm: MKA) to process the top-k spatial keyword queries efficiently.
 There are many other approaches that focus on spatial keyword queries. Ian De Felipe et al. [5] combined R-tree and signature file, and proposed a new efficient hybrid index called IR 2 -tree(informat ion retrieval R-tree). Each node of IR 2 -tree contained two parts of information: space information and keywords information. Zhang et al. [6] proposed bR  X  -tree to process m -closet keyword queries; Zhang et al. [7] proposed a Light-Weighted Index to process the spatial keyword queries for the objects that are described by tags. In this section, we briefly describe the problem addressed in the paper. Let D be a geo-tagged database. Each geo-tagged object O in D can be represented as atriple( O.id , O.loc , O.doc ), in which O.id is the identifier of the object, O.loc represents the location of the object and contains latitude and logitude, O.doc is the text that describes the object. Table 1 is an example of D .

O.id O.loc O.doc
Given a spatial keyword query Q(Q.loc, Q.keywords,  X  ) ,inwhich Q.loc is a given location, Q.keywords is the query keywords and  X  is the distance threshold, we need to find out all the geo-tagged objects which are far away from the location Q.loc within  X  and contain the query keywords. After we obtain all the objects that satisfy the textual and spatial constraints of the query, we compute the relevance scores for all the object s and rank the objects according to their scores. The top-k spatial keyword query can be finished by extending the space range of the query incrementally. In this paper we mainly focus on the range query processing. 4.1 Overview of ST b HI In this paper we want to manage the large scale geo-tagged objects using HBase. It is well known that HBase organizes the data based on the rowkeys and can provide very efficient queries on rowkeys. We try to design a suitable rowkey generation scheme that can combine the textual and spatial information of the geo-tagged objects together, so that we can deal with the spatial keyword queries more efficiently.
 Inverted Index Table Schema. In order to implement textual filtering, we build the inverted index. While different to the traditional inverted index file, we use a HBase table called  X  X nverted Index Table X  to finish the same task. Table 2 displays the scheme of the inverted index table. The rowkey is the composition of the term and the z-ordering value of the object. t i represents the i th term, id m is the object id, z m ( e.g., 01011010) is the z-ordering value of id m , ( x m ,y m ) represents the latitude and longi tude of the object respectively. The z-ordering value of each geo-tagged object can be computed based on its location information(latitude and longitude), because z-ordering technique preserves the original locality of the objects and the z-ordering value of the objects that are nearby in the original space are likely close to each other. The advantage of such kind of design is that we can implement the textual filtering and spatial filtering simultaneously and translate a spatial keyword query into several range queries on the rowkey KD-Tree Index. As long as we encode the objects using z-ordering technique, we can translate the spatial query into range query on the z-ordering values. For instance, given a query rectangle R [( x min ,y min ) , ( x max ,y max )], we can get the minimum z-ordering value z min and the maximum z-ordering value z max and then execute a range query by using [ z min , z max ]. But in some cases, it is not feasible if we directly execute the ran ge query from the query rectangle, as it will produce many false positives. Just as shown in Figure 2, the red bordered rectangle is the range query, and the range of the z-ordering value is [2, 9]. If we directly execute the range query [2,9], w e have to scan every object from 2 to 9. But actually what we want to get just include 2, 3, 8 and 9, the objects from 4 to 7 are false positives. In order to eliminate the false positives as many as possible, we partition the objects by using KD-tree index, just like Figure 2 depicts, for the same query rectangle, we obtain tw o subspaces and get the required objects 2, 3, 8 and 9 finally.
 The procedure of the data insertion is as follows. Given a geo-tagged object O.id , represented as Z O.id . Then insert the object O.id into KD-tree, and decide whether the corresponding subspace needs to split or not, if the data size of a subspace exceeds the give threshold, th e subspace needs to split; (This step is optional, if the KD-tree is built beforehand, this step can be omitted.) Finally we construct the inverted index data rows and insert them into Inverted Index Table: ( t 1 Z O.id , 1 , O.id ) , ( t 2 Z O.id , 2 , O.id ) , ( t 3 Z O.id , 1 , O.id ). 4.2 Query Processing Given a spatial keyword query Q(Q.loc, Q.keywords,  X  ) ,inwhich Q.loc is a given location, Q.keywords is the query keywords,  X  is the distance threshold, Q.loc and  X  can be represented as a rectangle area R [( Q.loc x - X  , Q.loc y - X  ), ( Q.loc x +  X  , Q.loc y +  X  )]. When dealing with the spatial keyword query, we need to choose the suitable query strategy according to the area of the query rectangle, it can be divided into the following three categories:  X  As shown in Fugure 3, if the area of the query rectangle is relative small,  X  As the area of the query rectangle become s larger, the number of the distinct  X  While if the z-ordering range of the query rectangle exceeds a given threshold, 4.3 Pre-Splitting for Inverted Index Table It is well known that HBase organizes the data as regions and the data is stored in regions according to their rowkey. At the beginning, all the data is inserted into just one region, if the number of the reco rds in the first region exceeds the given threshold, the region will split into two roughly equal sized child regions. As more and more data is inserted, the regions w ill split recursively. Such scheme has two pitfalls, one is the concurrency, the other one is the high splitting cost. Because all the data are inserted into one region or several regions at the beginning, the concurrency will be constrained by the limited regions, in order to enhance the concurrency, we can pre-split the regions for the Inverted Index Table.
In Inverted Index Table, the rowkey is composed of term and the z-ordering value of the geo-tagged objects, so the records will be stored into different regions according to the terms and the location information of the objects. We all know that, the distribution of the term frequency is always skewed and obeys to the Zipf -like distribution, what we want to do is that we can divide all the distinct terms into several segments, and make sure that the sum of the term frequency in each segment is roughly equal. The detail of the pre-splitting is described in Algorithm 1.
 Algorithm 1. Pre-splitting for Inverted Index Table In ST b HI index approach, for a given geo-tagged object o i ,if o i has n terms, then we have to insert one index entry for each term into the Inverted Index Table. That is to say, we have to do n times insertion for each geo-tagged object o , so the index speed will decrease and the space overhead will be high. At the same time, when we deal with a spatial keyword query Q that contains m query keywords, we have to execute m sub-queries and then combine the results of all the sub-queries, so the query performance will also be affected. Because of the above reasons, ST b HI Index approach is not the best suitable solution for managing the geo-tagged objects that contain many terms and dealing with the multi-keywords queries. In order to tackle the above problem, we propose another index solution: Term Cluster Based Inverted Spatial Index(TC b ISI). This idea is mainly inspired by the following observations: some terms are usually used together to describe the same objects and some terms often occur in the same query. According to the above observation, we can divide the terms into different clusters based on the co-occurrence relationship among the terms, the objects that correspond to one term cluster can be treated together, each cluster is mapped to a HBase table. The objects of a term cluster are stored in one HBase table and the organization of the objects is like that of ST b HI. By doing so, when we deal with a query that contains several keywords, the number of the HBase tables that we need to access is less than the number of the keywords, so the response time can be decreased. 5.1 Framework of Term Cluster Based Inverted Spatial Index Figure 4 shows the framework of Term Cluster based Inverted Spatial Index. The TC b ISI index consists of four components: Inverted Index, Term Cluster Index, KD-tree and HBase Table.  X  Inverted Index . The Inverted Index is used to implement textual pruning  X  Term Cluster Index . Term Cluster Index is mainly used to map the term  X  X D-tree . The KD-tree is used to divide the geo-tagged objects that corre- X  X BaseTable . HBase Table is the actual storage of the objects, it uses the 5.2 Query Processing According to the framework of TC b ISI we can finish a spatial keyword query in several steps: given a spatial keyword query Q(Q.loc, Q.keywords,  X  ) ,firstly, getting the term clusters which contain Q.keywords through Inverted Index; Secondly obtaining the corresponding KD-trees or HBase table names through Term Cluster Index; Thirdly adopting suitable query methods according to the query range; Finally we merge the results returned from each term cluster and obtain the final results. The remaining query procedure is the same as that of ST b ISI. 5.3 Term Cluster Generation Term cluster is the basis of TC b ISI, in order to obtain the high quality clustering result, we propose a Term Co-occurrence Graph based clustering method(TCG-Cluster), in which each node represen ts a term and the edge between two nodes represents the co-occurrence frequency of two terms. Because of the space limit, the detail of TCG-Cluster will not be lis ted here and it can be referred from the extended version of the paper. In this section, we compare our approaches with the Spatial Inverted Index (S2I) proposed by Joao et al.[1], to the best of our knowledge, S2I is the state-of-the-art approach that addresses spatial keyword queries. The setup for S2I is the same as described in [1], the nodes of the aR-trees have a block size of 4KB and are able to store between 42 and 85 entries. 6.1 Experimental Settings Setup. The experiments for S2I were executed on a server with a 3GHz Dual Core AMD processor and 4GB memory. Our approaches were implemented on HBase-0.20.6 and Hadoop-0.90.4, the cluster size is 16 nodes that are connected with 1Gbit Ethernet switch. The main par ameters and values used in the exper-iments are described in Table 3. The default values are presented in bold. Datasets. Table 3(b) shows the characteristi cs of the datasets used in the ex-periments. In this paper we mainly focus on querying from large scale geo-tagged objects, we have two real datasets presently, one is twitter dataset containing about 10,000,000 tweets, another one is a document corpus from Reuters con-taining 10,000 documents. Based on the two real datasets we generated several other datasets, the detailed statistics of them are listed in Table 3(b). 6.2 Performance Varying the Data Size Insert throughput. Figure 5 shows that the insert throughput of S2I, ST b HI and TC b ISI with different data size. We can see that the insert throughput of S2I is the worst one, and the insert throughput decreases dramatically with the data size increasing. That is because S2I adopts the R-tree like index and R-tree like index needs additional cost to keep the tree balanced which affects the insert performance. The insert performance of TC b ISI is better than that of ST b HI, the main reason is as the follows: a given geo-tagged object o i containing m keywords needs m times insertion for ST b HI approach, while the insertion times of TC b ISI is equal to the number of the clusters which the keywords of o i belong to, so the insertion times of TC b ISI is less than that of ST b HI. We can also observe that the insert throughput of ST b HI and TC b ISI has good scalability, they can keep high insert throughout with the data size increasing. The peak insert throughput of TC b ISI is over 10,000 objects per second.
 Query Performance. Figure 6 mainly describes the query performance of the different index approaches. When the data size and the query range are both relative small(e.g., the data size is less than about 1,500,000 and the query range is smaller than 50), S2I can obtain the better query performance than ST b HI. While as the data size increases, the query performance of S2I-50 is becoming more inferior than that of ST b HI-50 and TC b ISI-50. For the large range query, the query performance of ST b HI and TC b ISI is always better than that of S2I, e.g., ST b HI-100 and TC b ISI-100.
 Index Space Requirement. Figure 7 shows the storage space required for S2I, ST b HI and TC b ISI. The size required by S2I is larger than the size required by ST b HI and TC b ISI. The reason is that ST b HI and TC b ISI are both implemented on HBase, while the data in HBase is actually stored on HDFS and HDFS always adopts many compression algorithms to improve the space utilization. In order to keep fault tolerant, HDFS always keep 3 replicas for each data block, even so, the total size requires is still smaller than that of S2I. 6.3 Varying the Number of Keywords Figure 8 depicts the response time while varying the number of keywords(from one keyword to five keywords) for large scale dataset(100M geo-tagged objects), the default query range is set to 0-50. From section 6.2, we know that the time consumed by S2I for inserting two million objects is about 32 hours, it will spend more than 66 days to insert 100,000,000 objects, so in this section we just test theresponsetimeofST b HI and TC b ISI. The response time of ST b HI increases almost linearly with the number of the key words. For the query with small range, the query performance of TC b ISI is better than that of ST b HI, while for the large range query, the performance of ST b HI is much better than that of TC b ISI. The main reason is as the follows: for the large range query, many records need to be scanned and verified, in ST b HI we can finish the filtering and verification based on the rowkey, so that is very fast. While in TC b ISI, we need additional time to filter and verify the records on the non-rowkey column. 6.4 Varying the Query Range In this section we mainly test the query response time of ST b HI and TC b ISI for the queries with different range varying from 5, 50, 100 to 200, 300, 500, the query contains three keywords, the number of geo-tagged objects is the same as in section 6.3. In order to obtain the rel ative accurate response time, We execute ten times queries and use the average time as the final response time.
As the query range increases, more objects need to be scanned and trans-formed to the client side, so the response time increases as the query range becomes larger. For the small range queries( 5), the performance of ST b HI is better than that of TC b ISI, as the query range increases, the performance of ST b HI is becoming much better than that of TC b ISI, the reason is as the same described in the above subsection. In this paper, we propose a scalable data management system for massive geo-tagged objects called ST-HBase (Spatial Textual HBase) in which we use HBase as the storage so that it can provide high insert throughput. In order to support efficient spatial keyword query, we lay er KD-tree index on HBase and propose two kinds of index approaches. In the future, we plan to extend our work to ad-hoc spatial temporal analysis about the large scale geo-tagged objects, because many geo-tagged objects also contain time dimension, such as photos in Flickr, tweets from Twitter, and the time dimension is also important for analyzing the geo-tagged objects, for instance we can compute the temporal and spatial distribution of the tweets about some specific topics.
 Acknowledgments. This research was partially supported by the grants from the Natural Science Foundati on of China (No. 61070055, 91024032, 91124001); the Fundamental Research Funds for the Central Universities, and the Research Funds of Renmin University( No. 11XNL010); National 863 High-tech Program (2012AA010701, 2013AA013204).

