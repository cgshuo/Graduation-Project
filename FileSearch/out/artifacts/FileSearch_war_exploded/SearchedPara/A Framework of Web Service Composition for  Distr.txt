 The basic architecture of Web services lay out the primary Web service components including Provider, Broker and Requester, including such a series of standard protocols as XML, SOAP, WSDL, UDDI, etc. In Web service environments, legacy components can be efficiently managed in line with the Web based requirement while transparent to the requesters. Motivated by real applications, Web services related research issues are carried out increasingly, and Web service composition is one of most important aspects [1]. the standard of Web data representation, transformation and exchange. There are many query languages and corresponding processors for XML data, such as Quilt language and Kweelt processor. Publishing relational data as XML, and transforming one XML to another are the most frequent and critical facets of XML-based query processing. By far, the generic publishing strategy and some optimizations are presented in [2]. The method of DTD-directed XML publishing and the DTD-conforming XML to XML transformation are proposed in [3] and [4] respectively. However, the complex query evaluation and the corresponding optimizations that concern both publishing and transformation are more challenging than those of the simple ones. In order to make facilitated the distributed query advertised on the Web and can be requested by the applications based on http protocol. warehouses that carry out some data processing and exchange w.r.t. a schema [5, 6, 7, 8]. It is natural that Web services are used as uniform wrappers for heterogeneous data sources, but also provide generic means to apply various transformations on the retrieved data. The generic architecture for XML data exchange has been the subject of increasing attention [9]. The architecture of Web service composition in P2P environments is presented in [10, 11]. In particular, SELF-SERV is specific application oriented for the definition of composition flow [10, 11]. And the concrete data processing in Web service environment is carried out in AXML [12], but the composition on queries is not concerned in that just the relationship among service calls is considered by lazy XM L query evaluation [13]. Therefore, service composition of query processing or data retrieving on the distributed and heterogeneous data sources is the significant research issue based on above motivations and related work. on distributed data sources. Regarding query as service, the method of Web-Service-customized complex XML query evaluation is proposed centered at concrete data processing, including composition and the corresponding optimizations. Generally, the central contributions of this paper can be summarized as follows:  X  We propose a generic framework and concrete methods for RDB and XML query processing in information integration under Web service environment.  X  We exploit the composite service of distributed XML query, and make full use of the existing query related techniques to enable the effective service composition adopting 
RDB publishing and XML transformation as the elementary services.  X  We correspondingly propose the optimizations and present the preliminary experiments. The remainder of the paper is organized as follows: Section 2 presents the basic structure of our framework, and the definitions and description of services. Then the optimization method is presented in Section 3. The experimental results and performance analysis are described in Section 4. Finally, we conclude and discuss the future work in Section 5. Based on the classical mediator model [6] a nd Web Service architecture w.r.t. distributed queries, the  X  X ediator X  will be taken place by  X  X omposite Service Evaluator X , which distributes the service requests to  X  X DB Wrapper X  and  X  X ML Wrapper X , integrate the gives a motivating example of a composite query service on RDB and XML. 2.1 Description of Elementary Service and Composite Service Definition1 (Elementary Service). (1) An elementary service is a query invocation that just concerns one data source, either RDB or XML document. The registry information of an elementary service is ( URL , DSN , interface ), where DSN is the data source name, i.e., RDB name or XML document name including relational schema or XML DTD; interface accepts query statements. (2) An elementary service returns the XML document by publishing the retrieved relational data or transforming the source XML by executing SQL or Quilt statements. Definition 2 (Elementary Service Function). Suppose that DSN and URL can identify a data source uniquely, the elementary service can be uniformly expressed as the following declarative function of S-Query ( URL , DSN , query_statememt ). For example, the elementary services on RDB and XML can be given as follows. Q 1: Get the information of the dep. that the student whose sno is  X  s 1 X  belongs to . Q 2: Get the medical information of the student whose sno is  X  s 1 X . 
As for the services and the procedures of service execution, there are three critical problems. First, what is the structure that publishing or transformation should conform to? Second, how does RDB wrapper or XML wrapper get the supervising structure to satisfy the composite query request? Third, how to tackle the more general cases that combine publishing and transformation? First of all, the composite query structure is defined. Definition 3 (Composite Query Structure Tree). A composite query structure is a tree that the query result, in XML format, should conform to, denoted by CQST . For simplicity, we  X  is the set of leaf nodes in CQST . Definitions 4 (Query Production in CQST ). Supervised by CQST structure, in order to i.e., cE  X  X  X  , such that c =( pn , l ). The actual service invocation on l is S -Query function as Definition 3. That is, l  X  get ( l , pn )  X  S-Query ( URL , DSN , query_statement ). which the query productions attached to the leaf nodes, define the concrete and respective operations to fill the hierarchical CQST step by step. Taking Fig. 1 as the example, Fig. 2 and Fig. 3 show a composite query structure tree and some query productions respectively. 2.2 Composite Logic Guided Query Service Evaluation CQST gives the service composition logic and the pre-defined structure, so that the evaluation of composite query services can be simplified as the execution of publishing and transformation mentioned above. For instance, in Fig. 2,  X  grade  X  information can be returned by adding a tag  X  grade  X  to the retrieved relational data as the XML fragment: &lt;grade&gt; grade 2 &lt;/grade&gt; . adding some desired tag of the XML fragment: bottom-up. Definition 5 gives the description of combination referring to the ideas in [9]. Definition 5 (XML Fragment Combination). Suppose the two fragments are frag 1 and the child of Pn by executing the operation of combine ( XML fragment 1 , XML fragment 2 ). RDB spot is transferred to XML spot, and the combine is carried out on XML spot to generate the result. The second case is that the fragment on XML spot is transferred to RDB spot, and the combine operation is done on RDB spot. The third case is that both fragments on RDB spot and XML spot are transferred to the client, and then combined. As for these alternatives, we choose the optimal one accordi ng to their median total execution costs. queries across the RDB and XML wrappers, but also the composite service can be invocated as a virtual elementary service to generate more complex query services. In CQST , for a set of query productions with the same parent node, the frequent initializations on RDB or XML are equivalent and carried out repeatedly if they are processed one by one in immediate mode. However, the lazy query processing on the leaf nodes in CQST can be done in bulk mode by partitioning the continuous query productions into some sections. The queries in one section will have the same parent node and the same selected data source. Lazy-Process algorithm is invoked during the pre-order traversal of CQST , shown in Algorithm 1, in which the inputs are CQST and the set of query productions, { l i  X  get ( l i , pn i )  X  S -Query ( URL , DSN , query _ statement )}. 
Algorithm 1: Lazy-Process Algorithm 2: Bulk-Evaluate query productions of  X  allergy  X  get ( allergy , medical_info ) X  and  X  blood_type  X  get ( blood_ type , medical_info ) X . They have the same parent node of  X  medical_info  X  and the same data source of  X  stu_medical  X , so the lazy optimization is feasible to be performed. In this section, we present the experimental results and the performance studies of our framework, and especially for the lazy processing of query services. Our experiments were conducted on the machine with a 1.4GHZ P4 processor, 512M of main memory, running the operating system of Windows XP Home Edition. Our codes were written in JAVA, and JDBC-ODBC is used to communicate with DB2 (UDB 7.0). The size of the buffer pool is 30M. The artificial data set is used including the XML document conforming to a specific DTD, and the relational data of specific relational schemas, which is similar to those in Fig. 1. The XML query structure tree for the composite service result in Fig. 2 is used. XML data source. At the same time, we take the node number of the result XML document, evaluated conforming to the pre-defined CQST , as the size of query service workload. compared. The query productions are processed one by one in immediate mode, while processed in bulk manner in lazy mode, in which a section of queries are processed in each pass. Fig. 4 gives the comparison of the two strategies w.r.t the same size of service workload It is clear that the lazy strategy is much better than the immediate one until the data source is very large. Following, as for immediate and lazy modes, we carried out the experiments on the same data source of 1000  X  student  X  entities, to give the comparison with the increase of the sizes of query service workloads as the measure of the desired evaluation results. It can be seen from Fig. 5 that the lazy method is more scalable for the size-increasing services compared to the immediate one, and it can improve the performance of composite service execution by an order of magnitude. combine and transfer alternative strategies that are mentioned in Section 2. However, it will not be described here for space limitation. In this paper, we propose a middleware framework of Web service Composition for distributed XML query evaluation based on th e mediator architecture and the corresponding composite query service evaluation strategies. As well, this paper arouses some interesting research issues from the inherent point of Web Services, such as cache and materialization mechanisms to improve the query service evalua tion. Then, if the semantics are considered in service processing, some heuristic approaches can be used as the optimization to exclude some useless retrieval. As well, statistics based methods can be used in the discovery of Web service semantics, and automatic composition, including the real application development. Most of these issues are out current or future work. 
