 XML has been a de facto standard format in the Web, and the sizes of XML doc-uments have rapidly been increasing. R ecently, due to geographical and admin-istrative reasons an XML document is partitioned into fragments and managed separately in plural sites. Such a form of XML documents is called distributed XML [5,2,1]. For example, Figures 1 and 2 show a distributed XML document of an auction site. In this example, one XML document is partitioned into four ( S 0 is the parent site of S 1 and S 3 ).

In this paper, we consider XSLT transformation for distributed XML docu-ments. An usual centralized approach for performing an XSLT transformation of a distributed XML document is to send all the fragments to a specific site, then merge all the fragments into one XML document, and perform an XSLT transformation to the merged document. However, this approach is inefficient due to the following reasons. First, in this approach an XSLT transformation processing is not load-balanced. Second, an XSLT transformation becomes in-small, whenever the merged document is large.

In this paper, we propose a method for performing XSLT transformation ef-XML fragment perform an XSLT transformation in parallel. This avoids cen-tralized XSLT transformation for distributed XML documents and leads to an efficient XSLT processing. For distributed XML, however, we have to consider handling modes of XSLT templates carefully, since multiple templates may be defined to a single element, e.g., in Fig. 3 two templates are applicable to a and the other two templates are applicable to b . This implies that we cannot determine the template that should be applied to a fragment F until the trans-formation of the  X  X arent X  fragment of F is completed. For example, in Fig. 1, in order to transform F 2 we need the mode applied to F 2 that is obtained af-method takes the following approach. 2. When the parent site S of S completes the transformation of its fragment, 3. S chooses the result transformed in mode m , and returns it as the result. XSLT transformation for distributed XM L. Therefore, in this paper we restrict the expressive power of XSLT to unranked top-down tree transducer[8]. We implemented our method in Ruby and made evaluation experiments. The result suggests that our method is more efficient than the centralized approach. Related Work A distribution design of XML documents is firstly proposed in [3]. There have XML. [4,5] propose an efficient XPath evaluation algorithms for distributed partitioned XML documents. [10] considers a regular path query evaluation in path query and structural r ecursion over distributed semistructured data. Be-for distributed XML. To the best of the authors X  knowledge, there is no study on XSLT evaluation for distributed XML. Trees, Hedges, and Tree Transducer Since our method is based on unranked top-down tree transducer, we first show  X  -trees) such that leaf nodes can be labeled with elements from Q . restricted to T  X  ( Q ) \ Q . A state corresponds to a mode of XSLT.
The translation defined by a tree transducer Tr =( Q,  X , q 0 ,R )onatree t in state q , denoted by Tr q ( t ), is inductively defined as follows. R1: If t = ,then Tr q ( t ):= .
 R3: If there is no rule ( q, a )  X  h in R ,then Tr p ( t ):= .
 Example 1. Let Tr =( Q,  X , p, R ) be a tree transducer, where T r corresponds to the XSLT script shown in Fig. 3. For example, consider the The tree t in Fig. 4 is transformed to Tr ( t ) in Fig. 5.
 Distributed XML that each fragment F i  X  X  t is stored in a distinct site. We allow arbitrary  X  X esting X  of fragments. Thus, fragmen ts can appear at any level of the tree. For example, the XML tree t  X  X   X  in Fig. 1 is partitioned into four fragments, F called root fragment . In Fig. 2, the root fragment is F 0 .

For two fragments F i and F j ,wesaythat F j is a child fragment of F i if connection between F i and F j ,weuseanEntityReferencenodeattheposition  X  X egions X  and  X  X eopl e X , respectively.
 S 0 has two child sites S 1 and S 3 . 3.1 Outline In our transformation method, all the sites S transform the fragment stored in F , the template that should be applied to F cannot be determined until the transformation of the parent fragment of F is completed. For example, consider and we cannot determine which of the rules should be applied to this node until the transformation of the root node is completed. Thus, for a fragment F and the rules r 1 ,  X  X  X  ,r n thatcanbeappliedto F , our method proceeds the transformation of F as follows. 2. When the parent site S of S completes the transformation of the parent 3. S receives the mode(s) tha t should be applied to F from S . S choose the 3.2 Our Transformation Method We now present the details of our method. We use two XSLT possessors Master-XSLT and Slave-XSLT. First, Master-XSLT is used in the root site and has the following functions.  X  Transforming the root fragment.  X  Sending appropriate modes to its child sites according to the transformation  X  Merging (a) the transformed root fragment and (b) the transformed frag-Second, Slave-XSLT is used in a slave site and has the following functions.  X  Transforming a fragment F stored in the slave site.  X  Applying rules to F in parallel, using native threads of Ruby.  X  Sending appropriate modes to its child sites according to the transformation  X  Sending the transformed result of F to the root site.
 Let us first present Master-XSLT. This procedure first sends a tree transducer ment by procedure Transform shown later (line 5), and receives the transformed Master-XSLT Input: A tree transducer T r =( Q,  X , q 0 ,R ) and the root fragment F . Output: Tree T  X  X   X  . 1. for each slave site S do 2. Send tree transducer T r to S . 3. end 4. v  X  the root node of F ; 5. F  X  Transform( T r ,F,v,q 0 ); 6. Wait until transformed fragment F i is received from each slave site S i . 7. Merge F and F 1 ,  X  X  X  ,F k into T . 8. Return T ; forms a given fragment recursively. Lines 4 to 21 transform the subfragment thesitestoring F ( v ).
 Procedure Transform of F ,andamode q .
 Output: A transformed fragment of F in mode q . 1. if v is an EntityReference node then 2. By referring to the parent node of v , identify the mode q that should 3. Send the mode q to S ( v ). 4. else if ( q, v )  X  h  X  R for some h then 5. Q  X  X  q | q is a leaf node of h } X  Q ; 6. if v has a child node v 1 ,  X  X  X  ,v k then 7. for each q  X  Q do 8. for each child node v i  X  X  v 1 ,  X  X  X  ,v k } of v do 9. F i  X  thesubtreerootedat v i of F ; 10. T i  X  Transform( T r ,F i ,v i ,q ); 11. end 12. Replace node q in h with hedge T 1  X  X  X  T k . 13. end 14. else 15. for each q  X  Q do 16. q  X  ; 17. end 18. end 19. Replace the subtree rooted at v of F with h . 20. else 21. Replace the subtree rooted at v of F with . 22. end 23. Return F ; Finally, we present Slave-XSLT. This procedure runs in each slave site S and transforms the fragment F stored in S . This procedure starts when it receives a tree transducer from the root site, and then transforms F by using the rules one transformation results may be obtained. Then the procedure waits until the and sends the fragment(s) transformed in mode(s) p to the root site (line 11). modes of v to child sites S ( v ). This is done in lines 12 to 15. Procedure Slave-XSLT Input: A fragment F stored in its own site.
 Output: none 2. v r  X  the root node of F ; 3. Modes  X  X  q | ( q, v r )  X  h  X  R for some h } ; 4. for each q  X  Modes do 5. Thread start 6. T q  X  Transform( T r ,F,v r ,q ); 7. Thread end 8. end 9. Wait until mode(s) p is received from the parent site. 10. if T p = null then 11. Send T p to the root site. 12. for each EntityReference node v in F do 13. Identify the mode q of v in T p . 14. Send q to S ( v ). 15. end 16. else 17. Send to the root site. 18. end For example, let us consider the distr ibuted XML document consisting of two Moreover, let S r betherootsitestoring m and S s be the slave site storing f . transformation of m with the initial mode p (Figure 8 shows the the transfor-mation result). Slave-XSLT running in S s receives T r and starts to transform andtheobtainedresultsareshowninFig.9.WhenMaster-XSLTencounters cedure sends the transformed fragments. In this case, the two fragments shown we obtain the output tree in Fig.10.
 our method in Ruby 1.93. We used 4 Linux machines, distributed over a local LAN (100base-TX). Each machine has a 2.4GHz Intel Xeon CPU and 4GB of memory. We used five XML documents generated by XMark[9], each of the documents were divided into four fragments (Table 1). Each XML document is and F 3 arefirstsentto S 0 ,then F 0 to F 3 are merged into one document T and an XSLT transformation is performed on T in site S 0 .

We used the following three XSLT stylesheets. These are synthetic stylesheets generated by our Ruby program.
 Sheet-1: This stylesheet has, for every element m of an XML document, at Sheet-2: This stylesheet has, for every element m of an XML document, a Sheet-3: This stylesheet has, for some element m of an XML document, at The results are shown in Figs. 11 to 13. As shown in these figures, our method is about four times faster than the cen tralized method, regardless the used stylesheets. This suggests that our method works well for distributed XML doc-uments. In this paper, we proposed a method for performing XSLT transformation for distributed XML documents. The experimental results suggest that our method work well for distributed XML documents.
 power of XSLT is restricted to unranked top-down tree transducer. We have investigated XSLT elements and functions, and we have found that about half of the elements/functions can easily be incorporated into our method (Type A of Table 2). The elements/functions f of this type can be calculated within the fragment in which f is used, e.g., xslt:text . On the other hand, it seems Table 2). An example element of this type is xslt:for-each , which accesses several fragments beyond the fragment in which the xslt:for-each element is used. Thus, we have to handle XSLT elements/functions of Type B carefully in to experimentation. In our experimentation we use only three synthetic XSLT stylesheets. Thus we need to make more experiments using real-world XSLT stylesheets.
 Acknowledgement. This research is partially supported by Research Center for Knowledge Communities, University of Tsukuba.

