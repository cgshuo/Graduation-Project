 Given that search engines need to answer queries within fractions of a second, naively traversing the huge amount of basic index structure, which could take hundreds of milliseconds, is not acceptable [1]. This efficiency problem has been largely addressed by top-k processing methods [2-4, 7, 8], which in a nutshell means returning the best k results without an exhaustive traversal of the relevant posting lists. However, most top-k processing algorithms start with a threshold of zero, and then update the value while results are discovered. Thus, the algorithms can only speed up until there are k results obtained, and too small initial threshold can make lots of documents be prom-ising candidates temporarily. 
The slow startup problem in top-k processing has motivated a lot of work on opti-mization techniques. Fontoura et al. [5] propose a new technique to speed up MaxScore query and a long query. The results (or threshold) obtained by quickly evaluated short query is used to speed up the evaluation of the long query. The term bounded MaxScore method [3] improves upon the DAAT MaxScore to set a better initial threshold by using toplist index structures [6]. Recent work in [7] builds a two-tiered index upon the blockmax index, resulting in considerable performance gains. Different from previous work, we propose a novel improvement of MaxScore that requires no modifications to the index structure. Our method allows a first aggressive process with one posting list X  X  max score as the top-k threshold and then a supplementary process if not enough results are returned, thus the name Aggressive MaxScore (AMaxScore). In the following sections, we present and evaluate our AMaxScore on TREC GOV2 collection. As mentioned, a proper threshold can exactly avoid processing documents that are obtained by a complete query evaluation, one possible approach is to estimate the threshold as  X  X  with a guarantee that  X   X   X  X  , in order to ignore any documents with scores lower than  X  X  . The threshold  X  X  is commonly automatically set to the k th score of the documents in the results heap during the query processing. It is obvious that the nored. initial stage of the query, the whole query latency will be reduced. The threshold es-timation methods are very popular for most optimization techniques, but most of these methods require modification to the underlying index structures for storing high quality documents. Also, it is hard to exactly estimate threshold that satisfies the condition of  X   X   X  X  , and provide extra memory for processing more indexes. In AMaxScore, we  X   X   X  X  , but somehow closer to  X  . When complete the query processing, we check the number of the results. If the number of the results is not enough, we can conclude that duct supplementary passes with smaller initial thresholds until the results is enough. The threshold  X  X  can be set to various accumulative score of term upper bounds, i.e., the minimum or maximum score of term upper bounds, the sum of all term upper bounds etc. Suppose the threshold is set to the sum of some or all of the term upper bounds, it means a document that can make it into the top result heap only if it contains the term upper bounds, it means a document that only contains that term, but no other terms, can never make it into the top results heap. Thus, there is no need to score any documents that contain only that term. Performance gains are achieved when the processing does not run a supplementary pass. 
This kind of method tends to be less studied for top-k processing methods. Though focuses on WAND approach and is just us ed to transfer normal queries into AND-queries. Thus, we can consider it as a special case of our method. Note that in our method, the partial results by the aggressive pass can be used in the supplementary pass to reduce a large amount of heap sort operations. We use the TREC GOV2 collection containing about 25.2 million documents and about 32.8 million terms with an uncompressed size of 426GB. We build inverted index with 128 docIDs per block, using PForDelta compression, removing stopwords, and applying Porter X  X  stemmer. The final compressed index size is 7.57GB. We use 10000 queries randomly selected from the TREC2005 Efficiency track queries using distinct amounts of terms with |q|  X  2. Our experiments were performed on an Intel(r) Xeon(r) E5620 processor r unning at 2.40 GHz with 8GB of RAM and 12, 288KB of cache. All methods were implemented in JAVA on Terrier IR platform [9] with Okapi BM25 as the ranking function. In every experiment, the index was preloaded into memory and the numbers are averaged over 5 independent runs. 3.1 Results In this section, we compare AMaxScore with the state-of-the-art MaxScore [4] by fine tuning the threshold  X   X  . The threshold  X   X  is set to the minimum value, maximum value and average value of the query term upper bounds respectively in the aggressive pass. In extreme cases, too large threshold will lead to completely ineffectiveness of the aggressive pass, resulting in some of the top-k results obtained in the supplementary pass. Thus, we run an experiment of AMaxScore with a threshold set to the sum of all term upper bounds. In additional, we also test the effect of resetting the heap after an aggressive pass for query processing performance. Table 1 shows the query processing time using different algorithms with different number of documents returned. From Table 1, we can see that all optimi zed techniques improve greatly over the MaxScore baseline. For different k, AMaxScore_Max(  X   X  ) always performs the best, which achieves an average improvement of 15.4% over the MaxScore baseline. We also observe a little performance degradation in AMaxScore_TooLarge(  X   X  ) over the baseline. This is mainly because too large threshold value will cause ineffectiveness of the aggressive pass. Most results are returned in the supplementary pass, and the aggressive processing becomes an extra cost for the whole query processing. In addition, the improvement achieved by AMaxScore_Max(  X   X  )_HR is not as much as that achieved by AMaxScore_Max(  X   X  ). This suggests that keeping the query results stored in the heap is helpful for enhancing the performance. Although the results in the first pass can be obtained by a supplementary pass again, a couple of heap sort opera-tions are reduced when the same results are inserted into the heap. As we increase k, though query processing time increases for all methods, our AMaxScore achieves an increasingly improvement over the baseline. The explanation is that the estimated occurred in AMaxScore_Max(  X   X  ) with k equals 1000, being about 20% faster. Thus, we can conclude that fine-tuning the top-k threshold can result in significant perfor-mance improvement for different corpus. In this paper we have proposed a new method to speed up MaxScore by fine-tuning the top-k threshold, which can trigger an aggressive processing with supplementary orig-inal MaxScore processing if not enough results returned. Experimental results with TREC GOV2 showed that our AMaxScore significantly outperforms the previous methods with an average improvement of 15.4%. The best case produced almost 20% performance gains without sacrificing result quality. 
