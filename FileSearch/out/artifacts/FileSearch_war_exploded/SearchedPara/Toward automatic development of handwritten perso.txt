 ORIGINAL PAPER Kazim Fouladi  X  Babak N. Araabi Abstract The interest in personalized handwritten fonts has been increased in recent years. This paper concerns with the automatic generation of Farsi/Arabic handwritten fonts. To reach this target, we need to extract the properties of the writer X  X  script style. The  X  X lyphs X  (simple characters or liga-tures) of the writer X  X  script are extracted from the basic sub-words. The basic subwords are acquired from a writer using tabular sheets. A learning method is used in extraction phase. After glyph extraction, four important steps are performed automatically: (a) adjusting glyphs joints and baselines (b) computing metric data, (c) locating dots, and (d) computing kerning pairs. Finally, the gathered information is compiled in an OpenType  X  font file structure to generate a computer font, which can be used in any computer application. The results seem visually acceptable.
 Keywords Farsi, Persian, Arabic font  X  Glyph extraction  X  Handwriting generation  X  Kerning  X  OpenType  X  font 1 Introduction Computer font is one of the most important parts of a type-setting system that almost all people deal with them in word processing and other applications. In recent years, develop-ing handwritten fonts for various languages has been con-sidered more by designers and researchers of typography domain [ 18 ]. Many people may like to write their letters and notes by using their personal font to express their feelings. Receiving a letter or email written in a personal font makes communication more pleasant and expressive than if written in a common font [ 28 ].

Designing a font by the classical methods has special steps that mainly need a high-level knowledge of graphical design and fine attentions, and it is very time-consuming. On the other hand, personal fonts that prepared from the people X  X  handwriting are recently interested [ 5 ]. The application soft-wares such as  X  X canhand X  from HighLogic corporation have been designed to generate a personal font from a user X  X  hand-writings for English and other Latin languages [ 13 ]. It pro-vides a two-page tabular form consisting of letters, digits, and other symbols, which the user should fill it by the hand. Then, the forms are fed to the software using a scanner. The soft-ware processes the filled forms and extracts the glyphs, then returns its output as a font file. This approach is almost sim-ple, because there is no need to segment user X  X  input images to smaller units. The quality of the output font depends on the quality of user-filled forms more than anything else.
Based on our knowledge, a similar work has not been performed yet for Farsi/Arabic language. This is perhaps because of the natural complexities of these scripts such as their cursiveness. In this paper, we study this problem for the first time. We develop a method for generating personalized fonts for Farsi/Arabic script. To this end, an appropriate set of words are selected that the user should write them in pre-designed tabular forms. Our algorithms analyze these forms and extract the glyphs automatically. Then, dots are added to the glyphs, and metric data of them are computed.

Our target is generating fonts in open-type format that includes required parameters for production of high-quality Farsi/Arabic handwritten fonts.

This paper is organized in seven sections. After the intro-duction, in Sect. 2 , the related works in the literature are reviewed. The properties of Farsi/Arabic open-type fonts are explained in Sect. 3 . In Sect. 4 , the process of automatic gen-eration of Farsi/Arabic open-type fonts is presented. Experi-mental results are given in Sect. 5 . In Sect. 6 , advantages and shortcomings of the proposed method are discussed. Finally, concluding remarks and suggestions for future works are pre-sented in Sect. 7 . 2 Related works The early attempts in the field of font generation had been devoted to extract dot-matrix templates of glyphs, which are suitable for display devices and matrix printers [ 23 ]. After the growth of usage of laser printers, scalable outline fonts were regarded more than the past [ 17 , 39 ]. At the same time, the generation of parametric fonts X  X he families of fonts that can be rendered when a few parameters were set X  X as taken into account [ 20 ].

Work on personal fonts was begun in the domain of hand-writing synthesis that has applications such as handwriting analysis [ 34 ], writer identification [ 27 ], handwriting genera-tion [ 7 , 18 ], generating handwritten-style computer fonts [ 5 ] and generating training data for handwriting recognition sys-tem [ 4 , 33 ]. In 1996, Guyon [ 10 ] proposed a direct method to produce handwritten words. The system gathers hand-written glyphs of single characters and most frequent let-ter groups, such as  X  X y X  and  X  X ion X . To synthesize a word, the system splits the word into letter groups or characters, and then the corresponding glyphs are concatenated directly. This simple approach requires users to write more than 1,000 letter groups, which is tedious and non-practical; however, the appearances of the results were acceptable. In [ 18 ], the authors select the most important features that depict the handwriting style, including character glyph, size, slant, and pressure, special connection style, letter spacing, and cur-siveness, and compute them by gathering information from users with the aid of a specially designed sample collect-ing interface. The glyphs are extracted, and their properties are adjusted. The system gets an English ASCII text and returns corresponding bitmap image of synthesized hand-writing. The experiments performed on eight writers and the results were shown subjectively acceptable.

Many works on personal font generation are in the context of Chinese handwriting. Due to the large number of charac-ters, the process of manual generation of a personal font is very time-consuming and boring; therefore, many authors try to reduce the severity of this task by proposing automatic and semiautomatic methods. In [ 43 ], a method for generating dynamic Chinese fonts is proposed. The shape of character in dynamic font is random and determined only when the character is rendered. This kind of fonts may be used to sim-ulate handwritten Chinese characters, create character vari-ants, and design new symbols. In [ 40 ], an intelligent system was proposed to automatically generate original Chinese cal-ligraphy. The main technique is constraint-based analogous reasoning. The results show that the system can yield novel calligraphy styles given some existing ones. Xu et al. [ 41 ] propose an intelligent algorithm, which can generate imita-tions of Chinese handwriting of a person requiring only a very small set of training characters written by the person. This algorithm first decomposes the sample Chinese hand-writing characters into a hierarchy of reusable components. For handwriting generation, the algorithm tries and compares different possible choices to compose the target character. The likeliness of a given personal handwriting generation result is evaluated according to the captured characteristics of the person X  X  handwriting, and the one which can max-imize a likeliness estimation is selected. The results were verified through comparison with the groundtruth data and by a small-scale user survey. Kuroiwa and Shin [ 16 ] propose a method for discovering efficient Chinese characters so as to generate handwritten-style fonts effectively. In their method, the characters that are essential for generating all other char-acters are selected. With their procedure, all 2,965 Chinese characters were generated using 126 efficient input charac-ters, which have relatively few. As a result, the burden of writing characters for font generation was greatly reduced. In [ 6 ], a popular snake model and genetic algorithm are applied to segment the radicals in handwritten Chinese characters. The segmentation accuracy reaches 94.91% for complicated samples with overlapped and connected radicals. The experi-ments show that the constructed characters well maintain the handwriting style of the user. The user only needs to write a small number of samples for obtaining his/her own hand-written font library. In [ 19 ], example-based approach simi-lar to [ 41 ] is used. This algorithm analyzes and learns the characteristics of character handwriting styles both defined in the Chinese national font standard and those exhibited in a person X  X  own handwriting records. The parametric repre-sentation of character shapes is completed by using spatial relationships between multiple constituent components of a character. The quality of the automatic generation algorithm was explored by comparing the computer-generated results with the authentic human handwriting samples.

Similar works on Japanese font generation have been per-formedsuchas[ 36 ](calligraphygenerationusingdeformable contours), [ 35 ] (using genetic algorithm), and [ 28 ] (by utiliz-ing user interaction to generate a handwritten-style font that reflects the user X  X  individuality).

In the context of English and Latin languages, Yoshida et al. [ 42 ] propose an interactive genetic algorithm for font generation system. This system combines the user X  X  favorite fonts and creates a new font. The result font can be used to generate other fonts in further steps. The evaluation step needs user interaction. Another work in [ 31 ] proposes an example-based automatic font generation method from a user-defined example. For each character outline, a skele-ton is derived as a topological structure. Then an arbitrary font is represented using a weighted blend of outlines and skeletons from template fonts. The system takes the outline of a single character drawn by the user and computes blend-ing weights from a database to reproduce the given outline. The weights are then applied to all characters to synthesize the new font. The quality of this method is evaluated with some examples.

For Farsi/Arabic languages, we did not find any compre-hensive work on automatic handwritten font generation. The only two works, [ 8 ] and [ 24 ], are about handwriting syn-thesis using glyph concatenation technique for generating datasets for training handwriting recognition systems, which take Arabic script into account. The current paper to our knowledge is the first article about Farsi/Arabic automatic handwritten font generation. 3 Properties of Farsi/Arabic OpenType  X  fonts 3.1 Properties of Farsi/Arabic script Farsi alphabet consists of 32 letters. Due to the position of a letter in a word, each letter may have up to four shapes: initial, medial, final, and isolated (Table 1 ), which are called simple glyphs. Those letters which have no initial or medial shape cannot join to their next letter; therefore, their isolated form is used as initial and their medial form is used as final. In Arabic alphabet, four letters do not exist. If dots and other marking symbols (diacritics) such as Madd (  X  ) discarded from the letters, the main bodies of the letters are extracted. It can be seen that the main bodies of some letters are identical, such as  X   X  and  X  . X  The gray rows in Table 1 show a complete set of Farsi letters with distinct main bodies. It is obvious that the number of Farsi main bodies is less than the number of letters [ 29 ].

Farsi/Arabic script is written from right to left. The let-ters in a word are usually joined together. The shape of letters depends on their previous/next letters. There is no joint between two distinct words, and words are separated by space.

Glyph is a symbol representing one letter or a combina-tion of two or more letters. Simple glyphs , i.e., those shown in Table 1 , are the symbols representing single letters. Liga-ture is a glyph that represents a combination of two or more letters in a typographically acceptable manner. Farsi/Arabic scripts have several standard ligatures, which do not fol-low simple letter-joining rules. The most common ligature is  X  X am-Aleph ( ), X  which is typographically different from a simple joint of letters ( ). The precise shape of each lig-ature depends on the font in printed text, and writer X  X  script in handwritten text [ 2 , 11 ]. Figure 1 shows a set of simple glyphs and most important ligatures in printed/handwritten Farsi/Arabic script, where only the main bodies of glyphs are shown. When dots are taken into account, several glyphs correspond with the same main body. 3.2 OpenType  X  features of Farsi/Arabic fonts The OpenType  X  font format has special features that make it enable to construct handwritten-style Farsi/Arabic fonts [ 2 , 12 ]. Each feature has a four-letter name and implemented by using look-up tables:  X  ccmp (character composition/and decomposition): The  X  init, medi, fina, isol (initial, medial, final, and isolated  X  rlig (required ligatures): The  X  X lig X  feature is used to map  X  calt (connection alternatives): In specified situations,  X  liga (standard ligatures): The  X  X iga X  feature is used to  X  curs (cursive positioning): The  X  X urs X  feature positions  X  kern (kerning): The  X  X ern X  feature is used to adjust
Our proposed method computes the parameters of these features and constructs the corresponding tables to prepare the font. 4 Automatic generation of Farsi/Arabic open-type fonts The central part of generating a font is preparing its glyphs. The glyphs of a personal font are extracted from a writer X  X  handwriting samples. Basic subwords are appropriate words, whichcanprovideusessentialinformationoftheglyphswrit-ten by a writer (subword is a continuous part of a word). A proposed algorithm extracts the glyphs and their properties from these sample words. Afterward, required dots are added to the glyphs and complementary items such as kerning pairs are computed and ligatures are defined. As shown in Fig. 2 , this set of information can come together to generate a per-sonalized OpenType  X  font file.

We assume that the writer X  X  script is clean and clear, and segmenting its samples to simpler parts to extract glyphs is possible by using an algorithmic method. Therefore, we do not consider non-regular scripts for evaluating our proposed method. 4.1 Basic subwords The set of basic subwords consists of the appropriate words, which can provide us essential information of the glyphs written by a writer. According to the required glyphs (sim-ple and ligatures), we select 229 single-part words with the following two conditions: (1) the word is as short as possible, (2) the connections of the letters are as simple as possible, i.e., separation of the glyph from its neigh-bors is regularly possible with high accuracy. The set of subwords in Fig. 3 has selected according to these conditions. In subword selection process, we also try to choose meaningful subwords that are familiar to common writers. 4.2 Getting writers X  data and preprocessing Each writer provides the system his/her handwriting sam-ples via filling the tabular forms containing basic sub-words (Fig. 4 ). The system reads theses forms automati-cally and extract the images of the basic subwords. To get appropriate images, the following preprocessing steps are performed: 1. Connected components labeling : to extract main bodies 2. Image dilation by morphological operations : to elim-3. Image magnification : to enlarge details of subword bod-4. Edge detection : to extract boundary images of subword 5. Tracing boundaries of subword bodies : to obtain a 6. Contour smoothing : a low-pass filter is used to gen-
We use contours (closed curves) to represent main bodies of all words. Glyph extraction from words is performed on these contours. 4.3 Extraction of glyphs from basic subwords The proposed algorithm needs templates as training data to separate glyphs. These templates are obtained from manu-ally separated glyphs in training phase for a few users. Tem-plates are stored in the system. In the test/evaluation phase, the glyphs of other users are extracted automatically using obtained templates in the training phase. 4.3.1 Preparing template glyphs To prepare template glyphs, we need a set of prototypes of handwriting styles. This prototyping process can be per-formed via clustering handwriting samples which we have. Toclusterhandwritingstyles,weusecontouranglehistogram feature, which is used in writer identification literature [ 1 ]. This feature is computed for each writer X  X  basic subwords. The clustering method is k -means clustering with  X  2 dis-tance, which is more meaningful in comparison of two his-tograms [ 14 ]. Number of clusters is determined using entropy measure [ 21 ]: H = X  1 where N c is the number of clusters, N w is total number of writers in our dataset, and D ( j , i ) is the  X  2 distance of j th writer from the mean of i th cluster. Changing N c from 1 to N w (which is equal to 52 in our experiments), the entropy of the best partitions for each N c is calculated. The optimal number of clusters, N  X  c , is one that H value has little changes for N c &gt; N  X  c . It means that increasing the number of clusters may not increase the information measure of the clustering. Therefore, we use N  X  c writers (each one from one cluster) for generating templates.

The templates which needed in manual glyph extraction are prototypes of handwriting styles. These prototypes are representatives of the obtained clusters that are selected by minimal intra-cluster distance criteria. They are numbered from 1 to T , where T is the number of prototypes, which is equal to the optimal number of clusters, N  X  c .

Now, the glyph label and its generative basic subword for each prototype in the contour form are shown to the human operator and s/he selects the appropriate cutting points to extract glyph shape using mouse clicks on the contour. This operation is performed for all required glyphs, and there-fore, the cutting points are determined for all basic subwords on their contours. Having cutting points, we can decompose each basic subword to its consisting glyphs, and therefore, the set of all glyphs of a prototype writer is determined. So, template glyphs are available to further processes. 4.3.2 Automatic glyph extraction using contour alignment Having a set of template glyphs and their cutting points as training data, we can generate required glyphs for the other writers X  glyphs, automatically. This task is performed as fol-lows for each glyph (Fig. 5 ): 1. The contour of the generative basic subword is consid-2. Using an alignment algorithm for contours [ 9 ], we align 3. Cutting points on the template contour have been speci-4. The resulting cutting points of the contour C are utilized 4.4 Glyphs adjustment Theautomaticallyextractedglyphsneedsomeadjustmentsto stand in appropriate frame. Since the extracted glyph joints may not be rectified or their thicknesses may be incorrect, we should perform adjustments to eliminate this problem. Furthermore, the position of each glyph with respect to the baseline position is very important in the output fonts; thus, baseline adjustment is another task that is necessary to per-form. 4.4.1 Joints adjustment The joint adjustment task rectifies the joints for right-joinable and left-joinable glyphs and corrects their thick-nesses. According to Fig. 6 , there are three cases for each right or left joints. Assume that uR and lR are upper and lower points of the right joint, and uL and lL are upper and lower points of the left joint. As illustrated in Fig. 7 , these cases can be corrected by exploiting the following rules: a. Correcting thickness of the left joint: let h = 1 2 ( y b. Rectification of the left joint: y ( lL )  X  y ( uL ) + c. Rectification of the left joint: y ( uL )  X  y ( lL ) + d. Correcting thickness of the right joint: e. Rectification of the right joint: y ( lR )  X  y ( uR ) + f. Rectification of the right joint: y ( uR )  X  y ( lR ) + 4.4.2 Baseline adjustment The baseline adjustment task corrects the location of baseline with respect to the bottom edge of the black box of each glyph. The glyphs are considered without any dot at this stage (the main bodies of the glyphs are used). There are five cases for this adjustment: 1. For the main bodies of the isolated glyphs, those 2. For the main bodies of the final glyphs 3. For the main bodies of initial glyphs that are left-joinable 4. The BBBE of all the main bodies which ended with 5. For the main bodies which are joinable from both right
Finally, each glyph must be moved along with y direction such that the y coordinate of its baseline be located in the origin, i.e., y = 0.

After above adjustments, the outline curve of glyph X  X  body is ready. The appropriate Bezier curves for representing high-quality contours are obtained using a method similar to [ 25 ] and [ 26 ]. 4.5 Adding dots to glyphs The final glyphs of a font are obtained via adding dots to the main bodies (if required). We need four types of dots: single-dot (.), double-dot (..), upper-triple-dot, lower-triple-dot, which are extracted directly from sample words , and , respectively.

The positions of the dots are determined by using these heuristics: We take the image of the main body of the glyph and perform a dilation operation l times for thickening the body ( l , lifting, can be thought as the distance between center of a dot and the edge of the main body in terms of pixel). An edge detection operation is performed on this thicken image (Fig. 10 a). The intersection of the edge with the black box of the glyph yields two curves (upper and lower than main body). The centers of these curves over x direction are the suitable points for the dots (Fig. 10 b). If the desired glyph has more than one component (ligature), namely n ,the width of its black box is divided into n section. The width of each section is proportional to the width of each individual corresponding letter. Figure 11 shows a three-part glyph and the positions of its possible dots. In Fig. 11 d, some samples of adding dots to the main body of a glyph are illustrated. Note that the value of the lifting of dots, l , can be selected arbitrary and is used as a tuning parameter. We let its default value l = 2 d .

This heuristics has some exceptions, which mainly related to the glyphs ending with the main bodies of ,or . The positions of dots can be corrected as shown in Figure 12 . 4.6 Glyphs X  metrics computation Each glyph has a window, which includes its black box (the minimal bounding box that includes all the outlines of the glyph). This window has some defining lengths that called metric parameters. The important metric parameters are (Fig. 13 ):  X  Left Side Bearning (LSB) :LSB = x ( lL )  X  x min  X  Right Side Bearning (RSB) :RSB = x max  X  x ( lR )  X  Upright Baseline offset (UBO) :UBO = y baseline  X  y min  X  Advance Width (AW) :AW = x ( lR )  X  x ( lL )  X  Width (W) :W = AW + LSB + RSB. 4.7 Font X  X  kerning data computation Kerning is the selective reduction of the amount of white space found between two adjacent glyphs. Kerning is impor-tant for an attractive and beautiful look of the script. This concept is more essential for handwriting fonts. In Fig. 14 ,a sample two-part word is shown, which has written by three different writers and the result of ignoring/using kerning has been illustrated. Obviously, the result of applying kerning is more natural and more regular in these samples rather than ignoring it.

To add the kerning data to a font, we must compute the appropriate space between adjacent glyphs; but this is a very time-consuming task. If the font has n glyphs, the number of pairs is O ( n 2 ) and the time of manually adjusting kernings is O ( n 2 ) , too, although we can perform these computations automatically by a method similar to the proposed method in [ 30 ], which is adapted for Farsi/Arabic script by us. The steps of this method are:  X  All the possible pairs of the glyphs are determined: these  X  For each pair of ( G L , G R ) : 1. Rasterize the left and right glyphs after standing them on 2. Extract the common height of the images IG L and IG R 3. Scan by a horizontal line from top to bottom with step 4. Find the minimal length scanning line (its length is r ). 5. Relocate the glyph G L to left by r to remove the blank 6. If the desired blank space is k , it can be achieved by Figure 15 illustrates these steps on a sample pair of glyphs. 4.8 Adding ligatures The set of sample words written by each writer contain a lot of ligature patterns. To use ligatures in an OpenType font, we assign a glyph to each ligature pattern and add its associated rule to font X  X  ligature tables (liga, rlig, and clig features of the OpenType  X  fonts), for example:
It should be mentioned that the order of ligature rules in the tables is important and is determined by their number of parts (from the largest to the smallest). 5 Experimental results We implement the proposed method of generating personal handwritten font in MATLAB  X  . For each writer, all the required information for creating an OpenType  X  font is com-puted and prepared for locating in a font file. A user interface is designed to simulate typesetting with the generated font with its features and properties. To get the final font file, we use FontForge  X  textual format ( *.sfd )[ 37 ] that can be compiled to *.ttf and *.otf font formats.

In our experiments, there are 52 sample writers. We assign an identifier as w i for writer i . 5.1 Selecting templates among writers As explained in previous section, we need some template writers to compare their basic subwords with other X  X  basic subwords in automatic glyph extraction phase. The cutting points on the template basic subwords should be specified manually. We use a prototyping procedure via clustering to determine the proper number of template writers. In our experiment, we consider number of clusters from 1 to 52 (total number of writers in our dataset) and evaluate the result clustering by entropy measure (Eq. 1 ). As shown in Fig. 16 for N c greater than 8, this value has very little changes. It meansthatincreasingthenumberofclustersmaynotincrease the information of clustering. Therefore, we use 8 writers as template prototypes. The selected prototype writers in our experiments have the following identifiers 3, 9, 11, 26, 36, 39, 47, 51. 5.2 Visual comparison of generated fonts with handwritten In Fig. 17 , a sample sentence of 10 randomly selected writers is shown. The handwritten sample and the typewritten sample (by the corresponding generated font) of each writer can be compared visually. It can be seen that the general scheme of the writer script has been reflected in his/her corresponding font. The visible differences are due to the natural differences between typesetting and handwriting. One of the advantages of the generated fonts is their harmonies and regularities in spaces and dots (shape and location), which are less consid-ered in handwritings. Figure shows more sample generated sentences for these writers (Fig. 18 ). 5.3 A test using writer identification framework We use WRIDE, as an open-source writer identification application to verify the actual similarity between gener-ated fonts and writers X  handwritings. WRIDE is a simple Matlab implementation of a system based on state-of-the-art techniques for writer identification [ 1 ]. The system is based on multi-scale edge-hinge and grapheme features. The grapheme codebook that used in the computation of grapheme features is constructed by means of a Kohonen SOFM. The classification is performed by a 1-nearest neigh-bor classifier using Manhattan distance [ 32 ].

We prepare a synthetic sample page of words for each writer by using his/her generated font. Also, for each writer a handwritten page of words is prepared. According to Table 2 , four configurations for experiment are obtained.

The best performance of running WRIDE on this dataset is 96.15% which was obtained by synthetic samples as training and test data. The worst performance (84.61%) belongs to the case: synthetic samples as training data and handwritten samples as test data. This result is expected because synthetic training data cannot perfectly capture the visual properties of handwritten test data. The results in Table 2 indicate that the generated fonts have good similarities to their original handwritings. In training the system by handwritten samples and testing it by synthetic data, the only three writers of 52 are incorrectly identified. Visual inspection indicates that this is because the high similarity between the handwritings of these writers and the identified results (Fig. 19 ). 6 Discussion The proposed method generates a handwriting font for each writer by using a small set of his/her script samples. However, some of the aspects of the handwriting model are ignored. We set the spaces between words and dot liftings to default values without referring to the writers X  script samples. These parameters can be computed for each writer, but it seems that the nature of handwriting prevents a proper computation. As shown in left column of Fig. 17 , the writers usually adjust spaces and dots positions arbitrary, but these parameters have more regularity in typewritten forms (right column). There-fore, we believe that it is better to adjust these parameters without referring to the writers X  samples.

Another thing is baseline adjustment. For each writer, we provide guidelines for the baselines of sample words on the tabular forms, but our experiments show that most of the writ-ersdidnotrespectthesebaselines.Therefore,automaticbase-line adjustment is necessary. We adjust the location of base-line for each glyph according to the proposed rules. Although these rules generate acceptable results but, the results may differ with natural handwritings. For example, dynamic base-line relocation is a common case. Some of these relocations can be implemented in the resulting fonts via vertical kerning feature of OpenType  X  fonts, but to learn them, we need more handwriting samples of each writer (in the level of text liens not words only).

The size of handwriting sample is another issue. We assume that the users write the samples in a fixed size, and we do not perform any size normalization. Fortunately, this assumption was true greatly in our experiments.

Moreover, the proposed method assumes that the writers write carefully with constant speed. In our test samples, this assumption was true, but in real, it may be possible that users write more quickly and less patiently after some time such that the script may become crabbed. Since the target of our system is font generation, it is reasonable to expect the writer to write as well as possible. Thus, improper handwriting sam-ples must be discarded at all.

The results of evaluations in the context of writer iden-tification indicate that the proposed method can capture the overall scheme of the writers X  scripts in the generated fonts. However, in some cases, one can observe various differences. For example, in Fig. 17 row 6 (w27), the comparison of nat-ural handwriting with font-generated one indicates more dif-ferences. This is because of the variations in the writer X  X  handwriting style or due to the increasing writing speed in drawing test sentences. However, the invariant properties are also observable. For the writers with more stable styles, these variations are lower, for example, in Fig. 17 rows 1 (w9), 9 (w46), and 10 (w47).

The generated fonts by using the proposed method have almost 1000 glyphs due to using a large set of ligatures for better simulation of handwriting styles (one ligature body can have several dot patterns such that each one is a distinct glyph).Inaddition,morethan10000automaticallycomputed kerning pairs are included in the generated font. It is obvious that manual generation of such font is very time-consuming and tedious. The proposed method performs this task auto-matically. Even if the resulting font has less quality than writer X  X  exception, it is possible to edit the obtained font manually in a font editor application so faster than building it from scratch.

Another issue discussed here is about manual selection of cutting points for template glyphs, which is done by a human operator. While the cutting points are selected in a reason-able manner, the total effect on the extracted glyph does not cause any problem, because the glyph joints are corrected and adjusted in  X  X oint adjustment X  phase after matching and cut-ting. However, if the cutting points are selected completely wrong, this error cannot be corrected and may rise special problems on glyphs X  appearances in further steps. The correct selection of cutting point should be judged visually according to calligraphic rules of the script.

It should be noted that the suitable structure of OpenType fonts for handling Farsi/Arabic handwritten fonts, specially supporting cursive attachment, ligature and kerning features, was very helpful in the construction of our desired fonts. Without these features, the resulting fonts cannot properly simulate their corresponding handwritings. 7 Summary and conclusion In this paper, we presented a new method to generate handwritten-style Farsi/Arabic personal font, which extracts the user X  X  handwriting glyphs from his/her limited set of words and computes the necessary parameters of the result-ing font. Particularly, our system respects the features such as dot attachment to main body of glyphs and kerning val-ues, as well as the proper adjustments of glyphs X  joints. The experimental results demonstrate that our system can pro-duce personal handwriting fonts with pleasing visual quality.
The proposed method has considerable advantages: First, the user involvement is minimal. It is limited to fill a set of 240 subwords (in three tabular sheets). Second, the number of training data for leaning glyph extraction system is very low (eight writers of 52 in our experiment). Third, the results appear visually acceptable regarding to the generated sam-ple outputs. Finally, the system automates time-consuming tasks in Farsi/Arabic handwriting-style font generation such as adding dots to glyphs bodies, adjusting kerning pairs and setting cursive attachments.

We believe that developing a complete application using the proposed method allows each person to have a personal handwriting-style font to write his/her letters and notes dig-itally by a fully dedicated font.
Following this work, we try to add other features to the fonts such as marks and vertical kernings. Furthermore, con-sidering parameters such as pen pressure and obtaining arbi-trary thickness of glyphs are performed in a later phase of this research.
 References
