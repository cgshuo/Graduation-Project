 Abstract Parser Evaluation using Textual Entailments (PETE) is a shared task in the SemEval-2010 Evaluation Exercises on Semantic Evaluation. The task involves recognizing textual entailments based on syntactic information alone. PETE intro-duces a new parser evaluation scheme that is formalism independent, less prone to annotation error, and focused on semantically relevant distinctions. This paper describes the PETE task, gives an error analysis of the top-performing Cambridge system, and introduces a standard entailment module that can be used with any parser that outputs Stanford typed dependencies.
 Keywords Parsing Textual entailments 1 Introduction Parser Evaluation using Textual Entailments (PETE) is a shared task in the SemEval-2010 Evaluation Exercises on Semantic Evaluation that involves recog-nizing textual entailments (RTEs) to evaluate parser performance. Given two text fragments called  X  X  X ext X  X  (T) and  X  X  X ypothesis X  X  (H), RTE is the task of determining whether the meaning of the hypothesis is entailed (can be inferred) from the text. In contrast to general RTE tasks (Dagan et al. 2009 ) PETE is a targeted textual entailment task that focuses on syntactic entailments: Text: The man with the hat was tired.
 Hypothesis-1: The man was tired. ( yes ) Hypothesis-2: The hat was tired. ( no )
By syntactic entailments we mean entailments that can be recognized using grammatical knowledge alone, without recourse to background knowledge or logical reasoning. The main goal of PETE is not to create a general entailment system, but to use entailments as a probe to evaluate a basic linguistic competence, in this case identification of grammatical relations (GR).

The participants were provided with a number of text X  X ypothesis sentence pairs as input (similar to the Text X  X ypothesis-1 pair given above). The goal of the participating systems was to output an accurate YES/NO decision on the syntactic entailment status of each pair (e.g. YES for the Text X  X ypothesis-1 pair and NO for the Text X  X ypothesis-2 pair). Each entailment was focused on the relationship of a content word pair (e.g. man-tired for Hypothesis-1 and hat-tired for Hypothesis-2), however these content word pairs were not made available during testing. Table 1 provides some text X  X ypothesis examples from the actual test set. Section 2 provides further details on the dataset and Sect. 3 describes the participating systems and their results. All task relevant data is available at http://pete.yuret.com . 1.1 Motivation The motivation behind using targeted textual entailments as a test of linguistic competence is to use non-expert, native speaker judgements and achieve high inter-agreement in artificial tagging tasks. We cite two examples: Dickinson and Meurers ( 2003 ) have found that of the 34,564 constituent strings that appear multiple times in Penn Treebank (Marcus et al. 1994 ), 5,584 (16 %) have multiple conflicting annotations, of which an estimated 3,934 are errors. If indicative of the general level of inconsistency, 16 % is a very high number given that state of the art parsers claim F -scores above 90 % (Charniak and Johnson 2005 ). In the field of word sense disambiguation, Snyder and Palmer ( 2004 ), the organizers of the  X  X  X nglish all-words 65 X 70 % range. This is not surprising given the typical inter-annotator agreement of 70 X 75 % for this task. X  X 
The reason for the low inter-annotator agreement is usually not the annotators X  lack of comprehension of the example sentences. The problem is their less than perfect ability to be consistent with the annotation guidelines, or the difficulty of coming up with consistent guidelines in the first place: The Penn Treebank annotation guidelines exceed 400 pages. WordNet (used in Senseval-3) defines more than 100,000 word senses, some of which are difficult to distinguish even for professional lexicographers. We believe the situation might be improved if our systems can target the natural competence of the annotators in comprehending sentences rather than their imperfect performance on artificial annotation tasks.
One can envision annotation tasks that probe the ability to identify GR, word senses, co-references etc. using basic sentence comprehension and generation skills rather than relying on detailed annotation guidelines or sense inventories. One example that targets the natural competence of annotators in comprehending and generating sentences is the lexical substitution task (McCarthy and Navigli 2007 ) introduced in SemEval-2007. Unlike standard word sense disambiguation tasks where the annotators need to comprehend not only the example sentences but the dictionary definitions of the target words, the lexical substitution task asks them to come up with substitutes for the target word that preserve the meaning of the sentence. Another example is (Erk et al. 2009 ), which introduces a usage similarity task asking the annotators to judge the similarity between different usages of a word without relying on a sense inventory. Targeted textual entailment tasks that focus on one type of linguistic competence, like PETE, may be one possible path in the direction of more such evaluation schemes. To our knowledge, PETE is the first task to use crowd-sourcing with non-expert, native speaker judgements for parser evaluation, which has traditionally had to rely on trained experts because of the complexity of labeling parse trees. 1.2 Other approaches There are currently two main approaches in the field of parser evaluation. The treebank based measures introduced nearly two decades ago (Black et al. 1991 ) compare phrase-structure bracketings or dependency links produced by the parser with the ones in an annotated corpus, or  X  X  X reebank X  X . A second, more recent strand of parser evaluation methods is based on grammatical dependency relations, proposed for ease of use by end users and suitable for parser evaluation. These include the GR of Carroll et al. ( 1999 ), the PARC representation (King et al. 2003 ), and Stanford typed dependencies (SD) (De Marneffe et al. 2006 ; see Bos et al. ( 2008 ) for other proposals).

Compared to the first approach, treebank based evaluation methods, parser evaluation using short textual entailments has the following advantages:
Consistency: Recognizing syntactic entailments is a more natural task for people than treebank annotation. Focusing on a natural human competence makes it practical to collect high quality evaluation data from untrained annotators. The
PETE dataset was annotated by untrained Amazon Mechanical Turk workers at an insignificant cost ( $ 19 : 50) and each annotation is based on the unanimous agreement of at least three workers.

Relevance: PETE automatically focuses attention on semantically relevant phenomena rather than differences in annotation style or linguistic convention.
Whether a phrase is tagged ADJP versus ADVP rarely affects semantic interpreta-tion. Attaching the wrong subject to a verb or the wrong prepositional phrase to a noun, however, changes the meaning of the sentence. Standard treebank based evaluation metrics do not distinguish between semantically relevant and irrelevant errors (Bonnema et al. 1997 ). In PETE semantically relevant differ-ences lead to different entailments, semantically irrelevant differences do not.
Framework independence: Entailment recognition is a formalism independent task. A common evaluation method for parsers that do not use the Penn Treebank formalism is to automatically convert the Penn Treebank to the appropriate formalism and to perform treebank based evaluation (Nivre et al. 2007a ; Hockenmaier and Steedman 2007 ). However, such conversions are noisy due to fundamental cross-formalism differences as well as inconsistencies in the original treebank (Hockenmaier 2003 ;
Cer et al. 2010 ), compounding the already mentioned problems of treebank based evaluation. Clark and Curran ( 2007 ) similarly found an upper bound of 85 % accuracy when translating between two grammatical dependency based formalisms for parser evaluation. In addition, manually designed treebanks do not naturally lend themselves to unsupervised parser evaluation. Unlike treebank based evaluation,
PETE can compare phrase structure parsers, dependency parsers, unsupervised parsers and other approaches on an equal footing.

The second approach, evaluation methods based on grammatical dependency relations, uses a set of binary relations between words in a sentence as the primary unit of representation. These methods share some common motivations: usability by people who are not (computational) linguists and suitability for relation extraction applications. Furthermore, they more closely represent semantics than treebank constituency or dependency measures, and various types of parsers are capable of producing dependencies as an interchange format. Here is an example sentence and its SD representation (De Marneffe and Manning 2008 ):
Bell, based in Los Angeles, makes and distributes electronic, computer and building products . PETE was inspired by such methods, but goes one step further by translating most of these dependencies into natural language entailments: PETE has some advantages over representations based on grammatical relations:
Ease of use: Each of the three proposals of grammatical dependency relations mentioned in this paper (GR, PARC, SD) uses a different set of binary relations.
For example SD defines 55 relations organized in a hierarchy, and it may be non-trivial for a non-linguist to understand the difference between ccomp (clausal complement with internal subject) and xcomp (clausal complement with external subject) or between nsubj (nominal subject) and xsubj (controlling subject). In this study we were able to achieve unanimous agreement among 3 or more untrained annotators for close to half of the entailments generated for PETE without any training, correction or adjudication.

Relevance: Though grammatical dependency schemes represent more semantic information than treebank annotation, they still give equal weight to dependencies of differing semantic importance, for example determiners compared to verbal arguments. They are typically used in the aggregate, so that evaluation is weighted towards more frequent dependency types, not necessarily more important ones. 1
When labeled dependencies are used, differences in annotation style can affect evaluation, for example whether a dependency is labeled amod or advmod .In contrast, PETE is designed to focus on semantically relevant types, and is label-free. 1.3 Challenges There are also significant challenges associated with an evaluation scheme like PETE. It is not always clear how to convert certain relations into grammatical hypothesis sentences without including most of the original sentence in the hypothesis. Including too much of the sentence in the hypothesis would increase the chances of getting the right answer with the wrong parse. Grammatical hypothesis sentences are especially difficult to construct when a (negative) entailment is based on a bad parse of the sentence. Introducing dummy words like  X  X  X omeone X  X  or  X  X  X omething X  X  alleviates part of the problem but does not help in the case of clausal complements. In summary, PETE makes the annotation phase more practical and consistent but shifts the difficulty to the entailment creation phase.

PETE gets closer to an extrinsic evaluation by focusing on semantically relevant, application oriented differences that can be expressed in natural language sentences. This makes the evaluation procedure indirect: a parser developer has to write an extension that can handle entailment questions. However, given the simplicity of the entailments, the complexity of such an extension is comparable to one that extracts GR. In Sect. 7 we present a standard entailment module which can be used with any parser that can output Stanford typed dependencies.

The balance of what is being evaluated is also important. A treebank based evaluation scheme may mix semantically relevant and irrelevant mistakes, but at least it covers every sentence at a uniform level of detail. In this evaluation, we focused on sentences and relations where state of the art parsers make mistakes. We hope this methodology will uncover weaknesses that the next generation of parsers can focus on. 1.4 Summary The remaining sections will go into more detail about these challenges and the solutions we have chosen to implement. Section 2 explains the method followed to create the PETE dataset. Section 3 presents the participating systems, their methods and results. Section 4 presents the best scoring Cambridge system in more detail. Sections 5 and 6 give a detailed error analysis of the C &amp; C parser and the entailment system used in the Cambridge system. Section 7 introduces a standard entailment system for Stanford typed dependencies and evaluates some example systems for several state of the art parsers. Section 8 summarizes our contribution. 2 Dataset To generate the entailments for the PETE task we used the following three steps:  X  Identify syntactic dependencies challenging to state of the art parsers.  X  Construct short entailment sentences that paraphrase those dependencies.  X  Identify the subset of the entailments with high inter-annotator agreement. 2.1 Identifying challenging dependencies To identify syntactic dependencies that are challenging for current state of the art parsers, we used example sentences from the following sources:  X  The  X  X  X nbounded Dependency Corpus X  X  (Rimell et al. 2009 ). An unbounded  X  A list of sentences from the Penn Treebank on which the Charniak parser  X  The Brown section of the Penn Treebank.
We tested a number of parsers (both phrase structure and dependency) on these sentences and identified the differences in their output. We took sentences where at least one of the parsers gave a different answer than the gold parse. (The gold parses were available since all sentences came from existing treebanks.) Some of these differences reflected linguistic convention rather than semantic disagreement (e.g. representation of coordination) and some did not represent meaningful differences that can be expressed with entailments (e.g. labeling a phrase ADJP vs ADVP ). The remaining differences typically reflected genuine semantic disagreements that would affect downstream applications. These were chosen to turn into entailments in the next step. 2.2 Constructing entailments Entailment construction was performed manually by annotators trained to interpret phrase structure and dependency parser outputs. Each hypothesis sentence was based on the relationship between two content words that have a syntactic dependency. The content word pairs were chosen to demonstrate differences between a parser output and the gold parse. All true and false hypotheses generated were added to the dataset. The instructions for the annotators were: 1. Identify a sentence where at least one parser gives a different parse tree than the 2. Identify content words (defined as nouns, verbs, adjectives, and adverbs) in the 3. For each word X  X ead pair identified in the previous step, construct a minimal 4. If the two content words are not sufficient to construct a grammatical sentence
As an example consider the sentence  X  X  X ohn slept in the bed. X  X  Let us consider what entailments can be constructed from this sentence, assuming we have the gold parse tree. The three content words are  X  X  X ohn X  X ,  X  X  X lept X  X , and  X  X  X ed X  X .  X  X  X lept X  X  is the root of the sentence and has no head. The head of  X  X  X ohn X  X  is  X  X  X lept X  X , so we generate the hypothesis (John slept). The syntactic head of  X  X  X ed X  X  is  X  X  X n X  X , a function word, so we include the content word ancestor  X  X  X lept X  X , resulting in the hypothesis (Somebody slept in the bed). Note that we introduce  X  X  X omebody X  X , as in step 4 of the instructions, to make the hypothesis a complete sentence without including more constituents from the text. These are the only two hypothesis sentences that can be generated for this sentence.

In general the number of content words gives an upper bound on the number of entailments (text X  X ypothesis pairs) generated from a sentence. However not every entailment generated in this way made it into the final dataset because we only included entailments related to parser errors, as described in the previous section, and we filtered ones that did not result in unanimous annotator agreement as described in the next section.

The emphasis on having two content words per entailment reflects the relationship between PETE and grammatical dependency schemes. Entailments were constructed manually, although in the future we hope to develop automatic methods. In the first edition of PETE we did not measure inter-annotator agreement on entailment generation; based on the guidelines there should in general be a single well-defined H for each pair of content words, although issues such as embedded clauses and noun modification may need to be more carefully analyzed from an entailment generation perspective in the future to be sure of this.

A list of the content word pairs used to construct the entailments was provided to participants as background information, but the list was not accessible to the entailment systems developed by the participants. Thus entailment decisions could not be facilitated by limiting interrogation of parser output to specific lexical items (although some systems did independently choose to prioritize general categories of words or relations in their decisions). 2.3 Filtering entailments To identify the entailments that are clear to human judgement we used the following procedure:  X  Each entailment was tagged by 5 untrained annotators from the Amazon  X  The results from the annotators whose agreement with the  X  X  X ilver X  X  standard  X  The entailments for which there was unanimous agreement of at least 3
The second step was necessary to eliminate annotators that were answering questions randomly. The  X  X  X ilver X  X  standard truth values were  X  X  X es X  X  for entailments generated from parses agreeing with the gold parses, and  X  X  X o X  X  for entailments generated from incorrect parses (recall that the gold parses were available from existing treebanks). We call these truth values silver rather than gold since they became part of the gold standard only when unanimously agreed to by three annotators. Though not perfect, the 70 % measure provided a simple benchmark to detect annotators answering randomly.

The annotators were allowed to give  X  X  X ot sure X  X  answers which were later grouped with the  X  X  X o X  X  answers during evaluation. The instructions for the annotators were brief and targeted people with no linguistic background:
Computers try to understand long sentences by dividing them into a set of short facts. You will help judge whether the computer extracted the right facts from a given set of 25 English sentences. Each of the following examples consists of a sentence (T), and a short statement (H) derived from this sentence by a computer. Please read both of them carefully and choose  X  X  X es X  X  if the meaning of (H) can be inferred from the meaning of (T). Here is an example: (T) Any lingering suspicion that this was a trick Al Budd had thought up was dispelled . (H) The suspicion was dispelled . Answer: YES (H) The suspicion was a trick . Answer: NO unrelated, unclear, ungrammatical or confusing in any other manner. 2.4 Dataset statistics The final dataset contained 367 entailments which were randomly divided into a 66 sentence development set and a 301 sentence test set. 52 % of the entailments in the test set were positive.
 Approximately half of the final entailments were based on sentences from the Unbounded Dependency Corpus, a third were from the Brown section of the Penn Treebank, and the remainder were from the Charniak sentences. Table 2 gives the breakdown of the original list of entailments and the ones retained after the annotation filtering, according to the text source and the entailment value. Between 1/3 and 1/2 of the original entailments were kept in the final dataset in each category. 3
Table 3 lists the most frequent GR and constructions encountered in the entailments before and after the annotation filter. Note that the resolution of each entailment may rely on multiple grammatical phenomena, thus the numbers add up to more than 100 %.

The two groups of entailments that most often failed the inter-annotator agreement filter involved clausal complements and passivization. Constructing entailments for clausal complements based on two content words as described in Sect. 2.2 was sometimes challenging for the entailment generators and confusing to the annotators. Annotators failed to reach a unanimous agreement on examples like the following:
Text: He found a jar of preserved tomatoes and one of eggs that they had meant to save.
 Hypothesis: Somebody had meant to save one.

Passivization, which was used when constructing entailments from a verb object pair also proved to be confusing at times. Annotators also failed to reach unanimous agreement on some examples like the following:
Text: But he kept Fruit of the Loom Inc., the underwear maker that he still controls and serves as chairman and chief executive.

Hypothesis: The maker is served. 3 Task results Twenty systems from 7 teams participated in the PETE task. Table 4 gives the percentage of correct answers for each system. Twelve systems performed above the  X  X  X lways yes X  X  baseline of 51.83 %.

Most systems started the entailment decision process by extracting syntactic dependencies, GR, or predicates by parsing the text and hypothesis sentences. Several submissions, including the top two scoring systems, used the C&amp;C Parser (Clark and Curran 2007 ) which is based on the Combinatory Categorical Grammar [CCG; Steedman ( 2000 )] formalism. Others used dependency structures produced by MaltParser (Nivre et al. 2007b ), MSTParser (McDonald et al. 2005 ) and Stanford Parser (Klein and Manning 2003 ).

After the parsing step, the decision for the entailment was based on the comparison of relations, predicates, or dependency paths between the text and the hypothesis. Most systems relied on heuristic methods of comparison. A notable exception is the MARS-3 system which used an SVM-based classifier to decide on the entailment using dependency path features.

The top two scoring systems, Cambridge and SCHWA (University of Sydney), were based on the C &amp; C parser and used a similar approach (though Cambridge used GR output in SD format while SCHWA used the native CCG dependency output of the parser). They achieved almost identical task accuracies, but SCHWA was more accurate on  X  X  X es X  X  entailments, while Cambridge was more accurate on  X  X  X o X  X  entailments, resulting in a higher overall accuracy for Cambridge, but a higher F -score on positive entailments for SCHWA (Table 4 ). We attribute this difference to the decision criteria used in the entailment systems, which will be discussed in Sect. 4 , but notably the difference suggests that a dependency-based entailment system can be tuned to favour precision or recall.

The following sections describe the Cambridge system in more detail and present detailed error analyses for the parser and the entailment system. 4 The Cambridge system The best X  X coring Cambridge system used the C &amp; C parser (Clark and Curran 2007 ), which can produce GR output in SD format (see Sect. 1 ) using custom tools available with the parser. 4
The entailment system was very simple, and based on the assumption that H is a simplified version of T, which is true for this task though not necessarily for RTE in general. Let grs(S) be the GRs produced by the parser for a sentence S. The basic intuition is that if grs(H) grs(T), then in principle H should be considered an entailment of T. In practice, certain refinements of this basic intuition were required to account for non-matching GRs resulting from grammatical transformations used in entailment construction, or noise in the parse which could be safely ignored.
Three situations were identified in which GRs in H would not exactly match those in T. First, syntactic transformations used in entailment construction could change head-dependent relations. By far the most frequently used transformation in the PETE dataset was passivization.

Second, the introduction of dummy words and transformations during entailment construction meant that H could contain tokens not present in T. This included pronouns such as  X  X  X omebody X  X  and  X  X  X omething X  X , auxiliary verbs introduced by passivization, and expletive subjects. In addition, determiners were sometimes introduced or changed, e.g.  X  X  X rices X  X  to  X  X  X he prices X  X .

Third, the parses of T and H might be inconsistent in a way incidental to the target entailment. Consider the sentence pair T: I reached into that funny little pocket that is high up on my dress . ) H: The pocket is high up on something . The intended focus of the evaluation is the relation between  X  X  X ocket X  X  and  X  X  X igh X  X . As long as the parser analyzes  X  X  X ocket X  X  as the subject of  X  X  X igh X  X , we want to avoid penalizing it for, say, attaching the PP beginning with  X  X  X p on X  X  differently in T and H.

To address these issues the system used a small set of heuristics. First, it ignored any GR in grs(H) containing a token not in T. This addressed the pronouns, passive auxiliaries, expletive subjects, and determiners. Second, it equated passive subjects with direct objects. Similar heuristics could be defined to accommodate other transformations, but only this one was implemented, based on examination of the development set.

Third, when checking whether grs(H) grs(T), only the core relations subject and object were considered. The intention was that incidental differences between the parses of T and H would not be counted as errors. These GR types were chosen based on examination of the entailments in the development set, but the system could easily be reconfigured to focus on other relation types, e.g. PP relations for a PP-attachment task.
Finally, the system required grs(H) \ grs(T) to be non-empty (no vacuous positives), but did not restrict this criterion to subjects and objects.
 The system used a PTB tokenizer 5 for consistency with the parser X  X  training data. The morpha lemmatizer (Minnen et al. 2000 ), which is built into the C &amp; C tools, was used to match tokens across T and H, and all tokens were converted to lowercase. If the parser failed to find a spanning analysis for either T or H, the entailment decision was  X  X  X o X  X . The full pipeline is shown in Fig. 1 .

Comparing the Cambridge system with the SCHWA system, Cambridge was more accurate on  X  X  X o X  X  entailments and SCHWA on  X  X  X es X  X  entailments. We believe this is because both systems required at least one matching relation between T and H for a  X  X  X es X  X  answer, but Cambridge additionally answered  X  X  X o X  X  if any core relation (subject or object) was present for H but not for T. Thus Cambridge permitted fewer false positives than SCHWA. 5 Error analysis Table 4 includes the results for the Cambridge system on the test set. On the development set the system achieved an overall accuracy of 66.7 %. On positive entailments, precision was 0.7857, recall was 0.5789, and F -score was 0.6666.
Table 5 lists the frequency of various GR in the development and test set instances where the Cambridge system made mistakes. A comparison with Table 3 shows direct objects and reduced relative clauses to be frequent causes of error.
Table 6 further breaks down the results on the development set to show how different types of parser and entailment system errors contributed to incorrect answers. In the majority of cases the parser and entailment system worked together to find the correct answer as expected. For example, for T: Trading in AMR shares was suspended shortly after 3 p.m. EDT Friday and didn X  X  resume . ) H: Trading didn X  X  resume ., the parser produced three GRs for H (tokens are shown lemmatized and lowercase): (nsubj resume trading) , (neg do n X  X ) , and (aux resume do) . All of these were also in grs(T), and the correct  X  X  X es X  X  decision was made. For T: Moreland sat brooding for a full minute, during which I made each of us a new drink . ) H: Minute is made ., the parser produced two GRs for H. One, (auxpass make be) , was ignored because the passive auxiliary  X  X  X e X  X  is not in T. The second, passive subject GR (nsubjpass make minute) was equated with a direct object (dobj make minute) . This GR was not in grs(T), so the correct  X  X  X o X  X  decision was made.

In some cases a correct  X  X  X es X  X  answer was reached via arguably insufficient positive evidence. For T: He would wake up in the middle of the night and fret about it . ) H: He would wake up ., the parser produces incorrect analyses for the VP  X  X  X ould wake up X  X  for both T and H. However, these GRs are ignored since they are match (nsubj would he) . This is not entirely a lucky guess, since the entailment system has correctly ignored the faulty analyses of  X  X  X ould wake up X  X  and focused on the role of  X  X  X e X  X  as the subject of the sentence. However, especially since the target was the relation between the subject  X  X  X e X  X  and the lexical verb  X  X  X ake X  X , more positive evidence would be desirable. Of the 22 correct  X  X  X es X  X  decisions, only two were truly lucky guesses in that the single match was a determiner; all others had at least one core match.

Table 6 shows the breakdown of errors. The largest category was false negatives due to unbounded dependencies not recovered by the parser, for example T: It required an energy he no longer possessed to be satirical about his father . ) H: Somebody no longer possessed the energy . Here the parser fails to recover the direct object relation between  X  X  X ossess X  X  and  X  X  X nergy X  X  in T. It is known that parsers have difficulty with unbounded dependencies (Rimell et al. 2009 ), so this result is not surprising. Among the unbounded dependencies, one gold standard entailment was particularly difficult because it involved two layers of extraction; this was T: Index-arbitrage trading is  X  X  X omething we want to watch closely, X  X  an official at London X  X  Stock Exchange said . ) H: We want to watch index-arbitrage trading . Here, recovering the entailment requires not only correctly parsing the relative clause headed by  X  X  X omething X  X , but also resolving the reference of  X  X  X omething X  X  as  X  X  X rading X  X , a compound task that few modern syntactic parsers attempt. Nevertheless, this is a legitimate entailment, constructed according to the guidelines in Sect. 2.2 .
The next category was other parser errors. This is a miscellaneous category including e.g. errors on coordination, parenthetical elements, identifying the head of a clausal subject, and one error due to the POS tagger. For example, for T: Then at least he would have a place to hang his tools and something to work on . ) H: He would have something to work on ., the parser incorrectly coordinated  X  X  X ools X  X  and  X  X  X omething X  X  for T, making  X  X  X omething X  X  appear to be an object of  X  X  X ang X  X . As a result (dobj have something) was in grs(H) but not grs(T), yielding an incorrect  X  X  X o X  X .

Four errors were due to the entailment system rather than the parser; these will be discussed in Sect. 6 . 6 Entailment system evaluation The utility of PETE as a parser evaluation tool depends on the availability of appropriate entailment systems, since the entailment system acts as an intermediary between the parser and the PETE dataset. We believe the appropriate role of an entailment system is to be fully transparent with respect to the parser output, that is, to faithfully reflect whether the parser has made attachment decision(s) for T which entail a  X  X  X es X  X  answer for H, neither introducing nor correcting any errors. Recalling the example T: The man with the hat was tired , if the parser analyzes  X  X  X an X  X  as the subject of  X  X  X as tired X  X , the entailment system should pass along a  X  X  X es X  X  answer to H-1: The man was tired , and a  X  X  X o X  X  answer to H-2: The hat was tired . If the entailment system is transparent in this way, then a correct answer on H indicates a correct parse (with regard to the content of H) and an incorrect answer on H indicates a parser error.
It is easy to imagine a variety of non-transparent entailment systems. For example, an entailment system that always answers  X  X  X es X  X  regardless of parser output will yield an accuracy score exactly equal to the  X  X  X lways yes X  X  baseline, no matter how well or poorly the underlying parser has performed. On the other hand, an entailment system that is allowed to override parser output based on background knowledge or reasoning heuristics would also be non-transparent because it could improve on the parser X  X  decisions. Note we do not say there is no role in NLP for such an entailment system, only that it would not transparently convey parser accuracy on the PETE dataset. Moreover, there may be room for an intermediate, semi-transparent variety of entailment system that cannot override attachments made by the parser, but can add information.

We can say the PETE task is a valid parser evaluation tool if it is possible to construct an appropriate entailment system for any given parser. We do not attempt to evaluate whether the entailment systems of all participating systems were appropriate, but as a case study, we consider whether the Cambridge entailment system was an appropriate tool for evaluating the C &amp; C parser on the PETE dataset. A more generalized entailment system is described in Sect. 7 .
 We use two oracle experiments to isolate and evaluate the performance of the Cambridge entailment system. The first oracle experiment uses gold-standard GRs rather than automatic parser output as input to the entailment system. Assuming the Cambridge GR-based approach is valid, then given gold-standard GRs for T and H, we expect an appropriate entailment system to result in 100 % accuracy on the task evaluation (because all parses are correct, and the entailment system should faithfully pass along the correct analyses). To perform this experiment we manually annotated all T and H sentences in the development set with gold-standard GRs. Using the Cambridge entailment system with the gold GRs resulted in a task accuracy score of 90.9 %, which can therefore also be considered the entailment system accuracy score in this experiment.

Of the six errors made by the system, three (two FN and one FP) were due to transformations between T and H which changed the GR label or head. For example, consider T: Occasionally, the children find steamed, whole-wheat grains for cereal which they call  X  X  X uckshot X  X  . ) H: Grains are steamed . In T,  X  X  X teamed X  X  is a prenominal adjective with  X  X  X rains X  X  as its head; while in H, it is a passive with  X  X  X rains X  X  as its subject. The entailment system did not account for this transformation. In principle it could account for any transformation which can be expressed as a rule on GRs, in the same way it accounts for passivization. In practice, the only way to guarantee that an entailment system can account for all transformations between T and H in the dataset is for the complete list of possible transformations to be documented in the entailment generation guidelines and made available to developers.

Two errors (both FP) occurred when GRs involving a non-core relation or a pronoun introduced in H, both of which the system ignored, were crucial for the correct entailment decision. Since the development decision to ignore non-core relations and pronouns introduced in H was made for overall accuracy, errors are inevitable in these circumstances, but they are a small percentage of sentences in the dataset.
 The final error was on the difficult unbounded dependency discussed in Sect. 5 , T: Index-arbitrage trading is  X  X  X omething we want to watch closely, X  X  an official at London X  X  Stock Exchange said . ) H: We want to watch index-arbitrage trading . The gold GRs represent the unbounded dependency correctly, but nevertheless do not provide the necessary information to resolve the reference of  X  X  X omething X  X  as  X  X  X rading X  X .

The second experiment compared the Cambridge entailment system with an oracle entailment system, i.e. manual judgements on whether T entails H given the parser X  X  analysis. We used the GRs automatically generated by C &amp; C for the development set, and manually decided for each sentence whether T entailed H based only on the automatic parser analysis. We then compared this manual analysis with the automatic entailment system decisions, to determine how transparent the entailment system was.

Based on the manual analysis, we found the Cambridge entailment system made six errors on the development set, when using automatically generated C &amp; C output. Two errors were in the parser X  X  favor, i.e. the parser analysis was incorrect, but the entailment system  X  X  X orrected X  X  the error; and four were to its detriment, i.e. the parser analysis was correct but the entailment decision was incorrect. Accuracy of the entailment system was 90.9 % on this measure, consistent with the results of the previous oracle experiment (though the erroneous sentences were not identical).
Among the two errors in the parser X  X  favor, one involved T: They wanted to see what his back felt like X  X he General X  X . ) H: Somebody wanted to see what his back felt like . The parser analyzed the phrase  X  X  X hat his back felt like X  X  incorrectly, but made the same error for both T and H, so that the GRs matched. Only by manual analysis could the error be found. The other error was on a sentence where the attachment decision was incorrect, but there was a single GR match on a determiner.
The four entailment system errors to the detriment of the parser correspond to the  X  X  X ntailment system X  X  row in Table 6 . Three of these errors also occurred in the first oracle experiment and have been discussed above. The fourth resulted from a POS change between T and H for T: There was the revolution in Tibet which we pretended did not exist. ) H: The pretended did not exist . The crucial GR for finding a  X  X  X o X  X  answer was (nsubj exist pretended) in grs(H), but the entailment system ignored it because the lemmatizer did not give  X  X  X retend X  X  as the lemma for  X  X  X retended X  X  as a noun. This type of error might be prevented by answering  X  X  X o X  X  if the POS of any word changes between T and H, although the implementation would be non-trivial since word indices may also change. 6
Note that the 90.9 % accuracy figure for the entailment system based on the manual analysis in the second oracle experiment does not reflect parser accuracy: when the parser made an error on a crucial dependency, leading to an incorrect entailment decision, we judged the entailment system to be correct, since it faithfully passed along the parser X  X  error for the purpose of parser evaluation. If the &amp; C parser had been coupled with an oracle (i.e. fully manual) entailment system, it would have achieved 69.7 % accuracy on the development set, compared to the 66.7 % it achieved with the automatic entailment system.

The high accuracy levels for the simple Cambridge entailment system, which was over 90 % accurate at passing along the performance of C &amp; C on the PETE dataset, are very promising. Some additional accuracy could be recovered in the future if parser and entailment system developers have access to improved documentation of the linguistic transformations permitted in entailment generation. This is a positive result for the validity of the PETE task. 7 A generalized entailment system In order to facilitate further research on this task, we implemented a more modular and generalized entailment system based on the Cambridge system. By applying similar heuristics and search methods, we are able to replicate the top score on the task, and are also able to compare different parsing paradigms using a single entailment system, making for a more level playing field.

This system takes Stanford dependencies as input and thus integrates with several publicly available parsers which are capable of producing Stanford typed dependencies. The parsers used were the Berkeley Parser (Petrov and Klein 2007 ), Charniak Parser (Charniak and Johnson 2005 ), Collins Parser (Collins 2003 ), &amp; C Parser (Clark and Curran 2007 ), Malt Parser (Nivre et al. 2007b ), MSTParser (McDonald et al. 2005 ) and Stanford Parser (Klein and Manning 2003 ). Each parser was trained on sections 02-21 of the WSJ section of Penn Treebank. MaltParser and MSTParser were trained on the Stanford dependencies format of Penn Treebank as described in (Cer et al. 2010 ), and C &amp; C was trained on CCGbank (Hockenmaier 2003 ).
 Stanford typed dependencies come in several varieties (De Marneffe and Manning 2008 ). The Cambridge system used the option of tree-breaking depen-dency types ref , xsubj , and pobj and propagation of conjunct dependencies, but no collapsed dependencies. The generalized entailment system used Stanford depen-dencies with fully collapsed dependencies (including tree-breaking dependencies) and propagation of conjunct dependencies. Using the fully collapsed dependencies was intended to allow improved matching of various relations, especially prepositions, between T and H.

The outputs of all parsers except C &amp; C were converted to the Stanford collapsed dependency representation with propagation of conjunct dependencies using the Stanford Parser. Because the C &amp; C parser does not produce a representation suitable for conversion with the Stanford tools, we converted the C &amp; C output to Stanford dependencies using custom tools, as in Sect. 4 .

To decide on entailments both the test and hypothesis sentences were parsed. All the words in T and H were lemmatized and lowercased after parsing. We apply the same heuristics as in the Cambridge system for active-passive conversion and dummy word matching. We then consider the core dependency types nsubj , dobj , and prep-when comparing T and H (the use of the collapsed dependency representation making it possible to consider prepositions as a core relation). If there is at least one core dependency in H, and all core dependencies in H are also found decision is  X  X  X o X  X . The full pipeline is shown in Fig. 2 .

Table 7 lists the results achieved. There are significant differences in the entailment accuracies of systems that have comparable unlabeled attachment scores (UAS), with UAS derived from parser output in the CoNLL representation. One potential reason for this difference is the composition of the PETE dataset which emphasizes challenging syntactic constructions that some parsers may be better at. The difference between UAS and PETE scores reflects the indifference of treebank based measures like UAS to the semantic significance of various dependencies and their impact on potential applications.

Note that different conversion steps en route to Stanford dependencies may mean that results are not exactly comparable for all parsers. Nevertheless, the PETE score provides a notably different perspective on the parser results. We note that the two dependency parsers, MaltParser and MSTParser, show lower accuracies than the constituent parsers; this is consistent with the results in (Cer et al. 2010 ). No UAS is available for C &amp; C , which does not produce CoNLL style output. 8 Contributions We introduced PETE, a new method for parser evaluation using textual entailments. By basing the entailments on dependencies that current state of the art parsers make mistakes on, we hoped to create a dataset that would focus attention on the long tail of parsing problems that do not get sufficient attention using common evaluation metrics. By further restricting ourselves to differences that can be expressed by natural language entailments, we hoped to focus on semantically relevant decisions rather than accidents of convention which get mixed up in common evaluation metrics. We chose to rely on untrained annotators on a natural inference task rather than trained annotators on an artificial tagging task because we believe (1) many subfields of computational linguistics are struggling to make progress because of the noise in artificially tagged data, and (2) systems should try to model the natural competence of annotators in comprehending sentences rather than their imperfect performance on artificial tagging tasks.

Multiple systems, including the examples described in Sect. 7 achieved good results on the PETE task using state-of-the-art parsers and simple entailment systems. The analysis of the Cambridge entailment system showed it to have accuracy of approximately 90 % as a tool for evaluating the C &amp; C parser, or potentially any parser producing GRs, on the PETE development data. This result is perhaps even more important than the task scores since it suggests that PETE is worth pursuing as a parser evaluation approach. Our hope is datasets like PETE will be used not only for evaluation but also for training and fine-tuning of systems in the future. Further work is needed to automate the entailment generation process and to balance the composition of syntactic phenomena covered in a PETE dataset.
 References
