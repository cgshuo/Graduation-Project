 RUOYUN HUANG, YIXIN CHEN, YOU XU, WEIXIONG ZHANG , Washington University in An essential quality of a problem formalism is its modeling capability. It has been a continuing endeavor in extending the modeling capability of various planning for-mulations. An important development beyond classical planning is temporal planning, which deals with durative actions occurring over extended intervals of time [Penberthy and Weld 1994]. Particularly, both preconditions and effects of durative actions can be temporally quantified. Representative temporal planners include ZENO [Penberthy and Weld 1994], TGP [Smith 1999], TLPlan [Bacchus and Ady 2001], TP4 [Haslum and Geffner 2001], LPG [Gerevini and Serina 2002], TALPlanner [Kvarnstr  X  om and Magnusson 2003], VHPOP [Younes and Simmons 2003], SAPA [Do and Kambham-pati 2003], TM-LPSAT [Shin and Davis 2004], SGPlan [Wah and Chen 2006], CPT [Vidal and Geffner 2006], LPG-td [Gerevini et al. 2008], TFD [Eyerich et al. 2009], Crikey [Coles et al. 2009], Crikey3 [Coles et al. 2008], POPF [Coles et al. 2010], and a concurrency version of LPG (LPG-c) [Gerevini et al. 2010]. These planners have been successfully applied to many planning problems.

Despite their success, these planners are restrained by two limitations. First, some existing temporal planners, such as ZENO, TGP, TLPlan, TP4, LPG, LPGP, TALPlan, VHPOP, SAPA, SGPlan, CPT, and LPG-td, are unable to deal with temporally expres-sive problems. Temporal action concurrency was first introduced into the planning domain definition language in PDDL2.1 [Fox and Long 2003]. Cushing et al. [2007b] first presented the notion of temporal expressiveness. A planning problem is tempo-rally expressive if all of its solutions require action concurrency, which indicates that one action occurs within the time interval of another action. Second, most existing temporal planners either attempt to minimize the total duration of the solution plan (i.e., makespan), or do not consider any quality metric at all. However, for many applications, it is desirable to optimize not only the makespan, but also the total action costs [Do and Kambhampati 2003], which can represent many quantities, such as the cost of resources used, the total money spent, or the total energy consumed. Action costs was introduced as a new criterion in the IPC-6 planning competition [IPC 2008].
Both required concurrency and action costs are important features in real-world planning. In this article, we propose a general planning paradigm, called cost-sensitive temporally expressive (CSTE) planning. A CSTE planning problem is a temporally expressive problem in which actions have associated costs. Although CSTE planning problems are complex and difficult to solve, they are important and ubiquitous in many applications. Example CSTE domains include the following. (1) Peer-to-Peer network communication. In Peer-to-Peer network communication, one (2) Web service composition. Web service composition (WSC) is the problem of inte-(3) Autonomous systems. Planning for autonomous systems, including robotics, rovers, (4) Real-time manufacturing system. In real time manufacturing systems [Do et al.
Currently, few existing automated planners can handle CSTE problems. There are only a few temporally expressive planners, such as TM-LPSAT [Shin and Davis 2004], Crikey [Coles et al. 2008], Crikey3 [Coles et al. 2009], POPF [Coles et al. 2010], LPG-c [Gerevini et al. 2010], and TFD [Eyerich et al. 2009]. But most of them only optimize temporal makespan.

In this article, we introduce an efficient CSTE planning framework based on a Sat-isfiability (SAT) transformation, as shown in Figure 1. Central to this approach is a transformation for turning a CSTE instance into an optimization problem with SAT-based constraints (which is called a MinCost SAT formulation). The translation is based on the planning as SAT framework [Kautz and Selman 1992]. We first pro-pose a basic transformation scheme based on our previous work [Huang et al. 2009]. Then, we leverage and enhance the transformation scheme based on a relaxed parallel planning semantics. Our enhanced transformation can handle more temporal features than the basic translation scheme. Moreover, it can improve the search efficiency and make our solver find solutions with shorter makespan than the basic scheme. To solve the encoded MinCost SAT instance, a SAT problem with an objective of minimizing the total cost of literals assigned to be true [Li 2004], we develop BB-CDCL, a branch-and-bound algorithm based on the conflict driven clause learning (CDCL) procedure [Zhang et al. 2001; Mitchell 2005], to directly solve MinCost SAT problems. We also propose an effective heuristic-cost-based variable branching scheme to further improve search efficiency.

Figure 1 shows the architecture of our CSTE planner. Starting from a small makespan N , we repeatedly increase N and solve the corresponding MinCost SAT instance until a solution is found. Such a scheme guarantees to find the minimum makespan. Furthermore, since our BB-CDCL algorithm can minimize the objective function, we can also minimize the total action costs at the optimal makespan. Thus, we find a Pareto optimum for this multiobjective optimization problem. Our results show good performance of this approach. In particular, our results show that our SAT-based approach is currently a good choice for CSTE planning, especially for problems whose solutions require a high level of action concurrency. The solution strategy that we proposed solves the problem efficiently, comparing favorably against other existing temporally expressive planners.

The rest of this article is organized as follows. In Section 2, we define cost sensitive temporally expressive (CSTE) planning. In Section 3, we present the SAT-based CSTE planning framework, including the basic translation scheme and the enhanced scheme. In Section 4, we present our BB-CDCL algorithm enhanced with a variable branching mechanism for solving encoded MinCost SAT problems. We present our experimental results in a variety of CSTE planning domains in Section 5. We discuss related work in Section 6 and conclude in Section 7. Our method applies to temporal planning problems defined in PDDL2.1 and above [Fox and Long 2003]. In these problems, actions have starting and ending preconditions, overall preconditions, starting and ending effects, all of which are conjuncts of propo-sitions. Each action has a duration that is defined by a positive integer and a cost that is specified in a positive real number.

We now formally define cost sensitive temporally expressive (CSTE) planning. A fact f is an atomic proposition that can be either true or false; we use f t to represent the fact f at time t .A state S is a set of fact propositions. We use S t to represent the state ( f
Definition 2.1 ( Cost-Sensitive Durative Action ). A cost-sensitive durative action o is defined by a tuple where  X  and  X  are the duration and cost of o , respectively;  X  , X  are precondition fact sets that must be true at the start and at the end of o , respectively;  X   X  is the overall fact sets that must be true over lifetime, respectively; and  X  , X  are the effect fact sets at the start and the end of o , respectively.

In this article, we assume that action durations are integers where  X  ( o ) &gt; 0 and costs are real number where  X  ( o )  X  0. Given a durative action o ,weuse  X  to represent  X  ( o ). The same abbreviation applies to  X   X  , X  , X  ,and  X  . In PDDL2.1, the annotations of temporal precondition and overall facts are: 1)  X  :  X (at start f) X , 2)  X  :  X (at end f) X , and 3)  X   X  :  X (over all f) X . The annotations of effects are: 1)  X  :  X (at start f) X  and 2)  X  : X (at end f) X .
 S Note that f may represent positive precondition or negative precondition there. and 4) for each delete-effect  X  f  X   X  , f t +  X  ( o ) /  X  S t +  X  ( o ) .
In our previous work [Huang et al. 2009], we assume a discrete time horizon (the time t takes integer values) which means always equals to 1.

We now show an example of the PDDL definition for a serve action from the P2P domain. We will discuss the details of the P2P domain in Section 5.1. (:durative-action serve :parameters ( ?c -computer ?f -file ) :duration (= ?duration (file-size ?f) ) :condition( and :effect(and planning problem is defined as a tuple ( I , F , O , G ), where I is the initial state, F is a set of facts, O is a set of cost-sensitive durative actions, and G is a set of goal facts. indicates the actions executed at time t . P is a solution plan if there exists a state time t ,and S t + 1 , S t +  X  ( o ) satisfy o t  X  X  effects; c) for all f  X  G , f n  X  S n .
Given a plan P = ( p 0 , p 1 ,..., p n  X  1 ), we first optimize the makespan , defined as the duration of the plan: Then at the given optimized makespan, we minimize the total action costs , defined as the total costs of the selected actions (multiple appearances are counted multiple times):
The formulation of CST planning is a subset of PDDL2.1. Specifically, the PDDL features supported by our temporal planner include predicate representations, typed representations, untyped representations, grounded representations, and negative pre-conditions. The PDDL features which are not supported include object fluent repre-sentations, schematic representations, ADL conditions, conditional effects, universal effects, derived predicates, numeric state variables, and timed initial literals.
The semantics of temporal planning that we consider is as expressive as what is de-fined in PDDL2.1, except for the discrete time setting. Unlike many previous PDDL2.1 planners that are not temporally expressive, our approach is capable of handling tem-poral expressiveness.
 fine that o temporally depends on o when one of the following conditions holds: (1)  X  f  X   X  ( o ), such that f  X   X  ( o )and  X  f  X   X  ( o ); (2)  X  X  f  X   X  ( o ), such that  X  f  X   X  ( o )and f  X   X  ( o ).

A temporal dependency among actions may require actions to be executed concurrently.

Definition 2.5 ( Required Concurrency ). A CST planning problem has required concurrency if and only if it has at least one solution plan and every solution plan of has concurrently executed actions.

Two factors can lead to concurrencies in a temporally expressive problem. One is the required concurrent interaction (i.e., concurrent execution) among actions, and the other is enforced deadlines [Coles et al. 2008].

Definition 2.6 ( Cost-Sensitive Temporally Expressive (CSTE) Planning ). A CSTE planning problem is a CST planning problem with required concurrency. We now formulate CSTE planning as an optimization problem with SAT constraints, which is known as MinCost SAT. Our overall planning algorithm is referred to as a SAT-based CSTE Planning (SCP) framework, shown in Algorithm 1. Our planning frame-work follows the bounded SAT solving strategy, originally proposed in SATPlan [Kautz and Selman 1992, 1996] and Graphplan [Blum and Furst 1997]. We start from a lower bound of the makespan (N = 1), construct a planning graph and encode the CSTE problem as a MinCost SAT instance, either prove it unsatisfiable or find a solution with the optimal makespan. At the optimal makespan, we further solve it with respect to the MinCost SAT objective until the minimized costs solution is found or the search times out.

In this section, we first present the MinCost SAT formulation, then we introduce a basic encoding method that transforms a CSTE problem to a MinCost SAT. This encoding method was first presented in our previous work [Huang et al. 2009]. Further, we discuss a limitation of the basic encoding and then propose an enhanced encoding method based on a new action transformation, which can fully address the limitation. We first present the SAT formulations. A SAT problem is defined as = ( V , C ) , where V is a set of Boolean variables and C is a set of clauses. A variable assignment  X  assigns each variable x in V to true or false. Given a variable assignment  X  and a assignment, or 0 otherwise. Likewise, given a variable assignment  X  and clause c  X  C , we let v  X  ( c )tobe1when c is satisfied by the variable assignment, or 0 otherwise. Given a SAT problem = ( V , C ), a valid solution is a variable assignment  X  , such that for each c  X  C , v  X  ( c ) = 1.

We use the notation of assignment function  X  : V  X  C  X  X  0 , 1 } in the following definitions. First, we define MinCost SAT problems [Li 2004].
 ( V , C , X  ), where V is a set of Boolean variables, C is a set of clauses, and  X  is a function  X  : V  X  N . A solution to is a variable assignment  X  that minimizes the objective function: Another extended SAT problem that we consider is the weighted partial Max-SAT Problem (WPMax-SAT).
 ( V respectively, and w is the weight function of soft clauses defined by w : C s  X  N .
Asolutionto a is a variable assignment  X  that maximizes the function:
A WPMax-SAT problem a amounts to finding a variable assignment, such that all hard clauses are satisfied, and the total weight of satisfied soft clauses is maximized. A MinCost SAT problem can be easily converted to a WPMax-SAT problem (See the converting details in Appendix A). 3.2.1. Transformation of Actions. In the first step of our SCP framework (Algorithm 1), we use the TGP style semantics to compile temporal actions into STRIPS actions [Smith 1999]. Specifically, each cost-sensitive durative action o is converted to two simple actions and one propositional fact, written as ( o , o , f o ). The transformation is based on the assumption = 1. We use the symbol a to denote the simple action which indicates the starting ( a = o ) or ending events ( a = o )of o . The fact f o ,whenistrue, Each simple action a is defined as a tuple (  X , pre , eff ) where  X  is the cost of a , pre is the precondition fact set, and eff is the effect fact set. Specifically, given a durative action o = (  X , X , X  , X   X  , X  , X  , X  ), the transformed actions are o = (  X ,  X  , X  )and o = (0 , X   X   X   X  , X  ). In our basic encoding scheme, this transformation would only take effects on those actions with  X &gt; 1. Otherwise, the durative action with  X  = 1is viewed as a simple action and does not need transformation in our basic encoding.
In summary, we transform a CSTE planning problem = ( I , F , O , G )intoaclassical planning problem s = ( I , F s , O s , G ), where F s = F  X  F o and O s ={ o , o | o  X  O } X  { a which uses a planning-graph preprocessing to handle the frame problem. A no-op action for f is defined as a f = (0 , { f } , { f } ).

The idea of transforming durative actions to simple actions was first proposed in Long and Fox [2003]. An advantage of this scheme is that some techniques from classical planning can be applied to the transformed problem, such as mutual exclusion detec-tion. Given the above representation, it is necessary to encode fact and action mutual exclusion (mutex) constraints to ensure the correctness of solutions. An algorithm that detects mutexes between durative actions in temporal planning was proposed in [Smith 1999]. We use a similar definition of mutexes based on planning graphs for all facts f  X  F s and transformed actions a  X  O s . A planning graph is a directed, leveled graph with two kinds of nodes (fact and action nodes ) and three kinds of edges (precondition-edges, add-edges, and delete-edges) [Blum and Furst 1997].

In a planning graph for any given makespan N , two facts f and h at time t are marked to be exclusive of each other if and only if: (1) [Static mutex] f = X  h ,or Two simple actions a and b at a given makespan t are marked to be exclusive of each other if and only if: (1) [Competing needs]  X  f , f  X  pre(a) and  X  h , h  X  pre(b) that f and g are mutex at the (2) [Effect interference]  X  f , f  X  eff(a)  X  X  f  X  eff(b) , (4) [Concurrency interference]  X  f , f  X   X   X  ( o )  X  X  f  X  eff(b) where a is o , o , or no-op
This mutex definition is similar to the classical mutex definition in Graphplan [Blum and Furst 1997] except for the  X  X oncurrency interference X  mutex. The  X  X oncurrency in-terference X  mutex guarantees that actions that are concurrently executed with durative action o will not delete any overall preconditions of o . In the basic encoding, we allow two actions to be parallelly executed (not mutex) at the same makespan only if they can be executed in any order. 3.2.2. Transform to MinCost SAT. For a CSTE problem instance = ( I , F , O , G )and the corresponding transformation s = ( I , F s , O s , G ), given a makespan N , we define a MinCost SAT problem with the following variable set V and clause set C . The variable set V includes two types of variables: (1) action variables x a , t ,0  X  t &lt; N , a  X  O s . (2) fact variables x f , t ,0  X  t  X  N , f  X  F s .
 Each variable in V represents the assignment of an action or a fact at time t .
The clause set C has the following clauses. (1) Initial state (for all f  X  I ): x f , 0 . All initial state facts must be true at time 0. (2) Goal state (for all g  X  G ): x g , N . All goal state facts must be true at time N . (3) Preconditions of simple actions (for all a  X  O s ,0  X  t &lt; N ): for each precondition (4) Add-effects of simple actions (for all f  X  F s , 0 &lt; t  X  N ): (5) Durative actions (for all o , t , o  X  O ,0  X  t &lt; t +  X &lt; N ): (6) Action mutexes (0  X  t &lt; N ): for each pair of mutex actions ( a 1 , a 2 ): (7) Fact mutexes (0  X  t  X  N ): for each pair of mutex facts ( f 1 , f 2 ):
Since the transformed problem is a classical planning problem with additional tem-poral constraints, the encoding introduced above shares many similarities to the well known planning as SAT encoding [Kautz and Selman 1992; Kautz 2004] except for clauses in class (5). For a given valid assignment  X  , the corresponding plan sequence P = ( p  X  X lauses in class (1) guarantee that S 0 = I .  X  X or each action o t  X  p t , clauses in class (3) of actions a = o , o and clauses (5) of satisfy o t  X  X  add-effects. Similar to the SATPlan encoding for classical planning [Kautz 2004], our mutex clauses guarantee the consistency of delete effects. Clauses in effects.  X  X lauses (2) ensure that for all f  X  G , f N  X  S N .
 According to Definition 2.3, P is a solution plan of the CSTE problem. Therefore, any plan derived from a satisfying assignment of is a solution plan for CSTE problem .
The encoding above produces a standard SAT problem. The cost of each variable x  X  V in a MinCost SAT problem c = ( V , C , X  ) is defined as: In other words, for each action o whose cost is  X  ( o ), we make the corresponding variable x o , t to have a cost
Our approach is not only effective for handling temporally expressive semantics, but also capable of accommodating some other attributes of parallelism in temporal planning. According to the analysis in Rintanen [2007], whether a temporal planning problem can be compiled into a classical planning problem in polynomial time is deter-mined by whether self-overlapping is allowed. Our approach supports self overlapping. Suppose that in a plan, an action o (with duration  X  ) has two instances, starting at and x o , t to indicate the different starting times of the two instances. Those f o facts, along with all related conditions, will be enforced to be true from t + 1to t +  X   X  1 and t + 1to t +  X   X  1, even if they have overlapping durations. Thus, these invariant conditions of the two action instances do not exclude each other X  X  existence. 3.3.1. Limitations of the Basic Encoding. The key limitation of the basic encoding is the assumption that = 1. Our previous definition of transformed actions is actually based on classical planning as SAT framework [Blum and Furst 1997]. For classical planning, the execution of an action at time t will affect the state at time t + 1. For example, given a simple action a = (1 , { f } ,  X  ), if a is true at time t ,then f is true at t + 1. This definition of transformed actions based on that assumption = 1 can largely simplify the transformation progress since it can directly adopt existing techniques of planning as SAT framework. However, this definition does not exactly satisfy the semantics of durative actions of temporal planning. As we discussed in Section 2, a durative action o  X  X  execution at time t will affect the state S t + (  X  0). This continuous starting effect definition allows that two actions o and o are executed at the same time layer while in a continuous order ( o t , o t + ).

Although the assumption = 1 makes temporal planning problems easily con-vertible to simple planning problems, it may cause the basic encoding to fail on certain instances. For the example of Figure 2(a), there are two actions where o effect f ,if o is true at time t , f should be true at t + . Then, o can be executed at time t + . Given an initial state  X  and a goal state { g } , there should be a solution ( o However, our basic encoding cannot transform the action o with  X  = 1toasimple action since there are inconsistent facts f and  X  f in the starting and ending effects. Thus, the basic encoding cannot handle this problem. In the example of Figure 2(b), basic encoding, since we assume = 1, the ending precondition g cannot be satisfied at t + 1 which means that o is always false. Thus, there is no solution in the basic encoding SAT instance. 3.3.2. Enhanced Transformation of Actions. To address the above limitations, we enhance the basic encoding by removing the assumption = 1 in the starting effect states S t + . Specifically, we set  X  0 instead of = 1. We propose to achieve it by adopting a more relaxed parallel semantics and a concurrent enabling relation in our new encoding. For the examples in Figure 2, if o is true at t ,then f is true at t + . Thus, o can be true at t + which means o and o can be true at the same makespan based on a fixed order o  X  o ( o must be executed before o ), as shown in Figure 3. In our basic encoding, the strict parallel semantics requires that actions assigned to be true at the same makespan must be able to be executed in any order. Obviously, o and o do not satisfy this semantics since they can only be executed in a fixed order o  X  o .Inour new encoding, to allow o and o to be assigned to true at the same makespan, we extend our encoding by allowing two actions to be true at the same makespan if they can be executed in a fixed partial order. This definition of the relaxed parallel semantics was first proposed in nonmonotonic logic programs [Dimopoulos et al. 1997] and has been studied in  X  -step plan [Rintanen et al. 2006].

We now formally define our new transformation of actions as follows. Given a durative action o = (  X , X , X  , X   X  , X  , X  , X  ), (1) If  X &gt; 1, we transform it to a starting action o = (  X ,  X  , X  ), an ending action Note that we cannot handle the problems when there exists opposite facts in  X  ,  X   X  , and  X  when  X  = 1, for example, for a fact f  X   X  ,  X  X  f  X   X   X  or  X  X  f  X   X  .
The new transformed simplified planning problem is defined as s = ( I , F s , O s , G ), Note that O s is a simple action set that is transformed from CSTE problem under the new rules and a f is a no-op action for f .

In order to represent the partial order of actions encoded at the same makespan, we define a concurrent enabling relation between any two transformed actions. b on the fact f (denoted as CEnab ( a , b , f )) if and only if: (1) f  X  eff(a)  X  f  X  pre ( b ) where a = o and  X &gt; 1, or f  X   X   X  f  X  pre ( b ) where a is (2) g ,  X  g  X  eff(a)  X  g  X  eff(b) ,and (3) g ,  X  g  X  eff(a)  X  g  X  pre ( b ).

The relation that an action a concurrently enables an action b on a fact f requires that a must be a transformed starting action and adds the precondition f of b (Rule (1)), and a and b are not exclusive of each other (Rules (2) and (3)).

After transforming durative actions to simple actions, we construct a planning graph and develop a new algorithm to detect mutex constraints. In a planning graph for any given makespan N , two facts f and h at time t are marked to be exclusive of each other if and only if: (1) [Static mutex] f = X  h ,or (2) [Dynamic mutex] any action a  X  add ( f ) and any action b  X  add ( h ) are mutex. Two simple actions a and b at a given makespan t are marked to be exclusive of each other if and only if: (1) [Competing needs]  X  f , f  X  pre(a) and  X  h , h  X  pre(b) that f and g are mutex at the (2) [Effect interference]  X  f , f  X  eff(a)  X  X  f  X  eff(b) , (4) [Concurrency interference]  X  f , f  X   X   X  ( o )  X  X  f  X  eff(b) where a is o , o , or no-op (5) [Partial interference]  X  f ,  X  f  X  eff(a)  X  f  X  pre(b) and h , st. CEnab ( b , a , h ). We temporarily add the ignoring starting effects in transformed action X  X  effects for the special case that  X  = 1 when detecting mutex constraints. For example, if there (1 Thus, we will mark a and b to be mutex.

In reference to the mutex definition in our basic encoding, we relax the  X  X arallel interference X  to  X  a deletes a precondition of b and b deletes a precondition of a  X  X nd add the  X  X artial interference X  mutex. The interference mutexes allow two actions to be executed at the same makespan in a fixed order ( a  X  b ) if and only if 1) a and b do not and a does not delete any precondition of b .

Our parallel semantics, which is defined by the above mutex rules, has two differ-ences compared with the semantics studied in previous work [Blum and Furst 1997; Rintanen et al. 2006]. First, our definition of mutex is more relaxed than the mutex def-inition in Graphplan [Blum and Furst 1997]. In Graphplan, the  X  X nterference X  mutex is defined as  X  X f one of the actions deletes a precondition or add-effect of the other. X  It allows two parallel actions to be executed at the same makespan only if they can be exe-cuted in any order. However, we allow two actions to be executed at the same makespan in a fixed order if one concurrently enables the other. Specifically, we divide the inter-ference mutex into  X  X ffect interference X  and  X  X arallel interference X  mutexes and relax the latter to  X  a deletes a precondition of b and b deletes a precondition of a . X  Second, our parallel semantics is more strict than  X  -step plan [Rintanen et al. 2006].  X  -step plan is used for classical planning problems which does not distinct starting or ending effects. Our concurrent enabling relation represents that an action enables another action only by its starting add-effects, while the  X  -step plan considers all add-effects (including starting and ending effects). For the example in Figure2(b), our encoding will find a concurrent enabling relation CEnab ( o , a o , f ) while  X  -step plan will find enabling relation is more strict than  X  -step plan, which is necessary for finding correct temporal plans. 3.3.3. Transform to MinCost SAT. Based on our new action transformation and mutex definition, we now define the enhanced MinCost SAT encoding. For a CSTE problem instance = ( I , F , O , G ) and the corresponding transformation s = ( I , F s , O s , G ), given a makespan N , we define a MinCost SAT problem with the following variable set V and clause set C . The variable set V includes two types of variables: (1) action variables x a , t ,0  X  t &lt; N , a  X  O s , (2) fact variables x f , t ,0  X  t  X  N , f  X  F s .
 Each variable in V represents the assignment of an action or a fact at time t .
The clause set C has the following clauses. (1) Initial state (for all f  X  I ): x f , 0 . (2) Goal state (for all g  X  G ): x g , N . (3) Preconditions of simple actions (for all a  X  O s ,0  X  t &lt; N ): for each precondition (4) Add-effects of simple actions (for all f  X  F s ,0 &lt; t  X  N ): (5) Durative actions (for all o , t , o  X  O ,0  X  t &lt; t +  X &lt; N ): (6) Action mutexes (0  X  t &lt; N ): for each pair of mutex actions ( a 1 , a 2 ): (7) Fact mutexes (0  X  t  X  N ): for each pair of mutex facts ( f 1 , f 2 ): (8) Concurrent enabling circular mutexes (0  X  t &lt; N ): for each concurrent en-
Compared with the basic encoding (Section 3.2.2), the enhanced encoding has three differences. First, we add more clauses for concurrent enabling relation in the precon-dition clauses (Clauses 3). Second, our mutex clauses are fewer than before since we use a stricter mutex definition. Third, we add circular mutex clauses for concurrent enabling relations (Clauses 8).

Based on the concurrent enabling definition, the enhanced encoding can address the limitation of the basic encoding as described in Section 3.3.1. For the example in Figure 2(b), we show the constructed relaxed plangraph at makespan 2 in Figure 4(b). We only show the planning graph at makespan 2 because it has  X  X eveled off X  af-ter makespan 2 [Blum and Furst 1997]. Since CEnab ( a 1 , a 2 , f ), a 2 could be true at makespan 0 and we add two precondition clauses x a x v ( x a Thus, the decoded plan ( o 0 , o 0 + ) is a solution of this example. Specifically, we set = 10  X  log N  X  1 where N is the total number of actions in solution plans in our imple-mentation. Similarly, the plan ( o 0 , o 0 + ) is a solution of the example in Figure 2(a).
To show the difference between our two encoding schemes, we present the relaxed planning graph constructed by the basic encoding in Figure 4(a). Since a 3 is not encoded in makespan 1 which means x a action clause x a x For planning graphs with larger makespans, there is no satisfiable assignment neither based on similar propagations. Thus, there is no assignment that could satisfy the basic encoding for this example.

In summary, since the enhanced encoding based on concurrent enabling relations can describe the situation that o is executed immediately after o , it solves more problems than the basic encoding. Furthermore, compared with the planning graphs shown in Figure 4, the enhanced encoding has a more compact planning graph which means it may find solutions with shorter makespans than the basic encoding. For instance, given scheme is ( o 0 , o 1 ) which has a makespan of 3, while by our enhanced encoding scheme is ( o 0 , o 0 . 01 ) which has a makespan of 2.01. In this section, we develop a branch-and-bound based CDCL (BB-CDCL) algorithm for optimally solving MinCost SAT problems. BB-CDCL can be used to solve the MinCost SAT instances from both the basic and enhanced encodings. Based on the standard branch-and-bound procedure, we introduce a key planning specific technique: a variable branching scheme based on heuristic costs, which significantly improves the problem solving efficiency. Here we give an overview of the BB-CDCL procedure, which integrates two popular schemes, CDCL and branch-and-bound search procedures. The conflict-driven clause learning (CDCL) algorithm [Zhang et al. 2001; Mitchell 2005] is a modern variant of the DPLL algorithm [Davis et al. 1962; Zhang and Malik 2002] which adopts clause learning and constraint propagation techniques. It has been used in many modern SAT solvers [Marques-Silva et al. 1996; Moskewicz et al. 2001]. Although branch-and-bound has been studied and applied to SAT solving [Planes 2003; Alsinet et al. 2003; Fu and Malik 2006; Larrosa et al. 2009], planning-specific variable ordering techniques have not been extensively studied in a SAT solver.

The BB-CDCL procedure is shown in Algorithm 2. The algorithm uses a propagation queue that contains all literals pending propagation and a representation of the current assignment. In the procedure, a variable is free if it has not been assigned a value. Initially, all variables are free.

The BB-CDCL algorithm repeatedly propagates the literals in the propagation queue and returns a conflict if there is any (Line 5). Once a conflict occurs, the procedure analyze() checks the conflict to generate a learned clause [E  X  en and S  X  orensson 2003] (Line 7); after that, it calls backtrack() to undo the assignment until exactly one of the literals in the learned clause becomes unassigned (Line 12). If no conflict occurs, it calls the cost propagate() procedure to estimate the heuristic cost of variables changed by the last propagation (Line 15). It prunes a search node if the current costs exceeds  X  , the cost of the incumbent (the current best) solution (Line 16 X 17), or calls decide() to select a free variable, assigns it to be true or false , and inserts it into the propagation queue (Line 24). Then a new iteration takes place.

Each time a satisfying solution is found (when there is no free variable) (Line 19), it updates the incumbent solution, including the solution number num and threshold  X  , and then backtracks (Line 20 X 22). BB-CDCL keeps searching the whole space until all satisfying solutions are either visited or pruned, in order to find the one that minimizes cost (), the objective function of the MinCost SAT problem. The procedure stops when a top level conflict is found (Line 8 X 9). The variable branching scheme is one of the most important components in a SAT solver. A good branching scheme can improve the search efficiency significantly. In our basic BB-CDCL procedure, the variable branching scheme is the same as that in MiniSat [Zhang and Malik 2002; E  X  en and S  X  orensson 2003], an improved version of VSIDS (Variable State Independent Decaying Sum) [Moskewicz et al. 2001]. VSIDS works as follows. (1) Each variable x has a priority value p ( x ), initialized to 0. (2)  X  p is a priority increment that is initialized to 1.
 (3) In decide(), with a constant probability P 0 , randomly select an unassigned (4) Whenever a learnt clause is generated by analyze() in BB-CDCL, for each (5) Periodically divide all priority values by a large constant  X  and reset  X  p to 1. In MiniSat, P 0 = 0 . 02,  X  = 1 . 2, and  X  = 100.

VSIDS is competitive to other variable branching heuristics for SAT solving [E  X  en and S  X  orensson 2003]. MinCost SAT problems differ from SAT problems in that they have an optimization goal of minimizing the total variable costs. Hence, the variable branching mechanism can be improved by considering the variable costs. We present a branching scheme that is customized and more effective than VSIDS for CSTE plan-ning. Specifically, we propose a heuristic function to evaluate each variable X  X  potential costs. Then, we integrate the heuristic evaluation into the VSIDS branching scheme. 4.2.1. Heuristic Cost Evaluation. The implementation of our heuristic cost function is customized for CSTE planning based on the relaxed planning graph [Blum and Furst 1997; Hoffmann and Nebel 2001]. At each decision point (corresponding to a partial assignment  X  ) during the search, for each variable x (both assigned and unassigned in  X  are included), h ( x ) is maintained as a lower bound of the following quantity: the minimum total action costs of any solution plan that: 1) reaches the assignment v ( x ) = 1 from the initial state I , and 2) is consistent with the partial assignment  X  . bounding function h ( x ) is defined as:  X  X f v  X  ( x ) = 0, then h ( x ) = X  ;  X  X f v  X  ( x f , t ) = 1or x f , t is unassigned, then:  X  X f v  X  ( x a , t ) = 1or x a , t is unassigned, then: where  X  ( x a , t ) = 0if v  X  ( x a , t ) = 1, otherwise  X  ( x a , t ) = 1.
For a variable x assigned to be false, since no solution plan satisfying  X  can reach v ( x ) = 1, we have h ( x ) = X  . The lower bound of a non-false assignment fact variable x t is the minimum estimated value of action variables For each precondition f , it is satisfied either f is true or an action which concurrently enables a is true. Thus, a lower bound for h ( x a , t ) is the maximum of the lower bound of the cost for satisfying a  X  X  precondition variables and the lower bound of the cost for satisfying any precondition f is the minimum of the h values of x f , t and all action variables that concurrently enable f .Notethat  X  ( x ) makes the variable cost  X  ( x )only be counted once in h ( x )or cost (  X  ).

The heuristic function can be applied to MinCost SAT instances from both the basic and enhanced encodings. Since there is no concurrent enabling relation in our basic encoding, it only counts h ( x f , t ) and ignores any concurrent enabling action variables X  instance from the basic encoding.

The algorithms for initializing and maintaining the h ( x ) values for all x  X  V are shown in Algorithms 3 and 4, respectively. To initialize the cost function h ( x ), we first variables from level 0 to N following Definition 4.1. Algorithm 4 updates the h values each time when no conflict occurs during the search. It uses a priority queue U to store all variables whose h values need to be updated after a constraint propagation.
Our heuristic function is based on the idea of integrating the max-heuristic rule with the concurrent enabling relations. The max-heuristics have been extensively studied in SAT solvers (such as MinCostChaff [Fu and Malik 2006] and DPLL BB [Larrosa et al. 2009]). Compared with the generic max-heuristics in MinCostChaff and DPLL BB , the implementation of the heuristic function is customized for CSTE planning which considers durative actions and concurrent enabling relations. 4.2.2. New Variable Branching Scheme. Integrating the new heuristic costs into the VSIDS heuristic, we have the following variable branching rule for BB-CDCL. (1) Each variable x has a priority value p ( x ). Initialize p ( x ) as follows: (2)  X  p is a priority increment that is initialized to 1. (3) In decide(), with a constant probability P 0 , randomly select an unassigned (4) Whenever a learnt clause is generated by analyze() in BB-CDCL, for each (5) Whenever no conflict occurs after calling propagate(), we call cost propagate() to (6) Periodically divide all priority values by a large constant  X  and reset  X  p to 1. In our implementation, we set P 0 = 0 . 02,  X  = 1 . 2, and  X  = 100.

Compared with the VSIDS heuristics, our BB-CDCL heuristic gives higher priority to variables with higher heuristic costs. Since a heuristic cost of a variable x is the lower bound of the total costs of any solution plan that reaches the assignment v  X  ( x ), branching early on those variables with higher heuristic cost and assigning them to be false will likely avoid higher costs solution plans. Further, it will result in a search space with a lower heuristic cost that is more likely to lead to solution plans with lower costs. For example, suppose there are two actions a 1 and a 2 both of which add a goal fact f , which means that there may be two different solution assignments satisfying the goal variable x f , N .If h ( x a our SAT solver will make x a We report our experimental results in two aspects. First, we test seven temporally expressive planners to show the performance of our CSTE planner. Second, we study the effectiveness of our new variable branching scheme, by evaluating the efficiency of some MinCost and Max-SAT solvers.

We run all experiments on a workstation with a dual core AMD Opteron 2200 pro-cessor and 2GB memory. Sun Java 1.6 and Python 2.6 run-time systems are used. The time limit, for each instance, is set to 1800 seconds. Our experiments are performed on a P2P domain we develop and several other CSTE domains [Coles et al. 2008]. Since the original domain definitions in [Coles et al. 2008] do not specify action costs, we examine those actions and assign them reasonable numerical costs. Besides the original problems, we also generate some larger instances from a problem generator that we develop. Note that we do not use all the domains in Coles et al. [2008] because some of them cannot scale to large problems (e.g., the Match domain), and a few of them have variable-duration actions (e.g., the Caf  X  e domain). The following is a brief description of the domains that are included in the experiments. (1) Peer-to-Peer Domain. This domain models file transfers in Peer-to-Peer (P2P) net-(2) Matchlift Domain. In a Matchlift problem [Coles et al. 2008], an electrician enters (3) Matchlift-Variant Domain. The original Matchlift domain only requires one electri-(4) Driverslogshift Domain. The Driverslogshift domain [Coles et al. 2008] is an ex-
High concurrencies in CSTE planning problems are very different from most other temporal planning problems we have seen. Figure 5 illustrates the temporal depen-dencies (Definition 2.4) in several instances from different domains. All these instances have comparable problem sizes. The instance of P2P domain has 90 facts and 252 ac-tions, and the instance of Matchlift domain [Coles et al. 2008] has 216 facts and 558 actions. Figure 5(I) is an instance of the Trucks domain, which is temporally simple and thus has all actions isolated. In Figure 5(II) for the Matchlift domain, each action has up to two actions temporally depending on it. In Figure 5(III) for the P2P domain, each action has up to five actions temporally depending on it. Seven planners are tested and compared in our experiments. We test five temporally ex-pressive planners: Crikey [Coles et al. 2009] (runnable java JAR), Crikey3 [Coles et al. 2008] (static statically-linked binary for x86 Linux), POPF [Coles et al. 2010], LPG-c [Gerevini and Serina 2002], and Temporal Fast Downward (TFD) [Eyerich et al. 2009]. We also test SCP and SCP2. SCP uses the basic encoding and SCP2 uses the enhanced encoding. Both SCP and SCP2 do not minimize action costs. For each makespan, SCP and SCP2 use MiniSAT2 [E  X  en and S  X  orensson 2003], integrated with our new branch-ing scheme, as its SAT solver to either prove unsatisfiability or find a first satisfiable solution, disregarding the objective in the MinCost SAT formulation. We do so because these planners optimize makespan but not action costs and we want a fair comparison of their runtime. Note that SCP2 always gives the optimal makespan according to our empirical results.
 We first show the overall results of search time and number of solved problems in Table I and Figure 6. As shown in Table I, our planners (SCP and SCP2) can solve more problems than other planners. Figure 6 shows that our planners (SCP and SCP2) can search much faster than Crikey, LPG-c, and TFD. POPF runs fast when compared with our planners. However, SCP and SCP2 can solve more problems than POPF (SCP solves 41, SCP2 42, and POPF 40 problems). Further, SCP2 can solve more problems and run faster than SCP.
 We show the makespan results in Figure 7 for each domain. As shown in the figure, SCP finds solutions with shorter makespans than other planners (Crikey, Crikey3, POPF, LPG-c, and TFD) in most problems. However, SCP2 performs even better than SCP. Specifically, SCP2 can find shorter makespans than SCP in 16 instances. This is due to the relaxed parallel plan semantics in SCP2. SCP without this semantics may not find the optimal makespan for certain cases. More detailed results of search time and makespan are presented in Tables II, III, IV, and V. Since all planners except SCP2 do not consider action costs, we only present search time and makespan in these tables. We will show the results of total action costs in next section.
 The detailed results of each domain are presented as follows.
 P2P Domain. The results of P2P domain are shown in Table II. If a planner is able to solve all instances, more information is presented in the row  X   X  in Table II, which is the summation of solving time or makespan over all instances. This is for an easy comparison of different solvers. Crikey, LPG-c, and TFD are not included because they all fail to solve any instance in this domain.

Instances 1 to 9 have simple topologies. Each peer is connected to no more than two other peers. Also, in the initial state, only leaf peers (those connected to only one peer) have files to share. There are less concurrencies in this setting. Crikey fails to solve any instance in this category. Crikey3 solves 7 out of 14 instances. It is faster on three simpler instances but slower than SCP and SCP2 on three other larger instances. Overall, the makespans of solutions found by Crikey3 are up to four times longer than those found by SCP and SCP2.

Instances 10 to 14 have more complicated network topologies. Nearly all nodes in these networks are connected to more than one other node. Every peer has some files needed by all others. In these cases, high concurrencies are required to derive a plan. Both Crikey and Crikey3 fail to solve any of these instances. Crikey3 times out and Crikey reports no solution. It may be due to their incompleteness.

POPF and SCP2 solve all the instances. Since POPF tries to optimize makespan, it always finds shorter makespans than Crikey3. POPF also runs much faster than Crikey3, SCP, and SCP2. However, SCP and SCP2 find shorter solution makespans than POPF in 6 instances. Compared with SCP, SCP2 finds even shorter makespans in these 6 instances and runs faster on large instances (Instances 13 and 14). Matchlift Domain. The results of the Matchlift domain are shown in Table III. On all instances, POPF is the fastest to find solutions. POPF finds solutions with shorter makespans than Crikey, Crikey3, LPG-c, and TFD in most instances. SCP and SCP2 solve problems with longer time than Crikey, Crikey3, POPF, and TFD (SCP and SCP2 run time out in four instances). However, they can find shorter solution makespans than all other planners in solved instances. Compared with SCP, SCP2 runs faster on larger instances (Instances 5, 6, and 9) and finds shorter makespans on instances 6and9.
 Matchlift-Variant Domain. The results are shown in Table IV. All instances are gener-ated with increasing numbers of fuses and electricians. All the other settings, such as the number of floors, rooms and matches, are randomly set. Instances with the same number of fuses and electricians may still have different degrees of concurrency, due to different numbers of matches and other resources. For example, although Instances 7 and 8 have the same parameters, Instance 8 is more difficult than Instance 7 due to different ways the fuses are distributed among rooms.
 As shown in Table IV, SCP2 finds optimal makespans on all instances tested, whereas Crikey, Crikey3, and POPF run out of time on most instances and generate suboptimal plans on the few instances they finished. For the instances they solved, POPF has the worst makespans. Both LPG-c and TFD are not good in this domain, with three instances solved. By comparing to the optimal makespans found by SCP2, we see that SCP fails to find the optimal solution for instances 1, 4, 6, 7, 8, 10, and 11. Driverslogshift Domain. POPF again is the fastest among all planners. Crikey3 runs slightly slower than POPF while its makespans are much worse than that of all others except LPG-c. As shown in Table V, the optimal makespans provided by SCP2, are typically much shorter than those by Crikey3, POPF, and LPG-c. For example, the optimal makespan for Instance 6 in Table V is about one third of the makespan reported by Crikey3 and half of makespans by POPF and LPG-c. SCP does not find the optimal solution on instance 6. TFD is not included because it fails to solve any instance in this domain.
 Overall, our experiments on all the CSTE domains show that: 1) Our planners, SCP and SCP2, solve the problems efficiently and compare favorably with the existing temporally expressive planners such as Crikey, Crikey3, LPG-c, and TFD; 2) SCP2 can guarantee to find the optimal makespans while all other planners cannot. SCP finds optimal makespans on most instances. For those instances SCP cannot optimize, most of times it finds better makespans than the other planners.
 Number of Variables and Clauses. One may concern about the size of SAT encoding and the time cost of SCP2, which are issues that any optimal planner faces. In Table VI, we list the numbers of variables and clauses of each instance (in the last iteration). We show data in the P2P and the Matchlift-Variant domains. The solving time is presented to show the difficulty of the instances.

Similar to other SAT problems, it is obvious that the size of encoding does not necessarily reflect the complexity of a problem. For example, the numbers of variables and clauses of Instance 4 in the Matchlift-Variant domain are both slightly fewer than those of Instance 3. However, Instance 4 is solved 10 times more slowly than Instance 3.

In general, the encoding of SCP2 on current problem instances may have up to hundreds of thousands of variables, which are within the capability of current SAT solvers. Various improvements to SAT-based planning could also be applied to SCP2. We plan to further study techniques such as encoding in new formulations [Robinson et al. 2008b; Huang et al. 2010] and deriving constraint-based pruning clauses [Chen and Yang 2010].
 Under the proposed SCP2 framework, we consider three strategies for solving MinCost SAT instances and minimizing action costs at the optimal makespan: 1) us-ing BB-CDCL algorithm with VSID variable branching scheme (denoted as SCP2 bb ), 2) using BB-CDCL with our heuristic cost based variable branching scheme (de-noted as SCP2 bbh ), and 3) using a transformation from MinCost SAT to WPMax-SAT (weighted partial Max-SAT, introduced in Appendix A) and a generic WPMax-SAT solver WBO [Manquinho et al. 2009] (denoted as SCP2 max ). The reduction from Min-Cost SAT to WPMax-SAT is commonly used in solving MinCost SAT problems. WBO, the winner of weighted partial Max-SAT (industrial track) in the Max-SAT 2010 Com-petition [Max-SAT 2010], is an anytime solver, which keeps finding better solutions as it progresses.

Figures 8 and 9 show the solution quality and the solving time of different strate-gies. For each strategy, we present the results (total action costs and search time) of the first solution and the best costs solution found in 1800 seconds. For example, SCP2 bb 1 and SCP2 bb b represent the first solution and the best costs solution of SCP2 bb , respec-tively. Similar notation applies to SCP2 bbh and SCP2 max .NotethatSCP2 bbh 1 actually represents the result of the original MiniSAT which uses our new variable branching scheme and quits at the first solution. Thus, the search time of SCP2 bbh 1 is the same with the results of SCP2 presented in Section 5.2.

Comparing the results of SCP2 bb b to SCP2 bbh b in Figures 8 and 9, we can see that the new variable branching scheme is better than the original VSIDS scheme. SCP2 finds better solutions and is faster using the new variable branching scheme. Comparing the results of SCP2 bbh 1 to SCP2 bbh b , we can find that they find the same solutions with the same time in a lot of instances (About 33 out of total 46 instances). It shows that our new variable branching scheme has a high probability to guide the search to find the best solution the first time it finds any satisfiable solution. SCP2 bbh b also shows competitive performance compared with SCP2 max b .SCP2 bbh b finds better solutions in 12 instances and better summarized total action costs in P2P, Matchlift, and Driverslogshift domains than SCP2 max b . For most instances, SCP2 bbh b spends less time to find the best solutions than SCP2 max b .

In conclusion, our new variable branching scheme can significantly improve the ba-sic BB-CDCL algorithm in both search time and solution quality. Furthermore, the BB-CDCL algorithm with the new variable branching scheme shows competitive per-formance against the state-of-the-art WPMax-SAT solver WBO.

Detailed results for all instances in the testing CSTE planning domains are presented in Tables VII, VIII, IX, and X in Appendix B. Since the information of the cost of solutions found by other temporal expressive planners is also important, we also list the cost results of Crikey, Crikey3, POPF, LPG-c, and TFD in Appendix B. Surprisingly, Crikey, Crikey3, POPF, and LPG-c find the solutions with better total action costs than SCP2 bbh b and SCP2 max b in a few problems, because for these problems lower costs can be achieved under a longer makespan. The works most related to our research are temporally expressive planners that can handle concurrency, such as TM-LPSAT [Shin and Davis 2004], LPG-c [Gerevini et al. 2010], Crikey [Coles et al. 2009], Crikey3 [Coles et al. 2008], POPF [Coles et al. 2010], and TFD [Eyerich et al. 2009].
 Compared with our method that compiles planning problems to SAT problems, TM-LPSAT and LPG-c use different compilation methods to encode planning problems. TM-LPSAT compiles temporal metric problems with continuous time into linear pro-grams with SAT (LP-SAT) constraints and uses an LP-SAT solver [Wolfman and Weld 1999] to find solutions. LPG-c [Gerevini et al. 2010] introduces a revised representation, temporal action graph (TA-graph) with concurrency, that supports action concurrency. Recent work [Hu 2007] theoretically studies compilation of temporally expressive prob-lems into a constraint satisfaction formulation.
 Crikey, Crikey3, POPF, and TFD perform a state-based heuristic search. Crikey and Crikey3 use enforced hill climbing (EHC) followed by best-first search if EHC fails. POPF, built on Crikey3, avoids many of the overheads incurred through splitting ac-tions by using a forward search over a partial-order rather than a total order plans. TFD adds time increments of &gt; 0 after each action insertion to support this con-currency. Compared with our planner, all these temporally expressive planners cannot optimize action costs. Several pieces of related work focus on optimizing makespans or action costs for classi-cal planning while none of them is capable of handling temporally expressive planning problems.

For classical STRIPS planning without durative actions and concurrency, there exist planners that can optimize the total action costs. Most planners minimizing the total ac-tion costs use heuristic state space search, such as LAMA [Richter and Westphal 2008, 2010], HSP  X  0 ,HSP  X  F [Haslum 2008], FF( h a ) [Keyder and Geffner 2008], CO-PLAN [Robinson et al. 2008a]. Research has been carried out on optimizing the number of actions [Vidal and Geffner 2004; Haslum and Geffner 2000; B  X  uttner and Rintanen 2005; Helmert et al. 2008], which is a special case of optimizing the total action costs. SAT-based classical STRIPS planners have also been extended to optimize the action costs. Three recent representative works, Plan-A [Chen et al. 2008], SATPlan  X  [Giunchiglia and Maratea 2007] and COS-P [Robinson et al. 2010], can find plans that minimize the total action costs for classical planning. Plan-A completely searches the space of the SAT instance translated from a deterministic planning prob-lem to minimize its total costs. SATPlan  X  makes improvements in finding solutions with better total action costs by using OPTSAT [Giunchiglia and Maratea 2006], a tool for solving SAT constrained optimization problems. COS-P modifies the SAT solver RSAT2.02 to create an effective weighted partial Max-SAT procedure (PWM-RSat) for problems where all soft constraints are unit clauses. It uses PWM-RSat to optimize costs at the makespan that it successfully solved the encoded WPMax-SAT problem. Recent temporal planners that aim at optimizing makespan and action costs include MO-GRT [Refanidis et al. 2001] and SAPA [Do and Kambhampati 2003]. MO-GRT extends the heuristic state-space search to temporal planning. SAPA is a domain-independent heuristic forward chaining planner that can handle durative actions, met-ric resource constraints, and deadline goals. It is designed to deal with multiobjective metrics, such as makespan and action costs. Nevertheless, neither MO-GRT nor SAPA can handle temporally expressive domains. Translating metric planning problems into SAT formulations and calling MinCost SAT or Max-SAT solvers to solve them forms another choice for optimizing ac-tion costs [Robinson et al. 2010]. There are several MinCost SAT solvers, such as Scherzo [Coudert 1996], Bsolo [Manquinho and Marques-Silva 2002], Eclipse [Li 2004], and MinCostChaff [Fu and Malik 2006]. MinCostChaff is the first MinCost SAT solver that incorporates many modern SAT techniques [Fu and Malik 2006; Moskewicz et al. 2001]. Experimental results show that MinCostChaff has orders of magnitude of per-formance improvement over other MinCost SAT solvers. However, compared with Max-SAT solvers, MinCostChaff is slower since its lower bounding function does not perform well [Fu and Malik 2006].

There are several state-of-the-art Max-SAT solvers developed for Max-SAT Com-petition. One of the best WPMax-SAT solvers is WBO [Manquinho et al. 2009], the winner of weighted partial Max-SAT (industrial track) in the Max-SAT 2010 Competi-tion [Max-SAT 2010]. WBO uses a new unified framework that aggregates and extends Pseudo-Boolean Optimization (PBO) and Maximum Satisfiability (MaxSAT). It pro-poses a new unsatisfiability-based algorithm which can be orders of magnitude more ef-ficient that existing algorithms. Besides WBO, there are some other efficient Max-SAT solvers, such as SAT4J [SAT4J 2004], MaxSolver [Xing and Zhang 2005], IncWMaxSatz [Darras et al. 2007], W-MaxSatz [Li et al. 2006, 2007, 2009], and Clone [Pipatsrisawat and Darwiche 2007]. In this article, we proposed and developed a SAT-based framework for cost sensitive temporally expressive (CSTE) planning, an important but difficult planning domain that is potentially useful for many applications. Our work was motivated by the obser-vations that high action concurrency is a main characteristic of temporally expressive planning problems and that it is often desired to optimize action costs. Such high con-currency and cost sensitivity were exemplified by the new P2P communication network domain we introduced in this article.

We proposed a general framework for CSTE planning which translates a CSTE planning problem into a MinCost SAT problem, an optimization problem with SAT-clause constraints. Based on a basic translation scheme SCP, we introduced a new translation scheme SCP2 which leveraged and enhanced the basic scheme based on a relaxed parallel planning semantics. Furthermore, two approaches for solving MinCost SAT problems were developed under this framework. One is to use a generic WPMax-SAT solver, and the other uses the branch-and-bound technique based on the CDCL algorithm. We developed a planning-specific scheme, which is a heuristic-cost based scheme for variable branching, to improve the branch-and-bound procedure.
Our experimental results in several CSTE domains showed that our solver based on the enhanced encoding was able to find solutions with the minimum makespans and low total action costs. Compared with the basic translation scheme SCP, our new translation scheme SCP2 could solve problems faster and find solutions with shorter makespans. We showed that the proposed variable branching scheme is very effective in improving search efficiency. The proposed planners compare favorably against existing temporally expressive planners.

Compared with heuristic search based approaches, our framework, as an anytime algorithm, has at least three advantages. The first advantage is its flexibility. Given more time, our new planner can always search for better solutions with lower total action costs at the optimal makespan. Second, we can leverage the extensive research on SAT. We can always expect performance enhancements, by adapting more efficient WPMax-SAT or MinCost SAT solvers. In addition, we can easily utilize additional SAT instance evaluation strategies [Rintanen et al. 2006] to further improve the overall performance. The third advantage is its capability in handling high concurrencies. Our results showed that, for those problems with high concurrencies, our framework has clear advantages over the existing temporally expressive planners.

It is a continuing effort to advance the state of the art of temporally expressive plan-ning. While we developed an efficient CSTE planner with encouraging experimental results in several problem domains, our work can be further extended. One limitation of our current method is that it is not expressive enough for numerical constraints and other complex PDDL2.1 properties. For example, in light of POPF, the major limitation of our current implementation is that it does not support variable action durations. To fully support PDDL2.1 and to take advantage of SAT-based planning techniques, we plan to enhance our planner to handle more complex temporal constraints and other richer semantics.

Another interesting future work is to extend our encoding to handle problems with large action durations. For a temporal planning problem with very large action du-rations, our planner may create planning graphs at very large makespans. Thus, the encoded MinCost SAT instance may be too large to be solved efficiently. We plan to ex-tend our encoding to address this issue, through ideas such as merging multiple steps into one or encoding partial-order logic of actions. We will also study how to integrate some other reduction methods, such as partial-order reduction [Chen and Yao 2009; Chen et al. 2009], into our approach.
 The electronic appendix to this article can be accessed in the ACM Digital Library.
