 University of Rochester outputtrees.WeexaminetheformalpowerofMultiBottom-UpTreeTransducersfromthispoint of view. 1. Introduction
Many current approaches to syntax-based statistical machine translation fall under the theoretical framework of synchronous tree substitution grammars (STSGs). Tree substitution grammars (TSGs) generalize context-free grammars (CFGs) in that each rule expands a nonterminal to produce an arbitrarily large tree fragment, rather than a fragment of depth one as in a CFG. Synchronous TSGs generate tree fragments in the source and target languages in parallel, with each rule producing a tree fragment in either language. Systems such as that of Galley et al. (2006) extract STSG rules from parallel bilingual text that has been automatically parsed in one language, and the STSG nonterminals correspond to nonterminals in these parse trees. Chiang X  X  (2007) Hiero system produces simpler STSGs with a single nonterminal.
 restructuring operations necessary for machine translation (MT). They have the dis-advantage, however, that they are not closed under composition (Maletti et al. 2009).
Therefore, if one wishes to construct an MT system as a pipeline of STSG operations, the result may not be expressible as an STSG. Recently, Maletti (2010) has argued that multi bottom X  X p tree transducers (MBOTs) (Lilin 1981; Arnold and Dauchet 1982; Engelfriet,
Lilin, and Maletti 2009) provide a useful representation for natural language processing applications because they generalize STSGs, but have the added advantage of being closed under composition. MBOTs generalize traditional bottom X  X p tree transducers in that they allow transducer states to pass more than one output subtree up to subsequent transducer operations. The number of subtrees taken by a state is called its rank .MBOTs are linear and non-deleting; that is, operations cannot copy or delete arbitrarily large tree fragments.
 note that, in MT, we are primarily interested in translational relations between strings. in one natural language into a string in another. Whereas MBOTs originate in the tree transducer literature and are defined to take a tree as input, M Tsystems such as those of Galley et al. (2006) and Chiang (2007) find a parse of the source language sentence as part of the translation process, and the decoding algorithm, introduced by Yamada and Knight (2002), has more in common with CYK parsing than with simulating a tree transducer.
 in particular, in terms of the set of string translations that they generate. We relate
MBOTs and compositions of STSGs to existing grammatical formalisms defined on strings through five main results, which we outline subsequently. The first four results serve to situate general MBOTs among string formalisms, and the fifth result addresses MBOTs resulting from compositions of STSGs in particular.
 produced by linear context-free rewriting systems (LCFRSs) (Vijay-Shankar, Weir, and
Joshi 1987). LCFRS provides a very general framework that subsumes CFG, tree ad-joining grammar (TAG; Joshi, Levy, and Takahashi 1975; Joshi and Schabes 1997), and more complex systems, as well as synchronous context-free grammar (SCFG) (Aho and
Ullman 1972) and synchronous tree adjoining grammar (STAG) (Shieber and Schabes 1990; Schabes and Shieber 1994) in the context of translation. LCFRS allows gram-mar nonterminals to generate more than one span in the final string; the number of spans produced by an LCFRS nonterminal corresponds to the rank of an MBO Tstate.
Our second result states that the translations produced by MBOTs are equivalent to a specific restricted form of LCFRS, which we call 1-m-LCFRS. From the construction relating MBOTs and 1-m-LCFRSs follow results about the source and target sides of the translations produced by MBOTs. In particular, our third result is that the translations produced by MBOTs are context-free within the source language, and hence are strictly less powerful than LCFRSs. This implies that MBOTs are not as general as STAGs, for example. Similarly, MBOTs are not as general as the generalized multitext grammars proposed for machine translation by Melamed (2003), which retain the full power of
LCFRSs in each language (Melamed, Satta, and Wellington 2004). Our fourth result is that the output of an MBOT, when viewed as a string language, does retain the full power of LCFRSs. This fact is mentioned by Engelfriet, Lilin, and Maletti (2009, page 586), although no explicit construction is given.
 positions of STSGs, with the goal of better understanding the complexity of using such compositions in machine translation systems. We show that the translations produced by compositions of STSGs are more powerful than those produced by single STSGs, or, equivalently, by SCFGs. Although it is known that STSGs are not closed under composition, the proofs used previously in the literature rely on differences in tree structure, and do not generate string translations that cannot be generated by STSG.
Our result implies that current approaches to machine translation decoding will need to be extended to handle arbitrary compositions of STSGs.
 presenting our results on general MBOTs in Section 3, and our result on compositions of STSGs in Section 4. 2. Preliminaries
A ranked alphabet is an alphabet where each symbol has an integer rank , denoting the number of children the symbol takes in a tree. T  X  denotes the set of trees constructed 674 consisting of a single symbol of  X  of rank k dominating a sequence of k elements from
X .Weuse T  X  ( X ) to denote the set of arbitrarily sized trees constructed from ranked alphabet  X  having items from set X at some leaf positions. That is, T set such that X  X  T  X  ( X )and  X  ( t 1 , ... , t k )  X  T  X  t , ... , t k  X  T  X  ( X ). A multi bottom X  X p tree transducer (MBOT) (Lilin 1981; Arnold and where:
One step in an MBO Ttransduction is performed by rewriting a local tree fragment as under each variable in l to the location of the corresponding variable in r . Transducer rules apply bottom X  X p from the leaves of the input tree, as shown in Figure 1, and must terminate in an accepting state. We use underlined symbols for the transducer states, in order to distinguish them from the symbols of the input and output alphabets.
MBOT M to be the set of string pairs ( s , t ) such that there exist: a tree s
We use the notation source( T ) to denote the set of source strings of a translation T , strings. We use the notation yield(MBOT) to denote the set of translations produced by the set of all MBOTs.
 ( V N , V T , P , S ), where V N is a set of nonterminal symbols, V
P is a set of productions, and S  X  V N is a distinguished start symbol. Associated with each nonterminal B is a fan-out  X  ( B ), which tells how many spans B covers in the final string. Productions p  X  P take the form: p : A  X  g ( B 1 , B V
N ,and g is a function g :( V spans of the lefthand side nonterminal. The function g must be linear and non-erasing , which means that if we write the left-hand side exactly once, and may also contain terminals from V of generating a string from an LCFRS grammar consists of first choosing, top X  X own, a production to expand each nonterminal, and then, bottom X  X p, applying the functions associated with each production to build the string. We refer to the tree induced by top X  down nonterminal expansions of an LCFRS as the derivation tree , or sometimes simply as a derivation.
 such as CFG, consider the following CFG: This grammar corresponds to the following grammar in LCFRS notation:
Here, all nonterminals have fan-out one, reflected in the fact that all tuples defining the productions X  functions contain just one string. Just as CFG is equivalent to LCFRS with fan-out 1, SCFG and TAG can be represented as LCFRS with fan-out 2. Higher values of fan-out allow strictly more powerful grammars (Rambow and Satta 1999).
Polynomial-time parsing is possible for any fixed LCFRS grammar, but the degree of 676 the polynomial depends on the grammar. Parsing general LCFRS grammars, where the grammar is considered part of the input, is NP-complete (Satta 1992).
 LCFRS by using a special symbol # to separate the strings of the two languages. Our
LCFRS grammars will only generate strings of the form s # t , where s and t are strings not containing the symbol #, and we will identify s as the source string and t as the target string. We use the notation trans(LCFRS) to denote the set of translations that can be produced by taking the string language of some LCFRS and splitting each string into a pair at the location of the # symbol. 3. Translations Produced by General MBOTs In this section, we relate the yield of general MBOTs to string rewriting systems. by an LCFRS by giving a straightforward construction for converting MBO Trules to LCFRS rules.
 symbols of rank zero, at their leaves. For an MBO Trule l
S the leaves of l . Without loss of generality, we will name the variables such that x left to right, is: x 1,1 , ... , x 1, d ( S 1 ) , ... , x
Let S 0 be the state symbol at the root of the right-hand-side (r.h.s.) tree r leaf of S 0  X  X  i th child. Thus, for all i ,1  X  p ( i )  X  constructed as S 0  X  g ( S 1 , S 2 , ... , S k ). The LCFRS nonterminal S to the corresponding MBO Tstate X  X  rank plus one:  X  ( S i ) = d ( S the LCFRS nonterminal has one span in the source language, and d ( S the target language of the translation. The combination function for the LCFRS rule
S
Here we use e i for the variables in the LCFRS rule corresponding to spans in the input the MBO Trule.

Figure 2. The first example shows an MBOT rule derived from an STSG rule, in this case converting SVO (as in English) to VSO (as in Arabic) word order. The states of an MBO Trule derived from an S TSG rule always have rank 1. In the resulting LCFRS rule, this means that every nonterminal in the grammar has fan-out 2, corresponding to one span in the source language string and one span in the target language string of the translation. This is what we would expect, given that, in terms of the translations produced, STSG is equivalent to SCFG (because the internal tree structure of the rules is irrelevant), and SCFG falls within the class of LCFRS grammars of fan-out 2. Figure 2b shows a more general example, where the states of the MBO Trule have rank &gt; 1. spond to terminal symbols in the LCFRS. Let  X  0 be the sequence of rank zero symbols appearing at the leaves of l to the left of x 1,1 ,andlet  X  rank zero symbols to the right of x i , d ( S sequence of symbols of rank zero at the leaves of r appearing in the subtree under the  X  i ,0 being to the left of the first variable, and  X  i , p ( i )
We can add these sequences of terminal symbols to the LCFRS rule as follows:
An example of this conversion is shown in Figure 3. In this example,  X  all other  X  and  X  values are the empty string, and d ( S 0 constructed from MBO Trule l  X  r as p l  X  r .
 678 ate all final states S i of the MBO Tfrom the start symbol S of the LCFRS. identical to the yield of the MBOT. We represent MBOT transductions as derivation trees, where each node is labeled with an MBO Trule, and each node X  X  children are the rules used to produce the subtrees matched by any variables in the rule. We can construct an LCFRS derivation tree by simply relabeling each node with the LCFRS rule constructed from the node X  X  MBO Trule. Because, in the MBO Tderivation tree, each node has children which produce the states required by the the MBO Trule X  X  left-hand rules which expand the set of nonterminals appearing in the parent X  X  r.h.s. Therefore the LCFRS tree constitutes a valid derivation.
 lemma relates the strings produced by the derivations: Lemma 1
Let T MBOT be an MBO Tderivation tree with I as its input tree and O as its output tree, and construct T LCFRS by mapping each node n MBOT in T MBOT with the LCFRS production constructed from the rule at n MBOT string tuple returned by the LCFRS combination function at any node n The string t 0 contains the yield of the node of I at which the MBO Trule at the node of T
MBOT corresponding to n LCFRS was applied. Furthermore, the strings t the k yields of the k MBO Toutput subtrees (subtrees of O ) that are found as children of the root (state symbol) of the MBO Trule X  X  right-hand side.
 Proof When we apply the LCFRS combination functions to build the string produced by the
LCFRS derivation, the sequence of function applications corresponds exactly to the bottom X  X p application of MBO Trules to the input tree. Let us refer to the tuple returned by one LCFRS combination function g as t 0 , t 1 , ... , t bottom of the input tree cannot contain any variables, and for MBO Trules of this type, our construction produces an LCFRS rule with a combination function of the form: taking no arguments and returning string constants equal to the yield of the MBOT consider how further rules in the LCFRS derivation make use of the tuple t
Our LCFRS combination functions always concatenate the first elements of the input tuple in order, adding any terminals present in the portion of the input tree matched by the MBOT X  X  l.h.s. Thus the combination functions maintain the property that the tree where the corresponding MBO Trule applied. The combination functions combine the remaining elements in their input tuples in the same order given by the MBOT rule X  X  r.h.s., again adding any terminals added to the output tree by the MBO Trule.
Thus, at each step, the strings t 1 , ... , t k returned by LCFRS combination functions contain the k yields of the k MBO Toutput subtrees found as children of the root (state symbol) of the MBO Trule X  X  r.h.s. By induction, the lemma holds at each node in the derivation tree.
 our first result:
Theorem 1 yield(MBOT)  X  trans(LCFRS).
 Proof
From a given MBOT, construct an LCFRS as described previously. For any transduction of the MBOT, from Lemma 1, there exists an LCFRS derivation which produces a string consisting of the yield of the MBOT X  X  input and output trees joined by the # symbol. In the other direction, we note that any valid derivation of the LCFRS corresponds to an
MBO Ttransduction on some input tree; this input tree can be constructed by assembling the left-hand sides of the MBO Trules from which the LCFRS rules of the LCFRS derivation were originally constructed. Because there is a one-to-one correspondence between LCFRS and MBO Tderivations, the translation produced by the LCFRS and the yield of the MBO Tare identical.
 any given MBOT, we see that yield(MBOT)  X  trans(LCFRS).
 by a certain restricted class of LCFRS grammars, which we now specify precisely. Theorem 2 The class of translations yield(MBOT) is equivalent to yield(1-m-LCFRS), where 1-m-
LCFRS is defined to be the class of LCFRS grammars where each rule either is a start 680 Proof
Our construction for transforming an MBO Tto an LCFRS produces LCFRS grammars satisfying the given constraints, so yield(MBOT)  X  trans(1-m-LCFRS).
 each 1-m-LCFRS rule of the form where each  X  i is a string of terminals, and each symbol t single terminal, we construct the MBO Trule:
By the same reasoning used for our construction of LCFRS grammars from MBOTs, there is a one-to-one correspondence between derivation trees of the 1-m-LCFRS and the constructed MBOT, and the yield strings also correspond at each node in the derivation trees. Therefore, yield(1-m-LCFRS)  X  yield(MBOT).
 LCFRS).
 projections of MBO Ttranslations.
 source string (to the left of the # separator), and  X  ( A ) in the target language (to the right of the separator). This property is introduced by because of the condition on 1-m-LCFRS that the combination function must keep the two sides of translation separate. For a 1-m-LCFRS rule constructed from an MBOT, we define the rule X  X  source language projection to be the rule obtained by discarding all the target language spans, as well as the separator symbol # in the case of the start productions. The definition of 1-m-LCFRS guarantees that the combination function as arguments.
 source( G ) to be the LCFRS obtained by projecting each rule in G . Because more than rule, preserving a one-to-one correspondence between rules in the two grammars. Sim-ilarly, we obtain a rule X  X  target language projection by discarding the source language spans, and define target( G ) to be the resulting grammar. Lemma 2
For an LCFRS G constructed from an MBOT M by the given construction, L (source( G )) = source(trans( M )), and L (target( G )) = target(trans( M )).
 Proof
There is a valid derivation tree in the source language projection for each valid deriva-tion tree in the full LCFRS, because for any expansion rewriting a nonterminal of fan-out  X  ( A ) in the full grammar, we can apply the projected rule to the corresponding nonterminal of fan-out 1 in the projected derivation. In the other direction, for any expansion in a derivation of the source projection, a nonterminal of fan-out  X  ( A ) will be available for expansion in the corresponding derivation of the full LCFRS. Because there is a one-to-one correspondence between derivations in the full LCFRS and its source projection, the language generated by the source projection is the source of the translation generated by the original LCFRS. By the same reasoning, there is a one-to-one correspondence between derivations in the target projection and the full LCFRS, and the language produced by the target projection is the target side of the translation of the full LCFRS.
 projections of the LCFRS independently. This fact leads to our next result.
Theorem 3 yield(MBOT) trans(LCFRS).
 Proof
In the LCFRS generated by our construction, all nonterminals have fan-out 1 in the free language, and an MBO Tcannot represent the following translation: which is produced by an STAG (Shieber and Schabes 1990; Schabes and Shieber 1994). Because STAG is a type of LCFRS, yield(MBOT) trans(LCFRS).
 context-free language, we now show that the target side can be any language produced by an LCFRS.

Theorem 4 target(yield(MBOT)) = LCFRS Proof
Given an input LCFRS, we can construct an MBO Twhose target side corresponds to the rules in the original LCFRS, and whose source simply accepts derivation trees of the LCFRS. To make this precise, given an LCFRS rule in the general form:
S  X  g ( B 1 , ... , B r ) 682 where each symbol t i , j is either some variable x i , j the LCFRS, we construct the MBO Trule: x where the MBOT X  X  input alphabet contains a symbol S for each LCFRS nonterminal S , and the MBOT X  X  output alphabet contains  X  ( S ) symbols S nal S . This construction for converting an LCFRS to an MBOT shows that LCFRS target(yield(MBOT)).
 derived from an MBOT, we know that target(yield(MBOT))  X  LCFRS. Combining these two facts yields the theorem. 4. Composition of STSGs
Maletti et al. (2009) discuss the composition of extended top X  X own tree transducers, which are equivalent to STSGs, as shown by Maletti (2010). They show that this for-malism is not closed under composition in terms of the tree transformations that are and from this point of view we now examine the question of whether the yield of the composition of two STSGs is itself the yield of an STSG in general. It is important to note that, although we focus on the yield of the composition, in our notion of STSG composition, the tree structure output by the first STSG still serves as input to the second STSG.
 transformations are equivalent to an STSG rule that simply copies the three variables with no re-ordering. Thus, these counterexamples are not sufficient to show that the yield of the composition of two STSGs is not the yield of an STSG.
 composition is not a translation produced by an STSG. The essence of this counterex-ample, explained in more detail subsequently, is that rules from the two STSGs apply in an overlapping manner to unboundedly long sequences, as in the example of Arnold and Dauchet (1982, section 3.4). To this approach we add a re-ordering pattern which results in a translation that we will show not to be possible with STSG. sequences of c X  X  and d X  X . The MBOT of Figure 5 generates the translation: [ x ] i = 1 indicates the string concatenation x 1 x 2 of characters c and d, each occurring n i times, with each integer n freely.
 from the pattern of the first MBOT. It produces the translation:
When we compose the two MBOTs, the yield of the resulting transducer is the translation: 684 where will show that T crisscross cannot be produced by any SCFG.
  X  and  X  are the terminal alphabets of the source and target language respectively,
S  X  V is a distinguished start symbol, and P is a set of productions of the following general form: where  X  is a permutation of length n , and the variables X nonterminal symbols (for example, X 1 and X 2 may both stand for nonterminal A ).
In SCFG productions, the l.h.s. nonterminal rewrites into a string of terminals and nonterminals in both the source and target languages, and pairs of r.h.s. nonterminals that are linked by the same superscript index must be further rewritten by the same rule.
 is also an STSG with rules of depth 1, and any STSG can be converted to an SCFG with the same string translation by simply removing the internal tree nodes in each rule. We will adopt SCFG terminology for our proof because the internal structure of STSG rules is not relevant to our result.
 rank 2 , shown in Figure 8, because one rule can produce 2 nonterminals arranged in the permutation of Figure 7. (In the context of SCFGs, rank refers to the maxi-mum number of nonterminals on the r.h.s. of a rule.) We will show that strings of this form cannot be produced by any SCFG of rank less than 2 . Intuitively, factoring the alignment pattern of Figure 7 into smaller SCFG rules would require identifying subsequences in the two languages that are consistently aligned to one another, and, as can be seen from the figure, no such subsequences exist. Because can be unboundedly large in our translation, the translation cannot be produced by any SCFG of fixed rank.
 form such that each rule X  X  r.h.s. either contains only terminals in each language, or contains only nonterminals. An SCFG can be transformed into this normal form by applying the following procedure to each rule: 1. Associate each sequence of terminals with the preceding nonterminal, or 2. Replace each group consisting of a nonterminal and its associated 3. In each rule created in the previous step, replace each sequence of
Figure 9 shows an example of this grammar transformation. Because we do not change does not increase the rank of any grammar having rank at least 3.
 686 ure 10. We restrict derivations to apply rules producing terminals after applying all other rules. We refer to nonterminals at the last step in which the sentential form consists exclusively of nonterminals as preterminals , and we refer to a pair of linked preterminals as an aligned preterminal pair . Assuming that aligned preterminal pairs are indexed consecutively in the source side of the sentential form, we refer to the sequence of indices in the target side as the preterminal permutation of a derivation.
For example, the preterminal permutation of the derivation in Figure 10 is (3,2,1). The permutation of any sentential form of an SCFG of rank r can be produced by composing
Thus, while the permutation (3,2,1) of our example can be produced by composing permutations of length 2, the preterminal permutation (2,4,1,3) can never be produced by an SCFG of rank 2 (Wu 1997). In fact, this restriction also applies to subsequences of the preterminal permutation.
 Lemma 3
Let  X  be a preterminal permutation produced by an SCFG derivation containing rules of maximum rank r ,andlet  X  be a permutation obtained from  X  by removing some elements and renumbering the remaining elements with a strictly increasing function. Then  X  falls within the class of compositions of permutations of length r . Proof
From each rule in the derivation producing preterminal permutation  X  , construct a new rule by removing any nonterminals whose indices were removed from  X  . The resulting sequence of rules produces preterminal permutation  X  and contains rules of rank no greater than r .

As an example of Lemma 3, removing any element from the permutation (3,2,1) results in the permutation (2,1), which can still (trivially) be produced by an SCFG of rank 2. plying Ogden X  X  Lemma (Ogden 1968), a generalized pumping lemma for context-free languages, to the source language of an SCFG.
 Lemma 4 (Ogden X  X  Lemma) then there is some A in V and there are words  X  ,  X  ,  X  ,  X  ,and  X  in  X  Ogden X  X  lemma can be extended as follows to apply to SCFGs.
 Lemma 5 positions in  X  are designated as distinguished, then there is some A in V and there are words  X  ,  X  ,  X  ,  X  ,and  X  in  X   X  and  X  ,  X  ,  X  ,  X  ,and  X  in  X 
Note that there are no guarantees on the form of  X  ,  X  ,  X  ,  X  ,and  X  , and indeed these may all be the empty string.
 Proof
There must exist some sequence of rules in the source projection of G which licenses the derivation A  X   X   X  A  X  . If we write the j th rule in this sequence as A exist a synchronous rule in G of the form A j  X   X  j ,  X  j nal. Thus G licenses a synchronous derivation ( A 1 , A 1  X  and  X  . Similarly, the source derivation S  X   X   X  A  X  has a synchronous counterpart ( S 1 , S 1 )  X   X  (  X  A 1  X  ,  X  A 1  X  )forsome  X  and  X  , and the source derivation A a synchronous counterpart ( A 1 , A 1 )  X  (  X  ,  X  )forsome  X  . Because the synchronous 688 string pairs are generated by the SCFG for all m  X  0. The further conditions on  X  ,  X  ,  X  ,  X  ,and  X  follow directly from Ogden X  X  Lemma.
 (Equation (2)) as a run . In order to distinguish runs, we refer the run arising from c d the source and target strings as the i th aligned run . We now use Lemma 5 to show that aligned runs must be generated from aligned preterminal pairs.
 Lemma 6
Assume that some SCFG G generates the translation T crisscross exists a constant k such that, in any derivation of grammar G having each n i ,1  X  i  X  2 , there exists at least one aligned preterminal pair among the subsequences of source and target preterminals generating the i th aligned run.
 Proof
We consider a source string  X  ,(  X  ,  X  )  X  T crisscross , such that the length n is greater than the constant k of Lemma 5. For a fixed i ,1 the run can be pumped to be arbitrarily long; indeed, this follows from the definition of the language itself.
 guarantees that either  X  ,  X  ,and  X  all contain distinguished positions or  X  ,  X  ,and  X  all contain distinguished positions, we are guaranteed that either  X  or  X  lies entirely within the i th run. Consider the case where  X  lies within the run. We must consider three possibilities for the location of  X  in the string: Case 1. The string  X  also lies entirely within the i th run.

Case2. The string  X  contains substrings of more than one run. This cannot occur, because pumped strings of the form  X  X  m  X  X  m  X  would contain more than 2 runs, which is not allowed under the definition of T crisscross .

Case 3. The string  X  lies entirely within the j th run, where j = i . The strings  X  X  have the same form as  X  X  X  X  X  , with the exception that the i th and j th runs are extended from lengths n i and n j to some greater lengths n i and n in the target side. Because the permutation of Figure 7 cannot be decomposed, there must exist some k such that the k th aligned run lies between the i th and j th aligned side of the translation. If this were not the case, we would be able to decompose the permutation by factoring out the subsequence between the i th and j th runs on both and a substring of either  X  or  X  in the target. We apply Lemma 5 a second time, with all terminals of the k th run as the distinguished positions, to the derivation ( A , A ) (  X  ,  X  ) by taking A as the start symbol of the grammar. This implies that there exist  X   X  ,  X   X  ,  X   X  , X   X  ,and  X   X  such that and all strings are members of the translation T crisscross . Either  X   X  or the k th aligned run, so the k th aligned run can be pumped to be arbitrarily long in the source without changing its length in the target. This contradicts the definition of
T crisscross . Similarly, the case where the k th aligned run lies between  X  and  X  in the target leads to a contradiction. Thus the assumption that j = i must be false. Thus both  X  and  X  always lie entirely within the i th aligned run.
 same form as  X  X  X  X  X  , with the exception that the i th run is extended from length n some greater length n i . For the pairs of Equation (3) to be members of the translation,  X  and  X  must be substrings of the i th aligned run in the target. Because  X  (  X  ) m  X  (  X  ) m were derived from the same nonterminal, the two sequences of pretermi-nals generating these two strings consist of aligned preterminal pairs. Because both  X   X  X  m and (  X  ) m  X  (  X  ) m are substrings of the i th aligned run, we have at least one aligned preterminal pair among the source and target preterminal sequences generating the i th aligned run.
 Lemma 7
Assume that some SCFG G generates the translation T crisscross exists a constant k such that, if (  X  ,  X  ) is a string pair generated by G having each n any derivation of (  X  ,  X  ) with grammar G must contain a rule of rank at least 2 . Proof
Because the choice of i in Lemma 6 was arbitrary, each aligned run must contain at least one aligned preterminal pair. If we select one such preterminal pair from each run, the associated permutation is that of Figure 7. This permutation cannot be decomposed, so, by Lemma 3, it cannot be generated by an SCFG derivation containing only rules of rank less than 2 .
 Lemma 8 machine, and let R = L ( F ) be the regular language it accepts. Let T be the translation derived by intersecting the source strings of T with R 690 Then there exists an SCFG G such that T = L ( G ).
 Proof
Let V be the nonterminal set of G ,andlet S be the state set of F . Construct the SCFG G with nonterminal set V  X  S  X  S by applying the construction of Bar-Hillel, Perles, and
Shamir (1961) for intersection of a CFG and finite state machine to the source side of each rule in G .
 Theorem 5 SCFG = yield(STSG) yield(STSG;STSG), where the semicolon denotes composition. Proof
Assume that some SCFG G generates T crisscross .Notethat T secting the source of T crisscross with the regular language a[c construct an SCFG G generating T crisscross . By Lemma 7, for each , G has rank at least 2 . The intersection construction does not increase the rank of the grammar, so G has rank at least 2 . Because is unbounded in the definition of T
SCFG has a finite maximum rank, T crisscross cannot be produced by any SCFG. 4.1 Implications for Machine Translation
The ability of MBOTs to represent the composition of STSGs is given as a motivation for the MBO Tformalism by Maletti (2010), but this raises the issue of whether synchronous parsing and machine translation decoding can be undertaken efficiently for MBOTs resulting from the composition of STSGs.
 the case where the grammar is considered part of the input, and the case where the
For SCFGs, synchronous parsing is NP-complete when the grammar is considered part of the input and can have arbitrary rank. For any fixed grammar, however, synchronous parsing is possible in time polynomial in the lengths of the source and target strings, with the degree of the polynomial depending on the rank of the fixed SCFG (Satta and
Peserico 2005). Because MBOTs subsume SCFGs, the problem of recognizing whether a string pair belongs to the translation produced by an arbitrary MBOT, when the MBOT is considered part of the input, is also NP-complete.

LCFRS tabular parsing techniques to determine whether a given string pair belongs to the translation defined by the yield of a fixed MBOT. As with arbitrary-rank SCFG,
LCFRS parsing is polynomial in the length of the input string pair, but the degree of the polynomial depends on the complexity of the MBOT. To be precise, the degree of the polynomial for LCFRS parsing is r i = 0  X  ( S i ) (Seki et al. 1991), which yields d ( S i )) when applied to MBOTs.
 synchronous parsing is NP-complete if the STSGs to compose are part of the input, because a single STSG suffices. For a composition of fixed STSGs, we obtain a fixed
MBOT, and polynomial time parsing is possible. Theorem 5 indicates that we cannot apply SCFG parsing techniques off the shelf, but rather that we must implement some type of more general parsing system. Either of the STSGs used in our proof of Theorem 5 can be binarized and synchronously parsed in time O ( n 6
LCFRS resulting from composition has higher complexity. Thus, composing STSGs generally increases the complexity of synchronous parsing.
 is closely related to that of synchronous parsing; both problems can be seen as inter-secting the grammar with a fixed source-language string and a finite-state machine constraining the target-language string. The widely used decoding algorithms for SCFG (Yamada and Knight 2002; Zollmann and Venugopal 2006; Huang et al. 2009) search for the highest-scoring translation when combining scores from a weighted SCFG and a weighted finite-state language model. As with SCFG, language-model X  X ntegrated decoding for weighted MBOTs can be performed by adding n -gram language model state to each candidate target language span. This, as with synchronous parsing, gives an algorithm which is polynomial in the length of the input sentence for a fixed MBOT, but with an exponent that depends on the complexity of the MBOT. Furthermore,
Theorem 5 indicates that SCFG-based decoding techniques cannot be applied off the shelf to compositions of STSGs, and that composition of STSGs in general increases decoding complexity.
 a language model is equivalent to parsing with the source or target projection of the
MBO Tused to model translation. For the source language of the MBO T, this implies time O ( n 3 ) because the problem reduces to CFG parsing. For the target language of the MBOT, this implies polynomial-time parsing, where the degree of the polynomial depends on the MBOT, as a result of Theorem 4. 5. Conclusion
MBOTs are desirable for natural language processing applications because they are closed under composition and can be used to represent sequences of transforma-tions of the type performed by STSGs. However, the string translations produced by MBOTs representing compositions of STSGs are strictly more powerful than the string translations produced by STSGs, which are equivalent to the translations pro-duced by SCFGs. From the point of view of machine translation, because parsing with general LCFRS is NP-complete, restrictions on the power of MBOTs will be necessary in order to achieve polynomial X  X ime algorithms for synchronous parsing and language-model X  X ntegrated decoding. Our result on the string translations pro-duced by compositions of STSGs implies that algorithms for SCFG-based synchronous parsing or language-model-integrated decoding cannot be applied directly to these problems, and that composing STSGs generally increases the complexity of these prob-lems. Developing parsing algorithms specific to compositions of STSGs, as well as possible restrictions on the STSGs to be composed, presents an interesting area for future work.
 Acknowledgments 692
