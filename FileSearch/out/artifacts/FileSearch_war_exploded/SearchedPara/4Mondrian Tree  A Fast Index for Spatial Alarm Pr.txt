 With ubiquitous connectivity and advances in mobile devices and technologies, we are entering an information age where people are connected at all times and informa-tion are delivered through not only traditional authoritative media such as newspa-pers and TV but also new channels for disseminating information such as location-based applications, location-based recommenders, and location-based social networks. Location becomes an essential piece of information for learning and providing intelligent services and applications to mobile users. Spatial alarms are funda-mental capability for many intelligent location-based application systems, ranging from location-based advertisement, location-based intelligent asset tracking, location-enhanced social networking to a location-based intelligent personal assistant that can provide location reminders and location-based recommendations.

A spatial alarm is defined by three elements: a future reference location known as the alarm monitoring region and represented typically by a spatial region of interest, an owner who is the publisher of the alarm, and the list of subscribers of the alarm. In contrast to time-based alarms that remind us of the arrival of a future reference time point , spatial alarms remind us of the arrival of a future reference location.
Example 1 . Location-Based Advertisement Recommender. North Face retail stores gather mobile device locations within a certain radius of their retail store locations. For mobile subscribers with registered mobile devices, the stores can identify and filter out mobile users whose properties match advertisement content and send text messages to their mobile devices with discount offers [Grove 2010].

Example 2 . Location-Based Reminders [Sohn et al. 2005]. Alice sets a spatial alarm on a vitamin store in Lenox Square to  X  X emind her to pick up some vitamin products when she is within three miles of the store. X  Once she enters the spatial alarm region, the spatial alarm is triggered and pops up the predefined text reminder message.
We would also like to note that spatial alarms are fundamentally different from spa-tial continuous queries. Figure 1 illustrates such diffrences. Spatial continuous queries are targeted at mobile objects and events occur in the vicinity of the current location of the mobile user who issued the queries (i.e., the query focal object, represented as cir-cles in Figure 1(a)). An example of spatial continuous query is  X  X ind a nearest restroom within 500 meters of my current location. X  As the user (query focal object) moves on the road, the spatial queries are always centered at the vicinity of the query focal object as shown in Figure 1(a). For example, the continuous query searches spatial objects within 500 meters of the current location, which changes from t 1 to t 2 , t 3 , t 4 ,and t 5 chronologically. In contrast, spatial alarms are targeted at a future reference location of interest, instead of the current location of the mobile subscriber. Consider a spatial alarm by Alice,  X  X emind me to submit a petition for graduation when I am less than 200 meters of the Cherry Emerson Building in Georgia Tech, X  which is represented as a red rectangle in Figure 1(b). When Alice is moving on the road 30 miles away from Georgia Tech, the continuous query approach will keep checking the vicinity of the current location to see if Alice (the focal object) is entering the alarm target region, 200 meters radius of the Cherry Emerson Building. If the user is far away from the alarm (30 miles away in this case), such alarm checks can be repeated many times without triggering the alarm, which is a total waste of battery of the mobile device and causing high energy consumption at mobile clients and high cost at the alarm server. In contrast, the spatial alarm approach monitors the vicinity of the building instead of the current location of Alice. Alarm check is only performed when Alice is located near the alarm target region.

Clearly, to reduce unnecessary alarm evaluations when an alarm subscriber is far from the alarm monitoring region, an ideal approach is to hibernate the spatial alarm application when the user is traveling locally and only trigger it when the user is approaching the radius of 200 meters of the Cherry Emerson Building. Thus, an im-portant challenge in scaling spatial alarm processing is to compute alarm-free regions such that mobile objects traveling within a rectangular region containing no spatial alarms can safely hibernate the alarm evaluation until approaching the nearest alarms of interest. For example, when the user is at t 1 the mobile device starts to hibernating and wakes up at t 4 or t 5 . We argue that in the context of spatial alarm processing, spatial alarms and alarm-free regions are equally important and both should be treated as the first-class citizen. Thus, a key technical challenge for developing an intelligent spatial alarm system is how to scale a spatial alarm processing engine to the growing number of mobile users and the large number of alarms. Unfortunately, existing approaches for scaling spatial alarm processing are focused on computing Alarm-Free Regions (A FR ) and Alarm-Free Period (A FP ) dynamically, which often leads to too many unnecessary alarm checks, consuming significant battery energy of mobile clients.

We argue that on-demand computation of A FR is expensive and may not scale well for a dense population of mobile objects. We advocate the use of a spatial index to speed up the alarm-free region computation in addition to alarm search. It is well known that maintaining an index of spatial data of interest is critical for retrieving those spatial data quickly. However, conventional spatial indexing methods, such as R-tree [Guttman 1984], k -d tree [Bentley 1975], Grid [Nievergelt et al. 1984], and Quadtree [Finkel and Bentley 1974], are not well suited by design to index both spatial objects and empty regions. Figure 2 shows how conventional indexing methods index spatial objects of interests, represented as gray rectangles with numbers from 1 to 4 (spatial alarms in this context). The user X  X  current location is depicted as a red dot. Note that all structures, except Quadtree and Grid, do not index empty regions (the nongray regions). Given the current user location, R-tree and k -d tree know that the user is not inside of any spatial alarms but do not know the size and boundaries of the empty region in which the mobile user can move around without worry of entering any spatial alarm region. Using Grid index, one knows that a mobile user is in a specific cell, that is, (2,3), which is empty, and the size of the cell. However, if a user moves to a cell which overlaps with a spatial alarm, such as cell (1, 3), then the Grid index cannot tell what the size of empty region without computing the empty region. Similary, Quadtree sometimes cannot tell the size of empty region without A FR computation.

In this article we present the design of Mondrian Tree, a region partition indexing structure that is suitable to index both spatial alarms and Alarm-Free Regions (A FR s). For a given mobile user X  X  location, the Mondrian Tree approach can find the relevant spatial alalrms, whether the mobile user is in an alarm-free region, and determine whether an alarm check is needed much more efficiently. A Mondrian-Tree-powered spatial alarm system offers a suite of intelligent techniques for scaling spatial alarms. Mondrian Tree index has two unique features. First, it utilizes the precomputation and indexing of empty regions to avoid on-the-fly computation of alarm-free regions based on the motion behavior of mobile subscribers. Second, it incorporates a suite of locality-aware and motion-aware optimizations to further minimize the amount of wakeups and the number of region-crossing checks to be performed at mobile clients. We conduct a set of extensive experimental evaluations and show that the Mondrian Tree indexing offers fast spatial alarm processing, and it significantly outperforms existing spatial indexing methods, such as R-tree, k -d tree, and Quadtree, which compute alarm-free regions dynamically based on the motion behavior of mobile users. A critical challenge for efficient processing of spatial alarms is to determine when to evaluate each spatial alarm, while ensuring the two demanding objectives: high accuracy , which ensures zero or very low miss rate of spatial alarms, and high efficiency , which requires highly efficient processing of spatial alarms.

Periodic evaluation can be performed for spatial alarms by checking whether a mo-bile subscriber is entering the spatial alarm on every predefined time interval. High frequency is essential to ensure that none of the alarms is missed. Though periodic evaluation is simple, it can be extremely inefficient due to frequent alarm evaluation and the high rate of irrelevant evaluations [Murugappan and Liu 2008].

Similarly, processing spatial alarms upon location updates of mobile users is equally incompetent and wasteful due to the specific characteristics of spatial alarms. For example, assume that the user is currently at t 1 , 10 miles away from her spatial alarm as shown in Figure 1(b). Then it is unnecessary to evaluate those spatial alarms upon her location updates when she approaches at t 4 or t 5 [Bamba et al. 2008].
Safe regions are popular techniques for continuous spatial query processing [Gedik and Liu 2004; Hu et al. 2005; Prabhakar et al. 2002; Hasan et al. 2009]. The safe region of an object o is dynamically computed at the server based on the set of queries such that the current results of all queries remain valid as long as o is residing inside its safe region. Computing safe region takes O ( n 2 )for n queries [Prabhakar et al. 2002]. Although Bamba et al. [2008] extend the safe regions to spatial alarm processing, the high cost of dynamic safe region computation remains a challenging problem. As the mobile client moves, the server needs to recompute its new safe region continuously, which can be expensive. Figure 3 shows spatial alarms installed near Lombard street, San Francisco. At t 0 , the safe region is r 1 , the wide rectangle, because it is the largest rectangle that does not overlap with any spatial alarms. At t 1 , the client exists r 1 and the server computes a new safe region, r 2 , the tall rectangle. At t 2 , however, the client gets out of r 2 and the server computes a new safe region which is the same as r 1 . The computation of the same safe region, r 1 , occurs at t 0 , t 2 ,and t 4 as the client moves along Lombard street. This example scenario shows that although the safe region approach reduces the amount of unnecessary alarm processing, it also introduces a fair amount of unnecessary safe region computation.

Bearing these issues in mind, we present the Mondrian 1 Tree indexing structure, which partitions the universe of discourse into smaller regions of two types: spatial alarm regions and empty regions. We call empty regions Alarm-Free Regions (A FR ) because there is no alarm inside of the region. With Mondrian indexing, it takes O (log n ) for searching the A FR of the mobile client, which is much more efficient compared to O ( n 2 ) for computing the safe region on-the-fly. To our best knowledge, Mondrian Tree is the first index structure to partition the universe of discourse into small regions containing objects of interest (spatial alarms in our context) and empty regions and index them all. In this section we introduce the basic Mondrian Tree index, including data structure, batch index construction, search, and insertion algorithm. Although Mondrian Tree index is a general indexing structure and can be used to index any type of spatial objects, in this article we will introduce it in the context of spatial alarms. Given a set of m spatial alarms O ={ o j | 1  X  j  X  m } , the corresponding Mondrian Tree has a set of n nodes: { v i | 1  X  i  X  n } .Each v i stores the partitioned disjoint rectangular region, which is either an empty region or a region containing o j . Without loss of gener-ality, we denote each spatial alarm o j by its minimal bounding rectangle M BR j . The leaf nodes of a Mondrian Tree are either M BR (spatial alarms) or A FR (empty regions). The internal nodes of the Mondrian Tree contain a set of pointers to its children nodes. We represent and store each spatial region in Mondrian Tree as points using a point trans-formation scheme [Seeger and Kriegel 1988]. A k -dimensional rectangle-shaped region with each side parallel to a one-dimensional axis is represented by a 2 k -dimensional point. For example, a two-dimensional rectangular region r is defined by its lower left corner and upper right corner as a four-dimensional point r where ( p 0 , p 1 ) is the lower left corner and ( p 2 , p 3 ) is the upper right corner of the rectangle. From now on, we use r [ i ] to denote the ( i + 1)-th coordinate value of a four-dimensional point r . For example, r [2] is p 2 .If r is an array, then r [ i ]isthe( i + 1)-th item. Each node v i consists of five components
R i is a disjoint rectangular region that v i represents and expressed as a 2 k -dimensional point as explained before. O ID i is a set of identifiers of the spatial alarms, which overlaps with the rectangular region R i . Each non-leaf node is split into two children nodes. S I i , a split index, and K i , a key, are used for performing node split of internal node v i .S I i decides which axis to use for partitioning the node v i and K i is the value of the split line. S I i is an integer value between 0 and 2 k  X  1 and is defined as where d i is depth of v i .IfS I i is zero or an even integer value, then we split the internal node v i along the line parallel to x -axis, otherwise, along the line parallel to y -axis. null or the children nodes of v i . Leaf nodes do not have K i because they are either empty regions or M BR j and thus nonsplit nodes. We set the split index S I i of leaf nodes to be  X  1. For the root node, v 0 , its depth d 0 is 0. Given k as 2, S I 0 is 0, which is computed by (0 mod 2). Given a node v i , partitioning a node is processed using S I i , K i ,and o j . For each o j ,we line parallel to the y -axis represented by x = p 0 . Now the region of v i is split into two smaller disjoint regions, denoted by C HILD i [0] and C HILD i [1]. One of the two children regions contains o j . Assuming that it is C HILD i [1], then the node split process for v i repeats in the region of C HILD i [1]. In each iteration S I i and K i are computed again, and the node split of v i is performed along the line parallel to the x -or y -axis determined by S I i and K i . This node split process iterates until every p l (0  X  l  X  2 k  X  1) in R i is examined.
 Figure 4 shows the example of region partition and its Mondrian Tree representation. Table I shows how data is stored in the Mondrian Tree. Node v 0 is the root node that covers the rectangle region A represented by (0 , 0 , 100 , 100). Initially we set S I 0 as 0. M BR 0 for the spatial alarm o 0 is (40 , 30 , 70 , 60). In step 1, we compute the key K 0 by M
BR 0 [S I 0 ], which is 40. Then v 0 is divided into two children along the line parallel to y-axis represented as x = 40. Now v 0 has two children v 1 for rectangle B and v 2 for rectangle C as shown in Figure 4(a). R 1 for v 1 is (0 , 0 , 40 , 100), which is computed from (0, 0, K 0 , 100) and R 2 for v 2 is (40, 0, 100, 100), computed from ( K 0 , 0 , 100 , 100). In step 2, v 2 , rectangle C, is chosen to be partitioned because o 0 intersects with v 2 . v 2 is divided into v 3 , rectangle D, and v 4 , rectangle E as shown in Figure 4(b). In step 3, v 4 is chosen and partitioned into v 5 , rectangle F, and v 6 , rectangle G. At last, v 5 , rectangle F, is divided into v 7 , rectangle H, and v 8 , rectangle I. As a result, this example Mondrian Tree indexes both the spatial alarm represented by a gray rectangle H using index node v 7 but also four empty regions denoted by B ( v 1 ), D ( v 3 ), G ( v 6 ), and I ( v 8 ). In spatial alarm processing, we use the Mondrian Tree to find whether a mobile user enters a spatial alarm region or stays in an alarm-free region, which is an empty region. We refer to this search operation as a point search. In addition, we also need a region search operation that can find which index node overlaps with a given rectangle region. Point search over the Mondrian Tree is to find a leaf node v i that contains a point p . For example, in the context of two-dimensional data space, the point search can be used to answer a query like  X  X hat is the smallest rectangular region that contains the point ( x , y )? X  or  X  X oes the mobile user at position ( x , y ) enter a spatial alarm region? X 
Given a point p in k -dimensional space, P OINT S EARCH in Algorithm 1 takes a starting node v i , which is usually root of Mondrian Tree, and the point p as input and outputs the leaf node (either a spatial alarm region or an empty region) in which p resides. Given the node v i ,P OINT S EARCH determines which child node contains p . The child node C
HILD i [ idx ] that contains p is selected and P OINT S EARCH goes down to the node until it reaches the leaf node. Then the leaf node is a region that contains p .

The time complexity of the point search operation on a Mondrian Tree is proportional to the height of the tree because it is a kind of binary search. The average height of a binary search tree with n nodes is log n . Therefore, the time complexity of P OINT S EARCH is also O (log n ). For the skewed Mondrian Tree, the height might be n . Then the worst time complexity of P OINT S EARCH is O ( n ).

Region search algorithm R EGION S EARCH (Algorithm 2)finds all leaf nodes that overlap with a given rectangle r starting from v i , which is also usually root of Mondrian Tree. SimilartoP OINT S EARCH ,R EGION S EARCH determines which child node should be selected to go down further. Thus, it examines which child node overlaps with r . If it overlaps with one child node, then the overlapping node is chosen to next v i . If multiple child nodes overlap with r ,then k R EGION S EARCH is launched and result sets are merged by a union operation. This process repeats until a leaf node is reached.

Consider the Mondrian Tree in Figure 4(h) and a rectangle r 1 (10 , 10 , 20 , 30) as shown in Figure 4(d), the algorithm R EGION S EARCH returns v 1 representing region B . Given a rectangle r 2 (50, 10, 70, 40), the algorithm R EGION S EARCH returns three leaf nodes, v , v 6 ,and v 7 , which represent rectangle regions D, G, and H, all overlapping with r 2 . Concretely, r 1  X  X  x interval is (10, 20) and y interval is (10, 30). Given that K 0 as 40, x  X  X  upper bound, 20, is smaller than K 0 . Therefore the rectangle r 1 is overlapping with C
HILD 0 [0], which is the rectangle region B and located at left of the split line. Because B is the leaf node, R EGION S EARCH finishes returning B . Similarly, for r 2 x interval is (45,65) and y interval is (10,40). Thus, K 0 is smaller than the x X  X  lower bound of r 2 ,whichis 45. That is r 2 is overlapping with v 2 . We compare y interval with K 2 and K 2 is staying between y interval. Therefore R EGION S EARCH launches two R EGION S EARCH ,onewith v 3 and the other with v 4 . The first launch finishes because v 4 is the leaf node. The second launch also launches two R EGION S EARCH . We keep going down until all R EGION S EARCH reach leaf nodes. As a result we have D , G ,and H .
 Similar to a point query, R EGION S EARCH finishes if it arrives at the leaf node. Therefore, R
EGION S EARCH also takes O (log n ) on average and O ( n ) for the worst case. The algorithm of inserting a new spatial alarm o j to a Mondrian Tree starts from the root node and finds a node v t using R EGION S EARCH . v t is either a non-leaf node whose children both overlap with M BR j or a leaf node. Then we consider three cases. (1) M BR j  X  R t = M BR j .M BR j is smaller than and fully contained in R t of a leaf node (2) M BR j = R t .M BR j isthesameas R t . Then we add the identifier of oj into O ID t and (3) Otherwise, v t is a non-leaf node and M BR j is overlapping with both children nodes
We provide a sketch of the pseudocode in Algorithm I NSERT . Given a Mondrian Tree of n nodes, the time complexity of I NSERT is O (log n ). I NSERT consists of two parts: (1) find a leaf node v t and (2) add o j into v t . First part takes O (log n ) on average and O ( n )inthe worst case. The second part takes O (1). Therefore the complexity of I NSERT is O (log n ) on average and O ( n ) in the worst case.

Although Mondrian Tree is a memory-based tree, it can be extended to a tree with page-oriented storage like hard disks. Concretely, if the capacity of memory is n nodes, then those n nodes are stored in the memory and the remaining nodes are stored on external pages. We adopt this structure from LSD tree [Henrich et al. 1989]. In this article, we briefly describe basic ideas of using external pages. For a more de-tailed algorithm, one can refer to the LSD paper. Figure 5 shows the combination of memory and external storage. If the size of M exceeds n , then the subtree of M is written into an external page. If the height of a subtree in external pages exceeds h p , which is set by the system, then the external page is split into two pages. The deletion Algorithm 5 consists of two steps. The first step is to find leaf nodes that have the alarm to be deleted. Then for each found leaf node v , we remove the alarm from v . We denote p as the parent of v .If v was the only child node that has a spatial alarm among p  X  X  children, then we can remove all of p  X  X  children. Thus, the time complexity of deletion is O ( logn ), O ( logn ) for searching leaf nodes and O (1) for removing children. The basic Mondrian index does not guarantee the balance of the tree. Once a node is partitioned into two disjoint smaller regions, one of them is not touched and the other is selected for further partition. Therefore the basic Mondrian index cannot guarantee the balance of the tree. Also the skewness of the tree is affected by the insertion order. In this section we introduce Mondrian*, an optimized index structure that produces a more balanced tree.

The Mondrian* also has similar data structure except that each node has four chil-dren instead of two, denoted by C HILD i [0], C HILD i [1], C HILD i [2], and C HILD i [3]. That is, given v i ,C HILD i has pointers to left, right, bottom, and top of M BR i . Thus, the Mondrian* Tree has four keys in each node because we split the space by four lines. Mondrian* Tree shares search and deletion operation with Mondrian Tree. Insertion operation is slightly different from one in Mondrian Tree. Algorithm 4 shows pseudocode for in-serting a spatial alarm in Mondrian* Tree. Compared to I NSERT (Algorithm 3), I NSERT 2 (Algorithm 4) takes care of four child nodes. Thus, I NSERT 2 also takes O ( logn ) on average and O ( n ) on the worst case.

Figure 6 shows an example of how the Mondrian* partitions the space. For the chosen spatial alarm, say A, the Mondrian* partitions the space by drawing two vertical lines along the alarm as shown in Figure 6(a). Now we set C HILD 0 [0] and C HILD 0 [1] as shown in Figure 6(e). A box with a diagonal line means that node is null. Then two horizontal lines are drawn as shown in Figures 6(b) and we set C HILD 0 [2] and C HILD 0 [3] as shown in Figure 6(f). When B is inserted, then we put B on C HILD 0 [0] because B lies on left of A . Then we perform the same region partition operation on B as shown in step 3 and step 4 of Figure 6.

Mondrian* Index Batch Construction. Given a set of n spatial alarms, the worst case in index construction occurs when every spatial alarm o j (1  X  j  X  m ) is inserted as a child at the lowest leaf node. One advantage of batch index construction is to utilize the prior knowledge on the distribution of spatial alarms to avoid the extreme skewedness of the tree. In this section we describe the batch construction method of Mondrian* index such that no subtree has more than one half of the nodes in the Mondrian* Tree. For presentation brevity, we use k as 2 for two-dimensional space as our context.

Algorithm 6 briefly describes the algorithm of inserting a set of spatial alarms O in Mondrian* Tree. The first step is to sort the set of spatial alarm objects O in x coordinate and secondly in y coordinate. Given the sorted list of spatial alarm objects, we select the spatial alarm object that is the medium of the ordered list as the root node of the Mondrian* Tree, denoted by o root . We insert this o root first by performing the region partition as discussed previously (recall the example in Figure 4). The four children of o root are created and denoted as C HILD root [0] (left), C HILD root [1] (right), C
HILD root [2] (bottom), and C HILD root [3] (top). Furthermore, the remaining spatial alarm objects in the ordered list are regrouped into four subcollections, each of which will be inserted into one of four children of the root. This process iterates recursively until all alarm objects in the ordered list are inserted in the Mondrian* Tree. Clearly, this batch construction process ensures that no subtree can possibly contain more than half of the total number of nodes.

The time complexity of this algorithm is O ( n 2 log n ), given the ordering step on n spatial alarm objects takes O ( n log n ), the selection of the median requires O (1), and I NSERT takes O ( n ).
 Figures 7(a) and 7(b) show the result of region partitioning by basic Mondrian Tree and Mondrian* Tree after the batch index construction over six spatial alarms. Figures 7(c) and 7(d) show the corresponding Mondrian and Mondrian* Tree. Although the spatial alarm D is chosen as the root node for both basic Mondrian and Mondrian*, the region partitioning result for Mondrian* is quite different than basic Mondrian Tree. So is the index structure. This example illustrates that Mondrian* is much more balanced compared to the basic Mondrian index and thus offers much higher efficiency in terms of search and insertion. We have presented Mondrian Tree and Mondrian* Tree for indexing spatial alarms and empty regions. Intuitively, we can treat each empty region as an Alarm-Free Region (A FR ) such that when a mobile user travels inside an A FR , the alarm evaluation is hibernated, saving both energy consumption at the mobile client and the alarm evaluation cost at the server. However, as shown in Figure 7, an empty region in Mondrian Tree may not be the best A FR for a mobile user, especially when multiple A FR s are adjacent to one another. In this section we describe the best strategies for evaluating spatial alarms using Mondrian Tree indexes, including alarm-free period, patched and trimmed A FR , motion-aware A FR , and distributed Mondrian indexing scheme.
In principle, a spatial alarm should be evaluated in three steps. First, we need to determine what type of events should activate the spatial alarm evaluation process. Second, the server needs to find out the list of alarms to be evaluated upon the occur-rence of the alarm events. The shorter this list is, the more efficient the spatial alarm evaluation will be. Third, the server executes the action component of those spatial alarms whose alarm conditions are evaluated to be true.

As discussed in Section 2, periodic evaluation is extremely inefficient due to frequent alarm evaluation and the high rate of irrelevant evaluations. Although using the lo-cation update of a mobile user as the alarm evaluation event seems appealing, and it is independent of the concrete location update strategies, such as periodic, dead-reckoning or others [Pesti et al. 2010], we have pointed out in Section 2 that many location update events are not suitable as the alarm evaluation events. First, not all location updates of a mobile user will lead to a successful evaluation of her spatial alarms, especially when she travels in the spatial area that does not contain any of her spatial alarms. Second, location updates of a mobile user will have zero probability of leading to successful evaluation of those spatial alarms that are not owned or sub-scribed by this mobile user. For instance, Bob X  X  private spatial alarms are indifferent to the location updates of Alice.

To address the first issue, we promote the use of alarm-free regions such that no spatial alarm evaluation will be activated when a mobile user travels inside an alarm-free region. This can significantly reduce the frequency and overhead of spatial alarm evaluation. To address the second issue, the server needs to find out the list of alarms to be evaluated upon the occurrence of the alarm events. The shorter is this list, the more efficient is the spatial alarm evaluation. This motivates us to design the distributed Mondrian Tree index structure. An obvious idea for evaluating spatial alarms efficiently is to incorporate the spatial locality of the alarms and the motion behavior of mobile objects through alarm-free regions. We have discussed in Section 2 that dynamic computation of alarm-free regions is expensive due to unnecessary and possibly duplicate A FR computation. Given that the Mondrian-Tree approach indexes both spatial alarm regions and empty regions, it is intuitive to use empty regions as Alarm-Free Regions (A FR s). The only cost for using A
FR s is time to look up the leaf node instead of computing A FR s. Once A FR is acquired, then the client needs to check if it is still inside of A FR . We introduce the concept of Alarm-Free Period (A FP ) as a basic approach to assist a mobile user to determine when to check whether she moves outside of her current A FR . An important property of A FP is that it should avoid missing alarms or minimizing the alarm miss rate. 5.1.1. Basic A FP . Given a mobile client m and an alarm-free region A FR m ,theA FP m is the shortest travel time for m to arrive at the closest border of its current alarm-free region A FR m .DuringA FP m , m  X  X  alarm evaluation service can enter a sleep (hibernate) mode.

Two main factors that impact on the computation of the A FP m are the velocity of m , say V m , and the shortest distance from the current position of m to the closest border of A FR m ,say MinDist ( m , A FR m ). Thus, the A FP m can be computed as follows.
One caveat with Eq. (1) is that it assumes that the mobile subscriber m moves in a straight line from her current location to the closed border of A FR m . It is, however, not a realistic assumption in real life. For example, it is highly likely that the mobile user m is moving towards a direction that is opposite of the closest border of its current A
FR m . The steady motion assumption is specifically true when mobile users move on road networks. 5.1.2. Steady-Motion-Based A FP . Given a mobile user m and m  X  X  previous moving direc-tion  X  , we can compute the moving direction of m using the probability density function of moving direction  X  , denoted by p (  X  ). p (  X  ) is uniformly distributed and p (  X  )is 1 2  X  if the mobile client selects the next direction randomly, as shown in Figure 8(a).
However, under the steady motion assumption, the mobile client is likely to increase or decrease the value of  X  but not dramatically. For example, at an intersection, the probability of making a U-turn for the mobile client is less than the probability of mak-ing a left or right turn. Therefore, the density function p (  X  ) is not uniformly distributed. The modified p (  X  ) is provided as follows. Here y and z are parameters of steadiness such that y z &lt; 1. Figure 8(a) shows the probability density function p (  X  ) for different values of z when y = 1.

Figure 8(b) shows the steady motion behavior over the moving direction  X  while  X  may change between  X   X  L and  X   X  R . Based on this assumption we define a steady motion where D  X  ( m , A FR m ) is the distance from the current location of m to the intersection point with the boundary of A FR m over which m may cross while heading towards the  X  direction.

The steady-motion-based alarm-free period for mobile client m , denoted by A FP m ,is computed as follows.
 We have shown that the Mondrian Tree indexes both spatial alarm regions and empty regions, and thus we can efficiently determine whether a mobile user is inside of a spatial alarm region or an alarm free region. Furthermore, by utilizing the Alarm-Free Region (A FR ), we can significantly reduce the number of unnecessary alarm evaluations in anticipation of mobile client movement.

However, directly using empty regions as alarm-free regions can incur higher number of region-crossing checks to be performed, especially when mobile clients travel from one small empty region to another. Thus, the gain from reduction of the number of unnecessary alarm evaluations is offset by the cost of higher A FR crossing checks when A
FR s are small in size. We next examine the cost of A FR -based alarm evaluation in order to better understand the impact of the A FR perimeter on the cost of alarm evaluation.
Assume that the mobile user m moves in a randomly chosen direction with a constant speed V m , C SA is the cost for one alarm evaluation,  X  is the angle between m  X  X  moving direction and the positive x-axis (as shown in Figure 8(b)), l (  X  ) is the distance from the current location of m to the intersection point p with the boundary of A FR m when m travels along the  X  direction,  X  (A FR m ) is the perimeter of A FR m ,and V m is m  X  X  current speed. Given m  X  X  current alarm-free region A FR m , we can compute the amortized alarm evaluation cost for m over time, denoted by C m , as follows.

Note that 2  X  0 l (  X  ) d  X  =  X  (A FR m ), and given that A FR m is a rectangle region, the inter-section point p should be unique. Based on this equation, the average alarm evaluation cost is minimized when the perimeter of the A FR m is maximized.

This motivates us to investigate the opportunities of composing larger A FR s for each mobile client by merging empty regions in the vicinity of the mobile client. Intuitively, by maximizing the perimeter of A FR s, we can minimize the number unnecessary region-crossing checks to be performed, which further minimize the average cost of alarm evaluation. This is because reducing region-crossing checks can lead to better energy efficiency at mobile clients and reduced communication and computation load at the server.
 In the rest of this section, we describe two optimization techniques for extending A 5.2.1. Patch and Trim (PAT). Before describing our technique for merging empty regions to form a larger A FR , we illustrate the technical challenge of this problem by example. Figure 9(a) has five spatial alarms shown in small dark grey rectangles and the red circle denotes the current location of mobile client m . Clearly the optimal A FR with respect to these five spatial alarms and the current location of m is the light gray rectangle in Figure 9(a). However, it is costly in general to compute such an optimal A
FR . According to Chazelle et al. [1984], given a set of n spatial alarms, the time complexity for computing the largest empty rectangle with respect to the n alarms is O ( n log 3 n ). Therefore, in this article we develop a near-optimal but fast algorithm to compute an extended A FR . We call it Patch and Trim (PAT).
 Figure 9(b) shows the result of constructing an A FR rectangle by patching the adjacent A FR s (empty regions) and trimming the patched polygonal region over orthogonal lines.
P AT consists of two phases: Patch phase and Trim phase. In the Patch phase, we search the Mondrian index to get a set of adjacent A FR s with respect to the current location of mobile client m by using R EGION S EARCH in O (log n ). Then we perform the Trim phase over the four sides (top, right, bottom, left) of the patched empty region in clockwise manner in O (1). In total, P AT takes O ( logn ), which is faster than O ( n log 3 n ).
Figure 10 illustrates the patch phase and the four steps of the Trim phase. Assume that the user is inside of empty region A . Figure 10(a) shows the resulting polygonal area of the patch phase where all neighboring empty regions of A are selected. In the trim phase, we need to trim the polygonal area into a rectangle region containing A by setting the boundary of the extended A FR . This is done by selecting the intersecting interval of neighboring empty regions on four sides of A , clockwise one at a time. For example, in order to extend A upward, we consider A X  X  neighboring empty regions: B , C , D ,and E . The intersecting y interval by all four rectangles is the same as E  X  X  height. Therefore we choose y value of the top border in E as the extended top boundary shown in 10(b). On the right side of A , there are no adjacent A FR s. Therefore we use the x value of A  X  X  right border as the right boundary of extended A FR , shown in Figure 10(b). In order to extend A downward, we examine A  X  X  downward neighboring empty regions: F , G ,and H and the intersecting y interval they share is the same as G  X  X  y interval (height). Thus we select the y value of G  X  X  bottom border as the bottom boundary of the extended A FR , shown in Figure 10(c). Finally we examine if we can extend A on its left border. Given that the left neighboring region of A is a spatial alarm, we cannot extend A further on its left side. Thus, we choose the x value of A  X  X  left border as the left boundary of the extended A FR , shown in Figure 10(d).

We have shown that P AT can quickly compute an extended A FR that is near optimal when there is no additional knowledge about the user X  X  mobility and motion behavior. As discussed in Section 5.1, given the current A FR of a mobile user m , we compute the Alarm-Free Period (A FP ) during which m can hibernate its alarm evaluation service. Obviously, the longer is an A FP , the less number of A FR crossing checks will be performed and thus less alarm evaluations for m .

Given that most mobile users travel on a spatially constrained road network or walk path with a destination in mind, we know the approximate travel direction for these mobile users. Under such a steady motion assumption, we can utilize the moving direction of a mobile user to compute the extended A FR such that the Alarm-Free Period (A FP ) computed using this extended A FR will be maximized.

Recall the example in Figure 9, if user m is moving northwest, then all spatial alarms located in the south of m  X  X  current location are no longer relevant. Thus, the best extended A FR for m in this case is the extended A FR computed using M PAT ,shown in Figure 9(c). This is because by utilizing the steady motion of m , the extended A FR in Figure 9(c) maximizes the A FP for m .

This motivates us to develop a motion-aware patch and trim algorithm that can compute the extended A FR for each mobile user m based on her motion behavior, aiming at maximizing the AFP for m . 5.2.2. Motion-Aware Patch and Trim (MPAT). The motion-aware patch and trim algorithm for extending A FR consists of five steps. A pseudcode for computing M PAT is described in Algorithm 7 and we provide a walk-through of the algorithm using the example in Figure 11. Given the current location p , direction d , we can find the current node v that p stays. Using the previous approach we can find corner points C . Given the direction d , we can sort quadrants. For example, if d is heading northwest, quadrant I is the most possible direction to enlarge A FR , quadrant II is the second most possible, quadrant III is the third, and the last is quadrant IV. These orders are stored in Q .For each quadrant and corner points, we try to form a rectangle and measure the distance from p to four borders of formed rectangles. The rectangle with the longest distance will be chosen on the quadrant. We iterate this routine on four quadrants.

Step 1 : Determine the Relevant Quadrants . Under the steady motion assumption (re-call Section 5.1), if a mobile user is heading towards the  X  direction, then the probability of m moving forward or turning left or right on its current location is much higher than the probability of making a U-turn, as shown in Figure 8(a). Therefore, spatial alarms in the downward direction of m are no longer relevant.

In order to make the best use of the steady motion behavior of the mobile user m , we partition the universe of discourse into four quadrants using the current location of m as the center such that only those quadrants that are relevant to computing the extended A FR of m will be selected.

Figure 11(a) shows an example of four quadrants partitioned at o , the current location of mobile user m . We determine the set Q of quadrants to be considered based on the steady motion density function p (  X  ) of the mobile user m (recall Figure 8(a)). | Q | is at most 2. If  X  is 100  X  and we use p (  X  )with z = 8, then the range of moving direction will be between 78.5  X  and 122.5  X  . The range of direction overlaps with quadrant I and II . Therefore we consider two quadrants out of four. If the range of moving direction overlaps with only one quadrant (e.g., when  X  is 30  X  ), then only one quadrant is relevant and selected in this step.

Step 2 : Find Candidate Corner Points .Let A be the empty region in which m re-sides. In each selected quadrant, we first use the the function R EGION S EARCH to find all neighboring empty regions of A , which are included in this quadrant. Then we examine each of the neighboring empty regions, and add its four corner points into the set of candidate corner points. This set of candidate corner points will be used to determine the component rectangle of the extended A FR in the selected quadrant. In our running example, corner points in the quadrants I and II are represented by hollow circles as shown in Figure 11(a).

Step 3 : Find Candidate Component Rectangle by Revising Corner Points. For each selected quadrant, we examine all candidate corner points and revise those that may not form a component rectangle of the extended A FR . A component rectangle of the extended A FR is the empty rectangle region that has o , the current position of m ,as one of the corner points. For example, we examine the four corner points of B in the left top quadrant as shown in Figure 11(a). Consider a component rectangle consists of p 1 and o . This component rectangle overlaps with the spatial alarm S 1 as shown in Figure 11(b). Therefore the corner point p 1 needs to be moved to q 1 so that it avoids to overlap with S 1 . Similary, a corner point p 4 should be revised to move to q 4 which has the same x -value as S 1  X  X  right border. The new component rectangle formed with o and q 2 as two diagonal corner points will not overlap with any spatial alarms. The same process runs iteratively until every candidate corner point is examined and revised. The revised corner points are shown by dashed arrows in Figure 11(c).

Step 4 : Find Dominating Points. Let quadrant I denote the upper right quadrant, quadrant II denote the upper left quadrant, quadrant III denote the bottom left quadrant, and quadrant IV denote the bottom right quadrant. In each quadrant we change the meaning of the dominant points for p 1 ( x 1 , y 1 )and p 2 ( x 2 , y 2 ) as follows. (1) Quadrant I : p 1 dominates p 2 if x 1  X  x 2 and y 1  X  y 2 . (2) Quadrant II : p 1 dominates p 2 if x 1  X  x 2 and y 1  X  y 2 . (3) Quadrant III : p 1 dominates p 2 if x 1  X  x 2 and y 1  X  y 2 . (4) Quadrant IV : p 1 dominates p 2 if x 1  X  x 2 and y 1  X  y 2 .
 Based on the preceding definition, the set of dominating points are represented as solid black dots in Figure 11(d), namely d 21 , which disregards two hollow points with the same x -values, d 22 , which disregards three hollow points, d 11 , which disregards one hollow point with the same x -value, d 12 , which disregards two hollow points, one with the same x -value and the other with the same y -value; and d 13 .

The black dot corner points dominate all the hollow dots. An important property of a dominating point is that the size of the component rectangle defined by the cur-rent location o of m and a given black dot corner point is maximized, compared to the component rectangle defined by the current location o of m and a hollow corner point dominated by the given black dot. For example, the component rectangle with a dominant black dot is larger than the component rectangle with a hollow corner point.
Step 5 : Patch and Trim Component Rectangles. The set of dominating points form cor-ners of component rectangles in each quadrant. The final A FR is composed by patching one component rectangle from each quadrant and trimming the patched rectangle so that the distance from the current location to the border of the resulting A FR rectangle is maximized while m heading towards the  X  direction. In Figure 11(e), there are five component rectangles, each corresponding to one of the five dominating points marked in black dot. In quadrant II , we select the component rectangle with o and d 21 instead of the one with o and d 22 because the former provides the longest distance to the border. Similarly, in quadrant I we choose the component rectangle with o and d 11 , because the distance to the border remains the longest. If we choose d 12 , then the final A FR is wider but shorter and the distance to the border is shorter.

The time complexity for computing motion-aware A FR is O ( n 2 ), given that step 1 conquer, and step 5 takes O ( n ). Given n mobile users subscribing to public and private spatial alarms, there are three alternative ways of creating and maintaining Mondrian indexes. First, we can create and maintain a single Mondrian Tree for all mobile users and all their spatial alarms. We call it the centralized approach. Alternatively, we can create n Mondrian Tree indexes, each devoted for one mobile subscriber, which indexes all alarms subscribed by this subscriber, including public, private, and shared alarms. We call it the distributed approach. The third alternative is to create one Mondrian index for all public alarms, and n Mondrian Tree indexes for all private and shared alarms, each dedicated to one of the n mobile subscribers. We call it the hybrid approach.

Given the specific characteristics of spatial alarms, the approaches of creating and maintaining individual Mondrian Trees, one per client, can significantly minimize the overhead of searching for relevant alarms and A FR s of a given mobile user.
For example, if Alice installed 10 spatial alarms and Bob installed 30 alarms, then we create a single Mondrian Tree with 40 alarms under the centralized approach and two Mondrian Trees, one for Alice with 10 alarms and the other for Bob with 30 alarms, under the distributed approach. Then, the average size of A FR s in the centralized approach will be much smaller than that of A FR s in the distributed approach because the centralized approach inserts more alarms in a Mondrian Tree. Furthermore, the less nodes we have in a Mondrian Tree, the faster it takes to find a leaf node because the search conducted by Alice will not be affected by the spatial alarms installed by another user Bob. In addition, three alternative system architectures can be used to support spatial alarm processing: server centric, client centric, and distributed client-server. Considering that the client-centric architecture is only applicable for processing private spatial alarms [Murugappan and Liu 2008], we next focus on the server-centric architecture and distributed client-server architecture.

In the server-centric architecture, spatial alarms will be installed, subscribed, and processed at the server and mobile clients do not contribute directly to the spatial alarm processing tasks. Mobile clients only receive alarm notification when entering their alarm target regions.
 In the distributed client-server architecture, the server creates and maintains one Mondrian index per mobile subscriber. Insertion of new public or shared alarms will trigger the server to broadcast the newly installed alarms to those mobile clients whose subscriptions match with these new alarms, so that each mobile client can insert the newly added alarm into its local Mondrian Tree. Insertion of a private alarm only involves the insertion of this alarm to the local Mondrian Tree of its owner. A spatial alarm is removed from the system (client and server) upon reaching its expiration time. Alarm expiration is checked at each alarm evaluation. The server and the mobile clients accomplish spatial alarm processing collectively. Several strategies can be used for partitioning of spatial alarm processing tasks into server-side and client-side processing. We next describe three possible strategies for implementing the Mondrian Tree approach under the distributed client-server architecture.

The first strategy will have the sever perform the following four tasks: (1) construct and maintain the Mondrian Tree for each mobile object m ; (2) search the Mondrian Tree index to find A FR m for m ; and (3) compute A FP m for m ;and(4)sendA FP m to m .In this scenario, the client application checks if A FP m expires. If so, it sends a new A FP m request message to the server.

The second strategy will have the server perform only the first two tasks and a modified version of the fourth task. Concretely, the server sends the current A FR m to m instead of the A FP m . Now the client computes A FP m locally using A FR m (task 3). The client only reports to the server when it moves outside of A FR m or an alarm monitoring region.

The third strategy will have each client build a Mondrian Tree. Each client looks up the index locally, finds its current A FR , and computes A FP accordingly. A client only reports to the server if it arrives at an alarm monitoring region. All public, private, and shared alarms are installed at the server and distributed to clients by the server.
The choice of which strategy to use depends primarily on the capacity of mobile clients. Some clients have limited capability in terms of battery power, computing and storage capacity, whereas others are equipped with computing and memory capability equivalent to a laptop computer such that it can store the Mondrian Tree that indexes all of its subscribed alarms locally. In this situation, a mobile subscriber who is capable of storing its own Mondrian Tree locally can also perform the Mondrian Tree lookup and A FP computation locally. Thus this strategy significantly reduces the amount of client-to-server communication cost. In this section we report our experimental evaluation of the performance and effective-ness of the Mondrian Tree approach to spatial alarm processing. Our experiments are conducted with two objectives. First, we want to compare Mondrian index with a set of popular spatial indexing techniques, such as R-tree, k -d tree, and Quadtree in terms of multiple parameters, including total time, index lookup time, memory size, A FR computation time, average size of A FR , and average client-to-server communication messages. Our experimental results show that the Mondrian Tree approach signifi-cantly outperforms R-tree, k -d tree, and Quadtree for spatial alarm processing, due to faster A FR computation, longer A FP , and indexing of both alarms and A FR swithMon-drian Trees. Second, we conduct experiments to compare different design choices for processing spatial alarms using Mondrian Tree indexes, including: (i) comparing the basis A FP (alarm-free period) and the steady-motion-based A FP with respect to periodic evaluation; (ii) comparing the basic Mondrian Tree with Mondrian PAT and Mondrian MPAT in terms of the number of A FR crossing checks required and average A FP inter-val length; (iii) comparing the centralized, distributed, and hybrid approach to creating and maintaining Mondrian indexes in terms of A FR computation and average size of A We extend GTMobiSim mobility simulator [Pesti et al. 2009] and generate a set of traces of moving vehicles on a real-world road network. The road network data are obtained from the National Mapping Division of the U.S. Geological Survey [USG 2013] in the form of Spatial Data Transfer Format [SDT 2013]. Vehicles are distributed randomly on the road segments according to traffic densities determined from the traffic volume data [Gedik and Liu 2005]. Table II shows road types and traffic types for each road type. These vehicles move on the roads of metro Atlanta. On arrival at each intersection, vehicles choose which direction to take as a next direction. In this way, we prevent vehicles from moving straight and simulate a random walk. Even with this randomness, our M PAT shows the best performance by predicting future direction and speed.
 The number of spatial alarms and the number of vehicles vary from 1,000 to 10,000. The default number of vehicles is 5,000 and the default number of alarms is 5,000.
For R-tree, Quadtree, and k -d tree, the index structure does not provide a good quality of A FR . In this experiment we compute A FR s by the safe region algorithm in Bamba et al. [2008] for distributed processing of spatial alarms. It consists of two steps. First, it finds n nearest alarms and computes the A FR using a greedy approach in O ( n 2 ). The parameter n is a system-supplied parameter. When n is too small, A FR is too small. On the other hand, if n is too big, the A FR computation is too expensive.

All the Mondrian Trees used in this experimental evaluation are centralized Mon-drian Tree except in the experiment for performance of multiple Mondrian Trees. Given that Mondrian Tree is a memory-based space partitioning index structure, we modified other data structures so that they stored data in the main memory.

All experiments run on a Linux machine with Intel Core 2 Duo CPU 2.8 GHz and 4GB RAM. The first set of experiments is designed to compare the Mondrian Tree against other data structures in spatial alarm processing by measuring total time, index lookup time, memory size, A FR computation time, average size of A FR , and average client-to-server communication messages. In order to understand how the number of alarms and the number of users impact the alarm process performance, we design two groups of experiments, one with varying number of users from 1,000 to 10,000 and 5,000 alarms (Figures 12(a) X (d)) and the other with varying the number of alarms from 1,000 to 10,000 and 5,000 vehicles (Figures 12(e) through (h)). Note that to be fair in the comparison of centralized Mondrian Tree with other index structures, all experiments reported in this first set use the basic Mondrian Tree without A FR or A FP optimizations.
Figures 12(a) and 12(e) show total time spent for alarm processing for varying num-ber of alarms and varying number of users respectively. In both figures, although the total time increases for all approaches as the number of alarms or users increases, the rate of increase for Mondrian Tree is significantly smaller comparing with R-tree and k -d tree. The reason Quadtree is slightly slower than Mondrian Tree is that compared to other two data structures it only concerns a small leaf node and a set of spatial alarms in it, which reduces the number of alarms to be considered for computing A FR s. Figures 12(b) and 12(f) show total A FR computation time. By comparing with Figures 12(a) and 12(e), we note that A FR computation takes up to 90% of total alarm processing time. On each A FR request by mobile user m , the server looks up spatial alarms with regard to m  X  X  current location. Given a location,the Mondrian Tree ap-proach does not compute A FR s. It just looks up the relevant leaf node. However, R-tree and k -d tree need to dynamically compute A FR s upon each user request in O ( n 2 ), so their AFR computation costs are quadratic in comparison with the Mondrian approach.
Figures 12(c) and 12(g) compare the average size of A FR s. The Mondrian Tree parti-tions the universe of discourse into relatively smaller size of rectangles on average and thus smaller A FR s. Therefore the average size of A FR s in the Mondrian Tree is smaller than one in R-tree or k -d tree as shown in Figure 12(c). Like Mondrian Tree, Quadtree is also a region partition tree. Therefore the average size of A FR is also small. As we increase the number of alarms, the average size of A FR s decreases because more empty regions are occupied by alarms. However, it is obvious that the average size of A FR s does not change much while fixing the number of alarms and varying the number of users as shown in Figure 12(g).

The message cost from client to server is shown in Figures 12(d) and 12(h). Due to the smaller size of A FR in Mondrian Tree, the average number of client-to-server messages for requesting A FR s is slightly larger than other data structures. Quadtree also indexes smaller empty regions, but once it enters a region that has a spatial alarm, then it needs to compute A FR . This makes users using Quadtree frequently cross the border and compute A FR s. Therefore it has the greatest message cost as shown in Figure 12(d). When we vary the number of mobile objects but fix the number of alarms in Figure 12(h), the number of messages requesting A FR s barely changes because average sizes of A FR s are similar for all mobile objects, and thus each has similar probability of crossing A FR s. The second set of experiments compared optimization techniques such as A FP ap-proaches (Figures 13(a) and 13(b)) to extend A FR s with periodic wakeup (Figures 13(c) and 13(d)). After computing an A FR for each mobile user, we can either set a time in-terval as a hibernation period (periodic) for the mobile user to wake up and check if she has moved out of her A FR , or compute the A FP (recall Section 5.1). In Figure 13, two left figures show the average amount of time (A FP ) that client devices can enter the sleep mode during the entire 30-minute movement and the average amount of time to compute A FP . Figure 13(a) shows that the basic A FP and the steady motion A
FP have a much longer A FP interval compared to the periodic approach, thus reducing the amount of unnecessary alarm evaluations. Also steady motion A FP outperforms the basic A FP though the difference decreases as the number of alarms increases, because more alarms imply smaller A FR s. Figure 13(b) shows the experimenal result with the simulation of 30-minute driving. If a user actually moves for 30 minutes as the sim-ulation, the spatial alarm processing can enter hibernation for about 8 minutes and 30 seconds, 28% of 30 minutes of driving. Also Figure 13(b) shows that although steady motion A FP has the longest A FP interval, it takes more time to compute A FP because it needs to compute the average of A FP s for more than one direction.

Figures 13(c) and 13(d) show the comparison of the basic A FR with the two A FR optimizations. In this set of experiments, clients enter a hibernation mode during computed A FP . Thus, mobile clients issue lesser number of A FR requests compared to the A FR requests in the previous experiments in Section 6.2, where a periodic wakeup is used after A FR is obtained (see Figures 12(d) and 12(h)). Note that Mondrian refers to the use of an empty region from the basic Mondrian Tree construction as A FR s(no optimization). Mondrian MPAT refers to Mondrian approach powered with M PAT ,and Mondrian PAT is the Mondrian approach powered by P AT . In both cases, we compute A FP based on A FR s for processing spatial alarms. As shown in Figure 13(c), the message cost of Mondrian MPAT is smaller than Mondrian PAT because Mondrian MPAT considers moving direction and extends an A FR along the moving direction so that users may cross the border less frequently and also ask a new A FR less frequently than other approaches. Furthermore, extended A FR s based on Mondrian MPAT also provide longer A FP as shown in Figure 13(d) because it has a longer distance from the current location to the border of A FR . In this set of experiments, we compare the performance of distributed Mondrian Trees against the performance of centralized Mondrian index and hybrid Mondrian index. We set the number of users to be 5,000, the number of public alarms to be 100, and increase the number of private alarms per user from 0 to 10. Therefore the total number of alarms varies from 100 , (5,000 + 100) , (10,000 + 100) ,..., (50,000 + 100).
Figure 14(a) shows that the centralized approach has the longest total time for processing the same number of spatial alarms compared to distributed and hybrid approaches. This is because compared to distributed and hybrid approaches, the cen-tralized approach has longer A FR computation time. Figure 14(b) shows that centralized takes the longest time for computing A FR . If we add one additional private alarm to for all users, then the centralized approach needs to add 5,000 (1 alarm  X  5,000 users) more alarms in the tree. On the other hand, the hybrid and distributed approaches in-crease only 1 alarm. Similarly, when we add 10 additional private alarms per user, then the centralized approach will add 50,000 (10 alarms  X  5,000 users) more alarms. There-fore centralized has the worst performance. When there are 100% of public alarms, then there is no difference in each approach. Hybrid needs to check two trees: one for public alarms and the other for private alarms. Hence it takes more time than distributed . Figure 14(c) shows that the centralized approach has the smallest average A FR size. On 100% public alarms, the size of A FR is the same because each approach has the same alarms. When we assign one additional private alarm to each user, then centralized will have 5,000 more alarms while distributed or hybrid approach will increase by only 1 alarm. Therefore as we increase the number of private alarms per user, the average size of A FR in the centalized Mondrian Tree decreases dramatically. The smaller A FR is, the more frequently the client exits the current A FR , the more the client requests new A
FR s as shown in Figure 14(d). We performed a set of experiments to measure the performance of Mondrian* against Mondrian basic. Recall that Mondrian* has less number of nodes compared to Mondrian Tree as shown in Figure 7. The experimental results shown in Figures 15(c) and 15(d) prove that Mondrian* Tree has less number of nodes and shorter depth and takes smaller memory size on average. Thus, Figure 15(a) shows that compared to Mondrian basic, the Mondrian* Tree takes less total time for processing the same amount of alarms due to faster index search and due to shorter depth and less number of index nodes. Figure 15(b) shows that Mondrian* Tree also takes less time to compute the A FR due to fast index search. We have presented the design and implementation of the Mondrian Tree index, a fast index structure for scalable processing of spatial alarms. Compared with conventional spatial indexes, such as R-tree, Quadtree, and k -d tree, the main distinguishing feature of Mondrian Tree is that the Mondrian Tree approach indexes not only spatial alarms but also empty regions, which enables us to obtain the A FR s much faster compared to other spatial index data structures in which only alarms are indexed and A FR s are dynamically computed upon each wake of mobile clients. Another novelty of the Mondrian Tree indexing approach is its distributed version, enabling us to utilize the characteristics of spatial alarms to create and maintain one Mondrian Tree for each mobile subscriber. This is particularly effective when there is relatively small number of public alarms compared to the total number of private alarms in the system. We also provide a set of optimization techniques for scaling spatial alarm processing using Mondrian indexing, such as motion-aware A FP , extended A FR susingP AT and M
PAT , and Mondrian* Tree. Our experiments show that Mondrian Tree indexing can dramatically minimize the amount of unnecessary A FR computations and alarm checks, and is highly scalable for spatial alarm processing, compared to conventional spatial processing approaches based on R-tree, Quadtree, and k -d tree.

