
Giuseppe De Giacomo 1 , Marlon Dumas 2 , Fabrizio Maria Maggi The standard Business Process Model and Notation (BPMN) [ 13 ] and related approaches rely on an imperative paradigm wherein the process model cap-tures all allowed activity flows. Underpinning these notations is a  X  X losed world X  assumption, meaning that the process model captures all possible activity flows and hence any unspecified activity flow is disallowed. This paradigm has proved in essence one primary way of performing a process, with relatively few and well-scoped variations. imperative paradigm in the context of business processes with high variabil-patient treatment and related healthcare processes [ 17 , 19 ]. As an alternative, Guard-Stage-Milestones (GSM) [ 9 ] and the Case Management Model and Nota-tion (CMMN) [ 11 ]. Unlike their imperative counterparts, a declarative model captures a process under an  X  X pen world X  assumption, such that everything is allowed unless it is explicitly forbidden by a rule. In this context, a rule may take the form of a binary relation between pairs of tasks that must be satisfied in every execution of a process, like for example  X  X ask B can only be performed if task A has been previously performed in the same case X .
 and declarative process modeling is not crisp. Instead, mixtures of declarative and imperative modeling styles are sometimes preferable, leading to proposals tion of whether completely new notations are needed to support hybrid process modeling.
 ing BPMN with declarative constructs. The main contribution of the paper is an extension of BPMN, namely BPMN-D. BPMN-D is a conservative extension in the sense that it only adds constructs, such that any BPMN model is a BPMN-D model. Furthermore, BPMN-D is a macro-extension, i.e., it is designed so that any BPMN-D model can be translated into a (larger and potentially less readable) BPMN model. The paper also shows that any Declare model can be translated into a readable BPMN-D model via constraint automata. More gen-erally, any declarative process modeling language defined in terms of Linear Temporal Logic over finite traces ( ltl f ) can be translated into BPMN-D using the proposed translation method.
 ative process modeling  X  specifically the Declare notation  X  and discusses previ-ous research on linking declarative and imperative process modeling approaches. Section 3 introduces the BPMN-D notation and shows how the extended con-structs of BPMN-D can be re-written into standard BPMN. Next, Section 4 outlines the translation from Declare to BPMN-D. Finally, Section 5 draws con-clusions and outlines future work. Declare [ 1 , 14 ] is a declarative process modeling language wherein a process is specified via a set of constraints between activities, which must be satisfied by every execution of the process. Declare constraints are captured based on tem-plates. Templates are patterns that define parameterized classes of properties, while constraints are their concrete instantiations. Herein, we write template parameters in upper-case and concrete activities in their instantiations in lower-case. Constraints have a graphical representation. The semantics of templates can be formalized using different logics [ 12 ], for example Table 1 summarizes some Declare templates and their corresponding formal-The  X  , , ,and ltl f operators have the following intuitive meaning: for-mula  X   X  in the next position,  X  1 says that  X  1 holds forever, and, lastly, that sometime in the future  X  2 will hold and until that moment  X  and  X  2 ltl f formulas).
 Consider, for example, the response constraint ( a  X   X  b ). This constraint satisfied for traces such as t 1 = a, a, b, c , t 2 = b, b, c, d but not for t 4 = a, b, a, c because, in this case, the second occurrence of is not followed by an occurrence of b . A constraint can define more than one parameters branch out and, in the graphical representation, they are replaced by multiple arcs to all branched activities. In the ltl f semantics, the parameters are replaced by a disjunction of branching activities. For example, the semantics of the response template with two branches on the target parameter is ( A  X   X  ( B  X  C )).
 Example 1. Consider the Declare model that represents a fragment of a purchase order process, as shown in Figure 1 . The process is as follows:  X  a payment cannot be done until the order is closed ( precedence constraint);  X  whenever a payment is done, then a receipt or an invoice must be produced ( branching response constraint).
 Like any declarative model, this model should be interpreted according to an  X  X pen-world X  semantics: It is possible to send a receipt or an invoice without paying beforehand and, also, to close an order without eventually paying. In addition, an activity in the model can be executed several times. Closing an order several times has no effect on the process execution, whereas it is possible send invoices and receipts several times.
 dition Response Graphs (DCR) graphs [ 8 ]andGSM[ 9 ]. DCR graphs rely on binary relations between tasks (as in Declare) but employ a smaller set of five core relations and support decomposition (nesting). GSM differs from Declare and DCR in that it does not rely on binary relations. Instead it relies on three core concepts: guard, stage and milestone. A stage is a phase in the execution of a process where a certain number of tasks (or other stages) may occur in any order and any number of times (similar to ad hoc activities in BPMN). The opening of a stage is subject to one of its guards (event-condition rules) becoming true. The stage is closed when one of its milestones is achieved (i.e., becomes true). A milestone is also defined by means of an event-condition rule. The guards of a stage may refer to data associated to the process and/or to the status of other stages or milestones (e.g., whether a given stage is currently  X  X pen X  or  X  X losed X ). Tasks are modeled as atomic stages and may have their own guards and milestone(s). Several concepts proposed in the GSM notation have made their way into the CMMN standard [ 11 ].
 tives to imperative ones. Recent research though has put into evidence synergies notations have been proposed. In particular, [ 21 ] proposes to extend Colored Petri nets with the possibility of linking transitions to Declare constraints (in the same model). The notion of transition enablement is extended to handle declarative styles in the context of automated discovery of process models from sub-processes that can be either imperative (Petri nets) or declarative (Declare constraints). Meanwhile, the method in [ 6 ] discovers a process model with two types of arcs: imperative (sequence flows) and declarative (Declare constraints). idea is to first produce a Finite State Machine (FSM) from a Declare model using standard techniques for mapping regular expressions to automata. The FSM is then mapped into a sequential Petri net and methods related to  X  X heory captured. The resulting Petri net can then be mapped into other imperative process modeling notations (e.g., BPMN). A drawback of this approach is that the resulting Petri net is large and complex relative to the initial declarative model. This drawback is illustrated in [ 16 ] where a Declare model with 4 tasks and 7 constraints leads to an FSM with 10 states and 24 arcs. This FSM in turn leads to a Petri net with 25 transitions, 13 places and over 40 arcs. The issue at stake is that a given constraint may be satisfied by a large number of distinct possible execution paths. Capturing these paths in an imperative style leads to the case of Petri nets). This section introduces the BPMN-D notation and gives it a semantics by means of a translation from BPMN-D to plain BPMN, for which different formal seman-tics have been specified in previous work [ 7 ]. 3.1 Overview BPMN-D is an extension of BPMN partly inspired by BPMN-Q [ 2 ]  X  a language previously proposed to capture queries over collections of BPMN models. Like BPMN-Q, BPMN-D is a conservative (additive) extension of BPMN, implying that any BPMN model is also a BPMN-D model. Fig. 2 shows an example of a BPMN-D model. In particular, a BPMN-D model may have start and end event nodes , with the same semantics as in standard BPMN. For instance, in Fig. 2 , there is one start event and two end events. Similarly, behavioral XOR process execution, following the standard BPMN semantics of deferred choice As shown in Fig. 2 , the graphical representation for a XOR gateway is the same as in BPMN. In this paper, we only discuss XOR gateways as they are sufficient to demonstrate the extensions proposed in BPMN-D and the translation from Declare to BPMN-D. In the remainder of the paper, we denote by all tasks that can be performed in a given business context.
 sequence flows connectors. An activity node represents a task in the process, and is represented as a labeled, rounded rectangle. As in standard BPMN, this in turn corresponds to an execution step inside the process. Differently from BPMN, though, a BPMN-D activity node can be labeled not only with a single task name t  X   X  , but with a set T of multiple tasks, such that T is nonempty and does not coincide with  X  . When the label denotes a single task t , the semantics coincides with that of BPMN: the activity node is executed whenever whenever a task t is executed, such that either t  X  T ( inclusive task ), or ( exclusive task ). To distinguish between these two cases, a set-labeled BPMN-D is inclusive or exclusive. For example, in Fig. 2 ,the pay -labeled activity node indicates that a payment must be done, whereas the set-labeled activity node in performed. In addition to these three types of activity nodes, we consider also the case in which the process expects participants to do  X  X omething X , that is, to engage in an execution step by freely choosing a task from the global set this case, we assume that the activity node is just labeled with label different BPMN-D activity nodes are summarized in Table 2 .
 It indicates an ordering relationship between the connected nodes, and implicitly also the state of the process when the process has traversed the source node but has still to traverse the destination node. Differently from BPMN, in BPMN-D sequence-flow connectors do not only represent a direct ordering relationship (stating that the destination node comes next to the source one), but also a  X  X oose X  ordering relationship, which indicates that the destination node will be traversed after the source one, but that other BPMN-D tasks can be performed in between. First of all, BPMN-D supports the ordinary BPMN sequence flow, adopting its semantics and notation (a solid arrow from the source to the destina-tion node). Loose flow connectors are instead visually depicted as an interrupted solid arrow, and their specific semantics is defined by labeling and annotating the connector with additional information, similarly to the case of BPMN-D activity nodes. As summarized in Table 3 , three loose connectors are supported. with a set of T of tasks, and indicate that while moving from the source to the destination node along the flow connector, 0 or more repetitions of tasks respec-tively from or not in T can be executed. To distinguish between the two cases, the set T is also annotated with a property in or ex , so as to indicate whether connector indicates that when the process starts, 0 or more repetitions of tasks receipt and invoice may occur while moving to the first decision point. In addi-tion, we consider also the case in which while moving from a node to another node, 0 or more repeatitions of any task may occur. In this case, we assume that the flow connector is just labeled with label any , and we consequently call it any flow . 3.2 BPMN-D Models We now turn to the formal definition of BPMN-D model, substantiating the overview of the previous section. Given a set  X  of tasks, a BPMN-D model is a tuple N, type N , N ,F, type F , F , where:  X 
N is a finite set of nodes, partitioned into activity nodes, event nodes, and gateways.  X  type N is a total function from N to a finite set of node types ; the following types are considered in this paper:  X  atomic-task , in-task , ex-task ,and any-task for activity nodes  X  start and end for event nodes;  X  xor-split and xor-join for gateways.

We consequently define:  X  the set A of activity nodes as  X  N : A  X  X  X  2  X  is a function that assigns task names to activity nodes in  X  F  X  N  X  N is a set of flow connectors that obeys to the following restrictions:  X  type F is a total function from F to the finite set of flow connector types  X  F : F  X  X  X  2  X  is a function that assigns task names to flow connectors 3.3 Translating BPMN-D to Standard BPMN Any BPMN-D diagram can be faithfully represented as a (trace-equivalent) cor-responding standard BPMN diagram, at the price of conciseness. In this section, we discuss this translation, which has a twofold purpose: (i) it shows that, in principle, a BPMN-D process can be enacted on top of a standard BPMN engine; (ii) it provides an implicit execution semantics for BPMN-D in terms of standard BPMN.
 this respect, it is sufficient to discuss how elements annotated with have to be translated: each label of the kind ex ( T ) can be in fact equivalently re-expressed as in (  X  \ T ). As shown in Table 4 (top row), an inclusive task t , ..., t n is selected. An any -labeled task is translated in the same way, con-sidering all tasks in  X  as possible alternatives. The translation of an inclusive path sequence flow with label { t 1 ,...,t n } is also depicted in Table 4 (bottom row). In this case, two alternative behaviors are obtained: either the inclusive path sequence flow behaves as a normal sequence flow (thereby directly connect-ing node A to node B), or it allows the executors to repeatedly execute tasks t ,...,t n in between. As for tasks, also the case of a any handled in the same way, just considering all tasks in  X  as possible alternatives. Figure 3 shows the result obtained by applying this translation procedure to the BPMN-D model shown in Figure 2 . We now propose a translation mechanism that, given a declarative, constraint-based process model, produces a corresponding readable BPMN-D diagram that faithfully represents the original intended behaviors. As source language, we pinning the Declare notation. However, it is worth noting that our approach can adopted to formalize and monitor Declare constraints and meta-constraints [ 4 ]. ton that employs a form of declarative labels, and can therefore represent the given specification more compactly than for standard finite-state automata. In sponding BPMN-D model. Both steps are such that the produced model accepts exactly the same traces as the input model, in turn guaranteeing that the BPMN-D model is a faithful, equivalent representation of the input Declare model. phases. 4.1 From Declare to Constraint Automata It is well-known that a Declare model can be transformed into a corresponding finite-state automaton that accepts exactly those traces that satisfy all the con-straints present in the model [ 4 , 16 , 20 ]. A finite-state automaton (  X , S, I, F,  X  , where: (i)  X  is the alphabet of symbols; (ii) states ; (iii) I  X  S is the set of initial states ; (iv) F  X  S (v)  X  : S  X   X   X  2 S is the state transition function , which maps each state and symbol to a set of successor states. Hereby, we assume that symbols represent atomic tasks, and consequently that the symbol alphabet is constituted by all atomic tasks that can be executed in the targeted domain. The language of an fsa A , written L ( A ), is the set of finite traces (i.e., words) over accepted by A . The notions of deterministic finite-state automaton ( minimal automaton are as usual.
 can be determinized and minimized using standard techniques. This minimal dfa can be used to enact the Declare model [ 14 ]: at any time, the whether the process can be terminated or not, and indicates which tasks that can/must be executed next.
 the automaton is labeled with a single, atomic task. This means that the same pair of states can be connected through several transitions, each associated to a different task. All such transitions connect the same source state to the same destination state, and hence express different ways to achieve the same  X  X ffect X  on the process. This closely resembles the notion of inclusive task in BPMN-D. To fully exploit this analogy, and make the automaton closer to BPMN-D, we introduce a variant of finite-state automata, called constraint automata . Differ-ently from fsa s, constraint automata are finite-state automata whose transitions are associated to  X  X eclarative X  labels, each of which acts as a constraint on the automaton moves from one state to a successor state if the next symbol analyzed satisfies the constraint C attached to the corresponding transition. Given a task alphabet  X  , we consider the following task constraints ,which are directly inspired from BPMN-D and consequently provide the basis for a natural translation of constraint automata to BPMN-D:  X  t , with t  X   X  ; an atomic task t  X   X  satisfies t iff t = t  X  in ( T ), with  X  X  X  T  X   X  ; an atomic task t  X   X  satisfies in ( T )iff  X  ex ( T ), with  X  X  X  T  X   X  ; an atomic task t  X   X  satisfies ex  X  any ; every atomic task t  X   X  satisfies any .
 Intuitively, t represents the execution of an atomic task, of a task belonging to the set T of alternatives, ex ( T ) the execution of a task that does not fall inside the set T of forbidden tasks, and some task. Like for BPMN-D, the following correspondences hold, consistently with the notion of satisfaction as defined above: (i) t = ex (  X  \ T ).
 In the following, we denote by C  X  the set of all possible constraints that can be expressed over  X  . Technically, a finite-state constraint automaton ( a tuple  X , S c ,I c ,F c , X  c , c , where: (i)  X  is the (task) alphabet; (ii) set of states; (iii) I c  X  S c is the set of initial states; (iv) states; (v)  X  c  X  S c  X  S c is a transition relation between states; (vi) is a labeling function that, given a transition in  X  c , returns a task constraint over  X  .
 Given a finite trace  X  = t 1 ,...,t n over  X  , we say that A if there exists a sequence of states s 1 ,...,s n +1 over I ; (ii) s n  X  F c ; (iii) s i ,s i +1  X   X  c for i  X  X  1 ,n } ( s A , written L ( A c ), is the set of finite traces over  X  that are accepted by say that A c is a deterministic constraint automaton ( dca every state s  X  S c and every task t  X   X  , there exists at most one state such that s, s  X   X  c and t satisfies ( s, s ). If this is not the case, then nondeterministic constraint automaton ( nca ).
 It is important to notice that in a constraint automaton, at most one transi-connecting the same pair of states can be compacted into a unique transition labeled with a constraint obtained from the combination of the original labels. We make this intuition systematic by introducing a translation mechanism that, given a standard finite-state automaton on  X  , produces a corresponding con-straint automaton that employs the  X  X ost compact X  constraints on arcs. In this context,  X  X ost compact X  means that the constraint explicitly refers to the min-imum number of tasks in  X  . For example, if  X  = { a, b, c } over the equivalent constraint in ( { b , c } ).
 The translation mechanism is defined in Algorithm 1 , and it is straightfor-ward to prove that it enjoys the following key properties: Lemma 1. For every fsa A :(i) fsa2ca is correct , i.e., L (ii) fsa2ca preserves determinism, i.e., if A is a dfa , then fsa2ca The mechanism of transition compaction shown in Algorithm 1 can be either applied on-the-fly, during the construction of the automaton starting from the Algorithm 1. Translation of a standard fsa to an equivalent Declare model, or as a final post-processing step (using fsa2ca strategies do not affect the computational complexity of the automaton construc-tion, and do not interfere with determinization (cf. Lemma 1 ). Furthermore, the correctness of fsa2ca guarantees that, after this first phase, the input Declare model is transformed into a constraint automaton that accepts exactly the same behaviors.
 showninFigure 1 , assuming  X  = { close order , pay , receipt alphabet. 4.2 From Constraint Automata to BPMN-D The algorithm for translating a constraint automaton A c into a corresponding BPMN-D specification M is described in this section. We assume that the input constraint automaton is deterministic, and thus the unique initial state of corresponds to a single start event node in M . Consistently with the fact that automata are centered around states, while BPMN (and hence also BPMN-D) is centered around tasks, the translation maps states of A of M , and transitions of A c into activity nodes of M .
 to see that the translation is linear in the size of the input automaton (measured by considering the number of its states and transitions). Each state is handled according to the following rules: (1) State s is mapped to a flow connector f s that connects a dedicated xor-join in ( s ) to a dedicated xor-split out ( s in s , while out ( s ) accounts for the outgoing transitions from self-loop t , then the type and label of f s are set according to the constraint satisfying c are executed, the process continues to stay in state means that it is still flowing through f s . If instead s start event node of M is connected with a sequence flow to this models that when the process starts, it immediately flows through s is an output state, then out ( s ) is connected with a sequence flow to an end flowing through f s , the process executors can decide to terminate it. Each transition s 1 ,s 2 of A c that is not a self-loop (i.e., such that is then simply managed by: (1) introducing a corresponding activity node in M , whose type and label is determined according to the constraint attached to the transition (cf. lines 24 -27 ); (2) connecting out ( the activity node, and the activity node with another sequence flow to reconstructing the state transition triggered by the constraint from which the activity node is derived (cf. lines 28 -30 ).
 Obviously, the technique so presented may lead to introduce several  X  X ncon-sistent X  x-or split and join gateways with only one input and one output attached removing all such unnecessary gateways (cf. the remove-unnecessary-xor procedure on line 31 of Algorithm 2 ). This is quite straightforward, hence its actual code is omitted.
 By considering the language of a dca , and by modularly applying the trans-lation procedure from BPMN-D to BPMN of Section 3.3 to the BPMN-D frag-ments produced by the different components of Algorithm 2 ,wehavethat: Lemma 2. The fca2bpmnd procedure is correct: for every dca ( dca ) produces a proper BPMN-D model (according to the definition of Sec. 3.2 ), which accepts all and only the traces in L ( dca ) .
 We close this section by illustrating, in Figure 5 , the result of the procedure the fca of Figure 4 . 4.3 The Whole Translation Procedure By combining the contributions of Sections 4.1 and 4.2 , we can finally set up the whole translation procedure declare2bpmnd , which transforms a Declare model into BPMN-D, as shown in Algorithm 3 . The following key result witnesses the correctness of this transformation: Theorem 1. declare2bpmnd is correct: for every Declare model BPMN-D model produced by declare2bpmnd accepts all and only the traces accepted by D .
 Algorithm 2. Translation of an fca to BPMN-D Proof. First of all, by Lemma 1 , since fsa2ca is applied on minization, also the produced constraint automaton is actually an obtained from [ 4 ], and that of line 7 is obtained by applying Lemma 1 and 2 . We have provided elements to support a negative answer to the original question:  X  X re completely new notations needed to support hybrid process modeling? X . The definition of BPMN-D as a conservative extension to BPMN shows that Algorithm 3. Translation of a Declare model to BPMN-D  X  X pen-world X  modeling constructs can be embedded into existing imperative process modeling notations without fundamentally extending their semantics. Indeed, the proposed BPMN-D notation is a macro-extension of BPMN. More-over, we have shown that this notation can capture the range of constraints present in the Declare notation in an intuitive manner.
 In its present form, the translation from Declare to BPMN-D generates pro-cess models with exclusive (XOR) gateways only, thus without parallelism. A direction for future work is to extend this translation with the ability to gener-ate BPMN-D models with inclusive and parallel gateways. A possible approach is to adapt existing techniques from theory of regions [ 3 ], which extract paral-to unreadable process models as put into evidence in [ 16 ]. However, if we take constraint automata as a basis  X  as in our translation approach  X  it may be pos-sible to adapt techniques from theory of regions to produce simpler constraint-annotated Petri nets that explicitly capture parallelism, and from there we could generate a BPMN-D process model.

