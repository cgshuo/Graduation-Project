 1. Introduction
Recent developments in telecommunication and computer science along with the availability of new and cheaper technolo-gies are radically impacting the management of chronic diseases, broadly exploded with longer lives, by enabling the successful provision of services for Remote Health Monitoring (in the following, RHM). RHM of patients affected by chronic illness has been expected to increase the individual  X  s comfort, enhance quality of life, and encourage patient empowerment, while redu-cing the number of needless transfers at hospitals and the cost of provided healthcare services ( Kumar et al., 2013; Lee et al., 2009;
Osmani et al., 2013; Palaniswamy et al., 2013 ). RHM paradigm strongly relies on a new generation of medical devices designed to enable long-term, continuous, and unobstructed monitoring of physiologic information and, contextually, provide more realistic indication of the patient  X  s health status, otherwise inaccessible in clinical settings ( de Toledo et al., 2006; Rajan and Rajamony, 2013;
Logan, 2013; Tamrat and Kachnowski, 2012; Mart X nez-P X rez et al., 2013 ).

However, gathering, processing and correlating data coming from these new medical sensors in order to infer information about the patient's condition represent undoubtedly a very costly and complex process.

In this respect, the real added-value could be supplied by intelligent components, in the form of Decision Support Systems (in the following, DSSs), able to automatically process and corre-late huge volumes of monitored physiologic parameters, detect suspicious changes and supply alarms as a response to a worsen-ing of the patient  X  s status, plus suggestions about the actions to take. The potential for RHM applications integrating DSSs is well-documented ( Mart X nez-P X rez et al., 2014 ) and can ease personalized diagnoses and treatments, predict patient status and follow-up based on multi-level observations, and empower patients to actively participate in their health.

So far, a good number of intelligent RHM applications has been proposed ( Babu et al., 2013; Lee et al., 2007; Prasad et al., 2013; Won-Jae Yi et al., 2014; Xiaohui et al., 2012 ). Some of them are characterized by a centralized architecture that requires perma-nent communication between local sensing-data sources and remote decision support components, so implying sophisticated and reliable mechanisms for handling data losses or delays in the information fl ow. The remote decision support components are typically based on desktop-oriented reasoning systems equipped with knowledge management tools, aimed at automating the inference process of complex sensed data depending on a knowl-edge base (in the following, KB). Other existing RHM applications rely on distributed mobile agents able to process and exchange information in a recon fi gurable platform so increasing scalability and reliability of provided services ( Su, 2008; Kulkarni et al., 2014;
Su and Chiang, 2014 ). Such intelligent RHM applications have been reviewed for being applied to care delivery and management in cases of chronic diseases ( Par X  et al., 2007 ). A comparison of these applications has been also proposed in ( Pawar et al., 2012 ) with respect to their communication facilities, e.g. sensors and back-end servers. Moreover, a study about how the reduction of information transmitted over networks and presented to healthcare profes-sionals actually improves the quality of mobile health applications is diffusely described in ( Varshney, 2014 ). Finally, a review of the literature about existing mobile systems and applications dedi-cated to the medical decision support, as well as mobile apps currently available on the most used app stores has been proposed in ( Mart X nez-P X rez et al. 2014 ).

In this respect, even if, a centralized and/or cloud infrastructure can limit the resource consumption to locally perform the intel-ligent data processing, by demanding reasoning functionalities to some remote nodes, it cannot be pro fi ciently applied to many real situations. First, the necessity to communicate with a remote node for processing users  X  contextual and situational changes intro-duces an undesirable overhead for properly facing the rapid response time challenges of highly dynamic scenarios ( Steller and Krishnaswamy, 2009 ). In particular, on the one hand, the overhead involved in relaying raw unprocessed data can be very high, since such data fl ow through the network and can eventually cause congestion. On the other hand, also the intelligent data processing overhead at the remote node can act as a bottleneck in the RHM application ( Tai et al., 2013 ). Furthermore, users extremely sensitive in medical settings, and the needs of transmit-ting them to a remote node could also raise privacy concerns for the users ( Kleemann, 2006 ). Indeed, users could (rightly) be uncomfortable with sharing certain information outside of the mobile device ( Woensel et al., 2014 ).

Second, this paradigm relies on the availability of a reliable network connectivity with a remote reasoning infrastructure.
However, in some critical health scenarios, network connections established to reach a remote node could be not adequate, irregular or not feasible. For instance, in emergency medical care situations, the RHM application can make use only of a GSM network connection. This connection should prioritize the trans-mission of critical data, such as the real-time change in patient status, in order to promptly support the ambulance crew in the process of extrapolating or inferring what they need as a guide to the decision that re fl ects the reality of the given situation. In these scenarios, indeed, the role of ambulances and paramedics in the provision of emergency medical care is recognized as fundamental ( Anantharaman and Swee Han, 2001 ), especially in patients experiencing an acute episode of their chronic illness, since urgent medical treatments can create the potential for better outcomes and lesser mortality and morbidity. Nevertheless, existing GSM networks provide only  X  best effort  X  service and do not explicitly provide for prioritized traf fi c, which is critical for emergency medical care situations.

As a consequence of that, in the case of network disconnec-tions, RHM applications could completely fail without providing the requested decision support to the users.

In order to face such issues with continuous supporting services, the architectural paradigm used to build RHM applica-tions has been sensibly changed to retain part (or all) of intelligent data processing over mobile devices, which, meanwhile, have dramatically improved their communications and processing capabilities. Embedding knowledge-based decision support com-ponents over mobile devices can allow locally performing an accurate and continuous analysis of the patient's health status, by minimizing network transmission, avoiding communication delays or interruptions and maintaining appropriate levels of security and privacy. As a consequence of that, decision support could be timely supplied, even in cases where connectivity is lacking, so lessening non-(or too late) raised alerts, which could negatively impact the patient  X  s health ( Woensel et al., 2014 ). decision support components are likely to exceed the simple storage and retrieval of information. Thus, the critical point, still pending to date, regards the de fi nition of reasoning systems based on semantic technologies able to ef fi ciently deal with as well as reason over sensed data directly on the mobile devices and identify the appropriate suggestions, reminders or alerts. incremental reasoning, can be adopted in the construction of knowledge-based decision support components for RHM applica-tions ( Woensel et al., 2014 ).
 hereafter referred as computation intensive , where signi quantities of varying data are fi rst collected and, successively, at a certain time frequency, for instance, once a minute or even hourly or daily, they are processed jointly to infer a more complete indication about the patient  X  s health status, implying a high computational complexity. For these RHM scenarios, reasoning systems operate periodically on the collections of sensed data and have to guarantee a response within acceptable, but not strict, time constraints. Thus, they can be dynamically deallocated and reinstantiated every time depending on their frequency of invoca-tion in order to preserve the memory utilization.
 referred as real-time , where sensed data change very frequently (e. g. fresh readings are produced by sensors several times per second and assume different values from the previous ones) and are processed immediately to produce a real-time response. For these
RHM scenarios, reasoning systems are continuously invoked every time new data are sensed and have to respond to data changes in a timely manner. Thus, they have to be kept in memory and dynamically reapplied in order to infer new suggestions, remin-ders or alerts within strict time constraints.
 two typologies of reasoning ( Ali and Kiefer, 2009; Gu et al., 2007;
Kim et al., 2010; Lorecarra, 2009; Jang and Sohn, 2004; Tai et al., 2011; Motik et al., 2012 ). Nonetheless, from a theoretical point of view, their performance on mobile devices and under a realistic
RHM scenario is unlikely to achieve acceptable levels with refer-ence to responsiveness and memory consumption, since strongly in fl uenced by various factors, such as the reasoning algorithms used and the data scale. Indeed, most of them rely on reasoning algorithms that are too resource-intensive to be applied either to real-time and frequently varying RHM scenarios or to computation intensive RHM scenarios operating with considerable amounts of slowly changing data.
 have been optimized for mobile devices to ef fi ciently exploit their available resources, or simply ported from desktop-oriented implementations ( Woensel et al., 2014 ). A study reported in ( D  X  Aquin et al., 2010 ) has shown that semantic-enabled reasoning can take several tens or hundreds of KB of memory per elementary data. Hence, reasoning over a set of sensed data, even if not extremely large, but directly on a mobile device, can easily drain its memory resources, even on latest high-end models where the total memory size has reached 1 GB or more, because the quantity of memory available to the user applications is, however, limited.
For example, Samsung's latest offering, the Galaxy S5, has a quad-core, 2.5 GHz processor and 2 GB of RAM, more than a 8-fold increase in processing power and 4-fold increase in capacity in 5 years ( Patton and McGuinness, 2014 ). Nevertheless, the amount available to the user applications has actually decreased, reaching some tens of MB. A variety of reasons exists for this. In addition to the fact that the amount of memory used by the modern Operat-ing Systems for mobile devices, such as Android, has been increasing with almost every version upgrade, the amount of memory needed by applications at run-time has been increasing owing to the improvements in display resolution and system performance. Moreover, the number of simultaneously running applications has been increasing. As a result, in the case when an application exceeds the memory size allocated for it and the amount of available memory falls below a threshold, other appli-cations are terminated to release their resources. Obviously, an increasing request of new memory available to an application represents an overhead that can compromise the overall correct working of the device.

According to such considerations, this paper presents a light-weight rule-based reasoning system, purposely designed and optimized to build knowledge-based DSSs ef fi ciently embeddable in mobile devices with the aim of enabling the realization of both computation intensive and real-time RHM applications.

The key issues of such a system are a domain-independent reasoning algorithm and knowledge representation capabilities, which can be speci fi cally applied to support both frequent reason-ing and incremental reasoning in computation intensive and real-time RHM scenarios. In more detail, a novel rule-based reasoning algorithm based on a lazy evaluation ( Weert, 2010 ) has been de fi ned and implemented to be ef fi ciently run on mobile devices, by reducing the space complexity and improving the response time. Moreover, the system also offers capabilities to manage ontology-models, encoded according a light-weight standard-oriented language, and if-then rules expressed in a very straight-forward and easy-to-parse syntax, including directives to add or delete data instances according to a non-monotonic perspective.
The remainder of the paper is structured as follows. Section 2 reviews and compares existing light-weight languages and sys-tems for knowledge representation and reasoning. Section 3 presents the architecture of the proposed rule-based reasoning system, including the knowledge models adopted. The lazy rea-soning algorithm is diffusely described in Section 4 . Section 5 details a performance evaluation of the system implemented.
Finally, Section 6 concludes the work. 2. Background on light-weight knowledge representation and reasoning
Generally speaking, reasoning systems employing knowledge representation techniques are signi fi cantly in fl uenced by typical scenarios for which they should be most effective and ef fi
Thus, with reference to intelligent RHM applications, reasoning systems have to be purposely devised to face the requirements of mobile devices in both computation intensive and real-time scenarios, where frequent reasoning and incremental reasoning are required, respectively. In these scenarios, two different issues have to be addressed, namely how to optimally represent informa-tion in mobile devices and how to ef fi ciently reason on it without overwhelming their resources. So far, both these issues are still open challenges, even if some approaches have been addressed in literature.

From a knowledge representation perspective, existing techni-ques are properly adopted depending on the domain of interest and, mainly, on the practical requirements of the fi nal application itself. In more detail, in the last decade some specially-designed languages have been proposed, in order to represent speci medical knowledge, such as Asbru ( Young et al., 2007 ) and PROforma ( Fox et al., 2006 ). These languages are mainly focused on acquiring and representing clinical work fl ow information modeled in terms of a complex fl owchart-like structure, rather than condition-action guidelines, which are the most suitable way to detect whether a speci fi c critical situation is happened in RHM scenarios.

Condition-action guidelines represent elementary, isolated care recommendations, which specify one or at most a few conditions which are linked to speci fi c actions ( Shiffman, 1997 ). The form of representation mostly accepted in medical settings for encoding condition-action guidelines consists in representing declarative knowledge (i.e. the structure of the domain knowledge) in form of ontology-based models, whereas procedural knowledge (i.e. the knowledge about the decision making process) as a set of if-then rules built on the top of such models, according to the awareness that the combination of more representation techniques fre-quently perform better than the individual ones ( Arguello Casteleiro et al., 2009; Kong et al., 2008; Straszecka, 2004; Ting et al., 2011 ).

With reference to standard-oriented languages for encoding such portions of knowledge, OWL (Web Ontology Language) ( Patel-Schneider et al., 2004 ) is the ontology language, endorsed by The World Wide Web Consortium (in the following, W3C), for enabling the semantic de fi nition of declarative knowledge in the form of a vocabulary, by specifying a set of modeling primitives. OWL needs a particular syntax in order to store and exchange ontologies among applications. The most used representation is RDF/XML ( RDF/XML Syntax Speci fi cation, 2004 ), but the space complexity of its hierarchical structures and, contextually, also the time required for inserting and manipulating models according to its syntax make it not feasible for mobile devices, especially in computation intensive scenarios where frequent reasoning is required. Indeed, in these situations, the whole reasoning engine is instantiated from scratch each time it is invoked and, thus, ontologies and rules have to be frequently reparsed and reloaded. This represents a relevant overhead that could imply the genera-tion of a fi nal response outside an acceptable time constraint in the case when a heavy-weight syntax such as RDF/XML is used for representing OWL ontologies.

A valid alternative, best suitable to the mobile devices, in general, and, more in particular, to computation intensive RHM scenarios, is N-Triples ( RDF Test Cases, 2004 ), that is a line-based, plain text serialization format for ontologies, which is light-weight and, thus, easier to parse and process.

On the other hand, one of the most adopted rule languages for encoding procedural knowledge is SWRL (Semantic Web Rule Language) ( Horrocks et al., 2004 ), proposed for use by the Semantic Web Initiative of W3C, whose model-theoretic semantics is a straightforward extension of the semantics for OWL. Indeed, rules are given a standard fi rst order semantics, where ordinary predicates are limited to being OWL classes and properties. Nevertheless, with reference to a non-monotonic perspective, negation as failure as well as directives to retract or remove knowledge are not foreseen, so implying the impossibility to support incremental reasoning. Moreover, its syntax, which can assume two different forms (i.e. XML-based or OWL RDF/XML-based), is excessively time and space consuming. Thus, similarly to RDF/XML, also SWRL is considered not appropriate for being used on mobile devices, especially in real-time RHM scenarios where frequent reasoning is applied and rules have to be recurrently reparsed and reloaded.

Another solution, diffusely used in intelligent desktop applications, is the Jena rule language ( Carroll et al., 2004 ). Its model-theoretic semantics is also an extension of the semantics for OWL, but its ordinary predicates can be selected between classes and properties encoded as N-Triples. The Jena rule language is suitable for being ef fi ciently parsed on resource-limited settings since its syntax relies on a line-based and plain text format. Moreover, it includes non-monotonic directives for incremental reasoning, such as assertion and retraction (for adding or deleting a statement according to new input data, respectively), and negation-as-failure (for determining negative information in the case of not completely represented knowledge). However, its expressiveness (e.g. rules encoded according to forward chaining, tabled backward chaining and hybrid execution strategies) is oversized with reference to the possible reasoning mechanisms deployable on mobile devices.

With respect to the issue of straightforwardly enabling automated reasoning on the top of knowledge representation languages, some systems speci fi cally devised to mobile devices have been already proposed in the literature. In the following, only mobile reasoning systems ( Ali and Kiefer, 2009; Gu et al., 2007; Kim et al., 2010;
Lorecarra, 2009; Tai et al. 2011; Motik et al. 2012 ) expressly devised as rule-based, i.e. having if-then rules as their basic unit of computa-tion, have been analyzed, since mostly suitable to deal with declarative and procedural knowledge. A particular emphasis in the description is givenonthepatternmatchingalgorithmsadoptedtodeterminewhich rules can be executed, by comparing and matching rule predicates with current data instances.

The fi rst reasoning system is named  X  OR ( Ali and Kiefer, 2009 ), which is properly designed for Java enabled mobile devices. It automatically generates speci fi c inference rules for dealing with ontology-based models, even if including the semantics of only a subset of OWL. As a result, it does not directly operate on user-de fi ned rules, but it behaves as a resolution-based OWL reasoner.
This system employs a na X ve pattern matching algorithm, which simply iterates over all rules comparing each rule predicate against all the existing data instances. Thus, the number of com-parisons required to test the satisfaction of a rule grows expo-nentially with the number of predicates ( Miranker et al., 1990 ), making the algorithm computationally intractable due to this combinatory complexity and, hence, not feasible for real-time applications.

The mobile system proposed in ( Gu et al., 2007 ) provides ontology processing and reasoning. Similarly to  X  OR, it is used to operate on a subset of OWL ontology inference rules. It contains a rule engine, adopting RETE ( Forgy, 1982 ) as pattern matching algorithm. RETE, diffusely used in desktop applications, reduces the number of comparisons required to test the satisfaction of a rule, by maintaining a cache of intermediate results generated during the matching process. However, it is not optimized to ef fi ciently scale-up to large rule bases, as the memory usage required to maintain this cache increases dramatically, so limiting its ef fi ciency in resource-limited mobile devices. Moreover, several studies have highlighted how RETE reveals to be often counter-productive in highly dynamic scenarios, where the data instances are regularly updated in a not-incremental manner ( Weert, 2010;
Miranker et al., 1990; Miranker, 1987 ). Indeed, according to its optimization strategy, RETE fi res a rule between a list of executable candidates that have been preliminarily computed. However, the remaining candidates could be invalidated, and, thus, never as a consequence of the execution of the previous rule, so implying a useless waste of memory and computational resources.
MiRE4OWL ( Kim et al., 2010 ) is a rule-entailment OWL rea-soner developed in C  X  X  according to a light-weight design to cope with the resource constraints of mobile devices and guaran-tee a semantic expressiveness by implementing a subset of the
OWL semantics. The rule syntax provides expressive description mechanisms, by adopting different kinds of non-monotonic opera-tors and quanti fi ers to support practical logic operations, as well as a procedure attachment mechanism for handling external infor-mation. Moreover, it offers a RETE-based rule engine with some basic mechanisms to reduce the memory usage by optimizing the handling of data instances. However its RETE implementation is not optimized and, therefore, it is likely that inef fi cient pattern matches may occur if rules are not tuned by experts ( Tai et al., 2011 ).
 proposed as a new reasoning system based on a subset of the popular Jena framework, migrated to Android platforms ( Android, 2008 ). It includes a rule engine able to provide both forward and backward chaining, respectively based on a version of the RETE algorithm, optimized for supporting incremental changes due to the addition or removal of data instances, and Logic Programming.
In addition, the rule engine supports a hybrid execution model, where both mechanisms are employed in conjunction. However, it is not clear to what extent Androjena has been optimized for mobile devices or simply ported from its desktop-oriented imple-mentation ( Woensel et al., 2014 ).

Reasoner for resource-constrained devices. It makes use of two composition algorithms, i.e. a selective rule loading algorithm and a two-phase RETE algorithm. Instead of selecting a static reasoner con fi guration, or selecting a-priori from a set of known reasoners or reasoner con fi gurations, it dimensions the OWL entailment rule set and the reasoning algorithm on-the-fl y during the execution, by considering the particular semantic features of the ontology to be reasoned. However, COROR has been thought to work only on static ontologies rather than on changing knowledge bases, since its two-phase RETE algorithm enables to handle additions incre-mentally, but it does not offer truth maintenance mechanisms for avoiding logical errors when data are deleted.
 designed to support context-aware applications running on mobile devices. It uses RDF as the basic data model, and OWL for representing the necessary background knowledge in the form of an ontology. It has been designed to operate with knowledge bases not too large but changing very frequently, by employing an incremental reasoning algorithm able to ef fi ciently handle updates, consisting in data additions or removal. In particular,
Delta-Reasoner uses incremental reasoning to just compute the difference between the old and the new set of consequences drawing from its ontology, so limiting the computation load imposed on the limited resources of mobile devices.
 desktop-oriented system which exposes a native support for reasoning over OWL ontology models and SWRL rules. Since its runtime memory footprint is about 750 Kb, it runs also on mobile devices equipped with J2ME platform. Bossam is also built on a
RETE-based rule engine, but it is not expressly thought to run on mobile devices, since it is mostly focused on providing web-friendly and distributed reasoning facilities.
 the knowledge representation perspective, most of these existing reasoning systems do not support light-weight languages for representing both declarative and procedural knowledge, and, in particular, in the cases when they are able to deal with simple ontology-based models, they cannot handle light-weight rules also including non-monotonic directives.
 very expensive time and space demands for generating their inferences. Indeed, even if most of them implement RETE as pattern matching algorithm, which is very ef fi cient on desktop systems, it is entirely possible for them to result ineffective and wasteful in both computation intensive and real-time RHM scenarios where sensed data have to be processed on mobile devices.

Indeed, RETE, and its different implementations or optimiza-tions, performs an eager evaluation to determine which rules can be executed, by trading space for time: matching rules are incrementally cached for subsequent re-use, and, hence, the memory cost rapidly increases in computation intensive scenarios where a considerable amount of sensed data have to be jointly processed. Moreover, in real-time scenarios where a great number of sensed data changes frequently and, then, their values have to be modi fi ed, an eager evaluation results very expensive. Indeed, updating and deleting existing data are computed in a symmetric manner and, thus, equally in fl uence the process of recomputing the set of rules that could be executed, since they require the same sequence of operations to be performed, without any form of optimization.

This issue implies that not only are they not optimized to reason within a prescribed time and given constraints on the processing power and memory usage, but also they might unex-pectedly exhaust all of the available runtime memory of mobile devices when the search space in terms of the size of ontologies and reasoning complexity increases, corrupting their normal functioning. Thus, there is a need for optimized on-board reason-ing approaches that performs better than currently available solutions with the goal of meeting both the rapid response time and computation intensive challenges of highly dynamic mobile environments ( Steller and Krishnaswamy, 2009 ).

Summarizing, all these considerations represent the rationale for the reasoning system proposed in this work. 3. The system architecture
The proposed mobile reasoning system has been designed to support inferential reasoning procedures in mobile DSSs with the fi nal aim of monitoring the health status of chronic patients. It relies on if-then rules as its basic unit of computation and employs a forward chaining scheme, i.e. a data driven method that can be described logically as repeated application of the generalized modus ponens. In detail, the inferential reasoning process realized is represented by a cyclic repetition, typically referred as recognize-act cycle, made of two main phases, namely pattern matching and rule fi ring , as depicted in Fig. 1 .

In the pattern matching phase, the reasoning system looks for the fi rst applicable rule instance , also referred as rule activation , which consists into a couple made of a rule and the set of available data, representing the current system state, that satis fi ( Brant and Miranker, 1993 ). In more detail, according to a priority-based strategy, a rule activation is identi fi ed and selected as the fi rst applicable one in the case when it is matched by the most recent data characterizing the system state. Then, in the rule phase, the system executes the matched rule activation, updates its state and cycles back to the pattern matching phase. As a result, each rule activation is fi red as soon as it is matched against the system state, so granting a better performance in terms of response time.

It is worth noting that, differently from the typical recognize-act cycle, in the pattern matching phase, the proposed system does not search for the collection, typically referred as con fl rule activations matched against the available data representing its state. Indeed, after each new data insertion, modi fi cation or removal, the con fl ict set could be updated and, even, invalidated, before selecting a next rule activation to execute. For this reason, the proposed system avoids calculating many rule activations that could never fi re, because they soon could become inapplicable again. Such a way, it aims at optimizing the pattern matching, which is an NP hard combinatory problem and the most computa-tion intensive and time-consuming part of the reasoning process ( Tambe et al., 1992; Forgy, 1979 ), by not wasting time and memory resources computing super fl uous rule activations.
 The main components of the reasoning system are shown in Fig. 2 .
The Knowledge Manager (KM) provides the main interfaces between the reasoning system and the other application layers. The KM is responsible of managing the knowledge base reposi-tories, and it can be invoked by the other components in order to visit or update the current system knowledge. In this respect, the Working Memory (WM) is the repository containing (i) the termi-nological knowledge, which describes the speci fi c domain in terms of classes and properties, and (ii) the assertional knowledge, which consists in new patient's data coming from sensing devices, encoded as individuals (instances of concepts) with the corre-sponding instances of properties. All this information is arranged into the WM as a collection of facts, i.e. N-Triples composed by subject, predicate and object elements associated to RDF resources or literals. In other words, each WM element (WME) contains its N-Triple representation and, also, a univocal and growing ID used as timestamp of any alteration of the WM. This choice of model-ling facts as N-Triples is motivated by the need of drastically improving the knowledge insertion into the WM and the knowl-edge manipulation in the pattern matching phase, thanks to the use of simple and light-weight data structures, as introduced into Section 2 .

The Rule Memory (RM) is the repository where production rules (i.e. if-then rules) are stored. In particular, pushed by the need of a light-weight as well as expressive formalism, a speci fi c syntax has been de fi ned as reported in Fig. 3 .

According to such a grammar, a rule is made by a conjunction of condition elements (CEs) in its antecedents or left-hand side (LHS), and a set of actions in its consequents or right-hand side (RHS), respectively. Three kinds of CE can be used, namely triple pattern, negated triple pattern and function call.

A triple pattern (TP) is de fi ned as an N-triple object with the additional property that it can contain variables instead of only static values. Variables are indicated using the standard conven-tion of pre fi xing them with a question mark. A triple pattern can be inserted in both the LHS and RHS of a rule. In the fi rst case, it indicates a test for the existence of facts in the WM matching it. In the other one, it implies its assertion in the WM as a new fact. A negated triple pattern can be used only in the LHS of a rule and indicates a test for the absence of facts in the WM matching it according to the negation-as-failure strategy.

Function calls enable to invoke internal procedures able to evaluate logical conditions, compute arithmetic expressions, and assert and retract facts according to a non-monotonic strategy.
The proposed rule syntax has been designed as a re-arranged subset of the Jena rule language ( Carroll et al., 2004 ), including only the minimal expressiveness required to completely model procedural knowledge in the domain of interest and to be contextually processed by the reasoning algorithm that will be described in the next Section. The selected subset can be pro used for modelling diagnostic and therapeutic clinical guidelines distilled in terms of a set of condition-action clinical rules ( Peleg et al., 2003; Minutolo et al., 2012 ). It has a line-based and plain text format suitable for being ef fi ciently parsed on resource-limited settings, especially in scenarios where frequent reasoning is applied and rules have to be reloaded frequently. Plus, as abovementioned, it also offers non-monotonic directives, such as assertion, retraction and negation-as-failure, which are necessary to support incremental reasoning.

Furthermore, the KM is responsible of loading the terminolo-gical knowledge from an OWL ontology, rearranging it as N-triples and storing these latter as facts into the WM. N-Triples has been chosen as syntax for representing OWL ontologies, because it is light-weight and easier to parse and process. Thus, it can be ef fi ciently used in situations where frequent reasoning is requ-ested and, thus, ontologies have to be reloaded repeatedly.
The KM also initializes the RM with production rules encoded according to the proposed syntax. Furthermore, it populates the
WM with a set of individuals of the ontology concepts according to the patient's data coming from sensing devices. In particular, the values associated to the input data are assigned the corresponding properties of the de fi ned individuals, which are fi nally added to the WM as new facts. Finally, the KM also updates the WM with the inferred facts, i.e. the new facts generated at the end of the reasoning process.
 the basic terms composing the domain knowledge structure, the properties of these terms, i.e. attributes, and the relationships between them. It is important to note that the system does not include any ontology inference engine, and the ontology is used as a dictionary enabling users to de fi ne procedural inferences built above the ontology layer.
 since it holds the intrinsic ability to express ontological de by means of the so-called entailment rules ( Hayes, 2004 ; Horst, 2005 ), i.e. directional relations between expressions belonging to different knowledge representation formalisms, where the mean-ing of an expression can be entailed from the meaning of another one.
 mented, which map only ontological constructs and axioms belonging to the subset of OWL named Description Logic Programs (hereafter, DLP). It represents a large fragment of the intersection of Description Logics (hereafter, DLs), a decidable family of knowl-edge representation formalisms, based on fi rst-order logic and underlying OWL, and Logic Programming (hereafter, LP), a family of knowledge representation formalisms centred on the notion of rules. It is worth noting that DLs and LP are two orthogonal paradigms ( Grosof et al., 2003 ), and, thus, not everything in OWL ontologies can be expressed using rules. Hence, DLP includes only the OWL constructs convertible into rules. Nonetheless, it exhibits a signi fi cant degree of expressiveness and many of the existing ontologies are inside this fragment of OWL.
 permits de fi ning subsumption relationships between classes and properties, range and domain constraints on properties, asserted class-instance (type) and instance-property-instance relation-ships. Additionally, DLP allows also de fi ning (within DLs) equiva-lence relationships between classes and properties, equality and inequality between individuals, functional and inverse-functional as well as transitive, symmetric or inverse constraints on proper-ties. Finally, it enables to specify (still within DLs) a class by using the intersection connective (conjunction) or the union connective (disjunction), a superclass by using (a restricted form of) universal quanti fi cation, a subclass by using (a restricted form of) existential quanti fi cation ( Grosof et al., 2003 ).

As a result, the expressivity supported by the proposed system is essentially equal to the DLP fragment of OWL and can vary depending on the set of entailment rules loaded into it. Indeed, the system provides users a comfortable way to choose the particular set of OWL constructs to support, strictly within DLP, by simply adding one or more entailment rules according to the required features of a speci fi c semantic application. This implies that users are enabled to set up the desired OWL reasoning abilities through the proposed rule engine, which can be very fast and small in memory footprint, by avoiding the more expensive time and space demands of more complex and complete OWL-DL reasoners.
Moreover, in addition to these OWL-DL reasoners, the proposed system also offers the ability to process custom rules strictly connected to the particular application, such as rules for enabling actions on sensors/actuators, for sending remote messages, and so on.

As an example, Table 1 reports the set of enactment rules, mapping the RDF-Schema fragment of DLs, which has been implemented and included into the proposed system.

The Lazy Pattern Matcher (LPM) identi fi es the executable rules according to the current WM, by implementing the proposed pattern matching algorithm that exploits ad-hoc memory struc-tures, named Alpha Memories, Negated Alpha Memories , Rule
Activation Stack and Deferred Activation Stack. The LPM is the core component of the reasoning system and it is able to interact with the other components in order to both evaluate available data for drawing new knowledge, and properly manage a set of dedicated memory structures for ef fi ciently supporting the reasoning sys-tem. Such a way, it avoids increasing the runtime memory footprint when possible. Much more details on the LPM compo-nent will be provided in the next section.

Finally, the Rule Activation Executor (RAE) is in charge of an executable rule as soon as it is found. The RAE is responsible of determining the particular operation associated to the execution of a rule, by calling the KM when assertions/retractions are required or invoking speci fi c actions on the mobile device when an interaction with its sensors/actuators is required, such as speci fi c function calls for sending remote messages, and so on. 4. The lazy pattern matching algorithm
The lazy pattern matching algorithm here proposed has been speci fi cally designed and implemented as a light-weight solution suitable for resource-constrained devices and/or highly dynamic domains. In particular, for each recognize-act cycle, it has been conceived to determine, in the pattern matching phase, only one rule activation, based on the observation that, in the successive fi ring phase, one rule instance at a time is executed anyway.
The algorithm essentially consists in three phases, each of them devised respectively to: (i) identify the set of active rules, (ii) determine the fi rst rule activation to fi re at each recognize-act cycle (iii) update the set of active rules and their binding spaces.
Each of these phases is schematically depicted in Fig. 4 and deeply described in the following. 4.1. Identi fi cation of active rules
The fi rst phase of the algorithm searches for existing active rules according to the current WM. A rule is de fi ned active when each TP in its LHS is satis fi ed by a WME at least. To carry out this task, for each rule, intra-condition tests are computed to identify the WMEs satisfying each TP and the results are stored into ad-hoc memory structures, named Alpha Memories .

A single alpha memory is linked to a TP and contains, for each matching WME, its ID as recorded into the WM and a reference to it. When different TPs model the same pattern, for instance (?x, rdf:type,?y) and (?p, rdf:type,?q), they are linked to a shared alpha memory, so limiting the memory usage. The records in the different alpha memories are arranged coherently with the order of the matching WMEs, since intra-condition tests are computed by moving tidily on the WM.

In Fig. 5 , the rule ex01 , which states that  X  if two patients have respiratory rate x and heart rate y, respectively, then ...  X  example made of fi ve CEs and outlines how the alpha memories linked to them are built.

A negative triple pattern expressed into a CE is linked to a special alpha memory, named Negated Alpha Memory, devised to store information about its invalidating WMEs. Similarly to an alpha memory, it is fi lled when the intra-condition tests are calculated and it can be shared between similar negative CEs.
As a result, the intra-condition matching enables to determine whether a rule is active or not by simply verifying when all the alpha memories linked to its TPs contain matching WMEs.
With respect to its fl ow of execution, this phase starts after loading rules and instantiating the corresponding alpha memories (normal and negated ones). When all the initial facts are intro-duced in the WM, the fi rst set of active rules is determined according to the initial con fi guration of the known world. Succes-sively, the set of active rules can dynamically change each time the
WM is updated. In particular, when a fact is added (removed) into (from) the WM, all the existing alpha memories are noti fi intra-condition tests associated to them are calculated in order to evaluate if they are impacted by the updated knowledge. For instance, when an alpha memory is noti fi ed of the insertion of a new fact, if such a fact matches the TP, then a reference to the new
WME is added inside the memory, and such an insertion is noti to all TPs sharing that memory. Differently, when a TP is noti an update in its alpha memory, such an update is noti fi ed to all rules containing that TP.

The conditions associated to alpha memories are evaluated and classi fi ed in pattern conditions (TPs and nTPs) and function calls .
Pattern conditions are associated to alpha memories that store references to the WMEs matching them. Negated alpha-memories are strictly connected to the associated nTP, since the stored information, as detailed described in the next sub-section, is directly in fl uenced by the nTP and the rule containing it. Function calls allow de fi ning constraints acting on the values matching a TP.
In more detail, a generic function funcName(a,b) is considered a value constrainer when a or b are variables, but not both. Such a way, functions such as lessThan , greaterThan , equal , and so on, determine some constraints on the admitted values for the TP if both the function call and the TP act on the same variable. In fact, when in the same rule some function calls exist, which compare constant values with the values assumed by variables de fi
TPs, such constraints are incorporated in the involved alpha memories. In other words, potential inter-condition tests are converted into intra-condition constraints so as to reduce the amount of facts able to match those TPs and, hence, the memory consumption. On the other hand, also the amount of tests to execute before discovering the lack of consistency in a potential activation is optimized, thus improving the overall response time. 4.2. Identi fi cation of rule activations each of the active rules identi fi ed in the previous phase. Essen-tially, for each active rule, an activation is computed as the set of available WMEs satisfying it. It is formed by a reference to an active rule and, depending on the presence of variables in the LHS of the rule, a binding environment containing an ordered list of both variables and values. In more detail, in the case when no variable is present in the LHS of a rule, only one activation is admissible for that rule and is directly represented by the set of speci fi c WMEs matching its TPs. In the case when a variable occurs only once in the LHS of the rule, one or more activations are admissible for that rule, exactly determined by the number of
WMEs matching the TP containing that variable. Finally, in the case when one or more variables are present multiple times in different CEs, their occurrences have to be consistently joined in order to assume values coherently with the matching WMEs identi fi ed into the corresponding alpha memories. As a result, in this case, the activation is represented by the set of WMEs matching TPs where no variable is present plus a fi nite set of couples ( v ariable , value ) where for each variable contained into more TPs a value is chosen among WMEs matching all of them.
In this last situation, the strategy adopted to calculate rule activations relies on performing inter-condition joins by pairwise checking the consistency of variable bindings. In other words, for each active rule, an activation is composed, through its different
CEs, by visiting the space of all its possible variable bindings, in order to determine a set of values that satisfy the inter-condition joins and do not violate any other speci fi ed rule condition. In Fig. 6 an executable activation of the rule ex01 is reported.
For each rule, visiting the space of all possible variable bindings allows determining the con fl ict set, i.e. all its possible activations.
Differently from eager matching algorithms, which calculate and maintain the whole con fl ict set into runtime memory, and execute it according to a resolution strategy, here only one rule activation is calculated for each recognize-act cycle, so not generating any con fl ict set to be kept.

As a consequence of that, a Rule Activation Stack (RAS) has been introduced to correctly determine the next applicable activation, by avoiding to re-compute inter-condition joins already evaluated for the previous activation. This solution resembles the one proposed in ( Miranker et al., 1990 ), by extending its applicability to different kinds of CE in a rule and to alpha memories shared between similar CEs.

In Fig. 7 the RAS for the rule ex01 is reported. Each stack element enables to enumerate a speci fi ed sub-partition of the whole set of rule activations by combining the facts stored into the alpha memories according to its pivot and maxID . More speci cally, the pivot is used to identify a Pivot WME (PWME) , i.e. the WME with ID  X  maxID pivot and matching the pivot th TP. The subset of inter-condition joins is then generated by correlating the PWME to all the WMEs matching each TP i a TP pivot , and having ID r maxID i .

In Fig. 8 the usage of the RAS is reported for the rule ex01 .After executing all the possible inter-condition joins associated to the current stack element, the next one is popped until the stack becomes empty, and, thus, no other rule activation can be found. As a consequence of that, the RAS determines the order of execution of rule activations depending on the addition or removal of WMEs. In other words, for each active rule, the set of possible activations is embedded in its RAS entries, where the most recent one is positioned on the top. Thus, when two or more activations exist for the same rule, its RAS selects the most recent one applying a recency-based strategy. Similarly, when two or more active rules are potentially eligible for the execution, since char-acterized by not empty RASs, the rule is selected which has the most recently updated RAS.

The space of potential activations associated to the current stack element is visited by using different con fi gurations of pointers p i which enable to move on the different matching WMEs for each TP. The variables within the different CEs are incremen-tally bounded within a partial rule activation (rA), starting from the current PWME, which is the last changed fact in the WM when the stack entry has been created. Since each stack element contains a different PWME, the inter-condition joins are arranged for being computed depending on the last recent matching fact.
After identifying the current TP pivot , the enrichment or invalidation of the current rA is carried out by performing the inter-condition joins with all the other CEs as follows. When a CE, containing a TP or a function call, requires to bind a variable to a value, if that variable is already contained into the rA and bound to a different value, the rA is discarded, otherwise it can be enriched with the requested binding and the next CE can be evaluated. 4.3. Updating the binding space
The last phase consists in updating the binding space after the execution of a rule activation.

In more detail, if the WM is not changed at all, the search for activations can be resumed from the last interruption point, i.e. by removing the next element from the top of the stack. Otherwise, if some facts are asserted or retracted into the WM by the executed rule activation, the binding space determined for the rules involved by these changes has to be updated accordingly. In particular, when new facts are asserted into the WM, the intra-condition tests for each rule using the new WMEs have to be computed again. When TPs are satis fi ed, the matching WMEs are inserted into the corresponding alpha memories. Thus, new potential activations need to be investigated and a new stack entry is pushed for each TP satis fi ed. Otherwise, if the new WMEs match some nTPs, no potential activation is generated, and, thus, they have to be only inserted in the corresponding negated alpha memory without adding any new element into the stack.

Differently, when a fact is retracted into the WM, for each rule containing the triple patterns involved, it is fi rst removed from the corresponding alpha memory. Furthermore, the stack elements where that WME is a PWME are eliminated, so as to erase all the potential activations containing it.
 the WME is discharged from the corresponding negated alpha memory. As a result, some rule activations, previously not satis-fi ed, have to be made executable now. To this aim, a Deferred
Activation Stack is created, where blocked activations are stored by specifying the blocking WME and the current con fi guration of pointers p i linked to the invalidating nTP. In particular, after removing the retracted fact, the deferred activation stack of the nTP is evaluated in order to determine the existence of any rule activation previously blocked. In this case, a new entry containing a reference to the nTP (coded through a negative pivot) and the removed WME  X  s ID is pushed into the rule activation stack with the goal of re-inspecting successively the blocked rule activation. blocked activation is extracted from the deferred activation stack of the corresponding nTP and evaluated. A blocked activation is deleted from a deferred activation stack after being evaluated or after the assertion of a new invalidating WME. In Fig. 9 , the rule ex02 with a negated condition is reported, where A4 and DefAct1, both linked to the negative pattern CE4, are the negated alpha memory and the deferred activation stack, respectively. 5. Performance evaluation and discussion resource-limited mobile devices by using Java 2 Platform, Micro Edition (J2ME) in accordance with the Mobile Information Device Pro fi le 2.0 and Connected Limited Device Con fi guration (CLDC) 1.1.
It has been deployed and executed on four different mobile devices in order to evaluate its behaviour and effectiveness with respect to AndroJena on the Android platform.
 follows, with also their hardware and software features speci is due to two issues. First, among the other existing reasoning systems depicted in the state-of-the-art analysis reported into
Section II, it is the only tool offering comparable capabilities with the proposed system in terms of both knowledge representation expressiveness and rule-based reasoning. Second, the existing systems proposed in ( Ali and Kiefer, 2009; Gu et al., 2007; Kim et al., 2010; Tai et al. 2011; Motik et al. 2012 ) do not make their code accessible to be downloaded and tested on mobile devices for a comparative performance evaluation. Differently, Bossam ( Jang and Sohn, 2004 ) makes its implementation freely available, but it supports only J2ME Connected Device Con fi guration, so resulting incompatible to be ported on a lot of mobile devices only compliant with CLDC 1.1 or Android-based.

As a consequence of that, the proposed system and AndroJena have been compared in order to analyse their performance in a typical RHM application, where a collection of ten generic vital parameters is acquired at a high frequency, in the form of a single measurement, on a patient and has to be processed in real-time directly on a mobile device. This kind of scenario has involved a set of rules, de fi ned with the cooperation of RHM experts, whose objectives are to detect abnormal conditions involving the patient (also referred as anomalies ), starting from the monitored para-meters, and, contextually, generate an alert as soon as these anomalies are recognized.

More speci fi cally, each rule tests only a single generic vital parameter, collected within a measurement, and determines a possible anomaly accordingly. As soon as an anomaly is found at the time t, an alert is launched and the search for a new abnormal condition restarts by evaluating all the measurements gathered at the time t  X  1. Thus, the measurements with a timestamp older than the one associated to last anomaly detected are not considered anymore in the rule evaluation. In order to structure these rules for being processed by both the proposed system and AndroJena, an ontology has been designed, including all the main concepts, relations and attributes pertaining the scenario, as shown in Fig. 10 . In detail, three main concepts have been devised, namely PatientInfo , AbnormalCondition and Measurement. PatientInfo includes the collection of measurements acquired by the RHM application and pertaining a patient as well as the possible abnormal conditions detected. It is characterized by a state, indicating, for instance, when possible abnormal conditions are searched for or when an alarm must be generated, and by a timestamp related to the last abnormal condition identi fi AbnormalCondition indicates a possible anomaly occurred at a certain timestamp and is associated to the measurement that has generated it. Finally, Measurement includes the collection of ten generic vital parameters acquired at a certain timestamp.
The encoding of a new measurement according to the ontology designed generates a collection of 13 statements expressed by using N-Triples, as reported in Fig. 11 .

An example of rule built on the top of these ontological elements is reported in Fig. 12 , where the set of conditions to be satis fi ed are positioned in its LHS, whereas the set of actions to be executed are reported into its RHS, respectively. In particular, the LHS states that the rule is satis fi ed when: (i) a fresh measurement is collected with a timestamp newer than the one associated to last detected anomaly regarding that patient; (ii) a parameter A1 associated to that measurement has a value greater than 100; (iii) the inspection for possible abnormal conditions is enabled on the information pertaining a patient. On the other hand, the RHS states that (i) the inspection for further possible anomalies is disabled; (ii) an alarm is generated for the patient considered; (iii) the detected abnormal condition is de fi ned in terms of the measurement that has generated it and its timestamp and asso-ciated to the information pertaining the patient.

Starting from this ontology and rules, three factors, namely the number of individuals , rules, and anomalies, have been identi relevant for being evaluated in order to assess the performance of the proposed system and AndroJena, as a consequence of the following considerations. Firstly, the number of measurements acquired and successively codi fi ed in the form of individuals for populating the WM directly in fl uences the amount of information to process when a rule activation is looked for. Secondly, the number of rules to be evaluated affects the search for a single activation of each rule. Finally, the fi ring of a rule activation identi fi es an anomaly, and, thus, disables the search for other eligible activations of the same rule and of other rules with respect to measurements with timestamps older than the one associated to an anomaly detected. As a result, the number of potential eligible activations, corresponding to potential anomalies, that are calculated and successively invalidated also affects the search for the fi rst activation of a rule at each recognize-act cycle. The number of conditions in the LHS of a rule has not been considered as a relevant factor for the performance evaluation, since it has been speculated to generate similar effects of the number of individuals.
 and memory usage , since the reasoning system is strongly required to provide answers within a prescribed time and without exhaust-ing all the available runtime memory. It is worth noting that memory consumption has been identi fi ed as in fl uential for the system performance even though the technological advances involving the latest models of smartphone have augmented their memorization capabilities. This is due to the fact that this new generation of smartphones has been equipped with multitasking
Operating Systems (hereafter, OSs), which allow more than one program of app to run on them simultaneously. These OSs, together with the set of applications installed by default, such as phone, widgets, browser, calendar and so on, exploit most of available runtime memory, leaving just a little portion to third-party applications. This remaining portion of memory is subdi-vided and allocated to each application with the obligation of not exceeding the upper limit represented by the maximum heap size dedicated to each process. For instance, in Android smartphones, the default memory available for each application is usually included between 16 MB and 24 MB ( Dubroy, 2011 ), depending on the particular device, whereas, in Symbian smartphones, it is just equal to 1 MB ( Aubert et al., 2008 ). Thus, it appears clear that memory still represents a critical resource to handle carefully when developing mobile applications in general and, more in particular, a mobile reasoning system.
 three factors abovementioned, by identifying a set of repeated experiments according to the Taguchi  X  s experimental design. It essentially enables to organize well-balanced experiments with a reduced variance and optimum settings by using an orthogonal array for combining the factors affecting the performance and the levels at which they should be analysed, with the aim of avoiding to test all the possible con fi gurations of them ( Taguchi, 1986 ). In particular, three levels have been considered for each factor, as reported in Table 2 .
 determine the combinations between factors and their levels to use in nine different experiments to be performed. In order to determine the effect of these factors on the performance of the reasoning systems evaluated, the signal-to-noise ratio (here-after, SN) has been computed, conducting three trials for each experiment in the L 9 array, according to the standard SN ratio, named  X  Smaller-The-Better  X  , which is typically used in the case of minimizing the performance characteristic ( Phadke, 1989 ).
Experiments have been performed on all the mobile devices abovementioned, but the results described in the following tables are only those achieved on Samsung Galaxy Nexus. This is due to the fact that the results obtained on the other mobile devices are resulted as equivalent from a statistical point of view to the ones reported and, for the sake of brevity, have been omitted.
In detail, Table 3 shows the experimental layout used, the SN ratio and the mean value computed for the proposed reasoning system with respect to the two metrics considered. Once all the SN ratios have been computed for each run, the average SN value for every factor and for each of its levels has been calculated, as reported in Table 4 . In detail, given a factor F , the average SN value associated to the level 1 of F is computed by taking into account the SN values observed in the experiments when F assumes the value associated to its level 1. After determining the average SN value associated to each level of the factor F , the range effects on the performance has been calculated as the difference between maximum and minimum of such average SN values.
These ranges are used to rank the three factors depending on their values and, thus, to determine which factors have the largest effect on the performance (i.e. the maximum alteration induced in the associated SN ratio).

As shown in Table 4 , the number of individuals and anomalies have been recognized as more relevant for the performance with respect to the response time of the proposed reasoning system. In other words, the system is in fl uenced in fi nding and fi eligible rule activations mostly by the number of individuals to be processed and, secondly, by the number of potential anomalies generating rule activations. The number of anomalies becomes less relevant with respect to the response time for fi nding and the fi rst rule activation, since the con fl ict set is not computed entirely and, thus, only one among the potential anomalies that could generate rule activations is considered, so limiting the in fl uence of the remaining ones. On the other hand, with reference to the memory usage, the number of anomalies has been identi as the least signi fi cant among the three factors considered. This result is con fi rmed by the consideration that the proposed system does not save partial results after the search for eligible rule activations satis fi ed by the potential anomalies, since those activa-tions could be invalidated by a fi red one, and must be revaluated at a new recognize-cycle.

In Table 5 , the ranges of the effects on the performance produced by the three factors abovementioned have been calcu-lated for AndroJena. It is possible to note that, also for AndroJena, both the number of individuals and anomalies can signi fi in fl uence the performance in terms of response time, whereas the range of the effects of the number of rules is, on the average, inferior with respect to the range observed in the proposed reasoning system. From a theoretical point of view, this is probably due to the ability of the RETE algorithm, adopted in AndroJena, to save many intermediate results after the search for eligible rule activations satis fi ed by the potential anomalies. Indeed , such a way, the overall response time can be sensibly reduced when the number of rules increases. On the other hand, the need of the RETE algorithm to maintain and update the nodes constituting the memory network associated to each rule signi fi cantly in the performance in terms of response time when the number of individuals increases.

With reference to the memory usage, the effects on the performance produced by the factors in the case of AndroJena are relatively similar to the ones related to the case of the proposed system when either the number of rules or the number of anomalies increases. However, the consumption of memory resources has been always inferior in the proposed reasoning system with respect to AndroJena. Besides, it is worth noting that the range of effect of the number of individuals in the case of the proposed reasoning system is, on the average, inferior than the one observed in AndroJena. This is probably due to the greater amount of data stored into the memory structures managed by AndroJena to optimize the response time.

Starting from these statistical results, the performance evalua-tion has been successively articulated into a second phase, where the typical RHM application above considered has been instanced with respect to a real situation, i.e. the monitoring of cardiovas-cular diseases.

A key component of this application is a decision support module able to automatically process and correlate a set of vital parameters, acquired through a set of Bluetooth-enabled body sensors, identify markers of potentially abnormal conditions and alert clinicians. In more detail, starting from data acquired by the sensors, the patient electrocardiogram (ECG) is analyzed in order to recognize and report a set of anomalies, such as, for instance, a necrosis or ventricular hypertrophy when the width of the QRS segment is less than 120 ms ( Jara et al., 2009 ). Fig. 13 shows the ECG curve and some examples of the abnormal conditions considered in this case study, which can be inferred by analyzing the relationships between the ECG waves.

For this real scenario, ten rules have been arranged and encoded according to the structure shown in Fig. 12 in order to detect possible abnormal conditions as the ones reported in Fig. 13 .
 An example of rule codi fi ed to detect a possible anomaly due to
Tachycardia is detailed in Fig. 14 . In particular, the rule structure shown in Fig. 12 is still maintained, with the only two differences highlighted in red. First, the generic attribute ParameterA1 has been substituted by a more speci fi c one, named SegmentPR, and second, its value is imposed to be less than 0.12 ms, according to the information depicted in Fig. 13 .

Starting from these 10 rules, a set of 10 experiments has been performed with a growing number of measurements codi fi ed in the form of individuals, varying from 10 to 150, and a fi number of potential anomalies equal to 1. This choice is due to the fact that the experiments performed according to Taguchi s design have ranked the number of individuals as the most signi fi cant factor in fl uencing the performance with respect to both the response time and memory usage. Each experiment has been executed fi ve times for a total of 50 runs. The results achieved in terms of overall response time and memory usage have been calculated as the average obtained over the fi ve repeated observations of each experiment and reported in the next fi gures.
 on the four mobile devices considered. As the number of indivi-duals increases, the overall memory usage of AndroJena rapidly grows up. This issue is due to the intermediate memory structures used by the RETE algorithm, on which AndroJena is built, to reduce the pattern matching time and improve the overall reasoning time.
This implies that not only is RETE not optimized to reason given constraints on the memory usage, but also it might unexpectedly exhaust all of the available runtime memory of the mobile devices with a big WM, corrupting their normal functioning.
 usage does not increase so evidently according to the number of individuals and it is always inferior to in AndroJena, since the proposed lazy pattern matching algorithm does not adopt huge-weight memory structures but reduces the space complexity by adopting the previously de fi ned stacks. Indeed, the presented case study is characterized by a set of rules that, if satis fi measurements, can require a refresh of facts in the WM in terms of assertions and retractions. Thus, saving the partial results of inter-condition tests results useless since the tests should be frequently re-calculated.
 usage does not signi fi cantly vary depending on the mobile device used, since memory resources allocated by both the systems are not excessive and, however, strongly inferior than the ones reserved to a third-party application by Android OS in all the devices considered.
 executed on the four mobile devices considered. Despite the differences due to the different computing capabilities of the four devices, it is possible to note that the response time required to detect and execute the fi rst rule activation in the proposed system, i.e. the fi rst abnormal situation, is sensibly less than the overall reasoning time in AndroJena, where a response is generated only at the end of the whole reasoning process. Moreover, the overall reasoning time in the proposed system is also inferior with respect to the overall response times observed in the AndroJena system.
From a theoretical point of view, this is due to the particular scenario considered, where, according to a non-monotonic strat-egy, facts are asserted and retracted when rules are executed, and, in these situations, the proposed algorithm can improve its performance, in terms of average response time, by avoiding the computation of useless potential information. As concluding observation, the shortest response time is achieved on Samsung Galaxy S5, which is equipped with the best hardware capabilities among the devices considered.

The RHM scenario here considered can require either frequent reasoning or incremental reasoning depending on time and modality of submission of the measurements to the reasoning system and time constraints regarding the fi nal response. Indeed, in accordance with the consideration that the admissible measur-ing range for the heart rate varies from 30 bpm (i.e. beat per minute) to 240 bpm, the heart rate can change its value up to a maximum of four times per second (i.e. up to a maximum of four ECG curves per second).

This involves that, in the case when incremental reasoning is adopted and a real time response is requested, the proposed system has to elaborate a variable numbe r of measurements per second, varying from 1 to 4. In other words, the reasoning system can be invokedatafrequencyupto4Hzanditsresponsehastobeproduced before new measurements are available. On the other hand, in the case when frequent reasoning is used, the proposed system can be invoked each minute, i.e. at a frequency of 0.0166 Hz, and has to jointly process a collection of measurements, varying from 60 to 240.
Considered the number of rules involved and both these frequencies of invocation, the results reported in Fig. 16 in terms of response time prove that the proposed system can be pro -ciently used in both the frequent and incremental modalities.
Indeed, its response time, calculated when the fi rst activation of a rule is fi red, meets their performance demands, without the risk of unexpectedly exhausting all of the available runtime memory of the mobile device, as in the case of AndroJena. 6. Conclusions
This paper presented a light-weight rule-based reasoning system, purposely designed and optimized to build knowledge-based DSSs ef fi ciently embeddable in mobile devices with the aim of enabling the realization of both computation intensive and real-time RHM applications.

Thekeyissuesofsuchasystemareadomain-independent reasoning algorithm and knowledge representation capabilities, which can be speci fi callyappliedtosupportbothfrequentreasoningand incremental reasoning in computation intensive and real-time RHM scenarios. In more detail, a novel rule-based reasoning algorithm based on a lazy evaluation has been de fi ned and implemented to be ef fi ciently run on mobile devices, by reducing the space complexity and improving the response time. Moreover, the system also offers capabilities to manage ontology-models, encoded according a light-weight standard-oriented language, and if-then rules expressed in a very straightforward and easy-to-parse syntax, including directives to add or delete data instances according to a non-monotonic perspec-tive. It has been implemented for re source-limited mobile devices by using Java 2 Platform, Micro Edition and deployed on different mobile devices equipped with Android OS.
 arranged according to the Taguchi  X  s experimental design and per-formed directly on four different mobile devices in order to evaluate its performance and effectiveness, in terms of memory usage and response time, with respect to the AndroJena system in a RHM scenario. Moreover, a case study has been arranged in order to evaluate the effectiveness of the proposed system within a real RHM application for monitoring cardiovascular diseases. The evaluation results show that the system offers an innovative and ef fi to build mobile DSSs for healthcare applications where real-time performance or computation intensive demands have to be met. Acknowledgements  X  Smart Health 2.0  X  funded by the Italian Ministry of Education, University, and Research (MIUR).
 References
