 By rapid progress of high-speed networks and large-scale storage technologies, a huge amount of electronic data of new types, called semi-structured data have emerged in the late 1990s. Web Pages, XML documents, and genome data are typical examples of such semi-structured data. Therefore, there have been po-tential demands for efficient methods that extract useful information from these semi-structured data.

Traditionally, data mining mainly deals with well-structured data, e.g., trans-action databases or relational databases, for which data is arranged in a table-like regular structure. On the other hand, these semi-structured data are (i) huge, (ii) heterogeneous collections of (iii) weakly-structured data that do not have rigid structures. Thus, we cannot directly apply these traditional data mining tech-nologies to semi-structured data. Hence, our goal is to develop efficient methods that discover interesting or useful rules from large collections of semi-structured data, namely, semi-structured data mining [13, 15, 17, 18, 20, 21, 25, 29].
In this paper, we present efficient semistuructured data mining algorithms for discovering rules and patterns from structured data such as sequence, trees, and graphs. In Section 2, we considers tree mining and sequence mining in the framework of frequent pattern mining. We present the rightmost expansion tech-nique [9,1,11]. Then, in Section 3, we extend them to closed or maximal pattern mining by the PCC-expansion technique [31,4,5,7], where each pattern is a rep-resentative of an equivalence class of p atterns having the same occurrences in a given database. Finally, in Section 4, we condlude.
 In this section, we introduce a framework of frequent pattern mining for semi-structured data and present effi cient tree mining algorithms. 2.1 Framework of Semi-structured Data Mining A general framework. In our framework, a semi-structured data mining prob-lem is specified by a 4-tuple ( P , T , O ,L ), where P is a class of patterns , T is a class of databases , O is a class of occurrences (or positions ), and L : P X D X  2 O is a function called occurrence function ,where L ( P, T )= { o 1 ,...,o n } X  X  is the set of all occurrences of a pattern P  X  X  in a given database T  X  X  .We also assume that a partial order over patterns, called the subsumption order (or the generalization order ) such that for every patterns P, Q , P Q implies L ( P, T )  X  L ( Q, T ). If P Q then we say that P subsumes Q or P is more general than Q . For most classes of semi-structured patterns, L (  X  ,  X  )and are defined by the notion of matching or embedding of patterns.

Now, we define the frequent pattern mining problem for P as the problem of, given a database T  X  X  and a minimum frequency threshold 0  X   X   X | T | , finding all frequent patterns P  X  X  appearing in T such that | L ( P, T ) | X   X  without duplicates.

As the theoretical framework to study the computational complexity of semi-structured data mining, we adopt the theory of enumeration algorithms. Hence, our goal is to design polynomial-delay polynomial-space enumeration algorithms [16], where the exact delay is the maximum computation time between the suc-cessive outputs and the amortized delay is the total time devided by the number of output patterns.
 Ordered and unordered trees. For example, we gives the definition of fre-quent ordered tree mining. In tree min ing, data and patterns are modeled by labeled ordered trees as shown in Fig. 2. Let  X  be a countable alphabet of sym-bols. A labeld ordered tree is a rooted tree T =( V T ,E T ,  X  T , root T ,lab T ), where V = V T is the set of vertices , E T  X  V 2 is a set of directed edges called the parent-child relation ,  X  T  X  V 2 is a binary relation called the sibling relation , which orders children of each internal node left to right, root T  X  V is the root of T ,and lab T : V  X   X  is a function called the labeling function .A labeld unordered tree is a rooted tree T =( V T ,E T , root T ,lab T ), where the order  X  T of children is not relevant. We denote by O T and U T the classes of labeled ordered trees and of labeled unordered trees.

For a ordered trees P and T , P matches Q , denoted by P Q ,ifthere exists a matching function  X  : V P  X  V T from P to T that satisfies the following conditions (i)  X  (iv): (i)  X  is one-to-one; (ii)  X  preserves the parent-child relation; (iii)  X  preserves the sibling relation; (iv)  X  preserves the node label. We denote by  X  ( P, T ) the set of all matching functions from P to T .An input database is a set of trees T = { T 1 ,...,T m } . We assume that T is encoded in a single tree T  X  X  T obtained by attaching a common root to T 1 ,...,T m . Then, the occurrence list of a pattern tree P in a text tree T is the set of the root occurrences of P in T defined by L ( P, T )= {  X  ( root P ):  X   X   X  ( P, T ) } . Then, the frequency of P is defined by the number of occurrences 1  X | L ( P, T ) | X | T | . 2.2 Rightmost Expansion Technique for Frequent Pattern Mining For frequent ordered tree mining problem, we developed algorithm Freqt [9] that finds all frequent ordered tree patterns in a database. One of the keys of the algorithm is efficient enumerati on of labeled ordered trees. Our Freqt ,aswell as TreeMiner by Zaki [34], are in the first generation of depth-first tree and graph mining algorithms. The key of these algorithms is the rightmost expansion technique explained below, which is independently proposed by our group [9], Nakano [23], and Zaki [34].

A basic idea of the method is to build a spanning tree G over the search space of ordered tree patterns, called family tree for labeled ordered trees as shown in Fig. 3. By using the family tree, we can enumerate all the distinct ordered tree patterns without duplicates in a unique way starting at the root pattern called the empty tree  X  and expanding (or growing ) an already generated tree of size k  X  1(a parent tree ) by attaching a new node to yield larger tree of size k (a child tree ).
However, a straightforward implementation of this idea leads exponential number of the duplication for one tree resulting G to be a DAG. The rightmost expansion [9, 23, 34] is a technique to avoid duplicates, where we grow a pattern tree by attaching a new node to only the rightward positions on the rightmost branch of the parent tree so that the attached node becomes the rightmost leaf of the resulting tree.

This is equivalent to encode each labeled ordered tree T with n nodes by the sequence code ( T )=( X 1 ,...,X n ), called the depth-label sequence, where for each 1  X  i  X  n , X i =( depth i ,lab i )  X  N  X   X  are the pair of the depth and the label of the i -th nodes of T in the preorder traversal of T . Then, we grow a tree by attaching a new depth-label pair at the tail of code ( T ) [11, 23, 34]. Optimization techniques such as occurre nce-deliver [31] and duplicate detection achieve significant speed-up of the order of magnitude. 2.3 Frequent Unordered Tree Miner Unot For frequent unordered tree mining problem, we developed algorithm Unot [11] that finds all frequent unordered tree patterns in a database. Some real-world applications requires more general classes of graph patterns than ordered trees. However, from theory point of view, graph mining with general graph patterns seems intractable due to the NP-completeness of the subgraph isomorphism problem for general graphs. Our algorithm Unot , and the algorithm indepen-dently proposed by Nijssen and Kok [26], are ones of the first output-polynomial time tree/graph mining algorithms for nontrivial subclasses of graphs larger than ordered trees, which finds all frequent unordered tree patterns from a given collections of trees in time polynomial time per pattern [11].

A difficulty comes from the fact that a n unordered tree can have exponen-tially many equivalent re presentations as ordered trees (Fig. 4). To overcome this difficulty, we introduced the unique canonical representation of an ordered tree, called a left-heavier tree . Left-heavier tree representation has a monotonic-ity that if an unordered tree T (a child ) is left-heavier then the tree S obtained from T (the parent ) by removing the rightmost leaf is also left-heavier. Thus, We developed an efficient method to enumerate such canonical representation without duplicates [11, 24] by generalizing rightmost expansion technique of [1]. 2.4 Applications of Frequent and Optimized Pattern Mining Optimized pattern mining is a variant of frequent pattern mining, where a database is a collection D = { T 1 ,...,T m } X  X  of data together with labeling function  X  : D  X  X  +1 ,  X  1 } that assigns a binary classification label  X  ( T i )to each text T i  X  D and the goal is to find a best pattern P  X  X  that optimizes a given statistical score function such as the classification error or the Shan-non entropy in D . In weighted frequent pattern mining, we optimizes the sum score ( P, D,  X  )= T  X  L ( P,D )  X  ( T ).

An interesting application of the optimized tree miners are feature extraction for statistical machine learning over semi-structured data, such as boosting [19], SVM, statistical clustering [30] for tr ee and graph structures. Our tree min-ing algorithm Freqt is appleid to text mining from natural language texts for log analysis at the call center and custom er services [22], where a collection of Japanese sentences are transformed int o a collection of lab eled unordered trees by lexical and dependency analyses, and then Freqt is applied to find top-K best patterns in the MDL measure [22]. 3.1 Maximal Pattern Discovery Maximal pattern discovery (also known as closed pattern discovery [27]) is one of the most important topics in recent st udies of data mining [4, 5, 7, 8, 12, 27, 29, 33, 32]. A maximal pattern is such a pattern that is maximal with respect to the subsumption ordering (or the generalization relation) among an equivalence class of patterns having the same set of occurrences in a database. For some known classes of patterns, such as itemsets and sequence motifs [3], it is known that the number of frequent maximal patterns is much smaller than that of fre-quent patterns on most realworld datasets, while the frequent maximal patterns still contain the complete information of the frequency of all frequent patterns. Thus, Maximal pattern discovery is useful to increase the performance and the comprehensivity of data mining.

Formally, for a class P of patterns , we define the associated classe C of maximal patterns (also known as closed patterns in [27]) as follows [31,4,5,7]. Recall that the class of maximal patterns C is specified by a 4-tuple ( P , T , O ,L ) of a pattern class P , a database class T , an occurrence class, and an occurrence mapping L : P X T X  2 O . We define patterns P and Q are equivalent each other, denoted by P  X  Q ,iff L ( P, T )= L ( Q, T ) holds, and the equivalence class for pattern P by [ P ]= { Q  X  X  : P  X  Q } . Then, a pattern P is maximal in a database T if P is a maximal elment in [ P ] w.r.t. .Equivalently, P is maximal if there exists no strictly more specific pattern Q  X  X  than P equivalent to P , i.e., P Q and L ( P, T )= L ( Q, T )hold. 3.2 Depth-First Algorithms for Maximal Pattern Discovery Efficient Algorithms. For maximal pattern discovery, we have developed the following efficient algorithms for finding all maximal patterns from a given col-lection of data. Let  X  be an alphabet of symbols.
  X  The algorithm LCM ( Linear-time Closed Itemset Miner ) for maximal sets  X  The algorithm MaxMotif ( Maximal Motif Miner ) for mining maximal mo- X  The algorithm CloAtt ( Closed Atribute Tree Miner ) for mining maximal  X  The algorithm MaxGeo ( Maximal Geometric Subgraph Miner ) for mining
All of the above algorithms are polynomial time polynomial space algorithms based on depth-first search. To achieve t his requirement, we developed the PPC-extension (prefix-pres erving closure extension) technique below.
 Reverse search technique. Our PPC-extension can be viewed as an instance of the reverse search technique [16], which is a technique for designing effi-cient enumeration algorithms for complex combinatorial objects, such as perfect matching and maximal cliques. Let S be the set of solutions on an instance of a given combinatorial enumeration problem . In reverse search, for every non-root solutions Y , we arbitrarily assign the parent X = Pa ( X ) in a systematic way by using a parent mapping Pa . The mapping Pa is designed so that Pa ( P )is uniquely determined and the size of P is properly decreasing. Then, it follows that the directed graphs with S as the set of vertices and Pa as the set of di-rected edges, called the family tree 1 forms a spanning tree over the solutions. Finally, we can apply depth-first search to enumerate all solutions by starting from the root and then by expanding the current solution to obtain its children. If a child no longer belongs to S , then we backtrack to its parent and continue the search. Repeating the above process, we can enumrate all the solutions in S in depth-first manner with small delay and small memory. 3.3 PPC-Extension for Maximal Semi-structured Patterns In this subsection, we will present the PPC -extension framework for designing an efficient maximal pattern mining algorithm for a given class P of semi-structured patterns. In particular, we give an algorithmic schema PPC-MaxMine, from which we can derive polynomial delay and polynomial time enumeration algo-rithms LCM [31], MaxMotif [4], CloAtt [5], and MaxGeo [7] for maximal pattern mining.
 Merge and Closure operations. For the class of maximal patterns C specified by a 4-tuple ( P , T , O ,L ), we require that any set S of patterns has the unique greatest lower bound S of S w.r.t. ,orthe least common subsumer (LCS) of all patterns in S . Although this property of the existence of the unique LCS does not hold in general, the four classes of patterns that we have considered, i.e., the classes of itemsets, motifs with wildcards, attribute trees, and geometric graphs, enjoy this property.
 Under the assumption of the unique LCS, we give the merge operation  X  : P X P X  X  that computes the l east common subsumer Q patterns Q 1 ,Q 2  X  X  . We suppose that a pattern P occures in a database T  X  X  at occurrence or position p  X  L ( P, T )  X  X  . Then, an alignment or displacement of T at the occurrence p , denoted by ( T  X  p )  X  X  , is a copy of the data T where the origin of the copy is set to the position p . Then, we define the closure of a possibly non-maximal pattern P by the pattern Clo T ( P )= p  X  X  ( P ) ( T  X  p ). Lemma 1. Let P be any class among the classes of itemsets, motifs with wild-cards, attribute trees, and geometric graphs. Let T  X  X  be any database. Then, for every P, Q  X  X  , the following properties holds: 1. If P Q then Clo T ( P ) Clo T ( Q ) . 2. Clo T ( Clo T ( P )) = Clo T ( P ) . 3. If P and Q are maximal, then P Q iff L ( P, T )  X  L ( Q, T ) . 4. P is maximal in T iff Clo T ( P )= P .
 Defining the parent function. Now, we define the parent function for the maximal patterns in C by using the closure operator Clo T as follows. Firstly, we introduce an adequate representation scheme for patterns of P , where each pat-tern P of size n is encoded by a sequence code ( P )=( X 1 ,...,X n ) over an alpha-bet X of components. Then, we assume that the encoding is prefix-closed, i.e., for any pattern P , any prefix of the encode of P is a proper encoding of some pattern in P . The increasing sequence representa tion for itemsets and the depth-label sequence representations are examples of such encoding schema. In what follows, we identify a pattern P and its encoding code ( P )=( X 1 ,...,X n )ifitisclear from the context. If P =( X 1 ,...,X n ), 1  X  k  X  n ,and Z  X  X  then we define the insertion of Z at the index k by P [ k  X  Y ]=( X 1 ,...,X k  X  1 ,Z,X k ,...,X n ).
We define the root pattern by  X  = Clo T (  X  )  X  X  , which is the closure of the empty pattern  X  that appears everyposition in T .Let P =( X 1 ,...,X n )  X  X  be any non-root pattern that is maximal in T .For k  X  n ,wedenoteby P ( k )= ( X 1 ,...,X k ) the prefix of P with length k .The critical prefix of P in T is the shortest prefix P ( k )(0  X  k  X  n )of P that has the same occurrence list with the original, i.e., L ( P ( k ) ,T )= L ( P, T ) holds. Then, i is called the critical index of P w.r.t. T and denoted by crit idx ( P )= i . We define the parent of pattern Q in T by where k = crit idx ( Q ) is the critical index of Q w.r.t. T . Then, we can observe that since Q ( k ) is the shortest prefix of Q having the same set of occurrences, the strictly shorter prefix Q ( k  X  1) has a properly larger set of occurrence L ( Q ( k  X  1)) ( L ( Q )  X  L ( Q ( k  X  1))). By the definition of the equivalence relation  X  ,we know that Q ( k  X  1) now belongs to an equivalence class [ Q ( k  X  1)]  X  X  disjoint with the previous equivalence class [ Q ]for Q . Thus, it follows by Property 4 of Lemma 1 that the closure P = Clo T ( Q ( k  X  1))  X  X  of Q ( k  X  1) is a maximal pattern in C . By this construction, for every non-root maximal pattern Q  X  X  ,we always associate as its parent the maximal pattern P = Pa ( Q )  X  X  .Furthermore, we can easily see from Lemma 1 that P is more general than Q , and furthermore, P is strictly shorter than Q in length. Combining the above discussion, we can see that the rooted directed graph G =( C ,Pa,  X  ) with the set of vertices C ,the set of reverse edges Pa  X  X  X C ,andtheroot  X  is a family tree for C , a spanning tree for all maximal patterns in C . Depth-first mining by PPC-extension. The remaining thing is to perform the depth-first search over the family tree G for C by inverting the direction of the reverse edges in Pa . Suppose that P is a parent of Q , i.e., P = Pa ( Q )= Clo T ( Q ( k  X  1)) for the critical index k = crit idx ( Q )and Z = X k  X  X  is the k -th component of Q . Then, we can show that we can recover Q from P by computing Q = Clo T ( P [ k  X  Z ]) provided that the prefix check P ( k  X  1) = Q ( k  X  1) succeeds, i.e., the prefices of P and Q of length k  X  1 coincide, where P [ k  X  Z ] is the encoding obtained from P by inserting Z at position k . Then, Q is said to be a PPC-extension of P . Furthermore, for different selection of ( k, Z )  X  N  X X generates distinct children of P .

Fig 6 shows the search structure of PPC-extension in LCM algorithm in the case of maximal itemset mining [31]. In Fig. 7, we give a simple backtracking algorithm PPC-MaxMine based on the PPC-extension technique. The algorithm PPC-MaxMine finds all maximal patterns in the class C appearing in T without duplicates in the depth-first manner.
 Complexity analysis. From the view from enumeration algorithms, we showed that all instances of the algorithm scheme PPC-MaxMine, namely, LCM [31], MaxMotif [4], CloAtt [5], and MaxGeo [7], are actually polynomial delay and polynomial time enumeration algorithms that computes all maximal pat-terns for the classes of itemsets, motifs with wildcards, attribute trees, and ge-ometric graphs, respectively. To our kno wledge, these are the first results on efficient output-sensitive algorithms for maximal pattern disocvery for semi-structured data. In this talk, we reviewed techniques fo r designing efficient frequent and max-imal/closed mining algorithms for large semi-structured data. We capture the notion of high-throughput and light-weight pattern mining algorithms by the class of polynomial-delay and polynomial space enumeration algorithms for pat-tern mining problems. Firstly, we study efficient frequent tree mining based on the rightmost expansion technique developed by [9,23,34], which enable us to effi-ciently enumerate complex semi-struct ured patterns in a systematic way without duplicates. Then, we present frequent mining algorithms Freqt [9], Optt [1], and Unot [11]. Secondly, we study efficient maximal/closed pattern mining for classes sets, sequences, trees, and gra phs based on the prefix-preserving clo-sure extension (PPC-extension) techniqu e. Based on this technique, we present frequent mining algorithms LCM [31], MaxMotif [4], CloAtt [5], and Max-Geo [7]. All the above algorithms that we presented have polynomial-delay and polynomial space enumeration complexity for the corresponding semi-structured data mining problems.

It is an interesting future problem to apply the above frameworks for other classes of complex pattern mining problems such as maximal/closed pattern mining for sequential patterns (sequen ces of itemsets) or generalized itemsets (sets of elements of a concept hierarchy ). On maximal/closed pattern mining, we mainly considered th e pattern classes of  X  ridid patterns  X , e.g., items sets, motifs with wild cards and attribute trees, where the LCS and the closure are uniquely determined from the occurrences. On the othe hands, there are a few results on efficient maximal/closed pattern mining for the classes of  X  flexible  X  patterns such as ordered tr ees, unordered trees, and s ubsequences patterns for which no closure operator is known. Thus, it is a future problem to study a generic framework for mining maximal flexible patterns.
 The results presented in this talk are ob tained in the joint works with Takeaki Uno, Shin-ichi Nakano, Tatsuya Asai, Hiroshi Sakamoto, Shinji Kawasoe, Kenji Abe, and Yuzo Uchida. The author would like to express sincere thanks to them. This research was partly supported by the Ministry of Education, Science, Sports and Culture, Grant-in-Aid for Specially Promoted Research, 17002008, 2007 on  X  X emi-structured data mining X , and the MEXT/JSPS Global COE Program,  X  X enter for Next-Generation Information Technology based on Knowledge Dis-covery and Knowledge Federation, X  at Graduate School of Infomation Science and Technology, Hokkaido University.

