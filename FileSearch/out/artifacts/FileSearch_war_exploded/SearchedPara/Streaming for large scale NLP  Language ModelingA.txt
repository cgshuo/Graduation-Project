 In many NLP problems, we are faced with the chal-lenge of dealing with large amounts of data. Many problems boil down to computing relative frequen-cies of certain items on this data. Items can be words, patterns, associations, n -grams, and others. Language modeling (Chen and Goodman, 1996), noun-clustering (Ravichandran et al., 2005), con-structing syntactic rules for SMT (Galley et al., 2004), and finding analogies (Turney, 2008) are examples of some of the problems where we need to compute relative frequencies. We use language modeling as a canonical example of a large-scale task that requires relative frequency estimation.
Computing relative frequencies seems like an easy problem. However, as corpus sizes grow, it becomes a highly computational expensive task. Brants et al. (2007) used 1500 machines for a day to compute the relative frequencies of n -grams (summed over all orders from 1 to 5 ) from 1 . 8 TB of web data. Their resulting model contained 300 million unique n -grams.

It is not realistic using conventional computing re-sources to use all the 300 million n -grams for ap-plications like speech recognition, spelling correc-tion, information extraction, and statistical machine translation (SMT). Hence, one of the easiest way to reduce the size of this model is to use count-based pruning which discards all n -grams whose count is less than a pre-defined threshold. Although count-based pruning is quite simple, yet it is effective for machine translation. As we do not have a copy of the web, we will use a portion of gigaword i.e. EAN (see Section 4.1) to show the effect of count-based pruning on performance of SMT (see Section 5.1). Table 1 shows that using a cutoff of 100 produces a model of size 1 . 1 million n -grams with a Bleu score of 28 . 03 . If we compare this with an exact model of size 367 . 6 million n -grams, we see an increase of 0 . 8 points in Bleu ( 95 % statistical significance level is  X  0 . 53 Bleu). However, we need 300 times big-ger model to get such an increase. Unfortunately, it is not possible to integrate such a big model inside a decoder using normal computation resources.

A better way of reducing the size of n -grams is to use entropy pruning (Stolcke, 1998). Table 2 shows the results with entropy pruning with different set-tings of  X  . We see that for three settings of  X  equal to 1 e -10 , 5 e -10 and 1 e -9 , we get Bleu scores compara-ble to the exact model. However, the size of all these models is not at all small. The size of smallest model is 25 % of the exact model. Even with this size it is still not feasible to integrate such a big model inside a decoder. If we take a model of size comparable to count cutoff of 100 , i.e., with  X  = 5 e-7 , we see both count-based pruning as well as entropy pruning per-forms the same.

There also have been prior work on maintain-ing approximate counts for higher-order language models (LMs) ((Talbot and Osborne, 2007a; Tal-bot and Osborne, 2007b; Talbot and Brants, 2008)) operates under the model that the goal is to store a compressed representation of a disk-resident table of counts and use this compressed representation to an-swer count queries approximately.

There are two difficulties with scaling all the above approaches as the order of the LM increases. Firstly, the computation time to build the database of counts increases rapidly. Secondly, the initial disk storage required to maintain these counts, prior to building the compressed representation is enormous.
The method we propose solves both of these prob-lems. We do this by making use of the streaming al-gorithm paradigm (Muthukrishnan, 2005). Working under the assumption that multiple-GB models are infeasible, our goal is to instead of estimating a large model and then compressing it, we directly estimate a small model. We use a deterministic streaming al-gorithm (Manku and Motwani, 2002) that computes approximate frequency counts of frequently occur-ring n -grams. This scheme is considerably more ac-curate in getting the actual counts as compared to other schemes (Demaine et al., 2002; Karp et al., 2003) that find the set of frequent items without car-ing about the accuracy of counts.
 We use these counts directly as features in an SMT system, and propose a direct way to integrate these features into an SMT decoder. Experiments show that directly storing approximate counts of fre-quent 5 -grams compared to using count or entropy-based pruning counts gives equivalent SMT perfor-mance, while dramatically reducing the memory us-age and getting rid of pre-computing a large model. 2.1 n -gram Language Models Language modeling is based on assigning probabil-ities to sentences. It can either compute the proba-bility of an entire sentence or predict the probability of the next word in a sequence. Let w m quence of words ( w estimating word w where n denotes the size of n -gram. This assump-tion that probability of predicting a current word de-pends on the previous words is called a Markov as-sumption, typically estimated by relative frequency: Eq 1 estimates the n -gram probability by taking the ratio of observed frequency of a particular sequence and the observed frequency of the prefix. This is precisely the relative frequency estimate we seek. 2.2 Large-scale Language modeling Using higher order LMs to improve the accuracy of SMT is not new. (Brants et al., 2007; Emami et al., 2007) built 5 -gram LMs over web using dis-tributed cluster of machines and queried them via network requests. Since the use of cluster of ma-chines is not always practical, (Talbot and Osborne, 2007b; Talbot and Osborne, 2007a) showed a ran-domized data structure called Bloom filter, that can be used to construct space efficient language models for SMT. (Talbot and Brants, 2008) presented ran-domized language model based on perfect hashing combined with entropy pruning to achieve further memory reductions. A problem mentioned in (Tal-bot and Brants, 2008) is that the algorithm that com-putes the compressed representation might need to retain the entire database in memory; in their paper, they design strategies to work around this problem. (Federico and Bertoldi, 2006) also used single ma-chine and fewer bits to store the LM probability by using efficient prefix trees. based LMs together with word-based LMs to im-prove SMT performance despite the large size of the word-based models used. (Schwenk and Koehn, 2008; Zhang et al., 2006) used higher language mod-els at time of re-ranking rather than integrating di-rectly into the decoder to avoid the overhead of keeping LMs in the main memory since disk lookups are simply too slow. Now using higher order LMs at time of re-ranking looks like a good option. How-ever, the target n -best hypothesis list is not diverse enough. Hence if possible it is always better to inte-grate LMs directly into the decoder. 2.3 Streaming Consider an algorithm that reads the input from a read-only stream from left to right, with no ability to go back to the input that it has already processed. This algorithm has working storage that it can use to store parts of the input or other intermediate compu-tations. However, (and this is a critical constraint), this working storage space is significantly smaller than the input stream length. For typical algorithms, the storage size is of the order of log k N , where N is the input size and k is some constant.

Stream algorithms were first developed in the early 80s, but gained in popularity in the late 90s as researchers first realized the challenges of dealing with massive data sets. A good survey of the model and core challenges can be found in (Muthukrish-nan, 2005). There has been considerable work on the problem of identifying high-frequency items (items with frequency above a threshold), and a detailed re-view of these methods is beyond the scope of this ar-ticle. A new survey by (Cormode and Hadjielefthe-riou, 2008) comprehensively reviews the literature. Prior work on approximate frequency estimation for language models provide a  X  X o-false-negative X  guar-antee, ensuring that counts for n -grams in the model are returned exactly, while working to make sure the false-positive rate remains small (Talbot and Os-borne, 2007a). The notion of approximation we use is different: in our approach, it is the actual count values that will be approximated. We also exploit the fact that low-frequency n-grams, while consti-tuting the vast majority of the set of unique n-grams, are usually smoothed away and are less likely to in-fluence the language model significantly. Discard-ing low-frequency n -grams is particularly important in a stream setting, because it can be shown in gen-eral that any algorithm that generates approximate frequency counts for all n -grams requires space lin-ear in the input stream (Alon et al., 1999).
We employ an algorithm for approximate fre-quency counting proposed by (Manku and Motwani, 2002) in the context of database management. Fix parameters s  X  (0 , 1) , and  X   X  (0 , 1) , X   X  s . Our goal is to approximately find all n -grams with fre-quency at least sN . For an input stream of n -grams of length N , the algorithm outputs a set of items (and frequencies) and guarantees the following:  X  All items with frequencies exceeding sN are  X  No item with frequency less than ( s  X   X  ) N is  X  All reported frequencies are less than the true  X  The space used by the algorithm is
A simple example illustrates these properties. Let us fix s = 0 . 01 , X  = 0 . 001 . Then the algorithm guar-antees that all n -grams with frequency at least 1% will be returned, no element with frequency less than 0 . 9% will be returned, and all frequencies will be no more than 0 . 1% away from the true frequencies. The space used by the algorithm is O (log N ) , which can be compared to the much larger (close to N ) space needed to store the initial frequency counts. In addi-tion, the algorithm runs in linear time by definition, requiring only one pass over the input. Note that  X N , and so the algorithm uses optimal space (up to a logarithmic factor). 3.1 The Algorithm We present a high-level overview of the algorithm; for more details, the reader is referred to (Manku and Motwani, 2002). The algorithm proceeds by conceptually dividing the stream into epochs , each containing 1 / X  elements. Note that there are  X N epochs. Each such epoch has an ID, starting from 1 . The algorithm maintains a list of tuples 1 of the form ( e,f,  X ) , where e is an n -gram, f is its re-ported frequency, and  X  is the maximum error in the frequency estimation. While the algorithm reads n -grams associated with the current epoch, it does one of two things: if the new element e is contained in the list of tuples, it merely increments the frequency count f . If not, it creates a new tuple of the form ( e, 1 ,T  X  1) , where T is the ID of the current epoch.
After each epoch, the algorithm  X  X leans house X  by eliminating tuples whose maximum true frequency is small. Formally, if the epoch that just ended has ID T , then the algorithm deletes all tuples sat-isfying condition f +  X   X  T . Since T  X   X N , this ensures that no low-frequency tuples are re-tained. When all elements in the stream have been processed, the algorithm returns all tuples ( e,f,  X ) where f  X  ( s  X   X  ) N . In practice, however we do not care about s and return all tuples. At a high level, the reason the algorithm works is that if an element has high frequency, it shows up more than once each epoch, and so its frequency gets updated enough to stave off elimination. We conduct a set of experiments with approxi-mate n -gram counts (stream counts) produced by the stream algorithm. We define various metrics on which we evaluate the quality of stream counts com-pared with exact n -gram counts (true counts). To evaluate the quality of stream counts on these met-rics, we carry out three experiments. 4.1 Experimental Setup The freely available English side of Europarl (EP) and Gigaword corpus (Graff, 2003) is used for computing n -gram counts. We only use EP along with two sections of the Gigaword corpus: Agence France Press English Service(afe) and The New York Times Newswire Service (nyt). The unigram language models built using these corpuses yield better perplexity scores on the development set (see Section 5.1) compared to The Xinhua News Agency English Service (xie) and Associated Press World-stream English Service (apw) as shown in Table 3. The LMs are build using the SRILM language mod-elling toolkit (Stolcke, 2002) with modified Kneser-Ney discounting and interpolation. The evaluation of stream counts is done on EP+afe+nyt (EAN) cor-pus, consisting of 1.1 billion words. 4.2 Description of the metrics To evaluate the quality of counts produced by our stream algorithm four different metrics are used. The accuracy metric measures the quality of top N stream counts by taking the fraction of top N stream counts that are contained in the top N true counts. Accuracy = Spearman X  X  rank correlation coefficient or Spear-man X  X  rho(  X  ) computes the difference between the ranks of each observation (i.e. n -gram) on two vari-ables (that are top N stream and true counts). This measure captures how different the stream count or-dering is from the true count ordering. d is the difference between the ranks of correspond-ing elements X found in both sets; X stream and true counts.

Mean square error (MSE) quantifies the amount by which a predicted value differs from the true value. In our case, it estimates how different the stream counts are from the true counts.
 true and predicted denotes values of true and stream counts; N denotes the number of stream counts con-tained in true counts. 4.3 Varying  X  experiments In our first experiment, we use accuracy,  X  and MSE metrics for evaluation. Here, we compute 5 -gram stream counts with different settings of  X  on the EAN corpus.  X  controls the number of stream counts pro-duced by the algorithm. The results in Table 4 sup-port the theory that decreasing the value of  X  im-proves the quality of stream counts. Also, as ex-pected, the algorithm produces more stream counts with smaller values of  X  . The evaluation of stream counts obtained with  X  = 50 e -8 and 20 e -8 reveal that the stream counts learned with this large value are more susceptible to errors.

If we look closely at the counts for  X  = 50 e -8 , we see that we get at least 30 % of the stream counts from 245 k true counts. This number is not signifi-cantly worse than the 36 % of stream counts obtained from 4 , 018 k true counts for the smallest value of  X  = 5 e-8 . However, if we look at the other two met-rics, the ranking correlation  X  of stream counts com-pared with true counts on  X  = 50 e -8 and 20 e -8 is low compared to other  X  values. For the MSE, the error with stream counts on these  X  m values is again high compared to other values. As we decrease the value of  X  we continually get better results: decreasing  X  pushes the stream counts towards the true counts. However, using a smaller  X  increases the memory usage. Looking at the evaluation, it is therefore ad-visable to use 5 -gram stream counts produced with at most  X   X  10 e -7 for the EAN corpus.

Since it is not possible to compute true 7 -grams counts on EAN with available computing resources, we carry out a similar experiment for 7 -grams on EP to verify the results for higher order n -grams 2 . The results in Table 5 tell a story similar to our results for 7 -grams. The size of EP corpus is much smaller than EAN and so we see even better results on each of the metrics with decreasing the value of  X  . The overall trend remains the same; here too, setting  X   X  10 e -8 is the most effective strategy. The fact that these results are consistent across two datasets of different sizes and different n -gram sizes suggests that they will carry over to other tasks. 4.4 Varying top K experiments In the second experiment, we evaluate the quality of the top K (sorted by frequency) 5 -gram stream counts. Here again, we use accuracy,  X  and MSE for evaluation. We fix the value of  X  to 5 e -8 and com-pute 5 -gram stream counts on the EAN corpus. We vary the value of K between 100 k and 4 , 018 k (i.e all the n -gram counts produced by the stream algo-rithm). The experimental results in Table 6 support the theory that stream count algorithm computes the exact count of most of the high frequency n -grams. Looking closer, we see that if we evaluate the algo-rithm on just the top 100 k 5 -grams (roughly 5 % of all 5 -grams produced), we see almost perfect results. Further, if we take the top 1 , 000 k 5 -grams (approx-imately 25 % of all 5 -grams) we again see excellent performance on all metrics. The accuracy of the re-sults decrease slightly, but the  X  and MSE metrics are not decreased that much in comparison. Perfor-mance starts to degrade as we get to 2 , 000 k (over 50% of all 5 -grams), a result that is not too surpris-ing. However, even here we note that the MSE is low, suggesting that the frequencies of stream counts (found in top K true counts) are very close to the true counts. Thus, we conclude that the quality of the 5 -gram stream counts produced for this value of  X  is quite high (in relation to the true counts).
As before, we corroborate our results with higher order n -grams. We evaluate the quality of top K 7 -corpus, we evaluate the stream counts produced by setting  X  to 10 e -8 . Here we vary the value of K be-tween 10 k and 246 k (the total number produced by the stream algorithm). Results are shown in Table 7. As we saw earlier with 5 -grams, the top 10 k (i.e. approximately 5 % of all 7 -grams) are of very high quality. Results, and this remains true even when we increase K to 100 k . There is a drop in the accu-racy and a slight drop in  X  , while the MSE remains the same. Taking all counts again shows a signifi-cant decrease in both accuracy and  X  scores, but this does not affect MSE scores significantly. Hence, the 7 -gram stream counts i.e. 246 k counts produced by  X  = 10 e -8 are quite accurate when compared to the top 246 k true counts. 4.5 Analysis of tradeoff between coverage and In our third experiment, we investigate whether a large LM can help MT performance. We evaluate the coverage of stream counts built on the EAN cor-pus on the test data for SMT experiments (see Sec-tion 5.1) with different values of  X  m. We compute the recall of each model against 3071 sentences of test data where recall is the fraction of number of n -grams of a dataset found in stream counts.

We build unigram, bigram, trigram, 5 -gram and 7 -gram with four different values of  X  . Table 8 con-tains the gzip size of the count file and the recall of various different stream count n -grams. As ex-pected, the recall with respect to true counts is max-imum for unigrams, bigrams, trigrams and 5 -grams. However the amount of space required to store all true counts in comparison to stream counts is ex-tremely high: we need 4 . 8 GB of compressed space to store all the true counts for 5 -grams.

For unigram models, we see that the recall scores are good for all values of  X  . If we compare the approximate stream counts produced by largest  X  (which is worst) to all true counts, we see that the stream counts compressed size is 50 times smaller than the true counts size, and is only three points worse in recall. Similar trends hold for bigrams, although the loss in recall is higher. As with uni-grams, the loss in recall is more than made up for by the memory savings (a factor of nearly 150 ). For trigrams, we see a 14 point loss in recall for the smallest  X  , but a memory savings of 400 times. For 5 -grams, the best recall value is . 020 ( 1 . 2 k out of 60 k 5 -gram stream counts are found in the test set). However, compared with the true counts we only loss a recall of 0 . 05 ( 4 . 3 k out of 60 k ) points but memory savings of 150 times. In extrinsic evalua-tions, we will show that integrating 5 -gram stream counts with an SMT system performs slightly worse than the true counts, while dramatically reducing the memory usage.
For 7 -gram we can not compute the true n -gram counts due to limitations of available computational resources. The memory requirements with smallest value of  X  are similar to those of 5 -gram, but the re-call values are quite small. For 7 -grams, the best re-call value is 5 . 9 e -4 which means that stream counts contains only 32 out of 54 k 7 -grams contained in test set. The small recall value for 7 -grams suggests that these counts may not be that useful in SMT. We further substantiate our findings in our extrinsic evaluations. There we show that integrating 7 -gram stream counts with an SMT system does not affect its overall performance significantly. 5.1 Experimental Setup All the experiments conducted here make use of publicly available resources. Europarl (EP) corpus French-English section is used as parallel data. The ing and decoding (Koehn and Hoang, 2007). The news corpus released for ACL SMT workshop in 2007 consisting of 1057 sentences 5 is used as the de-velopment set. Minimum error rate training (MERT) is used on this set to obtain feature weights to opti-mize translation quality. The final SMT system per-formance is evaluated on a uncased test set of 3071 sentences using the BLEU (Papineni et al., 2002), NIST (Doddington, 2002) and METEOR (Banerjee and Lavie, 2005) scores. The test set is the union of the 2007 news devtest and 2007 news test data from 5.2 Integrating stream counts feature into Our method only computes high-frequency n -gram counts; it does not estimate conditional probabili-ties. We can either turn these counts into conditional probabilities (by using SRILM) or use the counts di-rectly. We observed no significant difference in per-formance between these two approaches. However, using the counts directly consumes significantly less memory at run-time and is therefore preferable. Due to space constraints, SRILM results are omitted.
The only remaining open question is: how should we turn the counts into a feature that can be used in an SMT system? We considered several alternatives; the most successful was a simple weighted count of n -gram matches of varying size, appropriately backed-off. Specifically, consider an n -gram model. For every sequence of words w obtain a feature score computed recursively accord-ing to Eq (2). count in the count set (the presence of Z is simply to ensure that these values remain manageable). In or-der to efficiently compute these features, we store the counts in a suffix-tree. The computation pro-ceeds by first considering w  X  X xpanding X  to consider the bigram, then trigram and so on. The advantage to this order of computa-tion is that the recursive calls can cease whenever a zero count is reached. (Extending Moses to include this required only about 100 lines of code.) 5.3 Results Table 9 summarizes SMT results. We have 4 base-line LMs that are conventional LMs smoothed using modified Kneser-Ney smoothing. The first two tri-gram and 5 -gram LMs are built on EP corpus and the other two are built on EAN corpus. Table 9 show that there is not much significant difference in SMT results of 5 -gram and trigram LM on EP. As expected, the trigram built on the large corpus EAN gets an improvement of 1 . 5 Bleu Score. How-ever, unlike the EP corpus, building a 5 -gram LM on EAN (huge corpus) gets an improvement of 3 . 2 Bleu Score. (The 95 % statistical significance bound-ary is about  X  0 . 53 Bleu on the test data, 0.077 Nist and 0.16 Meteor according to bootstrap resampling) We see similar gains in Nist and Meteor metrics as shown in Table 9.

We use stream counts computed with two values of  X  , 5 e-8 and 10 e-8 on EAN corpus. We use all the stream counts produced by the algorithm. 4 , 5 , 7 and 9 order n -gram stream counts are computed with these settings of  X  . These counts are used along with a trigram LM built on EP to improve SMT perfor-mance. The memory usage (Mem) shown in Table 9 is the full memory size required to run on the test data (including phrase tables).

Adding 4 -gram and 5 -gram stream counts as fea-ture helps the most. The performance gain by using 5 -gram stream counts is slightly worse than com-pared to true 5 -gram LM on EAN. However, using 5 -gram stream counts directly is more memory ef-ficient. Also, the gains for stream counts are ex-actly the same as we saw for same sized count-based and entropy-based pruning counts in Table 1 and 2 respectively. Moreover, unlike the pruning methods, our algorithm directly computes a small model, as opposed to compressing a pre-computed large model.

Adding 7 -gram and 9 -gram does not help signifi-cantly, a fact anticipated by the low recall of 7 -gram-based counts that we saw in Section 4.5. The results with two different settings of  X  are largely the same. This validates our intrinsic evaluation results in Sec-tion 4.3 that stream counts learned using  X   X  10 e-8 are of good quality, and that the quality of the stream counts is high. We have proposed an efficient, low-memory method to construct high-order approximate n -gram LMs. Our method easily scales to billion-word monolin-gual corpora on conventional ( 8 GB) desktop ma-chines. We have demonstrated that approximate n -gram features could be used as a direct replacement for conventional higher order LMs in SMT with significant reductions in memory usage. In future, we will be looking into building streaming skip n -grams, and other variants (like cluster n -grams).
In NLP community, it has been shown that having more data results in better performance (Ravichan-dran et al., 2005; Brants et al., 2007; Turney, 2008). At web scale, we have terabytes of data and that can capture broader knowledge. Streaming algorithm paradigm provides a memory and space-efficient platform to deal with terabytes of data. We hope that other NLP applications (where we need to com-pute relative frequencies) like noun-clustering, con-structing syntactic rules for SMT, finding analogies, and others can also benefit from streaming methods. We also believe that stream counts can be applied to other problems involving higher order LMs such as speech recognition, information extraction, spelling correction and text generation.
