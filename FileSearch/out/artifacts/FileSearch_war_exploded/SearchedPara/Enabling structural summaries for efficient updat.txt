 1. Introduction
In recent years, eXtensible Markup Language (XML) [1] has become the dominant standard for exchang-ments describe the semantics of data. The references between elements can be established through id/idref attributes or Xlink constructs [1,4] .
A variety of query languages [2,5 X 7] have been proposed to query XML and semi-structured data. All these summary. Since the naive navigation that scans the whole data is obviously very expensive in term of compu-graph consisting of a structural summary along with a mapping from data nodes to index nodes, instead of source data, is used to evaluate path expressions. Similar to APEX, we also employ a structural summary.
However, in this paper we makes use of the concept of local similarity to make structural summary adaptive to query pattern changes and also study the structural summary updates upon source data changes.
Structural summary is based on the notion of bisimilarity [13,14] . On the graph data model, two nodes are both safe and sound . Path expressions can be evaluated on 1-index and evaluation results can be directly retrieved without referring to source data. Unfortunately, 1-index summaries usually remain big, hence can lence condition and considers only the incoming paths of length 6 k . Experiments have demonstrated that false positives.
 ally expensive validation process. The key observation exploited by our new index proposal is that not all terns optimally .
 real applications but have not been adequately addressed in previous literatures. Our major contributions are summarized as follows: (1) We propose D ( k )-index and present its efficient construction algorithms. Unlike previous proposals, (3) We demonstrate through extensive experiments that D ( k )-index is a more effective structural summary paper include: (1) Besides the basic index construction algorithm, we present a more sophisticated, greedy method to opti-(2) Besides the subgraph and edge additions, we consider updating D ( k )-index upon a comprehensive set of (3) The experimental evaluation is more elaborate. Besides comparing the query and update performance of
The remainder of this paper is organized as follows. In Section 2 , we introduce the data model and some techniques. Finally, we conclude this paper with some future research suggestions in Section 8 . 2. Preliminaries
We model XML and other semi-structured data as a directed and labeled graph. Each node has a label and with the distinguished label, ROOT. The edges indicate element X  X ubelement or element X  X alue relationships. The structure of an XML document is basically a tree. The presence of references makes it a graph. In
Fig. 1 , a portion of an XML document about movies is represented as a data graph. Tree edges, shown as both as normal edges.

We now introduce the terminologies of paths and path expressions. A node path in a data graph G is a sequence of nodes v 1 v 2 v p such that an edge exists between nodes v is a sequence of labels L 1 L 2 L p . A node path matches a label path if Label( v path P matches a node v in G if there exists a node path into node v matching P .
 expression(?) as follows: in which the symbol _ matches any label in G . We denote the regular language specified by R as L ( R ). R appear directly after movieDB or be a child of any node whose parent is movieDB . The expression matches nodes {12,22} in Fig. 1 .

The idea of structural summary is to preserve paths of a data graph in a summary graph but with a far uate path expressions on summary graph instead of data graph. We denote the index graph for G as I node V in I G , it matches every data node in extent ( V ).
 Structural summary is based on the notion of bisimilarity [11,16] .

Definition 1. Two data nodes u and v in G are bisimilar( u v ) iff (1) u and v have the same label; (2) if u has a parent u 0 , then v has a parent v 0 such that v has not. 3. D ( k )-index 3.1. Introduction to D(k)-index An accurate structural summary is constructed through creating an index node for each equivalence class.
An edge is inserted from index node V to U in I G if there is an edge v ! u in G with v 2 extent ( V )and and m is the number of edges in G .

Definition 2. k -bisimilarity( k ) is defined inductively: for two data nodes u and v : (1) u 0 v iff u and v have the same label; (2) u k v iff
A ( k )-index possesses the following properties: (1) If u k v , the set of label paths of length p ( p 6 k ) matching u or v in G is the same. (2) A label path of length p ( p 6 k ) matching an index node V in I (3) A ( k )-index is safe . (4) A ( k )-index is sound for path expressions of length p ( p 6 k ).
 tural patterns present in a query load.
 We first prove a theorem establishing D ( k )-index as a correct structural summary.
Theorem 1. Given a node path N 1 N 2 N p in I G and Label(N is at least (i 1)-bisimilar, the label path L 1 L 2 L p matches all data nodes in extent(N the result is true for p = t . Let us now consider the case when p = t + 1 and P = N
L
L 2 L t matches all data nodes in extent ( N t ) according to the assumption. Since there is an edge N in I G , there should be some data node v in extent ( N t +1
Because the label path L 1 L 2 L t matches data node u , the label path L
Since the data nodes in extent ( N t +1 ) are at least t -bisimilar, the label path L Let K ( N i ) denote index node N i  X  X  local similarity in I
K ( N i ) P K ( N j ) 1 for any two directly connected index nodes N result in I G N 1 N 2 N p is sound as long as K ( N p ) P p 1. We call such index structure D ( k )-index.
Definition 3. D ( k )-index is a structural summary I G satisfying K ( N connected index nodes N i ! N j .
 and Theorem 1 . (1) D ( k )-index is safe . (2) D ( k )-index is sound for a path expression P of length p if every matching node path of P in I
Algorithm 1. Target local similarity broadcast algorithm (1) Sort the target local similarities of all labels in I (2) For each k i ,1 6 i 6 t , repeat: 3.2. Construction 3.2.1. Basic approach index nodes X  local similarities equal to 0.

We use k max to denote the maximal local similarity any index node can have on a D ( k )-index. If the max-imal length, p max , of path expressions querying a label is less than k
D ( k )-index structural requirements. Suppose that two directly connected nodes N The index nodes on a D ( k )-index are refined using the approach proposed in [12] . For an index node U in I with u 2 extent ( U )}. Given two index nodes U and V in I
Beginning with k = 1, it repeatedly computes k -bisimulation equivalence classes from ( k 1)-bisimulation is the maximal target local similarity. A construction example is also shown in Fig. 2 .
Algorithm 2. The basic construction algorithm (1) Build the label-split index graph I G from G ; (2) Use the query load and Algorithm 1 to set target local similarities; (3) For k =1to k max 3.2.2. Greedy approach overcome these shortcomings, we propose a more sophisticated, greedy approach to construct D ( k )-index. refinement is defined to be the ratio between the evaluation performance improvement and the index size ported by D ( k )-index.

Algorithm 3. The greedy construction algorithm (1) For each path P i in a query load Q (2) Repeat until I G reaches its size limit:
Because no standard storage scheme and query cost model exists for graph-structured data, we adopt the ligible, we measure the evaluation performance improvement by the decrease in the number of data nodes to be validated times the length of query path.

We measure the index size increase by the number of newly created index nodes. If G is tree-structured, the estimation is straightforward. Suppose that an index node V has t parents in I number of U -labeled parents, denoted as aver ( U , V ). Suppose that a W -labeled index node W parents and t 2 V -labeled parents in I G . Since each data node in extent ( W parents in G and the maximal number of distribution probabilities of aver ( U , W ) data nodes among t partitioning W 1 according to its t 1 U -labeled parents is estimated to be C total number of index nodes resulting from partitioning W ber of new index nodes as a result of partitioning W 1 according to its parents to be C Extending this estimation method to the case of multiple parent labels is straightforward. Algorithm 4. The single refinement algorithm: Single_Refinement( V , k , I (1) If ( K ( V ) P k ) return I G ; (2) For each parent U i of V in I G (3) For each parent U i of V in I G (4) Return I G . refers to D ( k )-index I G but not G . This is crucial for the algorithm X  X  efficiency. in a recursive way. 4. Updating D ( k )-index
In [16] , two types of update operations upon source data were considered for updating an index: subgraph addition and new edge addition. Subgraph addition represents the insertion of a new document into database. update algorithms upon these two basic cases. Then we proceed to demonstrate that our approaches can flex-ibly accommodate other defined update operations on XML documents. 4.1. Subgraph addition
The D ( k )-index update algorithm for subgraph addition is a variant of the 1-index update algorithm pro-D ( k )-index I H for H and adds I H as an index subgraph under the root of I correctness is established by the following theorem. It is essentially a variant of Theorem 1 in [16] . Theorem 2. If I G is G X  X  D(k)-index and I 0 G is a refinement of I 4.2. Edge addition of main memory. Instead of refining index nodes, D ( k )-index accommodates small updates in source data rithms on D ( k )-index than on its predecessors.
 new edge from c 3 to d 2 does not change the label set of d 1 and its child E  X  X  be set to 2 . Suppose that a new edge from U local similarity. It is observed that if all label paths of length k ( 6 K ( V
V ilarity for V 1 is described in Algorithm 5 .

Algorithm 5. The single local similarity resetting algorithm k max the upperbound of V 1  X  X  new local similarity kV 1  X  X  current local similarity
NewPaths ( i ) the set of label paths of length i into V 1
OldPaths ( i ) the set of label paths of length i into V 1
S ( P ) the set of starting nodes of node paths into V 1 matching P through U
S ( P ) the set of starting nodes of node paths into V 1 matching P in the original I (1) k max = K ( V 1 ), k =0; (2) NewPaths (1) = { Label ( U 1 )}, S n ( Label ( U 1 )) = { U (3) OldPaths (1) = { L j L is the label of V 1  X  X  parent in the original I
S o ( Label ( U 1 )) = { U i j U i ! V 1 and Label ( U i )= Label ( U (4) While ( k 6 k max ) to V 1  X  X  descendants in I G . An index node with distance d from V originally larger than ( k + d ). In the worst case, Algorithm 5 involves all nodes within distance k to V following broadcast algorithm involves all nodes within distance ( K ( V and A ( k )-index. We will validate our claims empirically in the experimental evaluation section. 4.3. Update operations upon XML
In recent years, there were a few proposals for updating XML documents, such as XUpdate [18] , the work in [17] , XML-RL Update Language [19] and XQuery Update Facility [20] . Even though these proposals differ applied on XML documents because in term of structural summary updating, they represent currently defined
XML update operations well.
The paper [17] uses the term object to refer to an XML component, which can be an element, an attribute, an IDREF or a PCDATA content, and assumes the presence of tuples of references to selected objects within
XML documents through a path expression matching operation. Six primitive XML update operations are defined as (1) Delete ( child ): if child is a member of the target object , it is removed; (2) Insert ( content ): it inserts a new content into the target object ; (3) Rename ( child , name ): if child is a non-PCDATA member of the target object , it is renamed. (5) Replace ( child , content ): it replaces child with content ; Delete , Insert and Rename .
 Before that, we consider the D ( k )-index update upon another type of incremental change: edge deletion. are U 1 and V 1 in I G respectively. If v is still connected with some data node in extent ( U into V 1 through U 1 ! V 1 match V 1 in I G without edge U variant of Algorithm 5 can be used to determine V 1  X  X  maximal new local similarity. 4.3.1. Delete(child)
The affected index nodes X  local similarities remain unchanged. 4.3.2. Insert(content) for content in I G . Its extent contains the only data node and its local similarity is set to be K ( V
V is V  X  X  parent in I G . 4.3.3. Rename(child,name) steps: (1) It creates a new index node L i labeled L for v and assigns 1+min{ K ( U (2) Reset the local similarities of L i  X  X  descendants in I
At step two, we first reset the local similarities of L i into X i through V i or L i in I G match X i in the original I
X  X  X  local similarity is concerned, the Rename operation amounts to an edge deletion operation (from v to some data node in extent ( X i )) followed by an edge insertion operation (from renamed v in extent ( L data node in extent ( X i )). Similarly, a minor variant of Algorithm 5 can be applied to determine X new local similarity.
 5. Adjusting D ( k )-index decrease gradually. At the same time, changes in query load may demand higher local similarities for some propose promoting/demoting procedures to upgrade/degrade index nodes X  local similarities in D ( k )-index.
They are supposed to be executed periodically to tune D ( k )-index structure for high query performance. 5.1. Promoting process
The process to promote a single index node X  X  local similarity has been described in Algorithm 4 . In real is conducted in an orderly way:
For instance, suppose that there is a path A 1 ! B 1 ! C 1 ilarity of 3. B 1 and C 1 are to be promoted to 5. At the first step, we record ( A the second step, A 1 and B 1 are promoted to 4. The resulting index nodes B
Compared with random one-by-one promotion, the ordered promotion reduces over-promotion cases: if B first promoted to 5, C 1 would be unnecessarily partitioned according to B of 5. Over-promotion is undesirable because it increases index size.

The promotion can also be performed in the greedy approach described in Section 3.2.2 . At each step, it thus omitted here. 5.2. Demoting process
The demoting process downgrades index nodes X  local similarities. Lower local similarities make it possible to merge index nodes of the same label, thus achieve smaller index size.
 local similarities, since the current D ( k )-index I 0 G by treating I 0 G as a data graph. 6. Experimental study tigate how its performance varies with changes to source data and query workload. For comparative purposes, we choose to measure the relative performance of other indexes based on bisimilarity which can support the (1) Achieve comparable or higher query performance with a smaller index size; (2) Be updated efficiently by deferring propagation to a maintenance procedure; (3) Achieve reasonable query performance, even when propagation is deferred for data updates, or when (4) Be periodically maintained to preserve its query performance.
We perform our experiments on two datasets: (1) XMark: This is a synthetic dataset from an XML benchmark suite [21] , which produces XML docu-(2) NASA: This dataset is based on a DTD designed by the XML Group at the NASA Goddard Space All experiments are implemented in C++, and executed under Linux 2.6 kernel. The machine used has a
Pentium 4 2.8 GHz processor and 512 MB RAM. 6.1. Query performance
Due to lack of an external memory cost model for graph-structured data querying, we assume that both index graph and source data reside in primary memory during execution. Previously [15] , we used the number of nodes traversed on data and index graphs to measure query performance. We choose to present our results here using elapsed CPU time instead, so that relative comparisons can be made between query, update and is no difference in the characteristics of the graphs.

For each dataset, we randomly generate a query workload consisting of 100 distinct paths with lengths evenly distributed between 1 and 5. A random label is first chosen among all possible labels in the DTD, a random data node of that label is then selected. From the data node, we obtain a random path in the data that is a representative mixture of both selective and unselective paths.

We present two flavors of D ( k )-index. The max-k variant has a parameter k analogous to that of A ( k )-index. For a given workload, the maximal position of each label within the query paths is noted. Within
The max-k variant with k = 5, denoted D (5), for example, does not require any validation since paths have validation. D [70%], for example, can evaluate at least 70% of paths without accessing the data graph. age ranging 65 X 95% in 5% increments. Query performance on the XMark and NASA datasets are presented in Fig. 4 .
 diminishing returns on performance when we allow more information to be stored in the indexes. For A ( k )-structures diverge, thereby requiring more space to be indexed. Unsurprisingly, for any value of k , the local similarities that would not be taken advantage of during query evaluation.

In comparison, the isl variant achieves an even faster convergence behavior by recognizing that not all which requires the user to have some knowledge of the nature of the workload (e.g. typical length of query paths), the isl variant also has the benefit of admitting a more automatic, rule of thumb administration (e.g. 80 X 20 rule).

It is possible to milk even more performance by further noting within the workload the parent labels which of the query performance under unchanging source data and a static workload represents the best case sce-nario for D ( k )-index. In general, query performance varies when data updates or workload changes occur, for certain classes of applications. 6.2. Update performance
To measure update performance, we insert new edges between the pair of data nodes whose labels compose an ID/IDREF pair in the DTD file. We choose nine ID/IDREF label pairs and generate 3000 edges that are uniformly distributed among these pairs.
 We use a variant of the 1-index update algorithm [16] to update A ( k )-index. Suppose that a new edge
U ! V is inserted into I G because of an edge insertion u ! v in G . The maximal new local similarity k
V can be determined in the same way as on D ( k )-index. If k tors within distance ( k k n ) into new index nodes in I G will be preserved on the resulting index.

In addition to what has been presented in [15] , we introduce several optimization techniques in this paper time of determining an index node X  X  maximal local similarity is linear with the number of edges in I
A ( k )-index update performance is improved by an order of magnitude. Secondly, the algorithm associates a of 5.
 Moreover, its update performance is independent of parameters and remains roughly unchanged.
In our experiments, it is assumed that source data resides entirely in main memory. It is worthy to empha-to be stored in external memory, the performance difference is supposed to be even starker.
An update algorithm for A ( k )-index with a provable guarantee on the resultant index X  X  quality has also ing. Our algorithm instead separates the merging phase from the update operation. This choice is based on two experimental observations: (1) the query cost is dominated by the number of data nodes validated, not 6.3. Evaluation performance variation with updates make evaluations trigger more validations.

Our experiment tracks the size increase of A ( k )-index over a sequence of 300 incremental updates, edge ( k &gt; 3). On XMark data, the size increase after 300 updates amounts to more than 100% when k = 2 or 3; it is more moderate while k is larger, 45% for k = 4 and 13% for k = 5. On NASA data, the size increase is quite moderate for all values of k . It is roughly between 10% and 20%.
 are shown in figure. Results on A ( k )-index with k = 1 and 2 follow the same trend as presented here.
D ( k )-index performance degradation is sharper on both data. D ( k )-index performance on XMark data is visibly worse than that of A (4) or A (5)-index after updates. On NASA data, D ( k )-index performance deterioration is less dramatic. Since the majority of paths in NASA data do not contain ID / IDREF labels, updates do not affect the evaluation cost of most queries in the workload. Our experiments verify the claim that local similarity downgrading may severely affect D ( k )-index performance. 6.4. Evaluation performance variation with changing query load
We study A ( k )and D ( k )-index query performance variation upon the changing workload through adding scratch easily outperform original ones. 6.5. Maintaining indexes
Our study on D ( k )-index performance variation with incremental updates and changing workload justifies promote index nodes and then merge them if possible.

We compare the maintenance performance of A ( k )-index with 3 6 k 6 5 and D ( k ) with k maintenance process is invoked only after a considerable number of updates; (2) as demonstrated later, the price to pay.
The maintenance operation X  X  effectiveness to improve D ( k )-index evaluation performance is demonstrated in Fig. 10 .On A ( k )-index, even though the index can be shrunk to some extent, its overall performance remains roughly the same. In contrast, the performance improvement on D ( k )-index is much more dramatic.
Note that on NASA data, the evaluation cost is actually cut by half. The two dots before and after mainte-nance appear close because of the large value of Y -axis. 7. Related work
Three structural summaries have been proposed for graph-structured data, strong DataGuide [9] , 1-index
A path expression is then evaluated by matching an exact sequence of nodes in DataGuide. Since a data node may appear in extents of more than one index node, the size of a strong DataGuide may be exponential with queried, but the whole access patterns present in path expressions. Under the M ( k )-index proposal, index an improved way to construct index structure and can achieve ever higher evaluation performance.
Update algorithms have been proposed to maintain strong DataGuide [9] . However, because D ( k )-index, two update cases: document insertion and edge addition. The propagate refinement strategy was proposed to
The bisimulation technique comes from the verification research community [24] . It was used to compress for graph-structured data. Graph schema [27,28] is also a structural summary. However, its construction and explored their applications on query optimization.

There have been lots of other indexing strategies proposed for evaluating XML documents. Here we review cess path expression queries have also been proposed in [31,32] . Note that these indexing techniques were designed to handle tree-structured data. Extending them to accommodate graph-structured data is not that combines inverted lists with structural summary to optimize XML path expressing evaluation on the tree path expressions beginning at root. Compared with D ( k )-index, it is based on the assumption of tree data model and does not take advantage of query load to optimize the index structure. In [35] , a workload-aware path index, termed APEX, was introduced for XML data. APEX enhances a structural summary with a hash hash tree and retrieves the extents of the matching nodes on a summary graph. An incremental algorithm was also presented to adjust APEX upon changing query load. However, the authors did not address the problem of updating APEX upon source data change. The APEX work is complementary to our work. D ( k )-index, as a robust structural summary, can be flexibly adjusted to the changes on both query load and source data. The hash tree approach can be used to speed up the lookup on D ( k )-index. 8. Conclusion and future work and update performance.

The future work can be charted on two research fronts. Firstly, we currently assume that both the source data and its index can stay in main memory. The more practical assumption should be that only the index graph is in main memory, but the source data resides in external memory. It is important to investigate the structural summary proposal based on the external-memory cost model. Secondly, the actual queries on
XML or other graph-structured databases may involve values and more complicated query patterns (for instance, branch predicates). Extending structural summary to accommodate more general path expressions is, therefore, another interesting research direction. The FleXPath [36] and XFT algebra [37] approaches for integrating the structure and text queries on XML may be helpful to address this problem.
References
