 These years have seen the widespread use of transaction management in non-traditional applications. The transactions in these applications are different from tradi-tional transactions [1,2] for their long-time running and for that they may access data held in heterogeneous, autonomous and distributed systems. The ACID properties will be too strict for them to follow. To overcome the limitations of traditional trans-actions, some advanced transaction models (ATMs) [3] have been proposed, such as Sagas [4], closed/open nested transactions [5, 6], multi-level transactions [6], flexible transactions [7] and Contracts [8]. 
The mechanism of compensation is originally proposed by Gray in [9], and then widely used in ATMs to maintain atomicity when the isolation property has been cessfully committed. For example, for a DEPOSIT transaction, its compensating transaction can be a WITHDRAW. We take the Sagas model as an example to clarify how the compensation mechanism is used. In Sagas, the long transaction is divided into several short subtransactions each of which strictly follows the ACID properties. global transaction commits. For each subtransaction (except for the very last one), there exists a corresponding compensating transaction. When a subtransaction fails, it will firstly be rollbacked by a transaction manager and all its preceding subtransac-tions will be compensated by executing their corresponding compensating transac-tions in a reverse order. 
A compensating transaction has some special characteristics besides the fundamen-transaction X  X  effect in a semantic manner, rat her than by physically restoring to a prior state. Secondly, a compensating transaction is retriable, namely, once the compensat-ing transaction is invoked to execute, it will ultimately commit successfully. Thirdly, a compensating transaction is always regarded as being associated with a compen-sated-for transaction. In most situations, it is the programmer X  X  responsibility to pre-define a compensating transaction. 
Compensation mechanism is not only widely used in ATMs but also adopted by transactional workflows to maintain reliability and consistency of business processes. It is assumed that users can define for each task in a business process one compensat-ing task [11, 12]. When some committed tasks which are called compensated-for tasks need to be undone, their corresponding compensating tasks will be invoked. 
The loosely coupled property of Web services offers a good environment for busi-ness process collaborations. Some existing Web service protocols, such as WSCI [13], BPEL4WS [14] and WS-CDL [15] also provide some transaction management by supporting the open nested transaction model and compensation mechanism. 
Currently, each task can only have one compensating task. This compensation quirements. For example, when penalty has to be considered for carrying out compen-sation, different penalty polices will result in different compensation strategies. As a result, a multiple-compensation mechanism is necessary. This paper proposes a con-cept of multiple-compensation and describes how to incorporate it in workflow sys-tems. The rest of the article is organised as follows. Section 2 gives a motivating ex-ample to clarify the importance of multiple-compensation. Section 3 defines a busi-ness process model with the multiple-compensation feature. Section 4 introduces an algorithm on how to implement the multiple-compensation mechanism and analyse its complexity. Section 5 discusses the related work on compensation. Section 6 con-cludes the paper and indicates the future work. Consider a travel reservation process shown in Figure 1 as an example. The whole business process has ten tasks. Travellers will send their trip requests to a travel agent (SR). After receiving the request and sending back acknowledgment (SA), the travel agent will invoke two concurrent activities at the same time: to reserve proper tickets for the traveller via the airline company (BAT) and to book a hotel for the traveller to reside in the destination place (BH). Whether to rent a car in the visiting place is an optional task determined upon the traveller X  X  requirements (RC). During the booking process, travellers should provide their credit card information for identity validation. After all the necessary reservations have been completed, the travel agent will send an itinerary describing the reservation information and an invoice to the traveller (SBS). The traveller can send acknowledgment to confirm his or her bookings (ACK). Before confirm the booking by paying the money (TP). After the traveller finishes purchas-ing, the travel agent will send airplane ticket and confirmation letter for hotel booking and for car rental to the traveller. If the traveller cancels the booking or does not com-plete purchasing after departure, a penalty will apply. There exists compensation dependency among tasks. For example, since BAT and BH are concurrent tasks, and only when both of them successfully complete can the succeeding task be executed, consequently, either BAT or BH fails, the other commit-ted task should be compensated. 
Consider the situation for the traveller to cancel the booking after having sent out the acknowledgment information. Some corresponding compensation tasks should be companies such as the airline company will normally take actions based on some penalty policies for the sake of their own interests. The following table illustrated the penalty policies taken by an airline company. 
Time column indicates when the traveller cancels his booking, 2 weeks before de-different status of the users and correspondingly they have different privileges. Pen-alty column indicates the different charges the company will ask for due to the time to cancel and the user status. 
A penalty policy is associated with a compensation task and can be regarded as cases, leading to different compensation tasks. Our multi-compensation mechanism is motivated to deal with this situation. From the motivating example described in the previous section, we can see that the multiple compensations are common phenomena in real applications. Consequently, a corresponding multiple-compensation mechanism should be considered and reflected in the business process models. In this section, we introduce the multiple-compensation mechanism in a business process environment which associates for each task several compensating tasks. We give formal definitions of a business proc-ess model with a multiple-compensation feature in the following. Definition 1. A business process can be modelled as an acyclic directed graph in the form of ) , , , ( s n t E N G , where (2) E is a set of directed edges. Each edge E n n e  X  = ) , ( 2 1 corresponds to the con-(3) For each N n  X  , Ind(n) and Outd(n) define the number of edges which take n as If t(n) =  X  X ormal X  then ind(n) = outd(n) = 1 . 
Tasks are the main components of a business process. A task can be modelled as a combination of a normal part (of operations), which is used for forward execution and a compensation part (of operations), which is used for backward recovery. In order to introduce the mechanism of multiple-compensation, we define for the compensation part of each task not only one, but a set of compensating tasks. We can model a task as follows. Definition 2. A task n is defined as ) , , ( C tb tf where, (2) tb defines the backward execution part (compensation part) of n . When tb is More details on the process of selecting will be explained in Section 4. acyclic graph (,,,,,, ) s GNEtstetsn , where (1) NN  X  Each N n i  X  corresponds to a task instance in the business process (2) EE  X  . Each edge 12 (, ) enn E = X  corresponds to the control dependency be-(3) : tN Type  X  is the same mapping function as that defined in the business proc-(5) : s N States  X  is a function which maps each task instance in set N to a certain (6) s n indicates the starting task instance. (7) N N succ prec 2 : ,  X  are functions which define for each task instance N n i  X  its GNEtstetsn , where E N , E E are subsets of N and E respectively and for each iE nN  X  , () " " i s n initial  X  . Upon the definitions given in Section 3, we present an algorithm on how to imple-ment the multiple-compensation mechanism in this section. Before the presentation of the algorithm, the main ideas of it will be firstly introduced. The analysis for the com-putational complexity of the algorithm will be given in the end. 4.1 Algorithm Introduction The algorithm describes what should be done with the multiple-compensation mecha-nism to maintain atomicity and consistency of the whole business process in the pres-ence of tasks X  failures. The algorithm is invoked by the input of the executed part of a will play an important role in the algorithm. For each executed task instance E nG  X  , () et n and the current state () sn will all be kept in a system log. 
Due to the compensation dependencies among tasks, the abortion or compensation of some tasks will lead to the abortion or compensation of other tasks. For example, when a  X  normal  X  task is aborted or compensated, its only one preceding task should be compensated. When an  X  And-Join  X  task is aborted or compensated, all of its multi-ple preceding tasks should be compensated. When a task that is one of the succeeding tasks of an  X  And-Split  X  task is aborted or compensated, not only the  X  And-Split  X  task The abortion or compensation of tasks should be executed in a reverse order with the business process control flow. directions. One is backward traversing (recovery), which keeps processing and adds new traced preceding tasks into set NP for processing. The other is forward trav-ersing (tracing), which keeps tracing succeeding tasks until some certain tasks are reached. 
The algorithm starts from a failed task in graph E G and invokes the backward trav-ersing first. During the process of backward traversing, the preceding tasks except those And-Split tasks of the currently processed task will be put into set NP in order for processing. The order of adding tasks into set NP indicates the corresponding compensation order. The tasks in NP , which have not been completed successfully, will be aborted by system. Other tasks in NP , which have already successfully com-mitted will be compensated for. When a task is going to be compensated, its back-compensating tasks one appropriate compensating task to execute according to those system-logged information of the task. 
When the preceding task of the currently processed task is an And-Split task, a forward traversing process will be needed. The forward traversing process will trav-reached. The whole algorithm will be terminated when the starting task instance in graph E G is reached. 
Please note that we only consider the execution part of the business process succeeding tasks will be specific. We can treat them as normal tasks. 4.2 Algorithm Description We now describe the algorithm for implementing the multiple-compensation mecha-nism in a more formal way as follows. 
Algorithm 1 describes the backward traversing process. It takes the executed part of a business process instance graph E G as an input and starts from an arbitrary fault-tasks in E G will be set into  X  X nded X . The main body of the algorithm consists of two parts, processing part and generating part. During the processing part, tasks in set NP will be processed differently. For those tasks with current states of  X  X ctive X  or  X  X omplete X , they will be compensated for. Algorithm 3 will be invoked to compensate these compensated-for tasks. During the generating part, the preceding tasks of the tively until at last the starting task is reached. When an And-Split task is first reached, a forward tracing process is associated, which will be described explicitly in algo-rithm 2. In order to avoid reduplicate traversing, a set ASMarked is constructed. The And-Split tasks, which have once been processed, will be added into set ASMarked. the traversing. 
Algorithm 2 describes a forward tracing process invoked when an And-Split task is already been in set NP or has no succeeding task is reached. In the latter situation, the and And-Join tasks that have once been traversed. 
Algorithm 3 describes the multiple-comp ensation process. When a task in set NP is going to be compensated, its tb part will be invoked. Then it will choose from the set of its compensating tasks one appropriate task for executing. 4.3 Computational Complexity Analysis Algorithms 1, 2 and 3 describe the whole process of backward recovery using the multiple-compensation mechanism. The ma in principle is to traverse the graph E G for two times, one for backward traversing, and the other for forward traversing. For algorithm 1, we can see that it traverses b ackward through edges in the graph G from a faulting node to the starting node and repetitively adds preceding nodes into set NP . Set NP grows dynamically during the process of traversing. Conse-quently, the complexity of algorithm 1 should be equal to O (|E|).

For algorithm 2, it describes a forward traversing process from any And-Split node in the graph to the node of each of its branch paths that is in set NP or has no succeed-ing nodes. New found succeeding nodes during traversing are added into set Asucc thus makes it grow gradually. Its complexity should also be equal to O (|E|). However, extra cost comes from step 6, which contains two set computation bet-ween succ(n i ) (through traced edges) and Asucc and AJMarked, respectively . We consider the worst situation when Asucc and AJMarked are proportional to |N|, complexity of algorithm 2 should be (| | log | |) OE N . 
For algorithm 3, it will be invoked for all nodes that have been completed success-fully. The complexity for selecting one appropriate compensating task among several compensating tasks would be a constant. So, the complexity for algorithm 3 would be O (|N|) , which is less than O (|E|) . (| | log | |) OE N . Compensation mechanism is firstly proposed in ATMs. It is then widely adopted by transactional workflows and Web service transaction protocols to maintain atomicity when isolation property is relaxed. 
For transactional workflow systems, the no tion of compensation is of great impor-tance, since most workflow instances tend to be long running and the processing enti-ties of some tasks do not support transaction management (such as file systems or legacy systems). The backward recovery based on compensation is well supported in some workflow systems, the most typical of which are the FlowMark workflow sys-tems and the Virtual Transaction Model. 
In FlowMark [16] workflow systems, the notion of sphere of joint compensation, which is proposed by Frank Leymann [17] for providing partial backward recovery, is well supported. A sphere is a collection of tasks in a workflow. It should be satisfied compensated. Each sphere and each task enclosed in the sphere is defined to be asso-ciated with a compensating task. The sphere can be aborted by compensating its com-posed tasks individually or by invoking the compensation task for the sphere as a whole. Spheres can overlap and be nested. If a task fails, the sphere that immediately compensated and this can go on recursively. 
The Virtual transaction model [18] specifies Virtual Transaction (VT) regions on top of a workflow graph. Upon a failure during the execution of a task enclosed in a ward execution, until a compensation end point is reached. 
Confirmation is a new mechanism proposed in [19]. It is able to modify some non-compensatable tasks to make them compensatable. While compensation is to semanti-cally eliminate the effects of some completed tasks, confirmation is to semantically commit them. With confirmation mechanism, a task in a business process will not only be associated with a compensating task but also a confirmation task. Once a executed tasks will be executed automatically. 
The technology of Web service is developing rapidly. It offers a good environment for business process execution since the Web service components are loosely coupled with each other. Some Web service protocols include transactional support mecha-nism. For example, the WSCI, WSBPEL and WS-CDL all support open nested trans-action model and compensation mechanism. The Web service business activity trans-action protocol (WS-BA) [20] is also compensation-based. 
Compared with our multiple-compensation mechanism, those compensation mechanisms proposed in ATMs, transactional workflows are not flexible enough. They associate for each task only one compensating task. The compensation mecha-nism adopted in some Web service protocols is targeted at a scope (or context) level. Scopes and contexts can be nested, which will lead to redundant definition of com-pensation tasks and cannot be executed automatically. Our multiple-compensation mechanism defines for each task several compensating tasks, thus can satisfy various application demands. The compensating task can be invoked and executed automati-cally once its corresponding task needs to be compensated for. Compensation is an important mechanism for backward recovery in long running business processes. Its main principle is to semantically eliminate the effects of some successfully committed tasks in the business process. System developers or users can define for each task in the business process a corresponding compensating task. When a certain task needs to be compensated, its compensating task will be invoked. 
In the previous studies, only one compensating task is defined to be associated with a task, which cannot satisfy the different requirements in real applications when some other conditions should be considered, such as penalty, time limits, different user mechanism of multiple-compensation, which associates for each task several compen-sating tasks. When a task should be undone, one appropriate compensating task will be selected to invoke under some pre-fixed conditions. 
We incorporated the multiple compensation mechanism into a business process model by giving some formal definitions. We then introduced and described in detail an algorithm on how to decide which tasks should be compensated, in which order they should be compensated and which one specific compensating task should be selected to compensate them. The algorithm is efficient, which basically traverses the executed part of a business process graph twice. In most cases, the complexity of the algorithm is O (|E|) , with the worst case to be (| | log | |) OE N . 
For future work, we would like to take into account the concept of sphere of the joint compensation to see how the multiple compensation mechanism can be applied to it. We also would like to incorporate th e mechanism of multiple-compensation into a Web service environment to see what benefits it will bring to improve the existing Web service protocols on Web service transactions. This work is supported by the Australian Research Council Discovery Project under the grant number DP0557572. 
