 Temporal datasets, in which data evolves continuously, exist in a wide variety of applications, and identifying anomalous or outlying objects from temporal datasets is an important and challenging task. Different from traditional outlier de-tection, which detects objects that have quite different be-havior compared with the other objects, temporal outlier detection tries to identify objects that have different evo-lutionary behavior compared with other objects. Usually objects form multiple communities, and most of the objects belonging to the same community follow similar patterns of evolution. However, there are some objects which evolve in a very different way relative to other community mem-bers, and we define such objects as evolutionary community outliers . This definition represents a novel type of outliers considering both temporal dimension and community pat-terns. We investigate the problem of identifying evolution-ary community outliers given the discovered communities from two snapshots of an evolving dataset. To tackle the challenges of community evolution and outlier detection, we propose an integrated optimization framework which con-ducts outlier-aware community matching across snapshots and identification of evolutionary outliers in a tightly cou-pled way. A coordinate descent algorithm is proposed to improve community matching and outlier detection perfor-mance iteratively. Experimental results on both synthetic and real datasets show that the proposed approach is highly effective in discovering interesting evolutionary community outliers.
 H.1.0 [ Information Systems ]: Models and Principles; H.4.m [ Information Systems Applications ]: Miscellaneous Algorithms, Experimentation community matching, evolutionary community outliers, anomaly detection, ECOutlier, temporal outliers
For a large number of applications, systems can be mod-eled as temporal datasets. Each snapshot in such a tem-poral dataset could describe the attributes of a collection of objects or a network of connected objects. For exam-ple, consider a database of employees in a company. Each employee can be associated with a large number of tempo-ral attributes like salary, address, telephone number, des-ignation, etc. As another example, consider co-authorship networks like DBLP where each author node is associated with temporal data and links. In daily life, various kinds of records like credit, personnel, financial, judicial, medi-cal, etc. are all temporal. Given a snapshot of such a tem-poral dataset, analysts often perform clustering of objects with the goal of determining intrinsic grouping of objects in an unsupervised manner. We can refer to each group as a community . By analyzing a pair of snapshots from such a temporal dataset, we can observe that these communities evolve, often contracting, expanding, splitting or merging with each other. Most of the objects within a community follow similar evolution trends and their average defines the evolution trend of the community. However, evolutionary behavior of certain objects is quite different from the aver-age evolutionary behavior of its community. Our goal is to detect such anomalous objects as E volutionary C ommunity O utliers (or ECOutliers ) given a pair of snapshots from a temporal dataset.
 ECOutlier Examples
ECOutliers a re interesting because they evolve against the trend, and often times they prove to be trend-setters. Inter-esting examples of ECOutliers can be commonly observed in real-life scenarios. We list a few below. Case Studies Now let us study two specific cases in detail.

C omputer Science Research Evolution . An ECOutlier au-thor may change his research area across time while others in his community continue to research in the same area. For example, consider the two snapshots 1997 and 1998 when Soumen Chakrabarti changed his research area from  X  X aral-lel Systems X (characterized by work in ICALP, PLDI, SPAA) to  X  X ata and Information Systems X  (characterized by work in VLDB, SIGMOD). In a bibliographic network, a confer-e nce may change the sub-topics it deals with while other conferences in the area continue to focus on the same sub-topics. For example, in 2010, there were 13 papers in CIKM about personalization, while none of the other IR confer-ences like WWW, WSDM, SIGIR or ECIR focused so much on personalization in that year.

Employee Promotion . Suppose we have collected the com-munication frequencies among employees in a company. Also, each employee has temporal attributes like salary, designa-tion, location, etc. We can identify the natural communities based on their attribute values and communication links. Across two snapshots of this small company, say only one employee E gets promoted from a developer two levels up to a team lead. Also, E  X  X  salary increases, and his commu-nication pattern changes because he starts communicating more with managers. Due to change in links and the asso-ciated data, the community membership of E changes too. As E has behavior (community membership) changes much different from other members in his original community, he can be considered as an ECOutlier . E can be detected by identifying and comparing the communities of the two snap-shots.
 Existing Work
Here we briefly mention the difference between this work a nd existing outlier detection techniques. More discussions can be found in Section 2. (1) S ingle-snapshot outlier de-tection : Distance-based [ 22 , 30 ] and density-based [7, 24 ] m ethods have been proposed but they work on only single snapshot data and hence cannot detect temporal changes. (2) Temporal outlier detection : Traditional time series liter-ature [ 13 ] defines two types of outliers (Type I/additive and T ype II/innovative) based on the data associated with an in-dividual object across time, ignoring the community aspect completely. (3) Stream outlier detection : Recent work on outlier detection on data streams has focused on distance-based local outliers [ 29 ] or on graph outliers [4], while we f ocus on outliers in the community context. In general, ex-isting work ignores time or community information in out-lier detection, and thus the outliers detected traditionally are not evolutionary community outliers as proposed in this paper.
 Integrated Framework
Evolutionary community outliers are objects that do not f ollow the evolutionary trend compared with other objects in the same community. Therefore, one natural way to identify such ECOutliers is to detect objects which change their com-munity belongingness against the trend across time. How-ever, community discovery is an unsupervised procedure, so communities discovered at different snapshots may not match with each other. Moreover, communities evolve too, and thus communities must be matched across snapshots. ECOutliers can be detected with high accuracy if the com-munity matching across two snapshots is of high quality. However, community matching suffers from the presence of ECOutliers itself. Outliers are objects that defy the trend, and the trend must be obtained from community match-ing. Therefore, community matching and outlier detection cannot be separated. This motivates us to present an inte-grated framework which models outlier detection and com-munity matching as a joint optimization problem. As we will show in Section 5, such an integrated approach is much more e ffective compared to a two-stage approach, which detects outliers after community matching is done.
 Brief Overview of ECOutlier Detection
Consider a temporal dataset represented by the snapshot s eries X 1 , X 2 , . . . , X T . In this paper, we focus on the prob-lem of detecting evolutionary outliers from any of the two snapshots X i and X j . Given community detection results on all pairs of snapshots, evolutionary outliers across mul-tiple snapshots can be easily defined based on simple post-processing. For the sake of simplicity, let us denote the pair of snapshots as X 1 and X 2 . Latent community discovery on X 1 (or X 2 ) leads to a matrix P (or Q ). Each element of P (or Q ) denotes the probability with which a particular ob-ject belongs to a particular community in snapshot X 1 (or X ). Next, one needs to match a particular community in X 1 to one or more communities in X 2 . Note that commu-nity mismatch happens due to permutation of community labels and community evolution. Such matching should try to minimize the distance between the matrices P and Q . To ignore the effect of ECOutliers from such an optimiza-tion, the distance function should appropriately discount the matrix entries ((object, community) pairs) corresponding to outliers, thereby also learning an outlierness score for every (object, community) pair. Hence, we formulate the prob-lem as an optimization problem over both outlierness degree and community correspondence. Community matching and outlier detection are improved through iterative updating procedures, and upon convergence, meaningful outliers are output.
 Summary
We make the following contributions in this paper:
Our paper is organized as follows. We discuss related work in Section 2. In Section 3, we define the E COutlier detec-tion problem, and present the optimization framework and solution. In Section 4, we present analysis and discussions r elated to the algorithm. We discuss experimental setup and results with detailed insights in Section 5. The paper is s ummarized in Section 6.
Our work is related to the areas of community matching and outlier detection.

Community Matching: The problem of community matching appears mainly when multiple different cluster-ings need to be integrated into a single clustering. Com-munity mismatch happens because of  X  X abel switching X  or  X  X enuine multimodularity X  [20 ]. Community matching (con-s ensus clustering) can be done in a hard or a soft way. Hard community matching can be performed by selecting the best matching pair of communities one by one, avoiding conflict with already selected pairs [ 10 , 11 ] or using greedy algo-r ithms like CLUMPP [20 ]. Soft community matching can be d one so as to minimize the distance between the two matri-ces [ 27 ]. In computer vision, community matching has been d one by using cluster features like position, intensity, shape and average gray-scale difference [ 23 ], and degree of match b etween surrounding clusters [ 28 ]. Words-based communi-t ies could be matched using TF-IDF similarity [ 9]. Differ-e nt from these studies, we introduce a new soft community matching technique which is evolutionary-outlier-aware.
Outlier Detection: Outlier (or anomaly) detection is a very broad field and has been studied in the context of a large number of application domains. Chandola et al. [ 8] and H odge et al. [ 18 ] provide extensive overview of outlier detec-t ion techniques. Four main types of outliers studied in litera-ture are point outliers, contextual outliers, collective outliers and evolutionary outliers. A variety of supervised, semi-supervised and unsupervised techniques have been used for outlier detection. These include mixture of models [ 12 ], neu-r al networks, stat profiling using histograms, SVMs [ 19 ], rule b ased systems, parametric stat modeling, non-parametric stat modeling, bayesian networks, etc. The problem stud-ied in this paper has connections with distance-based out-lier detection algorithms [ 21 ] in the sense that we are try-i ng to search outliers in a space with community change trends as dimensions. Outliers have been discovered in high-dimensional data [ 2], uncertain data [3], stream data [4], n etwork data [ 15 ] and time series data [13 ]. Recently, there h as been significant interest in detecting outliers in evolving datasets [ 16 , 17], but none of them explores the outliers with r espect to communities in a general evolving dataset.
Trajectory outlier detection and community tracking meth-ods [5, 26 ] (1) usually work well for lo nger time series (unlike two timestamps in our setting), (2) and need crisp correspon-dence among clusters across timestamps. Also, often such methods cannot model link dependencies between objects (e.g. in networks) in the same timestamp. Such techniques usually use Markov models, which could lead to expensive computation or approximate solutions; our method provides high accuracy in time linear in the number of objects.
In this section, we will present our integrated framework for ECOutlier detection. Let us start by first introducing the notations. We represent a matrix using the notation B . We use  X  b i and  X  b j to represent the i th row and j th of B respectively. We will represent the ( i, j ) th element of the matrix B using b ij . Given two vectors  X  a and  X  b , we will use  X  a  X   X  b to denote their dot product. Table 1 shows the i mportant notations that we use in this paper. Next, we use these notations to define our problem. We start with an introduction to some basic concepts. Community
A community is a probabilistic collection of similar ob-j ects, such that similarity between objects within the com-munity is higher than the similarity between objects in dif-ferent communities. For example, a research area is a com-munity in a co-authorship network. We will use K 1 and K 2 to denote the number of communities in the two snapshots respectively.
 Belongingness Matrix
Each entry in the belongingness matrix corresponds to the p robability with which an object o belongs to a community i . The rows of the matrix correspond to objects while the columns correspond to communities. Let us denote the be-longingness matrices for the N objects in X 1 and X 2 by P and Q respectively. Thus, P  X  [0 , 1] N  X  K 1 , Q  X  [0 , 1] P Correspondence Matrix
We propose to use a soft matching of communities across s napshots. Soft correspondence means that a community of a given clustering corresponds to every community in an-other clustering with different weights. Hence, the match be-tween two clusterings may be formulated as a matrix called (  X  i = 1 . . . K 1 ).
 Outlierness Matrix
We denote the outlierness matrix by A N  X  K 2 . a o j repre-sents the outlierness score for the (object, community) entry ( o, j ).
 Evolutionary Community Outlier
An (object, community) pair ( o , j ) is an ECOutlier if change in p oi to q oj is quite different from the average change trend for community i in X 1 and j in X 2 . An object can be considered as an outlier if the change in its probability dis-tribution with respect to community belongingness is quite different from that of its X 1 community members. Evolutionary Community Outlier Detection Problem
Given two snapshots ( P a nd Q ), our problem is to esti-mate S and A and thereby derive ECOutliers with respect to the two snapshots.
 To perform community matching between the matrices P and Q , one needs to estimate a correspondence matrix S differences) between the matrices Q and P  X  S is mini-mized. However, such an approach will perform biased com-munity matching if we take into account the contribution from outlier entries too, when estimating the correpondence matrix S . For higher quality matching, one needs to ignore evolutionary outlier entries. Hence, we need to incorporate the outlierness score matrix A into community matching. In the remainder of this section, we will develop an integrated approach to compute S and A . Let be the estimated sum of outlierness in the snapshot. Then, we can incorporate the outlierness score into the com-munity matching formulation as shown in Eqs. 1 to 5. We w ill discuss the estimation of in Section 3.5 .

I n the objective function (Eq. 1), S a nd A are the vari-ables to be learned. ( q oj  X   X  p o  X   X  s j ) 2 denotes the squared error incurred in community matching and log 1 a mines the outlier weight associated with the ( o, j ) th entry. Note that even if there were no outliers, there would still be some matching error, because each object evolves some-what differently from the community averages. However, outliers that evolve very differently from community aver-a ges are penalized using a higher a oj value. Using log 1 in the objective function allows us to smooth out outlierness values. The log function makes sure that the weights for in-dividual entry matching across snapshots lie within a small range. The more anomalous a particular (object, commu-nity) entry ( o, j ) is, the higher will be the value of a will be associated with the ( o, j ) th outlier entry when per-forming community matching. While there could be other ways of formulating the objective function, we use this par-ticular formulation for ease of computation. Total Amount of Outlierness
If the total amount of outlierness is unbounded, one can s imply mark all entries as outliers and then there will be no useful community matching. This corresponds to the trivial solution of setting all A elements to very high values, for the optimization (Eq. 1). Hence, we need to put in a constraint b ased on how many outliers we expect. Note that normal entries have small a oj values, while outlier entries have large a oj values. Thus, we would like to bound the total sum of all a oj values to be within a maximum level of outlierness we expect in the snapshot. This can be achieved using the constraint P N o =1 P K 2 j =1 a oj  X  (Eq. 5). We replace it by a n equality constraint to simplify computation. In fact, the semantic meanings of outlierness scores will not change by this action because we only care about the relative ranking of the scores. Essentially the equality claims that there is a certain level of outlierness in the entire snapshot. We will show later how we can estimate .

The objective function can be minimized (local minimum) by alternately optimizing one of S and A while fixing the other. Next, we will derive iterative update rules for the correspondence entry ( s ij ) and the outlierness scores ( a Using the method of Lagrangian Multipliers, we can rewrite the problem as follows. Here,  X  i and  X  are Lagrangian vari-ables.
Taking the partial derivative of Eq. 6 with respect to a p articular a oj and setting it to 0, we obtain the following.
This gives us the update rule for a oj as follows.
The numerator ( q oj  X   X  p o  X   X  s j ) 2 represents the squared er-ror for the ( o, j ) th entry, which represents the error incurred by matching the community detection results between two snapshots on the o th object with respect to the j -th commu-nity in Q . The denominator in Eq. 10 represents the overall e rror across all the entries in matrix Q , given a particular S , which serves as a normalization factor. Intuitively, we assign a higher outlierness score to objects and communities that incur higher community matching error, while objects that are matched well with respect to certain communities across two snapshots are considered normal and thus receive lower outlierness score.

Now, we will obtain the update rule for s ij . Taking partial derivative of f with respect to s ij , we obtain the following.
After some algebraic simplifications, we obtain the follow-ing update rule for s ij .
The intuition behind Eq. 12 is as follows. Our goal is t o compute s ij when other elements of the matrix S are fixed. s ij involves matching of all objects with respect to the i th column of P and the j th column of Q . Contributions from each object o  X  are weighted by log 1 a highly outlying objects contribute little to matching. Fixing other elements of S , of q o  X  j that needs to be explained by p o  X  i s ij .  X  denominator of Eq. 12 are used to make sure that P j s i j 1.  X  i  X  X  can now be computed easily using Eq. 12 and the c onstraints P K 2 j =1 s ij = 1 (  X  i = 1 . . . K 1 ). This value of  X  can then be substituted back in Eq. 12 to obtain the update r ule for s ij .
S captures the average evolution trend for the communi-ties in the two snapshots. It also captures the permutation effect when matching two clusterings. s ij represents the de-gree to which the community i in snapshot X 1 contributes to the community j in snapshot X 2 . Thus, s ij averages the evolution/match across all the objects belonging to i in X and j in X 2 . If a community i splits into two parts j 1 j , s ij 1 and s ij 2 will have non-zero values. Similar to this split case, s ij can be used to represent community merges, community expansion, community shrinking and a mix of such scenarios. Apart, a community i may die out with all s  X  X  set to 0. Similarly, S can also capture birth of new communities.

Now, if there are evolutionary outliers, they will possess values quite different from the average. For example, when s =1, community i in X 1 gets merged with, or is renamed as community j in X 2 . However, an outlier will have most of its mass moving from community i in X 1 to communities other than j in X 2 . Presence of such outliers can affect the computation of s ij itself because outliers can lead to signifi-cantly different average values. In our formulation, a weight is given to an object o when computing the community evo-lution values for community j , which is a function of a oj For normal (object, community), a oj should be low, while for outlying (object, community), a oj should be high. A is designed to capture such evolutionary outlierness. Note that indicates the total sum of outlier scores (in Eq. 5). If we set t o 1, a oj is expected to be quite small for most of the ( o, j ) entries. There are N objects and K 2 munities, and thus the matching error of one entry is much smaller than the total squared sum of errors. The conse-quence is that the difference between a oj is also small and it is hard to judge whether an object is an outlier or not based on a oj . Techniques that transform and interpret outlierness scores [ 25 ] might help solve this problem. However, another p roblem is that a small causes overfitting of S to the out-lier entries, when performing community matching. Hence, we would like to have as high as possible without vio-lating constraints in the optimization. is upper-bounded by the combination of Eq. 10 and the constraint a o j  X  1. Therefore, we propose the following two-pass procedure to set . In the first pass, the overall snapshot outlierness is initialized to 1. After the first pass, is estimated as the ratio of overall error to the maximum entry value, as shown in Line 7 of Algorithm 1. The algorithm then uses this esti-m ated for the second pass. Since increases compared to the first pass, a oj values are relatively large. This reduces the overfitting of S to the outlier entries. Hence, matching for non-outlier entries improves, and so outlier detection im-proves too. Also, due to relaxation in matching, the overall error, i.e., the denominator in Eq. 10 is higher than the over-a ll error in the first pass, and thus the value of a oj remains  X  1, ensuring that the constraint is not violated.
Algorithm 1 summarizes the proposed E COutlier detec-tion algorithm. We name it OneStage to distinguish it from several baselines we evaluated, which will be discussed in detail in Section 5.  X  X neStage X  indicates that the proposed m ethod conducts outlier detection and community matching together, and is used to represent the two-pass procedure that estimates . As can be seen, the proposed method iter-atively learns both parameters representing the outlierness scores ( a oj ) and the community correspondence values ( s At every iteration, a oj values are first updated assuming all s ij are fixed, and then s ij values are sequentially updated based on the values of all a oj and s ij from other entries. The algorithm terminates when the change in the value of the objective function is less than a threshold  X  .
In this section, we analyze the convergence property and time complexity of the proposed ECOutlier detection method. We also discuss several important issues in implementing the method.
 Convergence
Lemma 4 .1. Algorithm 1 converges and the final solution i s a stationary point of the optimization problem presented in Eqs. 1 to 5.

P roof. As stated in [6, p. 267-271], a block coordinate d escent algorithm converges to a stationary point if the func-tion achieves minimum at each step with respect to the set of working variables when the values of other variables are fixed. To prove this, we first check the convexity of the function. We notice that the constraints (Eqs. 2 to 5) are a ll linear. When we consider S as constant, the optimiza-tion function is a linear combination of negative log of a As log( 1 a When A is fixed and s ij  X  X  are updated sequentially, the ob-jective function can be written as a quadratic function in s Since p ij are all positive, it can be derived that the function is convex in each s ij . As the function to be minimized is convex at each step, setting derivatives with respect to the working variables to zero will give unique minimum. Hence, Algorithm 1 is guaranteed to converge.
 Computational Complexity
Recall that N i s the number of objects, K 1 and K 2 are the number of communities in the two snapshots respectively. Sum of all error values in Eq. 10 can be computed once for a ll a oj  X  X  in O ( N K 1 K 2 ) time. Then, computation of each a takes O ( K 1 ) time. S consists of K 1 K 2 entries. When com-puting S , at every iteration, for each s ij , one needs to use Eq. 12 which is O ( N K 1 ) itself. Thus, computational com-plexity of the OneStage Algorithm is O ( N K 2 1 K 2 I ) where I is the number of iterations. As can be seen, the running time is linear with respect to the number of objects. Usually the number of communities is small, and thus the proposed method scales well to large data sets.
 Identifying Outliers
Algorithm 1 allows us to obtain outlierness scores for every ( object, community) pair, given two snapshots of a tempo-ral dataset. These scores are useful to identify interesting objects that are outliers with respect to a particular com-munity. One could also aggregate such outlierness scores in a variety of ways to obtain the outlierness score for an ob-ject across all communities. Different aggregation functions could be used; weighted sum of scores or maximum (object, community) entry corresponding to an object may be a good choice, depending on the application. Also, when reporting top outlier objects in the snapshot one may want to consider the overall activity of the object along with its outlierness score. For example, an author publishing 50 papers in a snapshot with a relatively lower level of outlierness may still be more interesting than an author publishing only 5 papers but with a relatively higher level of outlierness. Initialization
We initialize all a o j values to 1 NK sidering all entries to be equally anomalous. We initialize all s i j entries to 1 K snapshot X 2 evolves equally from each of the communities in snapshot X 1 .
 Series of Snapshots
In this paper, we focused on finding E COutliers given a pair of snapshots. However, it is quite natural to extend our approach given a series of snapshots. We can perform community matching and outlier detection across every pair of consecutive snapshots, using the proposed module. Also, when the evolution is gentle, one can smooth out community matching over several consecutive snapshots. This can help in improving the community matching accuracy, thereby also improving the outlier detection.
Evaluation of outlier detection algorithms is quite diffi-cult due to lack of ground truth. We perform experiments on multiple synthetic datasets, each of which simulates real scenarios. We will evaluate outlier detection accuracy of the proposed algorithm based on outliers injected in synthetic datasets. We evaluate the results on real datasets using case studies. We perform comprehensive analysis of objects to justify the top few outliers returned by the proposed algo-rithm. The code and the data sets are available at: http:// blitzprecision. cs.uiuc.edu/ECOutlier
W e compare the proposed algorithm with three baseline methods: OneStage (1S) , TwoStage (2S) and NearestNeigh-bor (NN) . As discussed, our method is named as OneStage (1S ) because it integrates outlier detection and community matching, and is estimated using a two-pass procedure. The baseline methods are explained as follows.
 OneStage (1S): 1S is the one pass version of 1S (Steps 1 to 6 of Algorithm 1), in which total outlier score i s set to 1. Thus, comparison with 1S will help us understand improvement in accuracy by improved estimation of . TwoStage (2S): Outliers are obtained by looking at the top values in Q  X  P  X  S where S is computed by matching P and Q . Comparison with 2S will help us understand which method is better  X  performing outlier detection after community matching ( 2S ) or doing them in an integrated way ( 1S ).
 NearestNeighbor (NN): For every object o , we find its k -Nearest Neighbors set, N N X 1 ( o ), in P using the KDTree implementation in Java-ML [ 1]. Recall that P a nd Q are the belongingness matrices for snapshots X 1 and X 2 . We exclude the object o from N N X 1 ( o ). The outlierness score for (object, community) pairs ( o, j ) can then be computed as a outlier entry ( o, j ) has a high score if q o,j (i.e., belongingness of object o to community j in the second snapshot) is quite different from the average belongingness of its X 1 nearest neighbors to the same community j in X 2 . NN seems to follow the exact definition of ECOutliers and so one would expect it to get high accuracy but we will discuss later on why it fails to perform better than other methods. Dataset Generation
We generate a variety of synthetic datasets to capture d ifferent spatial cases of evolution (Figs. 1 and 2). For each dataset, the figures show two snapshots. In each snap-shot, we generate multiple clusters, each of which represents a community. Each cluster is modeled using a 2D Gaus-sian distribution, and evolution is modeled by changing the means and the variances of the Gaussians. For example, to model contraction (expansion) of a cluster, we reduce (in-crease) the standard deviation of the corresponding cluster (the first two plots in Fig. 1). N oEvolution is represented by Plots 3 and 4 in Fig. 1. Plots 5 and 6 in Fig. 1 show t he case of Merge where top four clusters merge to form one big cluster, and Split is shown in the last two plots in Fig. 1 where the upper cluster splits into four small clusters. We m odel a mix of cluster evolution in Fig. 2, which consists of c luster expansion, contraction, merging and splitting. Thus, we try to incorporate all forms of possible cluster evolution in our synthetic datasets. The circles represent 2  X  boundary for the cluster Gaussian. For each cluster, we generate a set of N/K 1 points, each of which is sampled from the cluster Gaussian. For each of the N points, we obtain p oj and q oj as the probability with which the point can be generated from its cluster X  X  Gaussian distribution. Using P and Q , we obtain S as the community matching matrix in absence of any outlierness. S captures evolution without the effect of outliers.

Next, we inject outliers as follows. First we set an out-lierness factor  X  and choose a random set of objects, R with N  X   X  objects. For each object o in R , we swap communities with the min and the max q oj values. Thus, we inject two outliers per object in R . Finally, we set a we show the top three outliers (using different black filled shapes) discovered by OneStage . We show their original positions in X 1 and their new positions in X 2 . Results on Synthetic Datasets
We experiment using a variety of different settings. For e ach setting, we perform 100 experiments and report the mean values. We fix the threshold  X  for convergence to 10  X  6 . We vary the number of objects as 1000, 5000 and 10000. We vary the percentage of outliers injected into the dataset as 1%, 2%, 5% and 10%. Using these settings, we compare the actual outlier objects with the top outliers re-turned by various algorithms. For each algorithm, we show the precision of outlier detection with respect to the ranking of outliers. The results of the three baselines and the pro-posed method are shown in Fig. 3 for S ynMix dataset (10000 objects,  X =10%). Note that the proposed algorithm ( 1S ) outperforms the others in finding the top few outliers most precisely. The area under this curve (AUC) is a good mea-sure of the effectiveness of the algorithm in identifying the outliers. We report the AUC values in Table 2 (Average vari-a nces are .0012 for NN , .0021 for 2S , .0017 for 1S , and .0005 for 1S ). For NearestNeighbors , we tried k =5, 10, 50 and 100. We found the best AUC at k =10 and hence report the values for k =10. As the table shows, the proposed algorithm outperforms all the other algorithms for all the settings by a wide margin (sometimes as high as 30% better than the TwoStage method). NearestNeighbors performs fairly well for SynNoEvolution but not for other datasets. This is be-cause it does not consider evolution and assumes that the set of nearest neighbors does not change across the snapshots. In contrast, the proposed algorithm detects outliers in the context of community evolution. Dataset Generation We perform experiments using three real datasets: I MDB , DBLP and Four Area (subset of DBLP ). We use iTopic-Model [31 ] to perform community detection on the dataset s ince it uses both data and link information. It outputs the ( X IMDB : We consider the co-starring graph (edge weight = co-starring frequency) created using actors who acted in at least 5 movies per snapshot. The two snapshots correspond to the years  X 06- X 07 (15337 actors) and  X 08- X 09 (13142 actors). Sets of genres of movies in which the actor acted constitutes the data associated with an actor. After community de-tection, we retain only those actors (6609) that are present in both snapshots. We consider number of communities as K 1 = K 2 = 5.
 DBLP : We consider the co-authorship graph (edge weight = co-authorship frequency) created using publications in the top 1500 conferences by authors, each of which published  X  10 papers per snapshot. The two snapshots correspond to the years  X 06- X 07 (4784 authors) and  X 08- X 09 (5633 authors). Sets of related conferences constitute the data associated with an author. After community detection, we retain only those authors (2666) that are present in both snapshots. We consider number of communities as K 1 = K 2 = 5. Similar to the author network, we also create a network of conferences (edge weight = #authors publishing at both conferences) where the words in paper titles constitute the data associ-ated with each conference. 920 conferences are present in both snapshots and again, we set K 1 = K 2 = 5.
 Four Area : This is a subset of DBLP for the four ar-eas of data mining (DM), databases (DB), information re-trieval (IR) and machine learning (ML). It consists of pa-pers from 20 conferences (5 per area). For details, read [ 14]. W e obtain two snapshots corresponding to the years  X 01- X 04 (601 authors) and  X 05- X 08 (1206 authors). We build the co-authorship network similar to the one for DBLP . K 1 = K 2 = 4, and 374 authors are present in both snap-shots.
 Results on Real Datasets
Here, we discuss case studies obtained from these datasets. Table 3: Analysis of Top Outlier Conferences ( 1 S ) IMDB : Top two outlier actors returned by OneStage are discussed below. 1. Kelly Carlson (I): In X 1 , she did many Sport, Thriller and Action movies, while in X 2 she switched to Drama, Mu-sic, Reality-TV. Most of her top ten closest collaborators in X 1 still do Documentary, Thriller, Action in X 2 . Few of her co-stars collaborate with her in the second time snapshot. Also, her X 1 neighbors used to do Sport, Comedy, Docu-mentary, Action while her X 2 neighbors do Drama, Doc-umentary, Thriller, Music. Thus, clearly she changed her community from Sports, Thriller, Action genres to Drama, Music genres. 2. Josh Brolin: In X 1 , he did a lot of Thriller, Drama, Crime and Mystery movies. In X 2 , he acted in a lot of Documentary, Comedy, History, Music movies. Not only did he change his genres completely, but also not many other actors show such a change in the type of their movies. This is why, in X 2 , his genres are quite different from that of his X 1 nearest neighbors. Hence, clearly he is an outlier. DBLP (Authors Network): We will discuss about the top two authors which are detected as evolutionary commu-nity outliers. 1. Georgios B. Giannakis. In X 1 , his publications were mainly in CISS, ICC, GLOBECOM, INFOCOM. In X 2 , he published in completely different conferences: ICASSP, ICRA. We looked at the conferences at which his X 1 com-munity members published in X 2 . This set of conferences (GLOBECOM, ICC, CISS, INFOCOM) is completely dif-ferent from the set of conferences at which he published in X , but much similar to his own published venues in X 1 . 2. Vassilios Peristeras. In X 1 , his publications were mainly in HICSS, ICEGOV, IEEE SCC, EDOCW, CSREA, etc. In X , he published in completely different conferences: WSKS, ICSC, OTM, ICDIM, SAC. We looked at the conferences at which his X 1 community members published in X 2 . This set of conferences (HICSS, ISI, ICEGOV, etc.) is completely different from the set of conferences at which he published in X 2 , but much similar to his own conferences in X 1 . This clearly justifies him to be a community outlier.
 DBLP (Conf Network): Table 3 shows the top five con-f erences returned as outliers by OneStage . We performed some analysis and hence list four measures in Table 3: sim-i larity between top 20 words (we removed most frequent 100 words from dataset) for the conference across the snap-shots, similarity in top 20 words between the conference at X 2 and its ten closest X 1 community members, similarity in neighbor conferences across the two snapshots, similarity in the words shared by the neighbors in the first snapshot and neighbors in the second snapshot.

As the table shows, each of the conferences have very low similarity for at least one of the measures, justifying their detection as ECOutliers . For comparison with the baseline, we present the top five conferences returned as outliers re-turned by TwoStage in Table 4. As one can clearly see, the s imilarity values in Table 4 are much higher compared to T able 3. Thus, the outliers returned by T woStage are not as good as the outliers returned by the proposed algorithm. Table 4: Analysis of Top Outlier Conferences ( 2 S ) Four Area (Authors Network): In this dataset, we ob-serve a trend of people moving from ML community to DM community. Also, many authors often publish in both DB and IR. For this dataset, we will discuss two outliers re-turned by OneStage , who behave quite different from these trends. 1. J  X er X ome Lang. For this author, most of his community members moved from logical reasoning and related areas to other areas like DM and IR but he stays in AI field. He pub-lished 5 and 11 papers in the two snapshots respectively. Words in the titles of his papers are mainly  X  X ogic, plan-ning, representation, action, uncertainty, propositional X . We looked at the words which his X 1 community members (other authors having similar word distributions) use in X 2 . The top words were  X  X ata, retrieval, xml, web, learning, min-ing X . This clearly shows that his community members moved from logical reasoning to other areas while J  X er X ome decided to stay in the area, opposed to the trend. While he continued to publish in pure ML and AI conferences, his community members publish in a lot of IR and DM conferences in X 2 . 2. Georg Gottlob. Generally the observed trend is that ML authors move to other related areas like DM and IR. Sometimes, some DM authors publish in ML conferences. But Georg has been a DB author in X 1 , who started publish-ing in ML community in X 2 . In X 1 , he published frequently in PODS, VLDB, ICDE. In X 2 , apart from PODS, he pub-lished heavily in IJCAI and AAAI. His set of collaborators also changed by a large extent across the two snapshots. A lot of his X 2 collaborators publish in ML conferences. The experiments were run on a Linux machine with 4 Intel Xeon CPUs with 2.67GHz each. The code was implemented in Java. Fig. 4 shows the execution time for O neStage on different synthetic datasets in ms. Note that the algorithm is linear in the number of objects. These times are averaged across 100 runs of the algorithm. On an average OneStage needed  X  13 iterations per pass to converge on both real and synthetic datasets. Fig. 5 shows the change in the objective f unction value with iterations for the SynMix dataset for different number of objects, using a log-linear plot. The figure shows that OneStage converges fairly quickly.
We introduced the notion of evolutionary outliers with re-spect to latent evolving communities, i.e., ECOutliers . Such outliers represent the objects which disobey the common evolutionary trend among the majority of the objects in a community. The challenge is that both community evolu-tion patterns and outliers are unknown. Outliers should be derived based on community matching across different snap-shots, but need to be ignored when conducting community matching. We proposed an optimization framework which integrates community matching and outlier detection. The objective function is to minimize community matching error, in which the contributions from outlier objects are weighed lower. An iterative algorithm OneStage is developed to solve the optimization problem, which improves community m atching and ECOutlier detection gradually. Experiments on a series of synthetic data show the proposed algorithm X  X  capability of detecting outliers under various types of com-munity evolution. Case studies on DBLP , IMDB and Four Area datasets reveal some interesting and meaningful evolu-tionary outliers. Although the proposed algorithm focuses on two snapshots, it can detect both short-term and long-term trends and outliers, as snapshots can consist of short or long intervals. Moreover, it can be extended to handle multiple snapshots.
We thank Vinod Vydiswaran and anonymous KDD re-viewers for discussions and insightful comments. Research was sponsored in part by the Cyber Security project (W911NF-11-2-0086) of U.S. Army Research Laboratory, NSF IIS-0905215, and U.S. Air Force Office of Scientific Research MURI award FA9550-08-1-0265. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official poli-cies, either expressed or implied, of the Army Research Lab-oratory or the U.S. Government. The U.S. Government is authorized to reproduce and distribute reprints for Govern-ment purposes notwithstanding any copyright notation here on.
