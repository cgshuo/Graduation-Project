 Recently, the research area of correlation mining , that extracts the underlying dependency among objects, attracts a big attention and extensive studies have been reported [25,23,7,15,12]. Among these researches on correlation mining, we focus on the hyperclique pattern discovery [26,27] in this paper.

While the most of researches aim at finding mutually dependent  X  X airs X  of ob-jects efficiently, a hyperclique pattern is a  X  set X  of highly-correlated items that has high value of an objective measure named h-confidence [26,27]. The h-confidence measure of an itemset P = { i 1 ,  X  X  X  ,i m } is designed for capturing the strong affinity relationship and is defined as follows. where sup and conf are the conventional definitions of support and confidence in association rules[1], resp ectively. A hyperclique pattern P states that the occurrence of an item i l  X  P in a transaction implies the occurrence of all other items P \{ i l } in the same transaction with probability at least hconf ( P ). In addition, the cosine similarity between any pair of items in P is greater than or equals to hconf ( P )[27]. By these features, hyperclique pattern discovery has been applied successfully to some real world problems [9,18,24].

While hyperclique pattern discovery aims at finding valuable patterns in trans-action databases, structured data is becoming increasingly abundant in many ap-plication domains recently. Although we can easily expect to get a more powerful tool for structured data by introducing correlation mining, the most of current research on correlation mining are designed for transaction databases and lit-tle attention is paid to mining correlations from structured data. Motivated by these background, in this paper, we tackle the problem of hyperclique pattern discovery in the context of graph mining[21,22] and discuss the effectiveness of the correlation mining in structured domains.

The basic idea of hyperclique patterns in graph databases is simple: Instead of items, we employ subgraphs ( i.e. patterns) as building blocks of hyperclique patterns. While this simple replacement might seem to be trivial, it gives us new expectations and difficulties. On one ha nd, the proposed framework extracts sets of mutually dependent or affinitive patterns in graph databases. Because each pattern gives another view to other patterns in the same set, we can expect to obtain new findings and precise insights. On the other hand, as easily imagined, hyperclique pattern discovery in graph databases is much harder than the tradi-tional tasks because there are exponentially many subgraphs in graph databases and any combinations of those subgraphs are to be potentially candidates. In order to alleviate this combinatorial explosion and to discover hyperclique pat-terns efficiently, in this paper, we propose a novel algorithm named HSG. HSG reduces the search space effectively by taking into account the generality ordering of hyperclique patterns.

The main contributions of this paper are briefly summarized as follows. First, we formulate the new problem of hyperclique pattern discovery in graph databases. Second, we propose a novel algorithm named HSG for solving this problem effi-ciently. Third, through the experiment s with real world datasets, we assess the effectiveness of our proposal.

This paper is organized as follows. In section2, after introducing basic no-tations, we formulate the problem of hyperclique pattern discovery in graph databases. In section3, the proposed algorithm HSG is explained in detail. After mentioned related work in section4, we show the results of the experiments in section5. Finally, we conclude the paper and describe futur e work in section6. Let L be a finite set of labels. A labeled graph g =( V g ,E g ,l g )on L consists of a vertex set V g ,anedgeset E g and a labeling function l g : V g  X  E g  X  X  that maps each vertex or edge to a label in L . Hereafter, we refer labeled graph as graph simply.

Each graph can be represented in so called code word [3,28], that is a unique string which consists of a series of edges a ssociated with connection information. Especially, we employ canonical code word[3,28] which is minimal code word among isomorphic graphs to represent each graph. The lexicographic order on code word gives a total order on graphs. Given two graphs g and g , g&lt; lex g denotes that the code word of g is lexicographically earlier than that of g .Ifthe code word of g is a prefix of that of g ,wedenoteitas g&lt; pfx g .Examplesof graphs and those code words are shown in Fig.1.
Agraph g =( V g ,E g ,l g ) is called a subgraph of another graph g =( V g ,E g ,l g ), denoted as g g , if there exists an injective function f : V g  X  V g such that  X  l ( f ( u ) ,f ( v )). If g g ,thenwesaythat g is more general than g .Notethat,if g&lt; pfx g holds, then g g also holds[3,28].

Based on the relationship of subgraphs, we consider the joint occurrence of a set of subgraphs in a graph. The most intuitive definition is as follows: Given a set of subgraphs G and a graph g ,if  X  g i  X  Gg i g holds, then G is considered as to be occurred in g . However, this simple definition might not be suitable for the hyperclique patterns of subgraphs because large number of uninteresting combinations of subgraphs having large overlaps in a graph will be obtained. Therefore, we introduce another definition in consideration of edge-disjointness to suppress the redundancy. Given a set of m subgraphs G = { g 1 ,  X  X  X  ,g m } and a graph g , G is called a set of k -edge disjoint subgraphs of g , denoted as G  X  k g ,if The second condition gives the constraint on the edge overlaps. By this con-straint, the redundant combinations can be expected to be controlled. For ex-ample in Fig.1, while both g 1 g 3 and g 2  X  g 3 hold, if k is set to be 0, then { g We introduce the definitions of support and h-confidence for a set of subgraphs. Let D = { d 1 ,  X  X  X  ,d N } be a database of N graphs. The support and h-confidence of a set of subgraph G = { g 1 ,  X  X  X  ,g m } in D are defined as follows:
Based on the above preparation, we formulate the problem of  X  X ining frequent hyperclique patterns in graph databases X  ( HSG mining in short) below. Given a database D of labeled graphs, a positive number called minimum support  X  (0 &lt;  X   X  1) and a positive number called minimum h-confidence h then the problem of HSG mining is to find all frequent hyperclique patterns of subgraphs G in D such that sup D ( G )  X   X  , hconf D ( G )  X  h c and the cardinality of G is more than one. Note that, because we are interested in the sets of mutually dependent subgraphs, the hyperclique patterns of cardinality one are excluded. In this section, we propose an algorithm named HSG for mining frequent hy-perclique patterns in graph databases. Before describing the concrete algorithm, we show some properties of hyperclique patterns and a data structure called a conditional prefix tree of hyperclique patterns , that are utilized for the effective pruning based on the generality ordering of hyperclique patterns. 3.1 Properties of Hyperclique Patterns Given two sets G 1 and G 2 of subgraphs, if there exists an injective function  X  : G 1  X  G 2 which satisfies  X  g  X  G 1 g  X  ( g )  X  G 2 ,thenwesaythat G 1 is more general than G 2 and denote it as G 1 G 2 .

As shown formally below, given a set of subgraphs G 1 , there are two kinds of specializations to obtain a more specific set of subgraphs G 2 from G 1 .Note that, while only first kind of specialization is considered in item set mining, the second one also plays the key role in HSG mining. (1) Specialization by addition G 2 is obtained by adding a new subgraph g (2) Specialization by replacement G 2 is obtained by replacing a subgraph
The following two lemmas hold in hyperclique patterns of subgraphs based on the generality ordering introduced above.
 Lemma 1 (Anti-monotone property of support value). Given two sets G 1 and G 2 of subgraphs, if G 1 G 2 ,then sup D ( G 1 ) Proof. Obvious from the definition of support value.
 By this lemma, if a set of subgraphs G 1 does not satisfy the minimum support, then all sets of subgraphs G 2 s.t. G 1 G 2 can be eliminated safely from the candidate of frequent hyperclique patterns.
 Lemma 2 (Upper bound of h-confidence). Given two sets of subgraphs G if G B G B , then the following inequality holds. Proof. Since G A  X  G 2 ,max sup D ( G 1 )  X  sup D ( G 2 ) also holds. Therefore, sup D ( G 1 ) / max sup D ( G 2 ) / max This lemma gives the upper bound of h-confidence. If up ( G 1 ,G A ) does not satisfy the minimum h-confidence h c , then any set of subgraphs G 2 = G A  X  G B s.t. G
B G B must not satisfy h c . Furthermore, this lemma also shows the anti-monotone property of h-confidence with respect to the specialization by addition. no set of subgraphs obtained by adding some subgraphs to G 1 can satisfy h c . 3.2 A Conditional Prefix Tree of Hyperclique Patterns Here, we consider the enumeration of hyperclique patterns in graph databases.
According to the reverse search[2], t he repeated enumeration of the same pattern can be avoided by generating each pattern from its unique parent .In case of hyperclique patterns of subgraphs, the parent can be uniquely defined by using the total order of graphs formed by code word. The parent of a set of subgraphs G , denoted as p ( G ), is a set obtained by removing the smallest element with respect to &lt; lex from G , i.e. p ( G )= G \{ g  X  G |  X  g  X  Gg &lt; lex g } .
Because of the anti-monotone propert y of hyperclique patterns with respect to the specialization by addition shown in lemma1 and 2, all subsets of a frequent hyperclique pattern must be also frequent hyperclique patterns. Furthermore, a hyperclique pattern should be enumerated via its parent to avoid the repeated enumerations. Therefore, in our strategy, a new hyperclique pattern G will be generated by joining two hyperclique patterns G 1 = G  X  X  g 1 } and G 2 = G  X  X  g 2 } as G = G  X  X  g 1 } X  X  g 2 } = G 1  X  X  g 2 } . Note that  X  X he enumeration via parent X  can be naturally realized through the join operation.

Since a hyperclique pattern will be generated by joining two hyperclique pat-terns having the same parent, it is convenient to treat all hyperclique patterns which have the same parent as an unit. Furthermore, in order to effectively uti-lize the pruning based on the generality ordering, hyperclique patterns in this unit should be organized in consideration of the generality ordering. Motivated by these backgrounds, we propose a tree-shaped data structure called condi-tional prefix tree of hyperclique patterns , on which our algorithm HSG works, for storing hyperclique patterns which have the same parent in common.

A conditional prefix tree of hyperclique patterns CPT G =( V G ,E G ,B G , root ) is an ordered tree and it stores hyperclique patterns which have a hyperclique pattern G as those parent. The root node root is a dummy node. Each node v in V
G , except for root , corresponds to a hyperclique pattern G graph g ( v ). E G  X  V G  X  V G and B G  X  V G  X  V G represent the set of parent-child and sibling relationships, respectively. These are formally defined as follows. of v 3 .Notethat,  X  ( g 1 ,g 2 )  X  E G g 1 g 2 holds. The children of a node are ordered in the lexicographic order &lt; lex . An example of conditional prefix tree is shown in Fig.2. This tree is constructed from six hyperclique patterns that have { G } as parent in common. 3.3 HSG: A Hyperclique Pattern Miner in Graph Databases In this subsection, we propose an algorithm HSG and explain it in detail.
The algorithm HSG for mining frequent hyperclique patterns in graph data-bases is shown in Fig.3. In the following explanation, we use the notations below for the sake of simplicity: G x = G  X  X  g ( g x ) } , G x = G  X  X  g ( g x ) } and G x,y = G  X  X  g ( g
As an input, HSG takes an unconditional prefix tree CPT  X  of hyperclique patterns that stores frequent hyperclique patterns of cardinality one, i.e. frequent subgraphs potentially obtained by the conventional graph miners[28,11,10,16]. Then, HSG calls a procedure LoopV with T a = T b = CPT  X  (line1 in HSG).
HSG consists of two main procedures LoopV and LoopH which realize the join of elements in a conditional prefix tree mutually while considering the generality ordering. LoopV traverses a tree T a in preorder by using recursive call (line5 in LoopV). By using the preorder traversal, elements in T a will be considered in the order of &lt; lex . During the traversal, LoopV calls LoopH with G , g a and T b (line3 in LoopV). LoopH also traverses a tree T b in preorder (line16 in LoopH). Since T a and T b refer to the same tree at the beginning, if no pruning is applied, all pairs of elements in a conditional prefix tree w ill be considered. Note that, no repeated enumeration occurs due to the check of g ( g a )  X  lex g ( g b ) (line2 in LoopH). During the recursive calls, LoopH cons tructs two new conditional prefix trees NT a and NT b which form the search spaces afterwards. NT a is a prefix tree under the condition G a and it is used as an input for discovering hyperclique patterns whose parent is G a,b (line4 in LoopV). NT a will be constructed by adding a new hyperclique pattern G a,b whenever it is obtained (line10 in LoopH). NT b is a prefix tree under the condition G , on which hyperclique patterns having G a as parents will be mined (line5 in LoopV). Conceptually, NT b will be obtained by pruning some branches in T b .

Four prunings will be applied in LoopH. They are achieved partially by  X  X ot adding new vertices to NT a and NT b  X . The first pruning is based on the anti-monotone property of support value in lemma1 (line5 in LoopH). If the support of G a,b is less than the minimum support, then all patterns which are more specific than G a,b must not satisfy the minimum support. Thus, we ignore the following specializations of G a,b by skipping the loop of line1 in LoopH: (1) G a,b by not calling LoopH (line16 in LoopH), (2) patterns obtained by  X  X pecialization of G a,b by addition X  by not updating NT a ,and(3) G a ,b and G a ,b by not updating NT b . The second pruning is derived from the upper bound of h-confidence in lemma2 (line6 in LoopH). As similar to the first pruning, all specializations of G a,b will be ignored in the same way. The third pruning is by anti-monotone property of h-confidence with respect to the specialization by addition in lemma2 (line8 in LoopH). If G a,b dose not satisfy minimum h-confidence, the search for patterns having G a,b as parent will be avoided by not adding G a,b to NT a .The fourth pruning is based on the upper bound of h-confidence in lemma2 (line13 in LoopH). The search for G a,b can be avoided by not calling LoopH. Note that, G a ,b as well as G a ,b must be considered. Therefore, NT b has to be updated. This is achieved through the update of N b .

As shown above, HSG makes the best use of the pruning based on the special-izations by using the conditional prefix trees. For HSG, the following theorem holds.
 Theorem 1. Given an unconditional prefix tree having all frequent subgraphs, HSG discovers all frequent hyperclique patterns without any duplication. Proof. Derived from the complete enumeration procedure by the double preorder traversals and the safety prunings guaranteed by lemma1 and 2.
 Although HSG can discover all frequent hyperclique patterns, the obtained set of hyperclique patterns may contain some redundancy. Since each frequent subgraph in the unconditional prefix tree is treated as an item, if some sub-graphs which are equivalent in some se nses are contained in the tree, they cause the redundancy. To eliminate obviously redundant patterns, we believe that the frequent subgraphs included in the unconditional prefix tree should be limited to the representatives such as closed subgraphs (a graph g c s.t.  X  g g c g  X  sup D ( g c )= sup D ( g )) or minimal subgraphs (a graph g m s.t.  X  g g g m  X  sup D ( g m )= sup D ( g )). In particular, minimal subgraphs might be more suitable if the edge-disjointness is considered in the joint occurrence. Although, to the best of our knowledge, the method which finds minimal sub-graphs directly has not been proposed yet, those subgraphs can be obtained by some post-processing of the conventional graph miners[28,11,10,16]. The concept of HSG mining is inspired by the hyperclique pattern discovery in transaction databases [26,27].
 The methods of mining correlated pairs of items have been proposed[25,23,7]. Furthermore, correlated pattern mining based on a pattern-growth methodology in transaction databases has been proposed[15]. Compared with these methods, HSG is different in the point of finding sets of affinitive structured patterns.
On the correlation mining in graph databases, a new problem named Corre-lated Graph Search has been proposed recently[12]. In this problem, Pearson X  X  correlation coefficient[20] is employed as correlation measure and all correlated subgraphs with a query graph will be discovered. This framework is greatly dif-ferent from our proposal because the different measure is employed and only subgraphs correlated with a given query are considered.

Pattern team proposed in [13] is a set of patterns that optimizes some quality measure. The discovery of pattern team may look similar to the HSG mining because both find the set or combination of patterns. However, pattern team discovery is done by selecting patterns f rom the given set. In addition, pattern team usually consists of a set of mutually dissimilar and independent patterns for optimizing the quality measure. Similar to the pattern team in some senses, the concept of  X  -orthogonal patterns in graph databases has been proposed recently[6]. In this framework, a set o f frequent maximal subgraphs that are mutually dissimilar with each other will be obtained by employing a randomized search. While treating a set of subgraphs, this framework is also different from the HSG mining because HSG discovers the complete sets of affinitive subgraphs.
From the aspect of finding similar patterns, redescription mining [19,17,29] is closely related to the HSG mining. In red escription mining, patterns consist of any combinations of conjunction, disjunction and negation of items and pairs of patterns that occur in almost the same transactions will be discovered. While this framework is very general, neither the application to the structured data nor precise algorithms which use the generality ordering have been proposed yet. To assess the effectiveness of the proposed algorithm, we implement HSG in Java and conduct some experiments with the datasets shown in Table1 on a PC (CPU: Intel(R) Core2Quad 2.4GHz) with 4Gbytes of main memory running Windows XP. Furthermore, another miner pHSG, that is  X  X SG without pruning (2) and (4) X , is also prepared to demonstrate the effects of pruning related to the  X  X pecialization by replacement X . I n the experiments, we construct the un-conditional prefix trees CPT  X  by using minimal subgraphs only. Experimental results are shown in Table2.

The obtained number of hyperclique patterns decreases when the value of k is reduced. Furthermore, though not shown in Table2, about 231 million and 17 thousand of hyperclique patterns were obtained if we set  X  =0 . 1 ,h c =0 . 9and k =  X  in PTE and DTP CM , respectively. This means t hat the consideration of edge-disjointness succeeds in suppressing the generation of redundant patterns.
In all cases, pHSG discovers all frequent hyperclique patterns in a reasonable time though at least O ( | CPT  X  | 2 ) of candidates will be generated if no pruning applied. Thus, it is understood that the pruning by minimum support is effective enough. Note that, this pruning eliminates the patterns obtained by the  X  X pecial-ization by addition X  as well as the  X  X peci alization by replacement X . Compared with pHSG, the execution time of HSG f or real world problems decreases to 16.0% in the maximum and to 33.9% on the average. The number of candidate patterns is also reduced to 15.9% in the maximum and to 30.8% on the average. It is also observed that HSG runs about two times faster than pHSG in the synthetic dataset on the average. These reductions are the strong evidences to show the effectiveness of the pruning based on the generality ordering, especially on the  X  X pecialization by replacement X . In this paper, we formulate the problem of hyperclique pattern discovery in graph databases. To solve this problem efficiently, a novel algorithm named HSG is pro-posed that utilizes the depth-first/breadth-first search with the effective pruning based on the generality ordering. We believe that HSG can mine hyperclique patterns efficiently not only in other types of structured data but also in trans-action databases with the conceptual hierarchy because the conditional prefix trees, on which HSG works, can be constructed naturally from these kinds of datasets.

For future work, the theoretical analysis of the proposed algorithm and fur-ther experiments with large-scale datasets are necessary. In addition, some more efficient mechanism is required for com puting support value of a set of edge dis-joint subgraphs. For this objective, we plan to employ the idea of support value computation of edge disjoint subgraphs in a large graph[14]. We also plan to apply the proposed algorithm to top-k correlated pattern discovery as well as to redescription mining in structured databases.

