
Many applications track the movement of mobile objects, which can be represented as sequences of timestamped lo-cations. Given such a spatio-temporal series, we study the problem of discovering sequential patterns, which are routes frequently followed by the object. Sequential pat-tern mining algorithms for transaction data are not directly applicable for this setting. The challenges to address are (i) the fuzziness of locations in patterns, and (ii) the iden-tification of non-explicit pattern instances. In this paper, we define pattern elements as spatial regions around fre-quent line segments. Our method first transforms the orig-inal sequence into a list of sequence segments, and detects frequent regions in a heuristic way. Then, we propose al-gorithms to find patterns by employing a newly proposed substring tree structure and improving Apriori technique. A performance evaluation demonstrates the effectiveness and efficiency of our approach.
The movement of an object (i.e., trajectory) can be de-scribed by a sequence of spatial locations sampled at con-secutive timestamps (e.g., with the use of Global Position-ing System (GPS) devices). Parts of the object routes are often repeated in the archived history of locations. For in-stance, buses move along series of streets repeatedly, people go to and return from work following more or less the same routes, etc. The movement routes of most objects (e.g., pri-vate cars) are not predefined. Even for objects (e.g., buses) with pre-scheduled paths, the routes may not be repeated with same frequency due to different schedule in weekends or some special days. We are interested in finding fre-quently repeated paths, i.e., spatio-temporal sequential pat-terns , from a long spatio-temporal sequence. These patterns could help to analyze/predict the past/future movement of the object, support approximate query on the original data, and so on. However, they cannot be obtained straightfor-wardly by eliminating the noisy movement because of the large volume of the spatio-temporal data.

Discovery of sequential patterns from transactional databases has attracted lots of interest since Agrawal et al. introduced the problem [1]. In such a database, each trans-action contains a set of items bought by some customer in one time, and a transaction sequence is a list of transac-tions ordered by time. For example, ( a, b ) , ( a, c ) , a sequence containing three transactions ( a, b ) , ( a, c ( b ) . Given a collection of transaction sequences, the prob-lem is to find ordered lists of itemsets appearing with high frequency. E.g., ( b ) , ( a ) , ( b ) is a pattern supported by the above sequence.

Unfortunately, pattern discovery techniques in transac-tional databases are not readily applicable for finding se-quential patterns in spatio-temporal data. First, the elements in a transactional pattern are items that explicitly appear in pattern instances. On the other hand, location coordinates in a spatio-temporal series are real numbers, which do not re-peat themselves exactly in every pattern instance. Second, the patterns are discovered from explicitly defined sets of Thus, a transaction list only contributes 0 or 1 to the sup-port of a pattern, depending on whether the pattern appears or not in the specific sequence-set. In our setting, however, we detect frequent patterns from one long spatio-temporal sequence, without predefined segmentation of the data. The challenge is to identify the segments that contribute to a pat-tern, without allowing them to overlap with each other.
To summarize, the main contributions of this paper are: (i) We propose a model for spatio-temporal sequential pat-terns mining, based on appropriate definitions for pattern elements and pattern instances. (ii) We present an effective method for extracting pattern elements. (iii) We provide efficient pattern mining algorithms for discovering longer patterns. The remainder of the paper is organized as fol-lows. Section 2 reviews the related literature. The formal definition of spatio-temporal sequential pattern is given in Section 3. Section 4 presents our solutions in detail. An ex-perimental evaluation about the effectiveness and efficiency of our approach is presented in Section 5. Finally, Section 6 concludes this paper.
Our work is most related to pattern discovery from se-quential data, which include time series, event sequences, and spatio-temporal trajectories.

Mannila et al. [10] investigated the discovery of frequent episodes from event sequences. An episodes is a (partially or totally) ordered list of events, thus is a variant of sequen-tial pattern. A fixed sliding window w is used to extract segments (i.e., subsequences) in the event series, and the contribution of every segment to each candidate episode X  X  frequency is counted. The segments supporting one episode may overlap, which is reasonable since episodes try to cap-ture the appearing order of instantaneous events. However, this methodology may not get satisfactory results in finding spatio-temporal patterns, for several reasons. First, the win-dow limits the length of the patterns. Second, pattern sup-ports may not be counted correctly. E.g., the object X  X  move-ment is aabbcdef g , where each character a , b , etc. corre-sponds to a spatial region. The occurrence of the pattern abc should be 1, since the object moves from a to c , once. How-ever, if w is 5, pattern abc has support 4 due to the contri-bution of 4 segments ( a b c , ab c , a bc ,and a bc ). Third, as opposed to well-defined categorical values for event in-stances, object locations do not repeat themselves exactly in pattern instances, for they are usually ordinal and inex-act. Yang et al. investigated mining long sequential patterns in [13], also dealing with event series with noise.
Previous work on detecting patterns from time-series (e.g, [2, 7]) converted the problem to finding subsequences in lists of categorical data (e.g., event sequences), by pre-processing the original sequence to a string. A window w of fixed size is slided along the sequence, and a subsequence with length w is extracted for every position . In [2], the subsequences are clustered based on their shapes, and each cluster is given an id. In [7], some features are extracted from each subsequence (e.g., the slope of the best-fitting line of the sub-series, the mean of the signal, etc.). The fea-ture space is divided into groups of similar values, and every subsequence is converted to a group-id. The raw sequence is then transformed to a string of cluster-ids or group-ids. The use of the window may over-count the patterns due to the reason explained above. In addition, since w is fixed ,theex-tracted subsequences have the same length, which may af-fect the resultant patterns. Furthermore, for spatio-temporal data, even when we extract the subsequences using a slid-ing window and get simple features from these segments, we cannot directly group these features using methods in [2] and [7]. The cluster-based approach ([2]) has been dis-credited by [8]. The way to group the subsequence features ([7]) may be effective for time-series with 1-dimension val-ues. For more complex spatio-temporal data, if we directly apply this method, i.e., split the features into groups, we may miss the information about the spatial proximity of seg-ments, which is essential for grouping.

The first study on finding frequent sequential patterns from spatio-temporal data is [11]. The raw data here is not a long sequence, but lists of spatial locations. After dis-cretizing the locations to pre-defined spatial decomposition, the process is intrinsically similar to that in transactional databases. [9] addresses the problem of discovering periodic pat-terns in spatio-temporal data, which is a generalization of mining periodic patterns in event sequences. Given a pe-riod T , in the case of spatio-temporal data, a periodic pat-tern is a (not necessarily contiguous) sequence of spatial regions, which appears frequently every T timestamps and describes the object movement (e.g., a bus moves from dis-trict a to district b andthento c with high probability, every three hours). The contribution of [9] is that it does not treat spatio-temporal series as event sequences, by merely replac-ing each location by a predefined region enclosing it, but automatically discovers the regions that form the patterns. This method, although effective for its purpose, relies on afixed T (i.e., the patterns repeat themselves every regular time periods). In addition, it is prone to distortions/shiftings of the pattern instances, i.e., periodic segments where the pattern does not appear in the same positions as in the pat-tern definition do not contribute to the pattern X  X  support.
A spatio-temporal sequence S is a list of locations, ( x 1 ,y 1 ,t 1 ) , ( x 2 ,y 2 ,t 2 ) , ..., ( x n ,y n ,t n ) sents the timestamp of location ( x i ,y i ) ( 1  X  i  X  n ). Figure 1 illustrates the movement of an object which repeats a sim-ilar route in three runs. We are interested in movement pat-terns repeated frequently in such a series. This section first motivates our solution, then formally defines the problem. 3.1 Motivation
Locations are not repeated exactly in every instance of a movement pattern. Our idea is to summarize a series of spatial locations to that of spatial regions.

A naive method is to use a regular grid (or some pre-defined spatial decomposition) to divide the space into re-gions by taking a user-defined parameter G ,an approximate number that each axis will be split to. Then, the locations series can become a sequence of grid-ids utilizing a trans-formation approach. The first method, Grid I, converts each location to the id of the cell it falls in. E.g., the raw se-ries in Figure 1a, can be transformed to the cell-id sequence c c 4 c 8 c 9 c 6 c 2 ...c 3 . Although intuitive, this method has two problems. First, we lose the information on how the object moves inside a cell, if the space decomposition is coarse. The patterns may not be very descriptive. Second, for two instances of a pattern, the locations may not fall into the same cell (i.e., two adjacent locations appear in neigh-boring cells). We may miss some frequent patterns, whose instances are divided between different grid-based patterns. The first problem could be alleviated by decreasing G ,how-ever, this would increase the chances of missing patterns due to the second problem. An alternative conversion tech-nique adds the ids of cells that intersect with the line seg-ments connecting consecutive locations to the transformed sequence. In the example of Figure 1a, Grid II converts the sequence for the first run to c 2 c 1 c 4 c 7 c 8 c 9 c 6 less, by this improvement, the new series may be signifi-cantly longer than the original one, which may already be extremely long, like spatio-temporal sequences usually are. Thus, we need a better way to abstract the trajectory. Motivated by line simplification techniques ([3]), we repre-sent segments of the spatio-temporal series by directed line segments. Figure 1b shows that the line segment l summa-rizes the first three points in each of the three runs with little error. In this way, not only do we compress the original data, decreasing the mining effort, but also the derived line seg-ments (which approximately describe movement) provide initial seeds for defining the spatial regions, which could be expanded later by merging similar and close segments. 3.2 Problem definition
A segment s ij in a spatio-temporal sequence S (1  X  i&lt;j  X  n ) is a contiguous subsequence of S , starting from ( x i ,y i ,t i ) and ending at ( x j ,y j ,t j ) .Given s fine its representative line segment l ij with starting point ( x i ,y i ) and ending point ( x j ,y j ) .Let beadistanceer-ror threshold, s ij complies with l ij with respect to and is denoted as s ij  X  l ij ,ifdist (( x k ,y k ) , l ij )  X  k ( i  X  k  X  j ) , where dist (( x k ,y k ) , l ) is the distance be-tween ( x k ,y k ) and line segment l .When s ij  X  l ij , each point ( x k ,y k ) ,i  X  k  X  j ,in s ij can be projected to a point ( x of ( x k ,y k ) to l ij . Figure 2a illustrates a segment s ij plying with l ij and shows the projection ( x k ,y k ) of point ( x k ,y k ) on l ij .A segmental decomposition S s of S is defined by a list of consecutive segments that constitute S . notation, we use s 0 s 1 ...s m  X  1 to denote S s .
Let l represent a directed line segment, l.angle and l.len be its slope angle and length respectively. Two line seg-ments l ij and l gh representing segments s ij and s gh are similar , denoted by l ij  X  l gh , with respect to angle dif-ference threshold  X  and length factor f ( 0  X  f  X  1 )if: (i) | l ij .angle  X  l gh .angle | X   X  and (ii) | l ij .len  X  l gh .len | X  f  X  max ( l ij .len, l gh l ij  X  l gh , s ij and s gh are also treated as similar to each other. Note that similarity is symmetric. The location infor-mation of segments is not considered in defining similarity, since we use it when defining the segments X  closeness.
Line segment l ij is close to l gh if for  X  ( x k ,y k )  X  dist (( x k ,y k ) , l gh )  X  .When l ij is close to l gh say that the segment s ij is close to the segment s gh ,where s ij  X  l ij and s gh  X  l gh . As opposed to similarity, close-ness is asymmetric. Figure 2b shows an example. Let l ij is parallel to l gh and =5 . 0 . The distance between these two parallel line segments is 4 . 5 . Observe that l ij is close to l gh because the distance from each point in l ij to l gh is less than 5 . 0 .However, l gh is not close to l ij for the point in the right upper part has distance to l ij bigger than 5 . 0 .
Let L be a set of segments from sequence S s .The mean line segment for L , l c , is a line segment that best fits all the points in L with the minimum sum of squared errors (SSE). In other words, if PSet contains all the points of the segments in L , the mean line segment l c is such that
Let tol be the average orthogonal distance of all the points in L to l c . A spatial pattern element is a rectangu-lar spatial region r L with four sides determined by ( l c as following: (1) two sides of r  X  X  that are parallel to l thesamelengthas l c , and their distances to l c are tol ;(2) the other two vertical sides have length 2  X  tol ,andtheir midpoints are the two end points of l c . We refer to l c the central line segment of region r L . We say that region r
L contains k segments or k segments contribute to r L if L consists of k segments. Figure 2c visualizes this definition. A spatio-temporal sequential pattern P is an ordered se-quence of pattern elements: r 1 r 2 ...r q , (1  X  q  X  m ) length of pattern P is the number of regions in it.
A contiguous subsequence of S s , s i s i +1 ...s i + q  X  1 pattern instance for P : r 1 r 2 ...r q if  X  j (1  X  j  X  q the representative line segment for segment s i + j  X  1 is sim-ilar and close to the central line segment of region r j .A pattern X  X  instances cannot overlap in time (the pattern may be over-counted like that in [10] otherwise), i.e., if two con-tinuous subsequences of S s , s i ...s j and s g ...s h ,aretwo instances for pattern P , either j&lt;g or h&lt;i .Givenpat-terns P : r 1 r 2 ...r i and P : r 1 r 2 ...r j , P is a subpattern of P if i  X  j and  X  k, (1  X  k  X  j  X  i +1) such that r 1 = r = r k +1 , ... , r
The support of a pattern P is the number of instances supporting P . Given a support threshold min sup , P is frequent if its support exceeds min sup . Since a pattern with same frequency to one of its supersets is redundant, we focus on detecting closed frequent patterns [4], for which every proper subpattern has equal frequency. The mining problem is to find frequent patterns from a long spatio-temporal sequence S with respect to a support threshold min sup , and subject to a segmenting distance error thresh-old , a similarity parameter  X  and a length factor f .The parameter values depend on the application domain, or can be tuned as part of the mining process [2]. In using the raw data to discover patterns, we discuss how to set the parame-ters in Section 5.1 more applicably.
In this section, we describe how to discover frequent sin-gular patterns, i.e., frequent spatial regions (Section 4.1) and longer closed patterns (Section 4.2). 4.1 Discovering frequent singular patterns
The segmentation (line simplification) algorithm ([3, 5, 6]) is used to convert the locations series to segments se-quences so that each raw sequence segment could be ab-stracted by a line segment. Our idea is to transform S to S s using such a technique, and take the segments obtained as seed for the desired spatial regions, whose central line segments best fit the points of segments in the regions. The DP (Douglas-Peucker) algorithm [3] is a classical top down approach for this problem. [6] provides an online algorithm in splitting a sequence to segments with quite good quality. Since it is important to keep the internal movement inside a region, we need to capture the sharp turn of the movement in the transformation. We employ DP method because it has been proved to be the best algorithm in choosing split-ting points [12]. In brief, DP algorithm recursively decom-poses S : { p 1 ,...,p n } to a series of line segments l m  X  n , each of which, l i , simplifies a subsequence S l such that the perpendicular distance from every point in S to l i is at most . For efficiency purpose, DP X  X  improved version ([5]) could be adopted.

Discovering frequent singular patterns from S s is a hard problem, since in the worst-case, all combinations of seg-ments in S s have to be considered as candidate. To expe-dite the process, we employ a heuristic, Growing .Let Segs be a set initially containing all the segments in S s . Grow-ing works as follows. It selects the segment s with median length, i.e., the median of the lengths of the segments in Segs , as seed for the initial spatial region r . Then, r is grown by merging other segments in Segs through filtering and verification steps, described later. Next, for the set of remaining segments not merged to r , the segment s with median length in it is selected as seed for growing. Finally, the overall algorithm terminates after all segments (i) have been assigned to a region (as initial seeds or to the region of another seed), or (ii) have been found not to belong to any frequent region and marked as outliers. Selecting the seg-ment with median length as seed could help to absorb short segments with less error, compared to taking segment with longer length as seed. Meanwhile, it could prevent gener-ating regions with too fine granularity, which could happen when shorter length segment is used as seed. Growing is deterministic in using this seed selection procedure.
The filtering process checks two conditions. First, for each s i in Segs the angle difference dif f a i between l s is computed, and s i is treated as candidate if dif f a i less than  X  . All the candidate segments are put into a set C . Second, the minimum distance from every segment in C to l is computed and all segments whose minimum distances to l s is larger than f  X  l s .len are pruned. The remaining segments in C will be used for verification.

The filtering step computes the minimum distance be-tween segments, but it does not consider the length differ-ence (second condition of similarity), between each l s i and l s , and the exact spatial distances of segments in C to l (closeness condition). In the verification step, Algorithm 1 (shown below) merges the segments in C to the spatial re-gion r around l s ,if s i  X  C satisfies the closeness and length difference condition. Otherwise, we extract from s i the part that satisfies the condition, and merge this part with r .The remaining part of s i is a new segment and inserted back to Segs (Line 15) for later processing.
 Algorithm 1 Verification( l s , C , Segs , f , min sup )
We explain how we compute the intersected part of s i and l s in Line 4. Let l s i be the representative line seg-ment for s i . If all projection points ( x k ,y k ) in l distance to l s no more than  X  (Line 1), its related location point ( x k ,y k ) in the segment is put into the intersected part s . The line segment created by mapping each point in s to l s i is denoted as l s . For example, let s i represent seg-distances from points in l s i to l s are all smaller than  X  ex-cept points from ( x 10 ,y 10 ) to ( x 15 ,y 15 ) . Then, s is seg-ment ( x 16 ,y 16 ,t 16 ) , ... , ( x 30 ,y 30 ,t 30 ) ,and l line segment from ( x 16 ,y 16 ) to ( x 30 ,y 30 ) in l s 4.2 Deriving longer patterns
After finding frequently visited spatial regions, original data S is converted to a series S R of spatial regions by changing the segments in frequent regions to region ids, and those not in any region to outliers. S R preserves the motion continuity of the object by showing how it moves among regions. Although each region in S R is repeated frequently, the concatenation of some regions may not be frequent. E.g., a person living in r 1 often goes to a place r in some days and to region r 3 in other days. r 1 , r 2 and r are frequently visited, but the path r 2 r 3 is not frequent. This section discusses how to detect the longer frequent patterns. 4.2.1 Level-wise mining A direct way is to perform level-wise pattern mining. How-ever, this approach suffers from the disadvantage that S R needs to be scanned many times. We propose solutions to reduce the number of candidates and scans in probing long candidates, based on the following properties we observe.
Property 1 (Connectivity Constraint): Due to conti-nuity of object movement, a spatial region can only connect to some but not all the others in S R . This constraint can help reduce the number of generated candidates, as follows. We first construct a connectivity graph for all the spatial re-gions in S R . A directed edge from r i to r j is added to the graph if the substring r i r j appears in the sequence. The edge weight is the frequency that r i r j appears in the se-quence. Let r 1 r 2 ...r k be a frequent pattern, and r k points to r i and r j , only two candidates, r 1 r 2 ...r r r 2 ...r k r j are generated. Further, if the edge weight from r to some element, say r i , is no more than min sup ,we need not generate candidate r 1 r 2 ...r k r i .

Property 2 (Closeness Property): Given a pattern P , suppose its last element connects to r 1 , r 1 connects to r ... , r m  X  1 connects to r m ,( m  X  2 ). We can get pattern P 1 = Pr 1 (concatenating P and r 1 ), P 2 = Pr 1 r 2 , ... , P m = Pr 1 r 2 ...r m . Obviously, if P 1 and P m have the same support, any P i ,( 1 &lt;i&lt;m ) also has the same support. This property helps to generate candidates more efficiently. Let result be the frequent patterns at the end of the k th scan and P be a pattern in it with last element r .We can extend P using other patterns in result that start with r . For instance, let P = r 1 r 2 r 3 ,and r 3 only connect to r the connectivity graph. In addition, assume that result con-tains only one pattern starting from r 3 : P = r 3 r 4 r 6 can then be extended to candidates r 1 r 2 r 3 r 4 (using Property 1), and r 1 r 2 r 3 r 4 r 6 r 7 (using Property 2). If r 1 r r 2 r 3 r 4 r 6 r 7 have the same support after the counting, we only need to consider candidates longer than r 1 r 2 r 3 r later, significantly reducing the number of scans. 4.2.2 Mining using the substring tree We propose a substring tree structure to facilitate counting of long substrings with different elements. The substring tree is a rooted directed tree whose root links to multiple substring sub-trees. Each node in a sub-tree consists of pat-tern element and a counter, which counts the number of substrings (i.e., subsequences of elements) that contribute to the pattern formed by the path from the root to this node. A substring tree example is shown in Figure 3a.

To construct the tree, in scanning S R , we extract sub-strings containing distinct elements, and insert them to the tree. In seeing an element r in S R , we concatenate it to the substrings found so far that do not contain r . Also, if no substring starting with r is found, r is treated as a new substring. We give an example to illustrate the extraction of substrings. Let S R be r 1 r 2 r 3 r 4 r 1 r 3 r 4 r 2 r 3 tially, no substring is extracted. When see the first r 1 create a new substring for it. On seeing the second element r , we create a new substring r 2 since no substring starting with r 2 exists. In addition, we concatenate it to the only substring r 1 and get r 1 r 2 . The process continues until we see the fifth element r 1 . There is already a string r 1 and a new substring starting from r 1 is created. Figure 3a shows the full substring tree for sequence S R .
For deriving frequent patterns from the substring tree, we utilize a stack. Each element in the stack comprises of a pattern , its count and a level , indicating whether the pat-tern has reached a leaf or not. First, we add to the stack the patterns associated with the root X  X  children. Then, we iter-atively pop patterns with highest frequency from the stack. If the popped up pattern is not at leaf level and is frequent, we output it, and extend it by concatenating it with its chil-dren X  X  elements and push the extended patterns to the stack; otherwise, the pattern is just output (if frequent). In the above example, there are in itially four elements in the stack. Figure 3b shows the first several steps for the mining pro-cess. Let min sup =2 . When popping r 3 (4) from the initial stack, we output it as result, and extend it to r since it is not at the leaf level. Next, we pop up r 3 r 4 and delete r 3 (4) from the result because its frequency is the same to that of r 3 r 4 (definition of closed patterns). This process continues until no pattern exists in the stack. The final closed patterns are r 3 r 4 (4) , r 1 (3) , r 2 r 3 r ered from the substring tree are not the final results be-cause they only contain patterns with distinct elements. We extend the patterns using the level-wise method. The re-sult may contain overlapping patterns like r 1 r 2 r 3 r 4 r r 3 r 4 r 1 (2) . We report all of them though the pattern space may be large. The reason is that if we output only one of them, say r 1 r 2 r 3 r 4 (2) , the information that r 4 connects to r (necessary for generating longer patterns) will be missed. Finally, our algorithm outputs frequent closed patterns.
This section evaluates our proposed approach with real and synthetic data. After discussing the way to set the pa-rameters in Section 5.1, we study the effectivesness and ef-ficiency in Section 5.2.

Real datasets: The real data contain tracked bus move-ments in Patras, Greece. Each sequence is the movement of a bus in a single day. The coordinates in the sequence are in meters following the EGSA84 projection (A Greek coordinate system). Bus locations were sampled every 30 seconds. However, since a vehicle might stop intermittently and the GPS is switched off during that period, the move-ment in a sequence may not be straightly continuous. The series length varies in the range between 1000 to 7000.
Synthetic data: We also generated long sequences to facilitate the performance study. The generator takes three parameters, | p | , n ,and m . | p | is the number of line segments constituting circular paths (i.e., patterns) of the movement. n denotes the sequence length. And m represents the num-ber of times that the object repeats the patterns. Obviously, n&gt; | p | X  m . The generator first creates circular routes with | p | connected line segments. Then, it generates lo-cations along the routes to simulate the object movement. The actual number of positions for each run is produced by adding/reducing some random values to/from n m .In every run, the locations for each line segment are approxi-mately the same. The description of the artificial series is given in related experiments. 5.1 Setting the parameters
We employ a heuristic based on sampling, to determine the value of parameter . We choose a random sample from the dataset and keep only the locations, for which the x co-ordinates are very close to a set of x values, say x 1 ,x For each value in the set, we cluster the y coordinates of the sample points and derive dense ranges of y values. For instance, in Figure 4 for x values x 1 =1 ,x 2 =2 ,x 3 =3 we can identify 6 dense ranges YR 1 ,YR 2 ,...,YR 6  X  denoted by the bold (red in color mode) vertical short line segments.

We define y as the average length of these y val-ues. Similarly, x can be obtained. Finally, we set = min { x , y } as smaller will allow pattern definition at a finer granularity. Experimentally, we found that, for most datasets, by setting to the estimated value (even vary a little),  X  to around 0.3 radians, and f to around 0.2 (20% rule), our algorithm retrieves hidden patterns in the data, i.e., pre-scheduled paths for bus data and patterns generated for synthetic data. 5.2 Effectiveness and efficiency study
We examine the effectiveness of our method taking as input a raw bus movement sequence shown in Figure 5a, which contains 6921 locations. This movement exhibits partial regularity and consists of noise.

For visualization purpose, we show its interesting part in more detail in Figure 5b because the remainder contains noise segments appearing only once. According to the de-scription in Section 5.1, we tune the parameters to =20 (map size is 100  X  100 ), f =0 . 2 ,  X  =0 . 3 radian, and min sup =3 . In this movement, the frequently repeated paths are around cell c 51 . Figure 5c and 5d show the two longest closed patterns discovered by our method. For sim-plicity, only the central line segments for the regions in the patterns are plotted. The arrow of each central line seg-ment shows the movement direction inside that region and the connection of these directed line segments illustrates the movement from one region to another. They are not con-nected because of the noise movement near the boundary of grid 51 (see Figure 5b). We also plot the results discovered by Grid II since it is more effective than Grid I. When G is 10, the pattern discovered near cell 51 is c 50 c 51 c 60 5e (movement from the region of cell c 50 to cell c 51 then to cell c 60 ). This is quite coarse, since the movement inside each cell is unknown. The longest closed patterns for G =20 and G =100 are shown in Figure 5f and Figure 5g. They improve on accuracy with the increase of G ,however,the patterns in the cell above c 51 (related to pattern in Figure 5d) is still missed. Furthermore, the mining efficiency degrades significantly. Our approach takes about 200ms, while Grid II with G = 100 takes about 450ms, which is more than double. In summary, the results show that our method can find hidden sequential patterns effectively. Given proper G , Grid II can also discover coarse movement patterns. How-ever, it suffers from two disadvantages (i) the internal move-ment in a grid cell cannot be found; (ii) it is less efficient than our method in finding patterns of similar quality.
We used synthetic data to evaluate the efficiency .We first analyze the performance of finding frequent singular patterns. The parameters of the data generator were set to | p | =20 , n =30 K ,and m =50 in a map of size=1  X  1. We set the mining parameters =0 . 01 , f =0 . 2 and  X  =0 . 3 and vary min sup . The performance is shown in Table 1a. Num P 1 is the number of frequent singular patterns and S len is the length of S only when the increase of min sup brings the decrease of Num P 1 . It is because the Growing method inspects more seeds before it finds satisfactory spatial regions when the re-sultant Num P 1 is smaller. In the worst case, every segment in Segs need to be examined.

Table 1b compares the total time spent by our methods, and the grid methods which use the substring tree for find-ing longer patterns. The generating parameters are | p | = 100 , m =50 ,and n = 500 K . The substring tree technique slightly outperforms the level-wi se method in all cases since it uses most time (about 12s) to find singular frequent pat-tern and most patterns contain long subpatterns with distinct elements. Their time is nearly constant to min sup because S len is the same for different min sup . The grid methods take longer time, since the transformed cell-ids sequence is much longer (i.e., n or higher) than that of S R .When we increase G from 10 to 20 , the time increases sharply, since the number of cells quadruplicates and the sequence becomes much longer. Sometimes, Grid II may take less time than Grid I (e.g., for G =10 and min sup =50 and 60). This happens because many cells in the sequence become outliers for this case, thus Grid II discovers shorter patterns (whereas Grid I finds longer ones, since it does not intro-duce intermediate cells at a sharp movement).
Figure 6 tests the scalability of our method in using the substring tree. We generate the datasets, keeping | p | con-stant (50) and changing n (the number of spatial locations in
S ) from 50K to 1.5M. The total cost is nearly linear to n , although it includes the cost for sorting the segments lengths and computing angle differences, which is about O ( mlogm ) where m ( m n ) is the number of segments.
In this paper, we modeled the problem of mining sequen-tial patterns from spatio-temporal data by considering both spatial and temporal information. Singular frequent pat-terns are found effectively, by grouping segments not only by similar shape (like previous work in time-series min-ing), but also by closeness in space. In addition, we em-ployed special properties of the problem (spatial connectiv-ity, closeness) and a newly proposed substring tree to accel-erate search for longer patterns.

The authors would like to thank Dieter Pfoser and CTI for providing us with the real bus dataset. Unfortunately, the data are copyrighted and cannot be made publicly avail-able. The work was supported by grant HKU 7142/04E from Hong Kong RGC.

