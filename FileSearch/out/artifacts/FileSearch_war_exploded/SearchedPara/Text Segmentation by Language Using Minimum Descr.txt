 For the purposes of this paper, a multilingual text means one containing text segments, limited to those longer than a clause, written in different languages. We can often find such texts in linguistic resources collected from the World Wide Web for many non-major languages, which tend to also contain portions of text in a major language. In automatic process-ing of such multilingual texts, they must first be seg-mented by language, and the language of each seg-ment must be identified, since many state-of-the-art NLP applications are built by learning a gold stan-dard for one specific language. Moreover, segmen-tation is useful for other objectives such as collecting linguistic resources for non-major languages and au-tomatically removing portions written in major lan-guages, as noted above. The study reported here was motivated by this objective. The problem addressed in this article is thus to segment a multilingual text by language and identify the language of each seg-ment. In addition, for our objective, the set of target languages consists of not only major languages but also many non-major languages: more than 200 lan-guages in total.

Previous work that directly concerns the problem addressed in this paper is rare. The most similar previous work that we know of comes from two sources and can be summarized as follows. First, (Teahan, 2000) attempted to segment multilingual texts by using text segmentation methods used for non-segmented languages. For this purpose, he used a gold standard of multilingual texts annotated by borders and languages. This segmentation approach is similar to that of word segmentation for non-segmented texts, and he tested it on six different European languages. Although the problem set-ting is similar to ours, the formulation and solution are different, particularly in that our method uses only a monolingual gold standard, not a multilin-gual one as in Teahan X  X  study. Second, (Alex, 2005) (Alex et al., 2007) solved the problem of detecting words and phrases in languages other than the prin-cipal language of a given text. They used statisti-cal language modeling and heuristics to detect for-eign words and tested the case of English embed-ded in German texts. They also reported that such processing would raise the performance of German parsers. Here again, the problem setting is similar to ours but not exactly the same, since the embedded text portions were assumed to be words. Moreover, the authors only tested for the specific language pair of English embedded in German texts. In contrast, our work considers more than 200 languages, and the portions of embedded text are larger: up to the paragraph level to accommodate the reality of mul-tilingual texts. The extension of our work to address the foreign word detection problem would be an in-teresting future work.

From a broader view, the problem addressed in this paper is further related to two genres of previ-ous work. The first genre is text segmentation. Our problem can be situated as a sub-problem from the viewpoint of language change. A more common set-ting in the NLP context is segmentation into seman-tically coherent text portions, of which a represen-tative method is text tiling as reported by (Hearst, 1997). There could be other possible bases for text segmentation, and our study, in a way, could lead to generalizing the problem. The second genre is classification, and the specific problem of text clas-sification by language has drawn substantial atten-tion (Grefenstette, 1995) (Kruengkrai et al., 2005) (Kikui, 1996). Current state-of-the-art solutions use machine learning methods for languages with abun-dant supervision, and the performance is usually high enough for practical use. This article con-cerns that problem together with segmentation but has another particularity in aiming at classification into a substantial number of categories, i.e., more than 200 languages. This means that the amount of training data has to remain small, so the methods to be adopted must take this point into considera-tion. Among works on text classification into lan-guages, our proposal is based on previous studies us-ing cross-entropy such as (Teahan, 2000) and (Juola, 1997). We explain these works in further detail in  X  3.

This article presents one way to formulate the seg-mentation and identification problem as a combina-torial optimization problem; specifically, to find the set of segments and their languages that minimizes the description length of a given multilingual text. In the following, we describe the problem formulation and a solution to the problem, and then discuss the performance of our method. In our setting, we assume that a small amount (up to kilobytes) of monolingual plain text sample data is available for every language, e.g., the Universal Declaration of Human Rights, which serves to gen-erate the language model used for language identifi-cation. This entails two sub-assumptions.

First, we assume that for all multilingual text, every text portion is written in one of the given languages; there is no input text of an unknown language without learning data. In other words, we use supervised learning. In line with recent trends in unsupervised segmentation, the problem of finding segments without supervision could be solved through approaches such as Bayesian meth-ods; however, we report our result for the supervised setting since we believe that every segment must be labeled by language to undergo further processing.
Second, we cannot assume a large amount of learning data, since our objective requires us to con-sider segmentation by both major and non-major languages. For most non-major languages, only a limited amount of corpus data is available. 1
This constraint suggests the difficulty of applying certain state-of the art machine learning methods re-quiring a large learning corpus. Hence, our formu-lation is based on the minimum description length (MDL), which works with relatively small amounts of learning data.

In this article, we use the following terms and notations. A multilingual text to be segmented is denoted as X = x 1 , . . . , x | X | , where x i denotes the i -th character of X and | X | denotes the text X  X  length. Text segmentation by language refers here to the process of segmenting X by a set of borders B = [ B ber of borders, and each B i indicates the location of a language border as an offset number of charac-ters from the beginning. Note that a pair of square brackets indicates a list. Segmentation in this paper is character-based, i.e., a B i may refer to a position inside a word. The list of segments obtained from B is denoted as X = [ X 0 , . . . , X | B | ] , where the con-catenation of the segments equals X . The language of each segment X i is denoted as L i , where L i  X  X  , the set of languages. Finally, L = [ L 0 , . . . , L | B | denotes the sequence of languages corresponding to each segment X i . The elements in each adjacent pair in L must be different.

We formulate the problem of segmenting a multi-lingual text by language as follows. Given a multi-lingual text X , the segments X for a list of borders B are obtained with the corresponding languages L . Then, the total description length is obtained by cal-culating each description length of a segment X i for the language L i : The function dl L i ( X i ) calculates the description length of a text segment X i through the use of a language model for L i . Note that the actual total description length must also include an additional term, log 2 | X | , giving information on the number of segments (with the maximum to be segmented by each character). Since this term is a common constant for all possible segmentations and the min-imization of formula (1) is not affected by this term, we will ignore it.

The model defined by (1) is additive for X i , so the following formula can be applied to search for language L i given a segment X i : under the constraint that L i 6 = L i  X  1 for i  X  { 1 , . . . | B |} . The function dl can be further decom-posed as follows to give the description length in an information-theoretic manner: Here, the first term corresponds to the code length of the text chunk X i given a language model for L , which in fact corresponds to the cross-entropy of X i for L i multiplied by | X i | . The remaining terms give the code lengths of the parameters used to describe the length of the first term: the second term corresponds to the segment location; the third term, to the identified language; and the fourth term, to the language model of language L i . This fourth term will differ according to the language model type; moreover, its value can be further minimized through formula (2). Nevertheless, since we use a uniform amount of training data for every language, and since varying  X  would prevent us from improv-ing the efficiency of dynamic programming, as ex-plained in  X  4, in this article we set  X  to a constant obtained empirically.

Under this formulation, therefore, when detect-ing the language of a segment as in formula (2), the terms of formula (3) other than the first term will be constant: what counts is only the first term, simi-larly to much of the previous work explained in the following section. We thus perform language de-tection itself by minimizing the cross-entropy rather than the MDL. For segmentation, however, the con-stant terms function as overhead and also serve to prohibit excessive decomposition.

Next, after briefly introducing methods to calcu-late the first term of formula (3), we explain the so-lution to optimize the combinatorial problem of for-mula (1). The first term of (3),  X  log 2 P L i ( X i ) , is the cross-entropy of X i for L i multiplied by | X i | . Vari-ous methods for computing cross-entropy have been proposed, and these can be roughly classified into two types based on different methods of univer-sal coding and the language model. For example, (Benedetto et al., 2002) and (Cilibrasi and Vit  X  anyi, 2005) used the universal coding approach, whereas (Teahan and Harper, 2001) and (Sibun and Reynar, 1996) were based on language modeling using PPM and Kullback-Leibler divergence, respectively.
In this section, we briefly introduce two meth-ods previously studied by (Juola, 1997) and (Teahan, 2000) as representative of the two types, and we fur-ther explain a modification that we integrate into the final optimization problem. We tested several other coding methods, but they did not perform as well as these two methods. 3.1 Mean of Matching Statistics (Farach et al., 1994) proposed a method to esti-mate the entropy, through a simplified version of the LZ algorithm (Ziv and Lempel, 1977), as follows. Given a text X = x 1 x 2 . . . x i x i +1 . . . , Len i is de-fined as the longest match length for two substrings x x 2 . . . x i and x i +1 x i +2 . . . . In this article, we de-fine the longest match for two strings A and B as the shortest prefix of string B that is not a substring of A. Letting the average of Len i be E [ Len ] , Farach verges to zero as i  X  X  X  , where H ( X ) indicates the entropy of X . Then, H ( X ) is estimated as (Juola, 1997) applied this method to estimate the cross-entropy of two given texts. For two strings Y = y 1 y 2 . . . y | Y | and X = x 1 x 2 . . . x | X | , let Len i ( Y ) be the match length starting from x i of X for Y 2 . Based on this formulation, the cross-entropy is approximately estimated as Since formula (1) of  X  2 is based on adding the description length, it is important that the whole value be additive to enable efficient optimization (as will be explained in  X  4). We thus modified Juola X  X  method as follows to make the length additive: Although there is no mathematical guarantee that  X  J
Y ( X ) or entropy, our empirical tests showed a good estimate for both cases 3 . In this article, we use  X  J 0 Y ( X ) as a function to obtain the cross-entropy and for multi-plication by | X | in formula (3). 3.2 PPM As a representative method for calculating the cross-entropy through statistical language model-ing, we adopt prediction by partial matching (PPM), a language-based encoding method devised by (Cleary and Witten, 1984). It has the particular char-acteristic of using a variable n-gram length, unlike ordinary n-gram models 4 . It models the probability of a text X with a learning corpus Y as follows: where n is a parameter of PPM, denoting the max-imum length of the n -grams considered in the model 5 . The probability P Y ( X ) is estimated by es-cape probabilities favoring the longer sequences ap-pearing in the learning corpus (Bell et al., 1990). The total code length of X is then estimated as  X  log P Y ( X ) . Since this value is additive and gives the total code length of X for language Y , we adopt this value in our approach. By applying the above methods, we propose a solu-tion to formula (1) through dynamic programming. Considering the additive characteristic of the de-scription length formulated previously as formula (1), we denote the minimized description length for a given text X simply as DP ( X ) , which can be de-composed recursively as follows 6 :
DP ( X ) = min
In other words, the computation of DP ( X ) is de-composed into obtaining the addition of two terms by searching through t  X  { 0 , . . . , | X |} and L  X  L . The first term gives the MDL for the first t characters of text X , while the second term, dl L ( x t +1 . . . x | gives the description length of the remaining charac-ters under the language model for L .

We can straightforwardly implement this recur-sive computation through dynamic programming, by managing a table of size | X | X |L| . To fill a cell of this table, formula (4) suggests referring to t  X |L| cells and calculating the description length of the rest of the text for O( | X | X  t ) cells for each language. Since t ranges up to | X | , the brute-force computa-tional complexity is O( | X | 3  X |L| 2 ) .

The complexity can be greatly reduced, however, when the function dl is additive. First, the de-scription length can be calculated from the previ-ous result, decreasing O( | X |  X  t ) to O(1) (to ob-tain the code length of an additional character). Sec-ond, the referred number of cells t  X |L| is in fact U  X  |L| , with U | X | : for MMS, U can be proven to be O(log | Y | ) , where | Y | is the maximum length among the learning corpora; and for PPM, U corresponds to the maximum length of an n -gram. Third, this factor U  X |L| can be further decreased to U  X  2 , since it suffices to possess the results for the two 7 best languages in computing the first term of (4). Consequently, the complexity decreases to O( U  X | X | X |L| ) .
Table 1: Number of languages for each writing system 5.1 Monolingual Texts (Training / Test Data) In this work, monolingual texts were used both for training the cross-entropy computation and as test data for cross-validation: the training data does not contain any test data at all. Monolingual texts were also used to build multilingual texts, as explained in the following subsection.

Texts were collected from the World Wide Web and consisted of two sets. The first data set con-sisted of texts from the Universal Declaration of Human Rights (UDHR) 8 . We consider UDHR the most suitable text source for our purpose, since the content of every monolingual text in the declaration is unique. Moreover, each text has the tendency to maximally use its own language and avoid vo-cabulary from other languages. Therefore, UDHR-derived results can be considered to provide an em-pirical upper bound on our formulation. The set L consists of 277 languages , and the texts consist of around 10,000 characters on average.
 The second data set was Wikipedia data from Wikipedia Downloads 9 , denoted as  X  X iki X  in the following discussion. We automatically assembled the data through the following steps. First, tags in the Wikipedia texts were removed. Second, short lines were removed since they typically are not sen-tences. Third, the amount of data was set to 10,000 characters for every language, in correspondence with the size of the UDHR texts. Note that there is a limit to the complete cleansing of data. After these steps, the set L contained 222 languages with sufficient data for the experiments.

Many languages adopt writing systems other than the Latin alphabet. The numbers of languages for various representative writing systems are listed in Table 1 for both UDHR and Wiki, while the Ap-pendix at the end of the article lists the actual lan-guages. Note that in this article, a character means a Unicode character throughout, which differs from a character rendered in block form for some writing systems.

To evaluate language identification for monolin-gual texts, as will be reported in  X  6.1, we conducted five-times cross-validation separately for both data sets. We present the results in terms of the average accuracy A L , the ratio of the number of texts with a correctly identified language to |L| . 5.2 Multilingual Texts (Test Data) Multilingual texts were needed only to test the per-formance of the proposed method. In other words, we trained the model only through monolingual data, as mentioned above. This differs from the most similar previous study (Teahan, 2000), which required multilingual learning data.

The multilingual texts were generated artificially, since multilingual texts taken directly from the web have other issues besides segmentation. First, proper nouns in multilingual texts complicate the final judg-ment of language and segment borders. In prac-tical application, therefore, texts for segmentation must be preprocessed by named entity recognition, which is beyond the scope of this work. Second, the sizes of text portions in multilingual web texts dif-fer greatly, which would make it difficult to evaluate the overall performance of the proposed method in a uniform manner.

Consequently, we artificially generated two kinds of test sets from a monolingual corpus. The first is a set of multilingual texts, denoted as Test 1 , such that each text is the conjunction of two portions in different languages. Here, the experiment is focused on segment border detection, which must segment the text into two parts, provided that there are two languages. Test 1 includes test data for all language pairs, obtained by five-times cross-validation, giving 25  X |L| X  ( |L| X  1) multilingual texts. Each portion of text for a single language consists of 100 char-acters taken from a random location within the test data.

The second kind of test set is a set of multilingual texts, denoted as Test 2 , each consisting of k seg-ments in different languages. For the experiment, k is not given to the procedure, and the task is to ob-tain k as well as B and L through recursion. Test 2 was generated through the following steps: 1. Choose k from among 1,. . . ,5. 2. Choose k languages randomly from L , where 3. Perform five-times cross-validation on the texts 4. Shuffle the k languages and concatenate the For this Test 2 data set, every plot in the graphs shown in  X  6.2 was obtained by randomly averaging 1,000 tests.

By default, the possibility of segmentation is con-sidered at every character offset in a text, which provides a lower bound for the proposed method. Although language change within the middle of a word does occur in real multilingual documents, it might seem more realistic to consider language change at word borders. Therefore, in addition to choosing B from { 1 , . . . , | X |} , we also tested our approach under the constraint of choosing borders from bordering locations , which are the locations of spaces. In this case, B is chosen from this subset of { 1 , . . . , | X |} , and, in step 3 above, text portions are generated so as to end at these bordering locations. Given a multilingual text, we evaluate the outputs B and L through the following scores: P P P s and R s are obtained by changing the param-eter  X  given in formula (3), which ranges over 1,2,4,.. . ,256 bits. In addition, we verify the speed, i.e., the average time required for processing a text.
Although there are web pages consisting of texts in more than 2 languages, we rarely see a web page containing 5 languages at the same time. There-fore, Test 1 reflects the most important case of 2 lan-guages only, whereas Test 2 reflects the case of mul-tiple languages to demonstrate the general potential of the proposed approach.

The experiment reported here might seem like a case of over-specification, since all languages are considered equally likely to appear. Since our mo-tivation has been to eliminate a portion in a major Figure 1: Accuracy of language identification for mono-lingual texts language from the text, there could be a formula-tion specific to the problem. We consider it trivial, however, to specify such a narrow problem within our formulation, and it will lead to higher perfor-mance than that of the reported results, in any case. Therefore, we believe that our general formulation and experiment show the broadest potential of our approach to solving this problem. 6.1 Language Identification Performance We first show the performance of language identifi-cation using formula (2), which is used as the com-ponent of the text segmentation by language. Fig-ure 1 shows the results for language identification of monolingual texts with the UDHR and Wiki test data. The horizontal axis indicates the size of the in-put text in characters, the vertical axis indicates the accuracy A L , and the graph contains four plots 10 for MMS and PPM for each set of data.

Overall, all plots rise quickly despite the se-vere conditions of a large number of languages (over 200), a small amount of input data, and a small amount of learning data. The results show that language identification through cross-entropy is promising.

Two further global tendencies can be seen. First, the performance was higher for UDHR than for Wiki. This is natural, since the content of Wikipedia is far broader than that of UDHR. In the case of UDHR, when the test data had a length of 40 char-acters, the accuracy was over 95% for both the PPM and the MMS methods. Second, PPM achieved
Figure 2: Cumulative distribution of segment borders slightly better performance than did MMS. When the test data amounted to 100 characters, PPM achieved language identification with accuracy of about 91.4%. For MMS, the identification accu-racy was a little less significant and was about 90.9% even with 100 characters of test data.

The amount of learning data seemed sufficient for both cases, with around 8,000 characters. In fact, we conducted tests with larger amounts of learning data and found a faster rise with respect to the input length, but the maximum possible accuracy did not show any significant increase.

Errors resulted from either noise or mistakes due to the language family. The Wikipedia test data was noisy, as mentioned in  X  5.1. As for language fam-ily errors, the test data includes many similar lan-guages that are difficult even for humans to correctly judge. For example, Indonesian and Malay, Picard and Walloon, and Norwegian Bokm  X  al and Nynorsk are all pairs representative of such confusion.
Overall, the language identification performance seems sufficient to justify its application to our main problem of text segmentation by language. 6.2 Text Segmentation by Language First, we report the results obtained using the Test 1 data set. Figure 2 shows the cumulative distribution obtained for segment border detection. The horizon-tal axis indicates the relative location by character with respect to the correct border at zero, and the vertical axis indicates the cumulative proportion of texts whose border is detected at that relative point. The figure shows four plots for all combinations of the two data sets and the two methods. Note that segment borders are judged by characters and not by bordering locations, as explained in  X  5.2. (border, lower graph) results, where borders were taken from any character offset
Since the plots rise sharply at the middle of the horizontal axis, the borders were detected at or very near the correct place in many cases.

Next, we examine the results for Test 2 . Fig-ure 3 shows the two precision/recall graphs for lan-guage identification (upper graph) and segment bor-der detection (lower graph), where borders were taken from any character offset. In each graph, the horizontal axis indicates precision and the ver-tical axis indicates recall. The numbers appearing in each figure are the maximum F-score values for each method and data set combination. As can be seen from these numbers, the language identifica-tion performance was high. Since the text portion size was chosen from among the values 40, 80, 120, or 160, the performance is comprehensible from the results shown in  X  6.1. Note also that PPM performed slightly better than did MMS.

For segment border performance (lower graph), however, the results were limited. The main reason for this is that both MMS and PPM tend to detect a border one character earlier than the correct loca-tion, as was seen in Figure 2. At the same time, much of the test data contains unrealistic borders within a word, since the data was generated by con-catenating two text portions with random borders. Therefore, we repeated the experiment with Test 2 under the constraint that a segment border could oc-cur only at a bordering location, as explained in  X  5.2. The results with this constraint were significantly better, as shown in Figure 4. The best result was for UDHR with PPM at 0.94 11 . We could also observe how PPM performed better at detecting borders in this case. In actual application, it would be possible to improve performance by relaxing the procedural conditions, such as by decreasing the number of lan-guage possibilities.

In this experiment for Test 2 , k ranged from 1 to 5, but the performance was not affected by the size of k . When the F-score was examined with respect to k , it remained almost equal to k in all cases. This shows how each recursion of formula (4) works al-most independently, having segmentation and lan-guage identification functions that are both robust. Lastly, we examine the speed of our method. Since |L| is constant throughout the comparison, the time should increase linearly with respect to the input length | X | , with increasing k having no ef-fect. Figure 5 shows the speed for Test 2 processing, with the horizontal axis indicating the input length and the vertical axis indicating the processing time. Here, all character offsets were taken into consid-eration, and the processing was done on a machine with a Xeon5650 2.66-GHz CPU. The results con-firm that the complexity increased linearly with re-spect to the input length. When the text size became as large as several thousand characters, the process-ing time became as long as a second. This time could be significantly decreased by introducing con-straints on the bordering locations and languages. This article has presented a method for segmenting a multilingual text into segments, each in a differ-ent language. This task could serve for preprocess-ing of multilingual texts before applying language-specific analysis to each text. Moreover, the pro-posed method could be used to generate corpora in a variety of languages, since many texts in minor lan-guages tend to contain chunks in a major language.
The segmentation task was modeled as an opti-mization problem of finding the best segment and language sequences to minimize the description length of a given text. An actual procedure for ob-taining an optimal result through dynamic program-ming was proposed. Furthermore, we showed a way to decrease the computational complexity substan-tially, with each of our two methods having linear complexity in the input length.

Various empirical results were shown for lan-guage identification and segmentation. Overall, when segmenting a text with up to five random por-tions of different languages, where each portion con-sisted of 40 to 120 characters, the best F-scores for language identification and segmentation were 0.98 and 0.94, respectively.

For our future work, details of the methods must be worked out. In general, the proposed approach could be further applied to the actual needs of pre-processing and to generating corpora of minor lan-guages. Beatrice Alex, Amit Dubey, and Frank Keller. 2007.
Using foreign inclusion detection to improve parsing performance. In Proceedings of the Joint Conference on Empirical Methods in Natural Language Process-ing and Computational Natural Language Learning , pages 151 X 160.
 Beatrice Alex. 2005. An unsupervised system for iden-tifying english inclusions in german text. In Pro-ceedings of the 43rd Annual Meeting of the Associa-tion for Computational Linguistics, Student Research Workshop , pages 133 X 138.
 T.C. Bell, J.G. Cleary, and I. H. Witten. 1990. Text Com-pression . Prentice Hall.
 Dario Benedetto, Emanuele Caglioti, and Vittorio Loreto. 2002. Language trees and zipping. Physical Review Letters , 88(4).
 Rudi Cilibrasi and Paul Vit  X  anyi. 2005. Clustering by compression. IEEE Transactions on Information The-ory , 51(4):1523 X 1545.
 John G. Cleary and Ian H. Witten. 1984. Data compres-sion using adaptive coding and partial string matching. IEEE Transactions on Communications , 32:396 X 402. Martin Farach, Michiel Noordewier, Serap Savari, Larry
Shepp, Abraham J. Wyner, and Jacob Ziv. 1994. On the entropy of dna: Algorithms and measurements based on memory and rapid convergence. In Proceed-ings of the Sixth Annual ACM-SIAM Symposium on Discrete Algorithms , pages 48 X 57.
 Gregory Grefenstette. 1995. Comparing two language identification schemes. In Proceedings of 3rd Inter-national Conference on Statistical Analysis of Textual Data , pages 263 X 268.
 Marti A. Hearst. 1997. Texttiling: Segmenting text into multi-paragraph subtopic passages. Computational Linguistics , 23(1):33 X 64.
 Patrick Juola. 1997. What can we do with small cor-pora? document categorization via cross-entropy. In
Proceedings of an Interdisciplinary Workshop on Sim-ilarity and Categorization .
 Gen-itiro Kikui. 1996. Identifying the coding system and language of on-line documents on the internet. In Pro-ceedings of 16th International Conference on Compu-tational Linguistics , pages 652 X 657.
 Casanai Kruengkrai, Prapass Srichaivattana, Virach
Sornlertlamvanich, and Hitoshi Isahara. 2005. Lan-guage identification based on string kernels. In Proceedings of the 5th International Symposium on
Communications and Information Technologies , pages 926 X 929.
 Penelope Sibun and Jeffrey C. Reynar. 1996. Language identification: Examining the issues. In Proceedings of 5th Symposium on Document Analysis and Infor-mation Retrieval , pages 125 X 135.
 William J. Teahan and David J. Harper. 2001. Using compression-based language models for text catego-rization. In Proceedings of the Workshop on Language Modeling and Information Retrieval , pages 83 X 88. William John Teahan. 2000. Text classification and seg-mentation using minimum cross-entropy. In RIAO , pages 943 X 961.
 Jacob Ziv and Abraham Lempel. 1977. A universal al-gorithm for sequential data compression. IEEE Trans-actions on Information Theory , 23(3):337 X 343. For UDHR Latin Cyrillic Arabic Other For Wiki Latin Cyrillic Arabic Devanagari Other
