 As the fast development of smart phones, people nowadays have more chances to access their current locations with the he lp of GPS and WiFi localization system. Using their locations, users can preform the keyword k -nearest neighbor ( k NN) search [1,2,3,4], that is, given a set of keywords, finding the top k nearest point-of-interests (POIs), considering both spatial and textual information. Existing works [1,5,6,7] focus mainly on Euclidean d istance; therefore, they can easily use spatial data structures such as R-tree [8] to index the objects and perform search. However, it is quite inconvenient for users to use. For example, in Figure 1, there are seven POIs from n 1 to n 7 and a user entering a query  X  Coffee  X  at location q . n 3 and n 6 are the result candidates. If the user wants top one result, traditional services will return n 3 to the user since the Euclidean distance between q and n 3 is shorter. Nevertheless, in the road network, n 6 is much closer to the user; therefore, the service should give n 6 to the user.

In this paper, we present a fast keyword k NN search system in road networks, called Saturn , in order to give users more convenient services. The main chal-lenge for keyword k NN search in road networks is to achieve high interactive speed when the road networks are complicated. For a city with millions of POIs and complex road networks, users focus more on how to get the results fast and accurately. Existing algorithms [2] use Dijkstra-based [9] algorithms to expand the road networks from the query point. In this way, they can access all the POIs by the distance order and then considering the textual constraints in order to generate the final results. These methods will be greatly limited by the road network X  X  topology. With a complicated city map, those methods are rather ex-pensive as they involve a lot of useless computation on the expansion of road networks. Therefore, they cannot be adapted to the complicated city maps di-rectly. To solve this problem, we introduce an effective grid-based shortest path computation framework to reduce the time cost on the computation of the short-est path. We also develop a novel filter-and-verification framework and effective prune technologies to facilitate the keyword k NN search. As an improvement, we devise a hybrid filtering algorithm based on grid index to further improve the performance. To summarize, we ma ke the following contributions.  X  We design and implement a fast keyword k -nearest neighbor search system  X  We develop a grid-based index structure and a shortest path computation  X  We devise a novel filter-and-verification framework and effective prune tech- X  We have conducted an extensive set of experiments and results show that The rest of this paper is organized as fo llows. Section 2 formulates the keyword k NN search problem and gives a baseline method. We introduce the grid-based filter-and-verification framework in Section 3 and the hybrid filtering improve-ment in Section 4. Experimental resul ts are provided in Section 5. We review the related work in Section 6, and make a conclusion in Section 7. 2.1 Problem Formulation Road Data. Formally, our paper considers a set of node , N = { n 1 ,n 2 , ..., n |N| } , as the nodes that appear in road networks. Each n  X  X  consists a location n.x, n.y where n.x is the x-coordinate and n.y is the y-coordinate of the node. Therefore, a node is denoted by n = n.x, n.y . We also consider a set of way , W = { w are two nodes: the start node n s and the end node n e . There is a weight l , denoting the length of the way. Thus, a way is denoted by w = n s ,n e ; l . The nodes and ways are the basic elements of the road networks. We denote the dist ( n i ,n j ) as the shortest path of two nodes in road networks. POI. Consider a set of POIs , P = { p 1 ,p 2 , ..., p |P| } .Each p  X  X  has a location p.x, p.y , indicating the x and y coordinate of the POI. p also consists a set of keywords , denoting by p.k . Therefore, a POI is denoted by p = p.x, p.y ; p.k . Since all the POIs should be in road networks, we assign the nearest node X  X  location as the POI X  X  location. If there is no such node, we establish one and put the POI in that node. Therefore, a POI p is a special case of node n ,whereeach p has an additional keyword set.
 Query. A query q contains a location q.x,q.y as the user X  X  location, a set of user-input keywords q.k and a number k , which users can specify the top-k results returning. Thus, a query q is denoted by q = q.x,q.y ; q.k ; k . Answer. We first denote the textual constraint by sim ( p i .k, q.k ), where sim is defined as the Jaccard similarity coefficient of the two keyword sets. The answer for keyword k -nearest neighbor search finds all the p i  X  X  such that satisfy the textual constraints.
 Definition 1 ( Keyword k -Nearest Neighbor Search in Road Networks). Consider aroadnetwork R ,asetofPOIs P in that road network, and a query q = q.x,q.y ; q.k ; k . It returns the subset P k q of P with k POIs such that  X  p  X  X  k q and  X  p  X  X  X  X  k q , dist ( p, q )  X  dist ( p ,q ) and also sim ( p.k, q.k ) &gt; X  . For example, in Figure 1, given a  X  =0 . 5 ,k =2andaquery q showing in the figure, the results should be n 6 : X  Costa Coffee  X  X nd n 3 : X  Starbucks Coffee  X . 2.2 Baseline Method To solve any problem related to the shortest path problem, we can immediately come up with the Dijkstra methods, that is, expanding the road networks from the query location. Since users want to find the k -nearest POIs, the Dijkstra expansion can easily solve the problem. When a new node is expanding, for all the POIs at that location, the textual constraints are calculated. If the result is larger than the given  X  , then we put the POI into a priority queue to be the result candidate. If the result is smaller than the given  X  , the POI will not be the final result, we eliminate it. The algorithm will be terminated when the number of POIs in the queue equals to the k requirement. The correctness can be guaranteed because the node that is expanding must be the current shortest to the query location. Therefore, any node that will be expanded later must have a longer distance to the query location than the current node.

For example, in Figure 1, we set the  X  =0 . 5. We first locate the position of q and begin expanding. Since the shortest node to q is n 5 ,wetestif n 5 consists certain POIs that satisfy the similarity constraints. The second node we expand is n 6 and it includes a keyword  X  Coffee  X ; the sim =0 . 5  X   X  ; therefore, it is a candidate. Then, the n 4 , n 7 , n 2 , n 1 and n 3 are expanded in this order. Since n 3 has a sim =0 . 5  X   X  , it is also a candidate.

However, the computation cost for a complicated map with millions nodes, ways and POIs is really expensive. For the worst case, we need to iterate the whole map and compute all the textual constraints and finally generate the results. For metropolitan-scale usage, we need to generate fast search algorithm and indexing structures to prune unnecessary nodes and POIs. To achieve high interactive speed, in this paper, we p ropose a grid-based search method. In this section, we first introduce a filter-and-verification framework to solve the keyword k NN problem and then present our grid-based shortest path computa-tion method, which is the key process in the verification phase of our algorithm. 3.1 Filter-and-Verification Framework To answer the keyword k NN search, we want to prune unnecessary POIs that do not have similar textual information and then generate the final results. To this end, we introduce the filter-and-verification framework.
 Filter. In the filter phase, we prune unnecessary POIs and nodes in road net-works to generate a candidate set, which contains all the POIs that have textual similarity larger than the threshold  X  . This is the textual filter phase. Verification. We then verify the candidates generated by the previous phase by checking their shortest distance to the query location. We find the top-k POI results based on their location. This is the spatial verification phase. 3.2 Search Algorithm Based on the filter-and-verification framework, we present the search algorithm. Indexing Structure. We first build a keyword inverted index on top of the road networks to avoid iterating all the POIs. Formally, we denote the inverted index by I and for a keyword w , its inverted index is I w . For example, in the road networks showing in Figure 1, the keyword  X  Pizza  X  X ppearsin n 4 , n 5 and n ; therefore, the three nodes are in the inverted index. By generating such an index, we can easily acquire all the nodes that have the keyword.
 Generating Candidates. When a query comes, we first access all the keywords in the query and get the inverted index I w from our index. Since a query may contain several keywords, for example,  X  Starbucks Coffee  X , we should merge all the inverted index I w to eliminate the repetitive POIs. After the merging step, we can get a set of POIs, which are the candidates that include the keywords in the query.
 Filtering Candidates. Since we have acquired all the POIs that contain the keywords, we need one more step to filter all the POIs that do not satisfy the textual similarity constraint. For each POI, we calculate the textual similarity value using Equation 1. After the filter phase, we generate a set of POIs that satisfy the constraint and can be the final result.
 Verifying Candidates. For each candidate, we need to verify whether it be-longs to the top-k result set or not. To this end, we need to calculate the shortest distance of each candidate to the query location. We present a grid-based shortest path computation framework in Section 3.3, called Grasp (Gr id-ba sed S hortest P ath). Grasp can calculate the road distance fast and accurately. After com-puting all the distances, we put the results in a min-heap and generate the top-k results to the user.
 POI Pruning Technology. From the definition of road distance R (  X  )and Euclidean distance E (  X  ), we see that road distance is not smaller than the Eu-clidean distance, R (  X  ) &gt; = E (  X  ); therefore, we can use th e Euclidean distance as a bound to prune unnecessary POIs. Since we want to find top-k results, we first sort all the POI candidates generated from filter phase based on their Euclidean distance. During the search, we maintain k POIs in the heap. For the current POI, denoted by p c , that needs to calculate the distance, if the k -th POI, de-noted by p k , in the heap has a shorter road distance than the p c  X  X  Euclidean to the heap. For the POIs after p c , since they have a greater Euclidean distance, they cannot be added to the heap as well. Therefore, the search process can be terminated and the POIs in the heap are the final results that we need.
For example, if the R ( p k ) = 150 and E ( p c ) = 130, then R ( p c ) can be any value not smaller than 130, it has a good chance smaller than 150. So we need to calculate the distance to see if it can be added into the heap. While if E ( p c )= 170, then R ( p c ) must be greater than 150 and cannot be added into the heap. Algorithm 1. Saturn Algorithm
We give the pseudo-code of our Saturn algorithm in Figure 2. Saturn first initiates a set to maintain the POIs that have the same keywords, a list for can-didates that passed the filter phase and a min-heap for the final results (line 1). It then merges the POIs from inverted index (line 1) and filters the candidates using the textual similarity equation (line 1). Then it sorts all the POI candi-dates with the Euclidean distance (line 1). Finally, in the verification phase, if the Euclidean distance is smaller than the k -th POI in the heap, we calculate the actual road distance (line 1) and verify if it can be the result or not (line 1). The algorithm will be terminated when the Euclidean distance is larger as we mentioned before (line 1). 3.3 Grid-Based Shortest Path In this section, we present the Grid-based Shortest Path computation framework. Grid Indexing. For our Grasp algorithm, we use grid-based index structures. We first partition the road network into m  X  n grids, denoted by G m,n .Eachgrid includes a set of nodes, ways between nodes and a set of POIs. In this way, we partition the map into m  X  n small parts to fasten the computation of shortest path. For each G m,n , there are two kinds of nodes:  X  inner node : its all adjacent nodes are in the same grid with it.  X  border node : some adjacent nodes are in other grids.
 After partition, we calculate some additional information for shortest path com-putation. We need to calculate distances of all the border node pairs. In each grid, we also compute the distance of inner node to the border node.
In Figure 3, we can see two grids. There are three border nodes n 1 , n 4 and n 7 in the left grid while two border nodes n 21 and n 24 in the right grid. We need to pre-calculate the distance between all these border nodes and in each grid, the distances of inner nodes to the border nodes, for example, n 5 to n 1 , n 4 , n 7 . Shortest Path. There are two situations in our framework: at least one node is border node or two nodes are all inner nodes. For the first situation, it can be easily accessed if one node or two nodes are the border nodes since we have already indexed the distance.

For the second situation that two nodes are all inner nodes in one grid, we can use a Dijkstra expansion since the nodes number are limited. For example, if we partition the Beijing road network into 50  X  50 grids, each grid will only have no more than a hundred nodes and we can ignore the time cost for such a small map.

The most complicated situation is two nodes are all inner nodes but in different grids. We use dynamic programming with a three-step-jump method to calculate. We can easily see that first we should jump from one inner node to its border and then jump from a border node to the other border node in the different grid. The third jump is from the border node to the other inner node. After each jump, we calculate and save the shortest path from q to the node. Therefore, at the last step, the final result would be the shortest path from q .

From the example showing in Figure 3, both the query and candidate are inner node. It first jumps from q to the border nodes and the distances are saved in each node n 1 , n 4 , n 7 separately. In the second step, it updates the distance to n 21 and n 24 . There are six ways from n 1 , n 4 , n 7 to n 21 , n 24 ,thatis, n 1 n distance in n 21 , n 24 . In the last step, it calculates the distance from n 21 , n 24 to candidate c and updates the final distance of c .

We give the pseudo-code of our Grasp algorithm in Figure 4. Grasp first initiates two lists to save the border nodes in two grids (line 2). It then locates Algorithm 2. Grasp Algorithm the query and candidate in the grids (line 2), putting all the border nodes in each grid (line 2). In the first step (line 2), it updates border distances in grid one from query. In the second step (line 2), it updates border distances of two grids. In the third step (line 2), it updates the distance from border to candidate. The shortest distance from query to candidate will be returned finally (line 2). In this section, we present an improvement of the Saturn algorithm by taking consideration of both textual and spatial information simultaneously in the filter phase and propose a grid prune technology to further improve the performance. 4.1 Hybrid Filtering Algorithm In the filter step of Saturn algorithm, we only consider the textual information to generate the candidate POIs. However, to further improve the performance, we can simultaneously utilize textual and spatial information to prune unnecessary regions and POIs. Since we want to find top-k nearest results, we can filter the candidates from the nearest grid to the further ones.
 Grid Distance. We first give the definition of grid distance. For two grids, g i and g j , for all the road distance from node in g i to node in g j , the shortest one is the grid distance g ij .dis . We add the grid distance information to our indexing structure in order to prune unnecessary grids during the filter phase. Algorithm 3. Improved Saturn Algorithm Sorting Grids. The algorithm first locates the query in the grid g q .Itthen sorts all the grids in the map based on their grid distance to g q .Wefilterthegrids by this list in order to utilize the spatial information. The grids near the query can be filtered first; therefore, we can eliminate extra computation of POIs. Filtering Keywords. Addition to the previous information, for each grid, we need to maintain an inverted index of key words that appear in this grid. There-fore, when a query comes, we can filter a grid by textual information. If the grid does not contain the keywords in t he query, we can immediately eliminate the grid and filter the other grids. If the grid consists the keywords, we access the POIs in the grid and use the textual similarity function to further filter the POIs, generating results for the next phase.
 Verifying Candidates. For all the candidates in a certain grid, we verify if the results are the top-k POIs. We use Grasp to calculate the real road distance of each pair. Here, the Saturn POI pruning technology is still working that we use the Euclidean distance as a boundary to prune unnecessary POIs. After verifying all the candidates in a certain grid, the algorithm moves to the next grid and continue the filter-and-verification process.
 Grid Pruning Technologies. Similar as the POI pruning technology in Sat-urn , we also have a grid pruning technology to terminate the algorithm. For the next grid g x that need to be filtered, if the grid distance from g x to g q is greater than the k -th POI X  X  distance to q in the heap, we can stop the algorithm because any distance in g x to g q will be greater than k -th POI X  X  distance. There is no need to compare the following grids at all.

We give the pseudo-code of our the improved Saturn algorithm in Figure 5. It first initiates a list to save the ordering grids and a heap for final results (line 3). It then locates the query in the grids (line 3) and sorts the grids by the grid distance to the query grid (line 3). For each grid, it uses grid filter to determine whether the algorithm can be terminated or not (line 3). For each POI in the grid, it utilizes both spatial and textual information to filter (line 3). Finally, it puts the POIs that passed the verification step into the heap and returns the results to the user (line 3). We have implemented the Saturn system and conducted a set of experiments on real data sets. We used the data of real cities. Table 1 shows the detailed information of the data sets.
 Saturn Performance Evaluation. We compared our Saturn algorithm with the commonly used Dijkstra expansion algorithm [2] in three data sets to eval-uate the search efficiency. We randomly generate 10,000 queries from the POI database, using the keywords as input query keywords, the location of POI as the query location. Figure 6 shows the results.

We see that the results of Saturn are approximately 100 times better than expansion algorithms. The reason is that during the search process, Saturn saves quite a lot of time on the calculation of the shortest path. The Dijkstra methods spend more time on access use less nodes and POIs when they expand the map. For Saturn , it needs only to access those candidate POIs that have passed the textual similarity constraints. The improved algorithm is about 10 times better than Saturn . This is because during the search, it can first prune useless grids with quite a large number of POIs.

For the increasing value of k , the search time increases with it. The Dijkstra methods increase greatly because the search depends on the expansion and the more POIs it returns, the larger the map it expands. For our Saturn and im-proved method, the time increases little since we depend less on the topology of the road networks.
 Parameter Evaluation. We first evaluate the effects of keywords number to Saturn and the improved algorithm. We set the number of keywords from one to ten, returning top-20 results and we set  X  =0 . 5. Figure 7(a) shows the results. We see that Saturn increases with the keywords because the number of candidates increases and we need to calculate more textual similarity before we find the top-k . However, for the improved algorithm, it combines the spatial information at the filter step; therefore, the number of keywords affects it less.
We then evaluate the effects of the value  X  , which is the threshold in the calculation of the textual similarity. We set the value of  X  from 0.1 to 0.9 and k = 20. The results are shown in Figure 7(b). We can see that when  X  increases, the number of textual candida tes decreases; therefore, Saturn will perform better. However, the number of results will also decrease since the constraint is much tighter. It is possible that the number of POIs returning will be less than 20. Therefore, we should carefully choose the value of  X  in the real system to balance the trade-off of time cost and results. For the improved algorithm, the tighter constraint also makes it calculate less POIs so the time declines slightly. Grid Granularity Evaluation. We evaluate the effects of different grid gran-ularity. We set the number of grids from 100 to 2500 in a city thus the length of grid is from 10 kilometers to 2 kilomete rs. Figure 7(c) shows the results. We see that the more grids we partition the road networks, the less search time will be. For Saturn , the time for calculating the distance will decrease in a single grid since the number of nodes are less. For the improved algorithm, it can prune more useless grids and find the candidates fast. However, for a road network with more grids, the index size will also increase because there will be more border nodes. For Beijing, 2500 grids index will use 940M additional space. Most existing works [1,5,6,7] consider Eu clidean distance; th erefore, they use R-tree [8] to index the spatial objects and use branch-and-bound method to search for the results. Based on the R-tree indexes, k -nearest neighbor [10,11,12,13] queries have been well studied in tradit ional databases. They use a heap to maintain the objects and expand the obj ect with a mini-distance. However, in the real world usage, we need to consider the road network topology to ful-fill the users X  requirement. [1 4] formalizes the problem of k NN search in road networks and presents a system prototype for such queries. [2] uses algorithm based on Dijkstra X  X  algorithm to perform k NN search. Thus when expanding the road, the computation cost is expensive. Papadias et al. [15,16,17] describe a framework that integrates network and Euclidean information in order to answer different spatial queries. The main disadvantage of this approach is a dramatic degradation in performance when the nodes that need to retrieve are great. [18] systematically studies the problem of network distance computation, which is the most fundamental problem in road network. Shahabi et al. [3] propose an em-bedding technique to transform a road network into a higher dimensional space. The main disadvantage is that it provides only an approximation of the actual distance. In [19,20], they use pre-computed nearest neighbors as index; however, they cannot incrementally retrieve the results. [4] uses the Voronoi-based ap-proach, which tries to partition a large network into smaller Voronoi regions. The method will get computationally more expensive for increasing values of k. In this paper, we present and implement a fast keyword k -nearest neighbor search system in road networks, called Saturn . In order to reduce the com-putation cost of the shortest path, we devise an effective grid-based shortest path ( Grasp ) computation framework. We also develop a filter-and-verification framework and effective POI prune technologies to facilitate the keyword k NN search. To further improve the performance, we devise a hybrid filtering al-gorithm based on grid indexes to simultaneously use the textual and spatial information to prune unnecessary grids. The results from experiments show that our system has the capability of dealing with massive data and has a better performance than the existing state-of-the-art systems.

