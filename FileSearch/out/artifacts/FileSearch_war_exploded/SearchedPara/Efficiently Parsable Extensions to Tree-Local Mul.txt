 Tree-Adjoining Grammar (TAG) has long been pop-ular for natural language applications because of its ability to naturally capture syntactic relationships while also remaining efficient to process. More re-cent applications of TAG to the domain of seman-tics as well as new attention to syntactic phenomena such as scrambling have given rise to increased in-terested in multicomponent TAG formalisms (MC-TAG), which extend the flexibility, and in some cases generative capacity of the formalism but also have substantial costs in terms of efficient process-ing. Much work in TAG semantics makes use of tree-local MCTAG (TL-MCTAG) to model phenom-ena such as quantifier scoping, Wh-question forma-tion, and many other constructions (Kallmeyer and Romero, 2004; Romero et al., 2004). Certain ap-plications, however, appear to require even more flexibility than is provided by TL-MCTAG. Scram-bling is one well-known example (Rambow, 1994). In addition, in the semantics domain, the use of a new TAG operation, flexible composition, is used to perform certain semantic operations that seemingly cannot be modeled with TL-MCTAG alone (Chiang and Scheffler, 2008) and in work in synchronous TAG semantics, constructions such as nested quanti-fiers require a set-local MCTAG (SL-MCTAG) anal-ysis (Nesson and Shieber, 2006).

In this paper we suggest a shift in focus from constraining locality and complexity through restric-tions that all trees in a tree set must adjoin within a single tree or tree set to constraining locality and complexity through restrictions on the derivational distance between trees in the same tree set in a valid derivation. We examine three formalisms, two of them introduced in this work for the first time, that use derivational distance to constrain locality and demonstrate by construction of parsers their re-lationship to TL-MCTAG in both expressivity and complexity. In Section 2 we give a very brief in-troduction to TAG. In Section 3 we elaborate fur-ther the distinction between these two types of lo-cality restrictions using TAG derivation trees. Sec-tion 4 briefly addresses the simultaneity requirement present in MCTAG formalisms but not in Vector-
X a
X TAG formalisms and argues for dropping the re-quirement. In Sections 5 and 6 we introduce two novel formalisms, restricted non-simultaneous MC-TAG and restricted Vector-TAG, respectively, and define CKY-style parsers for them. In Section 7 we recall the delayed TL-MCTAG formalism intro-duced by Chiang and Scheffler (2008) and define a CKY-style parser for it as well. In Section 8 we explore the complexity of all three parsers and the relationship between the formalisms. In Section 9 we discuss the linguistic applications of these for-malisms and show that they permit analyses of some of the hard cases that have led researchers to look beyond TL-MCTAG. A tree-adjoining grammar consists of a set of el-ementary tree structures of arbitrary depth, which are combined by operations of adjunction and sub-stitution . Auxiliary trees are elementary trees in which the root and a frontier node, called the foot node and distinguished by the diacritic  X  , are labeled with the same nonterminal A . The adjunction opera-tion entails splicing an auxiliary tree in at an internal node in an elementary tree also labeled with nonter-minal A . Trees without a foot node, which serve as a base for derivations and may combine with other trees by substitution, are called initial trees . Exam-ples of the adjunction and substitution operations are given in Figure 1. For further background, refer to the survey by (Joshi and Schabes, 1997).

Shieber et al. (1995) and Vijay-Shanker (1987) apply the Cocke-Kasami-Younger (CKY) algorithm first introduced for use with context-free grammars in Chomsky normal form (Kasami, 1965; Younger, 1967) to the TAG parsing problem to generate parsers with a time complexity of O ( n 6 | G | 2 ) . In order to clarify the presentation of our extended TL-MCTAG parsers below, we briefly review the algo-rithm of Shieber et al. (1995) using the inference rule notation from that paper. As shown in Figure 2, items in CKY-style TAG parsing consist of a node in an elementary tree and the indices that mark the edges of the span dominated by that node. Nodes, mation: the identifier  X  of the elementary tree the node is in, the Gorn address a of the node in that tree 1 , and a diacritic,  X  , indicating that an adjunc-tion or substitution is still available at that node or  X  indicating that one has already taken place.

Each item has four indices, indicating the left and right edges of the span covered by the node as well as any gap in the node that may be the result of a foot node dominated by the node. Nodes that do not dominate a foot node will have no gap in them, which we indicate by the use of underscores in place of the indices for the gap. To limit the number of in-ference rules needed, we define the following func-tion i  X  j for combining indices:
The side conditions Init (  X  ) and Aux (  X  ) hold if  X  is an initial tree or an auxiliary tree, respectively. Label (  X  @ a ) specifies the label of the node in tree  X  at address a . Ft (  X  ) specifies the address of the foot node of tree  X  . Adj (  X  @ a, X  ) holds if tree  X  may adjoin into tree  X  at address a . Subst (  X  @ a, X  ) holds if tree  X  may substitute into tree  X  at address a . These conditions fail if the adjunction or substitu-tion is prevented by constraints such as mismatched node labels.
 Multi-component TAG (MCTAG) generalizes TAG by allowing the elementary items to be sets of trees rather than single trees (Joshi and Schabes, 1997). The basic operations are the same but all trees in a set must adjoin (or substitute) into another tree or tree set in a single step in the derivation.
An MCTAG is tree-local if tree sets are required to adjoin within a single elementary tree (Weir, , , ,n  X  Init (  X  ) 1 , , ,i  X  Label (  X  @ a ) = w i ,p,p,q,q  X  Aux (  X  ) ,i,j,k,l  X   X  @( a  X  2) undefined @( a  X  2)  X  ,l,j 0 ,k 0 ,m  X  ,k  X  k 0 ,m  X  @ a  X  ,p,j,k,q  X  Adj (  X  @ a, X  ) 1988). Although tree-local MCTAG (TL-MCTAG) has the same generative capacity as TAG (Weir, 1988), the conversion to TAG is exponential and the TL-MCTAG formalism is NP-hard to recognize (S X gaard et al., 2007). An MCTAG is set-local if tree sets required to adjoin within a single ele-mentary tree set (Weir, 1988). Set-local MCTAG (SL-MCTAG) has equivalent expressivity to linear context-free rewriting systems and recognition is provably PSPACE complete (Nesson et al., 2008). The domains of locality of TL-MCTAG and SL-MCTAG (and trivially, TAG) can be thought of as lexically defined. That is, all locations at which the adjunction of one tree set into another may occur must be present within a single lexical item. How-ever, we can also think of locality derivationally. In a derivationally local system the constraint is on the relationships allowed between members of the same tree set in the derivation tree.

TAG derivation trees provide the information about how the elementary structures of the grammar combine that is necessary to construct the derived tree. Nodes in a TAG derivation tree are labeled with identifiers of elementary structures. One elementary structure is the child of another in the derivation tree if it adjoins or substitutes into it in the derivation. Arcs in the derivation tree are labeled with the ad-dress in the target elementary structure at which the operation takes place.

In MCTAG the derivation trees are often drawn with identifiers of entire tree sets as the nodes of the tree because the lexical locality constraints re-quire that each elementary tree set be the deriva-tional child of only one other tree set. However, if we elaborate the derivation tree to include a node for each tree in the grammar rather than only for each tree set we can see a stark contrast in the derivational 1: 2: 3: locality of these two formalisms. In TL-MCTAG all trees in a set must adjoin to the same tree. This means that they must all be siblings in the derivation tree. In SL-MCTAG, on the other hand, it is possi-ble to generate derivations with arbitrarily long dis-tances before the nearest common ancestor of two trees from the same elementary tree set is reached. An example SL-MCTAG grammar that can produce an arbitrarily long derivational distance to the near-est common ancestor of the trees in a given tree set is given in Figure 3.

Chiang and Scheffler (2008) recently introduced one variant of MCTAG, delayed Tree-Local MC-TAG (delayed TL-MCTAG) that uses a derivational notion of locality. In this paper we introduce two ad-ditional derivationally local TAG-based formalisms, restricted non-simultaneous MCTAG (restricted NS-MCTAG) and restricted Vector TAG (restricted V-TAG) and demonstrate by construction of parsers how each gives rise to a hierarchy of derivation-ally local formalisms with a well-defined efficiency penalty for each step of derivational distance permit-ted. In addition to lexical locality constraints the defini-tion of MCTAG requires that all trees from a set ad-join simultaneously. In terms of well-formed deriva-tion trees, this amounts to disallowing derivations in which a tree from a given set is the ancestor of a tree from the same tree set. For most linguistic applications of TAG, this requirement seems natu-ral and is strictly obeyed. There are a few appli-cations, including flexible composition and scram-bling in free-word order languages that benefit from TAG-based grammars that drop the simultaneity re-quirement (Chiang and Scheffler, 2008; Rambow, 1994). From a complexity perspective, however, checking the simultaneity requirement is expensive (Kallmeyer, 2007). As a result, it can be advan-tageous to select a base formalism that does not require simultaneity even if the grammars imple-mented with it do not make use of that additional freedom. The simplest version of a derivationally local TAG-based formalism is most similar to non-local MC-TAG. There is no lexical locality requirement at all. In addition, we drop the simultaneity requirement. Thus the only constraint on elementary tree sets is the limit, d , on the derivational distance between the trees in a given set and their nearest common ancestor. We call this formalism restricted non-simultaneous MCTAG. Note that if we constrain d to be one, this happens to enforce both the derivational delay limit and the lexical locality requirement of TL-MCTAG.

A CKY-style parser for restricted NS-MCTAG with a restriction of d is given in Figure 4. The items of this parser contain d lists,  X  1 ,...,  X  d , called his-tories that record the identities of the trees that have already adjoined in the derivation in order to enforce the locality constraints. The identities of the trees in a tree set that have adjoined in a given derivation are maintained in the histories until all the trees from that set have adjoined. Once the locality constraint is checked for a tree set, the Filter side condition expunges those trees from the histories. A tree is recorded in this history list with superscript i , where i is the derivational distance between the location where the recorded tree adjoined and the location of the current item. The locality constraint is enforced at the point of adjunction or substitution where the
Goal Item Init (  X  1 )
Terminal Axiom
Empty Axiom
Foot Axiom
Unary Complete  X   X  x @( a  X  2) undefined  X 
Adjoin: Adj (  X  x @ a, X  y )
Substitute: ,  X  X  Subst (  X  x @ a, X  y )  X  Filter ( {  X  y } ,  X  1 1 ,...,  X  d  X  1 1 )
No Adjoin:  X   X  history at the limit of the permissible delay must be empty for the operation to succeed. A Vector-TAG (V-TAG) (Rambow, 1994) is similar to an MCTAG in that the elementary structures are sets (or vectors) of TAG trees. A derivation in a V-TAG is defined as in TAG. There is no locality re-quirement or other restriction on adjunction except that if one tree from a vector is used in a derivation, all trees from that vector must be used in the deriva-tion. The trees in a vector may be connected by dominance links between the foot nodes of auxiliary trees and any node in other trees in the vector. All adjunctions must respect the dominance relations in that a node  X  1 that dominates a node  X  2 must appear on the path from  X  2 to the root of the derived tree. The definition of V-TAG is very similar to that of non-local MCTAG as defined by Weir (1988) except that in non-local MCTAG all trees from a tree set are required to adjoin simultaneously.

Restricted V-TAG constrains V-TAG in several ways. First, the dominance chain in each elementary tree vector is required to define a total order over the trees in the vector. This means there is a sin-gle base tree in each vector. Note also that all trees other than the base tree must be auxiliary trees in or-der to dominate other trees in the vector. The base tree may be either an initial tree or an auxiliary tree. Second, a restricted V-TAG has a restriction level, d , that determines the largest derivational distance that may exists between the base tree and the high-est tree in a tree vector in a derivation. Restricted V-TAG differs from restricted NS-MCTAG in one important respect: the dominance requirements of restricted V-TAG require that trees from the same set must appear along a single path in the derived tree, whereas in restricted NS-MCTAG trees from the same set need not adhere to any dominance rela-tionship in the derived tree.

A CKY-style parser for restricted V-TAG with re-striction level d is given in Figure 5. Parsing is sim-ilar to delayed TL-MCTAG in that we have a set of histories for each restriction level. However, be-cause of the total order over trees in a vector, the parser only needs to maintain the identity of the highest tree from a vector that has been used in the derivation along with its distance from the base tree from that vector. The Filter side condition accord-ingly expunges trees that are the top tree in the dom-inance chain of their tree vector. The side conditions for the Adjoin non-base rule enforce that the domi-nance constraints are satisfied and that the deriva-tional distance from the base of a tree vector to its currently highest adjoined tree is maintained accu-rately. We note that in order to allow a non-total or-dering of the trees in a vector we would simply have to record all trees in a tree vector in the histories as is done in the delayed TL-MCTAG parser. Chiang and Scheffler (2008) introduce the de-layed TL-MCTAG formalism which makes use of a derivational distance restriction in a somewhat dif-ferent way. Rather than restricting the absolute dis-tance between the trees of a set and their nearest common ancestor, given a node  X  in a derivation tree, delayed TL-MCTAG restricts the number of tree sets that are not fully dominated by  X  . Bor-rowing directly from Chiang and Scheffler (2008), Figure 7 gives two examples.

Parsing for delayed TL-MCTAG is not discussed by Chiang and Scheffler (2008) but can be accom-plished using a similar CKY-style strategy as in the two parsers above. We present a parser in Fig-ure 6. Rather than keeping histories that record derivational distance, we keep an active delay list for each item that records the delays that are active (by recording the identities of the trees that have ad-joined) for the tree of which the current node is a part. At the root of each tree the active delay list is filtered using the Filter side condition to remove all tree sets that are fully dominated and the resulting list is checked using the Size to ensure that it con-tains no more than d distinct tree sets where d is the specified delay for the grammar. The active delays for a given tree are passed to its derivational parent when it adjoins or substitutes.

Delayed TL-MCTAG differs from both of the pre-vious formalisms in that it places no constraint on the length of a delay. On the other hand while the previous formalisms allow unlimited short de-lays to be pending at the same time, in delayed TL-MCTAG, only a restricted number of delays may be active at once. Similar to restricted V-TAG, there is no simultaneity requirement, so a tree may have another tree from the same set as an ancestor. The complexity of the restricted NS-MCTAG and restricted V-TAG parsers presented above depends on the number of possible histories that may appear in an item. For each step of derivational distance permitted between trees of the same set, the corre-sponding history permits many more entries. His-tory  X  1 may contain trees that have adjoined into the same tree as the node of the current item. The number of entries is therefore limited by the num-ber of adjunction sites in that tree, which is in turn limited by the number of nodes in that tree. We will call the maximum number of nodes in a tree in the grammar t . Theoretically, any tree in the grammar could adjoin at any of these adjunction sites, mean-ing that the number of possible values for each entry in the history is bounded by the size of the grammar
Unary Complete  X   X  x @( a  X  2) undefined  X 
Binary Complete ,k 0 ,m,  X  1 2 ,...,  X  d 2  X 
Adjoin base: Adj (  X  x @ a, X  1 )
Adjoin non-base:  X 
Substitute: ,  X  X  Subst (  X  x @ a, X  1 )  X  Filter ( {  X  1 } ,  X  1 1 ,...,  X  d  X  1 1 )
No Adjoin:  X   X  tries correspond to tree that have adjoined into a tree that has adjoined into the tree of the current item. Thus, for each of the t trees that may have adjoined at a derivational distance of one, there are t more trees that may have adjoined at a derivational dis-tance of two. The size of  X  2 is therefore | G | t 2 . The combined size of the histories for a grammar with a delay or restriction of d is therefore O ( | G | Replacing the sum with its closed form solution, we
Using the reasoning about the size of the histories given above, the restricted NS-MCTAG parser pre-sented here has a complexity of O ( n 6 | G | 1+ t d +1  X  1 where t is as defined above and d is the limit on de-lay of adjunction. For a tree-local MCTAG, the com-tic applications that motivate this chapter no delay greater than two is needed, resulting in a complexity of
The same complexity analysis applies for re-stricted V-TAG. However, we can provide a some-what tighter bound by noting that the rank , r , of the grammar X  X ow many tree sets adjoin in a sin-gle tree X  X nd the fan out , f of the grammar X  X ow many trees may be in a single tree set X  X re limited by t . That is, a complete derivation containing |D| tree sets can contain no more than t |D| individual trees and also no more than rf |D| individual trees. In the restricted V-TAG algorithm we maintain only one tree from a tree set in the history at a time, so rather than maintaining O ( t ) entries in each history, we only need to maintain the smaller O ( r ) entries.
The complexity of the delayed TL-MCTAG parser depends on the number of possible active de-lay lists. As above, each delay list may have a maxi-mum of t entries for trees that adjoin directly into it. The restriction on the number of active delays means that the active delay lists passed up from these child nodes at the point of adjunction or substitution can have size no more than d . This results in an addi-tional td ( f  X  1) possible entries in the active de-
Goal Item: Init (  X  1 )
Terminal Axiom } X  Label (  X  x @ a ) = w i
Empty Axiom } X  Label (  X  x @ a ) =  X 
Foot Axiom x } X  Aux
Unary Complete
 X   X   X  x @( a  X  2) undefined
Binary Complete ,l,j 0 ,k 0 ,m,  X  2  X   X   X  2  X 
Adjoin:
 X   X  Filter ( X   X  ,  X  0  X  )
Substitute: } X  Filter ( X   X  ,  X  0  X  )
No Adjoin: lay list, giving a total number of active delay lists Each of the formalisms presented above extends the flexibility of MCTAG beyond that of TL-MCTAG while maintaining, as we have shown herein, com-plexity much less than that of SL-MCTAG. All three formalisms permit modeling of flexible composi-tion (because they permit one member of a tree set to be a derivational ancestor of another tree in the same set), at least restricted NS-MCTAG and re-stricted V-TAG permit analyses of scrambling, and all three permit analyses of the various challeng-ing semantic constructions mentioned in the intro-duction. We conclude that extending locality by constraining derivational distance may be an effec-tive way to add flexibility to MCTAG without losing computational tractability.
 This material is based upon work supported by the National Science Foundation under Grant No. BCS-0827979.

