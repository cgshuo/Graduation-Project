 In statistical machine translation (SMT), the search problem is NP-hard if arbitrary reordering is allowed (Knight, 1999). Therefore, we need to restrict the possible reordering in an appropriate way for both efficiency and translation quality. The most widely used reordering constraints are IBM constraints (Berger et al., 1996), ITG con-straints (Wu, 1995) and syntactic constraints (Yamada et al., 2000; Galley et al., 2004; Liu et al., 2006; Marcu et al., 2006; Zollmann and Venugopal 2006; and numerous others). Syntac-tic constraints can be imposed from the source side or target side. This work will focus on syn-tactic constraints from source parse trees. 
Linguistic parse trees can provide very useful reordering constraints for SMT. However, they are far from perfect because of both parsing er-rors and the crossing of the constituents and for-mal phrases extracted from parallel training data. The key challenge is how to take advantage of the prior knowledge in the linguistic parse trees without affecting the strengths of formal phrases. Recent efforts attack this problem by using the constraints softly (Cherry, 2008; Marton and Resnik, 2008). In their methods, a candidate translation gets an extra credit if it respects the parse tree but may incur a cost if it violates a constituent boundary. 
In this paper, we address this challenge from a less explored direction. Rather than use all con-straints offered by the parse trees, we propose using them selectively. Based on parallel training data, a classifier is built automatically to decide whether a node in the parse trees should be used as a reordering constraint or not. As a result, we obtain a 0.8 BLEU point improvement over a full constraint-based system. In this section we briefly review a constraint-based system named IST-ITG (Imposing Source Tree on Inversion Transduction Grammar, Ya-mamoto et al., 2008) upon which this work builds. 
When using ITG constraints during decoding, the source-side parse tree structure is not consid-ered. The reordering process can be more tightly constrained if constraints from the source parse tree are integrated with the ITG constraints. IST-ITG constraints directly apply source sentence tree structure to generate the target with the following constraint: the target sentence is ob-tained by rotating any node of the source sen-tence tree structure. 
After parsing the source sentence, a bracketed sentence is obtained by removing the node syntactic labels; this bracketed sentence can then be directly expressed as a tree structure. For example 1 , the parse tree  X (S1 (S (NP (DT This)) (VP (AUX is) (NP (DT a) (NN pen))))) X  is obtained from the source sentence  X  X his is a pen X , which consists of four words. By removing the node syntactic labels, the bracketed sentence  X ((This) ((is) ((a) (pen)))) X  is obtained. Such a bracketed sentence can be used to produce constraints. 
For example, for the source-side bracketed tree  X ((f1 f2) (f3 f4))  X , eight target sequences [e1, e2, e3, e4], [e2, e1, e3, e4 ], [e1, e2, e4, e3], [e2, e1, e4, e3], [e3, e4, e1, e2 ], [e3, e4, e2, e1], [e4, e3, e1, e2], and [e4, e3, e2, e1] are possible. For the source-side bracketed tree  X (((f1f2) f3) f4), X  eight sequences [e1, e2, e3, e4], [e2, e1, e3, e4], [e3, e1, e2, e4], [e3, e2, e1, e4], [e4, e1, e2, e3], e1] are possible. When the source sentence tree structure is a binary tree, the number of word orderings is reduced to 2 N-1 where N is the length of the source sentence. 
The parsing results sometimes do not produce binary trees. In this case, some subtrees have more than two child nodes. For a non-binary sub-tree, any reordering of child nodes is allowed. For example, if a subtree has three child nodes, six reorderings of the nodes are possible. In IST-ITG and many other methods which use syntactic constraints, all of the nodes in the parse trees are utilized. Though many nodes in the parse trees are useful, we would argue that some nodes are not trustworthy. For example, if we constrain the translation of  X  X 1 f2 f3 f4 X  with node N2 illustrated in Figure 1, then word  X  X 1 X  will never be put in the middle the other three words. If we want to obtain the translation  X  X 2 e1 e4 e3 X , node N3 can offer a good constraint while node N2 should be filtered out. In real cor-pora, cases such as node N2 are frequent enough to be noticeable (see Fox (2002) or section 4.1 in this paper). 
Therefore, we use the definitions in Galley et al. (2004) to classify the nodes in parse trees into two types: frontier nodes and interior nodes. Though the definitions were originally made for target language parse trees, they can be straight-forwardly applied to the source side. A node which satisfies both of the following two condi-tions is referred as a frontier node:  X  All the words covered by the node can be  X  All the words covered by the node remain Otherwise the node is an interior node. 
For example, in Figure 1, both node N1 and node N3 are frontier nodes. Node N2 is an inte-rior node because the source words f2, f3 and f4 are translated into e2, e3 and e4, which are not contiguous in the target side. 
Clearly, only frontier nodes should be used as reordering constraints while interior nodes are not suitable for this. However, little work has been done on how to explicitly distinguish these two kinds of nodes in the source parse trees. In this section, we will explore building a classifier which can label the nodes in the parse trees as frontier nodes or interior nodes. 3.1 Training Ideally, we would have a human-annotated cor-pus in which each sentence is parsed and each node in the parse trees is labeled as a frontier node or an interior node. But such a target lan-guage specific corpus is hard to come by, and never in the quantity we would like. 
Instead, we generate such a corpus automati-cally. We begin with a parallel corpus which will be used to train our SMT model. In our case, it is the FBIS Chinese-English corpus. Firstly, the Chinese sentences are segmented, POS tagged and parsed by the tools described in Kruengkrai et al. (2009) and Cao et al. (2007), both of which are trained on the Penn Chinese Treebank 6.0. 
Secondly, we use GIZA++ to align the sen-tences in both the Chinese-English and English-Chinese directions. We combine the alignments using the  X  X row-diag-final-and X  procedure pro-vided with MOSES (Koehn, 2007). Because there are many errors in the alignment, we re-move the links if the alignment count is less than three for the source or the target word. Addition-ally, we also remove notoriously bad links in {de, le}  X  {the, a, an} following Fossum and Knight (2008). 
Thirdly, given the parse trees and the align-ment information, we label each node as a fron-tier node or an interior node according to the definition introduced in this section. Using the labeled nodes as training data, we can build a classifier. In theory, a broad class of machine learning tools can be used; however, due to the scale of the task (see section 4), we utilize the Pegasos 2 which is a very fast SVM solver (Shalev-Shwartz et al, 2007). 3.2 Features For each node in the parse trees, we use the fol-lowing feature templates:  X  A context-free grammar rule which rewrites  X  A context-free grammar rule which rewrites  X  The combination of the above two rules  X  A lexicalized context-free grammar rule  X  A lexicalized context-free grammar rule  X  Syntactic label, head word, and head POS  X  Syntactic label, head word, and head POS  X  Syntactic label, head word, and head POS  X  Syntactic label, head word, and head POS  X  Syntactic label, head word, and head POS  X  Syntactic label, head word, and head POS  X  The leftmost word covered by the current  X  The rightmost word covered by the current Our SMT system is based on a fairly typical phrase-based model (Finch and Sumita, 2008). For the training of our SMT model, we use a modified training toolkit adapted from the MOSES decoder. Our decoder can operate on the same principles as the MOSES decoder. Mini-mum error rate training (MERT) with respect to BLEU score is used to tune the decoder X  X  pa-rameters, and it is performed using the standard technique of Och (2003). A lexical reordering model was used in our experiments. The translation model was created from the FBIS corpus. We used a 5-gram language model trained with modified Knesser-Ney smoothing. The language model was trained on the target side of FBIS corpus and the Xinhua news in GI-GAWORD corpus. The development and test sets are from NIST MT08 evaluation campaign. Table 1 shows the statistics of the corpora used in our experiments. 4.1 Experiments on Nodes Classification We extracted about 3.9 million example nodes from the training data, i.e. the FBIS corpus. There were 2.37 million frontier nodes and 1.59 million interior nodes in these examples, give rise to about 4.4 million features. To test the per-formance of our classifier, we simply use the last ten thousand examples as a test set, and the rest being used as Pegasos training data. All the pa-rameters in Pegasos were set as default values. In this way, the accuracy of the classifier was 71.59%. 
Then we retrained our classifier by using all of the examples. The nodes in the automatically parsed NIST MT08 test set were labeled by the classifier. As a result, 17,240 nodes were labeled as frontier nodes and 5,736 nodes were labeled as interior nodes. 4.2 Experiments on Chinese-English SMT In order to confirm that it is advantageous to dis-tinguish between frontier nodes and interior nodes, we performed four translation experi-ments. 
The first one was a typical beam search decod-ing without any syntactic constraints. 
All the other three experiments were based on the IST-ITG method which makes use of syntac-tic constraints. The difference between these three experiments lies in what constraints are used. In detail, the second one used all nodes recognized by the parser; the third one only used frontier nodes labeled by the classifier; the fourth one only used interior nodes labeled by the clas-sifier. 
With the exception of the above differences, all the other settings were the same in the four experiments. Table 2 summarizes the SMT per-formance. Table 2: Comparison of different constraints by 
Clearly, we obtain the best performance if we constrain the search with only frontier nodes. Using just frontier yields a 0.8 BLEU point im-provement over the baseline constraint-based system which uses all the constraints. 
On the other hand, constraints from interior nodes result in the worst performance. This com-parison shows it is necessary to explicitly distin-guish nodes in the source parse trees when they are used as reordering constraints. 
The improvement over the system without constraints is only modest. It may be too coarse to use pare trees as hard constraints. We believe a greater improvement can be expected if we ap-ply our idea to finer-grain ed approaches that use constraints softly (Marton and Resnik (2008) and Cherry (2008)). We propose a selectively approach to syntactic constraints during decoding. A classifier is built automatically to decide whether a node in the parse trees should be used as a reordering con-straint or not. Preliminary results show that it is not only advantageous but necessary to explicitly distinguish between frontier nodes and interior nodes. 
The idea of selecting syntactic constraints is compatible with the idea of using constraints softly; we plan to combine the two ideas and ob-tain further improvements in future work. We would like to thank Taro Watanabe and Andrew Finch for insightful discussions. We also would like to thank the anonymous reviewers for their constructive comments. 
