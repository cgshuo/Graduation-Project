 Finding reverse nearest neighbors (RNNs) is an important opera-tion in spatial databases. The problem of evaluating RNN queries has already received considerable attention due to its importance in many real-world applications, such as resource allocation and dis-aster response. While RNN query processing has been extensively studied in Euclidean space, no work ever studies this problem on land surfaces. However, practical applications of RNN queries in-volve terrain surfaces that constrain object movements, which ren-dering the existing algorithms inapplicable.

In this paper, we investigate the evaluation of two types of RNN queries on land surfaces: monochromatic RNN (MRNN) queries and bichromatic RNN (BRNN) queries. On a land surface, the dis-tance between two points is calculated as the length of the short-est path along the surface. However, the computational cost of the state-of-the-art shortest path algorithm on a land surface is quadratic to the size of the surface model, which is usually quite huge. As a result, surface RNN query processing is a challenging problem.
Leveraging some newly-discovered properties of Voronoi cell approximation structures, we make use of standard index structures such as an R-tree to design efficient algorithms that accelerate the evaluation of MRNN and BRNN queries on land surfaces. Our pro-posed algorithms are able to localize query evaluation by accessing just a small fraction of the surface data near the query point, which helps avoid shortest path evaluation on a large surface. Extensive experiments are conducted on large real-world datasets to demon-strate the efficiency of our algorithms.
 H.2.8 [ Database Management ]: Database Applications X  Spatial databases and GIS Reverse nearest neighbor, land surface, terrain
Recent technological advances in remote sensing have made avail-able high resolution terrain data of the entire Earth surface. As a result, many online Earth visualization platforms emerge, such as  X  X oogle Earth TM  X  and  X  X ing Maps for Enterprise X . Other exam-ples involving geo-realistic rendering of surfaces include computer games such as  X  X ounter-Strike X  and  X  X all of Duty X . However, these applications focus mainly on the rendering of land surfaces rather than the processing of spatial queries on them.

Due to the ubiquity of high resolution terrain data, it is becom-ing more and more important to develop geographic information systems (GISs) that support efficient query processing on land sur-faces. Such systems would enable many novel and useful applica-tions in the terrain context.

The shortest path problem has been studied on land surfaces by many works such as [5, 6, 7, 8], and the best-known exact algo-rithm is Chen and Han X  X  algorithm ,whichtakes O ( n 2 ) time on a surface model of size n . Recently, several works [1, 2, 3, 4] begin to study k -nearest neighbor ( k -NN) queries on land surfaces, which is termed surface k -NN (S k NN) queries.

We call a reverse nearest neighbor (RNN) query on land surfaces as a surface RNN (SRNN) query, which, to our knowledge, has not been studied before. There are two popular types of RNN queries in the literature:
SRNN queries have many real world applications. For example, bichromatic SRNN (BSRNN) queries are important in the domain of disaster response: when a disaster (e.g. earthquake/tsunami) hap-pens, the transportation system may stop functioning, and thus res-using the blocked/damaged roads, to save the lives of the suffered. In this case, a victim should be reached by the rescue team near-est to him/her, and therefore, it is important for the rescue teams to keep track of their RNNs among the victims. Other applications of BSRNN queries include supply dis tribution durin g military opera-tions, and wild animal rescue in nature reserves.

Besides BSRNN queries, monochromatic SRNN (MSRNN) queries are also useful in many application domains, such as outdoor activ-ities and military operations. Consid er the activity of mountaineer-ing: in order to keep the mountaineers safe, it is important for each member to keep track of his/her RNNs among all the other moun-taineers, so that if a member encounters an accident such as a land-slide, he/she can get help from his/her nearest neighbor who tracks him/her (e.g. through GPS devices). Similar situations happen in military operations, where a troop would reinforce one of its re-verse nearest neighbor troop if that troop suffers severe casualty.
In this paper, we study RNN queries on land surfaces, includ-ing both MSRNN and BSRNN queries. Unlike traditional RNN queries, the evaluation of SRNN queries is more challenging due to the following two reasons:
As a result, efficient SRNN query evaluation requires that (1) the shortest surface path computation should be avoided whenever pos-sible, by efficient pruning methods; and that (2) only a small frac-tion of the surface data near the query point should be accessed, so that shortest surface path computations are done on a small surface.
To achieve these two goals, we adopt the Voronoi cell [24] ap-proximation structures (i.e. tight/loose cells) to accelerate SRNN query processing. The concepts of tight/loose cells are first pro-posed in [1] for processing S k NN queries. The algorithms of [1] achieve significant pruning power when answering S k NN queries, by using several properties of the relationship between a cell and a query points, which we call the cell-point properties .
However, the cell-point properties along are not sufficient for an-swering SRNN queries. We discover several (non-trivial) proper-ties of the relationship between two cells, termed the cell-cell prop-erties , which is essential in SRNN query processing. Furthermore, our MSRNN algorithm requires the loose cell of the query point, but [1] only gives an offline algorithm that computes the loose cells of all data points together. Therefore, we also study how to effi-ciently compute the loose cell of the query point online.
While [1] designs a cell index dedicated to S k NN query pro-cessing, we find that its algorithm may not return the exact k NNs, due to a flawed cell-cell property it assumes. Therefore, we do not follow that indexing methods, but rather use standard index struc-tures such as R-tree in our algorithms. Extensive experiments on large real-world datasets have demonstrated the efficiency of our algorithms for MSRNN and BSRNN queries.
 The rest of the paper is organized as follows. We formally define MSRNN and BSRNN queries in Section 2. In Section 3, we review the concept of tight/loose cells, as well as the cell-point properties . Our cell indexing method is explained in Section 4, where we also present the algorithm of surface NN query processing using the in-dex. In Section 5, we prove two new cell-cell properties and present our algorithm for NN queries among the data objects (rather than the query point), which is a fundamental operation in our MSRNN algorithm. Our online algorithm for constructing tight/loose cells is introduced in Section 6, and our algorithms for MSRNN and BSRNN queries are described in Section 7. Extensive experiments are conducted in Section 8 on large real-world datasets to verify the efficiency of our algorithms. Finally, we review the related work in Section 9, and conclude the paper in Section 10.
A land surface can be regarded as a continuous function that coordinate value. The TIN model is the most popular model to represent a land surface, which is constructed from the sampled ground positions at regularly spaced in tervals, by Delaunay trian-gulation [24], to form a set of non-overlapping triangles whose network . Figure 1 shows a piece of land surface represented by the TIN model, where the red lines correspond to the edges of the model network .

Before presenting the formal definition of SRNN queries, let us first define some distance metrics between two points on the TIN model, as well as the corresponding notations.

D EFINITION 1. Let p 1 and p 2 be two points on a land surface.
It is obvious that for any two given vertices p 1 and p 2 surface, where the second inequality is because the shortest network path is also a path along the surface. Therefore, the Euclidean distance and the network distance are the lower bound and the upper bound of the surface distance , respectively.
 Now, we are ready to formally define SRNN queries:
D EFINITION 2 (MSRNN). Given a data point set O and a query point q on a land surface, a monochromatic surface reverse nearest neighbor (MSRNN) query finds all the data points o such that  X  o  X  O  X  X  o } ,d S ( o, q )  X  d S ( o, o ) .
D EFINITION 3 (BSRNN). Given a site point set S , a data point set O and a query point q  X  S on a land surface, a bichro-matic surface reverse nearest neighbor (BSRNN) query finds all the data points o  X  O such that  X  s  X  S  X  X  q } ,d S ( o, q ) Voronoi diagram [24] is a powerful tool for processing NN queries. Given a set O of data objects, a Voronoi diagram divides the space into disjoint cells, where each cell belongs to one object. If a query point q falls into the Voronoi cell of object o  X  O ,then o is guar-anteed to be the NN of q among all objects in O .

Many algorithms have been proposed for computing Voronoi di-agrams in 2D Euclidean space, among which the most commonly used one is Fortune X  X  plain-sweep algorithm [24], whose time com-plexity is O ( n log n ) with n = | O | .

However, as pointed out by [1], it is very expensive to construct the exact Voronoi diagram on a land surface. Therefore, [1] pro-poses two approximation structures of Voronoi cells that can be computed without the necessity of shortest surface path evaluation:
D EFINITION 4(T IGHT C ELL ). Given a data point set O on a land surface S , the tight cell of a data object o  X  O , denoted as TC ( o ) , is a polygon area around o , defined by TC ( o )= S | d N ( o, q )  X  d E ( o ,q ) ,  X  o  X  O  X  X  o }} .

D EFINITION 5(L OOSE C ELL ). Given a data point set O on a land surface S , the loose cell of a data object o  X  O , denoted as LC ( o ) , is a polygon area around o , defined by LC ( o )= S | d E ( o, q )  X  d N ( o ,q ) ,  X  o  X  O  X  X  o }} .

Note that we can always assume an object o  X  O to be on a vertex, since otherwise, we can split the face that the object is on as three faces by connecting the three face vertices to o .
We can rewrite the definitions of tight and loose cells in the fol-lowing equivalent forms:
Figure 2 shows the tight and loose cells of 6 objects ( o on a surface, where the blue cells are the tight cells of the objects in them, and the green (purple) cell is the loose cell of o
Next, we review the cell-point properties proposed in [1], which are necessary in both the S k NN and our SRNN query processing.
Summary of cell-point properties. Let us use NN S ( q | O ) to denote the surface nearest neighbor of q among the data objects in O . Note that if q  X  O ,then q = NN S ( q | O ) . Theorem 1 summarizes the cell-point properties that correspond to Properties 1 to 4 in [1], the proof of which can be found therein.

T HEOREM 1. Given a set of objects O = { o 1 ,o 2 ,...,o n a land surface, the following statements hold: 1. If a query point q  X  O is within TC ( o i ) ,then o i 2. If a query point q  X  O is outside LC ( o i ) ,then o i 3. All the edges of the tight cells are also the edges of the loose 4. If o i = NN S ( q | O ) , then the shortest surface path from q
In this section, we first point out a problem with the existing cell index for S k NN query processing [1], which explains why we do not follow that framework for indexing. Instead, we propose to index the loose cells of all data objects by an R-tree, which is used to answer surface NN and SRNN queries. Finally, we present an algorithm of surface NN query processing using the index.
Problem with the existing S k NN algorithm. BasedonState-ment 3 in Theorem 1, [1] defines the neighbors of an object o as NL ( o )= { o  X  O  X  X  o }| TC ( o ) and LC ( o ) have common edges } . For example, in Figure 2, NL ( o 1 )= { o 2 ,o 3
For each data object o  X  O , its neighbor list NL ( o ) is stored with o in the cell index of [1], and used to find the k NNs incre-mentally on the surface. However, the underlying property of that incremental algorithm (Property 6 in [1]) is based on the following statement:
If o i and o j are not neighbors, then LC ( o i )  X  LC ( o thus a point m on the shortest surface path between o j and a point q within LC ( o i ) should exist outside both LC ( o i ) and LC ( o
Nevertheless, this claim is not proved in [1], and in fact, it is not correct. One counterexample is given by Figure 2: although o NL ( o 1 ) ,wehave LC ( o 6 )  X  LC ( o 1 ) =  X  ; moreover, the shortest surface path between o 6 and o 1 is totally within LC ( o
Therefore, the incremental method is not guaranteed to be cor-rect even when k goes from 1 to 2. This result is not surprising since Voronoi cells are dedicated to 1-NN queries.

In order to study how frequently the claim is breached in general, we randomly generate an object set O on a fraction of the Eagle Peak land surface dataset [25], and check how many objects o has its loose cell LC ( o i ) overlapping with that of a non-neighbor object o j  X  NL ( o i ) , by using the following approach.
We bulk-load an R-tree T LC from the loose cells { LC ( o ) O } using the Sort-Tile-Recursive (STR) algorithm [10]. For each object o i  X  O , we find the set of objects C = { o { o i }| LC ( o j )  X  LC ( o i ) =  X  X  by an intersection query on T with query window LC ( o i ) . Then, for each o j  X  C , we check whether LC ( o i )  X  TC ( o j ) =  X  .If o j  X  NL ( o i ) , we know that LC ( o i ) and TC ( o j ) have common edges and thus LC ( o TC ( o j ) =  X  . Otherwise, we find a breach of the claim.
The experimental results are surprising: we find that 70% to 80% of the objects in O breach of the claim (which is very high), and the larger the object set size | O | , the smaller the breach frequency.
Cell index. While the tight/loose cells of the data objects provide great pruning power in surface NN and SRNN query processing, cell construction is time-consuming. As a result, they are usually pre-computed offline, and organized by a spatial index.
We have shown that the neighbor information maintained by the cell index of [1] is no longer useful for correctly answering S k NN queries. Fortunately, only 1-NN queries are necessary in SRNN query processing, and therefore, we do not adopt the index structure of [1], but rather use the R-tree T LC over all the object loose cells as the cell index, which has already been used in breach checking.
The R-tree T LC is sufficient for answering surface NN and SRNN queries. We now present our algorithm for surface NN queries, namely Algorithm 1, which makes use of T LC .

Algorithm for finding NN S ( q | O ) . According to Statements 2 and 4 in Theorem 1, we can use Algorithm 1 to find NN S ( q for a query point q  X  O . Specifically, we first issue a point intersec-tion query on the R-tree T LC to find the objects whose loose cells this implies that  X  o  X  O  X  X  o } ,LC ( o ) does not contain q , and according to Statement 2 in Theorem 1, only o has chance to Algorithm 1 QO-NN ( q , O , T LC ) Input: query point q  X  O ; object set O ; R-tree T LC bulk-loaded from { LC ( o ) | o  X  O } Output: NN S ( q | O ) 1: Find the object set C = { o  X  O | q is within LC ( o ) 2: if | C | =1 then 3: { C = { o } } 4: return o 5: min  X  X  X  ,o min  X  NULL 6: for each o  X  C do 7: Invoke Chen and Han X  X  algorithm to compute d S ( o, q ) on 8: if d S ( o, q ) &lt;min then 9: min  X  d S ( o, q ) 11: return o min q  X  TC ( o ) in this case. Otherwise, we check all the candidates o  X  C and return the one with the smallest shortest surface path length (Lines 5 to 11). Note that we compute d S ( o, q ) on LC ( o ) rather than on the whole surface, and therefore the shortest surface path between q and o found on LC ( o ) may not be the global short-est surface path. However, according to Statement 4 in Theorem 1, we are able to find the shortest surface path to NN S ( q guarantees the correctness of Algorithm 1.
In this section, we study object NN queries: Given an object o O , find its nearest neighbor in O on the surface, i.e. NN { o } ) . As we shall see, an object NN query is a fundamental opera-tion in our MSRNN algorithm in Section 7.

Cell-cell properties. Before describing our algorithm for pro-cessing object NN queries, we first present two underlying cell-cell properties which guarantee the correction of our algorithm.
Theorem 2 prunes all the objects whose loose cells do not inter-sect with LC ( o ) , from being NN S ( o | O  X  X  o } ) .
T HEOREM 2. Any object o  X  O that satisfies LC ( o )  X  LC ( o )=  X  cannot be NN S ( o | O  X  X  o } ) .
P ROOF . Let us illustrate the idea by Figure 3, where o sponds to o in Theorem 2, and o 5 corresponds to o . In Figure 3, the green (purple) cell is LC ( o 2 ) ( LC ( o 5 ) ).

Since LC ( o )  X  LC ( o )=  X  , a point m on the shortest path between o and o (the orange path in Figure 3) should exist outside both LC ( o ) and LC ( o ) .

Since m is outside of LC ( o ) , according to Definition 5, we know that  X  o  X  O  X  X  o } ,d E ( o ,m ) &gt;d N ( o ,m ) .Wenow prove that  X  o  X  O  X  X  o ,o } ,d E ( o ,m ) &gt;d N ( o ,m ) .
We prove by contradiction. If o is the only object in O  X  X  satisfies d E ( o ,m ) &gt;d N ( o, m ) ,then  X  o  X  O  X  X  o ,o  X  d N ( o ,m ) .Since d E ( o ,m ) &gt;d N ( o, m )  X  d E ( o, m ) ,we have d N ( o ,m )  X  d E ( o ,m ) &gt;d E ( o, m ) and  X  o { o ,o } ,d E ( o, m ) &lt;d E ( o ,m )  X  d N ( o ,m ) . Therefore, we obtain  X  o  X  O  X  X  o } ,d E ( o, m ) &lt;d N ( o ,m ) . According to Definition 5, this implies that m is inside LC ( o ) , which contra-dicts our assumption of m .

Now that we know  X  o  X  O  X  X  o ,o } ,d E ( o ,m ) &gt;d N ( o ,m ) (in Figure 3, o 1 corresponds to o ), we have d S ( o ,m ) &gt;d N ( o ,m )  X  d S ( o ,m ) . Thus, d S ( o ,o )= d d ( m, o ) &gt;d S ( o ,m )+ d S ( m, o )  X  d S ( o ,o ) , which implies that o is closer to o than o ,i.e. o = NN S ( o | O  X  X  o }
Theorem 2 provides the candidates of NN S ( o | O  X  X  o } ) for fur-ther refinement. To find the exact NN S ( o | O  X  X  o } ) among the candidates, we have to invoke Chen and Han X  X  algorithm to com-pute the lengths of shortest surface paths from o to these candidates. Since the time cost of Chen and Han X  X  algorithm is quadratic to the number of triangular faces, we would like to evaluate the shortest surface paths on a small fraction of the surface, which is made pos-sible by the following theorem:
T HEOREM 3. If o j = NN S ( o i | O  X  X  o i } ) , then the shortest surface path from o j to o i is within LC ( o j )  X  LC ( o
P ROOF . Let us prove by contradiction. Note that LC ( o intersect with LC ( o i ) according to Theorem 2. Suppose that a point m on the shortest path between o j and o i exists that is outside both LC ( o j ) and LC ( o i ) (see Figure 4).

Since m is outside of LC ( o j ) , according to Definition 5, we that  X  o k  X  O  X  X  o i ,o j } ,d E ( o j ,m ) &gt;d N ( o k
We prove by contradiction. If o i is the only object in O { o j } that satisfies d E ( o j ,m ) &gt;d N ( o i ,m ) ,then { o i ,o j } ,d E ( o j ,m )  X  d N ( o k ,m ) .Since d E ( o j  X  d E ( o i ,m ) ,wehave d N ( o j ,m )  X  d E ( o j ,m ) &gt;d  X  o k  X  O  X  X  o j ,o i } ,d E ( o i ,m ) &lt;d E ( o j ,m )  X  d Therefore, we have  X  o k  X  O  X  X  o i } ,d E ( o i ,m ) &lt;d According to Definition 5, this implies that m is inside LC ( o which contradicts our assumption of m .
 Now that we know  X  o k  X  O  X  X  o i ,o j } ,d E ( o j ,m ) &gt;d (see Figure 4), we have d S ( o j ,m )  X  d E ( o j ,m ) &gt;d d ( o k ,m ) . Thus, d S ( o j ,o i )= d S ( o j ,m )+ d S ( m, o m )+ d S ( m, o i )  X  d S ( o k ,o i ) , which implies that o than o j , contradicting the assumption o j = NN S ( o i | in the theorem.

Algorithm for finding NN S ( o | O  X  X  o } ) . Our MSRNN query processing only requires to compute the surface distance between an object o  X  O and its surface nearest neighbor in O ,i.e. NN O  X  X  o } ) . According to Theorems 2 and 3, we can use Algorithm 2 to compute this distance. Note that Algorithm 2 can be easily ex-tended to find NN S ( o | O  X  X  o } ) by tracking the object with min-imum current distance.

Since the computation of d S ( o, N N S ( o | O  X  X  o } )) for objects o  X  O is a basic operation in our MSRNN query processing, one method is to pre-compute the value for each object o  X  O .How-ever, unlike Algorithm 1 which may not require any shortest surface path computation, Algorithm 2 requires to perform this expensive computation for | C | times. Thus, the pre-computation phase takes a long time and is only worthwhile for those applications where the object set O is static and they are frequently queried. In our implementation, d S ( o, N N S ( o | O  X  X  o } )) is computed online.
Intersection judgement. Algorithm 1 requires a point intersec-Algorithm 2 OO-NN ( o , O , T LC ) Input: query point o  X  O ; object set O ; R-tree T LC bulk-loaded from { LC ( o ) | o  X  O } Output: d S ( o, N N S ( o | O  X  X  o } )) 1: Find the set C = { o  X  O  X  X  o }| LC ( o )  X  LC ( o ) = 2: min  X  X  X  3: for each o  X  C do 4: Invoke Chen and Han X  X  algorithm to compute d S ( o, o ) on 5: if d S ( o, o ) &lt;min then 6: min  X  d S ( o, o ) 7: return min be within the minimum bounding box (MBR) of a leaf node en-try corresponding to LC ( o ) , a refinement step is required to check section judgements can be done simply on the xy -plane, without considering the z -coordinate values. We regard q as being within a polygon P even if q is on the boundary of P .
To determine whether a point q is within a polygon P ,weusethe ray casting algorithm . The method counts the number of times the horizontal ray extending to the right of q crosses a polygon bound-ary edge. If this number is even, the point is outside; otherwise, the point is inside. Figure 5(a) illustrates the idea of the ray casting al-gorithm . However, due to the edge crossing rules of the algorithm, a point on a right or top edge is considered outside, and therefore we check these special cases (e.g. the cases shown in Figures 5(b) and (c)) to ensure the correctness of intersection judgement.
Algorithm 2 requires an intersection query on R-tree T LC polygon window win , and if the MBR of win is found to intersect with the MBR of a leaf node entry corresponding to LC ( o ) ,are-finement step is needed to check whether polygon LC ( o ) intersects with win .

The general problem of determining whether two polygons P and P 2 intersect cannot be answered by simply checking whether there exists a vertex of P 1 that is within P 2 (see Figure 6(a)), and requires more advanced techniques such as the Bentley-Ottmann algorithm [24].

However, both win and LC ( o ) in our problem are loose cells, whose boundary must have a vertex on an edge of the model net-work whenever it crosses the edge (see Section 6). Therefore, we have the following theorem:
T HEOREM 4. Two loose cells LC 1 and LC 2 intersect with each other, if and only if, there exists a vertex of LC 1 that is within LC
P ROOF . Suppose that part of the edge de of LC 1 is inside LC but both d and e are outside of LC 2 ,then de crosses at least two edges of LC 2 , such as edges ab and bc in Figures 6(b) and (c). Let us call a horizontal or vertical line of model network edges as a model line. Note that there are two possible cases: (1) If b is not collinear with a and c on a model line, then there exist at least 3 model lines between a and c (see Figure 6(b)) and de must cross the model line in between. (2) If b is collinear with a (or c )ona model line as shown in Figure 6(c), then de must cross the model line of ab (or bc ). Thus, in either case, there is another vertex on de , contradicting the fact that de is an edge of LC 1 .
Note that we can use the ray casting algorithm described before to determine whether a vertex of LC 1 is within LC 2 .
In this section, we present our approach for cell construction, which is important due to the following reasons. (1) In order to ac-celerate SRNN query processing, we need to pre-compute TC ( o ) and LC ( o ) for all o  X  O . Recall that we also need to bulk-load an R-tree T LC from the loose cells LC ( o ) . (2) Our MSRNN algo-rithm requires to obtain the loose cell of the query point online.
The work of [1] proposes to comput e the tight/loose cells by con-tracting/expanding the Voronoi cells of the object set O in 3D Eu-clidean space. However, it is not easy to compute the 3D Voronoi cells and then to map them onto the surface. Besides, this approach constructs the cells of all objects in O at once, and cannot support efficient cell evaluation for an individual point q , which is a funda-mental operation in our MSRNN algorithm.

Therefore, we propose to construct the cells of a point online, by a breadth-first traversal of the faces starting from that point. We first describe the data structures relevant cell construction.
Vertex inverted index. We build an inverted index I faces each entry corresponds to a vertex v of the TIN model. Each entry faces whose vertices include v . For example, in Figure 7, the list L ( b ) contains six faces marked by 1 to 6.

One usage of I faces is to get the seeding faces for our breadth-first cell construction algorithm, and the other usage is to obtain the gluing relationships of faces, which are required as part of the input to Chen and Han X  X  algorithm . Referring to Figure 7 again, suppose that we want to obtain the face next to Face 6 by the edge ab . This can be done by first computing L ( a )  X  L ( b )= boundary of the land surface, its neighboring face along a boundary edge does not exist, and we denote it by NULL .

The above approach requires two I faces look-ups (i.e. two I/O operations) to get one neighboring face of a given face. An alterna-tive method is to pre-compute the three neighboring faces of each face in the TIN model, so that only one I/O operation is required to obtain all the three neighboring faces for a given face. We do not adopt this alternative to avoid the additional space overhead.
Tight cell vertex computation. Let us consider how to find the o k be the NN of v among O  X  X  o i } in the Euclidean space, i.e. o k =argmin o j  X  O  X  X  o i } d E ( o j ,v ) . We bulk-load an R-tree T from the object points in O beforehand, so that o k can be found by a best-first NN search [12] using query point v , where object o filtered out during the R-tree traversal.

To decide whether v is within TC ( o i ) , according to Equation (2), we need to compute and compare d N ( o i ,v ) and d E d ( o i ,v )  X  d E ( o k ,v ) , we say that vertex v is on o noted as v o i ; otherwise, we say that v o i .

For an edge uv of the model network, if u o i and v o i , then d N ( o i ,u )  X  d E ( o k ,u ) and d N ( o i ,v ) &gt;d therefore there must exist at least one split point s on uv such that d ( o i ,s )= d E ( o k ,s ) . The split point s is a vertex of TC ( o
There can be more than one split point on an edge uv ,which on edge ( u, v ) with | up | = x . From Figure 8(a) we can see that d ( o i ,p )=min { d N ( o i ,u )+ x, d N ( o i ,v )+( | uv piecewise linear function of x with at most 2 pieces. In Figure 8(b), by Cosine law, we can obtain d E ( o k ,p ) 2 = d E ( o k 2 d ( o i ,s ) 2 = d E ( o k ,s ) 2 to compute split points s .
The work of [1] mistakenly assumes that at most one split point s exists on an edge uv . To avoid the complication of solving quar-tic equations, we follow their assumptions by finding a split point inside the exact TC ( o i ) . Although cells computed in this way are not the exact ones, they do not influence the correctness of SRNN evaluation, but just slightly reduce the pruning power of the cells, due to the following intuitive principle:
Making the tight cells smaller and the loose cells larger than the exact ones does not influence the correctness of the cell properties.
We compute the split point s on an edge as follows. Consider face def in Figure 9, where e o i and f o i . We compute the split point s on ef as follows: Let us denote x = | fs | , we compute s by solving the equation coordinate of s is computed as Equation (4) equals d N ( o i ,s ) , and the L.H.S. is at least d
The work of [1] differentiates 4 possible cases for a face: (1) all three vertices are on o i  X  X  side (e.g. Face 1 in Figure 9), in which are not on o i  X  X  side (e.g. Face 4 in Figure 9), in which case the face is totally outside of TC ( o i ) ; (3) only one vertex is on o Face 3 in Figure 9), in which case two split points can be computed as illustrated by face abc in Figure 9; (4) two vertices are on o side (e.g. Face 2 in Figure 9), in which case two split points can be computed as illustrated by face def in Figure 9. In the last two cases, a cell edge of TC ( o i ) is defined by the two split points. We also adopt this approach in our implementation.
 Loose cell vertex computation. The vertices computation for LC ( o i ) is similar but more tricky. Given a vertex v of the model Equation (3), to decide whether v is within LC ( o i ) , we need to compute and compare d E ( o i ,v ) and d N ( o k ,v ) .
Due to the large size of the TIN model network (typically with millions of vertices) and the object set O , it is not practical to find o by evaluating d N ( o j ,v ) for all o j  X  O  X  X  o i } . Besides, since the computation of LC ( o i ) works in a breath-first manner, the net-work distance computation for different vertices v can be shared rather than done individually, so a s to utilize the locality property.
Our approach of network distance computation when evaluat-obtained from the Dijkstra algorithm for different source vertices o k  X  O  X  X  o i } during the computation of LC ( o i ) . Whenever a network distance computation d N ( o k ,v ) is required, we check whether the partial result of o k exists in the pool: (1) if the par-If it is available, it is returned directly; otherwise, we continue to run the Dijkstra algorithm until d N ( o k ,v ) is computed. (2) if the partial result does not exist, we create and initialize a new partial partial result to the pool.

Our approach is efficient since only a small number of partial re-sults are kept in the pool. To see this, consider the example in Fig-ure 10, where vertex c of face abc is being evaluated. Note that o k 5 is so far from o i that d E ( o k 5 ,c ) &gt;d N ( o k 3 is even larger and o k 5 can be safely pruned. In general, if d for all checked objects o j ,then o can be pruned.
To get a tight upper bound in the very beginning, we find the nearest neighbor of v among objects in O  X  X  o i } in the Euclidean space, say o n , using the object R-tree index T O mention before, and initialize t he upper bound as d N ( o n ,v ) .

The split point computation is similar to that of TC ( o i Breath-first cell edge collection. To collect all the edges of starting from o i . Specifically, we first initialize a queue Q with the faces whose vertices contain o i , which can be obtained by looking up L ( o i ) from I faces . Then, whenever Q is not empty, we fetch the next face in Q , check the three face vertices, and evaluate split faces (if exists) to Q ; otherwise, we know that the face is totally outside of LC ( o i ) and we do not further expand faces.
Recall that during this process, we maintain a pool of partial Di-jkstra results for different source vertices o k .Since LC ( o only a very small fraction of the whole surface, we can expect that objects far away from o i will never require a network distance com-putation to a vertex on a traversed face. Thus, the pool is kept small (usually less than 10 source objects), and even for those source ob-jects in the pool, the Dijkstra algorithm is run on just a small frac-tion of the whole surface, as illustrated by the circles in Figure 10.
Boundary cells. For most of the cells, the edges collected form a closed curve (see Figure 11(a)), and thus the polygon cell can be easily constructed. However, there are cases where the edges form one open curve (see Figures 11(b) and (c)), and additional edges or vertices from the boundary of the surface are required to form the polygon cell. To decide which side of the curve is inside, we check whether object o is in the resulted polygon. In our experiments, we also find other rare cases such as the one shown in Figure 11(d). Therefore, for all the other cases, we set TC ( o ) to be the point o and LC ( o ) to be the MBR of the collected split points. Given an object set O and a query point q on a land surface, a MSRNN query returns the set of objects { o  X  O | NN S ( o { q } X  X  o } )= q } . Equivalently, an object o is the MSRNN of q ,if and only if
To obtain the MSRNN candidates, we compute LC ( q ) among the set O  X  X  q } online using our breadth-first cell construction al-gorithm described in Section 6, with an important additional oper-ation: whenever we obtain a split point s for the loose cell LC ( q ) on edge uv , according to Equation (3) we have and we collect o into the MSRNN candidate set C . The following theorem guarantees that the MSRNNs of q must be in C . Algorithm 3 Finding the MSRNNs of Query Point q 1: MRNN  X  X  X  2: Compute LC ( q ) among O  X  X  q } and collect candidates to set 3: for each o  X  C do 4: if LC ( o )  X  LC ( q ) =  X  then 5: d S ( o, N N S ( o | O  X  X  o } ))  X  OO-NN ( o , O , T LC 6: Invoke Chen and Han X  X  algorithm to compute d S ( o, q ) on 7: if d S ( o, N N S ( o | O  X  X  o } ))  X  d S ( o, q ) then 8: MRNN  X  MRNN  X  X  o } 9: return MRNN T HEOREM 5. Any object o  X  C in O cannot be q  X  X  MSRNN.
P ROOF . Note that the polygon LC ( q ) computed in the context of O { q } is the same as the polygon LC ( q ) computed in the con-text of C { q } . Therefore, for any point v outside LC ( q ) , it holds that  X  o c  X  C, d E ( q, v ) &gt;d N ( o c ,v ) .

For an object o  X  C in O , it must be outside of LC ( q ) according to the definition of loose cells, and therefore  X  o c  X  C, d d ( o c ,o ) . Thus d S ( q, o )  X  d E ( q, o ) &gt;d N ( o d ( o, N N S ( o | O  X  X  o } )) , and according to Equation (5), o cannot be an MSRNN.

Algorithm 3 shows our algorithm for MSRNN queries. In Line 2, we first compute the MSRNN candidate set C by evaluating LC ( q ) among O  X  X  q } using the breadth-first approach. We filter out those candidates o that satisfy LC ( o )  X  LC ( q )=  X  in Line 4. This is because, according to Theorem 2, any point p  X  O  X  X  satisfies LC ( o )  X  LC ( q )=  X  cannot be NN S ( o | O  X  X  where LC ( o ) is computed in the context of O  X  X  q } , denoted as LC ( o | O  X  X  q } ) . Note that the LC ( o ) in Algorithm 3 is the pre-computed one in the context of O ,i.e. LC ( o | O ) . According to Definition 5, it can be easily proved that LC ( o | O  X  X  LC ( o | O ) . Therefore, if Line 4 finds that LC ( o | O ) then LC ( o | O  X  X  q } )  X  LC ( q )=  X  and q cannot be NN { q } X  X  o } ) .
 For each non-pruned candidate o , we compute d S ( o, N N { o } )) in Line 5 using the object NN query described in Section 5, compute d S ( o, q ) in Line 6, and then determine whether o is an MSRNN of q by checking Equation (5) in Line 7. Note that in Line 6, we only need to evaluate the shortest surface path on LC ( o O )  X  LC ( q ) (  X  LC ( o | O  X  X  q } )  X  LC ( q ) ) according to Theorem 3.
If d S ( o, N N S ( o | O  X  X  o } )) is pre-computed for all o Algorithm 3 only require one shortest surface path computation. Otherwise, it needs to compute several shortest surface paths.
To process BSRNN queries, we pre-compute the cells for all sites s  X  S and bulk-load an R-tree T LC from { LC ( s ) | s  X  S } cell construction, an R-tree T S is bulk-loaded for nearest neighbor queries when computing the cells. Besides, we also bulk-load an R-tree T O for range queries used in the BSRNN query processing.
Algorithm 4 shows our algorithm for BSRNN queries. Accord-ing to Statement 2 in Theorem 1, only those objects within LC ( q ) have chance to be BSRNNs, and they are obtained as the candidate set C in Line 2. For each candidate o , if it is within TC ( q ) ,itis guaranteed to be a BSRNN of q according to Statement 1 in Theo-rem 1. Otherwise, we find the nearest site to o in Line 7 and check whether it is q in Line 8 to determine whether o is a BSRNN.
The algorithm can also support BSRNN queries on a moving object set O , by maintaining T O as a TPR*-tree [23].
 Algorithm 4 Finding the BSRNNs of Query Site q 1: BRNN  X  X  X  2: Perform a range query on T O with query window LC ( q ) to 3: for each o  X  C do 4: if o is within TC ( q ) then 5: BRNN  X  BRNN  X  X  o } 6: else 7: nn  X  QO-NN ( o , S , T LC ) 8: if nn = q then 9: BRNN  X  BRNN  X  X  o } 10: return BRNN
In this section, we evaluate the performance of our algorithms for MSRNN and BSRNN queries on two large real-world datasets downloaded from [25]: Eagle Peak (Eagle) and Bearhead (BH), which have also been used in previous studies such as [1] and [2]. The statistical information of the datasets is given in Table 1.
We use the most recent implementation of Chen and Han X  X  algo-rithm [9] for surface shortest path computation. All our programs are written in JAVA, and the executable program of [9] is called on the localized surface regions for surface shortest path computation.
The pre-computation of the index structures, such as the vertex inverted index I faces and the loose cell R-tree T LC out on a public Linux server with eight 3GHz Intel Xeon X5450 CPU and 32GB memory. All the experiments on queries are done on a computer with 3GHz Intel Core2 Duo E8400 CPU and 2GB memory, where the huge model network and all the index structures are disk-based.

Let G =( V, E ) be the model network, we define object (site) ent object densities. For each density configuration, we randomly generate 100 query points and run our algorithms with each query point. All the reported measures are averaged on the 100 runs.
The operation of breadth-first cell construction for all objects o  X  O dominates the time cost of the index construction phase. Figure 12(a) shows the number of source objects whose partial Di-averaged over all the objects in O , with varying object density. We can see from Figure 12(a) that, as object density increases, the pool size also increases. The pool size is usually around 7 to 8, which verifies the effectiveness of our Euclidean distance based pruning of network distance computation.

Figure 12(b) shows the time of constructing cells for all the ob-jects o  X  O , with varying object density. We can see from the figure that the cell construction time increases almost linearly with the increment of object density. This is because, given a specific surface data, object number is proportional to object density.
In this set of experiments, we evaluate the performance of our algorithm for surface NN queries (Algorithm 1). Recall that no (c) TC Coverage Ratio (g) MSRNN Query Time (k) BSRNN Time (  X  =3 %) shortest surface path computation is necessary if query point q falls within the tight cell of some object. For each object density, we count the number of such queries, denoted N , among the 100 NN queries tested. The ratio N/ 100 is called the Tight Cell Coverage Ratio (TCCR). Figure 12(c) shows the TCCR with varying object density, where around 80% to 90% NN queries do not need to in-voke Chen and Han X  X  algorithm . Figure 12(d) shows the average NN query processing time with varying object density. The query processing time is long (1 to 3 seconds) for sparse object distribu-tion, due to the large areas of loose cells which act as input to Chen and Han X  X  algorithm .
In this set of experiments, we evaluate the performance of our algorithm for MSRNN queries (Algorithm 3). Recall that Algo-rithm 3 performs MSRNN candidate filtering in the beginning in Line 2. Figure 12(e) shows the average number of candidates with varying object density, where we can see that there are usually 6 to 7 candidates and the trend is not sensitive to object density. We also find that the MSRNN count distribution is not sensitive to object density. Figure 12(f) shows the MSRNN count distribution over all the MSRNN queries we tested, where almost half of the query points have exactly one MSRNN, very few of the query points have four MSRNNs, and no query point has over four MSRNNs.

Figure 12(g) shows the average MSRNN query processing time long for sparse object distribution, due to the large areas of loose cells which act as input to Chen and Han X  X  algorithm .

To further clarify the trend of query time, we plot the curves in log-scale in Figure 12(h), where we can see that the performance of our algorithm is good for reasona bly large object densities (
In this set of experiments, we evaluate the performance of our algorithm for BSRNN queries (Algorithm 4). For each site density, we generate object sets of different sizes, and for each object set, we perform 100 BSRNN queries.
 The objects that fall in TC ( q ) are guaranteed to be q  X  X  BSRNNs. Let the percentage of BSRNNs among the objects in LC ( q ) TC ( q ) be termed the BSRNN ratio . Figure 12(i) shows the BSRNN ratio when | O | / | S | varies. The results are averaged over experi-ments with different site densities, since BSRNN ratio is insensitive to site density. We can see that around 45% to 50% of the objects that fall in region LC ( q )  X  TC ( q ) are q  X  X  BSRNNs.
The average number of BRNNs of a query point is also found to be insensitive to site density. On the other hand, it is sensitive to | O | / | S | , as Figure 12(j) shows. This is within the expectation, since each site s  X  S has to serve | O | / | S | objects on average.
Figure 12(k) shows the average BSRNN query processing time on the site set S with site density 3%, when | O | / | S | query processing time increases when | O | / | S | increases. This is the region LC ( q )  X  TC ( q ) , and therefore more NN queries are required to check whether each candidate object is q  X  X  BSRNN.
Figure 12(l) shows the average BSRNN query processing time densities implies larger areas of loose cells, which not only implies larger input region to Chen and Han X  X  algorithm , but also higher chance that an object falls in region LC ( q )  X  TC ( q ) .
The concept of RNN is first introduced in [13]. Since then, many algorithms have been proposed for finding RNNs in the Euclidean space. Algorithms for MRNN query processing include SAA [14], TPL [15], Finch [20], Influence Zone [21]. Algorithms for BRNN query processing include [18] and [19]. [22] studies RNN queries in road networks.

Studies on finding shortest surface paths date back to the 80s to 90s, when a series of exact and approximation algorithms are proposed. The most efficient exact algorithms include the one pro-posed in [7] with O ( n 2 log n ) time complexity, and Chen and Han X  X  algorithm [8] with O ( n 2 ) time complexity, where n corresponds to the number of triangles in the TIN model. Chen and Han X  X  algo-rithm is later implemented in [9].

Recently, [5] proposes an approximate algorithm with O (log n +  X  n ) time complexity, by treating the surface paths on the non-rough areas as straight lines, and [6] studies the problem of find-ing shortest paths with slope constraint and develops the surface simplification technique to reduce the model complexity, so as to reduce the time complexity of finding shortest paths.

As for the research on surface k -NN queries, [2] and [3] first propose a filter and refinement strategy to answer S k NN queries on multi-resolution terrain models. However, this approach can nei-ther guarantee accuracy nor provide the shortest surface paths to the nearest neighbors. An exact solution to the S k NN problem is pro-posed in [1], where approximations of Voronoi cells are constructed to prune unnecessary shortest surface path computation and to lo-calize the shortest path computation. In this paper, we also make use of these Voronoi Cell approximation structures for the same purposes. Although the concept of Voronoi diagram is only related to 1-NN, [1] claims that its approximation structures can be used in an incremental manner to answer k -NN queries for arbitrary k . Unfortunately, as we have discussed in Section 4, the correctness of the algorithm relies on an unproved statement, which is, however, flawed. [4] studies the problem of continuously monitoring the k nearest neighbors of a fixed query point when the objects on the surface are moving.
In this paper, we investigate how to process RNN queries on land surfaces. Specifically, we study monochromatic SRNN queries and bichromatic SRNN queries. Our SRNN algorithms are based on several newly-discovered properties of the Voronoi cell approxi-mation structures, and are able to localize the query evaluation by accessing just a small fraction of the surface data near the query point. The majority of the objects that cannot be the SRNNs of the query point are pruned by our cell properties. Furthermore, we pro-pose a new online cell construction algorithm which is essential to our MSRNN algorithm, and is efficient due to our smart approach for computing network distances. Extensive experiments on large real-world datasets demonstrate the efficiency of our algorithms.
This work is partially supported by RGC GRF under grant num-ber HKUST 618509. [1] C. Shahabi, L.-A. Tang and S. Xing.  X  X ndexing Land Surface [2] K. Deng, X. Zhou, H. T. Shen, K. Xu and X. Lin.  X  X urface [3] K. Deng, X. Zhou, H. T. Shen, Q. Liu, K. Xu and X. Lin.  X  X  [4] S. Xing, C. Shahabi and B. Pan.  X  X ontinuous Monitoring of [5] S. Xing and C. Shahabi.  X  X calable Shortest Paths Browsing [6] L. Liu and R. C.-W. Wong.  X  X inding Shortest Path on Land [7] J. S. B. Mitchell, D. M. Mount and C. H. Papadimitriou. [8] J. Chen and Y. Han.  X  X hortest Paths on a Polyhedron X . In [9] B. Kaneva and J. O X  X ourke.  X  X n Implementattion of Chen &amp; [10] S. T. Leutenegger, J. M. Edgington and M. A. Lopez.  X  X TR: [11] N. Roussopoulos, S. Kelly and F. Vincent.  X  X earest [12] G. R. Hjaltason and H. Samet.  X  X istance Browsing in Spatial [13] F. Korn and S. Muthukrishnan.  X  X nfluence Sets Based on [14] I. Stanoi, D. Agrawal and A. El Abbadi.  X  X everse Nearest [15] Y. Tao, D. Papadias and X. Lian.  X  X everse k NN Search in [16] M. L. Yiu, D. Papadias, N. Mamoulis and Y. Tao.  X  X everse [17] M. A. Cheema, W. Zhang, X. Lin, Y. Zhang and X. Li. [18] I. Stanoi, M. Riedewald, D. Agrawal, and A. E. Abbadi. [19] T. Xia, D. Zhang, E. Kanoulas and Y. Du.  X  X n Computing [20] W. Wu, F. Yang, C.-Y. Chan and K.-L. Tan.  X  X inch: [21] M. A. Cheema, X. Lin, W. Zhang and Y. Zhang.  X  X nfluence [22] D. Taniar1, M. Safar, Q. T. Tran, W. Rahayu and J. H. Park. [23] Y. Tao, D. Papadias and J. Sun.  X  X he TPR*-Tree: An [24] M. D. Berg, O. Cheong, M. V. Kreveld and M. Overmars. [25] http://data.geocomm.com
