 Information systems are often not built from scratch, but are the result of integrating ex-isting software components and services into a larger system by means of middleware that connects the existing components. This very task of integrating preexisting com-ponents is challenging, especially if component s of multiple parties s hall be integrated. Conflicting interests and goals need to be resolved, and whether a particular integration solution is  X  X ood X  is subject to numerous criteria. In a recent survey [17], SAP listed as goals the ability to design fast and correct middleware systems, to enable enterprise interoperability, and to monitor and con tinuously optimize existing integrations.
Hohpe and Woolf proposed a collection of Enterprise Integration Patterns (EIP) [24] to help addressing many of the challenges at early stages of an integration project. Each pattern in their collection e ncapsulates a key functionality typically found in middle-ware solutions, such as message creation, routing, filtering, etc. These patterns can then be used to abstractly describe complex middleware systems in a comprehensive manner. Ideally, once the design is complete, the middleware can be implemented in appropriate technology [24, Chap. 13]. However, the functionality and behavior of each pattern in the EIP-collection is only given in informal text. Thus, analyzing the design for func-tional errors, missing or incomplete functionality, or performance problems requires additional and non-trivial work. Likewise the step from an informal design to a work-ing implementation is costly and subject to mistakes.

In this paper we address the open problem of automatically generating from an in-formal EIP-middleware design a formal model of the middleware that allows for (1) verifying the middleware design for functional errors, e.g., using model checking, (2) completing the middleware design in case of missing functionality, e.g., using controller synthesis techniques, (3) analyzing the performance of the designed system, e.g., using comprehensive simulation techniques, (4) a utomatically creating a running implemen-tation of the middleware, e.g., using process engines or code generation.
 Contribution. We provide for each pattern in the EIP -collection a formal model in terms of Coloured Petri Nets (CPN) [26], an extension of Petri nets that also describe the processing and exchange of typed data. Using this formalization, a given EIP-middleware design can be translated to a CPN model that describes the functionality of the middleware. For the CPN model in turn a variety of techniques are available: the CPN model can be modelchecked for functional errors [29], its control-flow can be completed using controller synthesis techniques [19], its performance can be ana-lyzed using simulation techniques [26, 27], and an implementation of the middleware could be obtained by code generation [30] or by deploying the CPN model in a process engine [33].
 Outline. We give an overview on existing works on enterprise integration in Sect. 2. Then, we recall some basic notions of Colour ed Petri nets in Sect. 3. Section 4 recalls the Enterprise Integration Patterns and we present the principles of formalizing EIP in CPN models for several comprehensive examples; the complete collection of formal patterns is available at [15]. We then show how to derive formal CPN models of a middleware design using our approach, and discuss in Sect. 5 how available techniques for verification, synthesis, simulation, and deployment of CPN models can be used in the context of middleware designs. We conclude in Sect. 6. Enterprise integration receives much attention from industry and academia yielding a large body of literature. Some recent surveys can be found at [9,22,39]. In the following we focus on approaches that address the use cases raised in Sect. 1.

Many authors, such as Scheibler and Leymann [41], advocate a pattern-based or model-driven approach for enterprise integration and many solutions have been pro-posed in this direction. Frantz et al. [16] introduce the DSL Guaran X  that uses EIP to model enterprise application integration solutions and can be translated to Java code. Spring Integration [28] and Apache Camel [25] are further frameworks for modeling messaging systems based on EIP. Recent approaches for pattern languages [23, 34] con-centrate on identifying patterns and implementing them, though missing the chance of giving formal semantics. The existence of such tools shows the acceptance of EIP, but these frameworks lack formal analysis facilities required in early stages of the design.
Approaches with formal semantics, among many others, propose AI planning [35], theory building [4], or model-driven archit ectures [38] to obtain a formal model of an enterprise integration solution. Howeve r, none of the resulting models can address all the uses cases of Sect. 1. The perhaps most versatile approach thus far is proposed by Mendes et al. [36] who show the feasibility of Petri Nets in Enterprise Integration. Un-fortunately, their approach lacks a complete and structured support for all known Enter-prise Integration Patterns and focuses on simulation and execution, only. That complex systems can be built from formalized pattern s has been successfully demonstrated in other domains such as the Workflow Patterns [3] or Service Interaction Patterns [5].
To the best of our knowledge, the combin ation of EIP and a translation of each pattern into a formal model, such as Coloured Petri nets, for interweaving the worlds of pattern-based enterprise integration and versatile formal analysis has not been addressed before. We u s e Coloured Petri Nets (CPN) [26] to model the semantics of Enterprise Integra-tion Patterns. CPN are successfully applied in research and industry in modeling and analyzing distributed systems [43].

A Petri Net processes resources called token . Places hold these resources, and tran-sitions process them. A flow relation connects places with transitions and vice versa.
Figure 1a shows an example for the struc ture of a CPN; a circle depicts a place, a rectangle depicts a transition, and the arcs depict the flow relation. This basic structure already dictates that transition recv req has to consume a resource from place chan1 and that it produces new resources on places p1 and enforce reply .

In CPN each token is a value (called color ) of some type (called colorset ). Each place is typed with a specific colorset and holds only tokens of that type. In Fig. 1b places chan1 and p1 have type Request , enforce reply has type CorrelationIDType ,and p2 and chan2 have type Reply . Each arc is labeled with either a variable (e.g., cid or x ), or a complex term such as function applications (e.g., id x applying function id on variable x ) or complex data structures (e.g., tuple (cid, x) ). The labels of arcs adjacent to a transition express which tokens the tra nsition consumes and produces as explained below. In addition, a transition can have a guard to restrict consumption and production of tokens; e.g., transition send rep has the guard [cid = i] .

The state of a CPN is a marking describing a distribution of tokens (colors) over places of the respective colorset. In Fig. 1b, place chan1 holds token (42, X  X ing X ) (a tuple of the colors 42 and  X  X ing X  ), place enforce reply holds token 23 , and place p2 holds token (23, X  X ong X ) ,
The behavior of a CPN is described by firing transitions, which consume and produce tokens as follows. Figure 2a shows the effect of firing transition recv req at the marking of Fig. 1b. For firing recv req ,thevariables cid and x at the arcs adjacent to recv req have to be bound to a color, such for each incoming arc ( p, recv req ) its arc label evaluates to a token on place p ; in this case recv req is enabled . For instance, for the binding cid = 42 and x =  X  X ing X  , there is a token (42, X  X ing X ) on place chan1 . If multiple bindings evaluate to available tokens, then one binding is chosen non-deterministically. When firing an enabled transition under the chosen binding, th e tokens described by labels of incoming arcs are consumed from the respective place, and tokens described by labels of outgoing arcs are produced on the respective place. Firing recv req in our example consumes (42, X  X ing X ) from place chan1 and produces (42, X  X ing X ) on p1 and 42 on enforce reply . The resulting marking is shown in Fig. 2a.
 In Fig. 2a, there is no binding to enable recv req because there is no token on chan1 . Transition send rep still can fire for the binding i = 23 , x =  X  X ong X  ,and cid = 23 .The guard of send rep ensures that i and cid are bound to the same value. The result of firing send rep isshowninFig.2b. In their best practices book Enterprise Integration Patterns [24], Hohpe and Woolf have collected a widely used and accepted collectio n of integration patterns. The patterns are typical concepts us ed when implementing a messaging system and have proved to be useful in implementation. They can cope with the asynchronous nature of message exchange and the facts, that  X  X etworks are unreliable X ,  X  X etworks are slow X ,  X  X ny two applications are different X , and  X  X hange is inevitable. X  On the other hand, the modular nature of patterns allows them to be used efficiently in new implementations.
In the following, we give a short overview of typical EIP, explain their concepts and their CPN realization. The shown patterns (and CPNs) will be used later in examples that illustrate several use cases. The complete list of patterns and CPN realizations is available at [15]. 4.1 Basic Concepts of EIP The following six patterns are the basic concepts described by Hohpe and Woolf; all further patterns are specializations.
 Message Channel prerequisite for specifying message layout and manipulation. xx Implementations of a message channel differ depending on its purpose pects like buffer capacity of a channel or t he order of messages influence the actual implementation. In any case, sending a m essage is normally decoupled from receiving a message, thus a channel needs the capability to hold a message. In CPN we realize this by using a place as buffer. In context of the intended properties, this place can be refined to a queue or to hold only a certain capacity of messages.
 Message influences how a message is treated. We may explicitly send a command, a document, or a notification. Based on this categorization, a messaging system can transfer a message to an appropriate destination or handle a message with higher priority.

In CPN we represent a message by a colored token. The corresponding colorset determines the type of a message, and colorsets can be used to represent even complex data types.
 Pipes and Filter which recipient, and whether all parts of a m essage are forwarded or even additional information is added to a message. A pipe connects different message processing units and thus directs messages through the messaging system. another message on a second pipe. The relation between the consumed and produced message is dictated by the filter X  X  purpose and in general resembles function application.
A pipe has a similar purpose as a message channel. Therefore we use again a place to represent a pipe.
 Message Router picks may be decided statically or dynamically, based on rules or a message X  X  content. mation for picking the appropriate recipient.
 Message Translator these applications to exchange messages. Message Endpoint Within the application, a message endpoint might be hidden behind an additional layer allowing to use an application without fundamental changes. 4.2 Detailed Description of Example EIP We now present examples of more involved pa tterns often needed in practical integra-tion scenarios; see [15] for the complete lis t. We have picked these patterns, because we will later use them in our examples and still they indicate the variety of these pattern. Content Enricher be added statically or dynamically by invoki ng another application that provides the required data. send a request req x based on the consumed message to that application. The appli-cation X  X  answer z then is used to enrich the original message ( enrich x z ). Recipient List can be chosen dynamically from the set of all potential recipients. address list l contains the recipients that shall recei ve their copy. A message is then for-warded to a recipient if it is in the list (guard [ inList l  X  pipe i  X  X  ) and dropped otherwise (guard [ not inList l  X  pipe i  X  X  ).
 Aggregator fits best to some criterion. Request-Reply the first one.
 Channel Adapter ing application data, so that the application does not have to be aware of message ex-changes. chronous message exchange into an asynchronous exchange, and vice versa.
 Connecting Patterns. The mean to connect EIP with each other are the channel and pipe patterns that are represented by arcs. These arcs become places in the CPN model, such that the remaining patterns are connect ed via these places; i.e., one pattern will put a message on the place while the other takes a message from it. Please have a look at the example below (Fig. 4b).

While the EIP model does not necessarily n eed to distinguish the identity of arcs, in the CPN model the identity of places is more important. Consider the routing pattern, which has multiple outgoing pipes. If we pr ovide conditions in the CPN model, then the right place should be marked if the condition comes true.

Connecting to EIP with an arc further implies type equality; i.e., the first pattern sends out a message of a certain type, then the second has to receive a message of the same type. Thus, in the CPN model the connecting place must have the same type. We actually can use this requirement to infer types when translating EIP to CPN. The result of the translation from EIP to CPN results in a canonical net structure. However, as a user has to provide the definition of types and and functions, the transla-tion is not unique, but depends on a user X  X  data declarations. 4.3 Deriving a Formal Model of a Middleware Using EIP designer then has to provide the function definitions used in the patterns.
We want to implement a loan broker . The loan broker (Fig. 3) acts centrally between a customer, several banks, and a credit bureau for the customer X  X  credit history.
Figure 4a shows the loan broker X  X  integration as proposed by Hohpe and Woolf. A customer X  X  Loan Request first passes a content enricher to add the credit score provided by a Credit Bureau to the request. The next content enricher preselects addresses of some banks with the help of a rule base .A recipient list actually sends the request to some of three Banks . The results are handled by an aggregator and the Best Quote is returned to the customer.

Translating the EIP design of Fig. 4a as d escribed above yields the CPN model shown in Fig. 4b. Such a formal CPN model of the middleware can then be used in various use cases as we discuss next. Hohpe and Woolf assume that a domain expert uses EIP to model a messaging system and then implements each pattern. Even when taking great care, the EIP design may contain flaws or have performance problems which cannot be unveiled based on the informal description of EIP. In the following, we show for various use cases how the CPN realization of an EIP design helps discovering problems at early stages of design.
CPN offer a high level of abstraction while allowing local refinements. On this level, we can simulate and model check a CPN model as well as create service adapters or run it on a workflow engine . Thus CPN models bridge the gap between conceptual models and their implementation. If required, the domain expert can use the CPN model as blueprint for implementation. 5.1 Simulation and Performance Analysis in CPN Tools CPN have proved to be a useful tool to discover design problems and performance is-sues of complex distributed systems, doc umented by several dozen case studies with industrial context [43] (e.g., [11, 31] have a similar context as our loan broker example). Main focus in these case studies is the evaluation of CPN models before actually im-plementing the final system. This allows flexible modeling and changing, s.t. the final system will meet performance requirements.

CPN models have a formal semantics and thus can be executed. Missing implementa-tion details manifest as abstraction or non-determinism. CPN Tools [27] run simulations on a CPN model yielding realistic analysis and performance data. With these data one can identify flaws and optimize the design before the actual implementation. This can particularly be done during the design phase allowing for an interactive analysis-driven design method.

Figure 5 shows the loan broker example in CPN Tools. Let us assume, the loan broker is paid on provision base for successfully procuring a loan quote. Given statistics on potential clients and offers of the banks, we can evaluate, how often a loan quote is offered and what the provision may be.

Since we already have the model at hands, even support for runtime decisions is possible. Rozinat et al. [40] developed a simulation system for operational decision support . They use YAWL [2] for running workflows and the ProM framework [1] for process mining and support decision making for the currently running workflow. Since YAWL and CPN are closely related, this idea can also be applied for middleware sys-tems that need guidance in complex interaction scenarios. The simulation results do not only allow to refine the messaging system before execution, but during execution simu-lation results allow to influence the message flow. The goal of distributing messages, s.t. the overall system load is low, can also be achieved by investigating multiple scenarios with simulation. 5.2 Model Checking Simulation can be used to validate and improve a design, but is incapable of proving the absence of design errors. CPN Tools also allow to explore the state space of a CPN model [29] for the purpose of verifying that a particular property holds. The state space can be infinite (depending on data domains and the general net structure), however, verification is still feasible in many cases.

CPN Tools ship with an extension ASK-CTL [10,12]. It implements a model checker allowing to check CPN models for temporal properties similar to the Computational Tree Logic (CTL) [13]. Alternatively, one may abstract from data aspects (by turning data-dependent decisions into non-deterministic choices) and consider only the control-flow and message flow of the designed middleware; the resulting net without any arc inscriptions or guards is called Place/Transition net . For Place/Transition nets a multi-tude of model checkers exist, allowing to verify temporal logic [21, 42], probabilistic properties [32], and timing constraints [18].

In our example of the loan broker, we may want to ask, if always a loan quote is sent back to the customer. There is the case, where the address list might be empty, s.t. no bank is contacted and therefore no loan quote offer arrives at the loan broker, which can be detected automatically in cluding a counter example trace. With this knowledge, we can also ask for the probability of a loan quote, or how long it takes to find a best offer. 5.3 Automatically Completing Designs Hohpe and Woolf focus on stateless applications (as in the loan broker example) that shall be connected by a messaging system, but EIP equally apply for integrating stateful applications . The difficulty arising here is that the integrating middleware may provide several message transformations that have to be applied in a controlled manner to avoid that the integrated system runs into a bad state, e.g., a deadlock. In the following, we show how a given EIP-based middleware design can be automatically completed to integrate stateful applications such that no error occurs.

We solve the problem by adapting a solution from the area of services, where a state-ful application is called service and the integrating middleware a service adapter [44]. Several approaches propose to model the message flow between two services formally. The techniques cover the Web Service Choreography Interface language [8], process algebra [7],  X  -calculus [6]ortheuseof message transformation rules [19]. Dumas et al. [14] even propose a visual notation using rectangles with the name of the building block to use. Using the variety of EIP we can complement these techniques. the system.

As example, we consider Google X  X  Checkout payment service [20] and a propri-etary web shop protocol (Fig. 7). Google Checkout is an API for handling web shop payments externally. We assume some proprietary payment back-end of such a web shop. We use communicating automata to describe the underlying protocols with gray boxes as states  X  black for final states  X  and arcs for transitions. An arc label tells us, whether the service sends (!) or receives (?) a certain message type. In Fig. 7 we do not distinguish the type of communication, but please note, that Google Check-out assumes synchronous message exchange, whereas the web shop uses asynchronous communication.

Google X  X  Checkout service needs a request and information on the charge , each followed by sending an acknowledgment. We may also reauthorize a payment (e. g., by entering new credit card credentials), cancel the whole payment, or trigger a subsequent charge , if we transfer only parts of the whole sum. When a payment is declined at first, the service decides afterward, whe ther the payment was successfully charged or the payment has to be redone.

The web shop first sends the payment info rmation and then either wants to change some of the information again, or it requests to execute the payment. If the payment is not done , then it returns to the processing state.
Besides the obvious mismatch in messa ge names, we do not succeed in matching the interfaces of both services, s.t. they can communicate correctly; that is, that both services can always reach a final state together. We now first introduce a mediator using EIP to model the message flow between both services.

For building the mediator in Fig. 8a we consider the services X  protocols: The web shop X  X  payment info is translated into a request which is answered by a corresponding chargeable . The mediator uses a request-reply for message correlation and drops the re-ply that is not expected by the shop. When the web shop sends a change , then Checkout shall reauthorize the payment and quit this step with a chargeable  X  again the mediator uses the request-reply pattern. The execute message is directly translated into a charge . If Checkout X  X  answer is a declined followed by chargeable , these two messages are ag-gregated to a not charged .A charged together with a possible declined is aggregated to a done .The message routers distribute the chargeable and declined messages, that are needed in different patterns. The channel adapters on Google Checkout X  X  side adapt the synchronous communication of the service to the asynchronous nature of the patterns.
While the mediator design connects both, Checkout and web shop, it allows for er-roneous runs that cannot be avoided. Whenever Checkout sends a chargeable message, the message router has to decide where the message shall be forwarded, but this decision cannot be made locally just in the router. For instance, to route chargeable to changed , the router has to know that a change message was sent earlier (but is no longer in the system). Without such knowledge, the message could be dropped (reply to payment info ) and the system deadlocks, waiting for the reply on change . This can be prevented when the message router is controlled based on preceding message exchanges.
The engine service in Fig. 8b uses the CPN pattern to model the message flow and we can recognize the same structure as in the mediator. By giving the abstract service models of Google checkout and the web shop, and the engine model of Fig. 8b to the synthesis technique of [19], we automatically synthesize a controller that restricts the firing order of transitions, of the router as well as of all other transitions, such that the interaction is deadlock-free. For the given example, the synthesized controller has 212 states, and the resulting equivalent Petri net has 44 places, 41 transitions, and 138 arcs; the controller is shown in [15, p.47]. The synthesized controller can be implemented as independent component that accesse s the interface of the engine. 5.4 Execution on Workflow Engine and Code Generation Enterprise Integration Patterns are normally considered to be used for modeling the architecture of a messaging system, and th en a developer has to implement the single patterns in languages like Java or C#. However, Coloured Petri Nets have a Turing-complete semantics, and thus are able to express any desired behavior expressible in any programing language.

Instead of implementing each pattern we can refine each CPN pattern and then di-rectly execute the CPN model. Liu et al. [33] describe the Tsinghua Workflow Man-agement System based on Coloured Petri Nets being suitable for this purpose. Although YAWL (Yet Another Workflow Language) [2] does not support the execution of arbitrary CPN, it is still based on CPN and shows the feasibility of executing CPN directly.
The CPN patterns may need some refinement in conditions or message translation, but these are rather small and local tasks and do not involve to implement a complete pattern in a programing language. Moreove r changes in the model or the implementa-tion are easily traceable, whereas a paradig m shift to a programing language usually ruins this kind of relation.

Implementations with better performance can also be obtained by generating equiv-alent code out of a CPN model [30, 37], though the particular constraints of middleware platforms may require adjustments of existing techniques. Enterprise integration will remain a hot topic, especially as industry needs to integrate existing applications into new infrastruct ures. Using EIP is a first step, because they allow to tackle the problem on a conceptual level and not only on the technical one.
The EIP by Hohpe and Woolf cover the large spectrum of concepts used in message-based middleware systems, for which we provided corresponding CPN pattern [15]. With the translation of EIP to CPN we provide the means to analyze and improve a system at early stages of its design using existing analysis techniques and tools. We discussed how the design can be checked fo r flaws and performance issues before the actual implementation and execution, and showed how to complete an incomplete de-sign using controller synthesis techniques. This enables system designers to save time and cost, as necessary changes can be made early.

We expect, that the methodology used in this paper can be transferred to other con-texts and thus enables analysis in context of other pattern collections. An aspect left open in this paper is to define appropriate functions for transforming and routing mes-sages; such definitions could for instance be derived using semantic techniques.
We plan to integrate this approach into an editor that allows to model a middleware system using the Enterprise Integration Pa tterns. Additionally each instance of a pattern can be enriched by the information needed fo r the CPN pattern; i.e., message types, routing conditions, and so on. Then an automatic translation into a CPN model shall allow us to apply the setting presented in this paper.
