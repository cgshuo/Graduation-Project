 Heterogeneous entities or objects are very common and are usually interrelated with each other in many scenarios. For example, typical Web search activities involve multiple types of interrelated entities such as end users, Web pages, and search queries. In this paper, we define and study a novel problem: S earch H eterogeneous IN terrelated E ntities (SHINE). Given a SHINE-query which can be any type(s) of entities, the task of SHINE is to retrieve multiple types of related entities to answer this query. This is in contrast to the tra-ditional search, which only deals with asingle type of en-tities (e.g., Web pages). The advantages of SHINE include: (1) It is feasible for end users to specify their information need along different dimensions by accepting queries with different types. (2) Answering a query by multiple types of entities provides informative context for users to better un-derstand the search results and facilitate their information exploration. (3) Multiple relations among heterogeneous en-tities can be utilized to improve the ranking of any particular type of entities. To attain the goal of SHINE, we propose to represent all entities in a unified space through utilizing their interaction relationships. Two approaches, M-LSA and E-VSM, are discussed and compared in this paper. The ex-periments on 3 data sets (i.e., a literature data set, a search engine log data set, and a recommendation data set) show the effectiveness and flexibility of our proposed methods. Categories and Subject Descriptors: H.3.1 [Content Analysis and Indexing]: Indexing methods; H.3.3 [Informa-tion Search and Retrieval]: Search process General Terms: Algorithms, Design Keywords: SHINE, heterogeneous interrelated entities, mul-tiple types, search
Heterogeneous interrelated entities or objects are common in many scenarios. For example, general Web search ac-tivities involve heterogeneous objects including end users, search queries, Web pages, and words. In literature data, four types of heterogeneous entities are included: authors, papers, conferences, and keywords. All the inter-relationships Copyright 2007 ACM 978-1-59593-803-9/07/0011 ... $ 5.00. among these heterogeneous objects provide rich information to build potentially better search services. However, most of current search services only deal with a single type of objects (e.g., Web pages) and are limited in both query capabilities and search result richness. For example, in the traditional Websearch,enduserscanonlyspecifytheirinformation need by a string of query terms and only a ranked list of pages are returned as search results. Although most search engine users have been trained to become accustomed to this traditional method, several drawbacks are still needed to be addressed in order to better satisfy users X  information needs. For example, in some cases, a user who needs help to formulate a better query may want to know  X  X hat are the possible words for me to refine my queries X  or  X  X hat are the related queries other users submitted for similar needs? X  In other cases, a Web master/advertiser is more curious about  X  X hat are the related pages to my page  X  or  X  X hat are the queries which are submitted by end users and related to my page ? X  For a literature search, a researcher may want to find papers of particular topics published in particular con-ferences or published by particular authors .Anovicemay want to know the prestigious conferences or experts of a re-search topic such as  X  X eb search X . In all these situations, we see keen needs from a user X  X  perspective to extend both query capabilities and search result richness.

Fortunately, the rich information among heterogeneous in-terrelated objects provide feasibility to satisfy users X  diverse information needs. In Figure 1, we show the interactions among heterogeneous entities: users, queries, Web pages, and words as following: users interact with queries by issu-ing ; queries interact with Web pages by referencing ;Web pages interact with words by containing ;andsoon. By leveraging all the interactions among heterogeneous entities, in this paper, we define and study a novel search problem: S earch H eterogeneous IN terrelated E ntities (SHINE) to ex-tend and generalize traditional searches. Specifically, to ex-tend query capabilities, a SHINE-query can be any combi-nations of entities in multiple types. To extend search result richness, SHINE retrieves and returns all types of heteroge-neous entities. For example, given a SHINE-query such as  X  X box X  with the type of word , the search results of SHINE consist of relevant users, Web pages, text-queries, and re-lated words. On the other hand, a user can input a Web page such as www.xbox.com as a SHINE-query to get rele-vant results consisting of all the four types of entities.
The functionalities of SHINE make such search services more desirable. Take literature search service as an example: Figure 1: Example of Heterogeneous Interrelated Entities. Each edge denotes a single interaction rela-tionship, which corresponds to a co-occurrence ma-trix.

However, the task of SHINE is challenging in the follow-ing aspects. (1) Different from traditional search problems which only deal with a single type of entities, the goal of SHINE is to search heterogeneous entities which are of mul-tiple types. It is not clear how to relate the same query to different types of entities. (2) There exist hidden semantics underneath all interactions among heterogeneous entities. Identifying the latent salient concepts is important to find semantically related entities. (3) In real applications, the entity number may be huge. As more and more entities emerge (e.g., entities in search log), the number of entities may increase dramatically. Thus the scalability becomes a big issue and an efficient solution to SHINE is more desir-able.

To the best of our knowledge, this problem has not been well studied in previous literature. In this paper, we first formally define the SHINE problem and then we propose a unified framework to address it. Two approaches are dis-cussed within this framework: Multiple-type Latent Seman-tic Analysis (M-LSA) [23] and Extended Vector Space Model (E-VSM). The first approach M-LSA is a generalization of traditional Latent Semantic Analysis (LSA) [12]. Its advan-tages include: (1) It can represent all heterogeneous objects in a unified space. (2) It conducts latent semantic analysis and identifies latent salient concepts underneath all hetero-geneous interaction relationships. The drawback of M-LSA is its inefficiency. Motivated by the unified representation of M-LSA, the second approach E-VSM is proposed as a very efficient solution to SHINE. E-VSM is an extension of the traditional Vector Space Model (VSM) and is shown to be linearly scalable in off-line indexing and sublinear in on-line searching. With the unified representation of hetero-geneous objects in E-VSM, important information retrieval techniques, ranking and feedback , can be incorporated natu-rally. As shown in [3], the essence of spectral methods is to conduct  X  X ocument expansion X . Feedback in our model is to conduct  X  X uery expansion X , which could achieve similar effects as document expansion. Thus combining feedback with E-VSM can help find semantically related objects.
To test the effectiveness of our proposed methods, we con-duct experiments on 3 data sets including a literature data set, a search engine log data set, and a recommendation data set. The experiments show that our SHINE formulation is very flexible and effective for different types of tasks.
The rest of this paper is organized as follows. We review the related work in Section 2. Section 3 is to formally define SHINE problem and we describe our unified framework in Section 4. Our system is described in Section 5. We adapt this system into 3 different tasks and conduct experiments in Section 6. Finally, we conclude this paper and discuss future work in Section 7.
Heterogeneous interrelated entities have attracted lots of attentions recently. For example, several recent work studies the effectiveness of clusterin g different types of objects by utilizing the interaction information [25, 22, 16, 4]. They find that the clustering results can be improved compared with the results when they only consider a single type of interaction relationship. Other work such as SimRank [14] measures the similarity between different objects by utilizing the interactions among heterogeneous objects. [23] proposes to conduct latent semantic analysis on these heterogeneous interrelated objects, which is a generalization of the work [11]. In this paper, we utilize the heterogeneous relationships among different types of entities to improve users X  search experiences.

PageRank [6, 18] and HITS [15] are the two earliest link analysis algorithms. They only consider a single type of rela-tionship (i.e., hyper-links) among homogeneous Web pages. Recent work such as [26, 17, 1] extends PageRank or HITS to consider the interactions among heterogeneous entities. All these algorithms focus on improving the estimation of entities X  static ranking, which is query independent. In con-trast, we are studying how to extend query capabilities and search result richness by utilizing the relationships among heterogeneous entities.

Instead of solely returning Web pages, several recent work proposes to answer search queries by a certain type of en-tities in a finer granularity [8, 9, 10]. For example, in [8],  X  X bject finder X  queries are defined to find the top K ob-jects that match a given set of keywords. Their algorithm first retrieves relevant documents and then relevant objects are ranked according to their relationship with the returned documents.  X  X xpert search X  track was initiated by TREC conference 1 recently and its task is to retrieve experts given a topic description. Our work is more general since all these work only considers retrieving a specific type of objects and the query can only be a set of keywords.

SHINE is also related to several commercial systems such as Google Scholar 2 and Citeseer 3 , when we apply our tech-nologies to the literature domain. A recent feature of Google Scholar is that it also provides an author list besides re-trieved papers given a query. This is a similar feature to SHINE in which authors are used to answer an input query. However, there is no public research about how they rank the authors. Furthermore, we are studying a more general problem which can also return other objects (e.g., confer-ences) and can be applied to data sets in other domains (e.g., search engine logs). In this section, we formally define our research problem: S earch H eterogeneous IN terrelated E ntities (SHINE). We first describe and model the data formally. Then we define the SHINE problem.
Suppose we have N types of objects { X 1 ,X 2 , ..., X N } each pair of them could have an interaction relationship. We model the objects and their interactions using a graph as defined in the following:
Definition 1 (Multiple-Type Graph). Amultiple-type graph G ( V, E ) consists of N vertices with the i -th vertex corresponding to the i -th type of entities X i .Iftwotypesof entities X i and X j have an interaction relationship, there is one edge e ij  X  E connecting the i -th and j -th vertices.
For example, in Figure 1, the corresponding graph G con-tains 4 types of objects: users, queries, Web pages, and words. We have 5 interaction relations in G and each of them is denoted by an edge in Figure 1. In general, all the interaction relationships can be represented as co-occurrence matrices with each entry measuring the correlation strength between two corresponding entities. For example, in infor-mation retrieval using the  X  X ag-of-words X  method, the in-teraction between words and documents is represented by a co-occurrence matrix with each entry measuring the word importance in the corresponding document [2]. In this way, each edge e ij in a multiple-type graph corresponds to a |
X i | X | X j | matrix M ij . In Figure 1, the 5 co-occurrence relationships correspond to 5 matrices and an example is also included in Figure 1. For a particular application, dif-ferent matrices may have different importance and we can associate a weight  X  ij with edge e ij to reflect its relative importance.

The multiple-type graph encodes the semantics of all the interactions among heterogeneous entities. Semantically re-lated objects may directly co-occur with each other or may co-occur via other types of objects. Take the literature search as an example, two researchers may be related be-cause they have co-authored papers. They can also be im-plicitly related because their papers are published in related http://trec.nist.gov/ http://scholar.google.com http://citeseer.ist.psu.edu conferences or their papers are on the same topics. Our task of SHINE is to exploit these interactions on a multiple-type graph to answer a query by semantically related data objects.
On a multiple-type graph, the task of SHINE is to retrieve all types of relevant objects given a query. In this section, we give the definition of a SHINE-query and the expected results in SHINE framework.

Definition 2 (SHINE-Query). Aquery Q in SHINE framework is an object of any type or a list of objects of multiple types. In general, Q := [ t i : ID i ] i =1 ..k the number of objects in query Q and [ t i : ID i ] means the type of the i -th object in Q is t i and its identifier is ID
For example, in literature search task, the query Q := [ author : Jiawei Han ; word : mining ] is a combination of two objects. The first object is an author and its identifier is Jiawei Han and the second is a word and its identifier is mining . Just as the  X  X ag-of-words X  method used in ad-hoc information retrieval, we can treat a SHINE-query Q as  X  X ag-of-objects X .
 Definition 3 (SHINE Results). Given a SHINE-query Q and a multiple-type graph G , the SHINE search results are several lists of relevant objects. All the objects in a list are of the same type and ranked by its relevance with respect to the query Q .

Table 1 presents a mock up result example of the given query Q := [ author : Jiawei Han ; word : mining ]inthe literature search task. Here we have 4 types of objects thus we have 4 lists. Each list is ranked according to the relevance of the objects with respect to the query Q . For example, the first conference is  X  X DD X  and the first keyword is  X  X attern X , which are the most relevant conference and the most relevant keyword to the query Q respectively. Table 1: An example of the SHINE search results in the literature search application.
 As we can see, the advantages of SHINE include: (1) SHINE provides more flexibility for users to specify the desired information by SHINE-queries which are not re-stricted to several keywords. We can add any type of ob-jects as components into SHINE-queries. For example, if a user only wants to know the  X  X ining X  papers published by  X  X iawei Han X , she can compose a query Q := [ author : Jiawei Han ; word : mining ]. (2) SHINE returns differ-ent types of entities which enrich the information of the search results and provide useful context for users to di-gest the information. This can also help to answer interest-ing questions such as:  X  X ho are the active researchers in SIGIR conference? X   X  X hat keywords can be used to an-notate a researcher or a conference such as CIKM? X  (3) SHINE search results also facilitate users X  information ex-ploration. For example, a user may refine her query from Q := [ author : Jiawei Han ; word : mining ]to Q := [ word : mining ; conference : KDD ] if she wants to know more along the conference dimension.

In the experiment part, we will build SHINE search ser-vices on a literature data set and a commercial search engine log data set. We will show that more interesting questions or information needs can be satisfied by our SHINE func-tionalities.
In this section, we propose a unified framework for search-ing heterogeneous objects. Within this framework, all het-erogeneous objects are represented in a unified vector space. Thus the relevance between any two objects (even in differ-ent types) can be measured in this space and the ranking and feedback techniques used in the traditional information retrieval can be incorporated in our framework naturally.
We first describe two approaches to represent heteroge-neous objects by utilizing the interactions among them: Multi-type Latent Semantic Analysis (M-LSA) based method and Extended Vector Space Model (E-VSM) based method.
In our previous work [23], M-LSA is proposed to conduct latent semantic analysis using interactions among hetero-geneous objects. Given a multiple-type graph G ,M-LSA is used to identify the most important concepts contained in the co-occurrence data. As a result, all heterogeneous objects are mapped into a low-dimensional semantic space. The importance of concepts are identified by the Mutual Reinforcement Principle (MRP): Formally, assume we have N types of objects on graph G : {
X 1 ,X 2 , ..., X N } . For any two types of objects: X i we have the co-occurrence matrix M ij ( M ij =0iftheedge e ij is absent on G ). Let us associate an importance value with each object. For the i -th type of objects in X i ,we have one weight vector w i to denote their importance. The mutual reinforcement pri nciple can be expressed as: where  X  ij reflects the relative importance of matrix M ij
Taking a unified view of the latent concepts, we use w = [ w 1 , ..., w N ] define as the unified co-occurrence matrix. We can rewrite Equa-tion (1) in a matrix format: It is easy to know that w will converge to the eigenvector of the co-occurrence matrix R .

In M-LSA, each w is regarded as a latent concept under-neath all the co-occurrence relations. Each entry in w cor-responds to an object and its value can be regarded as the association weight between the object and this latent con-cept. Similarly, the first k eigenvectors of R represent the top k most important concepts, which span a k -dimensional semantic space to represent all the objects. Specifically, let be the top k eigenvalues of R and the corresponding vectors are  X  gives precisely the salience of the corresponding concept vector c l (1  X  l  X  k ). Therefore, the i -th object can be represented by where c li is the i -th entry in c l (i.e., the association weight between the i -th object and the l -th concept). All the ob-jects can be represented in a matrix: with each row representing an object in the k -dimensional space.

M-LSA based method has the advantage of utilizing all the co-occurrence relations to capture the latent semantics on a multiple-type graph. Unfortunately, its computational cost is expensive because it involves solving an eigenvector problem of a matrix with dimension equal to the total num-ber of objects. This makes it difficult to apply M-LSA to large scale data sets.
Motivated by the unified representation of M-LSA, we propose an efficient method: Extended Vector Space Model (E-VSM). E-VSM is closely related to M-LSA in that it rep-resents all heterogeneous objects in a unified space. E-VSM is an extension of traditional vector space model. In traditional vector space model, given a term by document co-occurrence matrix A =[ a ij ], each document is repre-sented in a word space, which corresponds to a column vec-tor in A , and each word is represented in a document space, which corresponds with a row vector in A . To seek a uni-fied space to represent both documents and words, we  X  X on-catenate X  the two spaces spanned by words and documents and represent each object (document or word) by a unified longer vector. By filling zeroes in the missing dimensions of each object, we get a unified matrix 0 A A T 0 . However, this type of representations do not help since a word and a document have no overlapped dimensions with nonzero values, and thus their similarity score is still zero in this space. Clearly, we can replace the two 0 matrices by the co-occurrence information among documents and among words respectively. In the worst case where this co-occurrence in-formation is not available, we can still assume that an object co-occurs with itself by default, and thus replace 0 matrices by the identity matrix I .Weget: Each row in the upper part is a document representation vector and each row in the lower part is a word representa-tion vector.

On a multiple-type graph, each type of objects co-occur with other types of objects. Similar to the document and word representations, an object can be represented by sev-eral vectors. Each vector corresponds to a type of objects which co-occur with the considered object. Formally, given a multiple-type graph G with N vertices, the i -th type of ob-jects can be represented by the j -th type of objects via the co-occurrence matrix M ij . By concatenating all the matrix together, we can represent each object by a unified longer vector. We again can assume that each object co-occurs with itself by default. Then we obtain a new matrix U : In the unified matrix U , each object corresponds to a row vector. All the objects are represented in a unified space spanned by all the objects on the multiple-type graph G . Similar to M-LSA, we can associate an importance value  X  ij with each matrix M ij and thus transform U toaweighted matrix E-VSM is closely related to M-LSA. In fact, the following Theorem 1 describes their relation.
 Theorem 1. Matrix U in Equation (6) and matrix R in Equation (2) have the same eigenvectors.

Proof. It is easy to show that U = I + R . Suppose c i is an eigenvector of R with eigenvalue  X  i ,wehave R  X  c i =  X  Thus U  X  c i = c i + R  X  c i =(1+  X  i )  X  c i . This shows that c is an eigenvector of U with eigenvalue 1 +  X  i . Similarly, it can be shown that eigenvectors of U are also eigenvectors of R .

Both M-LSA and E-VSM represent all the objects in a unified space. From Theorem 1, we know that M-LSA is the representation of E-VSM in a latent semantic space, and thus a potentially better representation. There are several advantages in a unified space: (1) Since all the objects are represented in the same space, we can calculate the simi-larity between heterogeneous objects. (2) This representa-tion considers multiple and complementary information on G and thus can measure the similarity between objects more accurately. (3) This can facilitate to incorporate the useful techniques such as ranking and feedback used in the tradi-tional information retrieval into SHINE and we will discuss this in the next section.
One of the most important techniques in information re-trieval is ranking [21]. Given a text-query consists of sev-eral words, documents are rank ed according to the similar-ity scores between the documents and the query. We define the similarity measure for the unified representations in this section. Later we will show that the traditional VSM is a special case in our definition.

Since each object is represented in a unified space, a straight-forward way to define the similarity is the inner product or cosine score of two vectors. In the following, we will only use inner product as the similarity measure since cosine sim-ilarity can be defined similarly. Specifically, the similarity between two object vectors o 1 and o 2 is: where o 1 ,l ( o 2 ,l )isthe l -th value in o 1 ( o 2 ).
Given a query Q := [ t j : ID j ] j =1 ..k in SHINE framework and let o j be the object vector corresponding to the j -th object in Q , the similarity between Q andanobjectvector o is calculated as: It is easy to show that Sim ( Q, o )= S ( q , o )where Thus we can regard q as the vector representation of Q in the unified space.

All the objects can then be ranked according to their sim-ilarity defined in Equation (8). Since each object bears a type, we can separate the ranked list according to their types and thus obtain the SHINE results as defined in Definition 3.
An important and effective technique to improving the re-trieval performance is feedback. We show that our object representation can incorporate feedback to conduct query expansion naturally. As discussed in [3], the essence of spectral methods like LSA is to conduct  X  X ocument expan-sion X  implicitly. In our E-VSM, feedback is used to conduct  X  X uery expansion X  and thus could achieve similar effects as document expansion. Therefore, combining feedback with E-VSM can help find semantically related objects. Specif-ically,supposethatwehaveasetofrelevantobjects, C , which are either judged by users or the top retrieved results as in pseudo feedback [7], the expanded query vector  X  q of q is calculated similarly to the Rocchio method [19]: where  X  and  X  are the weighting factors. By considering the different types of objects in C , the expansion can be improved as: where C i is the i -th type of feedback objects and  X  i is its feedback weight. We add a constraint N i =1  X  i =1. Since  X  q is still in the unified space, we can use the expanded query to retrieve and rank all the objects again to get refined results.
We have incorporated the ranking and feedback techniques into our proposed method. Both are extended from the tra-ditional information retrieval techniques naturally since we represent all types of objects in a unified space.
In the traditional VSM, there are two types of objects involved: words and documents. In E-VSM, the unified ma-trix is the same as the matrix U in Equation (4). Therefore, the i -th word has a vector w i and the j -th document has a vector d j in the unified space. Suppose we have m words and n documents, then
Given a query Q which have k words, let w i ( r ) be the vector corresponding to the r -thwordinthequery. Then, according to Equation (8), we have The last step is based on Equation (12). Since U is symmet-ricinEquation(4),wehave d j,i ( r )+ n = w i ( r ) ,j ,whichisthe co-occurrence frequency of i ( r )-th word in j -th document. We have Thus it is the dot product between the query vector and doc-ument vector in a space spanned by words, which is the tra-ditional similarity score used in vector space model. There-fore, the traditional vector space model is a special case of E-VSM. If we have co-occurrence information within doc-uments or co-occurrence information within words, we can incorporate this information into our framework straightfor-wardly. For example, the hyperlinks between Web pages can be regarded as co-occurrence information among Web pages and can be incorporated into our method easily.
We develop a general architecture for SHINE. Different applications can be adapted with little modification. Fig-ure 2 gives the sketch of our system. It basically involves two parts: offline indexing and online searching. In the of-fline indexing part, the first step is to extract different co-occurrence relationships from the raw sources such as search engine logs. After we get each co-occurrence data, the next step is to build the unified indexing and push the the data to a repository. This step is the key step for the offline indexing part. We first build a unified dictionary to map each object string to a unique identifier. Then we go over this dictionary and build the representation of each object by iterating over all its co-occurred objects. We keep the type identity by assigning each object a type indicator. After this, we index all the objects and store the index into the repository. For the online searching part, the search interface accepts users X  input, composes the input as a bag of objects, and sends it to the retrieval and ranking component. The retrieval com-ponent ranks all the objects according to their similarities to the SHINE-query. Since each object has a type indicator, the ranking component then separates the returned objects into different ranking lists and returns them to end users.
An snapshot of our system interface on literature data is given in Figure 3. In this figure, we have several input boxes where users can input objects of different types as queries. For example, the users can input a keyword, a conference, or an author, as a SHINE-query. The returned results include papers, authors, conferences, and keywords. Each type of returned objects are ordered by their relevance to the SHINE-query. To facilitate users X  information explo-ration, we embed a hyperlink under each object descriptor. If a user clicks on a hyperlink, the system will automatically take the corresponding object as a new SHINE-query and return its corresponding results.
In this section, we conduct experiments to show the flex-ibility and effectiveness of our SHINE framework. We use three different data sets for ex periments: a literature data set, a commercial search engine log data set, and a recom-mendation data set. We use E-VSM model as our solution to SHINE since these data sets are large.
Organizing and searching literatures motivate the devel-opment of digital libraries such as ACM and IEEE Digital Libraries 4 and search engines such as Citerseer and Google Scholar 5 . In literature domain, researchers always want to find relevant and authoritative publications. In general, sev-eral different methods are used, including typing some key-words to a literature search engine, going to a well-known researcher X  X  publication page, or going to a conference pro-gram page, to find relevant publications. Indeed, researchers implicitly try to find their paper objects using other objects such as keywords, authors, and conferences, as queries. In this section, we show that we can integrate all these different  X  X ethods X  in our unified SHINE framework.
 Figure 4: The multiple-type graph of literature data
The data set we use in this experiment is the DBLP data set 6 , which has information of all papers published by ma-jor computer science conferences. In this data set, each paper has an entry including its title, authors, published conference, and published year, etc. We define 4 types of objects for this data set: papers, authors, conferences, and keywords. The corresponding multiple-type graph is shown in Figure 4. In this data set, we have 463,931 pa-pers, 350,538 authors, 2,957 conferences, 78,349 keywords, and thus 895,701 objects in total. Based on the multiple-type graph, we represent each object in a unified space by E-VSM model using Equation (6). We set all  X  ij  X  X  to 1 in this experiment. http://www.acm.org, http://www.ieee.org http://citeseer.ist.psu.edu, http://scholar.google.com available from http://dblp.uni-trier.de/xml Table 2: Results for SHINE-query  X  X onference:-SIGIR X  Table 3: Results for SHINE-query  X  X uthor:-ChengXiang Zhai X  The interface for literature search is shown in Figure 3. This interface allows users to input SHINE-queries with dif-ferent types of objects and the system can answer users X  queries with multiple types of objects. These functionali-ties can satisfy several interesting information needs such as  X  X hat is the most famous researchers in SIGIR confer-ence? X   X  X hat are the representative keywords to describe a researcher?  X  and etc.

We show several representative cases in Table 2 and Ta-ble 3. Due to the space limit, we did not show the returned papers in these results. In Table 2, our query is  X  X IGIR X  of conference type. We can see the first researcher is  X  X ruce Croft X  and the relevant words include  X  X nformation X ,  X  X e-trieval X , and  X  X uery X . All these words accurately describe the research focus of  X  X IGIR X  conference. The similar con-ferences to SIGIR are  X  X REC X ,  X  X IKM X , and  X  X CIR X , etc. All these are very meaningful. In Table 3, we show the results when the SHINE-query is  X  X hengXiang Zhai X  of au-thor type. We can see that all the returned words and con-ferences provide useful information to know the research in-terests of this researcher. This confirms the effectiveness of our solution to SHINE. Furthermore, SHINE can also fa-cilitate users X  information exploration. For example, a user may first issue  X  X IGIR X  as a query along the conference di-mension. After reading the results, she may want to know Table 4: SHINE results for  X  X box 360 X  of text-query type more about researcher  X  X hengXiang Zhai X  and issue this as a SHINE-query with author type. All these can be easily satisfied by SHINE and the results will change from Table 2 to Table 3.
Search engine logs contain useful information about the interactions between Web users and search engines, and have been studied intensively for various applications. For exam-ple, search engine companies want to provide better services for advertisers in order to help them bid high quality adver-tising keywords; Web masters hope to provide personalized contents to their users; and general users want to get assis-tance to formulate better queries. In this section, we apply SHINE to click-through log data to satisfy the above needs.
Search engine logs generally have the following informa-tion: at what time, which user submit what query and visit what pages [24]. In our experiment, we do not consider the time information. For privacy concern, we do not include user information either. Thus we have 3 types of objects in this experiment: text-queries, Web pages, and words. The multiple-type graph in this application is a triangle with 3 vertices and 3 edges.

Our click-through log data is a sample from one month X  X  log data of a commercial search engine. After preprocess-ing, we have 1,161,248 text-queries, 2,044,147 pages, and 252,102 words. In Figure 1, their exists a containing re-lation between pages and words. An intuitive way to build this relation is to use the contents of pages. In order to avoid crawling all the Web pages, we build this relation by pooling all the text-queries which refer to a certain page together as the pseudo-content of this page. Therefore, the log data is enough for us to build all the 3 co-occurrence relationships in this application. We again set all  X  ij  X  X  to 1.
The interface for this application is similar to the one shown in Figure 3. Users can also exploit this search en-gine to answer various interesting questions. As illustrated in Table 4 and Table 5, given t he input  X  X box 360 X  of text-query type, the top returned text-queries include  X  X box X ,  X  X icrosoft xbox 360 X ,  X  X box.com X , and etc; the top re-turned Web pages include  X  X ww.microsoft.com/xbox X  and  X  X ww.xbox.com X , etc. Given the i nput  X  www.mapquest.-com X  of Web page type, the related text-queries, Web pages, and keywords are shown in Table 5. All these show the effec-tiveness of SHINE and can indeed facilitate the information Table 5: SHINE results for  X  X ww.mapquest.com X  of Web page type Table 6: 30 SHINE-queries composed from search logs: 10 with text-query type, 10 with Web page type, and 10 with word type. needs of general users, Web masters, and advertisers as we discussed above.

In order to evaluate SHINE X  X  search accuracy, we select 30 SHINE-queries from our log data: 10 of text-query type, 10 of Web page type, and 10 of keyword type. All these SHINE-queries are listed in Table 6. For each SHINE-query, we have 3 lists of objects in SHINE search results (e.g., Ta-ble 5). To evaluate these results, human subjects are asked to judge each returned object given a SHINE-query. We use precision at N documents (P@N) and let N range from 1 to 10 for evaluation. The results are shown in Figure 5. In this figure, the  X  X verage X  line corresponds to the evaluation on all the 90 groups of search results.  X  X ext-query type input X ,  X  X eb page type input X , and  X  X ord type input X  correspond to the evaluation result when text-queries, Web pages, and words are used as input type respectively. From Figure 5, we can see that our solution to SHINE is quite promising: The average P@1 is 93.1% and P@10 is 75.8%. For SHINE-queries with different types, most of P@N X  X  are larger than 70.0% and this shows that E-VSM is an effective model to handle different SHINE-queries.
In this section, we show that traditional Collaborative Fil-tering (CF) can also be modeled in our SHINE framework. In CF, there are two types of objects: n users and m items. The task of CF is to recommend items to an active user based on a historical user by item rating matrix R =[ r ij with r ij being the rating value of user i to item j .Inthe SHINE framework, we regard C F as to retrieve (recommend) items given a user as SHINE-query. We will show that our SHINE framework can model user-based CF [13], item-based CF [20], and also their combination. In this paper, we use SHINE-CF to denote CF in our SHINE framework. Figure 5: P@N of SHINE results on click-through logs with 30 SHINE-queries.
Given an active user, user-based CF first finds its simi-lar users and then recommends items based on these similar users [13]. The most popular method to calculate the simi-larity between two users v and u is Pearson correlation: where m is the number of items, r v,i ( r u,i ) is the rating of user v ( u )foritem i ,and  X  r v (  X  r u ) is the average rating of user v ( u ). w v,u is the similarity score between the two users. We use N v to denote the set of selected nearest neighbors for v , then the prediction of v  X  X  rating for an unseen item i is calculated as and the items with the largest prediction values are recom-mended to user v .

Item-based CF [20] is to first find similar items for each of the items that the active user rated. Then the recommen-dation score of a given item i is computed as
The Pearson correlation is indeed the cosine score between two vectors if we transform r v,i of R by r v,i  X   X  r v , and thus obtain the matrix  X  R . We compose the unified matrix in SHINE as Given a user as a SHINE-query, SHINE-CF is to retrieve both similar users and similar items with cosine similarity. It is easy to verify that in the unified space defined in Equa-tion (16), the similarity between two users v and u is the same as w v,u in Equation (13). The retrieved items are those which have been rated by the current user. In the sec-ond step, we do the feedback to modify the SHINE-query using Equation (11) and then only retrieve items. If we only use retrieved users in feedback (denoted as user-based method in the following), SHINE-CF will be the same as user-based CF. If we only use retrieved items in feedback (denoted as item-based method in the following), SHINE-CF will be similar to item-based CF. Apparently if we use Figure 6: The impact of number of feedback objects in SHINE-CF Figure 7: The impact combination parameter in SHINE-CF both users and items in feedback, we can combine these two methods together. In the following experiment, we will show that the combination can help improve the recommendation accuracy.

We use half-time utility metric to evaluate the recommen-dation accuracy [5]. For a user v , the expected utility of a ranked list of items is: where  X  is the half-time parameter (  X  = 5 in our experi-ments) and r v,j is v  X  X  rating for the item which is at the j -th position in the current rank list. The final score over all users in the test set is: where R max v is the maximum possible utility obtained when all test items are ranked at top according to user v  X  X  rating.
We use the benchmark MovieLens 7 data set to compare different methods. Figure 6 shows the impact of number of objects used in feedback on both item-based method and user-based method in SHINE-CF. The best result of user-based method is achieved when the number of feedback objects is 60 and the best result of item-based method is achieved when the number is 40.

In Figure 7, we combine both item-based and user-based method by a parameter  X  and we vary  X  from 0.0 to 1.0 with step 0.1. When  X  = 0, it is the item-based method and when  X  = 1, it is the user-based method. Clearly, the http://www.grouplens.org/ Figure 8: The offline indexing and online searching time with respect to the data size combination can improve the recommendation utility. We get the best result when  X  =0 . 6. The combination method achieves relative improvement 7 . 2% over item-based method and 3 . 5% over user-based method.
In this section, we study the efficiency of our SHINE so-lution. In particular, we study the average offline indexing and online searching time in our E-VSM model.

In this paper, we study the scalability of SHINE and re-port the experiment results on the search engine logs. We preprocess a large scale data set which contains 2,643,752 queries, 4,275,622 Web pages, and 6,888,081 words. In or-der to investigate the scalability of our method, we randomly select a certain percentage of the objects (from 20% to 100% with step=20%) from the whole data set to measure the av-erage offline indexing and online searching time. The results are shown in Figure 8. We measure the offline indexing time by second and the online searching time by millisecond. The online time is the average time of 500 SHINE-queries ran-domly selected from our search logs. From Figure 8, we can see that the offline indexing time is linearly increasing with the data size. The online time is approximately sublinear. For example, when we increase the data size from 80% to 100% (25% relative larger), the average time increases from 357 to 373 ms (5% relative slower). These confirm that E-VSM is an efficient solution to the SHINE problem.
In this paper, we define and study a novel search problem: search heterogeneous interrelated entities (SHINE). Com-pared with traditional search services, both the query ca-pability and the search result richness are extended in our SHINE framework. We discuss and compare two methods, M-LSA and E-VSM, in this paper. Experiments with E-VSM on three data sets (a literature data set, a search en-gine log data set, and a recommendation data set) show the effectiveness and flexibility of our SHINE framework.
SHINE is a promising framework and there are several natural future work. First, we only focus on the query de-pendent relevance based ranking in this paper. In the future, we will study how to better combine it with link-based static ranking to further improve the search results. Second, we set matrix weights  X  ij  X  X  to 1 in our experiments. It would be interesting to study how to set  X  ij  X  X  automatically and a compelling method that we will study is to use machine learning techniques to learn these weight parameters.
