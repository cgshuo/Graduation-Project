 In some IR applications, it is desirable to adopt a high preci-sion search strategy to return a small set of documents that are highly focused and relevant to the user X  X  information need. With these applications in mind, we investigate se-mantic search using the XML Fragments query language on text corpora automatically pre-processed to encode seman-tic information useful for retrieval. We identify three XML Fragment operations that can be applied to a query to con-ceptualize , restrict ,or relate terms in the query. We demon-strate how these operations can be used to address four dif-ferent query-time semantic needs: to specify target informa-tion type ,to disambiguate keywords ,to specify search term context ,orto relate select terms in the query. We demon-strate the effectiveness of our semantic search technology through a series of experiments using the two applications in which we embed this technology and show that it yields significant improvement in precision in the search results. H.3 [ Information Storage and Retrieval ]: Information Search and Retrieval Languages, Experimentation Semantic Search, XML Retrieval, Question Answering
In some IR applications, in particular those in which search results are directly presented for user consumption, it may be highly desirable to employ a search strategy that strongly favors precision at the possible cost of a loss in recall. Take, Copyright 2006 ACM 1-59593-369-7/06/0008 ... $ 5.00. for example, an intelligence analyst trying to find out whether there is nuclear technology transfer between North Korea and Syria. It may be preferable for a system to present to the analyst (at least initially) a small set of documents to confirm incidents of such technology transfers, than to re-turn a much larger and noisier document set from which a list of all transfers of this nature can be compiled.
With this class of applications in mind, we investigate, on unstructured text documents, the use of semantic search techniques, which have primarily been adopted in search on the Semantic Web or in collections of highly structured XML documents (cf. [7, 4]). Rather than rely on document authors to encode semantic information as metadata, we employ automatic named entity and relation recognizers to pre-process text corpora and identify the semantic informa-tion we intend to leverage to improve search performance.
In our applications, there are some frequently-occurring query-time semantic needs, such as specifying target infor-mation type , disambiguating keywords , specifying search term context ,and relating select query terms . To construct high-precision semantic queries to address these needs, we adopt the XML Fragments query language [3] because of its expres-siveness and the availability of a search engine that supports the query language. In a nutshell, XML Fragments allow XML tags to surround query terms as a way to constrain the semantics of those terms. We identify three XML Fragment operations that can be applied to a query to conceptualize , restrict ,or relate termsinthequery,andwedemonstrate how they can be utilized to address our query-time seman-tic needs. Since these operations constrain the underlying query, it is expected to yield more focused and more precise search results. Obviously, the impact of these operations on the precision and recall of retrieval results is directly affected by the accuracy of the named entity and relation recognizers used to analyze the corpus. In the case of perfect annota-tion, there should be a significant increase in precision with no loss in recall. We show that even in the face of imperfect annotations, our experiments yield significant improvement in precision in the search results.

The rest of the paper is organized as follows. Section 2 gives a brief overview of XML Fragments, while Section 3 de-scribes how we pre-process our corpora to encode semantic information. In Section 4 we discuss the three XML Frag-ment operations and their four use cases. Section 5 presents experimental setup and results. Finally, we discuss related work and conclude. &lt;
Book &gt; &lt; /Book &gt; &lt;
Book &gt; &lt; /Book &gt;
XML Fragments were initially developed to enable view-ing and editing of parts of an XML document [6]. [3, 2] introduced the idea of using XML Fragments as a document-centric means to specifying queries for searching XML docu-ments and showed it to be sufficiently expressive to address most information needs in multiple domains. In this section we give a brief overview of the subset of the XML Fragments query capabilities relevant to the discussion in this paper.
Consider a canonical example on the retrieval of book in-formation encoded as XML documents in Figure 1. The XML Fragment query [[ &lt; Book &gt; Bill Clinton &lt; /Book which allows Bill and Clinton to appear anywhere inside a Book tag, retrieves both documents, while [[ &lt; Book &gt;&lt; document. In the above and subsequent examples, we de-note the boundaries of XML Fragment queries with double square brackets ( [[...]] ) for better readability.
In addition to XML tags, XML Fragments support classi-cal operators such as  X + X ,  X  X  X , and phrase . The phrase oper-ator applies to content within XML tags, such as [[ &lt; Title  X  X hite House X  &lt; /Title &gt; ]] , while  X + X  and  X  X  X  apply also to XML Fragments themselves. For example, [[ &lt; Book &gt;&lt; retrieved have titles containing Clinton , while [[ &lt; + books with publication dates in their records. Additionally, the language supports numeric comparison operators repre-sented as XML tags. For instance, [[ &lt; Book &gt;&lt; PubDate &lt; .GE. &gt; 1999 &lt; /.GE. &gt;&lt; /PubDate &gt;&lt; /Book books published in or after 1999. For further details on the XML Fragment query language, see [3].
Much of the effort in the document-centric view of XML search has focused on developing query languages and search methodologies for the retrieval of XML documents, an ex-ample of which was discussed in the previous section. While this search paradigm has been shown to be effective in re-Figure 2: Sample Excerpt From Clinton X  X  Biography
Figure 3: Sample Annotations of Text in Figure 2 trieving existing XML documents where the semantics of text segments are clearly encoded, the majority of electronic documents available today are significantly less structured than the examples shown in Figure 1. We believe that XML search can be more broadly applicable if existing unanno-tated documents can be automatically processed to include useful semantic information which can subsequently be used to improve search results. In particular, we are interested in annotating semantic information, such as named enti-ties and relations, that can be reasonably reliably extracted from text, and in exploring alternative ways in which this semantic information may be exploited by XML search to improve retrieval performance. For example, Figure 3 shows how the unstructured text in Figure 2 may be annotated with named entities, such as Person , Date ,and College ,and relations, such as BirthDateOf and AlmaMater , of general interest (some annotations are omitted for space reasons).
There are ample techniques and systems in the area of in-formation extraction for creating named entity and relation annotations analogous to those shown in Figure 3 (cf. [1, 19]). In this paper, we will focus on the alternative ways in which we exploit the XML Fragment query language to perform semantic search over a text corpus pre-processed with a set of named entity and/or relation annotators. We assume that the annotators adopt a common type system, and that the annotations, along with lemmatized terms in the corpus, are stored in the search index. This technique is an extension of Predictive Annotation in [15] and of [14].
In our work, we focus on enriching query expressiveness to address four query-time semantic needs and to yield higher precision search results. We have identified three operations for this purpose that one may apply using the XML Frag-ment query syntax with its classical operators [2]:  X  The conceptualization operation, which generalizes  X  The restriction operation, which constrains the XML  X  The relation operation, in which the annotation rep-
Using XML Fragments to enable the conceptualization, restriction, and relation operations allows us to enhance the expressiveness of user queries and to obtain better search re-sults. We have utilized these three operations to express four different query-time semantic needs, i.e. to specify target in-formation type, to disambiguate keywords, to specify search term context, and to specify relations between select terms, which we discuss in detail in the following sections. Note that the ways we applied the operations place additional constraints on the queries compared to keyword queries, thus we expect them to result in more focused, higher pre-cision queries at the possible expense of recall. 1
Another application of the conceptualization operation cor-responds to walking up a hierarchy to generalize concepts in the query, resulting in a more recall-oriented query. We do not address this use of the operation in this paper. The conceptualization operation, indicated by the XML that explicitly specify the semantic type of the information the user is seeking. The inclusion of the target information type ensures that each returned document contains some in-formation of the target type that could potentially satisfy the user X  X  information need. This capability is particularly useful when 1) the query consists of low idf keywords, and 2) the target information does not frequently co-occur with these keywords. For example, suppose the user wants to find the zip code for the White House. In a typical newswire corpus, the query  X  X hite house X  will retrieve a large num-ber of documents. However, few, if any, of them are likely to mention its zip code, which co-occurs with the search terms fairly infrequently. Adding  X  X ip code X  to the query is unlikely to improve the results as the most common con-text in which the correct answer is mentioned is as part of the address: The White House, 1600 Pennsylvania Av-enue NW, Washington, DC 20500, without explicit indica-tion that 20050 represents the zip code. 2 On the other hand, the query [[+ X  X hite house X  + &lt; Zipcode &gt;&lt; /Zipcode only retrieve documents containing both  X  X hite house X  and a Zipcode annotation. This query will successfully retrieve documents containing the above sentence, assuming 20050 was annotated as a Zipcode , a fairly straightforward task given the regularity of most street address expressions.
In addition to the zip code example, target information types suitable for this operation include, for instance, Pho-neNumber , StreetAddress , URL ,and Date where the lexical formats of the target strings for the most part unambigu-ously identify their semantic types. Thus, they are often not cued by relevant keywords that would facilitate their re-trieval. Without the conceptualization operation, it would be difficult, if not impossible to locate such information in a large corpus. In other cases, information may equally likely be expressed in textual description or through an estab-lished convention. For instance, one may say  X  X ohn Gr-isham X  X   X  X he Testament X  (1999) was a bestseller. X  Here be-ing able to recognize  X 1999 X  as a PubDate enables retrieval of those documents where publication dates are expressed in this convention and which would otherwise be difficult to retrieve.

We have utilized this capability of specifying target infor-mation type in two applications. The first is the Semantic Analysis Workbench (SAW) for exploring different search paradigms, one of which supports semantic search with con-ceptualization capability [11]. In the SAW, the user can include desired concepts in the query to focus search either selecting tag from a dropdown list of available types. The second application is an open-domain question answering (QA) system in which the concept included in the query represents the semantic type of the answer the user is seek-ing [15]. In this system, the search query is automatically generated after the user X  X  question is analyzed to deter-mine, among other things, the answer semantic type and the salient terms in the question. For instance, the ques-tion  X  X hat is the telephone number for the University of
In our reference corpus of one million news articles, the queries + X  X hite house X  combined with either + X  X ip code X  or +zipcode yielded empty hitlists. Kentucky? X  results in the following XML Fragment query: [[+ &lt; PhoneNumber &gt;&lt; /PhoneNumber &gt; + X  X niversity of Ken-tucky X  X ] , while  X  X ow long is the Rio Grande? X  yields [[+ &lt; Length &gt;&lt; /Length &gt; + X  X io Grande X  long]] .
The restriction operation can be applied to disambiguate terms based on their word senses, thus focusing search to-ward retrieving documents more likely to match the user X  X  information need. This operation is particularly useful when the query terms have multiple senses in the corpus and when either the senses are fairly evenly distributed or when the user intends a minority word sense. For example, the string  X  X ictoria X  can be annotated as a City (city name in many countries), County (county name in a few countries), State (in Australia), Person (as a first name), Royalty (British Queen), or Deity (Roman goddess). In order to focus search on specific interpretations of  X  X ictoria X , for instance as a city or royalty, we can use the restriction operation to dis-ambiguate the search term by generating the query [[ &lt; Victoria &lt; /City &gt; ]] or [[ &lt; Royalty &gt; Victoria spectively. Our use of the restriction operation here can be viewed as a coarser grained application of WSD in IR adopted by earlier systems (cf. [13, 17]).

One may argue that in some cases, inclusion of extra dis-ambiguating keywords can yield similar search results with-out the XML Fragment disambiguation capability. For ex-ample, the query +city +Victoria is likely to steer search re-sults in the same direction as [[ &lt; City &gt; Victoria and similarly +Queen +Victoria maybeusedinlieuof [[ observation with respect to these examples where very spe-cific information is sought; however, we maintain that our semantic search approach offers a more desirable solution than the use of disambiguating keywords in that it 1) pro-vides a uniform query representation, 2) eliminates the need for query-time keyword selection for disambiguation, and 3) enables higher precision query with potentially lower loss in recall. We illustrate these advantages by way of the following example. Suppose a user is interested in finding out about geographic locations named  X  X ictoria X . With XML Frag-ments, formulating a query involves finding the semantic type in the type system that covers all geographic entities, in this case, GPE (GeoPolitical Entity). This results in the query [[ &lt; GPE &gt; Victoria &lt; /GPE &gt; ]] which is analogous in form to the semantic query representing the city of Victoria. On the other hand, without using the restriction operator, it is up to the user to come up with a list of geographic  X  X nits X  for disambiguation and to construct a query such as [[+Victoria + &lt;&gt; city state county &lt; / &gt; ]] . search, this burden of knowing what kinds of location Vic-toria can be is shifted to the developers of the named entity recognizers (the domain experts) and to inferences within the type system ( city , state and county are all subtypes of GPE ). Furthermore, requiring disambiguating keywords as in the example above may result in a loss in recall when the keywords selected by the user is incomplete or when the ge-ographic  X  X nit X  of  X  X ictoria X  is implicitly conveyed in the document (e.g.,  X  X ictoria, British Columbia X ).

We employed the restriction operation for disambiguation in the same two applications described in the previous sec-
The empty tags represent a disjunction. In this case, one of city , state ,or county must occur in the document. tion. In the SAW, the semantic search paradigm also sup-ports the restriction operation for disambiguation. This ca-pability is useful in this end user application when the user enters a keyword query and, upon examining the search re-sults, discovers that a large number of irrelevant documents are returned because a keyword is ambiguous in the target corpus. The user can then refine the original query and for-mulate a disambiguating XML Fragment query using the re-striction operator, resulting in a set of documents that better addresses his information need. In the QA application, our named entity recognizer is invoked during the question anal-ysis process and the restriction operation is applied to all keywords/phrases found to be potentially ambiguous. For example, for the question  X  X hen was George Washington born? X  , the disambiguating XML Fragment query (with lem-matized keywords) [[+ &lt; Date &gt;&lt; /Date &gt; bear + +George +Washington &lt; /Person &gt; ]] eliminates matches with &lt;
College &gt; George Washington University &lt; /College &gt; &lt;
Facility &gt; George Washington Bridge &lt; /Facility &gt;
In addition to being used for keyword disambiguation, the restriction operation can also be used to specify the context in which keywords should occur. In this case, the XML tags surrounding a keyword are not used to identify the mean-ing of the keyword, but are used to specify meta information which will be difficult, if not impossible, to express with key-word queries. Such meta information represents the context of the keyword and may include syntactic information ( Sub-ject/Object ), semantic information ( Agent/Patient ), and dis-course information ( Request/Suggest ).

There is growing interest in identifying and retrieving texts along the fact versus opinion dimension as well as the strength and polarity of opinions (cf. [23, 24]). The identifi-cation of opinion texts sets the context for the words appear-ing in these texts. With proper query support, this in turn enables the user to retrieve documents where keywords ap-pear in particular contexts, for instance, the war on Iraq be-ing discussed in a positive light or as part of a negative opin-ion about US foreign policy. A sample query to retrieve rel-evant documents using XML Fragments in this setting may be [[ &lt; PositiveOpinion &gt;  X  X ar on Iraq X  &lt; /PositiveOpinion Note that although this query is syntactically equivalent to the previous case in which XML Fragments are used for keyword disambiguation, in this case, the semantic tags are used to specify the context in which the keywords occur, and regardless of context, the phrase  X  X ar on Iraq X  is un-ambiguous and refers to the same event.

In our work on the AQUAINT 2005 opinion pilot, the goal was to establish a baseline performance for the task without making use of opinion-specific annotations. Our approach was based on the observation that many opinions in docu-ments are expressed as direct quotes from a person X  X  speech, which are annotated by our existing named entity recognizer with the semantic type Quotation . Thus by setting the con-text of the subject matter to appear within a Quotation in the query we are targeting a select subset of all opinions regarding the subject matter, i.e., those expressed in di-rect speech. For example, for the following question, taken from the opinion pilot test set,  X  X hat was the Pentagon panel X  X  position with respect to the dispute over the US Navy training range in the island of Vieques? X  , our system gen-erates the following XML Fragment query which includes the identified opinion holder and the subject matter con-strained in the context of a Quotation : [[+Pentagon +panel + &lt; Quotation &gt; +US +Navy training range island +Vieques &lt; /Quotation &gt; ]] . We recognize that our attempt to increase precision may result in a loss in recall, as our approach tar-gets only opinions expressed as direct speech. We also note that we do not require that there be any connection, other than textual proximity, between the opinion holder and the subject matter, which is a potential loss in precision. 4
The relation operation can be used to express relations that must hold between query terms. These relation queries are inherently more precise than keyword queries because of this added constraint. For example, to find out about the bi-ological weapons Iraq owns, the following XML Fragment re-lation query may be constructed: [[ &lt; WeaponOwner &gt; + &lt; BioWeapon &gt;&lt; /BioWeapon &gt;&lt; /WeaponOwner &gt; document matches this query if it contains a text span which is annotated as WeaponOwner and contains the term Iraq and an embedded text span annotated as BioWeapon .As would be expected from text search queries, the terms within the relation annotation are neither order nor type specific (unless specified), so [[ &lt; Visit &gt; Mary Sue &lt; /Visit retrieve documents in which Mary visited Sue, Sue visited Mary, Mary Sue (one person) visited some person or place, or some person visited Mary Sue, among others.

As in the case for using the restriction operation for disam-biguation, the use of the relation operation has one key ad-vantage in that it shifts the burden of synonym expansion as a query-time process performed by the user or search engine to the relation annotator development process. For example, while it is reasonable to suggest that, without the relation operator, the user or search engine frontend may expand an initial query such as [[+Iraq + &lt; BioWeapon &gt;&lt; /BioWeapon +own]] into [[+Iraq + &lt; BioWeapon &gt;&lt; /BioWeapon &gt; own have possess &lt; / &gt; ]] , it is much less likely that either would come up with a query that would retrieve the sen-tence The UN weapons inspection team confirmed the exis-tence of Iraq X  X  anthrax stockpile . This is because using the term stockpile to denote ownership is specific to this appli-cation domain, and thus we believe that the task of making the link between them explicit is best left to the domain expert involved in annotator development.

A natural question that arises with using XML Fragments to express relations is, once the relations are annotated in the corpus, why not extract all relations and their argu-ments and store the triplets in a database for efficient re-trieval? This approach has been taken by many researchers, including [11, 7], and we argue that both approaches have their merits. While SQL queries are more precise and po-tentially more efficient than text search, our approach of us-ing XML Fragments for relation queries offers more flexibil-ity and can retrieve relevant documents/relations that SQL queries against a database recording extracted relations can-not. The key difference is in that a database records only the extracted relevant information, i.e., relations and their arguments, while the semantic search index records the be-gin and end offsets of relations with complete information
This issue can be remedied by specifying a relation between these two entities using the relation operation discussed in the next section. We leave developing such a relation anno-tator and utilizing the resulting annotations for future work. over the text spans they cover. For example, in our system Iraq possesses 33kg of 80 percent enriched uranium is anno-tated as &lt; WeaponOwner &gt;&lt; Nation &gt; Iraq &lt; /Nation sesses 33kg of 80 percent &lt; NucWeaponAgent &gt; enriched ura-nium &lt; /NucWeaponAgent &gt;&lt; /WeaponOwner &gt; .Fromthe WeaponOwner annotation, a record for the database would contain the relation name, WeaponOwner ,aswellasitstwo arguments, Iraq and enriched uranium , thus losing the addi-tional information 33kg and 80 percent . 5 Using XML Frag-ments, the following query (with lemmatized keywords) can retrieve documents, including the above example, stating that Iraq possesses uranium that is 75 percent enriched or higher: [[ &lt; WeaponOwner &gt; +Iraq + &lt; .GE. &gt; 75 +percent +enrich +uranium &lt; /WeaponOwner &gt; ]] .
We have made use of the relation operation in our SAW system, where the user can formulate XML Fragment queries containing relations. Because of the additional constraint imposed by the relation, these queries typically retrieve fewer relevant documents than an otherwise identical query with the relation tag replaced by one or more keywords. This enables the user to quickly home in on a few relevant doc-uments with little or no noise. Our QA system provides the capability of automatically generating XML Fragment queries containing relations from natural language questions. For example, the question  X  X hen did Nixon visit China? X  generates the following relation XML Fragment query [[ &lt; HoldsDuring &gt; + &lt; At &gt; +Nixon +China &lt; /At &lt; /Date &gt;&lt; /HoldsDuring &gt; ]] .
Aside from enhancing the expressiveness of user queries, our use of the three XML Fragment operations to include target information type, to disambiguate keywords, to spec-ify search term context, and to specify relations, results in more constrained queries. We hypothesize that these seman-tic search queries, even in the face of imperfect annotations, will still result in significant improvement in precision in re-trieval results. This section describes our experiments for validating this hypothesis and their results for each of our four uses of XML Fragments for semantic search. Where possible, we use standard test and judgment sets in our eval-uation.
In this experiment we evaluate the impact of using the conceptualization operation to specify target information type. The reference corpus is the 3GB AQUAINT corpus used in the TREC QA track since 2002, which contains just over one million news articles between 1996-2000.
The corpus is pre-processed with a named entity recog-nizer that identifies about 100 entity types, ranging from common types such as Person , Organization and Date ,to specific types such as PhoneNumber and URL for address-ing particular information needs. The corpus is then pro-cessed by the indexer and both lemmatized keywords and the identified semantic types are stored in the index.
It is possible to include this information in the database by adding extra arguments to the relation. The point here, however, is that there will always be text where extra, pre-viously unanticipated information is provided and thus not recorded in the database entry. Table 1: Target Information Type Evaluation Re-sults
For our test set, we used the 50 questions and relevant judgments in the TREC 2005 QA track document task [22]. 6 Each question is processed by the question analysis compo-nent of our QA system [16] to identify one or more answer types and a set of salient keywords. The keywords and an-swer types are used to generate an XML Fragment query, where the conceptualization operator is applied to the an-swer type to specify target information. For our baseline run, a query is constructed from the keywords alone. In other words, the only difference between the baseline run and the run using semantic search is the presence of the con-to the semantic type of the answer.
Table 1 shows the results of this experiment in which up to 1000 documents were returned for each query. In con-trast to the INEX evaluation metrics [10] in which scoring isbasedontherelevanceofanelement(partofanXMLdoc-ument determined by the document structure), we evaluate our results at the document level because the annotations in our documents do not convey structural information. We report both the  X  X recision at R X  score (R-Prec, where R is the number of relevant documents for each question), and the MAP score, which were the two official evaluation met-rics used in the TREC 2005 QA track document task. Our results show a 2.9% and 4.1% relative improvement in R-Prec and MAP scores, respectively, where the MAP score improvement is statistically significant at the p&lt; 0 . (using the Wilcoxon Signed Rank Test in this and subse-quent evaluations). Although both of these metrics reward retrieving relevant documents and ranking them high in the hitlist, neither of them takes into account the total number of documents retrieved, which can be a critical element in an end user application. Since all of the semantic search operations discussed in this paper constrain the query and presumably lead to fewer matches for each query, we include a third evaluation metric in the table, the Exact Precision score as returned by the trec eval script, which is the exact precision over the retrieved document set. This measure fa-vors queries that return the same relevant documents with a smaller hitlist. Our Exact Precision score demonstrates that including target information type in the query resulted in a 37.5% improvement in precision, significant at p&lt; 0 . 001.
In this experiment, where we evaluate the impact of us-ing the restriction operation to disambiguate keywords, we used the same corpus, index, and test set as in the previous
In order to focus our experiment on the impact of seman-tic search, the anaphoric expressions in questions with ref-erents in previous questions or answers have been manually resolved so all questions are self-contained.

Baseline 0.4464 0.4357 0.1443 w/ Disambiguation 0.4658 0.4409 0.1443 experiment. Our QA system was reconfigured to generate XML Fragment queries that include, in addition to target information type, disambiguating XML tags for query terms that 1) are considered likely to be ambiguous based on a pre-determined occurrence threshold, and 2) have specific de-siredwordsensesasindicatedinthequestion. Wecompare this run to one without disambiguation capabilities, i.e., the outcome of the semantic search run in the previous section.
In manually examining the queries generated by the two runs, we found that most terms in this standard test set were not considered ambiguous relative to the reference corpus. In fact, out of the 50 questions, only 2 questions resulted in different queries. Table 2 shows the evaluation results on this subset of questions that yielded a difference. Our results show a 4.3% improvement in R-Prec score and a slight gain in MAP score; however, in both cases, the improvement is not statistically significant due to the small sample size.
This experiment evaluates the impact of using the restric-tion operation to specify search term context, and is again based on the same corpus and index. The test set is 46 out of the 50 questions in the AQUAINT 2005 opinion pilot which were of the general form  X  X hat does OpinionHolder think about SubjectMatter ? X  Each question was processed by the question analysis component of our QA system to extract OpinionHolder and SubjectMatter , along with keywords in the question that do not fall into either category. As de-scribed in Section 4.3, the restriction operation is applied to SubjectMatter to constrain the context in which it should appear. In this case, the query consists of OpinionHolder , the additional relevant keywords, and an XML Fragment where the Quotation tag is wrapped around SubjectMatter . For each question, the system returned up to two passages each containing 1-3 sentences.

For the baseline run, instead of wrapping Quotation tags around SubjectMatter , we merely added [[+ &lt; Quotation &lt; /Quotation &gt; ]] as the target information type. In other words, the query still required that a direct quote be present in the document, although the subject matter does not nec-essarily have to be present within the quote.
We manually judged the two runs based on the list of  X  X ital X  and  X  X kay X  nuggets [22] used by the NIST assessors in the opinion pilot evaluation. 7  X  X ital X  nuggets are those that must be present in the returned passages while  X  X kay X  nuggets are considered relevant but not essential. In the opinion evaluation, an F-score is computed based on the
Since some passages in our current runs were potentially previously unseen by the assessors, we augmented the as-sessors X  list in our best attempt to reproduce the assessor X  X  thinking, adding 20 nuggets to their list of 233 nuggets.
Table 3: Context Specification Evaluation Results number of  X  X ital X  nuggets returned (recall) and a length allowance determined by the total number of  X  X ital X  and  X  X kay X  nuggets returned (precision).

Since the two runs each returned two passages of similar average length per question, the final F-score is simply a function of the recall of  X  X ital X  and  X  X kay X  nuggets in each run. Given the same judgment set, we simply report the number of  X  X ital X  and  X  X kay X  nuggets returned by each run as shown in Table 3. Our results show that using semantic search to specify the context of the subject matter, we re-trieved twice as many  X  X ital X  nuggets as our baseline run, thus effectively doubling the recall as well as precision.
In this experiment, where we evaluate the impact of spec-ifying relations between search terms, we used a corpus in the national intelligence domain from the Center for Non-Proliferation Studies (CNS) because 1) there is no standard test set for evaluating relation semantic queries, and 2) our relation annotators focused on this domain. This corpus contains over 37,000 documents and is about 75MB in size.
The corpus was pre-processed with our named entity and relation recognizers, and the resulting annotations were in-dexed along with the lemmatized terms as in the AQUAINT corpus. The relation recognizer identifies 10 relations in this application domain, including ProducesWeapon (coun-try X produces weapon Y), ImportExport (country X im-ports/exports goods to/from country Y), and Destruction-Potential (weapon X can kill Y people).

Our test set for this experiment targets the 10 relations relevant to the reference corpus. For each relation, we con-structed semantic queries by randomly instantiating its ar-guments. For example, for ProducesWeapon we generated [[ &lt; ProducesWeapon &gt; + &lt; Nation &gt;&lt; /Nation &gt; +grade +uranium &lt; /ProducesWeapon &gt; ]] (countries that pro-duce weapon-grade uranium) and [[ &lt; ProducesWeapon &gt; sia + &lt; BioWeapon &gt;&lt; /BioWeapon &gt;&lt; /ProducesWeapon (biological weapons produced by Russia). We constructed 2-3 semantic queries for each relation, resulting in a total of 25 queries. The baseline queries which do not make use of relations were generated by replacing the relation in each query with one or more keywords to express the semantics of the relation. For example, the baseline queries for the above two relation queries are [[+ &lt; Nation &gt;&lt; /Nation +grade +uranium +produce]] and [[+Russia + &lt; BioWeapon &lt; /BioWeapon &gt; +produce]] , respectively.

For our evaluation runs, each query returned up to 10 doc-uments, which correspond to the typical  X  X irst page X  search results that a user examines. The documents returned by each question pair in the two runs are pooled and the doc-uments manually judged by one of the authors as relevant or irrelevant (without knowledge of which of the two runs retrieved a particular document). The pooled judgment set is used in the final evaluation for both runs.
 Table 4: Relation Specification Evaluation Results Baseline 0.3895 0.4147 0.3530 9.72
With Relation 0.4139 0.4108 0 . 6108  X  6 . 32  X  X  X   X  p&lt; 0 . 005;  X  X  X  p&lt; 0 . 00005
Table 4 shows our experimental results. While there is a 6.3% increase in R-Prec score and a very slight drop in MAP score, the relation queries achieved a 73% relative improve-ment in Exact Precision, which is significant at the p&lt; level. This result confirms our hypothesis and is expected because 1) our relation annotators were developed to favor precision over recall, and 2) the application of the relation operator constrains the query and results in a more precise hitlist. While the overall results are as expected, the statisti-cal insignificance of the R-Prec score improvement warrants some explanation. Because both the relation query and the relation annotators targeted high precision, in a fair num-ber of cases, this resulted in a loss in recall and hence a decrease in R-Prec scores. While the substantial gain in R-Prec scores in other questions are sufficient to result in a net improvement, the improvement is not sufficiently uni-form across questions to be statistically significant.
The last column in Table 4 shows the average number of documents returned for each query. In the baseline run, the average is very close to the maximum number of documents requested, with only two queries retrieving fewer than the maximum. In the relation run, however, all but three queries returned fewer than the maximum. This result is significant in applications where it is desirable to provide the user with a very targeted, short hitlist that may only contain partial evidence for the information sought. For example, if the user wants to know whether or not Iraq has a heavy water stockpile, returning a few documents that confirm its exis-tence may be sufficient to meet the user X  X  information need. On the other hand, a more extensive hitlist with higher re-call that details the storage facilities and quantities may be appropriate under a difference scenario. Based on these ob-servations and our evaluation results, we believe that the relation operation is a powerful semantic search query op-eration that is suitable for applications in which high recall is not initially an important factor and where the cost of processing large numbers of return documents is high.
Semantic search is deeply related to the concept and vision of the Semantic Web. Efforts on semantic search in this context assume a yet-to-be-constructed, large, distributed semantic network containing documents pre-annotated with metadata and focus on methods for the retrieval of relevant information from such documents [7, 8].

Research in XML query and retrieval can be divided into document-centric , where an XML document is viewed as text with markup, and the data-centric view, where an XML document is just a free form database. Research in the document-centric view has focused on marrying traditional IR techniques over text spans and tree retrieval techniques over XML tags [5, 2], as well as extending document repre-sentation to support stand-off annotations [12] that allow for the crossing of tags. In our work, we build upon these results to demonstrate how the XML Fragments query language can leverage a collection of annotated XML documents to address different query-time semantic needs.

To improve search performance, many researchers have in-vestigated encoding in an index additional information such as syntactic information [18, 9, 20], word sense informa-tion [21, 13], as well as named entity information [15, 13, 20]. Although there is some conceptual overlap between our work and these previous efforts at the indexing stage, we have demonstrated innovative uses of the semantic index to significantly improve precision in search. Furthermore, none of these previous efforts attempted to operationalize an existing query language and systematically apply these operations to address different query-time semantic needs.
In this paper, we have presented our work on seman-tic search using the XML Fragments query language. We presented three operations that are supported by the XML Fragments query syntax: conceptualization, restriction, and relation. When applied to a traditional keyword query, each of these operations places additional constraints on the query, and thus leads to more focused and more precise re-sults. These operations are therefore particularly valuable for applications in which the benefits of achieving high pre-cision strongly outweighs potential loss in recall.
We further demonstrated the use of these three operators to express different query-time semantic needs. The concep-tualization operation was used to specify target information type, the restriction operation was used to either disam-biguate keywords or to specify search term context, while the relation operation was used to specify the relation be-tween select terms. These uses of XML Fragment operators have been implemented and evaluated in multiple systems and, as we hypothesized, have led to significant increase in the precision of search results, thus validating their useful-ness in the precision-centric class of applications.
We would like to thank Eric Brown and Bill Murdock for helpful discussions. This work was supposed in part by the Disruptive Technology Office (DTO) X  X  Advanced Ques-tion Answering for Intelligence (AQUAINT) Program under contract number H98230-04-C-1577. [1] D. Bikel, S. Miller, R. Schwartz, and R. Weischedel. [2] A. Broder, Y. Maarek, M. Mandelbrod, and Y. Mass. [3] D. Carmel, Y. Maarek, M. Mandelbrod, Y. Mass, and [4] S. Cohen, J. Mamou, Y. Kanza, and Y. Sagiv.
 [5] N. Fuhr and K. Grosjohann. XIRQL: A query [6] P. Grosso and D. Veillard. XML fragment interchange. [7] R. Guha, R. McCool, and E. Miller. Semantic search. [8] J. Heflin and J. Hendler. Searching the web with [9] B. Katz and J. Lin. Selectively using relations to [10] G. Kazai and M. Lalmas. INEX 2005 evaluation [11] A. Levas, E. Brown, J. Murdock, and D. Ferrucci. The [12] R. Mack, S. Mukherjea, A. Soffer, N. Uramoto, [13] R. Mihalcea and D. Moldovan. Semantic indexing [14] R. Mihalcea and D. Moldovan. Document indexing [15] J. Prager, E. Brown, A. Coden, and D. Radev. [16] J. Prager, J. Chu-Carroll, E. Brown, and K. Czuba. [17] M. Sanderson. Retrieving with good sense.
 [18] A. Smeaton, R. O X  X onnell, and F. Kelledy. Indexing [19] R. Srihari, W. Li, C. Nui, and T. Cornell. InfoXtract: [20] J. Tiedemann. Integrating linguistic knowledge in [21] E. Voorhees. Using WordNet to disambiguate word [22] E. Voorhees and H. Dang. Overview of the TREC [23] J. Wiebe, T. Wilson, R. Bruce, M. Bell, and [24] H. Yu and V. Hatzivassilogou. Towards answering
