 Today, a huge number of web applications have been published over the Internet. Users want to create new mashup web applications by making those existing web applica-tions collaborate. However, today X  X  web applications are not designed to take reusability and interoperability into account. In e-Scien ce, there are many web applications which have similar components providing the s ame function developed individually by each project. If existing web applications could seamlessly exchange data, those existing web applications could then be reused to construct new mashup web applications. However, this is di  X  cult because the web applica tions are often located on di erent servers, so-called cross-domain servers, and the data str uctures required by web applications are often di erent.

In this paper, we provide a mashup tool which makes it possible to construct new mashup web application by allowing cross-domain web applications to collaborate. Our proposed tool provides a sophisticated copy and paste mechanism between distinct web pages which are managed in di erent domains. Our tool utilizes state-of-the-art web technologies, such as cross-document messaging[3] and XMLHttpRequest Level 2 (XHR2)[4] in HTML5[2], and Transforming JSON (JsonT)[1].

The remainder of this paper is structur ed as follows. Sec. 2 gives an overview of the architecture, a description of its configuration, and the details of its components. A conclusion is presented in Sec. 3. Fig. 1 illustrates the system architecture of our tool. In this figure, there are three web servers, the first one provides a web page called mashup engine page and is used to control the entire mashup web application. The other servers each provide a web ap-plication as a component of the mashup web application, and also provide wrapper pages that are used to intermediate betw een the mashup engine page and those web applications.

First, the mashup engine reads a configuration file when the mashup engine page is loaded using XHR2, which is provided as a new function of HTML5 (Step 0). The configuration file thus must not exist on the same web server as the mashup engine page. Based on the configuration, the mashup engine opens all the wrapper pages and their corresponding web applications. If a javascript object in web application A is modified, wrapper A sends the data using cross-document messaging, which is also provided in HTML5 (Step 2). At Step 3, the engine transforms the structure of the data using Transforming JSON (JsonT) , which can transform the structure of JSON based on configurable rules. Next, in Step 4, the engine sends the transformed data to wrapper B on web server B via cross-document messaging. If wrapper B receives the data, the wrapper puts the data into a variable of web application B as a javascript object.
In this way, the mashup tool can seamlessly exchange data between web applications, even if the web applications are located in di erent domains, and the data structures required are di erent. All communication is via the mashup engine page. In this figure, there are only two web applications and dat a is sent from web application A to web application B, that is, one-way and one-t o-one, but our tool can manage any number of web applications, and supports two-way and one-to-many communications, if those definitions are written in the configuration file. 2.1 Configuration List 1 shows an example of a configuration file. A configuration file is written in the JSON format and is composed of three definitions: application, flow, and JsonT. In lines 1-9, two application definitions are described, and two flow definitions are described in lines 10-16. The JsonT definition is described in each flow definition in lines 13 and 16. In this example, the application definitions mean that this mashup web application is created by the collaboration of two web applications, the first one of which is identified as  X   X , located at , and embedded in an iframe whose id is  X   X  on the mashup engine page. The flow definitions define two flows, the first one of which indicates that if an output object in the web application  X   X  is modified then the object is to be transformed based on the JsonT definition in line 13 and is to be sent to the web application  X   X  as input data. A JsonT definition can be written in the same configuration file directly, or in a di erent external file as shown as in line 16. A the JsonT definition in an external file is read by the mashup engine using XHR2. 2.2 Wrapper The HTML body tag of a wrapper page contains only an iframe tag to embed its cor-responding web application page, located on the same web server as the wrapper page. A wrapper page has two javascript functions. One is used to monitor a javascript object called  X   X  on the inner web application page. As soon as the  X   X  object is modified, the function serializes the object into a string in JSON format using the page using cross-document messaging. The other function is an event handler func-tion called when a message is received by cross-document messaging. After receiving a message, the event handler function ch ecks whether the source of the received mes-sage is the mashup engine page or not. If it i s from the engine page, then the function deserializes the message into an object using the function, and then puts the object into a variable called  X   X  on the inner web application page as an input. After a received object is put into the  X   X  variable, the data can be used freely by the web application with little modification to the application. 2.3 Mashup Engine The number of iframe tags in the mashup engine page is the same as the number of web applications used in the collaboration. After reading the configuration file, based on the application definitions in it, all wrapper pages and their corresponding web application pages are opened, since they are written in an iframe tag on the wrapper pages.
As soon as the engine page opens the wrapper pages, it sends a connection mes-sage to every wrapper page using cross-document messaging, because wrapper pages do not know anything about the engine page and not have the window object of the engine page, although the engine page has t he window objects of the wrapper pages. Cross-document messaging uses the windo w object of its destination page, because the function in the window object is called to send a message. When a wrapper page receives a connection message , the wrapper obtains the source of the message, keeps it as a window object, and then returns an acknowledgment message to the mashup engine page. If the engine page receives ackno wledgment messages from all wrappers, the preparation of connection windows is finished.

Then, when the engine page receives a me ssage by cross-document messaging, the engine page checks whether the message is sent from one of the wrapper pages man-aged. If it is from an allowed wrapper, based on the flow definition, the engine de-termines the destination of the message. Before sending the message, the message is transformed based on the JsonT definition in the configuration file, if necessary. In this paper, we introduce a mashup tool to construct mashup web applications by utilizing collaboration between existing cross-domain web applications as its compo-nents. Our mashup tool uses state-of-the-art mechanisms: cross-document messaging and XMLHttpRequest Level 2 in HTML5, and JsonT, allowing users to easily exchange (and transform) data between multiple existing web applications, even if they are lo-cated in di erent domains.
 In the demonstration, we will show two demonstrations which have di erent aspects. The one is that a sample mashup application which exchanges and transforms sample data in order to prove the feasibility. The other is that a mashup web application which collaborates existing real geographic applications to prove the requirements. Acknowledgment. This work was partially supported by a Grant-in-Aid for Scientific Research (A) (20240010) from the Ministry of Education, Culture, Sports, Science and Technology.
 Knowledge representation and visualization is a collaborative process while dealing with information of high dimensions and complex nature represented in ontology. The changes (happening to these complex ontologies) in a repository i.e., Change History Log (CHL) with conformance to the Change History Ontology (CHO) [1]. On top of these logged changes, applications like ontology change management, ontology recov-ery, change traceability, and to some extent navigation and visualization of changes and change effects [1, 2] are implemented. The plug-in consist of two main modules; 
Recovery module is responsible for rolling back and forwards the applied changes on model in reverse and forward manner for ontology recovery. SPARQL queries are plug-in ( Change Tracer ), we have checked its change detection accuracy against the ChangesTab of Prot X g X  and our plug-in showed good results. Accuracy of high per-centage for roll-back and roll-forward algorithm is observed [2]. 
Visualization module has two sub modules; a) To visualize the ontology and ontol-ogy changes in graph like structure. The TouchGraph API has been extended for graph drawing. Resources, such as classes, are depicted as nodes and properties as edges. Different resources are represented in different color with respect to one an-pressed in its complete relationships with its associated resources. Numbers of filters view and Fish-eye view effects. A modified version of the Spring graph drawing algorithm is implemented in the visualization that ensures esthetically good looking graph structured and well separated nodes. We have also provided a search facility in case if the ontology is too large to find a resource. The graph and each resource in the graph are also drag-able and the graph refreshes itself. 
The second sub module; b) Visually navigate through the history of ontology changes with roll-back and roll-forward operations (see Figure 1-b). Appropriate in-formation capturing is very important for accurate recovery. We implemented different listeners (i.e., KnowledgeBaseListener , ClsListener , SlotListener , FacetListener , and InstanceListener ) that actively listen to ontology changes during ontology engineering. and reverse changes. First, all the changes are converted to their inverse changes (e.g., RangeAddition to RangeDeletion ) and then implemented in reverse sequence of their occurring order on the current version of ontology to get it in previous state. We have provided the playback and play-forward features where not only the ontology but the changes could also be visually navigated and the trend could be analyzed. Starting from the very first version of the ontology, the user can play the ontology changes and visualize as well as visually navigate the ontology and ontology changes. Rest of de-tails on recovery, visualization, and their implementations is available in [2]. 
The plan is to demonstrate the plug-in features like change capturing, change log-ging, ontology recovery, ontology visualization, and visual navigation through the history of ontology changes of our developed plug-in. 
