 Given a large time-evolving network, how can we find patterns and communities? How do the communities change over time? One would expect to see strongly connected communities (say, groups of people, calling each other) with near-stable behavior X  X ossibly a weekly periodicity. Is this true? Are there other types of patterns we should expect to see, like stars? How do they evolve over time? Is the central node fixed with different leaves every day or are they fixed over time? Perhaps the star appears on some days but not others?
Here we focus on exactly this problem: how to find time-varying communi-ties, in a scalable way without user-defined parameters. We analyze a large, million-node graph, from an anonymous (and anonymized) dataset of mobile customers of a large population and a bipartite computer network with hun-dreds of thousands of connections, available to the public. We shall refer to time-varying communities as comet communities , because they (may) come and go, like comets.

Spotting communities and understanding how they evolve are crucial for fore-casting, provisioning and anomaly detection. The contributions of our method, Com2 , are the following:  X  Scalability : Com2 is linear on the input size, thanks to a careful, incremen- X  No User-Defined Parameters : Com2 utilizes a novel Minimum Descrip- X  Effectiveness : We applied Com2 on real and synthetic data, discovering  X  Generality : Com2 can be easily extended to handle higher-mode tensors. In this section, we summarize related work on graph patterns, tensor decompo-sition methods, and general anomaly detection algorithms for graphs. Tensor Decomposition. An n -mode tensor is a generalization of the concept of matrices: a 2-mode tensor is just a matrix, a 3-mode tensor looks like a data-cube, and a 1-mode tensor is a vector. Among the several flavors of ten-sor decompositions (see [1]), the most intuitive one is the so called Canonical Polyadic (CP) or PARAFAC decomposition [2]. PARAFAC is the generalization of SVD (Singular Value Decomposition) in higher modes.
 Tensors have been used for anomaly detection in computer networks [3] and Facebook interactions [4] and for clustering of web pages [5].
 Static Community Detection. Static community detection methods are closely related to graph partitioning and clustering problems. Using a more alge-braic approach, community detection can also be seen as a feature identification problem in the adjacency matrix of a graph and several algorithms based on spectral clustering have been developed. Santo Fortunato wrote a detailed re-port on community detection [6].
 Time Evolving Graphs. Graph evolution has been a topic of interest for some time, particularly in the context of web data [7,8]. MDL-based approaches for detecting overlapping communities in static graphs [9] as well as non-overlapping communities in time-evolving graphs [10] have been previously proposed. How-ever, the former cannot be easily generalized to time-evolving graphs, whereas the latter focuses on incremental, stream ing community discovery, imposing seg-mentation constraints over time, rather than on discovering comet communities. Other work, e.g. [11], studies the problem of detecting changing communities, but requires selection of a small numbe r of parameters. Furthermore, broadly related work uses tensor-based methods for analysis and prediction of time-evolving  X  X ulti-aspect X  structures, e.g., [12].
 detection methods.
 In this section, we formalize our problem, present the proposed method and analyze it. We first describe our MDL-based formalization which guides the community discovery process. Next, we des cribe a novel, fast, and efficient search strategy, based on iterated rank-1 tensor decompositions which can discover time varying communities in a fast and effective manner. 3.1 Formal Objective We are given a temporal directed network consisting of sources S , destinations D , and time stamps T . We represent this network via a 3-mode tensor X  X  { 0 , 1 } |S| X |D| X |T | where X i,j,t =1ifsource i is connected to destination j at time t . As abbreviations we use N = |S| , M = |D| ,and K = |T | . The goal is to automatically det ect communities: Definition 1. Community A community is a triplet C =( S, D, T ) with S  X  X  , D  X  X  ,and T  X  X  such that each triplet describes an  X  X mportant X  time-varying aspect.

We propose to measure the  X  X mportance X  of a community via the principle of compression, i.e. by the community X  X  ability to help us compress the 3-mode tensor: if most of the sources are connected to most of the destinations during most of the indicated times, then we can compress this  X  X omet-community X  easily. By finding the set of communities leading to the best compression of the tensor, we get the overall most important communities.

More specifically, we use MDL (Minimum Description Length) [16]. That is, we aim to minimize the number of bits required to encode the detected patterns (i.e. the model) and to describe the data given these patterns (corresponding to the effects of the data which are not captured by the model). Thus, the overall description cost automatically trades off the model X  X  complexity and its goodness of fit. In the following, we provide more details about the description cost:
Description cost. The first part of the description cost accounts for encoding the detected patterns C = { C 1 ,...,C l } (where l is part of the optimization and not a priori given). Each pattern C i =( S i ,D i ,T i ) can completely be described by the cardinalities of the three included sets and by the information which vertices and time stamps belong to these sets. Thus, the coding cost for a pattern C i is L The first three terms encode the cardinalities of the sets via the function log  X  using the universal code length for integers [17] 1 . The last three terms encode the actual membership information of the sets: e.g., since the original graph contains N sources, each source included in the pattern can be encoded by log N bits, which overall leads to | S i | X  log N bits to encode all sources included in the pattern.
Correspondingly, a set of patterns C = { C 1 ,...,C l } can be encoded by the following number of bits: That is, we encode the number of patterns and sum up the bits required to encode each individual pattern.

The second part of the description cost encodes the data given the model. That is, we have to provide a lossless reconstr uction of the data based on the detected patterns. Since in real world data we expect to find overlapping communities, our model should not be restricted to disjoint patterns. But how to reconstruct the data based on overlapping patterns? As an approach, we refer to the principle of Boolean algebra: multiple patterns a re combined by a logical disjunction. That is, if an edge occurs in at least one of the patterns, it is also present in the reconstructed data. This idea related to the paradigm of Boolean tensor factorization. More formally, the reconstructed tensor is given by: Definition 2. Tensor reconstruction Given a pattern C =( S, D, T ) . We define the indicator tensor I C  X  X  0 , 1 } N  X  M  X  K to be the 3-mode tensor with I C i,j,k =1  X  i  X  S  X  j  X  D  X  k  X  T .
 Given a set of patterns C , the reconstructed tensor X C is defined as X C = +
The tensor X C might not perfectly reconstruct the data. Since MDL, however, requires a lossless compression, a complete description of the data has to encode the  X  X rrors X  made by the model. Here, an error might either be an edge appearing in X but not in X C , or vice versa. Since we consid er a binary tensor, the number of errors can be computed based on the squared Frobenius norm of the residual tensor, i.e.
Since each  X  X rror X  corresponds to one triplet (source, destination, time stamp), the description cost of the data can now be computed as
Technically, we also have to encode the cardinalities of the set S , D ,and T (i.e. the size of the original tensor). Given a specific dataset, however, these values are constant and thus do not influence the detection of the optimal solution.
Overall model. Given the functions L 2 and L 3 , we are now able to define the communities that minimize the overall number of bits required to describe the model and the data: Definition 3. Finding comet communities Given a tensor X  X  X  0 , 1 } |S| X |D| X |T | . The problem of finding comet communities is defined as finding a set of patterns C  X   X  ( P ( S )  X P ( D )  X P ( T )) such that Again, it is worth mentioning that the patterns detected based on this definition are not necessarily disjoint, thus better representing the properties of real data.
Obviously, computing the optimal solution to the above problem is infeasi-ble as it is NP-hard. In the following, we present an approximate but scalable solution based on an iterative processing scheme. 3.2 Algorithmic Solution We approximate the optimal solution via an iterative algorithm, i.e., we sequen-tially detect important communities. Howev er, given the extremely large search space of the patterns (with most of the patterns leading to only low compres-sion), the question is how to spot the  X  X ood X  communities?
Our idea is to exploit the paradigm of tensor decomposition [2]. Tensor de-composition provides us with a principled solution to detect patterns in a tensor while simultaneously considering the global characteristics of the data. It is worth mentioning that tensor decomposition cannot directly be used to solve our prob-lem: (1) Tensor decomposition methods usually require the specification of the number of components in advance, while we are interested in a parameter-free so-lution. (2) Traditional tensor decomposition does not support the idea of Boolean disjunctions as proposed in our method, and Boolean tensor factorization meth-ods [18] are still limited and a new field to explore. (3) Tensor decomposition does not scale to large datasets if the number of components is large as many localmaximaexist.Inourcase,weexp ect to find many communities in the data.
Thus, in this work, we propose a novel, incremental tensor analysis for the detection of temporal communities. The outline of our method is as follows:  X  Step 1: Candidate  X  X omet X  community : We spot candidates by using  X  Step 2: Ordering and community construction : The scores from step 1  X  Step 3: Tensor deflation : Based on the communiti es already detected, we In the following, we discuss each step of the method.
 Candidate Generation. As explained, exhaustive search of all candidate com-munities is not possible. We propose to find a good initial candidate community using a fast implementation of rank-1 tensor decomposition. We aim at finding vectors a  X  R N , b  X  R M ,and c  X  R K providing a low rank approximation of the community. Intuitively, sources conn ected to highly-connected destinations at highly active times get a higher score in the vector a and similarly for the other two vectors. Specifically, to find th ese vectors, a scalabl e extension of the matrix-power-method only needs t o iterate over the equations: a where a i , b j and c k are the scores of source i , destination j and time k .These vectors are then normalized and the pr ocess is repeated until convergence. Lemma 1. ALS [19] reduces to Equation 1, when we ask for rank-1 results. Proof. Substituting vectors a , b , c , instead of matrices ( A , B , C ), and carefully handling the Khatri-Rao products, we obtain the result.

Notice that the complexity is linear in the size of the input tensor: Let E be the number of non zeros in the tensor, we can easily show that each iteration has complexity O ( E ) as we only need to consider the non zero X i,j,k values. In practice, we select an  X  and compare two consecutive iterations in order to stop the method when convergence is achi eved. In our experimental analysis in Section 4 (using networks with millions of nodes) we saw that a relatively small number of iterations (about 10) is sufficie nt to provide reasonable convergence.
We can now use the score vectors a , b and c as a heuristic to guide our community construction.
 Community Construction Using MDL. Since the tensor decomposition pro-vides numerical values for each node/time stamp, its result cannot be directly used to specify the communities. Additionally, there might be no clear threshold to distinguish between the nodes/time stamps belonging to the community and the rest. Our goal is to find a single community C  X  ( P ( S )  X P ( D )  X P ( T )) lead-ing to the best compression, based on a local (i.e. community-wise) evaluation based on MDL (see Definition 3).

The definition of L 3 ( X |C ) can be adapted to represent the MDL of this single community. By using the Hadamard product ( X  X  I C ), we restrict the tensor to the edges of the pattern: Even though we now only have to find a single community, minimizing this equation is still hard. Therefore, we exploit the result of the tensor decomposition to design a good search strategy.

We first sort the sources, destination, and time stamps according to the scores provided by the tenso r decomposition. Let S =( s 1 ,...,s N ), D =( d 1 ,...,d M )and T =( t 1 ,...,t K ) denote the lists storing the sort ed elements. We start construct-ing the community by selecting the most promising triplet first, i.e., we form the community using the most promising edge and we evaluate its description cost.
Given the current community, we incrementally let the community grow. For each mode, we randomly select an element that is not currently part of the community using the score vectors as samp ling bias. For each of these elements, we calculate the description length considering that we would add it to the community. The lowest description length is then selected, and the corresponding element is added to the community. If none o f these elements decreases the overall description length, we reject them, p roceed with the old community and repeat this process. If we observe l consecutive rejections, the method stops. It can be shown that the probability that an element that should have been included in the community was not included decreases exponentially as a function of l and of its initial score, thus a relatively small value of l is sufficient to identify a vast majority of the elements in the community. In our experimental analysis, a default value of l = 20 was seen to be enough, i.e. larger values have not led to the addition of further elements even when considering communities with thousands of elements. Therefore, we consider this parameter to be general and it does not need to be defined by the user of the algorithm.
 Tensor Deflation. The output of the previous two steps is a single community. To detect multiple communities, multiple iterations are performed. The chal-lenge of such an iterative processing is to avoid generating the same community repeatedly: we have to explore different regions of the search space.
As a solution, we propose the principle of tensor deflation. Informally, we remove the previously detected communiti es from the tensor, to steer the tensor decomposition to different regions. More formally: Let X (1) = X be the original tensor. In iteration i of our method we analyze the tensor X ( i ) leading to the community C i . The tensor used in iteration i + 1 is recursively computed as where  X  is once again the Hadamard product. This deflated tensor might either be used in both the candidate generation and community construction stages, in case we want to penalize overlapping communities, or in the candidate gen-eration stage alone if overlapping communities are not to be penalized.
The method might terminate when the tensor is fully deflated (if possible), or when a specific number of communities has been found, or when some other measure of community quality was not a chieved in the most recent communities (e.g. community size).
 Complexity Analysis Lemma 2. Our algorithm has a runtime complexity of O ( M  X  ( k  X  E + N  X  log N )) , where M is the number of communities we obtain, E is the number of non-zeros of the tensor, N is the length of the biggest mode, and k the number of iterations to obtain convergence. Thus, our method scales linearly w.r.t. the input E . Proof. Omitted for brevity. We tested our method on a variety of synthetic tensors to assess it X  X  quality and scalability. We also applied Com2 on two realworld datasets: a large phone call network and a public computer communications network, demonstrating that it can find interesting patterns in challenging, real-world scenarios. This section details the experiments on the datasets summarized in Table 2.
 4.1 Quality of the Solutions The characterization of the temporal communities identified by the method is important. In particular we want to answer the following questions: How are  X  X verlapping blocks X  identified? How  X  X ense X  are the communities found?
Impact of overlap. A tensor with two disjoint co mmunities was constructed and, iteratively, elements from each of the modes of one of the communities were replaced with elements of the other. O ur tests show that the communities are reported as independent until there is an overlap of about 70% of the elements in each mode, in which case they start b eing reported as a single community. This corresponds to an overlapping of slightly over 20% of the non-zero values of the two communities and the global community formed has 63% of non-zeros. This clearly demonstrates that Com2 has high discriminative power: it can de-tect the existence of communities that sh are some of their members and it is able to report them independently, regardless o f their size (the method is scale-free).
Impact of block density. We also performed experiments to determine how density impacts the number of communities found. Fifty disjoint communities were created in a tensor and non-zeros were sampled without repetition from each community with different probabilities and random noise was then added. We analyzed the number of non-zeros in the first fifty communities reported by our method in order to calculate its accuracy. As we show in Figure 1a, Com2 has high discriminative power even with respect to varying density. 4.2 Scalability As detailed before, Com2  X  X  running time is linear on the number of communities and in the number of non-zero values in the tensor. We constructed a tensor of size 10 000  X  10 000  X  10 000 and randomly created connections between sources and destinations at different timesteps. Figure 1b shows the runtime versus the number of non-zeros in the tensor when c alculating the first 200 communities of the tensor. We consider ra ndom insertion to be a good wo rst-case scenario for many real-life applications, as the lack of pre-defined structure will force many small communities to be found, effectively penalizing the running time of Com2 . In addition to its almost linear runtime, Com2 is also easily parallelizable. By selecting different random seeds in the tensor decomposition step, different communities can be found in parallel. 4.3 Discoveries on Real Data We applied Com2 to a dataset from a european mobile carrier, to charac-terize the communities found in real phone call data. We considered the net-work formed by calls between clients of this company over a period of 14 days. During this period, 3 952 632 unique clients made 210 237095 phone calls, 51 119177 of which formed unique (caller, callee, day) triplets. The tensor is very sparse, with density in the order of 10  X  7 . We extracted 900 communities using Com2 . These communities contain a total of 229 287 unique non-zeros. 293 unique callers and 97 677 unique callees are represented, so the first observa-tion is that the temporal communities are usually heavy on one side with large outgoing stars.

We also applied Com2 to a public computer network dataset captured in 1993, made available by the Lawrence Berkeley National Laboratory. 30 days of TCP connections between 1 647 IP addresses inside the laboratory and 13 782 external IP addresses were recorded. Thi s tensor was totally deflated and a total of 19 046 communities were found (1 930 of them having at least 10 non-zeros).
In both, fairly different, realworld scenarios, Com2 uses the default parame-ters (cf. Sec. 3), showing it can be applied without any user-defined parameters. Observation 1. The biggest communities are more active during weekdays. Figure 2 shows the number of active communities per day of the week on both datasets and we can see that most communities are significantly more active during weekdays. In the phone call data, we are led to believe that these are mostly companies with reduced activi ty during weekends, while the reduced activity during the weekends in the res earch laboratory is to be expected. Observation 2. A typical pattern is the  X  X lickering stars X .
 When analyzing a phone call network, a p attern to be expected is the marketeer pattern in which a number calls many others a very small number of times (1 or 2). Surprisingly, the stars reported by Com2 were not of this type. Two callers stand out in an analysis of the communities reported: one participated in 78 279 (source, destination, time) triplets as a caller but only in 10 triplets as a receiver, while the other participated in 8 909 trip lets as a caller and in none as a receiver. These two nodes are centers of two distinct outgoing stars and were detected by the algorithm. However, the time component of these stars was not a single day but rather spanned almost all the weekdays. This behavior does not seem typical of a marketeer, so we hypothesize that it is a big company communicating with employees. Many of the reported comm unities are stars of this type: a caller calling a few hundred people in a subset of the weekdays -we call them flickering because there is still some activity during the rest of the weekdays, only reduced so that those days are not considered part of the community.

In the LBNL dataset, one st ar was particularly surpr ising. It received connec-tions from over 750 different IP addresses inside the laboratory but only on a single day. One of the other big stars corresponded to 40 connections on a single day to an IP address attributed to the Stanford Research Institute, which is not surprising given the geographical proximity.

We define Flickering stars as a common temporal-community that has a vary-ing number of receivers. These communiti es are active on different days, not nec-essarily consecutive. Stars active on ma ny days (e.g. every weekday) are more common than single day stars.
 Observation 3. A typical pattern is the  X  X emporal Bipartite Cores X .
 Several near-bipartite cores were detected as communities in the phone call dataset. These are communities with abou t 5 callers and receivers that are active on nearly each day under analysis. These communities represent between 75 and 150 of the non-zeros of the original tensor, with a block density of around 40%.
An example of such communities can also be shown for the LBNL data. 7 machines of the laboratory communicated with 6 external IP addresses on every weekday of the month. After analyzing the IP addresses, the outside machines were found to be part of the Stanford N ational Accelerator Laboratory, the University of California in San Francisco, the UC Davis, the John Hopkins Uni-versity, and the U.S. Dept. of Energy. Com2 was able to detect this research group (possibly in particle physics) using communications data alone. We focused on deriving patterns from tim e-evolving graphs, and specifically on spotting comet communities, that come and go (possibly periodically). The main contributions are the following:  X  Scalability :Ourmethod, Com2 , is linear on the input size; instead of rely- X  No user-defined parameters : In addition to the above, efficient, incre- X  Effectiveness : We applied Com2 on real and synthetic data, where it dis- X  Generality : Com2 can be easily extended to handle higher-mode tensors. Com2 can also be applied on edge-labeled graphs, by considering the labels as the third mode of the tensor. Future work could focus on exploiting side information, like node-attributes (for example, demographic data for each node). Com2 is available at http://cs.cmu.edu/  X  maraujo/publications.html. Acknowledgments. This material is based upon work supported by the Na-tional Science Foundation under Grant No. IIS-1247489. Research was sponsored by the Defense Threat Reduction Agency and was accomplished under contract No. HDTRA1-10-1-0120. Also, sponsored by the Army Research Laboratory and was accomplished under Cooperative Agreement Number W911NF-09-2-0053. Additional funding was provided by the U.S. Army Research Office (ARO) and Defense Advanced Research Projects Agency (DARPA) under Contract Number W911NF-11-C-0088. This work is also partially supported by a Google Focused Research Award, by the Funda  X  c  X  ao para a Ci X  encia e a Tecnologia (Portuguese Foundation for Science and Technology) through the Carnegie Mellon Portugal Program, and by a fellowship within the postdoc-program of the German Aca-demic Exchange Service (DAAD). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation, DARPA, or other funding parties. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright no-tation here on.

