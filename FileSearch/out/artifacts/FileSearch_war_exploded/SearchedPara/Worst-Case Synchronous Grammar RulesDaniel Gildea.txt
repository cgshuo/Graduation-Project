 Recent interest in syntax-based methods for statis-tical machine translation has lead to work in pars-ing algorithms for synchronous context-free gram-mars (SCFGs). Generally, parsing complexity de-pends on the length of the longest rule in the gram-mar, but the exact nature of this relationship has only recently begun to be explored. It has been known since the early days of automata theory (Aho and Ullman, 1972) that the languages of string pairs gen-erated by a synchronous grammar can be arranged in an infinite hierarchy, with each rule size  X  4 pro-ducing languages not possible with grammars re-stricted to smaller rules. For any grammar with maximum rule size n , a fairly straightforward dy-namic programming strategy yields an O ( N n +4 ) al-gorithm for parsing sentences of length N . How-ever, this is often not the best achievable complexity, and the exact bounds of the best possible algorithms are not known. Satta and Peserico (2005) showed that a permutation can be defined for any length n such that tabular parsing strategies must take at least  X ( N c proportional to the square root of the rule length. In this paper, we improve this result, showing that in the worst case the exponent grows linearly with the rule length. Using a probabilistic argument, we show that the number of easily parsable permuta-tions grows slowly enough that most permutations must be difficult, where by difficult we mean that the exponent in the complexity is greater than a constant factor times the rule length. Thus, not only do there exist permutations that have complexity higher than the square root case of Satta and Peserico (2005), but in fact the probability that a randomly chosen permutation will have higher complexity approaches one as the rule length grows.

Our approach is to first relate the problem of finding an efficient parsing algorithm to finding the treewidth of a graph derived from the SCFG rule X  X  permutation. We then show that this class of graphs are expander graphs , which in turn means that the treewidth grows linearly with the graph size. We write SCFG rules as productions with one lefthand side nonterminal and two righthand side strings. Nonterminals in the two strings are linked with superscript indices; symbols with the same in-dex must be further rewritten synchronously. For ex-ample, is a rule with four children and no reordering, while Algorithm 1 BottomUpParser(grammar G , input strings e , f ) for x , y , y n ) , p } end for expresses a more complex reordering. In general, we can take indices in the first grammar dimen-sion to be consecutive, and associate a permutation  X  with the second dimension. If we use X 0  X  i  X  n as a set of variables over nonterminal symbols (for example, X for nonterminal A ), we can write rules in the gen-eral form: Grammar rules also contain terminal symbols, but as their position does not affect parsing complexity, we focus on nonterminals and their associated permuta-tion  X  in the remainder of the paper. In a probabilis-tic grammar, each rule R has an associated proba-bility P ( R ) . The synchronous parsing problem con-sists of finding the tree covering both strings having
We assume synchronous parsing is done by stor-ing a dynamic programming table of recognized nonterminals, as outlined in Algorithm 1. We refer to a dynamic programming item for a given nonter-minal with specified boundaries in each language as a cell . The algorithm computes cells by maximiz-ing over boundary variables x over positions in the two input strings, and specify beginning and end points for the SCFG rule X  X  child nonterminals.

The maximization in the inner loop of Algo-rithm 1 is the most expensive part of the proce-dure, as it would take O ( N 2 n  X  2 ) with exhaustive search; making this step more efficient is our fo-cus in this paper. The maximization can be done with further dynamic programming, storing partial results which contain some subset of an SCFG rule X  X  righthand side nonterminals that have been recog-nized. A parsing strategy for a specific SCFG rule consists of an order in which these subsets should be combined, until all the rule X  X  children have been recognized. The complexity of an individual parsing step depends on the number of free boundary vari-ables, each of which can take O ( N ) values. It is often helpful to visualize parsing strategies on the permutation matrix corresponding to a rule X  X  per-mutation  X  . Figure 1 shows the permutation matrix of rule (2) with a three-step parsing strategy. Each panel shows one combination step along with the projections of the partial results in each dimension; the endpoints of these projections correspond to free boundary variables. The second step has the high-est number of distinct endpoints, five in the vertical dimension and three horizontally, meaning parsing can be done in time O ( N 8 ) .

As an example of the impact that the choice of parsing strategy can make, Figure 2 shows a per-mutation for which a clever ordering of partial re-sults enables parsing in time O ( N 10 ) in the length of the input strings. Permutations having this pattern of diagonal stripes can be parsed using this strat-egy in time O ( N 10 ) regardless of the length n of the SCFG rule, whereas a na  X   X ve strategy proceeding from left to right in either input string would take time O ( N n +3 ) . 2.1 Markov Random Fields for Cells In this section, we connect the maximization of probabilities for a cell to the Markov Random Field (MRF) representation, which will later allow us to use algorithms and complexity results based on the graphical structure of MRFs. A Markov Random set of variables x that can be written as a product of factors f x . The probability of an SCFG rule instance com-puted by Algorithm 1 can be written in this func-tional form: where and the MRF has one factor f minal X is the probability of the child nonterminal, which can be expressed as a function of its four boundaries:
For reasons that are explained in the following section, we augment our Markov Random Fields with a dummy factor for the completed parent non-terminal X  X  chart item. Thus there is one dummy fac-tor d for each grammar rule: expressed as a function of the four outer boundary variables of the completed rule, but with a constant Figure 2: A parsing strategy maintaining two spans in each dimension is O ( N 10 ) for any length permu-tation of this general form. value of 1 so as not to change the probabilities com-puted.

Thus an SCFG rule with n child nonterminals al-ways results in a Markov Random Field with 2 n + 2 variables and n + 1 factors, with each factor a func-tion of exactly four variables.

Markov Random Fields are often represented as graphs. A factor graph representation has a node for each variable and factor, with an edge connect-ing each factor to the variables it depends on. An ex-ample for rule (2) is shown in Figure 3, with round nodes for variables, square nodes for factors, and a diamond for the special dummy factor. 2.2 Junction Trees Efficient computation on Markov Random Fields is performed by first transforming the MRF into a junction tree (Jensen et al., 1990; Shafer and Shenoy, 1990), and then applying the standard message-passing algorithm for graphical models over this tree structure. The complexity of the mes-sage passing algorithm depends on the structure of the junction tree, which in turn depends on the graph structure of the original MRF.
 A junction tree can be constructed from a Markov Random Field by the following three steps:  X  Connect all variable nodes that share a factor,  X  Choose a triangulation of the resulting graph,  X  Decompose the triangulated graph into a tree of We call nodes in the resulting tree, corresponding to cliques in the triangulated graph, clusters . Each cluster has a potential function , which is a function of the variables in the cluster. For each factor in the original MRF, the junction tree will have at least one cluster containing all of the variables on which the factor is defined. Each factor is associated with one such cluster, and the cluster X  X  potential function is set to be the product of its factors, for all combina-tions of variable values. Triangulation ensures that the resulting tree satisfies the junction tree property , which states that for any two clusters containing the same variable x , all nodes on the path connecting the clusters also contain x . A junction tree derived from the MRF of Figure 3 is shown in Figure 5.

The message-passing algorithm for graphical models can be applied to the junction tree. The algo-Figure 4: The graphs resulting from connecting all interacting variables for the identity permutation rule (2) (bottom). rithm works from the leaves of the tree inward, alter-nately multiplying in potential functions and maxi-mizing over variables that are no longer needed, ef-fectively distributing the max and product operators so as to minimize the interaction between variables. The complexity of the message-passing is O ( nN k ) , where the junction tree contain O ( n ) clusters, k is the maximum cluster size, and each variable in the cluster can take N values.

However, the standard algorithm assumes that the factor functions are predefined as part of the input. In our case, however, the factor functions themselves depend on message-passing calculations from other grammar rules:
We must modify the standard algorithm in order to interleave computation among the junction trees corresponding to the various rules in the grammar, using the bottom-up ordering of computation from Algorithm 1. Where, in the standard algorithm, each message contains a complete table for all assign-ments to its variables, we break these into a sepa-rate message for each individual assignment of vari-ables. The overall complexity is unchanged, because each assignment to all variables in each cluster is still considered only once.

The dummy factor d ensures that every junction tree we derive from an SCFG rule has a cluster con-taining all four outer boundary variables, allowing efficient lookup of the inner maximization in (3). Because the outer boundary variables need not ap-pear throughout the junction tree, this technique al-lows reuse of some partial results across different outer boundaries. As an example, consider message passing on the junction tree of shown in Figure 5, which corresponds to the parsing strategy of Fig-ure 1. Only the final step involves all four bound-aries of the complete cell, but the most complex step is the second, with a total of eight boundaries. This efficient reuse would not be achieved by applying the junction tree technique directly to the maximiza-tion operator in Algorithm 1, because we would be fixing the outer boundaries and computing the junc-tion tree only over the inner boundaries. The complexity of the message passing algorithm over an MRF X  X  junction tree is determined by the treewidth of the MRF. In this section we show that, because parsing strategies are in direct correspon-dence with valid junction trees, we can use treewidth to analyze the complexity of a grammar rule.
We define a tabular parsing strategy as any dy-namic programming algorithm that stores partial re-sults corresponding to subsets of a rule X  X  child non-terminals. Such a strategy can be represented as a recursive partition of child nonterminals, as shown in Figure 1(left). We show below that a recursive partition of children having maximum complexity k at any step can be converted into a junction tree hav-ing k as the maximum cluster size. This implies that finding the optimal junction tree will give a parsing strategy at least as good as the strategy of the opti-mal recursive partition.

A recursive partition of child nonterminals can be converted into a junction tree as follows:  X  For each leaf of the recursive partition, which  X  For each internal node in the recursive parti- X  Add each variable x i to all nodes in the junction
Because each variable appears as an argument of only two factors, the junction tree nodes in which it is present form a linear path from one leaf of the tree to another. Since each variable is associated only with nodes on one path through the tree, the result-ing tree will satisfy the junction tree property. The tree structure of the original recursive partition im-plies that the variable rises from two leaf nodes to the lowest common ancestor of both leaves, and is not contained in any higher nodes. Thus each node in the junction tree contains variables correspond-ing to the set of endpoints of the spans defined by the two subsets corresponding to its two children. The number of variables at each node in the junction tree is identical to the number of free endpoints at the corresponding combination in the recursive par-tition.

Because each recursive partition corresponds to a junction tree with the same complexity, finding the best recursive partition reduces to finding the junc-tion tree with the best complexity, i.e., the smallest maximum cluster size.

Finding the junction tree with the smallest clus-ter size is equivalent to finding the input graph X  X  treewidth , the smallest k such that the graph can be embedded in a k -tree. In general, this problem was shown to be NP-complete by Arnborg et al. (1987). However, because the treewidth of a given rule lower bounds the complexity of its tabular parsing strate-gies, parsing complexity for general rules can be bounded with treewidth results for worst-case rules, without explicitly identifying the worst-case permu-tations. In this section, we show that the treewidth of the graphs corresponding to worst-case permutations growths linearly with the permutation X  X  length. Our strategy is as follows: 1. Define a 3-regular graph for an input permu-2. Show that the edge-expansion of the 3-regular 3. Use edge-expansion to bound the spectral gap. 4. Use spectral gap to bound treewidth.

For the first step, we define H = ( V, E ) as a ran-dom 3-regular graph on 2 n vertices obtained as fol-lows. Let G cycles, each on a separate set of n vertices. These two cycles correspond to the edges ( x ( y ure 4. Let M be a random perfect matching be-tween V ( x Let H be the union of G contains only some of the edges in the graphs de-fined in the previous section, removing edges cannot increase the treewidth.

For the second step of the proof, we use a proba-bilistic argument detailed in the next subsection.
For the third step, we will use the following con-nection between the edge-expansion and the eigen-value gap (Alon and Milman, 1985; Tanner, 1984). Lemma 4.1 Let G be a k -regular graph. Let  X  the second largest eigenvalue of G . Let h ( G ) be the edge-expansion of G . Then
Finally, for the fourth step, we use a relation be-tween the eigenvalue gap and treewidth for regu-lar graphs shown by Chandran and Subramanian (2003).
 Lemma 4.2 Let G be a k -regular graph. Let n be the number of vertices of G . Let  X  largest eigenvalue of G . Then Note that in our setting k = 3 . In order to use Lemma 4.2 we will need to give a lower bound on the eigenvalue gap k  X   X  4.1 Edge Expansion The edge-expansion of a set of vertices T is the ra-tio of the number of edges connecting vertices in T to the rest of the graph, divided by the number of vertices in T , where we assume that | T | X | V | / 2 . The edge ex-pansion of a graph is the minimum edge expansion of any subset of vertices: Intuitively, if all subsets of vertices are highly con-nected to the remainder of the graph, there is no way to decompose the graph into minimally interacting subgraphs, and thus no way to decompose the dy-namic programming problem of parsing into smaller pieces.
 for  X   X  R , let We will use the following standard inequality valid for 0  X   X   X  n : Lemma 4.3 With probability at least 0 . 98 the graph H has edge-expansion at least 1 / 50 .
 Proof : Let  X  = 1 / 50 . Assume that T  X  V is a set with a small edge-expansion, i. e., and | T | X | V | / 2 = n . Let T t i = | T i | t  X  t 2 . We will denote as  X  i the number of spans of consecutive vertices from E 2  X  i = | E ( T i , V i  X  T i ) | counted by  X  counted in computing the complexity of a chart pars-ing operation. However, unlike in the diagrams in the earlier part of this paper, in our graph theoretic argument there is no requirement that T select only corresponding pairs of vertices from V
There are at least 2(  X  T and V  X  T . This is because there are 2  X  within V spans, and at least t vertices from T Thus from assumption (5) we have which in turn implies Similarly, using (6), we have
That is, for T to have small edge expansion, the vertices in T small number of spans  X  number of spans allows us to limit the number of ways of choosing T given. Any pair T in E ( T bits (corresponding to the possible  X  X waps X  of T with V 2  X  1 + 2  X  2  X  t 1 2  X / (1  X   X  ) number of choices of T
For a given choice of T small edge expansion, there must also not be too many edges that connect T Let k be the number of edges between T There are at least t V  X  T and from assumption (5) we have Thus The probability that there are  X  (1  X   X  ) t tween T where the first term selects vertices in T to
T 2 , and the second term upper bounds the proba-bility that the selected vertices are indeed connected to T alone:
Combining the number of ways of choosing T and T edges M from the input permutation connect almost all the vertices in T using the union bound over values of t that the probability p that there exists T  X  V with edge-expansion less than  X  is bounded by: 2
X where the factor of 2 is due to the assumption t t .

The graph H is connected and hence T has at least one out-going edge. Therefore if t edge-expansion of T is at least  X  . Thus a set with edge-expansion less than  X  must have t which, by (6), implies t sum in (11) can be taken for t from  X  (1  X   X  ) / (2  X  )  X  to  X  n/ 2  X  . Using (4) we obtain p  X  8 We will use t (12). We obtain
While this constant bound on p is sufficient for our main complexity result, it can further be shown that p approaches zero as n increases, from the fact that the geometric sum in (12) converges, and each term for fixed t
This completes the second step of the proof as outlined at the beginning of this section. The con-stant bound on the edge expansion implies a constant bound on the eigenvalue gap (Lemma 4.1), which in turn implies an  X ( n ) bound on treewidth (Lemma 4.2), yielding: Theorem 4.4 Tabular parsing strategies for Syn-chronous Context-Free Grammars containing rules with all permutations of length n require time  X ( N cn ) in the input string length N for some con-stant c .

We have shown our result without explicitly con-structing a difficult permutation, but we close with one example. The zero-based permutations of length p , where p is prime,  X  ( i ) = i  X  1 mod p for 0 &lt; i &lt; p , and  X  (0) = 0 , provide a known family of expander graphs (see Hoory et al. (2006)). We have shown in the exponent in the complex-ity of polynomial-time parsing algorithms for syn-chronous context-free grammars grows linearly with the length of the grammar rules. While it is very expensive computationally to test whether a speci-fied permutation has a parsing algorithm of a certain complexity, it turns out that randomly chosen per-mutations are difficult with high probability. Acknowledgments This work was supported by NSF grants IIS-0546554, IIS-0428020, and IIS-0325646.

