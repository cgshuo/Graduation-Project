 In event pattern matching a sequence of input events is matched against a complex query pattern that specifies constraints on extent, order, values, and quantification of matching events.

In this paper we propose a general pattern matching strategy that consists of a pre-processing step and a pattern matching step. Instead of eagerly matching incoming events, the pre-processing step buffers events in a match window to apply different pruning techniques (filtering, partitioning, and testing for necessary match conditions). In the second step, an event pattern matching algo-rithm, A , is called only for match windows that satisfy the neces-sary match conditions. This two-phase strategy with a lazy call of the matching algorithm significantly reduces the number of events that need to be processed by A as well as the number of calls to A . This is important since pattern matching algorithms tend to be expensive in terms of runtime and memory complexity, whereas the pre-processing can be done very efficiently. We conduct exten-sive experiments using real-world data with pattern matching algo-rithms for, respectively, automata and join trees. The experimental results confirm the effectiveness of our strategy for both types of pattern matching algorithms.
 H.2.4 [ Database Management Systems ]: Systems X  Query Pro-cessing Event pattern matching, Window, Optimization
In event pattern matching a sequence of input events is matched against a complex query pattern that specifies constraints on extent, order, values, and quantification of matching events. Due to its wide applicability in different application domains, such as finan-cial services [3, 8, 12, 15], click stream analysis [12, 15], RFID-based tracking and monitoring [3, 9], RSS feed monitoring [8], health services [5, 11], and workflow monitoring [10], an increas-ing amount of research is being conducted in this field.
In this paper we propose a two-phase strategy that leverages ex-isting pattern matching algorithms. To illustrate our framework, we use sequenced event set (SES) pattern matching [5], where a query specifies a sequence of event sets and a maximal time interval dur-ing which the events must occur. The order of input events that match a single event set is irrelevant, whereas the order of input events that match different event sets must correspond to the order of the sets in the pattern.

Example 1. As a running example, we consider the analysis of chemotherapy data. A chemotherapy is a treatment for cancer pa-tients and consists of a sequence of events, such as the administra-tion of medications and laboratory examinations. Figure 1 shows a sample event relation, Chemo . The attributes represent patient ID ( PID ), event type ( L ), value ( V ) with measurement unit ( U ), and occurrence time ( T ) of an event, respectively. For instance, event e represents the administration of 1672 . 5 mg of Ciclofosfamide to patient 1 on July 3. To investigate the effect of the medications on the blood count the following query is issued:
We propose a novel pattern matching strategy that consists of a pre-processing phase and a pattern matching phase. In the pre-processing phase, incoming events are buffered in the match win-dow to apply different pruning techniques, such as filtering, par-titioning, and testing for necessary match conditions. The aim of the comparably cheap pre-processing is to reduce the number of input events that need to be processed in the much more expensive pattern matching phase.

First, to eliminate irrelevant events that will never participate in a match we propose a filtering mechanism , which can be done very efficiently. Filtering out irrelevant events is particularly effective for the skip-till-next-match and skip-till-any-match event selection strategies that both skip all irrelevant events [3].

Second, a critical aspect of current solutions is that each input event is immediately processed by the pattern matching algorithm. For example, in automaton-based algorithms, each event creates a new automaton instance since each event can potentially start a match. This leads to a large number of automaton instances with a significant amount of state information to be maintained. A first step to improve this is to start an automaton only when it leaves the start state [3]. We achieve a substantial reduction of the number of automata by buffering input events in the match window , W , and lazily instantiating an automaton (or equivalently call a pattern matching algorithm A ) only when the buffered events satisfy a set of necessary match conditions and the window contains all events that need to be considered for matches starting at the first event in the window. We adopt a summary statistics based on event counting to efficiently check the necessary match conditions.

Third, although filtering removes irrelevant events, the match window might still contain events that cannot be part of any match starting at the first event in W . For instance, in our example all events in a match must be of the same patient. Thus, all events in W with a patient ID different from the one of the first event do not need to be forwarded to A . We achieve this by partitioning incom-ing events into different windows, based on equality constraints that are derived from the query specification.

In the second phase, an event pattern matching algorithm , A , is called for each match window that satisfies the necessary match conditions. This two-phase strategy with a lazy call of the matching algorithm significantly reduces the number of events that need to be processed by A and the number of calls to A . While pattern matching algorithms tend to be expensive in terms of runtime and memory complexity, pre-processing can be done very efficiently.
We conduct extensive experiments on two real-world datasets, using the automaton-based SES pattern matching algorithm and ZStream which is based on join trees. The experiments show the effectiveness of our strategy for both types of pattern matching al-gorithms.

The technical contributions can be summarized as follows:
The rest of the paper is organized as follows. Section 2 discusses related work. In Sec. 3 we introduce SES pattern matching. In Sec. 4 we present our two-phase pattern matching strategy together with the pruning techniques. An algorithm that implements this strategy is described in Sec. 5. In Section 6 we report experimental results. Section 7 concludes the paper and points to future work.
In the past, various approaches have been proposed for process-ing pattern matching queries, most prominently automaton-based solutions [3, 5, 8, 10] and solutions that use join trees [12]. A com-mon characteristic of these approaches is that incoming events are immediately processed by the pattern matching algorithm. In this paper we advocate a strategy that applies a pre-processing phase followed by a pattern matching phase. Pre-processing significantly reduces the number of events that need to be processed in the pat-tern matching phase. Our strategy leverages existing pattern match-ing algorithms and achieves significant performance improvements since pre-processing is cheap when compared to the more expen-sive pattern matching algorithms.

Sequenced event set (SES) pattern matching [5] allows to spec-ify in the query a sequence of event sets rather than a sequence of single events. For query processing, an approach that uses non-deterministic automata has been proposed. An automaton is cre-ated for each input event that matches the beginning of the pattern, which might lead to orders of magnitude more automaton instances than matches, and each input event is passed to all active automa-ton instances. In this paper we propose an effective pre-processing phase that significantly reduces the number of events that need to be processed by the automaton instances as well as the number of automaton instances.

SASE+ [3] translates a query to a nondeterministic finite state automaton. Specific optimization techniques include partitioning and merging of automaton instances during query execution. Sim-ilar to SES automata, SASE+ suffers from the many automaton instances that are created for each incoming event that matches the beginning of the pattern.

The publish/subscribe system Cayuga [8] uses a regular expres-sion like algebra and translates a query into a nondeterministic fi-nite state automaton. Optimization techniques focus on the simul-taneous evaluation of multiple queries using indices. By indexing automaton instances, an input event is only processed by those au-tomaton instances that may change state. This is similar to our filter mechanism, but many active automaton instances need to be maintained in memory. To reduce the number of transitions that are evaluated for each incoming event, transitions are indexed on their condition. Cayuga instantiates an automaton for each input event that matches the beginning of the query pattern, and therefore ex-hibits the same drawbacks as SASE+.

The C-CEP system [10] adopts an automaton-based solution that checks for pattern query unsatisfiability according to pre-existing constraints that are evaluated on the input stream. These constraints originate from the business logic and allow to detect at runtime op-timal points to terminate automaton instances that will never pro-duce a match. Different from this work, our pruning techniques need no extra constraints, but exploit the query pattern to filter out irrelevant events and to delay the instantiation of automata until some necessary conditions are satisfied.

The DejaVu system [9] implements a subset of the SQL exten-sion [16] for pattern matching in MySQL. The query processor is extended to use finite state automata for the evaluation of pattern matching queries such that an automaton runs as integral part of the query plan. Specific optimizations for pattern queries (apart from the optimizations of MySQL) are not presented.
ZStream [12] is a cost-based query processor using join trees for matching sequential patterns that are enriched with sequence, con-junction, disjunction, negation, and Kleene closure operators. Op-erators are arranged in a query tree that processes events from the leaves to the root. Hashing is used to evaluate equality predicates, and a cost-based reordering algorithm is used to find an efficient order of the operators. The algorithm finds an optimal order for patterns that consist of a sequence of single events; this is not guar-anteed for queries that consist of sets of more than two events since the reordering does not consider different orders of binary conjunc-tion operators.
 Other research work on event pattern matching includes SQL-TS [15], an extension of SQL to process complex sequential pat-terns in database systems. For efficient query processing, a so-lution based on the Knuth-Morris-Pratt string matching algorithm has been adopted and optimized. The Event Analyzer [11] is a data warehouse component that allows to analyze event sequences.
Systems for stream processing include Aurora [2, 6], Bore-alis [1], STREAM [4, 13], and TelegraphCQ [7]. Querying in these systems is limited to a combination of selection, join, and aggre-gation; pattern queries are not supported. Based on these opera-tions, optimization techniques focus on efficient resource manage-ment and load balancing.
This section gives an overview of sequenced event set pattern matching (or simply pattern matching), which we use to illustrate our framework. The notation is summarized in Table 1.

A n event is represented as a tuple with schema E = ( A 1 , . . . , A l , T ) , where T is a temporal attribute that stores the oc-currence time of an event. For T we assume a totally ordered time domain. An event relation , E , is a set of events with a total order given by attribute T (see relation Chemo in Fig. 1). A chronologi-cally ordered sequence of events is represented as ~e = h e with e 1 and e n referring to the first and last event in ~e , respectively. Definition 1. ( Pattern ) A pattern , P , is a triple where B = h B 1 , . . . , B k i , k  X  1 , is a sequence of pairwise dis-joint sets of variables of the form v or v + ,  X  = {  X  1 , . . . ,  X  set of constraints over variables in B 1 , . . . , B k , and  X  is a duration.
A variable, v  X  B i , binds a sequence of a single event, h e A quantified variable, v +  X  B i , binds a sequence of one or more that must be satisfied by matching events. We distinguish between properties and relationships, i.e.,  X  =  X  p  X   X  r . Properties ,  X   X   X  p , have the form ( v.A  X  C ), where v.A refers to an attribute of a matching event, C is a constant, and  X   X  { = , 6 = , &lt;,  X  , &gt;,  X  , } is a comparison operator. Properties can be further partitioned by to as properties of variable v i ) contains all constraints of the form ( v .A  X  C ). Relationships ,  X   X   X  r , have the form ( v i .A or ( prev( v.A )  X  v.A ). Finally,  X  is the maximal time span within which all matching events must occur.

Example 2. Query Q1 is formulated as pattern P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) . The first set, B 1 = { c, p + } , con-tains two variables with the quantifier + applied to p . The sec-ond set, B 2 = { b } , contains one variable. The maximal time span is fifteen days. The constraints, separated in properties and c = { c. L =  X  X  X  } ,  X  p p = { p. L =  X  X  X  } , and  X  p b = { b. L =  X  X  X  } and relationships  X  r = { c. PID = p. PID , p. PID = b. PID , prev( p. V ) &lt; p. V } . Variable c binds a single administration of Ciclofosfamide ( c. L =  X  X  X ), p + binds one or more administrations of Prednisone ( p. L =  X  X  X ), and b binds a single blood count mea-surement ( b. L =  X  X  X ). The first two relationships force the matched events to refer to the same patient. The third relationship requires the amount of Prednisone to be increasing.

To define the matching of a pattern P and an event rela-tion E , we use a substitution  X  = { v 1 /~e 1 , . . . , v Each pair v/~e represents a binding of variable v to a sequence, exactly one binding for each variable in P , and an event can appear in at most one of the bindings. For a constraint  X   X   X  ,  X  X  denotes the instantiation of  X  by  X  and is obtained from  X  by simultaneously replacing all variables v i by the corresponding event sequence ~e The instantiation of a set of constraints  X  is  X   X  = {  X  1 The truth value of an instantiation is defined through an interpreta-tion , I ( X   X  ) :
The interpretation of  X   X  is the conjunction of the interpretation of the individual constraints  X  i  X  . If  X  is a property, i.e., ( v.A  X  C ), the attribute A of all events bound to v are compared to constant C . attributes A i and A j of all events bound to v i and v j are compared. If  X  is a relationship of the form ( prev( v.A )  X  v.A ), the attribute A of each pair of consecutive events that are bound to v are compared.

Example 3. Let  X  be the set of constraints of pattern P 1 ( h{ c, p + } , { b }i ,  X  , 15 d) and  X  = { c/ h e 7 i , p/ h e be a substitution. The instantiation of  X  (cf. Example 2) with  X  is  X   X  = {h e 7 i . L =  X  X  X  , h e 5 , e 8 i . L =  X  X  X  , h e 12 The interpretation of  X   X  i s I ( X   X  )  X  I ( h e 7 i . L =  X  X  X  )  X  I ( h e 5 , e 8 i . L =  X  X  X  )  X   X   X   X   X  Definition 2. ( Match ) Let P = ( B,  X  ,  X  ) be a pattern with B = h B 1 , . . . , B k i and E be an event relation. A substitution  X  = { v 1 /~e 1 , . . . , v m /~e m } is a match of P in E iff the following holds:
I ( X   X  ) is true, (1)  X  v i /~e i , v j /~e j  X   X  ( v i  X  B i  X  v j  X  B i +1  X  e  X  v i /~e i , v j /~e j  X   X  ( | e i 1 .T  X  e j n .T |  X   X  ) . (3) Condition 1 requires that a match satisfies all constraints in  X  . Condition 2 ensures that all events in a match that are bound to a variable in B i must occur before all events that are bound to any variable in B i +1 . No order is imposed on events that are bound to variables in the same B i , hence any permutation is matched. Condition 3 constrains all events in a match to occur within a time span of  X  .
 Example 4. Figure 2 illustrates a match of P 1 in relation Chemo . Variables c and b bind a single event each, p binds a sequence of two events. The instantiation  X   X  is satisfied (Cond. 1): e event, e 5 and e 8 are  X  X  X  events, and e 12 is a  X  X  X  event; all events refer to the same patient; and the value of e 5 is greater than the value of e 8 . Events e 5 , e 7 , and e 8 that match the first event set occur before e 12 that matches the second event set (Cond. 2). The time span between the first ( e 5 ) and last event ( e 12 fifteen days (Cond. 3). The complete list of matches is: { c/ h e 1 i , p/ h e 3 i , b/ h e 11 i} , { c/ h e 1 i , p/ h e { c/ h e 7 i , p/ h e 5 i , b/ h e 12 i} , { c/ h e 7 i , p/ h e { c/ h e 7 i , p/ h e 8 i , b/ h e 12 i} , { c/ h e 7 i , p/ h e { c/ h e 7 i , p/ h e 5 , e 8 i , b/ h e 12 i} , { c/ h e Definition 2 specifies the set of all possible matches of P in E , but applications might be interested in a subset only. This can be controlled by different event selection strategies that have been proposed in the literature [3]. In the running example of this paper we use earliest and maximal matches. A match,  X  = { v 1 /~e 1 , . . . , v m /~e m } , is earliest iff each ~e i possible event after the first event in  X  . A match  X  is maximal iff no ~e i can be extended with an event that occurs after the start of  X  , and  X  remains still a match.

Example 5. Match  X  in Fig. 2 is earliest and maximal. All bound event sequences start with the earliest possible events and they can-not be extended and still satisfy the conditions of a match. In con-binds e 13 instead of the earlier event e 12 . Match { c/ h e b/ h e 12 i} is not maximal, since the event sequence bound to p can be extended with e 8 and still remains a match. The complete list of earliest and maximal matches is: { c/ h e 1 i , p/ h e 3 , e 9 i , b/ h e 11 i} , { c/ h e { c/ h e 7 i , p/ h e 5 , e 8 i , b/ h e 12 i} .
In this section we propose a lazy evaluation strategy for event pattern matching. Instead of eagerly matching incoming events, we advocate a two-phase strategy composed of a pre-processing step and a pattern matching step (see Fig. 3). First, incoming events are buffered in the match window, which allows to apply pruning tech-niques on the window, such as filtering, partitioning, and testing for necessary match conditions. Second, an event pattern match-ing algorithm, A , is called that needs to consider only the events in the match window. The pre-processing phase aims at reducing the number of events that need to be processed by A .

First, we introduce the match window, which buffers incoming events and aids a lazy call of A .

Definition 3. ( Match Window ) Let E be an event relation and P be a pattern with duration  X  . The match window starting at event e  X  E is defined as W i = h e  X  E | 0  X  e.T  X  e i .T  X   X  i .
A match window W is a maximal subsequence of E that starts at an event e i and includes all events that are within duration  X  . Example 6. Figure 4 illustrates two match windows, W 1 and W 2 , for pattern P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) . The match win-dows start at event e 1 and e 2 , respectively. Both match windows contain 12 events, each with a maximal time span of fifteen days between the first and the last event.

Conceptually, a match window slides over the input stream event-by-event and covers at each step all events that are within duration  X  from the earliest event in the window. Depending on the density of the input events along the time axis, the number of tuples in the match window might vary.

A match window W = h e 1 , . . . , e n i is a buffer that collects all incoming events that need to be considered for a match that starts at e 1 . This includes all events until the time span between the first event e 1 and the current input event exceeds  X  . At this point an event pattern matching algorithm is called to compute all matches that start at e 1 . Afterwards, e 1 is removed from W .
Definition 4. ( Event Pattern Matching Algorithm ) Let W = h e 1 , . . . , e n i be a match window for a pattern P . An event pat-tern matching algorithm , A ( P, W ) , takes P and W as input and returns the set of all matches that start at e 1 .

A can be any event pattern matching algorithm that returns matches that start at event e 1 . To make the discussion more con-crete, we assume an automaton-based algorithm, such as the SES pattern matching algorithm [5]. In the evaluation we also apply our framework to ZStream, which uses join trees.

Example 7. Consider pattern P 1 and the match windows W 1 and W 2 in Fig. 4. A ( P 1 , W 1 ) returns a single match { c/ h e p/ h e 3 , e 9 i , b/ h e 11 i} that starts at e 1 . In contrast, A ( P the second match window returns the empty set since no match starts at e 2 .

An eager instantiation of automata for each incoming event might lead to a large number of concurrent instances in memory, whereas a lazy instantiation strategy reduces this number.
While the lazy initialization of automata reduces the number of concurrently active automaton instances, filtering aims at reducing the number of events that need to be processed by A . For this we analyse each incoming event for the properties specified in the pattern.

Not all events in the match window are candidates for matching a variable in the query pattern. Events that cannot contribute to any match can be filtered out before they are passed to A . The following theorem specifies a condition that must be satisfied by each event in a match.

T HEOREM 1. Let P = ( B,  X  ,  X  ) be a pattern with variables v , . . . , v m and  X  be a match of P in E . Each event e in  X  satisfies P ROOF : see Appendix A.

From Theorem 1 we can conclude that an event e  X  E can only Therefore, we can filter out events that do not satisfy this condition, which leads to a reduction of the events that must be processed by algorithm A . Notice that only a subset of  X  need to be checked.
Example 8. Consider pattern P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) and match window W 1 in Fig. 4. All events e i that contribute to a match must satisfy  X  p c ( e i )  X   X  p p ( e i )  X   X  equivalent to e i . L =  X  X  X   X  e i . L =  X  X  X   X  e i . L =  X  X  X . Refer-ring to relation Chemo , we can easily verify that all events except e satisfy this condition. Thus, e 6 can safely be filtered out and need not to be buffered. W 1 and W 2 from Fig. 4 become W  X  h e , . . . , e 5 , e 7 , . . . , e 12 i and W  X  2 = h e 2 , . . . , e spectively.
While filtering checks for each individual event whether it sat-isfies the properties of at least one variable, here we consider all events in a match window together and formulate conditions that must be satisfied for a match that starts with the first event in the match window. Match windows that do not satisfy these conditions need not to be passed to A .
The following theorem specifies necessary conditions for a match window to contain a match that starts at the first event.
T HEOREM 2. (Necessary Match Conditions) Let P = ( B,  X  ,  X  ) be a pattern with B = h B 1 , . . . , B k i and variables v , . . . , v m . A match window, W = h e 1 , . . . , e n i , that contains a match starting at e 1 satisfies the following conditions: | W |  X  m, (4)  X  v  X  B 1 ( X  p v ( e 1 )) , (5)  X  v  X  { v 1 , . . . , v m } X  e i  X  W ( X  p v ( e i )) , (6) P ROOF : see Appendix A.

Theorem 2 allows to selectively pass match windows to algo-rithm A , thereby reducing the number of calls to A . A match win-dow that does not satisfy the necessary match conditions cannot contain a match that starts with the first event in the window.
Example 9. Consider P 1 = ( h{ c, p + } , { b }i ,  X  , 15d) and match is a candidate match window since the necessary match conditions are satisfied: the cardinality of the match window, | W  X  greater than the number of variables, which is 3 (Cond. 4); event e satisfies all properties of c in B 1 (Cond. 5); e 1 , e 3 all properties of c , p , and b , respectively (Cond. 6), and their order corresponds to the order of B 1 and B 2 (Cond. 7). Next, consider window, since e 2 does not satisfy all properties of c or p (Cond. 5). Hence, W  X  2 cannot contain a match that starts at e 2 .
Verifying Cond. 4 and 5 of the necessary match conditions is efficient and can be done incrementally as the individual events arrive. This is not the case for Cond. 6 and 7, for which all events in the match window must be considered. We maintain a summary statistics over the match window that can be updated incrementally and allows to efficiently verify the conditions.

Definition 5. ( Summary Statistics ) Let W be a match window and P = ( B,  X  ,  X  ) be a pattern with B = h B 1 , . . . , B and variables v 1 , . . . , v m . A summary statistics , S = h ( v 1 , cnt 1 ) , . . . , ( v m , cnt m ) i , is a set of variable-counter pairs such that for each v i  X  B i cnt i = |{ e i  X  W |  X  p v i ( e i )  X   X  v j  X  B i  X  1  X  e The summary statistics maintains a counter for each variable . The counter for a variable v i  X  B i records the number of events in W that (1) satisfy all properties of v i and (2) chronologically follow events in W that satisfy the properties of the variables in the previous set B i  X  1 .

Example 10. Consider P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) and match window W = h e 1 , e 2 , e 3 i . The summary statistics for W is S = h ( c, 1) , ( p, 1) , ( b, 0) i . Events e 1 and e ties of c and p , respectively, and there is no previous set B P . Although e 2 satisfies all properties of variable b , its counter is zero since there is no event in W that occurs before e 2 and satisfies the properties of p .

T HEOREM 3. Let P be a pattern with variables v 1 , . . . , v be a match window, and S = h ( v 1 , cnt 1 ) , . . . , ( v summary statistics. The necessary match conditions 6 and 7 are satisfied if cnt 1 &gt; 0  X   X   X   X   X  cnt m &gt; 0 .
 P ROOF : see Appendix A.

The summary statistics is incrementally updated when input events enter or exit W . When a new event e is added, the properties are evaluated. If e satisfies all properties of a variable v  X  B the counters of all variables from the previous set B i  X  1 than zero (i.e., W contains a matching event for these variables), cnt i is incremented by one. When the first event, e , is dequeued from the match window, the counter for each variable whose prop-erties are satisfied by e is decremented. If the counter for a variable v  X  B i becomes zero, the counters of all variables in the sets B j &gt; i , are reset to zero.

Example 11. Figure 5 shows the summary statistics for a match window W that buffers events of patient 1. The last four columns show the fulfillment of the necessary match conditions. Event e increments the counter for c . Event e 2 matches b , but has no effect on the statistics, since the counter for p is zero. After reading e counters are greater than zero, and the necessary match conditions are satisfied. Since the next event exceeds the duration of 15 days, the pattern match algorithm is called with W . Next, e 1 is removed from W and the summary statistics is updated. Since the counter for c becomes zero, the counter for b is reset to zero.
The summary statistics provides an approximate solution and might produce false positives (e.g. due to relationships between variables that are not encoded in the statistics). We show experi-mentally that the number of match candidates can be significantly reduced.
The last optimization aims to further reduce the number of events in a match window that are processed by algorithm A . The core idea is to remove events that, while fulfilling the properties of a variable, can be excluded from a match since they violate some relationships. If all events in a match must have identical values in one or more attributes, the corresponding equality relationships in  X  can be used to partition a match window W into a set of match windows W 1 , . . . , W n .

To formalize the partitioning of match windows based on equal-ity relationships, we first define the transitive closure of these relationships. Let P = ( B,  X  ,  X  ) be a pattern with variables v , . . . , v m and  X  eq = {  X  |  X   X   X   X   X   X  v i .A i = v j the set of all relationships with equality constraints over a single attribute. The transitive closure of  X  eq is defined as where  X  0 eq =  X  eq and  X  l eq = { v i .A i = v j .A i |  X  v v
Definition 6. ( Partitioned Match Windows ) Let W be a match window for a pattern P = ( B,  X  ,  X  ) with variables v 1 , . . . , v Furthermore, let X = { A |  X  i, j  X  [1 , m ](( v i .A = v eq ) } . The set of attributes X partitions W into W 1 , . . . , W that for each W i the following holds:
X is a maximal set of partitioning attributes that have to assume identical values for all events in a match. Accordingly, all events in a partition have identical values in the attributes X .
Example 12. Consider P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) . The transitive closure of the equality relationships is  X  eq = { c. PID = p. PID , c. PID = b. PID , p. PID = b. PID , c. PID = c. PID , p. PID = p. PID , b. PID = b. PID } . The set of partitioning at-tributes is X = { PID } . That is, all events in a match must have the same patient ID. Partitioning W  X  1 = h e 1 , . . . , e by PID results in two partitions, h e 1 , e 2 , e 3 , e 9 tient 2.
 Partitioning input events allows two types of optimizations. First, since each partition W i can be processed independently by algorithm A , parallel event processing is possible. Second, after partitioning, the relationships v i .A i = v j .A i for all A not to be considered anymore by A . They can be removed from  X  before calling A to reduce conditions that need to be verified in A .
Algorithm 1 implements the two-phase pattern matching strategy from the previous section. The input parameters are a pattern P , an event relation E , and an event pattern matching algorithm A . The algorithm returns the set of all matches.

In the initialization phase, an empty hash table H and result set R are created, and the set X of partitioning attributes is determined, which serves as a key for the hash table. H stores triples of the form ( K, W, S ) , where K = X are the grouping attributes, W is a match window, and S is the summary statistics over W .

The main loop iterates over all input events in chronological or-der. Events that do not satisfy the properties of any variable are immediately filtered out. For events that pass the filter, the corre-sponding entry in H is retrieved; if no such entry exists, a new entry is added with key set to the values of the partitioning attributes of the current event, an empty match window, and a summary statis-tics with all counters set to zero. Before inserting the current event e in W , the algorithm ensures that W does not exceed  X  when the Algorithm 1 : M atch ( P, E, A ) event is added. If e  X  s distance from the first event in W exceeds  X  , the necessary match conditions are verified; if they are satisfied, al-gorithm A is called. Afterwards, the first event is removed from W and the summary statistics is updated. This step is repeated until e fits into W and can be added; the summary statistics is updated.
After reading all input events, the remaining events in the match windows need to be processed. As long as the necessary match conditions are satisfied, A is called and the first event is removed.
The summary statistics can efficiently be implemented using bit vectors. Let P = ( B,  X  ,  X  ) be a pattern with B = h B 1 and variables v 1 , . . . , v m . We use a bit vector,  X  e mask each incoming event e i . Each position in the bit vector cor-responds to a variable in P . If a bit is 1 , the event satisfies all properties of the corresponding variable; otherwise it is set to 0 . Similarly, we use a bit vector,  X  s , where each position corresponds to a counter in the summary statistics. A 0 bit means that the corre-sponding counter is greater than zero; otherwise the counter is zero. Finally, we specify a bit mask,  X  b i , for each B i . It has all bits set to 0 except for the bits that represent the positions of the variables in the previous event set, B i  X  1 . Using these bit vectors in com-bination allows an efficient update and querying of the summary statistics.

Example 13. Consider P 1 = ( h{ c, p + } , { b }i ,  X  , 15 d) and the but not for p and b . The corresponding bit vector is  X  e the events e 2 and e 3 the bit vectors are, respectively,  X  e  X  e = 010 . The bit vector for the summary statistics is  X  s = 111 at the beginning and 001 after processing e 1 , e 2 , and e 3 The bit mask for event set B 1 is  X  b 1 = 000 ; for B 2 it is
In this section, we report the results of an empirical evaluation using real-world data. The experiments have three purposes: (1) to show the effect of the match window on the automaton-based SES pattern matching algorithm [5] that finds earliest and maxi-mal matches and on the join-based ZStream pattern matching algo-rithm [12] that finds all matches; (2) to show the scalability of the match window in the pattern, and (3) to show the scalability of the match window in the data.
We implemented our two-phase matching strategy with the SES algorithm and ZStream algorithm in C. The event relation is stored in an Oracle database, Enterprise Edition 11.1, which is accessed over the OCI API. The experiments were performed on a PC with four AMD Opteron 285 processors with 1 . 8 and 2 . 6 GHz and 16 GB memory, on which a 64 -bit Linux 2.6.32 is installed.
We use two different real-world data sets. The Onco data set con-tains 341055 chemotherapy events from the Department of Haema-tology at the Hospital Meran-Merano. The NYSE data set contains 1 M share trades in stock markets over 34 hours [14].

In the experiments, we analyze the scalability by varying the number of variables, the length of  X  , and the size of the event rela-tion. For the experiments with a varying number of variables, we use the following two query patterns: The number of variables varies from k = 1 , . . . , 10 . For each step, we randomly choose ten distinct patterns out of all possible patterns with k variables, and we take the average of the measured throughput. The duration  X  is 10 days for the Onco data set and 20 ms for the NYSE data set. P seq is a sequential pattern where the matching events must occur in the same order as the variables in the pattern. In P set the matching events may occur in any order.
For the experiments with a varying length of  X  , we use the fol-lowing patterns. P onco roughly resembles a cycle of a chemotherapy treatment. b matches white blood cell counts, h red blood cell counts, and the rest different medication administrations. Partitioning is applied on the patient ID. P nyse specifies that a , g , and i match share trades of Apple, Google, and IBM, respectively. The price of the Apple and Google shares must be increasing between trades (i.e., prev( a. price) &lt; a. price ), followed by a decrease of IBM shares (i.e., prev( i. price) &gt; i. price ). Apple and Google share trades can occur interleaved. We vary  X  from 5 days to 50 days for the Onco data set and from 10 to 100 ms for the NYSE data set.
 For the experiments with a varying size of E , we use the pattern P nyse and vary the size of E from 100 to 1000000 events in steps of a factor 10 .
In this experiment, we study the scalability of our framework by varying the number of variables and the length of  X  in the pattern, respectively. Our hypothesis is that match windows significantly increase the throughput.

We first run the SES and ZStream algorithms with a plain match window without any pruning techniques (baseline), and apply then filtering (f), partitioning (p), and testing for necessary match con-ditions (c). The performance of the optimizations is measured in terms of throughput increase with respect to the baseline algorithm.
Figures 6 and 7 show the factor of the throughput increase of the various pruning techniques relative to the baseline algorithm. The first observation is that the match windows achieve a signifi-cant improvement over the baseline solution, up to several orders of magnitudes for P set .
 Second, the optimizations are more effective for SES than for ZStream. The reasons are that ZStream implicitly filters new events when they are added to the join tree, and it uses hash tables for the joins on equality predicates. However, filtering, partitioning and testing for necessary conditions together still increase the through-put three to four times.

The third observation is that for SES the optimizations are much more effective for P set (more than two orders of magnitude) than for P seq . With P set and without any pruning techniques, every event that matches any variable starts an automaton instance, yield-ing a large number of automaton instances, many of which do not lead to a match. With P seq , only events that match the first variable in the pattern start an automaton instance. The match windows have a larger potential to increase the throughput of P set than of P
The fourth observation is that the throughput for P onco increases with increasing duration  X  for SES. Events in the Onco data set follow roughly a chemotherapy protocol. Individual chemotherapy treatments are shifted in time, hence the patients are not distributed uniformly over the data. With increasing  X  , events of more patients are encountered, hence more partitions of match windows can be created. SES can fully exploit the increasing number of partitions.
In this experiment, we study the scalability of our framework by varying the number of events in the event relation. Our hypothe-sis is that the throughput increase remains constant with increasing size of the event relation. Again, we run first the baseline SES and ZStream algorithms on NYSE, and apply then filtering (f) and test-ing for necessary match conditions (c).

Figure 8 shows the factor of the throughput increase relative to the baseline algorithm. As expected, the throughput increase for our two-phase matching strategy when the pruning techniques are applied remains roughly constant. The reason is that neither the filtering nor the testing for necessary match conditions depends on the length of the event relation. Notice the logarithmic scale on the horizontal axis.
In this paper we presented a novel pattern matching strategy that consists of a pre-processing phase and a pattern matching phase. In the pre-processing phase, incoming events are buffered in a match window, which allows to apply different pruning techniques, such as filtering, partitioning, and testing for necessary match condi-tions, and aids a lazy evaluation of a pattern matching algorithm. We conducted extensive experiments using two real-world data sets and two existing event pattern matching algorithms. The results show that our framework significantly increases the throughput for both algorithms.

Future work is possible in various directions, including the in-vestigation of additional runtime optimizations to efficiently sup-port other event selection strategies (e.g. contiguous matches) as well as to explore space optimizations.
This work has been done within the framework of the MEDAN project, which is funded by the Hospital of Meran-Merano. [1] D. J. Abadi, Y. Ahmad, M. Balazinska, M. Cherniack, [2] D. J. Abadi, D. Carney, U.  X etintemel, M. Cherniack, [3] J. Agrawal, Y. Diao, D. Gyllstrom, and N. Immerman. [4] A. Arasu, S. Babu, and J. Widom. CQL: A language for [5] B. Cadonna, J. Gamper, and M. H. B X hlen. Sequenced event [6] D. Carney, U.  X etintemel, M. Cherniack, C. Convey, S. Lee, [7] S. Chandrasekaran, O. Cooper, A. Deshpande, M. J.
 [8] A. J. Demers, J. Gehrke, M. Hong, M. Riedewald, and W. M. [9] N. Dindar, B. G X  X , P. Lau, A. Ozal, M. Soner, and N. Tatbul. [10] L. Ding, S. Chen, E. A. Rundensteiner, J. Tatemura, W.-P. [11] L. Harada and Y. Hotta. Order checking in a CPOE using [12] Y. Mei and S. Madden. Zstream: A cost-based query [13] R. Motwani, J. Widom, A. Arasu, B. Babcock, S. Babu, [14] NYSE. http://www.nyxdata.com/. [15] R. Sadri, C. Zaniolo, A. Zarkesh, and J. Adibi. Expressing [16] F. Zemke, A. Witkowski, M. Cherniak, and L. Colby. Pattern
P ROOF . (Theorem 1) The constraints  X  consist of relation-ships and properties, i.e.,  X  =  X  r  X   X  p . The properties can further be partitioned by variable, i.e.,  X  p =  X  p v 1  X   X   X   X   X  m . By Def. 2, a match  X  satisfies I ( X   X  ) . This can be the variable it is bound to.

P R OOF . ( Theorem 2 ) Condition 4: Since a given event can only appear once in a match, W needs to contain at least as many input events as variables in the query pattern. Condition 5: By Def. 2, the earliest event in a match is bound to a variable in B the first event in W must satisfy the properties  X  p v of a variable v  X  B 1 . Condition 6: By Def. 2, each variable v 1 , . . . , v to at least one input event that satisfies the properties  X  W must contain such an event for each variable. Condition 7: By Def. 2, input events that are bound to variables v i , v j B s need to occur in the same chronological order as the B i P .

P R OOF . ( Theorem 3 ) cnt i is greater than zero iff there exists at least one event in the set specified by Cond. 8. Therefore, cnt 0  X   X   X   X   X  cnt m &gt; 0 is equivalent to  X  v  X  B 1  X  e  X  W ( X  p v ( e ))  X   X  v  X  B 2 , v  X   X  B 1  X  e, e  X   X  W ( X  p v ( e )  X   X  p v  X   X   X   X   X   X   X  v  X  B k , v  X   X  B n  X  1  X  e, e  X   X  W ( X  p v ( e )  X   X  p By applying the rule  X  x ( A  X  B )  X   X  x ( A )  X   X  x ( A  X  B ) to all quantified conjuncts we get  X  v  X  B 1  X  e  X  W ( X  p v ( e ))  X   X   X   X   X   X  v  X  B k  X  e  X  W ( X   X  1 &lt; i  X  n (  X  v  X  B i , v  X   X  B i  X  1  X  e, e  X   X  W ( which corresponds to Conds. 6 and 7.
