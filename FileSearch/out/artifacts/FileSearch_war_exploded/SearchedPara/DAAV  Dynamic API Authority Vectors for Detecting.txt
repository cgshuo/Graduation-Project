 This paper proposes a novel birthmark, a dynamic API au-thority vector ( DAAV ), for detecting software theft. DAAV satisfies four essential requirements for good birthmarks X  cr-edibility , resiliency , scalability , and packing-free  X  X hile ex-isting birthmarks fail to satisfy all of them together. In par-ticular, existing static birthmarks are unable to handle the packed programs and existing dynamic birthmarks do not satisfy credibility and resiliency. Our experimental results demonstrate that DAAV provides satisfying credibility and resiliency compared with existing dynamic birthmarks and also can cover packed programs.
 H.2.8 [ Database Management ]: Database Applications X  Data Mining Security Software theft detection, Similarity, Graph, Random walk
Along with the blossom of open source projects available on the Internet, such as Sourceforge.net, OSDir.com, and Freshmeat.net, software theft has become easy to commit. Such software codes are easily downloaded and incorporated into a new software product with serious disguises (i.e., rip-ping off the interface components of the original software and  X  C orresponding author.
 c they are n ot applicable to packed programs . Dynamic birth-marks should be employed these packed programs [9].
In this paper, we propose a novel dynamic birthmark, named dynamic API authority vector ( DAAV ), satisfying all the four requirements above.
DAAV is a vector whose dimension corresponds to an API used in the program, and the value of each dimension indi-cates an authority score , which represents how importantly the corresponding API is called by the program. To mea-sure such importance of each API, (1) we first construct a dynamic API call graph ( DACG ), which is a directed graph that represents caller-callee relationships between APIs. (2) Then, we figure out which APIs are in a core position in DACG and which are not by the notion of random walk with restart ( RWR ) [6, 1]. (3) Finally, the vector of the authority scores over all the APIs becomes DAAV .
Our design ensures DAAV to satisfy the four essential requirements as follows. Since RWR measures the impor-tance of each node in a graph by giving a high score to the nodes receiving a lot of edges and also to the nodes closely connected to those nodes that receive high scores, the char-acteristics related to both sequence and frequency of APIs are reflected in DAAV . For example, frequently called APIs may get a high score because they may be called by a num-ber of other functions, and some other APIs, even though they are rarely called, also may get a high score as long as they are called by those functions that are frequently called. As a result, DAAV is affected by not only the frequency but also the sequence of APIs . This property remedies deficien-cies that the previous sequence-based and frequency-based birthmarks have, making our birthmark more resilient and credible . Moreover, by generating an n -dimensional vector which inherits the structural characteristics of DACG , the problem of comparing the two DACG s becomes a quite sim-ple and scalable task even if the size of DACG is large. We compute the similarity between DAAV s very efficiently by using the cosine similarity [5]. Finally, DAAV is applicable even when target programs are packed since it is derived by runtime code, which is unpacked at runtime [9]. We note that our goal is to detect whole-program copy , where the pla-giarizer copies the whole of the plaintiff program and wraps it in a modified interface [8].
DACG has almost the same concept with a call graph [4] which has been widely known in software engineering context. The main difference between them is that DACG has both user-defined functions (UDFs) and APIs as nodes, while a call graph has only UDFs. Following is a formal definition of DACG .

Definition 3 ( dynamic API call graph ) It is a directed 2-tuple graph ( N , E ), which represents the caller-callee re-lationships among a set of APIs and UDFs in a program, where N and E satisfy the following conditions: Using R WR gives our system several benefits. First, the au-thority score of each API computed by RWR reflects not only the frequency but also the sequence information in calling APIs. Along the procedure of computing authority scores, RWR gives a high authority score to (1) the nodes that receive a lot of edges and (2) the nodes closely con-nected to the nodes that have already received high scores [6]. Thus, frequently-called APIs receive a high authority score through RWR , since their nodes are pointed by a num-ber of nodes or have some incoming edges with high weights due to iterative calls. Also, some APIs, even though they are rarely called, could get a high authority score if they are closely connected to nodes with a high authority score. In contrast, if APIs are rarely called and their pointing nodes have a low authority score, they are likely to get a low au-thority score as well. In conclusion, each authority score is strongly affected by both the frequency and the sequence of APIs. This makes our birthmark unique to each pro-gram because the frequency and the sequence of API calls are capturing unique program behaviors. Moreover, the ma-nipulation of API call frequencies or API call orders while maintaining a program X  X  original semantics is a difficult task, which indicates that our proposed birthmark is resilient.
Second, by a simple modification of Eq. (1), we can con-sider the popularity of each API. The popularity indicates how much the corresponding API is commonly used among many programs. There are general tasks for most programs, such as exception handling, memory management, and thread creation &amp; termination. The APIs which perform the gen-eral tasks may be frequently called in most programs. Thus, these APIs may receive high authority scores regardless of the kind of programs, eventually making different programs look similar [3, 2]. To address this problem, we measure each API X  X  popularity and reflect it to the process of computing authority scores. Specifically, we modify the probability val-ues in restart vector w in Eq. (1) by assigning a modified probability to each API node computed as follows: In Eq. (2), w ( AP I ) denotes a restart probability value cor-responding to the API in vector w . CF ( AP I ) corresponds to the call frequency of the corresponding API. PF ( API ) indicates the number of programs that call the API. Because popular APIs are used in most programs and also used fre-quently, Eq. (2) assigns a low probability in inverse propor-tion to the call frequency and the program frequency. This modification not only gives low authority scores to popu-lar APIs but also gives high authority scores to the APIs that are uniquely used in each program successfully. Thus, we can not only characterize each program but also make different programs look different.

The third advantage is computation efficiency. The sta-tionary authority scores for each node are obtained by it-erative computations of Eq. (1) until R t converges. The complexity of this computation is O ( n + e ) where n denotes the number of nodes and e the number of edges in the graph; thus our system requires a reasonable time even with a large size of DACG [14]. Two programs having similar DAAV s not only use similar APIs as their major important APIs and some other similar birthmark proposed by Jang [7]; static A PI-labeled CFG birthmark proposed by Chae [2]. We simply call them SEQ , FREQ , CA , and ACFG , respectively.
 Table 2: Comparisons with previous birthmarks
Table 2 shows the results of similarity analysis among pro-g rams. Five float numbers in each pair of cells represent similarity values between two programs shown in its column and row. From the upper left one in clockwise order, the numbers indicate the similarity computed by DAAV , SEQ , FRQ , CA , and ACFG .

Ideally, the similarity between the original program and its copy should be high ( resiliency ). Also, to avoid false alarms, it should be low in the case of two independently developed programs ( credibility ). The sequence-based birth-mark ( SEQ ) shows a satisfactory performance in credibility but a poor performance in resiliency. SEQ tends to indicate a low similarity between two different programs. However, it also tends to indicate a low similarity even between copied programs. As opposed to SEQ , frequency-based birthmarks, i.e., FRQ and CA , indicate a high similarity between copied programs. However, they mostly provide a high similarity between different programs too, which indicates their poor credibility. Since the frequency-based birthmarks lack the sequence information of APIs, they have difficulty in dif-ferentiating two different programs that use some APIs in common. Also, since the sequence-based birthmarks lack the frequency information of APIs, they are vulnerable to semantics-preserving modifications on programs.

In contrast, by considering the sequence and frequency information of APIs together, DAAV can have both ro-bustness against evasions and ability to differentiate differ-ent programs. Consequently, DAAV shows a low similarity between different programs and a high similarity between
