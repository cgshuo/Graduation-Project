 Periodic and quasi-periodic time series appear in many data mining applications, often due to internal closed-loop regulation or external phase-locking forces on the data sources. A time series X  temporary deviation from a periodic or quasi-periodic pattern constitutes a major type of anomalies in many applications. For example, an electrocardi ography (ECG) recording is n early periodic, as one X  X  heartbeat. Figure 1 shows an ECG signal where a disruption of periodicity is highlighted. This disruption of periodicity actually indicates a Premature Ven-tricular Contraction (PVC) arrhythmia [3]. As another example, Figure 4 shows the number of beds occupied in a tertiar y hospital. The time series suggests a weekly pattern X  X usy weekdays followed b y quieter weekends. If the weekly pat-tern is disrupted, then chaos often follo ws with elective surgeries being canceled and the emergency department being over -crowded, greatly impacting patient satisfaction and health care quality.

Time Series Discord captures the idea of anomalous subsequences in time series and has proven to be useful in a diverse range of applications (see for example [5,1,11]). Intuitively, a discord of a time series is a subsequence with the largest distance from all other non-overlapping subsequences in the time se-ries. Similarly, the 2nd discord is a subseq uence with the second largest distance from all other non-overlapping subsequences. And more generally one can search for the top-K discords [1]. Finding the discord for a time series in general requires comparisons among O ( m 2 ) pair-wise distances, where m is the length of the time series. Despite past efforts in building heuristics (e.g., [5,1]), searching for the discord still requires expensive computation, making real-time interaction with domain experts difficult. In addition, most of existing algorithms are based on the idea of indexing subsequences with a data structure such as a trie. Such data structures often have unintuitive parameters (e.g., word length and alphabet size) to tune. This means time consuming trial-and-error that compromises the efficiency of the algorithms.

Keogh, Lin, and Fu first defined time series discords and proposed a search algorithm named HOT SAX in [5]. A memory efficient search algorithm was also proposed later [11]. HOT SAX builds on the idea of discretizing and index-ing time series subsequences. To select th e lengths for index keys, wavelet decom-position can be used ([2,1]). Most recentl y, adaptive discretization has been pro-posed to improve the index for efficient dis cord search ([8]). In this paper, we pro-pose a fast algorithm to find the top-K discords in a time series without prebuild-ing an index or tuning parameters. For periodic or quasi-periodic time series, the algorithm finds the discord with much less computation, compared to results pre-viously reported in the literature (e.g., [5]). After finding the 1st discord, our algo-rithm finds subsequent discords with even less computation X  X ften 50% less. We tested our algorithm with a collection of datasets from [6] and [4]. The diversity of the collection shows the definition of  X  X uasi-periodicity X  can be very relaxed for our algorithm to achieve search efficiency. Periodicity of a time series can be easily assessed through visual inspection. The experiments with artificially gen-erated non-periodic random walk time series showed increased running time, but the algorithm is still hundreds of times faster than the brute-force search, without tuning any parameter.

The paper is organized as follows. Section 2 reviews the definition of time-series discord and existing algorithms for discord search. Section 3 introduces our direct search algorithm and explains ideas behind it. Section 4 presents empirical evaluation for the new algorithm and a comparison with the results of HOT SAX from [5]. Section 5 concludes the paper. This section reviews the definition of time-series discord and major search algo-rithms.
 Notation. In this paper, T ( t 1 ,...,t m ) denotes a time series of length m .In addition, T [ p ; n ] denotes the length-n subsequence of T with beginning position p . The distance between two length-n subsequences T [ p ; n ]and T [ q ; n ] is denoted dist T,n ( p, q ). Following [5], we consider by default the Euclidean distance between two standardized subsequences X  X ll s ubsequences are standardized to have a mean of 0 and a standard deviation of 1. Nevertheless, the results in this paper apply to other definitions of distance. Given a subsequence T [ p ; n ], the minimum distance between T [ p ; n ]andany non-overlapping subsequence T [ q ; n ] is denoted d for d p,n . Finally we use d to denote the vector ( d 1 ,d 2 ,...,d m  X  n +1 ) and use  X  d and  X  d p to denote estimates for d and d p respectively.

For a time series of length m , there are at most 1 2 ( m  X  n  X  1)( m  X  n  X  dist T,n ( p, p ) == 0. Figure 3 shows a heatmap of the distances dist T,n ( p, q )for all p and q values of the time series xmitdb_x108_0 (see Figure 1).
 The following definition is reformulated from [5].
 Definition 1 (Discord). Let T be a sequence of length m .Asubsequence T [ p (1) ; n ] is the first discord (or simply the discord ) of length n for T if Intuitively, a discord is the most  X  X solated X  length-n subsequence in the space R n . Subsequent discords X  X he second discord, the third discord, and so on X  X f a time series are defined inductively as follows.
 of length n for a time series T . Subsequence T [ p ( k ) ; n ] is the k -th discord of length n for T if Note that the values for both n and k should be determined by the application; they are independent of the search algorithm. If a user was looking for three most unusual weeks in the bed occupancy example (Figure 4), k would be 3 and n would be 7  X  24, assuming the time series is sampled hourly. Strictly speaking, the discord is not well defined as there may be more than one location p that maximizes d p (i.e., d p 1 = d p 2 =max p { d p :1  X  p  X  m  X  n +1 } ). But the ambiguity rarely matters in most applications, especially when the top-K discords are searched in a batch. In this paper, we shall follow the existing literature [5] and assume that all d p  X  X  have distinct values.
 The discord has a formulation similar to the minimax problem in game theory. Note that max p min q { dist T,n ( p, q ): | p  X  q | X  n } X  min According to Sion X  X  minimax theorem [9], the equality holds if dist T,n ( p,  X  )is quasi-concave on q for every p and dist T,n (  X  ,q )isquasi-convexon p for every q . Figure 3 indicates, however, that in general neither dist T,n ( p,  X  )isquasi-concave nor dist T,n (  X  ,q ) is quasi-convex, and no global saddle point exists. That suggests searching for discords requires a strategy different from those used in game the-ory. In the worst case, searching for the discord has the complexity O ( m 2 ), essen-tially requiring brute-force computation of the pair-wise distances of all length-n subsequences of the time series. When m =10 4 , that means 100 million calls to the distance function. Nevertheless, the following sufficient condition for the discord suggests a search strategy better than the brute-force computation. Observation 1. Let T be a time series. A subsequence T [ p  X  ; n ] is the discord of length n if there exists d  X  such that In general, there are infinitely many d  X  that satisfies Clause (2) and Clause (3). Suppose we have a good guess d  X  . Clause (3) implies that a false candidate of the discord can be refuted , potentially in fewer than m steps. Clause (2) implies that, given all false candidates have been refuted, the true candidate for the discord can be verified in m  X  n + 1 steps. Hence in the best case, ( m  X  n +1)+( m  X  1) = 2 m  X  n calls to the distance function are sufficient to verify the discord. To estimate d  X  , we can start with the value of d p where p is a promising candidate for the discord, and later increase the guess to a larger and becomes the next candidate. This hill-climbing process goes on until all but one of the subsequences are refuted with the updated value of d  X  .
 This idea forms the basis of most existing discord search algorithms (e.g., HOT SAX in [5] and WAT in [1]); the common structure of these algorithms is shown in Figure 5. With this base algorithm, the effi ciency of a search then depends on the order of subsequences in the Outer and Inner loops (see lines 2 and 3). Intuitively, the Outer loop should rank p according to the singularity of subsequence T [ p ; n ]; the Inner loop should rank q according the proximit y between subsequences T [ p ; n ]and T [ q ; n ]. Both HOT SAX and WAT adopt the following strategy. Firstly all subsequences of length n are discretized and com pressed into shorter strings. Then the strings are indexed with a suffix trie X  X n the ideal situation, subsequences close in distance also share an index key or occupy neighboring index keys in the trie. This is not so different from the idea of hashing to achieve O (1) search time. In the end, all subsequences will be indexed into a number of buckets on the terminal nodes. The hope is that, with careful selection of string length and alphabet size, the discord will fall into a bucket containing very few subsequences while a non-discord subseq uence will fall into a bucket shared with similar subsequences. Then the uneven d istribution of subsequences among the buckets can be exploited to devise effici ent ordering for the Outer and Inner loops.

This ingenious approach however has two drawbacks. Firstly, one needs to select optimal parameters that balance the index size and the bucket size, which are critical to the search efficiency. F or example, to use HOT SAX, one needs to set the alphabet size and the word size for the discretized subsequences [5, Section 4.2]; WAT automat es the selection of word size, but still requires setting the alphabet size [1, Section 3.2]. Such parameters are not always intuitive to a user, as the difficulty of building a useable trie has been discussed in [11, Section 2]. Secondly, the above approach uses fixed/random order in the outer loop to search for all top-K discords. A dynamic ordering for the outer loop could potentially make better use of the information gained in the previous search steps. Also it is not clear how knowledge gained in finding the k -th discord can help finding the ( k + 1)-th discord. In [1, Section 3.6], partial information about  X  d is cached so that the inner loop may break quickly. But as caching works at the  X  X asy X  part of the search space X  X here d p is small, it is not clear how much computation is saved.

In the following section, we address the above issues by proposing a direct way to search for multiple discords. In particular, our algorithm requires no ancillary index (and hence no parameters to tune), and the algorithm reuses the knowledge gained in searching for the first k discords to speed up the search for the ( k + 1)-th discord. In Definition 1, the formula p (1) =argmax direct way to search for the discord with the following two steps: Step 1: Compute an estimate  X  d p of d p for each p .
 Step 2: Let p  X  arg max p  X  d p :1  X  p  X  m  X  n +1 ,andverifythat T [ p  X  ; n ]is Step 2 can be carried out by testing the condition d p  X   X  max p  X  d p , as justified by the following proposition.
 Proposition 1. Let  X  d be an estimate of d such that  X  d d .If d p  X   X  max p  X  d p , then d p  X   X  max p d p .
 Proof. With  X  d d ,wehave d p  X   X  max p  X  d p  X  max p d p .
 Proposition 1 gives a sufficient condition for verifying the discord of a time series. It shows that  X  d does not have to be close to d at every location p .Toverifythe discord, it suffices to have  X  d d and max d  X  max  X  d . This point is illustrated in Figure 2.
 To estimate d p =min q dist( p, q )inStep1,wecanuse  X  d p min q  X  Q p dist( p, q ). Here Q p is a subset of { q : | p  X  q | &gt;n }  X  X ence  X  d p  X  d p .As Q p includes more locations, the error  X  d p  X  d p becomes smaller. If Q p = { q : | p  X  q | &gt;n } ,then  X  d different p . Therefore Proposition 1 justifies the search strategy shown in Figure 6.
For top-K discords search, the while-loop (Line 2-10) is repeated K times (with proper book keeping to exclude overlapping subsequences). As  X  d s keeps decreasing in the computation, every time we start with a better estimate  X  d in Line 3. 3.1 Efficient Way to Estimate  X  d Figure 2 suggests that to find the discord, it is not necessary to have a highly accurate estimate of  X  d p for every p . Instead, highly accurate  X  d p is needed only when d p is relatively large. To minimize the total computation cost, we should distribute computational resources according to the importance of  X  d p .
We propose three operations to estimate d p , with increasing level of compu-tation cost. 1. Traversing : Suppose that dist( p, q p ) is known to be small for some q p .For 2. Sampling :Let Q p be a set of locations if d p is likely to be large or knowledge 3. Exhausting :Let Q p be all possible locations if the exact value of d p is Note that the most expensive Exhausting operation is needed only in verifying the discord (Line 4 in Figure 6).

The Traversing operation can be justified with the following argument. For a dist T,n ( p +1 ,q p +1) is likely to be small as well. The argument can be  X  X elescoped X  to other k values as long as k n is small enough. This is demonstrated in Figure 7, where local minima for s p  X  X  tend to cluster around some  X  X weet spots X  (the red circle). Therefore, in Tr aversing, a g ood estimate  X  d p =dist T,n ( p, q ) suggests a  X  X weet spot X  q around which good estimates  X  d p + k for neighboring positions ( p + k ) can be found.

The Sampling operation may be implemented with local search with a set of ran-dom starting points. But when the time series is nearly periodic or quasi-periodic, more efficient implementation exists. This will be discussed in the next section. 3.2 Quasi-Periodic Time Series Suppose a time series T is nearly periodic with a period l (i.e., t p t p  X  k  X  l ). ( ( ) ) as k  X  l  X  n for some k . Small distances associated with multiple times of the time-series period can be seen in Figure 7 X  X t locations around p + 360 and p +2  X  360 for each p in { 10 , 20 ,..., 100 } .
 With this observation, the following heuristic can be used to implement the Sampling operation for nearly periodic time series: a location q multiple periods away from p is likely to be near a local minimum for { dist T,n ( p, q ): q } .Figure8 shows the location q p =argmin series in Figure 1. It shows that in most cases a minimum-location q p is roughly multiple periods away from p .

There are a number of ways to estimate the period of a time series. For example, autocorrelation function (see Figure 9) and phase coherence analysis [7] are often used to estimate period.

As suggested in Figure 7, the gaps between local minima of a distance profile { dist T,n ( p, q ):1  X  q  X  m  X  n +1 } approximate the period of a time series, for dist T,n ( p, p + k  X  l ) 0. We use this observation to estimate period in this paper (see Figure 11). Figure 10 shows the collection of gaps {  X  k } for local minima of { dist T,n (1000 ,q ): q } ,where T is the time series in Figure 1 and n = 360. Taking the median of {  X  k } gives the estimate 354 for the period of the time series. Note that the period need to estimated only once (with the distance profile { dist T,n ( p, q ):1  X  q  X  m  X  n +1 } for only one location p ). Hence it takes only m  X  n calls to the distance function to estimate the period of a time series of length m . As a by-product, the exact value of d p is also obtained. 3.3 Implementation of the Search Strategy With heuristics for both Traversing and Sampling, Figure 12 implements Line 1 in Figure 6. The procedure uses a sequential covering strategy to estimate  X  d p for each p . In each iteration (the while loop from Line 2 to Line 10), a Sampling operation is done to find a  X  X weet spot X . Then a Traversing operation exploits that location to cover as many neighboring locations as possible.

The verification stage of our algorithm (Lines 2-10 in Figure 6) consists of a while loop which resembles the outer loop in HOT SAX and WAT. But here the order of location is dynamic, determined by the ever-improving estimate  X  d . Line 8 in Figure 6 further improves  X  d when the initial guess for the discord turns out to be incorrect. The improvem ent can be achieved by traversing with a better starting location q p  X  produced in Line 4 of Figure 6 (see Figure 13). As suggested by Figure 8, the  X  X est X  locations tend to cluster along the 45 degree lines. Moreover the large value of the initial estimate  X  d p  X  suggests the neighbor-hood of p  X  is a high-payoff region for further refinement of  X  d . As the traversing is done locally, the improvement step is relatively fast compared to the initial estimation step for d .

To sum up, we have described a new algorithm for discord search that con-sists of an estimation stage followed by a verification stage. The estimation stage achieves efficiency by dynamica lly differentiating locations p according to their potential influence to max p  X  d p . Further reduction in computation cost comes from the periodicity of a time series. In general, the Traversing heuristic works best when a time series is smooth (or equivalently densely sampled), while the Sam-pling heuristic works best when the periodicity of the time series is pronounced. The algorithm is guaranteed to halt and to return the discord by Observation 1. The efficiency of the algorithm has been evaluated in the following section. In this section, we first compare the performance of our direct-discord-search algorithm with the results reported for HOT SAX in [5]. We then report the performance of our algorithm on a collection of time series which are publicly available. Following the tradition estab lished in [5] and [1], the efficiency of our algorithm was measured by the number of calls to the distance function, as apposed to wall clock or CPU time. Since our algorithm entails no overhead of constructing an index (in contrast to the algorithms in [5] and [1]), the number of calls to the distance function is roughly proportional to the total computation time involved. As shown in [2] and [1], the performance of HOT SAX depends on the parameters selected . Here we assume that the metrics reported in [5] were based on optimal parameter values.

To compare to HOT SAX, we use the dataset qtdbsel102 from [6]. Although several datasets were used in [5] to evaluate the performance of HOT SAX, this is the only one readily available to us. The dataset qtdbsel102 contains two time series of length 45 , 000; we use the first one as the two are highly correlated.
Following [5], we created r andom excerpts of length { 1000  X  2 k :0  X  k  X  5 } from the original time series 1 . For each length configuration, 100 random ex-cerpts were created and the top 3 discords of length 128 were searched for.
Table 1 shows the mean and the standard error for numbers of calls to the distance function. The rightmost column of the table contains the mean perfor-mance metric visually estimated from Figure 13 of [5]. Similar information is also visualized in Figure 14. The figure plots the numbers of calls to the distance function for 6  X  3  X  100 runs of the direct-discord-search algorithm. Each point corresponds to one run of discord search; horizontal jitter was applied to reduce overlaps among points. The dashed intervals estimate the average number of calls to the distance function by HOT SAX. Loess lines for the costs of searching for top-3 discords are also plotted. We can see that for the 1st discord, the average number of calls by the direct search algorithm (the red line) is roughly linear to the size of the time series excerpts. Mo reover, these numbers are significant smaller than the numbers reported for HOT SAX (summarized with the dashed intervals). For subsequent discords, the average numbers of calls to the distance function (the blue line and the green line) decrease significantly, due to informa-tion gained from prior computation. The metrics for the second and the third discords also show larger variance: some points are significantly higher or lower than the loess lines. A likely cause is that the complete time series contains only a number of truly anomalous subsequences (discords): When a random excerpt of the time series includes only one (or two) of these discords, searching for the second (or the third, respectively) discord will be difficult. (Note the plot uses the log scale for x and y axes.)
In the second set of experiments, we search for the top 3 discords for a col-lection of time series from [6] 2 and [4], using the proposed algorithm. For time series from [6], the discord lengths are chosen to be consistent with configura-tions used in [5]. The results are shown in Table 2. Many of these datasets, in particular 2h_radioactivity , demonstrate little periodicity. The results show that our algorithm has reasonable per formance even for such time series. In Table 2, the results for the time series nprs44 are particularl y interesting. For nprs44 , no significant reduction in computation is observed for computing the 2nd and the 3rd discords. To find out why, we plot the time series and the estimated d vector in Figure 15. The figure shows that the 2nd and the 3rd discords are not noticeably different from other subsequences.
 Completely nonperiodic case. Completely nonperiodic time series rarely exist in applications, and they can be easily identified through visual inspection of the time series or their autocorrelation function. In an unlikely situation where our algorithm is blindly applied to a completely nonperiodic time series, a bad estimation of period will reduce the effici ency of the algorithm. To demonstrate this, we generate two random walk time series T with t p = p i =1 Z i ,where Z i are independent normally-distributed random variables with mean 0 and variance 1 (see Figure 16). Random walk time series i s interesting in two aspects: firstly a random walk time series is completely nonperiodic; secondly every subsequence of a random walk can be regarded as equally anomalous.

We applied the algorithm to find the top-3 discords in the two random-walk time series. The results are shown in Table 3. Without tuning any parameter, the algorithm is still hundreds of times faster than the brute-force computation of all pair-wise distances.

To sum up, our experiments show clear p erformance improvement on quasi-periodic time series by the proposed direct discord-search algorithm. Our algo-rithm also demonstrates consistent performance across a broad range of time series, with varying degree of periodicity. The paper has introduced a parameter-free algorithm for top-K discord search. When a time series is nearly periodic or q uasi-periodic, the algorithm demon-strated significant reduction in computation time. Many applications generate quasi-periodic time series, and the assumption of quasi-periodicity can be assessed by simple visual inspection. Therefore our algorithm has wide applicability.
Our results have shown that periodicity is a useful feature in time-series anomaly detection. More theoretical study is needed to better understand the effect of peri-odicity on the search space of time-series discords. We are also interested in know-ing to what extent the results in this paper can be generalized to chaotic time series [10].
One limitation of the proposed algorithm is that the time series need to be fit into the main memory. Hence the algorithm requires O ( m ) memory. One future direction is to explore disk-aware approximations to the direct-discord-search algorithm. When the time series is too large to be fitted into the main memory, one needs to minimize the number of disk scans as well the number of calls to the distance function (see [11]).

Another direction is to explore alternative ways of estimating the d vector so that the number of iterations for refining  X  d is minimized. We also are looking for ways to extend the algorithm so that the periodicity assumption can be removed. Support for this work was provided by an Australian Research Council Linkage Grant (LP 0776417). We would like to thank anonymous reviewers for their helpful comments.

