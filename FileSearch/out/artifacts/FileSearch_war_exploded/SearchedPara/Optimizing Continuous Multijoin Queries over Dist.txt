 Categories and Subject Descriptors: H.2.4 [Database Management]: Systems X  query processing,distributed databases General Terms: Performance Keywords: query processing, query optimization, data streams, distributed databases
Many recently emerging applications, such as network management, financial monitoring, sensor networks, stock tickers etc, fueled the development of continuous query pro-cessing techniques over data streams. In these applications, the data sources are typically distributed, e.g. the network hosts or routers in network management. Collecting all the data to a centralized server may not be cost-effective due to the high communication cost. Clearly, a distributed stream processing system is inevitable. Unlike traditional DBMS, where the processing in each node involves expensive I/O operations, stream processing systems often perform main memory operations. These operations are relatively inex-pensive in comparison to the communication cost. As both the queries and data streams are continuous, a few existing work focus on minimize the communication cost, especially when the source nodes are connected by wide area network. In this paper, we focus on multi-way window join query. Let us look at an example drawn from the network manage-ment application.

Example 1. We want to monitor the traffic that passes through three routers and has the same destination host within the last 0.5 seconds. Data collected from the three routers feed three streams s 1 , s 2 and s 3 to three processing nodes. The content of each stream tuple includes the destination host ip dest of a data packet and possibly other informa-tion. This task can be represented in a three-way window the window size of each stream is 0.5 seconds. 2
In Table 1,  X  i denotes the rate of stream S i and  X  a i denotes the rate of tuples from S i whose value in the dest attribute is a . Furthermore, S i,j is the result stream of S i 1 S rate is denoted as  X  i,j . The minimum communication cost that can be achieved under different schemes are as follows: 1. Centralized scheme: The best plan in this category is to send both S 2 and S 3 to n 1 . If we assume the tuple size of every stream is 1 byte, then this scheme results in com-munication cost of  X  2 +  X  3 = 100 . 1(bytes/sec). 2. Distributed scheme: In this category, the best plan is to send S 3 to n 2 first and then ship the result S 2 , 3 we assume the tuple size of a join result tuple is the sum of the two input tuples, we can derive the communication cost of this plan as  X  3 +  X  2 , 3  X  2  X  54 . 03(bytes/sec). 3. Partitioned-based scheme: Taking a closer look at the problem, we can find that the arrival rates of tuples vary with different values in the joining attributes. Furthermore, the popularity of the values in different streams also vary. Hence the optimal plans for these tuples are also different. For example in Table 1, dest = a is popular in S 3 while it is unpopular in the other two streams. Hence the best plan for these tuples is to ship them from S 2 to n 1 to join with S and then the resulting tuples are sent to n 3 to join with S This results in the cost of 0 . 036 (bytes/sec). However, for those tuples with dest = b , the best plan is totally different: those tuples from S 3 should be sent to n 1 and then to n By exploiting this characteristic, the minimum communica-tion cost that we can get for Example 1 is approximately 0 . 07 (bytes/sec).

We make the following contributions in this paper.  X  We formulate the problem and propose a heuristic-based optimization algorithm which uses a rate-based cost model, to minimize the communication cost of the plan.  X  To further reduce the communication cost, we propose a novel join scheme: partition-based join. We also study different partitioning strategies (e.g., rate-based, hash, etc).  X  We fully implemented the system and run a simulation study. The study showed the efficiency of our techniques.
In this technique, a stream is routed in its entirety around the nodes (or the operators). To decide the location of the join operations as well as the routing order of the tuples for a given query Q , a heuristic algorithm is proposed. The intuition of the optimization is to send the slower streams over the network. For example, consider a join between two streams from two nodes, sending the stream with the slower arrival rate over to the other node can achieve a smaller communication cost in comparison to the opposite approach.
The above stream-based join scheme can be applied to all kinds of join queries. However, it cannot exploit the different characteristics of the different substreams. In a partition-based scheme, we semantically partition each stream S i into D substreams S 1 i , S 2 i , . . . , S D i based on the values on the joining attribute. This is based on the observation that the arrival rates of tuples with different values may vary much inside each single stream. Hence the optimal processing plan for these tuples are different. We denote the rate of a sub-stream S k i as  X  k i .
In this subsection, we will look at how the partition-based join can be applied to a multi-way join queries whose join predicates are specified on a single attribute, say attr . This kind of queries is common in a lot applications, such as Ex-ample 1 in Section 1. Furthermore, these could also be a subset of predicates in a multi-way join query that are spec-ified on the same attribute. We propose a scheme that is called Partition-based Multi-way Join (PMJoin) to evalu-ate this set of join predicates. Every stream involved in these join predicates is partitioned into multiple substreams based on attr . The substreams of all the streams can be grouped into D groups. The k th group of substreams is { S 1 , S k 2 , . . . , S k |N| } . For each group of substreams, we can use the heuristic algorithm proposed in the stream-based join scheme to decide the allocation of the join operations.
To get the lowest cost, we can partition each stream into as many substreams as possible. For example, we can put tuples with each distinct value in the joining attribute into one substream. Let the number of these values be R then we could partition the stream into R substreams. However, it is clear that with more partitions, more plans have to be generated and it complicates the processing. So we adopt a more flexible approach where the number of partitions can be specified as any D . This can be viewed as clustering the above finest substreams (i.e., one substream per value) into D partitions. In the following discussions, we refer to these finest substreams as FStreams. We consider three ap-proaches: (1) Hash partition. A hash function can be applied to hash the value of the FStreams into one of the D buckets. The FStreams in each bucket compose a substream. This is actually a random partitioning method. (2) Range partition. Divide the data range into D sub-ranges. FStreams whose values fall into the i th sub-range compose the i th substream. (3) Rate-based partition. The above two approaches ig-nore the arrival rates of the various FStreams. A good partitioning method should put those groups of FStreams whose optimal plans are similar to each other in one par-tition. In this way, the generated plan for that partition would be good for all its FStreams. Here we use an ap-proximate approach to estimate the similarity of the opti-mal plans of two groups of FStreams. For each group of ing order of their arrival rates. Then we create a vector V where the i th element indicates the position of F S k i in the above sorted list. For example, if we have a sorted list as tween the k th and the l th groups of FStreams is measured by the distance between V k and V l , which is measured as | V k  X  V l | . The intuition is that the more similar the sorted lists of the two groups of FStreams are, the more similar their optimal plans would be. Now we can employ any clus-tering techniques to cluster the groups of FStreams into D clusters. In this paper, we adopt the k-Means approach.
For a generic multijoin query whose joins involve multiple attributes, our approach works as follows. The algorithm runs in three steps. First, we run our heuristic algorithm to determine the plan for the stream-based join scheme. Sec-ond, within the output plan, an algorithm is run to aggres-sively determine the subsets of join predicates where we can apply PMJoin. Third, we try to select some of the PMJoins from those found by the above step. Note that the result stream of a PMJoin, say S i may consist of a number of substreams that are located at more than one site. If this result stream has to join with another steam, say S j , on an-other attribute using PMJoin. We have to repartition the substreams of S i which are located at different sites. Fur-thermore, the substreams of S i may have to be sent to all these different sites. This results in high communication cost. Therefore, we opt to impose two constraints on the application of PMJoin. (1) The input streams of a PMJoin should be located at a single node. That means a PMJoin cannot be the child of another PMJoin. (2) The right child of a MJoin operator cannot be a PMJoin operator. Other-wise, the other input streams of the MJoin operator have to be sent over to the output nodes of that PMJoin. Our heuristic, which is given below, favors those PMJoins that have high input stream rates. This is because they may pro-vide more opportunities to reduce the communication cost by using PMJoin. 1. Sort all the PMJoins on the total input stream rates. 2. Remove the one with the largest input stream rate. 3. Remove the parent PMJoin (if any) from the sorted 4. If the list is not empty go to step 2.
We conducted a performance study of our proposed tech-niques whose detail can be found in [1]. First, by comparing to the optimal algorithm, we show that our stream-based heuristic algorithm works well in minimizing communica-tion cost under different situations. Second, it is shown that PMJoin can further reduce the communication cost signif-icantly. From our experiment, 45% of the communication cost can be reduced even partitioning a stream into only 2 substreams. Furthermore, range partition works well when the data  X  X otspots X  are contiguous but it works the worst if the  X  X otspots X  are randomly distributed. In contrast, our rate-based partitioning works the best in both situation. Fi-nally, another set of experiments shows that our heuristic algorithm that searches for opportunities to apply PMJoin performs better than two simpler algorithms. [1] Y. Zhou, Y. Yan, et al. Optimizing Continuous
