 Deep learning methods and convolutional neural networks (CNNs) among them have become de facto top performing techniques across a range of NLP tasks such as sentiment classification, question-answering, and semantic parsing. As methods, they require only limited domain knowl-edge to reach respectable performance with in-creasing data and computation, yet permit easy architectural and operational variations so as to fine tune them to specific applications to reach top performance. Indeed, their success is often con-tingent on specific architectural and operational choices.
CNNs for text applications make use of tem-poral convolution operators or filters. Similar to image processing, they are applied at multi-ple resolutions, interspersed with non-linearities and pooling. The convolution operation itself is a linear mapping over  X  X -gram vectors X  obtained by concatenating consecutive word (or character) representations. We argue that this basic build-ing block can be improved in two important re-spects. First, the power of n-grams derives pre-cisely from multi-way interactions and these are clearly missed (initially) with linear operations on stacked n-gram vectors. Non-linear interactions within a local context have been shown to improve empirical performance in various tasks (Mitchell and Lapata, 2008; Kartsaklis et al., 2012; Socher et al., 2013). Second, many useful patterns are expressed as non-consecutive phrases, such as se-mantically close multi-word expressions (e.g., X  X ot that good  X ,  X  X ot nearly as good  X ). In typical CNNs, such expressions would have to come to-gether and emerge as useful patterns after several layers of processing.

We propose to use a feature mapping operation based on tensor products instead of linear opera-tions on stacked vectors. This enables us to di-rectly tap into non-linear interactions between ad-jacent word feature vectors (Socher et al., 2013; Lei et al., 2014). To offset the accompanying parametric explosion we maintain a low-rank rep-resentation of the tensor parameters. Moreover, we show that this feature mapping can be applied to all possible non-consecutive n-grams in the se-quence with an exponentially decaying weight de-pending on the length of the span. Owing to the low rank representation of the tensor, this oper-ation can be performed efficiently in linear time with respect to the sequence length via dynamic programming. Similar to traditional convolution operations, our non-linear feature mapping can be applied successively at multiple levels.
We evaluate the proposed architecture in the context of sentence sentiment classification and news categorization. On the Stanford Sentiment Treebank dataset, our model obtains state-of-the-art performance among a variety of neural net-works in terms of both accuracy and training cost. Our model achieves 51.2% accuracy on fine-grained classification and 88.6% on binary clas-sification, outperforming the best published num-bers obtained by a deep recursive model (Tai et al., 2015) and a convolutional model (Kim, 2014). On the Chinese news categorization task, our model achieves 80.0% accuracy, while the closest base-line achieves 79.2%. Deep neural networks have recently brought about significant advancements in various natural lan-guage processing tasks, such as language model-ing (Bengio et al., 2003; Mikolov et al., 2010), sentiment analysis (Socher et al., 2013; Iyyer et al., 2015; Le and Zuidema, 2015), syntactic parsing (Collobert and Weston, 2008; Socher et al., 2011a; Chen and Manning, 2014) and ma-chine translation (Bahdanau et al., 2014; Devlin et al., 2014; Sutskever et al., 2014). Models applied in these tasks exhibit significant archi-tectural differences, ranging from recurrent neu-ral networks (Mikolov et al., 2010; Kalchbrenner and Blunsom, 2013) to recursive models (Pollack, 1990; K  X  uchler and Goller, 1996), and including convolutional neural nets (Collobert and Weston, 2008; Collobert et al., 2011; Yih et al., 2014; Shen et al., 2014; Kalchbrenner et al., 2014; Zhang and LeCun, 2015).
 Our model most closely relates to the latter. Since these models have originally been developed for computer vision (LeCun et al., 1998), their application to NLP tasks introduced a number of modifications. For instance, Collobert et al. (2011) use the max-over-time pooling operation to aggre-gate the features over the input sequence. This variant has been successfully applied to seman-tic parsing (Yih et al., 2014) and information re-trieval (Shen et al., 2014; Gao et al., 2014). Kalch-brenner et al. (2014) instead propose (dynamic) k-max pooling operation for modeling sentences. In addition, Kim (2014) combines CNNs of dif-ferent filter widths and either static or fine-tuned word vectors. In contrast to the traditional CNN models, our method considers non-consecutive n-grams thereby expanding the representation ca-pacity of the model. Moreover, our model cap-tures non-linear interactions within n-gram snip-pets through the use of tensors, moving beyond direct linear projection operator used in standard CNNs. As our experiments demonstrate these ad-vancements result in improved performance. document or sentence. Here L is the length of the sequence and each x i  X  R d is a vector represent-ing the i th word. The (consecutive) n-gram vector ending at position j is obtained by simply concate-nating the corresponding word vectors Out-of-index words are simply set to all zeros.
The traditional convolution operator is parame-thought of as n smaller filter matrices applied to each x i in vector v j . The operator maps each n-gram vector v j in the input sequence to m &gt; v j  X  R h so that the input sequence x is transformed into a sequence of feature representations, The resulting feature values are often passed through non-linearities such as the hyper-tangent (element-wise) as well as aggregated or reduced by  X  X um-over X  or  X  X ax-pooling X  operations for later (similar stages) of processing.

The overall architecture can be easily modified by replacing the basic n-gram vectors and the con-volution operation with other feature mappings. Indeed, we appeal to tensor algebra to introduce a non-linear feature mapping that operates on non-consecutive n-grams. N-gram tensor Typical n  X  gram feature map-pings where concatenated word vectors are mapped linearly to feature coordinates may be in-sufficient to directly capture relevant information in the n  X  gram. As a remedy, we replace concate-nation with a tensor product. Consider a 3-gram ( x 1 , x 2 , x 3 ) and the corresponding tensor product x 1  X  x 2  X  x 3 . The tensor product is a 3-way ar-ray of coordinate interactions such that each ijk entry of the tensor is given by the product of the corresponding coordinates of the word vectors Here  X  denotes the tensor product operator. The tensor product of a 2-gram analogously gives a two-way array or matrix x 1  X  x 2  X  R d  X  d . The n-gram tensor can be seen as a direct generalization Tensor-based feature mapping Since each n-gram in the sequence is now expanded into a high-dimensional tensor using tensor products, the set of filters are analogously maintained as high-order tensors. In other words, our filters are linear mappings over the higher dimensional interaction terms rather than the original word coordinates.
Consider again mapping a 3-gram ( x 1 , x 2 , x 3 ) into a feature representation. Each filter is a 3-way tensor with dimensions d  X  d  X  d . The set of h fil-ters, denoted as T , is a 4-way tensor of dimension d  X  d  X  d  X  h , where each d 3 slice of T repre-sents a single filter and h is the number of such filters, i.e., the feature dimension. The resulting h  X  dimensional feature representation z  X  R h for the 3-gram ( x 1 , x 2 , x 3 ) is obtained by multiplying the filter T and the 3-gram tensor as follows. The l th coordinate of z is given by The formula is equivalent to summing over all the third-order polynomial interaction terms where tensor T stores the coefficients.

Directly maintaining the filters as full tensors leads to parametric explosion. Indeed, the size of the tensor T (i.e. h  X  d n ) would be too large even for typical low-dimensional word vectors where, e.g., d = 300 . To this end, we assume a low-rank factorization of the tensor T , represented in the Kruskal form. Specifically, T is decomposed into a sum of h rank-1 tensors smaller parameter matrices. P i (similarly Q i , R i and O i ) denotes the i th row of the matrix. Note that, for simplicity, we have assumed that the num-ber of rank-1 components in the decomposition is equal to the feature dimension h . Plugging the low-rank factorization into Eq.(1), the feature-mapping can be rewritten in a vector form as where is the element-wise product such that, e.g., ( a b ) k = a k  X  b k for a,b  X  R m . Note that while Px 1 (similarly Qx 2 and Rx 3 ) is a lin-ear mapping from each word x 1 (similarly x 2 and x ) into a h -dimensional feature space, higher or-der terms arise from the element-wise products. Non-consecutive n-gram features Traditional convolution uses consecutive n-grams in the fea-ture map. Non-consecutive n-grams may nev-ertheless be helpful since phrases such as  X  X ot good  X ,  X  X ot so good  X  and  X  X ot nearly as good  X  ex-press similar sentiments but involve variable spac-ings between the key words. Variable spacings are not effectively captured by fixed n-grams.

We apply the feature-mapping in a weighted manner to all n-grams thereby gaining access to patterns such as  X  X ot ... good  X . Let z [ i,j,k ]  X  R h denote the feature representation corresponding to a 3-gram ( x i , x j , x k ) of words in positions i , j , and k along the sequence. This vector is calcu-lated analogously to Eq.(2), We will aggregate these vectors into an h  X  dimensional feature representation at each position in the sequence. The idea is similar to neural bag-of-words models where the feature representation for a document or sentence is obtained by averaging (or summing) of all the word vectors. In our case, we define the aggregate representation z 3 [ k ] in position k as the weighted sum of all 3-gram feature representations ending at position k , i.e., where  X   X  [0 , 1) is a decay factor that down-weights 3-grams with longer spans (i.e., 3-grams that skip more in-between words). As  X   X  0 all non-consecutive 3-grams are omitted, z 3 [ k ] = z [ k  X  2 ,k  X  1 ,k ] , and the model acts like a traditional model with only consecutive n-grams. When  X  &gt; 0 , however, z 3 [ k ] is a weighted aver-age of many 3-grams with variable spans.
 Aggregating features via dynamic program-ming Directly calculating z 3 [  X  ] according to Eq.(3) by enumerating all 3-grams would require O ( L 3 ) feature-mapping operations. We can, how-ever, evaluate the features more efficiently by re-lying on the associative and distributive properties of the feature operation in Eq.(2).

Let f 3 [ k ] be a dynamic programming table rep-resenting the sum of 3-gram feature representa-tions before multiplying with matrix O . That is, z [ k ] = O &gt; f 3 [ k ] or, equivalently, f 3 [ k ] = We can analogously define f 1 [ i ] and f 2 [ j ] for 1-grams and 2-grams, These dynamic programming tables can be calcu-lated recursively according to the following for-mulas: where s 1 [  X  ] and s 2 [  X  ] are two auxiliary tables. The resulting z [  X  ] is the sum of 1, 2, and 3-gram fea-tures. We found that aggregating the 1,2 and 3-gram features in this manner works better than us-ing 3-gram features alone. Overall, the n-gram feature aggregation can be performed in O ( Ln ) matrix multiplication/addition operations, and re-mains linear in the sequence length.
 The overall architecture The dynamic pro-gramming algorithm described above maps the original input sequence to a sequence of feature representations z = z [1 : L ]  X  R L  X  h . As in standard convolutional architectures, the resulting sequence can be used in multiple ways. One can directly aggregate it to a classifier or expose it to non-linear element-wise transformations and use it as an input to another sequence-to-sequence fea-ture mapping.

The simplest strategy (adopted in neural bag-of-words models) would be to average the fea-ture representations and pass the resulting aver-aged vector directly to a softmax output unit Our architecture, as illustrated in Figure 1, in-cludes two additional refinements. First, we add a non-linear activation function after each feature representation, i.e. z 0 = ReLU ( z + b ) , where b is a bias vector and ReLU is the rectified linear unit function. Second, we stack multiple tensor-based feature mapping layers. That is, the input sequence x is first processed into a feature se-quence and passed through the non-linear trans-formation to obtain z (1) . The resulting feature sequence z (1) is then analogously processed by another layer, parameterized by a different set of feature-mapping matrices P ,  X  X  X  , O , to obtain a higher-level feature sequence z (2) , and so on. The output feature representations of all these layers are averaged within each layer and concatenated as shown in Figure 1. The final prediction is there-fore obtained on the basis of features across the levels. Following standard practices, we train our model by minimizing the cross-entropy error on a given training set. For a single training sequence x and the corresponding gold label y  X  [0 , 1] m , the error is defined as, where m is the number of possible output label.
The set of model parameters (e.g. P ,  X  X  X  , O in each layer) are updated via stochastic gradient softmax ( output descent using AdaGrad algorithm (Duchi et al., 2011).
 Initialization We initialize matrices P , Q , R from uniform distribution similarly O  X  U each row of the matrices is an unit vector in expec-tation, and each rank-1 filter slice has unit variance as well, In addition, the parameter matrix W in the soft-max output layer is initialized as zeros, and the bias vectors b for ReLU activation units are ini-tialized to a small positive constant 0 . 01 . Regularization We apply two common tech-niques to avoid overfitting during training. First, we add L2 regularization to all parameter values with the same regularization weight. In addition, we randomly dropout (Hinton et al., 2012) units level. Datasets We evaluate our model on sentence sentiment classification task and news categoriza-tion task. For sentiment classification, we use the Stanford Sentiment Treebank benchmark (Socher et al., 2013). The dataset consists of 11855 parsed English sentences annotated at both the root (i.e. sentence) level and the phrase level us-ing 5-class fine-grained labels. We use the stan-dard 8544/1101/2210 split for training, develop-ment and testing respectively. Following previ-ous work, we also evaluate our model on the bi-nary classification variant of this benchmark, ig-noring all neutral sentences. The binary version has 6920/872/1821 sentences for training, devel-opment and testing.
 For the news categorization task, we evaluate on tains 10 different news categories in total, includ-ing Finance, Sports, Technology and Automobile etc. We use 79520 documents for training, 9940 for development and 9940 for testing. To obtain open-source Chinese NLP platform.
 Baselines We implement the standard SVM method and the neural bag-of-words model NBoW as baseline methods in both tasks. To as-sess the proposed tensor-based feature map, we also implement a convolutional neural network model CNN by replacing our filter with traditional linear filter. The rest of the framework (such as feature averaging and concatenation) remains the same.

In addition, we compare our model with a wide range of top-performing models on the sentence sentiment classification task. Most of these mod-els fall into either the category of recursive neural networks (RNNs) or the category of convolutional neural networks (CNNs). The recursive neural processor. network baselines include standard RNN (Socher et al., 2011b), RNTN with a small core tensor in the composition function (Socher et al., 2013), the deep recursive model DRNN (Irsoy and Cardie, 2014) and the most recent recursive model using long-short-term-memory units RLSTM (Tai et al., 2015). These recursive models assume the in-put sentences are represented as parse trees. As a benefit, they can readily utilize annotations at the phrase level. In contrast, convolutional neu-ral networks are trained on sequence-level, taking the original sequence and its label as training in-put. Such convolutional baselines include the dy-namic CNN with k-max pooling DCNN (Kalch-brenner et al., 2014) and the convolutional model with multi-channel CNN-MC by Kim (2014). To leverage the phrase-level annotations in the Stan-ford Sentiment Treebank, all phrases and the cor-responding labels are added as separate instances when training the sequence models. We follow this strategy and report results with and without phrase annotations.
 Word vectors The word vectors are pre-trained on much larger unannotated corpora to achieve better generalization given limited amount of training data (Turian et al., 2010). In particu-lar, for the English sentiment classification task, we use the publicly available 300-dimensional GloVe word vectors trained on the Common Crawl with 840B tokens (Pennington et al., 2014). This choice of word vectors follows most recent work, such as DAN (Iyyer et al., 2015) and RLSTM (Tai et al., 2015). For Chinese news categorization, there is no widely-used publicly available word vectors. Therefore, we run word2vec (Mikolov et al., 2013) to train 200-dimensional word vec-tors on the 1.6 million Chinese news articles. Both word vectors are normalized to unit norm (i.e. k w k 2 2 = 1 ) and are fixed in the experiments with-out fine-tuning.
 Hyperparameter setting We perform an exten-sive search on the hyperparameters of our full model, our implementation of the CNN model (with linear filters), and the SVM baseline. For our model and the CNN model, the initial learn-ing rate of AdaGrad is fixed to 0.01 for sentiment classification and 0.1 for news categorization, and the L2 regularization weight is fixed to 1 e  X  5 and 1 e  X  6 respectively based on preliminary runs. The rest of the hyperparameters are randomly cho-sen as follows: number of feature-mapping lay-ers  X  { 1 , 2 , 3 } , n-gram order n  X  { 2 , 3 } , hidden feature dimension h  X  { 50 , 100 , 200 } , dropout probability  X  { 0 . 0 , 0 . 1 , 0 . 3 , 0 . 5 } , and length de-cay  X   X  { 0 . 0 , 0 . 3 , 0 . 5 } . We run each config-uration 3 times to explore different random ini-tializations. For the SVM baseline, we tune L2 regularization weight C  X  { 0 . 01 , 0 . 1 , 1 . 0 , 10 . 0 } , word cut-off frequency  X  X  1 , 2 , 3 , 5 } (i.e. pruning words appearing less than this times) and n-gram feature order n  X  X  1 , 2 , 3 } .
 Implementation details The source code is implemented in Python using the Theano li-brary (Bergstra et al., 2010), a flexible lin-ear algebra compiler that can optimize user-specified computations (models) with efficient automatic low-level implementations, including (back-propagated) gradient calculation. 7.1 Overall Performance Table 1 presents the performance of our model and other baseline methods on Stanford Sentiment Treebank benchmark. Our full model obtains the highest accuracy on both the development and test sets. Specifically, it achieves 51.2% and 88.6% test accuracies on fine-grained and binary tasks re-formance is relatively stable  X  it remains high ac-curacies with around 0.5% standard deviation un-der different initializations and dropout rates.
Our full model is also several times faster than other top-performing models. For example, the convolutional model with multi-channel ( CNN-MC ) runs over 2400 seconds per training epoch. In contrast, our full model (with 3 feature layers) runs on average 28 seconds with only root labels and on average 445 seconds with all labels.

Our results also show that the CNN model, where our feature map is replaced with traditional linear map, performs worse than our full model. This observation confirms the importance of the proposed non-linear, tensor-based feature map-ping. The CNN model also lags behind the DCNN and CNN-MC baselines, since the latter two pro-pose several advancements over standard CNN.
Table 3 reports the results of SVM , NBoW and our model on the news categorization task. Since the dataset is much larger compared to the senti-ment dataset (80K documents vs. 8.5K sentences), the SVM method is a competitive baseline. It achieves 78.5% accuracy compared to 74.4% and Table 2: Analysis of average accuracy and stan-dard deviation of our model on sentiment classifi-cation task.
 Table 3: Performance of various methods on Chi-nese news categorization task. Our model obtains better results than the SVM, NBoW and traditional CNN baselines. 79.2% obtained by the neural bag-of-words model and CNN model. In contrast, our model obtains 80.0% accuracy on both the development and test sets, outperforming the three baselines by a 0.8% absolute margin. The best hyperparameter con-figuration in this task uses less feature layers and lower n-gram order (specifically, 2 layers and n = 2 ) compared to the sentiment classification task. We hypothesize that the difference is due to the nature of the two tasks: the document classifica-tion task requires to handle less compositions or context interactions than sentiment analysis. 7.2 Hyperparameter Analysis We next investigate the impact of hyperparame-ters in our model performance. We use the mod-els trained on fine-grained sentiment classification task with only root labels.
 Number of layers We plot the fine-grained sen-timent classification accuracies obtained during hyperparameter grid search. Figure 2 illustrates how the number of feature layers impacts the model performance. As shown in the figure, adding higher-level features clearly improves the classification accuracy across various hyperpa-rameter settings and initializations.
 Non-consecutive n-gram features We also an-alyze the effect of modeling non-consecutive n-and phrases with different sentiment in one sentence. Figure 2: Dev accuracy (x-axis) and test accuracy (y-axis) of independent runs of our model on fine-grained sentiment classification task. Deeper ar-chitectures achieve better accuracies. grams. Figure 3 splits the model accuracies ac-cording to the choice of span decaying factor  X  . Note when  X  = 0 , the model applies feature ex-tractions to consecutive n-grams only. As shown in Figure 3, this setting leads to consistent perfor-mance drop. This result confirms the importance of handling non-consecutive n-gram patterns. Non-linear activation Finally, we verify the ef-fectiveness of rectified linear unit activation func-Figure 3: Comparison of our model variations in sentiment classification task when considering consecutive n-grams only (decaying factor  X  = 0 ) and when considering non-consecutive n-grams (  X  &gt; 0 ). Modeling non-consecutive n-gram fea-tures leads to better performance. tion (ReLU) by comparing it with no activation (or identity activation f ( x ) = x ). As shown in Fig-ure 4, our model with ReLU activation generally outperforms its variant without ReLU. The obser-vation is consistent with previous work on convo-lutional neural networks and other neural network models. Figure 4: Applying ReLU activation on top of tensor-based feature mapping leads to better per-formance in sentiment classification task. Runs with no activation are plotted as blue circles. 7.3 Example Predictions Figure 5 gives examples of input sentences and the corresponding predictions of our model in fine-grained sentiment classification. To see how our model captures the sentiment at different lo-cal context, we apply the learned softmax ac-tivation to the extracted features at each posi-tion without taking the average. That is, for each index i , we obtain the local sentiment p = softmax W &gt; z (1) [ i ]  X  z (2) [ i ]  X  z (3) [ i ] . We plot the expected sentiment scores where a score of 2 means  X  X ery positive X , 0 means  X  X eutral X  and -2 means  X  X ery negative X . As shown in the figure, our model successfully learns nega-tion and double negation. The model also iden-tifies positive and negative segments appearing in the sentence. We proposed a feature mapping operator for con-volutional neural networks by modeling n-gram interactions based on tensor product and evaluat-ing all non-consecutive n-gram vectors. The as-sociated parameters are maintained as a low-rank tensor, which leads to efficient feature extraction via dynamic programming. The model achieves top performance on standard sentiment classifica-tion and document categorization tasks.
 We thank Kai Sheng Tai, Mohit Iyyer and Jordan Boyd-Graber for answering questions about their paper. We also thank Yoon Kim, the MIT NLP group and the reviewers for their comments. We acknowledge the support of the U.S. Army Re-search Office under grant number W911NF-10-1-0533. The work is developed in collaboration with the Arabic Language Technologies (ALT) group at Qatar Computing Research Institute (QCRI). Any opinions, findings, conclusions, or recommenda-tions expressed in this paper are those of the au-thors, and do not necessarily reflect the views of the funding organizations.

