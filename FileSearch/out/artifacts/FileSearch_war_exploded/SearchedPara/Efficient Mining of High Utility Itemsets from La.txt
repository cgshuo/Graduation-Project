 The goal of frequent itemset mining [1] is to find items that co-occur in a transaction database above a user given frequency threshold, without considering the quantity or weight such as profit of the items. However, quantity and weight are significant for addressing real world decision problems that require maximizing the utility in an or-ganization. The high utility itemset mining problem is to find all itemsets that have utility larger than a user specified value of minimum utility. Yao et al [2, 3] proposed a framework for high utility itemset mining. Recent research has focused on improv-ing the efficiency of high utility mining. Liu et al. [4] proposed a TwoPhase algorithm based on Apriori [1] to mine high utility itemsets, using a transaction weighted utility (TWU) measure to prune the search space. Their algorithm is suitable for sparse data sets with short patterns. We recently developed an algorithm named CTU-Mine [5] based on the pattern growth approach [6] that was efficient on dense data with rela-tively longer patterns. In [7], we proposed an algorithm named CTU-PRO for efficient mining of both dense and sparse data sets that fit into main memory. 
In this paper, we propose an algorithm named CTU-PROL for mining high utility itemsets from large datasets using the pattern growth approach [6]. The algorithm first identifies the large TWU items in the transaction database and if the dataset is relatively small, it creates a Compressed Utility Pattern Tree ( CUP-Tree ) for mining high utility itemsets. For data sets too large to be held in main memory, the algorithm creates subdi-visions using parallel projections that can be subsequently mined independently. For each anti-monotone property of TWU is used for pruning the search space of subdivisions in CTU-PROL , but unlike TwoPhase of Liu et al. [4], our algorithm avoids a rescan of the database to determine the actual utility of high TWU itemsets. The performance of CTU-PROL is compared against the implementation of the TwoPhase algorithm [4] available from [8] and also with CTU-Mine [5] . The results show that CTU-PROL outperforms previous algorithms on both sparse and dense datasets at most support levels. In this Section, we define the basic terms of high utility itemset mining based on [1, 2, where the items of each transaction T i is a subset of I . The quantity of an item i p in a subset of I . The utility of X in transaction T q , denoted by u ( X,T q ) is defined as: 
The utility of itemset X in the database, denoted by u(X) is defined as: 
The task of high utility itemset mining is to find all itemsets that have utility above a user-specified min_utility . Since utility is not anti-monotone, Liu et al. [4] proposed the concepts of Transaction Utility (TU) and Transaction Weighted Utility (TWU) to prune the search space of high utility items ets. Transaction Utility of a transaction, denoted tu(T q ) is the sum of the utilities of all items in T q : 
Transaction Weighted Utility of an itemset X , denoted as twu(X) is the sum of the transaction utilities of all the transactions containing X : 
As shown in [4], any superset of a low TWU itemset is also a low TWU itemset, and so we can prune all supersets of low TWU itemsets. However, since TWU is an over-estimation of the real utility value, high TWU itemsets will need to be pruned further. Consider a transaction database of a retailer as shown in Fig. 1(a), with exter-nal utility of each item as in Fig. 1(b). The values in each row of Fig. 1(a) shows the quantities of items bought in a transaction, and the last column contains the transac-tion utility with the total transaction utility of the database shown in the last row. From this sample data, we can compute, u ( 3 4, t 1 ) = $60, u ( 3 4, t 3 ) = $60, u ( 3 4, t 5 ) = $60, u ( 3 4 ) = $180 and twu ( 3 4 )=$262. In this section, we describe the CTU-PROL algorithm for mining large datasets, consist-ing of the following steps: (1) Create a GlobalItemTable by scanning the database to identify items of high TWU, (2) Subdivide the database by parallel projection of trans-actions with high TWU items, and (3) Mine each subdivision for high utility itemsets after constructing a Compressed Utility Pattern-Tree ( CUP-Tree ) for the subdivision. 3.1 Creating Global ItemTable A GlobalItemTable is constructed as explained in [5] and maps the item-ids to inte-gers in the descending order of their TWU values. Fig. 2 gives the GlobalItemTable for the database of Fig. 1, with a minimum utility of 10% of the total transaction util-ity (=129.9). Note that item 6 with TWU of 99 is pruned. The mapped new index of 1 to 5 correspond to the original items 5, 1, 2, 4, and 3 respectively. The terms mapped item id and item index are used synonymously in the rest of the paper. 3.2 Database Subdivision by Parallel Projection We adapt the concept of parallel projection reported in [10] for datasets that are too large for the corresponding CUP-Tree to fit into main memory. Using the Glob-alItemTable of Fig. 2, the original database is transformed into the mapped transac-tion database. Concurrently the parallel projection scheme is constructed. Fig. 3 illustrates the process for the database of Fig. 1 using the corresponding GlobalItem-Table . For item index i  X  2, every transaction t with positive quantity of items up to item i is written into the subdivision p i with the corresponding quantities and TWU. have entries for item index 1 and/or 2 that occur before index 3 in the transactions t 2 , t last subdivision from transactions t 1 , t 2 , t 3 , and t 5 .
Once the subdivisions are created, each subdivision p i is mined separately for high utility patterns. 3.3 Mining Subdivisions Using Compressed Utility Pattern Tree The Compressed Utility Pattern Tree ( CUP-Tree ) originally proposed by us in [7] is a variant of CFP-Tree [11] and CTU-Tree [5] data structures. In this paper for a given subdivision p i of the database, we construct the corresponding Compressed Utility Pattern Tree ( CUP-Tree ) exactly in the same way as in [5]. Fig. 4 illustrates the CUP-Tree and the GlobalItemTable for subdivision p 5 of the database given in Fig. 1. More explicitly, the first row of subdivision p 5 has mapped item-ids (pattern) 2, 4 and 5 (for inserted into the tree with the TWU (80) and a pointer to the array of quantities 2, 1 and 1 (node labeled p in Fig. 4). The nodes which represent the current subdivision p (index 5) are linked by node links to facilitate the traversal in the mining process. All the transactions will be inserted similarly, giving the CUP-Tree of Fig. 4.
Now mining for the subdivision p 5 is initiated using the CUP-Tree of Fig. 4 as in-put. Traversing the nodelink of index 5 (Fig. 4.) the associated ite ms are recorded in the projection tree named ProCUP-Tree . The information for extracting high utility items is recorded in a High Utility Pattern Tree (HUP-Tree) with mapped item id 5 as its root (labeled A in Fig. 6 which shows the ProCUP-Tree and HUP-Tree of subdivi-sion p 5 ). The mining of a subdivision consists of three steps: (1) Construction of ProItemTable , (2) Construction of ProCUP-Tree , and (3) Mining by traversing Pro-CUP-Tree . These steps are explained below using subdivision p 5 as an example. Step 1. Construction of Pro ItemTable . Traversing the node link of index 5 (Fig. 4), the associated items are arranged as ProItemTable in the descending order of the TWU values. This table is constructed in the same manner as the GlobalItemTable ex-plained in [5] restricting attention to linked nodes of index 5 in p 5.

For example, traversing of the linked nodes provides the following indexes and TWU from ( p , r ). Since our min_utility is 129.9, index 1 is pruned and indexes 2,3,4 (item ids: 1,2,4) are locally hTWU in ProIte mTable (see Fig. 6). The mapping of the Glob-alItemTable item index to the proItemTable item index and the corresponding original item-ids are provided in Fig. 5. Concurrently the level 1 children of the HUP-Tree root are recorded (indicated by label B in Fig. 6). Furthermore, note that the proItemTable includes a column giving the cumulative quantity of the projection item 5. Step 2. Construction of ProCUP-Tree . Retraversing the node-link in the CUP-Tree and using the mapping in ProItemTable (see Fig. 5), we construct the ProCUP-Tree. Note that ProCUP-Tree is expressed using the proItemTable index.
 Step 3. Mining by ProCup-Tree Traversal. For each item in proItemTable , the path to the root is traversed computing the other items that are together with the current item. In Fig. 6, traversing the node-link of item index 2 will return index 1, and since it has high TWU, the real utility value will be calculated by multiplying the appropriate corresponding to the local pattern of 1 2 5 (original item ids, 1 2 3). So the utility value for the pattern would be (2  X  10) + (1  X  150) + (1  X  25) = 195. An entry is created and attached as the child of index 2 (indicated by label C in Fig. 6) in the HUP-Tree. 
By traversing the HUP-Tree we can print the real utility of itemsets containing item The mining process is continued with the remaining subdivisions p 4 , p 3 , p 2 . The com-plete high utility itemsets (after mapping back to the original item-ids) are obtained as the following: {2(600), 4(175), 5(300), 12(490), 14(200), 15(245), 23(175), 24(185), 25(560), 45(300), 123(195), 124(195), 125(355), 145(255), 245(195), 1245(205)}. In this Section, the performance of CTU-PROL is empirically compared with the im-plementation of TwoPhase downloaded from [8] and CTU-Mine [5]. CTU-PROL is written in C++ and compiled using g++ version 4.1.0. The experiments were per-formed on a Pentium Core Duo, 3 GB RAM, with Linux operating system. We used the real datasets Retail and BMSPOS available from the FIMI Repository [12]. We also generated the synthetic datasets T10N5D100K and T5N5DXM using our program and IBM Quest data generator [13] to test the scalability of our algorithm. Table 1 shows the characteristics of the datasets. Since all these datasets are normally used for traditional frequent itemset mining, we had to add quantity and item utility values to the datasets. We generated utility values from a suitable log-normal distribu-tion, and the quantities randomly from numbers one to ten. 
Results of our experiments are shown in Fig. 7. For high thresholds in the Retail dataset, TwoPhase runs slightly faster compared to CTU-PROL , but when the utility threshold becomes lower, CTU-PROL outperforms TwoPhase . For very low utility thresholds, the performance of TwoPhase got worse. This is due to the limitations of the generation-and-test approach of TwoPhase that has to traverse the database many times to enumerate and compute the large number of possible itemsets of high trans-action weighted utility. As our algorithm is based on pattern growth using a compact tree, repeated traversal of the database is avoided. Note that for relatively large datasets, CTU-Mine ran out of memory and hence CTU-PROL is compared with only TwoPhase. On the synthetic dataset T10N5D100K, we tested CTU-Mine , CTU-PROL and TwoPhase . When the utility threshold is low, TwoPhase is unable to complete within a 10,000 seconds time limit. For scalability, we tested TwoPhase and CTU-PROL using T10N5DXM datasets with min_utility 0.05% of total utility. In general, the results show that CTU-PROL outperforms CTU-Mine and TwoPhase for various utility thresholds and transaction volumes. In this paper, we have presented the CTU-PROL algorithm to mine the complete set of high utility itemsets from both sparse and relatively dense datasets with short or longer high utility patterns. Our data structure and algorithm extend the pattern growth approach, taking into account the lack of anti-monotone property for pruning utility based patterns. We have compared the performance of CTU-PROL against the recent TwoPhase algorithm [4] and CTU-Mine [5]. The results show that CTU-PROL works more efficiently than TwoPhase and CTU-Mine . Our algorithm adapts to large data by constructing parallel subdivisions on disk that can be mined independently. The experiments show that CTU-PROL is scalable for larger datasets. 
Since TWU is an overestimation real util ity, resources used are possibly high for these pattern growth algorithms. Further research is needed to determine how the thresholds for TWU may be varied from the user specified utility to reduce this over-estimate. As the data for mining is very large in general, we plan to study sampling based approximations to reduce the computation. Alva Erwin is supported by Curtin International Research Tuition Scholarship (CIRTS).We thank Ying Liu for providing the TwoPhase program. 
