 partial periodicity, emerging patterns, and many other important data mining tasks [1,2,3]. For example egg  X  coffee (support: 3%, confidence: 80%) means that 3% of all transactions contain both egg and coffee , and 80% of the transactions that have egg also have coffee in them. In real dataset, time is one of the important factors. For ex-ample, eggs and coffee may be ordered together primarily between 7AM and 11AM. Therefore, we may find that the above association rule has a support as high as 40% among the transactions that happen between 7AM and 11AM and has a support as low as 0.005% in other transactions. So we can discover more useful knowledge if we consider the time interval. 
Informally, we refer to the association rules along with their temporal intervals as temporal association rules. The discovery of temporal association rules has been dis-cussed in the literature. For example, in [4], the discovery of cyclic association rules periodicity has limited expressiveness in describing real-life concepts such as the first business day of every month since the distances between two consecutive such busi-user-defined temporal patterns. Although the work of [5] is more flexible than that of [4], it only considers the association rules that hold during the user-given time inter-vals described in term of a calendar algebraic expression. In other words, a single set of time intervals is given by the user and only the association rules on these intervals are considered. This method hence requires user X  X  prior knowledge about the tempo-temporal association rules during time intervals that follow some user-given calendar schemas. Generally, the use of calendar schemas makes the discovered temporal asso-each d i is either an integer or the symbol  X * X . Such calendar-based patterns represent all daily, monthly, and yearly patterns. For example, &lt;2005, *, 10&gt; is such a pattern, which corresponds to the time intervals consisting of all the 10th day of all months in year 2005. But [6] adopts an Apriori-like candidate set generation-and-test approach. especially true for mining long patterns. 
In this paper, we propose an efficient temporal frequent pattern mining method us-ing TFP-tree (Temporal Frequent Pattern tree). We propose a completed TFP-tree for efficient mining. This approach has three adva ntages: (i) this method only scans data-base once and maintains all transactions using FP-tree. So we can reduce significantly ory. Moreover, we separate the transactions into many partitions by maximum size reduce significantly the run time. 
The remaining of this paper is organized as follows. Section 2 designs the TFP-tree TFP-tree based frequent pattern mining algorithm, TFP-tree Mining. Section 5 pre-sents our performance study. Section 6 summarizes this paper. Table 1 show the first running example of a transaction database. For convenience of later discussions, we continue to use this example and describe each part. where T i ( i occurrence frequency) of a pattern A , which is a set of items, is the number of transac-fined minimum support threshold,  X  . We present a class of calendar related to temporal patterns called calendar patterns. where each attribute f i is a time granularity name such as year, month, day, and so on. given a calendar schema (year:{1,2}, month:{1,2}, week:{1,2,3}, day:{1,2,3,4}). And corresponding to domain and means "every." Exactly, it represents periodic cycles on means the third day of every week of January in the first year. we define TFP-tree as follows. Definition 1. (TFP-tree) If a calendar schema R has n attributes, then a temporal fre-quent pattern tree (or TFP-tree in short) is a tree structure defined below: 1. It consists of one node of all the star patterns all_star , a two dimensional array 2. The structure of the internal nodes of a TFP-tree that is called internal_node is 3. The structure of the leaf node of a TFP-tree that is called leaf_node is as fol-
From the above definition, we can generally construct a TFP-tree shown in the ex-ample of Table 1 and Fig. 1. 
Why do we use the arrays and are there not any missing or overlapping transac-tions? We prove this problem in Problem A of Appendix. This section shows how to construct a TFP-tree based on Definition 1. The construc-Based on Definition 1, we have the following TFP-tree construction algorithm in detail. 
Scanning the transactions, we sort the transactions according to maximum size transactions into the array of leaf nodes and the array of internal nodes does not store the transactions but saves only the corresponding to star calendar patterns. But there is still a need of n times memory space of the total number of all transactions. Consider example 1 above, there needs 4 times memory space. So a solution to save the mem-separate many partitions of transactions. Why do we select maximum size domain? This reason is that the leaf node is 1-star calendar pattern and only one domain is  X * X . Therefore we must select maximum size domain and can separate many partitions of contains this domain value of maximum size domain before scanning next part of in each 1-star calendar pattern for saving the memory space. From these reasons, we ciently. In example 1, the maximum size domain is D 1 and we sort the transactions. It is shown in the left table of Fig. 2. transaction list of the covering the basic time in leaf node. node and star calendar patterns into internal node. In the process of inserting into leaf inserting into internal node, all of star calendar patterns that cover the basic time are inserted into the correspondi ng to internal node. In this case, we insert the star calen-dar pattern into internal node only if the internal node does not contain it. The exam-ple is shown in Fig. 2. 
The procedure of refresh_tree() is a function of creating FP-tree that the 1-star cal-endar pattern contains max_domain at leaf nodes. amount of databases, we can save so much memory and do not affect the mining frequent patterns. Where the procedure of FP-insert_tree([ p |P]; T) is the creating FP-tree function in [7]. The example is shown in Fig. 3. Construction of a compact TFP-tree can be performed with a rather compact data velop an efficient method for mining the complete set of frequent patterns. 
Given a transaction database DB and a minimum support threshold,  X  , the problem problem. Based on the above section, we have the following algorithm for mining frequent patterns using TFP-tree. 
To help the understanding of TFP-tree mining algorithm, we illustrate frequent pat-node is 5. 
The algorithm of TFP-tree mining consists of three parts. The first part is to gener-ate the frequent itemsets of 1-star calendar pattern. In this part, we can mine frequent patterns using each FP-T in the leaf node of TFP-tree. Where the algorithm of mining frequent pattern is FP-growth(Tree,  X  ) in [7]. The results are shown in the top right of dure generate_pattern() . And the detail of process is as follows. 
The procedure generate_pattern() is the function that generates the frequent calen-dar pattern. For each sub-tree, each internal node scans the leaf node of this sub-tree and generates frequent pattern itemsets. In other words, we scan each itemset of 1-star calendar pattern in a leaf node and merge these frequent itemsets into the star calendar only add the count. Otherwise, we insert the itemset into there. An example of these results is shown in the bottom right of Fig. 4. And we eliminate the itemsets that do shown in the bottom left of Fig. 4. 
Does this TFP-tree mining guarantee the frequent patterns in internal node without missing any frequent itemsets? We prove this problem in Problem B of Appendix. In this section, we perform a series of experiments for evaluating the performance of the experiments are performed on a Windows 2000 Server desktop with Pentium PC 2.8GHz and 512 Mbytes of main memory. Also we use JDK 1.4, MS-SQL 2000 data-base and JDBC driver for connecting MS-SQL 2000. D :{1,...,6}, D 2 :{1,...,12}, D 1 {1,...,30}). The number of items is 100 and the pattern-time interval are 100 and 1000, respectively. The average size of the transactions and generate a series of data sets, most of which are generated by varying one parameter 500MB to 5GB. 
In our experiments, we compare three algorithms: nontemporal association match (NTA match), calendar temporal association match (CTA match), and temporal fre-quent pattern match (TFP match). 
The first experiment studies the run time versus support threshold by decreasing method has good scalability with the reduction of support threshold. The second creasing from 1000 to 80000 on the right of Fig. 5. Both NTA match and CTA match able. In both experiments, the run time of TFP match method is increasing more pattern using TFP-tree is increased according to decreasing the support threshold while all constructions of TFP-tree have same time. Therefore, discovery temporal pattern mining algorithms. We have proposed a novel data structure, that is temporal frequent pattern tree (TFP-and developed a pattern growth method, TFP-tree mining, for efficient mining of frequent patterns in large databases. TFP-tree has several advantages compared to other approaches: (i) one scans the transaction only once for reducing significantly the I/O cost; (ii) one stores all transactions in leaf nodes but saves only the star calendar patterns in the internal nodes, then we can save a large amount of memory. For saving the memory efficiently, we divide the transactions into many partitions by maximum size domain. We prove that there are no transactions missed in Section 2 and Appen-dix; (iii) we efficiently discover each star calendar pattern of internal node using the frequent calendar patterns of leaf node. We prove that there are not any missing fre-quent itemsets in Section 4 and Appendix. 
Our performance study showed that the TFP-tree is efficient and scalable for min-ing, and is about an order of magnitude faster than the classical frequent pattern min-ing algorithms. This work was supported by the RRC program of MOCIE and ITEP and the Regional Research Centers Program of the Ministry of Education &amp; Human Resources Devel-opment in Korea. overlapping transactions? We can use two parts to answer this question. 1. The leaf nodes of each sub-tree has all transactions. 2. Each internal node covers all transactions not any missing or overlapping trans-
So each internal node covers all the transactions, without any missing or overlap-ping transactions. node without missing any frequent itemsets. 
If there is a m -star calendar pattern P in the internal node of a sub-tree and k of 1-{ p tions are partitioned into k parts. Hence this problem is converted into the problem of partition algorithm for mining the frequent itemsets. 
Let L be the set of actual frequent itemsets in P . Since the global frequent itemsets are generated by counting the support for every itemset in C G , it is sufficient to show that C G L . Assume there exists an itemet l that is actually frequent but does not ap-|p l  X  L i , it must be true that or 
This is equivalent to |p Therefore support ( l ) &lt; minSup and so l  X  L . But this is a contradiction. 
