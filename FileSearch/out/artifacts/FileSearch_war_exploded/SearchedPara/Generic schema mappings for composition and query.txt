 1. Introduction
Information systems often contain components that are based on different models or schemas of the same or intersecting domains of discourse. These different models of related domains are described in modeling languages (or metamodels) that fit certain requirements of the components such as representation power or tractability. For instance, a database may use
SQL or an object oriented modeling language. A web service described in XML schema may be enriched with semantics by employing an ontology of the domain. All these different types of models have to be connected by mappings stating how the data represented in one model is related to the data represented in another model. Integrating these heterogeneous models requires different means of manipulation for models and mappings which is the goal of a model management system [1]. It should provide operators such as Match that computes a mapping between two models [2], ModelGen that transforms models between modeling languages [3],or Merge that integrates two models based on a mapping in between [4].
An important issue in a model management system is the representation of mappings which can be categorized as inten-sional and extensional mappings [5]. Intensional mappings deal with the intended semantics of a model and are used, for example, in schema integration [4]. These mappings interrelate model elements by set relationships such as equality and lation. Extensional mappings define interschema constraints which must hold for all valid instances of the related schemas source and transforming it into a target schema. We denote such mappings as executable mappings. In this article, we will deal only with extensional mappings which are source-to-target as our goal is to have a generic representation for execut-able mappings. 1.1. Motivation we want to integrate a relational data source and an XML document into another XML document. The relational source can be mapped via an existing OWL ontology with the integrated XML schema. The first challenge to be addressed in this sce-nario is the heterogeneity of modeling languages involved. Other approaches for heterogeneous data integration use some schema might be lost due to the limited expressivity of the modeling language for wrapped schemas. Therefore, a mapping language is required which can map between heterogeneous metamodels and which can be translated into executable que-ries for a specific modeling language.

Another problem indicated in the scenario is the restructuring of nested data. The XML source groups student elements in a university element, whereas the target reverses this nesting structure. Consequently, a mapping language must support nested data structures as well as such restructuring operations.

A third requirement is the composability of mappings: in the example, there are already mappings from the relational source to the OWL ontology, and from the OWL ontology to the integrated XML schema. If we could compose these two map-pings, we could have a direct mapping from the RDB to the XML document.

An extensional mapping can be represented as two queries which are related by some operator (such as equivalent or subset) [7]. As the query language depends on the modeling language being used, the question of mapping representation is tightly connected to the question how models are represented. In schema matching systems, which often represent the models as directed labeled graphs, mappings are represented as pairs of model elements with a confidence value which indi-cates their similarity [2]. Such mappings can be extended to path morphisms that are defined on a restricted form of rela-tional schemas. Path morphisms can be translated into an executable form but have limited expressivity [8]. Most formal mapping representations also rely on the Relational Data Model, e.g. source-to-target tuple generating dependencies (s-t tgds, also known as GLAV mappings) [9] or second-order tgds (SO tgds) [10]. Tuple generating dependencies (tgds) are source-to-target and have the form 9 f  X  X  8 x 1  X  u 1 ! w on x i and equalities based on x i and f , and each w i is a conjunction of relation atoms based on terms of x model, a nested mapping language has been proposed [11].

Each mapping representation has its strengths and weaknesses regarding the requirements for a mapping language men-modeling languages; (ii) the mapping language should support complex expressions between sets of model elements; (iii) support for the nesting of mappings (to avoid redundant mapping specifications) and nested data structures should be pro-vided; (iv) mappings should have a rich expressiveness while being generic across modeling languages; (v) mappings should support data translation between the instances of the connected models. While each of the mapping representations men-take into account other modeling languages. 1.2. Contributions
The main contribution of this article is the definition of a mapping representation which is generic across several mod-mentation of model management operators which deal with these mappings. Furthermore, using a generic mapping for the generic mapping representation and do not have to be reconsidered for each combination of mapping and modeling language. The mapping language presented in this paper is based on second-order tgds for which a composition algorithm has been defined [10]. This algorithm has been adapted to our mapping language and complemented by optimization steps to deal with the exponential complexity of the algorithm.

A prerequisite for a generic representation of mappings is a generic representation of models. Our work is based on the role based generic metamodel GeRoMe [12]. It provides a generic, but yet detailed representation of data models originally represented in different metamodels and is the basis for our model management system GeRoMeSuite [13]. GeRoMeSuite pro-vides a framework for holistic generic model management; unlike other model management systems it is neither limited by nature to certain modeling languages nor to certain model management operators. The generic mapping language shown manipulation language such as SQL. This generation of executable queries and update statements for SQL and XML is also presented in this article.

The generic metamodel allows us to represent arbitrary model structures, e.g. flat relational tables as well as nested XML documents. Thus, the generic mapping language supports also nested structures and provides grouping and nesting func-tionality. Another contribution of this paper is the application of our generic mappings in data integration by using them for query answering.
 The contributions of our work define also the structure of the paper. After providing some background information on the usefulness and applicability of our mapping representation, we will present in Section 4 an algorithm for mapping com-ation of our approach with several examples of the recent literature is shown in Section 6. Section 7 then addresses query 9 concludes our paper and gives an outlook on future work.

This paper is an extended version of our previous paper [14]. Compared to the previous version, this paper provides an updated version of the mapping definition, explains this in more detail using more examples, provides a proof of the com-position algorithm, explains the query and update generation in more detail, updates the evaluation results, and adds the section about query answering. 2. Background
The Generic Role based Metamodel GeRoMe was presented in [12], including a formalization and a definition of the semantics of GeRoMe . As this representation forms the basis for our mapping representation presented in Section 3,we briefly summarize it in this section by using an example. 2.1. The Generic Metamodel GeRoMe
In GeRoMe each model element of a native model (e.g. an XML schema or a relational schema) is represented as an object of a GeRoMe model of the XML schema shown in Fig. 2 .

The gray boxes in Fig. 3 denote model elements, the attached white boxes represent the roles played by the model ele-the available modeling constructs. Rule based import operators [15] take care that model elements play roles according to guages such as EER or the Relational Metamodel. The main concept of XML schema  X  X  X lement X  represents actually an asso-the root element of a document. In GeRoMe , the definition of a root element is an association between the schema node and the element X  X  complex type, as there is no complex type in which the root element is nested. In the example, the element
University is an association between the model element Schema versity element is an association is described by the Association (As) role which connects the ObjectSet (OS) roles of and UniType via two anonymous model elements playing a CompositionEnd (CE) and an ObjectAssociationEnd (OE) role, respectively.

The anonymous association ends are required for several reasons. Firstly, since GeRoMe is a generic metamodel, we must take care that comparable modeling constructs from different modeling languages are represented uniformly. For instance, in UML, associations may be of degree higher than two, whereas in OWL or XML, instances of types (or classes) are always only connected via binary associations. However, in order to allow uniform handling by model management operators we need to represent all these types of associations in the same way. Secondly, the specialized association end type Composi-tionEnd encodes the nesting structure. Without knowing, which type is composed of which elements we would not be able to tell whether Student is nested into University or vice versa. Another reason is that association ends can have proper-ties themselves. For example, they may define cardinality constraints (which we omitted from the figure for sake of readability).
 The same structure of association and association end roles is used for the element tween the complex types UniType and StudType . The two complex types have attributes; therefore, they also play Aggre-gate (Ag) roles which link these model elements to their attributes. The model elements representing attributes play
Attribute (At) roles which refer also to the types of the attributes which are, in this example, simple domains denoted by the Domain (D) role.

Definition 1 ( GeRoMe model ). Formally, the GeRoMe metamodel is defined by a set of role types R  X f r property values. A model M represented in GeRoMe is defined by a tuple M  X h E ; R ; type ; plays ; property i , where The sets R and P are actually the modeling constructs that can be used in a GeRoMe model. Consequently, they are fixed. of these role types which are either simple properties or connect roles to each other. Examples of property types are the name property of a named model element (as opposed to an anonymous model element) or the participator property of ber of association ends, whereas XML elements always connect their own (nested) type to the containing complex type.
It is important to emphasize that the representation of models in GeRoMe is not to be used by end users for modeling mation to model management operators than a simple graph based model. 2.2. GeRoMe semantics: instances of a GeRoMe Model
Before we can formally define GeRoMe mappings, we first need to define the formal semantics of GeRoMe instances. Data main goal of the formal semantics is the formal definition of executable mappings between models. Our mappings are second-order tuple generating dependencies (SO tgds), which require that the instances are represented as a set of logical tionEnd as the roles which essentially express the structure of instances.
 the set of all abstract identifiers f id 1 ; ... ; id n g . An interpretation I of M is a set of facts D fication: av  X  id 1 ; a ; v  X ()9 id 2 attr  X  id 1 ; a ; id model. The first inst -predicate defines an instance of the schema element which represents the XML document itself. Then, tionships between the objects defined before.
 of this representation to SO tgds can significantly improve the expressiveness of SO tgds. 3. Formal definition of GeRoMe mappings
Mapping language and modeling language are closely related. We use the formal representation of GeRoMe instances as rich expressive mapping language which still maintains features such as composability and executability. Furthermore, the mapping language is generic across several modeling languages. This allows for a generic implementation of model manage-ment operators which deal with these mappings.

The main feature of our mapping language is that we use reification to describe data structures by introducing abstract called abstract variables and abstract function terms to resemble the abstract individuals. Since each instance of a model element is represented by an abstract variable or abstract function term, we can define references between instances using tions enable grouping functionality as will discuss in Section 3.3. Therefore, we can formulate mappings between any two models that can be described as a GeRoMe model. However, although the reified model elements are represented as predi-cates, they cannot be simply interpreted as relations.
 3.1. Definition
Based on the formal definition of GeRoMe instances, we extend the definition of SO tgds as a mapping between two rela-tional schemas in [10] to the definition of a mapping between two GeRoMe models: the target model, respectively, and where R is a set of formulas of the form: 9 f  X  X  8 x 1  X  u 1 ! w 1  X  X ^^ X  8 x n  X  u n ! w n  X  X  X  where (1) f is a collection of function symbols, (2) each x i is a collection of variables, (3) each u i is a conjunction of atomic predicates over constants defined in S and variables and/or equalities. (4) each w i is a conjunction of atomic predicates over constants defined on T , variables, and function symbols. (5) Valid atomic predicates are those defined in Definition 2 . (7) Each set x i can be partitioned into a set of abstract variables x (8) Analogously, f can be partitioned into a set of abstract functions f (9) The second component of a value predicate may also be a constant. (10) Equalities are of the form t  X  t 0 where t and t 0 are terms over x to be from T only on the target side. Thus, we only consider source-to-target dependencies in this work.
The intuition behind the partition of variables is that variables in x tional SO tgds. Concrete variables may be shared on both sides of the implication whereas the abstract variables x only on the source side. When executing a mapping, values are bound to the variables in x ferred X  from the source to the target.
 f choice of arguments for an abstract function determines the identification of objects on the target side, and thereby the grouping behaviour defined by the mapping. In addition, since the same function symbols can be used in multiple implica-tions, the results of these implications can be merged due to the interpretation as Skolem functions.
In the same way as x i ; c are the distinguished variables of conventional SO tgds, f values bound to distinguished variables.

The grouping functionality provided by abstract functions is not available in conventional SO tgds as their relational in-tgds. However, we will see that our mappings are still closed under composition. For nested mappings [11] on the other hand, which allow grouping in tree structures, it is not known whether they are closed under composition. This is because it is not known how to translate an SO tgd to a nested mapping. 3.2. Example
To show an example of a mapping between models originally represented in two different modeling languages, we define in Fig. 5 a GeRoMe model representing a relational schema for the university domain. The schema contains two relations
University(uname) and Student(id,sname,uni) . The keys uname tween Student and University is also represented by a separate model element which plays a Foreign Key (FK) role. The FK role points to a Reference (Ref) role which is played by the attribute that references the key of the other relation.
Now, we can define a mapping using the XML schema as source and the relational schema as target (cf. Fig. 6 ). The pred-describe (implicitly) the structure of the source data that is queried for. The predicate inst  X  o variable o 0 that must be bound to an instance of the Schema
UniType , whereas inst  X  o 1 ; University  X  defines a variable o ment. The av predicates define variables for the attribute values of the complex type instances o predicates are used to constrain the structure of the elements. In the example the student element o university element o 1 . The predicate part  X  o 1 ; child the XML element University to its type. The variable o 2 is also defined as the participator in the association end which links the variable o 3 (denoting an instance of the XML element eral tasks dealing with mappings such as composition, inverting, optimization, and reasoning have to be reconsidered for nested mappings (e.g. it is not clear how to compose nested mappings and whether the result composing two nested map-our generic mapping representation.
 to insert the data into the target.

The difference of our mappings from conventional SO tgds is that our mappings do not map relations to other relations
XML complex types and XML elements. Whereas this example features an XML Schema, such reified statements about model ented model. Furthermore, by using the part predicates, the mapping language allows us to define even n-ary relationships employed for mappings between object oriented models, which allow relationships of degree higher than two. Additionally, the part predicates together with the Skolem functions occurring on the right-hand side of our reified mappings allow for arbitrary grouping based on the values bound to concrete variables. This is done by using the concrete variables as argu-ments of the Skolem functions and, in doing so, defining the instances of model elements.
 will usually have more than one argument.
 actually evaluated to get the value which has to be inserted into the target. 3.3. Grouping and nesting
The generation of complex data structures which can be arbitrarily nested is an important requirement for a mapping representation. In order to show that our mapping language is able to express complex restructuring operations in data tion that we now assume that students may study at multiple universities. To have a schema in 3NF, we add a relation ies with two foreign keys uni and id . The foreign key from the courses taken by a student at a university can be stored in the XML document as the innermost XML element. The GeRoMe model of this XML schema is shown in Fig. 7 . The mapping between the updated relational schema and XML schema is shown in Fig. 8 . As the relational schema does not provide information about courses, the mapping does not reference the Course or CourseType .

The source side is almost identical with the target side of the previous mapping: the abstract functions f and g have been replaced with the abstract variables o 1 and o 2 ; a variable o have been added. On the target side, we first generate an instance of the ID, the abstract function f has only i as argument. f 0  X  i  X  represents an instance of under the Student element.
 cause each StudType instance has its own nested University ments for each university, as the universities have to be repeated for each student. This is guaranteed by using both identifiers (of the nesting element Student and the nested element tion g . Finally, we assign a value to the attribute uname of
StudType . 3.4. Visualization and editing of mappings
Our mappings have a rich expressivity, but are hard to understand in their formal representation, even for an information system developer who is used to working with modeling and query languages. As mentioned above, GeRoMe should not re-an internal metamodel for model management applications. This applies also to the GeRoMe mappings, users will not define mappings using the SO tgds as defined above, rather they will use a user interface in which they can define the mappings graphically.

As part of our model management system GeRoMeSuite [13], we are currently developing mapping editors for the various aggregations), and the mapping can be defined by connecting elements of the trees. However, such a visualization of models and mappings has limited expressivity (it roughly corresponds to the path morphisms and tree schemas used in Rondo [16]) as not every model can be easily visualized as a tree. Even an XML schema can break up the tree structure by having refer-ences between complex types.

Our current design for an extensional mapping editor also visualizes models as trees. To overcome the problem of limited expressivity of trees we provide multiple ways to convert a model into a tree, which can be seen as different views on the area [17], and we have to evaluate whether our design will be accepted by users. 4. Mapping composition
Composition of mappings is required for many model management tasks [18]. In a data integration system using the glo-bal-as-view (GAV) approach, a query posed to the integrated schema is rewritten by composing it with the mapping from the sources to the integrated schema. This application will be also shown for our mappings in Section 7. Schema evolution is another application scenario: if a schema evolves, the mappings to the schema can be maintained by composing them with an  X  X  X volution X  mapping between the old and the new schemas. 4.1. Semantics of mapping composition
In general, the problem of composing mappings has the following formulation: given a mapping M model S 2 , and a mapping M 23 from model S 2 to model S 3 to the successive application of M 12 and M 23 [10].

Mapping composition has been studied only for mappings which use the Relational Data Model as basis. Fagin et al. [10] proposed a semantics of the Compose operator that is defined over instance spaces of schema mappings. To this effect, M the composition of M 12 and M 23 means that the instance space of M spaces of M 12 and M 23 . Under this semantics, which we will also adopt in this article, the composition mapping M ique up to logical equivalence.

According to [10], the composition of two mappings expressed as SO tgds can be also expressed as an SO tgd. In addition, the algorithm proposed in [10] guarantees, that predicates in the composed SO tgd must appear in the two composing map-pings. Thus, the composition of two GeRoMe mappings is always definable by a GeRoMe mapping. It is important that GeRoMe mappings are closed under composition, because otherwise the Compose operator may not return a valid GeRoMe mapping.
However, due to the extensions made in the definition of our generic SO tgds we have to do some adaptations to the ori-enables mappings between heterogeneous metamodels. In the second part of this section, we address an inherent problem of the composition algorithm, namely that the size of the composed mapping is exponential in the size of the input mappings.
We have developed some optimization techniques which reduce the size of the composed mapping using the semantic infor-mation given in the mappings or models. 4.2. Composition algorithm
The composition algorithm shown in Fig. 9 takes two GeRoMe mappings M icates on the left-hand side (lhs) of R 23 , which refer to elements in S looking for a  X  X  X atching X  predicate, we can just focus on the predicate name. Then, we replace each implication in R set of implications which just have one predicate on the right-hand side (rhs). We put the normalized implications from R with the updated predicate names into S 12 . For the implications in R then we insert them into S 23 .

The next step performs the actual composition of the mappings. As long as we have an implication in S
P : c  X  y  X  on the lhs that refers to S 2 , we replace it with every lhs of a matching implication from S a set of equalities which reflect the unification of the predicates P c  X  y  X  and P c  X  t
To illustrate the composition algorithm, consider the mapping given in Fig. 10 which maps the simple relational schema from Fig. 5 to the relational schema with the additional Studies composed with the mapping from Fig. 6 to which we will refer as M av  X  p 2 ; uni ; x  X  in M 23 , which can be unified with av  X  g  X  i  X  ; duced are p 2  X  g  X  i  X ^ x  X  u . Now, the predicate av  X  p intermediate result: 2 sents the unchanged rhs of M 23 .

These steps have to be done for each predicate on the lhs of M icates of the lhs of M 12 will be repeated six times (once for each predicate on the lhs of M section, we will explain how we can simplify the composition result, by using logical transformations which transform the mapping into an equivalent simpler mapping, and by using the constraints of the schema to remove redundant predicates.
As a first step towards a simpler result, we apply in the next step some optimizations to each implication. Optimizations we just can apply item (iii), thus, we remove the variables which were originally in M ities in the mapping. In the example shown above, this means that we replace all occurrences of p
Please recall that this step must only be applied after all predicates from the lhs of M will replace abstract variables only in equality predicates. The result of such replacements are equalities between terms implications contained in the composed mapping, whether one implication is subsumed by the other implication. If this is the case, the subsumed implication can be removed.

The final step creates the composed mapping as one formula from S actually produces a correct result.

Theorem 4. Let M 12  X  X  S 1 ; S 2 ; R 12  X  and M 23  X  X  S 2 returns a GeRoMe mapping M 13  X  X  S 1 ; S 3 ; R 13  X  such that M the major difference between our and Fagin et al. X  X  composition algorithm. We rename all predicates in the two given map-pings before we compose them, and we also rename all predicates in the output mapping after we compose them. For nota-tional purposes, we use R 0 12 and R 0 23 to denote the formulas that are the results of renaming the predicates in R respectively, and we use R 0 13 to denote the formulas of R still SO tgds. Because of the correctness of Fagin et al. X  X  composition algorithm, the output, which is R
Based on the result of Fagin et al. X  X  composition algorithm, all predicate names appearing on the lhs of R predicate names appearing on the lhs of R 0 12 , and all predicate names appearing on the rhs of R names appearing on the rhs of R 0 23 . Observe that, we always get R on R 0 12 . Similarly, we always get R 23 if we apply the same rules on R in R 13 are predicate names from R 12 and R 23 only. That is, R mappings. Thus, the output mapping M 13 is always a valid GeRoMe mapping.

To prove the logical equivalence, we take the inst predicates as an example and prove that renaming inst predicates does not affect the logical equivalence. Consider the following two inst predicates, inst  X  x ; const and inst  X  y ; const y  X  on the lhs of an implication in R second step of the composition algorithm, we replace inst : const inst : const x  X  x  X  , only if const x is the same constant as const const x and const y are not the same. However, in the latter case, we would add const on the lhs of the result implication. The left-hand side of the result implication is always evaluated to false if const are not the same constants. Therefore, we can safely remove all result implications where const our output mapping is logically equivalent to the output mapping of applying composition without renaming predicates.
Also, the optimizations do not affect the logical semantics of the mapping as they guarantee that the optimized mapping is logically equivalent to the unoptimized mapping as we will discuss in the next section. 4.3. Semantic optimization of the composition result
The proposed mapping language is capable of representing composable and executable mappings between models in graph structures.

The composition algorithm has exponential time costs, which depend on the number of implications in the mappings and on the number of predicates in the implications. The reason for this is that we replace a predicate in S of predicates in S 12 and the same set of predicates in S
Thus, reification increases both, flexibility of the mapping language and computational costs. Consequently, the composed of the composition seem to be duplicated.
 we can compensate it by collapsing variables that must be bound to the same objects. This can be done based on the con-straints encoded in the model. The optimization steps first consider only each implication of the mapping separately and then perform a containment test between the implications.

A first step in optimizing the composed mapping consists of deriving equalities of concrete variables in the mapping based on equalities of abstract functions. As abstract functions are interpreted only syntactically like Skolem functions, the following conditions hold for abstract functions : are equal, too. This statement can be used to reduce the number of predicates in the composed mapping  X  p  X  x  X ^ p  X  y  X ^ x  X  y () p  X  x  X  X  .

Further optimization steps take the constraints of the models into account. For example, if we know than an attribute has maximum cardinality of 1, then we can conclude from av  X  x ; mization are uniqueness constraints: if the attribute a is unique, we can conclude from av  X  x ; be made anymore to an implication.
 Finally, a pairwise containment check is applied on all implications that were produced by the composition algorithm.
Given two implications I 1  X  A 1 ! C 1 and I 2  X  A 2 ! C 2
C ! C 1 . In this case, the implication I 1 can be safely removed from the mapping without changing its set of solutions. to construct one canonical database which might be a counter example for containment.

Furthermore, it is particularly important that this optimization step is interleaved with the composition algorithm. Be-the number of implications, which is crucial for the computational costs, grows exponentially depending on the numbers of predicates and implications. Keeping the number of implications low during the composition already, speeds up the com-position procedure and reduces the space requirements dramatically. However, in order to speed up the containment check, the preceding steps of collapsing variables have also been implemented interleaved with the composition. 5. Mapping execution
In this section, we first describe the architecture of our data translation tool before we explain how we generate queries from a set of generic mappings and how we use these queries to produce target data from source data.
Fig. 11 shows the architecture of our data translation tool. Given the mapping and the source model as input, the code generator produces queries against the source schema. An implementation of this component must be chosen, so that it pro-duces queries in the desired data manipulation language. In the same way, the target model code generator produces up-dates from the mapping and the target GeRoMe model.

Given the generated queries and updates the query executer produces variable assignments from the evaluation of the the target data. Hence, components related to source and target respectively are only loosely coupled to each other by the variable assignments whereas the query/update generator and the executer components have to fit to each other. 5.1. Generating XQuery queries from generic schema mappings
We now introduce our algorithm for generating XQueries from our generic mappings (cf. Fig. 12 ). However, our tool transforms data arbitrarily between relational and XML schemas; these generation and execution components can also be replaced by components that handle other metamodels (e.g. OWL or UML). The construction of SQL queries and updates will be explained later in this section.
 and the return set R assigns XQuery variables for values of attributes and simple typed elements in the source side of the mapping. The last step uses the computed data to produce the actual XQuery where _fname will be replaced with the actual XML file name when the query is executed.

We now generate an XQuery from the mapping in Fig. 6 that can be used to query the document in Fig. 4 . We first have to identify the variable which refers to the document element. As the lhs of the mapping contains a term inst  X  o the variable we are looking for. Therefore, we add  X  o 0 ;=  X  to Open and put  X  o empty list denoting the children of the root node).

Now, we construct the element hierarchy T . For  X  o 0 ;=  X  in Open the required pattern is satisfied by the subformula inst  X  o 1 ; University  X ^ part  X  o 1 ; parent U ; o 0  X ^ part  X  o  X  o  X  o ;=  X  from Open and add it to Close . We get Open  X f X  o
University  X  and Close  X f X  o 0 ;=  X g . We repeat the step for  X  o  X  o step.
 we add  X  u ; $ o 2 = @ uname  X  ;  X  s ; $ o 4 = @ sname  X  and  X  i ; $ o returned by the query are used as input when executing the rhs of the mapping. The XQuery generated from v is: for $ o 2 in fn:doc(_fname)/University return &lt; result &gt; 5.2. Generating and executing SQL queries and updates
Generating queries and updates in SQL are both very similar. As update generation also includes the phase in which the set of parametrized SQL update statements.

For a given implication it first computes the set of tables for which records are generated. By handling each predicate a way to identify tuples on the target side if multiple tuples have to be merged.

Fig. 14 depicts the execution procedure for the SQL update statements. Given a set of update statements, this procedure mation the denotation of each term on the rhs of the implication can be computed. Replacing the corresponding placeholders in the update statements gives a set of  X  X  X round X  update statements that can be executed.
 6. Evaluation of mapping composition and execution
To evaluate mapping composition we used fourteen composition problems which were taken from recent literature [10], or which were manually defined by us. The mappings from literature had to be formulated manually in our representation tests were run on a Windows XP machine with a Pentium M processor with 1.86GHz CPU and 700MB heap space.
In Fig. 15 , we list, for each test case, the number of implications in R icates in the lhs and rhs of the implications ( P l ; 12 ; P computation time for composition and the quality of the result which we captured with the number of implications in
R  X  I 13  X  and the average number of predicates in the lhs of its implication  X  P The upper bound of the number of implications in the unoptimized composition is O  X  implications in the normalized R 12  X  I  X  I 12 P r ; 12  X  and P cations in S 23 will increase at most at the factor of I . Repeating the same reasoning for every source predicate in R to the stated upper bound.

Thus, with increasing numbers of implications in mapping M rithm generates a new implication for each possible replacement of a predicate in the lhs of M ple used in [13] (example 8) the result contained 972 implications in the unoptimized case and only one implication in the optimized case. For composition task 14, the unoptimized composition mapping contained 9216 implications as opposed to rithm improves the computation time by keeping the number of implications low during the composition. Furthermore, tion procedure is needed to improve the computation time of more complex composition tasks, but also to produce an actu-ally useful result. Furthermore, the computation needs about 18 seconds in the unoptimized case, whereas doing the same composition with optimization returns the composed mapping after 1.2 s.

Similar to the number of implications, the number of predicates per implication in the composition mapping influences the practical usability of the mapping. In the unoptimized case, the result of composing the conferences example yields implications with about 200 predicates each whereas the optimized composition algorithm produces a mapping with one single implication containing 15 predicates. The result was the same mapping that would have been handcrafted for the two schemas. Thus, the optimization steps performed in the loop of the algorithm significantly reduce the number of pred-performance of the containment test that is necessary for the optimization.

The evaluation also confirms the exponential time costs of the composition algorithm which is inline with the results of [10] where it was proven that the computation time of composition is exponential in the size of the input mappings.
To evaluate mapping execution we defined seven test cases between relational databases and XML documents. The per-formance was linear in the size of the output and, thus, our framework does not impose a significant overhead to data ex-change tasks. These tests included also executing the composition of two mappings from a relational to an XML Schema and back. The result was an identity mapping and execution of the composed mapping was about twice as fast as subsequent ical formalisms and the grouping semantics specified in the mappings. 7. Answering queries using generic schema mappings
Data integration requires the definition of mappings between source schemas and the global integrated schema. These mappings can be defined in various ways [7]. The basic form of a mapping is q answers of q G evaluated over the corresponding instance of G .

Such a mapping in this general form, with queries on both sides of the mapping, is also called a  X  X  X LAV mapping X  (global X  In GAV mappings, each element of the global schema is described by a query over the source schema (i.e. the query q (i.e. the query q S is a single predicate).

For data integration, the problem of query answering is important. Query answering is the process of rewriting a query defined over the global schema into queries defined over the source schemas. Unless constraints for the global schema are given [20], the rewriting in the case of GAV mappings can be done by unfolding the query definition with mappings. In the case of LAV mappings, more complex algorithms for answering queries using views have to be used [21]. As the mappings left-hand side contains only elements from the source model and its right-hand side references only elements from the tar-to be from T only on the rhs. Thus, we only consider source-to-target dependencies in this work.
The details of this rewriting procedure will be explained in the following section. 7.1. Query answering with source-to-target mappings
We are considering a virtual data integration scenario, in which a query posed to the integrated schema has to be rewrit-oMe model in our data integration scenario.

Definition 5 ( GeRoMe query ). A query q to a GeRoMe model M is defined by an expression of the form q  X  x  X  p 1  X  y 1  X ^^ p n  X  y n  X  . The predicates p 1 ; ... ; p part predicates have also abstract variables as third argument; value predicates have concrete variables or constants as second argument.

The set x is a set of concrete variables, in which each variable occurs at least once as the second argument of a value predicate in p 1 ; ... ; p n .

Thus, a GeRoMe query is basically a conjunctive query, similar to the left-hand side of a GeRoMe mapping. As queries these variables refer to values, they may only appear as second argument of a value predicate.
As an example, we consider as integrated schema the XML schema in Fig. 7 with students, universities, and courses. A query for students with their ID and name, and the names of courses which they take, can be expressed in the following way: 3
The query navigates through the structure of the XML document by starting at the document root x (which is an instance of not interested in the name of the universities, we do not have an av predicate for the plan to use a modified variant of SQL with SELECT-FROM-WHERE clauses. On the one hand, this language will be a subset of the language will extend SQL with path expressions to be able to navigate through nested structures or associations.
To show the basic idea of our rewriting algorithm, we use as an example two mappings which have the integrated schema of Fig. 7 as a target:
Suppose now, we have to rewrite a GeRoMe query. As the body has the same structure as the left-hand side of a GeRoMe mapping, we can use the query as input mapping M 23 of the composition algorithm. The conjunction of the mappings be-tween all sources and the integrated schema is the input mapping M
When building the conjunction of mappings, we have to take care of the function symbols used in the mappings. Symbols in two different mappings, then the instances of this model element cannot be matched across these two mappings. To illus-trate this problem, we used the function symbol k in the mapping of Fig. 17 to identify instances of bols could be used in different mappings to identify the instances of the same model element.

Therefore, after constructing the conjunction of the mappings between sources and global schema, we have to check for the mappings that for each model element of the global schema, the same function symbols are used. We assume that, if different function symbols are used for the same model element, then they still have the same set of input arguments. This merge the information from different sources.
 with f  X  g . As said before, we assume that the functions still have the same set of input arguments. As function symbols semantics of the mapping.

If we have done this transformation, we can apply the composition algorithm to the conjoined mappings and the query. As a result, we will get a set of implications which might refer on the lhs to multiple different source schemas.
In the example, each condition of an implication in the resulting mapping will refer to both sources, as information about the student name ( sname ) can be only retrieved from the source in mapping M is only given in the source of M 2 . In order to be able to generate an executable mapping, we have to partition the pred-icates in the condition according to the source schemas. If two predicates referring to two different sources share the same variable x , we replace the variable in all predicates of one source with a new variable x 0 and introduce an addi-tional equality predicate x  X  x 0 . As equality predicates do not refer to any source schema, they will be handled separately.
 component of the data translation tool, execute the generated query and keep the variable assignment until the queries for 7.2. Optimization of the rewritten query
As we are using the composition algorithm presented in Section 4, the same optimization steps will be applied to the rewritten query to get more efficient source queries. In addition, further optimizations can be applied to the query which were not considered for the composition. To explain, we use again our running example: the query asks for the id and name of students together with their course names. The sources provide additional information such as university name and pings between sources and global schema, these predicates will be also contained in the rewritten query. However, these for each instance of the corresponding type.

If we generate an executable SQL query from a GeRoMe query, the removal of an av predicate in the query just corre-sponds to the removal of a term in the SELECT clause of the query, which will probably not have a big impact on query per-formance. However, for XML, we can omit one path expression to retrieve the attribute value, which might have a bigger impact on query performance. 8. Discussion and related work
In this section, we review related work and compare it with our approach for generic schema mappings. We will first present approaches for mapping representation, then discuss the mapping composition in Section 8.2, and address the exe-cution of mappings in Section 8.3. Section 8.4 presents recent approaches for query answering. 8.1. Mappings
Many different mapping representations are used in various areas of data management, such as data translation, query rewriting and schema integration. Each mapping representation has certain advantages and disadvantages for specific appli-cation areas. The simplest form of mappings are binary correspondences (also called morphisms [16]), which are usually the result of schema matching [2].

Morphisms only state a similarity between schema elements but do not provide any detailed semantics of the relation-ship. More formal mappings are required for tasks such as schema integration and data translation. Schema integration re-schema.

The topic of this article are extensional mappings which can be used for data translation or data exchange. Extensional mappings are defined as local-as-view (LAV), global-as-view (GAV), source-to-target tuple generating dependencies (s-t ating dependencies (s-t tgds) or GLAV assertions are used to specify mappings between relational schemas. Therefore, they mappings can express nested data structures, e.g. XML data, while s-t tgds cannot.

Path-conjunctive constraints [23] are an extension of s-t tdgs for dealing with nested schemas. However, they may suffer from several problems [11]. First, the same set of paths may be duplicated in many formulas which induces an extra over-head on mapping execution. Second, grouping conditions cannot be specified, leading to incorrect grouping of data. Nested mappings [11], which are used in Clio [24], extend path-conjunctive constraints to address the above problems. Nested map-pings merge formulas sharing the same set of high level paths into one formula, which causes mapping execution to generate be transformed into a corresponding GeRoMe mapping, our mapping language is more expressive than the nested mapping language. Like SO tgds, our generic mappings are closed under composition. Furthermore, like nested mappings they are also able to handle nested data and specify arbitrary grouping conditions for elements.

Like path-conjunctive constraints, a GeRoMe mapping cannot be nested into another GeRoMe mapping. Thus, a common
However, duplication in target data is overcome by grouping conditions. We may also borrow from the syntax of nested mappings [11] to allow nested mapping definitions.

Another form of mappings based on a Datalog-like representation is used by Atzeni et al. [3]. These mappings are generic as they are based on a generic metamodel, but they require the data to be imported to the generic representation as well. mapping representation into a specific query language of a metamodel and thereby avoid this overhead. 8.2. Mapping composition
Mapping composition has been studied for various mapping formalisms [9,10,18] . A semantics for mapping composition over the model S 3 where the  X  X  X quivalence X  means that, for every query q in Q , the certain answers for q wrt. M position is relative to the class of queries Q .

Mapping composition using s-t tgds was explored in [10]. It was proven that the language of s-t tgds is not closed under composition. To ameliorate the problem, the authors introduced the class of SO tgds and proved that (i) SO tgds are closed under composition by showing a mapping composition algorithm; (ii) SO tgds form the smallest class of formulas (up to log-ical equivalence) for composing schema mappings given by finite sets of s-t tgds; and (iii) given a mapping M and an in-stance I over the source schema, it takes polynomial time to calculate the solution J which is an instance over the target schema and which satisfies M . Thus, SO tgds are a good formalization of mappings and therefore, we have chosen them as the basis for our mapping representation. We adapted the composition algorithm of [10] to our generic mapping representation and thereby allow composition of mappings between heterogeneous modeling languages. Furthermore, we implemented the composition algorithm and made the observation, that the exponential complexity of the algorithm and fore, the results of our composition algorithm can be executed efficiently.

Another approach for mapping composition uses relational algebra expressions as mappings [18]. The approach uses an incremental algorithm which tries to replace as many symbols as possible from the  X  X  X ntermediate X  model. As the result of mapping composition cannot be always expressed as relational algebra expressions, the algorithm may fail under certain conditions which is inline with the results of [10]. 8.3. Executable mappings
Recall that an executable mapping is a mapping that has formal semantics and can be used for translating data or queries between different schemas of overlapping data. Executable mappings are necessary in many metadata intensive applica-tions, such as database wrapper generation, message translation and data transformation [8]. While many model manage-ment systems were used to generate mappings that drive the above applications, few of them were implemented using executable mappings. The reason is probably due to the lack of rigorous semantics of model management operators if the mappings are executable mappings.

Because executable mappings usually drive the transformation of instances of models, Melnik et al. [8] specified a seman-model management system prototypes to study two approaches to specifying and manipulating executable mappings. In the single mapping. However, the expressiveness of path morphisms is very limited. To overcome this limitation, they developed a new prototype called Moda [8] in which mappings are specified using embedded dependencies. The expressiveness is im-proved in the second implementation, but it suffers from the problem that embedded dependencies are not closed under composition. Although they further developed a script rewriting procedure to ameliorate this problem, it has not been com-pletely solved.

In this article, we modified the language of SO tgds such that we are able to represent generic mappings between schemas in heterogeneous modeling languages, as opposed to mappings between relational schemas only. Despite these changes, we have shown that our mapping language remains executable while at the same time being closed under composition and allowing for restructuring of data. 8.4. Query answering Many approaches dealt with the problem of query rewriting for data integration or data exchange scenarios [21,7,25,26] .
Since our mappings are strictly source-to-target mappings, we can use mapping composition for query rewriting.
Our work on query answering and query rewriting with our mapping representation is still work in progress. One limi-tation in our approach is that we assume that the sources are sound and complete, and therefore do not consider the con-straints in the target model. Constraints on the global schema and the assumption of incomplete sources complicate the have cyclic dependencies, query answering becomes more difficult. In order to get the certain answers [27] to a query, the but for a data exchange setting, is done in [26].

Our goal is to use our mappings in a peer-to-peer data integration scenario [25]. However, in such a system, a peer that ing the query. Therefore, we have to consider additional query rewriting techniques such as query answering using views [21]. The results have to be combined with queries rewritten by mapping composition. The expressiveness of our generic mapping language and the generic metamodel might complicate the adaptation of existing algorithms, but it provides on the other hand a good basis for a useful and efficient peer-to-peer system. 9. Conclusion
In this paper, we presented a rich language for schema mappings between models given in our Generic Role-based Meta-model GeRoMe [12]. Our mapping language is closed under composition as it is based on second-order tuple generating dependencies [10]. The mapping language is generic as it can be used to specify mappings between any two models repre-sented in our generic metamodel. Moreover, mappings can be formulated between semistructured models such as XML schemas, object-oriented models, or OWL ontologies and are not restricted to flat schemas like relational schemas. Another not supported by conventional SO tgds.
 We implemented an adapted version of the composition algorithm for second-order tuple generating dependencies [10].
Furthermore, we showed that the mapping language is still executable by developing a tool that exports our mappings to queries and updates in the required data manipulation language and then uses them for data translation. Exemplarily, we introduced algorithms that translate the source side of a generic mapping to a query in XQuery as well as algorithms for ating SQL updates harnesses the opportunity to specify mappings in which multiple implications contribute to the same gen-erated tuples. The components for mapping export and execution can be arbitrarily replaced by implementations for the required metamodels. The evaluation showed that both, mapping composition and mapping execution, yield the desired re-sults with a reasonable time performance. Furthermore, we discussed how generic schema mappings can be used for query rewriting and pointed out some problems that may appear in this context.

We are currently developing techniques for visualizing our mappings with the goal to implement a graphical editor for generic, composable, structured extensional mappings. This editor will be integrated into our holistic model management system GeRoMeSuite [13]. We will also investigate the relationship between our extensional mappings and intensional map-schema mappings from simple morphisms. As a starting point we adapt the techniques employed by Clio [28] to our generic metamodel and mapping language.
 Acknowledgements
This work is supported by the DFG Research Cluster on Ultra High-Speed Mobile Information and Communication UMIC at RWTH Aachen University, Germany (http://www.umic.rwth-aachen.de ).

References
