 1. Introduction
In the field of medical science, chronic liver disease is one of the major health problems in Asia. Most patients routinely take blood tests to determine the level of liver enzymes, such as alanine aminotransferase (ALT) and aspartate aminotrans-ferase (AST) in order to diagnose their liver cell damage. The measurements of these two liver enzymes have been widely caspase inhibitor, on the patients with elevated ALT and AST, where the levels of both liver enzymes were recorded in two time-series sequences. The result indicated that IDN-6556 progressively lowered the ALT and AST levels of the patients in a treatment period of 14 days.

Many diseases are believed to be associated with different indicators. If we could identify which indicators are likely to relate to a disease, we could routinely track the measurements of these indicators to prevent the illness or to predict the possible risks. Therefore, we are motivated to solve this problem and design a new data mining method to find patterns from a database where each record (or transaction) contains multiple time-series sequences. For example, Fig. 1 shows an exam-ple database containing three transactions, where each transaction contains two time-series sequences.
To find patterns in a time-series database, Faloutsos et al. [7] proposed a method to find the subsequences similar to the ing. Berndt et al. [3] presented a dynamic programming approach to find patterns in a time-series database. Lee et al. [13] developed a method to find fuzzy candlestick patterns for financial prediction. Teoh et al. [26] proposed a hybrid fuzzy time-series model, which combined cumulative probability distribution approach and rough set rule induction, to forecast stock markets. Han et al. [8] designed an algorithm to find periodic patterns. Yang et al. [33] showed an approach to detect intrusions. Takeuchi et al. [25] proposed a probabilistic model for detecting outliers and change points from time-series databases. Wang et al. [30] presented an approach to derive group patterns of mobile users based on their movement data.
However, those methods proposed are not suitable for mining frequent patterns in a multi-sequence time-series database tern is considered to be frequent if its support in the database is not less than the user-specified minimum threshold where the support is defined as the number of transactions containing the pattern.

Sequential pattern mining has become an essential data mining task with broad applications, including market and cus-tomer analysis, web analysis, pattern discovery in protein sequences, etc. The sequential pattern mining problem was first introduced by Srikant and Agrawal [21]. Then, Srikant and Agrawal [23] developed a refined algorithm, GSP, based on the
Apriori algorithm [22]. Many sequential pattern mining algorithms have been proposed for improvements, such as SPADE to decompose the original search space into smaller spaces. PrefixSpan [18] adopts a horizontal format dataset representa-tion and mines the sequential patterns under the pattern-growth paradigm. A prefix pattern is used to generate longer sequential patterns by building and scanning its projected database. The projected database then includes all subsequences resentation. It has been shown that SPAM is more efficient in mining long sequential patterns than SPADE and PrefixSpan; however, it consumes more space [2]. Masseglia et al. [16] presented an algorithm for incremental mining of sequential pat-terns when new transactions are added to the database. Lee et al. [12] developed a method for mining calling path patterns in GSM networks. Recently, Chen and Hsu [4] proposed an approach to discover tree-like patterns in a large dataset. Wang et al. [27] considered the relationships among the patterns spanning across different sequences and designed an algorithm for mining inter-sequence patterns. Since those proposed sequential mining algorithms do not consider multiple sequences sequence time-series database.

Mining frequent patterns often leads to the generation of a large number of patterns. Moreover, mining a long pattern may generate a large number of sub-patterns. A frequent pattern is closed if there does not exist a super-pattern with the same support. Generally speaking, the number of closed patterns in a database is often smaller than the number of fre-would be more efficient than mining all frequent patterns [17,34] .

Many closed itemset mining algorithms have been proposed, such as CLOSET [17], CHARM [34], TFP [9], and CLOSET+ [29]. Most of these algorithms maintain the already mined closed patterns to perform closure checking. To reduce the mem-ory and search space for closure checking, TFP and CLOSET+ adopt a two-level hash indexed tree structure to store the al-ready mined closed itemset candidates. Lee et al. [11] introduced a method called ICMiner that efficiently mines closed inter-transaction itemsets. ICMiner involves the concept of an ID-tree and domain attributes and applies effective pruning strategies to avoid consuming candidate generation. Yan et al. [32] proposed an algorithm for mining closed sequential pat-pruning on it. Because CloSpan needs to maintain the set of closed candidates, it will consume a large amount of memory for closure checking. Wang et al. [28] introduced an algorithm, called BIDE, for mining closed sequential patterns without main-taining candidates. They used forward and backward directional extension checking to perform closure checking and to prune the redundant patterns in the mining process.

In this paper, based on PrefixSpan [18] and BIDE [28], we propose an efficient algorithm to mine closed patterns in a data-base where each transaction contains multiple time-series sequences. Our proposed algorithm consists of three phases. First, we transform every sequence in the time-series database into the Symbolic Aggregate approXimation (SAX) representation jected database for each frequent 1-pattern, where the projected database of a pattern comprises all transactions containing patterns in a depth-first search manner. Moreover, we apply some closure checking and pruning strategies to prune frequent but non-closed patterns during the mining process. By using the projected databases, our algorithm can localize support counting, candidate pruning, and closure checking in the projected databases. Therefore, it can efficiently mine the closed patterns from a time-series database.

The main contributions of this paper are summarized as follows. First, we introduce a novel concept of mining closed multi-sequence patterns from a time-series database. Next, we propose an efficient algorithm to mine closed multi-sequence patterns. Finally, the experimental results show that our proposed algorithm is efficient and scalable, and outperforms the modified Apriori and BIDE algorithms.

The rest of this paper is organized as follows. Section 2 describes the problem definitions. Our proposed algorithm is dis-cussed in detail in Section 3. Section 4 presents the experimental results and performance analysis. Finally, concluding re-marks are made in Section 5. 2. Preliminaries and problem definitions
First, we apply the symbolic representation method SAX [15] to transform a time-series sequence into a symbolic se-quence. The method contains two steps. First, a time-series of length n is divided into m equal segments, and the average of each segment is calculated by:
The numerator represents the sum of all elements within a segment while the denominator x represents the number of elements falling within a segment ( x = n / m ). Thus, we obtain T the second segment, and so forth. As a result, a new representation of the time-series sequence is presented as is transformed into a symbolic sequence according to the breakpoints in a breakpoint mapping table. We have performed empirical tests on more than 50 datasets and verified that the normalized subsequences have highly Gaussian distributions.
Thus, the  X  X  X reakpoints X  can be determined so that equal-sized areas are produced under a Gaussian curve. The breakpoints are defined as a list of ordered numbers B = B 1 , B 2 , ... , B
B =1/ a . We use the statistical table [15] to determine the breakpoint for different values of a , as shown in Table 1 . m = 6, and a = 3. The time-series sequence is mapped to the symbolic sequence  X  X  ccbabc . X 
Given a database where each transaction consists of multiple time-series sequences, we first transform each sequence into a symbolic sequence and then mine closed patterns within these symbolic sequences.
 where e i is an item, e i 2 I , for 1 6 i 6 m . Assume there exists a lexicographical ordering
For example, a 5 b 5 c or x 5 y 5 z . To represent a sequence flexibly, we introduce a gap symbol  X  X  X  X , which is a wild card symbol and may be substituted by any item in I . The lexicographical order of the gap symbol is greater than any item in I .
Definition 2. called a k-pattern .

For example, both a x and b x are 1-patterns. aac xyx is a 3-pattern. 10-pattern, where ab occurs in sequence S 1 , after two time units bc occurs in S and after two time units yz occurs in S 2 . Note that the gap symbols after bc in S
Definition 3. The concatenation between patterns p 1 and p For example, abb yyx H cb xy  X  abbcb yyxxy .

Definition 4. A pattern p  X  an integer j such that a ik = b i ( k + j ) or a ik =  X  X  X  X , 0 pattern of p , or that p is a sub-pattern of p 0 .
 Definition 5. The support of a pattern p is defined as the number of transactions containing p in the database. Definition 6. A pattern is frequent if its support is not less than a user-specified minimum support threshold, min _ sup . Definition 7. A frequent pattern p is closed if there does not exist any frequent super-pattern of p with the same support.
Note that the gap symbols in a pattern may be substituted by any items. If one pattern with the substituted items is a super-pattern of the other, and both patterns have the same support, we would delete the latter one. For example, super-pattern of a .If a and a x have the same support, we should delete the pattern representative.
 Definition 8. The projection of a pattern p in a transaction t is defined as the rest of t behind p , where t contains p . Note that since a pattern p may appear more than once in a transaction, there exists a projection for each occurrence of p .
That is, a transaction may contain multiple projections of p . For example, the projection of is ba yy .
 Definition 9. The projected database of a pattern p contains all the projections of p in the database.
Since a pattern may contain many gaps, discovering all such patterns may require a lot of resources, but a user may only be interested in patterns with a certain number of gaps. Therefore, to avoid wasting resources by mining unwanted patterns, we introduce a parameter called a user-specified maximum number of gaps max _ gap . When mining closed patterns, we only mine the patterns so that the number of gaps between any two adjacent 1-patterns in the patterns is not greater than max _ gap .

To mine closed patterns, we build the projected database of a pattern and check if there exists any frequent 1-pattern in pattern p , we may find the frequent 1-patterns only from the first max _ gap + 1 positions in p  X  X  projected database.
For example, assume that min _ sup = 2 and max _ gap = 1. Given two transactions first find all 1-frequent patterns, namely, a x , a , b , to 2. From the projected database of a x , we know that a and at the first position of the second transaction. In the projected database of transaction and the first position of the second transaction, we cannot find any frequent 1-pattern from the first two posi-tions in the projected database since max _ gap = 1. However, in tions in the projected database, namely, c z , c , and z . Therefore, we obtain three frequent 2-patterns, namely, ac xz , ac xz , they are not closed. Since we cannot find any frequent 1-patterns in the projected databases of ac x , and
To find the closed patterns in a  X  X  projected database is quite similar to that in examine b  X  X  projected database to see if any frequent 1-patterns exist in the projected database, and find a frequent 1-pattern x . Thus, we obtain a frequent 2-pattern b x . Since we cannot find any frequent 1-patterns in projected database, we stop growing the pattern. Similarly, we may obtain all frequent patterns by growing all frequent 1-patterns as described above. Finally, we may obtain two closed patterns, namely,
The objective of mining closed patterns is to find all closed patterns in a multi-sequence time-series database with respect to the user-specified maximum number of gaps and minimum support threshold. 3. The proposed method
In this section, we propose an algorithm, called CMP-Miner (Closed Multi-sequence Patterns Miner), to mine the closed patterns. Since many previously proposed algorithms have demonstrated that the algorithm based on the depth-first search merates the frequent patterns by a frequent pattern tree in a DFS manner.
 3.1. Frequent pattern enumeration
The CMP-Miner algorithm uses a frequent pattern tree to enumerate frequent patterns, which may be constructed in the and add these 1-patterns to level one of the frequent pattern tree. Then, we can recursively extend a frequent pattern p at database, where 0 6 g 6 max _ gap . Note that g = 0 means that no gap is appended.

Let us consider the example shown in Fig. 3 , where every transaction shown in Fig. 1 is transformed into a symbolic se-tern. Note that (1) the children of a node are sorted lexicographically; and (2) the gap symbol  X  X  X  X  may be included in a pattern.

We first set the root to ; and then add all frequent 1-patterns to the children of the root. Next, we grow each frequent 1-pattern at level one to get the frequent 2-patterns formed by concatenating the frequent 1-pattern with one of the frequent 1-patterns in its projected database, and the frequent 3-patterns formed by concatenating the frequent 1-pattern with one gap and one of the frequent 1-patterns in its projected database. The patterns at level three may be obtained by growing the frequent patterns at level two with a frequent 1-pattern in the projected database or by growing the patterns with one gap plus a frequent 1-pattern in the projected database. Note that we only retain the frequent patterns in the frequent pattern tree for illustration.
 quentsuper-patterns. Basedonthe PrefixSpan [18],weadopt thepseudoprojectionapproachto generateaprojecteddatabase. 3.2. Closure checking and pruning strategies
The enumeration method described in Section 3.1 may only be used to mine a complete set of frequent patterns, not closed ones. Since mining closed patterns is more efficient than mining a complete set of frequent patterns, we will mine closed patterns in the proposed algorithm.

When we generate a new frequent pattern, we need to do some closure checking to assure whether the pattern generated is closed or not. Following a similar concept used in BIDE [28], we use bi-directional (forward and backward) checking to determine if the pattern generated is closed.
 database and not greater than max _ gap + 1 positions.
 base, and (2) the distance between p and q is not greater than max _ gap + 1 positions, it means that we can always find another frequent pattern formed by p and q whose support is equal to p  X  X  support. Therefore, p must not be closed. h
Next, we illustrate the forward checking strategy as follows. Assume 1-pattern y at the first position of every transaction in its projected database, then we can assure that a bc p X  X  projected database and not greater than max _ gap + 1 positions.
 base, and (2) the distance between q and p is the same in every transaction of p  X  X  projected database and not greater than to p  X  X  support. Therefore, p does not need to be grown because p is not closed. h
Next, we illustrate the backward checking strategy as follows. Assume find a pattern (for example, b  X  right before ab xy in every transaction of the projected database, we can conclude that ab xy does not need to be grown since there must exist another frequent pattern bab may be pruned because the pattern bab xy would be generated later.
 with a pattern q in the frequent pattern tree, (2) q contains p, and (3) p X  s projections are identical to q X  X  projections.
Proof. Since both patterns p and q share the same projections and q contains p , every pattern generated from p is contained by a pattern generated from q and both patterns generated have the same support. That is, every pattern generated from p is not closed. Thus, p may be pruned during the process of mining closed patterns. h
For example, as shown in Fig. 4 , pattern ab y contains pattern frequent pattern tree. Moreover, both patterns have the same projections since both patterns appear at the first and fourth action. Therefore, pattern ab may be pruned. 3.3. The CMP-Miner algorithm
In this section, we propose an efficient algorithm, called CMP-Miner, to mine closed patterns. The CMP-Miner algorithm ple symbolic sequences. Second, we scan the transformed database to find all frequent 1-patterns, and build a projected database for each frequent 1-pattern. Third, for each frequent pattern found, we recursively use a frequent k -pattern and its projected database to generate its frequent super-patterns at the next level in the frequent pattern tree, where k P 1. For each frequent k -pattern, we build its projected database and find all frequent 1-patterns in the projected database.
The frequent k -pattern plus g gaps plus one of these frequent 1-patterns are concatenated together to generate a frequent ( k + g + 1)-pattern, where 0 6 g 6 max _ gap .

During the mining processing, we use forward checking to check if the frequent patterns generated are closed. Then, we use backward checking to check if the frequent patterns need to be grown. Our proposed algorithm, CMP-Miner, is shown in detail in Fig. 5 . It contains a procedure, called CMP-Growth, which is presented in Fig. 6 .
 quent 1-patterns a y , a , b y , b , c , x , and y and do the forward checking on these patterns. All frequent 1-patterns except a y do not pass the forward checking step and thus, they are not closed. Moreover, ward checking step. Consequently, it is a closed pattern. Since there is no frequent 1-pattern in can stop growing the pattern.

Next, we grow the frequent 1-pattern a to find its frequent super-patterns by using frequent 1-patterns in its pro-jected database. There are three frequent 1-patterns in a grow the frequent 1-pattern a by appending b y to it, and obtain the frequent 2-pattern does not pass the forward checking step. Therefore, it is not closed and we continue to grow the pattern by appending a fre-quent 1-pattern in its projected database. Next, we obtain a frequent 3-pattern backward checking. Thus, it is a closed pattern. Since we could not find any frequent 1-patterns in database, we can stop growing the pattern. Then, we continue to grow the pattern 1-pattern in the projected database. There is only one frequent 1-pattern in
Consequently, we obtain a frequent 3-pattern a x . However, it is not closed since it is a sub-pattern of pattern ab
Furthermore, we grow the frequent 1-pattern a by appending database as ab y . Thus, pattern ab may be pruned by using Lemma 3 , as shown in Fig. 7 . Similarly, pattern may be pruned as well. By growing the tree in a similar manner as described above, we can get all closed patterns. Fig. 7 illustrates the mining processes of the CMP-Miner algorithm, where the patterns in the bold circles are closed patterns, and those in the dotted circles are not. Finally, we obtain five closed patterns ab 4. Performance analysis
In this section, we evaluated the performance of the CMP-Miner algorithm with synthetic and real datasets. We compared the CMP-Miner algorithm with the modified Apriori and BIDE algorithms. The modified Apriori algorithm generates the fre-tinued until no more frequent patterns can be generated. The modified Apriori algorithm uses only the anti-monotone prop-erty to prune the impossible candidates.

Since the BIDE algorithm is originally designed to analyze datasets that contain only a single sequence in each transaction, we transform a multi-sequence time-series database into a single sequence time-series database by composing multiple se-quences in a transaction into one sequence. That is, for each transaction that contains multiple sequences, we append these sequences one by one to form a new transaction. For example, a transaction that contains two sequences is transformed into a single sequence f abccdyyxyz g . After the modified BIDE algorithm mines all the closed patterns in a single sequence format, the mined patterns may be transformed into a multi-sequence format. For exam-ple, the patterns f ab yy g and f a c y x g mined by the modified BIDE algorithm, may be trans-formed into a y b y , and a y c x , respectively. To compare the modified Apriori algorithm, the modified BIDE and our proposed algorithms, we first mine all closed patterns and then generate a complete set of frequent patterns from the closed patterns mined.

All of the experiments were performed on an IBM compatible PC with Intel Core 2 Duo CPU 1.86 GHz, 2 GB main memory, running on Windows XP Professional. The algorithms were implemented using Microsoft Visual C++ 6.0.
 The synthetic datasets used for the experiments were generated similar to those used in [23], with some modifications.
First, we generate potential frequent patterns and use them to construct transactions in the database. The parameters used sequence following an exponential distribution with the mean equal to 1. In the default settings of a synthetic dataset, the set to 10, and there are 10,000 transactions in the dataset. There are 800 potential frequent patterns in the dataset, whose average length is 6, and the minimum support threshold is set to 2%. Note that the support of a pattern is defined as the fraction of transactions containing the pattern in the database in the experimental section.
 4.1. Experiments on synthetic data
We compare the CMP-Miner algorithm with the modified Apriori and BIDE algorithms by varying one parameter while maintaining the other parameters at the default values shown in Table 2 . Fig. 8 shows the runtime versus the minimum sup-port, where the minimum support varies from 0.01% to 5%. The CMP-Miner algorithm runs about 33 X 350 times faster than the modified Apriori algorithm and runs about 14 X 43 times faster than the modified BIDE algorithm. The CMP-Miner algo-rithm outperforms the modified Apriori algorithm because the latter generates a huge number of candidates, especially when the minimum support is low. By using the projected database, our algorithm requires only one database scan and can localize support counting, candidate pruning, and closure checking in the projected database. The CMP-Miner algorithm adopts the closure checking and pruning strategies to accelerate the mining process and to avoid generating many impos-sible candidates. Even though the modified BIDE algorithm avoids candidate generation and uses similar pruning strategies as the CMP-Miner algorithm, the length of a transaction in the modified BIDE algorithm is longer than that in the CMP-Miner algorithm. Thus, the modified BIDE algorithm spends more execution time than the CMP-Miner algorithm. Therefore, the CMP-Miner algorithm outperforms the modified Apriori and BIDE algorithms.

Fig. 9 shows the runtime versus the number of transactions in the database, where the number of transactions varies from 100,000 to 1,000,000, and the minimum support threshold is equal to 2%. The runtime of all three algorithms increases al-most linearly as the number of transactions increases; however, the CMP-Miner algorithm runs about 65 times faster than the modified Apriori algorithm and about 6 X 9 times faster than the modified BIDE algorithm.

Fig. 10 depicts the runtime versus the length of a transaction where the length of a transaction varies from 8 to 20. As the length of a transaction increases, the number of closed patterns increases. Therefore, the runtime of all three algorithms increases. However, the CMP-Miner algorithm is about 54 X 85 times faster than the modified Apriori algorithm and about 6 X  270 times faster than the modified BIDE algorithm. Moreover, we notice that the runtime of the modified BIDE algorithm tiple sequences to form a single sequence, and mining such long single sequences costs more time. The modified BIDE algo-rithm runs slower than the modified Apriori algorithm when the length of transactions is greater than or equal to 16.
Next, we show the impact of the maximum number of gaps on the performance of all three algorithms in Fig. 11 . As the maximum number of gaps increases, more candidates or patterns are generated. Thus, the runtime of all three algorithms increases. We observe that the runtime of the CMP-Miner algorithm increases slowly as the maximum gap increases. The
CMP-Miner algorithm is about 45 X 140 times faster than the modified Apriori algorithm and outperforms the modified BIDE algorithm by about 2 X 27 times.

Fig. 12 shows the runtime versus the number of sequences in a transaction. As the number of sequences in a transaction increases, the runtime of all three algorithms increases. When the number of sequences in a transaction increases, it takes much more time to check whether the candidate patterns are frequent for the modified Apriori algorithm. When the number of sequences in a transaction is more than five, the database cannot be mined by the modified Apriori algorithm. The data-base cannot be mined by the modified BIDE algorithm, either. Since multiple sequences are appended together to form a sin-gle sequence, the length of the single sequence formed is five times as long as the length of the transaction with multiple sequences. The modified BIDE algorithm cannot efficiently mine closed patterns in the database with such long sequences. However, the CMP-Miner algorithm can efficiently perform the mining task in such databases.
 Fig. 13 shows the runtime versus the number of symbols in a sequence where the number of symbols varies from 3 to 8. Note that when the number of symbols in a sequence increases, more frequent 1-patterns may be mined from the database. in the projected database. As the number of frequent 1-patterns increases, the CMP-Miner and modified BIDE algorithms need to check more concatenated patterns. The runtime of the modified Apriori algorithm also increases as the number of symbols increases. The reason is that more candidates are generated as the number of symbols increases, and hence, the algorithm spends more effort on pattern concatenation and support counting. Therefore, all three methods appear to spend more time in the mining process. However, the CMP-Miner algorithm still outperforms the other algorithms in all cases. 4.2. Experiments on real datasets
In this section, we compared the CMP-Miner, and the modified Apriori and BIDE algorithms using two real datasets: weather and stock. The weather dataset was retrieved from the Data Bank for Atmospheric Research (DBAR) and the period of the dataset was from January 2003 to December 2007 with a total of 1825 transactions [6]. Each transaction in the data-base included two sequences: temperature and relative humidity in a day. These measurements were taken at the weather station in Taipei. Both sequences were recorded hourly. In the experiment, we aimed to examine the influence of tempera-ture and relative humidity on cloud formation. Hence, we selected dates with average cloudiness greater than six on a dec-imal scale where a value of six refers to mostly cloudy [5]. As a result, 1348 days were selected. Therefore, the database contains 1348 transactions, and the length of each transaction is 24.

First, we transform each sequence in a transaction into a symbolic sequence in the weather dataset. The first sequence in a transaction represents temperature and it includes five different symbols L the symbols L 1 , ML 1 , M 1 , MH 1 , and H 1 represent low, medium low, medium, medium high, and high temperature, respec-tively. The second sequence in a transaction represents relative humidity, and also uses five different symbols L MH 2 , and H 2 from low to high humidity.

The stock dataset was collected from the Taiwan Stock Exchange Corporation (TSEC) [24] from January 2000 to December 2007. Seven stock indexes were chosen, including Nasdaq Composite Index (IXIC), Dow Jones Industrial average (DJI), Tokyo Nikkei 225 Price Index (NK-225), Korea Composite Stock Price Index (KOSPI), Hong Kong Hang Seng Index (HSI), Singapore
Straits Times Index (STI), and Taiwan Stock Index (TAIEX). Each of these stock market movements is represented by one of the sequences in a transaction. Each sequence in a transaction represents the movements of the stock market in a month.
Therefore, the database contains 96 transactions (96 months), where each transaction includes seven sequences and the length of each transaction is about 20. Then, each sequence is transformed into a symbolic sequence. The movements of a
R (rising), F i (falling), and C i (constant), where i is the sequence ID in a transaction, 1 The performance of the three algorithms using the real datasets is quite similar to that found using the synthetic data.
Fig. 14 illustrates the runtime versus the minimum support for the weather and stock datasets. In the modified BIDE algo-rithm, a new transaction is formed by appending the second sequence to the first sequence. The length of a transaction is 48 in the weather dataset and about 140 in the stock dataset. Since the modified BIDE algorithm cannot efficiently mine fre-quent closed patterns in long transactions, it runs slower than the CMP-Miner and modified Apriori algorithms. The CMP-
Miner algorithm outperforms the modified Apriori algorithm because the latter generates a large number of candidates, especially when the support is low. In addition, the CMP-Miner algorithm adopts closure checking and pruning strategies to accelerate the mining process and avoid generating many impossible candidates. Therefore, it outperforms the modified Apriori and BIDE algorithms.

Fig. 15 presents the runtime versus the maximum number of gaps for the weather and stock datasets. As the maximum number of gaps increases, more candidates or patterns are generated and therefore the runtime of all three algorithms in-creases. Since the runtime of the CMP-Miner algorithm increases slowly as the maximum gap increases, the CMP-Miner algorithm outperforms the modified Apriori and BIDE algorithms.

In Fig. 16 , we demonstrate how the SAX symbolic representation may affect the performance on the real datasets. We apply the CMP-Miner algorithm to the weather and stock datasets with a different number of symbols, where the minimum support threshold is 10% in the weather dataset and 30% in the stock dataset. In both real datasets, the number of closed patterns decreases as the number of symbols increases. When the number of symbols increases, the runtime decreases for the weather dataset; however, it increases for the stock dataset.

We perceive that the trend of runtime obtained for the weather dataset is different from what we have observed from the synthetic data in which the runtime of the CMP-Miner algorithm increases as the number of symbols increases. In the weath-for most days. Thus, many values in a sequence are transformed into the same symbol in the SAX symbolic representation. As more equivalent symbols are contained in the dataset, more closed patterns but fewer frequent 1-patterns may be mined. In other words, discretizing by three or more symbols does not make a big difference on the number of frequent 1-patterns generated. Thus, the runtime of the proposed algorithm depends on the number of closed patterns mined from the dataset.
With smaller number of symbols, more closed patterns can be mined, and hence, the proposed algorithm requires more time in the mining process.

In comparison with the weather data, the movements of stock market indexes are collected on a daily basis and have lar-ger fluctuations. Hence, fewer closed patterns but more frequent 1-patterns are generated in the stock dataset. As more fre-quent 1-patterns are generated, the number of combinations of forming candidate patterns from a frequent pattern increases. This leads to more computational effort to check whether these candidate patterns are frequent and closed or
In the case of three symbols, the effort on generating closed patterns dominates the total runtime. As the number of symbols increases, fewer closed patterns may be mined and the effort that dominates total runtimes would shift to forming candidate patterns and checking if the candidates formed are frequent and closed or not. However, in the cases of four and five sym-bols, the effort on forming candidate patterns and checking is not yet apparent since the number of symbols only increases a little and the effort on generating closed patterns decreases because fewer closed patterns can be found. Hence, the runtime in the cases of four and five symbols may be less than that in the case of three symbols. As the effort on forming candidate patterns becomes apparent in the cases of six and seven symbols, the performance would be worse in comparison to the case of three symbols. Therefore, as the number of symbols increases, the runtime decreases for the weather dataset; however, it increases for the stock dataset.
 Mining the weather dataset, some interesting patterns were found such as MH 1 MH 1
H humidity are medium high or greater, it is likely to be a day with high cloudiness.

In Figs. 17 X 19 , we project the patterns back to the original raw data. Fig. 17 shows a continuous period of high (or med-ium high) temperature and high (or medium high) relative humidity from the 1st to the 10th hours, and demonstrates that warm and moist air produces clouds during this period. However, when the relative humidity starts to drop in the 11th hour and remains at a lower level afterward, the cloudiness also drops dramatically despite the temperature remaining at the high level.

In Fig. 18 , the temperature remains at the medium high level and the relative humidity remains at the high level, and hence, high cloudiness can be observed through the day. In Fig. 19 , it is mostly cloudy in the early morning when the tem-perature and relative humidity are high (or medium high) through the first eight hours. However, the relative humidity de-creases to a lower level from late morning to the afternoon while the temperature remains at a high level. Hence, a trend in decreasing cloudiness may be observed during this period. Nevertheless, from the 20th to the 24th hour, the cloudiness starts to increase as the relative humidity starts to increase and the temperature remains at a medium high level. 4.3. Experiments on synthetic data of long time-series
In this section, we further evaluated the performance of the modified Apriori and the CMP-Miner algorithms for long time-series (LTS for short) where each time-series contained over one million data points. We experimented with both syn-thetic and real data. The default values for the parameters used in the LTS experiments are listed as follows: the number of transactions in the database is 300, the length of transactions is 1,000,000, the minimum support threshold is 52%, the num-ber of symbols in a sequence is 5, and the maximum gap between any two symbols is 1. Notice that we do not include the modified BIDE algorithm in the LTS experiments because its runtime is extremely large.

The results of both algorithms using LTS datasets are consistent with the previous outcomes shown in Section 4.1, except the case of the runtime versus the number of symbols in a sequence. Fig. 20 shows the runtime versus the minimum support.
As the minimum support decreases, the runtime of both algorithms increases. The reason is that more closed patterns are generated and hence more runtime is required. Fig. 21 presents the runtime versus the maximum number of gaps. The per-formance of both algorithms is greatly influenced by the number of gaps. With larger number of gaps, both algorithms tend to generate more closed patterns and thus lead to more execution time. However, the CMP-Miner algorithm outperforms the modified Apriori algorithm.

In Fig. 22 , we evaluate the performance of both algorithms on different number of symbols in a sequence. The runtime of both algorithm decreases as the number of symbol increases; however, the CMP-Miner algorithm is more efficient than the transaction is really large, it is likely that each symbol may appear in each transaction many times and the possibility for these symbols to form frequent patterns is much higher, especially for the case with the smaller number of symbols. That is, much more closed patterns can be mined from long transactions than short ones. The effort on mining closed patterns dominates the total runtime. Thus, the runtime of both algorithms depends on the number of closed patterns mined from the dataset. With smaller number of symbols, more closed patterns can be mined. Therefore, the runtime of both algorithms decreases as the number of symbols increases.
 4.4. Experiments on real data of long time-series
In order to illustrate the performance of the CMP-Miner and modified Apriori algorithms on LTS for a real-world applica-tion, we used the dataset retrieved from Wharton Research Data Services (WRDS) [31]. Each transaction in the dataset con-1, 1967 to December 31, 2007 with 40 years in total. We excluded holidays from the dataset and left with 10,319 days in the dataset. However, during this period, some companies were added to the S&amp;P 500 index and some were removed. Hence, we er symbol for Honeywell International Inc. was changed from ACD to ALD in April 28, 1981 and then changed from ALD to HON in December 02, 1999. We regarded these three ticker symbols as the same symbol. As a result, seventy six companies satisfy this requirement. Therefore, the database contains 76 transactions and the length of each transaction is 10,319.
Since the quotes and the volumes for 76 companies fall within different ranges, we first normalized each sequence by putting them on the same scale and then transformed each of them into a symbolic sequence in the dataset. The first se-quence in a transaction represents the quote and it is divided into five symbols including ES represents extremely small, small, medium, large, extremely large, respectively. The second sequence in a transaction rep-resents the volume and it is also divided into five different symbols ES extremely large volume.

Fig. 23 shows the runtime for both algorithms when the minimum support varies from 60% to 100% for the LTS stock data-set. The result indicates that as the minimum support decreases, the performance of both algorithms degrades. This is because more closed patterns can be mined from the database when the minimum support is low. Hence, more runtime is required. However, the CMP-Miner algorithm appears to be more efficient than the modified Apriori algorithm.
Fig. 24 shows the runtime for both algorithms with different maximum number of gaps for the LTS stock dataset, where the minimum support threshold is 100%. We observe that as the maximum number of gaps increases, more closed patterns are generated. Thus, the runtime of both algorithms increases. However, the CMP-Miner algorithm outperforms the modified Apriori algorithm in all cases.

In summary, since the CMP-Miner algorithm employs the projected database, closure checking, and pruning strategies to imum support threshold is low or the number of sequences in a transaction is large. By using the projected database, our algorithm requires only one database scan and can localize support counting, candidate pruning, and closure checking in the projected database. Moreover, the CMP-Miner algorithm adopts the closure checking and pruning strategies to avoid generating many impossible candidates. Therefore, the experimental results show that the CMP-Miner algorithm outper-forms the modified Apriori algorithm by one or two orders of magnitude. Compared with the modified BIDE algorithm, the CMP-Miner algorithm achieves better performance in all cases. Although the modified BIDE algorithm and the CMP-
Miner algorithm both employ projected databases and similar pruning strategies to mine closed patterns, the transactions used in the modified BIDE algorithm is 2 X 7 times longer than those in the CMP-Miner algorithm. Thus, the CMP-Miner algo-rithm is more efficient and scalable than the modified BIDE algorithm.
 5. Conclusions and future work
In this paper, we have proposed an efficient algorithm, called CMP-Miner, to mine closed patterns in a multi-sequence time-series database. The method consists of three phases. First, we transform each time-series sequence to a symbolic se-base, our proposed algorithm requires only one database scan and can localize support counting, candidate pruning, and clo-the CMP-Miner algorithm outperforms the modified Apriori and BIDE algorithms by one or two orders of magnitude.
Although we have shown that the CMP-Miner algorithm may efficiently mine the closed patterns, there are still some issues to be addressed in future research. It is worth extending the method further toward mining closed patterns with a flexible gap constraint in time-series databases, where a gap in a closed pattern may be an interval ranging from k k 6 k 2 , and both k 1 and k 2 are non-negative integers. Finally, the CMP-Miner algorithm could further be used for other doubts whether there is a pattern that corresponds to an unusual event before earthquakes. Thus, we may focus on the factors like changes in ground water levels, changes in the concentration of anions in ground water, etc. Then, we may apply the CMP-Miner algorithm to discover meaningful patterns and expect that these patterns could help seismologists predict earthquakes.

In microelectronics, wafers are the critical components in the fabrication of semiconductor devices. To manufacture such components, many factors are taken into consideration, including temperature, and humidity. Manufacturers usually rely on past experience to determine the adequate temperature and humidity in order to produce high quality wafers. In order to address the issue of finding the adequate temperature and humidity, we apply CMP-Miner algorithm to mine time-series patterns from a database where each record contains both temperature and humidity readings (multiple sequences) during the process of producing a wafer in a semiconductor facility. Accordingly, based on the frequency of these patterns, we can determine the acceptable range of temperature and humidity to produce the best wafer. Likewise, weather forecasts are re-quired to predict the possibility of deteriorating weather conditions, especially approaching tornados or hurricanes. How-ever, making such accurate predictions is difficult because many factors are involved such as temperature, humidity, the storm arrives, and save a lot of costs or lives.

Furthermore, other than the above discussed applications, we may apply the proposed method to analyze real-world Acknowledgements
The authors are grateful to the anonymous referees for their helpful comments and suggestions. This research was sup-ported in part by the National Science Council of Republic of China under Grant No. NSC 97-2410-H-002-126-MY3 and NSC 95-2416-H-002-053.

References
