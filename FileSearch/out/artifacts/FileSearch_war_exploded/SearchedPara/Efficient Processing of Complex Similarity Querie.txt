 Multimedia and complex data are usually queried by simila-rity predicates. Whereas there are many works dealing with algorithms to answer basic similarity predicates, there are not generic algorithms able to efficiently handle similarity complex queries combining several basic similarity predica-tes. In this work we propose a simple and effective set of algorithms that can be combined to answer complex simila-rity queries, and a set of algebraic rules useful to rewrite si-milarity query expressions into an adequate format for those algorithms. Those rules and algorithms allow relational da-tabase management systems to turn complex queries into ef-ficient query execution plans. We present experiments that highlight interesting scenarios. They show that the propo-sed algorithms are orders of magnitude faster than the tra-ditional similarity algorithms. Moreover, they are linearly scalable considering the database size.
 Categories and Subject Descriptors: H.2.4 Database Management, Systems: Query processing General Terms: Algorithms, Theory.
 Keywords: Similarity predicates, query rewriting.
Exact match comparisons are rare in domains of complex data, such as images, videos, genomic sequences, and time series. Comparison based on ordering relationships cannot be applied either, as the total ordering property does not hold. Therefore, similarity emerges naturally as the natural way to compare data in complex domains.

Similarity comparisons employs Distance Function (DF) to quantify how similar, or close two objects are. Those Copyright 2006 ACM 1-59593-433-2/06/0011 ... $ 5.00. functions are the basis to create a metric space, which for-of valid elements and d () is the function d : S  X  S  X  R + expresses a  X  X istance X  between elements of S , i.e., the smal-ler the distance, the closer or more similar the elements are [9]. A DF must satisfy the properties of: symme-if s 1 6 = s 2 and d ( s 1 , s 1 )= 0 ; and triangular inequality : d ( s 1 , s 3 )  X  d ( s 1 , s 2 )+ d ( s 2 , s 3 ) , where s 1 , s S is said to be in a metric space if S  X  S .

There are two basic similarity predicates, expressed as e the range and the k  X  nearest neighbor queries. Given a data set S  X  S and a query center s q  X  S , they are defined as: 1. Range Query -Rq : given the maximum search dis-2. k-Nearest Neighbor Query -kNN : given an integer
Most algorithms for similarity search consider each query as an isolated operation instead of predicates integrating more complex query expressions. Moreover, they do not take advantage of optimizations that can be performed combining simpler expressions.Therefore, queries composed of multiple similarity predicates require expensive union and intersec-tion operations to combine intermediate results to answer conjunctions and disjunctions of elementary predicates.
A RDBMS supporting multimedia data demands efficient ways to answer complex similarity queries. To integrate similarity queries with the traditional ones, the similarity predicates should be included into the relational algebra. As a consequence, similarity operators should be used together with other predicates already available in the relational algebra, such as exact match and order-based comparisons for textual/numeric attributes, and also in comparisons combining two or more similarity predicates. In this paper we delve into the later kind of queries, that is, those expressed as sequences of conjunctions and disjunctions of the basic similarity predicates. Examples of real systems demanding such kind of queries follows. Q1: In a user friendly word processor:  X  When a wrong word is written, show up to 5 correct words that differ at most 2 characters  X  ( k -NN and Range): e  X  Q2: In real state business:  X  X how the 10 nearest available houses to my job  X  X j X  that are not farther than 15 miles from  X  X j X , and not farther than 15 miles from my wife X  X  job  X  X j X  (conjunction of several predicates): e Q3: In health-care information systems:  X  X how the XRay exams of any patient that are the 10 most similar to each of these three XRay exams e 1 , e 2 and e 3 from my current patient but that do not differ from them more than 10 % X  (disjunction of conjunctions): e e  X 
Another important application for complex similarity que-ries is to support relevance feedback (RF), which allows the users to set the elements of a query that fulfills his/her in-terest, guiding automatic corrections of future queries [16]. The query reprocessing can change the distance function or the center element. It can also take advantage of rewri-ting the similarity query including new similarity conditions. The later approach produces the best results, but rely on the ability to efficiently handle complex queries.

Although complex queries can be executed combining in-termediate results of basic range and k -NN algorithms by set-theoretical operators, a more efficient approach should use few general algorithms configured by the query optimi-zer of a RDBMS. This approach leads to two core problems: how to rewrite a query plan to obtain an optimal execution; and how to make frequently-used composite operations more efficiently executed by a multi-purpose algorithm than by the sequential execution of the basic algorithms combined by set-theoretical operators. We tackle both problems in this paper, addressing the following issues: 1. Which multi-purpose algorithms are efficient to answer 2. What rules guide query rewriting when generating 3. How to adequately represent a query to be submitted
The remainder of this paper is structured as follows. The next section gives a brief history of algorithms for answe-ring similarity queries. Section 3 describes the basic algo-rithms for similarity queries and their most common variati-ons. Section 4 presents the rules governing complex simila-rity queries centered at the same query element and defines the algorithms required to support them. Section 5 pre-sents rules governing complex similarity queries centered at different query elements and an algorithm to answer them. Section 6 show experimental results comparing the traditi-onal approach with the algorithms and concepts presented in this paper. Finally, section 7 concludes this paper.
The properties of a distance function led to the develop-ment of hierarchical index structures called Metric Access Methods (MAM). MAM are fundamental to accelerate se-arches in large sets of complex data types, where only the set of elements and a DF are available. MAM such as the M-tree [9] and the Slim-tree [22] can accelerate similarity queries on complex data by orders of magnitude.
Similarity search algorithms motivated several works. Al-gorithms for range queries are straightforward, because a limiting radius is always known throughout its execution. However, the minimum radius that cover the k nearest ele-ments is not known beforehand for k-NN algorithms. Thus, the ordering to search subtrees in hierarchical index structu-res is important, turning the choice of path sequences that lead to high subtree-pruning one of the most pursued objec-tives [22]. Many approaches have been proposed to improve the performance of k -NN queries as, for instance, branch-and-bound [17], incremental [11], multi-step [13, 18] and fast parallel algorithms [1]. Another approach is to estimate a final limiting range for the query and perform a sequence of  X  X tart small and grow X  steps [20]. All of these works refer to algorithms dealing with just one simple similarity predicate.
Multiple similarity queries executed as a single command have been introduced, allowing potential for much more optimization than single queries do [4, 2]. Algorithms to answer multiple similarity queries substantially speed-up query-intensive data mining applications. Multiple k -NN queries are addressed in [4], analyzing optimizations re-garding CPU and I/O costs with potential for parallelism. Complex similarity queries consisting of more than one si-milarity predicate have been studied considering complex si-milarity queries over a single feature [10] and over multiple features [7, 3]. Algorithms to perform a spatial selection and a spatial join simultaneously are presented in [14]. Indexing structures are used in [10, 3] to enhance complex similarity queries in relevance feedback environment. None of these works consider combining multiple similarity predicates th-rough a set of operations, but instead they use intermediary scoring functions to evaluate the overall scores that indicate the pertinence of each element to the answer. A query involving complex Boolean expressions in RDBMS can be rewritten in an equivalent expression. Re-writing into Conjunctive or Disjunctive Normal Form (CNF or DNF) using one index per expression is a well-known technique [19]. Multiple indexes techniques are presented in [15]. Other approaches involve optimizing user-defined predicates with varying evaluation cost and selectivity re-garding AND [8] and OR [12, 7] expressions. Factorization also helps rewriting Boolean expressions aiming optimizati-ons [6].

Similarity query optimization over multimedia data star-ted to receive attention, addressing the rewriting and op-timization of ranked queries using expensive predicates [5]. However, no work addressed optimizations based on query rewriting for the similarity-based select operators regarding complex expressions, which is the objective of this paper.
Aiming at covering as many query options as possible, we consider that each type of basic similarity predicate corresponds to as a basic, but flexible operator. Thus, a range predicate Rq ( s q , r q ) corresponds to a Range ( operator, and a k -NN predicate kNN ( s q ) corresponds to a Nearest (  X  , s q , k ) operator. The parameter  X  is one of the re-lational operators &lt;,  X  ,&gt;,  X  , = or 6 = . The basic range and k -NN predicate uses  X   X   X  as  X  in the corresponding operators.
There are variations of each similarity predicate, and most of them can be expressed using the two basic operators. A common variation is obtaining the farthest instead of the nearest elements. Thus, a reversed range predicate Rq  X  1 ( s q , r q ) asks for the elements s i in the data set S such that d ( s i , s q ) &gt; r q . This is obtained when the in the range operator is &gt; . A k -farthest neighbor predicate kF N ( s q ) is equivalent.

Table 1 lists the basic queries and the variations used in this paper, together with their predicates and the corres-ponding operators. In this paper we use only  X  and &gt; as  X  for both operators. Table 2 lists the symbols used in this paper.

We define complex similarity queries as those composed of two or more basic similarity predicates combined by the Boolean operators  X  ( and ),  X  ( or ) and  X  ( not ). To analyze expressions representing complex similarity queries we di-vide the expressions into those having every predicate cen-tered at the same query object (centers), and those having distinct centers. The former expressions are further divided into those composed of only a single similarity operator, and those involving both range and k -NN operators. Single operator means either only range or only k -NN operators, resulting in three classes: In this section we analyze the expressions combining simi-larity operators over a single center s q  X  S applied over the data set S  X  S of a metric domain S with cardinality  X  = | S | .
We present in Appendix six basic properties of simila-rity predicate combination, and show that both the fields of range and of k -NN predicates centered at the same ele-ment forms corresponding Boolean Algebras. Therefore, any SCSO expression always can be expressed in disjunctive or conjunctive normal form (DNF or CNF). Both DNF and CNF share dual properties, so without loss of generality we consider only the DNF in the following discussion. A DNF expression consists of a disjunction of conjunctive min-terms, where each conjunctive min-term is the conjunction of either one variable or its complement. The variables are the basic similarity predicates. Therefore, any SCSO ex-pression can always be represented in DNF.

To simplify the notation for SCSO expressions, let p i , i = 1 ... n be a predicate using a basic similarity operator p , where p is either Range or Nearest. Let also u i be the limiting value of predicate p i , so if p is Range then u i is the radius r of the predicate k i NN ( s q ) . Let us also express a conjunction of predicates on p as m p a . Therefore, a SCSO expression involving predicates p i on the similarity operator p and the  X  ,  X  and  X  Boolean operators can always be expressed in DNF as (  X  p 1  X  ...  X  p i  X  p j  X  ... p k )  X  (  X  p x  X  ... p m b  X  ... . Notice that if p i is a range predicate p i = Rq ( s k NN ( s q ) then  X  p i =(  X   X  k i ) F N ( s q ) .

The following three Theorems apply to conjunctive min-terms, and can be straightforwardly demonstrated using the properties presented in the Appendix. Property 3 on Range operators and Property 5 on Nearest operators allow sim-plifying min-terms of the form m p a = p 1  X  p 2  X  ... p n we give an intuition of the theorems using Figure 1, which shows a two-dimensional space with the Euclidean DF, so the points nearer than a limiting radius r to a center point s are within a circle of radius r centered at s q . Figure 1: Regions covered by min-terms considering an Euclidean distance function in a 2D space. (a) min-term m p 0 ; (b) min-term m p 1 ; (c) min-term m p c .
Theorem 1: Two basic predicates per Min-terms -Each min-term in a SCSO DNF expression is composed of at most two basic predicates, one complemented and the other not complemented: where u i = min ( u 1 ,... u g ) and u j = max ( u h ,... u
The min-terms having only one basic predicate are either the one not having a complemented predicate, which we represent as m p 1 , or the one having only the complemented predicate, which we represent as m p 0 . Min-terms m p 0 m 1 in a two-dimensional Euclidean domain are shown in Figure 1(a) and (b) respectively.

Theorem 2: Min-terms as Rings -If the limiting value of the complemented predicate of a min-term m p c with two basic predicates is less or equal than the limiting value of the non-complemented predicate, then m p c defines a ring-shaped region, otherwise it can be dropped from the DNF expression. That is: Figure 1(c) shows a two-predicate min-term m p c . DNF ex-pressions combine one-and two-predicate min-terms leading to complex expressions, as the one shown in Figure 2.
Theorem 3: Overlapping Min-terms -Min-terms with overlapping limits can be joined as follows. ( total overlapping: ) ( partial overlapping: ) Figure 2 shows the min-term m p c =  X  p 4  X  p 7 totally overlap-ping min-term m p b =  X  p 5  X  p 6 , therefore only the min-term m c must be retained. Likewise, the min-term m p d =  X  p 9  X  p partially overlap min-term m p e =  X  p 8  X  p 10 , therefore they can be joined in the single min-term m p d  X  m p e =  X  p 8 Min-term m p 0 can be checked for overlap considering that the missing predicate is p  X  with u  X  =  X  , and the min-term m 1 checked using p 0 with u 0 = 0 .
 Figure 2: Regions involved in the disjunctive normal form p 1  X  (  X  p 2  X  p 3 )  X  (  X  p 5  X  p 6 )  X  (  X  p 4  X  p (  X  p 9  X  p 11 )  X  X  p 12 , considering range queries and the Euclidean distance function in a 2D space.
 Operators to execute SCSO expressions Single Center/Single Operator expressions in DNF simpli-fied by Theorems 1 to 3 cannot be further simplified, so a DBMS supporting similarity queries must be able to execute a simplified expression. There are two approaches: an al-gorithm for each basic operator processing a min-term at a time, or an algorithm executing the full expression at once.
The first approach employs the existing algorithms to exe-of min-terms m p 1 and m p 0 . However, two other algorithms must evaluate min-terms composed of two basic predica-tes: the RingRange ( s q , r qi , r qe ) and the RingNearest ( s each one executing a min-term m p i over the correspon-ding operator. These algorithms can be created mo-difying the corresponding basic algorithms as follows. The RingRange ( s q , r qi , r qe ) algorithm changes the comparison of an element s i meeting the predicate d ( s i , s q )  X  r q sic algorithm to the predicate r qi &lt; d ( s i , s q )  X  r forms just the Nearest (  X  , s q , k qe ) operation, dropping the k nearest neighbors from the final answer. The simplification process guarantees that each region covered by a min-term does not overlap any other, thus a complete SCSO expres-sion can be evaluated calling a ring operator once for each min-term and concatenating the partial results to get the final answer.

The second approach to execute SCSO expressions em-ploys a generalized algorithm to evaluate the full expression at once. We define the GenericRange ( s q , rLimit []) algorithm to process range predicates, where rLimit [] is an array of to a min-term. It is similar to the RingRange () algorithm, but the predicate compares each element s i to check if it is inside a valid region defined in rLimit [] . An equivalent GenericNearest ( s q , kLimit []) algorithm shown as Algorithm 1 is defined for k -NN predicates. It first sorts every element based on its distance to the predicate center, then includes in the answer those elements whose rank is inside the ex-tent defined by a min-term given by the pairs &lt; k i , k kLimit [] .

It is not worth to use the first approach in expressions composed of several min-terms with k -NN predicates, be-cause the rank of each element regarding its proximity to a predicate center cannot be determined without knowing the other elements in the set. Therefore, answering SCSO queries with on k -NN predicates imposes the second appro-ach. The cost of executing the GenericNearest () algorithm is equivalent to a single execution of the Nearest () using the largest k in kLimit [] . Therefore the GenericNearest () algo-rithm is always faster than calling the Nearest () algorithm several times, whenever the number of limits MaxK exceeds one.
 Algorithm 1 GenericNearest ( s q , kLimit []) 1: CoverOb jSet = Nearest ( s q , kLimit [ MaxK ] . k e ) 2: for each j in CoverOb jSet do 3: if j . rank () is in kLimit then 4: Answer . Add ( CoverOb jSet [ j ])
To analyze a SCMO expression, we extend the p i / u i no-tation of SCSO expressions to represent SCMO expressions in the following way. If p i is a range predicate with limiting radius u i then q j is a k -NN predicate with limiting k = v Similar to m p a , m q b represents a disjunctive min-term of pre-dicates of type q . The symbols p and q can be arbitrarily assigned to either range or nearest operators, provided they are distinct from each other. A conjunctive predicate p i on a single center s q recovers the elements satisfying both basic predicates. Therefore, if p i  X  q j = k i NN ( s q )  X  Rq ( s then e  X  lowing Theorem.

Theorem 4: The field of range and k -NN predicates with same center forms a Boolean Algebra -The conjunction of a k -NN predicate with a range predicate satisfies the com-mutative, associative and distributive properties over both  X  and  X  Boolean operators.

The importance of this theorem relies on representing every single-centered expression as a SCMO expression in DNF, where each min-term is a conjunction of range and k -NN predicates, complemented or not. Moreover, as each operator range or nearest can contribute with at most two predicates, each min-term is a conjunction of at most four predicates: a reversed range, a k -farthest neighbor, a range and a k -NN. As these predicates are commutative over  X  , each min-term of a DNF expression always can be expres-sed as m pq a =( m p b  X  m q c )=(  X  p g  X  X  q h )  X  ( p i
Any conjunction Rq ( s q , r q )  X  kNN ( s q ) or Rq  X  1 ( s kF N ( s q ) of predicates centered at the same element s quires intersecting the intermediate results obtained by the basic operators. We propose a new kAndRange (  X  , s q , k , r gorithm that receives the limits from both the range and the k -NN predicates and returns the elements that satisfy both criteria, so the following theorem can be stated.
Theorem 5: Conjunction of k -NN and Range with same center -The conjunction of a k -NN and a range predicate over dataset S is equivalent to the intersection of the results from both basic operators and equivalent to the Using the property of commutativity to represent every min-tion of a sub-expression on range with a sub-expression on k -NN predicates, and each one can be simplified using The-orems 1 to 3. Once simplified, the remaining min-terms can (  X  p g  X  X  q h ) and then to process ( p i  X  q j ) .
The intersection of two distinct min-terms in an SCMO expression in DNF can be non-empty. An algorithm to pro-cess such expressions can be improved guaranteeing that the min-terms are disjoint, so the following theorem is useful.
Theorem 6: Disjoint min-terms in DNF expres-sion -Suppose a SCMO expression in DNF with at least two min-terms m pq a = (  X  p g  X  X  q h )  X  ( p i  X  q m b = (  X  p e  X  X  q f )  X  ( p k  X  q l ) . If the limiting values u  X  u e  X  u i , then the min-term m pq a can be substituted by two non-overlapping min-terms: m pq a = (  X  p g  X  X  q h )  X  ( p e  X  q j )  X  (  X  p e  X  X  q h If the limiting values u e  X  u i  X  u k then the min-term m can be substituted by two non-overlapping min-terms: m pq b = (  X  p e  X  X  q f )  X  ( p i  X  q l )  X  (  X  p i  X  X  q f When no pair of min-terms of a SCMO expression allows any of those substitutions, then each min-term is disjointed from any other min-term, so we call it an overlap-free, or a O -expression.

The substitutions in Theorem 6 can be applied to both predicate types, but it is enough to apply to just one. Notice that it fosters the use of incremental algorithms, and enables the use of the concatenation operation in place of the more expensive union operation.
 Operators to execute SCMO expressions
SCMO expressions in DNF benefit from specific retrieval algorithms. A common sub-expression, worth to be imple-mented as a specific algorithm is the  X  k -nearest and range query X , defined as follows.

Definition 1: k -Nearest and Range Query -Given an element s q  X  S , a nearest value k , a distance r q  X  R + a relational operator  X   X  X  X  ,&gt; } , a  X  k -Nearest and Range query X  retrieves every element s i  X  S | d ( s q , s i )  X  Nearest (  X  , s q , k ) .

A  X  k -nearest and range query X  can be executed by a kAndRange (  X  , s q , k , r q ) algorithm (see Algorithm 2). It exe-cutes the conjunction p i  X  q j of a range and a k -NN predica-tes centered at the same element, where p i and q j are both complemented or both not complemented. The conjunction requires both predicates satisfying the same  X  condition, so this algorithm is based on the Nearest (  X  , s q , k ) one. The allowed distances of the answers to the query center, re-presented by r c , starts at r q and is reduced (increased) as nearer (farther) elements are found. The answer is sorted by the distance of the element to the query center. The methods Add () inserts a new element to the list keeping it sorted, Length () returns the number of elements in the list, DropLast () removes the farthest (if  X  =  X   X   X ) or nearest (if  X  =  X  &gt;  X ) element in the list, and MaxDist () returns the dis-tance to the farthest or to the nearest (regarding  X  ) element in the list.
 Algorithm 2 kAndRange (  X  , s q , k , r q ) 1: set Answer to null , set r c to r q 2: for each s i in S do 3: Compute d ( s i , s q ) 4: if d ( s i , s q )  X  r c then 5: Answer . Add ( s i ,  X  ) 6: if  X  ( Answer . Length ()  X  k ) then 7: Answer . DropLast (  X  ) 8: set r c to Answer . MaxDist (  X  ) 9: return Answer
The U niSimDNF ( minterms [] , s q ) algorithm (see Algo-rithm 3) answers a whole O f -expression, using the intermediary results of each call to kAndRange () is a set of elements sorted by their distances to the predicate center s The final answer of a min-term is the intersection of both intermediary answer but, as both are sorted by the distance of each element to s q , this operation can be computed with linear computational complexity on the number of elements involved.

The SCMO expression in DNF is sent to U niSimDNF () as parameter minterms [] . As each min-term is calculated, the result is maintained in a queue sorted by the distance of each element to the query center s q . Therefore, the union of each min-term to the previous ones can also be executed in linear time regarding the number of elements involved. Algorithm 3 U niSimDNF ( minterms [] , s q ) 1: set Answer to null 3: set Answer to Answer S kAndRange ( &gt;, s q , k h , r 4: return Answer
Expressions involving the basic similarity predicates can include predicates centered at several elements. The comple-ments of basic predicates do not depend on other predicates existing in the same expression, so Properties 1 and 2 also holds for MCMO expressions. The commutative, associative and distributive properties over the  X  and  X  Boolean opera-tors also hold for sub-expressions composed of the predicates centered at any element. Therefore, the field of MCMO ex-pressions also forms a Boolean Algebra.

MCMO expressions can be represented in DNF with min-terms composed of range or k -NN predicates, complemen-ted or not, centered at the same or at distinct elements. MCMO expressions do not present special properties ena-bling further optimizations. However, we developed a tech-nique to rewrite MCMO expressions that splits existing over-lapping min-terms into other disjoint min-terms, exploiting the proposed properties of the SCSO and SCMO expressions to build efficient algorithms to answer MCMO queries.
For this discussion, suppose a MCMO query expres-sion involving predicates centered at nc different elements c , c 2 ,... c nc , and let c k m pq a represent a disjunction on both operators p and q centered at c k , that is, c k m pq a =(  X  p  X  q tered at element c k . Then, each min-term has the form:
To evaluate an MCMO query in DNF, our algorithm factorizes the query expression using one center at a time. Let us assume that the set of centers are main-tained in a given order, so that c i precedes c j for every i &lt; j . An expression factorized by center c 1 becomes ( expression in DNF involving predicates centered at elements c j + 1 ,... c nc . For example, the expression with two centers c , c 2 : is factorized considering the center c 1 to Each E i , j is in turn recursively factorized considering one of the remaining centers. Each E i , j sub-expression and the full expression are simplified using Properties 1 to 3. After every sub-expression and the full expression had been simplified, they can be executed. The simplification process assures that each min-term in an expression do not overlap with the other min-terms in the same expression. Therefore, the implicit union operation required to integrate the answers of each min-term is executed as a concatenation operation, with linear processing cost regarding the number of elements concatenated.
 The algorithm to execute a factorized MCMO query called GenSimDNF ( minterms [] , centers []) is detailed in Algorithm 4. The parameter minterms [] is an array with the min-terms of the expression, and centers [] is an array with the cen-ters. The algorithm works as follows. If an expression has only one center c , it returns the result of executing U niSimDNF ( minterms [] , c ) . Otherwise, it chooses one cen-ter as c , and factorizes the expression finding each dis-tinct term c m pq i occurring in the set of min-terms. For each min-term c m pq i , it factorizes the remaining terms and calls GenSimDNF () recursively. The answers from each sub-expression are intersected with the answers from the c m pq term, generating the result of each min-term, which are in turn concatenated to obtain the final result of the query. Algorithm 4 GenSimDNF ( minterms [] , centers []) -Execute a generic similarity query in disjunctive normal form. 1: set Answer to null 2: if | centers [] | &gt; 1 then 3: set c = FactorOut ( centers []) 4: for each c m pq i  X  minterm [] do 5: Prepare ( minterms [] , c m pq i , InnerMinterms []) 6: set Answer to Answer S 7: return Answer 8: else 9: return U niSimDNF ( minterms [] , centers [ 1 ]) Algorithm FactorOut ( center []) , called in step 3 of GenSimDNF () , chooses one center to factor out, thus defining the order of the centers. Algorithm FactorOut () can use diffe-rent heuristics based on the sizes of the query radii relative to the dataset diameter, and on the number k of elements requi-red relative to the number of elements in the data set. This algorithm can benefit from optimizations regarding particu-larities from a given application domain, so this is a topic where further research can improve performance. To per-form the experiments presented in the next section, we have used a generic heuristic that we found useful in a variety of application domains. This heuristic uses the centroid of the remaining centers, selected as follows. Calculate the summa-tion of the squared distances from each center to every other, then select the center whose summation is the smallest. and stores the resultant sub-expression into InnerMinterms [] .
A factored expression can have more min-terms than the equivalent DNF expression, but it will never have more pre-dicates p i . Therefore, the factorized expression will never require more incursions into the dataset to retrieve the par-tial answers than the DNF expression. Similarity queries over multimedia data can be very expensive. However, in our approach the overhead of the factorization cost of the GenSimDNF () algorithm is overcame by the expressive gain in the query execution, as shown in the next section.
This paper proposes rewriting techniques to improve pro-cessing similarity queries. In this section we present ex-periments comparing the proposed algorithms with compo-sitions of the basic algorithms combined by set-theoretical operators (the traditional approach), and show that the pro-posed algorithms are much faster and scalable considering database size.

The algorithms were implemented in C++, and the ex-periments ran in an AMD Athlon XP 2600 processor with 385MB of main memory, under the Linux operating system. Every test was performed using both sequential scan (SeqS-can) and a Slim-tree index. We present the results obtained from the following four data sets:
Due to space limitations, in this paper we highlight the performance regarding only total time, as it summarizes the whole computational cost. Each measured point in the graphs represents the total time in seconds (log scale) to evaluate 200 queries with constant values for r and k and different centers.
We evaluated the proposed algorithms comparing them with the traditional ones to query the real world data sets. The first experiment evaluates the time required to exe-cute a complex similarity query on a pure metric data set ( EngWords ), processing the SCMO expression correspon-ding to Query Q1 stated in Section 3:
Figure 3 shows the total time required to process 200 que-ries asking for the k = 5 most similar words differing not more than r letters from a query center, for r varying from 1 to 10. The query centers are words randomly chosen in the data set. Plots A and C show the total time of the proposed kAndRange () algorithm respectively using Slim-tree and sequential scan. Plots B and D show total time using the traditional approach running both algorithms consecuti-vely, using Slim-tree and sequential scan respectively. When using the L Edit , the number of words retrieved rapidly incre-ases as r increases, and for r &gt; 8 it is retrieved, in average, more than 90% of the data set. The intersection operation required by the conjunction of the traditional algorithms can be quadratic on the cardinality of the sets intersected, explaining way plots B and D in Figure 3 present noticea-ble increasing starting on r  X  5 , whereas for smaller values Figure 3: Results of executing the following query over the EngWords data set, using the L Edit DF: e  X  of r the time is mostly spent in the retrieval operations. However, the proposed kAndRange () algorithm does not suf-fer from this problem (as seen in plots A and C). There-fore, the proposed techniques lead to speedups from at least two times faster (sequential scan for radius from 1 to 3) to more than a hundred times faster (large radius for any ac-cess method). Moreover, even when the indexing structure reflects the explosion of words for larger values of r (plot A), the k = 5 limit always guarantees a performance better than sequential scan, even for large values of r (plot C). The second experiment evaluates the execution time of the MCMO expression corresponding to Query Q3 of Section 3 over XR , a pure metric data set. Figure 4 shows the results of asking for the 10 images most similar to each of three images e 1 , e 2 and e 3 but not exceeding a given radius r . The radius r varies from 0.01% to 10% of the data set diameter, and the number of nearest neighbors is fixed at k = 10 . As in the previous experiment, each measurement represents the total time in seconds to evaluate 200 queries for the same r and k and three randomly chosen centers.

Figure 4(a) shows the results of evaluating the complete query in the traditional way (plots A and D), and optimizing the query with the proposed algorithms (plots B and E). It also shows the time to execute just one min-term th-rough the proposed kAndRange () algorithm (plots C and F), since the processing of each min-term gives equivalent mea-surements. Figure 4(b) shows the time to obtain intermedi-ary results, highlighting where the answering process spends more time. It shows the time to evaluate one range predicate (the e  X  e  X  10 NN ( e 1 ) X R ) (plots H and K) and the results of executing one min-term both through the proposed kAndRange () algo-rithm (plots C and F) and through the intersection of the range and k -NN algorithms (plots G and J). Plots C and F appears in both Figures 4(a) and 4(b) for reference. All plots are in log-log scales.

As it can be seen in Figure 4(a), for smaller values of r the proposed method (plots C and F) consistently requires approximately one third of the time required by the basic algorithms (plots A and D). This reduction comes from the query expression having three min-terms. This figure con-firms that the optimization-based algorithms can take into e account the other min-terms when processing one min-term, improving the overall performance.

Another important point shown in Figure 4(b) is that the kAndRange () algorithm improves the query execution by limiting the number of retrieved elements when using ac-cess methods. Observe that the plot corresponding to the range algorithm (plot L) increases continuously, surpassing the plot of the k -NN algorithm (plot K). However, as the number of elements retrieved by the range algorithm ap-proaches k , the curve corresponding to the kAndRange () al-gorithm flattens (plot F), always remaining lower than the combination of the range and k -NN algorithm (plot J). This effect is reflected in the time spent to evaluate the complete query, so the improvement for large values of r is even more remarkable, as it can be seen comparing plot E with plot D of Figure 4(a). The pruning obtained by limiting the number of elements in the range part of the min-term also reduces the complexity of merging the intermediary results of each min-term. As it can be seen comparing plots E and D of Figure 4(a), the speedup obtained achieves more than 130 times for large radii and small k .

Query Q3 is composed of three min-terms at different centers, and plots E and F of Figure 4(a) shows that the time required to evaluate the complete query by the propo-sed method is about one third of the time required by the basic algorithms. This is due to the cost of the U niSimDNF () algorithm being equivalent to a single call to kAndRange () , whereas the traditional approach needs calling the basic al-gorithms the same number of times as there are min-terms. Experimental evaluations confirmed that more complex que-ries lead to correspondingly larger improvements.
The third set of experiments evaluates the time required to execute the MCMO expression derived from Query Q2 of Section 3 over the LBeach data set. Figure 5 shows the results of asking for the 10 closest road intersections not farther than radius r 1 from center m j and not farther than radius r 2 from center w j . Radii r 1 are the abscissas and r randomly chosen in [ 0 , r 1 ] . Figure 5 shows the time required to evaluate the full expression using both the proposed and the traditional approaches, using the Slim-tree (plots A and C) and sequential scan (plots B and D). In this case, the gain for the proposed algorithm is about 35% for small radii, the ones most frequently asked in similarity queries. Figure 5: Evaluating Query Q2 of Sec-tion 3 over the LBeach data set using the Euclidean DF: e  X  e  X 
To evaluate the scalability of the proposed algorithms, we performed two experiments. The first employed the expres-sion of Query Q2 from Section 3 over the LBeach data set. For this experiment, we generated random samples of 5,000 elements, 10,000 elements, and so on from the LBeach data set, and measured the total time to calculate 200 queries using k = 37 (equivalent to 0.1% of the data set size) and r = 0 . 001 of the data set diameter. The result, shown in Fi-gure 6, indicates that the proposed algorithms have a linear behavior regarding the data set size.

The second scalability experiment evaluated the kAndRange () algorithm using the Synt30D data set, showing the total time to calculate 200 queries considering k = 10 and r q = 0 . 02 (see Figure 7). Each set of 200 queries was performed increasing the data set in steps of 50,000 elements. The measurements show that the behavior of this algorithm is linear even for very large data sets, that do not fit in main memory, as it happens with the Synt30D data set. Figure 6: Scalability test using Query Q2 of Sec-tion 3 over the LBeach data set.
 Figure 7: Scalability test regarding the kAndRange () algorithm over the Synt30D data set.
Similarity queries have been increasingly demanded to re-trieve complex data in large data sets but, until now, there was no study on how to analyze and optimize a query ex-pression involving more than one similarity predicate. This paper brings the following contributions to this subject: 1. It presents rules to derive formal optimizations for si-2. The algebraic approach adopted helps to identify 3. The rules developed for similarity query optimizations 4. We implemented the prototype of a similarity query
Throughout the paper we answered the three main issues stated in Section 1. Starting with the third issue,  X  How to adequately represent a query to be submitted to multi-purpose similarity search algorithms  X : it is solved by divi-ding the problem of analyzing complex similarity expressi-ons in three steps  X  Single Center/Single Operator (SCSO), Single Center/Multiple Operators (SCMO), and Multiple Centers/Multiple Operators (MCMO). Following this ap-proach, rules to simplify a complex similarity expression were straightforwardly obtained, solving the second issue:  X  What rules guide the query rewriting process to explore stra-tegies to execute similarity search algorithms  X . Those rules allow representing the query expressions in a way such that union and intersection operations can be performed with li-near computational cost regarding the number of elements involved, as opposed to the usual super-linear complexity required by traditional methods. Thereafter, we presented algebraic rules to optimize similarity queries, and a small collection of simple and generic similarity-based retrieval al-gorithms able to answer complex similarity queries in linear time, solving the first issue  X  Which algorithms are efficient to answer queries composed of conjunctions and disjuncti-ons of similarity predicates  X . We identified that four algo-rithms are enough to answer any complex similarity query involving range and k -NN predicates and their discussed va-riations. They are the GenericRange () , the GenericNearest () , the U niSimDNF () , and the GenSimDNF () algorithms. Th-ree others, the RingRange () , RingNearest () and kAndRange () were also included to improve performance when answering simpler but frequently asked queries.

Rules to simplify complex similarity expressions enable to generate multiple representations of a query. Selecting the one that leads to the best execution plan depends on a cost model, which is dependent from the underlying indexing structure employed. In this paper we concentrated on rules that are independent from indexing structures, so we do not elaborated on this subject. The experiments performed assume that the majority of the queries aim at retrieving few elements relative to the database cardinality. The results showed that the proposed approach is significantly better than the traditional one.

As a follow-up of this paper, we are working on the rules to extend the relational algebra to support similarity join and combinations of similarity and non-similarity based predi-cates. This will open the possibility to support the storage, relevance feedback and content-based retrieval of complex data, such as images, scientific and biological data, among others, in systems based on the relational algebra, such as the current RDBMS based on SQL.
 This work has been supported by CNPq (Brazilian Natio-nal Council for Research Supporting), FAPESP (S  X ao Paulo State Research Foundation) and CAPES/Fulbright (Brazi-lian Federal Agency for Post-Graduate Education).
