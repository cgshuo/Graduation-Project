 With the emergence of XML [1] as the standard for representation structured and semi-structured documents, relational databases, and object repositories, more and more distributed applications use XML to represent heterogeneous data sources. Nowadays, W3C has proposed XQuery language [2] as XML query standard and XPath [3] as a language embedded in XQuery to address the nodes of XML trees. In order to improve the query processing on XML data source, cached materialized XQuery view and XPath view can be used. We suppose that XQuery view is a view specified by a query written in XQuery language and XPath view is a view specified by a query written in XPath language. Our work puts its emphasis on XPath view. 
Cached materialized view has lots of benefits, but it has inconsistency problem when the data source is modified. View recomputing is a simple method to solve this problem, but it could result in unnecessary overload especially in web environment. Another method is maintaining the view incrementally. Many studies on relational data model have shown that the performance of incremental maintenance of materialized view is much better than that of view recomputing [4,5,6], but it is still a challenge for incremental maintenance of materialized view on semi-structured data model, such as XML data source. 
This paper proposes an incremental maintenance algorithm IMA to implement in-cremental maintenance of materialized XPath views based on the idea of incremental mental maintenance program automatically; (2) The incremental maintenance program sistent view; (3) The incremental maintenance program is written in XQuery language cost is very small. This approach can be used in mobile computing environment, het-erogeneous system and general C/S system where XML is used as its data source and materialized XPath view is used to improve the performance of refreshed query. 
The rest part of this paper is organized as follows. The motivation of our research is given in section 2. Related works are introduced in section 3. Section 4 gives the pre-liminaries of this research. Section 5 presents the incremental maintenance algorithm IMA. Performance evaluation of our approach is presented in section 6 and section 7 is the conclusion of our work. Our approach is inspired by the idea of incr emental computation of [7]. It proposes a systematic approach to derive incremental program for a program written in func-tional programming language. Based on this idea, we use different approach to implement incremental maintenance of materialized view. 
Suppose a query named query issues to an XML data source data is a computation written in XQuery language and its query result is r , that is: In equation (1), the subscript xq means this query program query is written in XQuery language. In order to improve the performance of refresh query, r is cached as a mate-than reissue the query to data source again. However, when  X  data takes place on data , it will result in a change  X  r in r , and the new query result is called r X  . Namely: An incremental maintenance algorithm IMA is used in this research to find what  X  r is maintenance program imp written in XQuery as its output. That is: imp can be executed on the cached materialized view r and guarantee: Motivating example . The example XML document file used in this paper is named a.xml and its XML tree is showed in Fig.1. Every node is given a name in form of A n . The upper-case letter A is the label of the node, and subscript n is used to distinguish different nodes with the same label. Now we suppose: (1) There is an XPath query query , its XPath expression e q is /D/B/S[1]/P/R[2] and its query result r is cached as a XPath expression e m is /D/B[3]/S[1] . S 5 is called modification node. declare function local:imp($r as item()*) as item()* { }; 
According to equation (3), incremental maintenance algorithm IMA accepts 3 pa-rameters as input: (1) data is the document node of file a.xml: doc( X  X .xml X ) ; (2)  X  data e = X  /D/B/S[1]/P/R[2]  X . In order to generate an incremental maintenance program imp , example, IMA finds that i is 3, k is 2 and r new is null. Therefore, IMA can generate an incremental maintenance program written in XQuery based on the information of  X  r . imp of the motivating example is shown in Fig. 2. In this program, there is a function XQuery function subsequence is used to reassemble r to obtain r X  . our approach: (1) imp is established when there is a modification happens, not when the query is refreshed; (2) IMA will check whether the modification is relative to the materialized view. If there is no relation between the materialized view and the modification, IMA needs not to generate any code to maintain materialized view. In small because the size of the query result is typically small compared with the original XML source size, and source updates are typically small compared with the original source size, too. Article [8] presents an approach for incremental order-preserving maintenance of XQuery views. It is based on a formal algebraic representation of the XQuery view query called XAT and provides a very powerful query processing capability. How-ever, it needs to store the intermediate resu lts as auxiliary data during query process-ing and there is not any restriction on the size of the auxiliary data. 
Another approach is proposed in article [9] to minimize the number and the size of the queries to data source. This approach also uses auxiliary data to maintain the cached materialized views and the size of the auxiliary data depends on the size of the XPath expression and the answer size regardless of the source data size. 
A scheme for incremental evaluation of XPath queries is proposed in [10]. It also deletion in data source lead to an insertion in query result or an insertion in data source lead to a deletion in query result. Article [11] proposes an incremental maintenance algorithm of materialized XPath/XSLT views defined by XPath expressions. This scheme needs to maintain an XML Transformation tree to realize the incremental maintenance. Article [12] studies the incremental evaluation of the result of an XPath query on an XML database under updates. It uses XPath query pattern and maintains an auxiliary data structure to implement incremental evaluation. However, it needs to maintain a complex intermediate data structure. 
Different from the approaches listed above, we propose an incremental maintenance generate an incremental maintenance program written in XQuery automatically. As the only auxiliary data, the incremental maintenance program is very small in size and can be executed by any XQuery engine. Our materialized XPath view model is based on Standard XML [1] and standard XPath [3]. In order to define materiali zed XPath view, some concepts are defined firstly, on which the materialized XPath view and data modification is defined. Definition 1: Axis Test , at, where at  X  { X / X  X  ,  X  /  X  is child test. Definition 2: Node Test , nt , where nt  X  {name-test, kind-test} , name-test  X  {QName,  X * X  X  , kind-test  X  { X  attribute X ,  X  X omment X ,  X  X ocument X ,  X  X lement X ,  X  X amespace X ,  X  X rocessing-instruction X ,  X  X ext X  } . QName is a valid identifier for XML elements and attributes. XPath language.  X  means pt can be null. axis test, node test and predicate test of step s . XPath step of e . standard XML, r is a sequence of XML nodes. of XML data source. n m is called modification node and it is specified by the XPath D e m , c is  X  because it is a deleting operation,. test  X / X  is considered and the situation that DTD of XML file is recursive is not consid-ered. Therefore, an XPath expression including descendant test  X // X  can be expressed by one or more Xpath expressions which only have child test  X / X  according to the schema of XML file, and reverse axis test can be transformed into forward axis test in test. It is feasible because a node in an XML document is described by its descendants nodes are modified, the algorithm will deal with these nodes one by one. Example 1. Consider the motivating example. e q = X /D/B/S[1]/P/R[2] X  , it is consists  X  /D/B[3]/S[1] X  is going to be deleted . the modification node; (2) All XPath expressions consist of independent steps. There-fore, all steps can be dealt with independently in our algorithm. 
According to equation (3) in section 2, IMA accepts 3 arguments as input: docu-the XPath query e q is used to represent the XPath query query . IMA tries to obtain 3 from the i th item will be updated by r new in r . Based on that, IMA generates an incre-mental maintenance program imp written in XQuery. In order to obtain i and k , IMA is invoked before the data modification is really took place when a data modification is issued. 5.1 Design Ideas of IMA There are 5 steps in IMA. The design ideas of these steps are introduced in this section. 1. Separate e q and e m e is used to conjunct two XPath expressions into one XPath expression. These 4 parts algorithm PSA (Path Separate Algorithm). This algorithm will be introduced in section 5.2. 
The separation strategy is based on the strategy of determining a very important ancestor node n a of the modification node n m . n a is a very important node because all obtain k and r new . Besides, from the left siblings of this node, i can be acquired. 
Suppose there are i steps in e m , try to find a step e q .s j in e q which have the same e , and e q .s j is the criteria step of e q . If it can not be found, try to find a step have the same name test of e m .s i-2 in e q again. This loop will be done until a criteria step of e q and a criteria step of e m can be found. After that, path separation can be done generate imp program code for this query. 
In the motivation example, e q is  X  /D/B/S[1]/P/R[2]  X  and e m is  X  /D/B[3]/S[1]  X . Ac-cording to PSA, there are 3 steps in e m , and the name test of the second step of e m is  X  X  X . PSA can find a step in e q that have the same name test, and all steps before that do not have any predicates. Therefore, the second step of e m is the criteria step of e m parts: e q1 is  X  /D/B  X , e q2 is  X  /S[1]/P/R[2]  X . 2. Locate n a n Function exeQuery is used to invoke the XQuery engine to do an XPath query on a specified node in an XML tree. node on document node n doc to obtain n a . It is B 3 . 3. Obtain k will be affected by the data modification and XQuery function count is used to know the number of these items. function count(exeQuery(B 3 , X /S[1]/P/R[2] X ) . k is 2. 4. Obtain r new Because IMA is invoked before the data modification is really took place on data modification is took place. This construction is implemented in the memory, not in the NUA will be introduced in section 5.2. eration is a delete operation on S 5 , n a  X  is node B 3 which does not have any children. Therefore, the query result of  X  B 3 /S[1]  X  on n a  X  is null. Namely, r new is null. 5. Obtain i document order. Therefore, the document order of the left siblings of n a is less than the rithm will be introduced in section 5.2. contributes 1 node to r , and the sum is 2. Therefore, i is 2. 5.2 Incremental Maintenance Algorithm The incremental maintenance algorithm IMA is introduced in this section. Other algo-rithms used in IMA are introduced after that. 
IMA is showed in Fig.3 and its design ideas have been listed in 5.1. In this algo-rithm, function exeQuery(n, e) is used to invoke XPath query engine with 2 argu-ments. The first argument is a node n , the second argument is an XPath expression e . It can return the items addressed by the XPath expression e in the subtree of the node n . XQuery function count(s) only has one argument s , it is a sequence. Its function is returning the number of items in the sequence s . Function genCode( i, k, r new ) is used to generate an incremental maintenance program imp written in XQuery language based on the information of i, k, r new . imp can be executed on the materialized view r to obtain r X  . 
PSA , NUA and LA are 3 important algorithms used in IMA. Function count and ex-eQuery are also used in these algorithms. PSA is showed in Fig.4, NUA is showed in Fig.5, and LA is showed in Fig.6. 
Algorithm 1. IMA (Incremental Maintenance Algorithm) 
Input: 
Output: 
Procedure: 
Algorithm 2. PSA (Path Separation Algorithm) 
Input: 
Output: 
Procedure:
Algorithm 3. NUA (Node Update Algorithm) 
Input: 
Output: 
Procedure: 
In PSA, function exist(e, st) returns an integer i to ensure the i th step of e have the same name test of step st , and all steps before step st (including st itself) do not have path of e which is consist of first t steps of e . Function extract is used on two XPath steps which are not appeared in e 2 . 
The first argument of NUA is a sequence. Its initial value is a sequence which has modification operation. Otherwise, the document order of the right sibling of this node is used as the criteria to judge whether n m is in the subtree of this node. Accord-ing to different condition, different strategies are used to construct node n a  X . 
Algorithm 4. LA (Locating Algorithm) 
Input: 
Output: 
Procedure: 
In this algorithm, operator  X  [n]  X  is used after a sequence q to return the n th item of q . XQuery function subsequence(q,n) can return a subsequence of q which is consist of items from the n th item of q to the last item. item in rr sequentially until it finds the item whose document order is bigger than that of n a . During the probing process, this algorithm counts how many items every node in rr contributes to the materialized view r . The sum of these numbers is i . 
IMA put its attention on the performance in the following cases: (1) IMA tries its IMA tries to know whether the data modification has no effects on materialized view r in PSA. If there is no relationship between them, there is no need to generate imp ; (3) IMA should access data source as few as possible because the data source is stored in the I/O device and the speed of I/O is slow. Function exeQuery is done in the memory when IMA wants to obtain k and r new because n a is already in the mem-left sibling of n a . In order to improve the performance, lazy query technique is used other instructions. 
The computational complexity of IMA is 0(n 2 )+2log(n) , where n is the number of steps in an XPath query. However, function exeQuery in IMA is used to invoke query engine to execute XPath query and the computational complexity of it is not included in the computational complexity of IMA. Because n is not always a big number in practice, the computational complexity of IMA is actually depend on the computa-tional complexity of exeQuery . The performance of our approach is evaluated in this section. Our experimental envi-Internet. Qizx/db free engine edition 3.0 [13] is used on client to execute incremental maintenance program imp to incrementally maintain the materialized XPath view. All queries are registered at the query agent implemented at server side. IMA is invoked to generate an incremental maintenance program for every query by this query agent when there is a data modification is going to be happened. After all imp s for all regis-tered queries are generated, the data modification is really took place on data source. The XML document files used in this experiment are 2 XML files on the server. One file named exp1.xml has information about 81,920 books and another file named 18,257k and 285k respectively. T recompute is the time of recomputing materialized view. During this time period, an XPath query is reissued to server, XQuery engine at server incrementally maintaining materialized view. During this time period, an XPath query the query agent when data modification takes place and imp is already generated when the query is refreshed, this experiment ignores the time IMA generate imp . 
The average value of T increm / T recompute of 30 different XPath query are evaluated ac-cording to the number of items in the materialized view r . The numbers of items in r practice. The experimental results are showed in Fig.7. 
The following conclusions can be drawn from Fig.7: (1) The performance of our less than 1; (2) Suppose |R| is the size of the materialized view and |D| is the size of data source, the smaller |R|/|D| is, the higher the performance of this approach is; (3) Our approach can be used in mobile computing environment, heterogeneous system and general C/S system where XML is used as data source and materialized view is used to improve the performance of refreshed query. This paper presents an incremental maintenance algorithm of materialized XPath views based on the idea of incremental computation. The incremental maintenance program written in XQuery is established automatically and can be executed on mate-rialized view by any XQuery engine. Experiments show that the performance of in-cremental maintenance of materialized XPath view is better than that of view recom-putaion. Our approach can be used in mobile computing environment, heterogeneous system and general C/S system where XML is used as data source and materialized view is used to improve the performance of refreshed query. 
For the future work, we intent to apply the idea of incremental computation on the incremental maintenance of materialized XQuery views. It will be more complex than the work we did in this paper because an XQuery program is more complex than an XPath query. We will introduce the future work in other papers. 
