 Recently, there is an increasing interest in supervised concept learning problems, where instances are labeled undirected graphs . This problem is motivated by various practi-cal problems e.g. in computational chemistry. Besides rule-based learning algorithms, kernel methods (see, e.g., [17]), in particular, support vector machines [20], have be-come a popular approach for this task. The crucial step of graph kernel approaches is to design some effectively computable positive definite function k : G X G X  IR , called kernel , where G is the set of labeled graphs representing the instances of the underlying learning problem. Many recent graph kernels rely on embedding G into a feature space defined by the set of frequent subgraphs occurring in G (see, e.g., [5]).
 an optimal trade-off between predictive power and runtime, as both these conflicting requirements depend on the choice of the frequency threshold. Therefore, as an alterna-tive to graph kernels based on frequent subgraphs, a new graph kernel, called the cyclic pattern kernel (CPK), has been proposed recently in [10]. CPK is based on embed-ding the graphs into a Boolean feature space made up of cyclic patterns independent of their frequencies, where cyclic patterns are strings formed by the labels of simple cycles . On the NCI-HIV 1 biochemical domain, CPK turned out to outperform frequent subgraph-based approaches in accuracy measured by the area under the ROC curve [4]. nor by any other algorithm). For a restricted graph class, we propose an algorithm based on explicitly embedding the graphs into the feature space. Although the features are only the patterns of simple cycles, they are computed by enumerating all simple cycles of the graphs. The reason is that, in contrast to simple cycles [15], cyclic patterns cannot be enumerated in output-polynomial time [10], i.e. in time polynomial in the combined size of the input and output. Since graphs may have exponentially many simple cycles, the method in [10] is restricted to graphs with a polynomial number of simple cycles. This limitation is rather severe because even graphs with small number of cyclic pat-terns may contain exponentially many simple cycles. Furthermore, to decide whether a graph meets the above requirement, one has to count its simple cycles which is #P-complete [19].
 that cyclic patterns for graphs of bounded treewidth can be enumerated with polynomial delay. Hence, CPK can be computed in time polynomial in the number of cyclic patterns for this class of graphs. Treewidth [16] is a measure of tree-likeness of graphs. The class of bounded treewidth graphs includes many practically relevant graph classes (see, e.g., [3] for an overview). To show our result, we use the positive result [1] on the regular-language-constrained simple path problem for bounded treewidth graphs.
 is relevant if it belongs to a minimum basis of the graph X  X  cycle space . Although in worst case, the number of relevant cycles of a graph can be exponential in the number n of its vertices, relevant cycles have important advantages over simple cycles; (i) They can be counted in time polynomial in n and are enumerable with polynomial delay [21], and (ii) their number is typically only cubic in n [9]. We present empirical results which indicate that there is no significant difference in predictive performance between CPK defined by simple cycles and that defined by relevant cycles. Hence, utilizing the above nice properties of relevant cycles, a more robust CPK can be obtained.
 the definition of CPK. In Section 3, we show that for graphs of bounded treewidth, CPK can be computed in time polynomial in the number of cyclic patterns. In Section 4, we define CPK based on relevant cycles and evaluate it empirically. Finally, in Section 5, we conclude and list some problems for future work. Due to space limitations, proofs are only sketched or even omitted in this version. In this section we recall some necessary notions. For further details, the reader is re-ferred to [6, 10, 17].
 Graphs. For a set S , [ S ] k denotes the family of k -subsets of S , i.e., [ S ] k = { S  X  S : | S | = k } .A labeled undirected graph is a quadruple G =( V, E,  X ,  X  ) , where V is a finite set of vertices , E  X  [ V ] 2 is a set of edges ,  X  is a finite set of labels , and  X  : V  X  E  X   X  is a function assigning a label to each element of V  X  E . | V | and | E | are denoted by n and m , respectively. Two vertices of G are adjacent if they are connected by an edge. The degree of a vertex v  X  V is the number of vertices adjacent to v . Unless otherwise stated, in this paper by graphs we always mean labeled undirected graphs. A graph database G is a set of disjoint graphs, and |G| denotes the number of graphs in G . of
G ,if V  X  V , E  X  E , and  X  ( x )=  X  ( x ) for every x  X  V  X  E . A sequence are all distinct. G is connected if there is a (simple) path between any pair of its vertices. A connected component of G is a maximal subgraph of G that is connected. A vertex v  X  V is an articulation (also called cut ) vertex, if its removal increases the number of connected components of G . G is biconnected if it contains no articulation vertex. A biconnected component (or block )of G is a maximal subgraph that is biconnected. degree. If, furthermore, C is connected and each of its vertices has degree 2 then C is a simple cycle of G . We denote by S ( G ) the set of simple cycles of G . Two simple cycles C and C of G are considered to be the same iff C or its reverse is a cyclic permutation of C . We note that the number of simple cycles can grow faster than 2 n .
 and form thus a partition on the set of G  X  X  edges. This partition, in turn, corresponds to the following equivalence relation on the set of edges: two edges are equivalent iff they belong to a common simple cycle. This property of biconnected components implies that an edge of a graph belongs to a simple cycle iff its biconnected component con-tains more than one edge. Edges not belonging to simple cycles are called bridges .The subgraph of a graph G formed by its bridges is denoted by B ( G ) . Clearly, each bridge of a graph is a singleton biconnected component, and B ( G ) is a forest.
 there is a bijection  X  : V 1  X  V 2 such that (i) for every u, v  X  V 1 , { u, v } X  E 1 iff  X  ( {  X  ( u ) , X  ( v ) } ) for every { u, v } X  E 1 .
 Kernel Methods. Kernel methods (see, e.g., [17]) are a theoretically well-founded class of statistical learning algorithms that have received considerable attention recently also in the data mining community. Algorithms in this broad class (e.g., support vector machines, Gaussian processes, etc.) have proved to be powerful tools in various real-world data mining applications. Since kernel methods are not restricted to the attribute-value representation used by most data mining algorithms, many of these applications involve datasets given in some non-vectorial representation formalism such as graphs (see, e.g., [8, 17]). In general, kernel methods are composed of two components: (i) A domain specific function  X  embedding the underlying instance space X into (ii) a domain independent algorithm aimed at discovering patterns (e.g., classification, One of the attractive computational properties of kernel methods is that in many cases, patterns can be computed in time independent of the dimension of F . In such cases, the inner product of the feature vectors can be calculated by a kernel without explicitly performing or even knowing the embedding function, where a kernel is a function of the form  X  : X  X  X  X  IR satisfying  X  ( x, y )=  X  ( x ) , X  ( y ) for every x, y  X  X . what follows. Let U be a set and  X   X  :2 U  X  2 U  X  IN be the function defined by for every S 1 ,S 2  X  U . The proof of the following proposition follows directly from the definitions.
 Proposition 1.  X   X  is a kernel.
 The function defined in (1) is called the intersection kernel 2 .
 The Cyclic Pattern Kernel. Finally, we recall the definition of the cyclic pattern kernel (CPK) introduced in [10]. Let  X ,  X  be alphabets, and  X  be a mapping from the set of simple cycles and trees labeled by  X  to  X   X  such that (i)  X  maps two graphs to the same string iff they are isomorphic and (ii)  X  can be computed in polynomial time. We note that such  X  and  X  always exist and can easily be constructed (see, e.g., [10, 22]). Using  X  ,thesetof cyclic and tree patterns of G is defined by respectively. The cyclic pattern kernel for a graph database G is then defined by for every G 1 ,G 2  X  X  . Since P S ( G ) and P T ( G ) are disjoint for every G ,  X  S is a kernel by Proposition 1.
 fact, one can show that computing  X  S is at least as hard as counting simple cycles of length k in a graph. This problem is #W[1]-complete [7], and is therefore unlikely to be fixed-parameter tractable.
 ing the embedding into the feature space for every graph, and then by (ii) calculating the inner product of the obtained feature vectors. To perform the embedding for a graph G , P S ( G ) is computed by enumerating all elements of S ( G ) . The reason is that while S ( G ) can be enumerated with linear delay [15], P S ( G ) cannot be enumerated in output-polynomial time (unless P = NP) [10]. Thus, the algorithm computing CPK in [10] is the method in [10] is restricted to graphs with polynomial number of simple cycles. To decide whether the graphs in the database satisfy this condition, one has to count their simple cycles which is #P-complete in general [19]. Restricting CPK to graphs of polynomial number of simple cycles is rather severe; graphs containing exponentially many simple cycles may have polynomially or even constant many cyclic patterns. Below we give an example of such graphs.
 Example 1. Let G =( V, E, { a } , X  ) with V = { u 1 ,...,u n ,v 1 ,...,v n ,w 1 ,...,w n } and G contains 2 n + n simple cycles, which in turn form only two different cyclic patterns. problem of listing cyclic patterns of a graph without enumerating the possibly exponen-tially large set of all its simple cycles. More precisely, we consider the problem whether cyclic patterns can be enumerated with polynomial delay. The following proposition states that, in contrast to simple cycles, this problem is most likely intractable. Proposition 2 ([10]). Unless P = NP, cyclic patterns cannot be enumerated in output-polynomial time.
 The proof of the above proposition is based on a polynomial-time reduction from the NP-complete Hamiltonian cycle problem. This and many other NP-hard compu-tational problems become, however, polynomially solvable when restricted to graphs of bounded treewidth (see, e.g., [2] for an overview). Treewidth [16] is a measure of tree-likeness of graphs. More precisely, a tree decomposition of a graph G =( V, E,  X ,  X  ) is a tree T =( V ,E , 2 V , X  ) such that (i) v  X  V  X  ( v )= V , (ii) for every e  X  E there is a vertex v  X  V satisfying e  X   X  ( v ) , and (iii) for every u, v, w  X  V it holds that  X  ( u )  X   X  ( v )  X   X  ( w ) whenever w is a vertex on the simple path between u and v .The width of T is max v  X  V |  X  ( v ) | X  1 , and the treewidth of G is the width of a tree de-composition of G with the smallest width. Clearly, the treewidth of a tree is 1 , and the treewidth of a simple cycle of length at least 3 is 2 .
 algorithmic applications because many problems that are hard on arbitrary graphs be-come easy for graphs of bounded treewidth. The class of bounded treewidth graphs includes many practically relevant graph classes (see, e.g., [3] for an overview). cycles. For instance, one can easily see that the treewidth of the graph in Example 1 is 2 for every n&gt; 1 .
 problem for graphs of bounded treewidth, in this section we show that CPK for graphs of bounded treewidth can be computed in time polynomial in the number of cyclic pat-terns. To prove this result, by (2) and (4) it is sufficient to show that cyclic patterns can be enumerated with polynomial delay for graphs of bounded treewidth. We start with the definition of the regular-language-constrained simple path problem ([1, 13]). to  X  , (ii) a source and a target vertex s, t  X  V , respectively, and (iii) a regular language 3 L ,or print  X  X O X  if such a path does not exist. While this problem is NP-complete in general, for graphs of bounded treewidth the following positive result holds. Theorem 1 ([1]). The regular-language-constrained simple path problem can be solved in polynomial time for graphs of bounded treewidth.
 Theorem 2. Let G i =( V i ,E i , X , X  i ) be bounded treewidth graphs for i =1 , 2 . Then  X  ( G 1 ,G 2 ) can be computed in time polynomial in Proof sketch. By (4), it is sufficient to show that cyclic patterns can be enumerated with polynomial delay because P T ( G i ) ( i =1 , 2 ) is bounded by | V i | and can be computed efficiently [18].
 with treewidth tw can be transformed into an edge labeled graph G with treewidth tw such that there is a bijection between the sets of cyclic patterns of G and G . 4 Thus, we may assume wlog that G 1 and G 2 are edge labeled graphs of bounded treewidth. given in Algorithm 1. In each iteration of the loop (step 2), we compute a deterministic finite automaton (DFA) M k =( S k , X , X  k ,s,F k ) that accepts the patterns computed so far in P , as well as each cyclic permutation of q and q  X  1 for every q  X  P , where q  X  1 the transition function, the initial state, and the set of final states of M k , respectively. Both the size of M k and the time required to construct M k is bounded by O ( nk ) .In step 4 we select an arbitrary edge e = { u, v } of G , and then, in step 5, construct a nondeterministic finite automaton (NFA) M k recognizing the language L k = { w  X  in polynomial time whether or not there is a simple path between u and v such that the string defined by this path belongs to L k . If such a simple path does not exist, we remove e from G , as in this case there is no simple cycle containing e that defines a new cyclic pattern. Otherwise, we add the new cyclic pattern to P (step 9), and repeat the loop. If N cyclic patterns have been found or G contains at most two edges, we stop the algorithm and return P containing min { N, | P S ( G ) |} cyclic patterns. Consider again the graph G in Example 1, but now with  X  = { a, 0 , 1 } and with  X  labeling the u i  X  X  by 0 ,the w i  X  X  by 1 , and each other vertex and edge by a . One can see that G has exponentially many cyclic patterns. In this section we empirically investigate whether another, possibly smaller set of cyclic structures can also be applied without significant loss of predictive performance. In particular, we consider cyclic patterns based on the relevant cycles [14] of a graph.
 from algebraic graph theory. Let G =( V, E,  X ,  X  ) be a graph and consider the set of cycles of G . Since cycles are subgraphs of G (such that every vertex has even degree), each cycle C =( V ,E , X , X  ) of G can be represented by the incidence vector C of its edges. That is, the components of C are indexed by E , and for every e  X  E , C e =1 if e  X  E and it is 0 otherwise. It holds that the set of vectors corresponding to the cycles of
G forms a vector space, called the cycle (vector) space , over the field GF (2) . 5 Thus, vector addition in the cycle space corresponds to the symmetric difference of the sets of edges of the cycles represented by the vectors. The dimension of the cycle space of G is its cyclomatic number  X  ( G )= m  X  n + c ( G ) , where c ( G ) denotes the number of connected components of G . To represent the cycle space of G , one can consider one of its bases, which has minimum length. The length of a basis is the sum of the number of edges of the cycles represented by the vectors belonging to the basis. Since the minimum basis of a graph X  X  cycle space is not unique, the cyclic structure of a graph is described by the union of all minimum bases of its cycle space [14]. This canonical set of cycles is called the set of relevant cycles . In [21], it is shown that relevant cycles can be enumerated with polynomial delay and counted in time polynomial in the order of
G . Although the set of relevant cycles of a graph can be exponential in the number of its vertices in worst case, its cardinality is typically only cubic in n [9]. periments we used monotone increasing subsets of simple cycles that can be generated by relevant cycles. More precisely, for a graph G and integer k  X  1 ,let R k ( G ) denote the set Since R 1 ( G )  X  X  ( G ) , it holds that R 1 ( G )  X  X  2 ( G )  X  ...  X  X   X  ( G ) ( G )= S ( G ) . We note that the set of relevant cycles of a graph is the union of the relevant cycles of its biconnected components. Since biconnected components of a graph are enumerable with linear delay [18], and relevant cycles of a biconnected graph are enumerable with polynomial delay [21], R k ( G ) can be computed in time polynomial in |R k ( G ) | for any arbitrary graph G and k&gt; 0 .
 is then defined by for every G 1 ,G 2  X  X  , where P R k ( G )= {  X  ( C ): C  X  X  k ( G ) } and P T ( G ) is defined by (3) for every G  X  X  . The remarks above along with Proposition 1 imply that  X  R k is a where n 1 and n 2 denote the number of vertices of G 1 and G 2 , respectively. 4.1 Empirical Evaluation To evaluate the predictive performance of CPK based on relevant cycles, we used the same NCI X  X IV dataset and evaluation method as in [10]. We briefly describe both the dataset and the method, and refer the reader to [10] for further details.
 its activity against HIV, which is one of the categories confirmed inactive (CI), moder-ately active (CM), and active (CA). The NCI-HIV dataset contains 42689 molecules, 423 of which are active, 1081 are moderately active, and 41185 are inactive. The total number of vertices and edges in this dataset is 1951154 and 2036712, respectively. Ta-ble 1 shows the total number of cycles of different types in this graph database, as well as the total number of patterns defined by them.
 compared  X  R 1 ,  X  R 2 ,  X  R 3 , and  X  S with each other on the following classification prob-lems: distinguish CA from CM (CA/CM), CA and CM from CI (CACM/CI), CA from CM and CI (CA/CMCI), and CA from CI (CA/CI). We used a modified version of the SVM-light [11] support vector machine with the same misclassification cost parameters as used in [5, 10]. For each problem and for each misclassification cost, we performed a 5-fold cross-validation and measured the predictive performance using the mean of the areas under the ROC curve (AUC) [4]. We used 5% and 10% significance levels in the comparisons (see [10] for the details). The results are given in Table 2. They indi-cate that  X  R 2 can be used in most of the cases without a significant loss of predictive performance wrt.  X  S , and that  X  R 3 was never outperformed significantly by  X  S . Hence, the alternative definition of CPK allows one to apply it to graph databases containing graphs even with exponentially many simple cycles. In this paper, we have presented two approaches relaxing the complexity limitation of computing CPK based on the set of simple cycles. We have shown that for graphs of bounded treewidth, CPK can be computed in time polynomial in the number of cyclic patterns. We then proposed an alternative CPK based on the smaller set of relevant cycles and compared its predictive performance with that based on simple cycles. Em-pirical results on the NCI-HIV dataset indicate that there is no significant difference between the two CPK X  X . Since the number of relevant cycles of a graph is typically only cubic in its order, the CPK proposed in this work can be applied even to graphs with ex-ponentially many simple cycles. In addition, relevant cycles can be counted efficiently in contrast to simple cycles. This allows one to decide in polynomial time whether the graphs in a database contain polynomial number of relevant cycles. Hence, utilizing the above nice properties of relevant cycles, we have presented a more robust CPK. databases. Furthermore, since R k ( G ) is usually significantly larger than P R k ( G ) (see, e.g., Table 1), we are going to investigate, whether  X  R k ( G 1 ,G 2 ) can be computed in time polynomial in | P R k ( G 1 ) | and | P R k ( G 2 ) | for every G 1 and G 2 . The author thanks Thomas G  X  artner and Stefan Wrobel for interesting discussions of this work. This work was supported in part by the DFG project (WR 40/2-1) Hybride Methoden und Systemarchitekturen f  X  ur heterogene Informationsr  X  aume .

