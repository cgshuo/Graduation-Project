 1. Introduction
Designing ef fi cient autonomous mobile robot controllers is a dif fi cult and time consuming process which requires wasting resources and efforts. Commonly, the robot navigation is based on continuous interaction between the robot and the environ-ment. However, in real world situations the environment is constantly changing, which makes desirable to develop robots that are capable to evolve to new behaviors, adapting the control strategies to the new situations. Providing the required degree of fl exibility and maintaining robustness is one of the relevant challenges when designing models for robot controllers because of the mathematical complexity involved in the necessity of taking into account any possible emerging change in the environment.
Commonly, the adaptation process requires the re fi nement of the solution using optimization stages for adjusting the coef cients of the mobile robot controller. However, this is a challenging task since solving optimization problems using small robot plat-forms with computational limitations is a time-consuming task.
Generally, in optimization problems developed over embedded platforms, the dimensionality (number of decision variables) is smaller than in conventional ones because of several restrictions in performance and power consumption related to embedded systems. However, even running over these conditions, embedded optimization algorithms require to fi nd a near-optimal solution in a short elapsed time (order of milliseconds) ( Boyd, 2009 ), above all in real time requirement cases.

Among other approaches, Arti fi cial Intelligence (AI) techniques have been studied for designing autonomous robot controllers with adaptation characteristics ( Pugh and Martinoli, 2009 ;
Chatterjee et al., 2005 ; Knudson and Tumer, 2011 ). In order to achieve online adaptation characteristics, the proposed solutions must take into account the following aspects: (a) the involved algorithms require to solve non-linear and multimodal optimiza-tion problems; (b) the optimization must be carried out in time scales of milliseconds or few seconds; (c) mobile robot platforms usually make use of embedded solutions with computational limitations; (d) embedded systems are usually designed for operating under several constraints such as portability, hardware resources consumption, performance and low energy consu-mption.

The above-mentioned restrictions suggest the necessity of proposing ef fi cient hardware solutions for embedded optimization problems which achieve real-time requirements. In this context,
Field Programmable Gate Arrays (FPGAs) are a feasible and cheap technology for exploiting the intrinsic parallelism of optimization algorithms allowing the solutions to be achieved with a short elapsed time. In addition, FPGAs provide several hardware resources such as DSP (digital signal processing) blocks, clock management units, RAM blocks, embedded software processors, among others facilities, which can be used for achieving hardware solutions with a low operational frequency ( Sass and Schmidt, 2010 ). All these characteristics make FPGAs suitable for embedded applications, such as those of mobile robotics, in which the adaptation processes or optimization stages should be executed in a short elapsed time and with low power consumption.
Recently, evolutionary computing techniques have been applied to nonlinear embedded optimization problems, in which the gradient-based and the exhaustive search methods are impractical because of the assumptions about the existence of the fi rst derivative and because of the large execution time of the involved algorithms ( Rao, 1996 ). The Particle Swarm Optimization (PSO) is a swarm intelligence algorithm bio-inspired on the social behavior of models of schooling fi sh and fl ocking birds. The PSO is a stochastic population-based optimization technique which provides several desired attributes, such as simplicity, easy implementation, less computational requirements and parallel capabilities ( Eberhart and
Kennedy, 1995 ; Kennedy and Eberhart, 1995 ; Poli et al., 2007 ; Banks et al., 2007 ). Therefore, FPGAs can be properly used for exploring the inherent parallelism of the PSO algorithm not only by imple-menting parallel particles, but also by performing as much as possible simultaneous computations, allowing for a performance improvement in terms of execution time.

An additional characteristic of the PSO algorithm is its rapid convergence towards optimal points that implies that after a few number of iterations the particles are clustered in sub-optimal solutions ( Riget and Vesterstrom, 2002 ; Pant et al., 2007 ). This drawback, namely premature convergence ( PC ), becomes evident when solving problems with many local optimal points. The loss of diversity among the particles is the main reason for the PC problem. Many efforts have been made to solve the PC problem, most of them making use of arti fi cial diversity for guiding the swarm ( Pant et al., 2007 ). However, for embedded applications, especially, when hardware solutions are needed, it is important to emphasize the importance of using simple operations for introdu-cing diversity, saving resources and power consumption.
This paper proposes a novel hardware architecture for explor-ing the parallel capabilities of the PSO algorithm applied to the online training process of an Arti fi cial Neural Network (ANN) robot controller. The proposed hardware architecture is based on the parallel version of the opposition-based PSO algorithm (for short
OPSO), abbreviated here as HPOPSO. Slight modi fi cations were addressed in the original OPSO ( Wang et al., 2007 ) in order to simplify its hardware implementation. The architecture was mapped onto a Virtex5 FPGA and operates using a specialized fl oating-point arithmetic, allowing the operations to be computed with high precision and large dynamic range.

A special feature of the architecture is the application of the opposition-based learning (OBL) technique ( Tizhoosh, 2005 ), which is implicit in the OPSO algorithm. The OBL technique is based on logical operations, and is used to preserve the swarm diversity and to improve the global search capabilities of the PSO algorithm. The main objective of this work was to develop a suitable FPGA embedded implementation for the OPSO that was focused on the ef fi cient exploration of the intrinsic parallelism of the OPSO algorithm over FPGAs. Achieving this objective is of great interest due to the growth and diversity of applications of embedded system in several areas such as medicine, automation, control, robotics, among others.

The HPOPSO architecture developed in this work is used to solve the learning-from-demonstration (LfD) problem ( Billard et al., 2008 ), in which the training dataset is composed of example executions of two obstacle avoidance behaviors (performed by a demonstration teacher), and stored using on-chip RAM memory blocks. The HPOPSO architecture is used to solve the optimization problem of the training process of an ANN robot controller, in which the goal is to minimize the approximation error of the desired behaviors. In addition, the proposed HPOPSO architecture has been used to preserve the desired behavior when one or more failures on the distance sensors occur.

Synthesis results point out that the proposed HPOPSO archi-tecture is feasible to be mapped on commercial FPGAs, requiring around 63% of the available hardware resources of the selected device and achieving an operational frequency of 130 MHz. The architecture speedups by 3.6 times a desktop Intel Core Duo processor at 1.6 GHz and achieves a speedup factor of three orders of magnitude in comparison with an embedded MicroBlaze soft-ware processor implementation. Simulation results demonstrate that by accomplishing the HPOPSO architecture it is possible to train the ANN robot controller. This fact allows the robot to learn new behaviors according to practical applications. In addition, the proposed solution provides a fault-tolerant mechanism, allowing the robot to automatically adapt its controller when a sensor malfunction occurs. In this case, the suitability of the opposition-based approach was demonstrated by a performance comparison with the standard PSO algorithm.

The main contributions of this work are synthesized as follows: (a) The hardware implementation of the opposition-based tech-nique applied to the PSO algorithm which provides improved solutions and achieves expressive speed up factors (due to the exploration of the intrinsic parallelism) in comparison with common software implementations; (b) The use of the FPGA specialized fl oating-point arithmetic which allows the operations to be computed with high precision and large dynamic range; and (c) A case study demonstrating the facilities of the proposed architecture for solving the online training process of an ANN robot controller.

The remainder of this paper is organized as follows: Section 2 presents the related works. Section 3 outlines the standard PSO algorithm and the opposition-based approach. Section 4 describes the implementation of the proposed HPOPSO algorithm and points out several assumptions and decisions that were adopted for simplifying the hardware implementation. Section 5 describes the neural model of the mobile robot controller as well as the LfD and fault-tolerant problems used for validating the proposed architecture. Section 6 details the hardware implementations. Section 7 presents the synthesis and simulation results as well as execution time comparisons and, before concluding, Section 8 discusses the implications of the reported results. 2. Related works
Most of the previous works regarding parallel PSO approaches in software make use of a networked array of master/slave Central
Processing Units (CPUs) and are tailored for large-scale optimiza-tion problems ( Schutte et al., 2004 ; Jin and Rahmat-Samii, 2005 ; Poli et al., 2007 ; Koh et al., 2006 ).
 On the other hand, different approaches have been proposed for FPGA implementations of the PSO algorithm. For instance, a discrete PSO has been developed using a hardware software co-design in
Farmahini-Farahani et al. (2010) .Inthisapproachthe fi tness func-tions were implemented on Altera NIOS II microprocessors and the update process of the particles was performed in hardware. Although thesoftwareimplementationofthe fi tness functions simpli fi implementation, the performanc e decreases due to the sequential way of evaluating the cost functions ( v on Neumann bottleneck). In general, the process that consumes most of the time during the treatment of the optimization problem is the evaluation of the functions. Therefore, a pure hardware implementation is a suitable solution for real-time embedded applications.
 A population-oriented hardware architecture for PSO with Discrete
Recombination was presented in Pena and Upegui (2007) .Inthis approach the architecture was validated using 32 dimensional bench-mark functions. Mehmood et al. (2008) describe an FPGA parallel version of the PSO algorithm called Hardware Oriented PSO (HPSO), which presents a modular approach separating the swarm block from the fi tness function block. The HPSO is applied to an object detection problem showing that the algorithm can be easily recon fi different detection tasks, either by setting up the parameters of the fi tness functions or by de fi ning new fi tness functions. An FPGA implementation of the PSO algorithm and its application to coef
Gupta and Mehra (2011) . In these hardware implementations PSO-based adaptive fi lters with adjustable parameters are effectively used for identifying unknown IIR sy stems and demonstrate a speed enhancement of the execution time.

Most of the above-mentioned previous works, implemented in hardware, are based on a fi xed-point arithmetic representation. There are a few publications reporting FPGA implementations of the PSO algorithm using fl oating-point arithmetic. For instance,
Tewolde et al. (2009 , 2012) presented a single precision point serial PSO with interfaces to swarm memories and fi evaluation modules, showing speed-up factors of 359 and 653, respectively, for the Sphere and Rosenbrock benchmarks, in compar-ison with a 16-bit microcontroller. Mu X oz et al. (2009 , 2010a) presented two hardware architectures of the PSO (respectively, full-parallel and partially parallel). In this approach, the authors introduced the application of parameterizable fl oating-point arith-metic and trigonometric libraries which allow the user to select the adequate bit width representation according to the application. There are few works reporting FPGA implementations of the
PSO algorithm for training neural networks and most of them propose the use of a fi xed-point arithmetic representation. In this case, Reynolds et al. (2005) implemented a PSO algorithm in
FPGAs for inversion of large neural networks and showed that the PSO computing time is approximately six times faster than in conventional computers. An FPGA architecture of a wavelet neural network with PSO has been applied to a prediction problem showing that the performance of the PSO algorithm improves by working with a suitable number of particles ( Lin and Tsai, 2007 ).
Duren et al. (2007) have presented a real-time inversion of a multilayer perceptron neural network using the PSO algorithm and applied the circuit architecture for estimating the perfor-mance of a sonar system. The proposed circuits were mapped on the SRC-6e computer which makes use of multiple FPGAs.
Ef fi cient FPGA based solutions for implementing population based optimization algorithms must be able to provide high performance computations and to preserve the swarm diversity, producing good quality solutions and avoiding the premature convergence problem.
Several works were developed focusing on providing these characteristics, in particular, Chowdhury et al. (2009) proposed an
FPGA based solution of an adaptive perceptive PSO (APPSO) for optimizing a fuzzy inference engine applied to medical diagnosis. This
APPSO approach allows particles to vary their perception of radius and/or number of sampling directions. Also, focusing on the obtention of these characteristics, hardwar e parallel implementations of the attractive-repulsive PSO (HParPSO) and the passive congregation PSO (HPPSOpc) (introduced in Mu X oz et al., 2010b , 2011 ,respectively) were developed for preserving the swarm diversity. For both these approaches, convergence results using two benchmark test functions have demonstrated their suitability for embedded applications in terms of execution time. Cavuslu et al. (2012) have implemented on
FPGAs a neural network with improved PSO learning for identi of dynamic systems. The implementations are based on a fl point arithmetic and the improved PSO is obtained by modifying the velocity update function adding an extra random term for reducing the possibility of stuckness in a local minimum.

Since the computational resources in FPGAs are limited, a friendly hardware architecture of the PSO must consider easily implementable operators. In this work is proposed a novel hard-ware parallel PSO architecture, which makes use of the opposition based learning (OBL) approach and apply it for training a neural network mobile robot controller. The OBL approach, explained in the next section, is an easily hardware implementable technique (based on a NOT operator) which allows particles to improve the quality of the solutions and to preserve the swarm diversity.
Additionally, the proposed approach makes use of a fl oating-point arithmetic representation allowing the computations to be performed with a large dynamic range and high precision. 3. Background
This section presents the necessary concepts and nomencla-ture. Initially, a brief description of FPGA devices is presented, focusing on the advantages of using fi eld programmable devices for implementing hardware parallel computations. Finally, the basic PSO operation and the opposition-based learning algorithms are described. 3.1. FPGA concepts
FPGAs are fi eld-programmable logic devices which contain a matrix of Con fi gurable Logic Blocks (CLBs) interconnected by an array of routing resources implemented in CMOS technology. Fig. 1 details the FPGA block structure. CLB features depend on both producers and family devices; however, they are typically small tables with 4, 5 or 6-bit inputs, namely Lookup Tables (LUTs), D fl ip-fl ops and several multiplexers, allowing the truth value table of basic Boolean functions to be implemented in hardware. In order to implement complex circuits, CLBs are connected by a programmable network of connection and switching blocks. The connection block (see Fig. 1 c) allows logic block inputs and outputs to be assigned to horizontal or vertical tracks. The switching block (see Fig. 1 b) allows a signal on a track to connect to another track.
The connections in the switching and connection blocks are made by programmable points. Commonly, a programmable point consists of a pass transistor controlled by a static random access memory cell (SR) to hold the user de fi ned con fi guration values.
Fig. 1 b depicts a planar switching box topology in which a wire in track number 0 (point A) connects only to wires in track number 0 (points B, C or D) in adjacent channel segments. Modern FPGA devices contain embedded DSP blocks, RAM blocks, dedicated processors and digital clock managers allowing the implementa-tion of more complex designs ( Hauck and Dehon, 2008 ).
One important issue in circuit design with FPGA platforms is that the above-mentioned logic resources can be accessed in a parallel approach, which provides to the designer the necessary fl exibility to improve performance of the algorithms (while programming FPGAs to the desired application or functionality requirements) by exploring different options of parallel architec-tures ( Kilts, 2007 ; Hauck and Dehon, 2008 ). Therefore, FPGAs are fl exible enough to implement adequately speci fi c solutions when compared with application speci fi c integrated circuits (ASICs), where the devices are designed in a customized manner for the speci fi c applications. 3.2. The standard PSO algorithm
In the PSO algorithm, the population is called swarm and individuals are called particles (mass-less and volume-less). Each particle i has a current velocity vector v i , a personal best position vector y i in the search space and a position vector x i , that represents a possible solution of the optimization problem. Con-sidering an N -dimensional evaluation function and a swarm size of
S particles, the position of the i th particle in the j th dimension is updated by executing the following equations: x v ij  X  wv where r 1 and r 2 are the uniformly generated random numbers in the range [0,1], y ij is the personal best position found by the particle i around the j th dimension and y sj is the global best position among all the particles around the j th dimension. The velocities v ij are clamped to the range  X  v max ; v max avoiding the particles leave the search space.

There are three parameters: the inertia ( w ), the cognitive ( c and the social ( c 2 ) coef fi cients. Large values for the cognitive coef fi cient ( c 1 ) indicate particles with a high self-con their experience and large values for social coef fi cient ( c a particle with a high con fi dence in the swarm ( van den Bergh, 2002 ). At each iteration ( t ) a new velocity v i and a new position x for each particle in the swarm are computed. If the fi tness value of the current position x i improves the fi tness value of the personal best position y i , then the personal best position is replaced with the current position of the particle. If the fi tness value of the current position x i is lower than the fi tness evaluated at the global best position y s , then the global best position is replaced with the current position x i of the particle. The inertia weight coef can be con fi gured to decrease linearly from 1 to 0 until the stopping criteria are met. 3.3. The opposition-based learning approach
The opposition-based learning (OBL) approach, fi rst introduced by Tizhoosh (2005) , is a simple technique which allows the population-based algorithms to search for an optimal point in the opposite direction of the current search. The basic idea is that whenever a solution is being explored in a direction, it is bene to consider the opposite direction as well ( Al-Qunaieer and Tizhoosh, 2010 ). The OBL approach is based on the de fi nition of opposite number , given by the below equation: x  X  a  X  b x  X  3  X  where x is a real number de fi ned in the range  X  a ; b and x is the point x j de fi ned in the range  X  a j ; b j ; j  X  1 ; ... ;
The OBL technique was initially applied to genetic algorithms in which anti-chromosomes allow the search process to be accelerated ( Tizhoosh, 2005 ). The OBL was also applied to neural computing in which the concepts of opposite-weight and opposite-network can be used to improve the results ( Tizhoosh, 2005 ). Rahnamayan et al. (2008) demonstrated formally that, in the case of an unknown function in an N -dimensional space, x j has a higher chance to be closer to the solution than x j .Additionally,anempiricalveri these mathematical proofs was performed, demonstrating the feasi-bility of the OBL approach ( Rahnamayan et al., 2008 ). 3.4. The opposition-based learning applied to the PSO
Recently the OBL approach has been applied to enhance the solutions of the PSO algorithms. Wang et al. (2007) proposed an opposition-based PSO with Cauchy mutation operation. The OBL approach is applied at random iterations ( generation jumping )to the entire population and the Cauchy operator is applied to the global best particle in order to avoid local optimal solutions. The proposed modi fi cation achieves a better global search ability for multimodal functions, maintaining and has a faster convergence for unimodal functions if compared with the standard PSO.
Jabeen et al. (2009) proposed a PSO algorithm with opposition based initialization. Then, the initial population is provided as input to the standard PSO. The modi fi ed PSO was applied to four benchmark functions, outperforming the solutions if compared with several PSO approaches.

Lin and Xingshi (2007) proposed the PSO with the OBL at three stages: initialization, generation jumping and local improvement of the global best individual. The authors applied the proposed modi fi cation to noise benchmark functions and demonstrated that the OBL approach enhances the solutions of the standard PSO algorithm.
 Wang et al. (2011) proposed a variant of the opposition-based
PSO in which a generalized OBL (GOBL) approach transforms the search space of candidate solutions in order to overcome the PC problem. The GOBL is applied at the initialization process and with generation jumping. Also, the Cauchy operator is applied to the global best particle in order to avoid stacking in a local minimum.
The proposed algorithm was applied to benchmark problems and results showed that this approach improves solutions for rotated multimodal problems, but performs badly on shifted and large scale problems.

Zhang et al. (2009) proposed a quasi-oppositional comprehen-sive learning PSO algorithm. The quasi-opposite particles are generated from the interval between the median and the opposite position of the particles. The proposed algorithm was applied to benchmark functions demonstrating faster convergence and glo-bal search ability than non-quasi-oppositional approaches.
Kaucic (2013) proposed an opposite-based PSO with adaptive velocity applied to bounded constrained problems. The proposed algorithm uses a differential evolution scheme for updating the tion phase as well as during a re-initialization phase in which a super-oppositional approach is used to re-initialize particles in the swarm. The proposed modi fi cation was applied to several benchmark functions, demonstrating that the OBL approach applied to the initialization phase and to the restarting process prevents the algorithm from premature convergence. 4. The proposed version of the OPSO algorithm
In order to simplify the hardware implementation of the OBL approach applied to the standard PSO algorithm, symmetrical search spaces are assumed which are appropriated for several applications, including those proposed in this work. Thus, two additions are saved, as stated by Eq. (3) . In contrast to previous approaches of the OPSO ( Wang et al., 2007 , 2011 ; Jabeen et al., 2009 ; Lin and Xingshi, 2007 ) in this work the OBL is applied only when the algorithm achieves several iterations without fi improvement, indicating a possible stagnation. In addition, a uniformly distributed random number in the range  X  1 ; 1 is used for applying the OBL to randomly selected dimensions. The same random number is used for producing a small random modi fi tion of the opposite position of the particles.

The pseudocode of the proposed opposition-based PSO algo-rithm is listed in Algorithm 1 .

Algorithm 1. Pseudocode for the proposed opposition-based PSO algorithm. 1: Set swarm size S , dimensionality N , search space domain 2: Initialize randomly the swarm (uniform distribution): x 3: repeat 4: for i  X  1to S do 5: if f  X  x i  X  o f  X  y i  X  then 6: y i  X  x i 7: f  X  y i  X  X  f  X  x i  X  8: end if 9: end for {Find the minimum among all the fi tness 10: f s  X  min  X  f  X  y i  X  X  11: Set y s as the particle with best fi tness value in the swarm 12: if lastf s f s o 0 : 001 then 13: FNC  X  FNC  X  1 14: else 15: FNC  X  0 16: lastf s  X  f s 17: end if 18: if FNC  X  maxFNC then 19: for i  X  1to S do 20: for j  X  1to N do 21: r  X  U  X  1 ; 1 22: if abs  X  r  X  o 0 : 5 then 23: x ij  X  x ij  X  r = 2 {apply OBL to random 24: end if 25: end for 26: end for 27: FNC  X  0 28: else 29: for i  X  1to S do 30: for j  X  1to N do 31: v ij  X  wv ij  X  c 1 r 1  X  y ij x ij  X  X  c 2 r 2  X  y sj x 32: x ij  X  x ij  X  v ij 33: end for 34: end for 35: end if 36: Update the value of weight factor w 37: until f s r Thres OR iter  X  maxITER
It can be observed in lines 12  X  17 that if the fi tness value f not have a noticeable improvement the counter FNC is incremen-ted. Otherwise, the FNC variable is set to zero and the last ( lastf ) is updated to the current fi tness value f s . In addition, lines 18  X  28 show that the OBL approach is applied to random dimen-sions when the FNC counter reaches the maximum number of iterations without fi tness improvement maxFNC . The U  X  1 function in line 21 is a uniformly distributed random number generated in the range  X  1 ; 1 . The abs  X  X  function indicates the absolute value.

It is important to take into account that the extension of the proposed algorithm to non-symmetrical search spaces can be achieved easily by using one addition and one subtraction opera-tion in the computation of the opposite number. 5. The problem description
This section initially describes two embedded optimization problems which are addressed to solve the online training process of a neural network controller of small mobile robot platforms. The fi rst problem is related to the learning-from-demonstration (LfD) process of desired mobile robot behaviors. The second problem is related to a fault tolerance design which allows the robot to adapt the neural controller when sensor malfunction occurs. Afterwards, the simulator environment used to acquire the training data as well as to validate the behavior of the mobile robot is described.
Finally, a well known neural model used for controlling a syn-chronous driven mobile robot and the fi tness function model used for the optimization problems are explained. 5.1. LfD problem
The LfD problem is a subset of supervised learning , in which the agent is presented with labeled training data and learns an approximation to the function which produce the data ( Billard et al., 2008 ; Argall et al., 2009 ). In this work, the demonstration process is provided by a teleoperation approach of the mobile robot. The training dataset is composed of example executions of the task by a demonstration teacher. Thus, the robot is operated by a human operator, who is the teacher , and records the state/action pairs experienced during the execution.

In the LfD problem, the proposed opposition-based PSO algo-rithm and its respective hardware implementation are applied to adapt the weights of a neural network robot controller for two obstacle avoidance behaviors: (1) performing trajectories in the middle of the free space con fi guration and (2) performing trajectories close to the external walls. 5.2. Fault tolerance problem
This problem involves the online training process of the neural network controller when one or more faults of the robot sensors are detected and isolated. In this situation, the robot must preserve a pre-de fi ned behavior. Therefore, it is necessary to specify a fault tolerant system with portability and small execution time requirements, allowing the robot controller to be adjusted in order to accomplish a speci fi c task.

It is important to point out that in this work the fault detection and isolation algorithms are not implemented. We assume that sensors have a well-known observation model and that fault detection and identi fi cation techniques can be implemented. 5.3. The mobile robot In this work it is used a simulated mobile robot, called Eve Robot, which has a synchronous drive actuator and is equipped with a ring of seven infrared proximity sensors (three left size sensors rg 0 , rg 1 and rg 2 ), as shown in Fig. 2 a.
The EyeSim simulator environment ( Br X uln, 2006 ) has been used for validating the proposed HPOPSO for solving the LfD and the fault tolerance problems. This simulator environment provides the mathematical models of the robot kinematics, motor engines, position sensors, inertial sensors, among others functionalities. It runs on Windows OS and uses a C code programming language.
The EyeSim simulator tool also provides a velocity control for the Eve robot, allowing the users to specify the rotational and linear speed of the robot. Thus, during the teleoperation process the robot records the state of the distance sensors (inputs) and the The individual wheel speeds ( _  X  R ; L ) can be obtained through the inverse kinematics equation (4) of a differential drive mobile robot ( Br X uln, 2006 ) _ _ "# where d is the distance between the two wheels and r is the wheel radius. 5.4. The neural model
The robot controller is a single-layer neural network of two neurons (perceptron model with sigmoid activation function), one for each velocity output. The proximity sensors are used as input neurons (see Fig. 2 b), given a total of 14 weights that must be adjusted during the training process. 5.5. The fi tness function speci fi cation
During the training process of the robot controller each particle of the proposed opposition-based PSO algorithm moves randomly in the 14-dimensional search space (14 weights to be adjusted). The goal of the optimization process is to minimize the approx-imation error of the desired robot behavior, provided by a teleoperation process. According to Algorithm 1 , at each iteration the particles evaluate their performance using a fi tness function model which compares the state/action pairs between the current solution and the desired outputs.

In this work, the proposed fi tness function is based on the sum of square errors between the simulated outputs and the desired outputs, as shown in Eq. (5) . The simulated outputs are computed by evaluating the current particle position using the neural model.
The desired outputs were previously recorded using the example executions of the task by the demonstration teacher f  X   X  where NTD is the number of training data samples, w r and the simulated outputs for the angular and linear velocities, respectively, and w rd and v rd are the desired angular and linear velocities, respectively, obtained from the training dataset. 6. FPGA implementations
The hardware implementation of the opposition-based PSO algorithm (see Algorithm 1 ) was speci fi ed in VHDL hardware description language. This architecture, named as HPOPSO, makes use of a 27 bit precision fl oating-point arithmetic. As previously remarked, this choice of using fl oating-point arithmetic is justi given the large dynamic range required during the optimization process in which small and large real numbers are computed. In previous works, several arithmetic and trigonometric operators were developed in hardware, using the IEEE754 standard, and were validated on FPGAs ( Mu X oz et al., 2010c , d ).

A tradeoff analysis, previously performed, demonstrates that the 27 bit width representation (8 bits for the exponent word and 18 bits for the mantissa word) allows the arithmetic and trigono-metric operators to save 50% of the embedded FPGA DSP blocks.
This representation also provides a similar dynamic range if compared with the single precision representation (32 bits). As expected, a small reduction of precision was veri fi ed; however the associated precision is satisfactory for the application presented in this work. 6.1. Floating-point uniform random number generator
As explained in Section 2 , the stochastic behavior of the PSO algorithm requires the implementation of a random number generator (RNG) for the particles movement process. In this work a RNG based on a 20 bit linear feedback shift register (LFSR) was used (see Fig. 3 ). The LFSR component is a shift register based technique, in which several bits, called taps , are chosen as a feedback function (logic XOR function) obtaining a new state.
The LFSR operates in a fi xed-point arithmetic; therefore, a to fl oat converter is used to represent the random number in fl oating-point arithmetic. This methodology constitutes a draw-back in terms of ef fi ciency given that very small numbers are represented with less resolution after the fi xed to fl oat conversion.
It can be explained because the Probability Mass Function (PMF) of uniform fl oating-point numbers increases its resolution for close to zero numbers ( Thomas and Luk, 2008 ). However, for the proposed applications the RNGs are used for creating randomness during the particles movement, thus, the loss of uniformity, which is only veri fi ed for small numbers (less than 2 3 ), does not represent a relevant problem for the PSO operation. 6.2. Particle architecture
The U 1 [0,1] and U 2 [0,1] RNGs of the update equation (2) can be replaced by the U 1 [0, c 1 ] and U 2 [0, c 2 ] RNGs, saving two point multiplications. Thus, the update process of the position of each particle requires to calculate two random numbers, fi sub and three multiplications. Fig. 4 shows the hardware archi-tecture for the update process of the particle position. The particle architecture is based on a Finite State Machine (FSM) approach. All the operations in each state are executed in a parallel approach.
When the opposition number must be computed, the FSM goes directly to the opposition state, otherwise the FSM computes the new position using the update equations (2 ) and ( 1 ). Notice that the opposite number is easily computed by changing the signal bit of the fl oating-point representation.
 6.3. The evaluation unit During the training process, each particle must simulate the
ANN robot controller for evaluating its performance. Therefore, it was necessary to implement in hardware the neural model shown in Fig. 2 b (single-layer of two neurons). According to Algorithm 1 the fi tness evaluation process depends on the previous updated particle positions (synchronous PSO approach). This fact suggests that the evaluation unit can share the same resources as the particle unit. Fig. 5 a shows the hardware architecture of the function evaluation. It uses two FPmul ( fl oating-point multiplica-tion), two FPadd ( fl oating-point addition) operators and two comparators for implementing the linear activation function of each neuron.

The fi tness functions were implemented using the same FPmul and FPadd units of the ANN output computation, see Fig. 5 b. 6.4. General architecture
The general HPOPSO architecture is shown in Fig. 6 .Itis composed of a swarm unit with S parallel particles and an evaluation unit with S parallel fi tness functions for evaluating the performance of each particle. A ROM memory stores the training dataset. After the evaluation process, the individual detection unit compares the current fi tness values with the respective best fi tness found previously, and updates the individual best position.
The global detection unit computes the global best fi tness and updates the global best position. Also, the global detection unit increments the FNC counter when no fi tness improvement is detected. If the FNC counter equals the maximum number of iterations without fi tness improvement, then the opp signal indicates that the opposition number must be computed.
The RS-232 block is used to communicate with the simulator environment, sending the global best position ( y s ) when the maximum number of iterations is reached. Additionally, the simulator environment sends to the HPOPSO architecture infor-mation about a failure in one or more sensors. In the case of a sensor malfunction, the architecture discards the respective infor-mation from the ROM memory. For doing that, the fault vector signal, which indicates a failure in a sensor, addresses through a multiplexer either the respective training data or a zero value. This allows the HPOPSO to adjust the ANN weights using only the available information provided by the operational sensors. 7. Results
This section summarizes the synthesis and simulation results of the proposed circuit architecture. The HPOPSO was synthesized in the Xilinx ISE10.1 development tool and was validated for a swarm composed of 10 particles ( S  X  10) optimizing the 14-dimensional problem ( N  X  14) of the neural model. Table 1 shows the para-meters used for the HPOPSO implementation. 7.1. The validation environment
Fig. 7 depicts the validation environment which is composed of the EyeSim simulator running on a PC, a serial communication interface and the HPOPSO architecture implemented on the FPGA device. The teacher performs the robot teleoperation process using the keyboard and the training dataset are recorded from the distance sensor (inputs) and the linear and angular velocities (outputs). After the training process, the global best particle position ( y s ), which contains the weights of the neural controller, is sent through the serial communication module to the PC in order to validate the learning behavior of the mobile robot. As explained in Section 5 , two main problems are solved by the HPOPSO optimization engine. The LfD problem, in which the robot must learn a speci fi c task, and the fault tolerance problem, in which the robot must perform correctly a task whenever sensor malfunctions occur. For both the problems, the training dataset was recorded during the teacher demonstration of two desired obstacle avoidance behaviors: (1) performing trajectories in the middle of the free space con fi guration and (2) performing trajec-tories close to the external walls. Thus, the goal of the optimization process is to minimize the approximation error during the robot learning process. This learning process is performed by adjusting the weights of the neural network robot controller.

Fig. 8 shows the trajectories performed during the demonstra-tion process for both the obstacle avoidance behaviors. 7.2. Convergence comparison between O-PSO and PSO
In order to demonstrate the suitability of the PSO with the OBL operator, several experiments were conducted for solving the training process of a mobile robot neural controller for the above explained behaviors. Table 2 shows a convergence comparison between the opposition-based PSO and the standard PSO algorithms.

It can be observed that in some cases, the PSO with OBL achieves similar results to the standard PSO. However, the OBL improves the results of the standard PSO in the case of the Behavior 1 with failure in the frontal sensor. In addition, a convergence improvement was achieved in the case of the Behavior 2 without sensor malfunction as well as for simultaneous failures of the sensors lf 0 and rg 7.3. Synthesis results
Table 3 shows the synthesis results of the HPOPSO architecture for a Xilinx Virtex5 family (chip xc5vlx110t). The cost in logic area is reported in fl ip-fl ops (FFs), LookUp Tables (LUTs), RAM and DSP blocks consumption. The performance is presented in megahertz.
These results point out that the proposed HPOPSO architecture is feasible to be mapped on the selected FPGA device. The area cost is satisfactory in terms of implemented combinatorial logic (LUTs) and registers (FF) consumption. There are around 36% of the available LUTs for future implementations. The maximum opera-tional frequency of the circuit is around 130 MHz.

Another important aspect is the DSP block consumption. In the case of a 27 bit width representation, the 10 parallel particles implementation consumes around 31% of the available DSPs and, although not shown here, the same architecture using a 32 bit width representation requires 62.5% of the DSPs. This fact can be a drawback when implementing more parallel particles or using large bit-width arithmetic representations (for example a double precision representation). This would imply that other solutions should implement the fl oating-point multipliers using the avail-able logic area of the FPGA.

It is important to take into account that the selected FPGA chip is not the largest device from the Virtex5 family. There are FPGA devices with more hardware resources which allow for implementing more parallel particles in order to solve more complex optimization problems. 7.4. Behavior learning test
Table 4 shows the connection weights obtained for obstacle avoidance behaviors. Neuron 1 controls the robot angular velocity w , whereas neuron 2 controls the robot linear velocity v
In the case of Behavior 1 , the weight connections to the lf rg sensors  X  i  X f 0 ; 1 ; 2 g X  have a major contribution to the angular velocity computation. In contrast, the weight connection to the frontal sensor fr has a major contribution for computing the linear velocity. This model indicates that the robot increments or decre-ments the linear velocity according to the frontal distance to the obstacles whereas turns according to the lateral distance to the obstacles.

In the case of Behavior 2 , the contribution of the left side estimation. In contrast, the weight connections to the right side the velocities. This fact allows the robot to perform counter-clockwise trajectories close to the external walls.

Fig. 9 depicts the trajectories obtained for both the obstacle avoidance behaviors. The solid lines are the trajectories used by the teacher demonstration during the teleoperation process. The dotted lines are the obtained trajectories after the training process.
It can be observed that the proposed HPOPSO architecture satis-factorily performs the training process of the robot neural con-troller for both the simulated behaviors.

In order to validate the effectiveness of the training process, the learned behaviors were analyzed for unknown environments.
Fig. 10 shows the trajectories performed by the robot in different scenarios. It can be observed that the validation test was per-formed in scenarios with different degrees of complexity. In general, the robot performs the task correctly. However, some collisions were detected in the case of the Behavior 2 (right column), speci fi cally in scenarios with bordering obstacles (see
Fig. 10 h and i). Notice that this situation was not considered during the demonstration process (see Fig. 8 ). 7.5. Fault tolerance test
One of the advantages of using hardware parallel architectures for training an ANN robot controller is the possibility of achieving good quality solutions in a short elapsed time. This fact allows the robots to adapt the control strategies in an online fashion. The robustness and fl exibility of the proposed HPOPSO architecture is explored by adapting the robot controller when a sensor malfunc-tion occurs.

A sensor failure can be detected by using the sensor model or analyzing the variance of the associated measurements. However, in this work, the sensor malfunction is emulated using some user buttons available on the simulator environment. It sends the ID sensor number to the FPGA which starts the ANN training process disregarding the training data of failure sensors. Once the new weights have been adjusted to the new situation the FPGA device returns the y s values through the serial communication.
Table 5 shows the weights obtained for a normal sensor operation and three sensor failures. These results were obtained for trajectories performed in the middle of the free space con uration ( Behavior 1 ). The fi rst seven rows correspond to the weight connections of the fi rst neuron (angular velocity output) and the last seven rows to the weight connections of the second neuron (linear velocity output).

It can be observed that under the normal operation of sensors ( no fault column) the ANN imitated the teacher demonstrations used for acquiring the training dataset. Notice that except for the fr sensor, all the other sensors contribute to the angular velocity. Only the fr sensor contributes to the linear velocity. All the weights connecting input data of failure sensors are equal to zero. In the case of a failure in the frontal sensor ( fr column), one can observe estimating the linear velocity. In the case of simultaneous failures of the sensors lf 2 and rg 2 , the training process has increased the contribution of the sensors lf 1 and rg 1 ( y s 20 and y s 30 Finally, in the case of failures of the sensors lf 0 and rg modi fi cations in the neural controller were conducted by the HPOPSO architecture.

Fig. 11 shows the trajectories obtained for each failure case problem. It can be observed that the trajectory obtained after the compensation of the failure of the sensor fr presents some collisions, speci fi cally for curves in reduced spaces.
In the case of failures on sensors lf 2 and rg 2 free collision trajectories were achieved for the fi rst two scenarios. However, some collisions were observed for complex scenarios in which border obstacles are presented ( Fig. 11 g and h). In that case, one can conclude that the compensation performed by incrementing the contribution of sensors lf 1 and rg 1 is not enough for estimating the diagonal distance to the obstacles. Finally, in the case of failures in sensors lf 0 and rg 0 the weights of the neural controller were effectively adjusted, obtaining free collision trajectories. 7.6. Execution time comparison
The large computational cost of population-based optimization algorithms is a drawback for portable systems applications, in which the algorithms must be executed with a high performance and low power consumption. In order to demonstrate the feasi-bility of the proposed HPOPSO architecture it is important to compare the execution time between hardware and common software solutions for mobile robotics.

Table 6 shows a comparison of the execution time per iteration between the proposed HPOPSO architecture and two software implementations. The fi rst one is based on a C code implementa-tion using an Intel Core 2 Duo, at 1.6 GHz, 2 GB RAM, Windows XP
O.S. The second one is based on the Microblaze embedded soft processor, operating at the same frequency as the HPOPSO architecture and 64 kB program memory.

Simulation results using the ModelSim simulator tool show that one iteration of the proposed HPOPSO architecture requires 106 118 clock cycles. According to the synthesis results reported in
Table 3 the maximum operational clock frequency of the HPOPSO circuit is around 130 MHz. Therefore, for a total of 5000 iterations, one can expect an execution time of 5.3 s. On the other hand, the
Desktop solution requires around 19.29 s to execute the same number of iterations. Therefore, the proposed hardware architec-ture achieves a speedup factor of 3.6 in comparison with the
Desktop software solution. In addition, the proposed HPOPSO achieves a speedup factor of 6248 in comparison with the Micro-blaze implementation. This fact demonstrates the suitableness of the hardware based solution for training/adapting neural robot controllers on portable applications.

It is important to stress here that more ef fi cient software implementations might be achieved in assembler code, and these numbers are only valid as a rough approximation to the expected speedup factor. However, a fair performance comparison between hardware and software solutions should use the same computa-tional platform, operating at the same clock frequency. From this point of view, it was demonstrated that the proposed hardware approach reaches an expressive acceleration in comparison with common microcontroller based miniature mobile robot platforms. 8. Discussion of the results
According to the previously ment ioned results, one can conclude that a hardware implementation of the parallel opposition-based PSO algorithm is, in general, suitable for embedded optimization problems in terms of quality of the solution and performance. Synthesis results (Table 3 ) pointed out that the proposed HPOPSO architecture is effectively implementable on commercial FPGAs. The circuits spend around 27% of the available fl ip-and 63% of the available LUTs for implementing the combinatorial logic.

The hardware resources consumption depends not only on the proposed architecture but also on the bit-width of the arithmetic representation. The Virtex5 family FPGA uses DSP48Es blocks which performs 23 18 bit multiplications. In this work, an ef fi cient hardware implementation of the HPOPSO architecture was achieved using a 27 bit width fl oating-point representation, which allows the representation of real numbers using 18-bits for the mantissa word. This fact allows for saving logic area and DSP blocks in comparison with a single precision implementation.
The HPOPSO architecture for training the neural robot con-troller has been implemented entirely in hardware. This choice is justi fi ed because of the high computational cost required for the neural network training process. However, several considerations must be done for improving the performance of the proposed architecture. Additional parallel computations, especially during the evaluation of the fi tness functions which is the most time consuming process, will decrease the number of clock cycles per iteration of the algorithm. However, it will require FPGA devices with more hardware resources than those applied in the given experiments. The use of embedded soft-processors can provide a fl exible platform for partitioning the navigation algorithms and executing functions that are not computationally complex.
Simulation experiments have demonstrated the learning cap-abilities of the robot controller which allows the robot to accom-plish different tasks as well as to maintain different desired behaviors when one or more faults occur in the distance sensors.
Another important aspect is that the proposed hardware architecture takes advantage of parallel processing for accelerating the training process of the robot controller. Execution time results point out that the training process requires 5.3 s (3.86 ms per iteration). Although these results are not tailored for real time mobile robot applications, it is important to take into account that the proposed architecture achieves a speed up factor of 3.6 in comparison with a software implementation running on a desk-top. Therefore, the proposed HPOPSO architecture can be a useful solution for small mobile robot platforms with high performance and low power consumption requirements. 9. Conclusions
This work presents an FPGA implem entation of the PSO algorithm with opposition based learning approach (HPOPSO). The proposed
HPOPSO architecture takes advantage of simple operators for improving the quality of the solutions preserving swarm diversity and avoiding the problem of premature convergence .Theentire architecture is described in VHDL and it makes use of a suitable fl oating-point arithmetic, allowin g the optimization process to oper-ate with high precision between a large dynamic range.
The HPOPSO has been applied to the learning from demonstra-tion problem in which the training dataset is composed of example executions of the task by a demonstration teacher. Thus, the HPOPSO architecture adjusts the weights of a neural network robot controller in order to perform the desired task as well as to preserve the desired behavior when malfunctions on the distance sensors occur.

Two different obstacle avoidance behaviors were used as case study. The mobile robot behavior has been analyzed for different scenarios and test results demonstrate that the robot successfully avoids obstacles according to the desired behavior demonstrated by the teacher. Additionally, the HPOPSO architecture obtained satisfactory solutions adapting the weights of the neural controller when failures on one or more infrared sensors were simulated.
Synthesis results demonstrate that the proposed hardware architecture requires around 63% of the available LUTs of the FPGA device and achieves an operational frequency around 130 MHz.
Execution time comparisons demonstrate an acceleration factor of 3.6 in comparison with a software implementation running on a common desktop platform operating at 1.6 GHz. In addition, the proposed architecture achieves a speed up factor of 6248 in comparison with an embedded Microblaze software processor, operating at 100 MHz.

As future works is intended the implementation of the training process in a real small mobile robot as well as to include an infrared sensor model in order to automatically detect sensor failures. Acknowledgments The authors would like to thank the National Council of
Scienti fi c and Technological Development of Brazil  X  CNPq (Pro-cess 142033/2008-1), the PRONEX program (FAPDF/MCT/CNPq Process 193.000.580/2009) for its fi nancial support and to the Xilinx University Program.
 References
