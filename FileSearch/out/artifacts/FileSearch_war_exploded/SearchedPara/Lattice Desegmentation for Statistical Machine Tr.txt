 Morphological segmentation is considered to be indispensable when translating between English and morphologically complex languages such as Arabic. Morphological complexity leads to much higher type to token ratios than English, which can create sparsity problems during translation model estimation. Morphological segmentation addresses this issue by splitting surface forms into meaningful morphemes, while also performing or-thographic transformations to further reduce spar-sity. For example, the Arabic noun  X   X  Y X  X  lldwl  X  X o the countries X  is segmented as l+  X  X o X  Aldwl  X  X he countries X . When translating from Arabic, this segmentation process is performed as input preprocessing and is otherwise transparent to the translation system. However, when translating into Arabic, the decoder produces segmented out-put, which must be desegmented to produce read-able text. For example, l+ Aldwl must be con-verted to lldwl .

Desegmentation is typically performed as a post-processing step that is independent from the decoding process. While this division of labor is useful, the pipeline approach may prevent the de-segmenter from recovering from errors made by the decoder. Despite the efforts of the decoder X  X  various component models, the system may pro-duce mismatching segments, such as s+ hzymp , which pairs the future particle s+  X  X ill X  with a noun hzymp  X  X efeat X , instead of a verb. In this sce-nario, there is no right desegmentation; the post-processor has been dealt a losing hand.

In this work, we show that it is possible to maintain the sparsity-reducing benefit of segmen-tation while translating directly into unsegmented text. We desegment a large set of possible de-coder outputs by processing n -best lists or lat-tices, which allows us to consider both the seg-mented and desegmented output before locking in the decoder X  X  decision. We demonstrate that sig-nificant improvements in translation quality can be achieved by training a linear model to re-rank this transformed translation space. Translating into morphologically complex lan-guages is a challenging and interesting task that has received much recent attention. Most tech-niques approach the problem by transforming the target language in some manner before training the translation model. They differ in what transforma-tions are performed and at what stage they are re-versed. The transformation might take the form of a morphological analysis or a morphological seg-mentation. 2.1 Morphological Analysis Many languages have access to morphological an-alyzers, which annotate surface forms with their lemmas and morphological features. Bojar (2007) incorporates such analyses into a factored model, to either include a language model over target mor-phological tags, or model the generation of mor-phological features. Other approaches train an SMT system to predict lemmas instead of surface forms, and then inflect the SMT output as a post-processing step (Minkov et al., 2007; Clifton and Sarkar, 2011; Fraser et al., 2012; El Kholy and Habash, 2012b). Alternatively, one can reparame-terize existing phrase tables as exponential mod-els, so that translation probabilities account for source context and morphological features (Jeong et al., 2010; Subotin, 2011). Of these approaches, ours is most similar to the translate-then-inflect ap-proach, except we translate and then desegment. In particular, Toutanova et al. (2008) inflect and re-rank n -best lists in a similar manner to how we desegment and re-rank n -best lists or lattices. 2.2 Morphological Segmentation Instead of producing an abstract feature layer, morphological segmentation transforms the tar-get sentence by segmenting relevant morphemes, which are then handled as regular tokens during alignment and translation. This is done to reduce sparsity and to improve correspondence with the source language (usually English). Such a seg-mentation can be produced as a byproduct of anal-ysis (Oflazer and Durgar El-Kahlout, 2007; Badr et al., 2008; El Kholy and Habash, 2012a), or may be produced using an unsupervised morphological segmenter such as Morfessor (Luong et al., 2010; Clifton and Sarkar, 2011). Work on target lan-guage morphological segmentation for SMT can be divided into three subproblems: segmentation, desegmentation and integration. Our work is con-cerned primarily with the integration problem, but we will discuss each subproblem in turn.

The usefulness of a target segmentation de-pends on its correspondence to the source lan-guage. If a morphological feature does not man-ifest itself as a separate token in the source, then it may be best to leave its corresponding segment attached to the stem. A number of studies have looked into what granularity of segmentation is best suited for a particular language pair (Oflazer and Durgar El-Kahlout, 2007; Badr et al., 2008; Clifton and Sarkar, 2011; El Kholy and Habash, 2012a). Since our focus here is on integrating seg-mentation into the decoding process, we simply adopt the segmentation strategies recommended by previous work: the Penn Arabic Treebank scheme for English-Arabic (El Kholy and Habash, 2012a), and an unsupervised scheme for English-Finnish (Clifton and Sarkar, 2011).

Desegmentation is the process of converting segmented words into their original surface form. For many segmentations, especially unsupervised ones, this amounts to simple concatenation. How-ever, more complex segmentations, such as the Arabic tokenization provided by MADA (Habash et al., 2009), require further orthographic adjust-ments to reverse normalizations performed dur-ing segmentation. Badr et al. (2008) present two Arabic desegmentation schemes: table-based and rule-based. El Kholy and Habash (2012a) provide an extensive study on the influence of segmentation and desegmentation on English-to-Arabic SMT. They introduce an additional deseg-mentation technique that augments the table-based approach with an unsegmented language model. Salameh et al. (2013) replace rule-based deseg-mentation with a discriminatively-trained char-acter transducer. In this work, we adopt the Table+Rules approach of El Kholy and Habash (2012a) for English-Arabic, while concatenation is sufficient for English-Finnish.

Work on integration attempts to improve SMT performance for morphologically complex target languages by going beyond simple pre-and post-processing. Oflazer and Durgar El-Kahlout (2007) desegment 1000-best lists for English-to-Turkish translation to enable scoring with an unsegmented language model. Unlike our work, they replace the segmented language model with the unseg-mented one, allowing them to tune the linear model parameters by hand. We use both seg-mented and unsegmented language models, and tune automatically to optimize BLEU.

Like us, Luong et al. (2010) tune on un-segmented and unsegmented language models for English-to-Finnish translation. However, they adopt a scheme of word-boundary-aware morpheme-level phrase extraction, meaning that target phrases include only complete words, though those words are segmented into mor-phemes. This enables full decoder integration, where we do n -best and lattice re-ranking. But it also comes at a substantial cost: when target phrases include only complete words, the system can only generate word forms that were seen dur-ing training. In this setting, the sparsity reduc-tion from segmentation helps word alignment and target language modeling, but it does not result in a more expressive translation model. Further-more, it becomes substantially more difficult to have non-adjacent source tokens contribute mor-phemes to a single target word. For example, when translating  X  X ith his blue car X  into the Ara-bsyArth is composed of three tokens: b+  X  X ith X , syArp  X  X ar X  and +h  X  X is X . With word-boundary-aware phrase extraction, a phrase pair containing all of  X  X ith his blue car X  must have been seen in the parallel data to translate the phrase correctly at test time. With lattice desegmentation, we need only to have seen AlzrqA X   X  X lue X  and the three morphological pieces of bsyArth for the decoder and desegmenter to assemble the phrase. Our goal in this work is to benefit from the sparsity-reducing properties of morphological segmentation while simultaneously allowing the system to reason about the final surface forms of the target language. We approach this problem by augmenting an SMT system built over target seg-ments with features that reflect the desegmented target words. In this section, we describe our vari-ous strategies for desegmenting the SMT system X  X  output space, along with the features that we add to take advantage of this desegmented view. 3.1 Baselines The two obvious baseline approaches each decode using one view of the target language. The un-segmented approach translates without segment-ing the target. This trivially allows for an unseg-mented language model and never makes deseg-mentation errors. However, it suffers from data sparsity and poor token-to-token correspondence with the source language.

The one-best desegmentation approach seg-ments the target language at training time and then desegments the one-best output in post-processing. This resolves the sparsity issue, but does not allow the decoder to take into account features of the desegmented target. To the best of our knowledge, we are the first group to go beyond one-best desegmentation for English-to-Arabic translation. In English-to-Finnish, although alter-native integration strategies have seen some suc-cess (Luong et al., 2010), the current state-of-the-art performs one-best-desegmentation (Clifton and Sarkar, 2011). 3.2 n -best Desegmentation The one-best approach can be extended easily by desegmenting n -best lists of segmented decoder output. Doing so enables the inclusion of an unsegmented target language model, and with a small amount of bookkeeping, it also allows the inclusion of features related to the operations per-formed during desegmentation (see Section 3.4). With new features reflecting the desegmented out-put, we can re-tune our enhanced linear model on a development set. Following previous work, we will desegment 1000-best lists (Oflazer and Dur-gar El-Kahlout, 2007).

Once n -best lists have been desegmented, we can tune on unsegmented references as a side-benefit. This could improve translation quality, as it brings our training scenario closer to our test scenario (test BLEU is always measured on unseg-mented references). In particular, it could address issues with translation length mismatch. Previous work that has tuned on unsegmented references has reported mixed results (Badr et al., 2008; Lu-ong et al., 2010). 3.3 Lattice Desegmentation An n -best list reflects a tiny portion of a decoder X  X  search space, typically fixed at 1000 hypotheses. hypotheses in a compact structure. In this section, we discuss how a lattice from a multi-stack phrase-based decoder such as Moses (Koehn et al., 2007) can be desegmented to enable word-level features. Finite State Analogy A phrase-based decoder produces its output from left to right, with each operation appending the translation of a source phrase to a grow-ing target hypothesis. Translation continues un-and AlTfl  X  X he child X . til each source word has been covered exactly once (Koehn et al., 2003).

The search graph of a phrase-based decoder can be interpreted as a lattice, which can be interpreted as a finite state acceptor over target strings. In its most natural form, such an acceptor emits target phrases on each edge, but it can easily be trans-formed into a form with one edge per token, as shown in Figure 1a. This is sometimes referred to as a word graph (Ueffing et al., 2002), although in our case the segmented phrase table also produces tokens that correspond to morphemes.

Our goal is to desegment the decoder X  X  output lattice, and in doing so, gain access to a compact, desegmented view of a large portion of the trans-lation search space. This can be accomplished by composing the lattice with a desegmenting trans-ducer that consumes morphemes and outputs de-segmented words. This transducer must be able to consume every word in our lattice X  X  output vo-cabulary. We define a word using the following regular expression: [prefix]* [stem] [suffix]* | [prefix]+ [suffix]+ where [prefix], [stem] and [suffix] are non-overlapping sets of morphemes, whose members are easily determined using the segmenter X  X  seg-Equation 1 covers words that have no clear stem, such as the Arabic  X  X  lh  X  X or him X , segmented as l+  X  X or X  +h  X  X im X . Equation 1 may need to be modi-fied for other languages or segmentation schemes, but our techniques generalize to any definition that can be written as a regular expression.

A desegmenting transducer can be constructed by first encoding our desegmenter as a table that maps morpheme sequences to words. Regardless of whether the original desegmenter was based on concatenation, rules or table-lookup, it can be encoded as a lattice-specific table by applying it to an enumeration of all words found in the lat-tice. We can then transform that table into a fi-nite state transducer with one path per table en-try. Finally, we take the closure of this trans-ducer, so that the resulting machine can transduce any sequence of words. The desegmenting trans-ducer for our running example is shown in Fig-ure 1b. Note that tokens requiring no desegmen-tation simply emit themselves. The lattice (Fig-ure 1a) can then be desegmented by composing it with the transducer (1b), producing a desegmented lattice (1c). This is a natural place to introduce features that describe the desegmentation process, such as scores provided by a desegmentation table, which can be incorporated into the desegmenting transducer X  X  edge weights.

We now have a desegmented lattice, but it has not been annotated with an unsegmented (word-level) language model. In order to annotate lattice edges with an n -gram LM, every path coming into a node must end with the same sequence of ( n  X  1 ) tokens. If this property does not hold, then nodes tained by the decoder X  X  recombination rules for the segmented LM, but it is not guaranteed for the de-segmented LM. Indeed, the expanded word-level context is one of the main benefits of incorporating a word-level LM. Fortunately, LM annotation as well as any necessary lattice modifications can be performed simultaneously by composing the de-segmented lattice with a finite state acceptor en-coding the LM (Roark et al., 2011).

In summary, we are given a segmented lattice, which encodes the decoder X  X  translation space as an acceptor over morphemes. We compose this acceptor with a desegmenting transducer, and then with an unsegmented LM acceptor, producing a fully annotated, desegmented lattice. Instead of using a tool kit such as OpenFst (Allauzen et al., 2007), we implement both the desegmenting transducer and the LM acceptor programmatically. This eliminates the need to construct intermediate machines, such as the lattice-specific desegmenter in Figure 1b, and facilitates working with edges annotated with feature vectors as opposed to sin-gle weights.
 Programmatic Desegmentation Lattice desegmentation is a non-local lattice trans-formation. That is, the morphemes forming a word might span several edges, making desegmentation non-trivial. Luong et al. (2010) address this prob-lem by forcing the decoder X  X  phrase table to re-spect word boundaries, guaranteeing that each de-segmentable token sequence is local to an edge. Inspired by the use of non-local features in forest decoding (Huang, 2008), we present an algorithm to find chains of edges that correspond to deseg-mentable token sequences, allowing lattice deseg-mentation with no phrase-table restrictions. This algorithm can be seen as implicitly constructing a customized desegmenting transducer and compos-ing it with the input lattice on the fly.

Before describing the algorithm, we define some notation. An input morpheme lattice is a triple  X  n s , N , E X  , where N is a set of nodes, E is a set of edges, and n s  X  N is the start node that begins each path through the lattice. Each edge e  X  X  is a 4-tuple  X  from , to , lex , w  X  , where from , to  X  N are head and tail nodes, lex is a single token accepted by this edge, and w is the (po-tentially vector-valued) edge weight. Tokens are drawn from one of three non-overlapping morpho-syntactic sets: lex  X  Prefix  X  Stem  X  Suffix , where tokens that do not require desegmentation, such as complete words, punctuation and num-bers, are considered to be in Stem . It is also useful to consider the set of all outgoing edges for a node n. out = { e  X  X | e. from = n } .

With this notation in place, we can define a chain c to be a sequence of edges [ e 1 . . . e l ] such that for 1  X  i &lt; l : e i . to = e i +1 . from . We denote singleton chains with [ e ] , and when unam-biguous, we abbreviate longer chains with their start and end node [ e 1 . from  X  e l . to ] . A chain is valid if it emits the beginning of a word as de-fined by the regular expression in Equation 1. A valid chain is complete if its edges form an entire word, and if it is part of a path through the lat-tice that consists only of words. In Figure 1a, the complete chains are [0  X  2] , [0  X  4] , [0  X  5] , and [2  X  3] . The path restriction on complete chains forces words to be bounded by other words moved the edge 2  X  3 ( AlTfl ) from Figure 1a, then [0  X  2] ([ b+ lEbp ]) would cease to be a com-plete chain, but it would still be a valid chain. Note that in the finite-state analogy, the path restriction is implicit in the composition operation.

Algorithm 1 desegments a lattice by finding all complete chains and replacing each one with a sin-gle edge. It maintains a work list of nodes that lie on the boundary between words, and for each node on this list, it launches a depth first search Algorithm 1 Desegment a lattice  X  n s , N , E X  { Initialize output lattice and work list WL } n 0 s = n s , N 0 =  X  , E 0 =  X  , WL = [ n s ] while n = WL . pop () do return  X  n 0 s , N 0 , E 0  X  to find all complete chains extending from it. The search recognizes the valid chain c to be complete by finding an edge e such that c + e forms a chain, but not a valid one. By inspection of Equation 1, this can only happen when a prefix or stem fol-lows a stem or suffix, which always marks a word boundary. The chains found by this search are de-segmented and then added to the output lattice as edges. The nodes at end points of these chains are added to the work list, as they lie at word bound-aries by definition. Note that although this algo-rithm creates completely new edges, the resulting node set N 0 will be a subset of the input node set N . The complement N X  X  0 will consist of nodes that are word-internal in all paths through the input lattice, such as node 1 in Figure 1a.
 Programmatic LM Integration Programmatic composition of a lattice with an n -gram LM acceptor is a well understood prob-lem. We use a dynamic program to enumerate all ( n  X  1) -word contexts leading into a node, and then split the node into multiple copies, one for each context. With each node corresponding to a single LM context, annotation of outgoing edges with n -gram LM scores is straightforward. 3.4 Desegmentation Features Our re-ranker has access to all of the features used by the decoder, in addition to a number of features enabled by desegmentation.
 Desegmentation Score We use a table-based desegmentation method for Arabic, which is based on segmenting an Arabic training corpus and memorizing the observed transformations to re-verse them later. Finnish does not require a ta-ble, as all words can be desegmented with sim-ple concatenation. The Arabic table consists of X  X  Y entries, where X is a target morpheme sequence and Y is a desegmented surface form. Several entries may share the same X , resulting in multiple desegmentation options. For the sake of symmetry with the unambiguous Finnish case, we augment Arabic n -best lists or lattices with only the most frequent desegmentation Y . 6 We provide the desegmentation score log p ( Y | X ) = try X  X  ambiguity in the training data. 7 When an X is missing from the table, we fall back on a set of de-segmentation rules (El Kholy and Habash, 2012a) and this feature is set to 0. This feature is always 0 for English-Finnish.
 Contiguity One advantage of our approach is that it allows discontiguous source words to trans-late into a single target word. In order to maintain some control over this powerful capability, we cre-ate three binary features that indicate the contigu-ity of a desegmentation. The first feature indicates that the desegmented morphemes were translated from contiguous source words. The second indi-cates that the source words contained a single dis-contiguity, as in a word-by-word translation of the  X  X ith his blue car X  example from Section 2.2. The third indicates two or more discontiguities. Unsegmented LM A 5-gram LM trained on un-segmented target text is used to assess the fluency of the desegmented word sequence. We train our English-to-Arabic system using 1.49 million sentence pairs drawn from the NIST 2012 training set, excluding the UN data. This training set contains about 40 million Arabic tokens before segmentation, and 47 million after segmentation. We tune on the NIST 2004 evaluation set (1353 sentences) and evaluate on NIST 2005 (1056 sen-tences). As these evaluation sets are intended for Arabic-to-English translation, we select the first English reference to use as our source text.
Our English-to-Finnish system is trained on the same Europarl corpus as Luong et al. (2010) and Clifton and Sarkar (2011), which has roughly one million sentence pairs. We also use their develop-ment and test sets (2000 sentences each). 4.1 Segmentation For Arabic, morphological segmentation is per-formed by MADA 3.2 (Habash et al., 2009), using the Penn Arabic Treebank (PATB) segmentation scheme as recommended by El Kholy and Habash (2012a). For both segmented and unsegmented Arabic, we further normalize the script by convert-bare Alif @ and dotless Ya  X  . To generate the de-segmentation table, we analyze the segmentations from the Arabic side of the parallel training data to collect mappings from morpheme sequences to surface forms.

For Finnish, we adopt the Unsup L-match seg-mentation technique of Clifton and Sarkar (2011), which uses Morfessor (Creutz and Lagus, 2005) to analyze the 5,000 most frequent Finnish words. The analysis is then applied to the Finnish side of the parallel text, and a list of segmented suffixes is collected. To improve coverage, words are fur-ther segmented according to their longest match-ing suffix from the list. As Morfessor does not perform any orthographic normalizations, it can be desegmented with simple concatenation. 4.2 Systems We align the parallel data with GIZA++ (Och et al., 2003) and decode using Moses (Koehn et al., 2007). The decoder X  X  log-linear model includes a standard feature set. Four translation model fea-tures encode phrase translation probabilities and lexical scores in both directions. Seven distor-tion features encode a standard distortion penalty as well as a bidirectional lexicalized reordering model. A KN-smoothed 5-gram language model is trained on the target side of the parallel data with SRILM (Stolcke, 2002). Finally, we include word and phrase penalties. The decoder uses the default parameters for English-to-Arabic, except that the maximum phrase length is set to 8. For English-to-Finnish, we follow Clifton and Sarkar (2011) in setting the hypothesis stack size to 100, distortion limit to 6, and maximum phrase length to 20. The decoder X  X  log-linear model is tuned with MERT (Och, 2003). Re-ranking models are tuned using a batch variant of hope-fear MIRA (Chi-ang et al., 2008; Cherry and Foster, 2012), us-ing the n -best variant for n -best desegmentation, and the lattice variant for lattice desegmentation. MIRA was selected over MERT because we have an in-house implementation that can tune on lat-tices very quickly. During development, we con-firmed that MERT and MIRA perform similarly, as is expected with fewer than 20 features. Both the decoder X  X  log-linear model and the re-ranking models are trained on the same development set. Historically, we have not seen improvements from using different tuning sets for decoding and re-ranking. Lattices are pruned to a density of 50 edges per word before re-ranking.

We test four different systems. Our first base-line is Unsegmented , where we train on unseg-mented target text, requiring no desegmentation step. Our second baseline is 1-best Deseg , where we train on segmented target text and desegment the decoder X  X  1-best output. Starting from the sys-tem that produced 1-best Deseg, we then output ei-ther 1000-best lists or lattices to create our two ex-perimental systems. The 1000-best Deseg system desegments, augments and re-ranks the decoder X  X  1000-best list, while Lattice Deseg does the same in the lattice. We augment n -best lists and lattices
We evaluate our system using BLEU (Papineni et al., 2002) and TER (Snover et al., 2006). Fol-lowing Clark et al. (2011), we report average scores over five random tuning replications to ac-count for optimizer instability. For the baselines, this means 5 runs of decoder tuning. For the de-segmenting re-rankers, this means 5 runs of re-ranker tuning, each working on n -best lists or lat-tices produced by the same (representative) de-coder weights. We measure statistical significance using MultEval (Clark et al., 2011), which imple-ments a stratified approximate randomization test to account for multiple tuning replications. Tables 1 and 2 report results averaged over 5 tun-ing replications on English-to-Arabic and English-to-Finnish, respectively. In all scenarios, both 1000 -best Deseg and Lattice Deseg significantly outperform the 1-best Deseg baseline ( p &lt; 0 . 01 ).
For English-to-Arabic, 1-best desegmentation results in a 0.7 BLEU point improvement over training on unsegmented Arabic. Moving to lat-tice desegmentation more than doubles that im-provement, resulting in a BLEU score of 34.4 and an improvement of 1.0 BLEU point over 1-best desegmentation. 1000 -best desegmentation also works well, resulting in a 0.6 BLEU point im-provement over 1-best. Lattice desegmentation is significantly better ( p &lt; 0 . 01 ) than 1000 -best de-segmentation.

For English-to-Finnish, the Unsup L-match seg-mentation with 1-best desegmentation does not improve over the unsegmented baseline. The seg-mentation may be addressing issues with model sparsity, but it is also introducing errors that would have been impossible had words been left un-segmented. In fact, even with our lattice deseg-menter providing a boost, we are unable to see a significant improvement over the unsegmented model. As we attempted to replicate the approach of Clifton and Sarkar (2011) exactly by working with their segmented data, this difference is likely due to changes in Moses since the publication of their result. Nonetheless, the 1000-best and lattice desegmenters both produce significant improve-ments over the 1-best desegmentation baseline, with Lattice Deseg achieving a 1-point improve-ment in TER. These results match the established state-of-the-art on this data set, but also indicate that there is still room for improvement in identi-fying the best segmentation strategy for English-to-Finnish translation.

We also tried a similar Morfessor-based seg-mentation for Arabic, which has an unsegmented test set BLEU of 32.7. As in Finnish, the 1-best desegmentation using Morfessor did not surpass the unsegmented baseline, producing a test BLEU of only 31.4 (not shown in Table 1). Lattice deseg-mentation was able to boost this to 32.9, slightly above 1-best desegmentation, but well below our best MADA desegmentation result of 34.4. There appears to be a large advantage to using MADA X  X  supervised segmentation in this scenario.
 Table 1: Results for English-to-Arabic translation using MADA X  X  PATB segmentation.
 Table 2: Results for English-to-Finnish translation using unsupervised segmentation. 5.1 Ablation We conducted an ablation experiment on English-to-Arabic to measure the impact of the various fea-tures described in Section 3.4. Table 3 compares different combinations of features using lattice de-segmentation. The unsegmented LM alone yields a 0.4 point improvement over the 1-best deseg-mentation score. Adding contiguity indicators on top of the unsegmented LM results in another 0.6 point improvement. As anticipated, the tuner as-signs negative weights to discontiguous cases, en-couraging the re-ranker to select a safer transla-tion path when possible. Judging from the out-put on the NIST 2005 test set, the system uses these discontiguous desegmentations very rarely: only 5% of desegmented tokens align to discon-tiguous source phrases. Adding the desegmenta-tion score to these two feature groups does not im-prove performance, confirming the results we ob-served during development. The desegmentation score would likely be useful in a scenario where we provide multiple desegmentation options to the re-ranker; for now, it indicates only the ambiguity of a fixed choice, and is likely redundant with in-formation provided by the language model. 5.2 Error Analysis In order to better understand the source of our improvements in the English-to-Arabic scenario, we conducted an extensive manual analysis of the differences between 1-best and lattice deseg-
Features dev test 1-best Deseg 24.5 33.4 Table 3: The effect of feature ablation on BLEU score for English-to-Arabic translation with lattice desegmentation. mentation on our test set. We compared the output of the two systems using the Unix tool wdiff , which transforms a solution to the longest-common-subsequence problem into a sequence of multi-word insertions and deletions (Hunt and McIlroy, 1976). We considered adjacent insertion-deletion pairs to be (potentially phrasal) substitu-tions, and collected them into a file, omitting any unpaired insertions or deletions. We then sampled 650 cases where the two sides of the substitution were deemed to be related, and divided these cases into categories based on how the lattice desegmen-tation differs from the one-best desegmentation. We consider a phrase to be correct only if it can be found in the reference.

Table 4 breaks down per-phrase accuracy ac-cording to four manually-assigned categories: (1) clitical  X  the two systems agree on a stem, but at least one clitic, often a prefix denoting a prepo-sition or determiner, was dropped, added or re-placed; (2) lexical  X  a word was changed to a mor-phologically unrelated word with a similar mean-ing; (3) inflectional  X  the words have the same stem, but different inflection due to a change in gender, number or verb tense; (4) part-of-speech  X  the two systems agree on the lemma, but have selected different parts of speech.

For each case covering a single phrasal differ-ence, we compare the phrases from each system to the reference. We report the number of in-stances where each system matched the reference, as well as cases where they were both incorrect. The majority of differences correspond to clitics, whose correction appears to be a major source of the improvements obtained by lattice desegmen-tation. This category is challenging for the de-coder because English prepositions tend to corre-spond to multiple possible forms when translated into Arabic. It also includes the frequent cases involving the nominal determiner prefix Al  X  X he X  (left unsegmented by the PATB scheme), and the Clitical 157 71 79 Lexical 61 39 80 Inflectional 37 32 47 Part-of-speech 19 17 11 Table 4: Error analysis for English-to-Arabic translation based on 650 sampled instances. sentence-initial conjunction w+  X  X nd X . The sec-ond most common category is lexical, where the unsegmented LM has drastically altered the choice of translation. The remaining categories show no major advantage for either system. We have explored deeper integration of morpho-logical desegmentation into the statistical machine translation pipeline. We have presented a novel, finite-state-inspired approach to lattice desegmen-tation, which allows the system to account for a desegmented view of many possible translations, without any modification to the decoder or any restrictions on phrase extraction. When applied to English-to-Arabic translation, lattice desegmen-tation results in a 1.0 BLEU point improvement over one-best desegmentation, and a 1.7 BLEU point improvement over unsegmented translation. We have also applied our approach to English-to-Finnish translation, and although segmentation in general does not currently help, we are able to show significant improvements over a 1-best de-segmentation baseline.

In the future, we plan to explore introducing multiple segmentation options into the lattice, and the application of our method to a full morpho-logical analysis (as opposed to segmentation) of the target language. Eventually, we would like to replace the functionality of factored transla-tion models (Koehn and Hoang, 2007) with lattice transformation and augmentation.
 Thanks to Ann Clifton for generously provid-ing the data and segmentation for our English-to-Finnish experiments, and to Marine Carpuat and Roland Kuhn for their helpful comments on an earlier draft. This research was supported by the Natural Sciences and Engineering Research Coun-cil of Canada.
