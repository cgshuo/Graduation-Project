 We present a novel method for retrieval and classification of 3D building models that is tailored to the specific require-ments of architects. In contrast to common approaches our algorithm relies on the interior spatial arrangement of rooms instead of exterior geometric shape. We first represent the internal topological building structure by a Room Connec-tivity Graph (RCG). To enable fast and efficient retrieval and classification with RCGs, we transform the structured graph representation into a vector-based one by introducing a new concept of subgraph embeddings. We provide compre-hensive experiments showing that the introduced subgraph embeddings yield superior performance compared to state-of-the-art graph retrieval approaches.
 Categories and Subject Descriptors: H.3.1 Informa-tion Storage and Retrieval: Content Analysis and Indexing; H.3.3 Information Storage and RetrievalInformation Search and Retrieval; I.3.m Computer GraphicsMiscellaneous; I.5.m Pattern RecognitionMiscellaneous General Terms: Algorithms, Experimentation, Performance. Keywords: Graph-based Retrieval, Bag-of-Features, 3D Object Retrieval. 3D modeling has become a crucial ingredient of today X  X  architectural design process. Despite numerous tools, cre-ation of building models still remains a time consuming and expensive task, rendering reuse of existing models either for inspirational purposes or for integration into own drafts in-dispensable.To facilitate reutilization, efficient retrieval and classification strategies for building models are essential.
An important aspect in building retrieval is the interior building topology. We depict an early part of the plan-Figure 1: Architectural design chain. a) Schedule of spaces. b) Two possible arrangements of spaces. c) Result-ing buildings with floor plans. ning process in Figure 1. Starting the preliminary design of a building with a given schedule of spaces (1a), architects arrange rooms and their connections in graphs represent-ing topological structures (1b). These topologies strongly characterize buildings and express their internal organiza-tion [8]. In the next step, these abstract graphs are used as templates to develop concrete 2D floor plans, see Figure 1c (here overlaid with the 3D building models). Note that different floor plans can be generated out of the same sched-ule of spaces through early decisions concerning the topol-ogy and outer parameters like global building form. Rooms, their properties and groupings plus the chosen connections in between constitute certain structural patterns (see Section 3.2). Those patterns refer to building zones (e.g. private or public) and to building types [7].

To enable efficient retrieval and classification of building models according to their internal structure, we use recently introduced Room Connectivity Graphs [14] as descriptors and suggest a new efficient retrieval method. It uses derived high-level room type attributes that closely resemble an ar-chitect X  X  understanding of floor plans and a new vector-based representation of RCGs that is based on embeddings of at-tributed subgraphs. We compare the retrieval performance of our method to that achieved by human architecture ex-perts. Results show that our approach using subgraph em-beddings and high-level attributes is superior to other meth-ods in terms of retrieval and classification performance with respect to our suggested classification scheme. Note that in this paper we focus on the presentation of achieved retrieval and classification results. For a thorough introduction to our newly introduced subgraph embeddings we refer to [15].
In the following we briefly summarize three important methods for attributed graph similarity computation.
Edit Distances The basic idea behind graph edit dis-tances is to define graph dissimilarity by the minimum amount of deformation that is necessary to transform one graph into another [12]. Since determining the edit path is NP-hard [16], Riesen et al. [10] propose efficient approximate graph edit distances which are also an ingredient of our approach.
Graph Kernels Graph kernels [5] transfer techniques originating from statistical learning theory that are defined in terms of inner products to structured data. A common strategy in graph kernel design is to incorporate similarity of substructures like random walks, subtrees, cyclic patterns, or shortest paths [2, 4].

Graph Embeddings Graph embeddings transform struc-tural graph data into a vector-based representation. A graph is thereby defined in terms of its similarity to a codebook of graphs. Riesen et al. [11] compute Lipschitz embeddings using approximate edit distance [10]. Approaches based on embeddings of subgraphs instead of complete graphs are pre-sented in [1] and [9].
Following the description in [14], a RCG G =( V,E ) characterizes a single storey or a whole building according to the topology of the underlying floor plans. Attributed nodes v i  X  V represent rooms. Interesting and useful room properties range from low-level geometric attributes like e.g. area, height, perimeter, to high-level semantic attributes like room type (corridor, distributor, balcony, etc.). Edges e  X  E represent connections between rooms. They can be assigned low-level attributes like width, height, or high-level attributes like connection type (door, staircase, etc.).
For our approach, we use the algorithm by Wessel et al. [14] for automatic extraction of RCGs and low-level geomet-ric attributes from unstructured 3D polygon soups.
Node Attributes For each room node v  X  V , we repre-sent the following room properties in a feature vector a prop Conn ( v ) denotes the relative number of doors in this room with respect to the total number of doors in the storey. It represents how much the room contributes to the connectiv-ity of the storey. A global ( v ) globally characterizes the area of the room with respect to the area of the whole story, while A local ( v ) describes the area with respect to that of the sur-rounding rooms. The has window ( v ) property is an indi-cator for the amenity value of the room, e.g. living rooms always contain windows while corridors or lumber-rooms are often windowless. The perimeter-to-area ratio P 2 AR ( v )is used to identify corridor-like rooms. In many cases, corri-dors serving as distributors in a storey are stretched rela-tively long but are not very wide. In contrast, rooms with high amenity value tend to be more square-shaped.
Edge Attributes As in this work we concentrate on single storeys, we only need to consider edges represent-ing doors. It would be possible to additionally character-ize doors by their properties in a similar way as the room property vector. However, as our data mostly consist of res-idential buildings, the diversity of doors is relatively small, which is why we do not represent them more detailed.
Weintroducefiveclassesoffloortypesthatareofgreat importance to architectural planning processes because they notably comprehend the crucial question of room access and zoning of floors in interactive and private spaces. They fol-low common guidelines of this field, see e.g. [13].
Floor Types The corridor type (Figure 2a) is charac-terized by a corridor which is the dominant path through the storey. The corridor X  X  only purpose is to connect rooms, it has no amenity value. The distributor type (2b) is sim-ilar to the corridor type. However, a large room instead of a corridor serves as the connecting element. This room is often the biggest one of the storey, with amenity values itself. In a loft type floor (2c), the whole storey mainly consists of one large room which can contain several ad-justable zones with different functions. In a hierarchical floor (2d), there exists a separation between a dominant area which leads to further areas, where a second distribution is conducted. This second distribution can be either the previ-ously defined corridor or distributor type. Chain type (2e) floors are characterized by access rooms that are arranged like a chain, so that the connection only exists between one spaceandthenext.

Like Schneider [13] accurately described with the state-ment  X  X fter all, the truly exciting solutions often lie on the line between two or more of these categories[...] X , it has to be taken into account that some of the floors cannot be assigned to a category with absolute certainty, neither by machine nor human classifiers.

Predicting Room Types The introduced floor classes can be easily described using architectural terms that char-acterize room types like corridor, access room, or distrib-utor with amenity value. Our idea is to transform low-level geometric room attributes into high-level room types to better reflect an architect X  X  understanding of floor plans and thereby to improve retrieval and classification perfor-mance. We identify corridors ( C ), distributors ( D ), ac-cess rooms ( AR ), and one-door spaces (1 S ) as high-level room types that are crucial for floor charaterization. To automatically derive the high-level room type from the ex-tracted low-level attributes we use supervised learning. Let L = { C, D, AR, 1 S } denote the set of room types. Suppose we have a training set of low-level room attributes with as-signed labels l ( a prop ( v i ))  X  X  . We then use a support vector machine (SVM) to learn a discriminant function that maps geometric room attributes to room type classes. For in-creased robustness, we assign the rooms in the testing set a vector a label representing the predicted distribution over the room type labels rather than only the most likely one.
Ground Truth Generation For our learning approach we need ground truth, i.e. a set of low-level training at-tributes with assigned labels l ( a prop ( v i )) must be available. A possible way would be to assign the labels manually. How-ever, a training set of 100 RCGs can easily contain several thousand rooms, rendering this method cumbersome. We instead generate ground truth for a large number of rooms automatically. All graphs in the training set have been as-signed to one of the classes described above. By that, we can infer the assignment of single nodes to room types: Rooms in the corridor class with high connectivity (more than two doors) are likely to be corridors; rooms in the distributor class with high connectivity (more than two doors) are likely to be distributors; rooms with exactly one door not belong-ing to the loft class are one-door spaces; rooms with exactly two doors not belonging to the loft class are access rooms.
Note that we do not assign labels to all rooms because of ambiguities. E.g., highly connected rooms in the hierar-chical floor class might be either corridors or distributors, and the central room of a loft could be regarded as any of the above defined room types depending on its connectivity. Our assumptions are of course simplifications and only ap-ply to RCGs that are perfectly and uniquely assignable to a single class, which is not the case for all of our data.
In the following we introduce the two building blocks for subgraph embedding, decomposition into subgraphs and code-book generation. We finally describe how to construct the vector-based RCG representation
Subgraph Mining Following the results on efficient sub-graph mining presented in [6], we use two different sampling strategies, Forest Fire (FF) and Random Walk (RW) .FF sampling patterns look similar to those of a spreading fire. RWs on the other hand rather reflect chain-like structures similar to those generated by depth-first search.
Codebook Generation WesplitthesetofRCGsinto a training set used for codebook generation and a test set used for evaluation. Note that all RCGs originating from different storeys of the same building are always included in either of the sets to avoid overfitting. We then sample a cer-tain number of subgraphs from the samples in the training set and apply a k -medoid clustering using approximate edit distances [10] to generate the codebook graphs.

Subgraph Embeddings Consider a single RCG from the testing set. We first sample a number of n subgraphs in the above described way.We compute the approximate graph edit distance between each sampled subgraph and each code-book graph. Rather than characterizing subgraphs by their closest codebook graph, we describe them by a Gibbs distri-bution over the codebook for increased robustness leading to a Bag-of-Features representation.
We evaluate our approach based on subgraph embeddings against three other strategies regarding retrieval performance. For approximate graph edit distances , we compute the dis-tance between two RCGs based on the algorithm described in [10]. For Lipschitz embeddings , we split the set of graphs into a training set constituting the codebook and a test set.We compute the distance of all graphs in the test set to all codebook graphs using approximate edit distances, resulting in a vector of fixed length for each graph. The dis-similarity of two graphs is measured using the L 2 distance of the embeddings. We additionally evaluate the performance of exponential random walk kernels [2]. For our subgraph embeddings , we follow the description in Section 4 to com-pute a vector-based Bag-of-Features description for RCGs. Comparison of two RCGs is based on the L 2 distance of the embeddings. For more details on parameters for subgraph mining, codebook size and cross-validation we refer to [15].
Influence of Attributes Foreachmethodweevaluate low-level geometric attributes, high-level room types and the complete absence of room attributes. We additionally exam-ine the influence of neglecting edges when evaluating approx-imate graph edit distances, such that only room similarity is considered during matching. Note however that low-level and high-level room attributes contain implicit knowledge about adjacent edges.
Retrieval We first evaluate the retrieval performance of each method separately regarding the influence of attributes and topology, see precision-recall plots 3a-d. Note that for graph kernels (Figure 3c) we do not evaluate neglecting edges because construction of the adjacency matrix would not be possible. Using high-level room types instead of low-level attributes boosts the retrieval performance. We at-tribute this to the learned room types that are much closer to an architect X  X  understanding of floor plans than its geo-metric properties alone. Incorporation of edges during the matching in general improves results to a performance that cannot not be achieved using nodes alone.

In 3e we compare all four methods using the individually best setting with high-level room types and edges. Taking into account that floors cannot be assigned to a category absolutely certain, we additionally provide the averaged re-trieval performance achieved by three human classifiers all having an educational background in architecture. Approx-imate edit distances perform better than Lipschitz embed-dings for small recall values, for larger recall this tendency is inverted, which is consistent with the results described in (a) Aproximate graph edit distances including human classifier preformance (e).
 Table 1: Classification results. The table shows floor classification rates using graph embeddings and subgraph embeddings. [11]. The exponential random walk kernel perform worst, ex-cept for quite large recall values it is superior to approximate edit distances. Our method using subgraph embeddings per-forms better than the three other methods, especially for increasing recall. The human classifiers X  average retrieval performance is slightly worse than the automatic methods for small recall values but unambigously superior for recall values larger than 0 . 2. Human classifiers are always superior if no room types are learned.

Classification We additionally evaluate the classification performance of vector-based subgraph and Lipschitz embed-dings using standard C-SVM with RBF kernel [3], see Ta-ble 1. For every feature setting, subgraph embeddings per-form better than Lipschitz embeddings. Using predictions of room types based on geometric room attributes boosts the performance. Additionally, combining topology and pre-dicted room types leads to better results than using only topology or only room attributes or their derived floor types.
We introduced a new approach for retrieval and classifi-cation of building models based on their internal structure that is represented by RCGs. The method adopts the Bag-of-Features paradigm and transfers it to structured data described by attributed subgraphs. We additionally pro-posed a method to substitute low-level geometric room at-tributes by high-level room type predictions. Our evaluation showed that our method using subgraph embeddings and high-level attributes results in improved retrieval and clas-sification performance compared to three other methods.
Future work should investigate the extension from RCGs representing single storeys to graphs representing complete buildings. Analogously, the classification scheme should be extended to floor plan classes covering several storeys (e.g. maisonette, split-level). Additionally, the influence of fur-ther geometric attributes should be examined.

Acknowledgements This work was partially supported by the German Research Foundation (DFG) under grants KL 1142/8-2 and INST 1647/14-1 ( www.probado.de ). [1] E. Barbu, P. H  X eroux, S. Adam, and  X  E. Trupin. Using [2] K. M. Borgwardt. Graph Kernels . PhD thesis, [3] C.-C. Chang and C.-J. Lin. LIBSVM: a library for [4] T. G  X  artner. Kernels for Structured Data . PhD thesis, [5] D. Haussler. Convolution kernels on discrete [6] J. Leskovec and C. Faloutsos. Sampling from large [7] W. Meyer-Bohe. Grundrisse  X  offentlicher Geb  X  aude. [8] W. J. Mitchell. The Logic of Architecture: Design, [9] B.  X  Ozdemir and S. Aksoy. Image classification using [10] K. Riesen and H. Bunke. Approximate graph edit [11] K. Riesen and H. Bunke. Graph classification by [12] A. Sanfeliu and K. Fu. A distance measure between [13] F. Schneider. Floor Plan Manual Housing .Birkh  X  auser, [14] R. Wessel, I. Bl  X  umel, and R. Klein. The room [15] R. Wessel, S. Ochmann, R. Vock, I. Bl  X  umel, and [16] Z.Zeng,A.K.H.Tung,J.Wang,J.Feng,and
