 XML documents are frequently used in applications such as business transactions and medical records involving sensitive information. Typically, parts of documents should be visible to users depending information part of a medical document but not the details of the patient X  X  medical history. Access control on the basis of data location or value in an XML document is therefore essential. In practice, the number of access control rules is on the order of millions, which is a product of the number of document types (in 1000's) and the number of user roles (in 100's). Therefore, the approaches to access control over XML documents have suffered from scalability problems because they tend to work on individual documents. In this paper, we propose a novel approach to XML access control through rule functions that are managed separately from the documents. A rule function is an executable code fragment that encapsulates the access rules (paths and predicates), and is shared by all documents of the same document type. At runtime, the rule functions corresponding to the access request are executed to determine the accessibility of document fragments. Using synthetic and real data, we show the scalability of the scheme by comparing the accessibility evaluation cost of two rule function models. We show that the rule functions generated on user basis is more efficient for XML databases. H.3.4 [ Information Storage and Retrieval ]: Systems and Software  X  Performance evaluation (efficiency and effectiveness) ; H.3.4 [ Information Storage and Retrieval ]: Information Search and Retrieval  X  Information filtering XML database, access control, fine-grained access control, expressiveness, rule functions The Extensible Markup Language [7] is widely used for data presentation, integration, and management because of its rich data structure. In applications such as business transactions and medical records, sensitive data may be scattered throughout an XML document and access control at the node level (element or attribute) authorized users. Access control must be expressive and be able to order of millions, which is a product of the number of document types (in 1000's) and the number of user roles (in 100's). Therefore, the solution requires high scalability and performance. Several XML access control models [4, 11, 17, 23] provide expressive access control over XML documents. These approaches usually support grant or denial access control specifications, a propagation mechanism whereby descendant elements inherit rules from their parents, and conflict resolution in case the data is covered by multiple access control rules. Since these models perform access control by traversing XML documents at runtime, the enforcement imposes heavy computational costs especially for deeply layered XML documents with large expressive access control rules. Ideas to efficiently provide expressive access control were proposed in [3, 9, 12, 30]. They are effective in searching for access-controlled nodes [3, 12, 30], or in eliminating unnecessary accessibility checks at runtime [9]. These research efforts managed to improve the efficiency of expressive access control; but since they generally focused on document-based optimizations, XML databases with frequent updates of either the documents or a ccess control rules may incur unacceptable costs. In our previous research [28], we proposed an efficient table-driven access control model that takes into acc ount XML document updates. It provides runtime efficiency but has limitations on access control expressiveness. In this paper, we develop an efficient expressive access control model applicable to existing access control models [4, 11, 23] for XML documents. The novelties of this access control model are the high scalability and the high performance. The key idea is to encode the access control rules as a set of rule functions that separately perform the actual access evaluation. Moreover, the rule functions are grouped to conserve memory and facilitate updates. We propose two scalable rule function models: one where each rule function encodes the access rules for a given node, and another where a rule function encodes the access rules for a given user subject. Rule functions are grouped, and the grouping information is stored in a system-global mapping table. Moreover, an accessibility cache is prepared to improve runtime performance. Given an access request, the corresponding rule functions are looked up in the mapping table and executed to determine the accessibility of the node, or if a result already exists in the cache, the result is returned directly and the function execution is skipped. Since only the required rule functions are loaded from disk to main memory, this model enables the access control system to s upport both large and As far as we know, our function-based approach is the first one that is capable of supporting millions of access control rules efficiently. The rest of this paper is organized as follows. After reviewing some preliminaries in Section 2, we introduce our function-based access control model in Section 3. Section 4 describes how to generate rule functions from the access control policy. Runtime access control enforcement using rule functions and runtime optimizations are introduced in Section 5, and experimental results are reported in Section 6. Extending XML access control to secure workflows is discussed in Section 7, and in Section 8 we summarize our conclusions and future work. Many approaches for enforcing XML access control have been proposed. Some of them [17, 23] support full XPath [10] expressions to provide expressiveness with na X ve implementations by creating the projection of the access control policy on a DOM [19] tree. However, these approaches incur massive runtime costs when handling a large access control policy or a deeply layered XML document. The mechanisms proposed in [2, 4, 11, 12] perform more efficiently but also encounter the same problem at runtime since the node-level access control on a DOM-based view can be expensive when processing large numbers of XML documents. To overcome this problem, several efficient access control models have been proposed [25, 28]. Qi et al. [28], our previous research, presented a method that performs in near-constant time regardless of the number of access control rules. This is achieved by using an independently of the XML data and XML documents. However, this approach places limitations on the XPath expressions, and does not provide an efficient runtime evaluation mechanism for value-based conditions. Murata et al. [25] optimized the pre-processing steps by minimizing the number of runtime checks for determining the accessibility of nodes in a query with automata. However, the mechanism is limited to XPath-based language (i.e. XQuery [6]) and cannot handle other query languages and primitive APIs such as DOM. XPath-based document filtering systems [1, 8, 14] also provide value-based access control enforcement and independence of XML data through a pre-computed data structure. However, these approaches focus more on data filtering rather than data selection. For example, they cannot specify denial of access on document completely satisfy the needs of real XML database applications. A different approach with document-based optimizations was proposed by Yu et al. [30]. Their scheme enforces efficient access control with an accessibility map generated by compressing neighboring accessibility rules to improve cost efficiency. However, since the maps are generated on a document-basis, document updates or policy updates may trigger expensive re-computations especially for a large XML database. Optimizations were also done in a number of research efforts on XML query languages (e.g., XPath and XQuery). The methods include query optimization based on (i) the tree pattern of queries [9, 13, 27]; (ii) XML data and XML schema [16, 21, 22, 24]; and (iii) the consistency between integrity constraints and schemas [15]. However, these usually perform efficient data selection usually on a document-basis and require indices. Therefore, in a large XML database, for instance, a database with 10,000 document collections and 10,000 documents for each document collection, such optimization mechanisms may consume a prohibitive amount of space. Moreover, these tec hnologies are designed for XQuery and they cannot handle other query languages and primitive APIs such as DOM. Various access control policy models have been pr oposed. We use the one proposed by Murata et al. [25] in which an access control Permission Action, Object&gt;. group . Permission  X + X  stands for a grant rule while  X - X  means denial. The action value can be either read (r or R), update, create, or delete. others can be implemented with the same mechanisms. The rule with +R or  X  X  propagates read permissions (grant or denial) downward to the entire sub-tree, while +r grants a permission on the selected node only. As an example, (uid:Seki, +r, /a) specifies that user Seki is allowed to access /a but access to /a/b is implicitly denied since grant is not propagated down to the descendants of /a. Moreover, according to the denial downward consistency principle [25] that stipulates that the descendants of an inaccessible node are also inaccessible, there is an accessibility dependence between ancestors and descendants. Therefore, it is obvious that  X  X  and  X  X  are equivalent, and thus we specify denial rules only with  X  X  in this paper. In addition, in order to maximize data security, we (i) resolve access conflicts with the denial-takes-precedence principle [25], and (ii) apply the default action of denying permission on paths that have no explicit or implicit access control specified. There are two traditional models for access control enforcement: ACL (access control list) [29] and Capability [5, 18, 20]. In the ACL model, the authorities are bound to the Objects being secured; in the Capability model, the authorities are bound to the Subjects, those seeking access. Henceforth, we use the notation Rule(sub, act, obj) to describe the access control rule &lt;sub, act, obj&gt;. S uppose ACL(obj access control list for obj k , while Policy represents the access control policy containing m objects. ACL(obj k ) and Policy are as follows: 
ACL(obj k ):= {Rule(sub 1 , act 1 , obj k ), ..., Rule(sub
Policy := {ACL(obj 1 ), ..., ACL(obj m )} paper, we use the above syntax for simplicity. Access control for subject sub k is represented as Cap(sub Capability model. Cap(sub k ) and Policy with s subjects are as follows: 
Cap(sub k ) := {Rule(sub k , act 1 , obj 1 ), ..., Rule(sub
Policy := {Cap(sub 1 ), ..., Cap(sub s )} . In this section, we describe a function-based access control model and an evaluation algorithm. In our approach, the access control policy is converted into a set of rule functions expressed in a programming language. In this section, we present three types of rule functions, ORF, SRF and GRF with several model components. Then we explain how the rule functions enforce access control on ACL/Capability models. A rule function is the basic element that performs access control on a specific object or a specific subject. In our model, we define the following three types of rule functions. Definition Object-driven Rule Function (ORF) is a function indexed runtime, ORF receives the relevant attribute(s) of a subject for a given access request and returns an evaluation result to the caller according to the algorithm of the ORF . Definition Subject-driven Rule Function (SRF) is a function indexed accessed path and returns an evaluation result to the caller on the basis of the algorithm of the SRF . Definition General Rule Function (GRF) is an extended rule GRF may place arbitrary c onditions on either the subject or object when determining accessibility and, as such, we use it to encode rules that cannot be bound to a specific ORF or a specific SRF. For instance, we use GRFs to process rules containing //, as these cannot be mapped to a single ORF. The concept of the ORF is close to the ACL, while the SRF can be mapped to the Capability approach. However, our rule functions return four types of evaluation results that extend these traditional models to the main current access control model. We examine these differences more closely in Section 3.5. Given a requested path or the subject of a request, the rule function returns an evaluation result in accordance with both the action permission and the propagation property of the appropriate rule. There are four types of evaluation results as Table 1 shows. GRANT_ON_NODE, and by GRANT_ON_SUBTREE which propagates access permissions to the sub-tree. When access is denied, the evaluation result of the descendants is also DENY due to the denial downward consistency principle. UNDECIDED is returned when the accessed path is not covered by any rule. Access is denied by default if no further access control is specified. A mapping table is the key component that connects an access request to the appropriate rule function(s) for accessibility evaluation. We define the following mapping tables. Definition ORF Mapping Table The ORF mapping table maps a given access path to one or more applicable ORF functions indexed by a package name and a class name. Definition : SRF Mapping Table The SRF mapping table maps a given subject of an access request to one or more applicable SRF functions indexed by a package name and a class name. Based on the defined components (rule functions, evaluation results, and mapping tables), our model computes a decision result of an access request based on the following algorithms. The requirement of our approach is: The access control policy must be consistent, so accessibility s hould be accessible as well. z ORF Algorithm Given the path and subject of a request, the corresponding entry is looked up in the ORF mapping table. If the corresponding entry exists, the ORF name is looked up. Otherwise, the ORF name of its closest ancestor is looked up. Since the accessed path is implicitly decided on the basis of the propagation information carried with the evaluation result returned from the ancestral ORF. In accessibility evaluation, a GRF is executed first. If the GRF returns DENY, the decision result is already decided and the ORF method is not executed. Otherwise, the ORF method is invoked and executed for a decision result. According to the access control policy, multiple applicable functions may be bound to a request. To produce the final decision result, we need to combine individual evaluation results. This is done in accordance with the denial-takes-precedence . z SRF Algorithm The SRF algorithm is much simpler than the ORF algorithm. Given the path and the subject of the request, the corresponding entry is looked up in the SRF mapping table. If the corresponding entry exists, the SRF with that name found in the table is invoked and executed. Otherwise, the decision result is DENY by default. Our rule function model is different from the ACL and Capability models in three aspects. First, we have the new component concept of GRF. GRF is introduced to handle rules that cannot be bound to a specific ORF or a specific SRF. Suppose ORF(obj k ORF for the rules sharing obj k , and SRF(sub j ) represents the SRF for the rules specified for sub j . When 1  X  k  X  m and 1 control policy can be converted as: 
Policy := { GRF, ORF(obj 1 ), ..., ORF(obj k ), ..., ORF(obj In the access control policy model we have a dopted, subjects are specific and therefore GRF is not required in the SRF-based model. However, GRF would be necessary in an application that distinguishes accesses from the IP address and provides domain-specific access control rules. Second the traditional ACL/Capability models focus on access control enforcement selected by simple paths. In contrast, our ORF-and SRF-based models are capable of handling access controls involving // and predicates that expand the expressiveness of the access control system. Third unlike the positive authori zation of the ACL/Capability models, ORFs and SRFs handle both positive and negative authorizations. During access control, evaluation results returned by the rule functions are combined to calculate the decision result. If an authorization conflict occurs, it will be resolved during the combination. These three points highlight the observation that our model extends the traditional ACL/Capability models by providing improved expressiveness. Access control rules are converted to a group of ORFs or a group of SRFs. During the conversion, both simple paths and paths involving // and predicates are coded as rule functions. An access control policy is combined in one of four basic ways: (+r), (+R), (+R, +r), and (-R, +R, +r), while (-R, +r) and (-R, +R) can be covered by (-R, +R, +r). Since various rules are for the same subject with the denial-take-precedence principle and the propagation mechanism, the execution order of the converted rules in the SRF directly decides the accessibility result. Suppose that path p consists of k nodes from n 1 to n root node. dependency is guaranteed, it is only necessary to check whether /n /n 2 /.../n k is specified with +r. The conversion order is random. 2) (+R): all of the rules are specified with +R. It is clear that access to the descendants is granted if one or multiple ancestors are specified with +R. Therefore, the order of checking whether an object is an ancestor of the requested path is random. 3) (+R, +r): the rules are specified with either +R or +r. Suppose at and both n i and n j are ancestors of n propagation from n i , n k is granted without respect to the relationship between n i and n j . When i=k or j=k , it is obvious that n policy, the code that checks for +R should come first to check whether or not the requested path is a descendant of one of these objects. Then the code that checks for +r are continues running. Next, in accord with 1), and 2), the orders in each gr oup of +R or +r can be random. 4) (-R, +R, +r): the rules are specified with  X  X , +R, or +r. Owing to denial-take-precedence, the codes for  X  X  come first to check whether the requested path is the descendant of these objects. Then, based on 3), continue with the rules with +R, and then +r. As a consequence, the rules are converted into code fragments in the order of  X  X , +R, and then +r, thus satisfying the accessibility dependency of the policy. In the ORF-based model, the access control policy is first sorted by objects. For each object and subset of rules corres ponding to that object, an ORF is produced containing code that implements those rules. Inside the ORF, the rules are distinguished by the subject, and the corresponding evaluation result is coded as the return value when the subject matches the requester. As an example, we have a rule subset of the access control policy P1 contains (1) Rule(sub +r, /a) (2) Rule(sub p , +R, /a). Figure 1 shows the Java fragment of ORF for P1. The SRF-based model differs from ORF in that it sorts the access control rules by subject. An SRF is generated corresponding to the distinguished by the object, and the corresponding evaluation result is coded as the return value when the accessed path satisfies the object condition. Figure 2 shows the SRF for (1) and (2). A path expression containing // selects nodes whose position in the data structure is not known precisely and therefore the path may map clear that ORF cannot handle rules involving //. Instead, we use the GRF to handle rules that cannot be mapped to a specific ORF. In our implementation, a GRF is generated as a global rule function of a Java class in which the requested path is matched against rules containing //. The matching is done using regular expressions and Rule(sub p , -R, /a//d) . The GRF is generated as shown in Figure 3. For the SRF-based model, since the subject in our model is specific, each rule can be bound to a specific SRF. Therefore, rules involving // are handled in the SRF for the subject. Figure 4 shows the corresponding SRF handling the rules (2) and (3). The code for (3) is executed before (2). An SRF is also different from an ORF in that inside of each rule function the denial rules are listed first, followed by the grant rules. An object containing a predicate(s) is first pre-processed by model, the Java code representing pred is generated inside ORF(p) . the rule function for the subject. A predicate is a condition comparing XML data or a conjunction of such conditions. The comparisons are performed through the mathematical relational operators, =, &lt;,  X  , &gt;, and ORF and SRF models, these mathematical operators are translated to Java code to enforce predicate evaluation. Since predicate evaluation requires XML data stored in the XML database, the data referenced Therefore, an API, retrieveData , is provided to retrieve the required data from the DBMS. The API retrieveData has two parameters: the requested node name n , and the path expression p of the node imposed by the predicate. Since at runtime the DBMS has the position information pos of the requested node, the position of n can be found by traversing from pos to p . For example, we may have a Record document type which contains order details. Each order is identified with a unique customer ID, the CustKey element. To guarantee that a customer can only see their own order details, the access control policy P2 can be In P2, $custID is a system variable which is automatically set when a obtainSystemData which is another API returning the value of the system global variables. Assuming that the object DataCenter implements both APIs, the Java program fragment for handling the predicate evaluation is as shown in Figure 5. On the other hand, if the rule contains multiple predicates, the conjunction of the predicates is encoded inside the rule function. The function-based access control system was constructed through Access Control Modeling and Model Deployment as shown in Figure 6. The system separates the access control from the database engine so that security-related support is not required from the underlying database. This permits any XML DBMS, even off-the-shelf products, to provide scalable access control. In Access Control Modeling, the access control policy is converted to Java classes where each class represents the access control rules for a specific number of subjects or objects. During this modeling, the corresponding mapping table is generated as well. In addition, the Java code fragments are compiled into bytecode so that they can be executed. Another process, Model Deployment, initially loads the Java mapping table into main memory, and then prepares another empty system global table, inMemTable , that stores in main memory the Since each function gr oup has a unique name, inMemTable uses the group name as a key and associates it with the corresponding object instance. At runtime, given an access request containing a subject and a simple path expression, the access control system runs the evaluation to get the decision result. If the access evaluation returns DENY, the access denied res ponse will be sent back to the user without data retrieval from the XML database. Otherwise, the output is generated after retrieving the data value from the database and returned to the user. Caching can be employed in both the access control system and the DBMS to reduce the costs of the accessibility evaluations. However, we only address internal caching, and the cache mechanisms on the application side are beyond the scope of this paper. When the accessibility status of a path remains unchanged even if the XML data changes, the result of the accessibility evaluation can be cached, thereby improving runtime performance. This is particularly beneficial if a path appears multiple times in an XML document(s), or in a document type, because obtaining the system to skip the duplicated accessibility evaluations. The accessibility cache is a table of 3-tuples: subject, path, and accessibility result. During evaluati on, if neither // nor predicate accessibility cache table. Otherwise, for both // and predicates involving data values in the XML document, the accessibility evaluation is performed at every access. We show an example on the basis of the access control policy P4. The initial status of the global mapping table T1 on the ORF model is shown in Table 2. For simplicity, each Java class contains 50 roles. Note the entry for (4) does not appear in T1 since it is handled in the GRF. When sub k attempts to access /a/b, since the accessibility cache table is empty, an accessibility evaluation is required and thus T1 is looked up. A match is found in the third entry, and so the ORF1 method in class Class_1 of package Package_1 is invoked to evaluate the access permissions of sub k for /a/b. However, Class_1 is not in main memory ow ing to its absence in inMemTable . Therefore the class loader loads Class_1 in Package_1 into memory and creates an instance with a name, for example class_1 . A new entry (Class_1, class_1) is inserted into inMemTable . The for sub k , the GRF method returns UNDECIDED . Then ORF1 is executed, it returns the value GRANT_ON_NODE , and a new entry (sub k , /a/b, GRANT_ON_NODE) is added to the accessibility cache. request of sub k to /a/b is granted. Next, sub k continues with an access to /a/b/g/h. Since /a/b/g/h is absent from both the accessibility cache and T1, the T1 entry of the closest ancestral path /a/b is looked up instead. The accessibility cache table is looked up with /a/b and the entry (sub GRANT_ON_NODE) is found. Since grant is applied only on /a/b without downward propagation, sub k  X  X  access to /a/b/g/h is denied. performance of our function-based access control mechanism for XML documents. All of the experiments are conducted on machine with 1.8GHz Pentium 4 CPU, 1.5GB of main memory, and IBM JDK1.4.2. We use two XML document types in our experiments. The first one, Orders , is a real data set describing business transactions, and we prepare two different-size documents of that type (100KB and 4MB). The other type is XMark benchmark data where we use a 111MB standard.xml . Both document types contain sub-trees with a similar structure occurring repeatedly at the same level. The main purpose of this experiment is to see whether the function-based model can support large access control policies. For simplicity, we specified 2,000,000 access control rules for 80, 000 set of 25 access control rules specified with simple path expressions and +r. We vary the group size from 50 to 100, and hence the 2,000,000 function-based models manage to load all of the rules into the main memory in a random order without any Java garbage collection (GC) being triggered. The memory cost is independent of group size and is close to 53MB for the ORF-based system and 58MB for the SRF-based system. The SRF consumes more memory since the path expressions are represented simply as strings in the rule functions, while the ORFs contain the subject string which is much smaller than path expressions. However, as a tradeoff, the ORF mapping table is several megabytes larger than the SRF mapping table because the former has 2,000,000 entries while the latter has only 80,000. As a consequence, the total memory costs are quite similar for both types of rule functions. In many access control systems, it is necessary to s upport access control for large XML documents whose sizes may reach to several hundred megabytes. In this experiment, we show the performance of the system by examining the tota l processing time when the XML documents shown in Table 3 are accessed. standard.xml 111MB 1,666,315 514 99.97% For each subject, we specify 25 access control rules for Orders.xml , and 514 rules for standard.xml . All rules are specified with a +r permission. Both documents contain repeated sub-structures and so part of the access control is duplicated at multiple locations. In Table 3, the fraction of duplicated paths is shown as the D-rate and we can see that standard.xml has more duplicated sub-trees than Orders.xml . We use the SAX API of the XML parser to parse the entire document, and check the accessibility when enc ountering either an element or an attribute. The processing time includes XML parsing time, Java class loading time, access control time, and GC time if any GC occurs. In this experiment, we label the total time excluding parsing time as AC Time. We also measure the performance improvement achieved with caching. In Figure 7 and Figure 8, the processing times of the entire documents are shown. From the figures, it is clear that the accessibility cache makes a significant improvement in processing time. For Orders.xml , the accessibility cache reduces the AC time by almost 50%. In the case of standard.xml , the AC time is reduced to by 60-70%. Since the accessibility cache is more effective when processing standard.xml . It is also obvious that the documents containing more path types require more time for access control. The downward propagation mechanism is convenient in access control specifications because we do not need to specify positive authorizations for each of the descendants. On the other hand, // provides a flexible access control mechanism to control nodes independently of their levels. This experiment examines the runtime performance of rules involving R and //. The accessibility cache was disabled for both function models in this experiment. In the experiment, we compare the access control cost of r, R, and //. For r, we used the access control policy by specifying +r on each Rule(user:User1, +R, /Orders) and Rule(user:User1, -R, /Orders//Item) . In the experiment, every one of the 3,247 nodes (paths) in the 100KB Orders.xml is checked and the average access control processing time on the path is measured. The numbers exclude XML parsing time and assume a warm execution (class files reside in memory without loading from the disk). Figure 9 shows the performance comparison between r, R, and //. For r, SRF performs about 5% better than ORF, which is negligible. The access control cost on a simple path is less than 3 microsec onds per path for both the ORF and SRF models. For R, both ORF and SRF cost around 2.2 microseconds per path, which is 20% less than for r. We also see that the accessibility check involving // requires 5 to 5.5 microseconds (180K+ per second) per path compared to the 2.2 microseconds of R. This demonstrates the performance advantage of R as compared to r and //. Therefore, when the accessibility results are the same, this suggests that R should be used where possible. Access control policies P2 presented in Section 4.4 and other policies containing multiple predicates are used to measure the performance of predicate evaluation. Since the performance of data retrieval from the XML database depends on the performance of the experiment. The accessibility cache was disabled in this experiment and the results show that the processing time is identical to the performance seen with simple paths: 2.2 to 3 microseconds per path. The cost was independent of the number of predicates. In this paper, we have proposed a function-based model for providing expressive and scalable access control for XML databases. We first presented two rule functions, ORF and SRF, which return accessibility results in res ponse to requests containing paths and subjects. We then described the accessibility evaluation mechanism involving a global mapping table that maps the request to the appropriate rule function. High scalability is achieved by grouping rule functions into Java classes and further organizing classes into packages. Each class is the unit for memory management and policy update. To improve performance, we enhance the access control system with a cache mechanism that eliminates the need for function invocations when the same path is accessed repeatedly by the same user. To demonstrate the scalability and efficiency of the proposed model, we perform experiments using synthetic and real XML documents. Experimental results show that the function-based model supports 2,000,000 rules without triggering Java garbage collection and can perform accessibility checks in 3 microseconds per path (300K+ evaluations per second) on commodity hardware. This model also microseconds per invocation. An accessibility cache further improves performance by a factor of 2 to 4. In future work, we plan to explore deeper into the efficiency of ORF and SRF models to examine specific conditions for each model. We also plan to explore the generation of efficient rule functions by sharing more Java code inside th e rule functions, leading to lower memory usage and more efficient class loading. Moreover, we plan to provide an efficient rule function update regarding to policy updates, and extend the predicate evaluation mechanism so that fewer database queries are made to retrieve the data values required for predicate evaluation. [1] M. Altinel and M. Franklin: Efficient filtering of XML documents for selective dissemination of information. VLDB (2000) pp.53-64. [2] E. Bertino, S. Castano, E. Ferrari, and M. Mesiti: Controlled access and dissemination of XML documents. ACM WIDM (1999) pp.22-27. [3] E. Bertino, S. Castano, E. Ferrari, and M. Mesiti: Specifying and Enforcing Access Control Policies for XML document Sources. World Wide Web Journal (2000), Vol. 3, No. 3, pp. 139-151. [4] E. Bertino and E. Ferrari: Secure and selective dissemination of XML documents. ACM TISSEC (2002) pp.290-331. [5] M. Bishop, and L. Snyder. The transfer of information and authority in a protection system. Proc. 17th ACM Symposium on Operating Systems Principles , 1979. [6] S. Boag, D. Chamberlin, M. F. Fernandez, D. Florescu, J. Robie, and J. Simeon: XQuery 1.0: An XML query language, W3C Working Draft 12 November 2003. http:// www.w3.org/TR/xquery/. [7] T. Bray, J. Paoli, and C. M. Sperberg-McQueen: Extensible Markup Language (XML) 1.0. W3C Recommendation. http://www.w3g.org/TR/REC-xml (Feb. 1998). [8] C.-Y. Chan, P. Felber, M. Garofa lakis, and R. Rastogi: Efficient filtering of XML documents with XPath expressions. ICDE (2002) pp.235-244. [9] S. Cho, S. Amer-Yahia, L.V.S. Lakshmanan, and D. Srivastava: Optimizing the secure evaluation of twig queries. VLDB (2000) pp.490-501. [10] J. Clark and S. DeRose: XML Path Language (XPath) version 1.0. W3C Recommendation. Available at http://www.w3g.org/TR/xpath, 1999. [11] E. Damiani, S. De Capitani di Vimercati, S. Paraboschi, and P. Samarati: Design and Implementation of an Access Control Processor for XML documents. WWW 9 (2000). [12] E. Damiani, S. De Capitani di Vimercati, S. Paraboschi, and P. Samarati: A Fine-Grained Access Control System for XML Documents. ACM TISSEC (2002) pp.169-202. [13] A. Deutsch and V. Tannen: Containment of regular path expressions under integrity constraints. KRDB (2001). [14] Y. Diao, P. Fischer, M. Franklin, and R. To.: YFilter: Efficient and scalable filtering of XML documents. Demo at ICDE (2002) pp.341. [15] W. Fan and L. Libkin: On XML integrity constraints in the presence of DTDs. Symposium on Principles of Database Systems (2001) pp.114-125. [16] M.F. Fernandez and D. Suciu: Optimizing regular path expressions using graph schemas. ICDE (1998) pp.14-23. [17] A. Gabillon and E. Bruno: Regulating Access to XML Documents. Working Conference on Da tabase and Application Security (2001) pp.219-314. [18] L. Gong: A Secure Identity-Based Capability System. Proc. IEEE Symposium on Security and Privacy , pp.56-65, 1989. [19] A.L. Hors, P.L. Hegaret, L. Wood, G. Nicol, J. Robie, M. Champion, and S. Byrne: Document Object Model (DOM) Level 3 Core Specification. http://www.w3.org/TR/ 2004/PR-DOM-Level-3-Core-20040205 (2004) [20] A.K. Jones, R.J. Lipton, and L. Snyder. A Linear Time Algorithm for Deciding Security. Proc. 17th Symposium on Foundations of Computer Science, Houston, Texas, pp. 33-41, 1976. [21] R. Kaushik, P. Bohannon, J.F. Naughton, and H.F. Korth: Covering indexes for branching path queries. ACM SIGMOD (2002) pp.133-144. [22] D.D. Kha, M. Yoshikawa, and S. Uemura: An XML Indexing Structure with Relative Region Coordinate. ICDE (2001) pp.313-320. [23] M. Kudo and S. Hada: XML Document Security based on Provisional Authorization. ACM CCS (2000) pp.87-96. [24] Q. Li and B. Moon: Indexing and Querying XML Data for Regular Path Expressions. VLDB (2001) pp.361-370. [25] M. Murata, A. Tozawa, M. Kudo and H. Satoshi: XML A ccess Control Using Static Analysis. ACM CCS , 2003. [26] OASIS. OASIS Extensible Access Control Markup Language (XACML), Feb. 2003. http:// www.oasis-open.org/committees/xacml/docs. [27] F. Neven and T. Schwentick: XPath containment in the presence of disjunction, DTDs, and variables. ICDT (2003) pp.315-329. [28] N. Qi and M. Kudo: A ccess-condition-table-driven access control for XML databases. ESORICS (2004). [29] R.S. Sandhu, E. J. Coyne, H.L. Feinstein, and C.E. Youman. Role-Based Access Control Models. IEEE Computer , Volume 29, No 2, pp.38-47, February 1996. [30] T. Yu, D. Srivastava, L.V.S. Lakshmanan, and H.V. Jagadish: Compressed Accessibility Map: Efficient Access Control for XML. VLDB (2002) pp.478-489. 
