 With the rapid growth of services on the Internet, a large amount of personal information is being stored and exploit ed for personalized online services. For example, online bookshops suggest that  X  X ustomers who bought this book also bought these books X . As another example, search engines offer personalized search services that reorder search results based on the history of past searches to give more weight to topics that interest each searcher.

If such distributed personal information is integrated among numerous users, variable knowledge for users would be extracted. However, it is pointed out that the combination of personal information can identify individuals with high probability, even when identifiers are removed from personal information[1]. As a technology to extract valuable knowledge from distributed private data sources without disclosure of them, privacy-preserving data mining (PPDM) has at-tracted attention. Many well-known data mining algorithms have been modi-fied to preserve the privacy of distributed datasets, for example, decision-tree learning[2], association rule mining[3], and k -means clustering[4].
Conventionally, public or private organizations that collect a large amount of personal information are assumed to be PPDM participants. They are re-sponsible for privacy preservation and the PPDM is conducted only when these organizations reach an agreement. We designate this framework as server-centric privacy preservation . Server-centric privacy preservation mainly assumes com-putations among relatively small number of participants and is well-suited to mining between enterprises. Nevertheless, problems persist, mainly from the per-spective of intrinsic owners of personal data.

Consider a PPDM using two databases managed by an online book shop and an online music store. They independently manage personalized recommendation systems based on clients X  personal prefer ences extracted from p ersonal purchase histories. Customers might want to know  X  X ustomers who bought these books and music also bought these books and music X . However, these two shops might not reach agreement for the PPDM beca use it might not benefit each other through integration of their databases (imagine these two shops are in a com-petitive relationship). This indicates that customers miss opportunities to enjoy more sophisticated personalized servi ces because individuals cannot lead PPDM using their own personal information at their own initiative.

As a contrasting privacy preservation concept, we specifically investigate user-centric privacy preservation . This framework assumes that users store personal information in their local storages not in enterprise databases. If users believe that valuable knowledge would be extracted from the collection of their personal information, they can freely establis h or join a session for PPDM and can enjoy data mining without disclosing personal information. For this framework, we present a novel protocol for k -means clustering in this paper. The cross-domain personalized recommendation service is one of motivating applications of this framework. Clustering from combinations of various personal information, such as histories of geographical movement, purchase, web search, and web browsing, is expected to provide more sophist icated personalized services.
 Little difference separates s erver-centric and user-centr ic privacy preservation. However, the number of parties to be processed is considered to be much larger in user-centric model than in s ever-centric model. The num ber of parties is typically assumed to be two in server-centric model; however, we assume 10  X  10 6 parties in user-centric model. In such a large-scale network, both the scalability and the treatment of uncerta in networking environment, such as asynchronism and fault-tolerance, are important. To overcome these difficulties, our protocol assumes a network in which users can directly co mmunicate with each other like Peer-to-Peer (P2P) network. Our contribution is mainly on following two protocols: 1. private Asynchronous Average Computation (AAC): This protocol is a cryp-2. private Nearest Cluster-center Determination (NCD): This protocol privately Based on these protocols, our protocol is constructed. The computational com-plexity of our protocol is O (log n ) with respect to the number of parties n .In addition, the computation i s decentralized over each no de almost asynchronously in a fault-tolerant manner.
The remainder of this paper is organized as follows. In section 2, we survey precedent studies relate d to privacy preserving k -means. Section 3 describes build-ing blocks for our protocol. In sections 4 and 5, we propose two primitives: private AAC and private NCD. The proofs of security for these primitives are also shown. In section 6, privacy-preserving k -means is designed with these two primitives. Experimental results are also shown. Section 7 presents our concluding remarks. Let X = { x 1 , ..., x n } ( x j  X  R d ) be a dataset and x j be the -th attribute of vector x j . k -means clustering partitions the data into k clusters, represented by belongs to i -th cluster, cluster label z ij =1.Otherwise, z ij = 0. Cluster labels and cluster centers are updated alternately and repeatedly until convergence as follows:
Private information in k -means clustering is defined by how the dataset X is par-titioned among nodes. Vaidya et al. have proposed a privacy-preserving k -means for the vertically partitioned model where X j corresponds to a subset of attributes of all data entries[4]. Jha et al. have proposed a privacy-preserving k -means for two parties in the horizontally partitioned model where X j corresponds to a subset of attributes of all data entries[5]. Jagannathan et al. proposed a privacy-preserving k -means for two parties in the arbitrarily partitioned model where there is not nec-essarily a simple pattern of how data are shared among parties [6].

In k -means clustering with user-centric privacy preservation, we can naturally assume that the horizontally partitioned model with numerous parties. In this model, privacy-preserving k -means clustering is ideally stated as follows: Statement 1. Let there be n parties P j ( j =1 , ..., n ) .Party P j holds a subset of data X j as the input of the protocol, where  X  j X j = X . After the protocol execution, party P j learns a set of cluster labels corresponding to data x  X  X j and nothing else.
 Jha X  X  protocol functions in the horizontally partitioned model. However, this allows each party to learn cluster centers and cannot be extended to a multi-party protocol. Jagannathan X  X  protocol also functions in the horizontally partitioned model. However, the secure circuit evaluation must be repeated synchronously O ( n 2 ) times in n -party case; consequently, it is not scalable and asynchronous. The description above reveals that conventional protocols are not available or are insufficiently scalable for user-centric privacy preservation.

Our protocol is basically divided into two steps: private Asynchronous Av-erage Computation (AAC) which computes cluster centers privately among all nodes and private Nearest Cluster-center Determination (NCD) which privately computes cluster labels at each node. Pr ivate AAC is a cryptographic extension of a gossip-based protocol[7]. For private NCD, we use a protocol for private comparison of random shares based on Yao X  X  secure circuit evaluation[8] as a primitive. The same protocol is used in [6] for the same purpose. Gossip-based Protocol. Gossip-based protocol has been emerging as an ap-proach that achieves scalable and fault-tolerant statistical aggregation[9]. Kowal-czyk et al. have proposed a simple gossip-based protocol called  X  X ewscast X , which computes the average of values distribut ed over P2P networks without transfer-x 1.  X  j  X  x j ,t =1 , 2. Contact a node P j  X  r P and receives  X  j , 3.  X  j  X   X  j +  X  j 2 ,t  X  t +1. If t&gt;T , terminate the protocol. Else, go to step 2.  X  r denotes an uniform randomly selection from a set. We call  X  j a local estimate and the number of messages of each node a cycle . Let the average j x j /n be  X  . After the asynchronous execution of this protocol, it is proved that the local estimate  X  j converges to  X  as cycle t  X  X  X  ; the variance of  X  i drops on the average by factor  X  ,with  X   X  1 2  X  e . See [7] for details of theoretical properties. Homomorphic Public-key Cryptosystem. The homomorphic property of public-key cryptosystem is exploited for the computation of encrypted values without decrypting them. The key generation algorithm generates a valid pair ( s k ,p k ) of private and public keys.
 data. The encryption of an integer t  X  Z N is denoted as c = Enc p k ( t ; r ), where r is a random integer. The decryption is denoted as t = Dec s k ( c ). With a valid a public key cryptosystem with homomorphic property satisfies where t 1 ,t 2  X  Z N . r 1 ,r 2 are random numbers in Z N and changed for every en-simplicity. These properties enable the addition of any two encrypted integers and the multiplication of an encrypted integer by an integer. Paillier cryptosys-tem is known as a semantically secure cryptosystem 1 with homomorphism[10]. Private Comparison of Random Shares. Let x  X  Z d N be an integer vector that appears in the middle of a computation. For example, x corresponds to cluster centers at each step in our protocol. where x i = x A i + x B i mod N and x A i ,x B i  X  r Z N for all i . Then, we say that Alice and Bob have random shares of a value x i for all i . When Alice and Bob have random shares of x i , x i is shared between Alice and Bob while x i itself is unknown to both of them. Thorough the protocol of private comparison of random shares , Alice learns an index i  X  such that i  X  =argmax i ( x A i + x B i )and nothing else. Bob learns nothing.

A few protocols for private comparison of random shares are known. One of standard solutions is Yao X  X  secure circuit evaluation[8]. 4.1 Protocol for Private AAC Private AAC is a cryptographic extension of newscast. In this section, we assume one-dimensional value x j is given to P j . Although data x j might be rational number, x j can be treated as positive integers by adding and multiplying some constant without loss of generality. We also assume that the nodes and the server behave as semi-honest parties 2 . Private AAC is described in figure 1. After the computation, all nodes learn encrypted local estimates Enc p k (2 T +1  X  j )and nothing else, where T is the maximum of cycles. The server learns nothing.
How this protocol c orrectly computes Enc p k (2 T +1  X  ) is explained. At step 2, values in each node are encrypted by the server X  X  public key. At step 3, values are sent to P j which is chosen randomly. At step 4, P j updates the encrypted local estimate of P j .

As shown before, the update of newscast is described as  X  j  X   X  j +  X  j 2 . This in-cludes division which is not allowable in the homomorphic cryptosystem. There-fore, this update is modified. Assume that each node works synchronously such that all nodes keep identical cycle and u pdates the local estimate with an equa-tion  X  j  X   X  j +  X  j . In this setting, the local estimate converges to 2 T +1  X  after T updates because this update is equivalent to that of newscast except that the local estimate is doubled at each update.
 In actual case, two local estimates with different cycles might be exchanged. The consistency between the cycle and the local estimate is retained if update equations are modified as t and t j are the number of updates in P j and P j , respectively. This update is also equivalent to that of asynchronous newscast except that the local estimate is doubled at each update. Using the homomorphic property, these update equa-as shown: In the protocol, randomizations are intr oduced to prevent the server from eaves-dropping on local estimates. The local estimate is randomized by r j at step 3 and r j at step 4: these randomization are resol ved at step 4 and step 5, respectively.
Convergence Property: The convergence property of newscast is inherited with these update equations. The domain of x j is set to Z d N/ 2 T +1 such that 2
T +1  X  exists in the message space Z N . This protocol can be modified such that the squared and the weighted mean are estimated, which are used in next section. See Appendix in detail.

Gosship-based averaging guarantees  X  j  X   X   X  for any with probability 1  X   X  after 0 . 581(log n +2log  X  +2log 1 +1log 1 variance  X  2 [7]. It follows that the computational complexity of this protocol is O (log n )withfixed ,  X  ,and  X  .

Even when some node leaves the network suddenly, the protocol is still pro-cessed fault-torelant because communi cation between two nodes does not affect communication between two other nodes: th e theoretical convergence property will not be followed in such a situation; however, it would give an estimate close to the average if the number of disappeared nodes is not very large.
Security and Privacy: Finally, a theorem for the security of this protocol is presented.
 Theorem 1. Assuming the server and all nodes behave semi-honestly, private AAC is secure. The proof should be stated following the standardized proof methodology of secure multi-party computation as shown in [11]; however, because of the limi-tation of the space we briefly explain why this protocol does not reveal private information as follows:
Because all exchanged local estimates are all encrypted by the server X  X  public key in this protocol, no nodes can decrypt m essages related to lo cal estimates and no nodes can know other nodes X  private values. The server can decrypt exchanged local estimates, however, all lo cal estimates are randomized by r j ,r j at each node at each step. Random values r j and r j are exchanged with encrypted by public key of each node. It follows that the server cannot resolve randomizations by itself. Thus, the sever never learns any knowledge related to nodes X  private value, x j ,either. We present a protocol by which a node privately determines the nearest cluster center by taking encrypted cluster centers as inputs. Let the i -th cluster center be  X  i =(  X  i 1 , ...,  X  id ). After the execution of private AAC, all nodes share encrypted estimates of cluster centers and squared cluster centers (see appendix) for all i as follows: (the index of the nearest cluster center) without disclosing x j and knowing  X  i . can be privately determined by private comparison of random shares (fig. 2, top).
First, the way to prepare random shares of these distances is described. Let d ij and d i at step 1a, node P j computes c = have random shares of d ( x j ,  X  i ). Then at step 2, P j learns the nearest cluster center using private comparison of random shares.

Assuming private comparison of random shares is secure, this protocol se-curely and correctly determines the nea rest cluster center. However, the compu-tational time of the server is seriously la rge. The server must reply requests from all nodes: the computational complexity is O ( n ) with respect to the number of nodes. This would be apparently a bottleneck because we assume n is very large in user-centric priv acy-preservation.

Considering this, a proto col in which the computat ion is decentralized over binary trees is presented (fig. 2 middle and bottom). In this protocol, two kinds of Red nodes function as the server and blue nodes attempt to learn the nearest cluster center. Two binary trees of red and blue nodes are formed in which R and B are parental node of R + and B + , respectively.

At step 1, each node generates a key pair. Let the first red node R (the root of the binary tree) be the server S .Atstep2, R chooses a blue node B .At step 3, R and B chooses R + (= R R ,R L )and B + (= B L ,B R ), respectively. Then, B encrypts random shares of clu ster centers and sends it to R (step 4(a)-i). B encrypts the random number and sends it to B + (step 4(a)-ii). R decrypts and re-encrypt it with R +  X  X  public key; send it to B + (step 4(a)-iii). Consequently, B + obtains cluster centers encrypted by R +  X  X  public key (step 4(a)-iv). The same is repeated for encrypted squa red cluster centers (4(b)). Thus, R + and B + are ready to start private NCD. R + and B + becomes R and B , respectively: the operation proceeds recursively until P B is empty set (step 3). After the binary tree is formed over all nodes, all pairs e xecute private NCD (step 7). We assume that P R and P B are managed by the server. However, this can also be distributed among the P2P network using some protocol for this purpose.

Complexity: By this decentralization, the f unction of the server node is distributed over binary trees. In theory, this recursion stops after the log 2 n -th recursion at most. However, this does not work. R and B must find four non-busy nodes (two B + sandtwo R + s) simultaneously in the second step. It follows that 2 log 2 n  X  1 +2 ( &gt;n ) nodes must be nominated in the log 2 n  X  1 -th recursion. To alleviate this bottleneck, the protocol can be modified such that R and B respectively nominates only one non-busy node to R + and B + after the ( log 2 n  X  3)-th recursion in pract ice. This modification makes the protocol slightly slower. Nevertheless, th e protocol is completed after the ( log 2 n + 4)-th recursion at most and the entire computational complexity is still kept O (log n ). The number of busy nodes after the ( log 2 n  X  3)-th recursion is less than n/ 2. It follows that the R and B can readily find next candidates. After forming binary trees, nodes can asynchronously execute private NCD. If red nodes go breakdown suddenly, the paired blue node can execute private NCD with the server node at any timing. If blue nodes go breakdown, the paired red node can terminate the following computation. If either of red node or blue node stops, the pair cannot choose their descendants any more; however, the computation is not terminated if the server and at least one pair is alive in the network. As shown, this protocol works totally asynchronous and fault-tolerant.

Security and Privacy: A theorem for decentrali zed private NCD protocol is presented.
 Theorem 2. Assuming that the server and all nodes behave semi-honestly and that private comparison of random shares is secure, decentralized private NCD is secure.
 In this paper, we omit the proof and just briefly show why this protocol does not reveal private information as follows:
Messages exchanged during the protocol execution except ones related to pri-vate comparison of random shares are denoted as
Assume that R, R + ,B ,and B + observes all messages exchanged for protocol execution. During step 2 in which R is engaged, R observes a randomized value 2
T +1  X  i  X  r B : the reminder of the messages are encrypted in the form that R cannot decrypt. R + observes two randomized values 2 T +1  X  i  X  r B and d A iB + ;the reminder of the messages are encrypted in the form that R + cannot be decrypt. B observes a random value r B : the reminder of the messages are encrypted in the form that B cannot decrypt. B + observes two random values r B and d A iB + : the reminder of the messages are encrypted in the form that B + cannot decrypt. Thus, all messages transferred in the network are randomized or encrypted in the form that they cannot decrypt. Consequently, they learn only the result of private comparison and nothing else. k -means clustering with user-centric privacy preservation is designed with two primitives presented in previous sections. The outline of the protocol is summa-rized as follows: 1. Server S and node P j generate a key pair ( p S k ,s S k )and( p P j k ,s P j k ). 2. All nodes join private AAC and obtain c i for i =1 , .., k . 3. All nodes and the server join decentralized private NCD : encrypted squared 4. If termination conditions are satisfied, terminate the protocol. Else, go to
At step 2, encrypted cluster centers c i and encrypted squared cluster centers are privately computed. Then, at step 3, distributed private NCD is conducted: i are propagated and cluster label are determined by taking inputs. Step 4 judges the convergence. The simplest termination condition is to stop the protocol after a fixed number of iterations. As an alternative, the convergence can be judged by sharing whether cluster labels are changed or not among nodes. These can be computed using private AAC and the termination protocol will be discussed in the longer version of this paper.

Here, we briefly show what the nodes and the server learn from execution of the protocol. At step 2, nodes just obtains a sequence of encrypted cluster centers, c i and c (2) i , which cannot be decrypted by n odes. As shown in theorem 1, all nodes and the server learn nothing about other nodes X  private data from private AAC. At step 3, both nodes learn a sequence of z ij that includes which cluster center is (or was) the nearest to the node X  X  data. Unfortunately, this result slightly deviates form what statement 1 in section 2 describes because statement 1 does not allow to disclose cluster labels at intermediated steps. Nevertheless, P j does not learn any from the protocol execution other than a series of z ij .
After the execution of the protocol, com puted results, such as cluster centers, number of nodes belonging to each cluster, nodes belonging to the same cluster, can be shared among nodes if they reach an agreement. Private sharing of these results among nodes requires additional protocols. These issues will be discussed in other paper, too.

Computational Analysis: To investigate the scalability, we show experi-mental results of these protocols. As homomorphic cryptosystem, Paillier cryp-tosystem with 512/1024-bit key was used. The server and the node program were implemented by J2SE ver. 1.5.0. The number of nodes was varied from n =10 to 10 6 . Actually, the execution in the real P2P network with a million nodes is unrealistic. Instead, we simulated the P2P network environment on a personal computer; both the server and nodes program were run on a Xeon2.8GHz(CPU), 2GB(RAM) Windows PC.

We simulated private AAC and measured the computation time per node. In private AAC, the computation time of encryption and decryption is much larger than the communication time because the unit message length is at most the length of the cipher, 512 or 1024 bit. Therefore, we only measured the overall computation time without communications overhead.

For a unit variance dataset and a network with n =10 6 nodes, 25 cycles are required to guarantee that the local estimate  X  j in each node is within 10  X  6 from the correct average  X  with 95% probability. Considering this, we set the maximum cycle to T =20 , 40 and the dimension d =1inexperiments.The results are shown in figure 3 left. As shown, private AAC with a million of nodes is completed within 50 (sec) at most.

Next, we evaluated the computation t ime of decentralized private NCD. In this experiment, we did not construct a complete binary trees but partial binary trees whose width was 2 and depth was log 2 n + 4 because of the limitation of the memory. This setting is sufficient for the evaluation of the computation time because the number of recursions is at most log 2 n +4asshowninsection5 andthecomputationisexecutedinpar allel in the P2P network environment. We set k = 2: the computation time from the step 2 to the termination of the protocol was measured. In the largest setting (1024-bit key, d =8, n =10 6 ), it costs 1200 ( sec)(=20 min) at most. This result includes the propagation of c (2) . Without this, the computation time is decreased by half.
 Finally, the computation time of privacy-preserving k -means was evaluated. Here, we assume two cases. Case 1 is a small-scale setting ( d =2 ,k =2 ,n = 1000). Case 2 is a large-scale setting ( d =4 ,k =4 ,n =10 6 ). Both cases assume T = 40 and 1024-bit key. For a single iteration of k -means in case 1, step 2 costs about 180 (sec) and step 3 costs 660 (sec). From those, k -means clustering is expected to be converged within a few h ours. In case 2, step 2 costs 740 (sec) and step 2 costs 9100 (sec). For single iteration, it costs about 2.7 hour. In this case, clustering is expected to be completed within a couple of days. We propose a protocol for k -means clustering with user-centric privacy preserva-tion based on two novel protocols: private AAC and private NCD. Our protocol is implemented totally asynchronous and fault-tolerant and is scalable even with a million users. Computation time is dependent on that of encryption and de-cryption strongly. With more sophisticated implementation of the cryptosystem would improve the computation time drastically. Nevertheless, considering a mil-lion users participate in the protocol, we can conclude that experimental results are remarkably scalable. Other data mining algorithms with user-centric privacy preservation is our future work.
 Appendix: Private AAC for Weighted Average Cluster centers are computed as weighted averages as  X  j = j z ij x j / z ij , where z ij  X  X  0 , 1 } .Ifweights z ij are not mutually private, this is easily solved by execution of private AAC only between nodes whose z ij is one. However, if the weight z ij is private, this violates the privacy. Then we modify updates of private AAC as follows:  X  Step 1,2, and, 3 is the same with private AAC  X  When z ij =1and z ij = 1, updates are executed normally  X  When z ij =1and z ij =0, P j updates the local estimate of P j normally.  X  When z ij =0and z ij = 0, both parties merely increment the cycle of the The behavior of each node is controlled by z ij . As a consequence of updates show above, the update progresse s only between parties with z ij = z ij =1without disclosure of z ij . Let the probability that two nodes whose z ij is both 1 be p . Then, T/p cycles are required to guarantee th e same convergence property with private AAC protocol.
 Appendix: Private AAC for Squared Average A protocol to compute the squared average is described. We need to use Yao X  X  secure circuit evaluation for this protocol. Let x A and x B inputs of two parties, Alice and Bob, respectively. x A and x B are random shares of x . Then, consider a Yao X  X  protocol to compute y A and y B as outputs of Alice and Bob, respectively, in which y A and y B are random shares of x 2 . By Yao X  X  protocol, squared averages are obtained through the computation between the sever and node P 1 as follows (arbitral node is available instead of P 1 ). 1. P 1 generates a random number r 1  X  Z N , computes c i  X  Enc p k (  X  r 1 ) and send 2. Server decrypts this and obtains r S =  X  i  X  r 1 ( r 1 and r s are random shares 3. Between the server and P 1 , run the Yao X  X  protocol. Then, P 1 and the server 4. The server compute c S  X  Enc p k ( y S ) and send to P 1 .
After P 1 obtains c (2) i for all i and , P 1 become the first blue node. Then, c (2) i
