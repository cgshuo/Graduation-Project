 Due to the ubiquitous data uncertainty in many emerging real ap-plications, efficient management of probabilistic databases has be-come an increasingly important yet challenging problem. In partic-ular, one fundamental task of data management is to identify those unreliable data in the probabilistic database that violate integrity constraints (e.g., functional dependencies), and then quickly re-solve data inconsistencies. In this paper, we formulate and tackle an important problem of repairing inconsistent probabilistic databases efficiently by value modification. Specifically, we propose a re-pair semantic, namely possible-world-oriented repair (PW-repair), which partitions possible worlds into several disjoint groups, and repairs these groups individually with minimum repair costs. Due to the intractable result that finding such a PW-repair strategy is NP-complete, we carefully design a heuristic-based greedy approach for PW-repair, which can efficiently obtain an effective repair of the inconsistent probabilistic database. Through extensive experi-ments, we show that our approach can achieve the efficiency and effectiveness of the repair on inconsistent probabilistic data. H.2.0 [ Database Management ]: Systems X  General ; H.3.0 [ Infor-mation Systems ]: Information Storage and retrieval X  General Algorithms, Design, Experimentation, Performance, Theory Inconsistent probabilistic database, possible-world-oriented repair
Recently, a wide spectrum of real applications often require in-tegrating data from multiple sources (e.g., the Web, public or en-terprise databases). Due to various reasons such as misspellings, integration precisions, and subjective opinions from people, incon-sistencies, errors, or conflicts may emerge in the integrated data, violating integrity constraints like functional dependencies. Such dirty data may lead to serious consequences, for example, annually costing US businesses 600 billion dollars [11, 12]. Therefore, it Table 1: Illustration of an Inconsistent Probabilistic Database, hotel . has been recognized as an important task for the data integration system to effectively manage inconsistencies in databases.
While previous works [8, 3, 5, 21, 9] on resolving inconsisten-cies by the database repair usually assume that the underlying data are precise, real-world data, however, are often uncertain and im-precise. Table 1 depicts an example of a small database containing the records (tuples) of 4 hotels t 1  X  t 4 . The table schema is: where each tuple has attributes: hotel id ( HID ), area code ( AC ), zip code ( Zip ), location in the area ( Loc . ), and the rating ( Rating ).
In addition, hotel records in Table 1 may possibly expire in re-ality (e.g., the hotel closes). Thus, we associate each tuple t an attribute t i . p (  X  [ 0 , 1]) , indicating the probability that the hotel entity still opens (exists) currently. As a result, Table 1 exactly cor-responds to a probabilistic database [10], where each tuple (hotel) t appears in the real world with an e xistence probability t
In the literature of probabilistic databases [10], we usually con-sider the possible worlds semantics, where each possible world pw ( D ) is a materialized instance of the probabilistic database D that can occur in reality. Table 2 shows all the 8 possible worlds, pw 1 ( D )  X  p w 8 ( D ) , of Table 1, where each tuple either exists or does not exist in a possible world.

In the table, tuples t 1 and t 4 in possible worlds p w 7 p w 8 ( D ) ha ve the same area code AC ( X  44  X ) and hotel location Loc. ( X  L 1  X ), however, they have distinct zip codes Zip (i.e.,  X  20000  X  and  X  10000  X , respectively), which violates a functional dependency (FD): Thus, we say that tuples t 1 and t 4 are inconsistent with each other in possible worlds pw 7 ( D ) and p w 8 ( D ) . Similarly, t also inconsistent in possible worlds pw 5 ( D ) , p w 6 ( D ) , and pw violating the FD above.

In order to resolve such inconsistencies, we may need to repair data in possible worlds by attribute value modifications. In our example, in possible worlds pw 7 ( D ) and p w 8 ( D ) , we can set at-tribute Zip of both inconsistent tuples t 1 and t 4 to a value,  X  2 0000  X  or  X  10000  X ; in possible worlds pw 5 ( D ) , p w 6 ( D ) , and pw we can also modify zip codes of t 2 and t 3 to a value,  X  3 0000  X  or  X  40000  X . Thus, one critical yet challenging issue arises, that is, how to efficiently determine repaired attribute values and resolve inconsistencies, especially in possible worlds of probabilistic data.
One straightforward method is to repair each possible world of the inconsistent probabilistic database, by applying the existing re-pair techniques on inconsistent certain data [5]. However, since there are an exponential number of possible worlds on probabilis-tic data, the total number of repairs can be also exponential in the worst case. Clearly, this repair method is inefficient or even infea-sible, in terms of the repair time and space cost. Moreover, the resulting (many) versions of repaired data are also inconvenient for the usage (e.g., answering queries) in practical applications.
Inspired by the inefficiency of the straightforward method, as a preliminary work for the repair in inconsistent probabilistic databases, we propose repair semantics, possible-world-oriented repair (PW-repair). A PW-repair classifies possible worlds into k (disjoint) groups, namely, possible world groups (PWGs), and obtains one re-pair for each PWG, such that the PW-repair cost in possible worlds of PWGs is minimum. Intuitively, instead of repairing every pos-sible world, the PW-repair repairs a much smaller number, k , of PWGs, which trades the effectiveness for (space/time) efficiency, where k is a controllable parameter that is specified by users.
Unfortunately, we prove that the problem of finding a PW-repair with the minimum repair cost (via value modification) is NP-complete and intractable. Therefore, in this paper, we will design a greedy algorithm for the PW-repair, which can efficiently obtain repairs with low repair costs in PWGs.

We make the following contributions in this paper. 1. We formalize the PW-repair problem which repairs inconsis-2. We prove in Section 3.1 that our PW-repair problem is NP-3. We propose in Sections 3.2  X  ?? an efficient greedy approx-4. We conduct extensive experiments to confirm the efficiency
In addition, Section 5 reviews previous works on repairs in in-consistent certain databases, and query answering in probabilistic databases. Section 6 concludes this paper. Probabilistic Databases [10]: A probabilistic database D con-tains a set of N x -tuples t 1 , t 2 , ..., and t N , where each x -tuple t ( 1  X  i  X  N ) consists of a single or multiple (mutually exclusive) alternatives t ij ( 1  X  j  X  l i ). Each alternative t ij is associated with an existence probability t ij .p , where P l i j = 1
F or the sake of clear presentation, throughout this paper, we as-sume that the probabilistic database contains single-alternative x -tuples (i.e., l i = 1 for all i ). For brevity, we will use tuple t represent either x -tuple or the single alternative t i 1 when the context is clear.
 Possible Worlds: A possible world pw ( D ) of a probabilistic database D is a materialized instance of D that may occur in reality. Each x -tuple has at most one alternative appearing in a possible world.
D EFINITION 2.1. ( P ossible Worlds, pw ( D )) A possible world, pw ( D ) , is a subset of probabilistic database D such that each x -tuple t i has at most one alternative in p w ( D ) . The appearance probability, P r { pw ( D ) } , that pw ( D ) occurs is: where l i is the number of alternatives in x -tuple t i .
T able 2 shows 8 possible worlds (and their appearance probabil-ities) of the probabilistic database in Table 1.
 Inconsistent Probabilistic Databases: In an inconsistent proba-bilistic database, tuples are often inconsistent with each other (e.g., violating FDs) [14]. Following the practice of US national statis-tical agencies [13, 22], we assume that each attribute A of a tuple t  X  X  is associated with a weight , t i .w ( A )  X  [ 0 , 1] , which reflects the confidence that attribute t i [ A ] is correct. Similar to [18], we assume that tuples (attributes) are from independent data sources. Table 3 summarizes the commonly used symbols in this paper. Functional Dependencies (FDs): An FD, X  X  A , indicates that any two tuples, t and t  X  , with the same value on attribute X (i.e., t [ X ] = t  X  [ X ] ) should also have equal values on attribute A (i.e., t [ A ] = t  X  [ A ] ). Possible-World-Oriented Repair (PW-Repair): To resolve in-consistencies, we propose PW-repair by considering attribute value modifications in possible worlds with minimal repair semantics [5].
D E FINITION 2.2. ( PW -Repair in Inconsistent Probabilistic Data-bases ) Given an inconsistent probabilistic database D , and a set,  X  , of FDs in the form of X  X  A , a possible-world-oriented re-pair (PW-Repair) divides all possible worlds, pw ( D ) , of D into k (  X  1 ) disjoint possible world groups (PWGs), P W G 1 , P W G ..., and P W G k , and for each PWG P W G i ( 1  X  i  X  k ), obtains 1) D R i is consistent in any possible world of P W G i , and 2) the PW -repair cost, Repr P W , is minimized, where and t R i  X  D R i is the repaired tuple of t  X  X  .

The function cost ( t, t R i ) in Eq. (2) is defined as: where d ist (  X  ,  X  ) is a distance function to measure the distance be-tween two attribute values, and max _ dist ( A ) is the maximum de-viation of the repaired value from original one.
 The PW-Repair Semantics: In Definition 2.2, the PW-repair divides all possible worlds into disjoint partitions (i.e., P W G which contains possible worlds with similar repairs. Then, a re-pair is carried out on each PWG P W G i , such that the resulting by Eq. (2)) is the lowest. Note that, here the partitioning of possi-ble worlds can be arbitrary, thus, an exhaustive search of PW-repair would incur rather high cost. Therefore, in this paper, we will de-sign an efficient PW-repair approach, which quickly finds a good partitioning strategy with low PW-repair cost.
 Parameter k : The parameter k in Definition 2.2 represents the num-ber of PWGs for PW-repair, which is assumed to be a user-specified constant parameter.
 PW-Repair Cost, Repr P W : The PW-repair cost, Repr P W , in Eq. (2) is given by the summation of repair costs in k possible world groups, P W G 1  X  P W G k , using k v ersions of data repairs, D R respecti vely. For each P W G i ( 1  X  i  X  k ), we compute the summed value modification cost of all tuples that appear in possible worlds pw ( D ) of P W G i (i.e., P  X  t  X  p w ( D ) cost ( t , t up these costs weighted by appearance probabilities P r { pw ( D ) } . Value Modification Cost, cost ( t, t R i ) : For a particular tuple t in possible worlds, the value modification cost, cost ( t, t t i is shown in Eq. (3), which sums up the weight, t.w ( A ) , of at-tribute t [ A ] times (normalized) value distances before and after the  X  data accuracy) and less attribute modification cost will indicate lower repair cost. We notice that this function (i.e., cost ( t, t w as also used as a measure to evaluate the repair cost on the tu-ple level in certain databases [5]. Here, in Eq. (2), we utilize it to calculate the repair cost of a tuple t in a possible world pw ( D ) . Applications: The PW-repair can be used in many practical appli-cations to improve the quality of real-world probabilistic data. In the application of data integration, we need to merge two distinct data sources via the join operator. The join results might be asso-ciated with existence probabilities due to inaccurate join attributes, which thus form a probabilistic database. In the application of the information extraction, we extract data (tuples) from Web pages. Each tuple t i is associated with a probability t i .p , indicating the chance that the Web page is still valid (not expired), and an extrac-tion accuracy t i .w ( A ) of attributes in t i . In these applications, data are usually probabilistic and inconsistent (in possible worlds). Our PW-repair can exactly resolve inconsistencies by providing k re-paired versions of the probabilistic database, where each version is specific for a group of possible real-world scenarios (i.e., PWGs).
After the PW-repair, we can use the k resulting repairs to answer queries in real applications. In particular, for any query, we can first find a PWG that contains the real world by checking the expiration status of those partitioning tuples w.r.t. PWGs, and then select the repaired database corresponding to this PWG for query processing.
We next present intractable results for our PW-repair problem under functional dependencies in inconsistent probabilistic databases, showing that this problem is NP-complete and not tractable.
L E MMA 3.1. Given an inconsistent probabilistic database D , a set  X  of functional dependencies, and a constant  X  , the problem of determining whether there exists a PW-repair of D whose repair cost is at most  X  is NP-complete.
 Proof. Please refer to Appendix A. 2 Lemma 3.1 shows that the PW-repair problem is not tractable. Thus, it is necessary to propose heuristic-based greedy approxima-tion approaches to find good PW-repairs with low costs. Figure 1: An example of identifying equivalence repair blocks (w.r.t.
T o facilitate our heuristic-based approach of repairing proba-bilistic data, we first define a notion of the basic repair unit, namely equivalence repair block (ERB). Specifically, an ERB, ERB ( A, {  X  1 , ...,  X  n } ) , for attribute A is defined as a set of tuples whose at-tribute A that should be modified to the same value after the repair, inferred from FDs  X  1 , ..., and  X  n in  X  , where  X  i : U over, each ERB ERB ( A, {  X  1 , ...,  X  n } ) is associated with a set of candidate repairing values for attribute A , denoted as V ( A, {  X   X  } ) = { t i [ A ] | X  t i  X  ERB ( A, {  X  1 , ...,  X  n } ) } . ERBs for a Single FD: For a single FD X  X  A , an ERB, ERB ( A, { ( X = v )  X  A } ) , for attribute A is given by a set of tuples { t | X  t, t [ X ] = v } , for a particular value v of attribute X . Intu-itively, ERB ( A, { ( X = v )  X  A } ) contains all tuples that have the same attribute value v in X , and their A values are also ex-pected to be the same after the repair, due to FD X  X  A . As an example in Figure 1(a), under X  X  A , we have 3 ERBs, that is, ERB ( A, { ( X = 1)  X  A } ) = { t 1 , t 2 , t 3 } , ERB ( A, { ( X = 2)  X  A } ) = { t 4 , t 5 } , and ERB ( A, { ( X = 3)  X  A } ) = { t ERBs for Multiple FDs: Given more than one FD, we may need to merge ERBs of different FDs. As an example, in Figure 1(a), in addition to X  X  A , we have another FD Y  X  A , where X 6 = Y . The resulting 3 ERBs under Y  X  A are given by ERB ( A, { ( Y = 1)  X  A } ) = { t 1 , t 2 } , ERB ( A, { ( Y = 0)  X  A } ) = { t and ERB ( A, { ( Y = 4)  X  A } ) = { t 6 , t 7 } .

Since t 2 , t 3  X  ERB ( A, { ( X = 1)  X  A } ) in Figure 1(a), we have t 2 [ A ] = t 3 [ A ] . Similarly, since t 3 , t 4  X  ERB ( A, { ( Y = 0)  X  A } ) , it holds that t 3 [ A ] = t 4 [ A ] . Thus, by the equality tran-sition, we know t 2 [ A ] , t 3 [ A ] , and t 4 [ A ] should be assigned with the same value after the repair. In other words, their residing ERBs ERB ( A, { ( X = 1)  X  A } ) and ERB ( A, { ( X = 2)  X  A } ) (or equivalently, ERB ( A, { ( Y = 1)  X  A } ) and ERB ( A, { ( Y = 0)  X  A } ) ) should be merged into one ERB, in which tuples should have the same value of attribute A . As shown in Figure 1(b), the merged ERB contains tuples t 1  X  t 5 , and can be denoted as ERB ( A, { ( X, Y )  X  X  (1 , 1) , (1 , 0) , (2 , 0) } X  A } ) . Further-more, the candidate values for attribute A are { 3 , 4 , 6 , 7 } , that is, the union of value sets V ( A, { ( X = 1)  X  A } ) ( i.e., { 3 , 4 } ) and V ( A, { ( X = 2)  X  A } ) ( i.e., { 6 , 7 } ) .
 Identification of ERBs: To identify ERBs under multiple FDs, we first find those dependent attributes A that appear on the RHS of FDs. Then, for each attribute A , we identify ERBs by considering relevant FDs one by one. That is, for an FD  X  i : U i  X  A , if a set, W j , of tuples that agree on attribute(s) U i belong to more than one (previously assigned) ERB, then we need to merge tuples in these ERBs, and update their candidate repairing values (via union) for the resulting merged block.
 Repair Order: By considering each attribute as a vertex and the determination relationship among attributes from FDs as edges, we can construct a directed acyclic graph (DAG). In this paper, we use Figure 2: An example of the PWG partitioning in PW-repair (w.r.t. the topolo gical order of vertices (attributes) in the DAG of FDs as the repair sequence on attributes. Intuitively, with this order, each tuple attribute will not be repaired more than once.
Since the PW-repair problem is NP-complete (see Lemma 3.1), in this subsection, we propose an efficient heuristic-based approach, which partitions all the possible worlds of an inconsistent proba-bilistic database D into disjoint PWGs, such that the repaired data in PWGs can achieve low PW-repair costs.
 Illustrative Example of Partitioning Possible Worlds: We illus-trate our heuristics of partitioning possible worlds using an example in Figure 2, where a small probabilistic database D contains 3 tu-ples t 1 , t 2 , and t 3 , following a functional dependency X  X  A , and all weights, t i .w ( A ) , of t i [ A ] are assumed to be 0.5. In this exam-ple, we can see that due to the functional dependency X  X  A , the tuple set, { t 1 , t 2 , t 3 } , forms an ERB.

Let us first consider the case where all possible worlds of D form one group, P W G 1 (i.e., k = 1 ). In this case, the PW-repair with k = 1 will obtain one repaired database D R for P W G modifies all values of attribute A to a single value 1 ( = t It is worth noting that, we still have the chance to further obtain lower repair cost. As an example in Figure 2, in a possible world pw ( D ) = { t 2 , t 3 } where t 1 (with t 1 [ A ] = 1 ) does not exist, our PW-repair (with k = 1 ) will always modify t R 2 [ A ] = t However, in fact, attribute A  X  X  value  X 1 X  never appears in this possi-ble world pw ( D ) , and a lower repair cost (i.e., 0.1) can be achieved in pw ( D ) if we modify attribute A of tuple t 3 to  X 2 X  ( = t
Based on the observation above, in some possible world of the database, attributes of tuples might be assigned with a repairing value that does not appear in this possible world, which may lead to high PW-repair cost. Therefore, our strategy of partitioning pos-sible worlds is based on heuristics of reducing such a repair cost.
Specifically, for PW-repair with k = 2 , we can divide all the pos-sible worlds into 2 disjoint groups, P W G 1 and P W G 2 . P W G includes all possible worlds that contain t 1 , whereas P W G tains possible worlds where t 1 does not appear. Intuitively, during the PW-repair, we perform a repair for each PWG individually. The repair in P W G 1 has candidate repairing values 1, 2, and 3 for at-trib ute A . For P W G 2 , since t 1 does not appear in possible worlds of P W G 2 , candidate repairing values are 2 and 3, and exclude v alue  X 1 X  ( = t 1 [ A ] ). This way, a lower repair cost can be obtained. Sub-Blocks: Next, we introduce a notion, namely sub-block , based on which we can apply our strategy to the PWG partitioning in PW-repairs. Note that, in Definition 2.2, possible worlds can be arbitrarily partitioned into k groups. However, since to find the partitioning with the minimum repair cost is NP-complete (Lemma 3.1), we can only give an approximate approach, which assumes that the sub-block is the basic partitioning unit in PW-repair.
Assume that we have identified m ERBs for an attribute A (as mentioned in Section 3.2), where the subscript i of ERB i de x for ERBs, and we omit symbols of FDs in ERB l ( A , {  X   X  } ) when the context is clear. Each ERB, ERB l ( A ) , has a tinct candidate repairing values, v l 1  X  v la l . Without loss of gener-ality, we denote a sub-block , sub _ ERB lj ( A ) , as a subset of tuples in an ERB, ERB l ( A ) , with the same value v lj of attribute A .
In the example of Figure 2, we have one ERB, ERB 1 ( A ) , which contains 3 sub-blocks, that is, sub _ ERB 11 ( A ) = { t ( A ) = { t 2 } , and sub _ ERB 13 ( A ) = { t 3 The PWG Partitioning Strategy: Our PWG partitioning strategy is as follows. We will always select some sub-block, sub _ ERB in the database, and divide possible worlds according to the cri-terion whether or not possible worlds in PWGs contain tuples in sub-block sub _ ERB lj ( A ) .

As in the example of Figure 2, we can partition possible worlds of D into two groups, based on the (non-)existence of sub-block sub _ ERB 11 ( A ) ( = { t 1 } ). That is, we can obtain two PWGs, P W G 1 having tuple t 1 , and P W G 2 without t 1 .
In the sequel, we will propose an approximation approach, namely the greedy algorithm (GA), to obtain a PW-repair with sub-optimal minimum repair cost.
 Greedy Algorithm: Our greedy algorithm aims to obtain k re-paired databases D R i , each with the attribute value setting to v in E RB l ( A ) ( 1  X  l  X  m and 1  X  j i  X  a l ), and associated with a PWG, P W G i , which can approximately minimize the PW-repair cost (given by Eq. (2)).
 Base Case: First, we consider the base case where the number, k , of PWGs is equal to 1 . For the convenience, we denote the minimum PW-repair cost in Eq. (2) (for k = 1 ) on all possible worlds of D (i.e., treated as one PWG) as function \ Repr PW ( D , 1 ) .
Since the original formula of Repr PW in Eq. (2) involves an ex-ponential number of possible worlds, we now reduce its computa-tional cost by condensing the possible worlds of D . Specifically, we have:
In particular, the formula above sums up the smallest repair cost in each ERB, which is given by first taking every possible repairing value v lj in E RB l ( A ) , and then selecting the one with the smallest cost. By condensing possible worlds, the repair cost in each ERB can be obtained by summing up the term t.p  X  t.w ( A )  X  dist ( t [ A ] , v for all tuples t in the ERB, where v lj is one candidate repairing v alue of A . This way, while computing the minimum PW-repair cost where k = 1 , we can also obtain a PW-repair mechanism on ERBs (when the minimum PW-repair cost is achieved).
 Recursive Function: To obtain PW-repairs, we propose a greedy approximation approach that partitions possible worlds into k dis-joint groups, and achieves low PW-repair cost \ Repr P W of Repr in Eq. (2), given by a recursive function: where \ Repr PW ( D , 1 ) is given by Eq. (4), Repr PW (  X  , k ) = 0 , and Repr PW ( D , k ) = 0 (if 2 a &lt; k holds, given the number, a , of sub-blocks in D ). Moreover, variable repr _ cost 1 is the repair cost on ERB ERB 1 ( A ) , which uses the repairing value of P W G tuples in ( ERB 1 ( A )  X  s ub _ ERB 11 ( A ) ) ; variable repr _ cost the minimum repair cost in ERB 1 ( A ) (under possible worlds in P W G i  X { X  p w ( sub _ ERB 11 ( A ) ) } ) using the repairing value v in s ub _ ERB 11 ( A ) ) .

Intuitively, \ Repr P W ( D , k ) in Eq. (5) aims to recursively find a good partitioning strategy on possible worlds of D , with a low PW-repair cost, and decides PW-repairs D R i , as well as their associated possible world groups P W G i .

Specifically , within the outer min { X } operator of Eq. (5), the first term considers dividing all possible worlds of D into two parts, P W G 1  X  P W G i (denoted as  X  ) and P W G i + 1  X  P W G noted as  X  ), according to the (non-)existence of tuples in the sub-block, sub _ ERB 11 ( A ) , where 1  X  i  X  k  X  1 .

Furthermore, the second term (denoted as N ) in min { X } of Eq. (5) corresponds to the case where all PWGs are not partitioned at the sub-block ERB 11 ( A ) . Thus, to compute the PW-repair cost, we first obtain the repair cost on the remaining data, D -sub _ ERB at which k PWGs, P W G 1  X  P W G k , are split. Then, since the re-pair in ERB 1 ( A ) using the repairing value v 11 in s ub _ ERB may produce lower repair cost for some PWGs, we thus update the obtained cost above, as shown in N of Eq. (5).

Therefore, the function in Eq. (5) will recursively take the smaller cost value (as well as selecting PW-repairs in PWGs where the value is achieved) between terms (  X  +  X  ) and ( N ) .
 We illustrate the pseudo-code for the PW-repair procedure, namely GA_PW_Repair , in Figure 3.
 Figure 3: The greedy algorithm of PW-repair in inconsistent proba-
In this section, we evaluate the efficiency and effectiveness of our repair approach in inconsistent probabilistic databases, on both real and synthetic data. For the real data, we crawl the zip codes and city containing the state name and the percentage of mothers in each city/county who smoked during pregnancy for different race groups during the period 1995-1999. We join these two tables on attribute city/county name, and obtain a large joined table. Since different states may have the same city/county name in our data, some join results thus violate the FD Zip  X  State . For synthetic data, under an FD: X  X  A , we first generate numerical values for attribute X within domain [1 , 100] , following Uniform or Zipf distribution (with skewness 0.8). Then, for tuples t with the same value t [ X ] , we randomly produce a value (with the same distribution as X ) for t [ A ] . Moreover, we associate each tuple t with an existence probability t.p  X  [ p min , p max ] ( [ 0 . 5 , 1] by default).
To evaluate the quality of our PW-repair, similar to [9], we ran-domly add noises to original data, changing (100  X   X  )% attribute values by adding a random noise within [  X  5 , 5] in synthetic data Table 4: PW-repair vs. Baseline ( k = 5 ) Under an FD: X  X  (or changing characters in strings of real data with maximum DL-metric 4), where  X  is the noise rate. To indicate the accuracy, for each attribute t [ A ] with noises, we generate a random weight t.w ( A ) within [0 , 0 . 5) ; for that without noises, we assign a ran-dom weight t.w ( A ) in [0 . 5 , 1) . We measure the quality of our PW-repair in terms of recall and precision , where recall is the ra-tio of the number of correctly repaired noises to the total number of noises we add, and precision is the ratio of the number of cor-rectly repaired noises to the total number of changed values made by repair algorithms. Since we repair on a probabilistic database D , we first materialize r possible worlds pw ( D ) (i.e., select tuple t to pw ( D ) with probability t.p ), where r is set to 1 , 000 by default. For PW-repair, we will use the repaired database D R i that corre-sponds to P W G i containing pw ( D ) . Then, we average recalls and precisions over all the tested possible worlds pw ( D ) (weighted by their probabilities P r { pw ( D ) } ) as our measures.

Further, we also use the time cost to measure the execution time of finding PW-repairs. We compare the time cost of our PW-repair with that of a baseline method, Baseline , which enumerates all the P ar _ N um partitioning strategies, computes the PW-repair cost for each strategy, and selects the one with the smallest PW-repair cost. Due to exponential number of partitioning strategies, we es-timate the time cost of Baseline by first taking 100 random par-titioning strategies, and then obtaining the PW-repair time, T these 100 strategies. Thus, the estimated time cost is P ar _ Num  X  T Below, we test the performance of PW-repairs under the FD: X  X  A . All our experiments are conducted on a PC with Core(TM)2 Duo 3GHz CPU with 3G memory.
Table 4 depicts the recall, precision, and time cost of our PW-repair on both real and synthetic data, where k = 5 , m = 500 ,  X  = 0 . 5% , and N = 10 K . In the table, recall and precision of PW-repair remain high (i.e., 70%-96%), whereas Baseline has 100% recall but much lower precision due to the exponential num-ber (about 10 790  X  10 6987 ) of candidates. The time cost of our greedy algorithm is about 3-4 seconds, which significantly outper-forms Baseline . This is because Baseline has to enumerate an exponential number of partitioning strategies, which incurs high cost. The results on real/synthetic data confirm that PW-repair is efficient and produces data with high precision and recall.
Figure 4 tests the scalability of our repair approach by varying the data size N from 5 K to 50 K , where k = 5 , m = 500 , and  X  = 0 . 5% . With larger data size, the recall and precision increase, which indicates the good scalability against the data size. More-over, the total repair time cost increases for large data size N . This is reasonable, since larger data size may incur more sub-blocks, which make the greedy algorithm more costly.

For data sets with other parameter values (e.g., different values of  X  , m , N , or r ) or with multiple FDs, the experimental results are similar, and thus we will not report them.
An inconsistent database contains inconsistent tuples that violate integrity constraints such as functional dependencies. In literature [3, 14], many existing works on inconsistent databases assume that the underlying data are certain and precise. The notion of minimal repair was first introduced by Arenas et al. [3], which manipu-lates inconsistent data such that a consistent database is obtained with the smallest repair cost , defined as the symmetric difference of databases before and after the repair. In contrast, our work con-siders a more complex scenario in probabilistic database where data are unreliable and uncertain. Thus, we have to re-define the repair cost for such inconsistent probabilistic data, as well as designing efficient and effective repairing techniques.

The repair models [12] can be classified into 3 categories: X-repair [8] allowing tuple deletions only, S-repair [3] with both tuple insertions and deletions, and U-repair [21, 5, 9] considering tuple value updates. In this paper, we consider the U-repair semantics by value modification in the probabilistic database. The repair-key operation in MayBMS [2] repairs the table that violates key con-straints by removing a minimum subset of tuples, whereas our work considers the U-repair with the attribute value modification.
Andritsos et al. [1] considered the repair under the key constraint by joining multiple dirty databases, where each tuple is associated with a probability, indicating the confidence that this tuple is clean. In contrast, our work considers the repair by attribute value modi-fication under FDs in possible worlds of inconsistent probabilistic databases. Lian and Chen [16] studied consistent query answering in inconsistent probabilistic databases by aggregating answers over all possible repairs, whereas this work directly modifies attribute values of tuples with the minimal repair semantics.

In the literature of probabilistic databases [10], there are many existing systems that manage probabilistic and uncertain data, for example, MystiQ [6], Orion [7], TRIO [4], MayBMS [2], MCDB [15], and BayesStore [20]. Most existing works assume consistent probabilistic data, and focus on query answering [17, 19] with the guaranteed accuracy of answers. Our work explores PW-repairs to resolve inconsistencies in possible worlds of probabilistic data.
In this paper, we study an important problem of repairing an in-consistent probabilistic database by value modification, under func-tional dependencies. We formalize and tackle the PW-repair prob-lem, which repairs over groups of possible worlds in the database, minimizing the PW-repair cost. Due to the NP-completeness of this problem, we propose a greedy algorithm to achieve the PW-repair with a low cost. Extensive experiments have been conducted to demonstrate the efficiency of our PW-repair approach.
 Funding for this work was provided by RGC NSFC JOINT Grant under Project No. N_HKUST61 2/09, HKUST RPC10 EG13, and NSFC Grant No. 60736013, 60803105, 60873022, and 60903053. [1] P. Andritsos, A. Fuxman, and R.J. Miller. Clean answers over [2] L. Antova, C. Koch, and D. Olteanu. MayBMS: Managing [3] M. Arenas, L. Bertossi, and J. Chomicki. Consistent query [4] O. Benjelloun, A. Das Sarma, A. Y. Halevy, and J. Widom. [5] P. Bohannon, W. Fan, M. Flaster, and R. Rastogi. A [6] J. Boulos, N. N. Dalvi, B. Mandhani, S. Mathur, C. R X , and [7] R. Cheng, S. Singh, and S. Prabhakar. U-DBMS: A database [8] J. Chomicki and J. Marcinkowski. Minimal-change integrity [9] G. Cong, W. Fan, F. Geerts, X. Jia, and S. Ma. Improving [10] N. N. Dalvi and D. Suciu. Efficient query evaluation on [11] W. W. Eckerson. Data quality and the bottom line: Achieving [12] W. Fan. Dependencies revisited for improving data quality. [13] I. Fellegi and D. Holt. A systematic approach to automatic [14] A. Fuxman, E. Fazli, and R. Miller. ConQuer: efficient [15] R. Jampani, F. Xu, M. Wu, L. L. Perez, C. Jermaine, and P. J. [16] X. Lian, L. Chen, and S. Song. Consistent query answers in [17] C. Re, N. Dalvi, and D. Suciu. Efficient top-k query [18] F. Sadri. Reliability of answers to queries in relational [19] M. A. Soliman, I. F. Ilyas, and K. C. Chang. Top-k query [20] D. Z. Wang, E. Michelakis, M. Garofalakis, and [21] J. Wijsen. Database repairing using updates. T ODS , 30(3), [22] W. E. Winkler. Methods for evaluating and creating data Appendix
