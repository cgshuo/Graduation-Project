 Intrusion detection is a very important topic of network security that has re-ceived much attention [5,9,4,7] since potential cyber threats are making the organizations vulnerable. Intrusion Detection Systems (IDS) are intended to protect information systems against intrusions and attacks and are traditionally based on signatures of known attacks [8,1]. Therefore, new kinds of attacks reg-ularly have to be added to the signature list. The main drawback is that in case of an emerging attack, based on the recent discovery of a new security hole for instance, the IDS will ignore it since this new attack has not yet been listed in the base of signatures.
 adaptive framework is an important topic in this domain. One answer to that problem could rely on data mining. Data mining tools have been used to pro-vide IDS with more adaptive detection of cyber threats [2,10]. Among those data mining approaches, anomaly detection tries to deduce intrusions from atypical records [4,3]. The overall principle is generally to build clusters, or classes, of usage and find outliers ( i.e. events that do not belong to any class or group identifying normal usage). However, the main drawback of detecting intrusions by means of anomaly (outliers) detection is the high rate of false alarms since an alarm can be triggered because of a new kind of usages that has never been seen before (and is thus considered as abnormal). Considering the large amount of new usage patterns emerging in the Information Systems, even a weak percent of false positive will give a very large amount of spurious alarms that would be over-whelming for the analyst. Therefore, the goal of this paper is to propose an intru-sion detection algorithm that is based on the analysis of usage data coming from multiple partners in order to reduce the number of false alarms. Our main idea is that a new usage is likely to be related to the context of the information system on which it occurs (so it should only occur on this system). On the other hand, when a new security hole has been found on a system, the hackers will want to use it in as many information systems as possible. Thus a new anomaly that occurs on two (or more) information systems is probably not a new kind of usage, but rather an intrusion attempt. Let us consider A x , an anomaly detected in the us-age of web site S 1 corresponding to a php request on the staff directory for a new employee: John Doe, who works in room 204, floor 2, in the R&amp;D department. The request will have the following form: staff.php?FName=John\&amp;LName=Doe \&amp;room=204\&amp;floor=2\&amp;Dpt=RD . This new request, due to the recent recruit-ment of John Due in this department, should not be considered as an attack. On the other hand, let us consider A y , an anomaly that corresponds to a true intru-sion. A y will be based on a security hole of the system (for instance a php vulner-ability) and might, for instance, look like: staff.php?path=../etc/passwd%00 . One can see in this request that the parameters are not related to the data ac-cessed by the php script, but rather to a security hole that has been discovered on the staff script. If two or more firms use the same script (say, a directory resquesting script bought to the same software company) then the usage of this security hole will certainly be repeated from one system to another and the re-quest having parameter ../etc/passwd%00 will be the same for all the victims. In this paper, we propose to provide the end-user with a method that takes only one parameter: n , the number of desired alarms. Then, based on the analysis of the usage data coming from the different partners, our algorithm will detect n common outliers they share. Such common outliers are likely to be true attacks and will trigger an alarm.
 this approach and our general fr amework. Section 3 presents Cod ,ourmethod for detecting outliers and triggering true alarms. Eventually, our method is tested through a set of experiments in Sectio n 4 and Section 5 gives the conclusion. In this paper we present Cod (Common Outlier Detect ion) a framework and algorithm intended to detect the outliers shared by at least two partners in a collaborative IDS. Outliers are usually small clusters and our goal is to use outlier lists from different systems (based on a similar clustering, involving the same similarity measure). If an outlie r occurs for at least two systems, then it is considered as an attack. Cod is indeed based on the assumption that an intrusion attempt trying to find a weakness of a script will look similar for all the victims of this attack. For clarity of presentation we present our framework on the collaboration of two Web sites, S 1 and S 2 and we consider the requests that have been received by the scripts of each site (cgi, php, sql, etc). Our goal is to perform a clustering on the usage patterns of each site and find the common outliers. However, that would not be eno ugh to meet the second constraint of our objective: to require only one parameter, n , the number of alarms to return. Our similarity measure (presented in section 3.1) will allow normal usage patterns to be grouped together rather than grouped with intrusion patterns. On the other hand, our similarity measure also has to ensure distinguishing an intrusion pattern from normal usage patterns and from other intrusion patterns (since different intrusion patterns will be based on a different security hole and will have very different characteristics). Our algorithm performs successive clustering steps for each site. At each step we check the potentially matching outliers between both sites. The clustering algorithm is agglomerative and depends on the maximum dissimilarity ( MD ) that has to be respected between two objects. time. Then, the potential alarms will be triggered at each step of the monitoring (for instance with a frequency of one hour). Depending on the number of true or false alarms, the user might want to adjust n for the next step, until no (or very few) false alarm is returned. Our assumption is that common outliers, sorted by similarity from one site to another, will give the intrusions at the beginning of the list. The principle of Cod is to perform successive clustering steps on usage patterns of different partners sites, until the number of common outliers meets the number of alarms desired by the user. We present in this section an algorithm designed for two information systems. Extending this work to more than two systems would require a central node coordinating the comparisons and triggering the alarms, or a peer-to-peer communication protocol. This is not the goal of this paper. Our objects are the parameters given to script files in the requests received on a Web site. In other words, the access l og file is filtered and we only keep lines corresponding to requests with parameters to a script. For each such line, we separate the parameters and for each par ameter we create an object. Let us con-sider, for instance, the following request: staff.php?FName=John&amp;LName=Doe . The corresponding objects are o 1 = John and o 2 = Doe . Once the objects are obtained from the usage data of multiple Web sites, Cod is applied and gives their common outliers. 3.1 Main Algorithm As explained in section 2, Cod algorithm will process the usage patterns of both sites step by step. For each step, a clustering result is provided and analyzed for intrusion detection. First, MD is set to obtain very tight and numerous clusters (very short similarity is allowed bet ween two objects in a cluster). Then, MD is relaxed by an amount of 0 . 05 step after step in order to increase the size of resulting clusters, decrea se their number and lower the number of alarms. When the number of alarms desired by the user is reached, then Cod ends.
 Algorithm Cod Input: U 1 and U 2 the usage patterns of sites S 1 and S 2 Output: I the set of clusters corresponding 1. Build M , the distance matrix between each pattern ; 2.  X  p  X  M, Neighbours p  X  sorted list of neighbours for p (the first usage 3. DensityList  X  sorted list of patterns by density ; 4. MD  X  0; 5. MD  X  MD +0 . 05 ; 6. C 1  X  Clustering ( U 1 ,MD ); 7. O 1  X  Outliers ( C 1 ); O 2  X  Outliers ( C 2 ); 8. I  X  CommonOutliers ( O 1 ,O 2 ,MD ); 9. If | I | X  n then return I ; 10. If MD = 1 then return I ;//Nocommonoutlier 11. Else return to step 5 ; End algorithm Cod 3.2 Clustering Cod Clustering algorithm is based on an agglomerative principle. The goal is to increase the volume of clusters by adding candidate objects, until the Maximum Dissimilarity ( MD )isbroken( i.e. there is one object o i in the cluster such that the similarity between o i and the candidate object o c is greater than MD ). Similarity between objects . We consider each object as a sequence of char-acters. Our similarity is then based on the longest common subsequence (LCS), as described in definition 1.
 Definition 1. Let s 1 and s 2 be two sequences. Let LCS ( s 1 ,s 2 ) be the length of the longest common subsequences between s 1 and s 2 .The dissimilarity d ( s 1 ,s 2 ) between s 1 and s 2 is defined as follows: d ( s 1 ,s 2 )=1  X  2  X  LCS ( s 1 ,s 2 ) | s Example 1. Let us consider two parameters p 1 = intrusion and p 2 = induction . The LCS between p 1 and p 2 is L = inuion . L has length 6 and the similarity between p 1 and p 2 is d =1  X  2  X  L | p of 66 . 66% between both parameters.
 Centre of clusters. When an object is inserted into a cluster we maintain the centre of this cluster, since it will be used in the CommonOutliers algorithm. The centre of a cluster C is the LCS between all the objects in C . When object o i is added to C , its center C c is updated. The new value of C c is the LCS between the current value of C c and o i .
 Algorithm Clustering Input: U , the usage patterns Output: C , the set of as large clusters as possible, 1. i  X  0; C  X  X  X  ; 2. p  X  next unclassified pattern in DensityList ; 3. i ++ ; c i  X  p ; 4. C  X  C + c i ; 5. q  X  next unclassified pattern in Neighbours p ; 6.  X  o  X  c i If d ( o, q ) &gt;MD then return to step 2 ; 7. add q to c i ; 8. C c  X  LCS ( C c ,q );// C c is the center of C 9. return to step 5 ; 10. If unclassified patterns remain then return to step 2 ; 11. return C ; End algorithm Clustering 3.3 Detecting Common Outliers Our outlier detection principle is described in [6]. Since we want our global algo-rithm to require only one parameter (the number of alarms), we want to avoid introducing a similarity degree for comparing two lists of outliers. For this com-parison, our algorithm uses the centre of outliers. For each pair of outliers, it calculates the similarity between centers of these outliers. If this similarity is below the current MD , then we consider those outliers as similar and add them to the alarm list. The goal of this section is to analyze our results ( i.e. the number of outliers and true intrusions and the kind of intrusions we have detected). Our datasets come from two different research organizations; ( anonymized for submission ). We have analyzed their Web access log files from March 1 to March 31. The first log file represents 1.8 Gb of rough data. In this file, the total number of objects (parameters given to scripts) is 30,454. The second log file represents 1.2 Gb of rough data and the total number of objects is 72,381. Cod has been written in Java and C++ on a PC (2.33GHz i686) running Linux with 4Gb of main memory. Parameters that are automatically generated by the scripts have been removed from the datasets since they cannot correspond to attacks (for instance  X  publications.php?Category=Books  X ). This can be done by listing all the possible generation of param eters in the scripts of a Web site. 4.1 Detection of Common Outliers As described in Section 2, Cod proceeds by steps and slowly increases the value of MD , which stands for a tolerance value when grouping objects during the clustering process. In our experiments, MD has been increased by steps of 0 . 05 from 0 . 05 to 0 . 5. For each step, we report our measures in table 1. The mean-ing of each measure is as follows. O 1 (resp. O 2 ) is the number of outlying ob-jects in site 1 (resp. site 2). % 1 (resp % 2 ) is the fraction of outlying objects onthenumberofobjectsinsite1(r esp. site 2). For instance, when MD is set to 0 . 3, for site 1 we have 5,607 outlying objects, which represents 18 . 4% of the total number of objects ( i.e. 30,454) in site 1. COD is the number of common outliers between both sites and % FA is the percentage of false alarms within the common outliers. For instance, when MD is set to 0 . 05, we find 101 alarms among which 5 are false (which represents 4 . 9%). One first obser-vation is that outliers cannot be directly used to trigger alarms. Obviously, a number as high as 5,607 alarms to check, even for one month, is not realistic. On the other hand, the results of Cod show its ability to separate malicious behaviour from normal usage. Our false alarms correspond to normal requests that are common to both sites but rarely occur. For instance, on the refer-ences interrogation script of anonym lab1 , a user might request papers of  X  X ohn Doe X  and the request will be publications.php?FName=John\&amp;LName=Doe .If another user requests papers of  X  X ohn Rare X  on the Web site of anonym lab2 ), the request will be biblio.php?FName=John\&amp;LName=Rare and the parameter  X  X ohn X  will be given as a common outlier and trigger an alarm. As we can see, % FA is very low (usually we have at most 5 false alarms in our exper-iments for both Web sites) compared to the thousands of outliers that have been filtered by Cod . Another lesson from these experiments is that a low MD implies very small clusters and numerous outliers. These outliers are shared be-tween both sites, among which some are false alarms due to rare but common normal usage. When MD increases, the clustering process gets more agglomer-ative and alarms are grouped together. Then one alarm can cover several ones of the same kind ( e.g. the case of easter eggs explained further). At the same time, the number of outliers corresponding to normal usage decreases (since they are also grouped together). Eventually, a too large value of MD implies building clusters that do not really make sense. In this case, outliers will get larger, and the matching criteria will get too tolerant, leading to a large num-ber of matching outliers capturing normal usage. In a streaming environment involving the real data of these experiments, one could decide to keep 70 as the number of desired alarms and watch the ratio of false alarms. If this ratio decreases, then the end-us er should consider increa sing the number of desired alarms.
 4.2 A Sample of Our Results None of the attacks found in our experiments have been successful on the consid-ered Web sites. However, our security se rvices and our own investigations allow us to confirm the intrusion attempts that have been discovered by our method:  X  X odeInjection: a recent kind of attack aims to inject code in PHP scripts  X  Passwords: another kind of (naive and basic) attack aims to retrieve the  X  Easter Eggs: this is not really an intrusion but if one adds the code In this paper, we have proposed i) an unsupervised clustering scheme for isolat-ing atypical behaviours, ii) a parameter less outlier detect ion method based on wavelets and iii) a new feature for characterizing intrusions. This new feature is based on the repetition of an intrusion attempt from one system to another. Ac-tually, our experiments show that atypical behaviours cannot be directly used to trigger alarms since most of them corre spond to normal requests. On the other hand, this very large number of outliers can be effectively filtered (reducing the amount of atypical behaviours up to 0 . 21%) in order to find true intrusion at-tempts (or attacks) if we consider more than one site. Eventually, our method guarantees a very low ratio of false alarms, thus making unsupervised clustering for intrusion detection effective, realistic and feasible.
 The authors want to thank Laurent Mirtain, the responsible for intrusion de-tection of Inria Sophia-Antipolis, for his assistance in identifying attacks in our access log files.

