 The AncestorRank algorithm calculates an authority score by using just one characteristic of the web graph X  X he number of ancestors per node. For scalability, we estim ate the number of ancestors by using a probabilistic counting algor ithm. We also consider the case in which ancestors which are closer to the node have more influence than those farther from the node. Thus we further apply a decay factor  X  on the contributions from successively earlier ancestors. The resulting authority score is used in combination with a content-based ranking algorithm. Our experiments show that as long as  X  is in the range of [0.1, 0.9], AncestorRank can greatly improve BM25 performance, and in our experiments is often better than PageRank. H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval Algorithms Probabilistic counting, link analysis, PageRank
A web page X  X  authority score is usually computed by analyz-ing the link structure of web graph. In this paper, we define ancestors to be the set of unique nodes with one or more di-rected paths to the target node. We analyzed the link structure based on the following assumptions:
These give us the intuition to calculate the decayed number of ancestors, that is, the decayed sum of all ancestors. For every node in the graph, we combine this information with BM25 result and our experiments show that AncestorRank can boost BM25 perfor-mance greatly. The intuition of AncestorRank is not unlike PageR-ank [2], yet is more straightforward and in our experiments has performance comparable or better than that of PageRank.

PageRank is a popular and well-studied link-based algorithm used to estimate authority. The intuition behind AncestorRank is similar to that of PageRank, except for two major differences. In our algorithm, a node has the same influence on its children, re-gardless of how many children the node has. In addition, the scores produced by AncestorRank do not form a probability distribution and thus are not intended to be representative of the actions of any kind of surfer.

A naive algorithm to count exactly the number of ancestors would be expensive: O ( n 2 ) . Simpler approaches that would be faster might over count nodes because of multiple paths, or would require significant storage resources. In order to retain scalabil-ity for large graphs but not to over count the number of ancestors, we turn to a probabilis tic counting approach, originally proposed by Flajolet and Martin [4]. A more recent refinement was offered by Becchetti et al. [1]. It is simpler and more accurate when the distance under consideration is small. It can also be viewed as a generalization of the ANF algorithm [5]. Their definition of supporter is same as our definition of ancestor . Becchetti et al. also provide an adaptive estimation process to select the best probabilistic representation. Their search process updates ,the probability of initializing a bit i n a node X  X  bit vector to 1, by mul-tiplying it by  X  (called MULT in their work) after every iteration, until the representation can accurately estimate the value for the current node.
We estimate the number of ancestors from distance 1 to i ,where for any distance greater than i , there are no additional ancestors for any node in the webgraph. After that, we apply the decay factor  X  to count the decayed number of ancestors for every node.
  X  is the decay factor, 0  X   X   X  1 .When  X  is 0.0, we simply count the number of inlinks (parents). When  X  is 1.0, we count the number of ancestors without decay. N i ( x ) is the sum of ancestor counts distance 1 to i . N i ( x )  X  N i  X  1 ( x ) is the number of new ancestors appearing in distance i .

After computing the decayed number of ancestors, we order all nodes by this value, and linearly combine each node X  X  rank with the rank of the query-specific IR score based on content. The IR score that we choose to combine is the OKAPI BM25 [8] weighting function, and the parameters are set to be the same as Cai et al. [3]. Figure 1: Error rate of probabilistic counting on 8 test graphs.
We use the TREC (http://trec.nist.gov/) GOV collection, which contains a 1.25M web page crawl of the .gov domain from 2002. To test ranking algorithms on the GOV corpus, we chose the topic dis-tillation task in the web track of TREC 2003, which has 50 queries.
Since we combine our ranked list with BM25, we use it as the baseline. In addition, we chose some popular authority ranking algorithms with which we can compare, including PageRank and Global HITS (denoted as GHITS) in which the hub and authority calculation of HITS [7] is applied to the full web graph, not just a query-specific subgraph. All algorithms have been linearly com-bined with BM25.

In order to compare our results with existing work, we evaluated the ranking algorithms using Precision@10, MAP (Mean Average Precision), RPrec, and NDCG@10 [6]. For every approach, we tune the combining parameter to get the best P@10 and output this result as the final performance.

In order to estimate the number of ancestors, we utilized Bec-chetti et al. X  X  adaptive probab ilistic counting appr oach. We set the bit vector representation to be 64 bits and tuned the  X  factor in the adaptive probabilistic countin g algorithm. In every iteration, the current = last _  X   X  . In our experiments, we find that the  X  factor can have a huge effect on the error rate, compared to the real number of ancestors. Figure 1 shows the average relative error rates for eight sample test graphs with different sizes, based on  X  increasing by 0.1 from 0.1 to 2.0.

Generally speaking, the error rate is much smaller (3-17%) when  X  is less than 1. In each test graph, the error rate is minimized when  X  is 0.9 since it covers more possible values for .Yetit also requires more time to complete the whole process since more values are tested. Cognizant of this trade-off, we selected  X  to be 0.5 in our experiments on the TREC 2003 web graph.
Table 1 shows the final performance for some sample  X  increas-ing from 0.0 to 1.0. As long as the  X  is in the range of [0.1, 0.9], most metrics show better performance of AncestorRank over BM25, PageRank and GHITS. A student X  X  t-test confirms that the improvements shown over BM25 and PageRank for MAP, Rprec and NDCG are statistically significant ( p = . 05 for BM25 and p = . 10 for PageRank).

For AncestorRank, we implemen ted the probabilistic counting algorithm to count from distance = 1 to distance = i when there are no additional ancestors in distance greater than i . Ideally we can increase the decayed sum with  X  j  X  1 ( N j ( x )  X  N j  X  1 count the ancestors for distances j and j  X  1 . The estimation for current node x stops when N j ( x )= N j  X  1 ( x ) .Itcosts O memory in total, where k is the length of the bit vector representa-tion and N is the number of nodes in the graph. In the adaptive al-gorithm with  X &lt; 1 , for every node, the appropriate in the current distance should be smaller or equal to the that is appropriate for the previous distance. Thus, for distance j , would decrease from  X  as needed. N max ( j ) is the maximum of number of ancestors for any node at distance j , which is generally much smaller than N . N max (0) corresponds to the starting which we set to be 0.5. In addition, every time we want to use a new to count the number of ancestors for distance j , we need to go through the graph j times during that iteration. To sum up, for distance j , the number of times to read the whole graph is j l og 1 AncestorRank is tractable, unlike a naive counting algorithm with O (
N 2 ) time complexity.
AncestorRank estimates authority by summing for each page its decayed number of unique ancestors. While this algorithm is con-ceptually simple, it appears to have comparable or better perfor-mance than PageRank. Since counting exactly the decayed num-ber of ancestors is expensive, we leverage a probabilistic counting algorithm which provides fairly good estimates and is scalable in practice.
 This work was supported in part by a grant from the National Sci-ence Foundation under award IIS-0545875. We also thank Xinlei Wu for some preliminary aspects of this work.
