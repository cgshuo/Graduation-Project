 The wide adoption of XML has increased the interest of the database community on tree-structured data management techniques. Query-ing capabilities are provided through tree-pattern queries. The need for querying tree-structured data sources when their structure is not fully known, and the need to integrate multiple data sources with different tree structures have driven, recently, the suggestion of query languages that relax the complete specification of a tree pattern. In this paper, we use a query language which allows par-tial tree-pattern queries (PTPQs). The structure in a PTPQ can be flexibly specified fully, partially or not at all. To evaluate a PTPQ, we exploit index graphs which generate an equivalent set of  X  X om-plete X  tree-pattern queries.

In order to process PTPQs, we need to efficiently solve the PTPQ satisfiability and containment problems. These problems become more complex in the context of PTPQs because the partial speci-fication of the structure allows new, non-trivial, structural expres-sions to be derived from those explicitly specified in a PTPQ. We address the problem of PTPQ satisfiability and containment in the absence and in the presence of index graphs, and we provide neces-sary and sufficient conditions for each case. To cope with the high complexity of PTPQ containment in the presence of index graphs, we study a family of heuristic approaches for PTPQ containment based on structural information extracted from the index graph in advance and on-the-fly. We implement our approaches and we re-port on their extensive experimental evaluation and comparison. H.2.3 [ Database Management ]: Languages X  Query languages ; H.2.4 [ Database Management ]: Systems X  processing Management, Experimentation, Languages tree-structured data, partial tree-pattern query, query containment Copyright 2006 ACM 1-59593-433-2/06/0011 ... $ 5.00.
The wide adoption of XML has boosted the interest of the data-base community on tree-structured data management techniques. Querying capab ilities are provided through tree-pattern queries. For instance, XPath [1], the core query language of XQuery [2], spec-ifies queries essentially in the form of tree patterns. Answers are computed by matching tree patterns against the data trees. Pro-cessing tree pattern queries (TPQs) is central to the optimization of XQuery. For this reason, a lot of attention has been paid recently to the satisfiability, containment, and minimization problems for TPQs in the presence and in the absence of schemas.

Consider the following XPath expression retrieving information about authors from a bibliographic database: //subject[/year]//article[/title]//author .
 Figure 1(a) shows the corresponding TPQ (query Q ). Two other TPQs (queries Q and Q ) are shown in Figure 1(b) and 1(c), respectively. The nodes are labeled by elements; double line ar-year article rows denote descendant relationships, and single line arrows de-note child relationships; a star (*) marks the output node (the node returned in the answer). Even though TPQs provide some freedom in the specification of a tree structure (e.g. by allowing ancestor-descendant relationships), they all have a common restrictive re-quirement: in every root-to-leaf path, there is a total order for the nodes . For instance, in the rightmost path of TPQ Q , node subject precedes node year , which precedes node article , which precedes node title . It is not possible in a TPQ to indicate that two nodes n and n 2 occur in a path without specifying a precedence relationship between them: node n 1 has to precede node n 2 or vice-versa.
Such a requirement causes several problems. Consider for ex-ample a database that integrates tree-structured data exported from several data sources under different structures. These structures may order elements differently, and a single TPQ is not able to re-trieve the desired information from all of them. In addition, users may not be fully aware of the database structure. Usually they are not able to provide of total order for the elements specified in the query.

Evoking the techniques of previous approaches in this context does not solve these problems: using TPQs in conjunction with traditional data integration mapping rules between a global struc-ture and local structures [7] requires extensive manual interven-tion, is complex and subject to errors. Approaches that relax the constraints in TPQs [4] result in approximate answers. Finally, structure-less keyword-based approaches [8, 13] do not allow the specification of structural conditions in the queries to filter out un-desirable answers.
 Our approach. To deal with the problems above, we use here a language of partial tree-pattern queries. This language is based on the language introduced in [23] to query tree-structured data us-ing semantic information. Consider the query of Figure 2. This is a tree pattern where the tree structure is partially specified. It has three paths. The first path involves elements subject and year ,and year is a descendant of subject . The second path involves elements subject and article and no order is specified between them. The third path involves elements article , title and author .Element ti-tle is a child of article ,but author can be an ancestor of article or a descendant of title . The first and the second paths have a com-mon element subject , while the second and the third paths have a common element article . We call this type of queries Partial Tree-Pattern Queries (PTPQs). The structure in a PTPQ can be flexibly specified fully, partially or not at all .

The need for a language that allows a flexible specification of the structure has also been identified in [17]. However, the approach adopted there focuses on reducing the number of query matchings to those that are meaningful with respect to the context of the query. In contrast to our approach, the user has to specify TPQs; that is, the user has to specify an order for all the nodes in each path of the tree pattern.
 Problem addressed. Efficient evaluation of queries requires tech-niques for efficiently processing the queries. In this paper, we ad-dress the satisfiability and containment problems for PTPQs and we study properties of PTPQs. These problems become more com-plex in the context of PTPQs because the partial specification of the structure in the queries allows new, non-trivial, structural ex-pressions to be derived from those explicitly specified in a PTPQ. Therefore, we focus on finding heur istic approaches for checking PTPQ containment in the presence of index graphs.
 Contribution. The main contributions of this paper are the fol-lowing:  X 
We introduce a set of sound and complete inference rules, in order to deal with the derivation of structural expressions (con-straints) in PTPQs. We further define a  X  X ormal form X  for PT-PQs, called full form, to enable the study and comparison of
PTPQs. Intuitively, the full form of a PTPQ comprises all the structural expressions that can be derived from those explicitly specified in the PTPQ.  X 
We define index graphs that summarize the structure of data trees. Even though index graphs are not schemas, we exploit them to evaluate and process PTPQs in the same way schemas are exploited in relational databases.  X 
We define two types of PTPQ satisfiability: absolute and rela-tive. Relative satisfiability is defined with respect to an index graph. We then provide necessary and sufficient conditions for both types of PTPQ satisfiability. Detecting relative unsatisfia-bility during the evaluation of a PTPQ prevents the access of the database which is typically much larger than its index graph.  X 
We define two types of PTPQ containment: absolute query con-tainment and PTPQ containment with respect to an index graph (relative PTPQ containment). We provide necessary and suffi-cient conditions for checking both types of PTPQ containment.  X 
In order to deal with the high complexity of relative PTPQ con-tainment, we design a family of sound but not complete heuristic techniques based on structural expressions extracted from the in-dex graph. We devise two ways for applying our heuristic tech-niques, one that precomputes and stores the extracted structural expressions and one that computes the extracted structural ex-pressions on-the-fly.  X 
We implemented the containment checking approaches mentioned above (absolute and relative) including all the heuristic ones. We performed an extensive experimental evaluation to compare the pros and cons of every approach. Our experiments show that the heuristic approaches are efficient compared to non-heuristic ones while maintaining high accuracy. These results show that our techniques can be directly exploited for PTPQ processing and optimization.
 Paper outline. The next section discusses related work. Section 3 presents our language for PTPQs, studies the inference of structural expressions, and introduces index graphs and additional concepts. Section 4 addresses PTPQ satisfiability check. In Section 5, we study the two types of PTPQ containment checking. Heuristic ap-proaches for checking relative PTPQ containment are described in Section 6. Section 7 analyses the experimental results. We con-clude and discuss future work in Section 8. Proofs are omitted because of lack of space. They will be included in the full version of the paper.
There is considerable work on the satisfiability [12, 16], con-tainment [9, 18, 25, 20, 10, 6] and minimization problems [3, 22] for tree-pattern queries in the presence and the absence of schemas. None of these papers addresses query containment for PTPQs. Most of these works focus on studying the complexity of these problems for different classes of TPQs. Our goal in this paper is different. We are focusing on providing sound (but not necessarily complete) techniques for checking query containment that can be used for efficiently processing and optimizing PTPQs. To the best of our knowledge, this issue has not been addressed previously for this type of queries.

Index graphs have been referred to with different names in the lit-erature, including  X  X ath summaries X ,  X  X ath indexes X  and  X  X tructural summaries X . They differ in the equivalence relations they employ to partition the nodes of the database, which includes simulation and bisimulation [19, 14], or even semantic equivalence relations [23]. Index graphs have been extensively studied in recent years in both the  X  X xact X  [11, 19, 21, 5] and the  X  X pproximate X  flavor [15, 14]. A common characteristic of those approaches is that the index graph is used as a back end for evaluating a class of path expressions without accessing the database. To this end, the equiv-alence classes of database nodes are attached to the correspond-ing index graph nodes. For the needs of PTPQs, we define index graphs where the equivalence classes are formed by all the nodes labeled by the same element in the database. In contrast to other approaches, here, the equivalence classes of the database nodes are not kept with the index graph. Therefore, PTPQs are ultimately evaluated on the database tree. The index graphs are used to sup-port the evaluation of PTPQs and the satisfiability and containment checking.

Partially specified tree-pattern queries were initially introduced in [23]. That query language assu med a partitioning of the nodes of a data tree based on semantic information. Subsequently, this semantic information was taken into account for querying the data tree. On the contrary, in this paper we view data trees as XML doc-uments, and we partitio n their nodes using merely their labeling elements (tags). This modifies also the way structural expressions can be derived. The containment problem for the class of queries considered in [23] was addressed in [24]. That paper does not ad-dress heuristic approaches for the containment of PTPQs which is the main focus of the present work.
We present in this section the data model and our query language that allows for partially specifying the structure of a tree pattern. Our goal in this paper is to focus on the structural aspects of the queries. Therefore, we retain only structural expressions and we abstract attribute and value restrictions, and variables that a full-fledged query language would normally comprise.
Let E be an infinite set of elements that includes a distinguished element r .A database is a finite tree of nodes labeled by elements in E , rooted at a node labeled by r (such a root node can always assume that the same element does not label two nodes on the same path. The attributes of an XML document are modeled here using the element nodes of such a tree.
 D EFINITION 3.1. A Partial Tree-Pattern Query (PTPQ) is a triple Q =( P , N ,o ) ,where: (a) P is a nonempty set of pairs ( p, R ) called Partial Paths (PPs). (b) N is a set of expressions of the form e [ p i ]  X  e [ (c) o is a PP in P . It is called output PP of Q .

We graphically represent PTPQs using graph notation. Each PP of a PTPQ Q is represented as a (not necessarily connected) graph of elements. The name of each PP is shown by the corresponding PP graph. The name of the output PP of Q is followed by a  X * X . Child and descendant precedence relationships in a PP are depicted using single (  X  ) and double (  X  ) arrows between the respective elements in the PP graph. In particular, descendant precedence re-lationships of the form r  X  e in a PP are shown only with the presence of element e in the PP graph. A node sharing expression e [ p i ]  X  e [ p j ] is represented by an edge between element e of the PP graph p i and element e of the PP graph p j labeled by 3, 4, and 5 show three PTPQs.

The answer of a PTPQ is based on the concept of PTPQ embed-ding.

D EFINITION 3.2. An embedding of a PTPQ Q to a database D is a mapping M of the elements of the PPs of Q to nodes in D such that: (a) an element e of Q is mapped by M to a node in D labeled by e ; (b) the elements of a PP in Q are mapped by M to nodes in D that are on the same path; (c)  X  e i [ p ]  X  e j [ p ] (resp. e in Q , M ( e j [ p ]) is a child (resp. descendant) of M ( (d)  X  e [ p i ]  X  e [ p j ] in Q , M ( e [ p i ]) and M (
We call image of a PP p in Q under M , denoted M ( p ) , the path from the root of D that comprises all the images of the elements of p under M and ends in one of them. Notice that more than one PP of Q may have their image on the same root-to-leaf path of D ( M does not have to be a bijection). The answer of Q on D is the set of the images of the output PP of Q under all possible embeddings of Q to D .

Notice that the PTPQ language allows the formulation of queries with no structure at all by specifying a single node per PP and no node sharing expressions. This resembles a flat keyword-based query. However, unlike such a query, a PTPQ returns a structured answer. On the other side, the PTPQ language also allows the for-mulation of queries that are completely structured trees by specify-ing only child relationships and node sharing expressions. Between the two extremes, there are PTPQs that provide some description of the structure without completely specifying a tree.
Precedence relationships and node sharing expressions are col-lectively called structural expressions . Because the structure of tree patterns is partially specified in PTPQs, new, non-trivial structural expressions can be derived from those explicitly specified in the queries. Many of these derivations are specific to PTPQs. Con-sider, for instance, query Q 1 of Figure 3. Since, c [ p 1 e [ p PP p 2 ). Since, b [ p 3 ]  X  a [ p 3 ] and a [ p 3 ]  X  c [ b [ p 3 ]  X  c [ p 3 ] . Since, b [ p 3 ]  X  a [ p 3 ] , b [ p 3 ]  X  PP p 2 , we can derive b [ p 2 ]  X  a [ p 2 ] (indeed, since b if a [ p 2 ]  X  b [ p 2 ] , we can derive a [ p 3 ]  X  b [ p Checking efficiently structural expression derivation is central in processing PTPQs. In this section, we address this problem.
Let S be a set of structural expressions of a PTPQ Q ,and s be a structural expression. We say that s is derived from S iff for every embedding M of Q to a database, M satisfies s .The closure of S is the set that comprises exactly the structural expressions in S and all the structural expressions that can be derived from S .
To compute closures of sets of structural expressions, we intro-duce a set of inference rules. Let a , b , c and d be distinct elements and p , p 1 ,and p 2 be distinct PPs. We use the symbol to de-note that the expressions that precede it produce the expression that follows it. The absence of expressions that precede denotes an axiom. Figure 6 shows a set of inference rules. (IR1) r [ p 1 ]  X  r [ p 2 ] (IR2) a [ p 1 ]  X  a [ p 2 ] ,a [ p 2 ]  X  a [ p 3 ] a [ p 1 (IR3) a structural expression that involves a [ p ] (IR4) a [ p ]  X  b [ p ] a [ p ]  X  b [ p ] (IR5) a [ p ]  X  b [ p ] ,b [ p ]  X  c [ p ] a [ p ]  X  c [ p (IR6) a [ p ]  X  b [ p ] ,a [ p ]  X  c [ p ] b [ p ]  X  c [ p (IR7) a [ p ]  X  b [ p ] ,c [ p ]  X  b [ p ] c [ p ]  X  a [ p (IR8) a [ p 1 ]  X  b [ p 1 ] ,b [ p 1 ]  X  b [ p 2 ] a [ p 2 (IR9) a [ p 1 ]  X  b [ p 1 ] ,b [ p 1 ]  X  b [ p 2 ] a [ p 2 (IR10) a [ p 1 ]  X  b [ p 1 ] ,a [ p 1 ]  X  a [ p 2 ] ,r [ p (IR11) a [ p 1 ]  X  b [ p 1 ] ,b [ p 1 ]  X  b [ p 2 ] a [ p (IR12) a [ p 1 ]  X  b [ p 1 ] ,c [ p 2 ]  X  b [ p 2 ] ,d [ p (IR13) a [ p 1 ]  X  b [ p 1 ] ,a [ p 2 ]  X  c [ p 2 ] ,d [ p (IR14) a [ p 1 ]  X  b [ p 1 ] ,b [ p 2 ]  X  a [ p 2 ] ,c [ p (IR15) c [ p ]  X  b [ p ] ,b [ p 2 ]  X  c [ p 2 ] ,a [ p ]  X  (IR16) a [ p ]  X  c [ p ] ,b [ p 2 ]  X  c [ p 2 ] ,a [ p ]  X 
The next theorem states that these rules correctly and completely characterize structural expression derivation.

T HEOREM 3.1. Let S be a set of structural expressions of a query, and s be a structural expression not in S . The set of in-ference rules of Figure 6 is sound (if s can be produced from S using the inference rules, then s can also be derived from S ), and complete (if s can be derived from S ,then s appears in S , or can also be produced from S using the inference rules).
 To study properties of PTPQs, we introduce a  X  X ormal form X  for PTPQs called full form . A PTPQ Q is in full form if the set S of structural expressions of Q equals the closure of S . Clearly, a PTPQ can be equivalently put in full form by replacing its set S of structural expressions in Q by the closure of S .

Figures 7 and 8 show the full form of the PTPQs Q 1 and Q Figures 3 and 4 respectively. Query Q 3 of Figure 5 is in full form. For clarity of presentation, when graphically representing queries in full form, we do not depict structural expressions that can be inferred trivially from the shown structural expressions using the inference rules IR1 -IR5.
Clearly, there can be only a polynomial number of structural ex-pressions in the closure of a set of structural expressions. In prac-tice, only a small percentage of the maximal possible number of expressions appear in the closure of the structural expressions of a PTPQ, and therefore, the cost of computing the full form of a PTPQ is insignificant.
Given a partitioning of the nodes of a database D , an index graph for D is a graph G such that: (a) every node in G is associated with a distinct equivalence class of nodes in D , and (b) there is an edge in G from the node associated with the equivalence class a to the node associated with the equivalence class b ,iffthereis an edge in D from a node in a to a node in b . Figure 9 shows an index graph G . Even though the index graph for a database is not a schema in the form of a DTD or an XML Schema, we take advantage of it in the same way schema information is exploited in relational databases. We use index graphs to support the evaluation of a PTPQs through the generation of an equivalent set of complete TPQs. We also use index graphs to process PTPQs; this comprises identifying valid clusters (introduced later) in a PTPQ, checking a PTPQ for satisfiability, and checking two PTPQs for containment. If G is the index graph of a database D , we say that D underlies G .GivenaPTPQ Q andanindexgraph G , Q can be evaluated by computing a set of complete TPQs whose answers taken together are equal to the answer of Q on any database underlying G .By complete TPQ, we mean a TPQ that involves only child relation-ships (and therefore, completely specifies a tree pattern.) A com-plete TPQ for Q on G is a TPQ T rooted at a node labeled by r that satisfies the following conditions: (a) T has a distinguished node called output node that defines a from-the-root path called output path (b) there is a mapping M from the nodes of Q to the nodes of T that respects paths, output paths, labeling elements, prece-dence relationships, and node sharing expressions, and (c) there is a mapping M from the nodes of T to the nodes of G that respects labeling elements and child precedence relationships. To minimize the set of TPQs that are able to compute the answer set of Q ,we further require for T that: (a) every leaf node of T is the image of a node of Q under M , and (b) the images under M of two nodes d [ p 1 ] and d [ p 2 ] of Q do not coincide unless d [ p 1 ]  X  be derived from the set of structural expressions of Q . Figure 10 shows the complete TPQs T 1 1 and T 2 1 for the PTPQ Q 1 of Figure 3 on the index graph G of Figure 9. Notice that it is possible that all the nodes of two distinct PPs of Q are mapped by M to nodes on thesamepathin T (e.g. this is the case with PP p 1 and p 2 which are mapped on the same path in T 1 1 and T 2 1 .) Figure 10: The complete TPQs of PTPQ Q 1 on index graph G : (a) T 1 1 ,(b) T 2 1 In terms of PTPQs, the output PTPQ of a complete TPQ T for a PTPQ on G is the path from the root of T to the output node of T . The answer of a complete TPQ T is defined similarly to that of a PTPQ. We can now show the following proposition.
 P ROPOSITION 3.1. Let Q be a PTPQ, G be an index graph, and T ,...,T k ,k  X  1 , be the complete TPQs of Q on G . Let also A, A 1 ,...,A k be the answers of Q, T 1 ,...,T k , respectively, on a database underlying G .ThenA=  X  i  X  [1 ,k ] A i .
The presence of two node sharing expressions a [ p 1 ]  X  a b [ p 2 ]  X  b [ p 3 ] in a PTPQ Q with no derived precedence relationship ery tree in which there is an embedding of Q to comprise a path that involves a number of elements which together do not appear in any PP of Q . A similar phenomenon appears when two node shar-ing expressions a [ p 1 ]  X  a [ p 2 ] and b [ p 1 ]  X  b [ Q along with the child precedence relationships a [ p 1 ]  X  ding of Q comprises a path that satisfies a  X  a 1 and b  X  though these child precedence relationships do not appear together in any PP of Q . For simplicity, when checking absolute PSTP con-tainment, we assume that: (a) if a [ p 1 ]  X  a [ p 2 ] and b appear in a PSTP Q and no precedence relationship can be derived between a [ p 2 ] and b [ p 2 ] ,then a [ p 2 ]  X  a [ p 3 appear in Q ,and(b)if a [ p 1 ]  X  a [ p 2 ] and b [ p 1 ]  X  along with the child precedence relationships a [ p 1 ]  X  ...  X  a k [ p 1 ] ,and b [ p 2 ]  X  b 1 [ p 2 ]  X  ...  X  b m precedence relationships a [ p 2 ]  X  a 1 [ p 2 ]  X  ...  X  a b [ p 1 ]  X  b 1 [ p 1 ]  X  ...  X  b m [ p 1 ] also appear in Q .
A cluster is a set C of PPs and node sharing expressions such that for every partition of C in two non-empty sets there is a node sharing expression on an element different than r that involves PPs from both sets (that is, the cluster does not comprise disconnected sets of PPs). Given an index graph G ,aclusteris valid w.r.t. G if for every database D underlying G , there is an embedding of C into D . Figure 11 shows a valid cluster w.r.t. the index graph of Figure 9. The reader can verify that C is valid since for every path p from the root of G that comprises the edge d  X  e (there are two of them r  X  a  X  c  X  d  X  e and r  X  b  X  a  X  c  X  d  X  e )there is an element and precedence relationship preserving mapping of the nodes of C to the nodes of p .

Valid clusters can be detected and removed from a PTPQ to yield an equivalent PTPQ. Therefore, in checking relative PTPQ contain-ment, we assume that a PTPQ Q does not contain disconnected valid clusters that do not comprise the output PP of Q .
APTPQis satisfiable iff it has a non-empty answer on some database. In the presence of an index graph G , we say that a query is satisfiable w.r.t. G iff it has a non-empty answer on some database underlying G . We qualify the first type of PTPQ satis-fiability as absolute and the second as relative . Clearly, a satis-fiable query w.r.t. G is also satisfiable. The opposite is not nec-essarily true. As an example, adding the precedence relationship e [ p 2 ]  X  a [ p 2 ] to PP p 2 of query Q 1 of Figure 3, results in a query Q 1 unsatisfiable w.r.t. index graph G of Figure 9. Nevertheless, Q 1 is absolutely satisfiable. Adding the precedence relationship c [ p 2 ]  X  b [ p 2 ] to PP p 2 of query Q 1 of Figure 3, results in an un-satisfiable query.
 Absolute satisfiability. PTPQ Q 1 becomes unsatisfiable after the addition of c [ p 2 ]  X  b [ p 2 ] because c [ p 2 ]  X  b [ descendant precedence relationship b [ p 2 ]  X  c [ p 2 ] that can be de-rived from the set of structural expressions of Q 1 (see the full form of Q 1 in Figure 7). This condition is necessary as the next propo-sition shows.

P ROPOSITION 4.1. A PTPQ is unsatisfiable iff two contradict-ing descendant precedence relationships a [ p ]  X  b [ p ] a [ p ] (for the same PP p ) appear in its full form.
 Detecting an absolutely unsatisfiable PTPQ avoids evaluating the PTPQ to compute an empty answer. The overhead for this check amounts to computing the full form of the query which, in practice, is insignificant.
 ity w.r.t. an index graph G ), Proposition 3.1 suggests that if the set of complete TPQs of a PTPQ Q on G is empty, Q is unsatisfiable w.r.t. G . The following proposition sho ws that this condition is also necessary.
 P ROPOSITION 4.2. Let Q beaPTPQand G be an index graph. PTPQ Q is unsatisfiable w.r.t. G iff there is no complete TPQ for Q on G .

Query Q 1 resulting by adding the descendant precedence rela-tionship e [ p 1 ]  X  a [ p 1 ] to PP p 1 of query Q 1 of Figure 3 is un-satisfiable w.r.t. the index graph G of Figure 9: query Q complete TPQs on G and both of them violate the precedence rela-tionship e  X  a . Therefore, Q 1 has no complete TPQ w.r.t. G .
Relative unsatisfiability of a PTPQ is detected during the gen-eration of its complete TPQs on the index graph. This detection saves accessing the database which is typically orders of magni-tude larger than its index graph.

Checking PTPQ containment subsumes checking PTPQ satisfi-ability: a PTPQ is unsatisfiable (w.r.t. an index graph G ) iff it is contained in an unsatisfiable PTPQ (w.r.t. G ). In studying PTPQ containment, we assume, in the following, that PTPQs are satisfi-able (w.r.t. G ).
Let Q 1 and Q 2 be two PTPQs. Q 1 contains Q 2 (denoted Q Q )iffforeverydatabase D , the answer of Q 2 on D is a subset of the answer of Q 1 on D .PTPQs Q 1 and Q 2 on D are equivalent (denoted Q 2  X  Q 1 )iff Q 1  X  Q 2 and Q 2  X  Q 1 . This type of PTPQ containment is called absolute . To exploit the presence of an index graph we also define PTPQ containment w.r.t. an index graph G : Q 1 contains Q 2 w. r. t . G (denoted Q 2  X  G Q every database D underlying G , the answer of Q 2 on D is a subset of the answer of Q 1 on D .PTPQs Q 1 and Q 2 on D are equivalent w. r. t . G (denoted Q 2  X  G Q 1 )iff Q 1  X  G Q 2 and Q 2 latter type of PTPQ containment is characterized as relative .An unsatisfiable PTPQ (w.r.t. an index graph G ) is contained in any PTPQ (w.r.t. G ). Similar to PTPQ satisfiability, absolute contain-ment implies relative containment, while the opposite is not neces-sarily true.

Considering the PTPQs Q 1 , Q 2 and Q 3 of Figures 3, 4, and 5 and the index graph G of Figure 9, one can see that Q 2  X  Therefore, Q 2  X  G Q 3 .However, Q 3  X  Q 2 . In contrast, Q Q . Therefore, Q 2  X  G Q 3 .PTPQs Q 1 and Q 2 (and Q 1 and Q are not related in terms of absolute or relative containment. Checking absolute query containment. In order to deal with ab-solute query containment we need the concept of homomorphism between PTPQs:
D EFINITION 5.1. Let Q 1 and Q 2 be two queries on D .An homomorphism from Q 2 to Q 1 is a mapping H from the nodes of Q 2 to the nodes of Q 1 such that: (a) nodes of Q 2 are mapped by H to nodes of Q 1 labeled by the same element, (b) nodes of Q thesamePParemappedby H to nodes of Q 1 onthesamePP,(c) the nodes in the output PP o 2 of Q 2 are mapped under H to nodes in the output PP o 1 of Q 1 , and every node in o 1 is the image under H of a node in o 2 ,(d)  X  e i [ p ]  X  e j [ p ] (resp. e i Q , H ( e i [ p ])  X  H ( e j [ p ]) (resp. H( e i [ p ])  X  H and (e)  X  e [ p i ]  X  e [ p j ] in Q 2 , H ( e [ p i ]) and H H ( e [ p i ])  X  H ( e [ p j ]) is in Q 1 .

As we mentioned above, the PTPQ Q 2 of Figure 4 is absolutely contained in the PTPQ Q 3 of Figure 5. One can see that there is a homomorphism from Q 3 to Q 2 that maps the nodes of PP p Q 3 to those of PP p 4 of Q 2 and the nodes of PP p 8 (the output PP of Q 3 )tothoseofPP p 5 (the output PP of Q 2 ). The next theorem shows that the existence of an homomorphism between PTPQs is a necessary and sufficient condition for absolute query containment. T HEOREM 5.1. Let Q 1 and Q 2 be two PTPQs in full form. Q 1  X  Q 2 if and only if there is a homomorphism from Q 2 to Q .

Notice the absence of an homomorphism from Q 2 to Q 1 only because e [ p 4 ]  X  d [ p 4 ] in Q 2 cannot be mapped to a precedence relationship in Q 1 . This explains our earlier claim in this section that Q 1  X  Q 2 .
 Checking relative query containment The next theorem provides necessary and sufficient conditions for relative PTPQ containment, in terms of absolute containment of complete TPQs.

T HEOREM 5.2. Let Q 1 and Q 2 be two PTPQs and G be an index graph. Let also T 1 be the set of complete TPQs of Q and T 2 be the set of complete TPQs of Q 2 on G . Q 1  X  G and only if there is a mapping f from T 1 to T 2 such that, for every complete TPQ T in T 1 , T  X  f ( T ) .
 Consider again the PTPQs Q 1 , Q 2 and Q 3 of Figures 3, 4, and 5. Their complete TPQs on the index graph G of Figure 9 are shown in the figures 10 and 12. Figure 12: The complete TPQs of PTPQ Q 2 on index graph G : (a) T 1 2 ,(b) T 2 2 . The complete TPQs of PTPQ Q 3 on index graph G :(c) T 1 3 ,(d) T 2 3
Theorem 5.2 proves our earlier claim in this section that Q Q 3 are equivalent w.r.t. G : considering the bijection f ( and f ( T 2 2 )= T 2 3 , one can easily verify, based on Theorem 5.1, that T 1 3 and T 1 2 are absolutely equivalent and the same holds for T 3 and T 2 2 . In contrast, one can see that Q 2  X  G Q 1 only because the node sharing expressing on e in T 1 1 cannot be mapped through an homomorphism to a node sharing expression on e in T 1 2
Checking relative PTPQ containment can be time consuming since, as we saw in the previous section, it involves checking sev-eral pairs of complete TPQs for absolute containment. In contrast, checking absolute PTPQ containment requires only the detection of an homomorphism between the two PTPQs. In this section, we suggest heuristic approaches for checking query containment w.r.t. an index graph G . These heuristic approaches reduce relative PTPQ containment to absolute PTPQ containment.

Suppose that Q 1 and Q 2 are two PTPQs and we want to check whether Q 1  X  G Q 2 . The basic idea is to extract all the prece-dence relationships that hold on the all paths from the root of G  X   X   X   X  w.r.t. R 3 and G under the cond ition that some other precedence relationships hold these paths. This information is represented in the form of rule instances where the extracted precedence relationships form the conclusion, and the conditional precedence relationships form the premise. For example, the reader can verify that the rule instance { e  X  d } =  X  X  e  X  d } holds on the index graph of Figure 9.
Given a set of rule instances that hold on G , if the precedence relationships in the premise of a rule instance R can be derived from the precedence relationships in a PP p of Q 1 , the precedence relationships in the conclusion of R are added to PP p . This process is repeated until a fixed-point Q 1 is reached. PTPQ Q 1 is called augmented Q 1 . Clearly, Q 1  X  G Q 1 . Then, Q 1 is checked for absolute containment into Q 2 .

Rule instances are grouped into rules which are patterns of rule instances. The following are rules: R 1 : { r  X  x } =  X  X  y  X  x, y  X  x } , R 2 : { r  X  x, r  X  y } =  X  X  u  X  v, u  X  v } ,and R 3 : { x  X  y } =  X  X  u  X  v, u  X  v }
For example, the rule R 1 groups together all the rule instances that extract child and descendant precedence relationships from any node to a node x . The instances of R 1 that hold on the index graph G of Figure 9 and extract non-empty sets of precedence relation-ships from G are: { r  X  c } =  X  X  r  X  c, a  X  c } , { r  X  e } =  X  X  r  X  e, a  X  e } ,and { r  X  d } =  X  X  r  X  d, a  X  d } .
 An example of an instance of R 3 that holds on G is: { b  X  e } =  X  X  r  X  b, r  X  e, r  X  a, r  X  b, b  X  a } .
 The reader is encouraged to find the rest of the instances for rules R , R 2 and R 3 that hold on G and extract non-empty sets of prece-dence relationships.

Consider a PTPQ Q , an index graph G , and a rule R .The aug-mented query Q (say Q ) w.r.t. R and G is constructed from Q as follows:
Figures 13 and 14 show the augmented Q 3 w.r.t. R 1 and G and w.r.t. R 3 and G respectively. The augmented Q 3 w.r.t. G and R is identical to the augmented Q 3 w.r.t. G and R 1 .

As mentioned in Section 5, absolute containment implies rela-tive containment with respect to any index graph, and consequently w.r.t. G . Therefore, if Q 1  X  Q 2 , it is guaranteed that Q As stated in the following propos ition, this approach is sound but not complete: if Q 1  X  Q 2 , it is not guaranteed that Q 1
P ROPOSITION 6.1. Let Q 1 and Q 2 be two PTPQs, G be an in-dex graph, and R be a rule. Let also Q 1 be the augmented Q R and G .If Q 1  X  Q 2 then Q 1  X  G Q 2 .If Q 1  X  Q 2 ,thenitis possible that Q 1  X  G Q 2 .

Let Q 3 be the augmented PTPQ Q 3 shown in Figure 14. One can easily see that there is an homomorphism from Q 2 to Q 3 . Based on Theorem 5.1, Q 3  X  Q 2 . Then, Propos ition 6.1 guarantees that Q 3  X  G Q 2 . This is precisely what we proved in Section 5.
We have employed two heuristic approaches, a precomputation and an on-the-fly approach, presented below: Precomputation heuristic approach. In the precomputation heuris-tic approach, precedence relations hips are extracted from the index graph in advance. When a query emerges, these precedence rela-tionships are ready for immediate application.

Using additional rules in the heuristic approach improves its ac-curacy (percentage of pairs of queries detected with relative con-tainment out of a set of pairs of queries that are relatively but not absolutely contained). Consider, for example, the rule R 1 augmented PTPQ Q 3 w.r.t. R 1 and G shown in Figure 13. This PTPQ is not contained in Q 2 . Therefore, a heuristic approach that uses only R 1 fails to detect the relative containment in this case. However, if the heuristic approach employs in addition rule R augmented PTPQ Q 3 w.r.t. { R 1 ,R 3 } and G (which is the same as the one shown in Figure 14) succeeds in detecting containment. These gains in accuracy are obtained at the expense of (a) extra space for storing the additional rule instances, and (b) additional time for computing the augmented query (possibly more rule in-stances to be checked for application, more precedence relation-ships to be added to the PTPQ, and more iterations in the com-putation of the augmented PTPQ). Therefore, a trade-off has to be determined between desired accuracy on the one side and space and time resources on the other side.

Using several rules, a family of heuristic approaches can be de-fined, each approach involving several rules, which have to be tested for appropriateness. Skipping the details because of space con-sideration, we only mention that in constructing such a family of heuristics, the designer has to (a) exclude rules that are redundant in the presence of other rules, and (b) minimize the effect of the extensive horizontal (among rule instances of the same rule) and vertical (among instances of different rules) overlapping of the rule instances by employing incrementality in storing the rule instances and in applying them to the PTPQs. We have used such incremen-tal techniques in our implementation and experiments presented in the next section.
 On-the-fly heuristic approach. Using all the precedence relation-ships in every PP of the full form of a PTPQ Q , we can extract more precedence relationships from G . Adding iteratively those precedence relationships to Q until a fixed-point is reached results in a query called augmented Q w.r.t. G . Clearly, the augmented Q w.r.t. G is not less restrictive than the augmented Q w.r.t. any set of rules and G . Consider, for example, PTPQ Q 3 of Figure 5. Figure 15 shows the augmented Q 3 w.r.t index graph G of Figure 9. This PTPQ is more restrictive than the augmented Q 3 w.r.t. R 3 shown in Figure 14. Nevertheless, this heuristic approach can only be applied after the query is issued and it is subject to the additional cost of extracting the precedence relationships on-the-fly.
To study the effectiveness of our PTPQ containment checking techniques, we ran a comprehensive set of experiments. Checking PTPQ containment in the presence of index graphs (relative con-tainment), is expected to be time consuming compared to checking PTPQ containment in the absence of index graphs (absolute con-tainment). However, our experimental evaluation shows that the heuristic approaches for checking relative containment can save a considerable amount of time, while maintaining high accuracy. Setup. We ran our experiments on a dedicated Linux PC (AMD Sempron 2600+ ) with 2 GB of RAM. The reported values are the average of repeated measurements. Specifically, for every measure point, 100 pairs of queries were generated ( 10 pairs of queries for each one of the 10 index graphs used). Only satisfiable queries w.r.t. the index graphs were generated. For all pairs ( Q PTPQs used for containment check, Q 1  X  G Q 2 ,but Q 1 Q 2
We used index graphs whose number of root-to-leaf paths does not exceed five times the number of their nodes. This is in confor-mance with the index graphs of several popular XML benchmarks, like XMark 1 and XMach 2 , where the number of root-to-leaf paths does not exceed twice the number of their nodes.
 Experiments. In our experiments, we compared the execution time and the accuracy for containment check among the following cases: (a) PTPQ containment in the absence of an index graph (Absolute Containment -AC ), (b) query containment in the presence of an index graph (Relative Containment -RC ), (c) heuristic query con-tainment in the presence of an index graph, where precedence rela-tionships are extracted from the index graph on-the-fly ( RCF H ), (d) three approaches of heuristic query containment in the presence of an index graph, where the precedence relationships extracted from the index graph are precomputed ( RCH 1 , RCH 2 , RCH Approach RCH 1 uses only the rule R 1 . Approach RCH 2 uses the rules R 1 and R 2 . Approach RCH 3 uses the rules R 1 , R (see Section 6).

We also tested the impact of the index graph X  X  and queries X  den-sity on the execution time and on the accuracy for contaiment check among the above cases for different structures of the index graph and of the queries. Next, we present the detailed results. Execution time and accuracy varying the density of the index graph. We measured the execution time and the accuracy for check-ing PTPQ containment varying the number of root-to-leaf paths for different numbers of nodes in the index graph. In Figures 16 and 17, we present the results obtained for index graphs having and 40 nodes. The number of PPs in the queries and the number of nodes per PP are fixed to 2 and 4 , respectively.

As expected, RC check is time consuming compared to AC check. The larger the number of paths in the index graph, the more is the time taken by RC check. This is due to the increase in the number of matchings of the PPs to the paths of the index graph. http://monetdb.cwi.nl/xml/ http://dbs.uni-leipzig.de/en/projekte/XML/ XmlBenchmarking.html Such an increase causes more complete TPQs to be produced. Ob-viously, the execution time for AC check is not affected by the index graph parameters.

Overall, our results show that all of our heuristic techniques clearly improve checking of RC . Note that RCH 1 is the fastest among all the heuristic containment checks we suggest, giving in some cases an improvement of more than two orders of magnitude compared to RC check.

The execution time for RCH 1 , RCH 2 and RCH 3 checks slightly drops as the number of paths in the index graph increases. The reason is that the density of the index graph increases, too, which in turn decreases the number of precedence relationships extracted from the graph. Note that the precedence relationships from the index graph are precomputed. Thus, the execution time does not include the time required to extract the precedence relationships from the index graph.

For a growing number of paths in the index graph, the execu-tion time for the on-the-fly heuristic containment check RCF H increases. This is caused by the increase in the number of paths ex-amined during the (on-the-fly) pr ecedence relationship extraction.
Regarding the accuracy, the on-the-fly heuristic containment ap-proach RCF H is clearly more accurate than all the other heuristic containment checking approaches, approximating 100% of the ac-curacy of the non-heuristic relative containment check RC .Heuris-tics RCH 1 , RCH 2 and RCH 3 have an accuracy higher than 45%, 65% and 85%, respectively, for index graphs whose number of root-to-leaf paths does not exceed twice the number of their nodes. Execution time and accuracy varying the density of queries. We measured the execution time and the accuracy for checking PTPQ containment varying the number of nodes per PP for different num-bers of PPs in the query. In Figures 18 and 19, we present the results obtained for queries having 2 , 3 and 4 PPs. The number of nodes and paths in the index graph are fixed to 30 and 15 respectively.
For a growing number of nodes per PP in the query, the execu-tion time of AC check is almost unaffected. However, it slightly increases as the number of PPs goes up, because of the raise in the number of matchings between the PPs of the involved queries that need to be examined.
 The execution time of RC check also goes up as the number of PPs in the queries increases. The reason is that a larger number of complete TPQs are generated and, then, examined in the contain-ment check. On the other hand, the execution time of RC check decreases as the number of nodes per PP goes up, since more re-stricted queries result in a smaller number of complete TPQs to be examined in the containment check.
 Again, our heuristic techniques clearly improve RC check, with RCH 1 being the fastest among all. For a growing number of nodes per PP in the query, the execution time of the precomputed heuristic containment checks RCH 1 , RCH 2 and RCH 3 is only slightly affected. On the contrary, the larger is the number of PP nodes, the less is the time spent for RCF H check. This is due to the decrease in the number of index graph paths examined during the (on-the-fly) precedence re lationship extraction.

At the same time, the accuracy of RCF H is close to 100%. The accuracy for the other heuristic containment checking approaches decreases as the number of nodes per PP in the queries increases. However, the accuracy of RCH 3 is almost in all cases above 80% for an execution time which is close to that of the approaches RCH and RCH 2 .
 Remarks. All of our heuristic techniques clearly improve the time of PTPQ relative query containment check RC .However,these techniques are not complete. Therefore, a trade-off has to be deter-mined between desired accuracy on the one side and time resources on the other side. Our experiments show clearly the benefit of using the RCF H heuristic containment check (on-the-fly) if accuracy is the goal ( RCF H check is more than one order of magnitude faster than RC containment check, while scoring an accuracy close to 100%). When efficiency is important, a full spectrum of heuristic approaches (including those that involve more rules than RCH RCH 3 ) gradually trade accuracy for efficiency. In this paper, we considered partial tree-pattern queries (PTPQs). A key feature of this type of queries is that the structure in a tree pattern can be flexibly specified fully, partially, or not at all. To efficiently process PTPQs, we defined index graphs on databases that summarize the structure of data trees. We studied the infer-ence of structural expressions of PTPQs and we presented a set of inference rules. We addressed the satisfiability and containment problems for PTPQs in the absence (absolute PTPQ containment) and in the presence (relative PTPQ containment) of index graphs, and we provided necessary and sufficient conditions for each type of query containment.

To cope with the high complexity of relative containment, we designed a family of (sound) heuristic techniques based on struc-tural expressions extracted from the index graph in advance and on-the-fly. We implemented all our approaches and we performed extensive experimental evaluation to report on their efficiency and accuracy. Our results showed that the heuristic relative contain-ment check provides reasonable execution time, while maintaining high accuracy. Those results make our approach appropriate for integration into a query processor for PTPQs.

Currently, our evaluation method of PTPQs is based on the gen-eration of complete TPQs using an index graph. Our future work comprises studying ad-hoc techniques for the optimization of this type of queries. [1] XML Path Language (XPath). World Wide Web Consortium [2] XML Query (XQuery). World Wide Web Consortium site, [3] S. Amer-Yahia, S. Cho, L. V. S. Lakshmanan, and [4] S. Amer-Yahia, S. Cho, and D. Srivastava. Tree Pattern [5] A. Barta, M. P. Consens, and A. O. Mendelzon. Benefits of [6] L. Chen and E. A. Rundensteiner. Xquery Containment in [7] S. Cluet, P. Veltri, and D. Vodislav. Views in a large scale [8] S. Cohen, J. Mamou, Y. Kanza, and Y. Sagiv. XSearch: A [9] A. Deutsch and V. Tannen. Containment and integrity [10] X. Dong, A. Y. Halevy, and I. Tatarinov. Containment of [11] R. Goldman and J. Widom. DataGuides: Enabling query [12] J. Hidders. Satisfiability of XPath Expressions. In Proc. of [13] V. Hristidis, Y. Papakonstantinou, and A. Balmin. Keyword [14] R. Kaushik, P. Bohannon, J. F. Naughton, and H. F. Korth. [15] R. Kaushik, P. Shenoy, P. Bohannon, and E. Gudes. [16] L. V. S. Lakshmanan, G. Ramesh, H. W. Wang, and Z. J. [17] Y. Li, C. Yu, and H. V. Jagadish. Schema-Free Xquery. In [18] G. Miklau and D. Suciu. Containment and Equivalence for [19] T. Milo and D. Suciu. Index structures for Path Expressions. [20] F. Neven and T. Schwentick. XPath Containment in the [21] N. Polyzotis and M. Garofalakis. Statistical Synopsis for [22] P. Ramanan. Efficient Algorithms for Minimizing Tree [23] D. Theodoratos, T. Dalamagas, A. Koufopoulos, and [24] D. Theodoratos, T. Dalamagas, P. Placek, S. Souldatos, and [25] P. T. Wood. Containment for XPath Fragments under DTD in the index graph. different numbers of nodes in the index graph. query. numbers of PPs in the query.
