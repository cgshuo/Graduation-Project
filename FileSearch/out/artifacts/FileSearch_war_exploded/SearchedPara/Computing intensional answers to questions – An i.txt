 1. Introduction views of NLI research). They are a crucial component towards providing users with intuitive access to the vast amount of information available world wide in the form of resources as heterogeneous as web sites, classical and Semantic Web dat-abases, RSS feeds, blogs, wikis, etc.

However, most of the prevalent work has concentrated on providing extensional answers to questions. In essence, what we mean by an extensional answer here is a list of instances that satisfy the query. that all the elements in the answer set share, i.e. the one of being a state.
 has not been much research on aspects of answer presentation, in particular on: Integrating additional external data for presentation and visualization purposes (e.g. mashups). Structuring the answer space, i.e. by grouping/clustering answers.
 Constructing explanations or proofs for answers.
 Providing partial answers, and Delivering non-extensional (e.g. intensional) answers.
 in the knowledge base.
 It could be certainly argued that providing intensional descriptions  X  X  X ver-answers X  the question. sional description might be useful.

Second, an intensional answer can indeed provide new but relevant knowledge to the user. For example, let us consider Brandenburg in particular.

Third and most importantly, as we will see in the remainder of this paper, IAs can help to detect flaws in the knowledge query-driven way. The confirmation by a user would be necessary as the axiom has been derived inductively and it is not clear if it holds universally or only in the given state of the knowledge base.
 We present an approach for computing intensions of queries given their extensions and a particular knowledge base.
Our research has been performed in the context of the natural language interface ORAKEL (see [2]) and the aim has been to integrate the component for providing intensional answers into the system. Notwithstanding, the approach presented here could be used in any setting where intensional answers are appropriate (and as we will see in the related work sec-tion it has strong connections to research on generating referring expressions). We describe an approach based on induc-tive logic programming (ILP) and in particular based on bottom-up clause generalization which computes a clause general generalizations (LGGs) for the answers by adding one answer item at a time and generalizing the clause computed so far.

The paper is structured as follows: in Section 2, we describe the ORAKEL system in more detail in order to provide the reader with some background of our research. We discuss the approach for generating intensional answers in more detail the knowledge base. We discuss related work in Section 5 and conclude in Section 6. 2. Background: the ORAKEL system be easily adapted to new ontologies and knowledge bases by non-experts. This has been corroborated before by experimen-and the way they are (syntactically) combined (as made explicit by a syntactic analysis of the sentence). The main components of the system as well as their interaction are depicted in Fig. 1 . These components are: Query Interpreter : translating the user question into a generic logical form.
 Query Converter : converting the generic logical form into the target query language.

Answer Generation : the component responsible for evaluating the query (w.r.t. the knowledge base) and presenting the answers to the user (as a list of instances satisfying the query so far).

FrameMapper : a graphical user interface used to adapt the system to a given domain by creating an ontology-specific lexicon.

Domain-independent lexicon : a lexicon specifying the domain-independent meaning of closed class words (articles, wh-pronouns, prepositions, etc.).
 Domain-specific Lexicon : a lexicon generated specifically for the ontology in question.

The underlying syntactic theory of our system is a formalism called Logical Description Grammars (LDGs, compare [5]), which is inspired by Lexicalized Tree Adjoining Grammars (LTAGs, see [6]). The structures used in LDG are essentially vide arguments while negatively marked nodes require some arguments to be inserted. An important characteristic of these and positively marked nodes together (see [7]).

As formalism for semantic composition, the lambda calculus is used, relying on functional abstraction, functional appli-complete logical query (compare [8]).

Fig. 2 shows the parse tree, decorated with lambda expressions conveying the semantics for the question Which river passes through Berlin?
The meaning of the diverse lexico-syntactic units in the input can be expressed in functional lambda notation roughly follows:
Which river k P ? x  X  ri v er  X  x  X ^ P  X  x  X  X  passes through k x k y flow through  X  x ; y  X  Berlin k QQ  X  Berlin  X 
While passes through is interpreted here as referring to the eral, as it can also refer to the relation located _ at _ individuals as arguments to be inserted into the appropriate relation argument.

Given the simplified syntactic structure together with instructions on how the semantic expressions are applied to each yielding as semantic representation of the VP node node S , we would carry out the functional application resulting in the final logical query: target query language of our choice. The above query would be represented in the F-Logic query language [9] as follows: system [10]), yielding the following answers: not expressive enough, then some of the queries interpreted by the ORAKEL system will not be translated into the target language. If the query language is too expressive this does not constitute a problem for the ORAKEL system. To exchange based on F-Logic [9], and Ontobroker [10] is used as the underlying inference engine.

The results of the ORAKEL system have been shown to be reasonable and competitive in comparison to other state-of-the-the ORAKEL system, the interested reader is referred to [2]. 3. Approach
Section 3.4. Section 3.5 presents a worked example. 3.1. Overview
The aim of the work described in this article has been to extend the ORAKEL natural language interface with capabilities to a given conceptualization [12].

While the extensional answer is displayed to the user, it is also forwarded to the component which generates intensional tion to the extensional answer. Note that in this paper, we are not concerned with the problem of generating an adequate guage. However, this is not the focus of the present paper, but an obvious issue for future work. user does not have to wait for them until an intensional answer is possibly generated.
 (LGG) of clauses in the next section. 3.2. Basics: LGG computation
Our approach to computing intensional answers is based on bottom-up clause generalization, which computes a clause lattice, thus allowing to effectively navigate the search space (compare [13, pp. 33 X 37] ).
Let us first recap some basic definitions needed for describing the computation of LGGs. Thereby we assume some basic familiarity with first order predicate logic.

Definition 1 ( Clauses ). A clause is a first-order formula of the form L easier representation, clauses are usually conceived as sets f L literal is a negated atom : p  X  t 1 ; ... ; t k  X  , where p is a predicate of arity k and t Aswewilldealwithafunction-freevariantoffirst-orderlogic,theonlytermswewillencounterare constants andvariables. (also denoted as rules) of the form A A 1 ^^ A k , where A ; A of the rule and A 1 ^^ A k as its body.
 obtained by substituting the variables occurring in the literals contained in c according to h .
We then say that c h -subsumes c 0 iff there exists a substitution h such that c h # c 0 . eralization lattice. The partial order 6 is defined by: c (see [13]). clauses c and c 0 in the generalization lattice as the least general generalization (LGG) of c and c 0 . The LGG of two clauses is computed in essence as described in [13, p. 41]: Definition 3 ( LGG ).
 where the LGG of literals is defined as follows: If both literals are positive: If they are negative: Otherwise, if one is positive and one is negative: For terms, the LGG is defined as follows: LGG  X  t ; t  X  X  t LGG  X  s ; t  X  X  V where s  X  t .
 Thereby, V is a variable not occurring in c 1 or c 2 , which is uniformly used to represent the LGG of s and t .
While there is an explicit negation operator in the F-Logic language and this is supported by the F-Logic implementation icate, the resulting clause is again a definite Horn clause and also carries the same head predicate.
From the way the LGG is constructed, it can be shown that it is the most specific clause (w.r.t. LGG  X  c 1 ; c 2  X  6 c 1 and LGG  X  c 1 ; c 2  X  6 c 2 .

While F-Logic and OntoBroker support function symbols, our assumption here is that the knowledge base is actually func-tion-free, so that we do not support function symbols in our approach to generating an intensional description. 3.3. Generalization
In order to compute a clause which covers all the extensional answers, we iterate over all the answers and compute pair-esis which covers all positive examples and ignores negative examples during learning. If the resulting hypothesis which covers the positive examples without overgeneralizing.

In our approach, we perform the search of the hypothesis space in a bottom-up manner. We start with the most specific hypothesis which covers a given example and generalize this clause with the specific hypothesis for the next example by specific hypotheses representing one element in the extension of the answer.
 well as the knowledge base KB . The aim is to generate a hypothesis which exactly covers the extensional answers. A sending queries asking for the names of methods or concepts sion of the first example. As head of this clause, we use an artificial target predicate answer . mation directly referring to a that can be retrieved from the knowledge base.
 example is generat structed so far and the clause c 0 (line 7) constructed on the basis of the next answer a 0 (lines 5 and 6).
In our example, the next specialized clause c 0 for the next answer Mecklenburg-Vorpommern is:
Computing the LGG of c and c 0 , we obtain: LGG  X  c ; c 0  X  :  X  The variables above then represent the LGGs of the following pairs of terms in the original clauses: X Saarland Mecklenburg-Vorpommern Y 1.062.754 1.735.000 P Saarbr X cken Rostock Q Saarbr X cken Schwerin
Theresultingclause isthentransformedintoaquery inthetargetlanguage,F-Logicinourcase,sothatit canbeevaluatedby theinferenceengine,whichreturnstheextensionofthe clause LGG  X  c ; c 0 X  onthebasisof thegivenknowledgebase(line8). Ifthe clause is inconsistent (line 9), i.e., it covers more answers than the required ones (this is the case if Answers \
As a further optimization of the algorithm, we could always remove those examples which have been already covered by clause in case it covers exactly the set of extensional answers.
By removing redundant literals, the above LGG can be reduced to: in one specialized clause, such that it is guaranteed that there is at least one instance. answers below: Nordrhein-Westfalen Bayern Hessen Baden-Wuerttemberg Berlin (Bundesland) Brandenburg (Bundesland) Niedersachsen Sachsen Sachsen-Anhalt Th X ringen Schleswig-Holstein Hamburg (Bundesland) Rheinland-Pfalz Saarland Mecklenburg-Vorpommern
Note that the state of Bremen is missing from the above list. The reason is that Bremen is not modeled as bordering any state, such that the atoms borders  X  X ; Z  X  and borders  X  X ; Z  X  are not satisfied.

Concerning the first case, assuming that the above clause would cover all of the examples in the original answers, it is highly redundant from the point of view of the knowledge base. For example, any state X is also a location according to our ontology (as state is subsumed by location in our ontology). Further, every state can be assumed to have some number 3.4. Clause reduction of positive examples without introducing any negative ones. Further, the reduction yields a more compact clause which might be more intuitive and informative for the user of the system compared to a longer clause. clause, i.e. that it is consistent.
 The following algorithm performs the reduction of the clause:
REDUCECLAUSE (Clause c, KnowledgeBase KB , Set Answers ) 1 List literals = orderLiterals(c) ; (in increasing order) 2 for i =1 to j literals j 3 do 4 c 0  X  remo v e  X  c ; L i  X  ; 5 Answers 0  X  e v aluateQuery  X  query  X  c 0  X  ; KB  X  ; 7 then 9 10 return c ; while preserving consistency at the same time, the original clause is returned.
 The literals are ordered according to a total order satisfying the following conditions: L i &lt; L j if L i is an atom of higher arity than L j
L i &lt; L j if L i and L j have the same arity and less variables in L
For the literals in the following clause: the following order would be admissible: predicate arity was chosen in order to obtain descriptions that are preferably intuitive and more compact. examples and the reduction does not affect the coverage. In case the reduction is performed after each LGG computation, each iteration we can reduce the number of iterations and speed up our algorithm in many cases. 3.5. A worked example
After having explained the different steps involved in the computation of an intensional answer, we now discuss the com-in earlier sections to enhance the overall understanding of the approach.
 following logical query: FORALL X EXISTS Y X : state ^ X  X  capital ! Y . The answer of the ORAKEL system can be repre-sented as follows in clause notation: answer(Saarland) answer(Mecklenburg-Vorpommern) answer(Rheinland-Pfalz) answer(Hamburg (Bundesland)) answer(Schleswig-Holstein) answer(Th X ringen) answer(Sachsen-Anhalt) answer(Sachsen) answer(Bremen) answer(Niedersachsen) answer(Brandenburg) answer(Berlin (Bundesland)) answer(Baden-W X rttemberg) answer(Hessen) answer(Bayern) answer(Nordrhein-Westfalen)
Now the goal of our approach is to find a clause describing the answer -predicate intensionally. The number of positive is verified by the condition Answers \ Answers 0 Answers 0  X  X  Saarland  X  in the knowledge base (compare Section 3.2): clause (see Section 3.2).
Now, computing the LGG of these two clauses yields the clause (compare Section 3.2 for the full clause):
This clause can then be reduced to the following by removing redundant literals: cated order as their removal does not increase the extension: 1. Location(P,X) (covering 15 examples). 2. Capital_of(Q,X) (covering 15 examples). 3. Inhabitants(X,Y) (covering 15 examples). 4. Borders(X,Z) (covering 15 examples). 5. Borders(Z,X) (covering in addition Bremen). 6. Location(X) (covering 16 examples).
 no others. The key here to cover also the example Bremen is thus the removal of the two
While this is not part of our current implementation of the system, an appropriate natural language answer could be gen-erated from this clause, thus having  X  X  All states (have a capital)  X  as final intensional answer.
Thus, reducing the clause after each step has the effect that a correct clause can be derived with one LGG computation literals), the algorithm needs to make 7 iterations, considering the examples: Mecklenburg-Vorpommern, Rheinland-Pfalz, dure in more detail. 4. Evaluation some observations with respect to the time performance of our algorithm. 4.1. Dataset
The dataset previously used for the evaluation of the ORAKEL natural language interface consists of 463 wh-questions about German geography. These questions correspond to real queries by users involved in the experimental evaluation of the ORAKEL system (see [2]). The currently available system is able to generate an F-Logic query for 245 of these, thus 169 of the queries. Roughly, we are thus able to generate intensional answers for about 83% of the relevant questions in proach is not able to find a clause (in 36 out of 205 cases): order to represent such a clause we would need to introduce numerical comparison operators into our clause language.
However, note that it is not excluded that such answers can be represented with our clause language if there are other properties not requiring numerical comparisons which might be used to pick out the entities in question. Such an example rivers flow through a capital?  X , which is translated into the query FORALL X EXISTS Y ; ZX  X  flows through ! of the entity Y to add the essential literal capital of  X  Y ; Z  X  .
 type) and have no properties one could use to describe them.
 all the answers and determined whether the user learns something new from the answer or it merely constitutes a rephras-ing of the question itself. 4.2. Analysis of intensional answers not give any additional knowledge, but merely rephrases the question. Of the above mentioned 140 useful answers, 97 are tom-up generalization algorithm was actually used.

In order to further analyze the properties of intensional answers, we determined a set of 54 questions which, given our found. Together with the above mentioned 140 queries the overall number of useful intensional answers for the actual knowledge base is 189. The queries which provided useful answers can be classified into the following four types:
Questions asking for all instances with a special property which turn out to coincide exactly with the extension of some atomic class in question share the property he/she is querying for. An example is the question:  X  X  Which states have a capital?  X , which produces the answer answer  X  X  X  state  X  X  X  or in natural language simply  X  X  All states  X . which passes Flensburg is the A7, so the intensional answer is  X  X  All the capitals located at the A7  X . flows through  X . These are the cities of Berlin and Hamburg. Such answers provide additional knowledge to the user about ones which are located at highway A24 and at some river.

Questions which yield a single answer as a result and for which the intensional answer describes additional properties
A831. It has 565.000 inhabitants and is the capital of Baden-W X rttemberg. The Neckar flows through Stuttgart  X . 4.3. Debugging the knowledge base low to detect errors in the knowledge base. We found that in some cases the intensional answer produced was not the ex-idea:
A closer inspection of the knowledge base revealed that some Swiss cities are mentioned in the knowledge base because some German rivers have their origin in Switzerland, but no number of inhabitants is specified for these cities.
As another example, the query  X  X  Which river has an origin?  X  yielded as intension: answer  X  X  X  ri a length nor an origin is specified. This instance is the river Isar .

This shows that intensional answers can be useful to detect where information in the knowledge base is missing. 4.4. Query-driven knowledge base refinement
Another application of intensional answers is knowledge base refinement. Consider our initial example, where we were formalism) can be added to the ontology as a logical axiom, provided the knowledge modeling language used offers the re-quired expressivity for doing so.

This strategy provides a way of continuously refining the knowledge stored in the system by the user. If a query imposed otherwise the confirmed propositions are added to the knowledge base. Either way, the information system is enriched by new knowledge that might be useful in further queries. 4.5. Performance analysis
Finally, we have also carried out a performance analysis of the component for inducing intensional answers. Table 1 of our system: one corresponding to a version in which the clause is reduced after each LGG computation and one in which swers as equally important and assume that both are shown to the user, we can even assume that first the extensional hardly differ in the average case. In fact, when the reduction is performed after each LGG computation, the average time the reduction clearly has an influence on the number of iterations needed, which is much lower than in the case where the reduction is only applied at the end. 5. Related work and discussion
We have presented an approach for computing intensional answers to a query formulated in natural language with re-spect to a given knowledge base. The approach relies on inductive logic programming techniques, in particular bottom-knowledge discovery from databases (see e.g. [15 X 17]), but also logic programs (see e.g. [18]).
Intensional query answering (IQA) emerged as a subject in the research of cooperative response generation, which has one of Benamara [20], who also presents an approach to induce intensional answers given the extension of the answer. In-portion of shared properties. On the one hand, the mechanism for generating intensional answers seems quite ad-hoc in comparison to ours, but, on the other hand, the WEBCOOP system of Benamara is able to generate natural language answers using a template-based approach.
 generatingnounphrasesanddefinitedescriptionsinparticular)thecontextsetisassumedtobewhatisaccessibletothereader orhearerinthesituationinquestion.Inoursettings,thetargetset S consistsoftheanswerstotheoriginalquery,thecontextset
C are allthoseentitiesavailableintheknowledgebase(as closedworld)and D :  X  C n S istheset of negativeexamples. The tasks getsetfromthelargercontext.Oursolutiontothisproblemhasbeenabottom-upgeneralizationalgorithmbasedonILP,which problemasaconstraintsatisfactionproblemandusingefficientconstraintprogrammingtechniquesforthispurpose(see [25]). example,theorderbywhichweremoveirrelevantliteralaimsatproducingcompactandthushopefullymoreintuitiveclauses.
In the area of generating referring expressions, Dale and Reiter have presented a top-down (starting from the empty will also be found. van Deemter then shows that under certain assumptions the algorithm can be extended to be complete.
The dichotomy intension vs. extension is also prevalent in the mathematical area of Formal Concept Analysis (FCA, [27]) to a large number of hypotheses subsequently presented to the user for decision. This has shown to be a time-consuming to his current focus of interest anyway (as it is triggered by the according query posed by him). 6. Conclusion can be computed in a reasonable amount of time, we have also argued that their benefit is not always obvious. While our
In the remaining cases, the intensional answers seem to indeed be delivering additional information about the knowledge ful X , a real proof of  X  X  X sefulness X  can only be provided in the form of user experiments, which we have not carried out.
The most obvious avenues for future work are the following. First, the bottom-up rule induction approach should explore  X  X  X arger environments X  of the answer items for clause construction by not only considering properties of the answer item a capital?  X , we have shown that exploring contexts beyond the one step neighborhood of the query variable can enable as body of the constructed clause.

Second, instead of only computing one single clause, we should also consider computing (disjunctive) sets of conjunctive intensional descriptions are much harder to grasp by users. Further, the addition of negation and exclusion operators to our language should be investigated together with its implications on the formulation of the bottom-up generalization and its performance.

It would also be interesting to compare the algorithms suggested to produce distinguishing descriptions in research on generating referential expressions on our task.
 of a knowledge base from which the intensional answers are generated. We do not see any way how our approach could be straightforwardly extended to an open domain scenario.

Finally, the task of generating natural language descriptions of the intensional answers represents a straightforward extension of our work.

On a more general note, we hope that our work contributes to stimulating discussion on a research issue which has not been a focal point of research lately, but seems crucial towards achieving more natural interactions with information systems.
 Acknowledgements This research has been funded by the Multipla (Grant number 38457858) and ReaSem projects, both sponsored by the Deutsche Forschungsgemeinschaft (DFG).

References
