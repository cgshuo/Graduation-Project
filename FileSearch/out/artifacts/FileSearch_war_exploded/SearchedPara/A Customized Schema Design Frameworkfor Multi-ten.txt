 Multi-tenant database application has attracted more and more attention from the leading IT companies and academic field. As the software model, it amortizes the cost of hardware, software and professional services to a large number of users and significantly reduces per-user cost. As the service provided by the multi-tenant system is usually topic related, the system predefines some tables called predefined tables . In the predefined tables, the system defines some attributes called predefined attributes . However, in order to design the schema which fully satisfies tenants X  requirements, the tenants require to configure their customized tables or add some new customized attributes in predefined tables. The tables newly configured are called customized tables , and the attributes configured by the tenants both in pre-defined and customized tables are called customized attributes. Providing a high-degree customization to satisfy each tenant X  X  needs is one of the important features in the multi-tenant database and the well-known leaders in multi-tenant database systems, e.g., Salesforce, Oracle, SAP, IBM and Microsoft, start to provide such features to boost their competitiveness. However, one big challenge is to devise a high-quality database schema with good performance, low space and high scala-bility supporting full customization.
 To our best knowledge, state-of-the-art approaches on the multi-tenant schema design can be broadly divided into three categories [ 3 , 4 ]. The first one is Independent Tables Shared Instances (ITSI). It maintains a physical schema for each customized schema and this method has the scalability problem when the service faces large numbers of tenants[ 1 ]. The second method is Shared Tables Shared Instances (STSI). In this method different customized tenants share one table and this method has poor performance and consumes more space since it involves large numbers of NULLs . The third method is to simplify the service and do not allow tenants to precisely configure schemas. Thus existing schema designs did little work to consider the performance, scalability and the customization at the same time. To address these limitations, we propose a customized frame-work. We not only allow tenants to fully configure customized schemas but also recommend appropriate customized schemas. We propose the graph partition method to do optimization. Experimental results show that our method with full schema customization achieves high performance and good scalability with low space. Customized schemas in the multi-tenant database pose great challenges. For customized attributes in predefined tables, if we put them into predefined tables, the predefined tables can be extremely wide. And each customized attribute is usually shared by a small number of tenants then the table is sparse containing large numbers of NULLs . It decreases the performance and wastes space. On the contrary, if we maintain one extension table for the customized attributes, the number of NULLs is reduced. However, similar to ITSI, the scalability becomes the bottleneck. While for customized tables, similar to customized attributes in predefined tables, if the system maintains one table for each customized table the scalability is the problem. In this paper we focus on how to design high-quality physical tables for customized schemas. 2.1 Cluster-Based Schema Integration In the typical multi-tenant applications, the data type is very expressive then we can use the data type information to build a feature vector for each cus-tomized table and then cluster them into similar groups. Each bit in the table feature vector represents the number of corresponding data type and we use the cosine function to compute the table feature vector and set it as customized table similarity. Next we use the hierarchical agglomerative clustering method to clus-ter customized tables. Based on the clustering results we integrate customized schemas into one integrated table for each cluster. In the attribute integration process, the attributes can only be integrated between the one with the same data type. In order to further ensure the accuracy, we take the constraint information the uniqueness, nullable and data length into account and the instance informa-tion data cardinality is also considered. We build the Attribute Feature Vector FV a for each customized attribute. For each customized attribute, the corre-sponding attribute feature vector has 4 dimensions, the first FV the uniqueness, unique is 1 otherwise 0. The second FV a (1) nullable, 1 means it may have NULL value, or else 0. The third FV data length, and the fourth FV a (3) is data cardinality. When we integrate the attributes in each cluster, we sum different dimension information similarity of the attribute feature vector as the final similarity value. For example, when we deicide whether to integrate attributes a i and a j , if only one of the two attributes are unique, then the sim ( FV a i (0) ,FV a j (0) ) similarity is 0, otherwise it is 1. The value sim ( FV a i (1) ,FV a j (1) ) is computed similarly. For the latter two parts, we both set the ratio of the minor value to the max value as the similarity value. For each attribute we must integrate it to the most similar integrated attribute above a threshold with the same data type. 2.2 Interactive-Based Schema Integration Besides the basic cluster-based schema integration, we can further improve the integration quality and efficiency. When the tenant starts to configure cus-tomized schema, the system can recommend some appropriate customized tables or attributes. Meanwhile, the system can record the selection of different tenants to integrate the schema manually online. This interactive integration produces no interruption and enhances the experience of tenants. When a tenant begins to use the system, the system has no information of the tenant to refer. Confronting with the  X  X old start X , we adopt the statistical information from the other tenants to rank customized schemas. For each customized table, the system records the number of tenants who configure to use, and the number is called voting .The voting information also applies for customized attributes. The system integrates the customized schemas in the same cluster and in each cluster different cus-tomized tables are very similar to each other, then based on the clustering result we select one table as the representative table for each cluster and the system recommends the representative tables from different clusters. Each cluster selects the table with the highest voting and set it as the representative table . Mean-while, in each cluster we calculate the voting of all the customized tables and set it as Table Total .Accordingto Table Total ,werank representative tables .A higher voting of Table Total means that customized tables in this cluster are utilized by more tenants, then the representative table has a higher rank. 2.3 Optimizing Integrated Schema After integrating customized schemas from different tenants, the integrated tables are still sparse and wide and we need to reorganize the integrated tables. Therefore, the optimization for customized schema becomes the integrated tables partition problem. Ideally, we formulate it as a graph partition problem .Aninte-grated table can be modeled as a graph, each vertex is an integrated attribute and each edge is the similarity between two integrated attributes. We want to partition the graph into k components. We can put those integrated attributes shared by similar tenants together. We record the configuration of each inte-grated attribute, build integrated attribute configure vector CV card function to measure the similarity of different integrated attributes. In the integrated table graph, given two integrated attributes v larity is computed Sim ( v i ,v j )= JAC ( CV i ,CV j ). Since k represents the number of tables which can represent scalability, then when we specify k we compute it like this. We define S , where S = k T  X  100%, T refers to the number of total customized tables in this cluster. Thus we use S to compute k . For instance, if S =5 then the scalability improves by 20. Thus we can use different the corresponding k , and the scalability improvement is also clear. Based on the typical tables and data type information in Salesforce we design our fully customized multi-tenant benchmark. When generating customized tables we define following parameters. The number of total tenants is T number of attributes for each customized table satisfies the normal distribution N(  X  ,  X  2 ), where  X  represents the average number of attributes and  X  is variance and set as 2 and we use MySQL database. Figure 1 compares the performance of our customized framework with STSI, ITSI and Chunk Tables [ 1 ]. We use to reflect the scalability improvement of the system. Here we utilize Cust+5% to represent our customized framework when S =5, then Cust+10% and Cust+20% are easy to understand. The workload contains 8000 operations. We vary the number of tenants and then compare the performance under different workloads. Here  X  is set 15. Based on the analysis in the YCSB benchmark [ 2 ], we vary the ratio of reading operations. We observe that STSI performs worst in all the cases. When the number of tenants is small, ITSI has some priority, however, when the number of tenants is larger, scalability becomes the problem. Chunk table method scales well but still performs worse than our method. In this paper, we propose the customized schema design framework for multi-tenant database. We allow tenants to fully configure customized schemas and propose the interactive-based method to help tenants precisely design their schemas. We finally optimize the integrated schemas. Experimental results show that our framework with full customized property achieves high performance and good scalability with low space.
