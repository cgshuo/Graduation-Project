 A moving range query continuously reports the query result (e.g., restaurants) that are within radius r from a moving query point (e.g., moving tourist). To minimize the communication cost with the mobile clients, a service provider that evaluates moving range queries also returns a safe region that bounds the validity of query results. However, an untrustworthy service provider may report in-correct safe regions to mobile clients. In this paper, we present effi-cient techniques for authenticating the safe regions of moving range queries. We theoretically proved that our methods for authenticat-ing moving range queries can minimize the data sent between the service provider and the mobile clients. Extensive experiments are carried out using both real and synthetic datasets and results show that our methods incur small communication costs and overhead. H.2.8 [ Database Applications ]: Spatial databases and GIS Algorithms, Performance authentication, moving queries
Moving spatial queries [33, 14] continuously report updated query result to a mobile client and they have numerous mobile ap-plications. For example, a moving range query continuously re-ports all tourist attractions that are within 3 km from a moving car.
Location-based service providers (LBS) that offer moving query-ing services return mobile users the query result and a correspond-ing safe region [33, 14]. Given a moving query point q , its safe region is a region where the result of q remains unchanged as long as q moves within it. In other words, it allows a mobile user to issue a new query to the LBS (to get the latest query result) only when the user leaves the safe region, Thus, safe region is a powerful op-timization for significantly reducing the communication frequency between the user and the service provider.

The query results and safe regions returned by LBS, however, may not always be accurate. For instance, a hacker may infiltrate the LBS X  X  servers [25] so that results of queries all include a partic-ular location (e.g., the White House). Furthermore, the LBS may be self-compromised and thus ranks sponsored facilities higher than actual query result. The LBS may also return an overly large safe region to the clients for the sake of saving computing resources and communication bandwidth [22, 16, 30]. On the other hand, the LBS may opt to return overly small safe regions so that the clients have to request new safe regions more frequently, if the LBS charges fee for each request, or if the LBS wishes to boost its request counts  X  a figure that could influence its advertisement revenue.
Recently, techniques for authenticating query result have re-ceived significant attentions, e.g., the authentication of relational queries [15, 10, 27], data stream queries [11, 20], text similar-ity queries [16], static spatial queries [28, 19], and shortest path queries [30]. Most authentication techniques [10, 27, 11, 20, 28, 19, 16, 30] are based on Merkle tree [12], which is an authenti-cated data structure (ADS) that is built on the dataset. Recently, Yang et al. [28] developed an authenticated data structure called Merkle R-tree (MR-tree) for authenticating spatial queries. The is-sue of authenticating moving spatial queries , however, has not been addressed yet. Existing techniques for authenticating static spatial queries such as [28, 19, 6] cannot help in authenticating moving spatial queries because their authentication target is the query re-sult , which is a subset of the dataset , whereas the authentication targets of moving queries include both the query result and the safe region  X  the latter is a geometric entity that is dynamically com-puted by the LBS at run-time and is not part of the dataset. Since a safe region is defined based on both points in the query result as well as points not in the query result, the missing of a non-result point during the authentication process may also fail the authenti-cation of the safe region.

This paper is devoted to the authentication of moving range queries. The specific technical contributions include: 1. The design of verification objects VO specific for authenti-2. Communication optimization techniques that allow a mo-3. We introduce a new notion called VO -optimal , to describe 4. An extensive experimental study on real data and synthetic
The rest of this paper is organized as follows. We discuss re-lated work in Section 2. We present the framework for authenti-cating moving queries in Section 3. In Section 4, we present our VO -optimal methods for authenticating moving range queries. The experimental study is presented in Section 5. Finally, we conclude this paper in Section 6. Query authentication In the literature, most authentication tech-niques [10, 27, 11, 20, 28, 19, 16, 30] are based on Merkle tree [12] with the public key infrastructure [21]. Merkle tree is an authen-ticated data structure (ADS) that is built on the dataset. Digests of nodes in the tree are first recursively computed from the leaf level to the root level. 1 Then, the signature of the dataset is ob-tained by signing the root digest using the data owner X  X  private key. Signature aggregation [15, 17] is an alternative of Merkle tree. It works by having a signature for each tuple in the dataset. Recently, Yi et al. [29] propose a probabilistic approach for authenticating aggregation queries; and Kundu et al. study the authentication of trees [8] and graphs [9] without revealing any data objects beyond the user X  X  access rights.

To authenticate spatial queries, Yang et al. [28] develops an au-thenticated data structure (ADS) called Merkle R-tree (MR-tree) MR-tree for the dataset shown in Figure 1a. A leaf entry p a data point. A non-leaf entry e i stores a rectangle e i e . X  , where e i .b is the minimum bounding rectangle of its child node, and e i . X  is the digest of the concatenation (denoted by | ) of binary representation of all entries in its child node. For instance, e . X  = h ( p 1 | p 2 ) , e 5 . X  = h ( e 1 | e 2 ) , and e root root signature is generated by signing the digest of the root node e root . X  using the data owner X  X  private key.

Consider the range query q with radius r in Figure 1. Its result is p . In order to let the client verify the correctness of the range re-sults, the LBS utilizes the MR-tree (provided by the data owner) to generate a verification object VO . First, it defines a circular verifi-cation region  X  ( q, r ) with center q and radius r . Then, it computes the VO by a depth-first traversal of the MR-tree, with the following conditions: (i) if a non-leaf entry e does not intersect  X  ( q, r ) , then e is added to the VO (e.g., e 2 , e 6 ) and its subtree will not be visited; (ii) data points in any visited leaf node are added into the VO (e.g., p , p 2 ). In this example, we have VO = {{{ p 1 , p 2 } , e where { and } are tokens for marking the start and end of a node.
Upon receiving the VO , the client first checks the correctness of the VO by reconstructing the digest of root of the MR-tree from the VO and then verifying it against the root signature using the data owner X  X  public key. If the verification is successful, the client next finds the range result directly from the data points extracted from
A secure-hash function is often used to compute a fix-length di-gest. the VO (ignoring the non-leaf entries). Then, the client defines the verification region  X  ( q, r ) and checks whether every non-leaf entry in the VO satisfies e.b  X   X  ( q, r ) =  X  . If so, the client can assure that the computed range result is correct. The reason is that, if a non-leaf entry e in the VO does not intersect  X  ( q, r ) , that means all the points in e cannot become the range result of q .
In this paper, we use MR-tree because of its popularity and low construction cost, and our concept of VO -optimality is also based on MR-tree. MR*-tree is an extension of MR-tree [28], where each node is embedded with a conceptual Merkle KD-tree defined on en-tries in the node. If a query region intersects with only one side of a split axis (in a KD-tree), then it skips inserting the entries on the other side into the VO . This technique can reduce the number of entries in the VO at the cost of higher construction and computation time. Reference [13] discusses another spatial ADS called PMKd-tree, which separates the query processing part and the VO con-struction part in order to obtain better query efficiency and smaller verification objects. To the best of our knowledge, we are the first to study the authentication of moving range queries. Existing spatial authentication techniques [28, 19, 6] cannot help in authenticating moving queries because they focus on static queries, so that the au-thentication targets (i.e., the query results) are part of the dataset. In contrast, authentication of moving queries require authenticating both the query results (part of the dataset) and the safe regions ( not part of the dataset).

Our recent work [31] examined how to authenticate the safe re-gions of moving k NN queries. However, the safe regions for k NN queries (e.g., convex polygons) are different from those for range queries (e.g., set unions/differences of circles). This renders the specific techniques in [31] inapplicable to our problem here. Also, we will prove that our method is VO -optimal, in which [31] did not introduce this notion yet.
 Moving query processing In moving query processing, [24] com-putes the nearest neighbors for each possible query point on a given line segment, whereas [7] studies how to maintain the user X  X  future k NN upon a change of the user X  X  velocity. Both [24] and [7] model the user X  X  movement as a linear function. When the user X  X  future movement is unknown, the buffering approach [23] and the safe re-gion approach [33, 14] are more appropriate for efficient moving query processing.

In the buffering approach [23], the LBS returns users the original result points and some additional result points to constitute a buffer region . While moving within the buffer region, the client X  X  latest result can be recomputed locally from the result of the previous query. However, it is not easy to tune the size of the buffer region in practice, and that value actually influences the communication frequency and the number of objects sent per communication.
In the safe region approach, the LBS reports a safe region [33, 14, 3] for the query result, such that the result remains unchanged while the user moves within the safe region. Unlike the buffer-ing approach, this approach does not require the client to compute result locally. This approach reduces both the communication fre-quency and the computational overhead for the user.

Finally, note that the solutions in [23, 24, 7, 14] focus on moving k NN queries rather than moving range queries. The safe regions of moving range queries were studied in [33, 3]: rectangular range queries [33] and circular range queries [3].
Following [33, 14, 3], in this paper, we consider a generic prob-lem setting in which q is a moving object whose future locations cannot be predicted in advance. In a moving query environment, the question is when and where the client should (re-)issue query in order to get the most updated query range result as q moves. Baselines for moving query authentication A brute-force method is that the client periodically issues a query to the server for every T time units. The correctness of the results can then be authenticated using an MR-tree. However, there is no way to guar-antee that result is always up-to-date even when a very small T is used, rendering this method impractical.

To authenticate moving spatial queries, a baseline method uses the buffering approach to compute the query result and then authen-ticate the results by using an MR-tree. Specifically, a client issues a range query with a range  X  r larger than the original query range r . Again, let q last be the last location sent to server. As long as the current location of q moves within the buffer region  X  ( q the latest query result can be derived from the result of the last query because any ranges that have center within  X  ( q last radius r are totally inside  X  ( q last , r +  X  r ) .

Although simple, the buffering approach requires finding the optimal value of  X  r . A small  X  r leads to more frequent communication, thereby increasing the communication cost. A large  X  r , unfortunately, also increases the communication cost because the size of the VO increases.
 Our safe region approach The buffering approach is not a true safe region approach because even when staying within the buffer region the client is still required to recompute result locally. Our approach is to return a safe region for the query result, such that the result remains unchanged as long as the user X  X  location q stays within the safe region. This approach helps reducing the commu-nication frequency between the LBS and the client. However, for the various reasons we mentioned in the introduction, the LBS may return incorrect safe regions, rendering the user X  X  future result in-correct. Our goal is thus to devise methods for the client to verify the correctness of the safe region returned by LBS.
 Framework for moving query authentication Figure 2 illus-trates the framework for answering moving spatial queries that supports query correctness verification. A map provider (e.g., the government X  X  land department, NAVTEQ 2 and TeleAtlas 3 ) collects points-of-interests into a spatial dataset. It builds the MR-tree [28] of the dataset and signs the digest of the root node, before dis-tributing/selling it to a service provider (i.e., LBS). Initially, a mo-bile user downloads the root signature from the LBS and the map provider X  X  public key from a certificate authority (e.g., VeriSign). Afterwards, the user sends its location to the LBS, and obtains the query result, the safe region, and the VO . The correctness of the query result and the safe region can be verified at the client by using the received VO , the root signature and the map provider X  X  public key. The client needs to issue a query to the LBS again only when it leaves its safe region.
NAVTEQ Maps and Traffic. http://www.navteq.com TeleAtlas Digital Mapping. http://www.teleatlas.com
The spatial dataset is expected to have infrequent updates (e.g., monthly map updates). In case the user requires fresh results (i.e., obtained from the latest datasets), the map provider could follow [10] to include a timestamp in the root signature of the tree.
Our adversary model is the same as in [28]. Except the data owner X  X  private key, adversaries are assumed to know all other in-formation, e.g., the data owner X  X  public key, the secure-hash func-tion, the Merkle R-tree, its root signature, and our authentication algorithms. The security is guaranteed by the Merkle R-tree [28].
There are two main types of range query, rectangular range query [5, 6] and circular range query [4, 6]. The former speci-fies the query range as a rectangle whereas the latter specifies the query range as a circle. In this paper, we focus on the authentica-tion of moving circular range queries. Hereinafter, we use the term range query to denote circular range query. A summary of notation used in this paper is given in Table 1.

In the following, we first introduce some basic definitions for our problem. Then, we present our Arc-Based (AB) method for con-structing VO for moving range query authentication (Section 4.2). As we will elaborate later, the safe region for a moving range query is constituted by a set of arcs. Hence, our AB method exploits this property to construct a compact VO . Furthermore, we can prove that our AB method is VO -optimal, i.e., it puts the minimum data points and MR-tree entries into the VO (Section 4.3). Afterwards, we analyze the size of the VO constructed by this method (Section 4.4). At the end, we present a method to further reduce the commu-nication frequency (Section 4.5) by reusing the VO when the client crosses a safe region.
A (circular) range query is a circle  X  ( q, r ) , where q is a query point and r is a radius (in Euclidean distance). A data point p is in the result set S if its distance from q is less than or equal to r , i.e., dist ( q, p )  X  r . In contrast, a data point p is not in the result S if its distance from q is greater than r , i.e., dist ( q, p ) &gt; r . In Figure 3(a), the bold circle  X  ( q, r ) is a circular range query with center q and radius r . Data points g 1 , g 2 , g 3 , and p  X  ( q, r ) , so they are result points and in S . Since g  X  ( q, r ) , g 4 is a not a result point and not in S .

When a client moves, its range query result may change. In or-der to get the updated result, basically it has to submit a new query to the LBS using its updated location q  X  . To minimize the com-munication frequency and the communication cost, we adopt the safe region approach. When the server receives a range query, it returns the client a safe region SR in addition to the query result S . Therefore, the client does not need to issue a new query to the LBS as long as it moves within SR . The safe region for moving range queries [4] is stated below.
 Definition 1. Safe Region of Range Query (Ref. [4]) The safe region SR ( S, D ) of a circular range query is defined as: where S is the set of result points of range query  X  ( q, r ) and D is the dataset.
 In Figure 3(a), the light grey region is the safe region SR ( S, D ) for the range query result S = { g 1 , g 2 , g 3 , p 1 } . It is formed by
Note that the safe region SR ( S, D ) is enclosed by four arcs: ab  X  , bd  X  , dc  X  , and ca  X  , which are originated from circles  X  ( g  X  ( p 1 , r ) does not contribute to the final safe region SR ( S, D ) (in fact SR ( S, D ) is completely inside  X  ( p 1 , r ) ). So, [4] distinguishes the set of data points G that are necessary for representing the safe region, which are called guard objects , from the others. Definition 2. Guard Object (Ref. [4]) Given a point g i , g i is a guard object if part of  X  ( g an arc g arc i , can contribute to the final safe region SR ( S, D ) .
In Figure 3(a), points g 1 , g 4 , g 2 , and g 3 are guard objects because contrast, point p 1 is not a guard object.

The challenges of verifying the correctness of the safe region SR can be explained using Figure 3(a). Assume that the LBS needs to evaluate a range query  X  ( q, r ) and its safe region (i.e., the light grey region). By Definition 2, the LBS can represent the safe region using four guard objects g 1 , g 2 , g 3 , and g 4 . Having these guard objects, the client is able to construct the safe region.
Suppose that the LBS intentionally omits guard object g 4 only sends guard objects g 1 , g 2 , and g 3 to the client. In this case, the client will get an incorrect (larger) safe region, which is the union of the light grey region and the dark grey region. The chal-lenge here is that the client cannot notice that one guard object ( g is missing. Note that all guard objects g 1 , g 2 , and g from the dataset D (thus they pass the data correctness checking). However, the client cannot determine whether the set of guard ob-jects provided by the LBS is complete. Similarly, the LBS may also report a smaller safe region by returning fake objects as guard objects. Again such case is easy to be detected by checking the root signatures.
 By Definition 1, SR ( S, D ) is constructed by all data points in D . So, a brute-force solution is to return the whole dataset D to the client so that the client is guaranteed to compute SR ( S, D ) correctly. Our goal is to design efficient methods to construct veri-fication objects VO for verifying the correctness of the safe region, yet the size of VO should be as small as possible.
Our Arc-Based method constructs a compact VO for authenti-cating a moving range query. Its idea is to exploit the arcs of a safe region to construct a VO with minimal size. The method consists of a server algorithm and a client algorithm. At the server side, ev-erything that is necessary for verifying the range query result and the safe region is put into VO and sent to the client. At the client side, the correctness of the query result and the safe region is veri-fied based on the data stored in the VO .
 Algorithm 1 Arc-Based Method (Server) 1: S := compute the result points of q from the tree T D 3: rRV R :=  X  ( q, r ) 4: G := set of guard objects g i 6: rSRV R := S g 7:  X  := rRV R  X  rSRV R 8: VO := DepthFirstRangeSearch( T D .root,  X  ) 9: send VO to the client
Algorithm 1 is the pseudo-code of the server algorithm. Upon receiving the user location q and the radius r , the server computes the result points from an MR-tree T D (Line 1). Then, it computes the safe region by using safe region computation method in [4] efficiently (Line 2).

Next, it defines a verification region  X  so as to identify data points that are useful for verifying the range query result and the safe region and put them into V O . More specifically, the verifica-tion region  X  is defined as the union of (i) the range query result verification region ( rRV R ) and (ii) the range query safe region verification region ( rSRV R ).
 Definition 3. Range query result verification region ( rRV R ). The range query result verification region ( rRV R ) is defined as the circular region  X  ( q, r ) at the current query location q with ra-dius r . In Figure 3(a), the bold circle  X  ( q, r ) is rRV R .

The definition of the range query safe region verification region rSRV R is quite complicated. Therefore, we first state some pre-liminary definitions.

Definition 4. Guard object end points circles ( GOEP C g i Given a guard object g i , the guard object end points circles of g ( GOEP C g i ) is the union of  X  ( A 1 end , r ) and  X  ( A 2 end and A 2 end are two end points of g arc i , an arc that contributes to the final safe region SR ( S, D ) .
 Definition 5. Guard object sector difference ( GOSD g i ) Given a guard object g i , the guard object sector difference of g ( GOSD g i ) is the difference between a sector 2 ( g i , 2 r ) with center g and radius 2 r , and a sector 2 ( g i , r ) with the same center g with radius r . The angle subtended by the sectors are determined by the end points A 1 end and A 2 end described in Definition 4.
In Figure 3(b), given a guard object g 3 , and assume that g is the arc that contributes to the final safe region SR ( S, D ) . The two end points of g arc 3 are a and b . So, the guard object end points circles of g 3 , i.e., GOEP C g 3 , is the union of circles  X  ( a, r ) and  X  ( b, r ) . Note that GOSD g 3 is the dark grey region abef .
With the definitions of guard object end points circles and guard object sector difference, we now define the verification region of a guard object as follows.

Definition 6. Guard object verification region ( GOV R g i
Figure 3(b) shows the verification region of guard object g which is the union of the light grey region and the dark grey re-gion.

Now, we define range query safe region verification region ( rSRV R ) as follows.

Definition 7. Range query safe region verification region ( rSRV R ) The range query safe region verification region ( rSRV R ) is de-fined as the union of the GOV R g i of each guard object g except its circumference : where G is the set of guard objects and is the circumference of
S g i  X  G GOV R g i , i.e., = { z  X  R 2 | X  location l on g dist ( l, z ) = r ,  X  locations l  X  on g arc i , dist ( l  X  , z )  X  r }
Finally, the verification region  X  for authenticating (moving) range query is defined as the union of the range query result verifi-cation region ( rRV R ) and the range query safe region verification region ( rSRV R ).
 Definition 8. Verification region  X 
With the verification region  X  for a moving range query clearly defined, the VO can be constructed by a depth-first traversal of the MR-tree (Line 8 in Algorithm 1). Points inside  X  are put in the VO and the rest are put in the VO as some non-leaf entries. We now prove that any point p  X  outside the verification region  X  cannot alter the range query result S and its corresponding safe region SR ( S, D ) and thus it is safe to exclude them in the VO .
T HEOREM 1. [Points p  X  outside  X  cannot alter the query re-sult and the safe region SR ( S, D ) ] PROOF: To prove the theorem, we prove that (i) any point p  X  out-side rRV R cannot be range query result (Lemma 1), and (ii) any point p  X  outside rSRV R cannot alter the safe region (Lemma 2). Since the verification region  X  is the union of rRV R and rSRV R , the theorem is proved if Lemma 1 and Lemma 2 hold.

L EMMA 1. [Points outside rRV R are not range query re-sult] We have  X  p  X  outside rRV R , p  X  /  X  S , where S is the range query result set.
 Proof: If p  X  is outside rRV R , then p  X  is not inside the query range. Thus, p  X  /  X  S .

L EMMA 2. [Points outside rSRV R cannot alter safe re-gion SR ( S, D ) ] If p  X  is outside rSRV R , then SR ( S, D ) = SR ( S, D \{ p  X  } ) .
 Proof: Recall that the safe region SR ( S, D ) is enclosed by a set of arcs g arc i . Therefore, if p  X  is outside GOV R g i for all g Lemma 3 from [4] implies that  X  ( p  X  , r ) does not intersect any arc g i and thus  X  ( p  X  , r ) does not overlap the safe region SR ( S, D ) . With that, Lemma 2 is proven.

L EMMA 3. If p  X  is outside GOV R g i , then  X  ( p  X  , r ) intersect arc g arc i . (Ref. [4]) Now, with Lemma 1 and Lemma 2, Theorem 1 is proven.

The shape of verification region  X  here is irregular (not a simple shape like circle). For efficient implementation, the server actually does not render the complex shape of the verification region  X  . Instead, we can check whether the following condition holds during the tree traversal (Line 8 in Algorithm 1), and if it does not, we add e into the VO :
The first term of Equation 1 checks whether the minimum dis-tance from non-leaf entry e to q is smaller than or equal to r . If the distance is smaller than or equal to r , e overlaps or touches rRV R . The second and third terms check whether the minimum distance from e to every end points A 1 end and A 2 end of arc g is smaller than r . If the distance is smaller than r , e overlaps with GOEP C g i . The last term checks whether e overlaps any
Algorithm 2 is the pseudo-code of the client algorithm. Upon receiving the VO , the client first reconstructs the root digest from the VO (Line 1) and verifies it against the MR-tree root signature signed by the data owner (Line 2). If the verification is successful, the VO is guaranteed to contain only entries from the original MR-tree (Line 3). After that, it proceeds to verify the correctness of result points and the safe region provided by the VO . It extracts from the VO (i) a set D  X  of data points, and (ii) a set R  X  of non-leaf entries, (Line 4-5) and then computes the result point set S  X  from rRV R (Lines 7 X 8). If the result points are correct, the client can proceed to check the safe region. The client next computes the safe region SR ( S  X  , D  X  ) from D  X  (Line 9). The client can ensure that SR ( S  X  , D  X  ) is correct if every non-leaf entry does not intersect  X  (Lines 10 X 14). If so, the client can treat the result points and the safe region as correct (Line 15).
 Algorithm 2 Arc-Based Method (Client) 7: rRV R :=  X  ( q, r ) 10: G := set of guard objects g i 12: rSRV R := S g 13:  X  := rRV R  X  rSRV R 16: return authentication failed
Up to now, we have introduced the server algorithm and the client algorithm of the Arc-Based (AB) method. Now, we prove that the client can verify the range query result and the safe region by using the VO constructed by this method.

L EMMA 4. [Client can verify the correctness of range re-sult] Proof: Direct results from [28].
 L EMMA 5. [Client can verify the correctness of safe region] Following the Arc-Based (AB) method, a client can verify that the constructed safe region SR ( S  X  , D  X  ) equals to the correct safe re-gion SR ( S, D ) , i.e., SR ( S  X  , D  X  ) = SR ( S, D ) . Proof: First, from Lemma 4, we know S  X  = S.  X   X   X  ( )
Next, line 1 and line 2 of Algorithm 2 ensure that all data points p  X  D  X  and all non-leaf entries e  X  R  X  in the VO are originated from the data owner [28]. Then, the client algorithm checks whether any non-leaf entry e  X  R  X  intersect rSRV R , and if no, it regards the safe region SR ( S  X  , D  X  ) as correct, i.e., SR ( S  X  , D  X  ) = SR ( S, D ) . We prove its correctness by contradic-tion.

Assume the client regards SR ( S  X  , D  X  ) = SR ( S, D ) even when a non-leaf entry e  X  R  X  in VO intersects rSRV R . When e inter-sects rSRV R , it is possible that  X  p  X   X  e inside rSRV R .
Let P  X  be the set of p  X   X  e that is inside rSRV R and P  X  be the set of p  X   X  e that is outside rSRV R . By Lemma 2, p  X   X  P  X  may (or may not) alter the safe region. Since e covers points in P  X   X  P  X  , a point p in e may (or may not) alter the safe region, i.e., it is possible that SR ( S, D \{ P  X   X  P  X  } ) 6 = SR ( S, D ) .  X  X  X  X  (  X  ) (the set of data points in VO ), as points in P  X   X  P  X  are repre-sented by a non-leaf entry e , they are not in D  X  , therefore, we have D  X  = D \{ P  X   X  P  X  } . And hence, we have SR ( S  X  , D  X  ) = SR ( S  X  , D \{ P  X   X  P  X  } ) .
 By ( ) , we get SR ( S  X  , D  X  ) = SR ( S  X  , D \{ P  X   X  P  X  } ) = SR ( S, D \ ( P  X   X  P  X  ) . Combining this with (  X  ) , we obtain that SR ( S  X  , D  X  ) may not equal to SR ( S, D ) , i.e., it possible that SR ( S  X  , D  X  ) 6 = SR ( S, D ) , which contradicts with the assump-tion. In this section, we prove that the Arc-Based (AB) method is VO -optimal, i.e., it puts the minimum data points and MR-tree entries into the VO .
 T HEOREM 2. [The AB method is VO -optimal] PROOF: To prove the theorem, we need to prove that (i) Points inside  X  are sufficient for the client to verify the correctness of the query result and the safe region (Lemma 6). (ii) Points inside  X  are necessary for the client to verify the correctness of the query result and the safe region (Lemma 7). Since the establishment of (i) shows that all points in  X  are sufficient and the establishment of (ii) shows that all points in  X  are necessary, the VO contains the minimum data points. Furthermore, since the MR-tree is being visited from the root node, and traversed until we find a non-leaf entry e that does not intersect  X  , so the number of non-leaf entries that put into VO is also minimum.

L EMMA 6. [Points p inside  X  are sufficient for client to ver-ify the correctness of range query result and its safe region] Proof: Lemma 4 implies that points p inside rRV R are sufficient for the client to verify the correctness of the query result. Lemma 5 implies that points p inside rSRV R are sufficient for the client to verify the correctness of the safe region. Since  X  is the union of rRV R and rSRV R , points p inside  X  are sufficient for client to verify the correctness of the range query result and the safe re-gion.

L EMMA 7. [Points p inside  X  are necessary for client to ver-ify the correctness of range query result and its safe region] Proof: First, we prove that all points inside rRV R are necessary for the client to verify the correctness of query result.  X   X   X  ( ) Since all points inside rRV R are the query result, they must be returned to the client. Hence all points inside rRV R are necessary.
Next, we prove that all points p inside rSRV R  X  rRV R are necessary for the client to verify the correctness of the safe region.  X   X   X  (  X  )
We prove this by contradiction. Suppose there exists non-result point p  X  inside rSRV R  X  rRV R such that SR ( S  X  , D  X  ) = SR ( S  X  , D  X  \{ p  X  } ) . By definition of rSRV R (Definition 7), we know that there exists a location l inside SR ( S  X  , D  X  \{ p  X  } ) such that dist ( p  X  , l )  X  r . Therefore, we have By this, we can conclude that: By the definition of safe region (Definition 1), we know Combining (2) and (3), we can conclude that SR ( S  X  , D  X  ) = contradiction.

Finally, since rRV R  X  ( rSRV R  X  rRV R ) = rRV R  X  rSRV R , and  X  is the union of rRV R and rSRV R , by ( ) and (  X  ) , all points p inside  X  are necessary for client to verify the correctness of the query result and the safe region.
Next, we provide a theoretical analysis on the size of the VO constructed by our AB-method. Given a region, the size of the VO can be estimated by the cost formula in [28]. So, here we focus on estimating the size of the verification region  X  .

For simplicity, we assume that data points are uniformly dis-tributed. Let d max be the maximum distance between query point q and any point in the safe region. Hence, the circular region  X  ( q, d max ) can completely cover the safe region. If a circular re-gion with radius r and center outside  X  ( q, r + d max ) , it cannot overlap with  X  ( q, d max ) and thus it cannot overlap with the safe region. Therefore,  X  ( q, r + d max ) is a valid verification region. Since  X  is VO -optimal and  X  ( q, r + d max ) is a valid verification region,  X  is completely covered by  X  ( q, r + d max ) . In [4], the upper bound of the expected distance m up that a point can move number of data points in D . Here, we use m up to approximate d max . Therefore, the size of the VO is estimated by substituting the area  X  ( r + 0 . 33 rn ) 2 into the MR-tree VO size analysis in [28].
Our Arc-Based method computes safe regions in order to mini-mize the communication frequency between the mobile client and the server. In this section, we discuss how the client can reuse the previously received verification object VO in order to further reduce the communication frequency between the server and the client even when the client leaves the safe region.

Let us consider the example in Figure 5. In Figure 5a, a client is located at q now and its previous location was at q last . At q the range query result set was { g 1 , g 2 , g 3 } and its safe region  X  last was the light grey region. Since  X  last intersected the non-leaf entries e 1 , e 2 , their leaf nodes were visited and their data points were inserted into the verification object VO last .  X  last tersect e 3 so e 3 was inserted into VO last , and the subtree of e not visited. Thus, VO last = { g 1 , g 2 , g 3 , g 4 , e 3
Later on, the client moves to a new location q now , which is outside the safe region. Before sending a new query to the server, the client can run Algorithm 2 again using the previous VO last and its current client location q now as inputs. First, the client finds the query result set of q now from VO last and the re-sults are { g 1 , g 2 , g 3 , g 4 } . Then, the corresponding safe region SR ( { g 1 , g 2 , g 3 , g 4 } , D  X  ) is computed as the region bdf and the corresponding verification region  X  now is computed as the dark grey region shown in Figure 5b. Observe that  X  now does not in-tersect any non-leaf entries in VO last (e.g., e 3 ), the client actually can compute the results and the safe region without any data points from e 3 . Therefore, it does not issue a new query to the server. This example illustrates how the client is able to refresh the safe region without issuing a new query to the server. By using this technique, the client needs to send a new query to the server only when the new verification region  X  now intersects some non-leaf entry in VO
Figure 5: Reusing VO for moving range query authentication We evaluate our methods using both synthetic and real datasets. We implemented all methods in C++ with the cryptographic func-tions in the Crypto++ library 4 . All experiments were run on a 2.5 GHz Intel PC running Ubuntu with 8 GB of RAM. The page size of MR-trees is set to 4 Kbytes.
 Datasets and query trajectories The real datasets are NA (North America, 175K points), ARG (Argentina, 85K points), CHINA (China, 32K points) 5 . These datasets have also been used in [18, 30] to model points-of-interests in different countries. We also generated UNI (synthetic uniform) and GAU (synthetic Gaussian) datasets for the scalability experiments. We followed [2, 32, 26] to generate each GAU dataset such that it contains 100 Gaussian bells of equal size and every Gaussian bell has a standard deviation as 2.5% of the domain space length. The query workload contains trajectories of 50 moving objects generated by trajectory generator in [14]. Each trajectory simulates an object running in Euclidean space (directional movement) and has a location record at every timestamp; there are 10,000 timestamps in total and the time be-tween adjacent timestamps is 1 second. Therefore, each object X  X  journey is about 10,000 seconds (i.e., about 2.7 hours). We try to simulate the scenario of a car (default speed 50km/hr) moving at the country level (i.e., on CHINA, ARG, and NA datasets).
Table 2 shows the building time of MR-trees on the real datasets and synthetic datasets (50K data points to 1000K data points). The time of building MR-trees scales well with the data size. Performance measure Following [14], we measure the cumula-tive total cost for each object X  X  trajectory. In our experiments, we
Crypto++ library: http://www.cryptopp.com/
Downloaded from http://www.maproom.psu.edu/dcw/ and http://www.dis.uniroma1.it/  X  challenge9/download.shtml We have repeated the whole experimental study using MR*-tree. The experimental results are similar and not described here. report the communication cost (in kilobytes) as the total size of VO per object. This is the most important measure in this paper and we hope to minimize it. We also report the communication frequency , which is the number of clients X  queries received by the server, per object. In addition, we report the server and client CPU time (in seconds), per object journey.
 Competitors We now report the experimental results of moving range queries. The default query range r is 5 km for a moving client (i.e., on CHINA, NA, and ARG datasets). We compare our AB-method with the baseline buffering method (rBASE) mentioned in Section 3. Again, rBASE X  X  performance depends on the  X  r value, which in turns depends on various factors such as the query range, query speed, data size, and data distribution. The optimal  X  r for a particular setting cannot be found unless we exhaustively try every possible  X  r value. However, for comparison purpose, we also car-ried out such a manual tuning process for rBASE in all our experi-ments. We use rBASE O to denote the best performance of rBASE that uses the optimal  X  r value. We use rBASE A to represent the average performance of rBASE over every  X  r value.
We study the effect of moving query speed on the performance of our AB-method, rBASE A , and rBASE O . Figure 6 shows (a) the total communication frequency, (b) the total communication cost, (c) the total server CPU time, and (d) the total client CPU time, of each moving object, with respect to different query speeds, in its 2.7-hour journey, on the three datasets.

In Figure 6a, the communication frequency of rBASE O is an-notated with the corresponding optimal  X  r value (in km) found by our manual tuning process. When the query speed increases, a client using the baseline methods leaves its buffer region easier, so its communication frequency increases. The communication fre-quency of our AB-method rises slowly because our method reuses the VO whenever applicable. Together with the fact that our VO -optimal method constructs very compact VO , this explains why the communication cost of our AB-method is much smaller than that of the baseline methods in Figure 6b.

The server computation overhead of our AB-method is very small (Figure 6c). That is because the communication frequency of AB-method is small and also computing safe regions for mov-ing range queries is not expensive.
 The client CPU times of all methods are shown in Figure 6d. We can see that all methods incur almost negligible computational overhead on the client side, which is less than 0.01 CPU seconds for a 2.7-hour journey.
Figure 7 shows the effect of the query range r . In Figure 7a, we can see that the communication frequencies of the baseline meth-ods are quite stable when r increases. That is because the optimal  X  r values for the baseline methods do not vary when r increases, so all buffering regions have the same size. Since the speed of the client is constant in this experiment, with constant size buffer-ing regions, the communication frequencies of the baseline meth-ods remain unchanged. The communication frequency of our AB-method increases slowly when r increases. That is because the number of result points increases when r increases. As the safe region of moving range query is defined as the intersection of re-sult points excluding the union of non-result points, the increase of result points results in a smaller safe region. This explains the increase of communication frequency with r . However, the com-munication cost of our AB-method is much lower than the baseline methods (Figure 7b) because our method is VO -optimal and thus is able to construct very compact VO . When r increases, the query results are larger and thus the VO s are larger. Therefore, the com-putation overhead of our AB-method on both the server side and the client side increase but still stays low (Figure 7c and d).
We proceed to study the scalability of our methods, by using synthetic data of different sizes. Figure 8 shows the performance of the methods under uniform datasets of different sizes. When the data size increases, the data density rises. Therefore, the query results as well as the VO -size generally would increase, leading to a higher communication cost. Nonetheless, we remark that the communication cost of our AB-method increases mildly because of the compact VO constructed as well as the reuse of the VO . Similar observations could be found on the Gaussian datasets (see Figure 9).
Finally, we validate the theoretical analysis about the size of VO in moving range query authentication. Our analysis has made cer-tain simplifying assumptions like uniform data distribution. Thus, the following validation is conducted on uniform data only. Fig-ure 10 shows the actual number of points covered by the verifica-tion region  X  and the estimated number based on the equations in Section 4.4 during moving range query authentication. The results show that our theoretical analysis is quite robust as it well captures the trend and the error is below 0.18 on uniform datasets.
In this paper, we presented a framework with efficient methods to authenticate moving range queries. We proved that our methods are VO -optimal, i.e., the size of the verification object ( VO ) required to carry out authentication is minimal in size. We also presented optimization techniques that can further reduce the communication frequency between a moving client and the service provider. Ex-perimental results show that our methods efficiently authenticate moving range queries using a small communication cost and com-putational overhead. As for future work, we plan to extend our methods to use other orthogonal ADS (e.g., PMKd-tree [13]) and establish the corresponding VO -optimality. [1] N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. [2] N. Bruno, S. Chaudhuri, and L. Gravano. Stholes: A [3] M. A. Cheema, L. Brankovic, X. Lin, W. Zhang, and [4] M. A. Cheema, L. Brankovic, X. Lin, W. Zhang, and [5] D. Gunopulos, G. Kollios, V.J.Tsotras, and C.Domeniconi. [6] L. Hu, W.-S. Ku, S. Bakiras, and C. Shahabi. Verifying [7] G. S. Iwerks, H. Samet, and K. P. Smith. Maintenance of [8] A. Kundu and E. Bertino. Structural Signatures for Tree Data [9] A. Kundu and E. Bertino. How to Authenticate Graphs [10] F. Li, M. Hadjieleftheriou, G. Kollios, and L. Reyzin. [11] F. Li, K. Yi, M. Hadjieleftheriou, and G. Kollios.
 [12] R. C. Merkle. A Certified Digital Signature. In CRYPTO , [13] K. Mouratidis, D. Sacharidis, and H. Pang. Partially [14] S. Nutanong, R. Zhang, E. Tanin, and L. Kulik. The [15] H. Pang, A. Jain, K. Ramamritham, and K.-L. Tan. Verifying [16] H. Pang and K. Mouratidis. Authenticating the Query Results [17] H. Pang, J. Zhang, and K. Mouratidis. Scalable Verification [18] D. Papadias, J. Zhang, N. Mamoulis, and Y. Tao. Query [19] S. Papadopoulos, Y. Yang, S. Bakiras, and D. Papadias. [20] S. Papadopoulos, Y. Yang, and D. Papadias. CADS: [21] R. L. Rivest, A. Shamir, and L. Adleman. A Method for [22] R. Sion. Query execution assurance for outsourced [23] Z. Song and N. Roussopoulos. K-Nearest Neighbor Search [24] Y. Tao, D. Papadias, and Q. Shen. Continuous Nearest [25] L. Wang, S. Noel, and S. Jajodia. Minimum-Cost Network [26] X. Xiong, M. F. Mokbel, and W. G. Aref. Lugrid: [27] Y. Yang, D. Papadias, S. Papadopoulos, and P. Kalnis. [28] Y. Yang, S. Papadopoulos, D. Papadias, and G. Kollios. [29] K. Yi, F. Li, G. Cormode, M. Hadjieleftheriou, G. Kollios, [30] M. L. Yiu, Y. Lin, and K. Mouratidis. Efficient Verification [31] M. L. Yiu, E. Lo, and D. Yung. Authentication of Moving [32] M. L. Yiu and N. Mamoulis. Clustering objects on a spatial [33] J. Zhang, M. Zhu, D. Papadias, Y. Tao, and D. L. Lee.
