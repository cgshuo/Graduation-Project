 A peer-to-peer (P2P) network is an internet communication model which allows a group of users to share the computing power, bandwidth, and other resources of participant computers. These autonomous computers form a self-organizing overlay network on the internet so that they can share resources without centralized control. There are two classes of P2P overlay networks: unstructured and structured [11]. In an unstructured P2P system, the overlay network does not form any particular topology and the peers can freely join the system by following some simple rules [5], [7]. Because of the unstructured nature, fl ooding is the most feasible mechanism for sending a query in the network. However, if there are a large number of peers in the system, the costs of locating an unpopular item using flooding are very high. 
On the other hand, various topologies, including mesh [14], [16], ring [4], [15], multi-dimensional space [13], XOR metric [12], list [1], and tree [2], [3], [8], [9], [10], have been proposed to organize the peers in a structured P2P overlay network. Because every data item stored in the network is assigned a unique key and the key is mapped to a peer according to the overlay topology, a data item can be easily found using the key. Many of the structured P2P network systems use a distributed hash table (DHT) as a substrate to support a hash-table based insertion and retrieval of data items. These DHT-based systems are scalable with respect to network size and efficient in terms of overlay routing hops for searching a data item. However, since they use hash tables to map data items, DHTs support only exact match queries. One effective means for supporting range based data partitioning and retrieval is to build a balanced tree overlay network. 
BATON is a balanced tree overlay network proposed for a P2P system [8]. The overlay network is based on a binary balanced tree structure, where each tree node is maintained by a peer in the network. Upper level nodes in a tree structure are more frequently accessed because a message needs to be routed through a common ancestor nodes near the root, BATON maintains both vertical and horizontal routing information. Therefore, each node in the tr ee structure stores not only links to its parent and children nodes, but also links to its adjacent nodes and some selected nodes at the same level. The tree overlay structure also acts as a distributed index structure. BATON assigns to each node in the tree a range of index values according evenly across all nodes. However, the data distribution may become uneven after data items are inserted into and/or deleted from the system. In addition, certain data ranges may be frequently accessed because they contain some popular data items. These situations cause undesired data and execution skew problems, where most queries are executed on only a few nodes. 
In order to remedy these skew problems, we need efficient strategies to perform load balancing. NbrAdjust and Reorder are two basic load balancing operations proposed in the literature [6]. The NbrAdjust operation moves a portion of data from the overloaded node to its neighbor. The Reorder operation first tries to find a lightly loaded helper node and then does the load balancing in three steps: (1) Mov-ing all data from the helper node to its neighbor; (2) Logically inserting the empty helper node as a neighbor to the overloaded node; (3) Splitting the load of the over-loaded node between the two neighboring nodes. BATON implements its load bal-ancing strategies based on these two operations [8]. On the other hand, P-Ring applies the same principle but improves the load balancing performance by keeping a set of helper nodes handy [4]. However, these load balancing strategies are basi-cally sequential algorithms, which try to balance the load of the overloaded node with the helper nodes one at a time. This is an expensive approach. Furthermore, if we have a highly skewed situation, the problem is getting worse because the over-loaded node and its neighbors are already busy with the overwhelming demands and cannot help much in executing the load balancing algorithms. Thus, we need paral-lel load balancing strategies that do not rely on active participation of the over-loaded nodes. 
This paper proposes two parallel load balancing strategies for tree-structured P2P networks: vicinity load balancing and virtual group load balancing. The former strat-egy first probes neighboring nodes of the overloaded node to find possible helper nodes and then distributes the load over them. The latter strategy tries to locate a lightly loaded region and then redirects th e load to the region. Because we send mes-sages in parallel, it takes less time and requires smaller number of messages to find the potential helper nodes. The time complexity of this step is in the order of O ((log 2 n ) nodes participated in this step. Similarly, parallel propagation of range and routing information reduces the costs of load distribution. In this step, the time complexity is in the order of O (log 2 N ) and the message complexity is in the order of O ( N ), where N is the number of tree nodes. In addition, we intentionally simplify the role played by the initiator of the algorithm so that the overloaded node does not need to pay too much attention to the load balancing process. Simulation results indicate that the pro-posed strategies perform well and are better than the BATON load balancing methods in most cases. 
The rest of the paper is organized as follows. Section 2 provides necessary back-ground information about BATON. Section 3 presents the two new parallel load balancing strategies. Section 4 describes the simulation results. Finally, Section 5 concludes this paper. BATON (BAlanced Tree Overlay Network) is a balanced tree structure overlay net-work designed for P2P networks [8]. Each node in the tree handles a range of index values, which are assigned to the nodes accord ing to an inorder traversal of the tree. also maintains links to its adjacent nodes in the inorder traversal sequence and some selected nodes at the same level. Links to the selected nodes at the same level are stored in a left routing table and a right routing table, which contain the links to nodes that are 2 i nodes away from the node ( i = 0, 1, 2, ...). An example of the BATON tree structure is shown in Fig. 1. 
Because BATON is a balanced tree structure, we can search for an exact index value in O (log N ) steps, where N is the number of tree nodes. A node is free to join or leave a P2P system, which may cause imbalance in a BATON tree. Therefore, we need to balance the tree after node addition or deletion by adjusting the tree structure and updating the routing tables. It takes O (log N ) messages for performing both of these operations on a BATON tree. 
Each node in a BATON tree manages a range of index values. The computational load on a node is the number of queries issued against the data items managed by the node. Therefore, we can share the load of an overloaded node with its adjacent nodes by adjusting the data range between them. However, if the adjacent nodes are also heavily loaded, this range adjustment operation may propagate to other nodes. This sequential load balancing process will incur high costs. An alternative way of doing load balancing is to use a helper node. We first try to find a lightly loaded helper node using neighbor routing tables. Then we pass th e load of the helper node to its adjacent node, remove the helper node from its original position, and insert it as a new adjacent node of the overloaded node. Finally, we split the load of the overloaded node be-tween the node and its newly inserted empty adjacent node. Because moving the helper node may cause imbalance in the tree structure, we need to adjust the tree structure and update the routing tables. If the load is too heavy to be balanced using only one helper node, we need to repeat this process. Although the costs of each op-eration are in the order of O (log N ), repeatedly readjusting the tree structure may incur very high costs. Neither sequentially propagating load through neighboring nodes nor repeatedly readjusting the tree st ructure is an effective way of doing load balancing in a tree-structured network. Thus, we need load balancing strategies that can efficiently distribute the extra load over multiple helper nodes in parallel. In order to effectively handle a highly skewed dataset, we propose two parallel load balancing strategies: vicinity load balancing and virtual group load balancing. The vicinity load balancing strategy distributes the heavy load over a set of neighboring nodes which manages a continuous range of the index values. On the other hand, the virtual group load balancing strategy moves the heavy load to another lightly loaded region. The proposed strategies perform well because of using three basic techniques: (1) Combining multiple messages for the same target node into a single message; (2) Sending messages in parallel; (3) Reducing the work load of the overloaded node when doing load balancing. We present these strategies in the following subsections. 3.1 Vicinity Load Balancing The basic concept of the vicinity load balanc ing strategy is to use multiple neighbor-ing nodes to share the heavy load. This strategy consists of two phases: probing for participant nodes and sending update information to affected nodes. Because the in-dex values are partitioned into continuous ranges, we need to probe neighboring nodes to find enough logically adjacent n odes for sharing the heavy load. Without loss of generality, we only probe the nodes on the right side of the overloaded node, but the algorithm can be extended to search both sides with similar costs and results. Sending messages to all nodes in the right routing table of the overloaded node can probe a large number of nodes. However, this is wasteful of resources if only a few neighboring nodes are needed. We propose a round-based probing approach, which will double the total number of nodes searched at the same level after each round. Probing Phase. Probing nodes in the routing table cannot cover every node because the routing table only contains links to nodes that are 2 i nodes away from the node. In order to probe 2 i nodes, we send messages to the first ( i +1) nodes in the right routing table in parallel. Among these nodes, we dedicate the last one as a leader node, which will collect all response messages and decide whether the next round of probing is necessary. When the j th node in the routing table receives the probing message, if j &gt; 2 and the node is not the last node, it will send probing messages to the first ( j -1) nodes in its own right routing table. In addition, the node will send a probing message probing 16 nodes. In the first step, node 0 sends probing messages to the first five nodes in its right routing table: node 1, node 2, node 4, node 8, and node 16, and noti-fies them that node 16 is the leader node of this round. Because node 4 is the 3rd node in node 0's routing table and it is not the last node in this round, node 4 needs to send probing messages to the first 2 nodes in its own right routing table. Similarly node 8 needs to send probing messages to nodes 9, 10, and 12 as shown in step 2. In addition, nodes 4, 8, and 16 also send probing messages to nodes 3, 7, and 15, respectively. This process continues until every node receives the probing message. In the mean time, node 16 will receive response messages from all nodes participated in this round and decide whether it should initiate the next round of probing. 
This probing process only propagates messages among nodes at the same level. Since index values are assigned to nodes according to the inorder traversal sequence, we need to consider nodes at other levels in the probing phase. Note that at least one of the two adjacent nodes of any internal node in a BATON tree is a leaf node [8]. Therefore, if the overloaded node is an internal node, we can use its right adjacent leaf node to initiate the probing process. On the other hand, if the internal overloaded node does not have a right adjacent node, we can initiate the probing process from the overloaded node itself. Thus, the probing messages are propagated at a level that is mainly composed of leaf need to probe these child nodes, too. For probing internal nodes, it is necessary to probe the right adjacent node of each probed leaf node. If the intended recipient node does not can relay the message through its parent node c to node f , because if a node x contains a parent node of node y [8]. The execution time of probing m nodes at the same level is cent nodes and child nodes only take constant time. Thus, the time complexity of the order of O ( n ), where n is the number of nodes probed. Updating Phase. When the probing phase finishes, the last leader node has received response messages from all the nodes probed. It can distribute the heavy load over the participant nodes by reassigning their index values. Therefore, the leader node needs to notify the participant nodes about their new range values. For those nodes that contain links to the participant nodes in their routing tables must change their routing tables accordingly. The leader node also n eeds to notify these affected nodes about the new range values. In order to reduce the number of messages, we propose a method that combines messages sent to the same node into a single message and transmits messages to multiple nodes in parallel. 
The leader node first divides participant nodes into buckets, each of which contains a set of consecutive nodes at the same level. For example, as shown in Fig. 3, the left subtree of the root node contains all participant nodes, which are divided into five different buckets because of the missing right child node of node 4. Secondly, the leader node passes all range values and routing tables of the nodes in the same bucket to the first node in the bucket. 
Knowing all range values and routing tables of the nodes in the bucket, the first node can combine the update information for a node into a single message. However, if the first node sends out all update messages at the same time, the node will be overwhelmed by this task because of the large number of messages. Thus, the node will divide the affected nodes into groups and notify them in parallel. For example, as This section presents the simulation results of vicinity load balancing, virtual group load balancing, and sequential adjusting strategies. We did compare the performance between the two methods used in BATON: adjusting with an adjacent node and inserting an empty helper node. One set of experiment results indicated that the number of messages sent in the latter approach was 30 times larger than the former approach. Because the costs of readjusting tree structure were much higher than the costs of other operations, we will not present the simulation results of this approach. The simulation programs were written in Python and run on a Linux system. We used a randomly generated BATON tree with 1000 nodes as the experiment data set. The experiment results were average values of 500 different experiments. 
We first compared the three load balancing strategies used in a system with a sin-gle overloaded node. In the experiments we assigned each node a default 0.8 unit load, and then varied the load of the single overloaded node from 2 to 17 units. The load balancing strategies shared the heavy load with helper nodes and ensured that the that the total messages sent and time units used in vicinity and virtual group strategies are much smaller than the sequential adjusting method when the load of the over-loaded node is heavy. As shown in Fig. 9, the number of participant nodes in the two parallel methods is larger than the sequential method because the round-based probing phase may probe more nodes than necessary. 
Then, we compared the three load balancin g strategies used in a system with mul-tiple overloaded neighboring nodes. We assigned 3 units of load for all overloaded nodes and varied the number of overloaded nodes from 1 to 19 in these experiments. Fig. 10 and Fig. 11 indicate that the costs of the virtual group load balancing strategy are the lowest among the three methods tested. In addition, as shown in Fig. 12, the number of participant nodes in the virtual group load balancing strategy is the small-est because it does not probe heavily loaded nodes. 4.1 Working Load We use the number of messages sent by each node to represent the working load of the node that participates in a load balancing process. This experiment assigned a single 5 units overloaded node and measured the number of messages sent in each adjusting method causes more nodes to send larger number of messages. Another set of experiments indicated that the overloaded node and its neighboring nodes sent more messages using the sequential adjusting strategy. Note that we did not include the costs of data migration in the experiments because they are similar in the three strategies after readjusting the index ranges. In tree-structured P2P networks, traditional load balancing operations either use an existing adjacent node or insert a helper n ode as an adjacent node to share the heavy load of the overloaded node. This approach is adequate for handling the data skew problem caused by data insertion and deletion, but this sequential approach may trig-ger a sequence of load balancing operations in case of execution skew. In order to handle both skew problems, we propose two parallel load balancing strategies for tree-structured P2P networks. The vicinity load balancing strategy, which consists of a probing phase and an updating phase, tries to find enough neighboring nodes to share the load in a round-based fashion. On the other hand, the virtual group load balancing strategy moves the heavy load to a lightly loaded region instead of moving helper nodes to the overloaded node. Becau se we combine all the messages that are intended to be sent to one node into a single message and send the messages in paral-lel, the time complexity and message complexity of the proposed strategies are lower than the sequential load balancing strategies. Furthermore, in order to reduce the work load of the overloaded node, we assign lead er nodes to collect response messages and initiate next round of probing if necessary. Simulation results indicate that the over-loaded node is relieved from the work of the load balancing process in the proposed strategies. 
Moving indexes instead of moving nodes can save the costs of readjusting the tree structure, but we need to modify query processing and index updating algorithms for redirecting the query to the virtual group. We will further study issues about imple-menting these algorithms and evaluating their performance in the future work. Acknowledgments. This research is supported in part by the National Science Coun-cil of ROC under grant NSC97-2221-E-415-006. 
