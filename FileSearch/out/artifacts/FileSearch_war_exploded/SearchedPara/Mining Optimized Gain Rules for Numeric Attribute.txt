 among the underlying data and have applications in marketing, financial and retail sectors. In its most general form, an association rule can be viewed as being defined over attributes of a relation, and has the form 12 X 1 + C X  X , where Cr and Cs are conjunctions of conditions, and each condition is from the domain of the attribute Ai). Each rule has an associated support and confidence. Let the of tuples satisfying Ci and the number of tuples in the relation. The support of a rule of the form while its confidence is the ratio of the supports of conditions Cr A CZ and Cl. The association rules problem is that of computing all association schemes for this can be found in [AS94, MTV94, tail information. The attributes of the rela-is a numeric attribute, 11 and u1 are uninstantiated variables, and Cl and Cz contain only instantiated conditions (that is, the conditions do not contain uninstantiated variables). Also, the authors define the gain of rule R, denoted by gain(R), to be the difference between the support of (Al E [ll, ~11) A C~ A Cz and the support of (Al E [II, ~11) A Cl times the user-specified minimum confidence. The authors then propose algorithms for determining values for the uninstantiated variables 21 and u1 for each of the following cases: l Confidence of R is maximized and the support l Support of the condition (Al E [II, ul]) A Cl is l Gain of R is maximized and confidence of R is 
Optimized association rules are useful for unrav-eling ranges for numeric attributes where certain trends or correlations are strong (that is, have high support, confidence or gain). For example, suppose the telecom service provider mentioned earlier was interested in offering a promotion to NY customers who make calls to France. In this case, the timing of the promotion may be critical -for its success, it would be advantageous to offer it close to a pe-riod of consecutive days in which the percentage of calls from NY that are directed to France is max-imum. The framework developed in [FMMT96b] can be used to determine such periods. Consider, for example, the association rule (date E [II, ~11) A src-city = NY + dst-country = France. With a min-imum confidence of 0.5, the optimized gain rule results in the period in which the calls from NY to France exceeds 50% of the total calls from NY, and furthermore, the number of these excess calls is maximum. 
A limitation of the optimized association rules dealt with in [FMMT96b] is that only a single optimal interval for a single numeric attribute can be determined. However, in a number of applications, a single interval may be an inadequate description of local trends in the underlying data. For example, suppose the telecom service provider is interested in doing upto Ic promotions for customers in NY calling France. For this purpose, we need a mechanism to identify upto Ic periods during which a sizeable fraction of calls are from NY to France. If association rules were permitted to contain disjunctions of uninstantiated conditions, then we could determine the optimal k (or fewer) periods by finding optimal instantiations for the rule: (date E dst-country = France. This information can be used by the telecom service provider to determine the most suitable periods for offering discounts on international long distance calls to France. The above framework can be further strengthened by enriching association rules to contain more than one uninstantiated attribute as is done in [FMMT96a]. Thus, optimal instantiations for the rule (date E duration E [G,&amp;]) + dst-country = France would yield valuable information about types of calls (in terms of their duration) and periods in which a substantial portion of the call volume is directed to France. 
In [RS99], we generalized the optimized asso-ciation rules problem for support, described in [FMMT96b]. We allowed association rules to con-tain upto k disjunctions over one uninstantiated nu-meric attribute. For one attribute, we presented a dynamic programming algorithm for computing the optimized support rule and whose complexity is O(n2k), where n is the number of values in the do-main of the uninstantiated attribute. In [RS98a], we considered a different formulation of the opti-mized support problem which we showed to be NP-hard even for the case of one uninstantiated at-tribute. The optimized support problem described in [RS98a] required the confidence over all the opti-mal regions, considered together, to be greater than a certain minimum threshold. Thus, the confidence of an optimal region could fall below the thresh-old and this was the reason for its intractability. In [RS99], we redefined the optimized support problem such that each optimal region is required to have the minimum confidence. This made the problem tractable for the one attribute case. 1.2 Our Contributions In this paper, we consider the generalized optimized gain problem. Unlike [FMMT96b] and [FMMT96a], we permit rules to contain upto k disjunctions over one or two uninstantiated numeric attributes. Thus, unlike [FMMT96b] and [FMMT96a], that only compute a single optimal region, our general-ized rules enable upto k optimal regions to be com-puted. 
Furthermore, unlike [RS99], in which we only ad-dressed the optimized support problem, in this pa-per, we focus on the optimized gain problem and consider both the one and two attribute cases. In addition, for rules containing a single numeric at-tribute, we develop an algorithm for computing the optimized gain rule whose complexity is O(nk) where n is the number of values in the domain of the uninstantiated attribute (the dynamic program-ming algorithm for optimized support that we pre-sented in [RS99] had complexity 0(n21E)). We also propose a bucketing optimization that can result in significant reductions in input size by coalescing contiguous values. For two numeric attributes, we present a dynamic programming algorithm that computes approximate association rules. Using re-cent results on binary space partitioning trees, we show that for the optimized gain case, the approx-imations are within a constant factor of the opti-mal solution. Our experimental results for a single numeric attribute demonstrate that our algorithms scale up linearly with the attribute X  X  domain size as well as the number of disjunctions. 
The work reported in this paper has been done in the context of the SERENDIP data mining project at 
Bell Laboratories (see www.bell-labs.com/projects/ serendip). Also, proofs of theorems and lemmas presented in the paper can be found in [RS98b]. 
In this section, we define the optimized association rules problem addressed in the paper. The data is assumed to be stored in a relation defined over categorical and numeric attributes. Association rules are built from atomic conditions each of which has the form Ai = wi (Ai could be either categorical or numeric), and Ai E [Zi, ui] (only if Ai is numeric). For the atomic condition Ai E [Zi, ui], if Zi and ui are values from the domain of Ai, the condition is referred to as instantiated, otherwise, if they are variables, we refer to the condition as uninstantiated. 
Atomic conditions can be combined using opera-tors A or V to yield more complex conditions. In-stantiated association rules, that we study in this paper, have the form Cr + CQ, where Cr and C X  X  are arbitrary instantiated conditions. Let the support for an instantiated condition C, denoted by sup(C), be the ratio of the number of tuples satisfying the condition C and the total number of tuples in the re-lation. Then, for the association rule R: Cl + Cz, sup(R) is defined as sup and conf(R) is defined as Sup(CIAC*) is different from the definition in [AIS93] where sup(R) was defined to be sup(Cr A Cz). Instead, we have adopted the definition of support used in [FMMT96b, FMMT96a, RS98a, RS99]. Also, let midonf denote the user-specified minimum confi-dence. Then, gain(R) is defined to be the difference between sup(C~ A CZ) and minConf times sz~p(Ci). 
In other words, gain(R) is sup(Cr A&amp;) -minConf * sup = sup(R) * (ccmf(R) -minconf). 
The optimized association rule problem requires optimal instantiations to be computed for an unin-stantiated association rule that has the form: U A 
Cr + C X  X , where U is a conjunction of one or two uninstantiated atomic conditions over distinct nu-meric attributes, and Cr and 15 X 2 are arbitrary in-stantiated conditions. For simplicity, we assume that the domain of an uninstantiated numeric at-tribute is {1,2,. . . ,n}. Depending on the number, one or two, of uninstantiated numeric attributes, consider a one or two-dimensional space with an axis for each uninstantiated attribute, and values along each axis corresponding to increasing values from the domain of the attributes. Note that if we consider a single interval in the domain of each uninstantiated attribute, then their combination re-sults in a region. For the one-dimensional case, this region [Zl, ui] is simply the interval [Zr,ur] for the attribute; for the two-dimensional case, the re-each axis by the endpoints of the intervals [Zr, ur] and [Zz, ~21 along the two axis. 
Suppose, for a region R = [ZI, ul], we define conf (R), sup(R) and gain(R) to be ccmf, sup and gain, respectively, for the rule Al E [II, ul] A Cl + 
CZ (similarly, for R = [(ZI, Z2), (211, uz)], cunf(R), sup(R) and gain(R) are defined to be wnf, sup In addition, for a set of non-overlapping regions, 
S = {RI, Rz, . . . , Rj}, Ri = [Zir, uir], suppose we define conf(S), sup(S) and gain(S) to be the conf, sup and gain, respectively of the rule Vi=,,Ar E [Zir , uir] A Cr + 15 X 2. For two dimensions, in which case each &amp; = [(&amp;I, b2 1, (~1, udl, cd(S), SUP(S) and gain(S) are defined to be the wnf, sup and gain, respectively of the rule Vi==, (Al E [Zil, uil] A 
A-J E [Ziz, uiz]) A Cr + CZ. Then, since RI,. . . , Ri are non-overlapping regions, the following hold for set S. conf(S) = 
Having defined the above notation, we present below, the formulation of the optimized association rule problem for gain. We refer to the set S as the optimized gain set. Example 2.1: Consider the telecom service provider database (discussed in Section 1) containing call de-tail data for a one week period. Figure 1 presents the summary of the relation for the seven days -the summary information includes, for each date, the total # of calls made on the date, the # of calls from NY and the # of calls from NY to France. Also included in the summary are the support, confidence and gain, for each date v, of the rule The total number of calls made during the week is 2000. 
Suppose we are interested in discovering the interesting periods with heavy call volume from NY to France (a period is a range of consecutive days). Then, the following uninstantiated association rule can be used. 
In the above rule, U is date E [Z,U], Cl is src-city = NY and Cz is d&amp;country = France. Let us assume that we are interested in at most 2 periods (that is, Ic = 2) with minConf = 0.50. The optimized gain set is { [5,5], [7,7]} -we require upto two periods such that the percentage of calls during each of the periods from NY that are to France is at least 50%, and the gain is maximized. Of the possible periods [1,2], [5,5] and [7,7], the gain in period [1,2] is 0, while the gains for [5,5] and [7,7] are 12.5 x 10m3 and 2.5 x 10T3, respectively. Thus, the optimized gain set is {[5,5], [7,7]}. I 
In the remainder of the paper, we shall assume that the support, confidence and gain for every point in a region are available -these can be computed by performing a single pass over the relation. The points, along with their supports, confidences and gains, thus constitute the input to our algorithms. Thus, the input size is n for the one-dimensional case, while for the two-dimensional case, it is n2. In this section, we tackle the problem of comput-ing the optimized gain set when association rules contain a single uninstantiated numeric attribute. Thus, the uninstantiated rule has the form: (AI E [Zr , ur]) A Cr + C X  X , where AI is the uninstantiated numeric attribute. We propose an algorithm with linear time complexity for computing the optimized gain set (containing upto k non-overlapping inter-vals) in Section 3.2. But first, in Section 3.1, we present preprocessing algorithms for collapsing cer-tain contiguous ranges of values in the domain of the attribute into a single bucket, thus reducing the size of the input n. 3.1 Bucketing For the one-dimensional case, each region is an interval and since the domain size is n, the number of possible intervals is O(n2). Now, suppose we could split the range 1,2,. . . ,n into b buckets, where b &lt; n, and map every value in Al X  X  domain into one of the b buckets to which it belongs. Then the new domain of Al becomes {1,2,. . . , b} and the number of intervals to be considered becomes O(b2) which could be much smaller, thus reducing the time and space complexity of our algorithms. Note that the reduction in space complexity also results in reduced memory requirements for our algorithms. 
In the following, we present a bucketing algorithm that 1) does not compromise the optimality of the optimized set (that is, the optimized set computed on the buckets is identical to the one computed using the raw domain values), and 2) has time complexity O(n). The output of the algorithm is the b buckets with their supports, confidences and gains, and this becomes the input to the algorithm for computing the optimized gain set in Section 3.2. 
For optimized gain sets, we begin by making the following simple observation -values in Al X  X  domain whose confidence is exactly minConf have a gain of 0 and can thus be ignored. Including these values in the optimized gain set does not affect the gain of the set and so we can assume that for every value in{1,2,... , n} , either the confidence is greater than minConf or less than minconf. 
The bucketing algorithm for optimized gain col-lapses contiguous values whose confidence is greater than minConf into a single bucket. It also com-bines contiguous values each of whose confidence is less than minConf, into a single bucket. Thus, for any interval assigned to a bucket it is the case that either all values in the interval have confidence greater than minConf or all values in the interval have confidence less than minconf. 
For instance, let the domain of Al be {1,2,. . . ,6} and confidences of 1, 2, 5 and 6 be greater than minConf, while confidences of 3 and 4 be less than minconf. Then, our bucketing scheme generates 3 buckets -the first containing values 1 and 2, the second 3 and 4, and the third containing values 5 and 6. It is straightforward to observe that assigning values to buckets can be achieved by performing a single pass over the input data and thus has linear time complexity. 
In order to show that the above bucketing algorithm does not violate the optimality of the optimized set, we use the result of the following theorem. Theorem 3.1: Let S be an optimized gain set. Then, for any interval [u,v] in S, it is the case that conf([u-l,u-11) &lt; midonf, conf([v+l,v+l]) &lt; minConf, conf([u,u]) &gt; minConf and cunf([v,v]) &gt; 
From the above theorem, it follows that if [u, v] is an interval in the optimized set, then values u and u -1 cannot both have confidences greater than or less than minConf -the same holds for values v and v + 1. Thus, for a set of contiguous values if the confidence of each and every value is greater than (or is less than) minconf, then the optimized gain set either contains all of the values or none of them. Thus, an interval in the optimized set either contains all the values in a bucket or none of them -as a result, the optimized set can be computed using the buckets instead of the original values in the domain. 3.2 Algorithm for Computing Optimized 
In this subsection, we present an O(bk) algorithm for the optimized gain problem for one dimension. 
The input to the algorithm is the b buckets generated by our bucketing scheme in Section 3.1 along with their confidences, supports and gains. 
The problem is to determine a set of at most k (non-overlapping) t al in erv s such that the confidence of each interval is greater than or equal to minConf and gain of the set is maximized. 
Note that due to our bucketing algorithm, buck-ets adjacent to a bucket with positive gain have 2. for i := 1 to k { 6. Delete Pq from PSet Figure 2: Algorithm for Computing Optimized 
Gain Set negative gain, and vice versa. Thus, if there are at most k buckets with positive gain, then these buckets constitute the desired optimized gain set. 
Otherwise, procedure optGainlD, shown in Fig-ure 2, is used to compute the optimized set. For an interval I, we denote by max(I), the subinter-val of I with maximum gain. Also, we denote by m&amp;(l), the subinterval of I whose gain is minimum. 
Note that, for an interval I, min(1) and maz(l) can be computed in time that is linear in the size of the interval. This is due to the following dy-namic programming relationship for the gain of the subinterval of I with the maximum gain and end-ing at point u (denoted by maz(u)): maz(u) = similar relationship can be derived for the subin-terval with minimum gain). The k desired intervals are computed by opt-GainlD in k iterations -the ith iteration computes the i intervals with the maximum gain using the results of the i -lth iteration. After the i -lth iteration, PSet is the optimized gain set contain-ing i -1 intervals, while the remaining intervals not in PSet are stored in NSet. After Pq and Nq have been computed as described in steps 3-4, if gain(min(Pq)) + gain(mas(Nq)) &lt; 0, then it fol-lows that the gain of min(Pq) is more negative than the gain of maz(N,) is positive. Thus, the best strategy for maximizing gain is to split Pq into two subintervals using min(Pq) as the split-ting interval, and include the two subintervals in the optimized gain set (steps 6-8). On the other hand, if guin(min(P,)) +gain(maz(l\r,)) 2 0, then the gain can be maximized by adding maz(N,) to the optimized gain set (steps 11-13). Note that if PSet/NSet is empty, then we cannot compute P,/N,, and so gain(min(Pq))/guin(mux(Nq)) in Step 5 is 0. Example 3.2: Consider 6 buckets 1,2,. . . ,6 with gains 10, -15, 20, -15, 20 and -15. We trace the execution of optGainlD assuming that we are interested in computing the optimized gain set containing 2 intervals. 
Initially, NSet is set to {[l,S]}. During the first iteration of optGainlD, Nq is [1,6] since it is the only interval in NSet. Furthermore, muz(N,) = [3,5] and guin(muz(N,)) = 25. Since PSet is empty, guin(min(Pq)) = 0 and Nq is split into 3 intervals [1,2], [3,5] and [6,6], of which [3,5] is added to PSet, and [1,2] and [6,6] are added to NSet (after deleting [1,6] from it). 
In the second iteration, Pq = [3,5] (min(Pq) = [4,4]) and Np = [1,2] (muz(N,) = [l, 11) (since 
For an interval [u, V] in PSet or NSet, conditions 1 and 2 state properties about the gain of its subin-tervals that contain u or V. Simply put, they state that extending or shrinking the intervals in PSet does not cause its gain to increase. Condition 3 states that the gain of PSet cannot be increased by replacing an interval in PSet by one contained in NSet, while conditions 4 and 5 state that splitting an interval in PSet and merging two other adjacent intervals in it or deleting an interval from it, cannot increase its gain either. Finally, Condition 6 cov-ers the case in which two adjacent intervals in PSet are merged and an additional interval from NSet is added to it -Condition 6 states that these actions cannot cause PSet X  X  gain to increase. Lemma 3.3: After the ith iteration of procedure optGainlD, the intervals in PSet and NSet satisfy conditions l-6. I We can also show that any set of i intervals (in PSet) that satisfies all of the 6 above conditions is optimal with respect to gain. -15). Thus, sinceguin(min(Pq))+guin(maz(Nq)) = conditions 1-6 is an optimized gain set. I of which [3,3] and [5,5] are added to PSet (after 
From the above two lemmas, we can conclude deleting [3,5] from it), which is the desired opti-that at the end of the ith iteration, procedure opt-mized gain set. I GainlD computes the optimized gain set containing i intervals (in PSet). 
We can show that the above simple greedy strategy computes the i intervals with the maximum gain (in the ith iteration). We first show that after Theorem 3.5: Procedure optGainlD computes the optimized gain set. 1 
We next consider the problem of mining the opti-mized gain set for the case when there are two unin-stantiated numeric attributes. In this case, we need to compute a set of k non-overlapping rectangles in two-dimensional space whose gain is maximum. Unfortunately, this problem in NP-hard [KMP98]. 
In the following subsection, we describe a dynamic programming algorithm with polynomial time com-plexity that computes approximations to optimized sets. 
The procedure optGain2D (see Figure 3) for com-puting approximate optimized gain sets is a dy-namic programming algorithm that uses simple end to end horizontal and vertical cuts for splitting each rectangle into two subrectangles. Procedure opt-
Gain2D accepts as input parameters, the coordi-nates of the lower left ((i, j)) and upper right ((p, q)) points of the rectangle for which the optimized set is to be computed. These two points completely de-fine the rectangle. The final parameter is the bound on the number of rectangles that the optimized set can contain. The array optSet[(i, j), (p, q), k] is used to store the optimized set with size at most k for the rectangle, thus preventing recomputations of the optimized set for the rectangle. The confidence, support and gain for each rectangle is precomputed -this can be done in O(n4) steps which is propor-tional to the total number of rectangles possible. 
In optGain2D, the rectangle [(i,j), (p, q)] is first split into two subrectangles using vertical cuts (steps 6-13), and later horizontal cuts are employed (steps 14-21). For k &gt; 1, vertical cuts between i to divide rectangle [(i, j), (p, q)] into subrectangles 
For every pair of subrectangles generated above, optimized sets of size kl and kg are computed by recursively invoking optGain2D for all k1, kz such that kl + k2 = k. An optimization can be employed in case k = 1 (Step 7), and instead of considering every vertical cut, it suffices to only consider the vertical cuts at the ends since the single optimized rectangle must be contained in either [(i,j),(p-l,q)] or [(i+ l,j),(p,q)]. After similarly generating pairs of subrectangles using horizontal cuts, the optimized set for the original rectangle is set to the union of the optimized sets for the pair with the maximum gain (function maxGainSet returns the set with the maximum gain from among its inputs). procedure optGainaD((i, j), (p, q), k) 1. if optSet[(i,j), (p, q), k] computed earlier 2. return optSetK43, (P, d, 4 5. optSet := optSet. := 0 7. ifk=l 8. optSet = maxGainSet(optGain2D((i,j), (p -1, q), 9. else 10. for 2 := i to p -1 do 11. for m := 1 to k -1 do 12. optSet = maxGainSet(optSetl, optGain2D 13. } 14. ifq&gt;j { 15. ifk=l 16. optSet = maxGainSet(optGainZD((i,j), (p, q -l), 17. else 18. for I := j to q -1 do 19. for m := 1 to k -1 do 20. optSet = maxGainSet(optSet2, optGain2D 21. } 22. optSet[(i,j), (p,q), k] := maxGainSet(optSet[(i,j), 23. return optSet[(i, j), (p, q), k] Figure 3: Dynamic Programming Algorithm for Computing Optimized Gain Set 
The number of points input to our dynamic programming algorithm for the two-dimensional case is N = n2 since n is the size of the domain of each of the two uninstantiated numeric attributes. 
Gain2D is O(N2.5k2). I 
Procedure optGain2D X  X  approach of splitting each rectangle into two subrectangles and then combin-ing the optimized sets for each subrectangle may not yield the optimized set for the original rectangle. 
This point is further illustrated in Figure 4(a) that shows a rectangle and the optimized set of rectan-gles for it. It is obvious that there is no way to split the rectangle into two subrectangles such that each rectangle in the optimized set is completely con-tained in one of the subrectangles. Thus, a dynamic programming approach that considers all possible splits of the rectangle into two subrectangles (using horizontal and vertical end-to-end cuts) and then combines the optimized sets for the subrectangles may not result in the optimized set for the original rectangle being computed. 
In the following, we first identify restrictions un-der which optGain2D yields optimized sets. We then show bounds on how far the computed ap-proximation for the general case can deviate from the optimal solution. 
Let us define a set of rectangles to be binary space partitionable if it is possible to recursively partition the plane such that no rectangle is cut, and each partition contains at most one rectangle. 
The set of rectangles in Figure 4(b) is binary space partitionable (the bold lines are a partitioning of the rectangles) -however, the set in Figure 4(a) is not. 
If we are willing to restrict the optimized set to only binary space partitionable rectangles, then we can show that procedure optGain2D computes the optimized set. Note that any set of 3 or fewer rectangles in a plane is always binary space partitionable. Thus, for t 5 3, optGain2D computes the optimized gain set. 
Theorem 4.2 : Procedure optGain2D computes the optimized set of binary space partitionable rectangles. I 
We next use this result in order to show that in the general case, the approximate optimized gain set computed by procedure optGain2D is within a factor of i of the optimized gain set. The proof also uses a result from [AF92], in which it is shown that for any set of rectangles in a plane, there exists a binary space partitioning (that is, a recursive partitioning) of the plane such that each rectangle is cut into at most four subrectangles and each partition contains at most one subrectangle. 
Theorem 4.3: Procedure optGain2D computes an optimized gain set whose gain is greater than or equal to a times the gain of the optimized gain set. 
I 
In this section, we study the performance of our algorithm for computing optimized gain sets for the one-dimensional case. In particular, we show that our algorithm is highly scaleable. For instance, we can tackle attribute domains with sizes as high as one million in a few minutes. 
In our experiments, the data file is read only once at the beginning in order to compute the gain for every point. The time for this, in most cases, constitutes a tiny fraction of the total execution time of our algorithms. Thus, we do not include the time spent on reading the data file in our results. Furthermore, note that the performance of our algorithms does not depend on the number of tuples in the data file -it is more sensitive to the size of the attribute X  X  domain n and the number of intervals L. We fixed the number of tuples in the data file to be 10 million in all our experiments. Our experiments were performed on a Sun Ultra-2/200 machine with 512 MB of RAM and running Solaris 2.5. Synthetic Datasets: The association rule that we experimented with, has the form U A Cr + C X  X  where U contains 1 uninstantiated attribute (see Section 2) whose domain consists of integers ranging from 1 to 72. Every domain value (that is, point in one-dimensional space) is assigned a randomly generated confidence between 0 and 1 with uniform distribution. Each value is also assigned a randomly generated support between 0 and 2 with uniform distribution; thus, the average support for a value is h. 5.1 Bucketing 
We begin by studying the reduction in input size due to the bucketing optimization. Table 1 illustrates the number of buckets for domain sizes ranging from 500 to 100,000 when minConf is set to 0.5. From the table, it follows that bucketing can result in reductions to input size as high as 65%. 5.2 Scale-up with n 
The graph in Figure 5(a) plots the execution times for our algorithm for computing optimized gain sets as the domain size is increased from 100,000 to 1 million for a minConf value of 0.5. Note that for this experiment, we turned off the bucketing optimization -so the running times would be even smaller if we were to employ bucketing to reduce the input size. The experiments validate our earlier analytical results on the O(M) time complexity of procedure optGainlD. As can be seen from the figure, our optimized gain set algorithm scales linearly with the domain size as well as k. 5.3 Sensitivity to minConf 
Figure 5(b) depicts the running times for our algorithm for a range of confidence values and a domain size of 500,000. From the graphs, it follows that the performance of procedure optGainlD is not affected by values for minconf. 
In this paper, we generalized the optimized gain as-sociation rule problem by permitting rules to con-tain upto k disjunctions over one or two uninstanti-ated numeric attributes. For one attribute, we pre-sented an O(nk) algorithm for computing the opti-mized gain rule, where n is the number of values in the domain of the uninstantiated attribute. We also presented a bucketing optimization that coalesces contiguous values -all of which have confidence ei-ther greater than the minimum specified confidence or less than the minimum confidence. For two attributes, we presented a dynamic programming al-gorithm that computes approximate gain rules -we showed that the approximations are within a constant factor of the optimized rule using recent results on binary space partitioning. For a single numeric attribute, our experimental results demon-strate the effectiveness of our bucketing optimiza-tion and the linear scale-up for our algorithm for computing optimized gain sets. Acknowledgements: We would like to thank 
Narain Gehani, Hank Korth and Avi Silberschatz for their encouragement. Without the support of 
Yesook Shim, it would have been impossible to complete this work. 
