 It is widely known that business processes (BPs) involve different kinds of el-ements, to be named control flow, time, data and resources. However, most commonly used BP models and notations focus on the control flow and the tim-ing of activities in the BP. As a consequence, in most BP models, data (e.g., documents, reports, invoices, emails and the like) play a secondary role, just as inputs or outputs of the activities of the process.

Nevertheless, understanding and analysing how data is modified during the ex-ecution of a BP is getting an increased interest from both industry and academy. For instance, BPMN, the de-facto standard for BP modelling, has incorporated more advanced constructs for data management in its last version [1]. In addi-tion, there is an increasing number of research proposals to analyse the way data is used in a BP to detect anomalies [2,3,4] and to define data-aware compliance rules [5] for BPs. Therefore, providing a mechanism to transform from the usual activity-centered view of a BP to a data-centered view that focuses on the data handled during the proces s is very appealing to this goal of understanding and analysing how data is modified during the execution of a BP.

In this paper we describe a model-driv en procedure based on Petri nets for carrying out this transformation automatically. In particular, the input of the procedure is a BP diagram expressed in BPMN 2.0 (cf. Figure 1). We use this notation because it is the de-facto standard for BP modelling. Such diagrams represent data objects connected to th e BP activities that use them either to read them or write them, or for both things. A data object has a type and can have one or more states along the execution of a process. For instance, in the BP of opening a bank account, the data object application filled by the new customer could go through states sent , accepted and stored . The output of the procedure is a data-centered view composed of the set of object life cycles (OLCs) of all the data objects that are involved in a BP. They represent the allowed transitions between the states of the data object according to the BP diagram. In addition, these transitions also include information about the activities of the BP that are executed in the transition between states of the data object (cf. Figure 2). Furthermore our procedure also deals with some data anomalies that may appear in a BP model (cf. Section 4 for more details).

Our approach has the following advantages: (i) it is fully automated; (ii) it is based on Petri nets, which allows us to use efficient and well-tested Petri net algorithms; (iii) since it includes information about the activities that are executed in each transition, it provides the same full information required to understand BP execution as activity-centered process diagrams; and (iv) it is robust in the sense that it provides an accurate data-centered view despite having a BP with data anomalies as input. Moreover, it informs the user about these data anomalies.

The remaining of the paper is organised as follows. Section 2 introduces a use case used to exemplify the output produced by the procedure. Section 3 contains the description of the whole pr ocedure for OLC generation. In Section 4 the detection and handling of data anomalies is introduced. Section 5 contains a summary of related work and in Section 6 we draw a set of conclusions and outline some future work. To illustrate our approach we use the BP for assigning the venue for the Olympic Games (Figure 1) as use case in this paper 1 . The International Olympic Com-mittee is in charge of this process. This committee first receive s the applications of the cities that want to organize the Olympic Games. Each city is evaluated in order to keep only those which fulfill all the requirements. After this filter is ap-plied, an approval of the final candidates is necessary. Once the list of candidates is ready, a secret voting is carried out. If there is consensus and only one city is selected, then the winner venue is published. Otherwise, the least voted city is eliminated from the list of candidates and a new voting is performed. This is repeated until there are only two cities left. Then, the city with a greatest number of votes wins.

There are two data objects i n this BP model. Data object Candidates repre-sents a document that contains a list of the cities that applied for the venue. The information of each candidate in the document includes the name of the city, its description, what it offers for each r equirement needed, and the mark given by the committee to discern between a ccepted and rejected candidates. This document may be updated during the voting repetitive process. Data object Resolution represents the result of the voting and, thus, is a document with the same list of candidates and the number of votes each of them received. Again, this data object will be updated if more than one voting is performed. If there is no winner yet, the resolution is notified. Otherwise, the resolution is completed with the features of the final venue and published.

The output of the procedure presented in this paper is a set of finite-state machines (FSM) representing the life cycles of the data objects modelled in a BP. Figure 2 depicts the life cycle of data object Resolution of our use case. The life cycles of a data object have one start state (represented with a filled circle), one final state (represented with a semi-filled circle), and one or more intermediate states (represented with a rectangle) that correspond with states of the data object in the BP model. Transitio ns (represented with directed arrows) connect two states and contain the parts of the BP that are executed in the transition between states of the data object. BP2OLC is our approach to automatically generate the OLCs of the data ob-jects represented in a BPMN model 2 . As depicted in Figure 3, it is a three-step procedure based on model transformations which involves four different models. The procedure must be carried out for each data object type present in the BP model. We assume the source BP model has the following features: 1. As far as control flow is concerned, the BP model is sound, which basically 2. There is only one copy of each data ob ject in each instance of the process, 3. Each data object has always a state. In case an appearance of a data object 4. The BP model can contain data object s connected to any kind of activity Assumption 1 is made because control-flow soundness is out of the scope of this paper. Assumptions 2 and 3 are reasonable and have also been made elsewhere [2]. The last assumption is related to the reach of the current approach. 3.1 Step 1. From BPMN Model to Petri Net We believe that providing a semantic mapping [7] between a BPMN model and a target domain such as Petri nets, whose semantics has been formally defined, is a good approach because it allows one to use the techniques specific to the target semantic domain for analysing the source models. We chose Petri nets for two reasons: (i) plenty of processing algorithms on Petri nets have already been developed and can be useful for our purpose [6,8]; and (ii) the transformation of the control flow of a BP model into an equivalent Petri net has already been described in [6].
 Definition 1. A Petri net is a 3-tuple PN =( T PN ,P,F ) ,where:  X  T PN = { t 1 ,t 2 , ..., t n } is the set of transitions of the Petri net, represented  X  P = { p 1 ,p 2 , ..., p n } is the set of places of the Petri net, represented graphi- X  F  X  ( P  X  T PN ) ( T PN  X  P ) is the set of arcs of the Petri net (flow relation), A marking (state) or markup assigns a nonnegative integer to each place of a Petri net. If it assigns to place p a nonnegative integer k ,wesaythat p is marked with k tokens. Pictorially, we place k black dots (tokens) in place p .Amarkup is denoted by M , an m-vector, where m is the total number of places. The pth component of M , denoted by M(p) , is the number of tokens in place p . The firing of an enabled transition will change the token distribution (marking) in a net [8].
We use the set of rules introduced by Awad et al. [2] to do the semantic mapping between elements of a BP model with data objects and elements of aPetrinet.Let E BP be the set of flow nodes of a BP (model), i.e. activities, gateways and events, D BP the set of states of a data object of that BP, and WRITERS BP  X  E BP be the set of activities of the BP that write that data object. The result of the semantic mapping is a Petri net with the following characteristics:  X  The places of the Petri net are of two different kinds: control places P C and  X  The transitions of the Petri net represent flow nodes of the business process An example of the transformation rules is depicted in Table 1, which illustrates an extension of the catalogue of transformations proposed in [2] to deal with loop activities. As stated in [1], a loop activity executes the inner activity as long as a loop condition evaluates to true. An attribute can be set to specify a maximal number of iterations. An example of loop activity is an activity Update order that updates an order in a restaurant (by customer X  X  command) until an event or a received message indicates n o more updates are allowed. For more details about the other transformations we refer the reader to [2].
Finally, note that there is a small difference between this mapping and the one presented in [2] because in this paper we consider no data objects are supposed to exist before the execution of a BP i n our BP2OLC proce dure, whereas [2] considers data objects have an initial state when instantiating a BP. This differ-ence causes the transformation in [2] referring to the writing of the data object has to be slightly changed for the first writing of the object in our BP2OLC procedure, in order to comply with our assumption 2. It means the first time the data object is written, the responsible transition of the Petri net does not have any input data places. 3.2 Step 2. Reachability Graph from Petri Net Definition 2. A reachability graph related to a Petri net is a 3-tuple RG PN = ( N, M, T RG ) ,where:  X  M : P  X  N  X  N represents the markup of the net.  X  T RG  X  ( N  X  N ) are the transitions of the reachability graph.
 The reachability graph is obtained by analysing the Petri net by means of well-known algorithms. Each node of the reachability graph represents a reachable marking state of the net and each arc a possible change of state, i.e. the firing of a transition. However, due to the charact eristics of our semantic mapping between BPMN and Petri net, in the reachability graph resulting from such Petri nets it holds that M ( p, n )  X  [0 , 1] ,  X  n  X  N,  X  p  X  P . In addition, the information about the markup of the net contained in every node always corresponds with both a sequence flow of the BP model and a state of the data object, as illustrated in Figure 4. It means there is always one token in a control place of the Petri net and one in a data place, except in the beginning (until an activity writes the data object for the first time) and in the final nodes of the reachability graph (in which, on the contrary, all the tokens in control places have been consumed).
Given the previous definitions, the following functions can be defined:  X  Function map : T RG  X  T PN is defined to map the transitions of a reacha- X  Function state : N  X  P D returns the state of the data object of the busi- X  Function flow : P ( N )  X  X  ( P C ) returns the set of sequence flow elements  X  Function activity : N  X  E BP returns the flow node of the business process The node of the reachability graph with no input arrows is called firstNode  X  N :  X  X  firstNode and it is the start node of a reachability graph. The nodes of the reachability graph with no output arrows, whose input is called END andwithnotokensinacontrolplaceare normal final nodes of the reachability graph. We will describe abnormal final nodes in Section 3.3. 3.3 Step 3. Object Life Cycle from Reachability Graph Definition 3. An object life cycle of a data object of a business process is a 2-tuple OLC =( S OLC ,T OLC ) ,where:  X  S OLC = { s 1 ,s 2 , ..., s n } is the set of states in which the data object can be.  X  T OLC  X  S OLC  X  S OLC  X P ( N ) is the set of transitions that appear in the We have defined Algorithms 1 and 2 to obtain an OLC from a reachability graph. Algorithm 1 receives the reachability graph resulting from the previous step and the list of activities of the BP that write the data object. Its out-put is the OLC together with a set of data anomalies found while creating it. Algorithm 1. Algorithm to initialize an object life cycle, call Algorithm 2 from a Its behaviour consists of calling Algorithm 2 with the appropriate parameters and post-processing the resulting reachability graph. Algorithm 2 is a recursive algorithm that builds an OLC by processing a reachability graph node by node from its start node. Its input set and steps are described below.

Input of Algorithm 2.
Check for and add new transitions (lines 3-7). A new transition of one of Algorithm 2. Algorithm to generate the life cycle of a data object from a reachability
Update variable PATH (line 8). New nodes will be added to the path in Revise the last activity executed and act consistently (lines 9-31).
Post-process the necessary nodes (lines 6-17 of Algorithm 1). Some As aforementioned in this paper, we assume soundness (also called correctness) in the control flow of BPs, but the process can be unsound regarding data perspective. The data-related deadlocks that appear in a reachability graph (i.e. abnormal final nodes) indicate data-related anomalous situations (known as data anomalies ) in the represented BP model. All these data anomalies cause dead-locks in the Petri net, so the OLC gener ated is not complete. For example, in Figure 7 only the states and transitions outlined with black solid lines are gen-erated when processing the actual reachability graph that represents the BP model in Figure 6 5 . States such as s0 and s5 are not detected without man-aging some data anomalies present in the BP model previously. There are two different groups of anomalous situations, which can be mapped into data-related problems defined in [2,3]. The resolution of the data anomalies in the BP is out of the scope of this paper. We explain how to modify the Petri net to solve the deadlocks and be able to simulate the whole execution of the BP modelled, with the aim of generating all the states and transitions there represented.
Too restrictive preconditions (TRP). This kind of problems appear when
Unreachable states (US). In this case, the state specified for the input There may be other alternatives for dealing with data anomalies, but their study is out of the scope of this paper. To apply the solutions described above, the Petri net has to be  X  X e-constructed X  in order to obtain a new reachability graph and then process it. For too restrictive preconditions, this re-construction has 4 steps. The resulting Petri net is kept while processing the rest of warnings. 1. Find the transition at which the deadlock takes place. 2. Identify the data place that is input of the blocked transition. 3. Identify the data place at which there is a token. 4. As we now know the transition that could not be triggered (step 1) and the Unreachable states are reflected in a Petri net in the form of unfired transitions. To detect them and fix them, we have to find the transitions that were never triggered and set the markup of the net with a token in each of their input places. Then a new reachability graph with this configuration is obtained and we can examine the rest of the net from that point by processing it.
In order to warn the modeller/analyst about the presence of data anomalies in the BP model, new elements emerged from dealing with them are marked in a different way in the OLC. In Figure 7, transitions and states generated from too restrictive preconditions are shown with dashed red lines, and those corresponding to unreachable states have dotted blue lines. The importance of complementing the act ivity-centered view of BP models with an object-oriented view has been describe d by Snoeck et al. [9]. We are generating such a view from the data objects that appear in a BP model.

The work most related to our approach is the one of Ryndina et al. In [10] they present an ad-hoc approach for the automatic generation of OLCs from a BP model and propose some techniques to analyse the consistency of BPs and OLCs on the basis of the concepts of conformance and coverage between OLCs. Their procedure is based on transformation rules that are applied directly to a BP model. However, no data anomalies a re described nor detected in their approach. Besides, our use of well-known Petri nets algorithms makes it more unlikely to introduce errors while implementing the procedure. In [11] the oppo-site procedure is introduced, i.e. an approach for generating a BP model from OLCs of different data objects is described.
 Data anomalies in BP models have been addressed by several researchers. Sadiq et al. [3] explain the importance of managing the data requirements in BPs and introduce some ideas related to the modelling and validation of data, such as the importance of considering the type of data and their structure. They also state some data anomalies that may appear in a BP model, which in turn are referenced by the authors in [4]. In that work, Sun et al. divide the same problems into three main groups with one or more scenarios, and then they explain the matching of every scenario with the data anomalies in [3]. Awad et al. describe three kinds of data anomalies that can also be mapped to anomalies defined in the previously mentioned work [2]. They have developed an approach for diagnosing and automatically repairing these three kinds of problems on the basis of Petri nets. A prototype has been implemented in Oryx [12]. Besides, they propose some validation algorithms targeted at fixing these data anomalies, which are being implemented to correct BPMN mode ls. In our BP2OLC procedure, we use the transformations described in that work to carry out step 1 of the BP2OLC procedure. However, the mentioned wo rk on data anomalies does not consider the generation of OLCs from a BP model.

Finally, Sakr et al. have developed a framework for querying both control flow and data flow perspectives of BPs [13]. Data perspective can be queried from OLCs. However, no automatic generation of OLCs is included and the framework is not targeted at the detection and management of data anomalies. In this paper we introduce a model-driven approach for the automatic generation of a data-centered view of a BP composed of the life cycles of the data objects the BP model has. It consists of mapping a BPMN model into a target semantic domain, Petri nets, which allows us to use techniques specific to that domain, in particular obtaining its reachability graph, for analysing the source model. Then, the reachability graph is mapped into an OLC model. An advantage of our procedure is that the resulting OLCs include information about the activ-ities that are executed in each transition and, hence, it provides the same full information required to understand BP execution as activity-centered process diagrams.

Besides, our procedure is robust in the sense that it provides an accurate result despite having a BP with data anomalies as input. Furthermore, we detail how this procedure can be used to detect two kinds of data anomalies present in a BP model. For each group of data anomalies identified, the following questions have been answered: (i) what does the ano maloussituationmeanintermsofthe BP model and the resulting OLC?; (ii) how can it be detected in the reachability graph?; and (iii) how can the Petri net be re-constructed to fix the deadlock?
A prototype of the BP2OLC procedure has been implemented reusing the code of ProM 6 , an open-source platform for process mining that counts on a number of plugins and components to work with Petri nets. The developed prototype corresponds to steps 2 and 3 of the BP2OLC procedure and also contains the detection and handling of the data anoma lies described above. It receives a Petri net in format PNML 1.3.2. as input and returns the life cycle of the data object represented in that net. The software is available upon request.

As future work, we plan to extend the ki nds of BP structures considered, to take data objects from repositories into account, and to study alternatives to manage and repair the detected data anomalies in the source BP model.
