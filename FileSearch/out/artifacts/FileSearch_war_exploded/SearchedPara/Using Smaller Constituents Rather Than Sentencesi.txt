 Reducing annotation cost is very important be-cause supervised learning approaches, which have been successful in natural language processing, re-quire typically a large number of labeled exam-ples. Preparing many labeled examples is time consuming and labor intensive.

One of most promising approaches to this is-sue is active learning. Recently much attention has been paid to it in the field of natural language pro-cessing. Various tasks have been targeted in the research on active learning. They include word sense disambiguation, e.g., (Zhu and Hovy, 2007), POS tagging (Ringger et al., 2007), named entity recognition (Laws and Sch  X  utze, 2008), word seg-mentation, e.g., (Sassano, 2002), and parsing, e.g., (Tang et al., 2002; Hwa, 2004).

It is the main purpose of this study to propose methods of improving active learning for parsing by using a smaller constituent than a sentence as a unit that is selected at each iteration of active learning. Typically in active learning for parsing a sentence has been considered to be a basic unit for selection. Small constituents such as chunks have not been used in sample selection for parsing. We use Japanese dependency parsing as a target task in this study since a simple and efficient algorithm of parsing is proposed and, to our knowledge, ac-tive learning for Japanese dependency parsing has never been studied.

The remainder of the paper is organized as fol-lows. Section 2 describes the basic framework of active learning which is employed in this research. Section 3 describes the syntactic characteristics of Japanese and the parsing algorithm that we use. Section 4 briefly reviews previous work on active learning for parsing and discusses several research challenges. In Section 5 we describe our proposed methods and others of active learning for Japanese dependency parsing. Section 6 describes experi-mental evaluation and discussion. Finally, in Sec-tion 7 we conclude this paper and point out some future directions. 2.1 Pool-based Active Learning Our base framework of active learning is based on the algorithm of (Lewis and Gale, 1994), which is called pool-based active learning . Following their sequential sampling algorithm, we show in Fig-ure 1 the basic flow of pool-based active learning. Various methods for selecting informative exam-ples can be combined with this framework. 2.2 Selection Algorithm for Large Margin One of the most accurate approaches to classifica-tion tasks is an approach with large margin classi-fiers. Suppose that we are given data points { x such that the associated label y or 1 , and we have a hyperplane of some large mar-gin classifier defined by { x : f ( x ) = 0 } where the 1. Build an initial classifier from an initial la-2. While resources for labeling examples are Figure 1: Flow of the pool-based active learning ID 0 1 2 3 4 Head 4 4 3 4 -Figure 2: Sample sentence. An English translation is  X  X isa gave that pen to him. X  classification function is G ( x ) = sign { f ( x ) } . In pool-based active learning with large margin clas-sifiers, selection of examples can be done as fol-lows: 1. Compute f ( x 2. Sort x 3. Select top m examples.
 This type of selection methods with SVMs is dis-cussed in (Tong and Koller, 2000; Schohn and Cohn, 2000). They obtain excellent results on text classification. These selection methods are simple but very effective. 3.1 Syntactic Units A basic syntactic unit used in Japanese parsing is a bunsetsu , the concept of which was initially in-troduced by Hashimoto (1934). We assume that in Japanese we have a sequence of bunsetsu s be-fore parsing a sentence. A bunsetsu contains one or more content words and zero or more function words.

A sample sentence in Japanese is shown in Fig-ure 2. This sentence consists of five bunsetsus: Lisa-ga, kare-ni, ano, pen-wo, and age-ta where ga, ni, and wo are postpositions and ta is a verb ending for past tense. 3.2 Constraints of Japanese Dependency Japanese is a head final language and in written Japanese we usually hypothesize the following:  X  Each bunsetsu has only one head except the  X  Dependency links between bunsetsus go  X  Dependencies do not cross one another.
 We can see that these constraints are satisfied in the sample sentence in Figure 2. In this paper we also assume that the above constraints hold true when we discuss algorithms of Japanese parsing and active learning for it. 3.3 Algorithm of Japanese Dependency We use Sassano X  X  algorithm (Sassano, 2004) for Japanese dependency parsing. The reason for this more, it is easy to implement. His algorithm is one of the simplest form of shift-reduce parsers final language and its dependencies are projective as described in Section 3.2, that simplification can be made.

The basic flow of Sassano X  X  algorithm is shown in Figure 3, which is slightly simplified from the original by Sassano (2004). When we use this al-gorithm with a machine learning-based classifier, function Dep() in Figure 3 uses the classifier to decide whether two bunsetsus have a dependency relation. In order to prepare training examples for the trainable classifier used with his algorithm, we first have to convert a treebank to suitable labeled instances by using the algorithm in Figure 4. Note Input: w Output: h Functions: Push( i , s ): pushes i on the stack s . procedure Analyze( w , N , h ) var s : a stack for IDs of modifier bunsetsus begin end Figure 3: Algorithm of Japanese dependency pars-ing that the algorithm in Figure 4 does not generate Most of the methods of active learning for parsing in previous work use selection of sentences that seem to contribute to the improvement of accuracy (Tang et al., 2002; Hwa, 2004; Baldridge and Os-borne, 2004). Although Hwa suggests that sample selection for parsing would be improved by select-ing finer grained constituents rather than sentences (Hwa, 2004), such methods have not been investi-gated so far.

Typical methods of selecting sentences are Input: h Function: Dep( j , i , w , h ): returns true if h procedure Generate( w , N , h ) begin end Figure 4: Algorithm of generating training exam-ples based on some entropy-based measure of a given sentence (e.g., (Tang et al., 2002)). We cannot use this kind of measures when we want to select other smaller constituents than sentences. Other bigger problem is an algorithm of parsing itself. If we sample smaller units rather than sentences, we have partially annotated sentences and have to use a parsing algorithm that can be trained from incompletely annotated sentences. Therefore, it is difficult to use some of probabilistic models for In this section we describe sample selection meth-ods which we investigated. 5.1 Sentence-wise Sample Selection Passive Selection (Passive) This method is to select sequentially sentences that appear in the training corpus. Since it gets harder for the read-ers to reproduce the same experimental setting, we avoid to use random sampling in this paper.
 Minimum Margin Selection (Min) This method is to select sentences that contain bun-setsu pairs which have smaller margin values of outputs of the classifier used in parsing. The procedure of selection of M IN are summarized as follows. Assume that we have sentences s pool of unlabeled sentences. 1. Parse s 2. Sort s 3. Select top m sentences.
 Averaged Margin Selection (Avg) This method is to select sentences that have smaller values of averaged margin values of outputs of the classi-fier in a give sentences over the number of deci-sions which are carried out in parsing. The differ-ence between A VG and M IN is that for A VG we use Dep() in Figure 3 for the sentence s min | f ( x k ) | for M IN . 5.2 Chunk-wise Sample Selection In chunk-wise sample selection, we select bun-setsu pairs rather than sentences. Bunsetsu pairs are selected from different sentences in a pool. This means that structures of sentences in the pool are partially annotated.

Note that we do not use every bunsetsu pair in a sentence. When we use Sassano X  X  algorithm, we have to generate training examples for the classi-fier by using the algorithm in Figure 4. In other words, we should not sample bunsetsu pairs inde-pendently from a given sentence.

Therefore, we select bunsetsu pairs that have smaller margin values of outputs given by the clas-sifier during the parsing process. All the sentences in the pool are processed by the current parser. We cannot simply split the sentences in the pool into labeled and unlabeled ones because we do not se-lect every bunsetsu pair in a given sentence. Naive Selection (Naive) This method is to select bunsetsu pairs that have smaller margin values of outputs of the classifier. Then it is assumed that annotators would label either  X  X  X  for the two bun-setsu having a dependency relation or  X  X  X , which represents the two does not.
 Modified Simple Selection (ModSimple) Al-though N AIVE seems to work well, it did not (dis-cussed later). M OD S IMPLE is to select bunsetsu pairs that have smaller margin values of outputs of the classifier, which is the same as in N AIVE . The difference between M OD S IMPLE and N AIVE is the way annotators label examples. Assume that we have an annotator and the learner selects some bunsetsu pair of the j -th bunsetsu and the i -th bun-setsu such that j &lt; i . The annotator is then asked what the head of the j -th bunsetsu is. We define here the head bunsetsu is the k -th one.

We differently generate labeled examples from the information annotators give according to the relation among bunsetsus j , i , and k .

Below we use the notation { s, t,  X  X  X  } to de-note that the s -th bunsetsu modifies the t -th one. The use of  X  X  X  instead of  X  X  X  indicates that the s -th does not modify the t -th. That is generating { s, t,  X  X  X  } means outputting an example with the label  X  X  X .
 Case 1 if j &lt; i &lt; k , then generate { j, i,  X  X  X  } and Case 2 if j &lt; i = k , then generate { j, k,  X  X  X  } . Case 3 if j &lt; k &lt; i , then generate { j, k,  X  X  X  } . Syntactically Extended Selection (Syn) This selection method is one based on M OD S IMPLE and extended to generate more labeled examples for the classifier. You may notice that more labeled examples for the classifier can be generated from a single label which the annotator gives. Syntac-tic constraints of the Japanese language allow us to extend labeled examples.

For example, suppose that we have four bunset-sus A, B, C, and D in this order. If A depends on C, i.e., the head of A is C, then it is automati-cally derived that B also should depend on C be-cause the Japanese language has the no-crossing constraint for dependencies (Section 3.2). By uti-lizing this property we can obtain more labeled ex-amples from a single labeled one annotators give. In the example above, we obtain { A, B,  X  X  X  } and {
B, C,  X  X  X  } from { A, C,  X  X  X  } . Although we can employ various extensions to M
OD S IMPLE , we use a rather simple extension in this research.
 Case 1 if ( j &lt; i &lt; k ), then generate Case 2 if ( j &lt; i = k ) , then generate Case 3 if ( j &lt; k &lt; i ) , then generate
In S YN as well as M OD S IMPLE , we generate examples with  X  X  X  only for bunsetsu pairs that oc-cur to the left of the correct head (i.e., case 1). 6.1 Corpus In our experiments we used the Kyoto University Corpus Version 2 (Kurohashi and Nagao, 1998). Initial seed sentences and a pool of unlabeled sen-tences for training are taken from the articles on January 1st through 8th (7,958 sentences) and the test data is a set of sentences in the articles on Jan-uary 9th (1,246 sentences). The articles on Jan-uary 10th were used for development. The split of these articles for training/test/development is the same as in (Uchimoto et al., 1999). 6.2 Averaged Perceptron We used the averaged perceptron (AP) (Freund and Schapire, 1999) with polynomial kernels. We set the degree of the kernels to 3 since cubic ker-nels with SVM have proved effective for Japanese dependency parsing (Kudo and Matsumoto, 2000; Kudo and Matsumoto, 2002). We found the best value of the epoch T of the averaged perceptron by using the development set. We fixed T = 12 through all experiments for simplicity. 6.3 Features There are features that have been commonly used for Japanese dependency parsing among related papers, e.g., (Kudo and Matsumoto, 2002; Sas-sano, 2004; Iwatate et al., 2008). We also used the same features here. They are divided into three groups: modifier bunsetsu features, head bunsetsu features, and gap features. A summary of the fea-tures is described in Table 1. 6.4 Implementation We implemented a parser and a tool for the av-eraged perceptron in C++ and used them for ex-periments. We wrote the main program of active learning and some additional scripts in Perl and sh. 6.5 Settings of Active Learning For initial seed sentences, first 500 sentences are taken from the articles on January 1st. In ex-periments about sentence wise selection, 500 sen-tences are selected at each iteration of active learn-In experiments about chunk wise selection 4000 pairs of bunsetsus, which are roughly equal to the averaged number of bunsetsus in 500 sentences, are selected at each iteration of active learning. 6.6 Dependency Accuracy We use dependency accuracy as a performance measure of a parser. The dependency accuracy is the percentage of correct dependencies. This mea-sure is commonly used for the Kyoto University Corpus. 6.7 Results and Discussion Learning Curves First we compare methods for sentence wise selection. Figure 5 shows that M IN is the best among them, while A VG is not good and similar to P ASSIVE . It is observed that active learning with large margin classifiers also works well for Sassano X  X  algorithm of Japanese depen-dency parsing.

Next we compare chunk-wise selection with sentence-wise one. The comparison is shown in Figure 6. Note that we must carefully consider how to count labeled examples. In sentence wise selection we obviously count the number of sen-tences. However, it is impossible to count such number when we label bunsetsus pairs.

Therefore, we use the number of bunsetsus that have an annotated head. Although we know this may not be a completely fair comparison, we be-lieve our choice in this experiment is reasonable form, and surface form. for assessing the effect of reduction by chunk-wise selection.

In Figure 6 N AIVE has a better learning curve compared to M IN at the early stage of learning. However, the curve of N AIVE declines at the later stage and gets worse than P ASSIVE and M IN .
Why does this phenomenon occur? It is because each bunsetsu pair is not independent and pairs in the same sentence are related to each other. They satisfy the constraints discussed in Section 3.2. Furthermore, the algorithm we use, i.e., Sassano X  X , assumes these constraints and has the specific or-der for processing bunsetsu pairs as we see in Fig-ure 3. Let us consider the meaning of { j, i,  X  X  X  } if the head of the j -th bunsetsu is the k -th one such that j &lt; k &lt; i . In the context of the algorithm in Figure 3, { j, i,  X  X  X  } actually means that the j -th bunsetsu modifies th l -th one such that i &lt; l . That is  X  X  X  does not simply mean that two bunsetsus does not have a dependency relation. Therefore, we should not generate { j, i,  X  X  X  } in the case of j &lt; k &lt; i . Such labeled instances are not needed and the algorithm in Figure 4 does not generate them even if a fully annotated sentence is given. Based on the analysis above, we modified N AIVE and defined M OD S IMPLE , where unnecessary la-beled examples are not generated.

Now let us compare N AIVE with M OD S IMPLE (Figure 7). M OD S IMPLE is almost always better than P ASSIVE and does not cause a significant de-terioration of accuracy unlike N AIVE . 6
Comparison of M OD S IMPLE and S YN is shown in Figure 8. Both exhibit a similar curve. Figure 9 shows the same comparison in terms of required queries to human annotators. It shows that S YN is better than M OD S IMPLE especially at the earlier stage of active learning.
 Reduction of Annotations Next we examined the number of labeled bunsetsus to be required in Figure 5: Learning curves of methods for sentence wise selection Figure 6: Learning curves of M IN (sentence-wise) and N AIVE (chunk-wise). Figure 7: Learning curves of N AIVE , M OD S IM -PLE and P ASSIVE in terms of the number of bun-setsus that have a head. Figure 8: Learning curves of M OD S IMPLE and S
YN in terms of the number of bunsetsus which have a head. Figure 9: Comparison of M OD S IMPLE and S YN in terms of the number of queries to human anno-tators Figure 10: Number of labeled bunsetsus to be re-quired to achieve an accuracy of over 88.3%. Figure 11: Changes of number of support vectors in sentence-wise active learning Figure 12: Changes of number of support vectors in chunk-wise active learning (M OD S IMPLE ) order to achieve a certain level of accuracy. Fig-ure 10 shows that the number of labeled bunsetsus to achieve an accuracy of over 88.3% depending on the active learning methods discussed in this research.

P ASSIVE needs 37766 labeled bunsetsus which have a head to achieve an accuracy of 88.48%, while S YN needs 13021 labeled bunsetsus to achieve an accuracy of 88.56%. S YN requires only 34.4% of the labeled bunsetsu pairs that P ASSIVE requires.
 Stopping Criteria It is known that increment rate of the number of support vectors in SVM in-dicates saturation of accuracy improvement dur-ing iterations of active learning (Schohn and Cohn, 2000). It is interesting to examine whether the observation for SVM is also useful for support changes of the number of support vectors in the cases of both P ASSIVE and M IN in Figure 11 and changes of the number of support vectors in the case of M OD S IMPLE in Figure 12. We observed that the increment rate of support vectors mildly gets smaller. However, it is not so clear as in the case of text classification in (Schohn and Cohn, 2000).
 Issues on Accessing the Total Cost of Annota-tion In this paper, we assume that each annota-tion cost for dependency relations is constant. It In addition, we have to note that it may be easier to annotate a whole sentence than some bunsetsu will be better to show a whole sentence to anno-tators even when annotating some part of the sen-tence.

Nevertheless, it is noteworthy that our research shows the minimum number of annotations in preparing training examples for Japanese depen-dency parsing. The methods we have proposed must be helpful when checking repeatedly anno-tations that are important and might be wrong or difficult to label while building an annotated cor-pus. They also will be useful for domain adapta-Applicability to Other Languages and Other Parsing Algorithms We discuss here whether or not the proposed methods and the experiments are useful for other languages and other parsing algorithms. First we take languages similar to Japanese in terms of syntax, i.e., Korean and Mon-golian. These two languages are basically head-final languages and have similar constraints in Section 3.2. Although no one has reported appli-cation of (Sassano, 2004) to the languages so far, we believe that similar parsing algorithms will be applicable to them and the discussion in this study would be useful.

On the other hand, the algorithm of (Sassano, 2004) cannot be applied to head-initial languages such as English. If target languages are assumed to be projective, the algorithm of (Nivre, 2003) can be used. It is highly likely that we will invent the effective use of finer-grained constituents, e.g., head-modifier pairs, rather than sentences in active learning for Nivre X  X  algorithm with large margin classifiers since Sassano X  X  seems to be a simplified version of Nivre X  X  and they have several properties in common. However, syntactic constraints in Eu-ropean languages like English may be less helpful than those in Japanese because their dependency links do not have a single direction.

Even though the use of syntactic constraints is limited, smaller constituents will still be useful for other parsing algorithms that use some determin-istic methods with machine learning-based classi-fiers. There are many algorithms that have such a framework, which include (Yamada and Mat-sumoto, 2003) for English and (Kudo and Mat-sumoto, 2002; Iwatate et al., 2008) for Japanese. Therefore, effective use of smaller constituents in active learning would not be limited to the specific algorithm. We have investigated that active learning methods for Japanese dependency parsing. It is observed that active learning of parsing with the averaged perceptron, which is one of the large margin clas-sifiers, works also well for Japanese dependency analysis.
In addition, as far as we know, we are the first to propose the active learning methods of using partial dependency relations in a given sentence for parsing and we have evaluated the effective-ness of our methods. Furthermore, we have tried to obtain more labeled examples from precious la-beled ones that annotators give by utilizing syntac-tic constraints of the Japanese language. It is note-worthy that linguistic constraints have been shown useful for reducing annotations in active learning for NLP.

Experimental results show that our proposed methods have improved considerably the learning curve of Japanese dependency parsing.

We are currently building a new annotated cor-pus with an annotation tool. We have a plan to in-corporate our proposed methods to the annotation tool. We will use it to accelerate building of the large annotated corpus to improved our Japanese parser.

It would be interesting to explore the use of par-tially labeled constituents in a sentence in another language, e.g., English, for active learning. We would like to thank the anonymous review-ers and Tomohide Shibata for their valuable com-ments.

