 Real-time group editing has been envisioned as an effective man-ner of collaboration. For years, operational transformation (OT) has been the standard concurrency control mechanism for real-time group editing, due to its potential for high responsiveness to local editing operations. OT algorithms are generally non-trivial to be error-free and are computation intensive. Recently, commutative replicated data types (CRDT) have appeared as an alternative to OT. The state-of-the-art OT and CRDT work still lacks the basic functionality found in single-user text editors. In particular, there is no published work that supports both string-wise operations and selective undo. This paper presents an approach that combines and extends OT and CRDT strengths. It is fully decentralized and sup-ports string-wise editing operations and selective undo. Our perfor-mance study shows that it provides sufficient responsiveness to the end-users.
 C.2.4 [ Computer-Communication Networks ]: Distributed Sys-tems X  Distributed applications ; H.5.3 [ Information Interfaces and Presentation ]: Group and Organization Interfaces X  Collaborative computing Algorithms, Performance Real-time collaborative editor, commutative replicated data type, operation transformation.
A real-time group editor allows multiple users to simultaneously edit the same document from different places. Fully decentralized, or peer-to-peer, collaboration has generally the advantage of avail-ability, scalability and resistance to censorship and surveillance, over collaboration via a central server.

Operational transformation (OT) has been established as a con-currency control mechanism for real-time group editing due to its potential for high responsiveness to local operations [4, 5, 6, 7, 8, 10, 14, 15, 16, 17, 18, 19, 21]. Local operations are executed immediately at local peers and later transformed and integrated at remote peers. OT algorithms are sophisticated. Counterexamples of several published OT algorithms have been reported. Moreover, they have time complexity in the length of operation history of the document been edited, which potentially grows endlessly.

Recently, a new class of mechanisms called commutative repli-cated data types (CRDT) have been proposed [2, 11, 12, 13, 22, 23]. Concurrent operations of a CRDT are mutually commutative, so that a document is eventually kept consistent at all peers.
A real-time group editor should support at least the most basic functionality found in a single-user text editor. At its minimum, it should support insertion and deletion of single characters and strings of characters, as well as the undo and redo of the insertions and deletions. String-wise operations are important as they are the basis for other useful operations like copy-paste, select-delete and find-replace. Surprisingly, there is currently no published work that supports both string-wise operations and their undo.

Our work supports both string-wise operations and their undo by combining and extending existing OT and CRDT approaches.

The rest of this paper is organized as follows. Section 2 presents background and related work. Section 3 gives an overview of the approach. Section 4 presents the view-model architecture and the data structure of the model. Section 5 describes operations and up-dates in view and model. Section 6 describes how model and view are synchronized. Sections 7 and 8 describe how local and remote operations are integrated into the model. Section 9 shows the cor-rectness of the approach. Section 10 presents performance results. Section 11 discusses some open issues. Section 12 concludes.
OT was first introduced in [4]. The basic idea is as the follow-ing. A shared document is replicated at different peers. An editing operation is first executed at a local peer and then propagated to remote peers. Suppose two peers start with  X 012 X . Peer 1 inserts  X  X  X  between  X 0 X  and  X 1 X  with ins (1,  X  X  X ) and Peer 2 deletes  X 2 X  with del ( 2 ) . The states after local executions at the two peers are  X 0a12 X  and  X 01 X . Now if the two peers execute the remote opera-tions as is, the states at these peers become  X 0a2 X  and  X 0a1 X , which are inconsistent. With OT, the remote operations are transformed to include the executed concurrent operations, into ins (1,  X  X  X ) and del ( 3 ) respectively. The two peers are in consistent state  X 0a1 X  after executing the transformed operations.

There are some challenges with this basic approach. First, a re-mote operation can only be transformed to include a concurrent operation that is compatible, i.e., the two operations operated on exactly the same state. To achieve this, a peer has to first trans-pose the history of operations to make the operations compatible, and then include the effects of compatible operations. The trans-position involves the transformation of both remote operation and operations in the local history. This whole process is sometimes called operation integration. The complexity of operation trans-formation and integration algorithms, or OT algorithms for short, depends on factors like how operations in the operation history are ordered and whether the integration of remote operations has to fol-low some restricted order. OT algorithms have linear or quadratic time complexities in the length of the operation history.
Transformation functions are difficult to be made correct. Coun-terexamples were found for many of the published transformation functions. For instance, [5], [6], [7], [10] and [17] reported coun-terexamples of earlier work. [8], [10], [11], [14], [15], [16], [17] and [21] are among the few that have no counterexample reported. One source of complication is the role of deleted characters, called landmarks in [6] and tombstones in [10]. Given three peers all starting with  X 012 X . Peers 1, 2 and 3 issue concurrent operations ins (2, X  X  X ), del ( 1 ) and ins (1, X  X  X ) respectively. Because  X  X  X  is in-serted to the right of  X 1 X  and  X  X  X  to the left of  X 1 X , the final states at all peers must be  X 0ax2 X . The deleted character  X 1 X  determines the ordering of  X  X  X  and  X   X  X  X . However, because  X 1 X  is deleted at Peer 2, the two inserted characters thus tie at Peer 2. Most counterex-amples are due to failure to break the tie of this type in different combinations of concurrent operations. [20] concludes that this is the only source of puzzles, as far as normal (i.e. not undo) insertion and deletion of single characters are concerned.

Another source of complication is the undo of executed opera-tions. Single-user editors typically support undo of operations in chronological order. In a collaborative editor, operations are not to-tally ordered chronologically due to concurrent operations. It is therefore necessary to support selective undo to undo the effect of any selected operation that has been executed. An undo op-eration undo ( o p ) is heavily dependent not only on the operation o p it undoes, but also on the contexts in which o p and undo ( o p ) are executed. Simply issuing a separate reverse operation o p and transforming it as a normal operation ignore such dependencies and therefore may lead to undesirable results in certain situations, such as in the dOPT puzzle [18]. Some particular solutions are intro-duced to address this issue. For example, in ABTU [15], undo ( o p ) and o p are associated with special attributes and are placed next to each other in the operation history. [21] concludes that operation transformation rules based solely on operation causal relations are no longer sufficient to cope with the complexity of existing OT sys-tems, and introduces a fundamentally different context-based OT framework where the dependency of o p on o p becomes more ex-plicit in terms of operation contexts.

Due to the inherent sophistication of OT, most published work only supports single-character insertions and deletions. GOT [19] and ABTS [14] are the only algorithms accessible in the literature that support string-wise operations. [7] identified a counterexample of GOT. Moreover, GOT seems to be superseded by the follow-up work of the same researchers in [21]. There has been no published work following [21] that supports string-wise operations. In ABTS [14], an operation history is composed of a sub-history of insertions followed with a sub-history of deletions. A string-wise deletion may be split into a set of sub-deletions during subsequent operation transformations.

Supporting selective undo or string-wise operations alone is al-ready challenging. Supporting both can be harder. For example, ABTU [15] and ABTS [14], of the same researchers, use differ-ent (incompatible) operation history structures to support selective undo and string-wise operations. It is not obvious that ABTU and ABTS can be combined to support both selective undo and string-wise operations.

Recently, CRDT has appeared as an alternative to OT for de-centralized real-time group editing. With CRDT, concurrent inser-tions are ordered based on the underlying data structure rather than on operation transformation, so that the time complexity may not depend on the lengths of operation histories. [2, 12, 13, 22, 23] achieve this by making use of specially designed identifiers associ-ated with edited objects (characters, lines of characters) or opera-tions. An identifier contains information about the relative position-ing of objects [2, 12, 13, 22, 23] as well as operation causality [13]. In [2], [12] and [22], the sizes of identifiers can grow unbounded, but experiments show that the sizes stay low even in the most de-manding situations. [11] takes a different approach. There, every character is uniquely identified and is associated with the previous and next characters at the time of its original insertion. This infor-mation is used for the ordering of the characters at remote peers. Experimental results [1] show that CRDT algorithms outperform OT algorithms by a factor between 25 and 1000.

As the CRDT-based approaches are still quite young, only [2] and [24] support string-wise operations and [22] supports undo. There has been no support for undo of string-wise operations.
We can think of the different approaches from a unified perspec-tive. On the one hand, operation histories in OT approaches can be seen as abstract data types and operations that transpose and manipulate the histories exhibit certain properties similar to com-mutativity of CRDTs. On the other hand, CRDTs can be regarded as operation histories extended with explicit relations among oper-ations. Based on this unified perspective, our work combines and extends the strengths of the two approaches. The data structure is basically a list of nodes (of sub-strings) that forms a total order, similar to the operation history in ABTU [15] that arranges opera-tions in a total effects-relation order (as formally defined in [7]). In addition, the data structure materializes dependencies among op-erations. Dependencies among insertions are similar to [11]. To support string-wise operations, additional links connect nodes be-longing to the same operations. Additional information is also pro-vided for undo of operations.

Our earlier work on support for string-wise operations was re-ported in [24]. The initial ideas of this paper was first reported in a short note [25].
A document is collaboratively edited by a number of peers at different sites. Every peer consists of a view, a model, a log of operation history and three queues (Figure 1).

A peer concurrently receives local operations from the user and remote updates from other peers. A view is mainly a string of char-acters. A user at a peer can insert or delete a sub-string at a position in the string, and undo an earlier executed local or remote opera-tion. The user X  X  operations take immediate effect in the view. Lo-cal and remote operations are first stored in queues Q v and Q later be integrated in the model. Integrated local operations are first stored in Q out and later broadcast to other peers. When the model is rendered, the effects of integrated remote operations are shown in the view. Integrated operations are also stored in the log. A user can select an operation in the log to undo.

The model is primarily a double-linked list of nodes. Following [7] and [14, 15], we call the order in which the nodes are linked effects-relation order . A node contains a sub-string, together with some additional meta-data and links for the operations on the string. When operations are integrated into the model, existing nodes are split at operation boundaries, and either new nodes are inserted or existing nodes are marked as deleted or undone. The list thus grows while the document is being edited.

Figure 2 illustrates a model list in different states. When string  X 0123456789 X  is first inserted, the model has only one node. Insert-ing  X  X BCD X  inserts a new node and splits the existing node. Delet-ing a sub-string further splits existing nodes. Concurrent deletions D 1 and D 2 overlap at  X  X  X . When D 1 is undone, only sub-string  X  X 56 X  is brought back in the view.  X  X  X  is still deleted, because D remains in effect. In the figure, characters in gray nodes are invisi-ble in the view. Solid lines between nodes are links maintaining the total effects-relation order among nodes. Dotted lines link nodes belonging to the same insertion. A dot at the bottom of a node in-dicates a deletion. Nodes of the same deletion are linked with the gray lines between the dots. A dot becomes gray when the deletion is undone. Section 4 explains the model in more detail.
A peer has an identifier pid and maintains a number pun (p eer u pdate n umber). pun increments by one for every editing opera-tion originated at the peer. An operation is uniquely identified with ( pid , pun ) at all peers.
 A character string , or simply string , is a sequence of characters. A position in a string, represented as a non-negative integer, is a place either left to the leftmost character, between two adjacent characters, or right to the rightmost character, of the string. For string str , we use str [ pos ] to denote the character right to position pos in str , or nil if pos is the rightmost position of str . Suppose that every character is uniquely identified. We use pos str [ c ] to indicate the position left to character c in str . For two adjacent characters c and c r in a str and c l is left to c r , we have pos str
A view is a character string currently visible to the user. The left-most position of view is always 0. curr view is the current position in view .

A model consists of a set of nodes . A node is originated with an ins operation and we say that a node belongs to its originating ins operation. A node has an interoperable part and a peer-specific part. The element values of the interoperable part of nodes will be preserved at all peers. The interoperable part of a node the following elements:
I 0 : ins ( X 0123456789 X ) 0123456789
I 1 : ins ( X  X BCD X )
D 0 : del ( X  X  X )
D 1 : del ( X  X D56 X )
D 2 : del ( X  X  X ) undo ( D 1 ) undo ( I 1 )
In a peer, a node can be directly referred to via its reference (i.e. a pointer). So the links l , r etc. refer to nodes with their references.
Node references, however, are meaningless across peer bound-aries. Fortunately, a node can be uniquely identified by the id of the ins ( str ) operation that inserted the string str , together with the offset of the node. In Figure 2, suppose the id of ins ( X 0123456789 X ) is I 0 = ( 1 , 1 ) . The node with string  X 56 X  can be uniquely identified are hash-indexed with their id s. Therefore given ( pid , pun , offset ) , a node can be obtained in near-constant time. In the worst case, if a peer cannot find a node with id ( pid , pun , offset ) , it can start from ( pid , pun , 0 ) and follow i r links to find the node containing position offset (and then make a split there). As a convention in this paper, offset is specifically used to identify nodes X  left ends. For positions in view or inside nodes, we use pos instead.

D EFINITION 1. Node  X  l is left to node  X  r (or equally,  X  to  X  l ), written as  X  l  X   X  r or  X  r  X  l , if either (a)  X  l  X  . l =  X  l ), or (b) there exist  X  1 ,  X  2 ,...,  X  n , such that  X  X  X  X   X  n  X   X  r .

In this paper, we use properties to describe invariants on data structures that are maintained by the algorithms. We use  X  -order for the effects-relation order among nodes.
 P ROPERTY 1. The nodes in a model form a total  X  -order.

An insertion consists of the nodes chained with the i l and i For insertion of string str , if  X  is the leftmost node of the insertion,  X  . i l = nil  X   X  . offset = 0; if  X  is the rightmost node of the insertion,  X  . i the rightmost node,  X  . i l 6 = nil  X   X  . i r 6 = nil  X   X   X  . i l . len .

A deletion consists of the nodes containing the del elements of the same del operation. When  X  . dels of a node contains multi-ple del elements,  X  . str has been deleted concurrently by multiple peers.

A del element has the following (sub-)elements:
P ROPERTY 2. Let  X  l and  X  r be nodes and del l and del r elements. (a)  X  -order:  X  l . r =  X  r  X   X  r . l =  X  l . (b) Insertion:  X   X   X  r . i l =  X  l . (c) Deletion: del l . r = del r  X  del
An undo element consists of the following (sub-)elements:
Please notice the different handling of concurrent del s and con-current undo s. Concurrent undo s always refer to the same opera-tion to be undone, and thus are regarded as a single undo , whereas concurrent del s, albeit with overlapping characters, are different operations. Therefore a node maintains a set of del elements (with their own sub-elements), but an undo element only maintains the sub-elements once for a set of concurrent counterparts.

If an undo operation itself is undone, the undo element refers to another undo element. An operation X  X  undo elements are thus chained into a linked list.

D EFINITION 2. An operation is effectively undone if it is un-done an odd number of times. A node (for insertion) or an element (for deletion or undo) of an operation is effectively undone if the length of the undo chain of the node or element is an odd number.
D EFINITION 3. A node  X  is visible , written as  X  . visible, if it is not effectively undone and all del  X   X  . dels are effectively undone.
A node  X  has the following peer-specific elements: P ROPERTY 3.  X  l  X   X  r  X   X  l . pos er &lt;  X  r . pos er . Note that the pos er values of nodes are not globally unique. When a node is inserted between two nodes, any pos er value be-tween the pos er values of the two nodes can be chosen. If there is no new value available, we can simply re-assign the pos er among a set of nodes to make sufficient interval between two adja-cent values. pos er is a simple implementation of a order-maintenance list [3].
 P ROPERTY 4.  X  . rendered  X   X  . visible =  X  . strInView.

A node  X  can be split at pos , where  X  . offset &lt; pos &lt;  X  . len . This results in an updated  X  , denoted here as  X  right-hand node  X  r , such that
P ROPERTY 5. The left and right ends of node  X  , represented with (  X  . pid ,  X  . pun ,  X  . offset ) and (  X  . pid ,  X  be uniquely located in a model, despite subsequent splits.
If node  X  is later split into  X  l and  X  r , (  X  . pid ,  X  . len ) can be located via  X  l . i r . We use  X  X  X   X  and  X  X  X  left and right ends of node  X  .

Since the left ends of all nodes are uniquely located and any char-acter can be uniquely located relative to a node X  X  left end, characters in a model can also be regarded as uniquely located.
 P ROPERTY 6. Ordering of characters. (a) Intra-node: If  X  . strInView and  X  . offset  X  pos l &lt; pos r &lt;  X  . offset + then pos view [  X  . str [ pos l ]] &lt; pos view [  X  . str [ pos For characters c l  X   X  l . str, c r  X   X  r . str, if  X  l . strInView, and  X  l  X   X  r , then pos view [ c l ] &lt; pos view [ c r
Some particular nodes are used for the synchronization between the model and the view. Node curr and position pos curr in curr , de-fine the current position of the model. It corresponds to the current position curr view of the view. render l and render r mark the range of nodes that might need be rendered to synchronize the view with the model.

P ROPERTY 7. Either (a) Empty range: render l = render nil and for all  X  in model,  X  . rendered, or (b) Non-empty range: render l 6 = nil  X  render r 6 = nil  X  render l render r  X  X  render dered  X  X  render r . rendered, and for all  X   X  render l or  X  . rendered.

P ROPERTY 8. Let  X  i ( i = 1 ,..., n ) be all the nodes left to curr and  X  i . strInView, curr view = Finally, a peer maintains a log of operations that can be undone. A log entry has a reference to the leftmost node (for ins ) or element (for del or undo ) of the operation in the model.
A user may execute the following (user-oriented) operations in the view:
After an operation is executed in the view, it is enqueued in the peer X  X  Q v . Consecutive operations in the queue may be merged. For example, a sequence of character operations can be merged into a string operation. These operations are turned into the fol-lowing (model-oriented) operations before they are dequeued for integration in the model.
After a local operation is integrated in the model, a representa-tion of the corresponding update is enqueued in Q out and the left-most node or element of the operation is appended to the log.
An insertion update is represented with the id of the insertion, the inserted string str , and the dependencies de p l and de p newly inserted node, i.e. the place of the insertion.

A deletion update is represented with the id of the deletion and a list of the ends of the nodes whose strings are deleted. We use (  X  of node  X  . The leftmost node of the deletion might be the result of a split during the local integration. offset old and offset offset s before and after the split. offset old = offset new tion happens to start at the left end of a node. A remote peers can quickly find the node before splitting with ( pid , pun , offset make a new split at offset new . The right end of  X  is indicated with  X  . len . For the rightmost node of the deletion, the node remote peer is split if  X  r . len &gt;  X  . len .

An undo update is represented with the id of the undo , the id of the operation it undoes, and for del and undo , also the id of the leftmost node of the operation.
A user edits the document at the view of the local peer. The executed view operations are placed in Q v after some conversion. Meanwhile, the peer may receive in Q in updates from remote peers. From time to time, the model and the view are synchronized.
Procedure synch ( f ullsynch ) while o p  X  Q v . dequeue () do if fullsynch then render ()
Procedure synch synchronizes the view and the model. There are two options: either can a peer synchronize operations in both Q v and Q in , or can it synchronize only operations in Q v
Procedure integrateLocal integrates a local operation. The up-date representations of the integrated operations are enqueued in Q out , which are later broadcast to remote peers. Procedure dequeue -Ready dequeues from Q in a remote update that is ready at this peer (Definition 5). Procedure integrateRemote integrates a remote up-date. Procedure render makes the effects of integrated remote op-erations available in the view. Because all integrated remote oper-ations are rendered after a synchronization, there is no concurrent update in the model when local operations are integrated.
Local undo operations require immediate interaction with the model and need special handling. When a user issues an undo operation, the operation is enqueued to Q v and Procedure synch is executed immediately (either full or local-only). Thus the undo operation is integrated into the model after all previously enqueued local operations. After Procedure render inside synch is done, the effect of the undo is shown in the view.

A peer may decide how often the model and the view are syn-chronized, with the restriction that every local undo operation must involve at least a local-only synchronization. Basically, with more frequent synchronizations, the view is more responsive to remote updates, at the cost of higher run-time overhead, and the user is more frequently distracted by the concurrent remote updates. A peer may also decide how often the updates of the integrated local operations are broadcast to remote peers.
To integrate executed local operations or render integrated up-dates to the view, positions in the model must correspond to the respective positions in the view. This is achieved through the move and goto procedures. Knowing a distance (i.e. number of charac-ters) in the view, move places the current position of the model to the right position of the right node. Knowing a position of a des-tination node  X  , goto finds the corresponding position in the view. Both procedures ensure that Property 8 holds.

Both the move and goto procedures traverse nodes via the l -r links and counts the lengths of the traversed nodes whose strInView values are true . goto compares  X  . pos er with curr . pos which direction to go.
A rendering makes the effects of integrated updates appear in the view. According to Property 7, only nodes between render render r (inclusive) need to be rendered. Suppose that render curr  X  render r and pos curr is at the left end of curr . Procedure renderCurrRightward renders curr and places the current position to the left end of the node just right to curr . To save space and keep readability, we do not enumerate all cases of rendering a node.
Procedure renderCurrRightward () if  X  curr . rendered then if curr . strInView then pos view  X  pos view + curr . len curr  X  curr . r ; pos curr  X  curr . offset curr . visible is calculated according to Definition 3. When curr is involved in many concurrent del s and undo s, calculating curr . visible can be more costly than, say, checking curr . strInView . A node X  X  visibility is only calculated while the node is being rendered.
A model integrates a local ins operation by inserting a new node at an empty interval of the model.

D EFINITION 4. An interval of a model is a pair (  X  X  X   X  l , ends, where  X  l  X   X  r . The interval is empty if  X  l . r =
Because node ends are always uniquely located in a model (Prop-erty 5), intervals are always uniquely located as well.

If pos curr is in the middle of curr , curr is split at pos new node is inserted in between. Otherwise, there might be invis-ible nodes at the place of insertion. If this is the case, a particular order is enforced. For example, all invisible nodes are placed to the right of the new node.

The interval at which the new node is inserted is the insertion dependencies de p l and de p r of the new node. If this node is subse-quently split, all new nodes after splitting have the same insertion dependencies. When a local insertion is integrated, there is no con-current remote operation integrated in the model (this is enforced by Procedure synch ). Therefore, the interval at which the new node is inserted is empty, that is, it is defined by two adjacent nodes.
A model integrates a local del operation by associating del ele-ments to the corresponding nodes whose strings are currently in the view. Nodes at deletion boundaries may be split.

A model integrates a local undo by associating undo elements to the corresponding elements ( node for insertion, del for deletion and undo for undo). The nodes involved in the undo are marked as not rendered, and the render l and render r are updated accordingly. Every local undo involves a synchronization between the model and the view, as described in Section 6.
A peer integrates a remote update only when the update is ready for integration at the peer. Otherwise, the update remains in Q
D EFINITION 5. A remote update is ready for integration at a peer when all its referenced node positions and elements are avail-able in the model of the peer.

More specifically, a remote insertion is ready when the depen-dent node positions are available. A deletion is ready when all node positions encoded in the deletion update are available. An undo is ready when all nodes or elements of the operation it undoes are available. The involved nodes or elements may be split due to concurrent operations. The positions and elements are regarded as available both before and after the split. The ready-for-integration a condition is less strict than  X  X eady X  or  X  X appen-before X  condition in the literature (such as [7, 19]), because only the node positions and elements that the update directly depends on are required to be available.
Concurrent insertions may conflict with one another. It is cru-cial that the integration algorithm enforces the same  X  -order at all peers. The enforcement of the total order is based on the dependen-cies of the insertions.

D EFINITION 6. Let  X   X  be a node of insertion ins  X  . ins dence: there exists a node  X   X  of ins  X  inside (  X  X  X   X   X  is a third insertion ins  X  such that ins  X  insert-depends on ins (  X  X  X   X 
Figure 3 shows an example of concurrent insertions. Figure 4 shows insert dependencies among these insertions at (  X  X  X   X  arrows depict direct insert dependencies. Note that ins (  X  X  X  ) insert-depends on ins (  X  X  X  ) at (  X  X  X   X  a ,  X  X  X   X  h ) but not at (
D EFINITION 7. Two insertions ins  X  and ins  X  are dep-ordered , written as ins  X   X  X  ins  X  if either there exists node  X  such that ins  X  . de p r = such that ins  X  . de p r =  X  X  X   X  l ,  X  l  X   X  r and ins  X  . de p In Figure 4, ins (  X  X b X  )  X  X  ins (  X  X  X  ) .

D EFINITION 8. Two insertions ins  X  and ins  X  conflict at inter-(  X  X  X   X 
In Figure 4, ins (  X  X  X  ) conflicts with ins (  X  X  X  ) at (  X  X  X  does not conflict with ins (  X  X  X  ) because ins (  X  X  X  ) insert-depends on ins (  X  X  X  ) .

D EFINITION 9. Two insertions ins  X  and ins  X  directly conflict at interval (  X  X  X   X  l ,  X  X  X   X  r ) , if they conflict at (  X  X  X  ist a third insertion ins  X  at (  X  X  X   X  l ,  X  X  X   X  r ) such that ins depends on ins  X  .

In Figure 4, ins (  X  X  X  ) conflicts with ins (  X  X  X  ) at (  X  X  X  ever, ins (  X  X  X  ) does not directly conflict with ins (  X  X  X  ) at ( because ins (  X  X  X  ) insert-depends on ins (  X  X  X  ) .
Our algorithm enforces a  X  -order among directly conflicting in-sertions with a policy that is agreed upon at all peers. A commonly used policy is based on the pid s of the originating peers of the in-sertions. For instance, the insertion with smaller pid is placed to the left.

Integrating a remote insertion update is handled in iterations, as illustrated in Figure 5. To insert  X  x at (  X  X  X   X  a ,  X  X  X   X  insertions at (  X  X  X   X  a ,  X  X  X   X  h ) that directly conflict with this is the insertion of  X  f . Since ins ( X  X  X ) has pid 4 and ins ( X  X  X ) has pid 3,  X  x is to be inserted to the left of  X  f .  X  x insertions are then ins (  X  X b X  ) , ins (  X  X  X  ) and ins (  X  X  X  ) .  X  is finally inserted between  X  c and  X  d .

This process is in essence the same as in [11]. Notice that dele-tion and node splitting have no effect with respect to the ordering of the insertions.

Procedure insertRemote (  X  ins ,  X  l ,  X  r )  X   X   X  l . r while  X  6 =  X  r do insertBetween (  X  ins ,  X  . l ,  X  r )
Procedure insertRemote is an improvement to the process just described. It inserts  X  ins between  X  l and  X  r . To integrate a remote insert update  X  ins , we start with  X  ins . de p l as  X  l Thus  X  ins does not insert-depend on any insertion at (  X  X  X  loop walks the node  X  through the nodes between  X  l and  X  does not insert-depend on any insertion at (  X  X  X   X  l ,  X  X  X   X  rectly conflict at (  X  X  X   X  l ,  X  X  X   X  r ) . We enforce the order between  X  according to their pid values and adjust  X  l or  X  r accordingly for the next iteration. We use the pos er values to figure out whether insert-depends on any node at (  X  X  X   X  l ,  X  X  X   X  r ) . If  X  . de p or  X  . de p r . pos er &lt;  X  r . pos er , then  X  insert-depends on a node be-tween  X  l and  X  . (Without the use of pos er , another loop is need for this purpose [11]). If  X  insert-depends on some node between and  X  r ,  X  moves to the next node and the loop goes on for the same iteration.
Integrating a remote del or undo simply associates the corre-sponding del or undo elements in the model data structure.
A node of a deletion is represented as ( pid , pun , offset len ) in an update message. If node ( pid , pun , offset old been split by a concurrent operation at a different position, the in-tegrating peer can use ( pid , pun , offset old ) , offset the correct node.

When the operation that a remote undo undoes has already been undone by a concurrent undo , the corresponding element is already associated with an undo element. In this case, the id of the remote undo is inserted to the ties element of that undo element.
Notice that concurrent deletions of the same sub-string have an accumulative effect (i.e. the overlapping sub-string is deleted mul-tiple times), while concurrent undo s have an idempotent effect. For either of them, integrating concurrent operations in different order results in the same visibility of the corresponding nodes.
We consider two correctness criteria, intention preservation and convergence, as defined in [19].
Intention preservation [19] requires that, for any operation o p , (1) the effects of executing o p at all peers are the same as the inten-tion of o p , and (2) the effect of executing o p does not change the effects (i.e. intentions) of independent operations.

Intention is not formally defined in [19] and is open for different interpretations. This is one of the reasons why correctness of OT algorithms are difficult to be proven formally [7]. A commonly adopted interpretation of intention of an insertion is the effects-relation order introduced by the originating insertion [7, 11].
In our work, the intention of an operation is decided at the view of the originating peer. More specifically, an insertion is between deletion removes a sub-string of characters from the view; undo of an insertion removes the inserted characters from the view; undo of a deletion makes the removed characters re-appear in the view and the positions of the re-appeared characters must preserve the intentions of the corresponding insertions.

First, we verify that integrating an operation preserves its inten-tion.

For insertion, we consider the ordering of nodes. For deletion and undo, we only consider the visibility of nodes, because they do not change the ordering of nodes.

Because splitting a node does not change the ordering among existing nodes or the visibility of nodes, it does not change the intention of any operation.

Integrating a local insertion inserts the new node between the two nodes of the visible characters at the current position. Placing the invisible nodes to the left of the newly inserted node does not change the intention. Integrating a remote insertion also inserts the new node between the two nodes of the same characters. The existence of concurrent insertions does not change the intention.
Integration of a local and remote deletion makes the same set of characters invisible in the view, thus preserving its intention.
Undo of a local or a remote insertion makes the characters of the insertion invisible. Undo of a local or remote deletion, or redo of an insertion, makes the characters that are not deleted by other deletions visible again. The intention of the original insertion is preserved after the undo or redo, because the characters are still in the same order.

Next, we verify that integration of an operation does not change the intentions of other operations.

No procedure switches the order of nodes. Therefore the inten-tion of an insertion will never be changed by the integration of any other operation.

Undoing a deletion brings the deleted characters back in the view only when the insertions of the corresponding characters are not undone and the characters are not deleted by any concurrent over-lapping deletion. Therefore undo of a deletion does not change the intention of the undo of any insertion and any other deletions. This is in contrast with all related work that defines the effect of con-current deletions of the same character as a single deletion. Undo of one deletion thus changes the intentions of all these concurrent deletions. Two concurrent deletions, despite overlaps, are different operations. Undoing one of them should not change the intention of the other.

On the other hand, concurrent undo s of the same operation are considered as a single undo, because they are always defined on the same operation.
Convergence [19] requires that, when the same set of operations have been executed at all peers, all copies of the shared document are the same.

For insertions, it is crucial to show that all peers enforce the same  X  -order among the characters. (Although the key idea of the algo-rithm was published in [11], there has not been a formal proof of its correctness.)
Due to Procedure synch in Section 6, there is no conflicting in-sertions during integration of local insertions. Therefore, we only need to verify that integrating remote insertions ensures a globally unique  X  -order among concurrent insertions.

To see that all peers enforce the same  X  -order among inser-tions, we verify that any peer enforces the same  X  -order as an ideal peer, peer 0 , where all insertions are available. peer grates insertions in iterations. An iteration consists of insertions that insert-depend on insertions of earlier iterations. These inser-tions are separated into groups by the nodes in earlier iterations. In every group, insertions directly conflict with each other between two nodes of earlier iterations. If for node  X  of an insertion, the iteration in which the insertion is integrated at peer  X  section,  X  . de p l or  X  . de p r is used to denote the node containing that node end, when this does not cause confusion from the context.
In Figure 3, assume the insertions in Iteration 0 are { X  X  X ,  X  X  X  X , then the insertions in Iterations 1, 2, 3 are { X  X  X ,  X  X  X  X , { X  X b X ,  X  X  X ,  X  X  X ,  X  X  X ,  X  X  X  X  and { X  X  X  X .

L EMMA 1. The  X  -order of all insertions at the ideal peer is unique.
 P ROOF . We prove with induction.

At iteration 0, all conflicting insertions are directly conflicting with each other. Their  X  -order is decided by the pun s of the origi-nating peers and therefore is unique.

Assume at iteration k the  X  -order of all insertions is unique. At iteration k + 1, we show, in the following two steps, that the  X  -order of all insertions is also unique: (a) Any insertion of iteration k + 1 is uniquely placed among the (b) For all insertions of iteration k + 1 that are to be placed at the
To show (a), we will show that if a node  X  of iteration k + 1 were inserted without the existence of any other node of the same iteration, it would have been placed immediately between nodes and  X  r . Then the insertion of node  X  0 (also of iteration k + 1) prior to  X  would not cause  X  to be placed outside of  X  l and  X  r . We show this with contradiction.

First, we know that either (i)  X  . de p l =  X  l , or (ii) flicts with  X  l during the last iteration of Procedure insertRemote , because otherwise  X   X   X  l . de p l or  X  l . de p r  X   X  and be the immediate left neighbor of  X  as the final result of the proce-dure. Therefore, either (i)  X  l  X   X  or (ii)  X  l . de p l  X   X  . pun &gt;  X  l . pun .

The only possibility that the insertion of  X  0 prior to  X  be placed left to  X  l is  X   X   X  0  X   X  l . This is impossible with case (i) above. Now consider case (ii). Because  X  directly conflicts with  X  . pun &lt;  X  0 . pun . However,  X  0 is placed left to  X  l  X  . de p l or when  X  0 directly conflicts with  X  l and  X  0 . pun &lt; In the former case,  X   X   X  0  X   X  l . de p l contradicts with  X  . In the latter case,  X  . pun &lt;  X  0 . pun &lt;  X  l  X  . pun &gt;  X  l . pun . This proves (a).

The proof of (b) is more straightforward. Because all insertions of iteration k + 1, that are to be placed at the same place among the nodes of iteration k or below, conflict directly with each other. They are uniquely ordered according to their pun values.

T HEOREM 1. When all peers have integrated the same set of insertions, the  X  -order of the integrated insertions are the same at all peers.

P ROOF . Assume that at a peer, a pair of insertions are integrated out of the ideal iteration order. We will show that this peer enforces the same  X  -order as peer 0 . Extending this to any pair of out-of-order insertions, we can conclude that a peer enforces the same  X  -order as peer 0 .

Given nodes  X  1 and  X  2 and  X  2 . itr &gt;  X  1 . itr (Figure 6). Assume and  X  2 may be integrated out of the ideal order. Because integrated after  X  2 ,  X  2 does not insert-depend on  X  1 (Definition 5). We show that integrating  X  2 prior to  X  1 enforces the same  X  -order as integrating  X  2 after  X  1 .

There are only three possible cases: 1. The intervals (  X  1 . de p l ,  X  1 . de p r ) and (  X  2. (  X  1 . de p l ,  X  1 . de p r ) is inside (  X  2 . de p 3. (  X  1 . de p l ,  X  1 . de p r ) contains  X  2 . de p l and/or
In case 1, either  X  1  X  X   X  2 or  X  2  X  X   X  1 (Definition 7), thus integrat-ing  X  1 (and  X  2 respectively) does not involve  X  2 (and  X  tively). Therefore integrating  X  1 after  X  2 results in the same  X  -order as integrating  X  1 before  X  2 . In case 3, Procedure insertRemote in Section 8.1 first resolves  X  -order of  X  1 against  X  2  X  . de p r . If  X  1 is placed outside (  X  2 . de p l ,  X  2 . de p rest of the procedure for integrating  X  1 will never involve
Now consider that  X  1 is inside (  X  2 . de p l ,  X  2 . de p rest of case 3). If  X  1 directly conflicts with  X  2 at (  X  their ordering is decided by their pid values, which is independent of the temporal order of their integration.

If  X  1 does not directly conflict with  X  2 at (  X  2 . de p cording to Definition 9, either  X  1 . de p l or  X  1 . de p (  X  2 . de p l ,  X  2 . de p r ) . Without loss of generality, assume that is inside (  X  2 . de p l ,  X  2 . de p r ) . The ordering between is resolved first (when  X  2 was inserted). If  X  2  X   X  1 . de p  X   X  X   X  1 and integrating  X  1 does not involve  X  2 . If  X  1 then we consider the cases where  X  1 directly conflicts with  X  prior to  X  1 enforces the same ordering as integrating  X  2
Therefore in all three possible cases, integrating  X  2 prior to enforces the same  X  -order as integrating  X  2 after  X  1 .
The convergence of deletions and undo s is straightforward. Be-cause the visibility of nodes is independent on the order of opera-tion integration, when the same set of operations are integrated at all peers, every character will have the same visibility at all peers, regardless of the order in which concurrent deletions and undo s are integrated.
Real-time collaborative editing requires high responsiveness to local user operations, since system responsiveness has clear effects on human performance. For example, [9] showed that at response time of 75ms, user performance becomes unstable, and at 225ms, user performance is degraded substantially. The effects of respon-siveness to remote operations, on the other end, depends on the application and the context of the application. For instance, dis-tributed pair programming is more demanding on responsiveness to remote user operations than collaborative writing of a technical report, particularly when the co-authors focus on different sections of the report.

The response time of local view operations is an important mea-sure of an editor X  X  local responsiveness. Except selective undo, all view operations are executed completely in the view. Their perfor-mance therefore are nearly the same as a single-user editor.
Local view operations are executed only when system resources (CPU, memory etc.) are available. When the system is heavily loaded, the user will experience low responsiveness even though the local view operations take very short time. Therefore respon-siveness is dependent on the overall performance of the editor, in-cluding the more expensive model operations.

In this section, we first discuss time complexity of the algorithms and space overhead of the data structure, and then present experi-mental results.
Table 1 shows the time complexity of the different procedures. m is the distance of a move, i.e. the number of nodes a move traverses. r is the size of the region to be rendered, i.e. the number of nodes in the region. l is the size of an operation, i.e. the number of nodes that the operation involves. k is the number of conflicting insertions. s is the span of an operation, i.e. the number of nodes between the leftmost and rightmost nodes of the operation, including the nodes not belonging to the operation. For example, for a local insertion, s is the number of invisible nodes between two visible nodes at the place of an insertion;
It can be seen that a local undo can be an expensive operation, because the current position must first be moved to the node of the operation and the effect of the undo must then be rendered. For a local-only synch , the span of the undo is the size of the range for rendering. m and s can be considerably larger than l , the size of the operation to be undone.

To render the integrated remote updates, m nodes are first tra-versed to go to the edge of the region for rendering. This is costly when m is large. On the other hand, when m is large, the concur-rent remote updates are far from the document area where the local editing is focused on. In such situation, less frequent full synchro-nization would reduce the overall overhead of the system.
The number of concurrent insertions k is typically small. Al-though in the worst case it may take up to k 2 steps to integrate a remote update, the range (  X  l ,  X  r ) in Procedure insertRemote typi-cally shrinks very quickly.

In related work that do not support string-wise operations, l = 1, but the number of operations are much larger. This implies a larger number of invocations to the corresponding procedures, longer op-eration histories and larger number of network messages. Materializing relations among operations incurs space overhead. The materialized relations contribute not only to the correctness of the algorithms (for example, an undo always refers to the same characters of the operation it undoes), but also to the overall perfor-mance (OT approaches, for example, derive the relations through operation transformation every time the relation is needed). This space overhead, however, may not be larger than that in related work. Notice that the space overhead is shared not only by all the characters of a node, but also by all operations associated with the node. In related work, every single operation of every sin-gle character has its own space overhead for meta-data, either in terms of state vector or operation context in OT approaches, or in terms of character identifiers in CRDT approaches. To accommo-date this overhead, [22] for instance, supports line-wise, rather than character-wise, operations.

To make the analysis more specific, let us assume that for a node, the size of the fixed part ( pid , pun , offset , rendered , de p del elements of size D and a chain of u undo elements of size U . The total size of the node is N = F + d  X  D + u  X  U .

Here we ignore the space taken for the character string, because the same space is taken in all approaches.

Now, consider the corresponding information stored in an oper-ations history in an OT system that only supports character opera-tions. Assume that the size of an operation record in the history is R (a record contains information like state vector or context as well as some other meta data). The information contained in the above-mentioned node includes s single-character insertions, of each char-acter, d deletions and u undoes. The total size of all these operation records is R  X  = s  X  R + s  X  d  X  R + s  X  u  X  R .
 To make the comparison more straightforward, assume that F  X  D  X  U . The difference between the two is N / R  X  = F / ( s  X  R ) . F and R are typically comparable. When s is large, the space overhead of our approach is a small fraction of a character-wise OT approach.
We have implemented the core algorithms in Emacs Lisp, aim-ing at supporting group editing in a widely used open-source editor. Our experiment for performance study is based a trace of opera-tions for editing a program in a week X  X  period. We then re-play the operations in different settings to measure the time of different procedures presented in Sections 6, 7 and 8. The measurement was taken under GNU Emacs 24.3.1 running in 32-bit Linux 3.10.5-ARCH on a 7-year old ThinkPad T61p (2007 model) with 2.2GHz Intel Core2 Duo CPU T7500 and 2GB RAM.

The trace first captures the editing operations in view, as pre-sented in Section 5. The captured view operations are then ag-gregated and converted into model operations. There are different ways of aggregating the view operations. In the experiments, we aggregated the operations as far as possible. That is, consecutive insertions and deletions are aggregated into a single operation, un-til the cursor moves away from the boundary of the current inserted or deleted string. Figure 7 shows the number of model operations and their lengths (numbers of characters) obtained from the trace.
Figure 7: Occurrences of operations with different lengths Figure 8: Time (ms) for model-view synchronization (including Emacs Lisp garbage collection)
In the first experiment, there are two peers. The first peer, the local peer, re-plays the traced operations as local operations. To measure the time for selective undo, after re-played all traced op-erations, the peer undoes all these operations in reverse order. The updates for the integrated operations are then sent to the second peer, the remote peer, which integrates the received remote updates. Let us first look at Figure 8. The y-axis is the time for running Procedure sync at the remote peer. The x-axis is the time at which the procedure is called. Because the experiment only re-plays the traced operations, the x-axis values are of no interest and thus are not shown. For the vast majority of times, Procedure sync takes less than 1 ms. There are however occasions where it takes over 20 ms. It turns out, with closer investigation, that it is the garbage collection of Emacs Lisp that contributes to these long delays. In what follows, we will show the time of different procedures without those extra delays caused by garbage collection of Emacs Lisp.
Figure 9 shows the execution time of integrating the different operations. An overall observation is that the integration time of all operations is almost independent of the length of the operation history.

In general, integrating local operations takes longer time than integrating remote updates. One reason is that the time for integrat-ing a local operation includes the time for encoding the update into its JSON representation, whereas the time for integration a remote update does not include the time for decoding the JSON represen-tation, because the decoding has already been done for the testing of the ready-for-integration condition.
The time for integrating remote insertions seems to be more fluc-tuant than for integrating local insertions. In fact, if we  X  X oom in X  with the same resolution, the time for integrating local insertions is at least as fluctuant. The fluctuation is largely due to the main-tenance of Property 3, that is, to re-assign the pos er values among a set of nodes, when a node is inserted between two nodes, but there is no new pos er value available at the place of insertion. In addition, the numbers of invisible nodes at the places of insertion (i.e. the span s ) also cause the fluctuation of the time for integrating local insertions.

Integrating a local deletion can take much longer time (up to 15 ms) than integrating a remote deletion, because the span s of a deletion could be much larger than its size l (there may be nodes that are already invisible inside the region of the deletion). Notice that the shapes of the plots indicate a strong correlation between the spans and sizes of deletions.

Integrating a local selective undo could be expensive, because it involves at least a partial model-view synchronization. As a signifi-cant part of the synchronization, the current position must go to the place of the undo. On the other hand, integrating a remote selective undo is very fast. The plot for remote undo can even show the tiny difference between the time for undoing insertions and deletions. Figure 10 shows the time related to model-view synchronization. Procedure move is only called at the local peer. Procedures goto and render are called at both peers. At the local peer, they are only called during the integration of undo operations and their time is already shown in Figure 9. Therefore Figure 10 only includes the time for Procedures goto , render and sync at the remote peer. Furthermore, these three plots can be regarded as been composed of two halves: the left half for integrating remote insertions and deletions and the right half for integrating remote undo s.
For the local peer, please notice the similarity of the plot shapes between undo in Figure 9 and move in Figure 10 (flipped mirror-wise, because undo s are run in the reverse order of the insertions and deletions). This indicates that the overhead of integrating local undo s is largely determined by the distances between the current positions and the places of the undo s.

For the remote peer, it is obvious that the distance between the current position and the range to render is the determinant factor of the overhead of render and thus also sync . Particularly with this experiment, there is no local operation at the remote peer at all. The current position stays therefore at one end of the entire document. Consequently, the current position might have to go a long distance to get to the edge of the range for rendering, before a render is actually carried out. There are a few occasions where the sync takes clearly longer time, due to the integration of the remote deletions with very large spans.

To study the overhead of resolving the order of concurrent inser-tions, we did another experiment. Now there are three peers. Each peer re-plays the same trace of operations as in the first experiment. The updates are broadcast to all other peers to be integrated re-motely. To make sure that the insertions conflict and the operations are valid (i.e. with valid positions and lengths), the peers behave as the following. For an insertion, every peer does and integrates a local insertion, receives and integrates the identical updates from the other two peers, and then undoes immediately the last identical insertions except the one originated from the first peer. For a dele-tion, the first peer does the local deletion and the other two peers integrate the remote update. This way of generating conflicting in-sertions is clearly not ideal, because all conflicting insertions follow exactly the same pattern. In fact, it is generally hard to automati-cally generate conflicting insertions of different patterns and with similar complexity as the example in Section 8. We tried to run ex-periments with different combinations of concurrent insertions, but could not find one with significant difference in execution time.
Figure 11 shows the time for integrating remote insertions and for rendering the updates. Most of the time it still takes less than 0.05 ms to integrate a remote insertion. Notice that in this experi-ment the number of updates are many times as in the first experi-ment (every insertion is done three times and undone twice), but we could not observe clear impact of the number of operations (i.e. the
Figure 11: Execution time (ms) with conflicting insertions length of operation history) on the performance of the procedures. It is interesting to notice that the time for rendering the updates in this experiment is actually much shorter than in the first one. The reason is that in this experiment, the current positions in all peers move hand in hand with every insertion. Therefor the overhead of moving the current position to the range for rendering is signifi-cantly reduced. The only few occasions where it takes longer than 0.1 ms to render the updates are due to deletions with large spans.
Overall, we find the experimental results consistent with the the-oretical time complexity presented in Subsection 10.1. The exper-iments indicate that the distances of moving the current positions m and the spans of operations s (in particular, some deletions may have very large spans) are the dominant contributors to the observ-able (in plots, not by end-users) long delays. Local selective undo s are generally expensive because each of them has to involve a (par-tial) model-view synchronization. On the positive side, the sizes of operations l are only secondary to the overall performance. The performance is almost independent of the length of operation his-tory (except that garbage collection of Emacs Lisp may take longer time when there are more data elements in the runtime stack). With very few exceptions (mostly deletions with very large spans), all procedures finish under one millisecond. On the other hand, the garbage collection of Emacs Lisp may take over 20 ms and still hardly any end-user ever notices the delay. This strengthens our confidence that even on an old laptop, our algorithms can provide sufficient responsiveness to end-users.
As the performance of the approach depends on the spans of op-erations and the number of nodes a move or goto traverses, it is desirable to suppress the model to reduce the number of nodes in the data structure. This may include discarding invisible nodes and combining adjacent visible nodes.

An invisible node plays two roles. (1) The node may become visible again when an operation associated with the node is undone. (2) The node is a landmark, i.e. another node insert-depends on it.
If we assume that (1) max L last operations originated at a peer can be undone, and (2) all updates older than L are guaranteed to have been delivered at all peers, then we can, by carefully maintain-ing the right visibility of nodes, discard all del and undo elements older than p . pun  X  L , where p . pun is the latest known pun of peer p . We may also discard str of invisible nodes older than p . pun  X  L . We may then combine nodes of the same insertions after the discard of old elements. All this can be done locally at individual peers.
However, a peer cannot completely get rid of invisible nodes as they can be landmarks. How to effectively suppress the data struc-ture is still a challenging issue.
Another issue is session management. When a user joins a edit-ing session or resumes a suspended one, the latest state of the model must be established at the peer. Materialization of operation rela-tions makes session management more complicated.

Yet another important issue, not specific to our approach, is how to practically resolve conflicts. Currently, all approaches are based on the theoretical correctness, i.e. intention preserving and conver-gence. However, that a solution is theoretically correct does not imply that it is also practically or semantically correct. For exam-ple, if two peers both change the word  X  X e X  to  X  X he X , the end result is  X  X she X , which is theoretically correct but practically wrong.
The work presented in this paper advances the state-of-the-art of real-time decentralized group editing by supporting both string-wise operations and selective undo. The approach combines and extends the strengths of operation transformation (OT) and com-mutative replicated data type (CRDT) approaches by materializing operation relations in a data structure. This contributes not only to more straightforward enforcement of correct execution, but also to better runtime performance. This, however, makes some tasks more complicated, such as session management and garbage collection. We have proved the correctness of the approach using the classi-cal correctness criteria intention preservation and convergence. We have also analyzed the complexity of the algorithms and verified the analysis with experiments. The time complexity of the algo-rithms is independent of the lengths of operation histories. That is, the execution time for executing and integrating various opera-tions does not constantly grow over time. The experimental result is consistent with the analysis and indicates that the approach pro-vides sufficient responsiveness to end-users. [1] M. Ahmed-Nacer, C.-L. Ignat, G. Oster, H.-G. Roh, and [2] L. Andr X , S. Martin, G. Oster, and C.-L. Ignat. Supporting [3] P. F. Dietz and D. D. Sleator. Two algorithms for maintaining [4] C. A. Ellis and S. J. Gibbs. Concurrency control in [5] A. Imine, P. Molli, G. Oster, and M. Rusinowitch. Proving [6] D. Li and R. Li. Preserving operation effects relation in [7] D. Li and R. Li. An approach to ensuring consistency in [8] D. Li and R. Li. An admissibility-based operational [9] I. S. MacKenzie and C. Ware. Lag as a determinant of human [10] G. Oster, P. Molli, P. Urso, and A. Imine. Tombstone [11] G. Oster, P. Urso, P. Molli, and A. Imine. Data consistency [12] N. M. Pregui X a, J. M. Marqu X s, M. Shapiro, and M. Letia. A [13] H.-G. Roh, M. Jeon, J. Kim, and J. Lee. Replicated abstract [14] B. Shao, D. Li, and N. Gu. ABTS: A transformation-based [15] B. Shao, D. Li, and N. Gu. An algorithm for selective undo [16] B. Shao, D. Li, and N. Gu. A sequence transformation [17] B. Shao, D. Li, T. Lu, and N. Gu. An operational [18] C. Sun and C. Ellis. Operational transformation in real-time [19] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen. Achieving [20] C. Sun, Y. Xu, and Agustina. Exhaustive search of puzzles in [21] D. Sun and C. Sun. Context-based operational [22] S. Weiss, P. Urso, and P. Molli. Logoot-undo: Distributed [23] Q. Wu, C. Pu, and J. E. Ferreira. A partial persistent data [24] W. Yu. Constant-time operation transformation and [25] W. Yu. A string-wise CRDT for group editing. In GROUP ,
