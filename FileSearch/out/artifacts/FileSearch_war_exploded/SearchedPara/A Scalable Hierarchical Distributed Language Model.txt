 Statistical language modelling is concerned with building probabilistic models of word sequences. Such models can be used to discriminate probable sequences f rom improbable ones, a task important for performing speech recognition, information retrieval , and machine translation. The vast majority of statistical language models are based on the Markov assum ption, which states that the distribu-tion of a word depends only on some fixed number of words that im mediately precede it. While this assumption is clearly false, it is very convenient beca use it reduces the problem of modelling the probability distribution of word sequences of arbitrar y length to the problem of modelling the distribution on the next word given some fixed number of prece ding words, called the context. We will denote this distribution by P ( w ( w n -gram language models are the most popular statistical lang uage models due to their simplicity and surprisingly good performance. These models are simply conditional probability tables for P ( w n | w 1: n  X  1 ) , estimated by counting the n -tuples in the training data and normalizing the counts appropriately. Since the number of n -tuples is exponential in n , smoothing the raw counts is essential for achieving good performance. There is a large number of sm oothing methods available for n -gram models [4]. In spite of the sophisticated smoothing methods developed for them, n -gram models are unable to take advantage of large contexts since the data spa rsity problem becomes extreme. The main reason for this behavior is the fact that classical n -gram models are essentially conditional probability tables where different entries are estimated i ndependently of each other. These models do not take advantage of the fact that similar words occur in s imilar contexts, because they have no concept of similarity. Class-based n -gram models [3] aim to address this issue by clustering word s and/or contexts into classes based on their usage patterns a nd then using this class information to improve generalization. While it can improve n -gram performance, this approach introduces a very rigid kind of similarity, since each word typically belongs to exactly one class.
 An alternative and much more flexible approach to counteract ing the data sparsity problem is to represent each word using a real-valued feature vector that captures its properties, so that words used in similar contexts will have similar feature vectors. Then the conditional probability of the next word can be modelled as a smooth function of the feature v ectors of the context words and the next word. This approach provides automatic smoothing, sin ce for a given context similar words are now guaranteed to be assigned similar probabilities. Si milarly, similar contexts are now likely to have similar representations resulting in similar predict ions for the next word. Most models based on this approach use a feed-forward neural network to map the feature vectors of the context words to the distribution for the next word (e.g. [12], [5], [9]). P erhaps the best known model of this type is the Neural Probabilistic Language Model [1], which has been shown to outperform n -gram models on a dataset of about one million words. The main drawback of the NPLM and other similar models is that they are very slow to train and test [10]. Since computing the probability of the next word r equires explicitly normalizing over all words in the vocabulary, the cost of computing the probabili ty of the given next word and the cost of computing the full distribution over the next word are virtu ally the same  X  they take time linear in the vocabulary size. Since computing the exact gradient in such models requires repeatedly computing the probability of the next word given its context and updati ng the model parameters to increase that probability, training time is also linear in the vocabulary size. Typical natural language datasets have vocabularies containing tens of thousands of words, which m eans that training NPLM-like models the straightforward way is usually too computationally exp ensive in practice. One way to speed up the process is to use a specialized importance sampling pr ocedure to approximate the gradients required for learning [2]. However, while this method can sp eed up training substantially, testing remains computationally expensive.
 The hierarchical NPLM introduced in [10], provides an expon ential reduction in time complexity of learning and testing as compared to the NPLM. It achieves thi s reduction by replacing the unstruc-tured vocabulary of the NPLM by a binary tree that represents a hierarchical clustering of words in the vocabulary. Each word corresponds to a leaf in the tree an d can be uniquely specified by the path from the root to that leaf. If N is the number of words in the vocabulary and the tree is bal-anced, any word can be specified by a sequence of O (log N ) binary decisions indicating which of the two children of the current node is to be visited next. Thi s setup replaces one N -way choice by a sequence of O (log N ) binary choices. In probabilistic terms, one N -way normalization is replaced by a sequence of O (log N ) local (binary) normalizations. As a result, a distribution over words in the vocabulary can be specified by providing the probability of visiting the left child at each of the nodes. In the hierarchical NPLM, these local probabilities are computed by giving a version of the NPLM the feature vectors for the context words as well as a fea ture vector for the current node as inputs. The probability of the next word is then given by the p robability of making a sequence of binary decisions that corresponds to the path to that word.
 When applied to a dataset of about one million words, this mode l outperformed class-based trigrams, but performed considerably worse than the NPLM [10]. The hie rarchical model however was more than two orders of magnitude faster than the NPLM. The main li mitation of this work was the procedure used to construct the tree of words for the model. T he tree was obtained by starting with the WordNet IS-A taxonomy and converting it into a binar y tree through a combination of manual and data-driven processing. Our goal is to replace th is procedure by an automated method for building trees from the training data without requiring expert knowledge of any kind. We will also explore the performance benefits of using trees where ea ch word can occur more than once. We will use the log-bilinear language model (LBL) [9] as the f oundation of our hierarchical model because of its excellent performance and simplicity. Like v irtually all neural language models, the LBL model represents each word with a real-valued feature ve ctor. We will denote the feature vector for word w by r next word w next word by linearly combining the context word feature vec tors: where C predicted feature vector and the feature vector for each wor d in the vocabulary is computed using the inner product. The similarities are then exponentiated and normalized to obtain the distribution over the next word: Here b Note that the LBL model can be interpreted as a special kind of a feed-forward neural network with one linear hidden layer and a softmax output layer. The i nputs to the network are the feature vectors for the context words, while the matrix of weights fr om the hidden layer to the output layer is simply the feature vector matrix R . The vector of activities of the hidden units corresponds to the the predicted feature vector for the next word. Unlike the NP LM, the LBL model needs to compute the hidden activities only once per prediction and has no non linearities in its hidden layer. In spite of its simplicity the LBL model performs very well, outperfo rming both the NPLM and the n -gram models on a fairly large dataset [9]. Our hierarchical language model is based on the hierarchica l model from [10]. The distinguishing features of our model are the use of the log-bilinear languag e model for computing the probabilities at each node and the ability to handle multiple occurrences o f each word in the tree. Note that the idea of using multiple word occurrences in a tree was propose d in [10], but it was not implemented. The first component of the hierarchical log-bilinear model ( HLBL) is a binary tree with words at its leaves. For now, we will assume that each word in the vocabula ry is at exactly one leaf. Then each word can be uniquely specified by a path from the root of the tre e to the leaf node the word is at. The path itself can be encoded as a binary string d of decisions made at each node, so that d corresponds to the decision to visit the left child of the cur rent node. For example, the string  X 10 X  corresponds to a path that starts at the root, visits its left child, and then visits the right child of that child. This allows each word to be represented by a binary str ing which we will call a code. The second component of the HLBL model is the probabilistic m odel for making the decisions at each node, which in our case is a modified version of the LBL m odel. In the HLBL model, just like in its non-hierarchical counterpart, context wor ds are represented using real-valued feature vectors. Each of the non-leaf nodes in the tree also has a feat ure vector associated with it that is used for discriminating the words in the left subtree form th e words in the right subtree of the node. Unlike the context words, the words being predicted are repr esented using their binary codes that are determined by the word tree. However, this representation i s still quite flexible, since each binary digit in the code encodes a decision made at a node, which depe nds on that node X  X  feature vector. In the HLBL model, the probability of the next word being w is the probability of making the sequences of binary decisions specified by the word X  X  code, g iven the context. Since the probability of making a decision at a node depends only on the predicted fe ature vector, determined by the context, and the feature vector for that node, we can express the probability of the next word as a product of probabilities of the binary decisions: where d corresponding to that code. The probability of each decisio n is given by where  X  ( x ) is the logistic function and  X  r is the predicted feature vector computed using Eq. 1. b the equation is the node X  X  bias that captures the context-in dependent tendency to visit the left child when leaving this node. The definition of P ( w summation over all codes for w as follows: where D ( w ) is a set of codes corresponding to word w . Allowing multiple codes per word can allow better prediction of words that have multiple senses or mult iple usage patterns. Using multiple codes per word also makes it easy to combine several separate words hierarchies to into a single one to to reflect the fact that no single hierarchy can express all the r elationships between words. Using the LBL model instead of the NPLM for computing the loca l probabilities allows us to avoid computing the nonlinearities in the hidden layer which make s our hierarchical model faster at mak-ing predictions than the hierarchical NPLM. More important ly, the hierarchical NPLM needs to compute the hidden activities once for each of the O (log N ) decisions, while the HLBL model computes the predicted feature vector just once per predict ion. However, the time complexity of computing the probability for a single binary decision in an LBL model is still quadratic in the feature vector dimensionality D , which might make the use of high-dimensional feature vecto rs too computationally expensive. We make the time complexity linear in D by restricting the weight matrices C representational power of the model because the context wei ght matrix C word feature vectors. And while this restriction does makes the models with larger contexts slightly less powerful, we believe that this loss is more than compens ated for by much faster training times which allow using more complex trees.
 HLBL models can be trained by maximizing the (penalized) log -likelihood. Since the probability of the next word depends only on the context weights, the featur e vectors of the context words, and the feature vectors of the nodes on the paths from the root to the l eaves containing the word in question, only a (logarithmically) small fraction of the parameters n eed to be updated for each training case. The first step in training a hierarchical language model is co nstructing a binary tree of words for the model to use. This can be done by using expert knowledge, data -driven methods, or a combination of the two. For example, in [10] the tree was constructed from th e IS-A taxonomy DAG from WordNet [6]. After preprocessing the taxonomy by hand to ensure that each node had only one parent, data-driven hierarchical binary clustering was performed on the children of the nodes in the taxonomy that had more than two children, resulting in a binary tree.
 We are interested in using a pure learning approach applicab le in situations where the expert knowl-will lead to superior performance. Hierarchical binary clu stering of words based on the their usage statistics is a natural choice for generating binary trees o f words automatically. This task is similar to the task of clustering words into classes for training cla ss-based n -gram models, for which a large number of algorithms has been proposed. We considered sever al of these algorithms before decid-ing to use our own algorithm which turned out to be surprising ly effective in spite of its simplicity. However, we will mention two existing algorithms that might be suitable for producing binary word hierarchies. Since we wanted an algorithm that scaled well t o large vocabularies, we restricted our attention to the top-down hierarchical clustering algorit hms, as they tend to scale better than their agglomerative counterparts [7]. The algorithm from [8] pro duces exactly the kind of binary trees we need, except that its time complexity is cubic in the vocab ulary size. 2 We also considered the distributional clustering algorithm [11] but decided not t o use it because of the difficulties involved in using contexts of more than one word for clustering. This p roblem is shared by most n -gram clustering algorithms, so we will describe it in some detail . Since we would like to cluster words for easy prediction of the next word based on its context, it is na tural to describe each word in terms of the contexts that can precede it. For example, for a single-w ord context one such description is the distribution of words that precede the word of interest in th e training data. The problem becomes apparent when we consider using larger contexts: the number of contexts that can potentially pre-cede a word grows exponentially in the context size. This is t he very same data sparsity problem that affects the n -gram models, which is not surprising, since we are trying to describe words in terms of exponentially large (normalized) count vectors. Thus, clu stering words based on such large-context representations becomes non-trivial due to the computatio nal cost involved as well as the statistical difficulties caused by the sparsity of the data.
 We avoid these difficulties by operating on low-dimensional real-valued word representations in our tree-building procedure. Since we need to train a model to ob tain word feature vectors, we perform the following bootstrapping procedure: we generate a random binary tree of words, train an HLBL model based on it, and use the distributed representations i t learns to represent words when building the word tree.
 compressing such a collection of contexts down to a low-dime nsional vector. After training the HLBL model, we summarize each context w it using Eq. 1. Then, we condense the distribution of context s that precede a given word into a feature vector by computing the expectation of the predicte d representation w.r.t. that distribution. Thus, for the purposes of clustering each word is represente d by its average predicted feature vector. After computing the low-dimensional real-valued feature v ectors for words, we recursively apply a very simple clustering algorithm to them. At each step, we fit a mixture of two Gaussians to the feature vectors and then partition them into two subsets bas ed on the responsibilities of the two mixture components for them. We then partition each of the su bsets using the same procedure, and so on. The recursion stops when the current set contains only two words. We fit the mixtures by covariances of the components. Since the means of the compon ents are initialized based on a random partitioning of the feature vectors, the algorithm is not de terministic and will produce somewhat different clusterings on different runs. One appealing pro perty of this algorithm is that the running time of each iteration is linear in the vocabulary size, whic h is a consequence of representing words using feature vectors of fixed dimensionality. In our experi ments, the algorithm took only a few minutes to build a hierarchy for a vocabulary of nearly 18000 words based on 100-dimensional feature vectors.
 The goal of an algorithm for generating trees for hierarchic al language models is to produce trees that are well-supported by the data and are reasonably well-balanced so that the resulting models generalize well and are fast to train and test. To explore the trade-off between these two require-ments, we tried several splitting rules in our tree-buildin g algorithm. The rules are based on the observation that the responsibility of a component for a dat apoint can be used as a measure of con-fidence about the assignment of the datapoint to the componen t. Thus, when the responsibilities of both components for a datapoint are close to 0.5, we cannot be sure that the datapoint should be in one component but not the other.
 splits the words into two disjoint subsets of equal size base d on the sorted order. The second rule makes splits well-supported by the data even if that results in an unbalanced tree. It achieves that by assigning the word to the component with the higher respon sibility for the word. The third and the most sophisticated rule is an extension of the second rule, modified to assign a point to both components whenever both responsibilities are within  X  of 0.5, for some pre-specified  X  . This rule is designed to produce multiple codes for words that are difficult to cluster. We will refer to the algorithms that use these rules as BALANCED, ADAPTIVE, a nd ADAPTIVE(  X  ) respectively. Finally, as a baseline for comparison with the above algorit hms, we will use an algorithm that generates random balanced trees. It starts with a random per mutation of the words and recursively builds the left subtree based one the first half of the words an d the right subtree based on the second half of the words. We will call this algorithm RANDOM. Table 1: Trees of words generated by the feature-based algor ithm. The mean code length is the sum of lengths of codes associated with a word, averaged over the distribution of the words in the training data. The run-time complexity of the hierarchical model is l inear in the mean code length of the tree used. The mean number of codes per word refers to the number of codes per word averaged over the training data distribution. Since each non-leaf node in a tr ee has its own feature vector, the number of free parameters associated with the tree is linear in this quantity.
 Table 2: The effect of the feature dimensionality and the wor d tree used on the test set perplexity of the model.
 We compared the performance of our models on the APNews datas et containing the Associated Press news stories from 1995 and 1996. The dataset consists o f a 14 million word training set, a 1 million word validation set, and 1 million word test set. T he vocabulary size for this dataset is 17964. We chose this dataset because it had already been us ed to compare the performance of neural models to that of n -gram models in [1] and [9], which allowed us to compare our re sults to the results in those papers. Except for where stated otherwi se, the models used for the experiments used 100 dimensional feature vectors and a context size of 5. The details of the training procedure we used are given in the appendix. All models were compared ba sed on their perplexity score on the test set.
 We started by training a model that used a tree generated by th e RANDOM algorithm (tree T1 in Table 1). The feature vectors learned by this model were used to build a tree using the BALANCED algorithm (tree T2). We then trained models of various featu re vector dimensionality on each of these trees to see whether a highly expressive model can comp ensate for using a poorly constructed tree. The test scores for the resulting models are given in Ta ble 2. As can be seen from the scores, using a non-random tree results in much better model perform ance. Though the gap in performance can be reduced by increasing the dimensionality of feature v ectors, using a non-random tree drasti-cally improves performance even for the model with 100-dime nsional feature vectors. It should be noted however, that models that use the random tree are not en tirely hopeless. For example, they outperform the unigram model which achieved the perplexity of 602.0 by a very large margin. This suggests that the HLBL architecture is sufficiently flexible to make effective use of a random tree over words.
 Since increasing the feature dimensionality beyond 100 did not result in a substantial reduction in perplexity, we used 100-dimensional feature vectors for al l of our models in the following experi-ments. Next we explored the effect of the tree building algor ithm on the performance of the resulting HLBL model. To do that, we used the RANDOM, BALANCED, and ADAP TIVE algorithms to generate one tree each. The ADAPTIVE(  X  ) algorithm was used to generate two trees: one with  X  set Table 3: Test set perplexity results for the hierarchical LB L models. All the distributed models in the comparison used 100-dimensional feature vectors and a context size of 5. LBL is the non-hierarchical log-bilinear model. KN n is a Kneser-Ney n -gram model. The scores for LBL, KN3, and KN5 are from [9]. The timing for LBL is based on our impleme ntation of the model.
 to 0.25 and the other with  X  set to 0.4. We then generated a 2  X  overcomplete tree by running the ADAPTIVE(  X  = 0 . 4 ) algorithm twice and creating a tree with a root node that had the two generated trees as its subtrees. Since the ADAPTIVE(  X  ) algorithm involves some randomization we tried to improve the model performance by allowing the model to choos e dynamically between two possible clusterings. Finally, we generated a 4  X  overcomplete using the same approach. Table 1 lists the generated trees as well as some statistics for them. Note tha t trees generated using ADAPTIVE(  X  ) using  X  &gt; 0 result in models with more parameters due to the greater numb er of tree-nodes and thus tree-node feature vectors, as compared to trees generated u sing methods producing one code/leaf per word.
 Table 3 shows the test set perplexities and time per epoch for the resulting models along with the perplexities for models from [9]. The results show that the p erformance of the HLBL models based on non-random trees is comparable to that of the n -gram models. As expected, building word trees adaptively improves model performance. The general trend t hat emerges is that bigger trees tend to lead to better performing models. For example, a model based on a single tree produced using the ADAPTIVE(0.4) algorithm, performs as well as the 5-gram but not as well as the non-hierarchical LBL model. However, using a 2  X  overcomplete tree generated using the same algorithm resul ts in a model that outperforms both the n -gram models and the LBL model, and using a 4  X  overcomplete tree leads to a further reduction in perplexity. The time-pe r-epoch statistics reported for the neural models in Table 3 shows the great speed advantage of the HLBL m odels over the LBL model. Indeed, the slowest of our HLBL models is over 200 times faste r than the LBL model. We have demonstrated that a hierarchal neural language mode l can actually outperform its non-hierarchical counterparts and achieve state-of-the-art p erformance. The key to making a hierarchical model perform well is using a carefully constructed hierarc hy over words. We have presented a simple and fast feature-based algorithm for automatic cons truction of such hierarchies. Creating hierarchies in which every word occurred more than once was e ssential to getting the models to perform better.
 An inspection of trees generated by our adaptive algorithm s howed that the words with the largest numbers of codes (i.e. the word that were replicated the most ) were not the words with multiple distinct senses. Instead, the algorithm appeared to replic ate the words that occurred relatively in-frequently in the data and were therefore difficult to cluste r. The failure to use multiple codes for words with several very different senses is probably a conse quence of summarizing the distribution over contexts with a single mean feature vector when cluster ing words. The  X  X ense multimodality X  of context distributions would be better captured by using a small set of feature vectors found by clustering the contexts. Finally, since our tree building algorithm is based on the fe ature vectors learned by the model, it is possible to periodically interrupt training of such a mod el to rebuild the word tree based on the feature vectors provided by the model being trained. This mo dified training procedure might produce better models by allowing the word hierarchy to adapt to the p robabilistic component of the model and vice versa.
 The models have been trained by maximizing the log-likeliho od using stochastic gradient ascent. All model parameters other than the biases were initialized by sampling from a Gaussian of small variance. The biases for the tree nodes were initialized so t hat the distribution produced by the model with all the non-bias parameters set to zero matched the base rates of the words in the training set. Models were trained using the learning rate of 10  X  3 until the perplexity on the validation set started to increase. Then the learning rate was reduced to 3  X  10  X  5 and training was resumed until the validation perplexity started increasing again. All model parameters were regulated using a small L We thank Martin Szummer for his comments on a draft of this pap er. This research was supported by NSERC and CFI. GEH is a fellow of the Canadian Institute for Advanced Research.
 [1] Yoshua Bengio, Rejean Ducharme, Pascal Vincent, and Chr istian Jauvin. A neural probabilistic [3] P.F. Brown, R.L. Mercer, V.J. Della Pietra, and J.C. Lai. Class-based n-gram models of natural [4] Stanley F. Chen and Joshua Goodman. An empirical study of smoothing techniques for lan-[5] Ahmad Emami, Peng Xu, and Frederick Jelinek. Using a conn ectionist model in a syntactical [6] C. Fellbaum et al. WordNet: an electronic lexical database . Cambridge, Mass: MIT Press, [7] J. Goodman. A bit of progress in language modeling. Techn ical report, Microsoft Research, [8] John G. McMahon and Francis J. Smith. Improving statisti cal language model performance [9] A. Mnih and G. Hinton. Three new graphical models for stat istical language modelling. Pro-[10] Frederic Morin and Yoshua Bengio. Hierarchical probab ilistic neural network language model. [11] F. Pereira, N. Tishby, and L. Lee. Distributional clust ering of English words. Proceedings of [12] Holger Schwenk and Jean-Luc Gauvain. Connectionist la nguage modeling for large vocabu-
