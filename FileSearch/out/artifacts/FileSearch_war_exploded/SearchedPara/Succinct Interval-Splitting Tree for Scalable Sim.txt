 Analyzing functional interactions between small compounds and proteins is indispensable in genomic drug discovery. Since rich information on various compound-protein inter-actions is available in recent molecular databases, strong demands for making best use of such databases require to in-vent powerful methods to help us find new functional compound-protein pairs on a large scale. We present the succinct interval-splitting tree algorithm (SITA) that efficiently per-forms similarity search in databases for compound-protein pairs with respect to both binary fingerprints and real-valued properties. SITA achieves both time and space efficiency by developing the data structure called interval-splitting trees, which enables to efficiently prune the useless portions of search space, and by incorporating the ideas behind wavelet tree, a succinct data structure to compactly represent trees. We experimentally test SITA on the ability to retrieve sim-ilar compound-protein pairs/substrate-product pairs for a query from large databases with over 200 million compound-protein pairs/substrate-product pairs and show that SITA performs better than other possible approaches.
 H.3.1 [ Content Analysis and Indexing ]: Indexing meth-ods Algorithms, Design Succinct data structure, wavelet tree, similarity search
Since most drugs are small compounds that interact with their target proteins and modulate the biological functions of the proteins, analyzing functional interactions between small compounds and proteins plays an important part in genomic drug discovery [28, 9]. A vast number of small compounds [5, 6], all possible proteins coded in human genomes [8, 10], and various functional interactions of compound-protein pairs [17, 14, 33, 13] are stored in many recent databases. There is therefore a strong demand for developing powerful methods to make best use of such databases and to find new func-tional compound-protein pairs on a large scale.

Searching for similar compound-protein pairs in databases for a given query is an example of effective use of databases with rich information. However, finding such pairs in a short time remains a challenge, since the number of all possible compound-protein pairs is calculated by the product of the number of compounds and the number of proteins, which makes the database preserving compound-protein pairs ex-tremely large. So far, although many databases support options of similarity search for either compounds [5, 6] or proteins [8, 10], no database supports queries for similar compound-protein pairs due to a large amount of memory and excessive runtime required by existing techniques.
Fingerprint, defined as a binary bit string, is a power-ful representation of various bio-molecules including small compounds and proteins [31]. In practice, the fingerprint representation is commonly used in molecular databases [5, 6], because of its facility of recording the presence or ab-sence of molecular substructures and physicochemical fea-tures. Jaccard similarity (aka Tanimoto similarity) is the de facto standard criterion [18] to evaluate similarity of com-pounds based on their fingerprints in chemoinformatics and pharmacology. Similarity search of compounds for a query is usually performed with Jaccard similarity. Despite many attempts [16, 29, 3, 22, 1], leveraging multibit tree (MT) is the most efficient approach using the upperbounds of Jac-card similarity [16]. By splitting the database into clusters of fingerprints and then building binary trees that recursively split clustered fingerprints with their upperbound informa-tion, MT can prune out useless portions of the search space when searching for similar fingerprints to a query. Bio-molecules have several important properties such as Log P, topological polar surface area, and autocorrelation po-larizability. These properties are represented by real values rather than binary values. In the context of compound-protein pair search, it would be more rational to find similar compound-protein pairs in terms of both binary fingerprints and real-valued properties. For example, PubChem sup-ports such a property similarity search, but the usability is currently limited to searching for compounds only [5].
When an MT-based algorithm is used to search for simi-lar fingerprints with similar properties for a query, the algo-rithm first narrows down candidate fingerprints by using the aforementioned MT-based technique for finding similar fin-gerprints. It then checks whether each candidate fingerprint also has a similar property to the query or not. However, this approach suffers from performance degradation caused by intensively checking one-by-one the similarity of the prop-erty when the number of candidate fingerprints is large. Al-though any algorithm might inherently have this problem with large databases or with small thresholds of Jaccard similarity, the problem is especially pressing in MT-based approaches. Additionally, despite many attempts to achieve high-performance similarity search algorithms in data min-ing (e.g., [19, 21, 20]), these algorithms must also perform a large number of one-by-one checks when they are adapted to similarity search for compound-protein pairs.

We present a novel method called SITA that efficiently performs similarity search for compound-protein pairs with respect to both binary fingerprints and real-valued proper-ties. As in MT, the database is split into clusters of fin-gerprints to narrow down candidate fingerprints. However, unlike MT, SITA safely excludes the fingerprints that never have similar properties by sorting the fingerprints in order of properties and by considering the necessary interval of the sorted fingerprints. Besides, SITA X  X  recursive search in a binary tree with two pruning conditions bypasses the proce-dure of checking one-by-one the similarity of the fingerprint and its property. Finally, while preserving the same time complexity, SITA successfully reduces the memory usage by using the rank dictionary [25] of the wavelet tree [12, 7] that is a succinct, memory-efficient data structure. By synthe-sizing these techniques, SITA X  X  time complexity is output-sensitive . That is, the smaller the threshold is, the more quickly SITA terminates than the existing algorithms.
Experiments were performed on retrieving similar compound-protein/substrate-product pairs for a query from large databases with over 210 million pairs. The performance comparison with other algorithms demonstrates SITA X  X  superiority.
We formulate the similarity search problem for compound-protein pairs with the fingerprint representation. A finger-print is a fixed-length bit string and is conceptually equiva-lent to the set that contains element i if i -th bit of the finger-print is 1. For clarity, notation x i denotes the bit string rep-resentation of a fingerprint, while notation W i corresponds to its set representation. A fingerprint database contains n compound-protein pairs x 1 ,  X  X  X  , x n , where each compound-protein pair is represented by a fingerprint concatenating the compound fingerprint and the protein fingerprint. A word w is an element in W i and | W i | denotes the cardinality of W , i.e., the number of words in W i . F ( W ) is the property of a compound-protein pair W where F maps W to a real number. There are a number of ways to define F in practice (e.g., acidic group count and ALOGP descriptors) [27].
Jaccard similarity for W and W  X  is defined as J ( W, W  X  | W  X  W  X  | | W  X  W  X  | . Gi ven a query compound-protein pair Q , the task of similarity search is to retrieve from the database all the identifiers of fingerprints P NC = { i 1 , i 2 ,  X  X  X  , i satisfy the following two constraints for each j (1  X  j  X  k ) : where  X  and  X  are user-defined thresholds of Jaccard simi-larity and the similarity of the property, respectively.
Several efficient algorithms have been presented to find similar fingerprints satisfying only constraint (1) in both chemoinformatics and data mining. The following subsec-tions review the literature in these research areas.
To our best knowledge, in chemoinformatics, most algo-rithms try employing better bounds of Jaccard similarity to reduce the number of similarity checks. For example, tight bounds are computed with XOR operations in [3]. Approaches to divide the fingerprint database into several blocks are presented [22, 16, 1]. They reduce candidate fin-gerprints since a tighter bound is obtained by applying Baldi et al. X  X  method to each block. Despite their advantage, their scalability is limited with respect to the database size.
Kristensen et al. [16] present indexing data structures called multibit tree (MT) and overcome the scalability prob-lem. Their algorithm first clusters fingerprints with the same cardinality into a block and computes Swamidass and Baldi X  X  bound [29] for each block to exclude useless blocks that never satisfy constraint (1). To efficiently search for similar finger-prints to query Q in the unfiltered blocks, each block is rep-resented as a binary tree where each node represents a set of fingerprints. In the binary tree, fingerprints for a node are disjointly and recursively split to the left and right children according to whether a word chosen by entropy maximiza-tion is included in each fingerprint or not until each leaf contains at most a certain number of fingerprints. In search of similar fingerprints in the block, the algorithm recursively traverses the binary tree from the root and computes at each node the upperbound of the similarity based on [2]. If the upperbound proves that the fingerprints there are not similar to Q , the subtree rooted at that node is pruned. If the algo-rithm reaches a leaf, fingerprints at that leaf are included as candidates of similar ones. After the tree traversal, the algo-rithm finally calculates Jaccard similarity between each pair of those fingerprints and a query for validating the constraint (1). These procedures are repeated until all the similar fin-gerprints are retrieved from the database. Recently, Nasr et al. [23] theoretically analyze MT, and derived a pruning probability of the search space. At present, MT still remains as the most efficient algorithm in chemoinformatics.
Sev eral algorithms presented in data mining can be used to find similar fingerprints satisfying constraint (1).
DivideSkip [19] uses inverted index , an associative array whose key is a word and whose value is a list of fingerprint ids containing that word. Inverted-index-based methods have also been proposed to find all the pairs of similar fingerprints from a given collection of fingerprints [34, 26].

Although DivideSkip was originally used to solve the prob-lem of finding all the fingerprints sharing at least T common words to query Q , the task of finding all the fingerprints sat-isfying constraint (1) is essentially the same as the problem in [19]. DivideSkip obtains | Q | lists by retrieving the list of fingerprint ids for each word in query Q . Those lists are then divided into a set L l of long lists and the set L s of | Q | X  X  L short lists . DivideSkip relies on the fact that fingerprint id i appears at least T  X  X  L l | times on the short lists if two finger-prints W i and Q share at least T common words. For each of such ids found on L s , DivideSkip checks if the id appears at least T times on L l . If this is the case, the fingerprint with that id has at least T common words with Q . If | L s small, DivideSkip performs efficiently by filtering out the ids that appear less than T  X  X  L s | times. However, DivideSkip often suffers from performance degradation caused by large | L s | with a large-scale database containing over hundreds of millions of fingerprints (see Section 5).

The b -bit minwise hashing ( b -bit minhash) algorithm [21, 20] performs a random projection [4] from a fingerprint to a fixed-length string. Each character of the string consists of a b -bit symbol. Jaccard similarity between two fingerprints is then approximately equal to the Hamming distance between the strings of the fingerprints. In the prepossessing phase, all the fingerprints in the database are projected to their cor-responding strings calculated by b -bit minhash and they are sorted in lexicographical order. When finding similar finger-prints to query Q , this approach first calculates the string for Q by using b -bit minhash. It then performs binary search to find the strings of which Hamming distances are similar to Q  X  X  string. Although b -bit minhash is known to be both time and memory efficient, there are cases of which strings with similar Hamming distances are not similar with respect to Jaccard similarity (i.e., false positive) and of which finger-prints that are similar in terms of Jaccard similarity do not have similar Hamming distances (i.e., false negative). To filter out false positives, b -bit minhash must check if each  X  X imilar X  fingerprint is similar to Q with respect to Jaccard similarity, which may result in a slowdown of the speed. Ad-ditionally, because of the possibility of false negatives, b -bit minhash might fail to return similar fingerprints to Q . Al-though the probability of occurring false negatives can be reduced by increasing the value of b , this increase may slow down the speed of the algorithm.

Despite the importance of considering the similarity of both fingerprints and properties, no prior work exists con-sidering constraints (1) and (2) in chemoinformatics and data mining. The current best possible approach is to first exclude the fingerprints that break constraint (1) by using algorithms reviewed in this section and then perform check-ing whether or not each unfiltered fingerprint satisfies con-straint (2). However, this one-by-one-check procedure for constraint (2) must be performed many times, if there are a large number of fingerprints satisfying constraint (1), which occurs with a large database or with small  X  , resulting in intensive computation.
SITA splits the database into blocks to examine only a necessary set of blocks. Each block is constructed as a bi-nary tree with the notion of intervals and depth-first search is performed with subtree pruning schemes to improve the efficiency. SITA further incorporates the ideas behind the inverted index and the wavelet tree to reduce the memory requirement and to preserve the search efficiency.
Table 1 summarizes the characteristics of the representa-tive algorithms and SITA, where B c is a block of fingerprints with cardinality c in the database, W max is the maximum word in all W i belonging to B c and N c is the total number of words in B c . Unlike b -bit minhash, SITA guarantees cor-rectness. Additionally, in terms of space complexity, SITA requires a similar amount of memory to DivideSkip, which requires less memory than MT. Furthermore, SITA is more time-efficient than the other algorithms for finding finger-prints that satisfy constraints (1) and (2) (see Section 5).
Swamidass and Baldi [29] show that  X  | Q |  X  | W |  X  | Q | hol ds if J ( W, Q )  X   X  . This indicates that P 1 = { i ;  X  | Q |  X  | W i |  X  | Q |  X  } mus t contain all elements in P NC (i.e., P P ). That is, a fingerprint id that is not in P 1 is never a member of P NC . As in [29, 16], excluding such use-less fingerprints can be performed efficiently by partitioning the database into blocks each of which contains fingerprint ids with the same cardinality. More specifically, let block B c = { i ; | W i | = c } , which contains all the fingerprints with cardinality c in the database. SITA then need to examine no element in B c if either c &lt;  X  | Q | or c &gt; | Q |
Once blocks B c are selected that satisfy  X  | Q |  X  c  X  | Q | SIT A bypasses one-by-one checks with constraint (2) for each element in B c .

First, fingerprint ids in B c are sorted in ascending order of properties and are saved as an array (see the left of Figure 1). For simplicity, let B c be the sorted block with cardinality c .
A binary tree T c called the interval-splitting tree is then built on each B c beforehand. When a query is given, T c is traversed with pruning schemes to efficiently select all the ids of fingerprints with cardinality c that satisfy constraints v has a summary fingerprint y v for the fingerprints in its interval. (1) and (2). Each node in T c represents a set of fingerprint ids by using an interval of the array of B c , which is different from MT. Let B c [ i ] be the i -th fingerprint id in B c I v be the interval of node v . Node v with interval I c v [ s, e ] contains fingerprint ids B c [ s ] , B c [ s +1] ,  X  X  X  , B interval of a leaf is always in the form of [ s, s ] indicating that the leaf has only one id. The interval of the root is [1 , | B the whole range of B c .

Let left ( v ) and right ( v ) be the left and right children of node v with interval I c v = [ s, e ], respectively. When these children are generated, I c v is disjointly partitioned to I left ( v ) = [ s,  X  ( s + e ) / 2  X  ] and I The procedure of splitting the interval is recursively applied from the root to leaves (see the middle and right of Figure 1 illustrating intervals and sets of fingerprints at the root and its children of T c ).

Each node v is identified by a bit string (e.g., v = 010) indicating the path from the root to v ;  X 0 X  and  X 1 X  denote the selection of left and right children, respectively. At each leaf v , the index of B c is calculated by int ( v ) + 1, where int (  X  ) converts a bit string to its corresponding integer (see the middle of Figure 1 again).
Given query Q , SITA recursively examines T c from the root in a depth-first manner. If SITA reaches a leaf and its fingerprint and property are similar to Q , the id of that fingerprint is included as one solution. To avoid exploring the whole T c , we develop two schemes to prune the subtrees of nodes if all the fingerprints for these nodes are proven to break constraint (1) or (2).

The first pruning scheme refers to constraint (2). Before starting to examine T c , by using constraint (2), SITA cal-culates the necessary condition of the interval I c q that indi-cates where candidate fingerprints for B c should be located. I = [ i c l , i c r ] is calculated as follows: Binary search over B c can efficiently calculate i c l and i the O (log | B c | ) time complexity.

When SITA enters node v , it checks if fingerprints at v have similar properties. The ids of fingerprints with similar verified without looking at any fingerprints, the properties of all fingerprints at v are proven to be different from Q and the subtree rooted at v is safely ignored.

The second pruning scheme is performed at each node v by using summary fingerprint y v of which Jaccard similarity to Q is the upperbound of the fingerprints for v . When T is built, y c v is computed. Let x c i  X  { 0 , 1 } M and W fingerprint of length M and its corresponding set representa-tion, respectively. Then, y c v for v is defined as y c v indicating that any word in x c i is in y c v (see the right of Fig-ure 1 that represents y 2 v in the first two-level nodes of T
Assume that SITA currently checks fingerprints for B c (i.e., | W | = c holds for any fingerprint). The following equiv-alent constraint is derived from constraint (1):  X  X  X  | W  X  Q | X   X 
Let Y b e the set representation of y c v and y c v [ i ] be the i -th bit of y c v . | W B c [ i ]  X  Q |  X  | Y  X  Q | holds for any i  X  I c Therefore, if | Y  X  Q | = P j  X  Q y c v [ j ] &lt;  X  1+  X  node v , any fingerprint x i at v breaks constraint (1). Thus, SITA can safely prune the subtree rooted at v , which results in improving the efficiency of similarity search.

Algorithm 1 shows the pseudo-code of SITA.
SITA X  X  efficiency comes from the fact that the useless parts of T c are pruned out. Let  X  and m be the numbers of tra-versed nodes and fingerprints in the query, respectively. The time complexity of Algorithm 1 is O (  X  m ). SITA is particu-larly efficient with large  X  and small  X  , because of achieving the tighter bound regarding Jaccard similarity and narrower I . However, since DivideSkip and MT also improve the per-formance with large  X  , the empirical performance differences among SITA, DivideSkip and MT tend to be smaller than that with large  X  (see Section 5).

A crucial drawback is that T c requires M P M c =1 | B c | log | B c | bits due to the requirement of M bits for each y c v . Since M is large in practice ( M  X  5000 in our experiments), SITA re-quires a much larger amount of memory than modern PCs. The next two subsections describe approaches to reduce the memory usage while preserving the same time complexity. Algorithm 1 Alg orithm for finding similar fingerprints with similar properties to query Q 1: function Se arch ( Q ) 2: for c satisfying  X  | Q | X  c  X | Q | / X  do 3: k  X   X  1+  X  ( c + | Q | ), I c ro ot  X  [1 , | B c | ], v  X   X  4: I c q  X  [ i c l , i c r ] where i c l  X  min { i ; F ( Q )  X  5: Recursion( v , I c root , Q , c , I c q ) 6: end for 7: end function 8: function Recursion ( v , I c v , Q , c , I c q ) 9: if I c v  X  I c q =  X  then 10: return 11: else if P j  X  Q y v [ j ] &lt; k then 12: return 13: end if 14: if | v | =  X  log | B c | X  then  X  Leaf Node 15: Output the index id [ int ( v ) + 1] 16: end if 17: Recursion( v +  X  0  X  ,[ s,  X  ( s + e ) / 2  X  ], Q , c , I 18: Recursion( v +  X  1  X  ,[  X  ( s + e ) / 2  X  + 1 , e ], Q , c , I 19: end function
To reduce the large memory requirement for preserving summary fingerprints, we use the inverted index to calculate the aforementioned upperbound on the similarity of finger-prints. The inverted index itself does not always reduce the memory requirement. However, with the help of the ideas behind the wavelet tree [12, 7], SITA compactly main-tains only the minimum amount of information called the rank dictionary [25] decreasing the memory usage by a large margin (see the next subsection for details).

Our inverted index is an associative array that maps a word w to the set of all fingerprint ids that contain w . We build an inverted index for each node v with I c v in T c z ids containing j within I c v ). The inverted index A c v v in T c is a one-dimensional array that concatenates all z in ascending order of j and is defined as A c v = z c v 1  X  X  X  X  z c vM . Figure 2 shows the first two levels of the inverted v has word j , P c v [ j + 1] = P c v [ j ] holds. Assume that a query Q = ( q 1 ,  X  X  X  , q m ) is given, s vj = P c v [ q j ] and t 1. Then, if s vj  X  t vj holds, there is at least one fingerprint that contains q j because of A c v  X  X  property. Otherwise, no fingerprint at v contains word q j . Thus, | Y  X  Q | in Subsection 4.2.2 is equal to P m j =1 I [ s vj  X  t vj ] where I [ cond ] is the indicator function that returns one if cond is true and zero otherwise, and | Y  X  Q | is safely used as a criterion to perform pruning. For example, in Figure 2, for Q = (1 , 2 , 4) and A left ( root ) , | Y  X  Q | = I [1  X  0] + I [1  X  3] + I [4  X  5] = 2.
One advantage is that computing | Y  X  Q | requires only s vj and t vj . Therefore, after A c v is built, by saving a pair of ( P v [ j ] , P c v [ j + 1]  X  1) for each word j at each node v in T A v can be removed from the memory. However, since this approach still requires larger spaces than the available mem-ory of modern PCs, the next subsection presents techniques to further reduce the memory usage.
We describe a memory-efficient approach to combine the inverted index with the rank dictionary. After introducing the notion of the rank dictionary, we develop bit array rep-resentations for each node in T c and techniques to check the similarity between summary fingerprints and a query.
Rank dictionary is a data structure for a bit array B of length n [25] and supports the rank query rank c ( B, i ) that returns the number of occurrences of c  X  { 0 , 1 } in B [1 , i ]. Although naive approaches require the O ( n ) time to com-pute a rank, several data structures with only the n + o ( n ) bit storage are presented to achieve the O (1) time [24, 32]. We employ the verbatim rank dictionary [24] to calculate I [ s vj  X  t vj ] in Subsection 4.3 with the O (1) time and thus to preserve the same time complexity as the aforementioned similarity search algorithm. We discuss only how to compute the rank 1 query, because rank 0 ( B, i ) = i + 1  X  rank 1
First, in verbatim the bit array is divided to large blocks of length l = log 2 n (see Figure 3). The ranks of the bound-aries of large blocks are then recorded explicitly into an ar-bits. Next, each large block is further divided into small blocks of length s = log n/ 2. For all boundaries of small blocks, their ranks relative to the large block are recorded into R S [0 , . . . , n/s ]. In addition, the popcount data struc-ture is used and allows to count the number of ones in S [ i, i + j ] in constant time using a precomputed table of size O ( ones in S [ i, i + j ]. Then rank 1 ( S, i ) is computed as: Space complexity of auxiliary data structures for R L , R popcount is sublinear and negligible in the limit n  X  X  X  . Al-though popcount alone can construct a rank dictionary, the hierarchical construction of verbatim is much more succinct.
Our idea is based on the wavelet tree (WT) [12, 7], a suc-cinct data structure for efficiently accessing arrays with a rank dictionary. However, SITA maintains only the memory-efficient rank dictionary without preserving A c v in memory. Thus, SITA can efficiently compute | Y  X  Q | in Subsection 4.3 with a small amount of memory.

A WT contains a collection of bit arrays to update the intervals in the constant time. Let b c v be a bit array for node v in T c with size of | A c v | and with interval I c Figure 4: First two levels of wavelet tree for Figure 2 and r ight ( v ) be v  X  X  left and right children, respectively. We use the verbatim rank dictionary to represent b v c . ement of A c v to either left ( v ) or right ( v ) with keeping the order of elements in A c v by considering the fact that A a concatenated inverted index of which fingerprint ids are I to whether left ( v ) or right ( v ). If b c v [ k ] is 0, A A with I c v = [ i, i  X  ] is defined as: Figure 4 shows an example of the first two levels of the and it is the fourth element of A 2 root that must go to the right 6 hold.

Let Q = ( q 1 ,  X  X  X  , q m ) be a query and s vj and t vj be loca-tions of A c v which are used to compute | Y  X  Q | = P m j =1 t ] at node v as in Subsection 4.3. SITA preserves P c root memory so that it can set s vj = P c v [ q j ] and t vj = P 1]  X  1 if v is the root. Then, by using s vj , t vj , the rank oper-are obtained with the O (1) time complexity as follows: Note that SITA need to preserve only b c v to compute | Y  X  Q | and does not require P c v if v is not the root.
As in the WT, SITA requires (1+  X  ) P M c =1 N c log | B c | for managing b c v for all nodes v , where  X  is the overhead of the rank dictionary (  X  is about 0.62 in our case), and N is the total number of words in B c , i.e., N c = P i  X  B c This is a better representation than managing the summary fingerprints in memory, which requires M P M c =1 | B c | log | B c | bits where M  X  5000 in our experiments. Although P c root requires M P M c =1 log N c bits, it is not an obstacle even for a larger database. The storage for P c root grows only logarith-mically in the number of fingerprints. We evaluated the performance of binary search (BIN), MT, b -bit minhash, DivideSkip, and SITA on one core of a quad-core AMD Opteron Processor 8393 SE (3.1GHz) ma-chine with 512 GB memory. BIN is a strawman baseline that first excludes fingerprints breaking constraint (2) by sorting and binary search, and then calculates Jaccard similarity for each unfiltered fingerprint to find P NC . As in Section 3, MT is the best possible algorithm in chemoinformatics, and Di-videSkip and b -bit minhash are state-of-the-art methods in data mining. We implemented them in C++ and SITA used Vigna X  X  rank dictionary implementation called rank9 [32].
We used 214 , 636 , 657 compounds-protein pairs in the STITCH database [17]. We represented each compound-protein pair by a fingerprint with the dimension of 5 , 014, constructed by concatenating the compound substructure fingerprint (881 substructures) in PubChem [5] and the protein domain fin-gerprint (4 , 133 domains) in PFAM [8, 10]. We used seven representative properties with a variety of mean values and standard deviations (see Table 2) to elucidate the behavior of each algorithm. In particular, SITA tends to perform better for a property of a large standard deviation, because of the higher possibility of pruning search spaces. We randomly sampled 2 , 000 compound-protein pairs as queries.
It took 253 minutes to precompute SITA X  X  necessary data structures for all compound-protein pairs. Once these data structures are computed, the query phase using SITA does not need to recompute them. The data structure construc-tion time indicates that the overhead incurred in the con-struction phase is not a serious issue to use SITA in practice. b -bit minhash is an approximate algorithm that has three parameters of string length  X  , hashing value b and search width k . We tried all combinations of  X  = { 5 , 10 , 50 } , b = that found solutions most quickly with at most the 5% false negative rate. As in [23], MT X  X  single parameter, the max-imum number of fingerprints associated with a leaf, was set to 10. DivideSkip X  X  parameter  X  used to choose the length of long lists was set to the best one by experimenting the cases of  X  = { 10  X  3 , 10  X  2 , ..., 10 3 } .
Tables 3 and 4 show the results of each algorithm with var-ious properties, two different property thresholds (  X  = 0 . 5 and 5) and  X  = 0 . 6, where the search time is the average over 2,000 queries with its standard deviation, | P 1 | is the number of candidate fingerprints chosen by database par-titioning in Subsection 4.1, | P 1  X  [ i l , i r ] | is the number of candidates chosen by database partitioning plus sorting and binary search (i.e., the total size of I c q for unfiltered blocks in Subsection 4.2.2), #Rank is the number of rank operations, and | P NC | is the number of solutions.
Since MT, DivideSkip and b -bi t minhash filter out useless candidates by only considering constraint (1), their perfor-mance remained unchanged with different  X  and properties.
Although DivideSkip X  X  efficiency had been verified in pre-vious work in [19], its performance was evaluated with a much smaller database consisting of 2 million fingerprints. In contrast, when a large-scale dataset consisting of 214 mil-lion fingerprints was used with including an additional con-straint on properties, DivideSkip did not perform well. It took 48 , 235 seconds for DivideSkip to find P NC on average.
Since BIN X  X  performance depends on how many finger-prints are filtered out with  X  , its performance was improved with smaller  X  due to a smaller value of | P 1  X  [ i l , i ten resulted in outperforming MT. However, BIN still needed to perform many one-by-one checks for constraint (2) due to large differences between | P 1  X  [ i l , i r ] | and | P
Although MT is the most efficient algorithm in the previ-ous chemoinformatics literature and we observed that MT was faster than DivideSkip and b -bit minhash which are state-of-the-art in data mining, SITA performed much faster than MT. In case of considering properties, it was hard for MT to reduce the candidate fingerprints, while SITA effec-tively ignored fingerprints with dissimilar properties. In par-ticular, SITA was 150-3390 times faster than MT if  X  = 0 . 5. With larger  X  , the performance difference became smaller be-tween SITA and MT, due to an excessive number of SITA X  X  rank operations (see  X  = 5 and ALOGP(1) in Table 4). How-ever, SITA still outperformed MT even in this case.
Figure 5 shows the search time of each algorithm for  X  = 0 . 6 and 0 . 8 with  X  = 0 . 5, three properties of various stan-dard deviations and various database sizes. SITA consis-tently outperformed the second best algorithm by 2-3 orders of magnitude. Although the performance difference became smaller with different  X  and other properties, we still ob-served the superiority of SITA to other approaches.
Figure 6 shows the average search time for various  X  with  X  = 0 . 5 and TPSA. Again, SITA significantly outperformed the others, despite smaller performance differences with larger  X  that increases the possibility of filtering out candidates for the others except BIN. BIN X  X  performance remained un-changed because it performs pruning only with  X  .

Figure 7 depicts the memory usage for each method. MT used the largest amount of memory and consumed 167 GB to preserve 214 million compound-protein pairs. Although a space-efficient version of MT was presented in [30], we verified that the search time of this approach drastically increased without any significant reduction of memory us-age. In contrast, BIN kept fingerprints of compound-protein pairs by using only 16 bits per word in a fingerprint, which resulted in using only 60 GB memory to store all compound-protein pairs. b -bit minhash required a similar amount to BIN at the price of giving up correctness. With the help of succinct data structures behind the wavelet tree, our SITA consumed 85 GB memory, which was similar to DivideSkip, as estimated from the theoretical analysis (see Table 1).
Figure 8 shows an example of querying compound-protein pairs with XlogP. PubChem and Uniprot IDs are used to specify compounds and proteins, respectively, followed by the chemical structures of compounds, protein names and PFAM domains. Among proteins that could bind to com-pounds similar to the query compound, SITA found many ion-transport proteins that play important biological roles such as neurotransmitter. Considering the fast average search time (2 . 2 seconds) and small memory usage (85GB), the re-sult demonstrated the feasibility to find similar compound-protein pairs in terms of both compounds and proteins, which would be beneficial to analyze compound-protein in-teractions by checking known compound-protein interactions that are similar to the compound-protein pair of interest. Figure 7: Memory usage for each method
As a nother application, we tested SITA, MT and BIN on their abilities to search for substrate-product pairs (compound-compound pairs converted to each other by enzymatic re-actions). We calculated the average search time of 2 , 000 queries per algorithm on a large-scale database consisting of 243 , 438 , 006 compound-compound pairs, where each pair is represented by a fingerprint with the dimension of 1,758 based on differential chemical substructures [15]. In addi-tion, we used the absolute difference of the molecular weights of each compound-compound pair as a property. With  X  = 0 . 8 and  X  = 0 . 5, the average search time of SITA, MT and BIN was 0.12, 461.38 and 651.15 seconds, respectively. SITA used 89 GB memory, while MT and BIN required 114 and 86 GB memory, respectively. This clearly indicates a supe-riority of SITA on a different dataset. Detailed results are supplementally available at http://www.bioreg.kyushu-u. ac.jp/labo/systemcohort/kdd2013/supplement.pdf .
We have presented SITA, a novel, time-and-memory-efficient algorithm to find all compound-protein pairs that are similar to a query in terms of Jaccard similarity and properties from a large-scale database. Experimental results demonstrated that SITA outperformed other state-of-the-art algorithms while reducing the memory requirement to 85 GB.

SITA can currently deal with Jaccard similarly and only one property at a time. One extension is therefore to find similarity with many properties that generate additional con-straints. This would be more beneficial for users to find potential functional compound-protein pairs. [1] Z. Aung and S. Ng. An indexing scheme for fast and [2] P. Baldi and D. Hirschberg. An intersection inequality [3] P. Baldi, D. Hirschberg, and R. Nasr. Speeding up [4] A. Z. Broder, M. Charikar, A. M. Frieze, and [5] B. Chen, D. Wild, and R. Guha. PubChem as a source [6] J. Chen, S. Swamidass, Y. Dou, J. Bruand, and [7] F. Claude and G. Navarro. Practical rank/select [8] T. U. Consortium. The universal protein resource [9] C. Dobson. Chemical space and biology. Nature , [10] R. Finn, J. Tate, J. Mistry, P. Coggill, J. Sammut, [11] R. Gonzalez, S. Grabowski, V. M  X  akinen, and [12] R. Grossi, A. Gupta, and J. Vitter. High-order [13] S. Gunther, M. Kuhn, M. Dunkel, M. Campillos, [14] M. Kanehisa, M. Araki, S. Goto, M. Hattori, [15] M. Kotera, Y. Tabei, Y. Yamanishi, T. Tokimatsu, [16] T. G. Kristensen, J. Nielsen, and C. N. S. Pedersen. A [17] M. Kuhn, D. Szklarczyk, A. Franceschini, [18] A. Leach and V. Gillet. An introduction to [19] C. Li, J. Lu, and Y. Lu. Efficient merging and filtering [20] P. Li and A. Christian K  X  onig. Theory and applications [21] P. Li and C. K  X  onig. b-bit minwise hashing. In [22] R. Nasr, D. Hirschberg, and P. Baldi. Hashing [23] R. Nasr, T. Kristensen, and P. Baldi. Tree and [24] D. Okanohara and K. Sadakane. Practical [25] R. Raman, V. Raman, and S. Rao. Succinct indexable [26] L. Ribeiro and T. H  X  arder. Efficient set similarity joins [27] C. Steinbeck, C. Hoppe, S. Kuhn, M. Floris, R. Guha, [28] B. Stockwell. Chemical genetics: Ligand-based [29] S. Swamidass and P. Baldi. Bounds and algorithms for [30] Y. Tabei. Succinct multibit tree: Compact [31] R. Todeschini and V. Consonni. Handbook of [32] S. Vigna. Broadword implementation of rank/select [33] D. Wishart, C. Knox, A. Guo, D. Cheng, [34] C. Xiao, W. Wang, X. Lin, J. X. Yu, and G. Wang.
