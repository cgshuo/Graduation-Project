 In terms of search strategy, most parsing al-gorithms in current use for data-driven parsing can be divided into two broad categories: dy-namic programming which includes the domi-nant CKY algorithm, and greedy search which in-cludes most incremental parsing methods such as mer performs an exact search (in cubic time) over an exponentially large space, while the latter is much faster (in linear-time) and is psycholinguis-tically motivated (Frazier and Rayner, 1982), but its greedy nature may suffer from severe search er-rors, as it only explores a tiny fraction of the whole space even with a beam.

Can we combine the advantages of both ap-proaches, that is, construct an incremental parser that runs in (almost) linear-time, yet searches over a huge space with dynamic programming?
Theoretically, the answer is negative, as Lee (2002) shows that context-free parsing can be used to compute matrix multiplication, where sub-cubic algorithms are largely impractical.

We instead propose a dynamic programming al-ogorithm for shift-reduce parsing which runs in polynomial time in theory, but linear-time (with beam search) in practice. The key idea is to merge equivalent stacks according to feature functions, inspired by Earley parsing (Earley, 1970; Stolcke, 1995) and generalized LR parsing (Tomita, 1991). However, our formalism is more flexible and our algorithm more practical. Specifically, we make the following contributions: input: w axiom 0 : h 0 ,  X  i : 0 sh re re goal 2 n  X  1 : h n, s where  X  is the step, c is the cost, and the shift cost  X  and reduce costs  X  and  X  are: Figure 1: Deductive system of vanilla shift-reduce.
For convenience of presentation and experimen-tation, we will focus on shift-reduce parsing for dependency structures in the remainder of this pa-per, though our formalism and algorithm can also be applied to phrase-structure parsing. 2.1 Vanilla Shift-Reduce Shift-reduce parsing performs a left-to-right scan of the input sentence, and at each step, choose one of the two actions: either shift the current word onto the stack, or reduce the top two (or more) items at the end of the stack (Aho and Ullman, 1972). To adapt it to dependency parsing, we split the reduce action into two cases, re pending on which one of the two items becomes the head after reduction. This procedure is known as  X  X rc-standard X  (Nivre, 2004), and has been en-gineered to achieve state-of-the-art parsing accu-racy in Huang et al. (2009), which is also the ref-
More formally, we describe a parser configura-tion by a state h j, S i where S is a stack of trees s , s 1 , ... where s 0 is the top tree, and j is the Figure 2: A trace of vanilla shift-reduce. After step (4), the parser branches off into (5a) or (5b). queue head position (current word q each step, we choose one of the three actions: 1. sh : move the head of queue, w 2. re 3. re Note that the shorthand notation t x t  X  denotes a new tree by  X  X ttaching tree t  X  as the leftmost child of the root of tree t  X . This procedure can be sum-marized as a deductive system in Figure 1. States are organized according to step  X  , which denotes the number of actions accumulated. The parser runs in linear-time as there are exactly 2 n  X  1 steps for a sentence of n words.

As an example, consider the sentence  X  X  saw Al with Joe X  in Figure 2. At step (4), we face a shift-reduce conflict: either combine  X  X aw X  and  X  X l X  in a re y action (5a), or shift  X  X ith X  (5b). To resolve this conflict, there is a cost c associated with each state so that we can pick the best one (or few, with a beam) at each step. Costs are accumulated in each step: as shown in Figure 1, actions sh , re and re which are dot-products of the weights w and fea-tures extracted from the state and the action. 2.2 Features We view features as  X  X bstractions X  or (partial) ob-servations of the current state, which is an im-portant intuition for the development of dynamic programming in Section 3. Feature templates are functions that draw information from the fea-ture window (see Tab. 1(b)), consisting of the top few trees on the stack and the first few words on the queue. For example, one such fea-ture template f of two atomic features s the root word of the top tree s the part-of-speech tag of the current head word q on the queue. See Tab. 1(a) for the list of feature templates used in the full model. Feature templates are instantiated for a specific state. For example, at step (4) in Fig. 2, the above template f erate a feature instance More formally, we denote f to be the feature func-tion , such that f ( j, S ) returns a vector of feature instances for state h j, S i . To decide which action is the best for the current state, we perform a three-way classification based on f ( j, S ) , and to do so, we further conjoin these feature instances with the action, producing action-conjoined instances like We denote f be the conjoined feature instances, whose dot-products with the weight vector decide the best ac-tion (see Eqs. (1-3) in Fig. 1). 2.3 Beam Search and Early Update To improve on strictly greedy search, shift-reduce parsing is often enhanced with beam search (Zhang and Clark, 2008), where b states develop in parallel. At each step we extend the states in the current beam by applying one of the three ac-tions, and then choose the best b resulting states for the next step. Our dynamic programming algo-rithm also runs on top of beam search in practice.
To train the model, we use the averaged percep-tron algorithm (Collins, 2002). Following Collins and Roark (2004) we also use the  X  X arly-update X  strategy, where an update happens whenever the gold-standard action-sequence falls off the beam, ition behind this strategy is that later mistakes are often caused by previous ones, and are irrelevant when the parser is on the wrong track. Dynamic programming turns out to be a great fit for early updating (see Section 4.3 for details). 3.1 Merging Equivalent States The key observation for dynamic programming is to merge  X  X quivalent states X  in the same beam Table 1: (a) feature templates used in this work, adapted from Huang et al. (2009). x. w and x. t de-notes the root word and POS tag of tree (or word) x . and x. lc and x. rc denote x  X  X  left-and rightmost child. (b) feature window. (c) kernel features. (i.e., same step) if they have the same feature values, because they will have the same costs as shown in the deductive system in Figure 1. Thus we can define two states h j, S i and h j  X  , S  X  i to be equivalent, notated h j, S i X  X  j  X  , S  X  i , iff. Note that j = j  X  is also needed because the queue head position j determines which word to shift next. In practice, however, a small subset of atomic features will be enough to determine the whole feature vector, which we call kernel fea-tures e f ( j, S ) , defined as the smallest set of atomic templates such that For example, the full list of 28 feature templates in Table 1(a) can be determined by just 12 atomic features in Table 1(c), which just look at the root words and tags of the top two trees on stack, as well as the tags of their left-and rightmost chil-dren, plus the root tag of the third tree s nally the word and tag of the queue head q state form  X  : h i, j, s c , v : prefix and inside costs;  X  : predictor states equivalence  X  : h i, j, s ...s  X  0 i iff. e f ( j, s d ...s 0 ) = e f ( j, s  X  d ...s , v , ) iff. c &lt; c  X  or ( c = c  X  and v &lt; v  X  ). axiom ( p ...s 0 i : ( c, , ) ...s 0 , w j i : ( c +  X , 0 , { p } ) ) s i : ( c  X  + v +  X , v  X  + v +  X ,  X   X  ) where  X  = w f  X  = w f sh ( i, s  X  d ...s  X  0 ) and  X  = w f re The re , and  X  with  X  = w f tag of the next word q information to the parser (unlike the stack, which changes dynamically), we can use j to replace fea-tures from the queue. So in general we write if the feature window looks at top d + 1 trees on stack, and where f from tree s model in Table 1(a) we have where d = 2 , f ( x. w , x. t , x. lc . t , x. rc . t ) (see Table 1(c)). 3.2 Graph-Structured Stack and Deduction Now that we have the kernel feature functions, it is intuitive that we might only need to remember the relevant bits of information from only the last ( d + 1) trees on stack instead of the whole stack, because they provide all the relevant information for the features, and thus determine the costs. For shift, this suffices as the stack grows on the right; but for reduce actions the stack shrinks, and in or-der still to maintain d + 1 trees, we have to know something about the history. This is exactly why we needed the full stack for vanilla shift-reduce parsing in the first place, and why dynamic pro-gramming seems hard here.

To solve this problem we borrow the idea of  X  X raph-structured stack X  (GSS) from Tomita (1991). Basically, each state p carries with it a set  X  ( p ) of predictor states , each of which can be combined with p in a reduction step. In a shift step, if state p generates state q (we say  X  p predicts q  X  in Earley (1970) terms), then p is added onto  X  ( q ) . When two equivalent shifted states get merged, their predictor states get combined. In a reduction step, state q tries to combine with every predictor state p  X   X  ( q ) , and the resulting state r inherits the predictor states set from p , i.e.,  X  ( r ) =  X  ( p ) Interestingly, when two equivalent reduced states get merged, we can prove (by induction) that their predictor states are identical (proof omitted).
Figure 3 shows the new deductive system with dynamic programming and GSS. A new state has the form where [ i..j ] is the span of the top tree s s .. s bined with some predictor state p spanning [ k..i ] to form a larger state spanning [ k..j ] , with the resulting top tree being either s This style resembles CKY and Earley parsers. In fact, the chart in Earley and other agenda-based parsers is indeed a GSS when viewed left-to-right. In these parsers, when a state is popped up from the agenda, it looks for possible sibling states that can combine with it; GSS, however, explicitly maintains these predictor states so that the newly-3.3 Correctness and Polynomial Complexity We state the main theoretical result with the proof omitted due to space constraints: Theorem 1. The deductive system is optimal and runs in worst-case polynomial time as long as the kernel feature function satisfies two properties:
Intuitively, boundedness means features can only look at a local window and can only extract bounded information on each tree, which is always the case in practice since we can not have infinite models. Monotonicity, on the other hand, says that features drawn from trees farther away from the top should not be more refined than from those closer to the top. This is also natural, since the in-formation most relevant to the current decision is always around the stack top. For example, the ker-nel feature function in Eq. 5 is bounded and mono-tonic, since f
These two requirements are related to grammar refinement by annotation (Johnson, 1998), where annotations must be bounded and monotonic: for example, one cannot refine a grammar by only remembering the grandparent but not the parent symbol. The difference here is that the annotations are not vertical ((grand-)parent), but rather hori-zontal (left context). For instance, a context-free rule A  X  B C would become D A  X  D B B C for some D if there exists a rule E  X   X DA X  . This resembles the reduce step in Fig. 3.

The very high-level idea of the proof is that boundedness is crucial for polynomial-time, while monotonicity is used for the optimal substructure property required by the correctness of DP. 3.4 Beam Search based on Prefix Cost Though the DP algorithm runs in polynomial-time, in practice the complexity is still too high, esp. with a rich feature set like the one in Ta-ble 1. So we apply the same beam search idea from Sec. 2.3, where each step can accommodate only the best b states. To decide the ordering of states in each beam we borrow the concept of pre-fix cost from Stolcke (1995), originally developed for weighted Earley parsing. As shown in Fig. 3, the prefix cost c is the total cost of the best action sequence from the initial state to the end of state p , i.e., it includes both the inside cost v (for Viterbi inside derivation), and the cost of the (best) path leading towards the beginning of state p . We say that a state p with prefix cost c is better than a state p with prefix cost c  X  , notated p  X  p  X  in Fig. 3, if c &lt; c  X  . We can also prove (by contradiction) that optimizing for prefix cost implies optimal inside
As shown in Fig. 3, when a state q with costs ( c, v ) is combined with a predictor state p with costs ( c  X  , v  X  ) , the resulting state r will have costs where the inside cost is intuitively the combined inside costs plus an additional combo cost  X  from the combination, while the resulting prefix cost c + v +  X  is the sum of the prefix cost of the pre-dictor state q , the inside cost of the current state p , and the combo cost. Note the prefix cost of q is ir-relevant. The combo cost  X  =  X   X  +  X  consists of shift cost  X   X  of p and reduction cost  X  of q .
The cost in the non-DP shift-reduce algorithm (Fig. 1) is indeed a prefix cost, and the DP algo-rithm subsumes the non-DP one as a special case where no two states are equivalent. 3.5 Example: Edge-Factored Model As a concrete example, Figure 4 simulates an edge-factored model (Eisner, 1996; McDonald et al., 2005a) using shift-reduce with dynamic pro-gramming, which is similar to bilexical PCFG parsing using CKY (Eisner and Satta, 1999). Here the kernel feature function is Figure 4: Example of shift-reduce with dynamic programming: simulating an edge-factored model. GSS is implicit here, and re where h ( x ) returns the head word index of tree x , because all features in this model are based on the head and modifier indices in a dependency link. This function is obviously bounded and mono-tonic in our definitions. The theoretical complexity of this algorithm is O ( n 7 ) because in a reduction step we have three span indices and three head in-dices, plus a step index  X  . By contrast, the na  X   X ve CKY algorithm for this model is O ( n 5 ) which can be improved to O ( n 3 ) (Eisner, 1996). 6 The higher complexity of our algorithm is due to two factors: first, we have to maintain both h and h  X  in one state, because the current shift-reduce model can not draw features across different states (unlike CKY); and more importantly, we group states by step  X  in order to achieve incrementality and lin-ear runtime with beam search that is not (easily) possible with CKY or MST. We first reimplemented the reference shift-reduce parser of Huang et al. (2009) in Python (hence-forth  X  X on-DP X ), and then extended it to do dy-namic programing (henceforth  X  X P X ). We evalu-ate their performances on the standard Penn Tree-ing the standard split: secs 02-21 for training, 22 for development, and 23 for testing. Both DP and non-DP parsers use the same feature templates in Table 1. For Secs. 4.1-4.2, we use a baseline model trained with non-DP for both DP and non-DP, so that we can do a side-by-side comparison of search quality; in Sec. 4.3 we will retrain the model with DP and compare it against training with non-DP. 4.1 Speed Comparisons To compare parsing speed between DP and non-DP, we run each parser on the development set, varying the beam width b from 2 to 16 (DP) or 64 (non-DP). Fig. 5a shows the relationship between search quality (as measured by the average model score per sentence, higher the better) and speed (average parsing time per sentence), where DP with a beam width of b =16 achieves the same search quality with non-DP at b =64, while being 5 times faster. Fig. 5b shows a similar comparison for dependency accuracy. We also test with an edge-factored model (Sec. 3.5) using feature tem-plates (1)-(3) in Tab. 1, which is a subset of those in McDonald et al. (2005b). As expected, this dif-ference becomes more pronounced (8 times faster in Fig. 5c), since the less expressive feature set makes more states  X  X quivalent X  and mergeable in DP. Fig. 5d shows the (almost linear) correlation between dependency accuracy and search quality, confirming that better search yields better parsing. 4.2 Search Space, Forest, and Oracles DP achieves better search quality because it ex-pores an exponentially large search space rather than only b trees allowed by the beam (see Fig. 6a). As a by-product, DP can output a forest encoding these exponentially many trees, out of which we can draw longer and better (in terms of oracle) k -best lists than those in the beam (see Fig. 6b). The forest itself has an oracle of 98.15 (as if k  X   X  ), computed ` a la Huang (2008, Sec. 4.1). These can-didate sets may be used for reranking (Charniak 4.3 Perceptron Training and Early Updates Another interesting advantage of DP over non-DP is the faster training with perceptron, even when both parsers use the same beam width. This is due to the use of early updates (see Sec. 2.3), which happen much more often with DP, because a gold-standard state p is often merged with an equivalent (but incorrect) state that has a higher model score, which triggers update immediately. By contrast, in non-DP beam search, states such as p might still of search quality or parsing accuracy, DP (at b =16) is  X  4.8 times faster than non-DP (at b =64) with the oracle precision k -best lists with higher oracles, while non-DP only explores Figure 7: Learning curves (showing precision on dev) of perceptron training for 25 iterations ( b =8). DP takes 18 hours, peaking at the 17th iteration (93.27%) with 12 hours, while non-DP takes 23 hours, peaking at the 18th (93.04%) with 16 hours. survive in the beam throughout, even though it is no longer possible to rank the best in the beam.
The higher frequency of early updates results in faster iterations of perceptron training. Table 2 shows the percentage of early updates and the time per iteration during training. While the number of updates is roughly comparable between DP and non-DP, the rate of early updates is much higher with DP, and the time per iteration is consequently shorter. Figure 7 shows that training with DP is about 1.2 times faster than non-DP, and achieves +0.2% higher accuracy on the dev set (93.27%).
Besides training with gold POS tags, we also trained on noisy tags, since they are closer to the test setting (automatic tags on sec 23). In that case, we tag the dev and test sets using an auto-matic POS tagger (at 97.2% accuracy), and tag the training set using four-way jackknifing sim-ilar to Collins (2000), which contributes another +0.1% improvement in accuracy on the test set. Faster training also enables us to incorporate more features, where we found more lookahead features ( q 4.4 Final Results on English and Chinese Table 3 presents the final test results of our DP parser on the Penn English Treebank, compared with other state-of-the-art parsers. Our parser achieves the highest (unlabeled) dependency ac-curacy among dependency parsers trained on the Treebank, and is also much faster than most other parsers even with a pure Python implementation it update early % time update early % time 1 31943 98.9 22 31189 87.7 29 5 20236 98.3 38 19027 70.3 47 17 8683 97.1 48 7434 49.5 60 25 5715 97.2 51 4676 41.2 65 Table 2: Perceptron iterations with DP (left) and non-DP (right). Early updates happen much more often with DP due to equivalent state merging, which leads to faster training (time in minutes). McDonald 05b 90.2 Ja 0.12 O ( n 2 ) McDonald 05a 90.9 Ja 0.15 O ( n 3 )
Zhang 08 single 91.4 C 0.11 O ( n )  X  Zhang 08 combo 92.1 C  X  O ( n 2 )  X  Koo 08 semisup 93.2  X   X  O ( n 4 ) Table 3: Final test results on English (PTB). Our parser (in pure Python) has the highest accuracy among dependency parsers trained on the Tree-bank, and is also much faster than major parsers. converted from constituency trees. C=C/C++, Py=Python, Ja=Java. Time is in seconds per sen-tence. Search spaces:  X  linear; others exponential. (on a 3.2GHz Xeon CPU). Best-performing con-stituency parsers like Charniak (2000) and Berke-ley (Petrov and Klein, 2007) do outperform our parser, since they consider more information dur-ing parsing, but they are at least 5 times slower. Figure 8 shows the parse time in seconds for each test sentence. The observed time complexity of our DP parser is in fact linear compared to the super-linear complexity of Charniak, MST (McDonald et al., 2005b), and Berkeley parsers. Additional techniques such as semi-supervised learning (Koo et al., 2008) and parser combination (Zhang and Clark, 2008) do achieve accuracies equal to or higher than ours, but their results are not directly comparable to ours since they have access to ex-tra information like unlabeled data. Our technique is orthogonal to theirs, and combining these tech-niques could potentially lead to even better results.
We also test our final parser on the Penn Chi-nese Treebank (CTB5). Following the set-up of Duan et al. (2007) and Zhang and Clark (2008), we split CTB5 into training (secs 001-815 and 1001-Figure 8: Scatter plot of parsing time against sen-tence length, comparing with Charniak, Berkeley, and the O ( n 2 ) MST parsers. Duan 07 83.88 84.36 73.70 32.70
Zhang 08  X  84.33 84.69 76.73 32.79 this work 85.20 85.52 78.32 33.72 Table 4: Final test results on Chinese (CTB5).
The transition parser in Zhang and Clark (2008). 1136), development (secs 886-931 and 1148-1151), and test (secs 816-885 and 1137-1147) sets, assume gold-standard POS-tags for the input, and use the head rules of Zhang and Clark (2008). Ta-ble 4 summarizes the final test results, where our work performs the best in all four types of (unla-beled) accuracies: word, non-root, root, and com-This work was inspired in part by Generalized LR parsing (Tomita, 1991) and the graph-structured stack (GSS). Tomita uses GSS for exhaustive LR parsing, where the GSS is equivalent to a dy-namic programming chart in chart parsing (see Footnote 4). In fact, Tomita X  X  GLR is an in-stance of techniques for tabular simulation of non-deterministic pushdown automata based on deduc-tive systems (Lang, 1974), which allow for cubic-time exhaustive shift-reduce parsing with context-free grammars (Billot and Lang, 1989).

Our work advances this line of research in two aspects. First, ours is more general than GLR in that it is not restricted to LR (a special case of shift-reduce), and thus does not require building an LR table, which is impractical for modern gram-mars with a large number of rules or features. In contrast, we employ the ideas behind GSS more flexibly to merge states based on features values, which can be viewed as constructing an implicit LR table on-the-fly . Second, unlike previous the-oretical results about cubic-time complexity, we achieved linear-time performance by smart beam search with prefix cost inspired by Stolcke (1995), allowing for state-of-the-art data-driven parsing.
To the best of our knowledge, our work is the first linear-time incremental parser that performs dynamic programming. The parser of Roark and Hollingshead (2009) is also almost linear time, but they achieved this by discarding parts of the CKY chart, and thus do achieve incrementality. We have presented a dynamic programming al-gorithm for shift-reduce parsing, which runs in linear-time in practice with beam search. This framework is general and applicable to a large-class of shift-reduce parsers, as long as the feature functions satisfy boundedness and monotonicity. Empirical results on a state-the-art dependency parser confirm the advantage of DP in many as-pects: faster speed, larger search space, higher ora-cles, and better and faster learning. Our final parser outperforms all previously reported dependency parsers trained on the Penn Treebanks for both English and Chinese, and is much faster in speed (even with a Python implementation). For future work we plan to extend it to constituency parsing. We thank David Chiang, Yoav Goldberg, Jonathan Graehl, Kevin Knight, and Roger Levy for help-ful discussions and the three anonymous review-ers for comments. Mark-Jan Nederhof inspired the use of prefix cost. Yue Zhang helped with Chinese datasets, and Wenbin Jiang with feature sets. This work is supported in part by DARPA GALE Con-tract No. HR0011-06-C-0022 under subcontract to BBN Technologies, and by the U.S. Army Re-search, Development, and Engineering Command (RDECOM). Statements and opinions expressed do not necessarily reflect the position or the policy of the United States Government, and no official endorsement should be inferred.
