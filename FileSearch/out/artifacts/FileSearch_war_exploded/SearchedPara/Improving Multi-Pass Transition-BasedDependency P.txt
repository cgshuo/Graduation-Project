 In recent years, data-driven deterministic dependency parsing has received an increasing amount of interests. Dependency parsing uses dependency representa-tion of syntactic structure, which directly reflects relationships among the words in a sentence. Dependency parsing is usually more efficient and accurate than constituency parsing, since dependency trees are inherently lexicalized and do not need full structure grammar and extra non-terminal nodes. Therefore, de-pendency parsing is widely used in a variety of practical tasks, especially for web-scale data.
 parsing: graph-based [10] and transition-based methods [18, 12].
 sible spanning trees [10]. Graph-based methods usually consist of two stages. In the scoring stage, a classifier is used to score all possible edges (or other small substructures), in the decoding stage, the highest scoring parse tree is found from all possible outputs by combinatorial optimization algorithm. When the depen-dency tree is projective, the time complexity is O ( n 2 ) for first-order models using a minimum directed spanning tree algorithm [4, 8].
 parsing actions locally [18, 12]. Transition-based parsing gives complexities as low as O ( n ) or O ( n 2 ) for parsing. curately, they suffer the problems of error propagation. Therefore, their per-formances are slightly below the graph-based methods[2, 11]. However, recent researches on transition-based dependency parsing have therefore explored differ-ent ways of improving their accuracy [19, 1, 17]. With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages. obviously loses some information which will be helpful for the dependency pars-ing. Especially in multi-pass transition-based dependency parsing algorithm, the shift actions are usually inconsistent for the same node pair in different passes. Some node pairs have a indeed dependency relation, but the modifier node has not been a complete subtree yet. The bottom-up parsing strategy requires to perform shift action for these node pairs.
 based parsers by using the enhanced shift actions, which combine the actions and the relations between the target nodes. Our method can give a link between actions and the real relations between the target nodes. While all previous tran-sition systems ignore shift information, our new system distinguishes the shift action by the relation between the two target nodes. With the more detailed actions, the parser can predict more accurately when it has to decide whether the action should be left or right after several shift actions between the target nodes. Besides, the previous actions can be helpful for next decision by using these actions as features.
 in parsing accuracy, compared to a baseline parser. Our parser also performs better than Maltparser[12], which is one of the most widely used state-of-the-art transition-based systems.
 transition-based parsing in section 2 and give a discussion for the shift action used in current state-of-the-art algorithm in section 3. Then we propose our method on section 4. The experimental results are given in section 5. Finally, we introduce the related work in section 6 and conclude our work in section 7. Our work is based on the Yamada X  X  algorithm [18], which performs multi-pass scans of a partially built dependency structure.
 to right. Yamada X  X  algorithm uses a deterministic analyzing model based on shift-reduce algorithm. It performs multi-pass scans of a partially built dependency structure. At each point, it focuses on a pair of adjacent nodes in the partial dependency structure and uses a support vector machine to decide whether to create a dependency link between them or to shift the focus to the next pair of heads.
 shift No construction of dependencies between these target nodes, and the po-left A dependency relation is constructed between two neighboring nodes where right A dependency relation is constructed between two neighboring nodes ate parsing actions using contextual information surrounding the target nodes, (ii) constructs a dependency tree by executing the estimated actions, (iii) if there is no construction in one pass, get the left or right action which has the max probability in the dependency tree to construct.
 n ) , each element of which represents the root node of a sub-tree constructed in the parsing process (initially all t i is a word w i ).
 classifier.
 executed and the variable no _ construction = true . We select the action y  X  j and make the construction. j = argmax i s  X  i .
 t ; t i +1 &gt; . Then an appropriate parsing action y 2 f Right ; Left ; Shift g is esti-mated by one or more classifiers.
 n  X  1 passes to construct a complete dependency tree. However, it runs in linear time in practice. Due to the bottom-up regulation, a dependency relation h d can be con-structed only after all modifiers of the d have been constructed. Therefore, there are two cases for shift action in Yamada X  X  algorithm: (a) there is no dependen-cies relation between the node pair, (b) there is dependency relation between the node pair, but the modifier node has not been a complete subtree yet. These two cases are shown in Figure 1. ABC is a word sequence.
 However, for case (b), it need predict to take left action at node pair ( A; B ) at the second pass. The difference between two predictions is whether C has been attached as a dependent of node B . This might cause a degradation of performance since that the prediction is often made with linear classifier. The features extracted from this two situations have a lot of overlap. So the prediction of ( A; B ) is very difficult and may cause error propagation. If it predicts left action on ( A; B ) at the first pass, the predict head of C will be never right due to the bottom-up regulation.
 relation between the target node pair when it predicts a shift action. In order to cope with this problem, Yamada and Matsumoto [18] suggested to divide the action shift into two kinds of actions, shift X  and wait for two cases respectively. These new actions are the same behavior in parsing process. However, they do not report any experimental result for their suggestion.
 Fig.1: Two Cases of Shift Action (The arc is from the modifier to its governor.) In this paper, we deal with this problem with two improvements. First, we modify the actions of the transition system. Second, we extend the feature set for parsing based on our improved actions. 4.1 Enhanced Shift Actions We expand the parsing action by adding two actions: shift-left and shift-right . left let the right node become a child of the left one. right let the left node become a child of the right one. shift let the point of focus moves to the right. And there is no relation between shift-right let the point of focus moves to the right. And there is a right relation shift-left let the point of focus moves to the right. And there is a left relation action into shift , shift-left and shift-right , which is used to distinguish the relation between the target node pair. The shift-left and shift-right actions can be also called pseudo shift actions.
 the CoNLL 2009 shared task[9]. The pseudo shift actions are more than 20 %. The detailed information is shown in Table 1.
 4.2 Feature Extraction Let i and i + 1 be the indexes of the left and right of target nodes in T. The and the right context is defined as those on the right: t r ( i + 1 &lt; r ) . Context Fig.2: Examples of shift-left and shift-right Actions(The arc is from the modifier to its governor.) lengths ( l; r ) represents the numbers of nodes within the left and right contexts. We choose the context lengths (2, 2).
 from the target nodes, k denotes the feature type, and v is the value of the feature. If p &lt; 0 , it represents the node in the left context, p = 0 ; 0+ denotes the left or right node of target nodes. p &gt; 0 denotes those in the right context. The feature type k and its value v are summarized in the Table 2.
 vious action. These features are shown in bold in Table 2. If the last action is information of last action including la, la-L-pos, la-L-lex, la-R-pos, la-R-lex. And p is set to 0 to make a formal unity. The information about last action will be a good reference to predict the current action. 4.3 Training We use online Passive-Aggressive (PA) algorithm [6, 7] to train the model pa-rameters. Following [5], the average strategy is used to avoid the overfitting problem.
 rithm of building instance list is just like the parsing algorithm. Here, x is the contextual features and y is the parsing action. We can get all the instances from training corpus.
 consisting of lots of overlapping features, which is the chief benefit of discrimi-native model.
 ^ y i as the hinge-loss function. If ^ y i = y i , the resulting algorithm is passive, that is, w k +1 = w k as we expected. In contrast, when ^ y i  X  = y i , the algorithm aggres-sively forces w k +1 to satisfy the constraints. We define the following constrained optimization problem to update the new weight vector w k +1 based on weight vector w k . The margin ( w ; ( x ; y )) is defined as controls the influence of the slack term on the objective function.
 where Our experiments were conducted on Chinese dataset of the CoNLL 2009 shared task[9]. The detailed information is shown in Table 3. FORM/LEMMA OOV (out-of-vocabulary) is the percentage of FORM/LEMMA tokens not found in the respective vocabularies derived solely from the training data.
 Table 3: Data Statistics for the Chinese Dataset of CoNLL-2009 Shared Task algorithm. The MaltParser is an efficient deterministic dependency parser that is gaining popularity. Similar to Yamada X  X  algorithm, the MaltParser relies on a discriminative classifier to choose its actions. However, by employing the arc-eager algorithm presented in [12], the parser can build the complete parse tree in a single pass and therefore it guarantees O ( n ) complexity in the worst case. line and 0.72 over the maltparser. Considering LAS, we achieve improvements of 1.71 and 0.86, respectively.
 4.1. These enhanced actions avoid the inconsistent actions for the same nodes pair in different passes. Furthermore, they also improve the accuracy of classifier. by recording last shift action, which introduced in section 4.2. When the previ-ous action is shift-left , we can derive that the current action may not be right . Otherwise, there would be two heads for one node. Table 4: Accuracy on test set, excluding punctuation, for unlabeled attachment score (UAS), labeled attachment score (LAS) and Complete Match (CM) Yamada and Matsumoto [18] is in the light of the target nodes, and determines what kind of action to do. This can be treated as a multi-class classification problem. It also uses the the left and right context information of the target nodes and their children X  X  information to exclude ambiguity. However, this method suffers from the inconsistent action problem. It is caused by the strict bottom-up strategy, which requires each node to have found all its dependents before it is combined with its head.
 ing strategy. It combines the bottom-up and top-down processing. It has four actions: Left-arc, Right-arc, Reduce and Shift. And it to some extent eases the contradiction between restrict parsing framework and the structure of the de-pendency tree.
 dependency parsing using linear-time vine pruning and structured prediction cascades. Their first-, second-, and third-order models achieve accuracies com-parable to those of their unpruned counterparts, while exploring only a fraction of the search space.
 which implements a flexible mix of bottom-up and top-down strategies. The new strategy allows the parser to postpone difficult decisions until the relevant information becomes available. In this paper, we investigate to use the enhanced shift actions to improve the transition-based parsing. Our method is based on the multi-pass parsing algo-rithm. The experiments show the effectiveness of our parser over the baseline and Maltparser.
 accuracy of the transition-based dependency parser. We also wish to apply our strategy in the one-pass transition-based parsing algorithm. We would like to thank the anonymous reviewers for their valuable comments. This work was funded by NSFC (No.61003091) and Science and Technology Commission of Shanghai Municipality (14ZR1403200).
 [1] Bohnet, B.: Very high accuracy and fast dependency parsing is not a con-[2] Buchholz, S., Marsi, E.: Conll-x shared task on multilingual dependency [3] Che, W., Li, Z., Li, Y., Guo, Y., Qin, B., Liu, T.: Multilingual dependency-[4] Chu, Y.J., Liu, T.H.: On shortest arborescence of a directed graph. Scientia [5] Collins, M.: Discriminative training methods for hidden markov models: [6] Crammer, K., Singer, Y.: Ultraconservative online algorithms for multiclass [7] Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S., Singer, Y.: Online [8] Edmonds, J.: Optimum branchings. Journal of Research of the National [9] Haji X , J., Ciaramita, M., Johansson, R., Kawahara, D., Mart X , M., M X rquez, [10] McDonald, R., Crammer, K., Pereira, F.: Online large-margin training of [11] Nilsson, J., Riedel, S., Yuret, D.: The conll 2007 shared task on dependency [12] Nivre, J.: An efficient algorithm for projective dependency parsing. In: [13] Nivre, J.: Incrementality in deterministic dependency parsing. In: Proceed-[14] Nivre, J., Hall, J., Nilsson, J., Chanev, A., Eryigit, G., K X bler, S., Marinov, [15] Ren, H., Ji, D., Wan, J., Zhang, M.: Parsing syntactic and semantic depen-[16] Rush, A.M., Petrov, S.: Vine pruning for efficient multi-pass dependency [17] Sartorio, F., Satta, G., Nivre, J.: A transition-based dependency parser [18] Yamada, H., Matsumoto, Y.: Statistical dependency analysis with support [19] Zhang, Y., Clark, S.: A tale of two parsers: investigating and combining
