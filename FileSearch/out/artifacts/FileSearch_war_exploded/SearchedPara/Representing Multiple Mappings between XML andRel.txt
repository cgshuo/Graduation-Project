 Relational databases have been widely used in enterprises to support critical business operations, while XML has emerged as the de facto standard for data representation and exchange on the World-Wide-Web. Ther e is a need to translate an SQL against a relational database to an XQuery for XML data, and vice versa. For example, suppose originally data are stored in the relational database. An SQL which is embedded in existing applications, should be translated into an XQuery to get the XML data from the Web. On the other hand, an XQuery posed against an XML view, might need to be translated to SQL if the underlying database engine is relational.

In this paper, we propose a general frame work, where relational queries and XML queries can be easily transformed to each other. The main issue to support this task is to properly represent the mapping between the relational schema and the XML schema, where representational conflicts might exist. Among all the conflicts, we mainly focus on those related to the characteristic s of the XML representation. Take the structure constructs as an example. A relational schema is usually considered as flat ,sinceno explicit structures exist between relations and the relationship is constructed by join-ing attribute values. On the contrary, the relationship between XML data could be di-rectly represented through the nested structure. The correspondence between a join and a nested structure will need to be presented. Moreover, we also consider the possibility of multiple mappings between the different constructs in two schemas, which is usually neglected to simplify the transformation task.

The contributions of this paper could be summarized as follows:  X  Classification of the representational conflicts:  X  Specification of the mapping of schemas:  X  Design of the transformation algorithms:  X  Implementation of the system: The remaining of this paper is organized as follows. In Section 2, we describe the rep-resentation of relational and XML schemas, and formulate the problem to solve. In Section 3, we define a set of mappings between different schema constructs, and the transformation algorithms along with examples are presented in Section 4. We evalu-ate our proposed approach in Section 5, and a brief comparison with other works is provided in Section 6. Finally, we conclude this paper in Section 7. In this section, we discuss how to represent the relational schema and the XML schema, and show the differences of the corresponding query languages. We also formalize the problem to solve in this paper. 2.1 Schema Representations The relational schema considered in this paper follows the traditional definition and satisfies the First Normal Form. A sample relational schema, which is illustrated as a graph, is shown in Figure 1(a). In the gra ph, each box corresponds to a relation, and the attributes associated with the relation are represented within the box, with the primary key on the top. The foreign key is depicted as an arrow pointing to the corresponding primary key. We further classify the relations into two types. The E-relation corresponds to a relation which describes the information of an entity, e.g. , supplier , part ,and order . The R-relation corresponds to a relation which describes the relationship among other entities and has a composite primary key, e.g. , partsupp and lineitem .
The XML schema proposed by W3C consists of many complex constructs. We only process those conforming to the definition of DTD (Document Type Definition). It can be represented as a quadruple ( E, A, r, P ) ,where E is a set of elements, A is a set of attributes, r is the root element, and P is a production rule defined as follows: where is the empty string; e | e , ee ,and e  X  represent the union, concatenation, and Kleene star, respectivley.

In this paper, the XML schema is represented as a graph, where elements and at-tributes are represented as nodes, and the nesting relationship between elements is rep-resented by the relationship of parent/child nodes in the graph. Note that we do not distinguish the representation of union and concatenation. The sample XML schema, which represents similar information as in Figure 1(a), is illustrated in Figure 1(b). We also define several special kinds of nodes. The repeatable element refers to an internal node which is allowed to have multiple occurre nces under the same parent element, and is annotated by the symbol  X * X , e.g. , part . On the other hand, the dummy element , e.g. , suppliers , is an internal node which is usually introduced just to group elements that appear beneath it. They are both represented as square nodes. The leaf nodes ,which are represented by rounded rectangles, are nodes associated with values. They might be elements, which are named as value elements , or they might be attributes ,which are represented using dotted lines. We also use dashed lines to connect two leaf nodes which are semantically equivalent.

To uniformly refer to the construct repre sented in different schemas but with the same functionality, we define the following terms. A value construct is the construct which directly represents data, e.g. , attribute or leaf node .The collection construct is a construct which represents a set (multi-set) of data with homogeneous structures, eg., relation or repeatable element .The structure construct is used to connect two col-lections. In XML, it can be directly represented by the nested construct , or indirectly represented by a join statement in the relational database. This will be explained further in the next subsection.
 2.2 Query Representations The XQuery and SQL statements considered in this paper, are formally specified in Figure 2. We use two sample queries to explain. Suppose the user intends to identify the type of all parts with the name  X  X vd X , and retrieve the name of its suppliers. The SQL query posed against the relational schema in Figure 1(a) will be as follows: SQ1: SELECT supplier.name, part.type FROM supplier, part, partsupp WHERE part.name =  X  X vd X  AND ................................. (1) To briefly explain, the FROM clause is used to enumerate all the relations consulted, and the SELECT clause lists the attributes fo r output. The conditional statements listed in the WHERE clause could be classified into two types: the one marked with (1) is called the selection statement , which restricts the values of certain attributes; the one marked with (2) is called the join statement , which constructs the relationship between two relations. Note that the two join statements construct the relationship between the two E-relations supplier and part through the R-relation partsupp .

The XQuery statement which performs the same function as SQ1 does, but is appropriate for the XML schema in Figure 1(b), will be as follows: XQ1: FOR $t0 in /tpch/suppliers/supplier , $t1 in $t0/part WHERE $t1/name =  X  X vd X  RETURN $t0/name, $t1/type An XQuery statement uses the FOR clause to list a sequence of variable bindings. In this query, the variable t 0 considers all supplier elements, and the variable t 1 examines all the parts supported by a supplier. The WHERE clause is used to specify the selection condition, and the RETURN clause specifies what to output. Note that XQuery uses path expressions such as /tpch/suppliers/supplier to navigate the nested structure of the XML schema.
Similarly, we define some terms which have the common functionality in differ-ent query languages. First, value literals refer to those statements represented in the SELECT/RETURN clause, such as supplier.name , or the selection statement in the WHERE clause. The collection literals refer to the relations or elements extracted from the FROM/FOR clause, such as /tpch/suppliers/supplier . Finally, the structure literal will be the join statement in the WHERE clause, such as supplier.suppkey = part-supp.suppkey ,orthe nested statement in the FOR clause, such as $ t1 in $ t0/part .Note that value literals operate on value constructs , and the correspondence is same for the collection and the structure literals .

In this paper, we intend to translate an input XQuery into an equivalent SQL query, or vice versa. Traditionally, two equivalent que ries in the same database mean that they can retrieve the same set of data. This definitio n is not applied in our heterogenous environ-ment. Therefore, we define the equivalency based on the query statements themselves. An intuitive definition is first given as follows: Definition 1. Given the input query q i and the output query q o , q i and q o will be strongly equivalent, denoted q i  X  q o , if they have the same numbers of value literals, collection literals, and structure literals, and the corresponding literals are equivalent. However, based on this definition, the sample query SQ1 is not equivalent to XQ1, since the numbers of collection literals are different. The weaker definition is then specified as follows: Definition 2. Given the input query q i and the output query q o , q i and q o will be weakly equivalent, denoted q i q o , if they have the same number of equivalent value literals, but with different numbers of equivalent collection literals. However, the collections in q are connected by proper structure literals.
 We can see SQ1 XQ1. In this paper, we will consider the translated query as correct , if it is strongly or weakly equivalent to the input query. The problem to solve in this paper could be therefore formally stated as follows:  X  X iven two relational or XML schemas, where there might exist multiple mappings between the val ue, collection, or structure constructs, and an input query, find the correct translated query. X  We discuss how to represent schema mappi ngs between the relational schema and the XML schema in this section. The two sample schemas described in Section 2 will be used as examples, and they will be called rdb and xdb , respectively. We also use the suffix s 2 x to represent the mapping from rdb to xdb ,and x 2 s for the reverse direction. 3.1 Representing Value and Collection Mappings There might exist multiple mappings between values in two databases, due to redundant representations, or keys which are represented in two relations to construct joins. We define the following Value Mapping (VM) to represent the correspondence between values in two schemas: Definition 1. Given a value construct v i from schema 1 ,VM( v i ) will return the set of tuples ( v o , type), where v o represents the equivalent value construct represented in schema 2 , and the value of types could be PK (standing for primary keys), FK (standing for foreign keys), or ANY.
 FK &gt; ANY, since primary keys have the important identifying characteristics. For example, VM x 2 s (supplier @ skey) = { (supplier.suppkey, PK), (partsupp.suppkey, FK), (lineitem.suppkey, FK) } , and we will use the attribute associated with the relation sup-plier in the translated query.

The mappings between collections are more c omplicated. We first discuss the case of 1: n mappings from xml schemas to relational schemas. This refers to the situ-ation where the value elements or attributes under a repeatable element are scattered in different relations. This is usually caused by the normalization process in relational databases. A special case concerns the R-relation, which consists of information from several E-relations. In the XML representation, such relationship could be represented by the nested construct. For example, partsupp is a relationship between the two E-relations part and supplier . In the sample XML schema, there is no such explicit ele-ment, and part is directly represente d as a child element of supplier instead. Therefore, we will let partsupp corresponds to the more specific element part , since the path asso-ciated with part is //suplier/part , which represents the rela tionship between the repeat-able elements supplier and part .

As to the case of 1: n mappings from relational schemas to xml schemas, it refers to the situation where the attributes in one relation are represented under several repeatable elements. It might be similarly caused by different partitions of an entity, e.g. ,usingtwo repeatable elements to represent normal cus tomers and VIP customers, respectively. It is also possibly caused by the dummy element . For example, since the functionality of the dummy element suppliers is to group all the supplier elements, both suppliers and supplier will map to the same relation supplier in the sample relational schema.
The Collection Mapping (CM) summarizes the discussion above and is defined as follows: Definition 2. Given a collection construct c i from schema 1 ,CM( c i ) will return the set of tuples ( c o , type), where c o represents the corresponding collection construct repre-sented in schema 2 . For an XML schema, the type could be REP (standing for repeatable elements) or DUM (standing for dummy elements). For a relational schema, the type could be E (standing for E-relations) or R (standing for R-relations).
 For example, CM s 2 x (supplier) = { (suppliers, DUM), (supplier, REP) } ,andCM s 2 x (partsupp) returns the single tuple (part, R EP). As to the case of multiple mappings, the priority of REP will be higher than DUM. However, we let E and R have the same priority, since which relation to output depends on the required attributes. For exam-ple, CM x 2 s (part) = { (part, E), (partsupp, R) } , where the two relations have the same priority. 3.2 Representing Structure Mapping We define the structure mapping in this secti on. Recall that the structure construct might be represented as join statements or nested paths. For easy explanation, we will repre-sent them using tables and give each construc t an identifier, which is used to identify the type of the construct.

Consider the relational schema. If the second letter of the identifier is the letter E , it will represent a join between two E-relations or one E-relation and one R-relation. two R-relations. The join statements for the sample relational schema are represented in Table 3(a). For example, RE1 is a join between the E-relation supplier and the R-relation partsupp , and RR1 is a join between two R-relations partsupp and lineitem . Note that RR1 consists of the two joins RR1-1 and RR1-2. The reason is that the R-relation partsupp has a composite primary key which consists of two attributes partkey and suppkey . To make the query uniquely identify the correct tuples, we need to let the join statements involve all component keys.
 Similarly, the structure constructs in the sample XML database are represented in Table 3(c), and the identifiers are used to denote their types. If the second letter is  X  X  X , which stands for  X  X lat X , the two paths represented by the fields Xpath1 and Xpath2 , will be used to construct a join expression. If the second letter is  X  X  X , it will represent two nested elements. Here Xpath1 represents the ancestor, and w e specify the complete path from the root, while Xpath2 represents the descendent, and we only specify the element name. If a dummy element is involved, the second letter will be  X  X  X .

Table 3(b) represents the structure mappings between the two sample schemas. Re-call that two structure constructs are equivalent if they connect equivalent collection constructs. As specified in the second row of Table 3(b), XN1 is equivalent to RE1, since XN1 connects the repeatable elements supplier and part , and RE1 connects the equivalent counterparts, the E-relation supplier and the R-relation partsupp .Observe that there exist multiple mappings between structural expressions, as seen in collection constructs. If the case happens in the XML schema, the priority will be XN &gt; XD, i.e. , the construct without involving dummy elements will have the higher priority. As to the relational schema, we let RE &gt; RR, since the construct involving the E-relations is preferred.
 In conclusion, we define the Structure Mapping (SM) as follows: Definition 3. Given a structure construct s i from schema 1 ,SM( s i ) will return the set of tuples ( s o , type), where s o represents the corresponding structure construct in schema 2 , and the type could be RE or RR in the relational schema, or XF, XN, or XD in the XML schema.
 Note that in a special case of multiple mappings between collection constructs, where several equivalent collections are select ed for output at the same time, we will need to connect those collections to identify that they are mapped from the same source. For example, the two relations PART and PARTSUP both map to the repeatable element part , so we need to provide an internal join between the two relations. Several examples are listed in Table 3(a), whose identifiers are started with IJ. Also note that internal joins map to nothing, as seen in Table 3(b). We discuss how to perform query transformation using the mapping information in this section, and the sample queries in Section 2 will be used to illustrate the whole translation process. 4.1 Processing Each Literal The transformation system is depicted in Figure 4(a). The input query, either in SQL or XQuery, will be parsed into the internal representation, where the value literals, collec-tion literals, and structure literals are ext racted, and are then sent to the corresponding processor for transformation in sequence.

First, Algorithm ColProcessor processes each collection literal, and gets all the col-lection constructs with the highest priority through CM. If there are several of them, each of which will be associated with a flag called UsedFlag, with the initial value FALSE. It will be set TRUE later if the data r epresented in the collection is  X  X ccessed X , either for projection, selection, or join. All the identified output collections will be rep-resented in the structure ColSet.

Algorithm ValProcessor then identifies e quivalent value literals through VM. In con-trast, only one with the highest priority will be obtained, since it alone can get the most relevant information. Note that this algorithm will update the UsedFlag of the corre-sponding collection in ColSet. It also needs to deal with missing collections and inserts additional collections if necessary. Such s ituation happens when the input collection is an R-relation, but the used attributes do not occur in the pre-defined output collection. Consider the query:  X  X elect suppkey from partsupp X  . The collection equivalent to the R-relation partsupp is the repeatable element part , but it does not have the required at-tribute. It is represented in the element supplier instead. Therefore, we need to add the element supplier into the structure ColSet for output.

In the next step, Algorithm StrProcessor will examine and identify all the equivalent structure literals. To perform this task, we first represent all the relevant information into graphs as defined in the following: Definition 4. A 2-join graph for two input collections c 1 and c 2 is a bipartite graph, where the node s of partition i represent the output collections equivalent to c i . A node will be marked black if its UsedFlag has the value TRUE. The edge connecting two nodes represents the structure literal bet ween the associated out put collections, and annotated with the structure identifier.
 Definition 5. A n-join graph consists of a sequence of n partitions, and i th and i+1 th partitions and the edges between them form a 2-join graph, where 1  X  i  X  n-1. A 3-join graph is illustrated in Figure 4(b), where there are three input collections, and each input collection has two equivalent out put collections. We omit the identifier of the structure construct. The idea is to select the structure construct if the associated collection is marked black. Otherwise, we will choose the one with the highest priority. be output. The complete algorithm is omitted due to space limitation. Note that an original unused collection may be marked black if the corresponding structure construct is chosen. 4.2 Formulating the Query After processing the collection, value, and structure literals, all the intermediate struc-ture will be processed by Algorithm Validator. There are mainly three parts in this Algorithm. The first part forces each input coll ection to have an output collection. The second part of the algorithm removes unused collections. The last part identifies re-quired internal joins, as discussed in Section 3.

Finally, Algorithm Constructor will insert the proper keywords, and combine those intermediate structures as a syntactically correct statement and produce the transformed query statement. Note that when processing the structure literals for XML, if the two identified path statements are nested, as denot ed in the identifier, a nested statement in the FOR clause will be produced. Otherwise, the paths will be transformed into a proper join statement in the WHERE clause.
 We use the two sample queries in Section 2 to illustrate the process of translation. If the input query is SQ1, the two repeatable elements supplier and part will be first identified, and their UsedFlags will be set TRUE by Algorithm ValProcessor. The first join statement, which is RE1, will map to XN1, based on Tables 3(a)-3(b). XN1 will be selected since both the asso ciated collections are marke d black. Therefore, a nested path between supplier and part will be output, as seen in XQ1. Note that the second join statement is an internal join and has no corresponding output. In the reverse direction, the two repeatable elements will identify three relations, supplier , part ,and partsupp , where only the first two relations are marke d by Algorithm ValProcessor. The nested path in the FOR clause will then identify the join statement supplier.suppkey = part-supp.suppkey . Note that here StrProcessor will mark the relation partsupp . Algorithm Validator will find out that relations part and partsupp are both introduced by the el-ement part , and the internal join part.partkey = partsupp.partkey will be identified, as seen in SQ1. We evaluate the correctness and the efficiency of the proposed approach in this section. A formal proof of the correction is shown first, followed by the presentation of the experimental results. 5.1 Correctness To prove the correctness of the proposed approach, we suppose all the schema con-structs have mapping counterparts, since the output query will not be correct if the transformation system cannot get all the re quired information. Processing missing at-tributes are outside of the scope of this paper.
 Lemma 1. Given the input query q i , the output query q o transformed by the proposed system will have the same number of value literals as that of q i , and they are equivalent. Proof. Since Algorithm ValProcessor will process each value literal, and output the one with the highest priority, this statement is trivially proved.
 Theorem 1. Given the input query q i , the output query q o transformed by the proposed system will be correct.
 Proof. The proof is provided by induction on the number of collection literals and value literals. Suppose the statement is true when the input query consists of collection literals CI 1  X  X  X  CI m and value literals VI 1  X  X  X  VI l , and the output query consists of collection literals CO 1  X  X  X  CO n . We consider the case when the input query has an additional CI m +1 , and an additional value literal VI l +1 . Note that to make the input query cor-rect, there must exist a collection literal CI i ,where 1  X  i  X  m , which is connected with CI m +1 . Without loss of generality, we will assu me only one structural construct between any two collection constructs. W e call the structural literal connecting CI i and
Suppose all the collection constructs corresponding to CI m +1 are represented by {
CO n +1 } ,and CO j corresponds to CI i ,where 1  X  j  X  n . The structural constructs connecting { CO n +1 } and CO j are represented as { SO j } . Based on Lemma 1, there will be an VO l +1 corresponding to VI l +1 , so we only need to analyze the collection and structural literals in the output query. In the following, we discuss how many CO n +1 instances appear in the output query. (1) zero: This case happens when no SO j and VO l +1 access any CO n +1 instances, but it is only possible when all SO j instances are empty mapping, and all CO n +1 instances are equal to CO j .Thisisacaseof n :1 mappings, and each SI i is an internal join and maps to nothing. Therefore, the collection and structure parts of the output query do not change. It is still a correct output query. (2) one: One CO n +1 instance appears in the final output query if VO l +1 accesses it. Algorithm StrProcessor will choose the proper SO j instance to output. Therefore, the output query will have n +1 collection literals and all the collection literals are con-nected. If m = n , the output query will satisfy the definition of strong equivalency. Otherwise, it will satisfy the definition of weak equivalency. (3) more than one: This case happens when VO l +1 and SO j access different CO n +1 instances. This is a case of 1: n mappings, and Algorithm StrProcessor will output additional internal joins to make the query correct. 5.2 Efficiency We have designed several experiments to evaluate the efficiency of the proposed ap-proach. Due to space limitation, we will only show the result of one of them. All exper-iments are performed on a P4-2.4 GHz machine, with 512 MB of DDR-RAM.

The schemas used for the experiment are shown in Figure 5(a)-(c). In the relational database, the attributes BE1-BE4 are all represented within the relation B, but they are scattered under different repeatable elements in the XML schema. The difference between the two XML schemas, is that the repeatable elements in (b) are in a flat structure, but in a nested structure in (c). We test four SQL query statements, with increasing BE attributes. Note that the numbers of output collection and structure lit-erals will increase along. The transformation time is shown in Figure 5(d). We can see that the numbers of output literals possess a linear effect on the transformation time, which is acceptable. Also note that the effect of the XML schema structure is quite minor.
 There has been many researches on repr esenting XML documents in relational databases systems. In this type of researches, users pose XQuery to manipulate XML data, but the query needs to be translated into SQL for being executed in the underlying relational databases. The issues regarding t his translation process have been addressed in [10]. Particularly, the authors in [3] c onsider the efficient ways to handle wild cards in the path expression, the authors in [6,5] tackle the problem of recursive path expres-sions or paths, and the authors in [7] discuss how to produce optimal queries. Note that the platform of our research is more general than this type of work, since we consider any kind of mappings between relational dat abases and XML databases, and can per-form bi-directional query translation. However, We could include their approach in our system if we want to consider more complex XQuery.
 Some researchers intend to present complex mappings between schemas as well. The mapping proposed in [4] could handle  X  X omposite X  mappings, such as the object address consisting of many components like street , city and state . The authors in [2] consider the case of multiple elements mapping to the same relation, and they use the input query to uniquely identify one. We have not seen other works which tackle the same problem of multiple mappings as we do.

On the other hand, many researchers hav e investigated the technique on automatic schema matching [9,8,1]. This type of work can be incorporated in our work to help identify equivalent constructs. We can also use such information in the assignment of priorities. In this paper, we represent the schema mapping between relational databases and XML databases. A prototype utilizing these mapping information is built to translate the core expressions between SQL and XQuery. We have shown that our translator could produce transformation correctly and efficiently. In the future, we plan to extend our prototype, so that the full-fledge syntax of XQuery and SQL could be handled.
