 Real -time collaborative programming and n on-real-time collabo-rative programming are two classes of methods and techniques for supporting programmers to jointly con duct complex programming work in software development. They are complementary to each other, and both are useful and effective under different progra m-ming circumstances . However, most existing programming tools and environments have been designed for supporting only one of them, and little has been done to provide integrated support for both. In this paper, we contribute a novel Any-Time Collaborative Programming Environment (ATCoPE) to seamlessly integrate conventional non-real-time collaborative programming tools and environments with emerging real-time collaborative pro gramming techniques and support collaborating programmers to work in and flexibly switch among different collaboration modes accord ing to their need s. We present the general design objectives for ATCoPE, the system architecture, functional design and specifications , ra-tionales beyond design decisions, and major technical issues and solutions in detail , as well as a proof-of-concept implementation of the ATCoEclipse prototype system. D.2 .2 [ Software Engineering ]: Design Tools and Techniques  X  computer-aided software engineering (CASE) ; D.2 .6 [ Software Engineering ]: Programming Environments  X  interactive env i-ronments ; H.5 .3 [ Information Interfaces and Presentation ]: Group and Organization Interfaces  X  computer-supported coope r-ative work , collaborative computing, synchronous interaction . Design, Human Factors.
 Any-time , non -real-time, real-time, collaborative programming, seamless integration, compatibility, transparency. Software development is a complex process which requires so-phisticated coordination and collaboration among software eng i-neers with diverse skills, knowledge and expertise [5] . Progra m-ming is one important and critical phase during the software d e-velopment process, in which multiple programmers work collabo-ratively to transform software requirements into software solu-tions. The effectiveness of collaboration in programming work is critical to the productivity of programmers and the quality of software products [3] [4] [5] . In terms of the interactions among collaborating programmers during the programming work, there are two general classes of collaborative programming : non -real-time collaborative programming and real-time collaborative pro-gramming , which are elaborated below. Non -real-time collaborative programming supports multiple pro-grammers to access shared programming artifacts (e.g., source code directories and files), complete individual programming tasks (e.g., editing source code directories and files) independen t-ly, and merge their changes on the shared programming artifacts at pre-scheduled stages manually. Non-real-time collaborative programming has been widely applied in modern software indu s-try, and commonly supported by software configuration manag e-ment (SCM) systems. An SCM system is essentially a version control system for managing any collection of directories and files collaboratively edited by distributed users. Sophisticated version control systems include Subversion 1 (SVN) [7] , Concurrent Ve r-sions System 2 (CVS) [2] , IBM Rational ClearCase 3 [11] , which commonly support the following working process based on a copy-modify-merge model [14] [20] : 1) The programmer checks out a source code tree of the project 2) The programmer modifies the source code copy in the local http://subversion.apache.org http://www.nongnu.org/cvs http://www.ibm.com/software/awdtools/clearcase http://git-scm.com 3) The programmer may merge the current source code copy in With the support of an SCM system, each p rogrammer can co m-plete the programming work independently without being inte r-rupted by others. Such kind of collaborative programming is r e-garded as non -real-time collaboration because neither local changes performed by an individual programmer are immediately propagated and merged with others  X  copies, nor changes made by others are immediately propagated and merged with the local copy. The local copy is kept private until this programmer manu-ally commit s the local copy into the public repository, and in ad-dition, other programmers also h ave to explicitly perform update operations to incorporate the latest committed changes in the r e-pository into their local copies. In contrast, r eal -time collaborative programming support s a group of programmers to work on shared programming artifacts concu r-rently in a closely-coupled fashion, in which collaborating pro-grammers  X  changes on the shared source code copy are instantly propagated and merged [12] [17] . In addition, such real-time prop-agation and merging are achieved automatically without requiring programmers to manually issue version control operations (e.g., update , commit ) as they do in non -real-time collaborative pro-gramming. Multiple programmers are allowed to access and edit the same source code directory, and even the con tent of the same source code file at the same time, as follows: 1) One programm er  X  s editing operations performed on source 2) Multiple programmers are also allowed to work jointly on the Past studies have found that real-time collaborative programming is capable of accelerating the progress of problem -solving, crea t-ing better design and shorter code length, making programmers enjoy the work more, and eventually increasing the productivity of programmers and improving the quality of software products [6] [12] [17] [21] [22] . Due to these benefits of the emerging meth od and technique, numerous real-time collaborative programming tools and environmen ts have been built in recent years, including research prototypes such as RECIPE [17] , Collabode [10] and Saros 5 [15] , as well as commercial products such as SubEthaEdit beWeeVee 7 and VS Anywhere 8 . Non-real-time collaborative programming is generally suitable for loosely-coupled, long-duration and pre-scheduled collaboration, which may involve a large number of programmers working on large-size programming modules. In practice, large-scale software projects are commonly decomposed and structured by following well-established design principles (e.g., high modularity, low coupling among modules, separation of concerns), so that each individual programmer is able to work independently on pro-gramming modules that are relatively isolated from other pro-gramming modules within a large project. In contrast, real-time collaborative programming is more suitable for a small team of programmers to work on shared and inter-dependent pro gramming tasks in a closely-coupled fashion . Such kind of work is often unstructured because low -level design, cod-ing and testing activities are mixed within the programming pro-cess. It can be started spontaneously and conducted in an ad hoc fash ion, and has relatively short durations in a large project. Th e main difference between real-time and non-real-time collabo-rative programming lies on the interactions among pro grammers. Real -time collaboration enables frequent propagation, notification and merging, while non -real-time collaboration enables in frequent propagation and merging [16] . They are complementary to each other, and both of them are useful and effective under different programming circumstances. However, most existing progra m-ming tools and environments have been separately designed for supporting only one of them, with incompatible working proces s-es, user interfaces and working semantics. It is desirable and ben-eficial to support both of them in one environment, in which pro-grammers can work in any collaboration mode and flexibly switch among different modes according to their needs. In this paper, we propose a novel Any-Time Collaborative Programming Environ-ment (ATCoPE) to seamlessly integrate both real-time and non-real-time collaborative programming techniques. The rest of the paper is organized as follows. In Section 2 , general design objectives for ATCoPE are presented as the guidance for system design, functional specifications, and technical implemen-tation. The system architecture and functional design for ATCoPE are presented in Section 3 , and major technical issues and solu-tions of ATCoPE are discussed in Section 4. The implementation of the ATCoEclipse prototype system is presented in Section 5, followed by conclu sions and future work in Section 6. http://www.saros-project.org http://www.codingmonkeys.de/subethaedit http://www.beweevee.com http://www.vsanywhere.com In this section, four design objectives for ATCoPE are presented as the general guidance for technical design and implementation. Design Objective 1 : Compatibility and transparency in suppor t-ing non-real-time collaborative programming ATCoPE is compatible with existing non-real-time collaborative programming tools and environments in terms of user interfaces , functionalities and features, working processes, and working s e-mantics. It achieves such compatibility by transparent ly incorpo-rating existing single-user programming environments and non-real-time collaboration supporting tools, without any change to the source code of existing systems. For end-users (programmers) of ATCoPE, compatibility means that they can continue to use familiar single-user programming environments (e.g., Microsoft Visual Studio 9 , Eclipse real-time collaboration supporting tools (e.g., CVS, SVN ) with the same skills, knowledge and experience as before, while enjo y-ing emerging real-time collaboration capabilities. For researchers and system builders of ATCoPE, transparency means that they can achieve conventional single-user programming functionalities and non-real-time collaboration supporting capabilities by reusing and incorporating existing tools and environments, without rein-venting them from scratch. Design Objective 2: Capability of supporting advanced real-time collaborative programming ATCoPE supports multiple programmers to freely and concu r-rently work in a shared collection of source code directories and files for the same project at the same time. Under the real-time collaboration mode, multiple programmers can create, delete and update any directory and file for the shared project; they can in-stantly see others  X  updates to the shared source code directories and files in real-time. ATCoPE resolves operation conflicts and ensures consistency of shared data in the face of concurrent m a-nipulation, and provides advanced workspace awareness sup port. Design Objective 3: Capability of supporting any-time collabo-ra tive programming ATCoPE supports not only simultaneous real-time and non-real-time collaboration sessions for different projects, but also any-time collaboration sessions for the same project , which may con-sist of real-time and non -real-time collaboration sessions at the same time. An any-time collaboration session comes into exis t-ence as long as there are multiple programmers working in both real-time and non-real-time collaboration sessions for the same project. In an any-time collaboration session, programmers may work individually, collaborate with others in a conventional non-real-time fash ion, and work in a closely-coupled real-time fashion at the same time. ATCoPE also supports real-time collaborating programmers to perform conventional non-real-time collaboration functions (e.g., check-out , update and commit ) for the shared pro-ject and collectively resolve non-real-time collabo ration conflicts in a real-time collaboration fashion. Moreover, ATCoPE allows programmers to switch among different collabo ration modes and sessions flexibly according to their collaboration needs. http://www.microsoft.com/visualstudio http://www.eclipse.org Design Objective 4 : High performance and scalability ATC oPE provides end-users with high local responsiveness (as responsive as single-user programming tools and environments ), fast remote notification and merging for real-time collaborating programmers, and efficient band width usage for communications among any-time collaborating programmers. ATCoPE also main-tain s good system performance as the increase of the number of collaborating programmers and the number of simultaneous active collaboration sessions for large-scale software projects. To achieve the design objectives, the ATCoPE system archite c-ture is proposed in Figure 1 , and the functionalities of its key components are also specified . The ATCoPE system consists of a server and multiple clients connected by commu nication networks. The ATCoPE Server contains a Real-Time Collaboration Service (RTCoS) component and a Non -Real-Time Collaboration Service (NRTCoS) component, as well as a uni form ATCoPE S erver In-terface for any-time collaboration service (Design Objective 3). The NRTCoS component is responsible for account man agement, source code repository management, and versioning management , which are commonly supported by version control systems. The NRTCoS component incorporates these functionalities from exis t-ing systems (Design Objective 1). The RTCoS component is r e-sponsible for providing advanced real-time collaboration services (Design Objective 2), including real-time collaborative progra m-ming session management, project cache man agement, and group membership management. The RTCoS makes use of the NRTCoS for conventional account and repository man agement, as well as other non -real-time collaboration services (Design Objective 3). An ATCoPE Client provides an integrated d evelopment environ-ment (IDE) with comprehensive facilities for coding , compilation and debugging, as well as various tools (e.g., class browser). The IDE is also integrated with a version control client for supporting non -real-time collaboration. Such features are commonly suppor t-ed by conventional IDE products (e.g., Eclipse), so the ATCoPE Client can incorporate existing tools and systems without reinven-tion (Design Objective 1). While preserving all conventional IDE fun ctions and interface features, the ATCoPE Client also provides additional features for real-time collaborative programming. The ATCoPE Client Adaptor is designed to transparently convert a conventional IDE into an ATCoPE Client, without any change to the source code of the IDE, which can be achieved by following the Transparent Adaptation (TA) approach proposed in prior work [19] . Among various tools and facilities encapsu lated in an IDE, the current design of the ATCoPE Client focuses on extend-ing source code editing tools for supporting any-time (both real-time and non-real-time) collaboration (Design Objective 3 ). Like working with a conventional version control system such as SVN , a programmer needs a user account to use the repository, version control, and other collaboration services in the ATCoPE system. Within the ATCoPE Server, the NRTCoS component is responsible for incorporating source code repository and version control functions from existing tools, and the ATCoPE Client Adaptor is responsible for keeping the process of using user a c-counts to log into the ATCoPE system the same as that of using a conventional IDE with an integrated version con trol client. For end-users, the ATCoPE login process for both real-time and non-real-time collaboration is the same: using the same user account and interface to access the same source code repository man aged by the same version control system. After logging into ATCo PE , the programmer can proceed to access and browse the source code trees granted to his/her account in any way. After logging into ATCoPE, a user may select any source code file or sub-tree of files, and then issue a check-out command to down load the selected files to the local workspace, which triggers the creation of an ATCoPE session. The difference between real-time and non-real-time collaboration sessions comes into exis t-ence when different collaboration options are chosen at the time of checking out files (see Section 5.2 ). If the  X  non-real-time  X  option is chosen, the selected files are downloaded from the NRTCoS repository to the ATCoPE Client, without any interaction with the RTCoS component. The notion of a non -real-time session is implicit in the sense that no explicit session record is created in the ATCoPE Server. If the  X  real-time  X  option is chosen, the selection of the files to be checked out, together with the user account authentication data , is transmitted to the RTCoS component to create a real-time session record, which includes the group membership information (initia l-ly the first user X  s account name and authentication data) and a cache of the source code copy being checked out. The source code copy associated to this session is then downloaded and du-plicated at the client. The creation of a real-time session is tran s-parent to the NRTCoS: the check-out process in the version con-trol system is always the same, regardless of whether a real-time session is created or not . Each explicit real-time session managed by the RTCoS compo nent corresponds to one implicit non-real-time session in the NRTCoS version control system, and such correspondence facilitates close integration and easy switch ing among real-time and non-real-time sessions (see Section 4.3 ). For end-users, the creation of a real-time or non-real-time session in the APCoPE system is nearly the same, ex cept for ticking a different option at the time of checking out files from the version control repository. What happens at the server-side is invisible to the user, but some distinctive visual clues must be provided at the ATCoPE client interface to differentiate whether the current se s-sion is real-time or non-real-time (see Section 5.2 ). In the ATCoPE system, a user is provided with not only a conven-tional repository interface for browsing and checking out files to create new sessions, but also a list of existing real-time sessions available for the programmer to join (see Section 5.2 ). Joining a non -real-time session happens implicitly as long as the progra m-mer checks out file s from the version control repository. Diffe r-ently, to join a real-time session, the user needs to request permi s-sion. In the simplistic case, a user may automatically become a new member of a selected existing real-time session if the session is open for anyone who holds a valid ATCoPE account. In add i-tion, more sophisticated group membership management policies and strategies are possible. For example, the creator of a real-time session may give permissions to a specific group of ATCoPE users, and/or require late-comers to make explicit requests and grant permissions on a case-by-case basis. Once the permission is o btained, the user will join the real-time session under the control of a distributed join-protocol for ensuring consistency (to be di s-cussed in Section 4.2 ). Upon joining, the new session member is recorded in the RTCoS component and the source code copy a s-sociated to this session is downloaded and duplicated at the ATCoPE Client of this new member. At the same time, all exis t-ing members of the real-time session are notified of the joining of the new member. In a non-real-time session, a programmer works on source code copies inside the private workspace; changes to those copies are local and invisible to the public until the local programmer manu-ally commits the changes back to the version control repository . To incorporate changes made by others, a programmer has to explicitly issue an update operation, which merges the latest ve r-sion of the shared source code copy at the version control repos i-tory with his/her local version. The update / commit process may involve conflict detection and conflict resolu tion, as conflicts may occur in the face of concurrent changes on shared files. In a real-time session, a programmer also works on source code copies inside the local workspace, but changes to those copies become v isible automatically and instantly to other collaborating programmers without manually executing update / commit oper a-tions . Esp ecially , multiple programmers may jointly edit one file at the same time, thus creating an internal real-time collaborative editing session. To differentiate these real-time sessions, we use the term real-time project session to refer to a real-time session created when checking out files from the version control reposito-ry, and use the term real-time file session to refer to a real-time collaborative editing session created when multiple programmers are editing the same file in side a r eal -time project session. During a real-time session, programmers may freely and concu r-rently perform two types of editing operations: (1) file -level edi t-ing : to edit the content of any source code file by inserting and deleting texts; and (2) project-leve l editing : to creat e, delete and rename directories and files for the shared project. The timeliness of prop agating changes to other collaborators depends on the nature and need of the collaborative work, as specified below: 1) When multiple programmers are working on the same source 2) When multiple programmers are concurrently changing the In addition to project-level and file-level editing operations with effects in the scope of the same real-time session, a programmer may also issue version control operations (e.g., update , commit ) to merge the source code copy of the real-time session with the latest committed version s from other non-real-time collaborators in the version control repository. All interactions between a real-time session and the version control system are performed in the name of one user who created the real-time session. From the version control syste m X  s perspective, a real-time session is merely a sin-gle user, regardless of how many members are actually in volved in the session. If conflicts with other non-real-time collab orators are detected and reported in processing update or commit oper a-tion, real-time collaborators may jointly resolve them: they may separately resolve conflicts in different files, or jointly resolve con flicts in the same file in a real-time file session . Such kind of close interaction among real-time and non-real-time collaborators is a unique any-time collaboration feature of the ATCoPE system. Upon completion of collaborative work, a programmer may leave a session at any time. Leaving a non-real-time session is implicit by simply issuing a commit operation to merge the local source code copy with the latest copy in the version control repository . Leaving a real-time session can be initiated by a session member under the control of a distributed leave-protocol that flushes all local changes at the leaving site to other existing sites and notifies them of the leaving event, and the corresponding session membe r-ship record will be updated in the RTCoS compo nent. After the last session member has left a real-time session, this session will be terminated, which results in the removal of the whole session record from the RTCoS component. Before the termination of a real-time session, the source code copy in the RTCoS cache will be committed back to the version control repository, which sign i-fies leaving the corresponding non-real-time session. With ATCoPE, a p rogrammer may switch among real-time and non -real-time sessions freely. For example, a programmer may check out a collection of source code files from the version con-trol repository and work individually in a non-real-time collabor a-tion fashion (by using update and commit operations) for a while. At a later moment, this programmer may wish to have more clos e-ly-coupled interaction with some collaborators for solving certain problems, and s/he can simply click a button at the client interface (see Section 5.2 ) to create a real-time session based on the local source code copy. Internally, this will trigger the uploading of the local source code copy to the RTCoS cache and the creation of a new real-time session, which will become visible to other pro-grammers who have currently (or later) logged in to the system. Conversely, a real-time session member may quit the current real-time session and continue to work on the same project (based on his/her local source code copy) as a non-real-time collaborator. In this section, several major technical issues and solutions are presented for supporting the ATCoPE system as designed in pre-vious sections. To achieve responsive and unconstrained real-time collaboration in high latency communication networks like the Internet, the real-time collaborative source code editor in the ATCoPE Client has been designed with a replicated architecture where the shared source code copy is replicated at each collaborating site to allow local operations to be responded and executed quickly (Design Objective 4). When a programmer is editing any shared directo ry or file in a real-time session, editing operations issued are imm e-diately performed on the local replica (thus achieving responsiv e-ness), and then captured by the ATCoPE Client Adaptor and in-stantly propagated to remote sites for execu tion (thus achieving real-time notification and merging ). Such kind of collaborative editing is unconstrained in the sense that programmers can freely and concurrently access and update any part of the shared pro-gramming artifacts at any time. Under the replicated architecture, consistency maintenance b e-comes an essential requirement and technical challenge: after all editing operations are propagated and executed at all collabora t-ing sites within a real-time s ession, the distributed replicas of the source code directories and files should be identical across all collaborating sites. As there are two types of real-time sessions (i.e., real-time project session with project-level editing oper a-tions and real-time file session with file-level editing operations), suitable consistency maintenance techniques have been devised and ap plied for each of them respectively, as follows. In a real-time project session, each project-level editing op eration is immediately performed at the local replica, automatically cap-tured by the ATCoPE Client Adaptor, and instantly propagated, via the real-time session manager inside the ATCoPE Server, to all other collaborating sites for remote execution. As mentioned in Section 3.2.4 , concurrent editing operations may cause con flicts. One possible approach to solving this problem is to use a lock ing-based protocol to serialize concurrent operations. Under this ap-proach , one site must obtain the permission token from the central coordinator before performing any pro ject -level editing operation, and the token must be returned back to the coordinator after the operation has been done locally and executed at remote sites. Thi s approach achieves consistency by prohibiting concurrent project-level editing operations, thus eliminating the possibility of oper a-tion conflicts. However, it is too restrictive for real-time collabo-rative work (which often requires unconstrained in teraction), and may incur high computation and communication overhead b e-cause each project-level editing operation needs a costly global synchronization in high-latency communication networks. To achieve high performance and scalability (Design Objective 4 ), an optimistic approach to concurrency control has been adopted for project-level editing operations: programmers are allowed to perform project-level editing operations without any delay, and the system auto matically detects and resolves operation conflicts at remote sites. To detect and resolve conflicts among project-level editing operations, the following techniques are applied . First ly, a scheme based on state vector s [18] is devised to time-stamp each project-level editing operation with a state vector , which is used to derive causal relationships (one necessary cond i-tion for conflicts ) among operations. Second ly, a history buffer is maintained at each site to save all project-level editing operations that have been executed at the site. When a remote operation a r-rives and becomes cau sally ready for execution , operations saved in the history buffer are scanned to check whether they are con-current with the newly arriv ed operation by comparing the ir timestamps. If an executed operation is found to be concurrent with the newly arriv ed one, detailed operation information (such as the operation type and the pathname of the target ed directo-ry/file) is further examined to check whether the concurrent ope r-ations are conflicting with each other. In case that a conflict is detected , the corresponding conflict reso lution strategy is applied. In a real-time file session, consistency maintenance is con cerned with the textual content of the shared source code file that is being collaboratively edited. After all file-level editing operations are executed at all sites within a real-time file session, the textual content of the shared source code file in each local replica should be identical. Similar to a project-level editing operation, a file-level editing operation is also immediately applied on the local replica of the shared file, automatically captured by the ATCoPE Client Adaptor, and then instantly propagated, via the ATCoPE Server, to all other collaborating sites within the same real-time file session. Concurrent file-level editing operations may also conflict with each other due to the positional shifting effects of textual editing operations, which is a well-known problem and can be resolved by using the OT technique contributed in prior work [18] . The OT technique has been invented to maintain con-sistency without restricting user interactions, which is able to achieve two key consistency requirements: (1 ) convergence : a ll replicas of the shared document must be identical after executing the same group of operations; and (2 ) intention p reservation : the effect of an op eration in all replicas must be the same as its effect at the local replica. With the support of other distributed compu-ting techniques, a real-time collaborative editing system also en-sures causality preservation to ensure that editing operations are always executed in their cause-effect order at all collaborating sites. Technically, the OT technique transform s parameters of concurrent operations to compensate the positional shifting effects (in the domain of plain text editing), so that their execution in different orders can pro duce consistent and intended results. ATCoPE supports dynamic membership in real-time sessions where collaborating sites can join and leave a session at any time during collaborative programming. To accommodate late-comers at any time in a reliable way, a distributed join-protocol has been designed, with the following communication messages:  X  JOIN: sent from a new client to the session manager to re- X  START: sent from the session manager to all existing clients  X  READY: sent from an existing client to the session manager  X  FINISH: sent from the session manager to all clients (includ-Major steps of the join-protocol are listed and described below. In addition, an example is presented in Figure 2 to illu strate how the join-protocol works step-by-step in a re al-time session with two existing clients for accepting a new client to join.  X  When a new client attempts to join a real-time session, it  X  Upon receiving a JOIN message from a new client, the se s- X  Upon receiving a START message sent from the session man- X  Upon receiving READY messages from all existing clients,  X  Upon receiving a FINISH message, a client is unblocked for Under the assumption that all communications between clients and the server are performed in FIFO channels (e.g., TCP conne c-tions), a session will enter the quiescent state when all clients have received the FINISH message. In a quiescent state, there is no message in transition, and all sites must have executed the same collection of operations and hence have consistent cop ies of source code. At the end of the join-protocol procedure, the new comer will receive the latest source code copy of the project, and all sites will resume work as if a fresh session is started. In case that multiple clients concurrently issue joining requests for the same session, they are seria lized by the session manager to avoid inconsistency and complication . When a joining request arrives at the session manager, if one join-protocol procedure for the same real-time session is in progress, the coming request will be queued until the ongoing p rocedure is completed. However, concurrent joining for different sessions can be processed in parallel. For a leav ing request from an existing client, the session manager simp-ly broadcasts a LEAVE message to other existing clients to in-form the event, removes the site from the session X  X  active mem-bership list, and closes the network connection with the client. Based on the general design objectives , ATCoPE should be com-patible with existing single-user programming environments and non -real-time collaboration supporting tools, and achieve such compatibility by transparently incorporating existing IDEs and version control systems. The transparent integration with existing single-user programming environments and con verting them into multi-user real-time collaborative programming environments can be achieved by taking the TA approach proposed in prior work [19] . The transparent integration with non-real-time collaboration service involves multiple components inside the ATCoPE system, which collectively achieve the following objectives: (1) incorpo-rating conventional and existing non -real-time collaboration ser-vice supporting tools for non-real-time collaborative progra m-ming sessions in ATCoPE; and (2) bridging n on-real-time collab-oration service and real-time collaborative programming sessions . In the following parts, we present how various ATCoPE compo-nents collaborate with each other to achieve these objectives. As shown in Figure 3 , for a non -real-time collaborative progra m-ming session, an ATCoPE Client issues version control operations (e.g., check-out , update , commit ) in the same way as working in a conventional IDE integrated with a version control client. The ATCoPE Server Interface processes these operations by simply passing them to the NRTCoS component in the ATCoPE Server, which in turn invokes public interfaces of existing version con trol systems to execute these operations . At the begin ning of a non-real-time session, the source code copy is checked out from the NRTCoS repository to the local workspace of the ATCoPE Client . In the face of update / commit operations, the source code copy is either downloaded from the NRTCoS repository to the AT CoPE Client  X  s local workspace (by update ), or uploaded from the local work space to the NRTCoS repository (by commit ). In summary, the ATCoPE client user issues version control operations by using the same process and user interface , executing operations with the same semantics, and achieving the same results as working with a conventional IDE and version control client. 
Figure 3 . Incorporating non-real-time collaboration service As illustrated in Figure 4 , to support the use of the non -real-time collaboration service from real-time collaboration sessions , each real-time session is associated with a Non -Real-Time Client Proxy in the RTCoS component, which bridg es the non -real-time co l-laboration service and the real-time collaborating programmers. Inside the ATCoPE Server, each real-time session has a corr e-sponding session cache for storing the latest copy of the project  X  s source code as a shared repository for the period of the real-time session. When a real-time session is created by an ATCoPE user, the source code copy is checked out from the NRTCoS repository to the corresponding session cache for the newly created real-time session in the RTCoS. The source code copy is then downloaded from the RTCoS Session Cache to the client  X  s local workspace via the ATCoPE Server Interface. Similarly, when a new site joins the real-time session, the latest copy of the project  X  s source code is transmitted from the RTCoS Session Cache to the local work-space of the new client, upon completion of the join-protocol procedure as presented in Section 4.2 . During a real-time session, programmers concurrently perform various editing operations on the shared source code copy, and changes are propagated to other sites in stantly and saved to the RTCoS Session Cache as well. 
Figure 4 . Bridging non-real-time collaboration service and Whenever a member of the real-time session issues an u pdate or commit operation , this operation is transmitted to the correspond-ing Non -Real -Time Client Proxy inside the RTCoS component, which relays these version control operations (and associated data) to the NRTCoS version control system. In processing an update operation, the latest copy in the NRTCoS repository is download-ed and merged with the current copy stored in the session cache, and the updates are then downloaded to all clients within the real-time session. Conversely, in processing a commit operation, the latest source code copy stored in the session cache is committed to the NRTCoS repository . The Non -Real -Time Client Proxy ent of the NRTCoS, so the credentials of the session creator must be saved in the RTCoS session manager at the time of session creation for facilitating authentication when communicating with the NRTCoS comp onent. In processing non-real-time version control operations within a real-time session, the proxy must also ensure consistency of the shared source code copy among all session members. This has been achieved by using synchronization protocols to force the session to reach a quiescent and consistent state. For support ing update and commit operations in real-time collaborative pro-gramming sessions , synchronization proto cols similar to the join-protocol have been devised, which simply replace the JOIN me s-sage with an UPDATE or COMMIT message. When the session reaches a quiescence state, the shared source code copy must be consistent across all sites, and this latest copy is committed to the NRTCoS repository, or merged with the downloaded copy from the NRTCoS repository by the update command. In executing either update or commit operation, conflicts may be detected and reported by the NRTCoS version control system, and the resolu-tion of those conflicts can be carried out in a real-time collabor a-tion fashion (using ATCoPE real-time collaboration service). Moreo ver, in the face of concurrent version control operations issued by multiple active members in the same real-time session , they are serialized by the session manager. To validate the feasibility of ATCoPE as well as the functional design and technical solutions , a prototype named ATCoEclipse ( A ny-T ime Co llaborative Programming with Eclipse ) has been implemented, which realizes the system architecture, tech niques , and solutions derived from the research, and serves as a proof-of-concept for ATCoPE. To achieve transparency and compatibility with existing single-user programming environments , the ATCoPE Client has been implemented as a plug-in with the popular Eclipse IDE, using the TA approach and the Generic Collaboration Engine (GCE) con-tributed in prior work [19] . To achieve compatibility with existing version control systems for non-real-time collaboration service, the SVN has been adopted for supporting conventional version control functionalities in the ATCoEclipse system. These design decisions have been made based on the following reasons. First ly, the Eclipse IDE is an open platform with a core runtime engine and various subsystems as plug-ins, allowing d e-velopers to add exten sions easily. SVN is also a free and open source system which provides extensibility and reusability. Se c-ond ly, the Eclipse IDE contains a rich set of popular plug-ins that provides not only useful features but also programming interfaces for other plug-ins to utilize. Similarly, SVN also provides rich interfaces for supporting version con trol functions that can be utilized by external applications in communicating with the SVN service (e.g., sending SVN commands). Last but not least, the Eclipse IDE is widely used by a large nu mber of users in software industry and academic commu nities due to its free, open-source, and extensible properties, and similarly, SVN is also a sophist i-cated and popular system with a wide range of users. Large popu-larity of Eclipse and SVN provides great opportunities for usabi l-ity study and evaluation. As presented in Figure 5 , the ATCoEclipse system architecture is an instance of the generic ATCoPE system architecture in Figure 1, with the ATCoPE Client instantiated by the ATCoEclipse Cl i-ent , and the ATCoPE Server instantiated by the ATCoEclipse Server . The ATCoEclipse system takes a client-server commun i-cation structure where multiple ATCoEclipse Clients are connec t-ed to the ATCoEclipse Server via the Internet. At the client-side, the ATCoEclipse Client Adaptor transparently converts the existing single-user Eclipse source code editor into an advanced multi-user real-time collabo rative source code editor. Within the ATCoEclipse server-side, the SVN Service is incorpo-rated as the non-real-time collaboration service. The RTCoServer ( Real-Time Collaboration Server ) component contains various functional modules for collectively offering real-time collabor a-tion service, and transparently incorporates the SVN Service for support ing non -real-time collaboration functionalities in real-time collaboration sessions. The ATCoEclipse S erver Interface pro-vides a uniform any-time collaboration interface for pro cessing both real-time and non-real-time collaboration requests and co m-mands from all ATCoEclipse Clients. Figure 6 presents the user interface for a programmer to initialize programming work with ATCoEclipse , which is designed accord-ing to functional specifications in Section 3.2.1 , 3.2.2 and 3.2.3 . In the upper-left part of the dialog box, the programmer specifies the SVN repository to access and the user account (with username and password) used in the SVN system, which is similar to the authentication process for using a conventional SVN client . Up on successful authentication (performed by the SVN Service via the ATCoEclipse Server Interface), the source code directories and files located at the specified location are retrieved and displayed as a tree at the ATCoEclipse Client, as shown in the lower-left part of Figure 6 . If th e programmer wants to create a new collaboration session, s/he can browse this source code tree and specify a location to check out, which acts similarly as a conventional version con trol client integrated with single-user programming environments . After specifying the source code directories and files to check out, the programmer pro ceeds to choose the collaboration mode in the right panel. The programmer is provided with two options for the collaboration mode: (1) non-real-time collaboration, which will directly check out the source code copy from the SVN repository to the local workspace; and (2) real-time collaboration, which will trig ger the ATCoEclipse Server to create a new session (with this user as the session owner and creator), check out source code copy from the specified location in the SVN repository to the session cache at the ATCoEclipse Server, and then transmit the source code copy to the programmer  X  s local work space. Alternatively, the programmer can also join an existing real-time collaborative programming session that is available in the sys tem . In the lower part of the right panel in Figure 6 , a list is displayed to show all existing real-time sessions that are available for this programmer to join. In this figure, there are three real-time se s-sions that are available at the moment: (1) RS -SimpleCalculator-Chengzheng , which is a real-time session for the project named SimpleCalculator created by the programmer named Chengzheng ; (2) RS -AdvancedSearch-Yuqing , which is a real-time session for a different project named AdvancedSearch created by another pro-g rammer named Yuqing ; and (3) RS -OTXplorer-Xuyi , which is a real-time session for another project named OTXplorer created by a programmer named Xuyi . By simply choosing the collabo ration mode in the right panel, the corresponding collaboration session is created or joined, leading the user to the programming work. Figure 7 presents the main user interface of the ATCoEclipse Client when a programmer is con ducting programming work in a real-time collaboration session. Similar to the sin gle-user Eclipse IDE , ATCoEclipse  X  s programming interface contains a package explorer as shown in the left panel , but additional real-time co l-laboration features have been embedded: when the programmer issues any operation in the package explorer to create, delete or rename a directory or file, this operation is instantly propagated and replayed at all other active sites within the same real-time session. Similarly, other session members  X  changes to the source code tree are also performed in this package explorer in real-time. Figure 7 . Main user interface of the ATCoEclipse Client. In the middle panel, the source code editor looks almost the same as the single-user Eclipse source code editor, but many advanced real-time collaboration features have been embedded. First ly, the local programmer  X  s changes on the textual content of the source code file are instantly propagated to other active members in the same file session, and editing performed by other programmers in the same file session can also be noticed at this site in real-time. While programmers are concurrently editing the same source code file in a flexible and unconstrained way, consistency of the source code is maintained by underlying techniques at all times. Second-ly, advanced collaboration awareness techniques devised in prior work [9] have been applied in the source code editor. As illustra t-ed, workspaces of different programmers are highlighted by di f-ferent background colors, so each programmer can intuitively see where and what others are doing in real-time, thus improving the communication and understanding among collaborators. In add i-tion to workspace awareness, ATCoEclipse also incorporates novel techniques related to dependency relationships among source code regions (e.g., methods/fields of the Java class) con-tributed in prior work [8] , which are applied to automatically derive dependency relationships among these regions (e.g., a method invok es another method, a method referenc es a field) and highlight depended regions of programmers  X  working regions. Fo r example, the local programmer ( Hongfei ) is working on the push method which references three fields ( int store [] , int max_length , int top ) of the class, and therefore all these regions are high lighted by the color assigned to the local user. Similarly, it can be watched that another collaborator ( Cheng zheng ) is working on the pop method, which references one field ( int top ). To differentiate the working region and depended regions with respect to a pro-grammer, a color bar is displayed to the left of the working region . indicate that it is currently referenced by both working regions of the two programmers, and they should pay attention to potential conflicts among their work. With these awareness features, pro-grammers not only see where others are working, but also intu i-tively understand the relationships among collaborators  X  working regions to help avoid producing incompatible programming work. In the right panel of the ATCoEclipse Client, important collabor a-tion-related information is displayed, including the current co l-laboration mode (real-time/non -real-time), the session name, and the owner of the session. More importantly, the lists of collabor a-tors in the same file session and the same project session are di s-played respectively, which are d ynamically updated when a new client join s the session or an existing active site leaves the session. A unique color is assigned to each collaborator in the lists, which is used for highlighting the working region and depended regions in the source code editor, as introduced above. In the lower part of the right panel, the programmer may click a button to switch between real-time and non-real-time collabor a-tion modes, thus achieving seamless transition among different collaboration modes. The version control operations (SVN update and SVN commit ) are also provided for real-time collaborating programmers to enjoy close interaction with non -real-time collab-orators. A notification box is placed below to deliver collabor a-tion-related messages (e.g., who joins or leaves the session, who commits the latest source code copy to the SVN repository on behalf of the group). The notification box is also integrated with instant chatting features so that collaborating programmers can conduct real-time communication in case of need. In summary, programmers can wo rk with the ATCoEclipse sys-tem by using familiar functionalities and interface feature s that were available in the single-user Eclipse IDE, while in the mean-time, enjoying novel any-time collaboration features. Th e successful implementation of ATCoEclipse has validated the feasibility of ATCoPE. Preliminary performance evaluation has confirmed that the ATCoEclipse system achieves high perfo r-mance in several aspects. First ly, the local responsiveness of the client is as good as the single-user Eclipse IDE due to the repl i-cated architecture for the shared source code copy. Second ly, the propagation of editing operations to remote collaborating sites has been very efficient as well because most communication messag-es (e.g., editing operations, join-protocol messages) are less than 1 kB in size, which can reach inter-continental remote sites no r-mally within a delay of 100ms. Third ly, a global synchronization procedure (e.g., join-protocol) involves a maximum of three sin-gle-trip messages, which can be transmitted with in a total delay of less than 300ms (100ms for each single-trip). Fourth ly, transmi s-sion of the entire source code copy for a project can be costly, depending on the total size of the pro ject, but this occurs only when a new user joins a real-time session or a real-time collabo-rating programmer issues a non-real-time version control oper a-tion ( update or commit ) on behalf of the group, which is infr e-quent. Last but not least, ATCoEclipse is scalable, which is able to accommodate a large number of collaborating programmers for large-scale software projects, because: (1) most of the heavy work in either real-time or non-real-time collaboration sessions can be completed at individual and separated AT CoE clip se Clients; and (2) the ATCoEclipse Server has been designed and implemented to maintain administrative information and data only for active real-time sessions, without involvement in keeping track of non-real-time sessions and users or in performing real-time work, except for relaying real-time editing operations and communic a-tion messages via the session manager. In this paper, we have contributed a novel Any-Time Collabora-tive Programming Environment (ATCoPE) in seamlessly integra t-ing and supporting both real-time and non-real-time collabo rative programming . Major contributions include the ATCoPE system architecture, functional design for ATCoPE, techni cal solutions for realizing ATCoPE, and the design and implementation of the ATCoEclipse prototype system as a proof-of-concept for ATCoPE. The prototype implementation and preliminary performance eva l-uation have confirmed the technical feasibility of ATCoPE and its supporting techniques, and provided positive feedback on the performance and scalability of the system. This research work has initiated a new direction in the domain of collaborative software development, and laid foundations for explo ration of a range of interesting issues. Our ongoing work focuses on extending the functionalit ies of the ATCoEclipse system for conducting usabi l-ity study, which will be reported in future p apers. [1] Allen, L., Fernandez, G., Kane, K., Leblang, D. B., Minard, [2] Berliner, B. CVS II: Parallelizing Software Development. In [3] Blackburn, J . D., Scudder, G. D., and Van Wassenhove , L. N. [4] Blackburn, J., Scudder, G ., and Van Wassenhove , L. N. [5] Brooks, F. P. The Mythical Man-Month (Anniversary Ed.) . [6] Cockburn, A. and Williams, L. The costs and benefits of pair [7] Collins-Sussman , B. The subversion project: buiding a better [8] Fan , H. and Sun, C. Dependency-based automatic locking [9] Fan , H. and Sun, C. Achieving integrated consistency [10] Goldman, M., Little, G ., and Miller , R. C. Real-time collabo-[11] Loeliger , J. Version Control with Git: Powerful Tools and [12] Nosek, J. T. The case for collaborative progra m-[13] Perry, D ., Siy, H., and Votta , L . Parallel changes in large-[14] Pilato, C., Collins-Sussman, B., and Fitzpatrick, B. Version [15] Salinger, S., Oezbek, C., Beecher, K., and Schenk, J. Saros: [16] Shen , H. and Sun., C. Flexible notification for collaborative [17] Shen , H. and Sun, C. Recipe: a web-based environment for [18] Sun, C. and Ellis, C. Operational transformation in real-time [19] Sun, C., Xia, S., Sun, D., Chen, D., Shen, H., and Cai, W. [20] Tichy, W. F. Tools for software configuration management. [21] Williams , L. A. and Kessler, R. R. All I really need to know [22] Williams, L., Kessler, R. R., Cunningham, W., and Jeffries, 
