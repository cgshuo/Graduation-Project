 The increasing number and size of XML documents require efficient techniques for querying and updating the content and structure of XML data stored in databases. To acceler ate query processing , databases use secondary index struc-tures, which provide a search function to select nodes without scanning all data. Each entry in an index consists of a list of index keys, specifying the search con-dition, and the nodes to be returned by the search function. Incremental index maintenance refers to the process of determining which index structures need to be updated with which index entries when updating document fragments.
State-of-the-art indexing approaches (cf. [1]) mostly consider primary index structures that can be updated with speci fic maintenance algorithms. To adapt indices to the query workload, an XML database however requires various sec-ondary index structures, e.g. b-trees and multidimensional indices. To reduce the index size, the database needs to support indices on arbitrary document fragments instead of on whole documents only. This implies that update frag-ments need not correspond to indexed fragments and thus do not necessarily contain all nodes required for index mai ntenance. To incremen tally maintain in-dex structures, either (i) each index structure maintains required nodes in an auxiliary data structure, or (ii) a generic maintenance algorithm extracts index entries directly from update fragments and decouples the generation of index entries from the index structures as such. The approach presented in this paper follows approach (ii) as it is widely applicable and does not need to persist and maintain auxiliary data structures.
 Example 1. As running example, an XML database storing conference proceed-ings is used. The sample document of Fig. 1 consists of four fragments (a-d), which are connected via dashed lines . The name and the number associated with each node uniquely identify the node. Figure 2 depicts a sample index defi-nition, represented as a tree pattern. Symbol $ K V indicates to use the value of a node as index key. Symbol R specifies which nodes to return by the index. Single lines represent parent-child edges, doubl e lines are used for ancestor-descendant edges. The index selects papers (return R) by specifying their title and their au-thors X  last name (index keys K). Each index entry can be written as [(K)  X  R]. Assume that we successively insert fragments (a-c) into the database. The inser-tion of fragment (a) does not affect the index. The insertion of fragments (b) and (c) triggers the insertion of the index entries [( X  XML Index  X ,  X  Kim  X )  X  paper1 ] and [( X  XML Index  X ,  X  Miller  X )  X  paper1 ], respectively. Note that fragment (c) misses the title which is required to create the index entry.
 This paper proposes a novel algorithm to extract index entries from update fragments based on index definitions. Index definitions uncouple the algorithm from specific index structures. They are represented as tree patterns to support indices on arbitrary document fragments selected by an arbitrary index defin-ition language, e.g. with the XPath fragment { /, //, *, [] } . The main idea of the algorithm is to find embeddings of index patterns in update fragments and then generate index entries from these embeddings. By exploiting the structure of the update fragment, the proposed algorithm minimizes the number of ad-ditional queries without relying on auxiliary data structures. It only needs to retrieve those nodes from the database that are required for indexing but are not contained in the update fragment. If all index entries can be inferred from the update fragment, the algorithm is completely self-maintainable. The update of index structures with index entries is not subject of this work, as there exist specific algorithms to update the index structures as such. The developed tech-niques are not restricted to index mai ntenance, but can be carried over to the maintenance of caches, views or related problems.

The paper is structured as follows. Sect ion 2 reviews related work and Sect. 3 defines update fragments, index patterns and embeddings of patterns in docu-ments. The maintenance algorithm is pres ented in Sect. 4 and analyzed in Sect. 5. Section 6 concludes the paper. Relational databases define indices on columns of relations and simply need to update an index when the values of a tuple change. Object-oriented databases use specific index structures for efficient navigation along aggregation hierar-chies, i.e. nested index and multi-index [2]. When one of the objects changes, all objects on the indexed path are required for performing the update operation. For this purpose, the index structures maintain the relevant objects in an aux-iliary data structure. Various native XML databases [3] integrate indices into query processing. They support simple structural and value indices but cannot index nodes along multiple axes, e.g. for multidimensional indexing.
To the best of our knowledge, only the approach of Hammerschmidt et al. [4] supports incremental index maintenance based on more complex XML index definitions. The algorithm decomposes each index definition into a set of lin-earized path expressions and matches them with each updated node. If the path of an updated node intersects with a path of an index definition, queries on the remaining paths of the index definition are executed to retrieve all nodes that constitute an index entry. As the algorithm processes each updated node indi-vidually, it may generate the same index entry several times, which may lead to inconsistencies, and executes a large number of source queries (cf. Example 2). Example 2. Assume that the index of Fig. 2 is updated with fragment (d) of Fig. 1. The algorithm generates the index entry [(  X  , X  Kim  X )  X  paper2 ] twice, once for node paper2 and once for node last4 . The algorithm executes source queries to retrieve the remaining index keys and/or the return of the index entries. The update however only affects one entry and would not require any source query as all index entries can be inferred from the update fragment. Maintaining XML views is closely related to maintaining XML indices since views also need to be updated when documents change. Existing approaches on XML view maintenance either only suppor t updates containing all relevant nodes (e.g. [5]) or maintain relevant nodes in an auxiliary data structure (e.g. [6]).
Pattern matching (e.g. [7]) and tree inclusion (e.g. [8]) algorithms find embed-dings of query patterns in XML documents. XML filtering techniques (e.g. [9]) evaluate queries on XML documents on-the-fly. This work applies ideas of these query processing techniques to index mai ntenance. The main differences are that the index maintenance algorithm needs to (i) find embeddings in update frag-ments instead of in whole documents, (ii) issue source queries if the fragment misses nodes which are required for indexing, (iii) associate the index keys with the nodes to be returned and generate index entries. The main idea of our approach is to find embeddings of index patterns in up-date fragments and then generate index entries from these embeddings. Each embedding consists of nodes in the document that structurally correspond to the index pattern and represents an index entry. Before describing embeddings in more detail, we define update fragments and index patterns.
 A document D is an ordered tree of nodes N D connected via directed edges F
D , D =( N D ,F D ). Each node is identified by a unique node id, returned by function nid . Function label returns the name of a node. Leaf nodes may have associated a value. Function root returns the root node of a document. The parent of n is the node whose edge leads to n .The children of n are all nodes whose edges emanate from n .The descendants of n correspond to the transitive closure of the children of n ,the ancestors function is its inverse. The path of n is the sequence of nodes and edges from the root to n . Function labelpath of n applies function label on each node of the path of n and returns the sequence of node names and edges that connect the nodes. A schema is a structural summary consisting of all distinct labelpaths of a document. Note that generating a schema does not require a schema file in form of a DTD or an XML Schema.

Adocument fragment D F is a subtree of D consisting of a node n  X  N D , which is the root of D F , plus all descendants of n in D .An update fragment consists of the nodes that are either ins erted into or deleted from a document. Modifications can be executed as a deletion followed by an insertion. The update operation specifies the location of the update fragment, i.e. the path from the root of the document to the root of the update fragment. This implies that the labelpath of each node in the update fragment is known.

An index I consists of a set of index entries, I =( E I ). Each index entry maps a list of index keys K to a list of nodes R  X  N D , which are identified by their property of a node that can be indexed (e.g. its value or type). While the index entries of an index contain all nodes belonging to certain index keys, each index entry of an update operation only consists of one node and its index keys. This node is then either inserted into or deleted from the index entry of the index having the same keys. The number of index keys of an index entry determines the dimensionality of the index. A multidimensional index may allow one or several (but not all) index keys to be null, represented as  X  .An index structure is the specific data structure used t o represent an index, e.g. a b-tree.
An index pattern P represents an index definition in a language-independent way. It is an unordered tree of pattern nodes N P connected via parent-child (/) or ancestor-descendant (//) edges F P , P =( N P ,F P ). Each pattern node has a name, which is either a concret e name or a wildcard (*), and may have associated index variables. Index variables $ K determine which properties of a node to use as index keys. The order of index variables in the index definition determines the order of index keys in an index entry. Each index pattern consists of one distinguished pattern node specifying the return value R of an index entry. We assume that each index is defined on one document, but the approach can easily be extended to document collections. We define the same functions on a pattern as on a document. If any pattern node has more than one child, the patterns is called a twig index pattern , otherwise it is referred to as path index pattern .

Nodes of a document that structurally correspond to the pattern nodes of a pattern are referred to as embedding. Formally, an embedding of a pattern P =( N P ,F P )inadocument D =( N D ,F D ) is a mapping from N P to N D , emb : N (ii) if x/y  X  F P  X  emb ( x )= parent ( emb ( y )), (iii) if x//y  X  F P  X  emb ( x )  X  ancestors ( emb ( y )). The nodes of an embedding are called matching nodes .The pattern nodes that match a node are referred to as matching pattern nodes . The proposed algorithm consists of three steps: (1) find embeddings of patterns in update fragments, (2) query required nodes that are missing in the fragment and (3) generate index entries from the embeddings. The index entries are then forwarded to the affected index structures, which update their data structure with proprietary algorithms. Insertions and deletions can be handled analogously as they only differ in the update operation executed on the index structure.
The algorithm uses an intermediate data structure to compactly store the nodes of an embedding up to the time of generating index entries. The data structure resembles the one used in pattern matching algorithms (e.g. [7]) and associates with each pattern node a stack. Each entry in a stack consists of a node of the document and a pointer to its ancestor node in the stack of the parent pattern node, encoding the structural relationships between the nodes. Example 3. Figure 3 visualizes embeddings of a pattern in a document and Fig. 4 represents these embeddings in the intermediate data structure. The data structure encodes the embeddings ( conference1 , paper1 , title1 , last2 ), ( conference1 , paper1 , title1 , last3 )and( conference1 , paper2 ,  X  , last4 ). Step 1 -Find embeddings. To find embeddings of an index pattern in an update fragment, step 1 of the algorithm traverses the fragment once in docu-ment order. If a fragment is relevant, the algorithm matches its root with the pattern and puts it onto the stacks of matching pattern nodes. It then recursively processes the children of the root. Nodes of a fragment that is not relevant are not further processed. The details of step 1 are shown in Algorithm 1.
Procedure relevant determines whether a fragmen t is relevant for a pattern by comparing the labelpath of its root with the labelpaths of the pattern nodes. Procedure match finds matching pattern nodes for a node (cf. embedding in Sect. 3). Procedure addToStack puts the node onto the stack of each matching pattern node. Additionally, it creates a pointer from the node to the previously added node in the parent stack to connect the node with its ancestor. Algorithm 1. Find embeddings of a pattern in a fragment
The first two procedures can benefit fro m schema information by associating with each pattern node the matching labelpaths of the document. It is then possible to pregenerate (i) a list of labelpaths that are relevant for a pattern, (ii) a map from labelpaths to matching pattern nodes. The algorithm then does not need to compare each node with each pa ttern node but can directly determine whether a fragment is relevant as well a s matching pattern nodes for a node. Example 4. When updating the index of Fig. 2 with the document of Fig. 1, the algorithm proceeds as follows (cf. Fig. 3 and 4). Node conference1 matches pattern node conference . The fragment rooted at proceeding1 is relevant, but its root does not match a pattern node. With a schema, the algorithm can exclude that an editor has a paper as descenda nt and need not process this fragment. The fragment rooted at paper1 is relevant and its root matches pattern node paper . The algorithm performs the same steps on the remaining nodes. The algorithm can be extended in several ways (details are omitted for space reasons): (i) Each embedding requires a matching node for the pattern node specifying the return. Also other pattern nodes may be marked as required or may specify properties that matching nodes must fulfill. To improve space com-plexity, the algorithm should not keep partial embeddings for which required nodes cannot exist in the intermediate data structure. (ii) In case of a large number of index patterns, the algorithm should avoid matching the same sub patterns multiple times by pattern sharing.
 Step 2 -Execute queries. To retrieve the nodes that are part of index entries but not contained in the update fragment, the algorithm recursively processes the pattern nodes in a postorder traversal to query missing ancestors. When adding an ancestor to a pattern node, the algorithm recursively traverses its child pattern nodes in a preorder traversal to query missing descendants. Example 5. When updating the index of Fig. 2 with fragment (c) of Fig. 1, step 1 of the algorithm associates node last3 with pattern node last . Starting from this pattern node, the query execution algorithm retrieves the corresponding paper ( paper1 ) and its title ( title1 ).
 The algorithm can also be used to ret rieve all embeddings from a document when creating or deleting an index on an existing document. The efficiency of this step can be improved with labeling schemes that allow for navigating along certain axes without accessing base data. The update of whole documents is always self-maintainable as no queries are executed. A schema-aware labeling scheme (e.g. [10]) also makes the update of path patterns self-maintainable as it allows for navigating to ancestors without source queries.
 Step 3 -Generate index entries. To generate index entries, the algorithm extracts the embeddings from the intermediate data structure (cf. [7]). The index entries need to be inserted into the index structure in case of an insert operation, and deleted in case of a delete operati on. Special attention needs to be paid when an update operation adds/removes keys to/from existing index entries in a multidimensional index. These keys always stem from the nodes that have not been queried and either replace null values when executing an insert or generate null values in case of a delete operation.
 Example 6. The first embedding of Example 3 is converted into the index entry [( X  XML index  X ,  X  Kim  X )  X  paper1 ]. Assume that we add a title to the second paper and update the sample index. The existing index entry [(  X  , X  Kim  X )  X  paper2 ] then needs to be modified, i.e. the null value needs to be replaced with the new title  X  XML Index  X . We benchmarked our approach (a) of exploiting the structure of update frag-ments against the approach (b) of updating individual nodes (cf. Sect. 2, [4]). As sample dataset, we genera ted three fragments (cf. Fig. 1): (i) a proceeding with 100 papers, (ii) a paper and (iii) an author with a last name. When updating the sample index of Fig. 2 with fragments (i) and (ii), approach (b) generates each index entry twice and executes a large number of source queries. Matching whole fragments makes our approach 9 times faster, as it does not issue any source queries when updating the index with these fragments. Both approaches perform equally for fragment (iii), which only contains one relevant node. We presented an algorithm to extract index entries from update fragments. In-dices are represented as index patterns to handle arbitrary index structures defined on arbitrary document fragments. The algorithm (1) finds embeddings of index patterns in update fragments, ( 2) executes queries if nodes are required for indexing that are not part of the update fragment, (3) generates index entries from the embeddings and forwards them to affected index structures. By exploit-ing the structure of update fragments, the algorithm minimizes the number of source queries, resulting in a n improved update performance.

