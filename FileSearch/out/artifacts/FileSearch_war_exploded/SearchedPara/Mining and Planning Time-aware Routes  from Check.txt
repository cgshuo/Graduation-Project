 Location-based services allow users to perform check-in actions, which not only record their geo-spat ial activities, but also provide a plentiful source for data scientists to analyze and plan more accurate and useful geographical recommender system. In this paper, we present a novel Time-aware Route Planning (TRP) problem using location check-in data. The central idea is that the pleasure of staying at the locatio ns along a route is significantly affected by their visiting time. Each location has its own proper visiting time due to the category, objective, and population. To consider the visiting time of locations into route planning, we develop a three-stage time-aware route planning framework. First, since there is usually either noise time on existing locations or no visiting information on new locations constructed, we devise an inference method, LocTimeInf , to predict and recover the location visiting time on routes. Second, we aim to find the representative and popular time-aware location-transition behaviors from user check-in data, and a Time-aware Transit Pattern Mining (TTPM) algorithm is proposed correspondingl y. Third, based on the mined time-aware transit patterns, we develop a Proper Route Search (PR-Search) algorithm to construct the final time-aware routes for recommendation. Experiments on Go walla check-in data exhibit the promising effectiveness and efficiency of the proposed methods, comparing to a series of competitors. H.2.8 [ Database Management ]: Database Applications  X  Data Mining . Algorithms, Performance, Design. Time-aware routes; time-aware transition patterns; visiting time; route planning; check-in data Nowadays, location-based services (LBS), such as Foursquare and Gowalla, keep track of personal geospatial journeys through check-in actions. With smart p hones, users can easily perform check-in actions, and the geographi cal information of locations with timestamps is stored in LBS. Eventually a large-scaled user-generated location sequenc es (i.e., routes) data are derived. Such location sequence data can not only collectively represent the real-world human geo-activities, but also serve as a handy resource for constructing location-based reco mmendation systems. Since the user-moving records implicitly re veal how people travel around an area with rich spatial and temporal information, including longitude, latitude, and recording timestamp, one reasonable application leveraging such user-generated location sequence data is to recommend travel routes. Existing work on trip planning [10][21][17] consider either the shortest geodesic distance or the shortest time period to recommend routes. On the other hand, location recommendation [10][21][22] aims to recommend new locations that the user has never visited before, while location prediction [15][12][20] focuses on predicting the next existing locations that the user had ev er visited. Although there are a number of studies on geo-social recommendation, the pleasure of visiting locations in terms of time is never investigated. Figure 1: The distributions of the visiting probability at each time unit (hour) of four locations in New York City from Gowalla check-in data. In this paper, we aim to explo it the visiting time information of locations to recommend routes for users. The central idea lies in that the pleasure of visiting pla ces along a route is significantly diminished if arrived at the wrong time. Some places have a wider range of visiting time period while others are constrained to certain particular time slots. For example, most people do not want to visit a beach during the boiling hot noon, but rather arrive in the late afternoon to enjoy the sunset scene. Or certain ball game events usually take place at particular time period (e.g. in the evening). As shown in Figure 1, some place has better chance to be visited at certain time sl ots. For example, people visited Empire State Building from about 12:00 to the mid night (note that this place is famous for its excellent night view), in contrast, the proper time to visit Central Park is during daytime, and the Madison square garden have a few visiting peaks of ball games. In this paper, we propose a novel Time-aware Route Planning (TRP). The goal is to find a time-aware route based on the user query, consisting of a starting locat ion, a starting time, and/or a destination location. The time-aware route is a sequence of locations, in which each location is associated with a visiting time label that is supposed to be the most proper time to visit such location. All the locations vis ited at the given time along the desired route should be proper or satisfied by users. To achieve the proposed time-aware route pla nning, we develop a three-stage route planning framework to tackle diverse challenges and tasks about time-aware routes. The first stage aims to infer the visiting time labels of locations in routes. The second stage is to mine the popular time-aware transition pattern s, which can be regarded as the representative route segments generated by users. The third stage is to compose the desired route based on the query. We elaborate the challenge, objecti ve, and idea of the proposed solutions of each stage in the following. Inferring Visiting Time. In the first stage, given locations in a certain route, we aim to infer its visiting time labels from check-in data. Acquiring the visiting time of locations can benefit a number of applications, such as location recommendation [22], location prediction [6], and measuring route quality [8]. However, it is difficult to derive the complete visiting time of locations. The reason is two-fold. First, the number of new locations or Point-of-Interests (POI) is rapidly generated due to new events, new buildings, attractions, even new de veloped areas, and so on. Such cold-start places provide no or only few records about the visiting information. What we have coul d be incomplete or less visiting time on new locations. Second, even if we have lots of location check-in records, the data tend s to contain noise and abnormal check-in behaviors. For example, one might perform check-in actions using Web interfaces, inst ead of mobile phones. The time recorded by the former manner might not be the immediate check-in time, but it does in the latter manner. In other words, we need to do data correction or manually a nnotate the data before usage, which are expensive and time-consum ing. Therefore, in the first stage of the proposed time-aware route planning, we aim to infer the visiting time of locations from incomplete check-in data. We assume the data used is partially time-labeled and only a small amount. That says, we have only limit ed time-labeled information while most of locations are unlabeled. We propose an inference framework, LocTimeInf , to infer the visiting time labels of locations in routes. Since what we can use is few time-labeled data (less than 1%), we leverage the concept of semi-supervised learning to devise the inference model. The idea is two-fold: (a) the visiting order of locations in a route implicitly reveals the time information, and (b) locations are temporally similar if they share similar geographical and contextual behaviors by users. Mining Time-aware Transit Patterns. In the second stage, given a collection of time-labeled routes, we aim to mine the time-aware transit patterns (TTP), which summarize the representative and popular trip segments created by users. A TTP is a sequence of locations, in which each transit between locations is associated with visiting timestamps. For example, an example TTP is &lt;(MMOA museum, Macy X  X  store, 0, 3), (Macy X  X  store, H&amp;M store, 3, 5), (H&amp;M store, Time Squa re, 5, 6)&gt;, which refers to that the sub-route consists of MMOA museum, Macy X  X  store, H&amp;M store and Time Square in order. And the pattern suggests that the staying time as well as the tr ansportation time between MMOA museum and Macy X  X  store is 3-0=3 hours, and so on. To mine TTPs, we propose the Route Transit Graph (RTG) to model the location transition behaviors in routes. RTG is a directed graph, in which e ach node represents for a lo cation and each edge stands for a transit from one location to the other. Each edge is also associated with a set of time intervals that record the durations of users X  location transitions. Each time interval consists of a starting timestamp and an arrival timesta mp. Considering the real-world traveling activities follow a cert ain reasonable periodic property, such as that each time users usually plan one-day routes when traveling, we construct each RTG within a day . By collecting RTGs over a certain range of days, a RTG transaction database can be constructed, and used to mine TTPs. We propose an efficient algorithm, Time-aware Transit Pattern Mining algorithm (TTPM), to mine the closed frequent Time-aware Transit Patterns from the RTG transaction database. TTPM exploits the closed pattern mining concept to reduce the number of frequent patterns during mining process so that th e time efficiency can be boosted and the memory usage can be well utilized. Time-aware Route Planning. In the final stage, we aim to find the time-aware routes based on query requirement. We allow users to input two kinds of queries: source query and source-destination query. Both include a starting location, a starting time, and the number of locations in th e desired route while the latter needs an additional destination location. We develop a time-aware route planning method, which consists of three parts. The first is to construct a Routable Map from the mined TTPs, which models the time-aware transitions between locations. In the second step, we devise a time-aware measure, Route Visiting Goodness (RVG), to determine whether the route with time labeled locations is proper to visit. Third, we develop an algorithm, Proper Route Search (PR-Search), to find the time-aware route such that the RVG score of such route is maximized. Route Planning. Recent work exploits complete time-labeled check-in data for location and tr ip recommendation. Yuan et al. develop a collaborative reco mmendation model [22] to recommend POIs for a given user at a specified time in a day. Hsieh et al. develop a TripRouter system [8] to construct time-sensitive routes, which consider location popularity, visiting order, proper visiting time, and proper tr ansit time to model the goodness of a route. Wei et al. [17] deve lop a route inference to construct the popular routes passing through a given location sequence within a specified time span. Sadilek et al. [15] predict the most likely location of an individual at any time, given the historical trajectories of his/her friends. Chiang [5] consider the current time to predict locations. They construct a Time-constrained Mobility Graph that captures a user X  X  movi ng behavior within a certain time interval, and compute the reachability between locations to infer next one. Lu et al. [10] develop the Photo2Trip system, which integrates a series of tr aveling factors (including time duration, season, user preference, destination type, and popularity) to recommend trip itineraries. To the best of our knowledge, we are the first to tackle time-aware route planning by check-in data. Location Recommendation and Prediction. The task of location recommendation (LR) is to recommend new locations that the user has never visited before while the task of location prediction (LP) focuses on predicting the next existing locations that the user had ever visited. For the LR task, Ye et al. [19] point out the importance of geographical influence , which refers to that people tend to visit (a) near-by locations and (b) may be interested in farther locations that they are in favor of, to recommend check-in locations. By combining user pref erence, geographical influence, and historical trajectories, Liu et al. [9] develop an integrated geographical probabilistic analysis framework to learn how these factors affect the performance of POI recommendation. Yuan et al. [22] propose a temporal POI recommendation to recommend suitable locations for a certain user at a specified time in a day, using a temporal-enhance collaborating filtering. For the LP part, Sadilek et al. [15] predict the most likely location of an individual at any time, given the historical trajectories of his/her friends. Monreale et al. [12] predict the next location of a moving object with a basic assumption: people tend to follow common paths. Temporal Pattern Mining. When considering temporal pattern mining, sequential pattern mining is one of the traditional methods to mine frequently-occurring te mporal events or subsequences. The sequential pattern mining problem was first introduced by Agrawal et al. [2], who adopt a generate-and-test approach based on the Apriori method to mine frequent sequential patterns. SPAM [3] exploits a vertical bitm ap structure to count supports efficiently. PrefixSpan [14] uses the projected database to mine the complete set of patterns and to reduce the efforts of candidate subsequence generation. A frequent pattern is closed if there does not exist any super-pattern with th e same support. Yan et al. [18] propose CloSpan to mine closed sequential pattern s by candidate maintenance-and-test paradigm to prune the search space and check if a newly found frequent sequence is promising to be closed. Wang et al. [16] present the BIDE algorithm to improve the performance of CloSpan without keeping track of any frequent closed patterns (or candidates) for closure checking. SPADE [20] uses a vertical data format and a divide-and-conquer strategy to reduce the search space and the number of database scans. A (time-labeled) route is a sequence of time-labeled locations, denoted by r = &lt;( l 1 , t 1 ), ( l 2 , t 2 ), ..., ( l and t i is the corresponding time label in hour (i.e., 0, 1, 2, ..., 23). A time-unlabeled route is a route, in which the locations do not necessarily have the time labels associated. We also define the time-label ratio (denoted by  X  ) as the number of time-labeled routes divided by the number of time-unlabeled routes. Given a collection of routes with a certain time-label ratio, our goal aims to infer the visiting time labels for locations in such routes. Note that the time-label ratio  X  will be set to be less than 1% and be varied for the evaluation. To tackle the proposed time label inference problem, we devise a framework, LocTimeInf , which is a graph-based semi-supervised learning model. The framework consists of four steps: (1) constructing a Route-Correlated Graph ( RCG ) for each location to capture the temporal correlati on of such location in different routes, (2) using RCG to model the visiting time of locations in a time-labeled route, and (3) propagating and inferring the probability of a particular visiting time label for each location in a time-unlabeled route. For each location l i that appears in all n i routes (including both labeled and unlabeled), we construct a Route-Correlated Graph (RCG) to capture the temporal correlation for l i in different routes. The constructed RCG is a weighted connected graph with n in which some nodes have time la bels (i.e., those come from time-labeled routes) while others do not. Edge weights are derived considering the similarity between routes. The fundamental idea is that if two routes are more similar in geographical and contextual aspects, their time labels of location l i tend to be more correlated. Therefore, we give higher edge weights if two routes are more similar. The proposed route similar ity consists of three parts: (a) Location overlapping is the Jaccard coefficient on the location sets of two routes. If two routes share more locations, they will have a higher similarity score. (b) Position difference is the reciprocal of the maximum position difference of location l between routes, smoothed by adding one. If a location is visited at a relatively-close posit ion on two routes, the edge weight gets higher. (c) Geographical proximity is the average distance in geography over locations between routes. The geographical proximity is believed to model th e range of travels, which also implicitly reflect the difference of transportation time between routes. Higher proximity indicates lower transit time difference between routes. After normalization, we calculate the geometric mean of such three similarity scores and regard the value as the edge weight between routes of location l i in RCG. In addition, for each node in a RCG, we use a parameter  X  to retain  X  edges with top- X  highest weights so that the efficiency of the following inference algorithm can be boosted. RCG for Cold-Started New Locations. In the real-world cases, there might be new locations established in location-based services. New locations not only ha ve the visiting time labels, but also are rarely visited by the routes in the database. The cold start problem then happens because no time-labeled nodes can help the inference in RCG. We discover top-k auxiliary locations to deal with such case. The idea of selecting auxiliary locations for a new location l i is based on the route similarity scores between l the routes of candidate time-labeled locations. The detailed procedure of selecting top-k auxiliary locations consist three steps. First, we scan the database to find all the locations l geographically closed to l i within a certain geo-distance  X  . Second, we enumerate all the routes involved by l c , and compute their route similarity to l i . Finally, while k -RCGs are constructed from top-k auxiliary locations, we impose the RCG of l RCGs by constructed edges from each l i to all nodes in the k -RCGs, in which edge weights are associated as well. Note that the parameter  X  is also applied to remove insignificant edges here. A new auxiliary RCG of l i is then derived for the following inference. Based on the constructed RCG, we learn the visiting time label for each location in time-unlabeled routes, by devising a graph-based semi-supervised learning mechanism. The fundamental idea is to exploit Gaussian random fields t ogether with harmonic functions to relax the Boltzmann machines. Our goal is to optimize the loss function on the constructed RCG su ch that the labeled data are clamped, where unlabeled nodes that are nearby (i.e., connected by higher edge weights) would be given similar time labels. We where S i and S j is the sets of labeled and unlabeled nodes respectively. We design the objective function  X  X  X  X  X  X  X  X  such that it is harmonic. Th erefore, the harmonic property concludes that the value of function f at each unlabeled node is the average value over its neighboring nodes. We can then solve the minimum problem using combinatorial Laplacian  X  , which can be calculated through  X  = D -W , where D is the diagonal matrix, where  X   X   X   X   X   X  X  X   X  , and W is the weighted matrix. Since the harmonic solution process goes beyond the scope of this paper, please refer to Zhu et al. X  X  work [13] for details. Assume the RCG contains N nodes, in which N l are labeled, our goal is to infer the probabilities that the location was visited for 24 hour units. The harmonic solution would generate ( N -N l )*24 label matrices for the unlabeled instances, in which each row is for an unlabeled node while each column is for a cl ass label (i.e., hour). The hour with the highest probability value is regarded as the predicted time label for the unlabeled instance. We have derived the time labels for each location l i in each time-unlabeled route. The next step is to refine the time label with the probability for each l i , considering the visiting order of locations in a route. The idea is that us ers usually tend to visit locations with the most proper time and order. Therefore, given a time-unlabeled route with location sequence &lt; l 1 , l find the corresponding time la bels with probabilities p p such that  X   X   X   X  X  X  X .. X  is maximized. Such goal is constrained by the fact that the visiting time of the ( i-1) th should not be later than the visiting time of i th one. We adopt the dynamic programming technique to determine such probabilities. The proposed algorithm consists of two stages. First, we mine all frequent patterns of length one (denoted as 1-patterns) from the database. For each frequent k -pattern ( k  X  1), denoted by P , we build a projected database. Then we scan its projected database to find the local frequent 1-patterns e which is connected with P . For each e , we concatenate P with e to form a frequent ( k +1)-pattern. The concatenations are recursively performed in a depth-first search manner until no more fre quent closed patterns can be found. In the meanwhile, we devise the closure checking and pruning strategies to reduce unnecessary candidates so that the closed frequent Time-aware Transit Patterns can be efficiently mined. We represent the transition behaviors of users between check-in locations using the proposed Route Transit Graph (RTG). A RTG where V is a set of vertices, and E is a set of directed edges, ( i , j )  X  list of timestamps. Thus, an edge can be presented by a 4-tuple, ( s , d , t s , t e ), where s and d are vertices, and t the source location, and t e is the arrival time of the destination. For example, the transit edge from location L 1 to L 2 during timestamp [14, 16] (unit: hour) is represented by ( L 1 , L 2 , 14, 16). Considering a graph database DB containing n RTG graphs, DB = { g g edges by the associated timestamps and transform the graph into an edge sequence.
 Definition 1. (Edge Order). Let  X  =( s 1 , d 1 , t t , t e2 ) be two edges in a graph.  X  &lt;  X  if (1) t s1 t &lt; t e2 , (3) s 1 &lt; s 2 , t s1 = t s2 , and t e1 and t e1 = t e2 . Definition 2. (Edge Containment). A transit edge  X  = ( s t ) is contained by another edge  X  = ( s 1 , d 1 , t t  X  t e2 , denoted as  X   X   X  . For example, if  X  = ( L 1 , L L , 0, 3),  X  is contained by  X  . Definition 3. (Time-aware Transit Pattern). A Time-aware Transit Pattern (TTP) is defined as &lt;( s 1 , d 1 , t are sorted in an ascending order. A TTP should satisfy route connected constraint , which is defined in Definition 4. Definition 4. (Route Connected Constraint). A route transit sequence &lt;( s 1 , d 1 , t s1 , t e1 ), ( s 2 , d follows route connect ed constraint if  X  s i  X  { s always find an edge ( i, j ) whose i &lt; j , and d says, such route is required to be represented as a connected graph. Definition 5. (Pattern Length). The length of a pattern is defined as the number of edges. A pattern of length k is called a k -pattern. Definition 6. (Pattern Existence). A pattern &lt;( ps 1 , pd ( ps 2 , pd 2 , pt s2 , pt e2 ), ..., ( ps m , pd m , pt graph &lt;( gs 1 , gd 1 , gt s1 , gt e1 ), ( gs 2 , gd gt en )&gt; if there exists a sequence of integers j pu = gu ji , pl i = gl ji , pv i = gv ji , pt si  X  gt sji 1, 2,..., n . Since a pattern may contain many edges, discovering all such patterns would be lack of effi ciency and not useful for route planning applications. Therefore, we define some constraints to reduce unnecessary ones. For example, P =&lt;( L 4 , L 9, 10)&gt; is not helpful since the time span between two edges are too large. The user may only be interested in the patterns whose time spans are within a certain time interval. Therefore, we define a maximum time-span threshold maxgap , in Definition 7. Definition 7. (Timespan Threshold: maxgap ). The timespan between two edges ( s i , d i , t si , t ei ) and ( s k  X  t ei |. We aim to mine the patterns which follow the maxgap find another edge e i from e 1 to e k-1 that make | t where maxgap is a user-specified threshold . Note that t sometimes larger than t sj due to the flexible route construction. Definition 8. (Super-pattern). A pattern &lt;( ps 1 ( ps 2 , pd 2 , pt s2 , pt e2 ), ..., ( ps m , pd m , pt sm another pattern &lt;( qs 1 , qd 1 , qt s1 , qt e1 ), ( qs qd n , qt sn , qt en )&gt; if there is a sequence of integers j that ps i = qs j , pd i = qd ji , qt si  X  pt sji  X  pt i =1,..., n . Definition 9. (Pattern Support). The support value of a pattern P , denoted by sup ( P ), is defined as the number of RTG graphs containing P in the database. Definition 10. (Frequent Pattern). A pattern P is frequent if sup ( P ) is not less than minsup , where minsup is a user-specified minimum support threshold. Definition 11. (Closed pattern). A frequent pattern P is closed if there is no super-pattern of P with the same support. Definition 12. (Prefix &amp; Postfix). Given a pattern P =&lt;( S t ), ( S 2 , D 2 , t s2 , t e2 ), ..., ( S m , D m , t D D called the postfix of P , 1  X  i  X  m.
 Definition 13. (Projected Database). The P -projected database, denoted as | X  X   X  , contains all postfixes of the graph possessing P in database DB , where P is a frequent pattern in DB . Definition 14. (Conca tenation Function). The concatenation of patterns P and Q is denoted as P  X  Q. For example, if P= &lt;( L We construct a TTP pattern tree to enumerate frequent patterns where each node represents a frequent TTP pattern, and the level at which the node is located represents the length of the frequent pattern. For example, the frequent 1-patterns are recorded at level 1 and the frequent 2-pattens are at level 2. Moreover, a pattern at level k is derived from the pattern of its parent node at level k-1 ( k  X  2). The root of the tree is labeled by  X  . To generate all frequent patterns, we scan the database on ce to find all frequent 1-patterns and build the corresponding projected database. Then the frequent 1-patterns are added to the level 1 of the TTP pattern tree . Then we recursively extend a frequent k -pattern P ( k  X  1) at level k to get its frequent super ( k+1 )-patterns in a depth-first search. To find the frequent super-patterns of P , we scan the projected database of P and find local frequent 1-patterns whose which are connected with P (i.e. the destination of P  X  X  k th edge is same as the source location of 1-patterns ), and the timespan between P and each frequent 1-pattern found is not greater than maxgap . For each frequent 1-pattern found q , we concatenate P with q to form a frequent ( k+1 )-pattern. During the growth process of TTP pattern tree , we adopt lemma 1 to remove the redundant patterns. Lemma 1. ( Same Projected Database Removal ) If P 1 is a super-pattern of P 2 and both share the same projected database, P be removed from TTP pattern tree. We have generated many frequent TTP patterns. However, some generated patterns might not be closed. To eliminate to redundant patterns, we devise two closure checking and pruning strategies to check whether or not a new generated frequent pattern is closed. Lemma 2. (Forward Redundant Checking Scheme ) A pattern P is not closed if ther e exists a frequent 1 -pattern e in P X  X  projected database, whose support is equal to P X  X  support, and e is connected with P. Lemma 3. ( Backward Redundant Checking Scheme ) A pattern P is not needed to grow if there is a frequent 1 -pattern e before P , whose support is equal to P X  X  s upport, the timespan between e and P is not greater than maxgap, and e is connected with P. We find all frequent 1-patterns in the projected database, where the timespan between P and each frequent 1-pattern found is not greater than maxgap . We describe the proposed TTPM algorithm, which contains a sub-procedure, TTP-Growth. TTPM first scans the graph database once to find all frequent 1-patterns and builds the projected database. For each frequent 1-pattern P , if the frequent 1-pattern P passes the forward redundant checking scheme , we add P to TTP in step 4-6. We use the backward redundant checking scheme strategy to check whether a frequent pattern needs to be grown or not. If this is the case, in step 7, we call the TTP-Growth sub-procedure, which grows a pattern P to find all closed super-patterns of P . In the TTP-Growth sub-procedure, from the projected database of P , we first find all frequent 1-patterns in step 1. For each frequent 1-pattern found q , if q is structurally connected with P , we concatenate P and q to form a new frequent pattern R and build its projected database in step 3-4. If R passes the forward and backward redundant checking schemes, we add R to TTP in step 5-7. Then, in step 8, we recursively call the TTP-Growth sub-procedure to generate all th e closed frequent patterns. Lemma 4. All patterns TTPM-generated are frequent and closed.
 Lemma 5 . TTPM can find all frequent closed patterns.
 Theorem 1. The time complexity of the TTPM algorithm is O ( n  X  l  X  p ) ,where n is the number of RTGs in the database, l the average length in a RTG, and p the number of frequent TTP patterns. Proof. In the worst case, every pattern generated needs to do ( n  X  l ) traces to count the local frequ ent edges to concatenate new patterns of next level. Assume the total pattern number is p in our database. Thus, the total size is no more than n  X  l  X  p . However, we must check each new pattern produced is closed or not. Assume | pa | is the average lengths of all patterns, all closure checking execution can be computed in time p  X  | pa |. Therefore, the total time of TTPM can be finished in O( n  X  l  X  p+p  X  | pa |). However, it is obvious that the execution time of p  X  | pa | is extremely less than n  X  l  X  p . Thus the time complexity of TTPM is O( n  X  l  X  p ).  X  We provide two general route-planning queries for users, source query and source-destination query , as defined in the following. Definition 15. ( Source Query ). The input consists of (a) the source/starting location Q s =( l s , t s ), where l s and the latitude of such location in check-in data, and t starting timestamp (e.g. 8A M), and/or (b) The number k of locations in the final route. Definition 16. ( Source-Destination Query ). The input consists of (a) the source/starting location Q d = ( l s , t the longitude and the latitude of such location in check-in data, t is the starting timestamp (e.g. 8AM), and l d is the destination/end location, and/or (b) the number k of locations in the final route. We develop a Time-aware Route Planning (TRP) method, which consists of three parts. First, we construct a Routable Map , which models the time-aware transitions between locations. Second, we propose a time-aware measure, Route Visiting Goodness (RVG), to determine whether the route with time labeled locations is proper to visit. Third, we develop the Proper Route Search (PR-Search) algorithm, to generate final routes. We construct the routable map to model the representative transition behaviors between locations in check-in data. Routable map will be used in the proposed Proper Route Search to guide the generation of final routes. T echnically, the routable map is a directed graph  X  X  X  X  X   X   X ,  X   X  , in which each node  X  X  X  location and each edge  X  X  X   X  is a transition between locations. In addition, each node is associated with a set of time labels which represents when users had ever visited here. We use the mined time-aware transit patterns to cons truct the routable map. Given a set of TTP patterns, the constructi on of routable map consists of three steps. First, we create nodes for each location that appear in TTPs. Second, for each transition in each TTP, we construct a directed edge that connects the source to the destination location in the routable map. Third, for each location in the routable map, we find a set of the correspondi ng time labels occurring in the transitions of TTPs, and associate such set with the location. We devise a novel time-aware measure, Route Visiting Goodness (RVG) score, to determine whether it is proper for users to visit places along a route with given visiting times. The RVG consists of two parts: (a) measuring the pl easure of visiting a location at a given time, and (b) measuring the ex tent of pleasure when using a given transition time between two locations. We first define the visiting time distribution of a location and the transition time distribution between locations, wh ich can be derived using the inferred time labels in those routes containing l i . Definition 17. ( Visiting Time Distribution ). A Visiting Time Distribution (VTD) of location l i is a probability distribution over time labels in hour, denoted by VTD li ( t ) = &lt;( t p ), ..., ( t 23 , p 23 )&gt;, where p 0 + p 1 + ... + p Definition 18. ( Transition Time Distribution ). We define the Transition Time Distribution (TTD) between location l the probability distribution over time duration  X  in hour, TTD = &lt;(  X  1 , p 1 ), (  X  2 , p 2 ), ..., (  X  23 , p 23 Here we elaborate the details of VTD measure. Note that the measure of TTD follows the same details. Assuming we want to know how well a decision is to visit a place at time  X  , given the location X  X  VTD , we propose to first generate a thin Gaussian distribution  X , X ; X  X  X   X   X  whose mean value  X  is at time  X  with a very small variance  X   X  (e.g. standard deviati on is 1). And then we can transform the original task into measuring the difference between the Gaussian distribution with the learnt VTD of such location. Here we use the symmetric Kullback-Leibler ( KL ) Divergence between  X , X ; X  X  X   X   X  and  X  X  X   X   X  X  X  X  to represent the fitness of the assignment. The formal mathematical definition of a fitness score between a place l and a time t can be defined as: Conceivably, a smaller KL value indicates better match between the assignment and the distribution learned from data. Consequently, we form ally define the Route Visiting Goodness score, RVG ( s ), of a route r =&lt;( l 1 , t 1 combination of the popularity of places together with the fitness of each location over time, in the following equation. where  X  X  X   X   X   X   X   X  X  X  X  X   X   X / X   X  X  X  X  ,  X  X  X   X   X  is the number of recording actions performed on location  X   X  , and  X   X  X  X  X  is the maximum number of recording actions am ong all the locations in the location sequence data. In addition, the parameter  X  is used to control the preference or importan ce on either proper visiting time or proper transition time. Higher  X  values refer to prefer the visiting quality on locations while lower  X  values indicate the route should be strictly scheduled based on regular transportations. If the places in a route s are visited during the proper time period, the  X  X  X   X   X   X  value would become higher. Given either the source query Q s = ( l s , t s ) or the source-destination any, we propose Proper Route Search (PR-Search) algorithm to generate the final routes for recommendation. The PR-Search is based on the routable map an d the route visiting goodness. The fundamental idea is to find a directed path r = &lt;( l maximized. This proper route search problem with the route-planning query can be proved to be NP-hard. Due to the space limitation, we skip the proof. The PR-Search consists of three steps, and the detailed algorithm is described in Algorithm 3. We first construct the initial route  X  by including the starting location  X   X  (line 1). A  X  X  X  X  X  X  X  X  X  X  X  X  X  is used to maintain the route with the highest RVG score (line 2). Each element in  X  X  X  X  X  X  X  X  X  X  X  X  X  consists of a route  X  and the corresponding RVG score.  X  X  X  X  X  X  X  X  X  X  X  X  X  automatically sorts its elements according to their RVG scores. We add  X  the  X  X  X  X  X  X  X  X  X  X  X  X  X  . After setting the final route  X  one  X   X  (line 3), we perform the iterative expansion search process until the route  X  is constructed up to length  X  (line 5-13). For each iteration, the last location  X   X  X  X  X  X  in the route  X  with the highest RVG score is identified (line 6 and line 13) and each possible next visiting location  X   X  X  X  X  X  from the routable map H is put into a candidate set  X  (line 7). Then for each candidate next location  X  and for each time label  X   X  in the time label set  X  derive the score  X  X  X  X   X   X  X  X   X  X  X  X   X  X  X   X   X   X ,  X   X  X  X   X  . We put  X  X  X  X  X  together with the corresponding route  X   X  X  X  X  into  X  X  X  X  X  X  X  X  X  X  X  X  X  (line 8-12). The  X  X  X  X  X  X  X  X  X  X  X  X  X  will then pick the next best route and location to conduct the furthe r expansions (line 13). Finally (line 14), the route  X  is reported as the final generated route for recommendation. The time complexity of PR-Search depends on three parts: the number of search expansion  X  , the number of candidates of next locations | X | , the number of time labels of the next location  X | and the operation of the  X  X  X  X  X  X  X  X  X  X  X  X  X   X  X  X | X | X   X  X og X  , where  X  is the set of elements in the  X  X  X  X  X  X  X  X  X  X  X  X  X  . We can simply write down the complexity as  X  X  X  X  X  |  X  |  X | X   X  worst case, both the candidate set  X   X  of each next location and the number of search expansion could be all the locations in the routable map, while  X |  X  set of all locations in the database as  X  , the complexity is  X  X  |  X  |  X   X  X  X | X | X   X  X og for the worst case. We use a large-scale check-in data from Gowalla [6] for the experiments. This Gowalla datase t contains 6,442,890 check-in records from Feb. 2009 to Oct. 2010. The total number of check-in locations is 1,280,969. By cons training a route as a sequence of check-in locations of a user within a day, we can obtain 1,136,737 routes whose lengths are more than one and the average route length is 4.09. We extract two check-in subsets falling into the urban areas of New York and San Francisco. Some statistics are reported in Table 1. The experiments consist of three evaluation plans. The first is the evaluation on the inference of visiting time labels in Section 6.1. We aim to show the accuracy of the proposed LocTimeInf method under the setting of partially time labeled locations and the cold-start new locations. In Section 6.2, we evaluate the time efficiency of proposed TTPM algorithm, comp aring to two modified state-of-the-art methods. The third pl an is for the time-aware route planning, as reported in Section 6. 3. We aim to show the accuracy of the proposed TRP model for a route prediction task, comparing to a series of competitors. The effects of a series of parameters used in LocTimeInf , TTPM, and TRP are discussed. Note the in fact the experiments are also conducted on a large-scale Foursquare check-in data [4], and derive similar trends as Gowalla data. However, we do not repor t them due to the page limit. We design two evaluation tasks to evaluate the effectiveness the proposed LocTimeInf for inferring visiting time labels. The first is to test if the visiting time distribution (VTD), which can be derived from the inferred visiting time labels, on each location can be accurately inferred. We use the symmetric Kullback-Leibler ( KL ) Divergence , to measure the difference between the ground-truth VTD and the inferred VTD , the smaller the better. The average KL Divergence value over all unlabeled locations will be reported. In short, given a set of routes with a specified time-label ratio, we will show the KL difference between the ground-truth VTD ( l i ) and the inferred VTD X  ( l i ) for each location l The second task is to compute the accuracy of the inferred time labels. We define an accuracy measure, Hit Rate , as the number of successfully predicted check-in locations divided by the number of unlabeled check-in locations over all time-unlabeled routes. Higher hit rate indicates better inference quality. We set  X 7 X  . By varying the time-label ratio, we randomly select the time-labeled routes while the time labels of the remaining routes are removed (as the testing set) and regarded as the ground truths. The experiment is conducted on two data settings: the first is partially time-labeled data (contain few vis iting time), and the second is the cold-start new locations (c ontaining no visiting time). Partially Labeled Data. In this experiment, for KL , we develop two baseline methods: (a) normal distribution generates thin Gaussian distributions whose mean s locate at the most frequent check-in time in the labeled data. (b) We simply generate VTD s from the partially labeled data , which would serve as a strong baseline. For hit rate, the baseline chooses the most frequent check-in time label as the predicted one from partially time-labeled routes. Figure 2 and 3 shows the results. We can find LocTimeInf significantly outperforms the competitors in both cases, even when the time-label ratio is very low (e.g. 0.05%). Figure 2: Average KL divergence values for New York (left) and San Francisco (right) in partially labeled experiment. Figure 3: Hit rates for New York (left) and San Francisco (right), in partially labeled experiment. Figure 4: Average KL divergence values for New York (left) and San Francisco (right), in the cold-start experiment. Figure 5: Hit rates for New York (left) and San Francisco (right), in the cold-start experiment. Cold-start New Locations. We evaluate if the proposed auxiliary RCG can solve the cold start problem. Since new locations are assumed to have no time labels, the normal-distribution and labeled-data methods cannot be applied. We alternatively perform Spatial-KNN to select the top-k locations ( k =3 here) which has least geo-distances toward the new locations, and then apply the normal-distribution and labeled-data methods as the competitors. Figure 4 and 5 shows the results. We can find that the overall performance is worse than the previous experiment. However, the LocTimeInf still can not only outperform the competitors, but also is nearly insensitive to the varied time-label ratio. The two competitors have unstable perform ance since the nearest locations selected by the spatial-KNN does not guarantee the exhibitions of similar visiting ti me distributions. In constructing the RCGs, we retain  X  edges with top- X  highest weights so that the efficiency can be boosted. Here we use the partially labeled data to show the effect of  X  on the effectiveness and time efficiency of inference. We report the average inference time (in second) of locations. Fi gure 6 shows that the average runtime grows as  X  becomes larger. We can also find that the KL values are not affected by  X  . The results show that well around 7~10 considering both KL value and inference time. In contrast, we do not suggest small  X  or complete graph. Figure 6: Average KL divergence values and corresponding inference time for New York (left) and San Francisco (right), by varying the  X  in partially labeled experiment. This section aims to evaluate the time efficiency the proposed TTPM method using the Gowalla check-in data. Since no existing work tackles the time-aware transit pattern mining problem. We compare TTPM with a modified Apriori algorithm [1] and a modified TAS algorithm [7]. The modified Apriori algorithm generates frequent patterns level by level in a breadth-first search. At each level, it combines a frequent k -pattern and another frequent k -pattern to generate a candidate ( k + 1 )-pattern. For each candidate ( k + 1 )-pattern, we scan the database to count its support and check if it is frequent. Note that each candidate ( k+1 )-pattern should follow the maxgap constraint. The process repeats until no more frequent patterns can be generated. The modified Apriori algorithm can use anti-monotone property to prune the impossible candidates. On the other hand, the TAS is a state-of-art algorithm which adopts a prefix-projection approach to efficiently mine the temporally annotated sequential patterns. We modify the TAS algorithm to not only can fit the maxgap constraint but also mine the patterns which follow the Route Connected Constraint . Figure 7: Runtime versus minsup in (a) NYC and (b) SF, and versus maxgap in (c) NYC and (d) SF, using Gowalla data.
 The results using Gowalla data are shown in Figure 7. Figure 7(a) and 7(b) shows the runtime versus the minsup for NY and SF, where minsup is varied from 1% to 20%, and maxgap is set as 10%. We can find TTPM runs faster than the modified Apriori and TAS. As minsup gets smaller, the runtime of TTPM increases slowly, while the other two are more sensitive. We believe it is due to that TTPM needs to scan the database only once and remove impossible candidates in pr ojected databases. Figure 7(c) and 7(d) show the runtime versus maxgap in NY and SF, maxgap is varied from 0 to 4, and minsup is set as 10%. As maxgap increases, the number of frequent patterns increases, and thus the runtime increases. Nevertheless, TTPM is still the most efficient and scalable algorithm. The m odified Apriori and TAS methods need more time due to the drastic increases of candidates generated at each level and no effective checking and pruning strategies applied respectively, as maxgap increases We design a time-aware route cloze test to validate the quality of the recommended routes by the proposed TRP, comparing to a series of state-of-the-art and baseline methods. Gi ven some real and popular trip routes with time stamp in each location, through randomly removing m consecutive locations in each route, it is possible to test whether a method can successfully predict the missing locations. With the increasing of m , consecutive removal of locations does impose decent le vel of difficulty to this cloze test. It is because that when m increases, the information that can be utilized becomes sparse, and mistakes in the earlier position can lead to follow-up errors in the next positions to be predicted. Here we re-define the Hit Rate as the accuracy measure for this cloze test. Given there are totally N removals of locations over all routes, and assuming M places out of N is successfully predicted, the hit rate is defined as M / N . Higher hit rate indicates better quality of recommendation. Evaluation Settings. To examine the effectiveness of the inferred time label as well as to help TRP achieve higher quality for the location prediction, we do following settings so that the effect of LocTimeInf can boost the performance. This enhanced method is denoted by TRP+LocTimeInf. First, for each location l appears in n i routes, we randomly divide the participated n into time-labeled set (90%) and t ime-unlabeled set (10%). Second, we perform LocTimeInf to infer the visiting time labels of location instances in time-unlabeled set. We execute such step up to 10 times to make sure that all the routes have ever served as the time-unlabeled ones. In other words, the time labels in all the locations should be inferred and/or corrected by LocTimeInf . Third, for each instance, by comparing the difference between the inferred time check-ins with highest differences from the inferred ones. Such top-p percent check-ins are considered as the noise or abnormal ones, and are removed in the eval uation datasets. By applying the above procedure, for each location we obtain a new VTD which is supposed to lead to more accurate route visiting goodness and have better performance on the location cloze test. Due to the page limit, we simply choose p =10%. The enhanced method (i.e., TRP+LocTimeInf ) will be compared with the original TRP. Competitive Methods. We compare the proposed methods with a state-of-the-art method, Guidance Search [8], which consists of a novel heuristic satisfaction functio n to guide the search towards the destination location, and a backward checking mechanism to ensure the effectiveness of the constructed route. We believe that if our methods can outperform Guidance Search on the location cloze test, we can verify the quality of the time-aware route planning. We also design the following baseline competitors, which search in the check-in database in a greedy manner to find the route that not only satisfie s query requirement, but also maximize a certain objective function  X   X   X   X  . 
Distance-based Approach. This method chooses the closest location to the current spot as the next spot to move to. It measures the quality a route by using the objective function  X   X  X  X  X  X   X   X   X   X   X   X   X   X 1  X   X   X   X ,  X  X  X   X  X  X   X   X   X  X  X  X  the geographical distance between locations. 
Popularity-based Approach. This method chooses the most popular spot of a given time to be the next spot. It rates the route using the goodness function  X   X  X  X   X   X   X   X   X   X   X  X  X  X  X   X   X / X 
Forward Heuristic Approach. The forward heuristic chooses a location l i that possesses the largest bi-gram probability with the previous location  X  X  X   X   X |  X  X  X   X  as the next location. Its goodness function is  X   X  X  X  X   X   X   X   X   X   X  X  X   X   X  X  X  X  X   X   X |  X   X  X  X  X  X   X   X |
Backward Heuristic Approach. The backward heuristic chooses l that possesses the largest bi-g ram probability with the next location  X  X  X   X   X |  X  X  X   X  as the next location. The goodness function is designed as  X   X  X  X  X  X  X  X   X   X   X   X   X   X  X  X   X   X |  X   X  X  X  X  X   X   X |  X   X  X  X  X  X  X 
Frequent Sequen tial Patterns. To prove that the mined time-aware transit patterns are more effective than the conventional sequential patterns for planning time-aware routes. We perform the sequential pattern mining met hod [2] and select the patterns with highest RVG scores to predict the removed locations in the location cloze test. Effects of  X  . In the location cloze experiment, we first report the importance between visiting time and transition time), as shown in Figure 8(a) and 8(b). The minsup of TTPM is set as 10% and maxgap is set as 2. Our goal is to investigate whether the parameter  X  will affect the hit rate. We set the number of missing locations to be 3. The results indicate that the balance weighting (e.g.  X  ~0.5) provides a positive influence to the performance. When  X  is around 0.5, it can consistently produce the best or nearly best results. The hit rates of some baselines are lower than 3%. Moreover, we can find that the proposed TRP+LocTimeInf significantly outperform Guidance Search when  X  is from 0.25 to 0.75. It is not surprising beca use our TTP patterns can not only provide representative route segmen ts to guide the construction of routes but also capture the visiti ng and transit behaviors of users. We also find that TRP + LocTimeInf method can improve the performance of TRP slightly. The results implicitly verify that LocTimeInf is useful to boost the quality of route planning. Effects of the Number of Guessing Instances per Route. We vary the number of missing instances per route and report the hit rates. Here we set the  X 0.5 X  (i.e., the visiting time and the transit time are considered as equally important). The minsup of TTPM is set as 10% and maxgap is set as 2. The results are shown in Figure 8(c) and 8(d). General speaking, the hit rate of each method decreases when the number of missing instance increases. Nevertheless, the proposed methods still significantly outperforms the Guidance Search as well as the other baselines. TRP again guarantees a better performance using LocTimeInf . Figure 8: Hit rates by varying the  X  value (a)(b), and the number of guessing instance p er route (c)(d) in NYC (left) and SF (right).
 Effects of minsup and maxgap. We investigate the effects of minsup and maxgap on the location cloze test. The results are shown in Figure 9. It is obvious that the hit rates will increase when minsup decreases due to the drastic increasing of TTP patterns to be measured. We also report the time efficiency (in second). The runtime of PR-Search grow exponentially when the number of patterns increases (i.e., lower minsup values). We suggest that users can choose proper minsup according to their scenarios of usages. For example, lower minsup can help a tourist agency introduce different tourists for users. In contrast, a backpacker may prefer higher minsup values to derive the instant time-aware routes. On the other hand, as for maxgap , different from minsup , when the maxgap value increases, the hit rates grow slowly while the PR-Search time grows sharply. Therefore, we suggest not choosing a higher maxgap value. Setting maxgap as 1 or 2 will lead to a good balance between the hit rate and the PR-Search time.
 Figure 9: Hit rates and the corresponding runtime for NY (left) and SF (right), by varying minsup and maxgap . Based on LocTimeInf , TTPM, and PR-Search, we develop an online time-aware trip route recommendation system, called TRPlanner . TRPlanner is used to conduct a user study to test whether the routes recommended by the proposed method are rational, useful and acceptable to users. For each city, we randomly select two paired locat ions as source-destination to construct the routes for user study. The route length varies from 4 to 7. For comparison, we produce four kinds of routes for user study. The first three routes are generated by our TRPlanner with  X 0 X  ,  X 0.5  X  and  X 1  X  . The fourth is the popularity-based route recommendation which sequenti ally selects the most popular neighboring locations with the popul ar visiting time slots. We invite 20 backpackers who had ever gone to at least 10 countries to conduct the user study. Please refer to Table 2 for the evaluation criteria. For each user, we ask him/her to give the 0~5 score to each criterion/question fo r each constructed route. We report the average value for each criterion in Figure 10. 
Location Popularity (LP) Do you think these recommended 
Visiting Order (VO) Is the visiting order of locations in 
Overall Acceptance (OA) If you are a traveler, do you want to In general, TRP with  X 0.5  X  produces scores greater than 4 for all the criteria since the mined TTP patterns can ensure the quality of popularity and visiting order, and the TRP method can boost the effectiveness of visiting time and transit time as well. For the case of  X 0  X  , it also gets higher scores of LP, VO, and VT. However, it has relatively lower scores of TT due to the lack of addressing the transit time. TRP with  X 1 X  gets highest score of TT since it emphasizes on the tran sition time. However, its score of VT are lower than those of  X 0 X  and  X 0.5  X  . That says, sometimes  X 1 X  would recommend improper visiting time for users. On the other hand, the po pularity-based route ensures that the visiting locations associated visiting time stamps are popular, but the scores for the remaining four criteria are significantly lower. The user study gives us a quick view that the  X  can be set as 0.5 to achieve a better user satisfaction. 
Figure 10: Results of subjective evaluation for four methods. This paper attempts to tackle a novel time-aware route planning problem: given a query with starti ng location, starting time, and/or the destination if any, finding a route such that the pleasure of visiting and transiting locations along the route can be maximized. A three-stage model, consisting of inferring the visiting time of locations ( LocTimeInf ), time-aware transit pattern mining (TTPM), and proper route search (PR-Search ), are developed to generate the time-aware routes, with prom ising experimental results on Gowalla check-in data. Our model is data-driven, which assures diverse results can be learned from different cities where visiting patterns may vary with culture and characteristics of the city. Satisfication Score
