 Multi-key search has been an important function in database systems running on small devices [3]. It is to search tuples within a table constrained by two or more keys. Modern database systems use various indexing techniques (e.g., B+-tree [2], kd-Tree [1] and Bitmap [4]) to support efficient query processing of multi-key search queries. However, for applications running on small devices which have critical physical constrain ts (e.g., space and energy), the advanced indexes are often not applicable due to their excessive cost in space consumption. Quite often, linear list is more favored by many database systems designed for small devices with physical limitations. Although linear storage model has no extra space overhead and ver y few maintenance cost, th e sequential scan process is however slow and energy-consuming due to the vacancy of indexing supports. In this paper, we address the multi-key search problem in space-limited memory and propose a novel lightweight index nam ed D-Tree for multi-feature datasets. 2.1 Construction Algorithm of D-Tree Inspired by the dominance tree [5], we propose the D-Tree index structure to support such a multi-key search query with small extra space cost but efficient search speed. A dominance tree [5] is a binary tree, where the left-link field links to its left subtree whose root node is dominated by that node, and the right-link filed links to its right sub-tree whose root node is non-dominated by that node. However,different from dominance tree, the D-Tree has just the child field which point to the dominated nodes, whose data structure can be defined as follows. typedef struct DT{ Algorithm 1. addinTree(DT *pNode, DT *newNode) Algorithm 2. addinList(DT *pNode, DT *cNode, DT *newNode)
To construct a D-Tree, nodes are inserted one by one. When a node (called newNode ) is compared with an existing node (called cNode ), there are three pos-sible results. 1) newNode dominates the cNode . cNode is removed and inserted into the newNode  X  X  left branch. newNode will be further compared with original cNode  X  X  right neighbors. 2) newNode is dominated by cNode .The newNode will be inserted into the cNode  X  X  left branch for further comparison. 3) newNode is non-dominated with cNode . newNode will be further compared with the cNode  X  X  right neighbors. The node insertion algorithm of D-Tree is shown in Algorithm 1 and 2.
 times in queries.We propose the right-link sort method to boost the performance of queries containing a hot key. We will show that such a variation can improve search performance in experiments.

Equality Search Here we consider the simplest operation (i.e.,  X = X ) for the multi-key search algorithm.The algorithm is shown in Algorithm 3. The search process can be roughly separated into three steps. 1) Input an array list (a sibling chain). 2) Iteratively compare SN with CN through the list. 3) Determine whethergobackto1)ornot.
 We test the equality search performances on synthetic datasets. Three structures, FS, D-Tree and srD-Tree, are included in the experiments. FS means the multi-key sequential scan on linear list. D-Tree means the multi-key search on D-Tree without right-link sort adjustment. srD-Tree means the multi-key search on D-Tree with right-link sort. One search key is always selected as hot key.
In the results of Fig. 1(1), the data of a table with four keys are indexed. Each key has a domain of [1,50]. All queries contain 2 search key (i.e., R =2).The results show that D-Tree consistently outperforms the solution of the sequential multi-key scan. srD-Tree is the fastest one. In experiments of Fig. 1(2), we vary the number of search keys from 1 to 4. As shown in the figure, the more search keys used, the faster D-Tree and srD-Tree are. This is because when more values are filled in the search node (SN), SN has larger possibility to be non-dominated with CN.

Different from Fig. 1(1) and (2) which use uniform workload, Fig. 1(3) and (4) generate skew workload using Zipfian distribution 1 with parameter 1.0. Smaller values have larger possibility to be searched. Similar to the experimental setting in Fig. 1(1) and (2), we use 2 search keys in Fig. 1(3) and vary the number of keys in Fig. 1(4). As we expected, D-Tree and srD-Tree further improve the performance. srD-Tree in Fig. 1(4) is over 2 orders of magnitude faster than the sequential scan. The reason is tha t, when the values in the query become smaller, the target tuples stay closer to the root.

Instead of generating skew workload, we generate skew dataset using Zipfian distribution with parameter 1.0 in Fig. 1(5) and Fig. 1(6). Besides, 3 search keys are used in queries. In Fig. 4(5), large values has large possibility to be generated, while in Fig. 1(6) small values have large possibility of being generated. srD-Tree is nearly two orders of magnitude faster than FS.

In experiments of Fig. 1(7), the impact of M is tested. As shown in Fig. 1(7), when more keys are indexed, the perform ance of D-Tree and srD-Tree degrade. The reason is that when more keys are indexed, nodes have large possibility to be non-dominated with each other. And the sibling chain, which cannot be pruned by D-Tree, gets longer. Even though D-T ree degrades, it still outperforms FS when 15 keys are indexed.

We also test the impact of value domain in Fig. 1(8). The value domain of all keys is enlarged together. As the value domain is enlarged, fewer duplicate values occur. However, we do not observe the significant change of the performance when varying the value domain of all keys from 32 to 16k. It means that the time efficiency of D-Tree is not sensitive to domain size. Data management engines on small devi ces are faced with common special phys-ical restrictions and limited energy supp ort. They are not quite time-sensitive but have high requirements on space and energy. We propose the novel D-Tree, an in-memory lightweight storage model for multi-key search. The D-Tree can effectively store the dominance relation ships of tuples with small extra index space. We design efficient search algorithm s based on D-Tree for multi-key search. Extensive experiments show that D-Tree can achieve 2 orders of magnitude im-provement than linear sca n with very small extra spa ce cost. It indicates that D-Tree can be an effective substitution of linear list on the extreme space limit scenarios, such as smart card and sensor database.
 Acknowledgement. This work is supported by the National Basic Research Program of China (2013CB329603). It is also supported by the National Natural Science Foundation of China ( No. 61375058, 60905025, 61074128) and Ministry of Education of China and China Mobile Research Fund (MCM20123021).

