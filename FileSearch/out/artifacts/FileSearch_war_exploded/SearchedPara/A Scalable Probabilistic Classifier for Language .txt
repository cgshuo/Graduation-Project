 A Language Model (LM) is an important compo-nent within many natural language applications in-cluding speech recognition and machine translation. The task of a generative LM is to assign a probabil-ity p ( w ) to a sequence of words w = w 1 ...w L . It is common to factorize this probability as Thus, the central problem that arises from this formulation consists of estimating the probability p ( w i | w i  X  N +1 ...w i  X  1 ) . This can be viewed as a classification problem in which the target word W i corresponds to the class that must be predicted, based on features extracted from the conditioning context, e.g. a word occurring in the context.
This paper describes a novel approach for mod-eling such conditional probabilities. We propose a classifier which is based on the assumption that each feature has a predictive strength, quantifying how well the feature can predict the class (target word) by itself. Then the predictions made by individual features can be combined into a mixture model, in which the prediction of each feature is weighted ac-cording to its predictive strength. This reflects the fact that certain features (e.g. certain context words) are much more predictive than others but the pre-dictive strength for a particular feature often doesn X  X  vary much across classes and can thus be assumed constant. The main advantage of our model is that it is straightforward to incorporate rich features with-out sacrificing scalability or reliability of parame-ter estimation. In addition, it is simple to imple-ment and no feature selection is required. Section 3 shows that a generative 1 LM built with our classi-fier is competitive to modified Kneser-Ney smooth-ing and can outperform it if sufficiently rich features are incorporated.

The classification-based approach to language modeling was introduced by Rosenfeld (1996) who proposed an optimized variant of the maximum-entropy classifier (Berger et al., 1996) for the task. Unfortunately, data sparsity resulting from the large number of classes makes it difficult to obtain reli-able parameter estimates, even on large datasets and the high computational costs make it difficult train models on large datasets in the first place 2 . Scal-ability is however very important, since moving to larger datasets is often the simplest way to obtain a better model. Similarly, neural probabilistic LMs (Bengio et al., 2003) don X  X  scale very well to large datasets. Even the more scalable variant proposed by Mnih and Hinton (2008) is trained on a dataset consisting of only 14 M words, also using a vocabu-lary of around 20000 words. Van den Bosch (2005) proposes a decision-tree classifier which has been applied to training datasets with more than 100M words. However, his model is non-probabilistic and thus a standard comparison with probabilistic mod-els in terms of perplexity isn X  X  possible.

N-Gram models (Goodman, 2001) obtain esti-mates for p ( w i | w i  X  N +1 ...w i  X  1 ) using counts of N-Grams. Because directly using the maximum-likelihood estimate would result in poor predictions, smoothing techniques are applied. A modified inter-polated form of Kneser-Ney smoothing (Kneser and Ney, 1995) was shown to consistently outperform a variety of other smoothing techniques (Chen and Goodman, 1999) and currently constitutes a state-of-the-art 3 generative LM. We are concerned with estimating a probability dis-tribution p ( Y | x ) over a categorical class variable Y with range Y , conditional on a feature vector x = ( x 1 ,...,x M ) , containing the feature values x i of M features. While generalizations are conceiv-able, we will restrict the features X k to be binary, i.e. x k  X  { 0 , 1 } . For language modeling the class variable Y corresponds to the target word W i which is to be predicted and thus ranges over all possible words of some vocabulary. The binary input fea-tures x are extracted from the conditioning context w i  X  N +1 ...w i  X  1 . The specific features we use for language modeling are given in Section 3.

We assume sparse features, such that typically only a small number of the binary features take value 1 . These features are referred to as the active fea-tures and predictions are based on them. We in-troduce a bias feature which is active for every in-stance, in order to ensure that the set of active fea-tures is non-empty for each instance. Individually, each active feature X k is predictive of the class vari-able and predicts the class through a categorical dis-tribution 4 distribution, which we denote as p ( Y | x k ) . Since instances typically have several active features the question is how to combine the individual pre-dictions of these features into an overall prediction. To this end we make the assumption that each fea-ture X k has a certain predictive strength  X  k  X  R , where larger values indicate that the feature is more likely to predict correctly. The individual predic-tions can then be combined into a mixture model, which weights individual predictions according to their predictive strength: where Here A ( x ) denotes the index-set of active features for instance ( y,x ) . Note that since the set of active features varies across instances, so do the mixing proportions v k ( x ) and thus this is not a conventional mixture model, but rather a variable one. We will therefore refer to our model as the variable mixture model (VMM). In particular, our model differs from linear or log-linear interpolation models (Klakow, 1998), which combine a typically small number of components that are common across instances .
In order to compare our model to the maximum-entropy classifier and other (generalized) linear models, it is beneficial to rewrite Equation 2 as p ( Y = y | x, X  ) = where  X  j,k ( y,x ) is a sufficient statistics indicating whether feature X k is active and class y = y j and Table 1 shows the main differences between the VMM, the maximum-entropy classifier and the per-ceptron (Collins, 2002). e The VMM has two types of parameters: 1. the categorical parameters  X  j,k = p ( y j | x k ) 2. the parameters  X  k quantifying the predictive
The two types of parameters are estimated from a training dataset, consisting of instances ( y ( h ) ,x ( h ) Parameter estimation proceeds in two separate stages, resulting in a simple and efficient procedure. In a first stage, the categorical parameters are com-puted independently for each feature, as the maxi-mum likelihood estimates, smoothed using absolute discounting (Chen and Rosenfeld, 2000): where c 0 j,k is the smoothed count of how many times Y takes value y j when X k is active, and c k is the count of how many times X k is active. The smoothed count is computed as where c j,k is the raw count for class y j and fea-ture X k , NZ k is the number of classes for which the raw count is non-zero, and Z k is the number of classes for which the raw count is zero. D is the discount constant chosen in [0 , 1] . The smoothing thus subtracts D from each non-zero count and re-distributes the so-obtained mass evenly amongst all zero counts. If all counts are non-zero no mass is redistributed.

Once the categorical parameters have been com-puted, we proceed by estimating the predictive strengths  X  = (  X  1 ,..., X  M ) . We can do so by con-ducting a search for the parameter vector  X   X  which maximizes the log-likelihood of the training data:
While any standard optimization method could be applied, we use stochastic gradient ascent (SGA, Bottou (2004)) as this results in a particularly conve-nient and efficient procedure that requires only one iteration over the data (see Section 3). SGA is an online optimization method which iteratively com-putes the gradient  X  for each instance and takes a step of size  X  in the direction of that gradient: SGA contains the first-order derivatives of the data log-likelihood of a particular instance with respect to the  X  -parameters which are given by  X 
The resulting parameter-update Equation 8 has the following intuitive interpretation. If the predic-tion of a particular active feature X k is higher than the current overall prediction, the term in square brackets in Equation 9 becomes positive and thus the predictive strength  X  k for that feature is increased and conversely for the case where the prediction is below the overall prediction. The magnitude of the update depends on how much overall and feature
In order to improve generalization, we estimate the categorical parameters based on the counts from all instances, except the one whose gradient is being computed for the online update (leave-one-out). In other words, we subtract the counts for a particular instance before computing the update (Equation 8) and add them back when the update has been ex-ecuted. In total, training only requires two passes over the data, as opposed to a single pass (plus smoothing) required by N-Gram models. All experiments were conducted using the SRI Lan-guage Modeling Toolkit (SRILM, Stolcke (2002)), i.e. we implemented 5 the VMM within SRILM and compared to default N-Gram models supplied with SRILM. The experiments were run on a 64-bit, 2 . 2 GHz dual-core machine with 8GB RAM.
 Data The experiments were carried out on data from the Reuters Corpus Version 1 (Lewis et al., 2004), which was split into sentences, tokenized and converted to lower case, not removing punctuation. All our models were built with the same 30367 -word vocabulary, which includes the sentence-end symbol and a special symbol for out-of-vocabulary words (UNK). The vocabulary was compiled by se-lecting all words which occur more than four times in the data of week 31 , which was not otherwise used for training or testing. As development set we used the articles of week 50 ( 4 . 1 M words) and as test set the articles of week 51 ( 3 . 8 M words). For training we used datasets of four different sizes: D1 (week 1, 3 . 1 M words), D2 (weeks 1-3, 10 M words), D3 (weeks 1-10, 37 M words) and D4 (weeks 1-30, 113 M words).
 Features We use three different feature sets in our experiments. The first feature set ( basic , BA) con-sists of all features also used in standard N-Gram models, i.e. all subsequences up to a length N  X  1 immediately preceding the target word. The sec-ond feature set ( short-range , SR) consists of all ba-sic features as well as all skip N-Grams (Ney et al., 1994) that can be formed with the N  X  1 length con-text. Moreover, all words occurring in the context are included as bag features, i.e. as features which indicate the occurrence of a word but not the partic-ular position. The third feature set ( long-range , LR) is an extension of SR which also includes longer-distance features. Specifically, this feature set ad-ditionally includes all unigram bag features up to a distance d = 9 . The feature types and examples of extracted features are given in Table 2.
 Model Comparison We compared the VMM to modified Kneser-Ney (KN, see Section 1). The or-der of a VMM is defined through the length of the context from which the basic and short-range fea-tures are extracted. In particular, VM-BA of a cer-tain order uses the same features as the N-Gram models of the same order and VM-SR uses the same conditioning context as the N-Gram models of the same order. VM-LR in addition contains longer-distance features, beyond the order of the corre-sponding N-Gram models. The order of the models was varied between N = 2 ... 5 , however, for the larger two datasets D3 and D4 the order 5 models would not fit into the available RAM which is why for order 5 we can only report scores for D1 and D2. We could resort to pruning, but since this would have an effect on performance it would invalidate a direct comparison, which we want to avoid. Model Parametrization We used the develop-ment set to determine the values for the absolute dis-counting parameter D (defined in Section 2.1) and the number of iterations for stochastic gradient as-cent. This resulted in a value D = 0 . 1 . Stochas-tic gradient yields best results with a single pass through all instances. More iterations result in over-fitting, i.e. decrease training data log-likelihood but increase the log-likelihood on the development data. The step size was kept fixed at  X  = 1 . 0 .
 Results The results of our experiments are given in Table 3, which shows that for sufficiently high orders VM-SR matches KN on each dataset. As ex-pected, the VMM X  X  strength partly stems from the fact that compared to KN it makes better use of the information contained in the conditioning con-text, as indicated by the fact that VM-SR matches KN whereas VM-BA doesn X  X . At orders 4 and 5, VM-LR outperforms KN on all datasets, bringing improvements of around 10 % for the two smaller training datasets D1 and D2. Comparing VM-BA and VM-SR at order 4 we see that the 7 additional features used by VM-SR for every instance signifi-cantly improve performance and the long-range fea-tures further improve performance. Thus richer fea-ture sets consistently lead to higher model accuracy. Similarly, the performance of the VMM improves as one moves to higher orders, thereby increasing the amount of contextual information. For orders 2 and 3 VM-SR is inferior to KN, because the SR feature set at order 2 contains no additional features over KN and at order 3 it only contains one additional feature per instance. At order 4 VM-SR matches KN and, while KN gets worse at order 5 , the VMM improves and outperforms KN by around 14 %.

The training time (including disk IO) of the or-der 4 VM-SR on the largest dataset D 4 is about 30 minutes, whereas KN takes about 6 minutes to train. The main contribution of this paper consists of a novel probabilistic classifier, the VMM, which is based on the idea of combining predictions made by individual features into a mixture model whose com-ponents vary from instance to instance and whose mixing proportions reflect the predictive strength of each component. The main advantage of the VMM is that it is straightforward to incorporate rich fea-tures without sacrificing scalability or reliability of parameter estimation. Moreover, the VMM is sim-ple to implement and works  X  X ut-of-the-box X  with-out feature selection, or any special tuning or tweak-ing.

Applied to language modeling, the VMM re-sults in a state-of-the-art generative language model whose relative performance compared to N-Gram models gets better as one incorporates richer fea-ture sets. It scales almost as well to large datasets as standard N-Gram models: training requires only two passes over the data as opposed to a single pass required by N-Gram models. Thus, the experiments provide empirical evidence that the VMM is based on a reasonable set of modeling assumptions, which translate into an accurate and scalable model. Future work includes further evaluation of the VMM, e.g. as a language model within a speech recognition or machine translation system. More-over, optimizing memory usage, for example via feature pruning or randomized algorithms, would al-low incorporation of richer feature sets and would likely lead to further improvements, as indicated by the experiments in this paper. We also intend to eval-uate the performance of the VMM on other lexical prediction tasks and more generally, on other classi-fication tasks with similar characteristics. Acknowledgments I would like to thank Mirella Lapata and Charles Sutton for their feedback on this work and Abby Levenberg for the preprocessed datasets.
