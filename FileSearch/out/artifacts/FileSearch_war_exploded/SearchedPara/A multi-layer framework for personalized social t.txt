 1. Introduction
In recent years, the widespread adoption of Web 2.0 related technologies has greatly facilitated user collaboration and knowledge sharing, bringing several benefits to the field of Web metadata generation and management. Notable examples of
Web 2.0 technologies applied to Web metadata are those related to online communities, whose members have the ability of collaborative tagging [1,2] , has the purpose of collecting and sharing opinions about Web resources, and simplifying resource retrieval by organizing them according to a tag-based browsing criterion.

The huge availability of social tagging systems has pushed the development of several applications exploiting these metadata,
Here, users of online communities share resources that they consider relevant, and express personal opinions on them with the purpose of making resource retrieval easier.

In general, social tag-based applications gather metadata associated with resources, elaborate them and exploit the obtained tag-based applications has mainly focused on personalized recommendations of tags (e.g., [4 make use of techniques derived from the data mining area to predict which tags/resources might be relevant, and how much.
However, we believe that social tag-based applications can be further improved following several directions. First of all, resources, but also in assessing their trustworthiness [11] .

So far, this issue has been addressed by providing a measure/definition of trust based on some statistics on tags' frequency trustworthiness.

Further, we believe that several scenarios exist where taking into account user preferences during metadata selection could the case of a person, say Kate, who is looking for some science-fiction books for a teenager. In real life, Kate might ask recommendations and suggestions only to those of her friends that are considered expert in science-fiction books. Also, Kate could restrict her selection only to recommendations of those experts that are teens. Applying the same approach in social the users whose metadata have to be elaborated during resource evaluation. In contrast, existing social tag-based applications process resources by elaborating the whole set of metadata associated with it (see for instance [ 12 ]).
Further, the tags associated with a resource and their trust values can be used by users to decide how a given resource has to prefer that a recommender system recommends only those books whose metadata state that their content is related to science-fiction with trust value at least equal to 80%.

To cope with the above-discussed requirements, in this paper we propose a framework to support personalized social tag-based applications based on trust policies and user preferences . Trust policies allow one to identify trusted users and to state which  X  quality  X  assessment must be returned (e.g., to be performed (e.g., recommend, filter, classify) in case at least one of the specified conditions is satisfied.
More precisely, we propose a multi-layer framework , where each layer is designed as a black box, providing basic services to the purposes social tags are used for.

The novelty of this framework is in the supported features and in its modular architecture, thanks to which it is possible to tailorize, or even disable, one or more components depending on the different contexts and requirements. We would like to note, however, that, although in this framework trust computation plays an important role, it is just one of the components of method for trust computation, but it is designed to support different methods depending on the considered application scenario.
 search and Web access personalization.

We would like to note that, in this paper, we focus on the technical feasibility of the framework we propose, in order to supported, and by exploiting the potential of user-generated content, as social tags are. Nonetheless, the paper includes a stake, which we plan to address in future work.
 proposed multi-layer framework. Data layer is described in Section 4 ,whereas Section 5 presents the rule layer. We prove the research directions. Finally, Appendix A contains the main algorithms underlying our framework. 2. Related work
The social tagging phenomenon and its advantages in terms of knowledge acquisition and enhancement of Web users' issues, in this section we will discuss the ones that we think are most relevant to our approach. not terms from a predefined vocabulary, but keywords freely specified by end users, we may have different tags with the same meaning (synonymy), same tags with different meaning (homonymy), tags with multiple meanings (polysemy). This negatively affects the effectiveness of tag-based search, and leads to a low precision and recall of the obtained search results.
In order to address such issue, several solutions have been proposed, aiming at enforcing semantic interoperability (for the i.e., the idea that, in widely distributed systems, semantics emerges from the agreement of the involved agents [14] .Asan the other side, [16] proposes to model a folksonomy  X  i.e., the set of social tags specified by users in an online community tripartite graph derived from the information concerning users, tags, and bookmarked resources. Graph transformations are then used to derive lightweight ontologies of concepts and users.

The other main research direction focuses on using social tagging to enforce personalized recommendations. Basically, work carried out in this area is based on the adaptation to social tagging of techniques already established in recommender systems websites the resources are linked from and to. Tags are then derived based on the similarity between the resource to be predicted by extracting relevant terms from a resource, and then by computing their similarity with keywords representing the documents' corpus of the personal desktop of a given user. Other related works have been carried out in the context of Web services (see e.g., [17,18] ).

User profiling is a technique which is used also in works aiming to recommend to a given user a set of bookmarked resources build profiles and recommendations for Last.fm users. By contrast, [8] proposes to build user profiles by mining personal tags are hierarchically clustered by using measures like tag's frequency and distinctiveness. The system then computes how much a three of them, namely, collaborative tagging, browsing, and search.

The personalization approaches discussed above might be seen as an alternative solution to our framework, as far as the rule and application layers are concerned. However, they can be used to address a specific issue, namely, tag/resource recommendation, whereas our framework is designed to be as flexible as possible with regard to the purposes social tags are used for. From our perspective, the most relevant difference with our framework concerns how personalization is enforced. It is important to note that all these approaches have a common denominator in that they statistically derive new information from existing one, without requiring end users' opinion. This has great advantages in terms of usability, but has a major drawback in the probabilistic nature of the obtained results. As a consequence, it cannot be used for purposes where false positives might determine harmful consequences on the side of end users. For instance, they cannot be used to grant that a resource is safe for children, or that it satisfies the privacy requirements of an end user. For these purposes, the explicit specification of end users' preferences and requirements must be required, and this is exactly the issue addressed by the rule layer of framework.
 interact with either the data or rule layers, thus deciding whether or not to use trust policies and user preferences.
The rule layer of our framework can be seen as an enhancement to social tagging services by the integration of some of the features provided by Semantic Web rule languages (e.g., [19] ) and Semantic Web policy frameworks our knowledge, has not been addressed so far. Basically, Semantic Web policy frameworks are meant to support the specification and enforcement of policies expressed in terms of constraints on the machine understandable resource descriptions provided by systems, having a huge number of agents, with heterogeneous and dynamically evolving characteristics. Examples of such frameworks are KAoS [20] , REI [21] , and Ponder [22,23] , focusing mainly on access control, Protune [24,25] , which provides order to denote given  X  quality  X  requirements that resources must satisfy. 3. A multi-layer framework for personalized social tag-based applications managing personal data of online communities' members and services generating the metadata. To make the framework able to the notion of descriptor , instead of the one of tag, to denote a keyword, or attribute
In the proposed framework, besides labeling resources, social network members can express their dis/agreement about respectively, the trustworthiness of Web metadata and the quality of Web resources. Although there currently exist several we investigate Semantic Web technologies as the basis of the standard interchange format among our layers. More precisely, we use RDF/OWL [28,29] to encode the data layer's components, whereas trust policies and user preferences are represented and enforced through N3Logic rules [30] . We have adopted N3Logic, although it is not a standard Semantic Web language, not only about statements  X  a feature that we need, for example, to specify the author of a label. The alternative would have been the technologies designed by the Rule Interchange Format (RIF) of the W3C ( http://www.w3.org/2005/rules ). However, such technologies have reached only recently the status of a Semantic Web standard, and they are not fully implemented. resources according to the specified trust policies and user preferences and the available ratings and Web metadata. This abstract view of our framework, hiding the complexity of its architecture. This is an important issue, as far as usability is concerned, which is however out the scope of this paper, where we focus on system design, implementation, and evaluation.
The proposed multi-layer framework has the main advantage of being modular and therefore can complement existing services without the need of their re-design. The use of Semantic Web technologies as the interchange format among layers data and rule layers are optional. For instance, a typical social tagging service supports just the Web metadata service and, features by exploiting information already stored by the service.
 In what follows, for the sake of brevity, we will refer to our framework using the acronym WPF (Web Personalization
Framework). 4. Data layer of managing social network data, Web metadata, and ratings. 4.1. Social network data
Example 1. The following are examples of credentials released by CAs CA
C =( CA 2 , Henry, {profession=physician}) || DSig 2 ,where DSig into FOAF profiles [31] . FOAF (Friend of a Friend) is a widely used Semantic Web technology that allows the specification of personal information.

In addition, we need to model the relationships established by WPF users in the community with the purpose of specifying and sharing tags. Please note that relationships play a key role in our framework as they are used in trust policies to identify trustworthy users, that is, users whose labels/ratings should be considered for trust computation. Indeed, according to the my friends are considered trustworthy).

Formally, we model such social network SN as a tuple M SN and edges of a directed graph M SN ; E SN  X  X  , RT SN is the set of supported relationship types, whereas assigning to each edge e  X  E SN a relationship of type rt
We say that two WPF users participate in a relationship of a given type rt , if there exists a path connecting them consisting type ), and depth ( relx:depth ) of a relationship. 3 between Betsy and Henry ( BKPH ) and the other of type colleagueOf between Kate and Henry ( KBPH ).
It is interesting to note that up to now, existing social networks do not provide such functionality and as such our framework cannot be directly applied on them. However, thanks to FOAF and REL-X ontologies, profile and relationship information can be exported from existing social networks so as to be used in WPF. As an example, the framework could be integrated with Facebook
Facebook application could also be used to gather from WPF users their ratings and labels. 4.2. Web metadata
By abstracting from the various representations, Web metadata can be modeled as labels , which in turn consist of a set of
WPF users. They are identified by a URI, and contain a set of resource descriptors rd opinions on it. They are expressed as pairs t =  X  , where resources hosted by www.example.org , where the URI path component starts with contains the ID of the WPF user who created it, a timestamp, and, optionally, the validity period for the label.
Example 3. In the running example we will use to illustrate our framework, we suppose that Kate runs a blog denote by LB n the URI of label n .Labels LB 1 and LB 3 describe all the resources hos ted by about-gmos.net. Label relevance equal to 80% in describing their content. Label to 40% for the description of the resources content. In contrast, labels 20%, whereas topic nutrition has a relevance equal to 40.

As mentioned in Section 3 , we adopt POWDER as the interchange format for Web metadata [27] , to make easier processing and denote a set of descriptors encoded according to the POWDER syntax.

Example 4. Fig. 3 shows the RDF/OWL encoding of LB 1 in Table 1 according to POWDER specifications [34] and using the N3 syntax. 5 The ontology header at line 8 encodes the information about who issued the label, when it has been issued, and its classes D1 , D2 , and D3 . 4.3. Ratings corresponds to a single resource  X  i.e., the label being rated the lifetime of the corresponding label.
 omitted for brevity. As in Example 3 , we assume that LB 1 have been specified by Betsy and they apply to labels LB 3 relevance equal to 40%  X  i.e., ( biology =0.4,1)  X  for the description of the corresponding resources, whereas in on the fact that the topic health has a relevance equal to 20% relevance equal to 40%  X  i.e., ( nutrition =0.4,1). Rating gmos has a relevance equal to 80%  X  i.e., ( gmos =0.8,1). Henry has specified also ratings relevance of topic nutrition is equal to 60%  X  i.e., ( author =Henry,0) and ( nutrition =0.6,0) has a relevance equal to 100%  X  i.e., ( childCare =1.0,1). In contrast, in resources, and on the fact that topic nutrition has a relevance equal to 40% author  X  i.e., ( author = Kate ,1)  X  , and that the topic gmos has a relevance equal to 80% Example 6. Fig. 4 shows the N3 encoding of RT 6 in Table 2 . In order to associate a rating with the statements in label enclosed into quoted formulae , 6 and then the rating ( voc:rating ) the statement according to which Kate is the author of the resources having a URI starting with http://about-gmos.net, whereas to specify when the ratings have been issued (line 20), and who issued them (line 21). 5. Rule layer sort of user-defined quality label to resources. Moreover, they allow to associate different actions to be performed when the corresponding resource is accessed, based on the associated label. 5.1. Trust policies
Labels associated with a given resource, and the corresponding ratings, are used to determine the trustworthiness of the corresponding descriptors, according to a trust computation algorithm that may vary depending on the considered application scenario. Independent from the adopted trust computation method, it may be often the case that WPF users want to base trust account when computing descriptors' trust values.

In our approach, such preferences can be expressed through trust policies . A trust policy specifies which WPF users are topics, and resource property names in the system.

De fi nition 1. A trust policy TP is a tuple ( author , uriPattern , trustedM , T , PN ), where:  X  author  X  M SN is the WPF user who specifies the policy;  X  uriPattern is a URI pattern denoting the set of resources  X  trustedM denotes the set of WPF users whose opinion is considered trustworthy with regard to resources denoted by uriPattern .
It can have one of the following forms, possibly combined: 1. a set MM SN of WPF users; 2. a set of attribute constraints of the form an OP av , where an 3. a set of relationship constraints of the form ( m , rt ,max d ), denoting all the WPF users participating with member m  X 
T p T is a set of topics, possibly empty, for which the opinions of the WPF users denoted by trustedM are considered trustworthy in describing the resources denoted by uriPattern ; in case T = considered trustworthy for any topic;  X 
PN p PN is a set of property names, possibly empty, for which the opinions of the WPF users denoted by trustedM are considered trustworthy in describing the resources denoted by uriPattern ; in case PN = denoted by trustedM are considered trustworthy for any property name.
 Example 7. Table 3 reports examples of trust policies, all applying to the resources hosted by about-gmos.net. considers trustworthy for topic  X  nutrition  X  and for any resource property only those WPF users whoare experts in dietology that Phil considers Kate trustworthy for topic gmos and for resource property author .
 ( m ,  X  , m ,  X  ,  X  ), stating that m considers him/herself trustworthy for any resource, topic, and resource property.
When a user requires to access a resource rsc having a URI matching http://about-gmos.net*, the system verifies which taking into account only the matching descriptors and ratings.

Example 8. As an example of how Semantic Web technologies can be used to represent trust policies, Fig. 5 shows the encoding of
TP 3 in Table 3 into an N3 rule. More precisely, lines 14 the URI pattern (line 14), trustworthy members (line 15), and property/content descriptors (line 16). If such constraints are Trust policies may be of two different types, depending on the member who specifies them. More precisely, given a trust policy =( m , uriPattern , trusteM , T , PN ), if m is the owner of the resource(s) denoted by uriPattern ,wecall policy (denoted as OTP ); otherwise, TP is called user-defined trust policy (denoted as somehow theowner of a resourcewould liketostate whichare the usershe/she considers trustworthywith respectto the description and how user-and owner-defined trust policies should be taken into account (see Definition 2 ). 5.2. User preferences returned to an end user, such information can be exploited by him/her as a basis to assess the reliable medical information, and which have a trust value greater than 80%, an end user might decide that such resource is
We can therefore encode the criteria adopted by an end user to decide the quality of a resource to automate this process. More
As we have mentioned above, the notion of  X  quality  X  may vary depending on the end user's purpose(s), which might be quite preference must be blocked or not.
 The notion of user preference is therefore formally defined as follows.

De fi nition 2. A user preference UP is a tuple ( author , uriPattern , PC , CC , settings , Q , options ), where:  X  author  X  M SN is the WPF user who specifies UP ;  X  uriPattern is a URI pattern, denoting the set of resources  X 
PC is a set of triples ( pc , tc , dc ), where:  X  pc is a property constraint of the form pn OP pv , where pn is a property name, pv is a property value, whereas comparison operator compatible with pn 's domain;  X  tc is a trust constraint of the form tv OP  X  , where  X   X   X  dc is a distribution constraint of the form dv OP  X  , where  X  CC is a set of pairs ( cc , tc ), where cc is a resource content constraint of the form t relevance of topic t , OP  X  {= b ,&gt;,  X  ,  X  }, whereas tc is a trust constraint on cc ;  X  settings is a triple ( checkUTP , checkOTP , comb ), where:  X  checkUTP  X  all ; none fg denotes whether user-defined trust policies must (all) or must not (none) be taken into account;  X  checkOTP  X  all ; some ; none fg denotes whether owner-defined trust policies must (all), must not (none) be taken into  X  Q is a set of attribute  X  value pairs assessing the quality of the resources satisfying  X  options is a set of attribute  X  value pairs, possibly empty, denoting the set of actions to be performed by a user agent when accessing a resource satisfying UP .

It is important to note that the Q and options components of user preferences should be initialized with values from
Web resources, possible attribute  X  value pairs for options is refer to user preferences defined for the Web resource personalization application scenario. Example 9. Table 5 reports examples of user preferences, all applying to the resources hosted by about-gmos.net. Preference specified by Henry, denotes the resources hosted by about-gmos.net as carrying information which can be safely used (i.e., 1 also states that the descriptors and ratings to be considered when computing descriptors trustworthiness are only those satisfying at least one among the owner-and user-defined trust policies denotes as relevant all the resources whose author is Phil, provided that the descriptor author = Phil has a trust value and distribution value equal to 100%. Note that, different from user-defined policies or (b) those owner-defined policies selected at run-time by Kate (this is denoted by one among the user-defined trust policies must be considered state that topics gmos and biology have a relevance greater than 80%. Finally, preference 4 states that only user-defined trust policies must be considered
Example 10. As an example of how Semantic Web technologies can be used to represent user preferences, Fig. 6 shows the owner-and user-defined, combined by using OR, as required by granted (line 20). Finally, line 22 states that the author of such user preference is Henry. 5.3. Trust policies and user preferences enforcement preferences specified by m , and then returns the specified quality assessments and options, if any. To perform this task, the enforcement mechanism (whose main algorithms are reported in Appendix A ) takes as input the set of m 's user preferences, the the corresponding ratings.
 or owner defined preferences, according to what is stated in the considered user preference. If no trust policies apply to the computed according to the selected trust computation algorithm. Then, the enforcement mechanism checks if the considered of the set of descriptors on topic nutrition , having a value &gt;0.4 is computed. If the constraints in the user preference are satisfied, then the associated quality assessments and options are returned. [36] and PeerTrust [37] ) may be used for trust computation, which might depend also on the possible values that ratings can assume (e.g., ratings can be binary or scalar, using either discrete or continuous values). Additionally, each user could be that has been thoroughly investigated by recommender systems [3] , among which there exist examples of online communities, such as MovieLens [38] and MyWOT ( http://mywot.com ). However, in our framework we do not want to rely on a specific for internal processing.

The output of the enforcement mechanism is used by the application layer in order to perform a set of operations which depend on the specific agent. As an example, the returned quality assessments can be displayed as graphical and/or textual notifications (like a message window carrying a green icon and stating that the current resource can be safely used, since its will deny access to the resource.

Then, according to UP 1 settings , it selects only the descriptors and associated ratings satisfying one among Henry's trust policies (i.e., TP 2 ) or the owner-defined trust policies (i.e., TP previous phase satisfy TP 2 or TP 3 , whereas the selected ratings are
Finally, the system computes (a) the trust value tv rd , rsc  X  cc of the topic in each selected content descriptor cc , and (c) the percentage a trust value greater than 50% and satisfying author =Kate. Suppose that tv 1.0, or author = Kate , whereas tv rd , rsc =0,if rd corresponds to author =Henry. In our case, we have: gmos ;  X  cc 1 : 0, if cc concerns topic childCare ;  X  author =Kate marks it as carrying information which can be safely used.

It may happen that no labels are associated with the considered resource or no user preferences are satisfied or that the given resource is safe for children and access should be granted, whereas another one claims the opposite. How such situations are treated may vary depending on the purpose user agents are designed for, and thus these are issues addressed by the determine the prevailing quality assessments (e.g., referring to our example, the end user might decide that, between children  X  and  X  not safe for children  X  , the latter must prevail). 6. Application layer: the delicious case studies quality, relevance, etc. of a resource for a specific user (user preferences).

This requires, however, the availability of a set of metadata huge enough to perform trust computation, and covering a representation systems. However, as we have mentioned earlier in this paper, the success of social networking can be the fore, their datasets can be effectively reused by our framework.
 by extending the modules in charge of retrieving the online datasets.
 criterion. Moreover, Delicious members can also add contacts, thus setting up a social network. In November 2008, Delicious claimed to have 5.3 million registered users and 180 million bookmarked URLs. purposes. More precisely, Delicious tags and contacts correspond to the Web metadata and users' relationships contained in the among its members, whereas Delicious supports just a generic relationship type.
 Fig. 8 provides a graphical representation of how our framework has been built upon Delicious.
In the following sections, we provide the details about the WSN system architecture and implementation, and illustrate the experiments that we have carried out in order to verify the feasibility of our approach. 6.1. System architecture
The main component of our prototype, depicted in Fig. 9 , is the WSN Management System (WMS), which is in charge of storing and managing data collected by the WSN, and to enforce trust policies and user preferences. user preferences. It can be used also to create labels which will be transparently uploaded to Delicious by using its API.
The WMS is complemented by a WMS User Agent, which is implemented as a browser extension for Firefox. Such application a client-side agent, integrated into the user's browser.

Moreover, it provides direct access to WMS services, like the Semantic, and Trust-aware Search Engine, described later in this bases is accessible through an API, which can be used to query and manage the stored data.
 Thanks to them, it is possible to give access to WMS data to all authorized users and agents, even those external to the WMS. For this purpose, such APIs support requests in multiple protocols, namely, REST [40] , SOAP [41] , and SPARQL [42] .
To retrieve bookmarks and contacts from Delicious, we have designed two modules, namely the Label and Relationship Extractors, retrieving at runtime data from Delicious because this grants a better performance, as it will be explained in Section 6.1.2 . All the queries performed on the WMS bases are managed by the Request Manager.

The Request Manager is also invoked by the User Preference Engine (UPE), and the Semantic and Trust-aware Search Engine member of the WMS, he/she can decide whether they can be evaluated also with respect to the existing trust policies and user 6.1.1. The delicious dataset
As mentioned earlier in this section, Delicious provides a dataset consisting of two types of information: a set of bookmarks, username, real name, email address, and, possibly, the URL of his/her homepage.

The Delicious dataset can be accessed through: the Delicious Web site and the Delicious API. For our purposes, it would be and which can be extracted with a minimal processing overhead. However, the Delicious API has some disadvantages. First, it is provide access to all the data available from the Delicious Web site. Actually, the API is meant to give Delicious members the of bookmarks that can be retrieved. The API allows you to retrieve at most the 100 most recent bookmarks about a URL, whereas his/her username and password. This means that, in order to exploit the API, the WMS has to be set up with usernames and passwords of all WMS members, which is definitely a strong assumption. For all these reasons, we decided to retrieve the Delicious dataset directly from the Delicious Web site.
 6.1.2. Implementation details and issues The WMS is built on top of thePostgreSQLDBMS,by usingthePHPlanguage. Although thedata collectedby theWMSare served in better performance. The PostgreSQL DBMS has been used not only to manage the WMS's bases, but also to perform the most costly charge of returning data in different formats, and those in charge of extracting the Delicious dataset. number of bookmarks applying to a resource, extracting them from the Delicious website requires an average of 1 members, and how old are the retrieved tags.
 6.2. Experiments
In order to verify the feasibility of our approach, we have carried out a set of experiments to measure system performance when enforcing user preferences. In this section, we first analyze time complexity, and then illustrate the results of the experiments we have conducted.
 constraints), whereas retrieving the relevant descriptors, and the corresponding trust values and distribution requires the evaluation of the available Web metadata and the corresponding ratings.
 tablestoring thedirect contacts of WPF members, that is, storingthe number of edges of the graph,i.e. E the worst case, that is, when each user is connected with all the others: in such a scenario, we have E multiple edges. Consequently, we can use as an upper bound E
The former computation is performed by a query that, for each URL and associated descriptor, returns the number of occurrences evaluating a number of rows equal to the total number of descriptors and ratings in the system. descriptors' trust values are computed as follows: 1. let RD be a set of descriptors, specified by a given WPF user m , and associated with a given resource rsc ; 2. for each rd  X  RD , the sum of the ratings on rd is divided by the total number of users who created a rating for any of the descriptors applying to rsc , thus obtaining a preliminary trust value t in RD specified by m ; 4. the final trust value of rd is given by the product of t when all the users who have rated descriptors applying to rsc have also rated descriptor rd ;0 such reputation score is used to weigh the trust value obtained in step 2, thus obtaining the final trust value of rd .
In order to have an estimation of the time complexity in real world scenarios, we have performed several experiments to compute the time required by trust policy enforcement, by varying the number of selected users, descriptors, and ratings.
The experiments were conducted on a 3.60 GHz Dual-Core Intel Xeon GNU/Linux machine, with 4 GB RAM. We would like to note that this hardware configuration is far from being suitable for a typical Web community, which might collect data from millions of users, and thus this must be taken into account in evaluating the results of our experiments.
As far as trustworthy users are concerned, we have considered two different cases, depending on whether, in a trust policy, they are denoted by attributes or relationship constraints. In order to test system performance when trustworthy users are denoted by attribute constraints, we have varied the total number of users from 1000 to 10,000, and the average number of linearly as expected with the total number of rows in the table storing users' profiles.
 consequently carried out several experiments on the BFS by varying the graph order and degree (i.e., the total number of users and the average number of contacts per user, respectively).

Note that, in the experiments, we have considered the worst case relationship constraints in the trust policy requires exploring the whole network graph.
Fig. 11 summarizes the results of our experiments considering a total number of users ranging from 1000 to 6000 and a number of contacts per user ranging from 10 to 100. As can been seen by comparing the response times reported in Figs. 10 and 11 , enforcing relationship constraints is far less efficient than evaluating attribute constraints.
Note, however, that the worst case considered in our experiments on relationship constraints is not likely in a real world that grows logarithmically with the size of the graph [44 used to limit the BFS on a subgraph of the social network, thus reducing the number of nodes and edges to be explored.
The evaluation of attribute and relationship constraints affects, however, only part of response times. In fact, after having identified the set of trustworthy users denoted by a trust policy and aggregated in order to compute their trust value. the trustworthy users denoted by a trust policy TP (black area), by varying the number of descriptors and ratings from 1000 to this section, we have used the same table to store both descriptors and ratings.
 a trust policy denoting users through relationship constraints. As can be seen, in both cases, the maximum response time is around 0.1 s.

By taking into account the hardware configuration we have used for our experiments, which is far from being powerful of our approach. 6.3. Usability
Traditionally, system personalization in enforced by inferring users' preferences from their data and behaviors. In such a opinions, etc.

The framework proposed in our paper adopts a different approach, since users' preferences are not inferred by the system, but explicitly specified by end users. Consequently, precision and recall here measure whether and how much a given preference is can be summarized as follows:  X  preferences, as in our framework, it is important to make users aware of the consequences of their decisions, and to verify whether this is what they actually intended (e.g., a user may unintentionally specify conflicting policies);  X  necessary to find a trade-off among usability, expressiveness and efficiency of the enforcement, taking however into account result in preferences which do not correctly reflect the users' intentions; their purposes. Also, preferences which have correctly worked until a given moment, may be less effective later on. This may happen when preferences denote a set of resources whose content has changed during time, but also when a preference denotes a preferences and to revise them, if necessary. Note that revising a preference may mean changing the original one and/or specifying exceptions to it.
 preference expressiveness and update. About the former, it is necessary that the semantics of the preferences supported by the exceptions is provided by our framework, which allows the specification of conflicting preferences and enforces conflict resolution criteria.

As we have made clear throughout the paper, our contribution focuses on the technical feasibility of the framework we propose, in order to demonstrate that it is technically possible to enhance existing social media by providing personalization is equally important to verify whether and how the complexity of our framework can be hidden to end users in order to make it usable. However, this would require a separate study, which cannot be included in this paper.
Nonetheless, we have tried to obtain a preliminary evaluation about the usability issues of our framework by setting up an framework actually supports the technical requirements concerning preference expressiveness and update, but we have also partially verified other usability issues.
 In order to carry out the experiment, we have involved 10 undergraduate students of the Computer Science course at the
University of Insubria. We have prepared a testing environment in one of our laboratories, configuring a desktop computer for each one of the participants.

The test has been carried out on an instance of our system, where the front-end included a preference specification interface
The different fields in the form correspond to the components of a user preference (see Definition 2 , Section 5.2 ). For the experiment, we have enabled neither property constraints nor the (all,some, which set of tags should be displayed in the cloud (most popular ones, tags specified by contacts, my tags). The experiment has been designed and carried out according to the following phases:
Preparatory phase . From Delicious, we have collected the URLs of 50 resources annotated with the most popular tags, and we have then partitioned them into 10 groups of 5 resources each. We have then created 10 user accounts on Delicious, and established mutual relationships of type  X  colleague  X  among all them. We have then setup 10 web pages, each one relative to a single user and listing a single group of resources, along the corresponding links. All these pages were linked from a page including the numbered list of user.

First phase . Users, after entering the testing environment, have been asked to access their page, log in into the system, and create bookmarks for the 5 resources assigned to them. When creating a bookmark, users were asked to choose from a minimum of 2 to a maximum of 5 tags among those suggested by Delicious.

Second phase . We have collected the set of tags chosen by the users, and we have then selected those more frequently specified. Then, we have asked the users to access the preference specification page, and to create 4 preferences each using a single tag among those selected before. Users have then been asked to access the resources bookmarked by the other users, check the response given by the system, based on the specified preferences and on the content of the page, and then rate such response to denote whether and how much it had met the expected results.

Third phase . We have then collected the evaluations carried out by the users about the effectiveness of the preferences they have specified. Users have then been asked to revise the specified preferences, if necessary, in order to obtain the expected result. They have been given the options to revise the preference specification itself and/or to create exceptions. Users have then re-tested the updated preferences.

Fourth phase . Users were given a questionnaire, and asked to rate the included questions by choosing one of the following options:  X  no  X  ,  X  neutral  X  ,  X  yes  X  ,  X  don't know  X  , and to motivate them. The included questions were the following:  X  Would you use this application in your everyday life?  X  Have you find it useful?  X  Have you found it easy to specify preferences?  X  Is the logic underlying preference enforcement clear? We have then collected the questionnaires and then started a discussion with the users by reviewing their answers.
The results of such discussion can be summarized as follows:  X  The majority of the users were not sure they would have used the application regularly in their everyday life, but they all  X  Nearly all the users said the preference specification interface needs improvements, to be more intuitive, and to reduce as  X  None of the users said that he/she was not able to specify the intended preferences  X  Most of the users found the preference revision mechanism helpful to correct the unexpected results. However, they also  X  Most of the users said that the application did not significantly increase the response delay of the overall system.
From the outcome of this experiment, we can say that the problems concerning effectiveness are mainly related to usability about our framework and its front end, and also provide a first set of suggestions on how to improve usability. 7. Conclusions and future work
In this paper, we have presented a multi-layer framework, based on Semantic Web technologies, able to enhance the services where the services provided by the framework are used for personalized Web search and Web access personalization.
Besides integrating additional datasets from further social tagging communities, future work will include, on one side, investigating optimization techniques and implementation solutions, different from the ones we have adopted, in order to improve system performance and scalability, and, on the other side, studying how our framework can be extended in order to preferences specification. However, we are aware that a usable GUI could not be enough, since the proposed system may suffer to exploit similar techniques to infer trust policies and users preferences.
 Appendix A. Algorithms for trust policies and user preferences enforcement the value of the component comp of tuple t . Therefore, we denote by . options the different components of a user preference UP
Function E NF UP takes as arguments the set UP of m 's user preferences, the set UTP of m 's trust policies, the set OTP of preferences and trust policies. As first step (lines 2  X  5), function E collected into variable Prefs . Then, the function selects the set LB for UP . More precisely, given a label LB  X  LB , the function stores into variable PDes the descriptors in which the resource property constraints in UP are specified. Whereas those descriptors concerning the topics on which the resource content constraints in UP are specified are stored into variable CDes .

Then, the function analyzes the settings component of the considered user preference (lines 11 such a case, it invokes function E NF TP (see Algorithm 2 ). Function E least one of the policies in UTP .
A similar procedure is performed on owner-defined policies, if this is required by the currently considered user preference current user preference is set to some , will correspond to the set of policies selected by the user (line 18); otherwise, OTP corresponds to all the owner-defined policies applying to the considered resource (line 20). Variable OTP is then passed as next phase (lines 24-27), the set of descriptors and ratings satisfying user-and owner-defined trust policies are combined according to the comb flag in the considered user preference.

The subsequent part of the algorithm (lines 28  X  31) computes the trust value of each property and content descriptor in PDes and CDes .

Then (lines 32  X  49), the descriptors in PDes and CDes matching the property names and topics in the currently considered user and then to compare it with the content constraints specified in the currently considered user preference (lines 43
Algorithm 1. User preference enforcement Algorithm 2. Trust policy enforcement Therefore, the algorithm iteratively considers each constraint ( pc , tc , dc )in selected descriptors satisfy the distribution constraint dc (lines 35 . PC .
 If all the constraints in UP . PC are satisfied (line 41), the algorithm verifies whether the content constraints in or not (lines 42  X  49). The algorithm iteratively considers each constraint ( cc , tc )in on to perform the same verification with the next constraint in loop on the constraints in UP . CC . If all the constraints in variable Assessments and UP 's options, if any, are added to variable Options (lines 50
When all the user preferences have been analyzed, the function returns the quality assessments and the options included in the satisfied user preferences (line 56).

References
