 1. Introduction
In the last few years, lateral inhibition in accumulative computation (LIAC) method ( Ferna  X  ndez-Caballero et al., 2003a, 2003b, 2007, 2008a; Mira et al., 2004 ) and its application to the motion detection task have been introduced ( Ferna  X  ndez-Caballero et al., 2001, 2003c; Mart X   X  nez-Cantos et al., 2008 ). LIAC is a neurally inspired method based on biologically based accumula-tive computation (AC) and lateral inhibition (LI). Currently our research team is involved in implementing this neural method into real-time in order to provide efficient performance in visual Caballero et al., 2008b ).

Also in recent years, many researchers have explored the relation between discrete-time recurrent neural networks and finite state machines, either by showing their computational equivalence or by training them to perform as finite state recognizers from example N  X  eco and Forcada (1997). The relation-ship between discrete-time recurrent neural networks and finite state machines has very deep roots ( McCulloch and Pitts, 1943; Kleene, 1956; Minsky, 1967 ). The early papers mentioned show the equivalence of these neural networks with threshold linear units, having step-like transfer functions, and some classes of finite state machines. More recently, some researchers have studied the close relationships more in detail ( Carrasco et al., 1999; Carrasco and Forcada, 2001 ), as well as the combination of connectionist and finite state models into hybrid techniques ( Prat et al., 2001; Sun et al., 1998 ).
 From the excellent survey on the work by Carrasco and Forcada (2001) that has established a connection between finite state machines and neural networks, we highlight some pre-dominant ideas. Firstly, consider that finite state machines constitute the best characterized computational model, whereas artificial neural networks have become a very successful tool for modeling and problem solving. And indeed, the fields of neural networks and finite state computation started simultaneously. A McCulloch X  X itts (1943) net really is a finite state of intercon-nected McCulloch X  X itts neurons. Kleene (1956) formalized the sets of input sequences that led a McCulloch X  X itts network to a given state, and later, Minsky (1967) showed that any finite state machine can be simulated by a discrete-time recurrent neural net using McCulloch X  X itts units. During the last decades specialized algorithms even have extracted finite state machines from the dynamics of discrete-time recurrent neural networks ( Cleeremans et al., 1989; Giles et al., 1992; Manolios and Fanelli, 1994; Gori et al., 1998 ).

Now, also consider the fact that the use of neural networks for sequence processing tasks has a very important advantage: neural networks are adaptive and may be trained to perform sequence processing tasks from examples. An important issue in the motivation of this paper is that the performance of neural networks  X  especially during learning phase  X  can be enhanced by encoding a priori knowledge about the problem directly into the networks ( Geman et al., 1992; Shavlik, 1994 ). This knowledge can be encoded into a recurrent neural network by means of finite state automata rules ( Omlin and Giles, 1996 ). Our experience up to date has shown that most applications in computer vision, and more concretely in motion detection through LIAC, offer good results with the same values of the parameters of the model.
When neural networks are used to do sequence processing, the most general architecture is a recurrent neural network. And, sequence processors may be built around states. State-based sequence processors maintain and update at each time a state that stores the information about the up to date input sequence, which is necessary to compute the current output ( Forcada, 2002 ).
The state is recursively computed from the state at previous time and the current input using a suitable next-state function. The output is then computed using an output function. As we shall see in this paper, we will introduce all these concepts in our LIAC method applied to motion detection.

The rest of the paper is structured as follows. Section 2 revisits the LIAC method in the motion detection task. Then, Section 3 introduces a proposal for a formal model for LIAC in motion detection, entering into the three steps of the approach, namely
LIAC temporal motion detecting, LIAC spatial X  X emporal rechar-ging and LIAC spatial X  X emporal homogenization. Section 4 depicts the real-time hardware implementation of motion-detection LIAC modules obtained from the previous formal model. Lastly,
Sections 5 and 6 are the Data and results and Conclusions sections, respectively. 2. Lateral inhibition in accumulative computation (LIAC) in motion detection
From Ferna  X  ndez-Caballero et al. (2003a, 2003b) we cite and reformulate the most important concepts and equations of the lateral inhibition in accumulative computation (LIAC) method as formulated for the motion detection task.
 Temporal motion detection : This subtask firstly covers the need to segment each input image I into a preset group of gray level bands ( N ), according to Eq. (1). x  X  i ; j ; t  X  X  This formula assigns pixel  X  i ; j  X  to gray level band k . Then, the accumulated charge value related to motion detection at each input image pixel is obtained, as shown in formula (2): The charge value at pixel  X  i ; j  X  is discharged down to v no motion is detected, is saturated to v sat when motion is detected at t , and, is decremented by a value v dm when motion goes on being detected in consecutive intervals t and t D t . Spatial-temporal recharging : This subtask is thought to reacti-vate the charge values of those pixels partially loaded (charge different from v dis and v sat ) and that are directly or indirectly connected to saturated pixels (whose charge is equal to v where v rv is precisely the recharge value. This step occurs in an iterative way in a different space of time 5 t . The value of D t will determine the number of times the mean value is calculated.
 Spatial-temporal homogenization : In this subtask the charge is distributed among all connected neighbors holding a minimum charge (greater than v dis )  X  now, O k is initialized to z occurs according to Eq. (4).
 O  X  i ; j ; t  X  m D t  X   X  where 8 X  a ; b  X  A  X  i 7 1 ; j 7 1 ; d a ; b  X  Lastly, we take the maximum value of all outputs of the k gray level bands to show the silhouette of a moving object: O  X  i ; j ; t  X  X  argmax 3. Formal model for LIAC in motion detection
The control knowledge is described in extensive by means of a finite automaton in which the state space is constituted from the set of distinguishable situations in the state of accumulated charge in a local memory ( Mira et al., 2004 ). Thus, we distinguish N  X  1 states S 0 ; S 1 ; ... ; S N , where S corresponding to the totally discharged local memory ( v dis general v dis  X  0), S N is the state of complete charge ( v the rest are the N 1 intermediate charge states between v and v
Let us suppose, without loss of generality, that it is enough to distinguish eight levels of accumulated charge ( N  X  8) and, consequently, that we can use as a formal model of the control underlying the inferential scheme that describes the data flow corresponding to the calculation of this subtask an 8 states automaton ( S 0 ; S 1 ; ... ; S 7 ), where S 0 corresponds to v v . Let us also suppose that discharge ( v dm  X  2) and recharge ( v  X  1) initially take the values corresponding to the descent of two states and to the ascent of one state. This way, the state transition diagram corresponds to a particular kind of reversible counter ( X  X  X p-down X  X ) controlled by the result of the lateral inhibition (dialogue among neighbors).

To complete the description of the states, together with the accumulated charge value, v ( v dis r v r v sat ), it is necessary to include some binary signals, A P  X f 0 ; 1 g and A  X f 0 ; 1 g , as it will be explained in Section 3.2. When A pixel tells its neighbors that it has detected a moving object, or that some neighbor has told him to have detected a moving object. A C  X  1 indicates that motion has been detected on the pixel.
 3.1. LIAC temporal motion detecting
The aim of this subtask is to detect the temporal and local (pixel to pixel) contrasts of pairs of consecutive binarized images the 256 gray level input pixels and generates N  X  8 binary images, x  X  i ; j ; t  X  . The output space has a FIFO memory structure with two levels, one for the current value and another one for the previous instant value. Thus, for N bands, there are 2 N  X  16 binary values for each input pixel; at each band there is the current value x turns into x  X  i ; j ; t  X  X  vector quantization (scalar quantization) algorithm generally called multilevel thresholding. As well as segmentation in two gray level bands is a usual thing, here we are in front of a refinement to the segmentation in N gray level bands. Thus, multilevel thresholding is a process that segments a gray-level image into several distinct regions.

Thus, a pair of binarized values at each band, x k  X  i ; j ; t  X  and x  X  i ; j ; t D t  X  , constitutes the input space of the temporal non-recurrent lateral inhibition. The output of subtask LIAC Temporal Motion Detecting constitutes the accumulated charge value, y  X  i ; j ; t  X  , in complete agreement with formula (2), complemented by label A C . Remember that A C  X  1 denotes the fact that a movement has been locally detected by this pixel.
 A  X 
Fig. 1 shows the state transition diagram for the different inputs and outputs.

The following situations can be observed: 3.2. LIAC spatial X  X emporal recharging
In the previous subtask LIAC temporal motion detecting we have obtained the individual  X  X  X pinion X  X  of each computation element. But, our aim is also to consider the  X  X  X pinions X  X  of the neighbors. The reason is that an element individually should stop paying attention to motion detected in the past, but before making that decision there has to be a communication in form of S ( v sat , maximum charge). Otherwise, it will be discharging down pixel that has detected motion.

In other words, the aim of this subtask is to focus on those pixels charged with an intermediate accumulated charge value, y ( v sat ) in state S 7 by incrementing their charge. These  X  X  X otion values X  X  of the previous layer constitute the input space, whereas the output is formed after dialogue processing with neighboring pixels by the so-called permanency value, z k  X  i ; j ; t  X  . Each pixel takes into account the set of individual calculus, v  X  t  X  k D t  X  ; A j , by means of the logical union of the labels: A  X  t  X  X 
This result, A P , is now compared with A C , giving rise to one of two discrepancy classes (recharge or stand-by): D  X  t  X  l D t  X   X 
Subsequently, the class activated outputs the new consensus charge value after dialogue, z k  X  i ; j ; t  X  D t  X  , with D t  X  k D the number of iterations in the dialogue phase, a function of the size of the receptive field. Notice that t is a parameter that only depends on the size of the objects we want to detect from their 00,10 motion. So, the purpose of this inference is to fix a minimum object size in each gray level band.

The whole dialogue process is executed with clock t , during k intervals D t . It starts when clock t detects the configuration z image appears: A  X  A  X  0 ; if D  X  t  X  X  l 1  X  D t  X  X f stand by  X  v sat  X [ recharge g X  13  X 
In each dialogue phase (in other words, in each interval of clock D t ), the calculation element only takes into account values z k  X  i ; j ; t D t  X  , z k  X  i ; j ; t  X  and A moment in its receptive field. To diffuse or to use more distant information, new dialogue phases are necessary. That is to say, new inhibitions in l D t (1 o l r k ) are required. This only affects to state variable A C  X  t  X  ,as z k  X  i ; j ; t D t  X  and z remain constant during the intervals used to diffuse t and to consensus the different partial results obtained by the calculation elements.

Notice that the recharge may only be performed once during the whole dialogue phase. That is why A C  X  0, when a recharge takes place. Lastly, the output will be z  X  i ; j ; t  X  D t  X  X  v C  X  t  X  D t  X  X  14  X 
Fig. 2 shows the state transition diagram, where the following situations are distinguished: (1) z of the pixel X  X  dialogue with the neighbors, at the end of D t the pixel passes to state S 0  X  v  X  v dis ; A C  X  0 . (2) z dialogue phase, the pixel X  X  state will be S 7  X  v  X  v sat (3) z k  X  i ; j ; t D t  X  X  1 ; z k  X  i ; j ; t  X  X  1:
Fig. 4 shows an example with the evolution of the states of the automaton when there is motion in one pixel but no motion in its surrounding neighbors. After motion detection, the pixel X  X  state is to recharge its value.

In Fig. 5 , you may appreciate the evolution of the automata in their neighbors. Again, the pixel X  X  state is set to S 7 detected on it. However, a recharge follows to each discharge (e.g. that these recharges do not take place in the same cycle of the clock signal CLK (notice that CLK represents the clock at higher
A =0
A =0 )
A =0
A =0
A =0
A =1 frequency t ). Indeed, the recharge associated to pixel  X  0 ; 0  X  is 3.3. LIAC spatial X  X emporal homogenization
Now, the aim of this subtask is to obtain all moving patches present in the scene. The subtask considers the union of pixels that are physically together and at a same gray level band to be a component of an object. A set of recurrent lateral inhibition processes are performed to distribute the charge among all neighbors that possess a certain minimum charge ( X  X  X ermanency states S 1 to S 7 , and are physically connected. A double objective is aimed: (1) To dilute the charge due to the image background motion among other points of the own background, so that only moving objects are detected. To dilute the charge due to the image background motion does not mean that we are dealing with moving cameras. Instead of it, we are facing the problem (2) To obtain a parameter common to all pixels of the object
Charge values, offered by the previous subtask, are now evaluated in the center (proper pixel) and in the periphery charge value at this subtask. In the periphery (value v P have the average of those neighbors that have charge values different from y min , the so-called  X  X  X ermanency threshold value X  X . Therefore: v  X  max  X  v C ; y min  X  15  X 
The result of the individual value is compared with the mean value of the neighbors; and the new mean charge values that overcome threshold y min are accepted. After this, the result is again compared with a second threshold, namely y max , eliminat-ing noisy pixels pertaining to non-moving object. Eqs. (5) and (6) are simplified to O  X  i ; j ; t  X  D t  X  X  O  X  i ; j ; t  X  D t  X  X  v dis ; if O k  X  i ; j ; t  X  D t  X  4 y
Fig. 6 illustrates the dialogue scheme and the description of the control automaton where the transitions among the initial state S  X  t  X  (whenever S i  X  t  X  different from S 0 ) and the final state S state are carried out in agreement with rule: S where the sum on sub-index j extends to all neighbors, v j belonging to the subset of the receptive field, RF k , such that its state is different from S 0 , and N k is the number of neighbors with state different from S 0 .

Fig. 7 shows an example of the dialogue with the neighbors, be the mean value of the V s of its four neighbors provided that their charge value is 4 0 when V _ in is 4 0. 4. Real-time hardware implementation of motion-detection LIAC modules
In order to accelerate their performance, and hence to obtain real-time processing rates, many applications use reconfigurable hardware. More concretely, they are programmed on field programmable gate arrays (FPGAs) ( Bensaali and Amira, 2005; Isaacs et al., 2003 ). Some of the most recently used FPGA families are Xilinx Virtex-II ( Amer et al., 2006; Moon and Sedaghat, 2006;
In this section, we show how a single LIAC module, as well as its expansion to an 8 8 module, starting from the formal description as finite state machines, has been implemented (see Fig. 8 ). In order to implement the module, the programming has been performed under Very High Speed Integrated Circuit Hardware Description Language (VHDL), and by means of the Xilinx ISE 9.2 tool, the module has been synthesized and implemented in a Xilinx Virtex-5 FPGA. More concretely, the device used is a 5vlx330tff1738-1.

In Fig. 9 , the L R module possesses the necessary combinational logic to generate the recharge signal R .InFig. 10 there is an insight into the logic of sub-module L R of the module RCH.
Next, Fig. 11 shows the logic of the homogenization sub-module HG .

In Table 1 , the temporal results associated to the implementation are shown, and in Table 2 , the necessary logic for the implementation is offered.

Now, for the implementation of an 8 8 module, using the same FPGA (the 5vlx330tff1738-1), the results obtained are shown in Tables 3 and 4 .

The most relevant data is that clock CLK ( t in our formal model) can work at a frequency of 220.897MHz. Nevertheless, real results will be obtained at a higher time scale ( t ). When working with 8 8 modules, the CLK highest frequency has to be divided by 16. That is to say, the results for 8 8 modules will be obtained at a frequency of 13.806MHz (0 : 0724319 m s). When working with 1280 960 pixel images, which need 19200 8 8 LIAC modules, the results are obtained after 1.39ms. This result may be considered as excellent, as in order to work in real-time we have up to 33ms per image frame. 5. Data and results
In order to test the validity of our implementation, in this section the result of applying 8 8 LIAC modules to a well-known benchmark image sequence, namely the Hamburg Taxi motion sequence from the University of Hamburg, is shown.
The sequence contains 20 190 256 very noisy pixel image frames. Remember that our method only segments moving objects. And, in this case, the sequence contains a movement of four objects: a pedestrian near to the upper left corner and three vehicles.
 Fig. 12 shows the result on odd frames 1 X 17 of the sequence. As expected, due to the region growing technique underlying the LIAC method, the silhouettes of the vehicles slightly go appearing.
As you may appreciate, in frames #1 and #3 only a little portion of the moving vehicles X  silhouette appears. This is because no motion has been detected in a great part of each vehicle respect to the initial frame. Notice, however, that the pedestrian is little enough to be segmented very quickly. Nevertheless, gradually, up to frame #17, mostly the complete silhouette of the vehicles may be observed, as at this frame enough motion exists respect to the initial frame.

As you may appreciate in Fig. 12 there is much noise; that is to say, many pixels appear as belonging to moving objects. This result is easily enhanced by using morphological operators. For instance, after using the closing morphological operator, the results offered in Fig. 13 are obtained. 6. Conclusions
This paper starts from previous works in computer vision, where our lateral inhibition in accumulative computation method applied to motion detection has proven to be quite efficient. We have shown in this article how the LIAC model, based in recurrent neural networks, has been modeled by means of finite state automata, seeking for real-time through an implementation in FPGA-based reconfigurable hardware. Therefore, two steps to-wards that direction have been taken: (a) A simplification of the general LIAC method by formally transforming it into a finite state machine. (b) A hardware implementation of such LIAC modules.
The design by means of programmable logic enables the systematic and efficient crossing from the descriptions of the functional specifications of a sequential system to the equivalent formal description in terms of a Q -states finite state automata or a N -recurrent-neurons neuronal network, where Q r 2 N . Starting from this point, a hardware implementation by means of programmable logic is very easy to perform. This kind of design is especially interesting in those application domains where the response time is crucial (e.g. monitoring and diagnosing tasks in visual surveillance and security).

In this paper, the results obtained after implementing LIAC modules in hardware on programmable logic, concretely on Virtex-5 FPGA X  X , have been shown. These results start from previous validated researches on moving objects detection, which unfortunately did not reach real-time performance. Prior to the implementation, a simplification of the model into an 8-state finite automaton has been performed. The procedure is easily expandable to all delimited-complexity functions that may be described in a clear and precise manner by a not too high number of states, which alternatively are capable of getting the module of the function.
 Acknowledgments
This work was partially supported by the Spanish Ministerio de Ciencia e Innovacio  X  n under Project TIN2007-67586-C02, and by the Spanish Junta de Comunidades de Castilla-La Mancha under Projects PII2I09-0069-0994, PII2I09-0071-3947 and PEII09-0054-9581.
 References
