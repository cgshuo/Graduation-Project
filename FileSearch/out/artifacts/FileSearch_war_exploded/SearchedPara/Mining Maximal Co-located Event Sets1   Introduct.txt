 As one of important spatial data mining tasks, spatial association pattern mining has been popularly studied for discovering spatial dependencies among objects [19,23,25,9,16,13,8,22]. Shekhar et al. [19] defined a spatial association pattern (called spatial co-location ) based on clique neighbor relationships among spatial features. A spatial co-location pattern represents  X  X  set of spatial features which are frequently observed together in a spatial proximity X . Examples of co-location patterns include symbiotic species, e.g., West Nile disease and stagnant water sources in epidemiology [12], and in terdependent events, e.g., traffic jam, car accident, ambulances and police men in transportation [18]. Co-location min-ing results can be also used for finding dependencies among services requested by mobile users close in the geographic sense or discovering the relationship of spatial distributions among various kinds of mineral elements for geologists.
The problem of mining association rules based on spatial predicates (e.g., close to , near and overlap ) was first discussed in [13]. Mo st of spatial association min-ing algorithms [16,13,19,23,25] use a generation-and-test method like Apriori . Apriori-inspired co-location mining algorithms traverse the search space in a breadth-first manner and find prevalent co-located event sets by enumerating their co-location instances from an input spatial dataset. In order to produce a co-located event set of length k ,all2 k of its subsets are searched since they too must be co-location patterns. The size of search space in spatial co-location mining gives more significant effect on the computational performance than clas-sical association mining since a large fraction of the computation time is devoted to identifying co-location instances having clique relationships from input spa-tial data. When very long patterns present in the data, it is often impractical to generate the entire set of co-location patterns. Current algorithms may be restricted for short length patterns or sparse data. However, long co-location patterns often present with large or dense spatial neighborhoods.

To address this problem, we propose an algorithm for finding maximal co-located event sets which concisely represent al l co-location patterns. We follow the defi-nition of maximal in classical association rule mining [17]. A co-located event set with a minimum prevalence is maximal if and only if it has no super event set that is prevalent. In classical data mining lit erature, there are many works for discov-ering maximal frequent itemsets from transaction databases [17,26,14,4,10]. How-ever, it is non trivial to reuse them direct ly for discovering maximal co-locations since, unlike market-basket data, distinct transactions are not explicit in spatial data. Spatial objects are embedded in a continuous space and share a variety of spatial relationships with each other. The depth and complexity of pattern search space in large and dense spatial databases also make challenges in finding maximal co-location patterns.

The main contributions of this work are to formulate the maximal co-location mining problem, and develop an algorithm (MAXColoc) for efficiently extracting only maximal co-located event sets from large spatial data. The proposed algo-rithm generates only most promising candidates and traverses the pattern search space in both depth-first and breadth-first manners. The depth-first traversal is used in order to quickly identify maximal co-location patterns. A  X  subset pruning by a superset  X  strategy is used for further reducing the search space throughout the mining process. We use the breadth-first traversal for pruning all subsets of maximal co-locations. Our schemes ev entually reduce the expensive opera-tion to find co-location instances forming cliques. We show that the algorithm is correct and complete in finding maximal co-locations. Experimental results with real data and synthetic data show that the proposed algorithm is effec-tively to reduce the number of candidates and computationally efficient over a state-of-the-art co-location mining algorithm in finding maximal co-locations.
The remainder of this paper is organized as follows. Section 2 shows the basic concept of co-location pattern mining, our problem statement, and the related work. Section 3 describes the proposed algorithm and analysis. The experimental result is presented in Section 4. S ection 5 ends with the summary. We first introduce the basic concepts of spatial co-location mining and then present our problem statement and the related work. 2.1 Basic Concepts of Spatial Co-location Mining Given a set of spatial event types E , a set of their observed objects S ,andaneigh-bor relationship R over S ,a co-location X is a subset of spatial event types, X  X  E , whose objects frequently form cliques under the neighbor relationship (i.e., are neighbors to each other). The term co-location is interchangeably used with a co-located event set throughout this paper. When the Euclidean metric is used for the neighbor relationship R , two spatial objects are neighbors if the ordinary distance between them is not gre ater than a given distance threshold. Fig. 1 (a) shows an example spatial dataset which has five spatial event types named with A, B, C, D and E. Each object is represented by its event type and unique id, e.g., A.1. Identified neighb or objects are connected by a line in the figure. A co-location instance I of a co-location X is a set of objects, I  X  S , which includes the objects of all event types in X and forms a clique neighbor relationship. For example, in Fig. 1 (a), { A.1, C.1, E.1 } is a co-location instance of { A, C, E } but { A.3, C.3, E.2 } is not. We also call the co-location instance the clique instance . The prevalence strength of a co-location pattern is often measured by its participation index [19]. The participation index Pi ( X )ofa participation ratio of event type e i in a co-location X = { e 1 ,...,e k } ,thatis the fraction of objects of event e i in the neighborhood of co-location instances of X  X  X  e sure indicates that wherever an event in X is observed, with a probability of at least Pi ( X ), all other events in X can be observed in its neighborhood. For ex-ample, in Fig. 1 (a), there are two instances of a co-location X = { A,C,E } , { A.1, C.1, E.1 } and { A.4, C.1, E.1 } . The participation ratio of event A in X , Pr ( X , A) is 2 4 since only A.1 and A.4 among four objects of event A are involved in the co-location instan ces. In the same way, Pr ( X ,C)is 1 3 and Pr ( X ,E)is 1 2 .Thus the participation index of X , Pi ( X ), is min { Pr ( X ,A), Pr ( X ,C), Pr ( X ,E) } = . All co-located event sets having parti cipation index above a given minimum prevalence threshold are return ed as prevalent co-locations. 2.2 Problem Statement We define a key term and the problem statement for finding maximal co-location patterns.
 Definition 1. If X is a co-located event set which is prevalent but no super event set of X is prevalent, we say that X is a maximal co-location . Given 1) A set of spatial event types E = { e 1 ,...,e m } 2) A dataset of spatial point objects S = S 1  X  ...  X  S m where S i (1  X  i  X  m )is a set of objects of event type e i . Each object o  X  S i has a vector information of &lt; event type e i , object id j ,location( x, y ) &gt; ,where1  X  j  X | S i | . 3) A spatial neighbor relationship R 4) A minimum prevalent threshold  X  Develop An algorithm to find all maximal co-locations efficiently in computation. Constraint The result set of maximal co-loca tions is correct and complete. 2.3 Related Work Spatial association rule mining problem was first discussed in Koperski et al. [13]. Castro et al. [6] proposed a clustering-based map overlay approach for discover-ing spatial association patterns. Most works on co-location pattern mining have presented different approaches for identi fying co-location instances and choos-ing interest measures. Morimoto [16] discovered frequent neighboring class (i.e., co-located event) sets using a support count measure. Shekhar et al. [19] pro-posed statistically meaningful interest measures for co-location patterns and a join-based co-location mining algorithm. Approaches to reduce expensive join operations used in [19] for finding clique instances were proposed in [23] and [25]. Xiao et al. [22] proposed a density based approach for identifying co-location instances. Zhang et al. [27] enhanced the co-location pattern proposed by [19] and proposed an approach to find spatial star, clique and generic patterns. Al-Naymat [2] proposed the problem of enumeration of maximal cliques for mining spatial co-location patterns. This work can find maximal co-location patterns as ours. However it finds prevalent maximal co-locations after retrieving all max-imal cliques. Clique enumeration problem is known as NP -Hard, and is well studied in graph theory [1,15,21]. We more concern to reduce candidate event sets and to find clique instances for only filtered candidates.

In classical data mining lit erature, there are many works for discovering max-imal frequent itemsets from transaction database [17,26,14,4,10]. Bayardo [17] proposed the Max-Miner algorithm for discovering maximal frequent itemsets. Zaki et al. [26] presented the algorithms MaxEclat and MaxClique for iden-tifying maximal frequent itemsets. Lin et al. [14] have proposed an algorithm called Pincer-Search for mi ning long maximal frequent itemsets. MAFIA [5,4] is the most recent method for mining the p atterns. We adopt one of its pruning strategies for our algorithm. We first describe our algorithmic design concept in four parts: preprocess, candi-date generation, candidate pruning and instance filtering, and then present the algorithm. In the end, we analyze the proposed algorithm for completeness and correctness. 3.1 Preprocess An input spatial dataset can be represented as a neighbor graph with the spatial objects being its vertex set and an undirected edge between two objects where they are neighbors each other as shown in Fig. 1 (a). A brute-force approach to discover maximal co-location patterns is first to find all co-location instances forming cliques from the neighbor graph, compute a participation index per event set and then find out the maximal co-locations. However, it is computationally expensive to find all cliques directly from a graph [7]. Instead, we represent the input spatial data as a set of neighborhood transactions.
 Definition 2. Given a spatial object o i  X  S ,the neighborhood transaction type = o j seventtype } ,where R is a neighbor relationship.
 For example, in Fig. 1 (a), C.1 has neighbor relationships with each A.1, A.4, D.2 and E.1. The neighborhood transaction of C.1 is { C.1, A.1, A.4, D.2, E.1 } including itself as shown in Fig. 1 (b). Note that each object in a transaction has a neighbor relationship with the first object, C.1, which is called a refer-ence object. The set of distinct events in the neighborhood transaction is called an event neighborhood transaction . The size of event neighborhood trans-actions is usually much smaller than the original neighborhood transactions. Event neighborhood transactions are use d for generating candidate event sets. Neighborhood transactions are used for filtering their co-location instances. 3.2 Candidate Generation Rather than considering all possible sets, it would be desirable to focus on only candidates which can have a clique relationship. For example, in Fig. 1 (a), the objects of events A, B and D do not make any clique relationship. If we know this kind of event sets in advance, we can avoid se arching their co-location instances. It is important to reduce the number of candidate sets since a large fraction of the computation time is devoted to identifying their co-location instances having clique relationships [24]. The basic idea of our candidate generation is properly combining the event neighbor information of each reference event.

First, we generate event sets for co-location candidates using modified FP-tree and FP-growth algorithm [11]. FP-tree is a popular data structure for association rule mining. We adopt the data structure to store the neighbor relations of a reference event type. We build one FP-tree per each event type and combine the results of frequent event sets from each tree to generate co-location candidates. In Fig. 2, let us see a tree which stores the neighbor relation information of event type A. The tree consists of one root labeled as a reference event type (here, A) and a set of event prefix subtrees as the children of the root. Each node of the tree consists of three fields: event  X  type , count ,and node  X  link ,where event  X  type denotes an event this node represents, and count registers the number of event neighborhood transactions of the refer ence event represented by the portion of the path reaching this node. And node  X  link links to the next node in the tree carrying the same event-ty pe. We call the tree to the candidate pattern tree of a reference event.

Frequent event sets with a minimum thres hold (i.e., a given prevalence thresh-old) are generated from each candidate pattern tree using FP-growth algo-rithm [11]. The difference from the output of the original FP-growth is that each set has the event item of the root node as its first element. Fig. 2 (a) shows event sets generated from each tree. We call the result  X  star candidates  X  X ince all elements in a set have neighbor relationships with its first element (which was the root node of the tree). The output also gives a frequency information, i.e., support, which presents the frequency that its first item has a neighbor rela-tionship with all other items in the set. That represents the upper bound of the chance (i.e., participation ratio) that the reference event has a clique relationship with the other events in the set.

After generating all star candidates, we combine them for filtering co-location candidates. For example, in Fig. 2 (a), to be { A,B,C } a co-location candidate, three star candidates { A,B,C } , { B,A,C } and { C,A,B } should be there. Fig. 2 (b) shows all combined candidates which are called  X  clique candidates  X  X r X  co-location candidates  X .
 3.3 Candidate Pruning We present additional scheme (  X  X ubset pruning by a superset X  ) to reduce the can-didates further during the pattern mining process. Fig. 3 (a) shows the pattern search space with candidates generated using a lexicographic subset tree. We as-sume that there is a total ordering  X  L of the event item (e.g., lexicographic). In the subset tree, the size k event sets are ordered lexicographically on each level and all children are associated with the earliest subset in the previous level. The event set identifying each node will be referred to as the node X  X  head , while pos-sible extensions of the node are called the tail . For example, consider node Y in Fig. 3 (a). Y  X  X  head is { A } and the tail is the set { B,C,D,E } . The head union tail (HUT) is { A,B,C,D,E } . These terms are borrowed from [5].

We traverses the subset tree in both depth-first and breadth-first manners during the maximal mining process. The depth-first traversal is used in order to quickly identify maximal co-location patterns. The breadth-first traversal is used for the subset pruning by supersets. Once we determine maximal event sets at each level, we do the subset pruning with checking whether the HUT of each node is a subset of a current maximal set. If the HUT is a subset, the subtree whose root is the current node is pruned out. For example, in Fig. 3 (a), suppose {
A,C,D,E } is a maximal co-located event set. In the first level, the HUT of a node having A is { A,B,C,D,E } . Since it is not a subset of { A,C,D,E } , we cannot prune the subtree whose root is A. Next, see the node having C. The HUT is {
C,D,E } which is subset of the maximal { A,C,D,E } . We thus prune the subtree rooted at C. Fig. 3(b) shows the status of the search space tree after pruning all subsets with a maximal co-location { A,C,D,E } . 3.4 Candidate Instance Filtering To find co-location instances having clique relationships efficiently, we use a filter-and-refine strategy. The instances of a co-location candidate are gathered with scanning neighborhood transactions whose first item X  X  event type is the same with the first item of the candidate. The instances are called star instances . 3.5 Algorithm and Analysis We present an algorithm for mining MAXimal Co-location patterns (MAX-Coloc). Algorithm 1 shows the pseudo code.
 Preprocess(Step 1-2): Given an input spatial dataset and a neighbor relation-ship, first find all neighboring object pairs using a geometric method such as plane sweep [3], or a spatial query metho d using quaternary tr ees or R-trees [18]. Neighborhood transactions are simply generated with grouping the neighboring objects per each object. Event neighbor hood transactions are generated with event types in the neighborhood transactions.
 Candidate Generation (Step 3-6): A candidate pattern tree per each event type is constructed with the event neighborh ood transactions of the reference event. Star candidates with the minimum prevalence are generated using a project based mining algorithm (FP-growth) [11]. Co-location candidates are filtered with combining the star candidates.
 Select size k co-location candidates (Step 7-9) : The maximal pattern mining is processed from the longest size of c andidate events to size 2. Select size k candidates from the candidate pool.
 Gather the star instances of candidates (Step 10): The star instances of candi-dates are gathered from the neighborhood transactions whose first object X  X  event type is the same with the first item of the candidate.
 Filter the co-location instances of a candidate and compute its participation in-dex (Step 11-15): Next filter true co-location instances from the star instances of a candidate examining all neighbor relationships of objects except the first object in the star instance. Here we use neighbor pair information generated in preprocess without additional geographic operations. After finding all true instances of a candidate, compute its participation index.
 Update the result set and prune the subsets (Step 16-17): If the candidate set X  X  participation index is greater than a prevalence threshold, it becomes a maximal co-location and is inserted in the res ult. All subsets of the maximal set are removed from the set of remaining candidates.
 Return the final result (Step 20): The procedure of step 8 to step 19 is repeated until k reaches to 2 or there is no candidate. Finally, return the final result of the maximal patterns.
 Next we analyze the proposed algorithm (MAXColoc) for completeness and cor-rectness. Completeness means MAXColoc finds all maximal co-locations which satisfies Definition 1. Correctness means t hat co-located event sets discovered by MAXColoc are all maximal co-locations.
 Theorem 1. The MAXColoc algorithm is complete and correct.
 Proof. The completeness can be briefly explained in the following two parts. First, we show that the candidate generation and pruning procedures do not drop any potential maximal event sets. The candidate generation procedure ( step 3-6 ) filters a candidate event set using the upper bound of participation ratio of its reference event and the combine procedure is correct. The true participation ratio of an event is not greater than its upper bound value. The participation index of a co-location is a minimum value of all participation ratios of it. The subset pruning procedure ( step 17 ) drops only the subsets of maximal co-locations since the comparision with the HUT of a node is correct. Second, we need to show the methods to find co-location instances are correct. The neighborhood transactions generated from the neighboring objects of each object do not miss any neighbor relation ( step 1-2 ). Instances gathered from the neighborhood transactions whose first item X  X  event type is the same as the fi rst item of a co-located set, has correct star relationships( step 10 ). Any co-location instance is not missed since the star instances are a super set of the clique inst ances of co-location. It is also correct to filter co-location(clique) instances from the star instances using neighbor pair information ( step 12 ). In the other hand, the correctness of MAXColoc algorithm can be guaranteed by steps 14 and 16 .By step 17 , the candidate pool keeps maximal candidates. If a candidate is prevalent, it becomes a maximal set. We examined the computational effectiveness of MAXColoc in mining maximal co-location patterns. We co mpared MAXColoc with a gen eral co-location mining algorithm [19] which is called  X  X eneralColoc X  in this paper. GeneralColoc has a postprocess to return only maximal sets . We used synthetic data and real data for the experiment. A synthetic dataset(DATASET#1) had 54 event types and a total of 5378 data points. The max neighbor degree (number of neighbors) is 31. The real data is about points of interest(POI) in California from [20]. We view the category type such as  X  X hurch X ,  X  X chool X  and  X  X liff X , as event type . We made several experiment datasets from this base data. One dataset (DATASET#2) has 9949 data points in San Francisco area with 50 different event types. The other datasets (DATASET#3, #4, #5 and #6) have each 12000, 24000, 36000 and 48000 data points with 40 event types. All the experiments were performed on a PC Linux system with 2.0 GB main memory. Main programming language for the implementation is C++. 1) Comparison in the number of candidates: First, we examined the numbers of candidates considered for finding their co-location instances from MAXColoc and GeneralColoc using DATASET#1. The minimum prevalence threshold was 0.1. As shown in Fig. 4 (a), MAXColoc generates much less number of candidates compared with GeneralColoc. MAXColoc has zero candidate at size 2 and the mining process finishes at size 3. In contra st, GeneralColoc dra matically increases the number of candidates until size 7. 2) Effect of prevalence threshold: Next, we examined the performance effect with different prevalence thresholds. We used DATASET#2 for this experiment. As shown in Fig. 4 (b), the execution times for the MAXColoc and GeneralColoc have decreased with increase of the threshold value. MAXColoc shows overall better performance than GeneralColoc. 3) Effect of the number of data points: In the last experiment, we compared the effect of the number of data points in the different algorithms. We use four datasets different in size (DATASET#3, #4, #5 and #6). As shown in Fig. 4 (c), the execution times increased with number of data points. MAXColoc slowly increased compared w ith GeneralColoc. In this paper, we propose an algorithm for finding maximal co-located event sets which concisely represents all co-location patterns. The proposed algorithm has a preprocess to convert input spatial data to sets of neighborhood transactions. It reduces examined candidates and trav erses the maximal search space in a depth-first manner with an effective pruning mechanism. The algorithm also uses a filter-and-refine strategy for finding co-location instances. A few experiment results show that the proposed algorithm performs more efficiently against a general co-location mining algorithm in finding maximal co-location patterns. Acknowledgments This research was partly supported by Information Analytic and Visualization Center, IPFW.

