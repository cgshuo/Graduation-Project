 An XML document is typically modeled as a node-labeled tree T . For a given keyword query Q , each result T v isasubtreeof T containing each keyword of Q at least once, where the root node v of T v should satisfy a certain query semantics, such as SLCA [4] or ELCA [1]. Based on the set of qualified root nodes, researchers proposed three kinds of subtrees: (1) complete subtree (CSubtree) T C v , which is rooted at a node v and is excerpted from the original XML tree without pruning any information; (2) path subtree (PSubtree) T P v , which consists of paths from v to all its descendants, each of which contains at least one input query keyword; (3) matched subtree (MSubtree) T M v [3], which is a subtree after removing redundant information from T P v based on specific constraints. Let S u be the set of distinct query keywords contained in the subtree rooted at node u , S u  X  Q . Intuitively, a subtree T v is an MSubtree if for any descendant node u of v , there does not exist a sibling node w of u , such that S u  X  S w , which we call as the constraint of  X  keywords subsumption  X .
 Example 1. For query Q 1 and XML document D 1 in Fig. 1, the qualified SLCA node is node 7, and ELCA nodes are node 2 and 7. If the adopted query semantics is SLCA, then the CSubtree T C 7 is the subtree rooted at node 7, the PSubtree T P 7 and MSubtree T 7 are shown in Fig. 1. If the query semantics is ELCA, then the CSubtree sarethe two subtrees rooted at node 2 and 7; the PSubtree sare T P 2 and T P 7 ;andthe MSubtree s are T M 2 and T M 7 , respectively.

From Example 1 we know that CSubtree and PSubtree could make users feel frus-trated since they may contain too much irrelevant information. As a comparison, an MSubtree contains all necessary information after removing nodes that do not satisfy the constraint of keywords subsumption, and is more self-explanatory and compact.
However, most existing methods [4, 6] addressing efficiency focus on computing qualified root nodes, such as SLCA or ELCA nodes, as efficient as possible. In fact, constructing MSubtrees is not a trivial task. [3] adopts a three-step strategy to get all MSubtrees: ( Step1 ) scans all nodes in the set of inverted lists to get SLCA results. ( Step2 )getsasetof relevant keyword node s (RKNs) for each SLCA result v by res-canning all these nodes again, this RKN set covers, in the set of inverted lists, all v  X  X  descendant nodes that are not contained by other subtrees rooted at v  X  X  descendant LCA nodes. ( Step3 ) constructs a PSubtree for each RKN set , and then apply the constraint of keywords subsumption on this PSubtree to get the corresponding MSubtree. The prob-lems of [3] lie in two aspects: (1.1) no matter how many useless nodes can be skipped in Step1, Step2 will visit all these nodes to get all RKN sets; (1.2) no matter how many useless nodes are containe d by each PSubtree, they all need to firstly construct the PSubtree containing these useless nodes, and then make pruning.

Further, the wide availability of commodity multi-core (processor) systems allows concurrent execution of multip le threads through the use of multiple simple processing units (cores) with shared-address space on a single chip. For keyword query processing on XML data, however, prior algorithms assume a uniprocessor architecture, ignoring the potential for performance improvement that a chip multi-core system can offer. With the increase of the number of cores (processors) on a single chip, it is imperative to incorporate this hardware trends in algorithm design, for which the core problem is designing a good (if not best) d ata partitioning tec hnique, such that different threads can be executed independently.
 In this paper, we focus on efficiently co mputing all MSubtrees rooted at SLCA or ELCA nodes on a multi-core system. We firstly propose a generic top-down subtree construction strategy, where  X  generic  X  means that our method is independent of the query semantics, i.e., SLCA or ELCA;  X  top-down  X  means that our method constructs each MSubtree by visiting nodes o f the corresponding PSubtree level-by-level from left to right , such that to avoid visiting as many useless nodes as possible. Based on the top-down subtree construction strategy, we propose a two-step algorithm, namely TDM, for XML keyword query processing on XML data. Same as [3], Step1 of our method is used to find qualified SLCA/ELCA nodes. Different with [3], Step2 of our method is used to compute all MSubtrees, that is, Step2 is the union of the last two steps of [3]. We show that based on our top-down subtree construction strategy, for all SLCA/ELCA nodes, Step2 of our method can be executed independently by different threads. As Step1 usually consumes less than 10% overall processing cost, the parallel processing of Step2 significantly improves the overall performance. We model an XML document as a node-labeled tree, where nodes represent elements or attributes, while edges represent direct nesting relationship between nodes. If a keyword k appears in the node name, attribute name, or text value of v ,wesay v directly contains k ;otherwise,if k appears in the subtree rooted at v ,wesay v contains k .InFig.1,we assign each node an ID, which is its depth-first visiting order, based on which we can get the variant of its Dewey label by concatenating all IDs of its ancestors. E.g., for node 7, we denote its Dewey label as  X 1.2.5.7 X . Given two nodes u and v , u  X  a v denotes u is an ancestor node of v , u ' a v denotes u  X  a v or u = v .

For a given query Q = { k 1 ,k 2 , ..., k m } and an XML document D ,weuse L i to denote the inverted Dewey label list of k i . Fig. 2 shows the inverted lists of Q 1 . Among existing query semantics, Smallest Lowest Common Ancestor (SLCA) [4] defines a subset of all Lowest Common Ancestors (LCAs) of Q , of which no LCA is the ancestor of any other LCA. In Fig. 1, the qualified SLCA node of Q 1 on D 1 is node 7. Compared with SLCA, ELCA tries to capture more meaningful results. A node v is an ELCA if the subtree T v rooted at v contains at least one occurrence of all query keywords, after excluding the occurrences of the keywords in each subtree T v rooted at v  X  X  descendant LCA node v .InFig.1,theELCAsof Q 1 are node 2 and 7.
 Given a query Q , assume that v is an x LCA node ( x LCA can be either SLCA or ELCA), and keyword node u satisfy v ' a u ,wesay u is a relevant keyword node (RKN) of v if there does not exist other LCA nodes of Q on the path from v to u .The set of RKNs of v is denoted as RKN ( v ) , which contains at least one keyword node w.r.t. each keyword of Q . E.g., for query Q 1 and D 1 in Fig. 2, ELCA nodes are node 2 and 7, RKN (2) = { 3 , 4 , 25 , 26 } , RKN (7) = { 8 , 9 , 11 , 12 , 14 } . Note that since node 5 is an LCA node, according to RKN X  X  definition, node 6 is not an RKN of node 2, because node 6 is not taken into account wh en checking node 2 X  X  satisfiability. Our method adopts a two-step strategy to get all MSubtrees. In the first step, it gets a set of x LCA nodes by calling either one of the state-of-the-art algorithms [1, 4, 6]. In the second step, it firstly computes the RKN set for each x LCA node v , then constructs the corresponding MSubtree.  X  X DM X  means that our method computes all MSubtrees in a top-down way. 3.1 Computing RKN Sets To get all RKNs for each x LCA node v , our method directly takes all descendant nodes of v in each inverted list as RKNs of v , which we call as the relaxed interval sets of v . In this way, the task of computing RKNs for all x LCA nodes can be executed in parallel . Although such interval sets may contain non -RKNs for each x LCA node v , our algorithm can wisely avoid processing those useless nodes when constructing MSubtrees. 3.2 MSubtree Construction Themainideais: adding nodes to T M v in a top-down way, whenever it finds a useless node u , all other nodes in T P u will be directly pruned . The technical problems we need to solve are: ( P 1) how to know, for a given node u , the keyword set S u without visiting its descendant keyword nodes; ( P 2) as many sibling nodes may correspond to the same keyword set, and all these nodes may be valid nodes of an MSubtree, we need to know how to reduce the cost of checking whether the given keyword set S u is subsumed by, or subsumes that of u  X  X  sibling nodes.

For P 1 , the checking of whether a node u in the j th level of the given XML tree contains k i is very simple: if u appears in the j th level of L i ,then u contains k i . Given the current node u , the problem is how to get the next distinct node ID. This problem can be efficiently solved by using binary search, which takes u  X  X  ID as the key to probe all IDs of the same level of L i to find the smallest ID that is greater than u  X  X  ID.
For P 2 , we proved that the number of distinct keyword sets that are not subsumed by, or subsume other keyword sets is bounded by C m/ 2 m . Based on this result, we dis-tribute all u  X  X  child nodes into different distinct keyword sets that are not subsumed by, or subsume other keyword sets. In this way, the operation of checking the subsumption relationship of keyword sets for different sibling nodes can be transformed into directly checking the subsumption relationship between different keyword sets. Compared with MaxMatch, our method reduces the cost of checking the subsumption relationship for each node from O (2 m ) to O ( C m 2 m ) . Example 2. To construct T M 7 for Q 1 , our method firstly processes node 7, then adds adds these node sets into a temporary queue Q one by one. The next processed node is node 13, as S 13 = { XML } X  X  XML, WAIM } , node 13 will be skipped. After that, we remove node 8, 9 and 10 from Q and insert them into T M 7 , then we delete V { Tom } , V child nodes of node 10, i.e., node 11 and 12, which are added into two node sets and inserted into Q . After that, the two nodes are removed from Q and inserted into T M 7 . 3.3 Execution on a Multicore System We consider two kinds of strategies for executing Step2 of our method in parallel on a multicore system: (S1) each thread actively steals an x LCA node from the set of input x LCA nodes after it completes constructing the previous MSubtree; (S2) actively distribute all x LCA nodes evenly to all threads.

The benefit of the first strategy lies in that if different MSubtrees have huge differ-ence in their sizes, it can roughly guarantee that different threads have similar workload; however, when the size of all MSubtrees is small, it may suffer from more communica-tion and synchronization cost between these threads. As a comparison, the benefit of the second strategy lies in that it can completely avoid the communication and synchroniza-tion cost between different threads, but when different MSubtrees have huge difference in their sizes, it cannot guarantee that different threads have similar workload.
Note that our TDM algorithm can be easily extended to support different query se-mantics, such SLCA and ELCA, and different kinds of subtree results, such as PSubtree, RTF [2], TMSubtree [5], etc. Our experiments were implemented on a PC with dual six-core Intel Xeon E5-2620 CPUs running at 2.00GHz, 16GB memory, 500 GB IDE hard disk, and Windows XP professional as the operating system. The al gorithms used for comparison include Max-Match [3] and TDM, and were implemented to support both SLCA and ELCA seman-tics. For ELCA (SLCA) semantics, the algorithm used in Step1 is FwdELCA (Fwd-SLCA) [6]. All these algorithms were implemented using Microsoft VC++. The run-ning time is the averaged over 100 runs w ith hot cache. We selected 12 queries from XMark (http://monetdb.cw i.nl/xml) dataset of 582M B for our experiments.

Fig. 3 (A) shows comparison of the running time, from which we know that TDM performs faster than MaxMatch by at most two orders of magnitude (QX4). The reason lies in that MaxMatch needs to visit all nodes in the set of inverted lists to get all RKNs, and visit all nodes of each T P v . Fig. 3 (B) shows the comparison of the running time for the TDM-E algorithm executed by different number of threads on a multicore system, where the number before  X  X  X  denotes the number of threads,  X  X 1 (S2) X  denotes the first ( second ) parallel strategy (see Section 3.3),  X  X vg X  is the averaged running time for QX1 to QX12. From Fig. 3 (B) we know that the performance gain is not significant when the number of threads becomes large , this is because, with the increase of the number of threads, the impacts of Step1 is more significant since it cannot be executed in parallel. The third observation is that, since S1 roughly guarantees all threads have similar workload, S1 works better than S2 by 9%, 8% and 6% for two, four and eight threads on average, however, when the whole task is evenly distributed to all threads, S2 is better than S1 by avoiding the synchronization cost (QX5). Considering that existing methods suffer from inefficiency in MSubtree construction, we proposed a two-step generic top-down subtree construction algorithm, namely TDM, to support different kinds of query semantics and subtree results, and can be executed in parallel to utilize computational power of a multicore system. The experimental re-sults verified the performance benefits of our method according to various evaluation metrics.
 Acknowledgment. This research was partially supported by the National Natural Sci-ence Foundation of China (No. 61073060, 61272124), the Research Funds from Educa-tion Department of Hebei Province (No. Y2012014), and the Science and Technology research and development program of Hebei Province (No. 11213578 ).

