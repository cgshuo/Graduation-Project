
Knowledge acquisition (KA), i.e. the development and maintenance of knowledge bases (KB), e.g. an expert system, can be divided into several phases, performed sequentially and iteratively. Some phases may be performed in parallel with other phases. The most commonly recognised phase s are requirements defi nition, analysis, design and implementation.
 abstract and executable descriptions, was recognised during the early stages of KA (Marcus 1988a; Motta et al. 1988). It complicates the development of KBs and hinders traceability between parts of abstract and executable descriptions. The gap problem has been overcome in narrow-focused automated tools (Marcus 1988a; Leo et al. 1994; Grosso et al. 1999) that often use problem-solving methods (PSMs), getting their power from understanding th e roles that domain knowledge plays in problem solving. In problems in which scope-restricting heuristics cannot be used, the gap problem must be confronted using alternative solutions.
 present knowledge on several layers of abstraction. The structure of possible in-ference sequences, i.e. the inference structure , refers to components of the domain layer. Prot  X  eg  X  e-2000 (Fridman Noy et al. 2000) uses a metaobject protocol based on classes, instances of which are classes ( Steele 1990; Kiczales et al. 1991), to describe a model (Schreiber et al. 2000). This allows application knowledge to be presented as instantiations of the domain model.
 A metaobject protocol contains objects on three levels of abstraction: Ametaclass is a class, the instances of which are themselves classes.
Class attributes with types describe a group of objects. Behaviour is defined through An instance (in this article) is an instance of a class other than a metaclass.
The use of metaobject protocols is described in Sect. 3.1.
The SeSKA KA methodology (seamless structur ed knowledge acquisition) (Parpola 1998, 1999b, 1999a) is meant for the construction, use and maintenance of KBs. It is developed to enhance integration of the KA process in several ways. modified. The structure of a KB is based on the logical structure of the domain, which has been noticed to be more stable than the component structure (Jacobson et al. 1992).
 2002, 2001, 2000) implements the ideas sketched in SeSKA. All the information in SOOKAT is presented and handled as objects. The paper is structured as follows:
Section 2 briefly describes SeSKA from diffe rent perspectives, namely essential fea-tures, the construction process and possible implementations. Section 3 gives an overview of SOOKAT, describing its use of metaobject protocols, its architecture and the support SOOKAT provides for the cons truction process. Section 4 describes the principles of reasoning in the instantiated models of a KB. The instantiation of models, the basic principles of inference through message sending and assignment, the use of control objects, the generating o f explanations and inference according to alternative methods, especially the use of protocols and the cover-and-differentiate and propose-and-revise PSMs, are described. Section 5 discusses related work. Sec-tion 6 contains discussion and conclusions.
Use of uniform presentations. Phases of the KA process with varying characteristics (including the observation-oriented gathering of knowledge and operationality oriented execution of knowledge) should use compatible presentations (Parpola 1998). In this way, informal descriptions could be directly utilised in developing executable presentations. Domain knowledge is acquired in SeSKA through two separate models:  X  the domain model for somewhat stable knowledge (described through a net- X  dependency graphs for dynamic knowledge (described through a network of
These formalisms can be produced using several different KA techniques (Parpola 1999a). Heterogeneous vocabulary can also be harmonised.

Integration of a structured set of models through transformation. Seamless trans-formations , i.e. predefined ways of getting from objects in one model to objects in another model (Jacobson et al. 1992; Parpola 1998), are defined between most sequential models in an iterative chain. The models in the chain are illustrated in Fig. 1.

Maintenance of the KB structure through a shared skeleton. The inference struc-ture (IS) describes the structure of possible inference sequences through a net-work of  X  roles , referring to concept attributes, and  X  inference steps , having attached analysis , design and implementation descrip-The possibility of performing inferences described in the models.
 A KB is constructed in the following phases:
Initial formation of the models describing the domain. The initial domain model
Combining dependencies and attribute values. Complementary dependency graphs
Forming an inference model based on dependencies and their descriptions. An
Formalising descript ions of inferences. Analysis descriptions are formalised to im-
Managing change through sea mless transformations. Often, a need for change is acknowledged during the development or maintenance of a KB through imple-mentation errors or other instabilities in the design or implementation models.
The corresponding parts of the analysis model are traced using the shared infer-ence structure. It may frequently be the practice to describe changes that have already been carried out, but it is important to keep the logical description up to date.
To implement SeSKA, an implementation paradigm should be able to define and modify entities with properties, relations between entities, inheritance and instances. These facilities enable the presentation of metalevel constructions.
At least the OO approach and conceptual graphs (CG) (Sowa 1984) are acceptable formalisms. and partially modified during the iterative development process.
SOOKAT uses two metaobject protocols, for domain and inference models, in order to be able to  X  present and modify application instan ces and their attributes (see Sect. 1.2),  X  at run time, create and modify concepts with instances (see Sect. 4.1), so that the modifications transfer to instances, and  X  use instantiations of the inference structure to apply abstract rules defined in the inference model to application instances of concept attributes (see Sect. 4.1).
Instantiation models are created in order to complete use of metaobject proto-cols. Taking full advantage of using the metaobject protocols means being able to simultaneously modify and use the knowledge base.
The tool is implemented in the Java programming language, which does not inher-ently contain a metaobject protocol, such as e.g. the Lisp programming language.
Metaclasses Concept , Role and Inference are implemented as normal Java classes in the domain model (see Sect. 3.2.1) or the inference model (see Sect. 3.2.3). Classes (in SOOKAT, called application classes in order to distinguish them from Java classes) are implemented as instan ces of the metaclasses Concept, Role and Inference.

Instances of application classes (called application instances) are implemented as
Example 1. Instances of the metaclass Concept are used to present the application class Mineral , as well as its subclasses Olivine and Pyroxene . The three Concept instances know about their subclasses and superclass.
 sification , all of which have empty default values. Olivine overrides the attributes colour and crystal-shape with new attributes having the default values  X  X reen X  and  X  X ctagonal X .
 stances of metaclass Concept, are impleme nted in the value model as instances of the class ConceptI nstance. Instance mineral#23 of Mineral overrides the attributes colour and crystal-shape with new attributes having the values  X  X reen X  and  X  X ctago-nal X , corresponding to its appearance.

Example 2. Two instances of the metaclass Rol e are defined. The first refers to the attributes colour and crystal-shape of Mineral and the second to the attribute classification of Mineral.
 classification-role and contain premise and conclusion attributes of the abstract in-ference referring to the abstract rule  X  X f Mineral.colour is green and Mineral.crystal-shape is octagonal then Mineral. Classification is Olivine. X 
Instances of the two application classes contain premise and conclusion attributes of actual inferences performed, i.e. references to the attributes colour and crystal-shape, as classification, of mineral#23.
An instance of the metaclass I nference is defined between classification-factor-tribute classification of Mineral can be reasoned on the basis of the attributes colour and crystal-shape of Mineral.

Instances of InferenceInstance transfo rm the references to abstract premise and conclusion attributes into references to the actual premise and conclusion attributes used. The abstract rule becomes  X  X f mineral#23.colour is green and mineral#23.crystal-shape is octagonal then mineral#23.classification is Olivine X .
The class DomainModel (Fig. 4) contains an inheritance hierarchy of Concept meta-classes in the domain. The class ConceptAttribute can manage both the multiple values acquired from different knowledge sources and the default values worked out. A Concept contains instances of ConceptAttribute. The use of a domain model is described in Example 1.

The class DependencyGraph (Fig. 5) refers to instances of the classes AttributeRef-erence and Dependency . An AttributeReference contains a reference to a Concept in the domain model as well as the name of a ConceptAttribute. A Dependency de-scribes an inferential, i.e. logical dependency, between attributes of domain concepts.
Dependencies of one or several types can be used. The type of a dependency is indi-cated by referring to an instance of a suitable subclass of the class DependencyType . A description is attached to each depe ndency, as presented in Example 3.
This implements the Remove combination rule for DGs (Fig. 6), without deleting information, as discussed in Sect. 2.2.

Example 3. An instance of the class Dependency, with the default DependencyType, named  X  X epends-on X , is created between Mineral.classification and both Mineral.colour and Mineral.crystal-shape. To the dependency is attached to the description:  X  X f Mineral.colour is green and Mineral.crystal-shape is octagonal then Mineral.classification is Olivine X .
The model, managed through the class InferenceModel , is based on a network called the inference structure , which describes the structure of possible inferences through instances of the metaclasses Role and Infere nce. Inference defines, for each descrip-tion level, a separate aggregate attribute:
An analysis-level description is an abstract textual description. The initial analysis-
A design-level description is a semiformal presentation of the analysis-level de-scription. In SOOKAT, it is implemented as a rule table (Table 1).
An implementation-l evel description is composed of abstract descriptions of exe-cutable rules, impleme nted using the class Rule , containing  X  A premise expression , i.e. an instance of the class BooleanExpression ,defin- X  A reference to the conclusion attribute , i.e. a RoleAttributeReference instance,  X  A formula for obtaining the conclusion value that is an instance of the class Example 4. The instance of the class Inference in Example 2 has the descriptions Analysis level: table containing the statement of reasoning Mineral.classification. Design level: rule-table presentation of the analysis-level description (see Table 1). Implementation level: an instance of the class Rule with the components:
Premise expression: BooleanExpression instance, containing the logical opera-tor AND, and two operands that are themselves instances of BooleanExpression.
The operator in both is IS and the operands are:
Reference to conclusion attribute: RoleAttributeReference instance  X  X ineral.clas-sification X .

Formula for obtaining the conclusion value: constant reference to the Con-ceptInstance Olivine.
In the value model, application instances are represented by instances of the Java class ConceptInstance. The values of their attributes are the possibly variable given values (see Example 1) and the different possible conclusion values from the in-ferences. The latter depend on the execution model, in addition to the inference model.
The execution model contains instances of the Java classes RoleInstance and Infer-enceInstance. Messages are sent between these application instances in an order con-trolled by an instance of some subclass of the class ControlObject (see Sect. 4.3). placed with corresponding values or references to attributes of application instances in the value model.

Suggestions for attribute values of concepts can be inserted in an arbitrary order by different knowledge sources. All suggestions are stored in instances of the class
ConceptAttribute, a subclass of the class Attribute.
To eliminate heterogeneity in AttributeRef erence names, Concepts can be selected from among the ones in the domain model, as well as an attribute name from among those in a selected Concept. DependencyTypes can be selected from among the in-stances of it or its subclasses.
 in SOOKAT. Combination rules (Fig. 2) ( Parpola 1998) can be used incrementally, even when several knowledge sources are considered in parallel, assuming the con-text to be the same (Parpola 2002, 2001). Dependencies are joined automatically.
Simplification is performed semiautomatically when SOOKAT collects dependen-cies. SOOKAT simply joins descriptions of varying dependencies and the user can remove duplicate descriptions. The descriptions and sources of the original depen-dencies are maintained. Descriptions of dependencies can also be augmented with lists of suitable contexts.
The dependency graph, with its descriptions, is used in forming the initial inference model, called the analysis model , consisting of the inference structure and abstract descriptions taken directly from dependencie s (see Sect. 2.2). Inference structure for-mation is triggered from the user interface.
The informal, semi-informal and formal descriptions are stored as attributes of in-ference model. Thus, formal and informal descriptions can be stored contiguously, as different descriptions can simultaneous ly be at different stages of development.
Transformations between different descriptions of an inference are performed semi-automatically.

Different models can be modified in the user interface of SOOKAT, and models can be saved in a format that can be exported. Changes made can, to some extent, be propagated to other models (Parpola 1999a).
In order to be able to perform inferences in an application, the domain model (de-scribed in Sect. 3.2.1) and inference model (described in Sect. 3.2.3) have to be instantiated to form the value model and execution model (described in Sects. 3.2.4 and 3.2.5).
The Concepts in the domain model are gone through by the tool in order to remind the user of the items to be instantiated. For the desired concepts, the user can create one or more application instances with specific names and attribute values.
Roles in the inference model will be instantiated with selected collections of attribute instances. InferenceInstance i nstances between RoleInstan ce instances trigger rules of
Inference metaobjects, applied to the ConceptInstance instance attributes, indicated by the RoleInstance instances.

A reason for defining Inference as a metaobject is that it provides a handy way of collecting together a group of InferenceInstances using the same rules. In this way, modifying a rule in a subclass of Infere nce affects all of its InferenceInstances at a time. Inferences are performed according to p rinciples that have been adopted from the KADS methodology (Hesketh and Barrett 1989; Schreiber et al. 1999) and modified.
InferenceInstance instances between Role Instance instances trigger rules of corres-ponding Inference instances, applied to the desired ConceptInstance attributes.
Assignments are made to values of Attributes of ConceptInstance instances in the value model, considered as variables to whi ch either values of, or references to, the actual application instance attributes are assigned by InferenceInstance instances. the power of first-order logic (Wetter 1990) . Replacing concepts with attributes of concepts makes only a small addition to the proof.

Example 5. A green mineral with octagonal crystals needs to be identified, using a KB containing the roles r1 (Classification-role) and r2 (Classification-factor-role) as well as the inference inf1, all described in Example 2.
 which the application instance mineral#23 is assigned. Attributes referred to from the premise role r2 are replaced with links to mine ral#23.colour and mineral#23.crystal-shape, which have the values  X  X reen X  and  X  X ctagonal X , respectively. The value of the attribute mineral#23.classification is assigned to be  X  X livine X . The execution of the task is illustrated in Fig. 7.
 ture.
A ControlObject (CO), specific to the chosen inference strategy, is used to control message sending between RoleInstance and InferenceInstance instances.

Actual inferencing takes place when COs f or different inference strategies also guide the overall process as individual tasks. Message sending among CO, RoleIn-stance, and InferenceInstance i nstances, i.e. objects, is controlled by the CO. Suitable actions in RoleInstance and I nferenceInstance objects are also triggered by the CO.
The actual order of inferences to be pe rformed is determined by the inference strategy used. The performance of an infe rence according to backward chaining is illustrated in Fig. 8.
The main data structures used in controllin g inference according to forward or back-ward chaining are a goal stack, containing RoleInstances, and an inference queue, containing InferenceInsta nces. In backward chaining, a stack for premise RoleIn-stances is also used.

In both backward and forward chaining, InferenceInstances with satisfied premises (RoleInstances) are added to the infere nce queue. A premise is satisfied when the attributes it refers to have values. In back ward chaining, the goal RoleInstances and their child RoleInstances are pushed to the goal stack, as long as they are unsatisfied.
Figure 8 illustrates messages sent betw een objects belonging to different classes when controlled by a CO used for backward chaining. Other COs, used for reasoning according to PSMs, are des cribed in Sect. 4.5.

Example 6. The execution of the mineral classification task in Example 5, illustrated as tasks performed by objects during the execution of the problem-solving task, are specified.
In order for it to be possible to produce step-by-step explanations, each inference per-formed (by executing its implementation description) is provided with a time stamp and saved to a storage with it. Explanations are produced on the basis of  X  references from time stamp s to InferenceInstances,  X  analysis descriptions of the corresponding Inferences, and  X  values of Attributes of ConceptInstances referred to from RoleInstances referred
Example 7. The explanation produced of inferring the value  X  X livine X  of the at-tribute mineral#23.classification is based on the analysis description of the single inference performed. The follo wing explanation is produced:  X  X he value  X  X livine X  for the attribute mineral#23.classification was achieved as the value of the attribute mineral#23.colour is  X  X reen X  and the value of the attribute mineral#23.crystal-shape is  X  X ctagonal X  and the rule  X  X f Mineral.colour is green and Mineral.crystal-shape is octagonal then Mineral.classification is Olivine X  was applied. X 
Here, a protocol means a documented series of reasoning stages that are gone through when a solution based on some premise values is reached (Ericsson and Simon 1984).
In other words, a protocol goes through an instantiation of one possible path (a se-quence of inference steps, i.e. reasoning stages) through the inference structure. Rea-soning stages are called protocol phases.
 depends on the attribute(s) reasoned during it and on the previous phase. In other words, a DependencyGraph (see Sects. 2 &amp; 3.2) can describe the ordering of rea-soning steps, in addition to logical dependencies between attributes. graph with informal descriptions of the reasoning, using the values mentioned in the protocol phases. If a dependency already exists, its analysis description is expanded. class ProtocolPhase is, in turn, defined as a subclass of the class ConceptAttribute.
Dependencies (instances of the class Depe ndency) are added to the dependency graph between attribute references (instances of the class DependencyAttReference) and/or protocol phases.
 1. dynamic creation of Protocol instances, 2. inheritance among Protocol instances, and 3. instantiation of Protocol instances (e.g. MineralClassificationProtocol instances). system through enabling the association of different and alternative COs to instances of Protocols.
Protocol phases are extensible through alternative values for the attributes involved in dependencies, which have arisen in diffe rent connections. Suitable instantiations of concept attributes, referred to from a dependency graph, can be used to enlarge the scope of a protocol phase and possibly a protocol.

In other words, protocols can be expanded through alternative application in-stances of the protocols, i.e. by referring to alternative result instances of the meta-class Concept and alternative starting val ues, but retaining the attribute names.
Example 8. The mineral classification example can be extended by adding the informa-tion for classifying the mineral Pyroxene : Mineral.colour is  X  X reen X  and Mineral.crys-tal-shape is  X  X abular X .
The premise and conclusion attributes in volved in each phase are essential in a pro-instantiation of the path in the dependency graph. The forward and backward chain-ing strategies can also be used when reasoning according to protocols.
The reachability of different solutions an d coverage of existing material (depen-dencies) have to be checked. In other words, a path must exist in the dependency graph for reachiing each solution in the application domain.

Example 9. The possible solutions in the mineral classification example domain are  X  X livine X  and  X  X yroxene X . As dependencie s exist for reaching both, coverage of the material is sufficient.
Inferences can also be performed according to some problem-solving methods (PSMs) such as cover-and-differentiate (Eshelman 1988) or propose-and-revise (Marcus 1988b;
Leo et al. 1994). These were originally expected to apply only to heuristic classifi-cation (diagnostics) and planning tasks (Bylander and Chandrasekaran 1987; Mar-cus 1988a). Later, it was acknowledged that PSMs may have variable forms and that the relationship between tasks (or task families) and PSMs is not at all one-to-one (O X  X ara and Shadbolt 1993). In other words, a task can be performed in many different ways.

In PSMs, much power can be gained by understanding the roles that domain knowledge plays in problem solving (Marcus 1988a).

Different PSMs use different numbers of relation types and knowledge roles. They also define a pattern of using different knowledge roles in inference. For this reason, different PSMs require different COs in SOOKAT, conducting different patterns of message sending. The PSMs also determine the form of dependency graphs, i.e. the types of dependencies required.
The cover-and-differentiate PSM, originally used for fault detection (Eshelman 1988), requires only a single type of dependency. The implementation of the cover-and-differentiate PSM can use the same CO as fo rward and backward chaining, as a simi-lar dependency graph is used, and the PSM is an extension of forward chaining. knowledge and differentiating knowledge can also be used. This CO follows the OO principle of modularity, as well as the ge neral SOOKAT policy of generating COs.
Example 10. The cover-and-differentiate PSM is almost directly applicable to min-eral classification. The symptoms used a s input are replaced with attribute values of a mineral sample, and the possible fau lts causing the symptoms are replaced with minerals that the sample may present.
 alternatives. The CO for the cover-and-differentiate PSM uses two subordinate COs, one for covering and one for differentiating. The cover CO leaves in the list only the concepts fulfilling the current differentiating criterion (removing from the list items not fulfilling it). The differentiate CO finds a new differentiating criterion (re-quirement), finding a new criterion for differentiation through the attributes of the more than one remaining concept.
 cover phase, set to contain all concepts of the domain, i.e. Olivine and Pyroxene.
The first differentiation criterion based on the attribute value of mineral#23 is
Both candidates fulfil the criterion, so a new one is suggested:
During the next cover phase, the concept Pyroxene is removed, as it does not fulfil the criterion. The only remaining concept, Olivine, is the solution.
There are three knowledge roles that knowledge can play in the PSM (Marcus 1988b), propose a design extension , identify a constraint ,and propose a fix . The dependency graph acquired should contain three types of dependencies. The CO for propose-and-revise has two sub-COs. The propose CO proposes both extensions of the KB and potential fixes, and the revise CO proposes a revision of the KB.
Example 12. The propose-and-revise PSM can be used to solve the mineral classi-fication problem. Minerals will, in practice, be gone through one by one. hypotheses (identified one by one), and revision is performed by proposing a new Concept as a fix for a constraint violation.

Example 13. In the mineral classification application, the propose CO first proposes both the KB extension and the potential fix
As the value of the attribute crystal-shape of Pyroxene contradicts that of the sample, the revise CO proposes the KB revision  X  X ineral.classification is Olivine. X 
It can be noticed that the values of the attrib utes colour and cryst al-shape are  X  X reen X  and  X  X ctagonal X  both in mineral#23 and Olivine. As the solution has been found, there is no need to propose a new mineral.
A mechanism for importing descriptions of PSMs from outside, e.g. in a similar fash-ion as in a broker selecting a suitable PSM from a library on the Internet (Benjamins et al. 1999), is under development. Descriptions are expected to be written by PSM providers (library holders) in the unified problem-solving method description lan-guage (UPML) (Fensel et al. 1999; Fensel and Motta 2003).

A mechanism for generating COs based on the descriptions imported is also under development. Work concerning the use of metaobjects and metalevels in KA includes the following: Prot  X  eg  X  e-2000 (Fridman Noy et al. 2000) uses a metaobject protocol (Steele 1990;
Kiczales et al. 1991) to describe a model, for example, the CommonKADS model of expertise (Schreiber et al. 2000). This allows applications to be presented as instantiations of the model.
 OIL (ontology inference language) (Fensel et al. 2000) is a proposal, based on
OKBC (open knowledge base connectivity), XOL (ontology exchange language), and RDF (resource description framework ), for a joint standard for specifying and exchanging ontologies over the Internet. Modelling ontologies in OIL distin-guishes three separate layer s, the object level, the first metalevel, and the second metalevel. The structure consists of several components. Rule bases, classes and slots, and types, as well as slot constraints and inheritance, are used. OIL is a frame-based system, using, for example, rule bases.

MODEL-ECS (executable conceptual structures) (Lukose 1995) also apply infer-ences in parallel with development.
 Structured systems like SOOKAT can be vi ewed through ontologies (Parpola 2000).
Natalya Noy and Michael Klein have compared ontology evolution and schema evo-lution (Noy and Klein 2004).
SOOKAT (structured object-oriented kno wledge acquisition tool) (Parpola 2002, 2001, 2000), supporting the methodology SeSKA (Seamless Structured Knowledge Acqui-sition) (Parpola 1998, 1999b, 1999a), is in a state of continuous development. The
Sisyphus III rock classification problem (Shadbolt et al. 1996) has been used through-out the development of SOOKAT for testing different features.

The methodology SeSKA has been used manually to build a knowledge base (KB) for the dietary management of mu ltiple sclerosis (Parpola 1998). A SOOKAT KB for individual dietary planning is under development.
 larged to use two metaobject protocols. The models forming the KB (domain model and inference model) can be instantiated using the two metaobject protocols. Rea-soning according to different inference strat egies is performed using specific control objects (CO) and the instantiated models.
  X  showing how OO models created during t he KA process can be used as a plat- X  presenting protocols with dependencies, so that the shared CO defined for forward  X  sketching a way of presenting and using the cover-and-differentiate and propose- X  further investigations of inference i n SOOKAT according to PSMs, using specific  X  the construction of various kinds of application KBs,  X  developing mechanisms for importing descriptions of PSMs and exporting de- X  developing a mechanism for generating COs based on imported PSMs.

