 In unsupervised NLP tasks such as tagging, parsing, and alignment, one wishes to induce latent linguistic structures from raw text. Probabilistic modeling has emerged as a dominant paradigm for these problems, and the EM algorithm has been a driving force for learning models in a simple and intuitive manner.
However, on some tasks, EM can converge slowly. For instance, on unsupervised part-of-speech tagging, EM requires over 100 iterations to reach its peak performance on the Wall-Street Jour-nal (Johnson, 2007). The slowness of EM is mainly due to its batch nature: Parameters are updated only once after each pass through the data. When param-eter estimates are still rough or if there is high redun-dancy in the data, computing statistics on the entire dataset just to make one update can be wasteful.
In this paper, we investigate two flavors of on-line EM X  incremental EM (Neal and Hinton, 1998) and stepwise EM (Sato and Ishii, 2000; Capp  X  e and Moulines, 2009), both of which involve updating pa-rameters after each example or after a mini-batch (subset) of examples. Online algorithms have the potential to speed up learning by making updates more frequently. However, these updates can be seen as noisy approximations to the full batch up-date, and this noise can in fact impede learning.
This tradeoff between speed and stability is famil-iar to online algorithms for convex supervised learn-ing problems X  X .g., Perceptron, MIRA, stochastic gradient, etc. Unsupervised learning raises two ad-ditional issues: (1) Since the EM objective is non-convex, we often get convergence to different local optima of varying quality; and (2) we evaluate on accuracy metrics which are at best loosely correlated with the EM likelihood objective (Liang and Klein, 2008). We will see that these issues can lead to sur-prising results.

In Section 4, we present a thorough investigation of online EM, mostly focusing on stepwise EM since it dominates incremental EM. For stepwise EM, we find that choosing a good stepsize and mini-batch size is important but can fortunately be done ade-quately without supervision. With a proper choice, stepwise EM reaches the same performance as batch EM, but much more quickly. Moreover, it can even surpass the performance of batch EM. Our results are particularly striking on part-of-speech tagging: Batch EM crawls to an accuracy of 57.3% after 100 iterations, whereas stepwise EM shoots up to 65.4% after just two iterations. In this paper, we focus on unsupervised induction via probabilistic modeling. In particular, we define a probabilistic model p ( x , z ;  X  ) of the input x (e.g., a sentence) and hidden output z (e.g., a parse tree) with parameters  X  (e.g., rule probabilities). Given a dard training objective is to maximize the marginal log-likelihood of these examples: A trained model  X   X  is then evaluated on the accuracy of its predictions: argmax on the task. What makes unsupervised induction hard at best and ill-defined at worst is that the train-ing objective (1) does not depend on the true outputs at all.

We ran experiments on four tasks described be-low. Two of these tasks X  X art-of-speech tagging and document classification X  X re  X  X lustering X  tasks. For these, the output z consists of labels; for evalua-tion, we map each predicted label to the true label that maximizes accuracy. The other two tasks X  segmentation and alignment X  X nly involve unla-beled combinatorial structures, which can be eval-uated directly.
 Part-of-speech tagging For each sentence x = ( x 1 ,...,x ` wish to predict the corresponding sequence of part-of-speech (POS) tags z = ( z 1 ,...,z ` ) . We used a simple bigram HMM trained on the Wall Street Journal (WSJ) portion of the Penn Treebank (49208 sentences, 45 tags). No tagging dictionary was used. We evaluated using per-position accuracy.
 Document classification For each document x = ( x 1 ,...,x ` dict the document class z  X  { 1 ,..., 20 } . Each doc-ument x is modeled as a bag of words drawn inde-pendently given the class z . We used the 20 News-groups dataset (18828 documents, 20 classes). We evaluated on class accuracy.
 Word segmentation For each sentence x = ( x 1 ,...,x ` phonemes or Chinese characters without spaces separating the words, we would like to predict a segmentation of the sequence into words z = ( z contiguous subsequence of 1 ,...,` . Since the na  X   X ve unigram model has a degenerate maximum likeli-hood solution that makes each sentence a separate word, we incorporate a penalty for longer segments: p ( x , z ;  X  )  X  determines the strength of the penalty. For English, we used  X  = 1 . 6 ; Chinese,  X  = 2 . 5 . To speed up in-ference, we restricted the maximum segment length to 10 for English and 5 for Chinese.

We applied this model on the Bernstein-Ratner corpus from the CHILDES database used in Goldwater et al. (2006) (9790 sentences) and the Academia Sinica (AS) corpus from the first SIGHAN Chinese word segmentation bakeoff (we used the first 100K sentences). We evaluated using F 1 on word tokens.

To the best of our knowledge, our penalized uni-gram model is new and actually beats the more com-plicated model of Johnson (2008) 83.5% to 78%, which had been the best published result on this task. Word alignment For each pair of translated sen-tences x = ( e 1 ,...,e n predict the word alignments z  X  { 0 , 1 } n e n f . We trained two IBM model 1s using agreement-based learning (Liang et al., 2008). We used the first 30K sentence pairs of the English-French Hansards data from the NAACL 2003 Shared Task, 447+37 of which were hand-aligned (Och and Ney, 2003). We evaluated using the standard alignment error rate (AER). Given a probabilistic model p ( x , z ;  X  ) and unla-to maximize the marginal likelihood of the data (1). Let  X  ( x , z ) denote a mapping from a fully-labeled example ( x , z ) to a vector of sufficient statis-tics (counts in the case of multinomials) for the model. For example, one component of this vec-tor for HMMs would be the number of times state 7 emits the word  X  X ouse X  in sentence x with state sequence z . Given a vector of sufficient statistics  X  , let  X  (  X  ) denote the maximum likelihood estimate. In our case,  X  (  X  ) are simply probabilities obtained by normalizing each block of counts. This closed-form solution is one of the features that makes EM (both batch and online) attractive. 3.1 Batch EM In the (batch) EM algorithm, we alternate between the E-step and the M-step. In the E-step, we com-pute the expected sufficient statistics  X  0 across all the examples based on the posterior over z under the current parameters  X  (  X  ) . In all our models, this step can be done via a dynamic program (for example, forward-backward for POS tagging).

In the M-step, we use these sufficient statistics  X  is trivial, we represent it implicitly by  X  (  X  ) in order to concentrate on the computation of the sufficient statistics. This focus will be important for online EM, so writing batch EM in this way accentuates the parallel between batch and online. 3.2 Online EM To obtain an online EM algorithm, we store a sin-gle set of sufficient statistics  X  and update it after processing each example. For the i -th example, we compute sufficient statistics s 0 variants of online EM algorithms which differ in ex-actly how the new s 0
The first is incremental EM (iEM) (Neal and Hin-ton, 1998), in which we not only keep track of  X  but also the sufficient statistics s 1 ,...,s n for each ex-ample (  X  = we subtract out the old s i and add the new s 0
Sato and Ishii (2000) developed another variant, later generalized by Capp  X  e and Moulines (2009), which we call stepwise EM (sEM). In sEM, we in-terpolate between  X  and s 0 is the number of updates made to  X  so far).

The two algorithms are motivated in different ways. Recall that the log-likelihood can be lower bounded as follows (Neal and Hinton, 1998): ` (  X  )  X L ( q 1 ,...,q n , X  ) (2) = where H ( q i ) is the entropy of the distribution q i ( z with respect to q 1 ,...,q n in the E-step (represented implicitly via sufficient statistics  X  0 ) and with re-spect to  X  in the M-step. Incremental EM alternates between optimizing with respect to a single q i and  X  .
Stepwise EM is motivated from the stochastic ap-proximation literature, where we think of approxi-ple s 0 we interpolate between s 0 sEM can be seen as stochastic gradient in the space of sufficient statistics.
 Stepsize reduction power  X  Stepwise EM leaves open the choice of the stepsize  X  k . Standard results from the stochastic approximation literature state that cient to guarantee convergence to a local optimum. In particular, if we take  X  k = ( k + 2)  X   X  , then any 0 . 5 &lt;  X   X  1 is valid. The smaller the  X  , the larger the updates, and the more quickly we forget (decay) our old sufficient statistics. This can lead to swift progress but also generates instability.
 Mini-batch size m We can add some stability to sEM by updating on multiple examples at once instead of just one. In particular, partition the n examples into mini-batches of size m and run sEM, treating each mini-batch as a single exam-ple. Formally, for each i = 0 ,m, 2 m, 3 m,... , first compute the sufficient statistics s 0  X  X  X  + s 0 i + m . The larger the m , the less frequent the updates, but the more stable they are. In this way, mini-batches interpolate between a pure online ( m = 1 ) and a pure batch ( m = n ) algorithm. 2 Fast implementation Due to sparsity in NLP, the sufficient statistics of an example s 0 a small fraction of its components. For iEM, the time required to update  X  with s 0 the number of nonzero components of s 0 the sEM update is  X   X  (1  X   X  k )  X  +  X  k s 0 implementation would take time proportional to the total number of components. The key to a more effi-cient solution is to note that  X  (  X  ) is invariant to scal-ing of  X  . Therefore, we can store S =  X  instead of  X  and make the following sparse update: that  X  (  X  ) =  X  ( S ) .

For both iEM and sEM, we also need to efficiently compute  X  (  X  ) . We can do this by maintaining the normalizer for each multinomial block (sum of the components in the block). This extra maintenance only doubles the number of updates we have to make but allows us to fetch any component of  X  (  X  ) in con-stant time by dividing out the normalizer. 3.3 Incremental versus stepwise EM Incremental EM increases L monotonically after each update by virtue of doing coordinate-wise as-cent and thus is guaranteed to converge to a local optimum of both L and ` (Neal and Hinton, 1998). However, ` is not guaranteed to increase after each update. Stepwise EM might not increase either L or ` after each update, but it is guaranteed to converge to a local optimum of ` given suitable conditions on the stepsize discussed earlier.

Incremental and stepwise EM actually coincide under the following setting (Capp  X  e and Moulines, 2009): If we set (  X ,m ) = (1 , 1) for sEM and ini-tialize all s i = 0 for iEM, then both algorithms make the same updates on the first pass through the data. They diverge thereafter as iEM subtracts out old s i s, while sEM does not even remember them.

One weakness of iEM is that its memory require-ments grow linearly with the number of examples due to storing s 1 ,...,s n . For large datasets, these s s might not even fit in memory, and resorting to physical disk would be very slow. In contrast, the memory usage of sEM does not depend on n .

The relationship between iEM and sEM (with m = 1 ) is analogous to the one between exponen-tiated gradient (Collins et al., 2008) and stochastic gradient for supervised learning of log-linear mod-els. The former maintains the sufficient statistics of each example and subtracts out old ones whereas the latter does not. In the supervised case, the added sta-bility of exponentiated gradient tends to yield bet-ter performance. For the unsupervised case, we will see empirically that remembering the old sufficient statistics offers no benefit, and much better perfor-mance can be obtained by properly setting (  X ,m ) for sEM (Section 4). We now present our empirical results for batch EM and online EM (iEM and sEM) on the four tasks de-scribed in Section 2: part-of-speech tagging, docu-ment classification, word segmentation (English and Chinese), and word alignment.

We used the following protocol for all experi-ments: We initialized the parameters to a neutral set-ting plus noise to break symmetries. 3 Training was performed for 20 iterations. 4 No parameter smooth-ing was used. All runs used a fixed random seed for initializing the parameters and permuting the exam-ples at the beginning of each iteration. We report two performance metrics: log-likelihood normalized by the number of examples and the task-specific accu-racy metric (see Section 2). All numbers are taken from the final iteration.
Stepwise EM (sEM) requires setting two optimization parameters: the stepsize reduc-tion power  X  and the mini-batch size m (see Section 3.2). As Section 4.3 will show, these two parameters can have a large impact on performance. As a default rule of thumb, we chose (  X ,m )  X  { 0 . 5 , 0 . 6 , 0 . 7 , 0 . 8 , 0 . 9 , { 1 , 3 , 10 , 30 , 100 , 300 , 1 K , 3 K , 10 K } to maximize log-likelihood; let sEM ` denote stepwise EM with this setting. Note that this setting requires no labeled data. We will also consider fixing (  X ,m ) = (1 , 1) (sEM i ) and choosing (  X ,m ) to maximize accuracy (sEM a ).

In the results to follow, we first demonstrate that online EM is faster (Section 4.1) and sometimes leads to higher accuracies (Section 4.2). Next, we explore the effect of the optimization parameters (  X ,m ) (Section 4.3), briefly revisiting the connec-tion between incremental and stepwise EM. Finally, we show the stability of our results under different random seeds (Section 4.4). 4.1 Speed One of the principal motivations for online EM is speed, and indeed we found this motivation to be empirically well-justified. Figure 1 shows that, across all five datasets, sEM ` converges to a solution with at least comparable log-likelihood and accuracy with respect to batch EM, but sEM ` does it anywhere from about 2 (word alignment) to 10 (POS tagging) times faster. This supports our intuition that more frequent updates lead to faster convergence. At the same time, note that the other two online EM vari-ants in Figure 1 (iEM and sEM i ) are prone to catas-trophic failure. See Section 4.3 for further discus-sion on this issue. 4.2 Performance It is fortunate but perhaps not surprising that step-wise EM is faster than batch EM. But Figure 1 also shows that, somewhat surprisingly, sEM ` can actu-ally converge to a solution with higher accuracy, in particular on POS tagging and document classifica-tion. To further explore the accuracy-increasing po-tential of sEM, consider choosing (  X ,m ) to maxi-mize accuracy (sEM a ). Unlike sEM ` , sEM a does re-quire labeled data. In practice, (  X ,m ) can be tuned on a small labeled set along with any model hyper-parameters.

Table 1 shows that sEM a improves the accuracy compared to batch EM even more than sEM ` . The result for POS is most vivid: After one iteration of batch EM, the accuracy is only at 24.0% whereas sEM a is already at 54.5%, and after two iterations, at 65.4%. Not only is this orders of magnitude faster than batch EM, batch EM only reaches 57.3% after 100 iterations.

We get a similarly striking result for document classification, but the results for word segmentation and word alignment are more modest. A full un-derstanding of this phenomenon is left as an open problem, but we will comment on one difference be-tween the tasks where sEM improves accuracy and the tasks where it doesn X  X . The former are  X  X lus-tering X  tasks (POS tagging and document classifi-cation), while the latter are  X  X tructural X  tasks (word segmentation and word alignment). Learning of clustering models centers around probabilities over words given a latent cluster label, whereas in struc-tural models, there are no cluster labels, and it is the combinatorial structure (the segmentations and alignments) that drives the learning.
 Likelihood versus accuracy From Figure 1, we see that stepwise EM (sEM ` ) can outperform batch EM in both likelihood and accuracy. This suggests that stepwise EM is better at avoiding local minima, perhaps leveraging its stochasticity to its advantage.
However, on POS tagging, tuning sEM to maxi-mize accuracy (sEM a ) results in a slower increase in likelihood: compare sEM a in Figure 2 with sEM ` in Figure 1(a). This shouldn X  X  surprise us too much given that likelihood and accuracy are only loosely correlated (Liang and Klein, 2008). But it does sug-gest that stepwise EM is injecting a bias that favors accuracy over likelihood X  X  bias not at all reflected in the training objective.

We can create a hybrid (sEM a +EM) that com-bines the strengths of both sEM a and EM: First run sEM a for 5 iterations, which quickly takes us to a part of the parameter space yielding good accura-cies; then run EM, which quickly improves the like-lihood. Fortunately, accuracy does not degrade as likelihood increases (Figure 2). 4.3 Varying the optimization parameters Recall that stepwise EM requires setting two opti-mization parameters: the stepsize reduction power  X  and the mini-batch size m . We now explore the ef-fect of (  X ,m ) on likelihood and accuracy.

As mentioned in Section 3.2, larger mini-batches (increasing m ) stabilize parameter updates, while larger stepsizes (decreasing  X  ) provide swifter progress. Remember that since we are dealing with a nonconvex objective, the choice of stepsize not only influences how fast we converge, but also the quality of the solution that we converge to.

Figure 3 shows the interaction between  X  and m in terms of likelihood and accuracy. In general, the best (  X ,m ) depends on the task and dataset. For ex-ample, for document classification, larger m is criti-cal for good performance; for POS tagging, it is bet-ter to use smaller values of  X  and m .

Fortunately, there is a range of permissible set-tings (corresponding to the dark regions in Figure 3) that lead to reasonable performance. Furthermore, the settings that perform well on likelihood gener-ally correspond to ones that perform well on accu-racy, which justifies using sEM ` .

A final observation is that as we use larger mini-batches (larger m ), decreasing the stepsize more gradually (smaller  X  ) leads to better performance. Intuitively, updates become more reliable with larger m , so we can afford to trust them more and incorpo-rate them more aggressively.
 Stepwise versus incremental EM In Section 3.2, we mentioned that incremental EM can be made equivalent to stepwise EM with  X  = 1 and m = 1 (sEM i ). Figure 1 provides the empirical support: iEM and sEM i have very similar training curves. Therefore, keeping around the old sufficient statis-tics does not provide any advantage and still requires a substantial storage cost. As mentioned before, set-ting (  X ,m ) properly is crucial. While we could sim-ulate mini-batches with iEM by updating multiple coordinates simultaneously, iEM is not capable of exploiting the behavior of  X  &lt; 1 . 4.4 Varying the random seed All our results thus far represent single runs with a fixed random seed. We now investigate the impact of randomness on our results. Recall that we use randomness for two purposes: (1) initializing the parameters (affects both batch EM and online EM), and (2) permuting the examples at the beginning of each iteration (affects only online EM).

To separate these two purposes, we used two different seeds, S i  X  { 1 , 2 , 3 , 4 , 5 } and S p  X  { 1 , 2 , 3 , 4 , 5 } for initializing and permuting, respec-tively. Let X be a random variable denoting either log-likelihood or accuracy. We define the variance due to initialization as var ( E ( X | S i )) ( E averages over S p for each fixed S i ) and the variance due to permutation as E ( var ( X | S i )) ( E averages over S i These two variances provide an additive decompo-sition of the total variance: var ( X ) = var ( E ( X | S )) + E ( var ( X | S
Table 2 summarizes the results across the 5 tri-als for EM and 25 for sEM ` . Since we used a very small amount of noise to initialize the parameters, the variance due to initialization is systematically smaller than the variance due to permutation. sEM ` is less sensitive to initialization than EM, but addi-tional variance is created by randomly permuting the examples. Overall, the accuracy of sEM ` is more variable than that of EM, but not by a large amount. As datasets increase in size, the demand for online algorithms has grown in recent years. One sees this clear trend in the supervised NLP literature X  examples include the Perceptron algorithm for tag-ging (Collins, 2002), MIRA for dependency parsing (McDonald et al., 2005), exponentiated gradient al-gorithms (Collins et al., 2008), stochastic gradient for constituency parsing (Finkel et al., 2008), just to name a few. Empirically, online methods are of-ten faster by an order of magnitude (Collins et al., 2008), and it has been argued on theoretical grounds that the fast, approximate nature of online meth-ods is a good fit given that we are interested in test performance, not the training objective (Bottou and Bousquet, 2008; Shalev-Shwartz and Srebro, 2008).
However, in the unsupervised NLP literature, on-line methods are rarely seen, 5 and when they are, incremental EM is the dominant variant (Gildea and Hofmann, 1999; Kuo et al., 2008). Indeed, as we have shown, applying online EM does require some care, and some variants (including incremental EM) can fail catastrophically in face of local optima. Stepwise EM provides finer control via its optimiza-tion parameters and has proven quite successful.
One family of methods that resembles incremen-tal EM includes collapsed samplers for Bayesian models X  X or example, Goldwater et al. (2006) and Goldwater and Griffiths (2007). These samplers keep track of a sample of the latent variables for each example, akin to the sufficient statistics that we store in incremental EM. In contrast, stepwise EM does not require this storage and operates more in the spirit of a truly online algorithm.

Besides speed, online algorithms are of interest for two additional reasons. First, in some applica-tions, we receive examples sequentially and would like to estimate a model in real-time, e.g., in the clus-tering of news articles. Second, since humans learn sequentially, studying online EM might suggest new connections to cognitive mechanisms. We have explored online EM on four tasks and demonstrated how to use stepwise EM to overcome the dangers of stochasticity and reap the benefits of frequent updates and fast learning. We also discov-ered that stepwise EM can actually improve accu-racy, a phenomenon worthy of further investigation. This paper makes some progress on elucidating the properties of online EM. With this increased under-standing, online EM, like its batch cousin, could be-come a mainstay for unsupervised learning.
