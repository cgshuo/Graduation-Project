 1. Introduction
Semantic Web provides an environment where software agents can navigate through Web documents and perform sophisticated tasks. In this context, we can observe a great demand for Semantic Web-based applications ( Berners-Lee et al., 2001 ) due to its robustness on providing rich data description mechanisms, such as ontologies ( Gruber, 1993 ). In this manner, researchers and industry use Semantic web inside their web applications to express information accurately. As a consequence, software agents become able to process, share, reuse and understand the terms being described and take better decisions according to the information processed by Semantic Web tools, for example, Semantic search engines ( Devedzic, 2004 ).

Semantic Web requires explicit declaration of knowledge by using ontologies to make information understandable to compu-ter in the Web. In some applications, it is also necessary to provide services that machines and intelligent agents can under-stand, select, compose and invoke automatically. This is possible through the use of Semantic Web Services ( McIlraith et al., 2001 ), the focus of this work.
 Semantic Web Services promise the combination of Semantic Web and Web Service technology. It inherits characteristics from both approaches: semantic interoperability from Semantic Web, and dynamics of resources availability from the Web Services technology ( Daconta et al., 2003 ).

Although Semantic Web Services have emerged as a good candidate for Intelligent Systems development, it adds another one level of complexity in terms of systems development process. It usually increases processing time and can become a very expensive process in terms of choosing and integrating all the roles involved in this process, such as tools, developers and protocols ( Srinivasan, 2006 ). This occurs because the development process that is com-posed by a series of complex steps, such as: (i) Selection and development of services in order to meet the functional require-ments of the system; (ii) Implementation of semantic annotations for these services to describe them, wh ile this step requires the complete specification of the system domain using ontologies in order to describe the services; (iii) Selecti on of a service repository to store both services and their respective semantic annotations; (iv) Selec-tion of techniques and mechanism s to perform automatic discovery and composition of services in acco rdance to the needs of the system. This step also includes development of proprietary solutions; (v) Integration of technologies ch osen in the previous steps in order to provide an ecosystem with the processes of discovery, composi-tion and invocation of services.

In this context, the SWS community has proposed a series of documents to support developers on building Semantic Web
Services based systems, but there is not any proposal to integrate all the main tools required by developers to facilitate their software development process. In this manner, Section 2 presents some of these proposals.

In order to reduce the main problems of integrating related tools for the development of Semantic Web Services based system, this work proposes a framework for managing and integrating the processes involved in the use of Semantic Web
Services into intelligent applications. This work introduces the steps and techniques required during the development of Seman-tic Web Services systems. The evaluation methodology here adopted addressed an e-learning system as a real world example of application aiming at explaining the use of all steps and techniques applied in the process of developing Semantic Web
Services systems suggested and discussed along this work. Based on results, we showed that our proposal has been effective and relevant once we presented the improvements reached on the development of intelligent applications. 2. Development problems and current solutions
This section discusses some of the main issues regarding the challenges faced by developers in the process of building Seman-tic Web Services based systems. For each problem, we discuss several solution proposals by describing their benefits and limitations.

The research on building SWS based systems indicates that problems related to maintenance and performance of its tools and services make it difficult to adopt this kind of application. These problems are discussed below: Unguided development : The authors of the work available in Brambilla et al. (2007) propose a Model-Driven Design (MDD) to develop SWS applications. They use WebML ( Brambilla et al., 2007 ) to specify the Process Models of the system, and provide a methodology to generate Semantic Web Services according to these Process Models by using the WSMO ( Roman et al., 2006 ) Language. However, this work does not present techniques for developing mechanisms to manipulate these services (reposi-tories, discovery, composition and invocation). As discussed by the authors of the work available in Weise et al. (2008) , the use of different discovery and composition algorithms may influ-ence on system performance and on the results obtained in the process of discovery and composition. Thus, the choice of these mechanisms should also be considered in the development of the application, where a wrong choice of the mentioned set of algorithms may lead to worse development process or system performance.
 Using Static Planning approaching is not always possible : Despite allowing the execution of composed services with high level of complexity, the use of discovery through the Static Planning approach is not feasible for all systems. This is the case of the METEOR-S ( Aggarwal et al., 2004 ) project. In high dynamicity systems, the processes constantly change, making the Static Planning approach unfeasible for this kind of system. This problem occurs in works such as the one available in Song et al. (2004) , that presents a new proposal for dynamic discovery of services in pervasive environments. Due to the environment dynamics, it cannot be defined by Static Planning processes.
 Performance on loading ontologies : Ontologies are available on the Web, this means that, first, applications have to load the required ontologies and only after process them in order to use or compose Web Services. The process of loading ontologies in almost all cases becomes a bottleneck, cause negative impact of the system performance. A possible solution for this case is to store the ontologies in a local database. This approach may avoid the loading ontology problem, like it is accomplished by Broekstra et al. (2001) . However, this solution requires a mechanism to handle ontologies synchronization between the original one and the copy stored in the local database. In this case, it adds a point of failure for the system and increase the consumption of system resource, although it avoids sys-tems working with out-of-date ontologies.
 Integration of discovery and invocation mechanisms : The process of service discovery ensure that a given system works dyna-mically, where invocation and access of service repository should be performed automatically without requiring users or developers direct interactions with the system to link these repositories. In this case, the system should provide mechan-ism for integrating this process. In the existing approaches, such as the one provided by METEOR-S, these mechanisms do not allow users perform changes on the system features, once features are provided through SWS.
 Fault tolerance : Systems based on SWS may suffer problems related to errors in the execution of a service or in handling an ontology due to access problems on the network. This problem can be observed in the related work available in Erl (2005) . This occurs because SWS are based on distributed services available on the Web. In this way, these systems must provide mechan-isms for fault tolerance to avoid the system to stop performing its tasks. If a faulty service is detected, the system should use discovery mechanisms to find a service that is similar to the faulty service without requiring user intervention. Another problem related to fault tolerance is that faulty services may become zombie, remaining available for the system indefi-nitely, causing continuous and unexpected system errors. In this case, the system should not allow the use of the faulty service in the processes of discovery and invocation until the problem in the faulty service is fixed. This means that the system should not discard this service permanently, as it can be used in the future. 3. Our proposal
In this section we present our proposal to alleviate the existent problems on developing Semantic Web Services based systems, as we discussed in the previous section. Initially, a set of steps is provided in order to guide the system developer during the development process, presenting the characteristics of each step and the tools that must be analyzed in each of them. Thereafter, we present the Grinv, a Middleware for integrating the service discovery and invocation mechanisms. The Grinv allows devel-opers to adapt the system to accommodate their needs and therefore avoiding some problems discussed in the previous section. 3.1. Steps on development of systems based on Semantic Web Services
Fig. 1 illustrates the process related to the development of systems based on SWS. The steps of this process are presented as following: Domain specification : the domain is formally specified through ontologies. These ontologies have the purpose to specify the concepts and relationship in the system.
 In this context, developers should use a methodology to develop these ontologies (Ontology Engineering). Community has presented some approaches to define methodologies for building ontologies, as the authors of the work available in
Mizoguchi (2004) . In this work, they present a tutorial on ontology engineering ( Bittencourt et al., 2009a ).

In the context of SWS, it is not necessary to exhaustively specify the system domain ontology due to the fact that this process can be quite costly. The main objective of this stage is to build an ontology that describes each of the system of a service and its parameters (input, output, preconditions, effects and so forth).

Services specification : From the ontologies specified in the previous step, services responsible for providing the system functionalities are defined. Skeletons of semantic annotations are built to represent the services desired to be used ( Marinho et al., 2010 ). In this step, the system processes are specified to provide information necessary to perform the discovery using Static Planning.

Services development : Following a top-down approach, the semantic annotations built in the previous step are used to build services that implement the system functions. In this step, the customer can search in public repositories for services already implemented by other developers. In this manner, this process can reduce the time for services implementation. There are two ways to reuse services in the context of Semantic Web
Services: 1. Service without semantic description : Since there is not any 2. Service with semantic description : Although this kind of
Definitions of services repository : Once services of the system are developed and implemented, developer should define the type(s) of repository the system uses to store the services.
The use of traditional OASIS registries is not enough because they do not support semantic descriptions.

Development of discovery mechanisms : In this step, the devel-oper implements or chooses the mechanisms responsible for the service discovery and automatic service composition within the system. The discovery mechanisms are responsible for handling services in the repository in order to determine which service (or composition of them) will dynamically provide the functionality required by users of the system during the system execution.

It is important to point out that the services selected by the discovery mechanisms are not necessarily those developed in the Services Development step. As intelligent systems are con-stantly evolving, new services can be added to the repository and the choice of these services can improve system perfor-mance.

Another example is services that were added to the repository to provide redundancy to the system. In case of error in the execution of a particular service, the discovery mechanisms must find similar services automatically, without needing any kind of external interactions, such as by the user or the system developer.

Development of invocation mechanisms : Invocation mechanisms are developed to invoke services selected by the discovery mechanisms of the system. To guarantee the system works dynamically and automatically, these mechanisms must be capable of invoking these services without the direct interac-tion of the user.

Technologies integration : After defining and developing services and technologies, this step is responsible for integrating tools used to manipulate the services, proving necessary adaptations. 3.2. Grinv
The Grinv 1 Middleware aims at providing discovery, composi-tion, and automatic invocation of Semantic Web Services pro-cesses in an extensible way and also transparent to the user of the Middleware. In this manner, developers can modify the techni-ques/algorithms used in the service discovery and composition without causing major impacts to the rest of the system.
Grinv also provides a repository of services that aims to minimize the performance problem found in the loading of ontologies. In addition to this, Grinv can be integrated to others technologies of services repository and providing a mechanism for fault tolerance, as we will show next.

Regarding the approach to service description, the SAWSDL ( Farrell and Lausen, 2007 ) is the current W3C recommendation. It represents a conservative and incremental approach to introduce semantic characterization of Web services into mainstream Web service practices. Its objectives are modest. For example, it aims to provide semantic characterization of a services input and output types, which can be useful in disambiguating those types in the context of simple forms of service discovery. But it does not aim to provide a comprehensive framework to support more sophisticated approaches to discovery, composition, or any of the other service-related tasks that Semantic Web Services research hopes to automate ( Martin et al., 2007 ).

SAWSDL does not specify a particular semantic framework to characterize the semantics of Web services. Rather, it defines a small set of WSDL 2 extension attributes. These extensions may be used to refer to constructs within any external semantic frame-work. SAWSDL is completely noncommittal regarding the choice of semantic framework ( Martin et al., 2007 ). Thus, more sophis-ticated semantic frameworks are more appropriate to allow the execution of more complex tasks such as WSMO ( Roman et al., 2006 ) or OWL-S ( Martin et al., 2004 ), both are W3C submissions.
WSMO and OWL-S aim at representing Web Services that make an essential use of ontologies from the Semantic Web, and the goals of both efforts is to support more effective discovery, composition and interoperation. The two efforts take different approaches. WSMO consider the role of mediation in order to support automatic interoperation between Web Services, while
OWL-S consider action representation to support Static Planning processes that provide automatic composition ( Paolucci et al., 2004 ).

WSMO is based on WSML (Web Services Modeling Language) for building the semantic descriptions of services ( Roman et al., 2006 ). WSML is a language to create ontologies that is not derived from XML or OWL (W3C recommendation for the construction of ontologies in the Semantic Web). The consequence of this is incompatibility among the tools that manipulate other WSMO and OWL-based tools. In this case, the system need tools capable of interpreting ontologies described in OWL and in WSML, which requires the developer to conduct a series of mappings between these two languages.

In contrast, OWL-S is based on OWL that allows an easy integration of OWL-S tools and proposed tools for manipulating ontologies in OWL, such as Jena 3 (Jena is one of the most widely used Java APIs for RDF and OWL). In addition, a number of tools have been proposed for discovery and dynamic composition of services based on OWL-S, such as ( Paolucci et al., 2002 ; Srinivasan, 2006 ; Klusch et al., 2006 ; Calado et al., 2009 ).
With that in mind, the OWL-S was chosen to describe the services semantically. The Grinv Middleware has been developed using the Java language. OWL-S API, 4 based on Jena, was used for manipulating semantic descriptions of services.

Although we have chosen the OWL-S, the developer can extend the Middleware in order to support other approaches, such as SAWSDL. In this case, the steps described in Martin et al. (2007) can be used to integrate SAWSDL and OWL-S. 3.2.1. Architecture
Fig. 2 illustrates the Grinv high-level architecture. The mod-ules of this architecture are discussed below: Requisition manager : It is the kernel of the architecture. It is responsible for indicating the flow of processes that must be performed to attend the user X  X  requests.
 Discovery module : It is responsible for finding out what is the best service in system repository that matches the descriptions sent by the user. This module has a set of discovery algorithms to perform this task, while it is able to do discovery using Static Planning.
 Invocation module : It is responsible for invoking automatically a service been provided by user or discovered by Discovery module. This module must be capable of invoking simple (a single service) and composed processes in a transparent manner. This module is also able to perform the invocation of a Planning discovery.
 Repository manager : It has the function of storing services used by other modules of architecture. It is implemented using Sesame ( Broekstra et al., 2001 ) to store and manipulate ontologies that describe the services. As Sesame stores the ontologies in a data base, this module has routines to verify updates that may occur in the ontologies provided in Web and update the content of the data base.
 The repository manager has access to two repositories: the Services Repository (SR) and Services Under Observation (SUO). SR is responsible for storing the services that will be used by the system. The SUO stores services that presents problems during the discovery or invocation processes (i.e. Semantic description not provided in the Web, Web Service cannot be invoked, error during execution of the service).
 The services that are found in the SUO stay isolated to avoid their problems affecting the system performance. These faulty services are under constant evaluation to verify if they became available again and, when this occurs, they are reintegrated into the system.
 Configuration : It is responsible to adjust the system according to the configurations done by the user. It loads the configura-tion files that indicate the discovery algorithms that will be used, the invocation and the policy mechanisms of the reposi-tory. We will discuss this module in more detail in Section 4. 3.2.2. Discovery and invocation using Static Planning
To apply discovery using Planning provided by Grinv, the processes must be described using the OWL-S 5 Process Model ontology, similar to the work proposed by Sirin and Parsia (2004) .
During the Services Specification step, the developer must specify the processes that represent the functionalities of the system through the OWL-S ontologies.

These processes are modeled using the ControlConstruct class found in the Process Model ontology. This class represents a control structure for the specification of a process. The control structures provided in Grinv are the same ones provided by the
OWL-S language. More details about the use of ControlConstructs and of the process model ontology can be found in the specifica-tion of the OWL-S language. 6 With the specified processes through ControlConstructs , the
Planning Discovery module loads these processes and starts the discovery process. To start this process, it uses discovery mechan-isms presented in the Discovery Algorithms module. For each service specification that includes the specified process by the developer, it is found in the repository a service that performs the defined functionalities.
 In the same way, after the discovery process execution, the
Planning Invocation module is responsible to invoke the discov-ered services according to the specified control structures.
The Planning Discovery and Planning Invocation modules can be also extended. If the developer wishes use others ControlConstructs that is not provided by Grinv, he just need to extend the ProcessModel ontology and specify the control structures that he needs. After doing this process, he just need to add these new configurations in the Configuration module. 3.2.3. Fault tolerance mechanism As previously mentioned, systems based on Semantic Web Services must provide mechanisms for fault tolerance. The Grinv offers fault tolerance through the error detection in the mechan-isms of services invocation ( Invocation Controller ) and Repository Manager module removes the defective service from the Services Repository when the error is detected. After this, it adds the faulty service in the Repository Services Under Observation . In this way, the service will not be used by the system. After the removal of the defective service, a new discovery process is performed by the Discovery Controller module to search a new service similar to the defective service.

In this search for the service which will replace the defective service, the Discovery Controller module can use different algo-rithms available in Discovery Algorithms module, what increases the possibility of finding a new service as good as the faulty one. If none of the algorithms can find a new service similar to the defective service, the request made by the user can not be done by the system and Requisition Manager sends to the user an error message containing information about the execution of the defective service and the generated error.

As for the defective service, the SUO repository has routines to check if the service returned to its usual operation. Checking this, the defective service is added to the SR and reintegrated into the system. 4. Case study
In this section we describe a real case study in order to provide a detailed construction of an application based on the steps provided in Section 3. This case study focuses in the context of Intelligent Tutoring Systems (ITS). As a matter of fact, several groups around the world has been engaged on developing ITS for adoption in real world environments, where ITS are being used by thousands of students in several domains. A first project that has been used in large-scale system is ASSISTment ( Razzaq et al., 2009 ). It has been used by thousands of secondary school students as a tool that assists the teaching process and assisting students in resolving problems. With a broader view, the WebAs-sign 7 serves more than 300 thousand students, offering support to other fields of knowledge, mainly in Physics and Chemistry.
The Carnegie Learning has also been highlighted in the devel-opment of Intelligent Tutoring Systems ( Aleven et al., 2006 ). It receives funding from the U.S. Federal Government (National Science Foundation) to develop research in ITS field. 8 This group produces tutoring systems to support education, especially in the field of Mathematics. These tutors developed by the Carnegie Learning group has proved efficient in improving the education of students, they roughly estimate some half million students have used the tutor for a total of about 20 million student/hours ( Koedinger and Corbett, 2005 ). At last, the Andes ( Vanlehn et al., 2005 ) is another Intelligent Tutoring System for the field of Physics which helps hundreds of students to learn content related. In this manner, it has an individualized education in developing its knowledge.

The MASSAYO Tutor SPL ( Silva et al., 2010 ) has been developed as a tool of social order in northeast of Brazil, under the Program for the Integration of Vocational and Technical High School in the mode of Youth and Adults. This program was established by decree N. 5.840, of 13 July 2006 and covers professional technical education ( Correia et al., 2007 ). In this sense, tests have been conducted with these students in the field of physics, having a satisfactory approval.

The MASSAYO Tutor SPL ( Silva et al., 2010 ) has been developed as a tool of social order in northeast of Brazil, under the Program for the Integration of Vocational and Technical High School in the mode of Youth and Adults. This program was established by decree N. 5.840, of 13 July 2006 and covers professional technical education ( Correia et al., 2007 ). In this sense, tests have been conducted with these students in the field of physics, having a satisfactory approval.

In this section we are going to present a step-by-step con-struction of an Intelligent System developed in the Group of Optimization of the Web Laboratory  X  GrOW 9 based on the use of Semantic Web Services. Moreover, to evaluate the construction of such application, we take into account the problems stated in Section 2. 4.1. Intelligent Tutoring System
Broadly speaking, an Intelligent Tutoring Systems (ITS) is an educational system which uses artificial intelligence techniques to provide a personalized and adaptable teaching-learning pro-cess. During the specification of an ITS, the development team should answer three main questions ( Brusilovsky et al., 2006 ):
What to teach ? This question represents the specification of the application domain. For example, an ITS built in the context of legal domain or medicine or programming. From an architec-tural point of view, it is represented by a domain module.
To whom to teach ? This question represents the features of the learners to consider for adapting the teaching process. For example, it represents the cognitive knowledge of the student about a certain domain. According to the knowledge of the student, the system can adapt the resources in order to provide a more interesting resource to the student. From an architec-tural point of view, it is represented by a student module.
How to teach ? This question represents the way the student is taught. For example, some students prefer to learn by doing; others prefer to learn through the interaction with other students. Thus, the system adapts the teaching process accord-ing to the students X  learning preferences. From an architectural point of view, it is represented by a pedagogical module ( Bittencourt et al., 2008a ).

Intelligent Tutoring Systems is a software system that can be used in an efficient way to improve the student learning process ( Aleven et al., 2006 ; Koedinger et al., 1997 ; Brusilovsky and Vassileva, 2003 ). Actually, this is happening because this kind of systems provides interactivity instruction, in an automated way, for lifetime and lifelong ( Woolf, 2009 ). Then, this is useful for giving the students an individual support anytime and anywhere. Such systems are provided with mechanisms that enable, in an automated fashion, a better understanding of the students X  needs, responding them individually. Moreover, ITS allow student cen-tered learning despite the teacher centered learning, thus allow-ing the student to control his/her own learning process. In addition, ITS have been assumed as an important learning resource to be added as a module in e-learning systems.
Details about building of Intelligent Tutoring Systems are presented in the next subsections. 4.1.1. Domain specification
This subsection describes the specification of ITS through the presentation of use case diagrams and feature diagrams. As a matter of fact, every ITS is composed by several features which can vary according to the domain engineering. Some features are described below. 1. Tutoring : it is the main requirement of every ITS and it is responsible for providing an educational resource to the student according to the domain knowledge of the student. 2. Problem solving : one of the main requirements of an ITS is the capability of solving problems automatically and provide explanations to the students. The type of the problem depends on the specific ITS, such as multiple choice problems, true or false, fill columns, and so forth. 3. Open student model : this feature is optional and it provides to the student to whole view of the system about the knowledge of the student in a certain domain. 4. Recommendation : it is another optional feature on which the system recommends other users to the students in order to help them to achieve a learning goal, such as solve a problem. The recommendation can be to recommend other student or teacher of even a domain expert; 5. Basic requirements : several other requirements considered in this kind of application are register student, log-in, create student model and so forth.

In fact, there are several others requirements and features to consider in the construction of ITS ( Bittencourt et al., 2008b ). The complete use case diagram of the ITS developed in this case study have more than 50 use cases. Fig. 3 presents part of specification of as ITS through a use case diagram. 10
Besides Fig. 3 describes the requirements of the application, it is very important to point out that not every requirement must be implemented to the system. There are some requirements which can be optional in an ITS, such as Open Student model, Recom-mendation, the kind of educational resource available in the system, the kind of problems, and so forth. Fig. 4 describes a
Feature Diagram providing the required ( X  X ! X  X  symbol), optional ( X  X ? X  X  symbol), and alternative ( X  X  o 4  X  X  symbol) requirements.
After describing the requirements and the variation points of the application, it is necessary to specify the ontologies to be used by the application. The construction of the ontologies was based on an ontology engineering methodology ( Mizoguchi, 2004 ) taken into account the features presented in each ITS model (Pedago-gical, Student and Domain Model).
 View {include}
Indeed, the Domain Model was built based on a multi-dimen-sional view of this knowledge ( Bittencourt et al., 2009b ) describ-ing the curriculum structure and also the specified resources. The domain model ontology is shown in Table 1 . 11
The Student Model has the knowledge about who will be taught, so it contains information about the student being taught. The definition of the model was developed through the evaluation of Chen and Mizoguchi (2004) capturing some elements of static and dynamic information about the student. This ontology describes static information about the student (the student information that does not change during the student X  X  system interaction), learner goals (the goals of a student in a certain curriculum), and the cognitive information (the student informa-tion that change during the student X  X  system interaction. Usually, this information is associated with the domain information). Part of this ontology is presented in Table 2 .

At last, the Pedagogical Model contains the knowledge about how to teach, serving as a resource for conducting the interaction. Usually, this interaction occurs through an instructional plan that takes into account cognitive aspects of the students. The Pedago-gical Model construction was based on the works of Kumar et al. (2004) and du Boulay and Luckin (2001) , such as pedagogical strategies and tactics, as shown in Table 3 .

After the domain specification, the next step is to specify the services of the intelligent system. Such specification is provided in the next sections. 4.1.2. Services specification
The specification of the services takes into account the use case diagrams and the ontologies described in the prior subsection.
However, in order to better understand the services specifica-tion, the activity diagram with the life cycle of the ITS was created. Fig. 5 presents a fragment of this diagram, 12 this fragment contains some activities related to the use cases of Fig. 3 .
According to the activity diagram and the ontology, it is possible to define the Static Planning of the application with inputs and outputs, as described in Fig. 6 .

In the example illustrated in Fig. 6 , in the first step a Sequence control construct is used to build a sequence of execution that has as first service the specification of Send Education Response . In the second part of the sequence, a Split-Join control construct is used, this control construct specifies the parallel execution of the service View Resource and a last control construct is set. The last output parameter Resource is a Problem , in affirmative case the service Answer Question is invoked, in negative case the service Check Curriculum Advance will be executed.

In addition, each activity/step described in the diagram/plan-ning represents a requirement of the application represented by one or more Semantic Web Services and they can have different implementations. For example, the implementation of the activity  X  X  X nswer Problem X  X  varies according to the kind of implemented problem. 4.1.3. Services development
In this step, the implementation of services created in the previous step occurs. The article discusses the development of services shown in Fig. 6 . Then, the narratives of the use cases of each of these services are presented:
Send educational resource : (i) Student clicks in the icon to show next resource, (ii) system checks what is the next resource in the curriculum which the student is learning, (iii) returns to the student the indicated Resource.

View resource : (i) Receives the resource to be displayed, (ii) checks the type of view suitable according to the type of resource (text, video, slides), (iii) loads the visualization tool.
Answer question : (i) Receives the answers from the student, (ii) checks the type of problem, (iii) stores the answers in the interactions history in the learner ontology according to the type of problem.

Check answer : (i) Loads the answers in the interactions history of student, (ii) checks in the pedagogical ontology the answers of the problem, (iii) compares the answers of the student with the correct answers, (iv) stores the result in the interactions history of the student.
 Check curriculum advance : (i) Receives the resource seen by the
Student, (ii) checks the resource weight in the curriculum of the student, (iii) updates the student knowledge in his curriculum.
From the narratives of use cases begins the implementation of traditional Web Services. In this case study, the Framework
Apache Axis 13 was used for the development of the described services and using Tomcat 6.0 14 as the application server.
Then, with the service developed, the ontologies for descrip-tion of these services are created. The semantic descriptions of this case study are created by using OWL-S, due to the compat-ibility with the basic implementation of the Grinv.

With the OWL-S Editor ( Denker et al., 2005 ), the input and output parameters of the Send resource service were related to the classes of the ontologies that specify the system domain. The input parameter was related with the Student class and the output parameter with the Resource class. Fig. 7 shows fragments of the
Semantic descriptions created in the OWL-S Editor. The same process was repeated for the others services of the system. 4.1.4. Definition of services repository
At this stage, the services repository must be configured and the services developed in the previous step must be added to this repository.

Grinv uses repositories based on Sesame. Thus, the creation of two data bases is necessary, in order that the Services Repository (SR) and Services Under Observation (SUO) repositories can be created.
Sesame is compatible with MySQL 15 and PostGres. 16 In this case study, MySQL will be used for both the repositories (SR and SUO).
Configured the repositories, the semantic descriptions of the services developed in the previous step are inserted in the SR in Repository Manager module of the Grinv. This tool receives the services that will be added to the repository and uses the OWL-S API to manipulate the semantic descriptions of these services and add them to the repository. This phase contemplates the development of services discovery algorithms that will be used in the system. Two algorithms that will be integrated into the Grinv were implemented: 1. The discovery and composition algorithm based on searches in a graph ( Calado et al., 2009 ). 2. A search algorithm that uses backward chain, similar to the one presented by Sheshagiri (2004) .
 Since Algorithm 1 has higher priority within the system. Listing 1 presents a pseudo code for the search Algorithm 1.
Listing 1. PseudoCode of Algorithm 1. 1 public Service 2 findService (Inputs i, Outputs o){ 3 4 GrinvRepository SR  X  Config. getSR (); 5 List services  X  SR.loadServices (); 6 7 MatchGraph graph  X  new MatchGraph () ; 8 graph. addServices (services); 9 10 VertexList inV  X  graph.VertexWithInput (i); 11 VertexList outV  X  graph.VertexWithOutput (i) ; 12 13 PathList paths; 14 foreach (Vertex a in inV){ 15 foreach (Vertex b in outV){ 16 paths.add (graph.getpath (a,b)); 17 } 18 } 19 20 return Dijkstra.getShortest (paths); 21 22 }
The backward chaining, Algorithm 2, works as follows: the engine starts the search for services whose outputs match the requested service, then it searches for services whose output can be connected to the inputs of the first services. This iteration continues until they find services whose entries match the entries specified in the request, thus setting up a  X  X  X hain X  X  of services to be performed.

These algorithms were impleme nted using Java language. To integrate these algorithms with Grinv, they realize the DiscoveryAlgo-rithm Interface from Grinv Middleware and implements the method discover . In the same way, to create new algorithms and integrate them, the developers may build Java classes that realize the DiscoveryAlgorithm interface and implements the algorithm features.
Discovery and composition example using IOPE parameters : Regard-ing the search using the IOPE (Inp ut, Output, Preconditions and
Effects) parameters, the system uses the algorithms above to find services that meet user requests based on the IOPE parameters supplied by user, composing services if necessary.
 For example, student is doing a problems solve activity. However, he needs a tip to resolve this problem, i.e. the student need a service (simple or composite) that come to provide this hint based on problem that he is solving, this process corresponds to activity Ask Tip in Fig. 5 . So, he should specify this request, as shown in Table 4 , where he specifies the service based on its Inputs and Outputs Parameters, and sends the Problem (Pro-blem_143a) that he wants to use as parameter.
 Table 5 shows the services that are available in the Services Repository (SR). Some information about them is following:
Explain concept : This service aims at providing a Hint to help the student in understanding a certain Concept.

Show resource : This service receives as input a student and based on his course, this service returns to the user a resource that will be presented to the student.
 Give concept : This service helps the user in the problem solving activity. It relates a certain Problem to the Concept necessary to answer it.
 Evaluate problem : This service evaluates the solution of a problem made by a student. Therefore, it receives of system: a student and a problem and returns an assessment this solution.
In order to perform the discovery process, we used the algorithm based on graphs ( Calado et al., 2009 ), as stated above.
As we can see in log file provided in Listing 1, the algorithm execution got the Explain concept service as direct matching, that is the most similar service the request made by the user, in fact its output parameter is equal to asked by user, however its input parameters are different. As indirect matching, the algorithm indi-cated the Give concept and Explain concept services composition in sequence, in fact the first service input corresponds to the required input by user (Problem) and the se cond service output is equal to defined output by user (Hint). Moreover, the first service output is equal to second input making a good option to compose, Fig. 8 illustrates this composition. Comparing the two solutions, the indirect matching is chosen as discovery answer, more details about the execution of the algorithm can be found in Calado et al. (2009) . Listing 2. Discovery Algorithm execution log.

Discovery Request: 4 Descriptions: 44 Inputs: {Problem} 44 Outputs: {Hint}  X  X  X  X  X  X 
Direct Matching Search:  X  4 Service: Give Concept  X  75%  X  4 Service: Show Resource  X  35,5%  X  4 Service: Explain Concept  X  75%  X  4 Service: Evaluate Problem  X  75%  X  X  X  X  X  X 
Indirect Matching Search: 4 Path found, Services: 44 Give Concept  X  4 Explain Concept  X  100%  X  X  X  X  X  X  Direct Matching Result: 75% Indirect Matching Result: 100% Final Result: Indirect Matching
Composition: {Give Concept, Explain Concept} 4.1.5. Development of invocation mechanisms
Automatic invocation algorithms should be able to perform the invocation of a service by performing the necessary mappings between inputs and outputs without requiring user intervention, that is, the user must send the input parameters and the invocation mechanism must be able to map the input parameters supplied by the user with the service parameters found by the discovery mechanism.
 An invocation mechanism was developed using the OWL-S API, that is capable to dynamically perform simple and composed processes. 4.1.6. Technologies integration
The step of technologies integration corresponds to the crea-tion of mechanisms which allows that the mechanisms developed in the previous steps can automatically operate without the need of user intervention, that is, these integration mechanisms are responsible for match the discovery and invocation processes, and their results, in order that their operation becomes transparent to the user.
 Grinv implements these integration mechanisms through Requisition Manager that is responsible to integrate the execution of the processes for supporting the requests of the user. But, it is necessary to indicate the mechanisms that were chosen in order that the Configuration module can reflect in the system the choice of these mechanisms. For this, the configuration file was created, shown in Listing 3, containing the information about the mechan-isms developed in this case study.
 Listing 3. Grinv Configuration File. 1 o ? xml version  X   X  X  1 : 0 X  X  encoding  X   X  X  X TF X 8 X  X ? 4 2 o configuration 4 3 o ! Repository Settings 4 4 o SRrepository 4 5 o class 4 grinv : GrinvSR o = class 4 6 o location 4 http://grow.ic.ufal.br/ 7 openrdf 2 sesame = repositories = SR o = location 4 8 o = SRrepository 4 9 o SUOrepository 4 10 o class 4 grinv : GrinvSUO o = class 4 11 o location 4 http://grow.ic.ufal.br/ 12 openrdf 2 sesame = repositories = SUO o = location 4 13 o = SUOrepository 4 14 o ! Discovery Settings 4 15 o discovery 4 16 o algorithm 4 17 o class 4 grinv : GraphsMatchmaker o = class 4 18 o priority 4 1 o = priority 4 19 o = algorithm 4 20 o algorithm 4 21 o class 4 grinv : BackwardChaining o = class 4 22 o priority 4 2 o = priority 4 23 o = algorithm 4 24 o = discovery 4 25 o ! Invocation Settings 4 26 o invocation 4 27 o class 4 grinv : OwlsInvocEngine o = class 4 28 o = invocation 4 29 o = configuration 4 4.2. Evaluation
This subsection provides an evaluation of the presented case study, showing how the problems discussed in Section 2 were overcome in building an ITS based on Semantic Web Services. The case study showed a real scenario of building an Intelligent Tutoring System based on Semantic Web Services that are respon-sible for implementing the features of the system. Initially, the case study presented the main concepts and processes related to Intelligent Tutoring Systems through use case and features dia-grams ( Figs. 3 and 4 ). Based on these diagrams and following an Ontology Engineering methodology ( Mizoguchi, 2004 ), ontologies that describe concepts semantically related to ITS were built.
Then, in the Services Specification step, the Tutoring process was specified by an activity diagram ( Fig. 5 ), where each activity was related to a service or set of services, i.e. the characteristics of each activity were expressed in the form of parameters of the ontology OWL-S Profile, which specifies the functionality of each service. A Planning specification example was also shown.
The next step was the Services Development , where the services were implemented (traditional Web Services and semantic descriptions). This case study does not address the possibility of reuse of services implemented by other developers and available on the web, which does not mean that it cannot be done (in fact this is the best way to do it), but the goal of the scenario is just to show that in the end of this stage the services should be working. With the services running, they were stored in Grinv Services Repository . After that, the development of discovery mechanisms was shown. The development of two discovery algorithms were discussed, and following, the use of these algorithms in the process of discovery and composition through IOPE parameters.
Then, a mechanism for automatic invocation of services was developed using OWL-S API Process Execution Engine , which is able to invoke simple and composite services described in OWL-S, including support to versions 1.2 and below. So, to invoke services described in another language (e.g. WSMO, WSDL-S) the devel-oper should implements new mechanisms and integrates them to the system.

Finally, in the last step, the infrastructure for integration and automation of discovery and invocation were made. The Grinv Middleware was used to integrate these processes,
In relation to the application developed and the development process, the following points were noted: Guided development : The steps proposed in Section 3 guided the development process, during specification of the domain and services, services implementation and development of mechanisms for discovery and invocation. In this process, it was allowed to the developer to customize the system features according to the system needs.
 Grinv : The use of the Grinv as a Middleware was needed to enable easy integration between the technologies used in the processes of discovery, composition and invocation of services, in addition to provide a repository based on services using Sesame persistence.
 Furthermore, the use of Grinv is presented as a solution to the other mentioned problems, such as: 1. Using the Static Planning approach is not always possible : Grinv allows the developer to discover services through
Static Planning, as shown in Section 3.2.2. But it also enables the discovery process through IOPE parameters, thus ensur-ing that the system can sometimes use Planning, sometimes through use of parameters IOPE. Besides making the system adaptable according to their evolution. In the case study, both approaches were used (Sections 4.1.2 and 4.1.4). 2. Performance on loading ontologies : This is addressed because
Grinv uses a repository based on Sesame. As a result the ontologies are stored in databases, not in repositories located on the Web so the loading time of ontologies is optimized, avoiding this problem in system performance. If
Grinv used a distributed repository the performance pro-blems will be related only with regards to traditional distributed database problems ( Broekstra et al., 2001 ).
Moreover, Grinv implements mechanisms for automatic updating of ontologies stored in the repository with the files available on the Web, to avoid related problems. 3. Mechanisms Integration : Grinv provides the modules Requisi-tion Manager , Discovery Controller and Invocation Controller to enable the developer to integrate discovery and invoca-tion processes. In addition, Grinv allows changing these tools without directly affecting the other system modules.
For this, the developer only needs to implement or reuse the new tools and change the Configuration File . 4. Fault tolerance : As shown in Section 3.2.3, Grinv implements a technique for fault tolerance, ensuring that the system will not stop its execution due to a problem in the invocation of a faulty service ( Claro and de Arau  X  jo Mac  X  edo, 2008 ). Iterative process : During the development of the system was detected the necessity of using an iterative process in building the system, by the need for adjustments in the ontology due to the emergence of new concepts during the specification of services. Thus, ontologies have been slightly changed in the process of specifying services.
 Discovery mechanisms : the discovery and composition algo-rithms used in the discovery step showed satisfactory results, mainly because they have already been evaluated and used by other studies such as Weise et al. (2008) , Calado et al. (2009) and Barros et al. (2009) . Moreover, they are able to find compositions of services when needed.

Based on these observations, it is verified that in this case study was developed a system based on Semantic Web Services, with its development guided by the steps presented in Section 3.1, beyond the use of Grinv Middleware to assist this process, and avoids the problems found in the development of these systems and pre-sented in Section 2. 4.2.1. Semantic Web Services frameworks
Here, the goal is to provide a brief comparison between some similar approaches to the Grinv Middleware. Recently, the com-munity has proposed some tools for discovery, composition and invocation of Semantic Web Services. This section will present some of these works, comparing them with the work proposed in this article.

The METEOR-S ( Aggarwal et al., 2004 ) is a tool that provides mechanisms for discovery and invocation of Semantic Web
Services and supports discovery of services through Static Plan-ning. But this work provides no mechanism for fault tolerance or support the addition of new approaches to discovery.

The framework proposed in Majithia et al. (2004) provides discovery and service composition through a forward chaining approach and has a mechanism for fault tolerance, but it is restricted to fault tolerance in discovery process (non-availability of a service). This framework also does not allow adding new discovery mechanisms.

In the work ( Weise et al., 2008 ) is proposed an architecture that supports three different approaches for services composition, although results are presented that show the effectiveness of this approach. However, this work does not allow the addition of new techniques for discovering services, and does not provide any mechanism for invoking services and fault tolerance.

WSMX ( Hasselwanter et al., 2006 ) (Web Service Modeling eXecution environment) is the reference implementation of
WSMO. It is an execution environment for business application integration where enhanced web services are integrated for various business applications. WSMX focuses on building support business processes based on services while also providing support for discovery and composition as shown in Section 4.1.4.
Although we also allow the developer to customize the execution environment (e.g. change detection algorithms and composition), this framework supports only a detection algorithm for time, unlike the Grinv that supports multiple algorithms. The frame-work reference document ( Hasselwanter et al., 2006 ) does not mention the use of any technique for providing fault tolerance, as provided by Grinv. Support for Static Planning (orchestration and choreography) is provided through graphical tools that helps the developer. Grinv does not offer these tools yet, but they might in future be incorporated into the framework.

Additionally, the Grinv effectiveness has been proven in various applications developed by our research group, such as: (i) MASSAYO-LMS ( Bittencourt et al., 2009b ): A Learning Manage-ment System based on Semantic Web Technologies and (ii) LPS-STI ( Silva et al., 2010 ): A Semantic Web-Based Software Product
Line for Building Intelligent Tutoring Systems. 5. Conclusion
In this paper we discussed some important empirical issues faced by software system developers when building applications based on Semantic Web Services. In addition, we introduced a systematic way to facilitate the development process of intelli-gent applications based on SWS and presented how this approach tackles the discussed issues. Finally, preliminary experimental results have shown the effectiveness in building intelligent systems using our approach.

The proposed approach is relevant and original in what concerns to two aspects. First, it provides a set of steps that guide the developer in the process of building intelligent applications based on Semantic Web Services. Second, it proposes the use of Grinv Middleware to integrate the discovery, composition, and invocation processes, tackling the development problems stated during the paper. The use of Grinv allowed the construction of an Intelligent Application without the problems presented in Section 2. A number of references are provided addressing some isolated issues, such as, fault tolerance, performance on loading ontolo-gies, unguided development. Different from the other works, our proposal presents an integrated solution addressing each of the mentioned issues by applying them in a real application.
As immediate future work, we will focus on providing a better analysis using the same case study, in the same conditions, in order to compare our approach with other ones with respect to the W3C member submissions to Semantic Web Service model-ing, such as OWL-S ( Martin et al., 2004 ), WSMO ( Roman et al., 2006 ), and SAWSDL ( Farrell and Lausen, 2007 ).
 References
