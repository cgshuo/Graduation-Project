 Linear Support Vector Machines (SVMs) have become one of the most prominent machine learning techniques for high-dimensional sparse data commonly encountered in applica-tions like text classification, word-sense disambiguation, and drug design. These applications involve a large number of examples n as well as a large number of features N , while each example has only s&lt;&lt;N non-zero features. This paper presents a Cutting-Plane Algorithm for training lin-ear SVMs that provably has training time O ( sn ) for clas-sification problems and O ( sn log( n )) for ordinal regression problems. The algorithm is based on an alternative, but equivalent formulation of the SVM optimization problem. Empirically, the Cutting-Plane Algorithm is several orders of magnitude faster than decomposition methods like SVM-Light for large datasets.
 I.2.6 [ Artificial Intelligence ]: Learning Algorithms, Performance, Experimentation Support Vector Machines (SVM), Training Algorithms, Or-dinal Regression, Large-Scale Problems, ROC-Area
Many applications of machine learning deal with problems where both the number of features N as well as the number of examples n is large (in the millions). Examples of such problems can be found in text classification, word-sense dis-ambiguation, and drug design. While problems of such size seem daunting at first glance, the examples mentioned above have extremely sparse feature vectors, which gives hope that these problems can be handled efficiently.

Linear Support Vector Machines (SVMs) are among the most prominent machine learning techniques for such high-dimensional and sparse data. On text classification prob-Copyright 2006 ACM 1-59593-339-5/06/0008 ... $ 5.00. lems, for example, linear SVMs provide state-of-the-art pre-diction accuracy [10, 5, 17]. While conventional training methods for linear SVMs, in particular decomposition meth-ods like SVM-Light [11], SMO [19], LIBSVM [2], and SVM-Torch [3] handle problems with a large number of features N quite efficiently, their super-linear scaling behavior with n [11, 19, 9] makes their use inefficient or even intractable on large datasets. On the other hand, while there are train-ing methods that scale linear in n (e.g. [18, 7, 6, 15]), such methods empirically (or at least in the worst case) scale quadratically with the number of features N .

Even more difficult is the current situation for training lin-ear Ordinal Regression SVMs (OR-SVMs) [8]. In Herbrich et al. X  X  formulation, an ordinal regression SVM over n ex-amples is solved by translating it into a classification SVM with O ( n 2 ) examples, which obviously makes scaling with n even worse than for straightforward classification SVMs. Nevertheless, OR-SVM are very interesting even beyond ac-tual ordinal regression problems like those in information retrieval. When applied to problems with only two ranks, OR-SVMs are know to directly optimize the ROC-Area of the classification rule [20, 14]. This is a desirable criterion to optimize in many applications.

In this paper, we propose the first general training algo-rithm for linear SVMs that provably scales O ( sn ) for clas-sification and O ( sn log( n )) for ordinal regression, where s is the average number of non-zero features. Obviously, this scaling is very attractive for high-dimensional and sparse data. The algorithm is based on an alternative, yet equiv-alent formulation of the SVM training problem. Compared to existing methods, the algorithm has several advantages. First, it is very simple and easy to implement. Second, it is several orders of magnitude faster than existing decompo-sition methods on large classification problems. On a text classification problem with 800,000 examples and 47,000 fea-tures, the new algorithm is roughly 100 times faster than SVM-Light. Third, the algorithm has a meaningful stopping criterion that directly relates to training error. This avoids wasting time on solving the optimization problem to a higher precision than necessary. And, fourth, the algorithm can handle ordinal regression problems with hundred-thousands of examples with ease, while existing methods become in-tractable with only a few thousand examples.
We first introduce the formulation of the SVM optimiza-tion problem that provides the basis of our algorithm, both for classification and for ordinal regression SVMs. Both for-mulations are derived from Structural SVMs [24, 14] previ-ously used for predicting structured outputs and optimizing to multivariate performance measures. For each alternative formulation, we will show that it is equivalent to the respec-tive conventional SVM optimization problem.
For a given training set ( x 1 ,y 1 ) , ..., ( x n ,y n )with x and y i  X  X  X  1 , +1 } , training a binary classification SVM means solving the following optimization problem. For sim-plicity of the following theoretical results, we focus on classi-fication rules h w ( x )=sign( w T x + b )with b = 0. A non-zero b can easily be modeled by adding an additional feature of constant value to each x (see e.g. [18]).

OP 1. (Classification SVM (primal))
Note that we adopted the formulation of [22, 21] where  X  i is divided by n to better capture how C scales with the training set size. Most training algorithms solve either OP1 or its dual (see [21] for the dual).

The algorithm we explore in the following considers a dif-ferent optimization problem, which was proposed for train-ing SVMs to predict structured outputs [24] and to optimize multivariate performance measures like F 1 -Score or the Pre-cision/Recall Break-Even Point [14]. The following is a spe-cialization of this formulation for the case of error rate, and we will refer to it as the  X  X tructural X  formulation.
OP 2. (Structural Classification SVM (primal))
While OP2 has 2 n constraints, one for each possible vec- X  that is shared across all constraints. Each constraint in this structural formulation corresponds to the sum of a sub-set of constraints from OP1, and the c i select the subset. errors possible over each subset, and  X  is an upper bound on the fraction of tra ining errors made by h w . Interestingly, OP1 and OP2 are equivalent in the following sense.
Theorem 1. Any solution w  X  ofOP2isalsoasolution of OP1 (and vice versa), with  X   X  = 1 n n i =1  X   X  i .
Proof. Adapting the proof from [14], we will show that both optimization problems have the same objective value and an equivalent set of constraints. In particular, for every w the smallest feasible  X  and i  X  i are related as  X  = 1 n i
For a given w ,the  X  i in OP1 can be optimized individually, and the optimum is achieved for  X  i = max { 0 , 1  X  y i ( w For OP2, the optimal  X  for a given w is Since the function is linear in c i ,each c i can be optimized independently. min C X  = Therefore, the objective functions of both optimization prob-lems are equal for any w given the optimal  X  and  X  i ,and consequently so are their optima.

The theorem shows that it is possible to solve OP2 instead of OP1 to find the same soft-margin hyperplane. While OP2 does not appear particularly attractive at first glance, we will show in Section 3 that its Wolfe Dual has desirable sparseness properties. Before we show that a similar formu-lation also exists for Ordinal Regression SVMs [8], we first state the Wolfe dual of OP2, since it will be referred to later. Denote with x c the sum 1 n n i =1 c i y i x i and with || L1-norm of c (i.e. the number ones in c for binary c ).
OP 3. (Structural Classification SVM (dual)) max s.t.
In ordinal regression, the label y i of an example ( x i ,y indicates a rank instead of a nominal class. Without loss of related on an ordinal scale. In the formulation of Herbrich et al. [8], the goal is to learn a function h ( x )sothatforany pair of examples ( x i ,y i )and( x j ,y j ) it holds that Given a training set ( x 1 ,y 1 ) , ..., ( x n ,y n )with x y  X  X  1 , ..., R } , Herbrich et al. formulate the following or-dinal regression SVM (OR-SVM). Denote with P the set of pairs ( i, j ) for which example i has a higher rank than example j , i.e. P = { ( i, j ): y i &gt;y j } ,andlet m =
OP 4. (Ordinal Regression SVM (primal))
Intuitively, this formulation finds a large-margin linear function h ( x ) that minimizes the number of pairs of training examples that are swapped w.r.t. their desired order. Like for classification SVMs, OP4 is a convex quadratic program. Ordinal regression problems have applications in learning re-trieval functions for search engines [12]. Furthermore, if the labels y take only two values, OP4 optimizes the ROC-Area of the classification rule [20, 14].

In general, OP4 has m  X  O ( n 2 ) constraints and slack vari-ables. While this problem can be brought into the same form as OP1 by rewriting the constraints as w T ( x i  X  x j )  X  even relatively small training sets with only a few thousand examples are already intractable for conventional training methods. So far, researchers have tried to cut down on the number of constraints with various heuristics [20] which, however, cannot guarantee that the computed solution is optimal.

We will now derive a similar structural formulation of the ordinal regression SVM as we have already done for the bi-nary classification SVM.

OP 5. (Structural Ord. Regr. SVM (primal)) min s.t.  X  ( i, j )  X  X  X  c ij  X  X  0 , 1 } : 1
Like for classification, the structural formulation has O (2 constraints, but only a single slack variable  X  . Analogous to the classification SVM, the following theorem establishes that both formulations of the OR-SVM have equivalent so-lutions.

Theorem 2. Any solution w  X  ofOP5isalsoasolution of OP4 (and vice versa), with  X   X  = 1 m ( i,j )  X  X   X   X  ij
Proof. As mentioned above, the constraints in OP4 can be rewritten as y ij ( w T ( x i  X  x j ))  X  1  X   X  ij with all y 1. Theorem 1 applies immediately after substituting x ij x  X  x j , since OP4 has the same form as OP1, and OP5 has the same form as OP2.
While the alternative formulations of the classification and the ordinal regression SVM from above have an exponential number of constraints, they are very convenient in several ways.

First, there is a single slack variable  X  that measures train-ing loss, and there is a direct correspondence between  X  and the (in)feasibility of the set of constraints. In particular, if we have a point ( w , X  ) which fulfills all constraints up to precision ,then( w , X  + ) is feasible. So, the approxima-tion accuracy of an approximate solution to OP2 or OP5 is directly related to training loss, which provides an intuitive precision criterion.

Second, OP2 and OP5 are special cases of Structural SVMs [24, 14]. As we will detail below, for this type of formula-tion it is possible to prove bounds on the sparsity of an -approximate solution of the Wolfe dual. In particular, we will show that the sparsity is independent of the training set size n , and that simple Cutting-Plane Algorithms [16] find an -approximate solution in a constant number of iterations for both OP2 or OP5.
Algorithm 1 is our adaptation of the Cutting-Plane Al-gorithm for the Classification SVM optimization problem OP2. It is an adaptation of the Structural SVM training algorithm [24, 14]. The algorithm iteratively constructs a sufficient subset W of the set of constraints in OP2. The al-gorithm starts with an empty set of constraints W .Ineach iteration, it first computes the optimum over the current working set W (i.e. w =0and  X  = 0 in the first iteration) in Line 4. In Lines 5-7 it then finds the most violated con-straint in OP2 and adds it to the working set W in Line 8. Algorithm 1 for training Classification SVMs via OP2. 1: Input: S =(( x 1 ,y 1 ) ,..., ( x n ,y n )), C , 2: W X  X  X  3: repeat 4: ( w , X  )  X  argmin w , X   X  0 1 2 w T w + C X  5: for i=1,...,n do 6: c i  X  1 y i ( w 7: end for 8: W X  X  X  X  c } 9: until 1 n 10: return( w ,  X  ) Note that this assignment to ( c 1 , ..., c n )= c corresponds to the constraint in OP2 that requires the largest  X  to make it feasible given the current w , i.e. The algorithm then continues in Line 4 by optimizing over the new working set, unless the most violated constraint is not violated by more than the desired precision .
In the following, we will analyze the correctness and the time complexity of the algorithm. We will show that the algorithm always terminates after a polynomial number of iterations that does not depend on the size n of the train-ing set. Regarding its correctness, the following theorem characterizes the accuracy of the solution computed by Al-gorithm 1.
 Theorem 3. (Correctness of Algorithm 1)
For any training sample S =(( x 1 ,y 1 ) ,..., ( x n ,y n any &gt; 0 ,if ( w  X  , X   X  ) is the optimal solution of OP2, then Algorithm 1 returns a point ( w , X  ) that has a better objective value than ( w  X  , X   X  ) ,andforwhich ( w , X  + ) is feasible in OP2.

Proof. We first verify that Lines 5-7 compute the vector c  X  X  0 , 1 } n that maximizes  X  is the minimum value needed to fulfill all constraints in OP2 for the current w . Since the function is linear in c each c i can be maximized independently.  X  = 1 This directly corresponds to the assignment in Line 6. As checked in Line 9, the algorithm terminates only if  X  does not exceed the  X  from the solution over W by more than as desired.

Since the ( w , X  ) returned by Algorithm 1 is the solu-tion on a subset of the constraints from OP2, it holds that
Using a stopping criterion based on the accuracy of the training loss  X  is very intuitive and practically meaningful, unlike the stopping criteria typically used in decomposition methods. Intuitively, can be used to indicate how close one wants to be to the error rate of the best hyperplane. In most machine learning applications, tolerating a training error that is suboptimal by 0 . 1% is very acceptable. This intuition makes selecting the stopping criterion much easier than in decomposition methods, where it is usually defined based on the accuracy of the Kuhn-Tucker Conditions of the dual (see e.g. [11]). Solving OP2 to an arbitrary but fixed precision of is essential in our analysis below, making sure that computation time is not wasted on computing a solution that is more accurate than necessary.

We next analyze the time complexity of Algorithm 1. It is easy to see that each iteration of the algorithm takes poly-nomial time, and that time scales linearly with n and s .We then show that the number of iterations until convergence is bounded, and that this upper bound is independent of n .
Lemma 1. Each iteration of Algorithm 1 takes time O ( sn ) for a constant working set size |W| .
 Proof. Each dot-product in Lines 6 and 9 takes time O ( s ) when using sparse vector algebra, and n dot-products are computed in each line. Instead of solving the primal quadratic program, one can instead solve the dual OP3 in Line 4. Setting up the dual over W in Line 4 is dominated by computing the O ( |W| 2 ) elements of the Hessian, which can be done in O ( |W| 2 sn ) after first computing 1 n n i =1 for each constraint in W . Note that N  X  sn .Thetimefor solving the dual is then independent of n and s . This leads to an overall time complexity of O ( sn ) per iteration.
Lemma 2. For any &gt; 0 , C&gt; 0 , and any training sam-ple S =(( x 1 ,y 1 ) ,..., ( x n ,y n )) , Algorithms 1 and 2 termi-nate after at most iterations. R =max i || x i || for Algorithm 1 and for Algo-rithm 2 it is R =2max i || x i || .

Proof. Following the proof scheme in [24, 13], we will show that adding each new constraint to W increases the objective value at the solution of the quadratic program in Line 4 by at least some constant positive value. Since the objective value of the solution of OP2 is upper bounded by C (since w =0 and  X  =1 is a feasible point in the primal), the algorithm can only perform a constant number of itera-tions before termination. The amount by which the solution increases by adding one constraint that is violated by more then (i.e. the criteria in Lines 9 and 26 respectively) to W is characterized by Proposition 17 in [24]. A lower bound on the increase is where Q is an upper bound on the L 2 -norm of the coefficient vectors in the constraints. For OP2
Q =max in the case of Algorithm 1 and for OP5 Q =max in the case of Algorithm 2. Due to this constant increase of the objective value in each iteration, either algorithm can add at most max 2 , 8 CR 2 2 constraints before the objective value exceeds C , which is an upper bound on the objective value at the solution of OP2 and OP5.

Note that the formulation of OP2 with the scaled C n in-stead of C in the objective is essential for this lemma. We will empirically evaluate the adequacy of this scaling in Sec-tion 4. Putting everything together leads to the following bound on the time complexity of Algorithm 1.
 Theorem 4. (Time Complexity of Algorithm 1)
For any distribution P ( X, Y ) that generates feature vectors of bounded L 2 -norm || x || and any fixed value of C&gt; 0 and &gt; 0 , Algorithm 1 has time complexity O ( sn ) for any train-ing sample of size n and sparsity s .

Proof. Lemma 2 bounds the number of iterations (and therefore the maximum working set size |W| ) to a constant that is independent of n and s . Each iteration has time complexity O ( sn ) as established by Lemma 1.

To our knowledge, Algorithm 1 has the best scaling be-havior of all known training algorithms for linear SVMs. De-composition methods like SVM-Light [11], SMO [19], LIB-SVM [2], and SVMTorch [3] handle sparse problems with a large number of features N quite efficiently. However, their super-linear scaling behavior with n [11, 19, 9] makes them inefficient or even intractable on large datasets. We will compare our algorithm against SVM-Light as a representa-tive decomposition methods.

Other methods sacrifice the statistical robustness [22] of the  X  i loss in the objective for the numerically more con-venient  X  2 i loss. With additional restrictions on how the data is normalized, Core Vector Machines [23] are shown to scale linear in n . However, the restrictions make the method inapplicable to many datasets. Generally applicable are La-grangian SVM [18] (using the  X  2 i loss), Proximal SVM [7] (using an L 2 regression loss), and Interior Point Meth-ods [6]. While these method scale linearly with n ,theyuse the Sherman-Morrison-Woodbury formula for inverting the Hessian of the dual. This requires operating on N  X  N ma-trices, which makes them applicable only for problems with small N . As a representative of this group of methods, we will compare against the Lagrangian SVM in Section 4.
The recent L2-SVM-MFN method [15] avoids explicitly representing N  X  N matrices using conjugent gradient tech-iteration, they observe that their method empirically scales better. We will compare against this method as well.
Algorithm 2 solves the ordinal regression SVM in the form of OP5 and has a structure that is very similar to Algo-rithm 1. It is a generalization of the algorithm for optimiz-ing ROC-Area in [14] and similar to the algorithm indepen-dently developed in [4]. The key difference to Algorithm 1 lies in computing the most violated constraint of OP5 c =argmax without enumerating all m  X  O ( n 2 ) constraints from OP4. To avoid O ( n 2 ) cost, Algorithm 2 makes use of a condensed Algorithm 2 for training Ord. Regr. SVMs via OP5. 1: Input: S =(( x 1 ,y 1 ) ,..., ( x n ,y n )), C , 2: W X  X  X  3: repeat 4: ( w , X  )  X  argmin w , X   X  0 1 2 w T w + C X  5: sort S by decreasing w T x i 6: c +  X  0; c  X   X  0 7: n r  X  number of examples with y i = r 8: for r =2 , ..., R do 9: i  X  1; j  X  1; a  X  0; b  X  0 10: while i  X  n do 11: if y i = r then 12: while ( j  X  n )  X  ( w T x i  X  w T x j &lt; 1) do 13: if y j &lt;r then 14: b ++; c  X  j  X  c  X  j +( n r  X  a +1) 15: end if 16: j ++ 17: end while 18: a ++; c + i  X  c + i + b 19: end if 20: i ++ 21: end while 22: end for 23: W X  X  X  X  ( c + , c  X  ) } 24: until 1 2 m 25: return( w ,  X  ) representation of the constraints as follows. While the left-hand side of the linear constraints in OP4 contains a sum over m vectors of differences ( x i  X  x j ), most individual vec-tors x i are added and subtracted multiple time. With proper coefficients c + i and c  X  j , each constraint can be rewritten as asumof n vectors where c + i is the number of times x i occurs with positive sign (i.e. c ij =1)and c  X  i is the number of times x i oc-curs with negative sign (i.e. c ji =1). If c + and c  X  are known, each constraint can be evaluated in time O ( sn )in-stead of O ( sm ). Furthermore, the right hand side of each constraint can be computed from c + and c  X  in time O ( n ) following theorem shows that Algorithm 2 computes the co-efficient vectors c + and c  X  of the most violated constraint, and therefore converges to the optimal solution in the same sense as Algorithm 1.
 Theorem 5. (Correctness of Algorithm 2)
For any training sample S =(( x 1 ,y 1 ) ,..., ( x n ,y n any &gt; 0 ,if ( w  X  , X   X  ) is the optimal solution of OP5, then Algorithm 2 returns ( w , X  ) that have a better objective value than ( w  X  , X   X  ) ,andforwhich ( w , X  + ) is feasible in OP5.
Proof. Analogous to the proof of Theorem 3, c =argmax is reached for This means that the number of times x i enters with positive and negative sign is To compute these quantities efficiently, Algorithm 2 first sorts the training examples by decreasing value of w T x Then, for each rank r in turn, it updates the values of c and c + for all constraints ( i, j )  X  X  in OP4 with y i = r .By going through the examples in order of w T x i , the algorithm can keep track of via incremental updates. Whenever it encounters an exam-ple with y i = r , there are exactly b constraints ( i, j ) whenever it encounters an example with y j &lt;r , there are ex-actly ( n r  X  a ) constraints ( i, j )  X  X  in OP4 with y i r , y i = r ,and y j &lt;r and adding the respective quantities to c i and c in OP4.

Like Algorithm 1, the iteration terminate only if no con-straint in OP5 is violated by more than ,and since W is a subset of the constraints in OP4.

The following lemma characterizes the time Algorithm 2 takes in each iteration as a function of n and s . Lemma 3. Each iteration of Algorithm 2 requires time O ( sn + n log( n )+ Rn ) for a constant working set size
Proof. The proof is analogous to that of Lemma 1. The greatest expense per iteration in terms of n is the sort in Line 5 and the computation of n inner products w T x i .Lines 8-24 take R  X  1 passes through the training set. Due to the condensed representation, setting up the quadratic program in Line 4 can again be done in time O ( |W| 2 sn ) analogous to Lemma 1.

Lemma 2 already established an upper bound on the num-ber of iterations of Algorithm 2. Analogous to Theorem 4, the following characterizes its the scaling behavior. Theorem 6. (Time Complexity of Algorithm 2)
For any distribution P ( X, Y ) that generates feature vectors of bounded L 2 -norm || x || and any fixed value of C&gt; 0 and &gt; 0 , Algorithm 2 has time complexity O ( sn log( n )) for any training sample of size n and sparsity s .

Note that conventional methods for training ordinal re-gression SVMs based on OP4 have much worse scaling be-havior. They scale roughly O ( sn 3 ) even under the (opti-mistic) assumption that a problem with m constraints can be solved in O ( m ) time. Only small training sets with hun-dreds or at best a few thousand examples are tractable.
Classification Ordinal Regression Heuristic approaches for pushing the limits by removing con-straints offer no performance guarantees [20]. We will see in the following experiments that Algorithm 2 can handle problems with hundred-thousands of examples with ease.
While Theorems 4 and 6 characterize the asymptotic scal-ing of Algorithms 1 and 2, the behavior for small sample sizes may be different. We will empirically analyze the scal-ing behavior in the following experiments, as well as its sensi-tivity to C and . Furthermore, we compare the algorithms against existing methods, in particular the decomposition method SVM-Light.

We implemented Algorithms 1 and 2 using SVM-Light as the basic quadratic programming software that is called in Line 4 of each algorithm. However, other quadratic pro-gramming tools would work just as well, since |W| remained small in all our experiments. We will refer to our implemen-tation of Algorithms 1 and 2 as SVM-Perf in the following. SVM-Perf is available at http://svmlight.joachims.org .
We use 5 datasets in our experiments, selected to cover a wide range of properties. 1. First, we consider the binary text classification task 2. Second, we include the task C11 from the RCV1 collec-3. The third problem is classifying abstracts of scientific 4. The fourth problem is class 1 in the Covertype dataset 5. Finally, we added the KDD04 Physics task from the http://jmlr.csail.mit.edu/papers/volume5/lewis04a/ lyrl2004 rcv1v2 README.htm http://www.ics.uci.edu/  X  mlearn/MLRepository.html We use the Precision/Recall Break-Even Point (PRBEP) (see e.g. [10]) as the measure of performance for the text-classification tasks, and Accuracy for the other problems.
The following parameters are used in our experiments, unless noted otherwise. Both SVM-Light and SVM-Perf use =0 . 001 (note that their interpretation of is dif-ferent, though). As the value of C , we use the setting that achieves the best performance on the test set when using the full training set ( C =10 , 000 for Reuters CCAT , C = 50 , 000 for Reuters C11 , C =20 , 000 for Arxiv astro-ph , C =1 , 000 , 000 for Covertype 1 ,and C =20 , 000 for KDD04 Physics ). Whenever possible, runtime comparisons are done on the full set of examples, joining training and test data together to get larger datasets. Experiments that com-pare prediction performance report results for the standard test/training split. All experiments are run on 3 . 6MhzIntel Xeon processors with 2GB main memory under Linux. Table 1 compares the CPU-time of SVM-Perf and SVM-Light on the full data for the 5 tasks described above. For the classification SVM, SVM-Perf is substantially faster than SVM-Light on all problems, achieving a speedup of several orders of magnitude on most problems. We will analyze these results in detail in the following sections.
We also applied the ordinal regression SVM to these data-sets, treating the binary classification problems as ordinal problems with two classes. An alternative view on this setup is that the OR-SVM learns a classification rule that optimizes ROC Area [20, 14]. The runtimes are somewhat slower than for classification, but still very tractable. We tried to train SVM-Light in its ordinal regression mode on these problems as well. However, training with SVM-Light is intractable with more than  X  4,000 examples.
 A method that was recently proposed for training linear SVMs is the L2-SVM-MFN algorithm [15]. While they do not provide an implementation of their method, they re-port training times for the two publicly available dataset Adult and Web in the version produced by John Platt. On the Adult data with 32,562 examples and 120 features, they report a training time of 1.6 CPU-seconds for the value of C = 0.0625  X  32,562 achieving optimal cross-validation error, which is comparable to 3.1 CPU-seconds needed by SVM-Perf for C =0.05  X  32,562 as recommended by Platt. Sim-ilarly, for the Web data with 49,749 examples and 300 fea-tures, L2-SVM-MFN is reported to take 5.0 CPU-seconds ( C =1  X  49,749) while SVM-Perf takes 7.6 CPU-seconds for the same value of C . While both methods seem to perform comparably for these rather small training sets, it is unclear how L2-SVM-MFN scales. In the worst case, the authors conclude that each iteration may scale O ( sn min { n, N } though practical scaling is likely to be substantially better. Finally, note that L2-SVM-MFN uses squared slack vari-ables  X  2 i to measure training loss instead of linear slacks  X  i like in SVM-Light and SVM-Perf.

The Lagrangian SVM (LSVM) [18] is another method par-ticularly suited for training linear SVMs. Like the L2-SVM-MFN, the LSVM uses squared slack variables  X  2 i to mea-sure training loss. The LSVM can be very fast if the number of features N is small, scaling roughly as O ( nN 2 ). We ap-plied the implementation of Mangasarian and Musicant 3 to the Adult and the Web data using the values of C from above. With 31 . 4 CPU-seconds, the training time of the LSVM is still comparable on Adult . For the higher-dimensional Web task, the LSVM runs into convergence problems. Apply-ing the LSVM to tasks with thousands of features is not tractable, since the algorithm requires storing and inverting an N  X  N matrix.
Figure 1 shows log-log plots of how CPU-time increases with the size of the training set. The left-most plot shows the scaling of SVM-Perf for classification, while the left-middle plot shows the scaling of SVM-Light. Lines in a log-log plot correspond to polynomial growth O ( n d ), where d cor-responds to the slope of the line. The middle plot shows that SVM-Light scales roughly O ( n 1 . 7 ), which is consistent with previous observations [11]. SVM-Perf has much better scaling, which is (to some surprise) better than linear with roughly O ( n 0 . 8 ) over much of the range.

Figure 2 gives insight into the reason for this scaling be-havior. The graph shows the number of iterations of SVM-Perf (and therefore the maximum number of constraints in the working set) in relation to the training set size n .It turns out that the number of iterations is not only upper bounded independent of n as shown in Lemma 2, but that http://www.cs.wisc.edu/dmi/lsvm/ Figure 2: Number of iterations of SVM-Perf for clas-sification as a function of sample size n . it does not grow with n even in the non-asymptotic region. In fact, for some of the problems the number of iterations decreases with n , which explains the sub-linear scaling in CPU-time. Another explanation lies in the high  X  X ixed cost X  that is independent of n , which is mostly the cost for solving a quadratic program in each iteration.

Since Lemma 2 identifies that the number of iterations depends on the value of C , scaling for the optimal value of C might be different if the optimal C increases with training set size. To analyze this, the middle-right plot of Figure 1 shows training time for the optimal value of C . While the curves look more noisy, the scaling still seems to be roughly linear.

Finally, the right-most plot in Figure 1 shows training time of SVM-Perf for ordinal regression. The scaling is slightly steeper than for classification as expected. The num-ber of iterations is virtually identical to the case of classifi-cation shown in Figure 2. Note that training time of SVM-Light would scale roughly O ( n 3 . 4 ) on this problem. Figure 3: Difference in prediction performance be-tween SVM-Perf and SVM-Light for classification as a function of C . One potential worry is that the speedup of SVM-Perf over SVM-Light somehow comes at the expense of prediction ac-curacy, especially due to the choice of =0 . 001. However, this is not the case. Figure 3 shows the difference in test set accuracy / PRBEP between the classifiers produced by SVM-Light and SVM-Perf. For better readability, the dif-ference is shown in terms of percentage points. A positive value indicates that SVM-Perf has higher prediction perfor-mance, a negative value indicates that SVM-Light performs better. For almost all values of C both methods perform al-most identically. In particular, there is not indication that the rules learned by SVM-Perf are less accurate. One case where there is a large difference is the Covertype 1 task for small values of C , since SVM-Light stops before fully con-verging.
The previous section showed that =0 . 001 is sufficient to get prediction accuracy comparable to SVM-Light. But maybe a lower precision would suffice and reduce training time? Figure 4 shows the difference (in percentage points) in prediction accuracy / PRBEP compared to the performance SVM-Perf reaches for =0 . 001. Values above (below) 0 indicate that the accuracy of SVM-Perf for that is better (worse) than the accuracy at =0 . 001. The graph shows that for all  X  0 . 01 the prediction performance is within half a percentage point. For larger values of the resulting rules are starting to have more variable and less reliable performance. So, overall, =0 . 001 seems accurate enough with some  X  X afety margin X . However, one might elect to use larger at the expense of prediction accuracy, if training time was substantially faster. We will evaluate this next.
Lemma 2 indicates that the number of iterations, and therefore the training time, should decrease as increases. Figure 5 shows number of iterations as a function of .In-terestingly, the empirical scaling of roughly O ( 1 0 . 3 better than O ( 1 2 ) in the bound from Lemma 2. For training time, as shown in Figure 6, the scaling is O ( 1 0 . 4 ). Figure 4: Difference in Accuracy or PRBEP of SVM-Perf compared to its performance at =0 . 001 as a function of . Figure 5: Number of iterations of SVM-Perf for clas-sification as a function of . Figure 6: CPU-time of SVM-Perf for classification as a function of .
 is set to maximize test set prediction performance).
Could the runtime of SVM-Light be improved by increas-ing the value of as well? While SVM-Light converges faster for larger values of , the difference is much smaller. Even when increasing to 0 . 5, the speedup is less than a factor of 2 on all five problems.
While we have already established that training with =0 . 001 gives rules of comparable prediction accuracy, it is also interesting to look at how close the objective value of the relaxed solution is to the true optimum for different values of . As Theorems 3 and 5 show, the objective value is lower than the true objective, but by how much? Figure 7 shows the relative difference between the solution of SVM-Perf and a high-precision solu-tion computed by SVM-Light. The left-hand plot of Figure 7 indicates that for =0 . 001 the relative error is roughly be-tween 0.1% and 1% over all values of C . The missing points correspond to values where SVM-Light failed to converge. The right-hand plot shows how t he relative error decreases with . Finally, let X  X  examine how the number of iterations of SVM-Perf scales with the value of C . The upper bound of Lemma 2 suggest a linear scaling, however, Figure 8 shows that the actual scaling is much better with O ( sification (and similarly for ordinal regression). Figure 9 shows the resulting training times (left) and compares them against those of SVM-Light (right). Except for excessively large values of C , the training time of SVM-Perf scales sub-linearly with C . Note that the optimal values of C lie be-tween 10 , 000 and 50 , 000 for all tasks except Covertype 1 . For all values of C , SVM-Perf is faster than SVM-Light.
This research was supporte d under NSF Aw ard IIS-0412894 and through a gift from Google. Figure 8: Number of iterations of SVM-Perf as a function of C .
We presented a simple Cutting-Plane Algorithm for train-ing linear SVMs that is shown to converge in time O ( sn )for classification and O ( sn log( n )) for ordinal regression. It is based on an alternative formulation of the SVM optimiza-tion problem that exhibits a different form of sparsity com-pared to the conventional formulation. The algorithm is em-pirically very fast and has an intuitively meaningful stopping criterion.

The algorithm opens several areas for research. Since it takes only a small number of sequential iterations through the data, it is promising for parallel implementations using out-of-core memory. Also, the algorithm can in principle be applied to SVMs with Kernels. While a straightforward implementation is slower by a factor of n , matrix approxi-mation techniques and the use of sampling might overcome this problem. [1] R. Caruana, T. Joachims, and L. Backstrom. Kddcup [2] C.-C. Chang and C.-J. Lin. LIBSVM: a library for [3] R. Collobert and S. Bengio. Svmtorch: Support vector [4] J. Dez, J. del Coz, and A. Bahamonde. A support [5] S. Dumais, J. Platt, D. Heckerman, and M. Sahami. [6] M. Ferris and T. Munson. Interior-point methods for [7] G. Fung and O. Mangasarian. Proximal support [8] R. Herbrich, T. Graepel, and K. Obermayer. Large [9] D. Hush and C. Scovel. Polynomial-time [10] T. Joachims. Text categorization with support vector [11] T. Joachims. Making large-scale SVM learning [12] T. Joachims. Optimizing search engines using [13] T. Joachims. Learning to align sequences: A [14] T. Joachims. A support vector method for [15] S. Keerthi and D. DeCoste. A modified finite newton [16] J. Kelley. The cutting-plane method for solving [17] D. Lewis, Y. Yang, T. Rose, and F. Li. Rcv1: A new [18] O. Mangasarian and D. Musicant. Lagrangian support [19] J. Platt. Fast training of support vector machines [20] A. Rakotomamonjy. Svms and area under roc curve. [21] B. Schoelkopf and A. J. Smola. Learning with Kernels . [22] B. Sch  X  olkopf, A. J. Smola, R. C. Williamson, and [23] I. Tsang, J. Kwok, and P.-M. Cheung. Core vector [24] I. Tsochantaridis, T. Joachims, T. Hofmann, and
