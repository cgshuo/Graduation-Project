 The semantic similarity of words is a long-standing topic in computational linguistics be-cause it is theoretically intriguing and has many applications in the field. Many researchers have conducted studies based on the distributional hy-pothesis (Harris, 1954), which states that words that occur in the same contexts tend to have similar meanings. A number of semantic similarity mea-sures have been proposed based on this hypothesis (Hindle, 1990; Grefenstette, 1994; Dagan et al., 1994; Dagan et al., 1995; Lin, 1998; Dagan et al., 1999).
In general, most semantic similarity measures have the following form: where v ( w i ) is a vector that represents the con-texts in which w i appears, which we call a context profile of w i . The function g is a function on these context profiles that is expected to produce good similarities. Each dimension of the vector corre-sponds to a context, f k , which is typically a neigh-boring word or a word having dependency rela-tions with w i in a corpus. Its value, v k ( w i ) , is typ-ically a co-occurrence frequency c ( w i , f k ) , a con-ditional probability p ( f k | w i ) , or point-wise mu-tual information (PMI) between w i and f k , which are all calculated from a corpus. For g , various works have used the cosine, the Jaccard coeffi-cient, or the Jensen-Shannon divergence is uti-lized, to name only a few measures.

Previous studies have focused on how to de-vise good contexts and a good function g for se-mantic similarities. On the other hand, our ap-proach in this paper is to estimate context profiles ( v ( w i ) ) robustly and thus to estimate the similarity robustly. The problem here is that v ( w i ) is com-puted from a corpus of limited size, and thus in-evitably contains uncertainty and sparseness. The guiding intuition behind our method is as follows. All other things being equal, the similarity with a more frequent word should be larger, since it would be more reliable. For example, if p ( f k | w 1 ) and p ( f k | w 2 ) for two given words w 1 and w 2 are equal, but w 1 is more frequent, we would expect that sim ( w 0 , w 1 ) &gt; sim ( w 0 , w 2 ) .
In the NLP field, data sparseness has been rec-ognized as a serious problem and tackled in the context of language modeling and supervised ma-chine learning. However, to our knowledge, there has been no study that seriously dealt with data sparseness in the context of semantic similarity calculation. The data sparseness problem is usu-ally solved by smoothing, regularization, margin maximization and so on (Chen and Goodman, 1998; Chen and Rosenfeld, 2000; Cortes and Vap-nik, 1995). Recently, the Bayesian approach has emerged and achieved promising results with a clearer formulation (Teh, 2006; Mochihashi et al., 2009).

In this paper, we apply the Bayesian framework to the calculation of distributional similarity. The method is straightforward: Instead of using the point estimation of v ( w i ) , we first estimate the distribution of the context profile, p ( v ( w i )) , by Bayesian estimation and then take the expectation of the original similarity under this distribution as follows: The uncertainty due to data sparseness is repre-sented by p ( v ( w i )) , and taking the expectation en-ables us to take this into account. The Bayesian estimation usually gives diverging distributions for infrequent observations and thus decreases the ex-pectation value as expected.

The Bayesian estimation and the expectation calculation in Eq. 2 are generally difficult and usually require computationally expensive proce-dures. Since our motivation for this research is to calculate good semantic similarities for a large set of words (e.g., one million nouns) and apply them to a wide range of NLP tasks, such costs must be minimized.

Our technical contribution in this paper is to show that in the case where the context profiles are multinomial distributions, the priors are Dirich-let, and the base similarity measure is the Bhat-tacharyya coefficient (Bhattacharyya, 1943), we can derive an analytical form for Eq. 2, that en-ables efficient calculation (with some implemen-tation tricks).

In experiments, we estimate semantic similari-ties using a large amount of Web data in Japanese and show that the proposed measure gives bet-ter word similarities than a non-Bayesian Bhat-tacharyya coefficient or other well-known similar-ity measures such as Jensen-Shannon divergence and the cosine with PMI weights.
 The rest of the paper is organized as follows. In Section 2, we briefly introduce the Bayesian esti-mation and the Bhattacharyya coefficient. Section 3 proposes our new Bayesian Bhattacharyya coef-ficient for robust similarity calculation. Section 4 mentions some implementation issues and the so-lutions. Then, Section 5 reports the experimental results. 2.1 Bayesian estimation with Dirichlet prior Assume that we estimate a probabilistic model for the observed data D , p ( D |  X  ) , which is parame-terized with parameters  X  . In the maximum like-lihood estimation (MLE), we find the point esti-mation  X   X  = argmax  X  p ( D |  X  ) . For example, we estimate p ( f k | w i ) as follows with MLE: On the other hand, the objective of the Bayesian estimation is to find the distribution of  X  given the observed data D , i.e., p (  X  | D ) , and use it in later processes. Using Bayes X  rule, this can also be viewed as: p prior (  X  ) is a prior distribution that represents the plausibility of each  X  based on the prior knowl-edge. In this paper, we consider the case where  X  is a multinomial distribution, i.e., that models the process of choosing one out of K choices. Estimating a conditional probability dis-tribution  X  k = p ( f k | w i ) as a context profile for each w i falls into this case. In this paper, we also assume that the prior is the Dirichlet distribution, Dir (  X  ) . The Dirichlet distribution is defined as follows.
  X ( . ) is the Gamma function. The Dirichlet distri-bution is parametrized by hyperparameters  X  k ( &gt; 0) .

It is known that p (  X  | D ) is also a Dirichlet dis-tribution for this simplest case, and it can be ana-lytically calculated as follows. where c ( k ) is the frequency of choice k in data D . For example, c ( k ) = c ( w i , f k ) in the estimation of p ( f k | w i ) . This is very simple: we just need to add the observed counts to the hyperparameters. 2.2 Bhattacharyya coefficient When the context profiles are probability distribu-tions, we usually utilize the measures on probabil-ity distributions such as the Jensen-Shannon (JS) divergence to calculate similarities (Dagan et al., 1994; Dagan et al., 1997). The JS divergence is defined as follows.
 where p avg = p 1 + p 2 2 is a point-wise average of p 1 and p 2 and KL ( . ) is the Kullback-Leibler diver-gence. Although we found that the JS divergence is a good measure, it is difficult to derive an ef-ficient calculation of Eq. 2, even in the Dirichlet prior case. 1
In this study, we employ the Bhattacharyya co-efficient (Bhattacharyya, 1943) (BC for short), which is defined as follows: The BC is also a similarity measure on probabil-ity distributions and is suitable for our purposes as we describe in the next section. Although BC has not been explored well in the literature on distribu-tional word similarities, it is also a good similarity measure as the experiments show. In this section, we show that if our base similarity measure is BC and the distributions under which we take the expectation are Dirichlet distributions, then Eq. 2 also has an analytical form, allowing efficient calculation.

Here, we calculate the following value given two Dirichlet distributions: After several derivation steps (see Appendix A), we obtain the following analytical solution for the above: where  X   X  0 = with the Dirichlet prior,  X   X  k =  X  k + c ( w 1 , f k ) and  X  k =  X  k + c ( w 2 , f k ) , where  X  k and  X  k are the hyperparameters of the priors of w 1 and w 2 , re-spectively.
 To put it all together, we can obtain a new Bayesian similarity measure on words, which can be calculated only from the hyperparameters for the Dirichlet prior,  X  and  X  , and the observed counts c ( w i , f k ) . It is written as follows. where a 0 =  X  k c ( w 2 , f k ) . We call this new measure the Bayesian Bhattacharyya coefficient (BC b for short). For simplicity, we assume  X  k =  X  k =  X  in this paper.

We can see that BC b actually encodes our guid-ing intuition. Consider four words, w 0 , w 1 , w 2 , and w 4 , for which we have c ( w 0 , f 1 ) = 10 , c ( w 1 , f 1 ) = 2 , c ( w 2 , f 1 ) = 10 , and c ( w 3 , f 20 . They have counts only for the first dimen-sion, i.e., they have the same context profile: p ( f 1 | w i ) = 1 . 0 , when we employ MLE. When K = 10 , 000 and  X  k = 1 . 0 , the Bayesian similar-ity between these words is calculated as
We can see that similarities are different ac-cording to the number of observations, as ex-pected. Note that the non-Bayesian BC will re-turn the same value, 1.0, for all cases. Note also that BC b ( w 0 , w 0 ) = 0 . 78542 if we use Eq. 8, meaning that the self-similarity might not be the maximum. This is conceptually strange, al-though not a serious problem since we hardly use sim ( w i , w i ) in practice. If we want to fix this, we can use the special definition: BC b ( w i , w i )  X  1 . This is equivalent to using sim b ( w i , w i ) = Although we have derived the analytical form (Eq. 8), there are several problems in implement-ing robust and efficient calculations.

First, the Gamma function in Eq. 8 overflows when the argument is larger than 170. In such cases, a commonly used way is to work in the log-arithmic space. In this study, we utilize the  X  X og Gamma X  function: ln  X ( x ) , which returns the log-arithm of the Gamma function directly without the overflow problem. 2
Second, the calculation of the log Gamma func-tion is heavier than operations such as simple mul-tiplication, which is used in existing measures. In fact, the log Gamma function is implemented using an iterative algorithm such as the Lanczos method. In addition, according to Eq. 8, it seems that we have to sum up the values for all k , be-cause even if c ( w i , f k ) is zero the value inside the summation will not be zero. In the existing mea-sures, it is often the case that we only need to sum up for k where c ( w i , f k ) &gt; 0 . Because c ( w i , f is usually sparse, that technique speeds up the cal-culation of the existing measures drastically and makes it practical.

In this study, the above problem is solved by pre-computing the required log Gamma values, as-suming that we calculate similarities for a large set of words, and pre-computing default values for cases where c ( w i , f k ) = 0 . The following values are pre-computed once at the start-up time.
 For each word: (A) ln  X (  X  0 + a 0 )  X  ln  X (  X  0 + a 0 + 1 2 ) (B) ln  X (  X  k + c ( w i , f k ))  X  ln  X (  X  k + c ( w i , f (C)  X  exp(2( ln  X (  X  k + 1 2 )  X  ln  X (  X  k )))) + For each k : (D): exp(2( ln  X (  X  k + 1 2 )) .

In the calculation of BC b ( w 1 , w 2 ) , we first as-sume that all c ( w i , f k ) = 0 and set the output variable to the default value. Then, we iterate over the sparse vectors c ( w 1 , f k ) and c ( w 2 , f k we update the output variable just by adding (C). the output value using (B), (D) and one additional exp( . ) operation. With this implementation, we can make the computation of BC b practically as fast as using other measures. 5.1 Evaluation setting We evaluated our method in the calculation of sim-ilarities between nouns in Japanese.

Because human evaluation of word similari-ties is very difficult and costly, we conducted au-tomatic evaluation in the set expansion setting, following previous studies such as Pantel et al. (2009).

Given a word set, which is expected to con-tain similar words, we assume that a good simi-larity measure should output, for each word in the set, the other words in the set as similar words. For given word sets, we can construct input-and-answers pairs, where the answers for each word are the other words in the set the word appears in.
We output a ranked list of 500 similar words for each word using a given similarity measure and checked whether they are included in the an-swers. This setting could be seen as document re-trieval, and we can use an evaluation measure such as the mean of the precision at top T (MP @ T ) or the mean average precision (MAP). For each input word, P @ T (precision at top T ) and AP (average precision) are defined as follows.
  X  ( w i  X  ans ) returns 1 if the output word w i is in the answers, and 0 otherwise. N is the number of outputs and R is the number of the answers. MP @ T and MAP are the averages of these values over all input words. 5.2 Collecting context profiles Dependency relations are used as context profiles as in Kazama and Torisawa (2008) and Kazama et al. (2009). From a large corpus of Japanese Web documents (Shinzato et al., 2008) (100 million documents), where each sentence has a depen-dency parse, we extracted noun-verb and noun-noun dependencies with relation types and then calculated their frequencies in the corpus. If a noun, n , depends on a word, w , with a relation, r , we collect a dependency pair, ( n,  X  w, r  X  ) . That is, a context f k , is  X  w, r  X  here.

For noun-verb dependencies, postpositions in Japanese represent relation types. For example, we extract a dependency relation (  X  X  X  X  ,  X   X  X  X  ,  X   X  ) from the sentence below, where a postposition  X   X  (wo) X  is used to mark the verb object.  X  X  X  X  (wine)  X  (wo)  X  X  X  (buy) (  X  buy a wine)
Note that we leave various auxiliary verb suf-fixes, such as  X   X  X  X  (reru), X  which is for passiviza-tion, as a part of w , since these greatly change the type of n in the dependent position.

As for noun-noun dependencies, we considered expressions of type  X  n 1  X  n 2  X  (  X   X  n 2 of n 1  X ) as dependencies ( n 1 ,  X  n 2 ,  X   X  ) .

We extracted about 470 million unique depen-dencies from the corpus, containing 31 million unique nouns (including compound nouns as de-termined by our filters) and 22 million unique con-texts, f k . We sorted the nouns according to the number of unique co-occurring contexts and the contexts according to the number of unique co-occurring nouns, and then we selected the top one million nouns and 100,000 contexts. We used only 260 million dependency pairs that contained both the selected nouns and the selected contexts. 5.3 Test sets We prepared three test sets as follows.
 Set  X  X  X  and  X  X  X : Thesaurus siblings We Set  X  X  X : Closed sets Murata et al. (2004) con-
Note that we do not deal with ambiguities in the construction of these sets as well as in the calcu-lation of similarities. That is, a word can be con-tained in several sets, and the answers for such a word is the union of the words in the sets it belongs to (excluding the word itself).

In addition, note that the words in these test sets are different from those of our one-million-word vocabulary. We filtered out the words that are not included in our vocabulary and removed the sets with size less than 2 after the filtering.

Set  X  X  X  contained 3,740 words that are actually evaluated, with about 115 answers on average, and  X  X  X  contained 3,657 words with about 65 answers on average. Set  X  X  X  contained 8,853 words with about 1,700 answers on average. 5.4 Compared similarity measures We compared our Bayesian Bhattacharyya simi-larity measure, BC b , with the following similarity measures.
 JS Jensen-Shannon divergence between p ( f k | w 1 ) PMI-cos The cosine of the context profile vec-Cls-JS Kazama et al. (2009) proposed using BC The Bhattacharyya coefficient (Bhat-BC a The Bhattacharyya coefficient with absolute
Since it is very costly to calculate the sim-ilarities with all of the other words (one mil-lion in our case), we used the following approx-imation method that exploits the sparseness of c ( w i , f k ) . Similar methods were used in Pantel and Lin (2002), Kazama et al. (2009), and Pan-tel et al. (2009) as well. For a given word, w i , we sort the contexts in descending order accord-ing to c ( w i , f k ) and retrieve the top-L contexts. 5 For each selected context, we sort the words in de-scending order according to c ( w i , f k ) and retrieve the top-M words ( L = M = 1600 ). 6 We merge all of the words above as candidate words and cal-culate the similarity only for the candidate words. Finally, the top 500 similar words are output.
Note also that we used modified counts, log ( c ( w i , f k )) + 1 , instead of raw counts, c ( w i , f k ) , with the intention of alleviating the ef-fect of strangely frequent dependencies, which can be found in the Web data. In preliminary ex-periments, we observed that this modification im-proves the quality of the top 500 similar words as reported in Terada et al. (2004) and Kazama et al. (2009).
As for BC b , we assumed that all of the hyper-parameters had the same value, i.e.,  X  k =  X  . It is apparent that an excessively large  X  is not ap-propriate because it means ignoring observations. Therefore,  X  must be tuned. The discounting value of BC a is also tuned. 5.5 Results Table 1 shows the results for Set A. The MAP and the MPs at the top 1, 5, 10, and 20 are shown for each similarity measure. As for BC b and BC a , the results for the tuned and several other values for  X  are shown. Figure 1 shows the parameter tuning for BC b with MAP as the y-axis (results for BC a are shown as well). Figure 2 shows the same re-sults with MPs as the y-axis. The MAP and MPs showed a correlation here. From these results, we can see that BC b surely improves upon BC, with 6.6% improvement in MAP and 14.7% improve-ment in MP@1 when  X  = 0 . 0016 . BC b achieved the best performance among the compared mea-sures with this setting. The absolute discounting, BC a , improved upon BC as well, but the improve-ment was smaller than with BC b . Table 1 also shows the results for the case where we did not use the log-modified counts. We can see that this modification gives improvements (though slight or unclear for PMI-cos).

Because tuning hyperparameters involves the possibility of overfitting, its robustness should be assessed. We checked whether the tuned  X  with Set A works well for Set B. The results are shown in Table 2. We can see that the best  X  ( = 0 . 0016 ) found for Set A works well for Set B as well. That is, the tuning of  X  as above is not unrealistic in Figure 1: Tuning of  X  (MAP). The dashed hori-zontal line indicates the score of BC. practice because it seems that we can tune it ro-bustly using a small subset of the vocabulary as shown by this experiment.

Next, we evaluated the measures on Set C, i.e., the closed set data. The results are shown in Ta-ble 3. For this set, we observed a tendency that is different from Sets A and B. Cls-JS showed a particularly good performance. BC b surely im-proves upon BC. For example, the improvement was 7.5% for MP@1. However, the improvement in MAP was slight, and MAP did not correlate well with MPs, unlike in the case of Sets A and B.

We thought one possible reason is that the num-ber of outputs, 500 , for each word was not large enough to assess MAP values correctly because the average number of answers is 1,700 for this dataset. In fact, we could output more than 500 words if we ignored the cost of storage. Therefore, we also included the results for the case where L = M = 3600 and N = 2 , 000 . Even with this setting, however, MAP did not correlate well with MPs.

Although Cls-JS showed very good perfor-mance for Set C, note that the EM clustering is very time-consuming (Kazama and Torisawa, 2008), and it took about one week with 24 CPU cores to get one clustering result in our computing environment. On the other hand, the preparation Table 3: Performance on closed-sets (Set C). for our method requires just an hour with a single core. We should note that the improvement by using our method is just  X  X n average, X  as in many other NLP tasks, and observing clear qualitative change is rel-atively difficult, for example, by just showing ex-amples of similar word lists here. Comparing the results of BC b and BC, Table 4 lists the numbers of improved, unchanged, and degraded words in terms of MP@20 for each evaluation set. As can be seen, there are a number of degraded words, al-though they are fewer than the improved words. Next, Figure 3 shows the averaged differences of MP@20 in each 40,000 word-ID range. 7 We can observe that the advantage of BC b is lessened es-Table 4: The numbers of improved, unchanged, and degraded words in terms of MP@20 for each evaluation set. Figure 3: Averaged Differences of MP@20 be-tween BC b (0.0016) and BC within each 40,000 ID range (Left: Set A. Right: Set B. Bottom: Set C). pecially for low-ID words (as expected) with on-average degradation. 8 The improvement is  X  X n av-erage X  in this sense as well.

One might suspect that the answer words tended to be low-ID words, and the proposed method is simply biased towards low-ID words because of its nature. Then, the observed improvement is a trivial consequence. Table 5 lists some interest-ing statistics about the IDs. We can see that BC b surely outputs more low-ID words than BC, and BC more than Cls-JS and JS. 9 However, the av-erage ID of the outputs of BC is already lower than the average ID of the answer words. There-fore, even if BC b preferred lower-ID words than BC, it should not have the effect of improving the accuracy. That is, the improvement by BC b is not superficial. From BC / BC b , we can also see that the IDs of the correct outputs did not become smaller compared to the IDs of the system outputs. Clearly, we need more analysis on what caused the improvement by the proposed method and how that affects the efficacy in real applications of sim-ilarity measures.

The proposed Bayesian similarity measure out-performed the baseline Bhattacharyya coefficient Table 5: Statistics on IDs. (A): Avg. ID of an-swers. (B): Avg. ID of system outputs. (C): Avg. ID of correct system outputs.
 and other well-known similarity measures. As a smoothing method, it also outperformed a naive absolute discounting. Of course, we can-not say that the proposed method is better than any other sophisticated smoothing method at this point. However, as noted above, there has been no serious attempt to assess the effect of smoothing in the context of word similarity cal-culation. Recent studies have pointed out that the Bayesian framework derives state-of-the-art smoothing methods such as Kneser-Ney smooth-ing as a special case (Teh, 2006; Mochihashi et al., 2009). Consequently, it is reasonable to re-sort to the Bayesian framework. Conceptually, our method is equivalent to modifying p ( f k | w i ) as p ( f k | w i ) = taking the Bhattacharyya coefficient. However, the implication of this form has not yet been in-vestigated, and so we leave it for future research.
Our method is the simplest one as a Bayesian method. We did not employ any numerical opti-mization or sampling iterations, as in a more com-plete use of the Bayesian framework (Teh, 2006; Mochihashi et al., 2009). Instead, we used the ob-tained analytical form directly with the assump-tion that  X  k =  X  and  X  can be tuned directly by using a simple grid search with a small subset of the vocabulary as the development set. If substan-tial additional costs are allowed, we can fine-tune each  X  k using more complete Bayesian methods. We also leave this for future research.

In terms of calculation procedure, BC b has the same form as other similarity measures, which is basically the same as the inner product of sparse vectors. Thus, it can be as fast as other similar-ity measures with some effort as we described in Section 4 when our aim is to calculate similarities between words in a fixed large vocabulary. For ex-ample, BC b took about 100 hours to calculate the top 500 similar nouns for all of the one million nouns (using 16 CPU cores), while JS took about 57 hours. We think this is an acceptable additional cost.

The limitation of our method is that it can-not be used efficiently with similarity measures other than the Bhattacharyya coefficient, although that choice seems good as shown in the experi-ments. For example, it seems difficult to use the Jensen-Shannon divergence as the base similar-ity because the analytical form cannot be derived. One way we are considering to give more flexi-bility to our method is to adjust  X  k depending on external knowledge such as the importance of a context (e.g., PMIs). In another direction, we will be able to use a  X  X eighted X  Bhattacharyya coeffi-cient: the weights,  X  ( w i , f k ) , do not depend on p ik , as the base similarity measure. The analytical form for it will be a weighted version of BC b .

BC b can also be generalized to the case where the base similarity is BC d ( p 1 , p 2 ) = p 2 k , where d &gt; 0 . The Bayesian analytical form becomes as follows.

See Appendix A for the derivation. However, we restricted ourselves to the case of d = 1 2 in this study.

Finally, note that our BC b is different from the Bhattacharyya distance measure on Dirichlet distributions of the following form described in Rauber et al. (2008) in its motivation and analyti-cal form: Empirical and theoretical comparisons with this measure also form one of the future directions. 10 We proposed a Bayesian method for robust distri-butional word similarities. Our method uses a dis-tribution of context profiles obtained by Bayesian estimation and takes the expectation of a base sim-ilarity measure under that distribution. We showed that, in the case where the context profiles are multinomial distributions, the priors are Dirichlet, and the base measure is the Bhattacharyya coeffi-cient, we can derive an analytical form, permitting efficient calculation. Experimental results show that the proposed measure gives better word simi-larities than a non-Bayesian Bhattacharyya coeffi-cient, other well-known similarity measures such as Jensen-Shannon divergence and the cosine with PMI weights, and the Bhattacharyya coefficient with absolute discounting.
 Here, we give the analytical form for the general-ized case ( BC d b ) in Section 6. Recall the following relation, which is used to derive the normalization factor of the Dirichlet distribution: Then, BC d b ( w 1 , w 2 ) Using Eq. 10, A in the above can be calculated as follows: This will give: BC d b ( w 1 , w 2 ) =
