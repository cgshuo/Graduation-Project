 naumann@hpi.uni-potsdam.de Data dependencies are used to improve the quality of a database schema, to optimize queries, and to ensure con-sistency in a database. Conditional dependencies have been introduced to analyze and improve data quality. A con-ditional dependency is a dependency with a limited scope defined by conditions over one or more attributes. Only the matching part of the instance must adhere to the de-pendency. In this paper we focus on conditional inclusion dependencies ( Cind s).

We generalize the definition of Cind s, distinguishing cov-ering and completeness conditions. We present a new use case for such Cind s showing their value for solving complex data quality tasks. Further, we propose efficient algorithms that identify covering and completeness conditions conform-ing to given quality thresholds. Our algorithms choose not only the condition values but also the condition attributes automatically. Finally, we show that our approach efficiently provides meaningful and helpful results for our use case. H.2.8 [ Database Management ]: Database applications Cind , link discovery, association rule mining
Studying data dependencies, or integrity constraints, has a long history in database research. Traditionally, integrity constraints are defined such that all tuples in a table must obey them, and they have mostly been used to preserve con-sistency in a database and as a hint to the query optimizer. Recently, a weaker form of dependencies, so called condi-tional dependencies , have gained attention, mostly due to their power in analyzing and improving data quality [9]. A conditional dependency is a dependency with a limited scope, where the scope typically is defined by conditions over several attributes. Only those tuples for which these conditions evaluate to true must adhere the dependency. Research has focussed on two types, i. e., conditional func-tional dependencies ( Cfd s) [4] and conditional inclusion de-pendencies ( Cind s) [5]. Results have been published on rea-soning about consistency and implication [5, 6], validation of known conditional dependencies [6], or detection of con-ditional functional dependencies [11, 12].

Interestingly, detecting conditional inclusion dependencies has yet received little attention. We present an entirely new case for Cind s, which clearly shows their value for solving complex data quality tasks. To this end we generalize the established definition for Cind s to cover a subtle, yet im-portant difference between different classes of Cind present algorithms to detect all Cind s and evaluate their efficiency.
Our motivation for studying Cind s comes from the prob-lem of describing links between objects on the web. Con-sider, as an example, the problem of interlinking representa-tions of persons in the English and German version of DB-pedia[3]. Clearly, many persons have both an English and a German description in DBpedia. Relationships between entries in DBpedia are either represented by using the same URI or by  X  X ameAs X -links; we refer to these relationships as links . We use the following relational schema to represent information about persons in DBpedia: person(pid, cent) , birthplace(pid, bplace) , deathplace(pid, dplace) with foreign key relationships from birthplace.pid to person.pid and from deathplace.pid to person.pid . Each person has an identifier ( pid ; mostly a person X  X  name), and a century of birth ( cent The separate relations for place of birth and place of death result from the fact that persons in DBpedia can have sev-eral places of birth or death distinguishing for example the country, region, and city of birth or death. Figure 1 shows (part of) the result of the full outer join over relations birthplace , and deathplace on the foreign key attributes in the English version of DBpedia ( Person_EN ) and the German version ( Person_DE ).

Links between persons in Person_EN and Person_DE in Fig. 1 are represented by an identical pid . For some persons in son_EN there is no link to Person_DE (and vice versa). Having a German person without a link to an English person (and vice versa), two situations are possible: (1) This English description does not exist; then the lack of the link truly reflects the database. (2) The English description does ex-ist; then the missing link is a data quality problem. Such problems are very common in scenarios where heterogeneous data sets have overlapping domains but no central authority takes care of properly and bi-directionally linking objects. Many examples of such cases can be found in the world of Linked Open Data [14].

The inclusion dependency Person_EN.pid  X  Person_DE.pid holds only for part of Person_EN . The goal of discovering Cind s is to identify conditions within Person_EN that sum-marize properties of those persons that have a link to Per-son_DE . In the given example we can observe a condition deathplace = United States  X  cent = 18 , which can be ex-plained by the large number of European emigrants in the 19th century to the US. Such conditions are a useful tool to identify candidates for missing links. We propose a method to automatically identify conditions for Cind s between sets of interlinked objects. Figure 1: Selected data about persons from the En-glish ( Person_EN ) and German ( Person_DE ) DBpedia.
We approach the the problem of Cind detection in three steps: (i) detecting an approximate Ind , i. e., an Ind is only satisfied by part of the database, (ii) detecting con-ditions that can turn an approximate Ind into a Cind , i. e., conditions that hold in that part of the database that sat-isfies the approximate Ind , and (iii) choosing a (sub-)set of discovered conditions to build the pattern tableau of the Cind . The first step can be solved using detection methods for approximate Ind s, such as [16], or it could be manu-ally performed by an expert user. The problem of finding an optimal pattern tableau has been addressed for Cfd in [12]. In this paper we assume approximate Ind s to be given and focus on the second step, namely on efficiently de-tecting  X  X ood X  conditions that turn given approximate Ind to
Cind s. We outline in [2] how the third step can be real-ized by applying our algorithms to the ideas of [12].
To achieve our goal of identifying good conditions, we for-mulate desired features of conditions. In the following we reason over single conditions and their features. A condi-tion on a dependent relation R 1 should distinguish tuples of R 1 included in the referenced relation R 2 from tuples not in-cluded in R 2 . A condition that is satisfied only by included tuples is called a valid condition. Simply relying on counting the number of tuples that match a condition, however, may not give the desired results. In our example there are multi-ple tuples for a single person. If we want to find a condition filtering all included persons, should all tuples for this per-son match the condition or does one matching tuple suffice? Consider the six tuples for Cecil Kellaway in Person_DE : cil Kellaway certainly matches condition deathplace = Los Angeles . Counting tuples, however, lets this condition look only one-third as good, because it covers only 2 out of 6 tu-ples. This problem is common when discovering Cind s over relations that are derived by joining relations in a normal-ized database.

To account for these discrepancies we introduce a new fea-ture to characterize the scope of conditions: We distinguish covering conditions for counting objects, e. g., persons; and completeness conditions for counting tuples. More general, a covering condition counts groups of tuples whose projection on the inclusion attributes is equal.

We are not only interested in valid conditions that per-fectly filter only included persons. To be able to propose missing links, we are also interested in  X  X lmost valid X  condi-tions with some non-included persons matching the condi-tion. We use precision and recall measures to quantify the quality of a condition, i. e., the degree of its validity, cover-ing, or completeness (Sec. 2). Our use case then requires to find valid and covering conditions with a certain quality.
Discovering valid and covering, or valid and completeness conditions of a given quality for given approximate poses two challenges: (i) Which (and how many) attributes should be used for the conditions? (ii) Which attribute val-ues should be chosen for the conditions? Within this paper, we propose algorithms that address both of these challenges. Given an approximate Ind , our algorithms find all selecting conditions above a given quality threshold for validity and covering (or completeness) without the need to specify the attributes over which the conditions are generated.

The contributions of this paper are as follows: Formally, a Cind is defined by an embedded approximate Ind and a pattern tableau representing the conditions. The following definitions are based on [5] and [9] but we chose a different, yet more intuitive formulation. Let R 1 ,R 2 be rela-tional schemata over a fixed set of attributes A 1 ,A 2 ,...,A Each attribute A has an associated domain dom ( A ). We de-note instances of R 1 and R 2 by I 1 and I 2 , respectively. Each instance I is a set of tuples t such that t [ A ]  X  dom ( A ) for each attribute A  X  R . Let X,X P and Y,Y P be lists of at-tributes in R 1 and R 2 , respectively. We use t [ X ] to denote the projection of t onto attributes X .
 Def. 1: Approximate IND An approximate Ind R 1 [ X ]  X  R [ Y ] is an Ind that is satisfied for a non-empty subset of tuples in I 1 , i. e.,  X  t 1  X  I 1 ,t 2  X  I 2 : t 1 [ X ] = t
A tuple t 1  X  I 1 satisfies R 1 [ X ]  X  R 2 [ Y ] if there exists a referenced tuple t 2  X  I 2 with t 1 [ X ] = t 2 [ Y ]. We call at-tributes X and Y inclusion attributes .
 Def. 2: Pattern tableau A pattern tableau T P restricts tuples of R 1 over attributes X P and tuples of R 2 over at-tributes Y P . For each attribute A in X P or Y P and each tuple t p  X  T P , t p [ A ] is either a constant in dom ( A ) or a special value  X - X .

Each pattern tuple t p  X  T P defines a condition. A con-stant value for t p [ A ] restricts a matching tuple X  X  attribute value to this constant, a dash represents an arbitrary at-tribute value. A tuple t 1  X  I 1 matches t p  X  T P ( t 1  X  A  X  X P : t p [ A ] = ( X  X  X   X  t 1 [ A ]). The definition for a tuple t  X  I 2 matching t p  X  T P follows analogously over attributes Y . The pattern tableau is divided into a left-hand side (with attributes X P ) and a right-hand side (with attributes Y ). Both sides of the tableau can be left empty specifying no restriction on any attribute of the respective relation. We call attributes X P and Y P condition attributes .
 Def. 3: Conditional inclusion dependency (CIND) A bedded approximate Ind R 1 [ X ]  X  R 2 [ Y ] and the pattern tableau T P over attributes X P and Y P defining the restric-tions. Sets X and X P are disjoint, as are Y and Y P .
Our example Cind is denoted as follows:  X  : ( Person_EN[pid;
A Cind  X  holds for a pair of instances I 1 and I 2 if the following two conditions hold: 1. Selecting condition on I 1 : Let t 1  X  I 1 match any tuple 2. Demanding condition on I 2 : Let t 1  X  I 1 match any
Note that the Cind definition treats selecting conditions and demanding conditions separately and asymmetrically regarding validity and completeness.

Given a Cind  X  and instances I 1 and I 2 . Let I  X  denote the set of tuples from I 1 that satisfy the embedded i. e., I  X  = I 1 n X = Y I 2 . We refer to I  X  as the set of included tuples . We are also interested in groups of included tuples that have equal values in attributes X , e. g., all tuples for Cecil Kellaway . Let g x denote a group of tuples in I 1 value x for t [ X ], i. e., g x = { t | t  X  I 1  X  t [ X ] = x } . We call g x an included group if all tuples are included tuples, i. e., g x  X  I  X  . A group g x matches a pattern tuple t p , denoted by g x t p , if any of the tuples in g x matches t p , i. e., g t  X   X  t  X  g x : t t p . Let G 1 denote the set of groups in I and G  X  denote the set of included groups. Finally, for a pattern tuple t p let I 1 [ t p ] and G 1 [ t p ] denote the set of tuples from I 1 and the groups in G 1 that match t p , respectively. Def. 4: Valid Condition A condition is valid if all tuples of I 1 that match t p also satisfy the embedded IND, i. e., I [ t p ]  X  I  X  .

The validity of a condition can be measured by the pre-cision of this condition, i. e., the number of matching and included tuples related to the number of all matching tuples. We call t p  X  -valid if it has validity greater than threshold  X  . We also define a measure for validity based on groups as the number of matching and included groups relative to the number of all matching groups. We call a condition  X  -valid if it has group validity greater than  X  .
 Def. 5: Completeness condition A condition is complete if it matches all included tuples, i. e., I  X   X  I 1 [ t p
The completeness of a condition can be measured as re-call of this condition counting the relation X  X  tuples, i. e., the number of matching and included tuples related to the num-ber of all included tuples. We call t p  X  -complete if it has completeness greater than  X  .
 Def. 6: Covering Condition A condition is covering if it matches all included groups, i. e., G  X   X  G 1 [ t p ].
The quality of covering conditions can be measured by the recall of these conditions based on the relation X  X  groups, i. e., the number of matching and included groups related to the number of all included groups. We call t p  X  -covering if it has recall greater than  X  .
We describe algorithms to detect all  X  -valid g and  X  -covering conditions without restricting the attributes that should be used. We provide two different approaches:  X  X onditional INclusion DEpendency REcognition Leveraging deLimited Apriori X  ( Cinderella ) uses an Apriori algorithm and is faster, while  X  X osition List Intersection X  (PLI) leverages value position lists and consumes less memory. We present the general idea of both approaches for discovering covering se-lecting conditions and refer to [2] for details and modifica-tions to discover completeness and demanding conditions.
Our algorithms do not rely on the relational representa-tion of the data. Instead, we choose a representation that allows to handle multiple uses of one attribute or predicate for a single group and that holds information if a group is included or non-included: Given an approximate inclusion dependency R 1 [ X ]  X  R 2 [ Y ] we first compute the left outer join R 1 | 1 X = Y R 2 [ Y ] and group the result on the X at-tributes. Each group is represented by the following items: (i) the left-hand side inclusion attribute(s), e. g., the person identifier, (ii) a right-hand side inclusion indicator with val-ues Included for included groups or Null for non-included groups, and (iii) one item for each (attribute : value)-pair for potential condition attributes, i. e., all attributes of the de-pendent relation apart from the inclusion attributes. In the following we assume this representation for the embedded IND Person_DE.pid  X  Person_EN.pid to describe our algo-rithms discovering conditions for persons.
We apply association rule mining to identify conditions like  X  X hose century of birth is 18 and place of death is  X  X nited States X  often also is Included (in the English DB-pedia) X . There are two challenges: (i) mapping the problem of condition discovery to association rule mining and (ii) im-proving efficiency based on characteristics of condition dis-covery. To leverage association rule mining we prepare our baskets in two steps: We use the modified representation of the left outer join result as described above. We must encode the affiliation of values to their attributes to form basket items. For our example, we want to be able to distinguish the two conditions birthplace = Los Angeles and deathplace = Los Angeles . Therefore, we prefix each value with an at-tribute identifier. Using prefixes A to D for our example yields the following basket for Cecil Kellaway: { Included A18, BKapstadt, BS  X  udafrika, CLos Angeles, CKalifornien, CUnited States } . Now we are able to apply an Apriori algo-rithm to these baskets to find frequent itemsets and derive rules.

The Apriori algorithm [1] finds all frequent itemsets and uses these frequent itemsets to derive association rules. Apri-ori uses support and confidence of a rule to prune the search space. In our case the covering of a condition corresponds to the support of a rule in the set of included groups, and the validity of a condition corresponds to the confidence of the rule. A frequent itemset then ensures  X  -covering conditions, while the rule generation step filters  X  -valid g conditions.
The following observation exposes an optimization possi-bility for our problem: We need only rules with right-hand side item Included , because left-hand side items of such rules build the selecting condition. Thus, we can largely re-duce the number of itemsets that must be handled and there-fore improve the efficiency of the algorithm. Our rella algorithm reduces the number of generated frequent itemsets by only considering itemsets that contain item In-cluded [2].
The Position-List-Intersection (PLI) approach uses a po-sition list representation of values that has been used by the algorithm TANE for discovering functional dependen-cies [15]. While our approach looks for intersections of lists, the partition refinement of TANE is based on the discovery of subset relationships of position lists.

Position lists (or inverted lists) represent each distinct value in an attribute of a given instance by the set of tu-ple IDs [15] where the value occurs in. Thus, each attribute is associated with a set of position lists  X  one for each of its distinct values. In our case, positions are group-IDs (e.g., numbers 1-3 for Cecil Kellaway, Mel Sheppard, and Sam Sheppard). For our example the position list for attribute cent are cent : 18 = { 1 , 2 } and cent : 19 = { 3 } .
The idea of PLI is twofold: (i) We use a special posi-tion list for included groups, in our example included = 1 , 2. (ii) We cross-intersect position lists of attributes to test value combinations (i. e., conditions) for the intersected attributes, e. g., intersect each position list of attribute A with each po-sition list of attribute B . The covering of a condition then corresponds to the ratio of the cardinality of its position list P intersected with included to the cardinality of included ( | P  X  included | / | included | ). The validity of a condition corre-sponds to ( | P  X  included | / | P | ). The PLI algorithm [2] recur-sively processes the powerset lattice depth-first by checking all possible combinations that contain a certain condition. It uses the covering threshold for pruning. We evaluate our algorithms using two real-life data sets: Persons in the English and German DBpedia 3 . 6 and Wikipe-dia image data from [13]. We implemented our algorithms in Java6. Data is stored using a commercial DBMS. All experiments were run on a 2x Xeon quad-core server with 16 GB RAM running a 64bit Linux.
 DBpedia use case. There are 296 , 454 persons represented in the English and 175 , 457 persons in the German DBpedia data set; 74 , 496 persons are included in both data sets (iden-tified by using the same URI). We mapped the data sets into relations with 13 attributes, including pid , name , birthdate a description descr . The resulting relations contain 474 , 630 tuples for the English DBpedia, and 280 , 913 tuples for the German DBpedia with an intersection of 133 , 208 tuples.
We identify 85 conditions with a  X  -validity of above 0 . 84 (i. e., twice validity of the empty condition) for German DBpedia persons included in the English DBpedia. The two conditions with the largest covering measure are scr = American actor 1 (  X  -valid g = 0 . 91,  X  -covering = 0 . 029) or descr = American actress (0.89, 0.024). These conditions are intuitive and hardly surprising. But we also found un-foreseen conditions such as birthcent = 18  X  descr = Amer-ican politician  X  (0.94, 0.015) and birthcent = 19  X  death-place = Los Angeles  X  (0.91, 0.010). In [2] we provide a more detailed evaluation and explanation of discovered conditions. Wikipedia use case. Golab et al. [13] use two tables of Wikipedia to discover conditions for Cind s: table Image with attributes name , size , width , height , bits , media_type jor_mime , minor_mime , user , user_text , timestamp , sha1 table Imagelinks denoting links from webpages to image files (attributes il_from and il_to ). The authors in [13] assert the embedded Ind image.name  X  imagelinks.il_to and build a pattern tableau with completeness conditions of the pre-selected attributes bits , media_type , and user_text . The main advantage of our approach over [13] is that the condi-tion attributes need not be pre-selected. Here, we use the same dataset to compare the conditions discovered by both approaches.

If we restrict our algorithms to the same attribute set with the same validity threshold of 0 . 85 and a completeness of at least 0 . 003, we discover the same conditions as [13]. Cinde-rella runs 23 s compared to 18 s reported by [13] (on pre-sumably different hardware). However, our algorithms also discover more detailed conditions, which cannot be found by [13]: E. g. for condition media_type = AUDIO there is an-other condition media_type = AUDIO  X  bits = 0 with the ex-act same validity and completeness. These stricter condi-tions give more insight into the dataset and prevent wrongly generalizing the identified conditions for similar datasets.
Running our algorithms without restricting condition at-tributes yields even more interesting results: Unexpectedly, attributes width and height provide conditions with higher completeness than all other attributes. Conditions width = image both reach a completeness of 0 . 04, compared to com-pleteness measures between 0 . 003 and 0 . 008 of the previ-ous conditions. Conditions height = 300 and height = 200 (each with completeness = 0.02), height = 240 and width = 240 , (each with completeness = 0.01) also have higher com-pleteness. These conditions are non-trivial: other widths and heights also appear in the dataset with similar fre-quency. Cinderella runs 78 s to identify 188 conditions with  X  -valid &gt; 0 . 85 and  X  -complete &gt; 0 . 008.
In summary, the ability to select the condition attributes
Note that we provide translated condition values as the actual value is in German. automatically led to the discovery of more completeness con-ditions satisfying the same validity requirements, which in turn enables to build better pattern tableaux. [13] report an overall support of 0 . 0636, while we discover already individ-ual conditions with a completeness of 0 . 04, corresponding to a support of 0 . 03. Our top two conditions already yield a tableau with a completeness of 0 . 0824 (support 0 . 0641). Performance of algorithms. Comparing both algorithms, Cinderella is less sensitive in runtime to increasing num-bers of identified conditions, while PLI is less sensitive in memory consumption. The amount of included tuples is the decisive factor, not so much the size of the entire data set. We refer to [2] for details and a complexity estimation.
Conditional inclusion dependencies ( Cind s) were proposed by Bravo et al. for data cleaning and contextual schema matching [5]. In [5], complexity bounds for reasoning about Cind s and a sound and complete inference system for Cind are provided. The problem of discovering Cind s from a given database instance, however, is not addressed. De Marchi et al. propose data mining algorithms to discover approximate Ind s [16]. Approximate Ind s are input to the algorithms presented in this paper. Algorithms for generating pattern tableaux for given Ind s are proposed in [8, 13]. The algo-rithm in [8], however, does not ensure or check validity of conditions. Golab et al. present Data Miner , a system for analyzing data quality [13]. The two main differences to our approach are that (1) we do not require the condition attributes to be pre-selected, and (2) we introduce the new concept of covering Ind s, which is essential for the type of data and use case that we consider.

The algorithm in [13] extends the one proposed in [12] for generating pattern tableaux for conditional functional dependencies ( Cfd s), which were introduced in [10]. Algo-rithms for discovering Cfd s are also considered in [7, 11]. In contrast to other approaches, the work in [7] does not assume that the Fd is given in advance. Discovering Fd s, however, is significantly different from discovering approxi-mate Ind s and it therefore is not clear how the algorithms in [7] can be applied to Cind discovery. Fan et al. propose algorithm CFDMiner for discovering constant Cfd s based on closed itemset mining [11]. A minimal constant Cfd is a
Cfd for which the pattern tableau contains only constant values for the attribute in the right-hand side of the embed-ded Fd . Thus, minimal constant Cfd s correspond to asso-ciation rules with single attribute in their antecedent with confidence 100 %, i. e., to selecting conditions with  X  -validity one. Contradiction patterns are also a form of association rules with fixed antecedent [17]. Contradiction patterns were proposed to discover conditions that are frequent within a subset of a database but not frequent within the remain-der of the database. The definitions of conflict relevance and conflict potential are similar to our definitions of valid and completeness conditions. Covering conditions, however, cannot be discovered using the algorithms presented in [17].
We generalize the definition of Cind s by distinguishing covering and completeness conditions. This distinction is important when discovering Cind s over denormalized re-lations. To discover Cind s we present algorithms Cinde-rella and PLI. In contrast to existing approaches, both algorithms not only select the condition values but also the condition attributes automatically. Cinderella is faster than PLI, but consumes more memory. In our experimen-tal evaluation we identified comprehensible, but unforeseen conditions that highlight characteristics of persons for which there exists a link between the English and German version of DBpedia. We plan to adapt the distinction of covering and completeness conditions to the right-hand side of the pattern tableau.
