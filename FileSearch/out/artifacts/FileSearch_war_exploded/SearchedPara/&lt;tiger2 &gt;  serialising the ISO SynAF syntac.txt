 Abstract This paper introduces &lt;tiger2/&gt;, an XML format developed to serialise the object model defined by the ISO Syntactic Annotation Framework SynAF. Based on widespread best practices we adapt a popular XML format for syntactic annotation, TigerXML, with additional features to support a variety of syntactic phenomena including constituent and dependency structures, binding, and different node types such as compounds or empty elements. We also define interfaces to other formats and standards including the Morpho-syntactic Annotation Framework MAF and the ISOCat Data Category Registry. Finally a case study of the German Treebank TueBa-D/Z is presented, showcasing the handling of constituent struc-tures, topological fields and coreference annotation in tandem.
 Keywords syntactic annotation XML format corpus corpora Treebank Tiger XML 1 Introduction The provision of reliable syntactic annotation for written or spoken linguistic data represents an essential step for a variety of natural language processing tasks, as well as for the understanding of more content-related semantic or pragmatic linguistic phenomena. In order to maximise the usefulness of such annotations it is essential that standardised representations for the interchange of syntactic data be defined and widely used within the linguistic and computational linguistic community.

At present the situation appears to be particularly complex because of the variety of contexts and forms that syntactic information may take. Firstly, syntactic information may either be the result of an automatic parsing of textual data or may be manually generated as a component of an annotated corpus. Secondly, the organisation and actual complexity of syntactic information highly depends on both the application context and theoretical background of the project within which such data has been created. In the simplest cases, syntactic representations may boil down to the identification of structural chunks on the textual surface, which may lead for instance to the further identification of technical terms, named entities or conceptual relations (Maedche and Staab 2000 ) in large quantities of data. By contrast, the validation of specific theoretical frameworks requires in-depth syntactic represen-tations, often using a smaller sample of sentences, to account for the capacity of the corresponding theory to adequately represent some complex phenomena.

In between, comparatively large constituent treebanks [e.g. the Penn Treebank (Bies et al. 1995 ), TueBa-D/Z (Telljohann et al. 2004 , 2009 )] and dependency treebanks [e.g. the Prague Dependency Treebank (Hajic  X  et al. 2006 )] have been annotated with syntactic information following a more or less theory independent perspective, in order to offer a reference point for a variety of linguistic studies or for the development and testing of syntactic parsers. The complexity of the standardisation task arises from the need to uniformly represent data in a way that can do justice to all varieties of information from very disparate projects, retaining features from accepted best practices and without becoming unwieldy. Recent years have seen a wide range of standardisation initiatives which attempt to standardise models and formats of more or less particular subdomains in the linguistic area, such as MAF for morpho-syntactic information (ISO/ DIS 24611; see also Romary and Witt 2012 ) or more generally LAF, the Linguistic Annotation Framework (ISO/DIS 24612; see Romary and Ide 2004 ; Ide and Suderman 2014 ), as well as more general efforts within the Text Encoding Initiative (TEI, see Burnard and Bauman 2008 ) and generalised XML formats such as GrAF (Ide and Suderman 2007 ). For syntax, the syntactic annotation framework SynAF (ISO 24615, see Bosch et al. 2012 ) is the ISO standard defining a general data-model for syntactic objects and basic inventories with which syntactically annotated resources can be constructed. The goal of the present article is to introduce an XML serialisation based on TigerXML (Mengel and Lezius 2000 ) for concrete realisations of the SynAF data-model which follows accepted best practices in the treebanking community, is adequately powerful for its needs and avoids unnecessary complications. 2 Models and standards for language resources As alluded to in the introduction, the &lt;tiger2/&gt; initiative is part of a wider endeavor to provide the linguistic resource domain with a complete portfolio of standards facilitating the interchange of linguistic data or the interconnection of language processing tools. In the last 25 years, such initiatives have mainly taken place within the TEI community, with the delivery and maintenance of the TEI guidelines, but also within the International Organization for Standardization (ISO), where its technical committee TC 37/SC 4 has already published several essential standards, with currently even more on its work plan. In the following paragraphs we will try to provide a quick overview of these initiatives with the perspective of better understanding the relationship between concrete formats and the underlying data-models.

The reference example we may begin with is the ISO standard 24610-1 (see Lee et al. 2004 ) for the XML representation of feature structures issued in 2006. This work, the first published by ISO committee TC 37/SC 4, resulted from the conjunction of two favorable factors. On the one hand, the theoretical linguistics domain and in particular several syntactic theories had long since identified the formal background for modeling typed feature structures (cf. Pollard and Sag 1994 ). On the other hand, feature structures have been widely used for even very simple annotation tasks in linguistics (e.g. in phonetics) and this lead the TEI to design an early SGML (then XML) format for their representation (Langendoen and Simons 1995 ). As a consequence, it was a straightforward move that lead to the resulting ISO standard, which took up most of the TEI components and expanded it to be fully compliant with the general model of typed feature structures.

In the case of ISO 24613 (LMF, see Romary 2013a ), published in 2008, there was at that time no real generic model for the representation of lexical data, but a variety of more or less stabilized formats [see for instance Ide and Ve  X  ronis ( 1995 ) and Romary ( 2013a ) for an overview]. The standard thus focused on providing a flexible meta-model (with extensions) encompassing a variety of lexical forms (morpho-syntactic, syntactic-lexical, machine readable dictionaries, etc.) and paying reduced attention to defining a comprehensive serialization for it. Work thus remains to be done in this respect and as shown in (Romary 2013b ) it may be an opportunity to achieve a better convergence with large coverage vocabularies such as the TEI guidelines.

Finally, it can often be argued that the variety of models and formats that are related to the representation of language resources may be a hindrance to a real interoperability of linguistic data. Whereas this is typically a topic covered by GrAF for integrated language resources or PAULA (Dipper 2005 ) for the back-office representation within a corpus management environment such as ANNIS (Zeldes et al. 2009 ), we consider the main issue to be preserving the semantics of the underlying models as well as those of elementary descriptors that are combined with them, in the spirit of ISO 12620 (Data Category Registry/ISOCat, see below). In this respect, well defined language resources, which follow the ISO principles applied in this paper, can be disseminated further according to the Linked Open Data principles (see http://linkeddata.org/ and the Linguistic Linked Open Data initiative: http://linguistics.okfn.org/resources/llod/ ).

In this landscape, we will see that the definition of &lt;Tiger2/&gt; is indeed very close to our first example with feature structures in that an existing model (SynAF), combined with an already well recognized serialization (TigerXML) is a good candidate for a reference standard in its domain.
 3 The ISO SynAF initiative The SynAF standard was initiated within ISO committee TC 37/SC 4 in 2006 with the support of the European project Lirics. 1 Committee TC 37/SC 4 was put together in 2002 within ISO to cover the necessary standardisation activities in the domain of language resources, and in particular to provide, step by step, a comprehensive portfolio of standards improving interoperability across Language Technology applications. In this respect, SynAF was conceived as compliant with the main design principles within ISO/TC 37/SC 4 right from the outset, i.e.:  X  The necessity to rely on a generic modelling scheme to account for the variety of  X  To be articulated with the ISO Data Category Registry (DCR), as described in  X  To be compatible with further standards development within ISO/TC 37/SC 4, in
From a modelling point of view, ISO standards and initiatives in the domain of language resources rely on a modelling framework (cf. Romary 2001 ) that construes the description of a linguistic representation (annotation scheme or lexical structure) as the combination of two main components:  X  A meta -model that informs the general characteristics of the corresponding  X  Data categories, which represent elementary linguistic properties (or values
A specific combination of a meta-model with a data category selection provides a annotation or linguistic database.

The core part of the SynAF meta-model is based on the single notion of syntactic node  X  X erived from the generic annotation node in LAF (Ide and Romary 2003 ). A syntactic node represents the elementary unit of syntactic information. Syntactic nodes are in turn connected with one another by means of syntactic edges , thus forming a syntactic graph . Both syntactic nodes and syntactic edges can be further constrained by annotations, i.e. elementary feature-value pairs expressing properties attached to them. As in all ISO compliant linguistic models, both attribute names and values of annotations should be defined in relation to standardised data categories in ISOCat or at least by providing an ISO 12620 compliant specification recorded in ISOCat. Although the present article is not concerned with particular values, we also integrate a mechanism for referencing ISOCat entries as part of the XML serialization of SynAF. To provide a better account of the various forms of syntactic annotation, the SynAF meta-model further refines the notion of syntactic node by providing two more specific classes, namely terminal and non -terminal nodes . Non-terminal nodes account for the abstract syntactic structures that have no direct anchoring on the surface of the language data to be annotated. These usually serve to represent syntactic constituents such as nominal and verbal phrases. Terminal nodes, on the contrary, are the places of articulation between syntactic structures and the linguistic data. Terminal nodes too can form independent graphs without non-terminal nodes, for example in the case of dependency trees or some forms of coreference annotation. Terminal nodes are also understood as instances of the word form class in ISO MAF, which can flexibly represent a variety of surface forms analysed as having the status of a word unit (including blends, acronyms, compounds, truncated forms and much more). This allows one to deploy various implementation strategies of MAF and SynAF depending on available data or theoretical framework (see below on MAF integration with SynAF in &lt;tiger2/&gt;). In the following paragraphs, we outline several such possible strategies.

The meta-model in Fig. 1 shows syntactic types in the bottom box, with elements for terminal and non-terminal nodes (T_Node and NT_Node), which are instances of the type SyntacticNode. Objects of these types are connected by syntactic edges (objects of the type SyntacticEdge), both of which are annotatable with annotations possibly connected to the DCR. The resulting graph can be connected to external models such as morpho-syntactic annotations through links between terminal objects and external objects as shown above. With this general architecture in mind, the exact expression of the model elements above in the more specifically articulated model of &lt;tiger2/&gt; is laid out below. 4 Serialising SynAF Rather than further increase the diversity of already existing formats, we decided to serialise the SynAF meta-model by adapting an existing popular format for syntax annotation and changing only as much as required and as little as necessary. The choice of TigerXML as a basis for the serialisation of SynAF was primarily motivated by its reception in a wide community of computational and corpus linguists, its readability and its flexibility, as in the ability to define custom node and edge annotations in its declaration block, a mechanism we will extend below. 4.1 Extending the TigerXML data-model While TigerXML has been very successful as a linguistic theory-neutral, versatile format for constituent-based annotations, its expressive power is limited by design decisions made in the 1990s in order to meet the needs of specific corpus annotation schemes, and some of its general features are now out-of-date (e.g. use of the deprecated @idref attribute and the lack of modern @xml:id attributes and XPointers). The possibility of typing nodes in Tiger XML was, similarly to SynAF, limited to two types, called non-terminal and terminal nodes. The mechanism of typing edges was also restricted to two types: primary and secondary dominance edges, whose labels can be freely specified in @label . This restricts the power of the TigerXML format to the annotation of only a subset of the syntactic phenomena which are representable with just one type of terminal or non-terminal node and only two types of edges; as we shall see below, these may not suffice for a variety of purposes, and there is no reason not to extend the inventory of types to an arbitrary size to meet users X  needs. Further deficits which should be addressed from the contemporary perspective involve the ability to link and reference resources outside the syntactic annotation graph proper, including separately stored stand-off source text (for example to preserve whitespace, which the TigerXML tokenisation cannot represent), referencing external standards for annotation schemes using state-of-the-art repositories such as the ISOCat Data Category Registry (ISO 12620), and interoperable binding of annotation layers from other standards, such as the Morpho-syntactic Annotation Framework MAF for the annotation of morphological phenomena (ISO/DIS 24611). 4.1.1 A meta-model approach As with SynAF, &lt;tiger2/&gt; follows the design principles mentioned in Sect. 2 by implementing an explicit object model for its representational elements. Our approach is therefore not limited to providing a new XML-based format for syntactic data as described below, but rather also provides a meta-model following the model-based approach (see MDA, Miller and Mukerji 2003 ). Building on the Eclipse Modeling Framework (Steinberg et al. 2009 ). We have used EMF in combination with the Eclipse IDE for this purpose, because they are open source, available across platforms and have good support for generating Java code. EMF also distinguishes a model layer and a persistencing layer. This distinction allows us to bind several formats to the same meta-model. More specifically we created a mapping between the TigerXML format and &lt;tiger2/&gt; as well as the &lt;tiger2/&gt; meta-model. Thanks to this mechanism, it is possible to convert data from the TigerXML format to &lt;tiger2/&gt; and vice versa via a Java API. After importing data from the persistence layer into the model layer, the API allows us to programmat-ically manipulate, transform and merge data from multiple sources. This API can be used as a basis for processing SynAF data and as a library within other tools. The benefit of using such an API is that the programmer does not have to deal with the persistencing layer anymore, but just works with an abstraction above the concrete data level. Even if the underlying data format changes, for instance when serializing a &lt;tiger2/&gt; model in JSON instead of XML, programmers do not need to concern themselves with differences between formats.

In the last few years, we have seen a trend to not only observe linguistic phenomena on isolated levels of annotation, but also to bring annotation levels together in new multi-layer corpora. Therefore new tools and formats, which are able to deal with multi-layer data have gained prominence. In many cases users may wish to extend existing resources from various tools and formats with syntactic annotations in &lt;tiger2/&gt;. This means that users have to recreate their existing corpus in parts using a variety of serializations. Imagine a corpus, which already contains a tokenization and morphosyntactic layers (like lemma and POS annotations) next to the primary data. Such pre-processed data can also be a basis for a new syntactic annotation layer. Therefore the re-tokenization and re-annotation of data could become a nuisance and is in any case error prone. Because of this, the conversion of reusable data becomes an important issue. But, when establishing a new format the conversion of existing formats into a new one such as &lt;tiger2/&gt;, and vice versa, is less realistic the larger the set of already existing formats is. Though we have already implemented a conversion between the TigerXML format and the new variety of formats is desirable. We therefore extend the converter framework Pepper (Zipser and Romary 2010 ). Pepper is a pluggable framework basing on OSGi (see: www.osgi.org/ ) used to convert data between a variety of linguistic formats. The Pepper framework uses the meta-model Salt [see Zipser ( 2009 ) for details] as an intermediate representation of any supported linguistic format. Mapping data into another format via a common intermediate model allows us to reduce the number of mappings between all possible pairs of n formats from n 2 -n to 2n mappings. Like GraF, Salt is based on a graph model, allowing a very generic treatment of linguistic data. In contrast to GrAF, Salt acts on the model layer in memory and not as a persistent XML format.

The aim of Pepper is to provide an interface for programmers to create mappings between data in any linguistic format and Salt. As mentioned above, the extensibility of Pepper allows us to create a mapping between Salt and our &lt;tiger2/&gt; meta-model and also to plug that mapping into the framework as a Pepper module. The mapping consists of two modules, one to map Salt data to &lt;tiger2/&gt; data and one for the other way around. Figure 2 gives an overview of the architecture of Pepper and its pluggable nature. To implement the mapping, we used the previously described &lt;tiger2/&gt; Java API. The pepper module specifies a programmatic mapping between two meta-models, also written in Java. Since Salt is very generic and defines a set of nodes, edges, labels and layers adapted to generalized linguistic meanings, it is not fixed to syntactic annotations only and can represent morphology, coreference, information structure and many other phenom-ena. This is turn allows us to convert a wide variety of existing resources in different formats to &lt;tiger2/&gt;, including GrAF, as well as to export &lt;tiger2/&gt; projects without having to write separate converters between each pair of formats. New Pepper mapping modules can be written in Java, Python, XSLT or QVT to convert further formats to &lt;tiger2/&gt; (in our case we have opted for Java mappers, which are more efficient than e.g. XSLT).

With a growing pluriverse of formats, the conversion between these formats becomes more and more important. On the one hand it is important to be backwards compatible and continue support for existing formats and tools that are no longer developed. On the other hand it is also important that a format like &lt;tiger2/&gt; be able to deal with further developments in the future. 4.1.2 The &lt;tiger2/&gt; meta-model and XML serialisation Figure 3 shows the meta-model of &lt;tiger2/&gt; in Ecore, a UML-near syntax, generated with the Eclipse IDE and EMF. The meta-model of &lt;tiger2/&gt; derives from the meta-model of SynAF described above and is therefore fully compatible with the SynAF standard.

The elements describing the syntactic structure derived from the SynAF meta-model are Graph , Edge , Terminal and Nonterminal . In most cases, these elements will form a tree or DAG, but a graph including cycles is possible as well. The model elements Terminal and Nonterminal derive from Node . Together with Edge both are derived from the abstract element AnnotatableElement and can therefore be annotated with an arbitrary number of annotations. The top element Corpus contains a list of Feature objects, which represent names of annotations and annotation values represented by FeatureValue .A Node or Edge object contains a list of Annotation objects, having Feature and FeatureValue objects. This mechanism is analogous to the annotation mechanism of TigerXML. Since adding element typing has been a major point of interest in the development of &lt;tiger2/&gt;, we enhanced this mechanism by adding the attributes Node.type and Edge.type . To exemplify the power of the typing mechanism, we will consider the representation of dependency annotations, not originally supported in TigerXML, and the addition of a special class of nodes for compound items below. Figure 4 depicts a multilayer annotation for the syntactic fragment in (1): (1) put up new wallpaper The different annotation layers are shown using visualisations from the ANNIS corpus search and visualisation system. The XML representation of this fragment is given in Fig. 5 in the &lt;tiger2/&gt; format.

The fragment is contained within a Segment element serialised by &lt;s&gt; . 2 The segment can contain one or multiple &lt;graph&gt; s, the latter possibility being used for instance in the case of alternative parses. In the &lt;terminals&gt; area, we see references to five terminals linked stand-off from an external file called tokens.xml. It is also possible to use inline terminals using the backwards compatible @word attribute from TigerXML. The non-terminals encompass both default syntactic constituents, which have been given no special type and are annotated with @cat , and a special compound node using the @type attribute. 3 The compound can have different annotations, such as @pos (part-of-speech) and @lemma annotations. Similarly, the compound stem terminals lack the lemma and pos annotations of other terminals in the current fragment.

We also see how Edge objects are typed as  X  X onst X  (for constituent trees) or  X  X ep X  (for dependencies) much like Node objects can be typed as  X  X ompound X . The values of the @type attribute are not specified in &lt;tiger2/&gt; and can be freely chosen for a specific corpus, though they must be declared in the &lt;annotation&gt; block in the &lt;head&gt; of the document as shown in Fig. 6 , and bound to an element domain (terminals t , non-terminals nt ,or edge ).

Edges are defined using the &lt;feature&gt; element with the domain edge , analogous to the declaration of node features in TigerXML (the element &lt;edge&gt; is no longer used for the declaration). The edge type is specified as  X  X ep X  for dependencies. It then becomes possible to define an annotation named  X  X abel X , which applies to edges of the type  X  X ep X . Some values for the annotation  X  X abel X  can be specified in the declaration of values, e.g.  X  X bj X  for subject. This type of edges can then be used in the body of the document as in Fig. 5 above.

The definition of additional types of nodes works similarly, using the @type attribute. Figure 7 shows the declaration of the part-of-speech annotation for non-terminals ( domain =  X  X  nt  X  X ) of the type  X  X ompound X . Note that in this manner compounds can have different allowed pos tags than other types of nodes, such as terminals, though features with open-ended attribute values can be defined as well, as in TigerXML.

Terminal nodes may also be used to represent  X  X mpty X  elements, such as unexpressed subjects in languages such as Italian or Spanish. For example, in the Italian sentence Gliel X  X o gi X  dato  X (I) have already given it to him X , the subject pronoun  X  X  X  is not realized. At the same time, the clitic form Gliel X  , shortened from Glielo contains two grammatical functions: indirect object  X  X o him X  and direct object  X  X t X . This form is then written together with the auxiliary ho  X (I) have X , creating an orthographic unit. Figure 8 gives a possible representation of the dependencies in this sentence using &lt;tiger2/&gt;.

The  X  X mpty X  subject pronoun [pro] is added as a subject for the sentence (in this analysis all arguments are governed by the participle dato  X  X iven X , not the auxiliary). The complex pronoun gliel X  is split into two units for each grammatical function and then merged via a non-terminal of the type orthWord , which also gives the complete form of the word glielo . Finally, the further contraction with the auxiliary ho is represented by a non-terminal of the type orthContraction .
Which phenomena should be represented by what &lt;tiger2/&gt; objects and types (e.g. empty elements like traces, phrasal verbs like put up , subtokenisation phenomena) is a corpus design decision left up to individual data curators, though in either case, use of standardised semantics via ISOCat is recommended. For this purpose we provide the model attributes Feature.dcrReference and Feature-Value.dcrReference to carry a URI value pointing to an ISOCat entry. Their serialisation can also be seen in Fig. 7 , which specifies that the annotation named  X  X os X  refers to the ISOCat datapoint describing part-of-speech annotation, as well as a datapoint for a specific part-of-speech annotation for adjectives, both using the @dcr:datcat attribute.

A further possibility envisioned in &lt;tiger2/&gt; is the binding of other data resources, and especially of ISO standards, such as the Morpho-syntactic Annotation Framework MAF. Here we use the model attribute Terminal.source , which addresses a URI to another data source, for instance wordForm objects in the MAF meta-model which could then describe morphological phenomena such as compounding in an external file. In the XML representation, the terminal corresponding to wallpaper in Fig. 5 could then look as follows using the @corresp attribute: where the MAF document would also contain the relevant pos and lemma annotations, e.g. using MAF syntax:
For further examples using the typing mechanism, MAF integration and an exhaustive comparison of TigerXML and &lt;tiger2/&gt;, the interested reader is referred to the current documentation available on the &lt;tiger2/&gt; website: http://korpling.german.hu-berlin.de/tiger2/ . 4.2 A case in point: Tu  X  Ba-D/Z in &lt;tiger2/&gt; As a first application of the concepts described above to a real use-case, we have converted the Tu  X  Ba-D/Z Treebank (Telljohann et al. 2004 , 2009 ) to &lt;tiger2/&gt;. The original treebank was coded in TigerXML and contained two types of annotated nodes: syntactic phrase categories and topological fields (used in German e.g. to distinguish pre-and post-verbal domains in main clauses and positions after the complementiser in subordinate clauses). Though these types of annotation are unrelated, the constraints of the original TigerXML format forced a nesting of syntactic categories within topological ones and vice versa, as illustrated in Fig. 9 for the following sentence: (2)  X  X  X s gab Teilnehmer, die Umsatzzahlen gelernt haben. X  X 
For example, the nominal phrase Teilnehmer (NX) is embedded within the middle field (MF), the domain after the main clause finite verb. It is difficult to search for the direct object of the sentence (the edge above NX with the label OA for  X  X bject, accusative X ), since corpus users cannot know if the object will be realised in the middle field MF or e.g. in the preverbal field (or Vorfeld, VF).
With the addition of coreference annotation to the treebank in version 5, the corpus now also contains multiple types of edges: syntactic dominance edges and various types of coreference edges, such as anaphoric binding between Teilnehmer  X  X articipants X  and the relative pronoun die  X  X ho X . These challenges make the corpus an ideal use-case for separating types of nodes and edges to make them explicitly queriable (see Krause et al. 2011 for more details). The result of the separation, which can easily be expressed in &lt;tiger2/&gt; is shown in Fig. 10 .

It is now easy to find the direct object of the sentence regardless of topological fields, and likewise to query topological fields independently of the syntactic phrases which encompass them. It is also possible to include the coreference edge missing in the TigerXML version. Finally, for backwards compatibility it is even possible to represent a third tree with all nodes from the original structure using a third, hybrid node type to retain the original tree representation in parallel to the other two trees, if one so wishes. Since the expressivity of the format is graph-like (more specifically, the API supports an unbounded set of directed acyclic graphs), XML code for the graph in Fig. 10 is given in Fig. 11 .
 5 Conclusion In the previous sections we have presented &lt;tiger2/&gt;, a new XML format and meta-model for syntactic annotation serialising the data-model defined by SynAF (ISO 24615:2010). By further developing a widely accepted existing XML format, our approach has been to change as little as possible and as much as necessary to remain as close as possible to the already disseminated best practices defined by TigerXML. &lt;tiger2/&gt; is capable of representing constituent and dependency structures, distinguishing an arbitrary number of types of edges and terminal or non-terminal nodes, which may carry different key-value annotations. This allows the format to express a variety of phenomena which have been partly discussed here, such as coreference, as well as many conceivable implementations not exemplified above, such as the use of empty or trace elements to represent transformational theories. Binding of external resources such as stand-off source tokens, morpho-syntactically annotated documents in MAF and external reference to the ISOCat Data Category Registry in the annotation declaration all allow further expressivity and interoperability for development with the SynAF data-model.

As a first major resource and test case in &lt;tiger2/&gt; we have briefly outlined the conversion of the multi-layer edition of the German Tu  X  Ba-D/Z treebank described already available for download from the &lt;tiger2/&gt; website ( http://korpling.german.hu-berlin.de/tiger2/ ), along with examples representing var-ious phenomena. Using a meta-model approach and the SaltNPepper converter framework (cf. Zipser and Romary 2010 ), we also offer Java-based converters for a variety of XML and non-XML formats to &lt;tiger2/&gt;. For the near future we are planning the public release of the Java API for &lt;tiger2/&gt; which will facilitate the conversion of further existing formats to &lt;tiger2/&gt; and allow programmatic manipulation of resources in the format.
 References ISO Standards/Drafts
 Abstract This paper introduces &lt;tiger2/&gt;, an XML format developed to serialise the object model defined by the ISO Syntactic Annotation Framework SynAF. Based on widespread best practices we adapt a popular XML format for syntactic annotation, TigerXML, with additional features to support a variety of syntactic phenomena including constituent and dependency structures, binding, and different node types such as compounds or empty elements. We also define interfaces to other formats and standards including the Morpho-syntactic Annotation Framework MAF and the ISOCat Data Category Registry. Finally a case study of the German Treebank TueBa-D/Z is presented, showcasing the handling of constituent struc-tures, topological fields and coreference annotation in tandem.
 Keywords syntactic annotation XML format corpus corpora Treebank Tiger XML 1 Introduction The provision of reliable syntactic annotation for written or spoken linguistic data represents an essential step for a variety of natural language processing tasks, as well as for the understanding of more content-related semantic or pragmatic linguistic phenomena. In order to maximise the usefulness of such annotations it is essential that standardised representations for the interchange of syntactic data be defined and widely used within the linguistic and computational linguistic community.

At present the situation appears to be particularly complex because of the variety of contexts and forms that syntactic information may take. Firstly, syntactic information may either be the result of an automatic parsing of textual data or may be manually generated as a component of an annotated corpus. Secondly, the organisation and actual complexity of syntactic information highly depends on both the application context and theoretical background of the project within which such data has been created. In the simplest cases, syntactic representations may boil down to the identification of structural chunks on the textual surface, which may lead for instance to the further identification of technical terms, named entities or conceptual relations (Maedche and Staab 2000 ) in large quantities of data. By contrast, the validation of specific theoretical frameworks requires in-depth syntactic represen-tations, often using a smaller sample of sentences, to account for the capacity of the corresponding theory to adequately represent some complex phenomena.

In between, comparatively large constituent treebanks [e.g. the Penn Treebank (Bies et al. 1995 ), TueBa-D/Z (Telljohann et al. 2004 , 2009 )] and dependency treebanks [e.g. the Prague Dependency Treebank (Hajic  X  et al. 2006 )] have been annotated with syntactic information following a more or less theory independent perspective, in order to offer a reference point for a variety of linguistic studies or for the development and testing of syntactic parsers. The complexity of the standardisation task arises from the need to uniformly represent data in a way that can do justice to all varieties of information from very disparate projects, retaining features from accepted best practices and without becoming unwieldy. Recent years have seen a wide range of standardisation initiatives which attempt to standardise models and formats of more or less particular subdomains in the linguistic area, such as MAF for morpho-syntactic information (ISO/ DIS 24611; see also Romary and Witt 2012 ) or more generally LAF, the Linguistic Annotation Framework (ISO/DIS 24612; see Romary and Ide 2004 ; Ide and Suderman 2014 ), as well as more general efforts within the Text Encoding Initiative (TEI, see Burnard and Bauman 2008 ) and generalised XML formats such as GrAF (Ide and Suderman 2007 ). For syntax, the syntactic annotation framework SynAF (ISO 24615, see Bosch et al. 2012 ) is the ISO standard defining a general data-model for syntactic objects and basic inventories with which syntactically annotated resources can be constructed. The goal of the present article is to introduce an XML serialisation based on TigerXML (Mengel and Lezius 2000 ) for concrete realisations of the SynAF data-model which follows accepted best practices in the treebanking community, is adequately powerful for its needs and avoids unnecessary complications. 2 Models and standards for language resources As alluded to in the introduction, the &lt;tiger2/&gt; initiative is part of a wider endeavor to provide the linguistic resource domain with a complete portfolio of standards facilitating the interchange of linguistic data or the interconnection of language processing tools. In the last 25 years, such initiatives have mainly taken place within the TEI community, with the delivery and maintenance of the TEI guidelines, but also within the International Organization for Standardization (ISO), where its technical committee TC 37/SC 4 has already published several essential standards, with currently even more on its work plan. In the following paragraphs we will try to provide a quick overview of these initiatives with the perspective of better understanding the relationship between concrete formats and the underlying data-models.

The reference example we may begin with is the ISO standard 24610-1 (see Lee et al. 2004 ) for the XML representation of feature structures issued in 2006. This work, the first published by ISO committee TC 37/SC 4, resulted from the conjunction of two favorable factors. On the one hand, the theoretical linguistics domain and in particular several syntactic theories had long since identified the formal background for modeling typed feature structures (cf. Pollard and Sag 1994 ). On the other hand, feature structures have been widely used for even very simple annotation tasks in linguistics (e.g. in phonetics) and this lead the TEI to design an early SGML (then XML) format for their representation (Langendoen and Simons 1995 ). As a consequence, it was a straightforward move that lead to the resulting ISO standard, which took up most of the TEI components and expanded it to be fully compliant with the general model of typed feature structures.

In the case of ISO 24613 (LMF, see Romary 2013a ), published in 2008, there was at that time no real generic model for the representation of lexical data, but a variety of more or less stabilized formats [see for instance Ide and Ve  X  ronis ( 1995 ) and Romary ( 2013a ) for an overview]. The standard thus focused on providing a flexible meta-model (with extensions) encompassing a variety of lexical forms (morpho-syntactic, syntactic-lexical, machine readable dictionaries, etc.) and paying reduced attention to defining a comprehensive serialization for it. Work thus remains to be done in this respect and as shown in (Romary 2013b ) it may be an opportunity to achieve a better convergence with large coverage vocabularies such as the TEI guidelines.

Finally, it can often be argued that the variety of models and formats that are related to the representation of language resources may be a hindrance to a real interoperability of linguistic data. Whereas this is typically a topic covered by GrAF for integrated language resources or PAULA (Dipper 2005 ) for the back-office representation within a corpus management environment such as ANNIS (Zeldes et al. 2009 ), we consider the main issue to be preserving the semantics of the underlying models as well as those of elementary descriptors that are combined with them, in the spirit of ISO 12620 (Data Category Registry/ISOCat, see below). In this respect, well defined language resources, which follow the ISO principles applied in this paper, can be disseminated further according to the Linked Open Data principles (see http://linkeddata.org/ and the Linguistic Linked Open Data initiative: http://linguistics.okfn.org/resources/llod/ ).

In this landscape, we will see that the definition of &lt;Tiger2/&gt; is indeed very close to our first example with feature structures in that an existing model (SynAF), combined with an already well recognized serialization (TigerXML) is a good candidate for a reference standard in its domain.
 3 The ISO SynAF initiative The SynAF standard was initiated within ISO committee TC 37/SC 4 in 2006 with the support of the European project Lirics. 1 Committee TC 37/SC 4 was put together in 2002 within ISO to cover the necessary standardisation activities in the domain of language resources, and in particular to provide, step by step, a comprehensive portfolio of standards improving interoperability across Language Technology applications. In this respect, SynAF was conceived as compliant with the main design principles within ISO/TC 37/SC 4 right from the outset, i.e.:  X  The necessity to rely on a generic modelling scheme to account for the variety of  X  To be articulated with the ISO Data Category Registry (DCR), as described in  X  To be compatible with further standards development within ISO/TC 37/SC 4, in
From a modelling point of view, ISO standards and initiatives in the domain of language resources rely on a modelling framework (cf. Romary 2001 ) that construes the description of a linguistic representation (annotation scheme or lexical structure) as the combination of two main components:  X  A meta -model that informs the general characteristics of the corresponding  X  Data categories, which represent elementary linguistic properties (or values
A specific combination of a meta-model with a data category selection provides a annotation or linguistic database.

The core part of the SynAF meta-model is based on the single notion of syntactic node  X  X erived from the generic annotation node in LAF (Ide and Romary 2003 ). A syntactic node represents the elementary unit of syntactic information. Syntactic nodes are in turn connected with one another by means of syntactic edges , thus forming a syntactic graph . Both syntactic nodes and syntactic edges can be further constrained by annotations, i.e. elementary feature-value pairs expressing properties attached to them. As in all ISO compliant linguistic models, both attribute names and values of annotations should be defined in relation to standardised data categories in ISOCat or at least by providing an ISO 12620 compliant specification recorded in ISOCat. Although the present article is not concerned with particular values, we also integrate a mechanism for referencing ISOCat entries as part of the XML serialization of SynAF. To provide a better account of the various forms of syntactic annotation, the SynAF meta-model further refines the notion of syntactic node by providing two more specific classes, namely terminal and non -terminal nodes . Non-terminal nodes account for the abstract syntactic structures that have no direct anchoring on the surface of the language data to be annotated. These usually serve to represent syntactic constituents such as nominal and verbal phrases. Terminal nodes, on the contrary, are the places of articulation between syntactic structures and the linguistic data. Terminal nodes too can form independent graphs without non-terminal nodes, for example in the case of dependency trees or some forms of coreference annotation. Terminal nodes are also understood as instances of the word form class in ISO MAF, which can flexibly represent a variety of surface forms analysed as having the status of a word unit (including blends, acronyms, compounds, truncated forms and much more). This allows one to deploy various implementation strategies of MAF and SynAF depending on available data or theoretical framework (see below on MAF integration with SynAF in &lt;tiger2/&gt;). In the following paragraphs, we outline several such possible strategies.

The meta-model in Fig. 1 shows syntactic types in the bottom box, with elements for terminal and non-terminal nodes (T_Node and NT_Node), which are instances of the type SyntacticNode. Objects of these types are connected by syntactic edges (objects of the type SyntacticEdge), both of which are annotatable with annotations possibly connected to the DCR. The resulting graph can be connected to external models such as morpho-syntactic annotations through links between terminal objects and external objects as shown above. With this general architecture in mind, the exact expression of the model elements above in the more specifically articulated model of &lt;tiger2/&gt; is laid out below. 4 Serialising SynAF Rather than further increase the diversity of already existing formats, we decided to serialise the SynAF meta-model by adapting an existing popular format for syntax annotation and changing only as much as required and as little as necessary. The choice of TigerXML as a basis for the serialisation of SynAF was primarily motivated by its reception in a wide community of computational and corpus linguists, its readability and its flexibility, as in the ability to define custom node and edge annotations in its declaration block, a mechanism we will extend below. 4.1 Extending the TigerXML data-model While TigerXML has been very successful as a linguistic theory-neutral, versatile format for constituent-based annotations, its expressive power is limited by design decisions made in the 1990s in order to meet the needs of specific corpus annotation schemes, and some of its general features are now out-of-date (e.g. use of the deprecated @idref attribute and the lack of modern @xml:id attributes and XPointers). The possibility of typing nodes in Tiger XML was, similarly to SynAF, limited to two types, called non-terminal and terminal nodes. The mechanism of typing edges was also restricted to two types: primary and secondary dominance edges, whose labels can be freely specified in @label . This restricts the power of the TigerXML format to the annotation of only a subset of the syntactic phenomena which are representable with just one type of terminal or non-terminal node and only two types of edges; as we shall see below, these may not suffice for a variety of purposes, and there is no reason not to extend the inventory of types to an arbitrary size to meet users X  needs. Further deficits which should be addressed from the contemporary perspective involve the ability to link and reference resources outside the syntactic annotation graph proper, including separately stored stand-off source text (for example to preserve whitespace, which the TigerXML tokenisation cannot represent), referencing external standards for annotation schemes using state-of-the-art repositories such as the ISOCat Data Category Registry (ISO 12620), and interoperable binding of annotation layers from other standards, such as the Morpho-syntactic Annotation Framework MAF for the annotation of morphological phenomena (ISO/DIS 24611). 4.1.1 A meta-model approach As with SynAF, &lt;tiger2/&gt; follows the design principles mentioned in Sect. 2 by implementing an explicit object model for its representational elements. Our approach is therefore not limited to providing a new XML-based format for syntactic data as described below, but rather also provides a meta-model following the model-based approach (see MDA, Miller and Mukerji 2003 ). Building on the Eclipse Modeling Framework (Steinberg et al. 2009 ). We have used EMF in combination with the Eclipse IDE for this purpose, because they are open source, available across platforms and have good support for generating Java code. EMF also distinguishes a model layer and a persistencing layer. This distinction allows us to bind several formats to the same meta-model. More specifically we created a mapping between the TigerXML format and &lt;tiger2/&gt; as well as the &lt;tiger2/&gt; meta-model. Thanks to this mechanism, it is possible to convert data from the TigerXML format to &lt;tiger2/&gt; and vice versa via a Java API. After importing data from the persistence layer into the model layer, the API allows us to programmat-ically manipulate, transform and merge data from multiple sources. This API can be used as a basis for processing SynAF data and as a library within other tools. The benefit of using such an API is that the programmer does not have to deal with the persistencing layer anymore, but just works with an abstraction above the concrete data level. Even if the underlying data format changes, for instance when serializing a &lt;tiger2/&gt; model in JSON instead of XML, programmers do not need to concern themselves with differences between formats.

In the last few years, we have seen a trend to not only observe linguistic phenomena on isolated levels of annotation, but also to bring annotation levels together in new multi-layer corpora. Therefore new tools and formats, which are able to deal with multi-layer data have gained prominence. In many cases users may wish to extend existing resources from various tools and formats with syntactic annotations in &lt;tiger2/&gt;. This means that users have to recreate their existing corpus in parts using a variety of serializations. Imagine a corpus, which already contains a tokenization and morphosyntactic layers (like lemma and POS annotations) next to the primary data. Such pre-processed data can also be a basis for a new syntactic annotation layer. Therefore the re-tokenization and re-annotation of data could become a nuisance and is in any case error prone. Because of this, the conversion of reusable data becomes an important issue. But, when establishing a new format the conversion of existing formats into a new one such as &lt;tiger2/&gt;, and vice versa, is less realistic the larger the set of already existing formats is. Though we have already implemented a conversion between the TigerXML format and the new variety of formats is desirable. We therefore extend the converter framework Pepper (Zipser and Romary 2010 ). Pepper is a pluggable framework basing on OSGi (see: www.osgi.org/ ) used to convert data between a variety of linguistic formats. The Pepper framework uses the meta-model Salt [see Zipser ( 2009 ) for details] as an intermediate representation of any supported linguistic format. Mapping data into another format via a common intermediate model allows us to reduce the number of mappings between all possible pairs of n formats from n 2 -n to 2n mappings. Like GraF, Salt is based on a graph model, allowing a very generic treatment of linguistic data. In contrast to GrAF, Salt acts on the model layer in memory and not as a persistent XML format.

The aim of Pepper is to provide an interface for programmers to create mappings between data in any linguistic format and Salt. As mentioned above, the extensibility of Pepper allows us to create a mapping between Salt and our &lt;tiger2/&gt; meta-model and also to plug that mapping into the framework as a Pepper module. The mapping consists of two modules, one to map Salt data to &lt;tiger2/&gt; data and one for the other way around. Figure 2 gives an overview of the architecture of Pepper and its pluggable nature. To implement the mapping, we used the previously described &lt;tiger2/&gt; Java API. The pepper module specifies a programmatic mapping between two meta-models, also written in Java. Since Salt is very generic and defines a set of nodes, edges, labels and layers adapted to generalized linguistic meanings, it is not fixed to syntactic annotations only and can represent morphology, coreference, information structure and many other phenom-ena. This is turn allows us to convert a wide variety of existing resources in different formats to &lt;tiger2/&gt;, including GrAF, as well as to export &lt;tiger2/&gt; projects without having to write separate converters between each pair of formats. New Pepper mapping modules can be written in Java, Python, XSLT or QVT to convert further formats to &lt;tiger2/&gt; (in our case we have opted for Java mappers, which are more efficient than e.g. XSLT).

With a growing pluriverse of formats, the conversion between these formats becomes more and more important. On the one hand it is important to be backwards compatible and continue support for existing formats and tools that are no longer developed. On the other hand it is also important that a format like &lt;tiger2/&gt; be able to deal with further developments in the future. 4.1.2 The &lt;tiger2/&gt; meta-model and XML serialisation Figure 3 shows the meta-model of &lt;tiger2/&gt; in Ecore, a UML-near syntax, generated with the Eclipse IDE and EMF. The meta-model of &lt;tiger2/&gt; derives from the meta-model of SynAF described above and is therefore fully compatible with the SynAF standard.

The elements describing the syntactic structure derived from the SynAF meta-model are Graph , Edge , Terminal and Nonterminal . In most cases, these elements will form a tree or DAG, but a graph including cycles is possible as well. The model elements Terminal and Nonterminal derive from Node . Together with Edge both are derived from the abstract element AnnotatableElement and can therefore be annotated with an arbitrary number of annotations. The top element Corpus contains a list of Feature objects, which represent names of annotations and annotation values represented by FeatureValue .A Node or Edge object contains a list of Annotation objects, having Feature and FeatureValue objects. This mechanism is analogous to the annotation mechanism of TigerXML. Since adding element typing has been a major point of interest in the development of &lt;tiger2/&gt;, we enhanced this mechanism by adding the attributes Node.type and Edge.type . To exemplify the power of the typing mechanism, we will consider the representation of dependency annotations, not originally supported in TigerXML, and the addition of a special class of nodes for compound items below. Figure 4 depicts a multilayer annotation for the syntactic fragment in (1): (1) put up new wallpaper The different annotation layers are shown using visualisations from the ANNIS corpus search and visualisation system. The XML representation of this fragment is given in Fig. 5 in the &lt;tiger2/&gt; format.

The fragment is contained within a Segment element serialised by &lt;s&gt; . 2 The segment can contain one or multiple &lt;graph&gt; s, the latter possibility being used for instance in the case of alternative parses. In the &lt;terminals&gt; area, we see references to five terminals linked stand-off from an external file called tokens.xml. It is also possible to use inline terminals using the backwards compatible @word attribute from TigerXML. The non-terminals encompass both default syntactic constituents, which have been given no special type and are annotated with @cat , and a special compound node using the @type attribute. 3 The compound can have different annotations, such as @pos (part-of-speech) and @lemma annotations. Similarly, the compound stem terminals lack the lemma and pos annotations of other terminals in the current fragment.

We also see how Edge objects are typed as  X  X onst X  (for constituent trees) or  X  X ep X  (for dependencies) much like Node objects can be typed as  X  X ompound X . The values of the @type attribute are not specified in &lt;tiger2/&gt; and can be freely chosen for a specific corpus, though they must be declared in the &lt;annotation&gt; block in the &lt;head&gt; of the document as shown in Fig. 6 , and bound to an element domain (terminals t , non-terminals nt ,or edge ).

Edges are defined using the &lt;feature&gt; element with the domain edge , analogous to the declaration of node features in TigerXML (the element &lt;edge&gt; is no longer used for the declaration). The edge type is specified as  X  X ep X  for dependencies. It then becomes possible to define an annotation named  X  X abel X , which applies to edges of the type  X  X ep X . Some values for the annotation  X  X abel X  can be specified in the declaration of values, e.g.  X  X bj X  for subject. This type of edges can then be used in the body of the document as in Fig. 5 above.

The definition of additional types of nodes works similarly, using the @type attribute. Figure 7 shows the declaration of the part-of-speech annotation for non-terminals ( domain =  X  X  nt  X  X ) of the type  X  X ompound X . Note that in this manner compounds can have different allowed pos tags than other types of nodes, such as terminals, though features with open-ended attribute values can be defined as well, as in TigerXML.

Terminal nodes may also be used to represent  X  X mpty X  elements, such as unexpressed subjects in languages such as Italian or Spanish. For example, in the Italian sentence Gliel X  X o gi X  dato  X (I) have already given it to him X , the subject pronoun  X  X  X  is not realized. At the same time, the clitic form Gliel X  , shortened from Glielo contains two grammatical functions: indirect object  X  X o him X  and direct object  X  X t X . This form is then written together with the auxiliary ho  X (I) have X , creating an orthographic unit. Figure 8 gives a possible representation of the dependencies in this sentence using &lt;tiger2/&gt;.

The  X  X mpty X  subject pronoun [pro] is added as a subject for the sentence (in this analysis all arguments are governed by the participle dato  X  X iven X , not the auxiliary). The complex pronoun gliel X  is split into two units for each grammatical function and then merged via a non-terminal of the type orthWord , which also gives the complete form of the word glielo . Finally, the further contraction with the auxiliary ho is represented by a non-terminal of the type orthContraction .
Which phenomena should be represented by what &lt;tiger2/&gt; objects and types (e.g. empty elements like traces, phrasal verbs like put up , subtokenisation phenomena) is a corpus design decision left up to individual data curators, though in either case, use of standardised semantics via ISOCat is recommended. For this purpose we provide the model attributes Feature.dcrReference and Feature-Value.dcrReference to carry a URI value pointing to an ISOCat entry. Their serialisation can also be seen in Fig. 7 , which specifies that the annotation named  X  X os X  refers to the ISOCat datapoint describing part-of-speech annotation, as well as a datapoint for a specific part-of-speech annotation for adjectives, both using the @dcr:datcat attribute.

A further possibility envisioned in &lt;tiger2/&gt; is the binding of other data resources, and especially of ISO standards, such as the Morpho-syntactic Annotation Framework MAF. Here we use the model attribute Terminal.source , which addresses a URI to another data source, for instance wordForm objects in the MAF meta-model which could then describe morphological phenomena such as compounding in an external file. In the XML representation, the terminal corresponding to wallpaper in Fig. 5 could then look as follows using the @corresp attribute: where the MAF document would also contain the relevant pos and lemma annotations, e.g. using MAF syntax:
For further examples using the typing mechanism, MAF integration and an exhaustive comparison of TigerXML and &lt;tiger2/&gt;, the interested reader is referred to the current documentation available on the &lt;tiger2/&gt; website: http://korpling.german.hu-berlin.de/tiger2/ . 4.2 A case in point: Tu  X  Ba-D/Z in &lt;tiger2/&gt; As a first application of the concepts described above to a real use-case, we have converted the Tu  X  Ba-D/Z Treebank (Telljohann et al. 2004 , 2009 ) to &lt;tiger2/&gt;. The original treebank was coded in TigerXML and contained two types of annotated nodes: syntactic phrase categories and topological fields (used in German e.g. to distinguish pre-and post-verbal domains in main clauses and positions after the complementiser in subordinate clauses). Though these types of annotation are unrelated, the constraints of the original TigerXML format forced a nesting of syntactic categories within topological ones and vice versa, as illustrated in Fig. 9 for the following sentence: (2)  X  X  X s gab Teilnehmer, die Umsatzzahlen gelernt haben. X  X 
For example, the nominal phrase Teilnehmer (NX) is embedded within the middle field (MF), the domain after the main clause finite verb. It is difficult to search for the direct object of the sentence (the edge above NX with the label OA for  X  X bject, accusative X ), since corpus users cannot know if the object will be realised in the middle field MF or e.g. in the preverbal field (or Vorfeld, VF).
With the addition of coreference annotation to the treebank in version 5, the corpus now also contains multiple types of edges: syntactic dominance edges and various types of coreference edges, such as anaphoric binding between Teilnehmer  X  X articipants X  and the relative pronoun die  X  X ho X . These challenges make the corpus an ideal use-case for separating types of nodes and edges to make them explicitly queriable (see Krause et al. 2011 for more details). The result of the separation, which can easily be expressed in &lt;tiger2/&gt; is shown in Fig. 10 .

It is now easy to find the direct object of the sentence regardless of topological fields, and likewise to query topological fields independently of the syntactic phrases which encompass them. It is also possible to include the coreference edge missing in the TigerXML version. Finally, for backwards compatibility it is even possible to represent a third tree with all nodes from the original structure using a third, hybrid node type to retain the original tree representation in parallel to the other two trees, if one so wishes. Since the expressivity of the format is graph-like (more specifically, the API supports an unbounded set of directed acyclic graphs), XML code for the graph in Fig. 10 is given in Fig. 11 .
 5 Conclusion In the previous sections we have presented &lt;tiger2/&gt;, a new XML format and meta-model for syntactic annotation serialising the data-model defined by SynAF (ISO 24615:2010). By further developing a widely accepted existing XML format, our approach has been to change as little as possible and as much as necessary to remain as close as possible to the already disseminated best practices defined by TigerXML. &lt;tiger2/&gt; is capable of representing constituent and dependency structures, distinguishing an arbitrary number of types of edges and terminal or non-terminal nodes, which may carry different key-value annotations. This allows the format to express a variety of phenomena which have been partly discussed here, such as coreference, as well as many conceivable implementations not exemplified above, such as the use of empty or trace elements to represent transformational theories. Binding of external resources such as stand-off source tokens, morpho-syntactically annotated documents in MAF and external reference to the ISOCat Data Category Registry in the annotation declaration all allow further expressivity and interoperability for development with the SynAF data-model.

As a first major resource and test case in &lt;tiger2/&gt; we have briefly outlined the conversion of the multi-layer edition of the German Tu  X  Ba-D/Z treebank described already available for download from the &lt;tiger2/&gt; website ( http://korpling.german.hu-berlin.de/tiger2/ ), along with examples representing var-ious phenomena. Using a meta-model approach and the SaltNPepper converter framework (cf. Zipser and Romary 2010 ), we also offer Java-based converters for a variety of XML and non-XML formats to &lt;tiger2/&gt;. For the near future we are planning the public release of the Java API for &lt;tiger2/&gt; which will facilitate the conversion of further existing formats to &lt;tiger2/&gt; and allow programmatic manipulation of resources in the format.
 References ISO Standards/Drafts
