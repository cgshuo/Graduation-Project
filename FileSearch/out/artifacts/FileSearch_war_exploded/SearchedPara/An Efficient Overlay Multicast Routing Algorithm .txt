 Multicast is a basic communication service for many new network applications, like the real-time multimedia transmission. When it comes to practical issues, however, full deployment of IP multicast [1] has long been postponed in the Internet for both technical and economic reasons [2]. Researchers wondered whether the network layer is appropriate for implementations of multicast functionality; therefore, overlay multicast services on hosts instead of core routers. The advantage of doing so is that the multicast services are easier to deploy, since there is no need to change the existing IP network infrastructure. From the architectural point of view, the overlay multicast and proxy-based architecture (like Overcast [6 ] and Scattercast [7]). Both architectures face the same-natured problems when talking about overlay multicast routing. The architecture, taking the common features of both architectures into consideration. multicast routing algorithms for real-time multimedia applications. In centralized algorithms [4, 8], a server, which is supposed to know the path latency between any nodes in an overlay network, constructs multicast tree according to an objective function. However, these algorithms do not consider the dynamic feature of multicast members, and ignore the problems of algorithm complexity and the single-point failure. extensibility and dynamic flexibility. These algorithms can be classified into mesh-first [7, 9] and tree-first [5, 6] strategies. Studies show that none of the protocols above have considered the strict delay constraint in real-time multimedia applications, and how the multicast routing performance is affected by the dynamic end hosts also lacks sufficient study [10]. We introduce a novel distributed overlay multicast routing algorithm named Distributed Tree Algorithm (DTA). The algorithm adopts tree-first strategy in order to enhance multicast routing performance effectively and save system maintenance cost. By adjusting appropriate heuristic parameters, DTA can improve multicast routing performance and reduce node rejection rate considerably. The overlay multicast network is a logical network built on top of the Internet unicast infrastructure. It can be depicted as a complete directed graph, G = (V, E) , where V is the set of vertices and E = V  X  V is the set of edges. Each vertex in V represents a host. The directed edge from node i to node j in G represents a logical channel corresponding to a unicast path from host i to host j in the physical topology. The data delivery path will be a directed spanning tree T of G rooted at the source host, with the edges directed away from the root. Definition 1 d max (v)  X  N: The out-degree constraint of host v in the overlay tree. Definition 2 l(u, v)  X  R + : The unicast latency from host u to host v . all the unicast latencies along the path from r to v in the spanning tree T . 
We consider two optimization objectives: one seeks to minimize the maximum latency. Then the two objectives are formulated as follows: Problem 1 Minimum Maximum-Latency Degree-Bounded Directed Spanning Tree Problem (MMLDB): Given a complete directed graph G = (V, E) , a degree constraint d directed spanning tree T of G rooted at host r that minimizes the maximum delay(r, v) , and the degree constraint is satisfied at each node that d used (v)  X  d max (v) . Problem 2 Residual-Balanced Degree and Latency-Bounded Directed Spanning Tree Problem (RBDLB): Given a complete directed graph G = (V, E) , a degree bound d max (v) of the session that max v X  X  delay(r, v)  X  L . 
Both MMLDB and RBDLB problems are NP-complete [8]. Our design of DTA can make trade-off between minimizing end-to-end delay and reducing local resource consumption. Resultingly, both of the desired objectives are met. Children(v), parent(v), l(parent(v), v)} . Children(v) denotes the set of v  X  X  children and itself, which can be acquired by an end-to-end measuring tool. 3.1 Creating a Multicast Group Each multicast group has a Rendezvous Point (RP) from which new members can learn multicast group is as follows: 1) The host that sends out data acts as the creator, as well CREATEREQUEST message. 2) When receiving the CREATEREQUEST message, RP adds the QoS parameters to its group list, then sends out a CREATEACK message to the corresponding requesting host. 3.2 Joining a Multicast Group A newcomer v sends to RP a QUERYREQUEST message, containing the multicast group ID. On receiving the request message, RP checks its root list for the specific item, say r, of that group, then sends QUERYACK message containing r  X  X  IP address and the according to function (1): Local Optimal Parent Selection (L OPS) Function. If the local repeats this process until a local optimal parent, u for instance, perseveres in its role as the tentative parent. Then v makes u its parent by sending JOINREQUEST message to local optimal grandparent from p t  X  X  children and sets this grandparent as a new tentative parent according to function (2): Local Optimal Grandparent Selection (LOGS) Function, then repeats the joining process.  X  delay(r, n) + l(n, v)  X  L, n  X  { p t }  X  Children(p t )} . with them with either LOGS-Function or LOPS-Function mentioned above. The two functions are given as follows: Local Optimal Parent Selection (LOPS) Function: 
Pfunc(m) reflects the efficiency in selecting a node from PP(p t ) as candidate for the newcomer X  X  parent. It can be expressed as follows: {g}  X  Children(g) = {g, i, j, k} . v is now enquiring degree and latencies of all members in PP(p t ) to calculate the values of the corresponding Pfunc() . how close node m is to node v. A smaller value denotes a shorter distance from a node in PP(p t ) to v . have been used. Weight  X  i s a heuristic factor. We can trade off between minimizing end-to-end delay and reducing local resour ce consumption by adjusting the value of  X  between [0, 1]. 
Local Optimal Grandparent Selection (LOGS) Function: follows: parent g , and q itself has a relatively larger number of children. As a result, the tree X  X  radius can be decreased and the node rejection rate will fall.  X  t(q) is a balancing factor to prevent one single node from being selected as the local optimal grandparent all the LOGS-Function to evaluate i , j , k in Children(g) in order to decide which one will be the new tentative parent. 
To summarize, a newcomer tries to find a  X  X ood X  parent by searching a certain part detailed algorithm is shown as follows: Joining Algorithm v finds root r by querying RP, let p t = r ; if Gfunc(q) &gt; Gfunc(p t  X ) if Gfunc(p t  X ) == 0 while true if Pfunc(m) &lt; Pfunc(p t  X ) if p t  X  == p t 3.3 States Maintaining and Leaving a Multicast Group Status in DTA is refreshed by periodic message exchanges between neighbors. Every sending KEEPALIVE message back. Each memb er calculates the round-trip time (rtt) longer meets the latency constraint, then the joining algorithm is triggered. 
When a member leaves a group, it sends LEAVEREQUEST message to its parent and children, from whom it receives the LEAVEACK messages. Its parent simply member must find new parents. A child looks for a new parent with the help of joining CANCELGROUP message to them. RP then deletes the group information of this root from its group list. Other members in the tree pass the message on to their neighbors then all of them leave the group. 4.1 Performance Metrics and Simulation Setup We have done some simulations to evaluate the performance of DTA, concerning the node rejection rate defined as follows: nodes rejected by DTA and N denotes total amount of nodes. 
Our simulations are based on a network that consists of 1000 routers. The network has a random flat topology generated by using the Waxman model [11]. The communication delay which is designated between [1ms, 50ms] between neighbor routers, is directly proportional to their ge ometric distance. Some additional nodes are generated as regular hosts and are randomly attached to these routers. The node degree is uniformly distributed between 4 and 8. Each node experiences 100 rounds of simulation and the average value is recorded as experimental result. 4.2 Simulation Results and Analyses Fig. 2 and Fig. 3 show the node rejection rate versus the session delay constraint. There are 50 regular hosts which want to join the multicast group one by one in Fig. 2 and 200 among 0.0, 0.3, 0.7 and 1.0 with each different value of  X  . Different curve in a chart denotes a different value combination of  X  and  X  in the form of (  X  ,  X  ). From all these increases. Furthermore, different combinations of (  X  ,  X  ) also have an impact on system performance. Firstly, DTA approximates to minimizing local resource consumption strategy (RBDLB) when  X  is closer to 1, whereas it approximates to minimizing end-to-end delay strategy (MMLDB) when  X  approaches 0. The node rejection rate can not be decreased remarkably if only one of the two strategies is considered, i.e., only  X   X  X  value equals to 0 or 1. Therefore, an appropriate value must be set to trade off between the two strategies. Secondly, if  X  has a larger value, a newcomer is more likely to select some specific members as its local optim al grandparent, which could bring about overload in local area and the rejection rate will increase as a result; if  X  is smaller, a grandparents with a relatively equal probability, but some of the preferable ones may be ignored and the rejection rate could also incr ease as a result. From the six charts we can (0.3, 0.5). This result illustrates that our optimization strategy in DTA is much closer to end-to-end delay optimization strategy (  X  = 0.0 ). By comparing Fig. 2 and Fig. 3, it is clear that the optimization objectives are better achieved when the number of multicast group members is larger. Therefore, DTA is more suitable for large-scale overlay multicast applications. 
Fig. 4 shows the node rejection rate versus the multicast group size when  X  is set to 0.5. We can see that the combination of (0.3, 0.5) also brings about the best performance. If the session delay constraint is set to too low (the chart on the left) or too high (the chart on the right) a value, then the change in the value of  X  will have less impact on the performance. But when we set session delay constraint to 1400ms (the chart in the middle), a better choice of (  X  ,  X  ) will have a notable effect. We study tree-first overlay multicast routing algorithm and propose an efficient distributed routing algorithm named DTA. Our algorithm seeks to make trade-off between minimizing end-to-end delay and minimizing local resource consumption. Simulations show that the performance of DTA is quite a satisfaction with node degree improvement and discussion on the best value of (  X  ,  X  ) is left for the future. Acknowledgments. This research is supported by the Natural Science Foundation of China (Grant No. 90604003). 
