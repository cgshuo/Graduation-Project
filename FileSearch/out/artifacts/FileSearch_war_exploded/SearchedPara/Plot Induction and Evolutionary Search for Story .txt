 Computer story generation has met with fasci-nation since the early days of artificial intelli-gence. Indeed, over the years, several genera-tors have been developed capable of creating sto-ries that resemble human output. To name only a few, T ALE -S PIN (Meehan, 1977) generates sto-ries through problem solving, M INSTREL (Turner, 1992) relies on an episodic memory scheme, es-sentially a repository of previous hand-coded sto-ries, to solve the problems in the current story, and M AKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story gener-ation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting stories emerge as plans interact and cause failures and possible replanning.

The broader appeal of computational story gen-eration lies in its application potential. Examples include the entertainment industry and the devel-opment of tools that produce large numbers of plots automatically that might provide inspiration to professional screen writers (Agudo et al., 2004); rendering video games more interesting by allow-ing the plot to adapt dynamically to the players X  actions (Barros and Musse, 2007); and assisting teachers to create or personalize stories for their students (Riedl and Young, 2004).

A major stumbling block for the widespread use of computational story generators is their reliance on expensive, manually created resources. A typi-cal story generator will make use of a knowledge base for providing detailed domain-specific infor-mation about the characters and objects involved in the story and their relations. It will also have a story planner that specifies how these characters interact, what their goals are and how their ac-tions result in different story plots. Finally, a sen-tence planner (coupled with a surface realizer) will render an abstract story specification into natural language text. Traditionally, most of this knowl-edge is created by hand, and the effort must be re-peated for new domains, new characters and plot elements.

Fortunately, recent work in natural language processing has taken significant steps towards de-veloping algorithms that learn some of this knowl-edge automatically from natural language cor-pora. Chambers and Jurafsky (2009, 2008) pro-pose an unsupervised method for learning narra-tive schemas , chains of events whose arguments are filled with participant semantic roles defined over words. An example schema is { X arrest, X charge, X raid, X seize, X confiscate, X detain, X deport } , where X stands for the argument types { police, agent, authority, government } . Their ap-proach relies on the intuition that in a coherent text events that are about the same participants are likely to be part of the same story or narrative. Their model extracts narrative chains, essentially events that share argument slots and merges them into schemas. The latter could be used to construct or enrich the knowledge base of a story generator.
In McIntyre and Lapata (2009) we presented a story generator that leverages knowledge inherent in corpora without requiring extensive manual in-volvement. The generator operates over predicate-argument and predicate-predicate co-occurrence tuples gathered from training data. These are used to produce a large set of candidate stories which are subsequently ranked based on their interest-ingness and coherence. The approach is unusual in that it does not involve an explicit story plan-ning component. Stories are created stochastically by selecting entities and the events they are most frequently attested with.

In this work we develop a story generator that is also data-driven but crucially relies on a story planner for creating meaningful stories. Inspired by Chambers and Jurafsky (2009) we acquire story plots automatically by recording events, their par-ticipants, and their precedence relationships as at-tested in a training corpus. Entities give rise to different potential plots which in turn generate multiple stories. Contrary to our previous work (McIntyre and Lapata, 2009), we do not follow a generate-and-rank architecture. Instead, we search the space of possible stories using Genetic Algo-rithms (GAs) which we argue are advantageous in the story generation setting, as they can search large fitness landscapes while greatly reducing the risk of getting stuck in local optima. By virtue of exploring the search space more broadly, we are able to generate creative stories without an explicit interest scoring module.

In the remainder of this paper we give a brief overview of the system described in McIntyre and Lapata (2009) and discuss previous applications of GAs in natural language generation (Section 2). Next, we detail our approach, specifically how plots are created and used in conjunction with ge-netic search (Sections 3 and 4). Finally, we present our experimental results (Sections 6 and 7) and conclude the paper with discussion of future work. Our work builds on and extends the story genera-tor developed in McIntyre and Lapata (2009). The system creates simple children X  X  stories in an in-teractive context: the user supplies the topic of the story and its desired length (number of sentences). The generator creates a story following a pipeline architecture typical of natural language generation systems (Reiter and Dale, 2000) consisting of con-tent selection, sentence planning, and surface real-ization.

The content of a story is determined by consult-ing a data-driven knowledge base that records the entities (i.e., nouns) appearing in a corpus and the actions they perform. These are encoded as depen-dency relations (e.g., subj-verb , verb-obj ). In order to promote between-sentence coherence the gen-erator also make use of an action graph that con-tains action-role pairs and the likelihood of tran-sitioning from one to another. The sentence plan-ner aggregates together entities and their actions into a sentence using phrase structure rules. Fi-nally, surface realization is performed by interfac-ing RealPro (Lavoie and Rambow, 1997) with a language model. The system searches for the best story overall as well as the best sentences that can be generated from the knowledge base. Unlikely stories are pruned using beam search. In addition, stories are reranked using two scoring functions based on coherence and interest. These are learnt from training data, i.e., stories labeled with nu-meric values for interest and coherence.

Evolutionary search techniques have been pre-viously employed in natural language generation, especially in the context of document planning. Structuring a set of facts into a coherent text is ef-fectively a search problem that may lead to com-binatorial explosion for large domains. Mellish et al. (1998) (and subsequently Karamanis and Manurung 2002) advocate genetic algorithms as an alternative to exhaustively searching for the op-timal ordering of descriptions of museum arte-facts. Rather than requiring a global optimum to be found, the genetic algorithm selects an order (based on coherence) that is good enough for peo-ple to understand. Cheng and Mellish (2000) focus on the interaction of aggregation and text planning and use genetic algorithms to search for the best aggregated document that satisfies coherence con-straints.

The application of genetic algorithms to story generation is novel to our knowledge. Our work also departs from McIntyre and Lapata (2009) in two important ways. Firstly, our generator does not rely on a knowledge base of seemingly un-related entities and relations. Rather, we employ a document planner to create and structure a plot for a story. The planner is built automatically from a training corpus and creates plots dynamically depending on the protagonists of the story. Sec-ondly, our search procedure is simpler and more global; instead of searching for the best story twice (i.e., by first finding the n -best stories and then subsequently reranking them based on coherence and interest), our genetic algorithm explores the space of possible stories once. Following previous work (e.g., Shim and Kim 2002; McIntyre and Lapata 2009) we assume that the user supplies a sentence (e.g., the princess loves the prince ) from which the system creates a story. Each entity in this sentence (e.g., princess , prince ) is associated with its own narrative schema , a set of key events and actors co-occurring with it in the training corpus. Our nar-rative schemas differ slightly from Chambers and Jurafsky (2009). They acquire schematic represen-tations of situations akin to FrameNet (Fillmore et al., 2003): schemas consists of semantically similar predicates and the entities evoked by them. In our setting, every entity has its own schema, and predicates associated with it are ordered. Plots are generated by merging the entity-specific narrative schemas which subsequently serve as the input to the genetic algorithm. In the following we describe how the narrative schemas are extracted and plots merged, and then discuss our evolutionary search procedure.
 Entity-based Schema Extraction Before we can generate a plot for a story we must have an idea of the actions associated with the entities in the story, the order in which these actions are per-formed and also which other entities can partici-pate. This information is stored in a directed graph which we explain below. Our algorithm processes each document at a time, it operates over depen-dency structures and assumes that entity mentions have been resolved. In our experiments we used Rasp (Briscoe and Carroll, 2002), a broad cover-age dependency parser, and the OpenNLP 1 coref-erence resolution engine. 2 However, any depen-dency parser or coreference tool could serve our purpose. We also assume that the actions associ-ated with a given entity are ordered and that lin-ear order corresponds to temporal order. This is a gross simplification as it is well known that tem-poral relationships between events are not limited to precedence, they may overlap, occur simultane-ously, or be temporally unrelated. We could have obtained a more accurate ordering using a tempo-ral classifier (see Chambers and Jurafsky 2008), however we leave this to future work.

For each entity e in the corpus we build a di-rected graph G = ( V , E ) whose nodes V denote predicate argument relationships, and edges E rep-resent transitions from node V i to node V j . As an example of our schema construction process, consider a very small corpus consisting of the two documents shown in Figure 1. The schema for princess after processing the first document is given on the left hand side. Each node in this graph corresponds to an action attested with princess (we also record who performs it and where or how). Nodes are themselves dependency trees (see Fig-ure 4a), but are linearized in the figure for the sake of brevity. Edges in the graph indicate order-ing and are weighted using the mutual informa-tion metric proposed in Lin (1998) (the weights are omitted from the example). 3 The first sentence in the text gives rise to the first node in the graph, the second sentence to the second node, and so on. Note that the third sentence is not present in the graph as it is not about the princess .

When processing the second document, we sim-ply expand this graph. Before inserting a new node, we check if it can be merged with an al-ready existing one. Nodes are merged only if they have the same verb and similar arguments, with the focal entity (i.e., princess ) appearing in the same argument slot. In our example, the nodes  X  X rince marry princess in castle X  and  X  X rince marry princess in temple X  can be merged as they contain the same verb and number of similar ar-guments. The nodes  X  X rincess have influence X  and  X  X rincess have baby X  cannot be merged as influence and baby are semantically unrelated. We compute argument similarity using WordNet (Fellbaum, 1998) and the measure proposed by Wu and Palmer (1994) which is based on path length. We merge nodes with related arguments only if their similarity exceeds a threshold (deter-mined empirically).
The schema construction algorithm terminates when graphs like the ones shown in Figure 1 (right hand side) have been created for all entities in the corpus.
 Building a Story Plot Our generator takes an in-put sentence and uses it to instantiate several plots. We achieve this by merging the schemas associ-ated with the entities in the sentence into a plot graph. As an example, consider again the sentence the princess loves the prince which requires comb-ing the schemas representing prince and princess shown in Figures 2 and 1 (right hand side), re-spectively. Again, we look for nodes that can be merged based on the identity of the actions in-volved and the (WordNet) similarity of their ar-guments. However, we disallow the merging of nodes with focal entities appearing in the same ar-gument slot (e.g.,  X  X prince, princess] cries X ).
Once the plot graph is created, a depth first search starting from the node corresponding to the input sentence, finds all paths with length matching the desired story length (cycles are dis-allowed). Assuming we wish to generate a story consisting of three sentences, the graph in Figure 3 would create four plots. These are (princess love prince, prince marry princess in [castle, temple], princess have influence), (princess love prince, prince marry princess in [castle, temple], princess have baby), (princess love prince, prince marry princess in [castle, temple], prince rule country), and (princess love prince, prince ask king X  X  per-mission prince marry princess in [castle, temple]). Each of these plots represents two different stories one with castle and one with temple in it.
 Sentence Planning The sentence planner is in-terleaved with the story planner and influences the final structure of each sentence in the story. To avoid generating short sentences  X  note that nodes in the plot graph consist of a single ac-tion and would otherwise correspond to a sentence with a single clause  X  we combine pairs of nodes within the same graph by looking at intrasenten-tial verb-verb co-occurrences in the training cor-pus. For example, the nodes (prince have prob-lem, prince keep secret) could become the sen-tence the prince has a problem keeping a secret . We leave it up to the sentence planner to decide how the two actions should be combined. 4 The sentence planner will also insert adverbs and ad-jectives, using co-occurrence likelihoods acquired from the training corpus. It is essentially a phrase structure grammar compiled from the lexical re-sources made available by Korhonen and Briscoe (2006) and Grishman et al. (1994). The grammar rules act as templates for combining clauses and filling argument slots.
Figure 2: Narrative schema for the entity prince . The example shown in Figure 3 is a simplified ver-sion of a plot graph. The latter would normally contain hundreds of nodes and give rise to thou-sands of stories once lexical variables have been expanded. Searching the story space is a difficult optimization problem, that must satisfy several constraints: the story should be of a certain length, overall coherent, creative, display some form of event progression, and generally make sense. We argue that evolutionary search is appealing here, as it can find global optimal solutions in a more effi-cient way than traditional optimization methods.
In this study we employ genetic algorithms (GAs) a well-known search technique for finding approximate (or exact) solutions to optimization problems. The basic idea behind GAs is based on  X  X atural selection X  and the Darwinian princi-ple of the survival of the fittest (Mitchell, 1998). An initial population is randomly created contain-ing a predefined number of individuals (or solu-tions), each represented by a genetic string (e.g., a population of chromosomes). Each individual is evaluated according to an objective function (also called a fitness function). A number of individu-als are then chosen as parents from the population according to their fitness, and undergo crossover (also called recombination) and mutation in order to develop the new population. Offspring with bet-ter fitness are then inserted into the population, replacing the inferior individuals in the previous generation.

The algorithm thus identifies the individuals with the optimizing fitness values, and those with lower fitness will naturally get discarded from the population. This cycle is repeated for a given num-ber of generations, or stopped when the solution Figure 3: Plot graph for the input sentence the princess loves the prince . obtained is considered optimal. This process leads to the evolution of a population in which the in-dividuals are more and more suited to their envi-ronment, just as natural adaptation. We describe below how we developed a genetic algorithm for our story generation problem.
 Initial Population Rather than start with a ran-dom population, we seed the initial population with story plots generated from our plot graph. For an input sentence, we generate all possible plots. The latter are then randomly sampled until a population of the desired size is created. Contrary to McIntyre and Lapata (2009), we initialize the search with complete stories, rather than generate one sentence at a time. The genetic algorithm will thus avoid the pitfall of selecting early on a solu-tion that will later prove detrimental.
 Crossover Each plot is represented as an or-dered graph of dependency trees (corresponding to sentences). We have decided to use crossover of a single point between two selected parents. The children will therefore contain sentences up to the crossover point of the first parent and sentences after that point of the second. Figure 4a shows two parents (prince rescue princess, prince marry princess in castle, princess have baby) and (prince rescue princess, prince love princess, princess kiss prince) and how two new plots are created by swapping their last nodes. Mutation Mutation can occur on any verb, noun, adverb, or adjective in the plot. If a noun, adverb or adjective is chosen to undergo mutation, then we simply substitute it with a new lexical item that is sufficiently similar (see Figure 4b for an example). Verbs, however, have structural impor-tance in the stories and we cannot simply replace them without taking account of their arguments. If a matrix verb is chosen to undergo mutation, then a new random sentence is generated to re-place the entire sentence (see Figure 4d). If it is a subclause, then it is replaced with a randomly generated clause, headed by a verb that has been seen in the corpus to co-occur with the matrix verb (Figure 4e). The sentence planner selects and fills template trees for generating random clauses. Mu-tation may also change the order of any two nodes in the graph in the hope that this will increase the story X  X  coherence or create some element of sur-prise (see Figure 4c).
 Selection To choose the plots for the next gener-ation, we used fitness proportional selection (also know as roulette-wheel selection, Goldberg 1989) which chooses candidates randomly but with a bias towards those with a larger proportion of the population X  X  combined fitness. We do not want to always select the fittest candidates as there may be valid partial solutions held within less fit mem-bers of the population. However, we did employ some elitism by allowing the top 1% of solutions to be copied straight from one generation to the next. Note that our candidates may also represent invalid solutions. For instance, through crossover it is possible to create a plot in which all or some nodes are identical. If any such candidates are identified, they are assigned a low fitness, without however being eliminated from the population as some could be used to create fitter solutions.
In a traditional GA, the fitness function deals with one optimization objective. It is possible to optimize several objectives either using a vot-ing model or more sophisticated methods such as Pareto ranking (Goldberg, 1989). Following previ-ous work (Mellish et al., 1998) we used a single fit-ness function that scored candidates based on their coherence. Our function was learned from training data using the Entity Grid document representa-tion proposed in Barzilay and Lapata (2007). An entity grid is a two-dimensional array in which columns correspond to entities and rows to sen-tences. Each cell indicates whether an entity ap-pears in a given sentence or not and whether it is a subject, object or neither. For training, this repre-sentation is converted into a feature vector of en-tity transition sequences and a model is learnt from examples of coherent and incoherent stories. The latter can be easily created by permuting the sen-tences of coherent stories (assuming that the orig-inal story is more coherent than its permutations).
In addition to coherence, in McIntyre and La-pata (2009) we used a scoring function based on interest which we approximated with lexical and syntactic features such as the number of noun/verb tokens/types, the number of subjects/objects, the number of letters, word familiarity, imagery, and so on. An interest-based scoring function made sense in our previous setup as a means of selecting unusual stories. However, in the context of genetic search such a function seems redundant as inter-esting stories emerge naturally through the opera-tions of crossover and mutation. Once the final generation of the population has been reached, the fittest story is selected for sur-face realization. The realizer takes each sentence in the story and reformulates it into input com-patible with the RealPro (Lavoie and Rambow, 1997) text generation engine. Realpro creates sev-eral variants of the same story differing in the choice of determiners, number (singular or plural), and prepositions. A language model is then used to select the most probable realization (Knight and Hatzivassiloglou, 1995). Ideally, the realizer should also select an appropriate tense for the sen-tence. However, we make the simplifying assump-tion that all sentences are in the present tense. In this section we present our experimental set-up for assessing the performance of our story genera-tor. We give details on our training corpus, system, parameters (such as the population size for the GA search), the baselines used for comparison, and ex-plain how our system output was evaluated.
 Corpus The generator was trained on the same corpus used in McIntyre and Lapata (2009), 437 stories from the Andrew Lang fairy tales collec-tion. 5 The average story length is 125.18 sen-tences. The corpus contains 15,789 word tokens. Following McIntyre and Lapata, we discarded to-kens that did not appear in the Children X  X  Printed Word Database 6 , a database of printed word fre-quencies as read by children aged between five and nine. From this corpus we extracted narrative schemas for 667 entities in total. We disregarded any graph that contained less than 10 nodes as too small. The graphs had on average 61.04 nodes, with an average clustering rate 7 of 0.027 which in-dicates that they are substantially connected. Parameter Setting Considerable latitude is available when selecting parameters for the GA. These involve the population size, crossover, and mutation rates. To evaluate which setting was best, we asked two human evaluators to rate (on a 1 X 5 scale) stories produced with a population size ranging from 1,000 to 10,000, crossover rate of 0.1 to 0.6 and mutation rate of 0.001 to 0.1. For each run of the system a limit was set to 5,000 genera-tions. The human ratings revealed that the best sto-ries were produced for a population size of 10,000, a crossover rate of 0.1% and a mutation rate of 0.1%. Compared to previous work (e.g., Kara-manis and Manurung 2002) our crossover rate may seem low and the mutation rate high. How-ever, it makes intuitively sense, as high crossover may lead to incoherence by disrupting canonical action sequences found in the plots. On the other hand, a higher mutation will raise the likelihood of a lexical item being swapped for another and may improve overall coherence and interest. The fit-ness function was trained on 200 documents from the fairy tales collection using Joachims X  X  (2002) SVM light package and entity transition sequences of length 2. The realizer was interfaced with a tri-gram language model trained on the British Na-tional Corpus with the SRI toolkit. Evaluation We compared the stories gener-ated by the GA against those produced by the rank-based system described in McIntyre and La-pata (2009) and a system that creates stories from the plot graph, without any stochastic search. Since plot graphs are weighted, we can simply se-lect the graph with the highest weight. After ex-panding all lexical variables, the chosen plot graph will give rise to different stories (e.g., castle or temple in the example above). We select the story ranked highest according to our coherence func-tion. In addition, we included a baseline which randomly selects sentences from the training cor-pus provided they contain either of the story pro-tagonists (i.e., entities in the input sentence). Sen-tence length was limited to 12 words or less as this was on average the length of the sentences gener-ated by our GA system.

Each system created stories for 12 input sen-tences, resulting in 48 (4  X  12) stories for eval-uation. The sentences used commonly occurring entities in the fairy tales corpus (e.g., The child watches the bird , The emperor rules the kingdom. , The wizard casts the spell. ). The stories were split into three sets containing four stories from each system but with only one story from each input sentence. All stories had the same length, namely five sentences. Human judges were presented with one of the three sets and asked to rate the stories on a scale of 1 to 5 for fluency (was the sentence grammatical?), coherence (does the story make sense overall?) and interest (how interesting is the story?). The stories were presented in random or-der and participants were told that all of them were generated by a computer program. They were instructed to rate more favorably interesting sto-ries, stories that were comprehensible and overall grammatical. The study was conducted over the Internet using WebExp (Keller et al., 2009) and was completed by 56 volunteers, all self reported native English speakers. Our results are summarized in Table 1 which lists the average human ratings for the four systems. We performed an Analysis of Variance (A NOVA ) to examine the effect of system type on the story generation task. Statistical tests were carried out on the mean of the ratings shown in Table 1 for fluency, coherence, and interest.
 In terms of interest, the GA-based system is sig-GA-based 3.09 2.48 2.36 Plot-based 3.03 2.36 2.14  X  Rank-based 1.96  X  X  X  1.65  X  1.85  X  Random 3.10 2.23  X  2.20  X  Table 1: Human evaluation results: mean story ratings for four story generators;  X  : p &lt; 0 . 05, : p &lt; 0 . 01, significantly different from GA-based system. nificantly better than the Rank-based, Plot-based and Random ones (using a Post-hoc Tukey test,  X  &lt; 0 . 05). With regard to fluency, the Rank-based system is significantly worse than the rest (  X  &lt; 0 . 01). Interestingly, the sentences generated by the GA and Plot-based systems are as fluent as those created by humans. Recall that the Random system, simply selects sentences from the train-ing corpus. Finally, the GA system is significantly more coherent than the Rank-based and Random systems (  X  &lt; 0 . 05), but not the Plot-based one. This is not surprising, the GA and Plot-based sys-tems rely on similar plots to create a coherent story. The performance of the Random system is also inferior as it does not have any explicit coher-ence enforcing mechanism. The Rank-based sys-tem is perceived overall worse. As this system is also the least fluent, we conjecture that partici-pants are influenced in their coherence judgments by the grammaticality of the stories.

Overall our results indicate that an explicit story planner improves the quality of the generated sto-ries, especially when coupled with a search mech-anism that advantageously explores the search space. It is worth noting that the Plot-based sys-tem is relatively simple, however the explicit use of a story plot, seems to make up for the lack of sophisticated search and more elaborate linguis-tic information. Example stories generated by the four systems are shown in Table 2 for the input sentences The emperor rules the kingdom and The child watches the bird .

Possible extensions and improvements to the current work are many and varied. Firstly, we could improve the quality of our plot graphs by taking temporal knowledge into account and mak-ing use of knowledge bases such as WordNet and ConceptNet (Liu and Davenport, 2004), a freely available commonsense knowledge base. Secondly, our fitness function optimizes one ob-
The child watches the bird. The bird weeps for the child. The child begs the bird to lis-ten.The bird dresses up the child. The child grows up.

The child watches the bird. The bird comes to eat away at the child. The child does thor-oughly. The bird sees the child. The child sits down.

The child watches the bird. The bird lives from the reign to the child. The child thanks the victory for blessing the thought. The child loves to hate the sun with the thought. The child hopes to delay the duty from the happi-ness.

They cried,  X  X hat a beautiful child! X   X  X o, that I cannot do, my child X  he said at last.  X  X hat is the matter, dear child? X   X  X ou wicked child, X  cried the Witch. Well, I will watch till the bird comes.
 pastes together sentences from the training corpus (Random). jective, namely coherence. In the future we plan to explore multiple objectives, such as whether the story is verbose, readable (using existing readabil-ity metrics), has two many or two few protago-nists, and so on.

Thirdly, our stories would benefit from some ex-plicit modeling of discourse structure. Although the plot graph captures the progression of the ac-tions in a story, we would also like to know where in the story these actions are likely to occur X  some tend to appear in the beginning and others in the end. Such information would allow us to struc-ture the stories better and render them more natu-ral sounding. For example, an improvement would be the inclusion of proper endings, as the stories are currently cut off at an arbitrary point when the desired maximum length is reached.

Finally, the fluency of the stories would bene-fit from generating referring expressions, multiple tense forms, indirect speech, aggregation and gen-erally more elaborate syntactic structure.
 Agudo, Bel  X  en Di  X  az, Pablo Gerv  X  as, and Fred-erico Peinado. 2004. A case based reason-ing approach to story plot generation. In
Proceedings of the 7th European Conference on Case-Based Reasoning . Springer, Madrid, Spain, pages 142 X 156.
 Barros, Leandro Motta and Soraia Raupp Musse. 2007. Planning algorithms for interactive story-telling. In Computers in Entertainment (CIE) ,
Association for Computing Machinery (ACM), volume 5.
 Barzilay, Regina and Mirella Lapata. 2007. Mod-eling local coherence: An entity-based ap-proach. Computational Linguistics 34(1):1 X 34. Briscoe, E. and J. Carroll. 2002. Robust accurate statistical annotation of general text. In Pro-ceedings of the 3rd International Conference on
Language Resources and Evaluation . Las Pal-mas, Gran Canaria, pages 1499 X 1504.
 Chambers, Nathanael and Dan Jurafsky. 2008. Unsupervised learning of narrative event chains. In Proceedings of 46th Annual Meeting of the
Association for Computational Linguistics: Hu-man Language Technologies . Columbus, Ohio, pages 789 X 797.
 Chambers, Nathanael and Dan Jurafsky. 2009.
Unsupervised learning of narrative schemas and their participants. In Proceedings of the Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP . Singapore, pages 602 X 610.
 Cheng, Hua and Chris Mellish. 2000. Captur-ing the interaction between aggregation and text planning in two generation systems. In Pro-ceedings of the 1st International Conference on Natural Language Generation . Mitzpe Ramon, Israel, pages 186 X 193.
 Fellbaum. 1998. WordNet: An Electronic Lexi-cal Database (Language, Speech, and Commu-nication) . The MIT Press, Cambridge, Mas-sachusetts.
 Fillmore, Charles J., Christopher R. Johnson, and Miriam R. L. Petruck. 2003. Background to
FrameNet. International Journal of Lexicogra-phy 16:235 X 250.
 Goldberg, David E. 1989. Genetic Algorithms in Search, Optimization and Machine Learning . Addison-Wesley Longman Publishing Co., Inc., Boston, Massachusetts.
 Grishman, Ralph, Catherine Macleod, and Adam
Meyers. 1994. COMLEX syntax: Building a computational lexicon. In Proceedings of the 15th COLING . Kyoto, Japan, pages 268 X 272.
 Joachims, Thorsten. 2002. Optimizing search en-gines using clickthrough data. In Proceed-ings of the 8th Proceedings of the eighth ACM
SIGKDD international conference on Knowl-edge discovery and data mining . Edmonton, Al-berta, pages 133 X 142.
 Karamanis, Nikiforos and Hisar Maruli Manu-rung. 2002. Stochastic text structuring using the principle of continuity. In Proceedings of the 2nd International Natural Language Gener-ation Conference (INLG X 02) . pages 81 X 88.
 Keller, Frank, Subahshini Gunasekharan, Neil
Mayo, and Martin Corley. 2009. Timing accu-racy of web experiments: A case study using the WebExp software package. Behavior Research Methods 41(1):1 X 12.
 Knight, Kevin and Vasileios Hatzivassiloglou. 1995. Two-level, many-paths generation. In
Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics (ACL X 95) . Cambridge, Massachusetts, pages 252 X 260.
 Korhonen, Y. Krymolowski, A. and E.J. Briscoe. 2006. A large subcategorization lexicon for nat-ural language processing applications. In Pro-ceedings of the 5th LREC . Genova, Italy.
 Lavoie, Benoit and Owen Rambow. 1997. A fast and portable realizer for text generation sys-tems. In Proceedings of the 5th Conference on
Applied Natural Language Processing . Wash-ington, D.C., pages 265 X 268.
 Lin, Dekang. 1998. Automatic retrieval and clus-tering of similar words. In Proceedings of the 17th International Conference on Compu-tational Linguistic . Montreal, Quebec, pages 768 X 774.
 Liu, Hugo and Glorianna Davenport. 2004. Con-ceptNet: a practical commonsense reasoning toolkit. BT Technology Journal 22(4):211 X 226. Liu, Hugo and Push Singh. 2002. Using com-monsense reasoning to generate stories. In Pro-ceedings of the 18th National Conference on Ar-tificial Intelligence . Edmonton, Alberta, pages 957 X 958.
 McIntyre, Neil and Mirella Lapata. 2009. Learn-ing to tell tales: A data-driven approach to story generation. In Proceedings of the Joint Confer-ence of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natu-ral Language Processing of the AFNLP . Singa-pore, pages 217 X 225.
 Meehan, James. 1977. An interactive program that writes stories. In Proceedings of the 5th In-ternational Joint Conference on Artificial Intel-ligence . Cambridge, Massachusetts, pages 91 X  98.
 Mellish, Chris, Alisdair Knott, Jon Oberlander, and Mick O X  X onnell. 1998. Experiments using stochastic search for text planning. In Proceed-ings of the 9th International Conference on Nat-ural Language Generation . New Brunswick, New Jersey, pages 98 X 107.
 Mitchell, Melanie. 1998. An Introduction to Ge-netic Algorithms . MIT Press, Cambridge, Mas-sachusetts.
 Pizzi, David, Fred Charles, Jean-Luc Lugrin, and
Marc Cavazza. 2007. Interactive storytelling with literary feelings. In Proceedings of the 2nd
International Conference on Affective Comput-ing and Intelligent Interaction . Lisbon, Portu-gal, pages 630 X 641. Reiter, E and R Dale. 2000. Building Natural-Language Generation Systems . Cambridge University Press, Cambridge, UK.
 Riedl, Mark O. and R. Michael Young. 2004. A planning approach to story generation and his-tory education. In Proceedings of the 3rd In-ternational Conference on Narrative and Inter-active Learning Environments . Edinburgh, UK, pages 41 X 48.
 Shim, Yunju and Minkoo Kim. 2002. Automatic short story generator based on autonomous agents. In Proceedings of the 5th Pacific Rim In-ternational Workshop on Multi Agents . Tokyo, pages 151 X 162.
 Swartjes, I.M.T. and M. Theune. 2008. The vir-tual storyteller: story generation by simulation. In Proceedings of the 20th Belgian-Netherlands
Conference on Artificial Intelligence, BNAIC 2008 . Enschede, the Netherlands, pages 257 X  264.
 Turner, Scott R. 1992. Ministrel: A Computer
Model of Creativity and Sotrytelling . University of California, Los Angeles, California.
 Wu, Zhibiao and Martha Palmer. 1994. Verb se-mantics and lexical selection. In Proceedings of the 32nd Annual Meeting of the Associa-tion for Computational Linguistics . Las Cruces,
New Mexico, pages 133 X 138.
