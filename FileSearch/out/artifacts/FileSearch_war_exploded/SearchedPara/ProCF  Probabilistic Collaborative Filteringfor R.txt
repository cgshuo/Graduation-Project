 Memory-based collaborative filtering (CF) is the basis of many commercial rec-ommender systems, of which Amazon X  X  [13] item-based approach is probably the best known. In this work we present a unified framework incorporating both item-based and user-based CF and within it develop a novel probabilistic method of similarity that overcomes some of the limitations of previous approaches.
Conventional recommender systems attempt to discover user preferences over items by modelling the relation between users and items. The aim is to recom-mend items that match the taste (likes or dislikes) of users in order to assist the active user, i.e., the user who will r eceive recommendations, to select items from an overwhelming set of choices. It i s used to 1) predict whether a partic-ular user will like a particular item (a prediction problem), or 2) identify a set of N items that will be of interest to a certain user (a Top-N recommendation problem). Recently, recommender sys tems have also been extended to people to people (P2P) recommendation to model the relation between the active user and other users by finding user preferences over other users.

Assuming that users with similar tastes would rate items (or other users) similarly, memory-based collaborative filtering (CF) methods recommend items based on heuristic aggregated user preferences for items, independent of the availability of item descriptions. In this paper we formalise memory-based CFs in a uniform way that allows the derivation of a probabilistic method, ProCF , that is shown to improve performance in a P2P recommendation application.
Section 2 discusses related work. Section 3 defines the problems. Section 4 develops a probabilistic approach for both recommendation and ranking. Exper-imental evaluation is in Section 5 and we conclude in Section 6. CF algorithms fall into two categories: model-based and memory-based ap-proaches. Model-based CF [1,2,10,16] uses the collection of ratings to learn a model, which is then used to make rating predictions. Although model-based methods have reported higher accuracy of recommendation than memory-based approaches, there are some limitations. These methods are computationally ex-pensive since they usually require all users and items to be used in creating models, and the number of users and items is typically large. Memory-based CF is popular in many commercial recommende r systems, being effective and easy to implement. Memory-based approaches [2,11,13,18] make rating predictions based on the entire set or a sample of items previously rated by users. The un-known rating value r c,s of the active user c for an item s is typically computed as an aggregate of the ratings of users similar to c for the same item s .This aggregate can be an average or a weighted sum, where the weight is a distance that measures the similarity between users c 1 and c 2 . By using similarity as a weight, more similar users make a greater contribution to a predicted rating.
In memory-based CF, similarity comput ation between items or users is essen-tial. The definition of similarity measure varies depending on the recommenda-tion application. Often the similarity between two users is based on the ratings of items both users have rated. Two of the most popular approaches are corre-lation [11,18] and cosine-based [2,17]. Extensions to these include default voting, inverse user frequency, case amplification, and weighted-majority prediction [2,7]. Usually these use heuristics to model the weights and are not able to handle the different rating scales of different users. Solutions to this problem include the ad-justed weighted sum and preference-based fi ltering [14], which focuses on predict-ing the relative preferences of users i nstead of absolute rating values.
Memory-based probabilistic CF is an alternative. Yu et al. [20] use a mixture model for user preferences. Deshpande and Karypis [8] proposed conditional probability based similarity in item-based CF. These models only consider com-mon purchase information, which causes the problem that frequently purchased items tend to have high conditional probabilities, leading to reduced diversity in recommendation [9]. Adding a scaling p arameter to control for the effect of popular items in the model may help, but finding a suitable parameter value be-comes challenging. Also, these methods are uni-directional, relying only on users X  taste , so they are not applicable to P2P recommendation, which is reciprocal.
People recommenders deal with the problem of finding meaningful relation-ships among people or organisations. In online social networks, relationships can be friends [19] e.g., on Facebook, professional contacts [3] e.g., on LinkedIn, online dating [5,12], or jobs on employment websites [15]. The nature of these do-mains makes P2P recommender systems significantly different from traditional item to people (I2P) recommenders. The basic difference in the people recom-mender domain is the characteristic of reciprocal relationships. Recommender systems can be classified into t wo general classes: classical item to people recommender systems (I2PRec) and people to people recommender sys-tems (P2PRec). In classical I 2PRec, there are two types of entities, buyers (e.g., customers) and items (e.g., books, movi es, songs). In recent P2PRec [5], there only exists a uniform entity type: users (e.g., online dating service subscribers, job seekers and employers). To disting uish the different roles in a recommenda-tion, we use subject , S = { s 1 ,...,s | S | } , to refer to the recommendation recipient (e.g., customers in I2PRec and acti ve partner seekers for P2PRec) and object , O = { o 1 ,...,o | O | } , to refer to the recommendation candidate (e.g., books in I2PRec and partner seekers in P2PR ec). Recommender systems using CF meth-ods rely on collaborative information. There are several types of collaborative information. One important distinction is between explicit (i.e., ratings, up and down votes) and implicit (i.e., clicks, purchases, contacts, replies) expressions of user preferences. Depending on the type o f system, implicit information may be positive-only, i.e., no recorded negative preference observations, or positive-and-negative, i.e., both positive and negative preference observations are available.
In I2PRec, collaborative information used in traditional CF is merely based on the behaviours of subjects, i.e., the preference of buyers determines the transac-tions that represent the collaborative information. However, in P2PRec, collab-orative information usually depends on behaviours of both subject and object, since the relationship between the subject and the object can only be estab-lished when both parties agree on it, denoted by a successful interaction (i.e., the subject makes contact to express int erest and gets positive feedback from the object). We use so + to refer to this, representing the establishment of a successful interaction. Similarly, so  X  refers to an unsuccessful interaction. This requires P2PRec to consid er collaborative information based on behaviours of both subject and object rather than only those of subject, which consequently prevents traditional I2PRec from solving the P2P recommendation problem [4].
The task of P2P recommendation from implicit, positive and negative, pref-erences is to rank the obj ects from a candidate set O c for a subject according to the probability of establishing a relationship between them based on the collab-orative information. This task is related to, but distinct from, rating prediction, where the task is to predict how much a subject will like an object. Therefore, a ranked list of candidate objects for each subject, rather than an explicit rating, is the output of a typical P2P recommender.
 Similarity. Memory-based CF approaches to recommender systems differ ac-cording to the method used to compute the similarity between the various sub-jects/objects, which conse quently determines the overall performance of the rec-ommender. In general, the similarity between two entities should be high if they have interacted with a large set of oth ersincommonandlo w if few in common. In this case, the similarity between two entities is symmetric since the common set is shared with both entities and no other information is considered. But this may not be sufficient, since other subject s/objects that were not interacted with in common by the similar pairs, but only by one in the pair, can have impact on the similarity and thus the recommendation. When using information from such entities not interacted with in common by the similar pairs, similarity be-comes naturally asymmetric , since each entity in the pair can have a different set contacted by it alone. For example, in P2P recommendation, Bob may pre-fer Alice since she is younger than 30 years old and likes music, while Charlie could also prefer Alice, but only because she has age less than 30. Thus, Bob is similar to Charlie since they have a common preference and vice versa. In sym-metric similarity, similarity to each other is the same since they prefer the same woman. However, Diana, who is 20 years old but hates music could be preferred by Charlie but not by Bob, since Bob prefers women who like music. This shows that Bob and Charlie X  X  preferences are not the same, and moreover, that Bob X  X  similarity to Charlie is different from Charlie X  X  to Bob, and thus asymmetric .
Similarity can be represented by similar pairs. There are two roles within a similar pair: actor and imitator , as illustrated in Fig. 1. To define those two roles, we first define the coactor : Definition 1. A coactor is the entity who interacts with both entities in a sim-ilar pair, i.e., either the candidate of recommendation in user-based CF or the active entity in item-based CF.
 In the example, Bob is similar to Charlie. If Emma is preferred by Bob and likes music, we can recommend Emma to Charlie by user-based CF. Or if Emma prefers Bob, we can reco mmend Charlie to Emma by item-based CF. In both cases, we call Emma a coactor , the person who either receives recommendations or is recommended. The two roles within a similar pair are defined as: Definition 2. An actor is the entity within a similar pair that provides collab-orative information, i.e., the entity who actually interacted with the coactor. Bob is a actor in our example since he interacted with the coactor Emma. Definition 3. An imitator is the other entity in the similar pair with similar behaviour to the actor, i.e., either the active entity in user-based CF or candidate in item-based CF.
 Charlie is an imitator in our example for his similarity to the actor Bob. Given the above definitions, we formally define symmetric and asymmetric similarity: Definition 4. A symmetric similarity is a measurement of the amount of com-monality in the behaviour of an actor and its imitator.
 Definition 5. An asymmetric similarity is a measurement of the combined (e.g., summed) amount of commonality and difference in the behaviour of an actor and its imitator.
 These definitions subsume both user-based and item-based CF into a novel uni-fied model, which reveals the fundamental principles that drive the formation of collaborative recommender systems by discovering the relation among the entities involved in the collaborative recommendation (Fig. 1). In this section, we describe the probabilistic CF framework and apply it to the task of P2P recommendation from implicit, positive and negative, feedback. 4.1 Conditional Probabilistic Similarity We define probabilistic similarity in the context of item-based CF as the prob-ability that an action succeeds given that the subject of recommendation had a positive interaction with one of the similar objects and the subject attempted the same action with another similar object. This definition is sufficiently gen-eral to cover both item-based and user-b ased CF (Fig. 2). It also covers people to people recommendation, in which ther e are two types of actions: acceptance, i.e., positive feedback, and rejection, i.e., negative feedback. Depending on the type of action we can then define the probability of acceptance or rejection: Definition 6. The acceptance probability P ( i | j ) is the probability a positive ac-tion will occur with entity pair i given a positive action occurred with pair j : where P is the probability, E the set of entities in the training set, i the imitator in Definition 3, c the coactor in Definition 1 and a the actor in Definition 2. Definition 7. The rejection probability P ( x | y ) is the probability a negative ac-tion will occur with entity pair x given a positive action occurred with pair y : Note that the conditional probability-based similarity of [8] occurs as a special case of this framework when there is only a single type of action. For example, in item-based CF the similarity between two items is the conditional probability that one item will be purchased given that the other has been purchased. This is equivalent to P ( ic | ac ), which is obtained by dropping the sign of the interactions and simplifying in either of Definitions 1 or 2, when they become identical.
To compute the acceptance and rejection probability, as shown in Fig. 2, we first find the number (C) of common entities each of which has a positive action with the actor, and either a positive or negative action with the imitator. Here the common entities with negative actions with respect to the actor (  X  + or  X  X  X  ), shown greyed-out in Fig. 2, are not taken into account. Secondly, we count how many of those have positive actions in common with the imitator (A), and how many of them have negative actions with the imitator (B). Then, the acceptance probability is (A) divided by (C) and the rejection probability is (B) divided by (C). For the example in Fig. 2, the number of such common entities (in the dashed circle) is 4. Out of these the number of entities having positive actions with the imitator (++) is 2 and those having negative actions (+  X  )is2. Therefore, the acceptance probability is 2 / 4=0 . 5 and the rejection probability is 2 / 4=0 . 5. In this case the actor and imitator as similar entities have equivalent acceptance and rejection probability with respect to the coactors. 4.2 Probability Residue We consider both acceptance probability and rejection probability in estimating the impact of the preferences of similar entities. If we have a similar pair for which the acceptance probability ( P + , for short) is greater than the rejection probability ( P  X  ), we would naturally be inclined to decide that the similar pair will contribute to the acceptance of t he recommendation of a similar entity. Conversely, if P  X  is greater than P + , we would be inclined to consider rejection. To justify this decision procedure, we can calculate the probability of error. Whenever we observe a pa rticular similar pair i , the probability of an error is: Given i we can minimise the probability of error by deciding acceptance if P + &gt; P  X  and rejection otherwise. Thus, the probability residue is the contribution of each similar entity to the ranking by minimising the decision error: Definition 8. The probability residue is the difference between the acceptance probability and rejection probability: The probability residue reflects the balance of the acceptance and rejection prob-ability of an interaction between a pair of entities. It measures the degree to which the interaction departs from random, i.e., increases the possibility of ei-ther success or failure. Thus, a similar ent ity will contribute towards a positive rating and thus success if the probability residue  X  ai &gt; 0, contribute towards a negative rating and thus failure if the probability residue  X  ai &lt; 0, or not contribute to recommendation at all if the probability residue  X  ai =0.
For the example in Fig. 2 the probability residue is 0 and thus will be ignored in recommendation, since the actor as a similar entity to the imitator, as an active entity or candidate, has equivalent acceptance and rejection probability. 4.3 Rating Rating of candidates as active entities is then based on probability residues. It is the sum of probability residues of all the entities similar to the current active entity corresponding to a candidate: where S is the set of similar entities and  X  k the probability residue of Definition 8. Theorem 1. If  X  is a probability residue and | S | is the number of similar enti-ties, then the candidate rating function r of Equation 5 is a non-monotonically increasing function on the number of similar entities | S | .
 could have r ( | S 1 | )  X  r ( | S 2 | ) according to Equation 5. Thus function r does not preserve the ordering and is non-monotonic.
 Notice that this non-monotonic characteristic of the rating function is desired in recommender systems. In conventional recommender systems [11,13,8], the rating functions are usually monotonically increasing on the number of similar entities. This is a problem since it will cause popular (i.e., preferred by a large number of entities) or active (i.e., preferring a large number of entities) entities to have higher rating than others since popular or active entities have usually more similar entities than other entities.

More specifically, popular objects are pr eferred by a large number of subjects and thus have more chance to be co-preferred with other objects, which makes popular objects have more similar objects than non-popular ones. Similarly, active subjects prefer a large number of objects and thus have more chance to co-prefer with other subjects, which m akes active subjects have more similar subjects than non-active ones. However, since the rating function defined in Equation 5 is non-monotonic it is not necessarily increasing for popular or active entities. Therefore, by using the probability residue defined above, we are able to avoid the common problem of favouring popular entities in recommendation, and therefore increase the diversity as shown in Section 5. Promoting novel recommendation generates global diversity and improves user experience [6].
A ranked candidate list is then generated by descending sort of all candidates on rating. For tied ratings, we have two steps: (i) favour the candidate with a greater total number of interactions used in calculating similarity; and if this is also tied (ii) favour the candidate with more contributed similar pairs. In these rare cases the increased support means favouring more reliable ratings. 4.4 Summary of the ProCF Algorithm The proposed framework is realised in the ProCF algorithm. It constructs a similarity table and then generates a recommended candidate list for each sub-ject. Specifically, to construct the similarity table, ProCF collects all similar pairs, each of which has at least one common coactor, and then assigns each pair a probability residue value according to Equation 4. To generate recommenda-tions for an active entity, ProCF finds each imitator in the similarity table for which all pairs of their corresponding actors were interacted with by the active entity. It then computes a rating for the imitator according to Equation 5 and adds the imitator to the recommendation list.

The complexity of ProCF is approximately O ( N ), and O ( N 2 )intheworst case, where N is the number of entities in the training set, since it examines N entities and up to N  X  1 other entities for each entity. However, because the average entity interaction vector is extremely sparse, the performance of the algorithm tends to be closer to O ( N ) in practice. Scanning every entity is approximately O ( N ) rather than O ( N 2 ) because almost all entity interaction vectors contain only a small number of interactions with other entities. Although there are a few entities who interact wit h a significant percentage of all other entities, each still only requires O ( N ) processing time. In these experiments, we evaluate the proposed approach on people to peo-ple recommendation (Top-N recommendation) in a demanding real-world social network data set. We compare the proposed probabilistic CF method to several conventional recommendation strategies based on a set of common evaluation metrics. Owing to space restrictions, we can only summarize our results, which will be detailed in an extended version of the paper.
 Datasets. Data was collected from a commercial online dating site. In online dating, people are looking for potential partners. A user contacts people they like by sending messages. Receivers of messages then have options to reply, positively if they like the sender, negatively if they do not like the sender or are not sure, or they may just not reply. Specifically, the data contains interaction records, each of which represents a contact by a t uple containing the identities of the sender and receiver and whether the contact was accepted (positive response from receiver to sender) or not. The forme r case is denoted a successful or positive interaction, otherwise it is unsuccessful or negative.

The training set covered a four week period in February, 2010 and the test set a one week period from the first of March, 2010 (test results from a three week period from the same date were essentially identical and are omitted due to lack of space). Training and test sets contai ned all users with at least one contact in the respective periods. The training (resp. test) sets contained 166699 (95814) users with a total of 1710332 (436128) interaction tuples. Of these 264142 (66482) were positive interactions and 1446190 (369646) were negative (including non-replies). The default success rate (DSR), the proportion of interactions that were positive, was 15.4% (15.2%).
 Methodologies. We compare the proposed algorithm with the P2P Best 2CF+ method [12] on their evaluation metric and a new metric defined below. As far as we are aware this is the best-performing published CF method for recom-mendation in online dating. Model-based methods such as matrix factorisation methods were also tested but were not able to handle such a large dataset.
We trained ProCF and Best 2CF+ using the above training set. The learned model for each approach was then tested by generating the Top-N recommenda-tions for each user in the test set . Finally, recommendations from ProCF and Best 2CF+ were evaluated as described below and the results are compared. Evaluation Metrics. Evaluation in this domain is more complex than standard CF applications. Metrics used to capt ure key aspects of system performance are defined as follows. Precision/Success Rate(SR) : proportion of interactions predicted to be successful that were actu ally successful to all predicted successful interactions (PSI). Default Success Rate(DSR) : proportion of actual successful interactions (SI) to all interactions in the dataset. SRI : ratio of SR to DSR. Recall and F Value : recall is proportion of true PSI to all true SI. F Value is proportion of true PSI to all PSI with either positive or negative reply. ARI is the ratio of AR to default accep t rate without r ecommendation. Reject Rate and RRI : reject rate (RR) is proportion of false PSI with negative reply to all PSI with any reply. RRI is the ratio of RR to default reject rate without recommendation.

We use SRI to test how likely recommendation is to help the active user to have a positive interaction. Recall and F value tests how different user behaviour based on recommendation is to default. Finally, ARI and RRI test responses of the recommended user when the active user follows the recommendation. Results. Acomparisonof ProCF and Best2CF+ on the test set in terms of the evaluation metrics is shown in Fig. 3. Clearly ProCF outperforms Best 2CF+ on precision for all Top-N recommendations; the most significant comparative improvement is on Top 100 where ProCF outperforms Best 2CF+ by 34%.
 SRI shows that although Best 2CF+ improves the baseline performance of the system for all Top-N , ProCF achieves greater improvement. Since [12] show that Best 2CF+ outperforms traditional CFs on P2P recommendation, ProCF has a clear advantage. This suggests that considering both positive and negative collaborative information in creating similar pairs using probability residue leads to recommending users with higher probabilities of successful interaction with the active user. Recall and F Value improvements for ProCF indicates greater reliability in recommendation. Also, ProCF shows increased accept rate and reduced reject rate for the most highly ranked users. This supports the hypothesis that by looking at the difference between positive and negative information, ProCF can down-rank candidates with higher reject rate while up-ranking those with higher accept rate.

In Table 1, we show the average positive reply rate (APRR) per receiver over all recommended users compared to the t hose over all users in datasets. We also compared ProCF to Best 2CF+ on APRR with ProCF shown in bold in the figure. We can see from the results that both Best 2CF+ and ProCF have a similar APRR to the baseline over all Top-N . Best 2CF+ achieved smaller APRR than the baseline except from Top 20 and 10 while ProCF achieved even smaller APRR than Best 2CF+ except only Top 10. This indicates that ProCF does not recommend users who have higher positive reply rate. In contrast, it recommends users with lower positive reply rate in general. A recommender system that prefers recomme nding users with higher positive reply could improve the success rate. However, ProCF does not have a concen tration bias on those users and thus does not commit the problem of recommending very frequent items as in [8]. Diversity in P2P recommendation is important; for example, recommending people who always say  X  X es  X  to any contact is poorly personalized and leads to poor recommendation performance. ProCF  X  X  achievement of high success rate while maintaining div ersity is a significant result.
 Discussion. The experiments have shown that ProCF implementing our proba-bilistic similarity function significantly outperforms Best 2CF+ on all evaluation metrics used. This proves that ProCF also outperforms all standard CF meth-ods and combined CF methods evaluated in [12]. Note that ProCF achieved its performance by a single improved CF method not by any combination of CFs or profile-based methods. The characteristics of ProCF and its good performance suggest it could be used as an improved standard CF method to be integrated into existing commo n recommendation frameworks for increased performance. Beside good performance, ProCF has the advantage of being simple, easy to implement and fast. All presented algorithms were implemented using SQL in Oracle 11. ProCF required about 1 hour for training and several minutes for testing on a workstation with 64-bit Windows 7 Professional, 2 processors of Intel(R) Xeon(R) CPU x5660@2.80GHz and 32GB RAM. We presented a general and straightforward framework, ProCF , for recom-mender systems. Although ProCF is in general applicable to both I2P and P2P recommendation, this paper focuses o n P2P recommendation only. We demon-strated the usefulness of ProCF in a set of extensive experiments. The ex-periments were conducted on demanding real world datasets collected from a commercial social network site. The experimental evaluation of ProCF shows that it is suitable for P2P recommendation. The comparative evaluation to two of the best CF methods on this task shows that ProCF outperforms the best CF-based method for P2P recommendation. We also showed that ProCF retains diversity of recommendation while providing higher accuracy recommendation. It does not only recommend a small group of users with high positive reply rate. An appealing property of our framework is its simplicity and modularity. Because it follows a standard CF framework with its improved similarity and ranking functions, it can be applied or integrated into existing CF recommender systems to improve system performance.

In the future, we will extend this work to test ProCF using other probabilistic functions for similarity and other distribution functions for calculating proba-bility residue. We will also investigate the integration of profile based approach into ProCF for even better recommendation performance. Acknowlegement. This work was funded by Smart Services Cooperative Re-search Centre. We would also like to thank our industry partners for providing the datasets.

