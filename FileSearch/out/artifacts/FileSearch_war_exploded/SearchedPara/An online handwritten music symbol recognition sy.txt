 ORIGINAL PAPER Hidetoshi Miyao  X  Minoru Maruyama Abstract The objective of this study is to produce a system that would allow music symbols to be written by hand using a pen-based computer that would simulate the feeling of writing on sheets of paper and that would also accurately recognize the music symbols. To accom-plish these objectives, the following methods are pro-posed: (1) Two features, time-series data and an image of a handwritten stroke, are used to recognize strokes; and (2) The strokes are combined, as efficiently as pos-sible, and outputted automatically as a music symbol. As a result, recognition rates of 97.60 and 98.80% were obtained in tests with strokes and music symbols, respec-tively.
 Keywords Music score recognition  X  Online handwritten symbol recognition  X  Pen-based music editing system 1 Introduction Current composers and arrangers record music by hand-writing music symbols on sheets of paper. However, it would be desirable to be able to convert them into com-puter-readable data so that they could be easily edited and allow other functions, such as printing, automatic performance, dividing parts, and modulation.

In order to allow automatic conversions, many offline handwritten music recognition systems have been pro-posed [1 X 4]. However, according to Yadid-Pecht [4], the recognition rates of the musical notes range between 80 and 90%, which is not high enough. Therefore, they are impractical because it takes too long to correct the errors.

On the other hand, software that permits the direct input of music data have also been developed. In par-ticular, most commercial software has adopted this way and require the use of a mouse, keyboard and music keyboard. Complex notation can be written with these systems; however, the learning curve is long and diffi-cult. Anstice [7] reported that computer systems require about three times longer than handwriting to record a score. Consequently, most musicians prefer to handwrite the music rather than to use computers.

Pen-based music editing systems have been proposed because they are more user-friendly and require less time [5 X 9]. In such systems, Anstice [7] and Ng [8] de-fined shapes for symbols that are used frequently. These symbols are easily recognized by a computer. Other sym-bols can be selected from menus or icons on a computer window. The systems reduce the input time required, but the user needs to memorize the symbols and shapes and learn how to use the application.

George [10] has proposed an online pen-based recog-nition method for fundamental 20 music symbols by us-ing a multi-layer perceptron. This system allows a user to enter music symbols with the conventional music nota-tion. As an experimental result, the recognition rates of the system are approximately 80% on unseen test data. For practical use, we think the system with higher recognition rates is required.
Our aim is to propose a music symbol recognition system, that is simpletouse. Thesymbols canberecorded in a manner that is similar to traditional handwritten music, and they can still be accurately recognized. To in-crease the accuracy of recognition of the strokes (in this paper, the term  X  X troke X  means that it is a connected component from pen-down to pen-up), time-series and directional features were incorporated into the system. The directional features are obtained by an image of handwritten stroke. In addition, a proposal is made for a method that allows for the recognized strokes to be efficiently combined as a music symbol. 2 Input of strokes for each symbol Music symbols vary widely in shape compared with char-acter symbols. In particular, the combinations of shapes in music notes are innumerable since the number of note heads, dots, and flags included in a note is unlimited. It is impossible to prepare identifiers for all kinds of music symbols in contrast with that identifiers can be gener-ated for all characters in OCR systems. Therefore, the system proposed here deals with the individual strokes of a music symbol instead of the symbol itself. Then, they are combined to make one symbol.

The recognizable strokes for the proposed system are shown in Fig. 1. The shapes are similar to those used for handwritten symbols, with the exception of the filled-note head. The shape of the filled-note head is a circle with a slash, as shown in Fig. 1(11); it was modified to reduce the input time. Each stroke in Fig. 1 need to be written with one stroke; however, the start point is not restricted.

With this approach, the following music symbols can be generated: G clef, F clef, sharp, flat, natural, musical notes (except for the beamed notes), and rest symbols. The names of music symbols to which the stroke can belong, are listed below the stroke names in Fig. 1. For each music symbol, the strokes need to be written suc-cessively in order to combine the strokes into a music symbol automatically (discussed in Sect. 4). However, the system does not require that a particular order of entering the strokes should be followed when they are written. For example, the four strokes required for the creation of a  X  X harp X  may be written in any order; the software will automatically recognize them as a sharp. 3 Recognition of the strokes in each symbol An online entered stroke is sampled at an even time interval and points are obtained in order of time. The stroke can be represented by lines connecting the points. The stroke is classified by using the following method just after the pen is up. 3.1 Feature extraction by DP matching An eight-direction Freeman Chain Code is used to rep-resent the time-series data of the stroke, as shown in Fig. 2. Standard templates were prepared with chain codes for each stroke in each symbol. An input stroke is recognized based on matching of input and template codes. However, the length of the input code does not necessarilycoincidewiththat of thetemplatecode. String edit distance computation based on dynamic program-ming (DP) is suitable for matching the codes [11].
The chain code series of an input stroke and the k th template are represented by { a 1 , a 2 , ... , a I } { b 1 , b { a 1 , a 2 , feasibly, the accumulated distance g k ( i , j ) is calculated as follows: (a)(b) Initial values:  X   X   X  g k ( 0, 0 ) = 0 g k ( i ,0 ) = g k ( i  X  1, 0 ) + 1, for 1  X  i  X  I g k ( 0, j ) = g k ( 0, j  X  1 ) + 1, for 1  X  j  X  J Recurrence formula: g ( i , j ) = min where d ( i , j ) means the distance between codes a i and b Its value is assigned to be 0 if the two codes are identical; otherwise, it is 2. Using the above formulas, the min-imum accumulated distance g k ( I , J ) is calculated. The path length is also obtained by backtracking the calcu-lated process, and then the normalized distance G k can be calculated based on the length. G k has a value from 0to1.If G k is small, it means that there is a strong resemblance between the two patterns. The above pro-cess is repeated for each template code. The series of normalized accumulated distances { G 1 , G 2 , ... , G M } then obtained, where M means the number of the pre-pared templates. Since the start point of the stroke is not restricted, the reverse chain code is also matched to each of the template codes. After examining the dis-tances by using the ordinary chain code and the reverse chain code, the shorter distance is adopted for each tem-plate.

This process flowchart is shown in Fig. 3, Part A. 3.2 Feature extraction by SVM The difference of the start position of a stroke may pro-duce a wide variety of chain codes, particularly for the strokes containing a loop, such as the WHead, shown in Fig. 1(10). We assume that a template chain code for a loop symbol is defined as { 23456701 } . It means that the start position is the top of the loop. If a test stroke is the same loop symbol, but the start position is the bottom of the loop, the chain code becomes { 67012345 } . Although the ideal normalized distance between them should be 0, the actual calculated distance becomes 0.5 because the chain code is shifted. For such strokes, the use of the two-dimensional image features should be better than the use of the chain codes; therefore, they are used as well. First, the size of the circumscribed rectangle of the image is normalized to 64 dots  X  64 dots, and then the image is equally divided into regions of 8 dots  X  8 dots. Second, the directional feature of each region is calcu-lated. As a result, 256 (= 8  X  8  X  4) features are obtained for one stroke (see Fig. 4).

A support vector machine (SVM) is applied to rec-ognize the strokes. SVM is a learning method based on margin maximization principle [12]. SVM performs bi-nary classification by finding optimal separating hyper-plane in the feature space. Suppose that a set of training sify the input x based on the function f ( x ) = where K ( x , x i ) is a kernel function which defines the inner product in the feature space. The parameter b is determined by learning from examples. The class label y = X  1 means that the data x class and y i = 1 means that x i does. Coefficients  X  i sare non-zero only for the subset of the input data called support vectors.
 The performance of SVM depends on the kernel. We use RBF(Gaussian) kernel, which outperformed the other commonly used kernels in the preliminary exper-iments. Gaussian kernel is given as K ( x , y ) = exp  X 
For classification of each class of strokes used in the symbols, an SVM classifier was developed. This was accomplished by training with the directional features as input patterns. Using the trained SVM classifiers, a all of the classifiers, where S means the number of stroke classes andtheoutput values areclampedbetween 0 to 1 using a sigmoid function.

This process flowchart is shown in Fig. 3, Part B. 3.3 Stroke recognition based on the outputs Ultimately, the plan was to classify an input stroke for a symbol based on the output values calculated by two types of classifiers as shown in Fig. 3, Part C. An SVM classifier with large capacity for classification is also used. The output values { G 1 , G 2 , ... , G M , D 1 , D D
To apply SVM (binary classifier) to multiclass recog-nitionproblem, weuseone-versus-rest (1vr) typemethod [14]. Suppose that we are dealing with an n -class prob-lem. In 1vr type method, n SVMs f i ( i = 1, ... , n ) , each of which classifies a single class from the other classes, are learned from examples. The resultant class c is deter-mined as c = arg max i f i ( x ) .

The stroke Dot [Fig. 1(1)] needs special care; there-fore, it is recognized based on the size of circumscribed rectangle in advance of the classification process for the other strokes. 4 Combining the recognized strokes into a music symbol The next step is to combine the recognized strokes into a music symbol. This process is applied to each recog-nized stroke just after the time when recognition of the stroke is completed. The trivial method requires user X  X  direction; when all of the strokes from one symbol are entered, the user indicates so, and the computer can combine the strokes and output a music symbol as a result. This method increases the difficulty of the opera-tion. Intuitively, it appears that the strokes can be com-bined automatically when they form a specific music symbol. However, it is not that simple. Some symbols can be determined as the specific strokes are entered ( X  X eterminable symbols X ), but others cannot be ( X  X ncertain symbols X ). For example, a natural sym-bol is formed uniquely when two strokes, an LCheck and a NaturalRt, are entered as shown in Fig. 5a. On the other hand, a half note cannot be formed uniquely because it is unknown that how many WHeads or Dots will be entered in the following steps (see Fig. 5b).
Now,  X  X  X  and  X  X  X  represent a newly entered stroke and already entered strokes that have not been com-bined yet, respectively. In order to combine the strokes and output the symbol, the following methods based on the relative positions among the entered strokes are used: if (P exists){ P)){ bols){ the situation in Fig.7 bols){ able symbols){ # the situation in Fig.6 } else if (C coincides with one of the determinable sym-bols){ } else { } where  X  X eaningless symbol(*1) X  means that the sym-bol is not included in the prepared list shown in Table 1 and  X  X ar(*2) X  strictly means that the minimum horizon-tal distance between the bounding box for stroke(s) P and that for stroke C, is more than a certain threshold value d .

In this process, a specific combination of strokes is used for each music symbol shown in Table 1. For exam-ple, the data structure of an F clef symbol is defined as a determinable symbol that consists of one FClefArc and two Dots, and a half-note is defined as an uncer-tain symbol that consists of one or more WHead(s), one VLine, and zero or more Dots. Moreover, in order to permit a stroke distortion, some music symbols such as a sharp symbol have several possibility of combination of strokes.

In the Figs. 6 and 7, examples of the combining pro-cesses for a determinable symbol  X  X atural X  and an unc-ertain symbol  X  X alf-note X  are shown, respectively.
Suppose that a stroke LCheck is drawn in the first step as shown in Fig. 6a. Since this stroke does not coincide with any determinable symbols, the system does noth-ing. Next, a stroke NaturalRt is drawn. In this figure, the already entered stroke LCheck is denoted by  X  X  X  and the newly entered stroke NaturalRt is by  X  X , X  respec-tively. The strokes C and P are combined and outputted as a natural symbol since the strokes are satisfied with the following two conditions:  X  The stroke P exists.  X  C and P coincide with the determinable symbol Figure 7a shows the example in which WHead and VLine are drawn in the first step. They are denoted by  X  X . X  Next, a stroke Dot denoted by  X  X  X  is drawn. In this case, the system does nothing. In the next step shown in Fig. 7b, the already entered strokes are denoted by  X  X  X  and another WHead denoted by  X  X  X  is added. The strokes P are combined and outputted as a dotted half-note since the strokes are satisfied with the following three conditions:  X  The strokes P exist.  X  The stroke C is written far from all positions for the  X  The strokes P coincide with the uncertain symbol 5 Experimental results and discussion For these experiments, a PC (Pentium 4 CPU; 1.8GHz; 512MB memory) and an A4 tablet were used. Twenty-nine standard template chain codes for DP matching and 21 items shown in Table 1 for combining strokes were prepared. The threshold value d used for com-bining strokes was 0.7  X  (interval of staff lines), it was decided through preliminary experiments. SVMs were built with SVM light software [13]. Their various param-eters were set as the most suitable value through the experiment.
To build the SVM classifiers, 6,509 strokes, written by six users (who are not expert musicians and do not have any knowledge about this method), were used. For 7,292 strokes written by other five users, the recognition result for each stroke is shown in Table 2, where the  X  X ecall X  and  X  X recision X  are defined as follows: recall = precision = In general, the term  X  X ecognition rate X  means the recall rate. The  X  X op2 X  and  X  X op3 X  means the cumulative rec-ognition rate from the best two and three candidates, respectively. In this table, the total recognition rate of 91.40% was obtained when their time-series features ( X  X eature1 X  as shown in Table 2) were only used, the rate of 96.87% was obtained when the directional fea-tures ( X  X eature2 X  as shown in Table 2) were only used, and the rate of 97.49% was obtained when the both fea-tures were used. From this result, it is considered that the combination method provided satisfactory results. In particular, for the loop stroke WHead, it is difficult to recognize only used by their chain codes, but the recognition rate improved from 64.29 to 99.71% when the combination method was applied. Finally, when the recognition results for stroke Dot, 99.73% (= 373/374), were added, the total recognition rate for the strokes was 97.60%.

Table 2 shows that the combined recognition rates for certain strokes are lower than those of Feature1 (DP) or Feature2 (SVM). In particular for Slashes, the rec-ognition rate of Feature1 is 96.07% and the recognition rate of Feature2 is 90.45%, but the recognition rate of combined feature decreases to 85.67%. However, taking into account the fact that the precision rate of Feature1 was low (78.62%), many strokes were misclassified into Slash symbols in the recognition process, and it had bad effect on the other stroke classification. On the other hand, the precision rate of the combined method was 96.52%. With respect to the precision rate, it shows the performance was improved. It is desirable that both of the recognition rate (recall) and precision rate are high enough. Since the average precision rate for the com-bined method was 97.49% that is higher than the rates 92.14% for Feature1 and 96.87% for Feature2, it is con-sidered that the combined method is also much superior.
Table 3 shows the misclassified strokes and their per-centages, where the percentage for the i th misclassified stroke class is calculated as follows: False negative for the ith class True positive + False negative In this table, we can see that 13.76% of Slash symbols were misclassified as HLines and 9.46% of StLHook symbols were misclassified as LChecks. Apparently, they are difficult to discriminate. Although stroke recogni-tion has some errors, we can recover and correctly rec-ognize the symbol by using the combining method.
Moreover, to evaluate the robustness of the stroke recognition method, other 400 test strokes were also classified. These stroke shapes were intentionally de-formed by a test user. As a result, the top 1 recognition rate of 94.50% and the top 2 recognition rate of 98.25% were obtained. It is shown that our system can deal with patterns with the different cursive degrees.

Next, 250 music symbols including 637 strokes were written by one of the authors who did not create the learning patterns. As a result, two music symbols were deleted; one was improperly recognized; and the other 247 were recognized and combined appropriately (for the note symbol and accidentals, the relative position to the staff lines was also checked), which means that the recognition rate was 98.80%. The following errors were observed: (1) Two strokes that were not a part of a par-ticular symbol were combined because of their location; (2) Before the combining process began, the stroke rec-ognition process failed. However, the recognition rate was high enough. It was relatively easy to correct or redraw the errors.

We will consider the error case (1) in more detail. If the following conditions are satisfied:  X  the strokes P exist,  X  the stroke C is not written far from one of the posi- X  the strokes P and C coincide with one of the uncer- X  the stroke C belongs to a different music symbol the system miscombines C and P into a music symbol. For example, in order to input two quarter notes, a VLine, a BHead, a BHead and a VLine are written in this order. Ideally, the first quarter note consists of the first VLine and the first BHead, and the second note consists of the second BHead and the second VLine. But if the horizontal distance between the two BHeads is less than d , the second BHead is combined to the first quarter note. To solve this problem, the following solutions are considered:  X  When a user writes a different music symbol follow- X  We rebuild the combining process with taking into
In the combining process, a little distortion of the stroke was permitted. For this reason, the recognition rate for the symbols (98.80%) was higher than the rate for the strokes (97.60%). For example, ideally, the data structure of a sharp symbol is defined as a determinable symbol that consists of two Slashes and two VLines, but the stroke Slash may be substituted by a stroke HLine or UHook, so that some alternative data were prepared to adapt such distortion (see Table 1).

Figure 8 is an example of the system X  X  output. The staff lines are prewritten. As the strokes are drawn in the upper window, the symbols are automatically displayed in the bottom window as soon as the recogni-tion and combining processes are completed.

Next, we will consider the response time of the rec-ognition process. The interval time between a stroke is completely entered (i.e., the pen is up) and a result is outputted on a computer display (i.e., next stroke can be entered), can be calculated by adding of the following two times: 1. Time required for recognition of the entered stroke 2. Time required for displaying the result on a com-For the same 250 music symbols used as the test patterns, the times of the above items 1 and 2 were measured. As a result, the average times of the items 1 and 2 were 71.9 and 1.2 ms, respectively, and the average total response time was 73.1 ms. Therefore, a user hardly needs to wait while entering symbols.

To evaluate the usability of our system, the writing method is considered. In the traditional methods [7,8], almost all music symbols are written not in accordance with the conventional music notation, so that a user have to learn how to draw all of the symbols, while our sys-tem allows a user to draw symbols with the conventional music notation, except for filled note heads. Although taking into account the fact that a user must learn a few writing rules of our system, it is obvious that the usabil-ity of our system is superior to that of the traditional methods at least for beginners. 6 Conclusion To obtain a high rate of recognition for handwritten music symbols and good user interface that permits handwriting, the following methods were proposed: (1) The classification of the strokes was performed by SVM based on the output values of two methods. One is DP matching, which uses time-series data, and the other is SVM, which uses the directional features of a stroke im-age. (2) The strokes for each symbol are efficiently com-bined and automatically outputted as a music symbol. For 7,666 test strokes and 250 test symbols, recognition rates of 97.60 and 98.80% were obtained, respectively. The average response time of the recognition process for one stroke was 73.1 ms. The results indicate that the method is practical.
The proposed method suggests that time-series data can be transformed into input patterns for an SVM clas-sifier. For an SVM classifier, in general, the lengths of input patterns have to be the same, so that various length patterns like time-series data can not be treated. But, DP matching can transform time-series data into fixed length data and an SVM can treat them.

The future works are as follows:  X  It has been shown that the proposed system can eas- X  In response to the progress of drawing strokes, music  X  The feature extraction method by DP matching for  X  The proposed system combines the strokes using References
