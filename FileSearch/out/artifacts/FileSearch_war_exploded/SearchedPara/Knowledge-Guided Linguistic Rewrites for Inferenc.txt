 The visions of machine reading (Etzioni, 2007) and deep language understanding (Dorr, 2012) empha-size the ability to draw inferences from text to dis-cover implicit information that may not be explic-itly stated (Schubert, 2002). This has natural appli-cations to textual entailment (Dagan et al., 2013), KB completion (Socher et al., 2013), and effective querying over Knowledge Bases (KBs).

One popular approach for fact inference is to use a set of inference rules along with proba-bilistic models such as Markov Logic Networks (Schoenmackers et al., 2008) or Bayesian Logic Pro-grams (Raghavan et al., 2012) to produce human-interpretable proof chains. While scalable (Niu et al., 2011; Domingos and Webb, 2012), this is bound by the coverage and quality of the back-ground knowledge  X  the set of inference rules that enable the inference (Clark et al., 2014).

The paper focuses on generating a high preci-sion subset of inference rules over Open Informa-tion Extraction (OpenIE) (Etzioni et al., 2011) rela-tion phrases (see Fig 1). OpenIE systems generate a schema-free KB where entities and relations are rep-resented via normalized but not disambiguated tex-tual strings. Such OpenIE KBs scale to the Web.
Most existing large-scale corpora of inference rules are generated using distributional similarity, like argument-pair overlap (Schoenmackers et al., 2010; Berant et al., 2012), but often eschew any lin-guistic or compositional insights. Our early analysis revealed that such inference rules have very low pre-cision, not enough to be useful for many real tasks. For human-facing applications (such as IE-based de-mos), high precision is critical. Inference rules have a multiplicative impact, since one poor rule could potentially generate many bad KB facts.
 Contributions: We investigate the hypothesis that  X  X nowledge-guided linguistic rewrites can provide independent verification for statistically-generated Open IE inference rules. X  Our system K GLR  X  X  rewrites exploit the compositional structure of Open IE relation phrases alongside knowledge in re-sources like Wordnet and thesaurus. K GLR inde-pendently verifies rules from existing inference rule corpora (Berant et al., 2012; Pavlick et al., 2015) and can be seen as additional annotation on exis-ting inference rules. The verified rules are 27 to 33 points more accurate than the original corpora and still retain a substantial recall. The precision of inferred knowledge also has a precision boost of over 29 points. We release our K GLR imple-mentation, its annotations on two popular rule cor-pora along with gold set used for evaluation and the annotation guidelines for further use (available at https://github.com/dair-iitd/kglr.git ). Methods for inference over text include random walks over knowledge graphs (Lao et al., 2011), matrix completion (Riedel et al., 2013), deep neu-ral networks (Socher et al., 2013; Rockt  X  aschel et al., 2015a), natural logic inference (MacCartney and Manning, 2007) and graphical models (Schoen-mackers et al., 2008; Raghavan et al., 2012). Most of these need (or benefit from) a background knowl-edge of inference rules, including matrix completion (Rockt  X  aschel et al., 2015b).

Inference rules are predominantly generated via extended distributional similarity  X  two phrases hav-ing a high degree of argument overlap are simi-lar, and thus candidates for a unidirectional or a bidirectional inference rule. Methods vary on the base representation, e.g., KB relations (Gal  X  arraga et al., 2013; Grycner et al., 2015), Open IE rela-tion phrases (Schoenmackers et al., 2010), syntactic-ontological-lexical (SOL) patterns (Nakashole et al., 2012), and dependency paths (Lin and Pantel, 2001). An enhancement is global transitivity (TNCF algo-rithm) for improving recall (Berant et al., 2012). The highest precision setting of TNCF (  X  = 0 . 1 ) was released as a corpus (informally called C LEAN ) of
Distributional similarity approaches have two fundamental limitations. First, they miss obvious commonsense facts, e.g.,  X  (X, married, Y)  X  (X, knows, Y)  X   X  text will rarely say that a couple know each other. Second, they are consistently affected by statistical noise and end up generating a wide variety of inaccurate rules (see rules #4, and #5 in Figure 1). Our early experiments with C LEAN revealed its pre-cision to be about 0.49, not enough to be useful in practice, especially for human-facing applications.
Similar to our paper, some past works have used alternative sources of knowledge. Weisman et al. (2012) study inference between verbs (e.g.,  X  startle  X  surprise  X  ), but they get low (0.4) precision. Wordnet corpus to generate inference rules for nat-ural logic (Angeli and Manning, 2014) improved noun-based inference. But, they recognize relation entailments as a key missing piece. Recently, nat-ural logic semantics is added to a paraphrase cor-pus (PPDB2.0). Many of their features, e.g., lexi-cal/orthographic, multilingual translation based, are complimentary to our method.

We test our K GLR algorithm on C LEAN and en-tailment/paraphrase subset of PPDB2.0 (which we call PPDB e ). Given a rule  X  (X, r 1 , Y)  X  (X, r 2 , Y)  X  or  X  (X, r 1  X  (Y, r 2 , X)  X  we present K GLR , a series of rewrites of relation phrase r 1 to prove r 2 (examples in Fig 1). The last two rewrites deal with reversal of argument order in r 2 ; others are for the first case. Thesaurus Synonyms : Thesauri typically provide an expansive set of potential synonyms, encompass-ing near-synonyms and contextually synonymous words. Thesaurus synonyms are not that helpful for generating inference rules (or else we will generate rules like  X  produce  X  percolate  X  ). However, they are excellent in rule verification as they provide evi-dence independent from statistical overlap metrics.
We allow any word/phrase w 1 in r 1 to be replaced by any word/phrase w 2 from its thesaurus synsets as long as (1) w 2 has same part-of-speech as w 1 and (2) w 2 is seen in r 2 at the same distance from left of the phrase as w 1 in phrase r 1 , but ignoring words dropped due to other rules whose details follows next. To define a thesaurus synset, we tag w 1 with its POS and look for all thesaurus synsets of that POS containing w 1 . We allow this rewrite if PMI( w 1 ,w 2 ) &gt;  X  (=-2.5 based on a devset). We calculate PMI as Some words can be both synonyms and antonyms in different situations. For example, thesaurus lists  X  X ad X  as both a synonym and antonym of  X  X ood X . We don X  X  allow such antonyms in these rewrites.
Thesarus synonyms can verify  X  offer a vast range of  X  provide a wide range of  X  , since offer-provide, and vast-wide are thesaurus synonyms. We use Ro-get X  X  21 st Century Thesaurus in K GLR implementa-tion.
 Negating rules : We reject rules where r 2 explicitly negates r 1 or vice versa. We reject a rule if r 2 is same as r 1 if we drop  X  X ot X  from one of them. For example, the rule  X  be the president of  X  be not the president of  X  , will be rejected.
 Wordnet Hypernyms : We replace word/phrase w in r 1 by its Wordnet hypernym if it is in r 2 . We prove  X  be highlight of  X  be component of  X  , as Wordnet lists  X  X omponent X  as a hypernym of  X  X ighlight X . Dropping Modifiers: We drop any adjective, ad-verb, superlatives or comparatives (e.g.,  X  X ore X ,  X  X ost X ) from r 1 . This lets us verify  X  be most im-portant part of  X  be part of  X  .
 Gerund-Infinitive Equivalence: We convert infini-tive constructions into gerunds and vice versa. For example,  X  starts to drink  X  starts drinking  X  . Deverbal Nouns: We use Wordnet X  X  derivationally related forms to compute a verb-noun pair list. We allow back and forth conversions from  X  X e noun of X  to related verb. So, we verify  X  be cause of  X  cause  X  . Light Verbs and Serial Verbs: If a light verb precede a word with derivationally related noun sense, we delete it. Similarly, if a serial verb precede a word with derivationally related verb sense, we delete it. We identify light verbs via the verbs that fre-quently precede a  X  ( a | an) (verb | deverbal noun)  X  pair in Wikipedia. Serial verbs are identified as the verbs that frequently precede another verb in Wikipedia. Thus we can convert  X  take a look at  X  look at  X  . Preposition Synonyms: We manually create a list of preposition near-synonyms such as into-to, in-at, at-near. We replace a preposition by its near-synonym. This proves  X  translated into  X  translated to  X  . Be-Words &amp; Determiners: We drop be-words ( X  X s X ,  X  X as X ,  X  X e X , etc.) and determiners from r 1 and r 2 . Active-Passive: We allow (X, verb , Y) to be rewrit-ten as (Y, be verb by , X).
 Redundant Prepositions: We find that often prepo-sitions other than  X  X y X  can be alternatively used with passive forms of some verbs. Moreover, some prepositions can be redundantly used in active forms too. For example,  X  (X, absorb, Y)  X  (Y, be absorbed in , X)  X  , or similarly,  X  (X, attack, Y)  X  (X, attack on , Y)  X  . To create such a list of verb-preposition pairs, we simply trust the argument-overlap statis-tics. Statistics here does not make that many errors since the base verb in both relations is the same. 3.1 Implementation K
GLR allows repeated application of these rewrites to modify r 1 and r 2 . If it achieves r 1 = r 2 it ver-ifies the inference rule. For tractable implementa-tion K GLR uses a depth first search approach where a search node maintains both r 1 and r 2 . Search does not allow rewrites that introduce any new lexi-cal (lemmatized) entries not in original words( r 1 )  X  words( r 2 ). If it can X  X  apply any rewrite to get a new node, it returns failure.
 Many rules are proved by a sequence of rewrites. E.g., to prove  X  (X, be a major cause of, Y)  X  (Y, be caused by, X)  X  , the proof proceeds as: (X, be a ma-jor cause of, Y)  X  (X, be major cause of, Y)  X  (X, be cause of, Y)  X  (X, cause, Y)  X  (Y, be caused by, X) by dropping determiner, dropping adjective, deverbal noun, and active-passive transformation re-spectively. Similarly,  X  (X, helps to protect, Y)  X  (X, look after, Y)  X  follows from gerund-infinitive con-version (helps protect), dropping support from serial verbs (protect), and thesaurus synonym (look after). K GLR verifies a subset of rules from C LEAN and PPDB e to produce, VC LEAN and V PPDB e . Our ex-periments answer these research questions: (1) What is the precision and size of the verified subsets com-pared to original corpora?, (2) How does additional knowledge generated after performing inference us-ing these rules compare with each other? and (3) Which rewrites are critical to K GLR performance? Comparison of C LEAN and VC LEAN : The orig-inal C LEAN corpus has about 102K rules. K GLR verifies about 36K rules and filter 66K rules out. To estimate the precisions of C LEAN and VC LEAN we independently sampled a random subset of 200 in-ference rules from each and asked two annotators (graduate level NLP students) to label the rules as correct or incorrect. Rules were mixed together and the annotators were blind to the system that gen-erated a rule. Our initial annotation guideline was similar to that of textual entailment  X  label a rule as correct if the consequent can usually be inferred given the antecedent, for most naturally occurring argument-pairs for the antecedent.

Our annotators faced one issue with the guide-line  X  some inference rules were valid if (X,Y) were bound to specific types, but not for others. For exam-ple,  X  (X, be born in, Y)  X  (Y, be birthplace of, X)  X  is valid if Y is a location, not if Y is a year. Even seem-ingly correct inference rules, e.g.,  X  (X, is the father of, Y)  X  (Y, is the child of, X)  X  , can make unusual incorrect inferences: (Gandhi, is the father of, India) does not imply (India, is the child of, Gandhi). Un-fortunately, these corpora don X  X  associate argument-type information with their inference rules.
To mitigate this we refined the annotation guide-lines to accept inference rules as correct as long as they are valid for some type-pair. The inter-annotator agreement with this modification was 94% (  X  = 0.88). On the subset of the tags where the two annotators agreed we find the precision of C LEAN to be 48.9%, whereas VC LEAN was evaluated to be 82.5% precise  X  much more useful for real-world applications. Multiplying the precision with their 50K compared to 30K for VC LEAN . Overall, we find that VC LEAN obtains a 33 point precision im-provement with an effective yield of about 60%.
Error Analysis: Most of VC LEAN errors are due to erroneous (or unusual) thesaurus synonyms. For missed recall, we analyzed C LEAN  X  X  sample missed by VC LEAN . We find that only about 13% of those are world knowledge rules (e.g., rule #6 in Figure 1). Other missed recall is because of some missing rewrites, missing thesaurus synonyms, spelling mis-takes. These can potentially be captured by using other resources and adding rewrite rules.
 Comparison of PPDB e and V PPDB e : Unlike C
LEAN , PPDB2.0 associates a confidence value for each rule, which can be varied to obtain different levels of precision and yield. We control for yield so that we can compare precisions directly.

We operate on PPDB e subset that has an Open IE-like relation phrase on both sides; this was identified by matching to ReVerb syntactic patterns (Etzioni et al., 2011). This subset is of size 402K. K GLR on this produces 85K verified rules (V PPDB e ). We find the threshold for confidence values in PPDB e that achieves the same yield (confidence &gt; 0.342). We perform annotation on PPDB e (0.342) and V PPDB e using same annotation guidelines as before. The inter-annotator agreement was 91% (  X  = 0.82). On the subset of the tags where the two annotators agreed we find the precision of PPDB e to be low  X  44.2%, whereas V PPDB e was evaluated to be 71.4% precise. We notice that about 4 in 5 PPDB rela-tion phrases are of length 1 or 2 (whereas 50% of CLEAN relation phrases are of length  X  3). This contributes to a slightly lower precision of V PPDB e , as most rules are proved by thesaurus synonymy and the power of K GLR to handle compositionality of longer relation phrases does not get exploited. Comparison of Inferred Facts: A typical use case of inference rules is in generating new facts by applying inference rules to a KB. We indepen-dently apply VC LEAN  X  X , C LEAN  X  X , PPDB e  X  X  and V
PPDB e  X  X  inference rules on a public corpus of 4.2 nificant extraction errors (our estimate is 20% er-rors) and our goal is to evaluate the quality of in-ference, we restrict this evaluation to only the subset of accurate ReVerb extractions.

VC LEAN and C LEAN facts: We sampled about 200 facts inferred by VC LEAN rules and C LEAN rules each (applied over accurate ReVerb extrac-tions) and gave the original sentence as well as inferred facts to two annotators. We obtained a high inter-annotator agreement of 96.3%(  X  = 0.92) and we discarded disagreements from final analysis. Overall, facts inferred by C LEAN achieved a preci-sion of about 49.1% and those inferred by VC LEAN obtained a 81.6% precision. The estimated yields of fact corpora (precision  X  size) are 7 and 4.5 million for C LEAN and VC LEAN respectively. This yield estimate does not include the initial 4.2 million facts.
PPDB e and V PPDB e facts: As done previously, we sampled 200 facts inferred by PPDB e and V
PPDB e rules, which were annotated by two anno-tators. We obtained a good inter annotator agree-ment of 90.0%(  X  = 0.8) and we discarded disagree-ments from final analysis. Overall, facts inferred by PPDB e achieved a really poor precision -22.2% and those inferred by V PPDB e obtained an improvement of about 29 points (51.3% precision). Short relation phrases (mostly of length 1 or 2, which forms 80% of PPDB e ) contribute to low precision of V PPDB e . Example low precision V PPDB e rules include  X  (X, be, Y)  X  (X, obtain, Y)  X  ,  X  (X, include, Y)  X  (X, come, Y)  X  , which were inaccurately verified due to thesaurus errors. The estimated yields of fact cor-pora are 41 million and 35 million for PPDB e and V PPDB e respectively.
 Ablation Study of K GLR rewrites: We evaluate the efficacy of different rewrites in K GLR by per-forming an ablation study (see Table 3). We ran K GLR by turning off one rewrite on a sample of 600 C
LEAN rules (our development set) and calculating its precision and recall. The ablation study high-lights that most rewrites add some value to the per-formance of K GLR , however Antonyms and Drop-ping modifiers are particularly important for preci-sion and Active-Passive and Redundant Preposition add substantial recall. K
GLR  X  X  value is in precision-sensitive tasks such as a human-facing demo, or downstream NLP applica-tion (like question answering) where error multipli-cation is highly undesirable. Along with high preci-sion, it still obtains acceptably good yield.
Our annotators observe the importance of type-restriction of arguments for inference rules (similar to rules in (Schoenmackers et al., 2010)). Type an-notation of existing inference rule corpora is an im-portant step for obtaining high precision and clarity.
Inference rules are typically of two types  X  lin-guistic/synonym rewrites, which are captured by our work, and world knowledge rules (see rule #6 in Fig 1), which are not. We were surprised to estimate that about 87% of C LEAN , which is a statistically-generated corpus, is just linguistic rewrites! Ob-taining world knowledge or common-sense rules at high precision and scale continues to be the key NLP challenge in this area. We present Knowledge-guided Linguistic Rewrites (K GLR ) which exploits the compositionality of rela-tion phrases, guided by existing knowledge sources, such as Wordnet and thesaurus to identify a high pre-cision subset of an inference rule corpus. Validated C
LEAN has a high precision of 83% (vs 49%) at a yield of 60%. Validated PPDB e has a precision of 71% (vs 44%) at same yield. The precision of in-ferred facts has about 29-32 pt precision gain. We expect K GLR to be effective for precision-sensitive applications of inference. The complete code and data has been released for the research community. Acknowledgments: We thank Ashwini Vaidya and the anonymous reviewers for their helpful sugges-tions and feedback. We thank Abhishek, Aditya, Ankit, Jatin, Kabir, and Shikhar for helping with the data annotation. This work was supported by Google language understanding and knowledge dis-covery focused research grants to Mausam, a KISTI grant and a Bloomberg grant also to Mausam. Prachi was supported by a TCS fellowship.
