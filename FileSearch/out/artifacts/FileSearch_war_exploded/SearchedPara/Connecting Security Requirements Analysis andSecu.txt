 When building secure systems , it is instrumental to take security requirements into account right from the beginning of the development process to reach the best possible match between the expressed r equirements and the developed soft-ware product, and to eliminate any source of error as early as possible. Knowing that building secure systems is a highly sensitive process, it is important to reuse the experience of commonly encountered challenges in this field. This idea of using patterns has proved to be of value in software engineering, and it is also a promising approach in secure software engineering .Moreover, tool support greatly increases the practical applicability of secure software engineering ap-proaches. Tools not only guide software developers in their daily activities, they also help to make the construction of com plex secure systems feasible and less error-prone.

In fact, there already exist a number of approaches to security requirements analysis and secure design. Although this can be considered a positive develop-ment, the different approaches are mostly not integrated with each other. In par-ticular, relatively little work has been done on bridging the gap between security requirements analysis and design, and existing approaches only provide informal guidelines for the transition from security requirements to design. Carrying out the transition manually at the hand of these guidelines is highly non-trivial and error-prone, which leaves the risk of inadvertently introducing vulnerabilities in the process. Ultimately, this would lead to the security requirements not to be enforced in the system design (and later its implementation).

This paper presents an integrated and pattern-oriented approach connecting security requirements analysis and secu re architectural design. We use a security requirement analysis method [14] that makes extensive use of different kinds of patterns for structuring, characterizing, analyzing, and finally realizing security requirements. We extend this approach by architectural security patterns to con-struct platform-independent secure software architectures that realize previously specified security requirements. We speci fy structural and behavioral views of these architectural s ecurity patterns using UML 1 ( Unified Modeling Language ) class diagrams , composite structure diagrams ,and sequence diagrams .Wean-notate these diagrams based on an improved version of the security extension UMLsec [8] named UMLsec4UML2 [15] to represent results from security re-quirements analysis in the a rchitectural security patte rns. More specifically, we apply the advanced modeling possibilities of UML2.3 and UMLsec4UML2 to architectural design to construct the architectural security patterns presented in this paper. Moreover, our approach allows the tool-supported analysis of in-stances of these patterns with respect to security.

The rest of the paper is organized as follows: we present background about the patterns for security requirements engineering in Sect. 2. In Sect. 3, we first give an overview of the UMLsec4UML2-profile that adopts UMLsec to support UML2.3. Then, we use this profile to specify security patterns for software com-ponents and architectures. Furthermore, we generally discuss the application of these patterns yielding global secure so ftware architectures. In Sect. 4, we vali-date our approach using two case studies and illustrate its support for Common Criteria certifications. W e consider related work in Sect. 5. In Sect. 6, we give a summary and directions for future research. SEPP ( Security Engineering Process using Patterns ) (see [14] for a comprehen-sive overview) is a pattern-based approac h to construct secure software systems that especially deals with the early sof tware development phases. SEPP makes use of security problem frames (SPF) and concretized security problem frames (CSPF), which constitute patterns for security requirements analysis. (C)SPFs are inspired by problem frames invented by Jackson [7] for functional require-ments. SPFs are patterns for structuring, characterizing, and analyzing prob-lems that occur frequently in secure soft ware engineering. Following the divide &amp; conquer principle, SPFs are used to decompose an initially large software de-velopment problem into smaller subproblems. Then, for each instantiated SPF, a CSPF is selected and instantiated. CSPFs involve first solution approaches for the problems described by SPFs. For example, there exists an SPF for the problem class of confidential transmission of data over an insecure network, and a CSPF that represents the corresponding solution class of using cryptographic key-based symmetric encryption to protect such data transmissions.

Each CSPF contains a machine domain , which represents the software to be developed in order to fulfill the requirement . The environment, in which the software development problem is located, is described by problem domains .Ac-cording to Jackson [7], we distinguish causal domains that comply with some physical laws, lexical domains that are data representations, and biddable do-mains that are usually people. Each domain has at least one interface . Interfaces consist of shared phenomena , which may be events, operation calls, messages, and the like. They are observable by at least two domains, but controlled by only one domain. Since requirements refer to the environment, requirement references between the domains and the requirement e xist. At least one of these references is a constraining reference. That is, the domain this constraining references points to is influenced by the machine so that the requirement can be fulfilled. We developed a comprehensive set of SPFs for confidential and integrity-preserving data transmission and data storage, and authentication problems and the cor-responding CSPFs that use symmetric an d asymmetric encryption, keyed and non-keyed hashing, digital signatures, password-based and cryptographic key-based mechanisms (see [14] for details). This section contains the main scientifi c contributions of this paper. To proceed after security requirements analysis fo llowing SEPP to the development of secure software architectures that realize the s ecurity requirements, we develop in this section architectural security patterns . We specify these patterns using UML and an improved version of the security ex tension UMLsec, which is introduced in Sect. 3.1. We describe patterns for s ecurity components in Sect. 3.2, and we present patterns for secure software arch itectures related to CSPFs in Sect. 3.3. In Sect. 3.4, we briefly explain the process of instantiating GSAs. Then, we discuss the composition of different ins tances of GSAs yielding global secure software architectures in Sect. 3.5. Finally, we outline an approach to verify global secure software architectures based on the UMLsec4UML2-profile and the UMLsec tool suite in Sect 3.6. 3.1 UMLsec4UML2 In this section, we present an overview of a notation for the specification of structural as well as behavioral views of architectural security patterns based on UML. As explained in [11], UML includes special support for modeling software architectures since version 2.0. For example, the current UML version 2.3 sup-ports typical architect ural concepts such as parts , i.e., black-box components, connectors ,and required and provided interfaces (see Sects. 3.2 and 3.3 for de-tails). For this reason, we specify our arc hitectural securi ty patterns based on different kinds of UML2.3 diagram types, i.e., class diagrams, composite struc-ture diagrams, and sequence diagrams. Moreover, we use UMLsec [8] to pick up results from security requirements anal ysis, and to annotate the different UML diagrams representing the structural and behavioral views of architectural secu-rity patterns accordingly. Since UMLsec is a profile for UML1.5 2 , we developed a UML2.3-compatible profile called UMLsec4UML2 that adopts the UML1.5-compatible profile UMLsec. The UMLsec4 UML2-profile, all examples shown in this paper, as well as additional material are published in a technical report [15].
We constructed the UMLsec4UML2-profile using the Papyrus UML 3 editing tool. as a UML2.3 profile diagram. It defines several stereotypes and tags .Stereo-types give a specific meaning to the elements of a UML diagram they are attached to, and they are represented by labels surrounded by double angle brackets. A tag or tagged value is a name-value pair in curly brackets associating data with elements in a UML diagram.

The original version of UMLsec for UML1.5 is complemented by a tool suite 4 that supports static checks for stereotypes that restrict structural design models, a permission analyzer for access control me chanisms, and checks integrated with external verification tools to verify ster eotypes that restric t behavioral design models. Basically, models created based on the UMLsec4UML2-profile can be verified using this tool suite. However, the UMLsec4UML2-profile introduces a novel way to verify models directly within the UML editing tool. For this purpose, the UMLsec4UML2-profile is enriched with constraints denoted in the Object Constraint Language (OCL) 5 , which is part of UML2.3. OCL is a formal notation to describe constraints on object-oriented modeling artifacts. The static checks available in the tool suite of the original version of UMLsec are covered by the OCL constraints that are integrated into the UMLsec4UML2-profile.
We use the UMLsec4UML2-profile in the subsequent sections to specify struc-tural as well as behavioral views of archit ectural security patterns. There, we also explain details about the profile where necessary. 3.2 Generic Security Components The generic security components (GSC)discussedinthissectionconstitutepat-terns for software components that realiz e concretized securi ty requirements. We call them  X  X eneric X , because they are a k ind of conceptual pattern for concrete software components. They are platform-independent 6 .AnexampleforaGSC is an encryption component defined neith er referring to a specific encryption al-gorithm nor cryptographic keys with a certain structure and length. In addition to GSCs, generic non-security components (GNC) are necessary, which do not realize any security requirements. Instead, they represent auxiliary components for GSCs. Typical examples for GNCs ar e user interface, driver, and storage management components.

According to [16], the arc hitecture of software is multifaceted: there exists a structural view, a process-oriented view , a function-oriented view, an object-oriented view with classes and relations, and a data flow view on a given software architecture. Hence, we specify each GS C and GNC based on a structural view using UML2.3 class and composite structure diagrams, and control and data flow views using UML2.3 sequence diagrams. We make required and provided inter-faces of GSCs and GNCs explicit using sockets, lollipops, and interface classes. After GSCs are instantiated, the process-oriented and object-oriented views can be integrated seamlessly into the struct ural view. Semantic descriptions of the operations provided and used by the comp onents X  interfaces can be expressed as OCL pre-and postconditions.
 We use GSCs and GNCs to structure the machine domain of a CSPF. The GSCs and GNCs describe the machine X  X  i nterfaces to its environment and the machine-internal interfaces, i.e., th e interfaces between the GSCs and GNCs. Each CSPF is related to a set of GSCs and GNCs.
 Given a CSPF, the following procedure can be applied to construct GSCs and GNCs that help to realize the concreti zed security requirement of the CSPF: 1. Each interface of the machine with the environment must coincide with an 2. GSCs and GNCs that serve the same purpose can be represented by one such 3. For each interface between the machine and a biddable or display domain 4. For each interface from the machine to a lexical domain, a storage manage-5. For each interface of the machine domain with a causal domain, a driver com-6. GSCs adequate to realize the concre tized security requirement should be We enrich GSCs with UMLsec4UML2 lang uage elements to express security properties based on the CSPFs the GSCs are related to. Since each CSPF con-siders at least one asset to be protected against the malicious environment, these assets should be considered by the GSCs a ssociated to the CSPF. Consequently, we equip the GSCs dealing with the assets with the stereotype critical , and we assign values (e.g., in terms of attributes, parameters, return values, etc.) to the tags of this stereotype accordingly. In case of an asset to be kept confi-dential , we assign this asset to the { secrecy } tag, and in case of preserving the integrity of an asset, we assign this asset to the { integrity } tag.
According to the described procedure, we have developed catalogs (see [14, pp. 150 ff.] for details) of GSCs and GNCs for each available CSPF. For instance, there exist GSCs for keyed and non-keyed hash processing, calculation of random numbers, digital signature processing, etc. In the following, we present the GSC SymmetricEncryptorDecryptor as an example.
 GSC SymmetricEncryptorDecryptor. The SymmetricEncryptorDecryptor is a conceptual pattern for a component tha t provides symmetric encryption and decryption services (see [12, pp. 59 ff.] for details). Concrete implementations of symmetric encryption and decryption algorithms are, e.g., the javax.crypto.Cipher class provided by SUN X  X  Java 6 Standard Edition 7 ,the encryption.pbe.Standard-PBEStringEncryptor class provided by Jasypt 8 ,andthe crypto.engines class provided by Bouncycastle 9 .

Figure 1 shows the structural view of this GSC using a class diagram and a composite structure diagram. The first diagram defines the type of the port used in the second diagram. Moreover, the first diagram explicates the provided interface of the GSC. For reasons of simplicity, we do not present the GSC X  X  behavioral view here.

The GSC SymmetricEncryptorDecryptor abstracts from algorithm-specific de-tails such as cryptographic key lengths, the stream and block modes of the algorithms, and so on. Instead, the SymmetricEncryptorDecryptor component is de-signed to represent the essence of symmetr ic encryption and decr yption services, i.e., the usage of the same cryptographic key for encryption and decryption. The SymmetricEncryptorDecryptor provides the interface SEncDecIf , which contains an operation encrypt() to symmetrically en crypt a plaintext pt using a crypto-graphic key ck . The result is a ciphertext ct . Additionally, it provides an inverse operation decrypt() that calculates the plaintext pt given the ciphertext ct and the cryptographic key ck , which has to be equal to the cryptographic key used for the encryption process. This relation betw een the encryption and decryption func-tions can be formally expressed as follows:  X  pt : Data ; ck : CryptographicKey | decrypt ( encrypt ( pt , ck ) , ck )= pt .WeequiptheGSC SymmetricEncryptorDecryp-tor with the stereotype critical , and we assign the plaintext pt to the tag { secrecy } , since the goal of this GSC is to keep the plaintext confidential.
In the next section, we explain how different GSCs and GNCs are combined to obtain patterns for secure software architectures related to CSPFs. 3.3 Generic Security Architectures We combine the GSCs and GNCs constru cted or selected for a given CSPF to obtain generic security architectures (GSA). Such a GSA represents the struc-ture of the machine domain of the CSPF. Since GSCs and GNCs are platform-independent, so are GSAs. Based on the connection of CSPFs and GSAs, trace-ability links are introduced. Hence, our approach allows to understand which security requirements are realized by th e different parts of a software architec-ture. This improves the maintainability of the software. Similar to GSCs and GNCs, we specify GSAs based on structural views using UML2.3 composite structure diagrams, and control and data flow views using UML2.3 sequence diagrams. The structural as well as the behavioral views of GSAs comprise the composed views of the GSCs and GNCs they consist of. We construct GSAs according to the following procedure: 1. An adequate basic software architecture to connect the GSCs and GNCs has 2. If components can be connected dir ectly, one connects these components. 3. If components cannot be connected dir ectly (e.g., becaus e a component pro-4. Interfaces between the machine and its environment must be designed in the We enrich GSAs with UMLsec4UML2 lang uage elements to express security properties based on the CSPFs the GSAs are related to. We apply the stereotype secure dependency to the specification of the structural views of GSAs according to the following procedure: 1. The structural view of a GSA should be organized in a package stereotyped 2. As described in Sect. 3.2, GSCs refer to assets, and they are already equipped 3. use dependencies between components stereotyped critical in Moreover, the behavioral views of GSAs are equipped with the data se-curity stereotype. Given a package stereotyped data security contain-ing a structure and a behavior diagram, the requirements defined in the structure diagram using the critical stereotype should be fulfilled with respect to the behavior diagram and environment description (especially the malicious envi-ronment and the value of the tag { adversary } ). We apply the stereotype data security to the specification of the behavioral views of GSAs according to the following procedure: 1. The behavioral view should be organized in a package stereotyped data 2. The structural view previously discussed should be reused by importing the 3. A specification in terms of a set of sequence diagrams should be included 4. The attacker model, i.e., especially the { adversary } tag, is not assigned According to the described procedures , we have developed a catalog of GSAs (see [14, pp. 160 ff.] for details) for each available CSPF.
 GSA for CSPF Confidential Data Tra nsmission Using Cryptographic Key-Based Symmetric Encryption. In the following, we present as an example a GSA for the machine domain of the CSPF confidential data trans-mission using cryptographic key-based symmetric encryption. Figure 2 shows the structural view of the GSA using a composite structure diagram. The Sender device. Hence, we introduce the GNC StorageManager to access a storage device. The Sent data domain is encrypted using the Cryptographic key 1 domain. For this reason, we introduce the GSC SymmetricEncryptorDecryptor presented in Sect. 3.2. Furthermore, the Sender machine domain sends the encrypted data to the Com-munication medium domain. Hence, we introduce the GNC CommunicationManager to access a network.

AccordingtotheCSPFthisGSAi s related to, the plaintext pt represented in the CSPF as lexical domain Sent data should be kept confidential. Hence, the GSC SymmetricEncryptorDecryptor and the GNC Application that makes use of this GSC are stereotyped critical . Furthermore, the { secrecy } tag is assigned the plaintext pt ,andthe use dependency between the GSC SymmetricEncryptor-Decryptor and the GNC Application is stereotyped secrecy .

The overall behavior of the GSA is depicted in Fig. 3. Initially, the locations of the plaintext pt (that corresponds to the Sent data domain) and the crypto-graphic key ck (that corresponds to the Cryptographic key 1 domain) are known, and they are retrieved from a storage device using the GNC StorageManager . Then, the ciphertext is constructed by the GSC SymmetricEncryptorDecryptor .Fi-nally, the GNC CommunicationManager sends the ciphertext to a network. Both the structural as well as the behavioral views are contained in a package (not explicitly depicted in this paper) stereotyped data security .

In the next section, we discuss the instantiation of GSAs. 3.4 Instantiation of GSAs GSAs are instantiated based on the corresponding CSPF instances. The selec-tion process for GSAs is heavily intertwined with the (security) requirements engineering phase and described in detail in [6]. An application layer compo-nent should have a name that equals the name of the machine domain of the corresponding CSPF instance. Moreover , the interfaces between a GSA and the environment should be named after the domains of the corresponding CSPF instance. The names of shared phenomena of the CSPFs should be re-used for the instantiation of the messages contained in the sequence diagrams of the be-havioral views of the corresponding GS As. Thus, each component contained in a GSA is instantiated, too.

The CSPF instance that constitutes the basis for a GSA instance includes an environment description in terms of p roblem domains, interfaces in between, and domain knowledge. This information is used to construct an attacker model based on the UMLsec4UML2-stereotype secure links . Given a package stereotyped secure links with the tagged value { adversary=default } containing a deployment diagram with a dependency stereotyped secrecy (or / and integrity or / and high ) between two nodes, these nodes should be either connected via a co mmunication path stereotyped LAN or encrypted or wire (but not Internet ) or labeled LAN .We now explain how we use the secure links stereotype to co nstruct an at-tacker model based on the instantiated CSPFs: 1. An environment description in terms of a deployment diagram should be 2. Each machine domain, lexical domain, and causal domain should be modeled 3. The physical connections between no des should be modeled as communica-4. The tag { adversary } of the secure links stereotype should be as-5. The tag { adversary } of the data security stereotype of the behav-In the next section, we show how differen t GSA instances are combined yielding global secure software architectures. 3.5 Composition of Different GSA Instances Composing different GSA instances means that one must decide whether the components contained in more than one GSA instance should appear only once in the global architecture, i.e., whether they can be merged. Basically, three different categories of components must be considered: application layer compo-nents, GNC instances, and GSC instances.

Choppy et al. [2] developed for a set of functional subproblem classes a cor-responding set of subarchitectures that solve these subproblems. Moreover, the subarchitectures are composed based on dependencies between the subproblems such as parallel, sequential, and alternative dependencies. We adopt the prin-ciples by Choppy et al. [2] to merge application layer components and GNC instances.

We now discuss the composition of GSA instances to obtain a global secure software architecture that still fulfills the security requirements realized by the corresponding GSA instances. Especially confidentiality requirements must be treated carefully, since the composition of incompatible components can lead to non-fulfillment of confidentiality requirements.

If two GSA instances contain GSC instances that serve the same purpose, then these components cannot be merged in g eneral. The question to be answered is if the two GSC instances can use the same algorithm-specific configuration, e.g., a specific algorithm, key lengths, salt lengths, etc., to fulfill the different secu-rity requirements. For example, a speci fic encryption algorithm and specific key lengths might be sufficient to solve one security subproblem, while the same con-figuration would lead to a vulnerable system if applied to another subproblem. The level of abstraction o f GSC instances might not allow to decide whether they can be merged or if they have to be k ept separately. Th en, it is necessary to refine the GSC instances to platform-specific security components to come to this decision. An approach to deal with the composition of GSC instances before their refinement to platform-specific s ecurity components is to merge GSC in-stances of the same type into one configurable GSC instance of this type. Here, configurable means that we equip such a component with a variable mode, i.e., the algorithm a component realizes as well as the used cryptographic key can be changed at runtime.

Choppy et al.[2] considered only the structural composition of subarchitec-tures. Since our GSA instances are additionally equipped with behavioral views, we also consider the composition of thes e descriptions. The resulting behav-ioral specification of the global secure ar chitecture represents the life-cycle of the software to be constructed and its components. The behavior of GSA in-stances is given as a set of sequence diagrams, which should be composed based on the subproblem dependencies determined for the structural composition of the application layer components: in case of a sequential dependency, the se-quence diagrams should be composed according to the order defined by this dependency. In case of a parallel dependency, the sequence diagrams should be composed in such a way that the effects and output realized by the different GSA instances are fulfilled jointly. If GSC instances are merged into one configurable GSC instance, then its re-configuration should be included in the corresponding sequence diagrams. The result is a platform-independent global secure software architecture described by stru ctural and behavioral views.

We briefly discuss an approach to analyze global secure software architecture, i.e, to verify the constraints associated with UMLsec4UML2 st ereotypes that are contained in such architectures. 3.6 Verification of Global Secure Software Architectures We use the UMLsec4UML2-profile and the UMLsec tool suite to show that the GSC and GNC instances in a global secure software architecture work together in such a way that they fulfill the security requirements corresponding to the different subproblems. Based on the secure dependency stereotype and the OCL constraints contained in the UMLsec4UML2-profile, it is possible to check whether critical data items might be leaked ( { secrecy } and { high } )or changed ( { integrity } ). These checks can be executed directly within compat-ible UML editing tools such as Papyrus UML and MagicDraw UML. Based on the stereotypes data security and secure links and the OCL con-straints contained in the UMLsec4UML2-profile, it is possible to check whether behavior introduced by a GSA might compromise confidentiality ( { secrecy } and { high } )orintegrity( { integrity } ). Such checks can be executed based on the UMLsec tool suite, which makes use of the SPASS theorem prover 10 for the verification of properties of behavioral models.

We now illustrate the previously presented approach in the next section. We tested the approach presented in the previous sections using two case stud-ies: a secure text editor and an Internet-based password manager . We performed the complete development life-cycle for bo th case studies, i.e., from requirements engineering to architectural and fine-grained design to the implementation and testing of the programs. Moreover, we created all development artifacts as advo-cated by SEPP. While we present in this paper only a small part of the password manager case study, the complete results are contained in [14] and partly in a technical report abo ut UMLsec4UML2 [15].

Security requirements analysis of the password manager following SEPP as outlined in Sect. 2 leads to the elicitation and analysis of 13 different security requirements, e.g., about the confidentiality and integrity of the different user-names and passwords. Due to partly overlapping security requirements, only 11 different CSPF instances are developed. Consequently, 11 different GSAs are in-stantiated and combined yielding a global secure software architecture. Figure 4 partly shows the structural view of global secure software architecture of the password manager client expressed using a composite structure diagram. There, instances of GSCs for encryption/ decryption, keyed hash processing, digital sig-nature processing, generation of random numbers, as well as instances of GNCs for the user interface and network communication work together, coordinated by the application layer GNC instance, in order to ensure secure communi-cation between the password manager client and server over the Internet. The global architecture consisting of instances of GSCs and GNCs significantly helped us to proceed with the development phase s to follow. We identified adequate frameworks, off-the-shelf components, and API modules based on the generated artifacts, i.e., the components, the explicit interface descriptions, the protocol descriptions, and the UMLsec4UML2 secu rity annotations. Consequently, the programming phase had to cover creating the glue code to connect the exist-ing components and modules only. In summary, the case studies show that using patterns to bridge the gap between security requirements analysis and secure ar-chitectural design constitutes a feasible and promising contribution to the field of secure softwa re engineering. We also evaluated our approach with respect to ISO/IEC 15408:2005 aka Common Criteria (CC) certifications. The usage of the architectural artifacts generated following our approach for a CC certification is possible based on the TOE (Target Of Evaluation) Design Specification (TDS) of the class ADV Development. For instance, EAL (Evalua tion Assurance Level) 5 requires a semi-formal modular design, i.e., a representation of the TOE X  X  structure in terms of subsystems and a description of the part s the subsystem consists of in terms of modules. In addition to the TDS requirements for EAL 4, it is necessary to also describe those modules that represent S FR (Security Functional Requirement)-supporting modules in detail, i.e., by describing its SFR-related interfaces, return values from those interfaces, and called i nterfaces to other modules. These TDS requirements are met by the artifacts that describe the realizations of GSC and GNC instances. Moreover, a semiformal notation for the SFR-enforcing mod-ules should be used. Since our approach makes use of UML2.3 diagrams, this requirement is fulfilled right away. The tool suite developed for the original version of UMLsec and checking the OCL constraints of the UMLsec4UML2-profile supports creating TDS documents. For instance, the stereotype secure dependency allows to track the occurence of assets in the complex TDS doc-uments. Using an UML editing tool such as Papyrus UML the OCL constraints representing this stereoty pe can be verified to ensure that we covered all relevant occurences of an asset. Recently, an approach [10] to connect the s ecurity requirements analysis method Secure Tropos by Mouratidis et al. [3] and UMLsec [8] is published. Bryl et al. [1] extended the Secure Tropos variant by Massacci et al. [9] by an approach to automatically select design alternat ives based on results from security re-quirements analysis. Compared to our work, these approaches are not based on patterns, and they rather focus on the transition to finer-grained secure design.
Choppy et al. [2] present architectural patterns for Jackson X  X  basic problem frames [7]. The patterns constitute lay ered architectures described by UML com-posite structure diagrams. Similar to other approaches considering the connec-tion between problem frames and software architectures such as [13, 4], the work by Choppy et al. does not consider securi ty requirements, behavioral interface descriptions, and operation semantics. F urthermore, only a vague general proce-dure to derive components for a specific frame diagram is given in [2].
The vast body of patterns for secure so ftware engineering (see [5] for an overview) can be used during the phase that follows the phase presented in this paper, i.e., these patterns are applied in fine-grained design of secure soft-ware. Hence, the existing security desi gn patterns and our approach complement each other to such an extent that the existing patterns can be expressed in a unifying way based on SPFs, CSPFs, and GSAs.
 We presented in this paper a novel pattern-oriented and tool-supported approach to bridge the gap between security requir ements analysis and s ecure architectural design. Its main benefit is that the construction of global secure software archi-tectures based on results from security requirements engineering becomes more feasible, systematic, less error-prone, and a more routine engineering activity.
In the future, we plan to develop new UMLsec4UML2 stereotypes to specify assumptions and facts about the operational environment of the software. More-over, we intend to develop patterns that s upport the systematic composition of different GSA instances thereby preservin g the associated security requirements.
