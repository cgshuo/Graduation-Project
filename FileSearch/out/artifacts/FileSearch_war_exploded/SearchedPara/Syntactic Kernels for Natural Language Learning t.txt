 Recently, several tree kernels have been applied to natural language learning, e.g. (Collins and Duffy, 2002; Zelenko et al., 2003; Cumby and Roth, 2003; Culotta and Sorensen, 2004; Moschitti, 2004). De-spite their promising results, three general objec-tions against kernel methods are raised: (1) only a subset of the dual space features are relevant, thus, it may be possible to design features in the primal space that produce the same accuracy with a faster computation time; (2) in some cases the high num-ber of features (substructures) of the dual space can produce overfitting with a consequent accuracy de-crease (Cumby and Roth, 2003); and (3) the compu-tation time of kernel functions may be too high and prevent their application in real scenarios.
In this paper, we study the impact of the sub-tree (ST) (Vishwanathan and Smola, 2002), subset tree (SST) (Collins and Duffy, 2002) and partial tree (PT) kernels on Semantic Role Labeling (SRL). The PT kernel is a new function that we have designed to generate larger substructure spaces. Moreover, to solve the computation problems, we propose al-gorithms which evaluate the above kernels in linear average running time.

We experimented such kernels with Support Vec-tor Machines (SVMs) on the classification of seman-tic roles of PropBank (Kingsbury and Palmer, 2002) and FrameNet (Fillmore, 1982) data sets. The re-sults show that: (1) the kernel approach provides the same accuracy of the manually designed features. (2) The overfitting problem does not occur although the richer space of PTs does not provide better ac-curacy than the one based on SST. (3) The average running time of our tree kernel computation is linear.
In the remainder of this paper, Section 2 intro-duces the different tree kernel spaces. Section 3 de-scribes the kernel functions and our fast algorithms for their evaluation. Section 4 shows the compara-tive performance in terms of execution time and ac-curacy. We consider three different tree kernel spaces: the subtrees (STs), the subset trees (SSTs) and the novel partial trees (PTs).

An ST of a tree is rooted in any node and includes all its descendants. For example, Figure 1 shows the parse tree of the sentence "Mary brought a cat" together with its 6 STs. An SST is a more general structure since its leaves can be associated with non-terminal symbols. The SSTs satisfy the constraint that grammatical rules cannot be broken. For exam-ple, Figure 2 shows 10 SSTs out of 17 of the sub-tree of Figure 1 rooted in VP . If we relax the non-breaking rule constraint we obtain a more general form of substructures, i.e. the PTs. For example, Figure 3 shows 10 out of the total 30 PTs, derived from the same tree as before.
 The main idea of tree kernels is to compute the number of common substructures between two trees T 1 and T 2 without explicitly considering the whole fragment space. We designed a general function to compute the ST, SST and PT kernels. Our fast algorithm is inspired by the efficient evaluation of non-continuous subsequences (described in (Shawe-Taylor and Cristianini, 2004)). To further increase the computation speed, we also applied the pre-selection of node pairs which have non-null kernel. 3.1 Generalized Tree Kernel function Given a tree fragment space F = { f use the indicator function I the target f define the general kernel as: where N , respectively and  X ( n i.e. the number of common fragments rooted at the -if the node labels of n -else: are index sequences associated with the ordered child sequences c quences, and l (  X  ) returns the sequence length. We note that (1) Eq. 2 is a convolution kernel accord-ing to the definition and the proof given in (Haus-sler, 1999). (2) Such kernel generates a feature space richer than those defined in (Vishwanathan and Smola, 2002; Collins and Duffy, 2002; Zelenko et al., 2003; Culotta and Sorensen, 2004; Shawe-Taylor and Cristianini, 2004). Additionally, we add the decay factor as follows:  X ( n  X  In this way, we penalize subtrees built on child subsequences that contain gaps. Moreover, to have a similarity score between 0 and 1, we also apply the normalization in the kernel space, i.e. in Eq. 3 can be distributed with respect to different types of sequences, e.g. those composed by p children, it follows that where  X  rooted in subsequences of exactly p children (of n and n we consider only the contribution of the longest se-quence of node pairs that have the same children, we implement the SST kernel. For the STs computation we need also to remove the  X  2 term from Eq. 4.
Given the two child sequences c where c quences from 1 to i and from 1 to r of c we name the double summation term as D rewrite the relation as: Note that D p satisfies the recursive relation:
By means of the above relation, we can compute the child subsequences of two sets c plexity of the PT kernel is O ( p X  2 | N is the maximum branching factor of the two trees. Note that the average  X  in natural language parse trees is very small and the overall complexity can be reduced by avoiding the computation of node pairs with different labels. The next section shows our fast algorithm to find non-null node pairs. 3.2 Fast non-null node pair computation To compute the kernels defined in the previous sec-tion, we sum the  X  function for each pair  X  n with n  X ( n 1 , n 2 ) since it is 0 . Thus, we look for a node pair set N
To efficiently build N alphanumeric order and (iii) scan them to find N Step (iii) may require only O ( | N if peated r pairs. The formal can be found in (Moschitti, 2006). In these experiments, we study tree kernel perfor-mance in terms of average running time and accu-racy on the classification of predicate arguments. As shown in (Moschitti, 2004), we can label seman-tic roles by classifying the smallest subtree that in-cludes the predicate with one of its arguments, i.e. the so called PAF structure.

The experiments were carried out with the SVM-light-TK software available at which encodes the fast tree kernels in the SVM-light software (Joachims, 1999). The multiclassifiers were obtained by training an SVM for each class in the ONE-vs.-ALL fashion. In the testing phase, we selected the class associated with the maximum SVM score.

For the ST, SST and PT kernels, we found that the best  X  values (see Section 3) on the development set were 1, 0.4 and 0.8, respectively, whereas the best  X  was 0.4. 4.1 Kernel running time experiments To study the FTK running time, we extracted from the Penn Treebank several samples of 500 trees con-taining exactly n nodes. Each point of Figure 4 function applied to the 250,000 pairs of trees of size n . It clearly appears that the FTK-SST and FTK-PT (i.e. FTK applied to the SST and PT kernels) av-erage running time has linear behavior whereas, as expected, the na  X   X ve SST algorithm shows a quadratic curve. 4.2 Experiments on SRL dataset We used two different corpora: PropBank ( Treebank 2 (Marcus et al., 1993) and FrameNet. PropBank contains about 53,700 sentences and a fixed split between training and testing used in other researches. In this split, sections from 02 to 21 are used for training, section 23 for testing and section 22 as development set. We considered a total of 122,774 and 7,359 arguments (from Arg0 to Arg5 , ArgA and ArgM ) in training and testing, respectively. The tree structures were extracted from the Penn Treebank.

From the FrameNet corpus ( www.icsi. 24,558 sentences of the 40 Frames selected for the Automatic Labeling of Semantic Roles task of Senseval 3 ( www.senseval.org ). We considered the 18 most frequent roles, for a total of 37,948 examples (30% of the sentences for testing and 70% for training/validation). The sentences were processed with the Collins X  parser (Collins, 1997) to generate automatic parse trees.

We run ST, SST and PT kernels along with the linear kernel of standard features (Carreras and M ` arquez, 2005) on PropBank training sets of dif-ferent size. Figure 5 illustrates the learning curves associated with the above kernels for the SVM mul-ticlassifiers.

The tables 1 and 2 report the results, using all available training data, on PropBank and FrameNet test sets, respectively. We note that: (1) the accu-racy of PTs is almost equal to the one produced by SSTs as the PT space is a hyperset of SSTs. The small difference is due to the poor relevance of the substructures in the PT  X  SST set, which degrade the PT space. (2) The high F 1 measures of tree ker-nels on FrameNet suggest that they are robust with respect to automatic parse trees.

Moreover, the learning time of SVMs using FTK for the classification of one large argument (Arg 0) is much lower than the one required by na  X   X ve algo-rithm. With all the training data FTK terminated in 6 hours whereas the na  X   X ve approach required more than 1 week. However, the complexity burden of working in the dual space can be alleviated with re-cent approaches proposed in (Kudo and Matsumoto, 2003; Suzuki et al., 2004).

Finally, we carried out some experiments with the combination between linear and tree kernels and we found that tree kernels improve the models based on manually designed features by 2/3 percent points, thus they can be seen as a useful tactic to boost sys-tem accuracy.

