 Multi-task learning is an area of active research in machine learning and has received a lot of at-tention over the past few years. A common set up is that there are multiple related tasks for which we want to avoid tabula rasa learning by sharing information across the different tasks. The hope is that by learning these tasks simultaneously one can improve performance over the  X  X o transfer X  case (i.e. when each task is learnt in isolation). However, as pointed out in [1] and supported empirically by [2], assuming relatedness in a set of tasks and simply learning them together can be detrimental. It is therefore important to have models that will generally benefit related tasks and will not hurt performance when these tasks are unrelated. We investigate this in the context of Gaussian Process (GP) prediction.
 We propose a model that attempts to learn inter-task dependencies based solely on the task identities and the observed data for each task. This contrasts with approaches in [3, 4] where task-descriptor features t were used in a parametric covariance function over different tasks X  X uch a function may be too constrained by both its parametric form and the task descriptors to model task similarities effectively. In addition, for many real-life scenarios task-descriptor features are either unavailable or difficult to define correctly. Hence we propose a model that learns a  X  X ree-form X  task-similarity matrix, which is used in conjunction with a parameterized covariance function over the input features x .
 For scenarios where the number of input observations is small, multi-task learning augments the data set with a number of different tasks, so that model parameters can be estimated more confidently; this helps to minimize over-fitting. In our model, this is achieved by having a common covariance function over the features x of the input observations. This contrasts with the semiparametric latent factor model [5] where, with the same set of input observations, one has to estimate the parameters of several covariance functions belonging to different latent processes.
 For our model we can show the interesting theoretical property that there is a cancellation of inter-task transfer in the specific case of noise-free observations and a block design. We have investigated both gradient-based and EM-based optimization of the marginal likelihood for learning the hyper-parameters of the GP. Finally, we make use of GP approximations and properties of our model in order to scale our approach to large multi-task data sets, and evaluate the benefits of our model on two practical multi-task applications: a compiler performance prediction problem and a exam score prediction task.
 The structure of the paper is as follows: in section 2 we outline our model for multi-task learning, and discuss some approximations to speed up computations in section 3. Related work is described in section 4. We describe our experimental setup in section 5 and give results in section 6. Given a set X of N distinct inputs x 1 , . . . , x N we define the complete set of responses for M tasks task on the i th input x i . Let us also denote the N  X  M matrix Y such that y = vec Y . Given a set of observations y o , which is a subset of y , we want to predict some of the unobserved response-values y u at some input locations for certain tasks.
 We approach this problem by placing a GP prior over the latent functions { f l } so that we directly induce correlations between tasks. Assuming that the GPs have zero mean we set where K f is a positive semi-definite (PSD) matrix that specifies the inter-task similarities, k x is a covariance function over inputs, and  X  2 l is the noise variance for the l th task. Below we focus on stationary covariance functions k x ; hence, to avoid redundancy in the parametrization, we further let k x be only a correlation function (i.e. it is constrained to have unit variance), since the variance can be explained fully by K f .
 The important property of this model is that the joint Gaussian distribution over y is not block-diagonal wrt tasks, so that observations of one task can affect the predictions on another task. In [4, 3] this property also holds, but instead of specifying a general PSD matrix K f , these authors set K One popular setup for multi-task learning is to assume that tasks can be clustered, and that there are inter-task correlations between tasks in the same cluster. This can be easily modelled with a general task-similarity K f matrix: if we assume that the tasks are ordered with respect to the clusters, then K f will have a block diagonal structure. Of course, as we are learning a  X  X ree form X  K f the ordering of the tasks is irrelevant in practice (and is only useful for explanatory purposes). 2.1 Inference Inference in our model can be done by using the standard GP formulae for the mean and variance of the predictive distribution with the covariance function given in equation (1). For example, the mean prediction on a new data-point x  X  for task l is given by where  X  denotes the Kronecker product, k f l selects the l th column of K f , k x  X  is the vector of covariances between the test point x  X  and the training points, K x is the matrix of covariances between all pairs of training points, D is an M  X  M diagonal matrix in which the ( l, l ) th element is  X  , and  X  is an M N  X  M N matrix.
 In section 2.3 we show that when there is no noise in the data (i.e. D = 0 ), there will be no transfer between tasks. 2.2 Learning Hyperparameters Given the set of observations y o , we wish to learn the parameters  X  x of k x and the matrix K f to maximize the marginal likelihood p ( y o | X,  X  x , K f ) . One way to achieve this is to use the fact that y | X  X  N ( 0 ,  X ) . Therefore, gradient-based methods can be readily applied to maxi-mize the marginal likelihood. In order to guarantee positive-semidefiniteness of K f , one possible parametrization is to use the Cholesky decomposition K f = LL T where L is lower triangular. Computing the derivatives of the marginal likelihood with respect to L and  X  x is straightforward. A drawback of this approach is its computational cost as it requires the inversion of a matrix of poten-tial size M N  X  M N (or solving an M N  X  M N linear system) at each optimization step. Note, however, that one only needs to actually compute the Gram matrix and its inverse at the visible locations corresponding to y o .
 Alternatively, it is possible to exploit the Kronecker product structure of the full covariance matrix as in [6], where an EM algorithm is proposed such that learning of  X  x and K f in the M -step is decoupled. This has the advantage that closed-form updates for K f and D can be obtained (see equation (5)), and that K f is guaranteed to be positive-semidefinite. The details of the EM algorithm are as follows: Let f be the vector of function values corresponding to y , and similarly for F wrt which in this case is f , the complete-data log-likelihood is from which we have following updates: where the expectations  X  X  X  are taken with respect to p f | y o ,  X  x , K f , and parameters. For clarity, let us consider the case where y o = y , i.e. a block design. Then p f | y ,  X  x , K f = N ( K f  X  K x ) X   X  1 y , ( K f  X  K x )  X  ( K f  X  K x ) X   X  1 ( K f  X  K x ) . We have seen that  X  needs to be inverted (in time O ( M 3 N 3 ) ) for both making predictions and learning the hyperparameters (when considering noisy observations). This can lead to computational problems if M N is large. In section 3 we give some approximations that can help speed up these computations. 2.3 Noiseless observations and the cancellation of inter-task transfer One particularly interesting case to consider is noise-free observations at the same locations for all tasks (i.e. a block-design) so that y | X  X  Normal ( 0 , K f  X  K x ) . In this case maximizing the marginal likelihood p ( y | X ) wrt the parameters  X  x of k x reduces to maximizing  X  M log | K x |  X  N log | Y T ( K x )  X  1 Y | , an expression that does not depend on K f . After convergence we can obtain K and K x . We can learn K f by decorrelating Y with ( K x )  X  1 first so that only correlation with respect to K f is left. Then K f is simply the sample covariance of the de-correlated Y .
 Unfortunately, in this case there is effectively no transfer between the tasks (given the kernels). To see this, consider making predictions at a new location x  X  for all tasks. We have (using the mixed-product property of Kronecker products) that and similarly for the covariances. Thus, in the noiseless case with a block design, the predictions for task l depend only on the targets y  X  l . In other words, there is a cancellation of transfer. One can in fact generalize this result to show that the cancellation of transfer for task l does still hold even if the observations are only sparsely observed at locations X = ( x 1 , . . . , x N ) on the other tasks. After having derived this result we learned that it is known as autokrigeability in the geostatistics literature [7], and is also related to the symmetric Markov property of covariance functions that is discussed in [8]. We emphasize that if the observations are noisy, or if there is not a block design, then this result on cancellation of transfer will not hold. This result can also be generalized to multidimensional tensor product covariance functions and grids [9]. The issue of dealing with large N has been much studied in the GP literature, see [10, ch. 8] and [11] for overviews. In particular, one can use sparse approximations where only Q out of N data points are selected as inducing inputs [11]. Here, we use the Nystr  X  om approximation of K x in the K x . In fact for the posterior at the training points this result is obtained from both the subset of regressors (SoR) and projected process (PP) approximations described in [10, ch. 8].
 Specifying a full rank K f requires M ( M + 1) / 2 parameters, and for large M this would be a lot of parameters to estimate. One parametrization of K f that reduces this problem is to use a PPCA model [12] K f  X  e K f def = U  X  U T + s 2 I M , where U is an M  X  P matrix of the P principal eigenvectors of K f ,  X  is a P  X  P diagonal matrix of the corresponding eigenvalues, and s 2 can be determined analytically from the eigenvalues of K f (see [12] and references therein). For numerical stability, we may further use the incomplete-Cholesky decomposition setting U  X  U T =  X  L  X  L T , where  X  L is a M  X  P matrix. Below we consider the case s = 0 , i.e. a rank-P approximation to K f . Applying both approximations to get  X   X  e  X  def =  X  K f  X   X  K x + D  X  I N , we have, after using the K  X I ) , and  X  of  X   X   X  1 y takes O ( M N P 2 Q 2 ) .
 For the EM algorithm, the approximation of e K x poses a problem in (4) because for the rank-deficient matrix e K x , its log-determinant is negative infinity, and its matrix inverse is undefined. We overcome and the matrix inverse is replaced by the pseudo-inverse. With these approximations the compu-tational complexity of hyperparameter learning can be reduced to O ( M N P 2 Q 2 ) per iteration for both the Cholesky and EM methods. There has been a lot of work in recent years on multi-task learning (or inductive transfer) using methods such as Neural Networks, Gaussian Processes, Dirichlet Processes and Support Vector Machines, see e.g. [2, 13] for early references. The key issue concerns what properties or aspects should be shared across tasks. Within the GP literature, [14, 15, 16, 17, 18] give models where the covariance matrix of the full (noiseless) system is block diagonal, and each of the M blocks is induced from the same kernel function. Under these models each y  X  i is conditionally independent, but inter-task tying takes place by sharing the kernel function across tasks. In contrast, in our model and in [5, 3, 4] the covariance is not block diagonal.
 The semiparametric latent factor model (SLFM) of Teh et al [5] involves having P latent processes (where P  X  M ) and each of these latent processes has its own covariance function. The noiseless outputs are obtained by linear mixing of these processes with a M  X  P matrix  X  . The covariance matrix of the system under this model has rank at most P N , so that when P &lt; M the system corresponds to a degenerate GP. Our model is similar to [5] but simpler, in that all of the P latent processes share the same covariance function; this reduces the number of free parameters to be fitted and should help to minimize overfitting. With a common covariance function k x , it turns out that K f is equal to  X  X  T , so a K f that is strictly positive definite corresponds to using P = M latent processes. Note that if P &gt; M one can always find an M  X  M matrix  X  0 such that  X  0  X  0 T =  X  X  T . We note also that the approximation methods used in [5] are different to ours, and were based on the subset of data (SoD) method using the informative vector machine (IVM) selection heuristic. In the geostatistics literature, the prior model for f  X  given in eq. (1) is known as the intrinsic cor-relation model [7], a specific case of co-kriging . A sum of such processes is known as the linear coregionalization model (LCM) [7] for which [6] gives an EM-based algorithm for parameter es-timation. Our model for the observations corresponds to an LCM model with two processes: the process for f  X  and the noise process. Note that SLFM can also be seen as an instance of the LCM model. To see this, let E pp be a P  X  P diagonal matrix with 1 at ( p, p ) and zero elsewhere. Then we where  X  E pp  X  T is of rank 1 .
 Evgeniou et al. [19] consider methods for inducing correlations between tasks based on a correlated prior over linear regression parameters. In fact this corresponds to a GP prior using the kernel k ( x , x 0 ) = x T A x 0 for some positive definite matrix A . In their experiments they use a restricted form of K f with K f lk = (1  X   X  ) +  X M  X  lk (their eq. 25), i.e. a convex combination of a rank-1 matrix of ones and a multiple of the identity. Notice the similarity to the PPCA form of K f given in section 3. We evaluate our model on two different applications. The first application is a compiler performance prediction problem where the goal is to predict the speed-up obtained in a given program (task) when applying a sequence of code transformations x . The second application is an exam score prediction problem where the goal is to predict the exam score obtained by a student x belonging to a specific school (task). In the sequel, we will refer to the data related to the first problem as the compiler data and the data related to the second problem as the school data .
 We are interested in assessing the benefits of our approach not only with respect to the no-transfer case but also with respect to the case when a parametric GP is used on the joint input-dependent and task-dependent space as in [3]. To train the parametric model note that the parameters of the covari-ance function over task descriptors k f ( t , t 0 ) can be tuned by maximizing the marginal likelihood,  X  K not complete). For both applications we have used a squared-exponential (or Gaussian) covariance function k x and a non-parametric form for K f . Where relevant the parametric covariance function k f was also taken to be of squared-exponential form. Both k x and k f used an automatic relevance determination (ARD) parameterization, i.e. having a length scale for each feature dimension. All the length scales in k x and k f were initialized to 1 , and all  X  2 l were constrained to be equal for all tasks and initialized to 0 . 01 . 5.1 Description of the Data Compiler Data . This data set consists of 11 C programs for which an exhaustive set of 88214 sequences of code transformations have been applied and their corresponding speed-ups have been recorded. Each task is to predict the speed-up on a given program when applying a specific trans-formation sequence. The speed-up after applying a transformation sequence on a given program is defined as the ratio of the execution time of the original program (baseline) over the execution time of the transformed program. Each transformation sequence is described as a 13 -dimensional vector x that records the absence/presence of one-out-of 13 single transformations. In [3] the task-descriptor features (for each program) are based on the speed-ups obtained on a pre-selected set of 8 transformations sequences, so-called  X  X anonical responses X . The reader is referred to [3, section 3] for a more detailed description of the data.
 School Data . This data set comes from the Inner London Education Authority (ILEA) and has been used to study the effectiveness of schools. It is publicly available under the name of  X  X chool effectiveness X  at http://www.cmm.bristol.ac.uk/learning-training/ multilevel-m-support/datasets.shtml . It consists of examination records from 139 secondary schools in years 1985, 1986 and 1987. It is a random 50% sample with 15362 students. This data has also been used in the context of multi-task learning by Bakker and Heskes [20] and Evgeniou et al. [19]. In [20] each task is defined as the prediction of the exam score of a student belonging to a specific school based on four student-dependent features (year of the exam, gen-der, VR band and ethnic group) and four school-dependent features (percentage of students eligible for free school meals, percentage of students in VR band 1 , school gender and school denomina-tion). For comparison with [20, 19] we evaluate our model following the set up described above and similarly, we have created dummy variables for those features that are categorical forming a total of 19 student-dependent features and 8 school-dependent features. However, we note that school-descriptor features such as the percentage of students eligible for free school meals and the percentage of students in VR band 1 actually depend on the year the particular sample was taken. It is important to emphasize that for both data sets there are task-descriptor features available. How-ever, as we have described throughout this paper, our approach learns task similarity directly without the need for task-dependent features. Hence, we have neglected these features in the application of our free-form K f method. For the compiler data we have M = 11 tasks and we have used a Cholesky decomposition K f = LL T . For the school data we have M = 139 tasks and we have preferred a reduced rank parameterization of K f  X  e K f =  X  L  X  L T , with ranks 1 , 2 , 3 and 5 . We have learnt the parame-ters of the models so as to maximize the marginal likelihood p ( y o | X, K f ,  X  x ) using gradient-based search in MATLAB with Carl Rasmussen X  X  minimize.m . In our experiments this method usually outperformed EM in the quality of solutions found and in the speed of convergence.
 Compiler Data: For this particular application, in a real-life scenario it is critical to achieve good performance with a low number of training data-points per task given that a training data-point requires the compilation and execution of a (potentially) different version of a program. Therefore, although there are a total of 88214 training points per program we have followed a similar set up to [3] by considering N = 16 , 32 , 64 and 128 transformation sequences per program for training. All the M = 11 programs (tasks) have been used for training, and predictions have been done at the (unobserved) remaining 88214  X  N inputs. For comparison with [3] the mean absolute error (between the actual speed-ups of a program and the predictions) has been used as the measure of performance. Due to the variability of the results depending on training set selection we have considered 10 different replications.
 Figure 1 shows the mean absolute errors obtained on the compiler data for some of the tasks (top row and bottom left) and on average for all the tasks (bottom right). Sample task 1 (histogram) is an example where learning the tasks simultaneously brings major benefits over the no transfer case. Here, multi-task GP (transfer free-form) provides a reduction on the mean absolute error of up to 6 times. Additionally, it is consistently (although only marginally) superior to the parametric approach. For sample task 2 (fir), our approach not only significantly outperforms the no transfer case but also provides greater benefits over the parametric method (which for N = 64 and 128 is worse than no transfer). Sample task 3 (adpcm) is the only case out of all 11 tasks where our approach degrades performance, although it should be noted that all the methods perform similarly. Further analysis of the data indicates that learning on this task is hard as there is a lot of variability that cannot be explained by the 1 -out-of-13 encoding used for the input features. Finally, for all tasks on average (bottom right) our approach brings significant improvements over single task learning and consistently outperforms the parametric method. For all tasks except one our model provides better or roughly equal performance than the non-transfer case and the parametric model. School Data: For comparison with [20, 19] we have made 10 random splits of the data into training ( 75% ) data and test (25%) data. Due to the categorical nature of the data there are a maximum of N = 202 different student-dependent feature vectors x . Given that there can be multiple ob-servations of a target value for a given task at a specific input x , we have taken the mean of these observations and corrected the noise variances by dividing them over the corresponding number of observations. As in [19], the percentage explained variance is used as the measure of performance. This measure can be seen as the percentage version of the well known coefficient of determination r between the actual target values and the predictions. Figure 1: Panels (a), (b) and (c) show the average mean absolute error on the compiler data as a function of the number of training points for specific tasks. no transfer stands for the use of a single GP for each task separately; transfer parametric is the use of a GP with a joint parametric (SE) covariance function as in [3]; and transfer free-form is multi-task GP with a  X  X ree form X  covariance matrix over tasks. The error bars show  X  one standard deviation taken over the 10 replications. Panel (d) shows the average MAE over all 11 tasks, and the error bars show the average of the standard deviations over all 11 tasks.
 The results are shown in Table 1; note that larger figures are better. The parametric result given in the table was obtained from the school-descriptor features; in the cases where these features varied for a given school over the years, an average was taken. The results show that better results can be obtained by using multi-task learning than without. For the non-parametric K f , we see that the rank-2 model gives best performance. This performance is also comparable with the best (29.5%) found in [20]. We also note that our no transfer result of 21.1% is much better than the baseline of 9.7% found in [20] using neural networks. Table 1: Percentage variance explained on the school dataset for various situations. The figures in brackets are standard deviations obtained from the ten replications.
 On the school data the parametric approach for K f slightly outperforms the non-parametric method, probably due to the large size of this matrix relative to the amount of data. One can also run the parametric approach creating a task for every unique school-features descriptor 1 ; this gives rise to 288 tasks rather than 139 schools, and a performance of 33.08% (  X  1.57). Evgeniou et al [19] use a linear predictor on all 8 features (i.e. they combine both student and school features into x ) and then introduce inter-task correlations as described in section 4. This approach uses the same information as our 288 task case, and gives similar performance of around 34% (as shown in Figure 3 of [19]). In this paper we have described a method for multi-task learning based on a GP prior which has inter-task correlations specified by the task similarity matrix K f . We have shown that in a noise-free block design, there is actually a cancellation of transfer in this model, but not in general. We have successfully applied the method to the compiler and school problems. An advantage of our method is that task-descriptor features are not required (c.f. [3, 4]). However, such features might be beneficial if we consider a setup where there are only few datapoints for a new task, and where the task-descriptor features convey useful information about the tasks.
 Acknowledgments References
