
Constraints applied on classic frequent patterns are too strict and may cause interesting patterns to be missed. Hence, researchers have proposed to mine a more relaxed version of frequent patterns, where transactions are allowed to miss some items in the itemset they support. Patterns exhibiting such  X  X aults X  are called frequent fault-tolerant patterns (FFT-patterns) if they are significant in number. In this paper, the term  X  X attern X  is distinguished from  X  X tem-set X  as referring to a pair (tidset  X  itemset).

Unlike classical frequent patterns, the number of FFT-patterns grows exponentially not only with the number of items, but also with the number of transactions. Since the latter may reach millions, mining FFT-patterns by enu-merating them becomes infeasible. Hence, the challenge is to represent FFT-patterns concisely without losing any useful information. To address this, we draw on the ob-servation that, in transactional databases, the transactions themselves are not important from the data mining point-of-view; i.e. researchers are interested in finding itemsets con-tained in lots of transactions, rather than in the transactions per se. Therefore, we propose to mine only the frequent itemsets along with the statistical information of the sup-porting transaction sets, rather than enumerate entire FFT-patterns. Then we present our approach -the BIAS frame-work, consisting of Backtracking algorithm, Integer Linear Programming (ILP) constraints, and aggregation statistics to solve this problem. Algorithms under this framework not only increase the efficiency of the FFT-patterns mining pro-cess by more than an order of magnitude, but also provide a more comprehensive analysis of FFT-Patterns.
The frequent patterns mining problem [2] has been widely studied in data mining. Some researchers use the terms pattern and itemset interchangeably, but in this paper, we distinguish the term pattern as pair (tidset  X  itemset) instead of itemset only.
Figure 1. Transactional database: table and matrix form
Yang et al [14] argued that analysts would find it use-ful to mine groups of similar transactions that share most of the items, but these cannot be discovered by traditional approaches due to their harsh definition of support. Hence, they proposed to mine a more relaxed version of frequent patterns, where transactions are allowed to miss some items in the itemset they support.

Patterns significantly supported in such a manner are called frequent fault-tolerant patterns (FFT-patterns for short). Let us consider the transactional database as shown in Figure 1, which will be used as a running example in the rest of this paper. The database consists of a set of transactions (henceforth called tidset for brevity) over an itemset, and is illustrated in table and matrix forms. Here, we highlight some examples of FFT-patterns. We can see that when supporting transactions are allowed to miss one item in the itemset they support, three transactions, viz. 2 , 3 , 4 support itemset { a, b } ; when supported items are al-lowed to be missed by one transaction in their supporting set, itemset { a, b, c, d } is supported by tidsets { 1 , and { 2 , 3 } ; and when three such transaction-item misses are allowed in a pair (tidset  X  itemset), ( { 2 , 3 , 4 } X { a, b, c ( ria. These examples while not comprehensive, illustrate the variety of FFT-patterns.

Consequently, several definitions of FFT-patterns have been proposed [9, 10, 12, 3, 6, 7, 8, 11] to accommodate this diversity. However, a general problem with FFT-patterns is that they not only grow exponentially with the number of items, but also with the number of transactions. Since the number of transactions may reach millions, this implies that mining FFT-patterns is infeasible. Several approaches have been proposed to tackle this problem: [9, 14] relax the constraints, while [3, 10] add more constraints, and [14, 7, 8] perform approximation. Nevertheless, all of these approaches either still produce too many results, or might lose interesting patterns.

In transactional databases, the transactions themselves are not important from the data mining point-of-view, i.e. the interest is in finding itemsets which are contained in a lot of transactions, instead of finding the transactions them-selves. Therefore, we propose to mine all frequent itemsets , along with the statistical information of the supporting-transaction sets (formally defined in section 3.1). We choose this approach because (1) this approach doesn X  X  lose any interesting itemsets (no false negatives), and (2) we find that the statistical information can concisely describe the characteristics of huge data.
 In this paper, we formulate the general definitions of FFT-patterns in terms of basic relaxation criteria, and show how new and existing variants of such patterns can be formed from combinations of those criteria. Then we present our BIAS framework 1 , consisting of Backtracking algorithm , Integer Linear Programming (ILP) constraints, and aggregation statistics to solve this problem, and demon-strate its application for all problem variants. Note that ILP is used here to define constraints of a combinatoric prob-lem, and not to optimize an objective function as in usual LP. This framework can be used to mine statistical informa-tion of the FFT-patterns efficiently without generating the patterns themselves.

The rest of this paper is organized as follows. Section 2 discusses previous works related to the problem of FFT-patterns mining, and links them to the variants described in our paper. Section 3 presents the general problem defini-tion, and shows how variants of FFT-patterns can be derived from constraints. Section 4 describes the BIAS framework to mine frequent itemsets as well as the statistics of their supporting-tidsets, and algorithms under this framework are explained in detail for each variant in section 5. These ap-proaches are compared with related techniques, and section 6 shows the experimental results of these comparisons. Fi-nally, section 7 concludes with some directions for future work.
Pioneering work in FFT-patterns mining was by Yang et al [14] in 2001, where the amount of relaxation is pro-portional to the size of the pattern. An FFT-pattern, also called strong-ETI , is defined as a sub-matrix of itemset and transaction-set, where each transaction contains a certain proportion of the itemset. Besides [14], other papers min-ing FFT-patterns using proportion are [10, 7, 8]. In [10] and [14], the objective is to find interesting patterns, while [7] and [8] aim to approximate the pure frequent itemsets in a noisy data.

FFT-patterns mining with proportional relaxation, though natural, is intractable [3], because this problem lacks the anti-monotonicity property 2 of itemsets. With anti-monotonicity property, we can safely stop extending an itemset once it is not frequent, so the mining complexity is proportional to the number of frequent itemsets. This is not the case when mining using proportional relaxation. More-over, techniques using fixed-value relaxation [9, 12, 3, 11] demonstrate that interesting itemsets can be mined in real-world data. Since our paper focuses on fixed-value fault-tolerance, we skip details on these other variants.
The first piece of work using fixed-value as relaxation on FFT-patterns mining was authored by Pei et al [9]. The definition of FFT-pattern here is similar to the one given in [14], but they employ fixed-value relaxation instead of proportional relaxation, i.e. every transaction is allowed to miss a fixed number of items. This definition is equiv-alent to that of FFT T -pattern in our paper (c.f. section 3.2). To mine such patterns, the authors used an apriori -based method. Koh and Yo [6] tackled the same problem using a backtracking approach, and empirically showed that their approach improves the efficiency of the previous approach by an order of magnitude.

A more complicated problem was tackled by Sim et al [11], where the objective is to mine maximal quasi-bicliques in bipartite graphs. A quasi-biclique is maximal if it is not a proper subset of any other quasi-biclique. In [11], the relaxation criteria is applied to both sides of the bipartite graph, i.e. each vertex is allowed to disconnect to at most vertices in the other partite-set. To solve this prob-lem, they proposed algorithm CompleteQB which is based on the backtracking approach. The constraints for this prob-lem are exactly the same as for our FFT TI -pattern (c.f. sec-tion 3.2).

Besson et al [3] relate transactional databases with for-mal concept analysis in lattice theory. They performed comparisons on several definitions of FFT-patterns (DRBS, CBS, and FBS) with the objective of finding interesting patterns. However, all those definitions incorporate a con-sistency constraint , which restricts all transactions (resp: items) outside the patterns to contain lesser items (resp: transactions) than those inside the pattern. The implications of this constraint are illustrated in Example 1.
 Example 1. Consider the database as depicted in Figure 1. Let the minimum support be 3, and the allowed num-ber of misses in each transaction and item be 1. No FFT-pattern with itemset { b, c } can include transactions 3 and 4 together, since they both miss item c (no. of misses for item c becomes 2). Conversely, neither of them can be ex-cluded from any pattern that contains transaction 2, as it would violate the consistency constraint. As a result, { b, c is not considered interesting (frequent). On the other hand, if the dataset had contained only transactions 1, 2 and 3 (or 1, 2 and 4), we find patterns that support itemset { b, c which is now considered interesting. Therefore we conclude that such constraints are not appropriate for mining item-sets with fixed tolerance in transactional databases.
In this paper, we deal with transactional databases. A transactional database D consists of transactions T over a set of items I , and can be represented by a ( T X I ) matrix of transactions and items.

T ( x  X  X  ) (resp: T ( X  X  X  ) ) represents a tidset where each transaction contains item x (resp: itemset X ). Sim-ilarly I ( y  X  X  ) (resp: I ( Y  X  X  ) ) represents an itemset where each item is contained in transaction y (resp: tidset Y ).
 Definition 1. [P ATTERN ] A pattern is defined as a sub-matrix (( Y  X  X  )  X  ( X  X  X  )) of D . A pattern ( Y  X  X ) is said to be associated with itemset X .

In classic frequent itemset mining, a pattern P is inter-esting if all its transactions contains all its items, i.e. all ( tid, item ) pairs in the pattern are present in the database. In fault-tolerant mining, we relax this interesting constraint by allowing P to contain a constant number of ( tid, item pairs which are actually miss ing in the database. This re-laxation is formally defined by the following relaxation cri-teria , where we distinguish between the allowed number of miss es in each transaction, each item, and the entire pattern. Transaction relaxation In a pattern ( Y  X  X ) , the total Item relaxation In a pattern ( Y  X  X ) , the total number of Pattern relaxation In a pattern ( Y  X  X ) , the total number
The set of all patterns satisfying the relaxation criteria may be very large and undesirable. In order to reduce this, we consider the utility of the patterns in terms of the support for their itemsets and maximality of their tidsets, where the support of a pattern is calculated as the size of its tidset. The set of such patterns can be limited by the following constraints.
 Support constraint A pattern ( Y  X  X ) is frequent, i.e. Maximality constraint A pattern ( Y  X  X ) relaxed by any
Support constraint and maximality constraint are de-noted as utility constraints . Note that these constraints only restrict support and maximality in the tidsets, and not in the entire pattern as in usual terminology.
 Definition 2. [FFT-PATTERN ] An FFT-pattern is a pattern satisfying all utility constraints and any given combination of relaxation criteria .
 Definition 3. [ SUPPORT -TIDSET ] Tidset Y supports item-set X if ( Y  X  X ) is an FFT-pattern. The set of all support-tidsets of X is denoted as S ( X ) .
 Definition 4. [F REQUENT ITEMSET ] An itemset X is fre-quent if S ( X ) = X  .

As mentioned earlier, instead of mining all FFT-patterns, we propose to mine all frequent itemsets along with the statistics of their support-tidsets. In this work, we calculate the maximum support ,the average support , and the number of FFT-patterns associated with an itemset as the statistical information, which we consider useful for itemset analysis. Other statistical information such as median and mode can also be mined without adding much complexity.

In a market basket database, while |I| may reach thou-sands, the maximum size of any practical itemset is around 10 [13]. We denote the maximum size of an FFT-itemset as X max and use it to provide a tight upper bound for some operations (c.f. section 5), since X max &lt;&lt; |I| in practice.
In this paper, combinations of above relaxation criteria have been used to form three variants of the FFT-pattern, viz. FFT T -pattern (using transaction relaxation), FFT TI pattern (using transaction relaxation and item relaxation), and FFT P -pattern (using pattern relaxation). Variables sub-scripted with T , TI ,or P belong to the corresponding spe-cific variants of FFT-pattern.

The aim of introducing three different variants is mainly to show how the BIAS framework addresses each relaxation criteria. Depending on the dataset, some relaxation crite-rion by itself might not be pertinent, as the resulting pat-tern may be sparse. However, combining the criteria can produce good variants, like FFT T -pattern [9] and FFT TI pattern [11] which have already been successfully applied to real world problems. Differences among the variants in term of the patterns mined are shown in Example 2. Example 2. Consider the database as illustrated in Fig-ure 1. Let t = i = p =1 , and  X  =1 .Itemset X = { b, c } , is associated with (a) one unique FFT T -pattern, ( { 1 , 2 , 3 , 4 } X  X ) , and its corresponding S T ( X ) ton {{ 1 , 2 , 3 , 4 }} ; (b) two FFT TI -patterns, ( { 1 and ( { 1 , 2 , 4 } X  X ) , with S TI ( X )= {{ 1 , 2 , 3 } and (c) three FFT P -patterns, ( { 1 , 2 } X  X ) , ( { 2 , and ( { 2 , 4 } X  X ) , with S P ( X )= {{ 1 , 2 } , { 2 ,
Despite these differences, all the FFT-pattern variants share the anti-monotonicity property.
 Theorem 1. FFT-pattern is anti-monotone.
 Proof. Since every relaxation criterion on the FFT-patterns is based on fixed-value, the allowed number of miss es is a constant. The number of miss es in an FFT-pattern is thus in-variant to it X  X  size, and addition of items and/or transactions will never reduce the amount of miss es.

This property is very important for designing algorithms to mine FFT-itemsets. If an itemset is not frequent (regard-less of the definition), then none of its supersets are fre-quent. Based on this property, we can enumerate all results using the pattern growth approach [2], and safely prune when the current itemset is not frequent.
The BIAS framework, consisting of Backtracking algo-rithm, Integer linear programming (ILP), and aggregation statistic, is designed as follows. First, the backtracking al-gorithm iterates all necessary and relevant itemsets, while concurrently maintaining the necessary aggregation statis-tic of the transactions. For each itemset X , the statistical information of S ( X ) is determined by ILP incorporating the corresponding aggregation statistic.

Algorithm 1 : Backtracking algorithm 1: call Backtrack ( X ) ; 2: 3: Function Backtrack ( X ) :: void 4: for each item i extension of X 5: extend itemset X with item i while 6: Form ILP based on the aggregation statistics; 7: if ( X ) is frequent 8: output the statistical information of S ( X ) ; 9: call Backtrack ( X ) ; 10: exclude item i from X while maintaining
The backtracking algorithm (Algorithm 1) enumerates the itemsets by inserting items one by one. Once it fin-ishes enumerating all itemsets containing an item, it back-tracks, then inserts another item. The complete process can be seen as an enumeration tree [4]. As FFT-itemset is anti-monotone , once an itemset is not frequent, we can safely prune it by not traversing its subtree.

Since we enumerate all FFT-itemsets, this backtracking algorithm combined with pruning, traverses all necessary and relevant result states. This means that we cannot expect any algorithm that iterates the itemsets to be asymptotically more efficient than this algorithm.
Given an itemset X generated by the backtracking step, the aim of ILP is to find the statistical information of associ-ated FFT-patterns. We first present the algorithm to mine all S (
X ) , and then show how to calculate the statistics without enumerating all tidsets.

The problem of enumerating S ( X ) can be translated to a system of binary linear inequalities where the variables represent the transactions. We denote this system of integer linear equalities as an integer linear program ( ILP ). This ILP consists of |T | variables, denoted by integer array A ( a 1 ,a 2 , ..., a |T | ) . Each variable a i , 1  X  i  X |T| , represents one transaction and is constrained to be 0 or 1 (binary). A value 1 of variable a i means transaction i is present in the tidset.

The relaxation criteria and utility constraint on the pat-tern (c.f. section 3.1) presented in terms of the variables are as follows.
 Transaction Relaxation ( ILP T ) Item Relaxation ( ILP I ) Pattern Relaxation ( ILP P ) Maximality Constraint ( ILP max ) Support Constraint ( ILP sup )
Note that we haven X  X  changed the problem statement, in-stead we have only represented it in a mathematical form. Analyzing the variables, we note that this problem is in-tractable since the number of transactions can be potentially large. Especially, it is because integer programming in gen-eral is NP-Hard.

This problem can be resolved by reducing the number of variables. Equivalent variables are substituted by one combined-variable , representing the equivalence classes . In any definition of relaxation criteria, two transactions t and t b are equivalent if they contain the same itemset in X , i.e. I ( t a )  X  X = I ( t b )  X  X . This equivalent condition is even stronger in FFT T -pattern and FFT P -pattern, where two transactions are equivalent if they contain the same number of itemsets in X , i.e. | I ( t a )  X  X | = | I ( t this reduction, the number of variables is equal to the num-ber of equivalence classes. Let us call ILP with reduced variable as ILP red , with variables B =( b 0 ,b 1 , ..., b where | B | is the number of equivalence classes. A value k of variable b i means there are k transactions from equiva-lence class i in the tidset, hence it is constrained to be at most the number of variables it substitutes. Variable reduc-tion is illustrated in example 3.
 Example 3. Consider mining FFT T -pattern from the database in Figure 1. Let the itemset X = { a, b } . As de-scribed previously, transactions containing same number of items in X are considered equivalent. Hence, transaction 3 (resp: variable a 3 )is equivalent to transaction 4 since they both contain 2 items, while transactions 1 and 2 are dif-ferent since they contain 0 and 1 item respectively. Hence, there are 3 equivalence classes, b 1 representing tidset { 1 } b representing tidset { 2 } , and b 3 representing tidset { 3 These variables are constrained to be at most 1, 1, and 2 re-spectively.

Using this technique, this problem becomes tractable since the number of variables is generally small, as is shown in Section 5. Having a solution B for ILP red , the number of support-tidsets satisfying B , denoted as |S B ( X ) | computed using equation (6), where n i is the number of transactions in equivalence class i . Example 4. Continuing Example 3, we have n 1 =1 , n 2 = 1 , and n 3 =2 . If we consider one transaction of class 1 ( b 1 =1 ), none of class 2 ( b 2 =0 ), and one of class 3 ( b 3 =1 ), B =(1 , 0 , 1) representing 1 1  X  1 0  X  2 1 =2 tidsets, viz. { 1 , 3 } and { 1 , 4 } .

Total size of all transactions in S B ( X ) can be calculated as |S B ( X ) | X  ( | B | lutions of ILP red gives the total size of all support transac-tions, from which the average transaction size can be com-puted.

Since there can be multiple solutions A and B for ILP and ILP red , the set of all distinct solutions A and B is de-noted as A and B respectively. To summarize, the objective of ILP is to enumerate B , in order to find the statistical information of A .

In order to obtain the equivalence classes of transactions, we need to maintain an aggregation statistic which con-cisely represents the connectivity in the database.
The choice of the aggregation statistic needed depends on the variant of FFT-patterns being considered. Example 5 gives a broad view of what aggregation statistics are main-tained and how to calculate them.
 Example 5. Consider the problem of mining S T ( X ) .In this problem, all transactions containing the same number of items are equivalent . Hence, we maintain the number of miss es of every transaction. To speed up the variable reduc-tion process we can also maintain the number of transac-tions containing the same number of items as another ag-gregation statistic. The speed up occurs because instead of enumerating all transactions, we only need to enumerate the equivalence classes.

Let us consider current itemset X = { a, b } in the database in Figure 1. We maintain the statistic that transac-tion 1 contains zero item, transaction 2 contains one item, and transactions 3 and 4 contain both items. To speed up the reduction process, we can also maintain the statistic that there are two transactions (regardless of which transactions they are) that contain both items, one transaction that con-tains one, and one transaction that contains no items in X .
These aggregation statistics can be maintained effi-ciently. Since we are using a backtracking algorithm, at most one item is added or removed at one time. Thus, in the worst case this operation needs O ( |T | ) iterations. Details of the specific aggregation statistic used in each variant are explained in section 5.
In this section, we present algorithms based on the BIAS framework for the three FFT-pattern variants described in section 3.2.
Recalling the definition, a pattern ( Y  X  X )isanFFT T -pattern if it satisfies the criterion of transaction relaxation as stated in section 3.2 ( ILP T in section 4.2). Since there is no relaxation on the number of miss es on each item, each transaction is independent of each other. Hence the tidset Y supporting X is unique, i.e. the set of all transactions containing at least | X | X  t items in X .

In this problem, the information about the number of ap-pearances or number of miss es of each transaction is suffi-cient to determine S T ( X ) . These two variables can be used interchangeably since the number of appearances equals the size of the itemset less the number of miss es. For the sake of efficiency, we use the number of appearances as the ag-gregation statistic. 5.1.1 Number of appearances as aggregation statistic Given itemset X , one way to calculate its frequency is by maintaining the number of appearances of each transaction, denoted as count a .If x is the last added item in the back-tracking step, count a can be maintained by increasing the count of all transactions containing x . Hence, every update needs | T ( x ) | iterations. The complexity is O ( |T | ) worst case but O (  X . |T | ) in the expected case where  X  is the density of database. This approach has complexity propor-tional to the database X  X  density, which is desirable since the database is generally sparse.

To deduce the supporting tidsets, we need to maintain another aggregation statistic , which stores the number of transactions for every distinct value in count a . This is de-noted as count c , i.e. count c x = |{ t | count a t = x }| ample 5). This statistic can be maintained concurrently with the former, therefore the additional cost needed is constant. The support of an itemset can be calculated by summing count c from index | X | X  t to | X | , which needs t +1 iter-ations. This technique requires |T | integers to store count and X max integers to store count c . 5.1.2 Bitmap representation of aggregation statistic Another way to represent the aggregation statistic is by us-ing X max bitmaps , where bit t in bitmap c is set if and only if transaction t miss es c items. The insertion process is shown in following pseudo-code. A similar algorithm can be derived for the removal process. As before, x cor-responds to the last added item, and miss x is the bitmap corresponding to transactions not containing item x .This operation needs O (  X   X  X max  X |T| ) iterations for each up-date and O (  X   X  X max  X |T| ) space. The symbol  X  represents the ratio between bit-wise and integer operations which is roughly 1/32 in a 32 bits processor, where 32 operations can be performed in one clock cycle. for i := X max  X  1 down to 0 count i +1 := count i +1  X  ( count i  X  miss x ) count i := count i  X  X  miss x
By sacrificing space, we can reduce X max to t by main-taining t +1 bitmaps in all recurrence levels. In this case, the maximum space allocated is O (  X   X  X max  X  t  X |T| ) ,but each update only needs O (  X   X  ( t +1)  X |T| ) iterations. This approach even though asymptotically inefficient, is very fast in practice because of the architecture of current processors. 5.1.3 Comparisons with other techniques A similar problem has been tackled by Pei et al in [9] and Koh and Yo in [6]. Both their algorithms, as ours, iterate the itemsets and then find their supporting transactions. Pei et al proposed the FT-Apriori algorithm [9] that enumerates itemsets using an apriori -like approach. FT-Apriori first finds all frequent itemsets with size t +1 . Then for each k , it generates candidates of size k +1 whose k -subsets are frequent. Once these candidates are accumulated, they are all checked using one pass of the database.

To generate one candidate X , the algorithm checks whether all its subsets are frequent in O( | X | 2 ) time, and then verifies whether X is frequent in another pass of the database taking O( |T |  X  | X | ) time.

The number of candidates generated in this approach is relatively small compared to that in backtracking. However, generation of the candidates itself is an expensive process, consuming most of the mining time. Another disadvantage of this approach is that it needs another database pass while processing itemsets of each size.

Koh and Yo presented VB-FT-Mine [6] which uses a backtracking technique similar to ours. However instead of using an aggregation statistic, they analyzed the recur-rence relation of the support-tidset. Let P ( X, d ) be the set of transactions which support itemset X when t = d .They show that P ( X  X  X  x } ,d )= P ( X, d  X  1)  X  ( P ( X, d )  X  hence this problem can be solved using dynamic program-ming [4]. The time and space complexity of VB-FT-Mine is exactly the same as ours using bitmap. This algorithm is fast because the recurrence relation happens to be simple, and using bitmaps is efficient.

Both approaches limit each item x  X  X to be contained in at least  X  supporting transactions. Our technique can eas-ily be adjusted to this requirement by iterating each item x  X  X , as is done in [9] and [6]. However, this constraint is neglected for the sake of consistency among all variants discussed in this paper.

A summary comparison among these three approaches is presented in Table 1. Our approaches representing the aggregation statistic as appearances and bitmaps are char-acterized by BIAS(appear) and BIAS(bit) respectively. N denotes the total number of frequent itemsets, and the con-stant  X  represents the ratio of time taken for bit operations to integer operations, which in this case is roughly 1/32.
Table 1 shows that no approach is totally superior com-pared to others. Given a sparse database and large tolerance , ILP FT (appear) seems promising, while ILP FT (bit) and VB-FT-Mine [6] might be faster in a dense database and with small t . These results must be viewed in light of the main focus of this paper which is to mine the statistical information of support-tidsets. This variant is incorporated to illustrate how the BIAS framework handles the criterion of transaction relaxation .
FFT TI -pattern is defined as a pattern that satisfies the criteria of item relaxation and transaction relaxation as de-fined in section 3 ( ILP T and ILP I in section 4.2). This problem is seemingly more complicated compared to the FFT T -pattern problem since each itemset might have mul-tiple support-tidsets.

Since the approach used in FFT T -pattern can be applied to handle the transaction relaxation , the pending problem is to generate FFT-patterns that satisfy the criterion of item relaxation . 5.2.1 Finding the maximum sized S TI A pattern is frequent if the size of its largest support-tidset is greater than or equal to  X  . Therefore finding the largest sized support-tidset can verify whether the pattern is fre-quent. This problem can be expressed as the ILP I ob-jective function to maximize |T | i =1 a i . Clearly, finding the maximum sized S TI is at most as difficult as generating S
TI . While it may seem easier, we show that finding the maximum result in ILP I is an NP-Complete problem. Lemma 2. Finding maximum |T | i =1 a i in ILP I is NP-Complete .
 Proof. To prove NP-Hardness we take the problem of find-ing Maximum Independent Set (MIS) in a graph which is a well-known NP-complete problem , and prove that MIS can be reduced into this problem. Given a graph G , the ob-jective of MIS is to find a maximum set of vertices, such that there is no edge between any pair of them. The reduc-tion is as follows. For every edge e ( u, v ) , add inequality u + v  X  1 in ILP I . This reduction is complete since the result of ILP I will be the maximum set of variables (ver-tices) which are not connected. Since this case is a subset of ILP I ,the ILP I problem is at least as hard as MIS ,im-plying that it is NP-Hard . Proving the completeness of its decision-problem ( k i =1 a i  X  K ) is straight-forward.
Since this problem is NP-Complete, we cannot expect to have a practically efficient solution unless P = NP .In our implementation, we check if itemsets are frequent by calculating the statistical information of the FFT-pattern. 5.2.2 Finding statistical information of S TI As in section 4.2, we reduce the number of variables by finding the equivalence classes. In this variant, two transac-tions are equivalent if they contain exactly the same itemset in X . It is easy to see that the maximum number of equiv-alence classes is bounded by min ( k, 2 | X | ) . Since | less than 10 in many real-world datasets [13], the number of variables is at most 1024, hence enumerating all solutions is feasible.

To make this process more efficient, we introduce some heuristics, i.e., we iterate from the most constrained variable and from the highest possible value (most constraining), to reduce the search space as much as possible. Our experi-mental results show that all solutions can be found fast.
Once a solution B for ILP red I is obtained (section 4.2), we can calculate the desired statistic using equation (6).
A pattern ( Y  X  X ) is an FFT P -pattern if it satisfies the criterion of pattern relaxation as given in section 3 ( ILP in section 4.2). In this problem, transactions are equivalent if they miss the same number of items in X . Let variable b represent the equivalence class for transactions miss ing i items in X . Note that only transactions that miss one to items are important. Therefore, the number of equivalence classes, which is also the number of variables in ILP red equal to p . ILP red P itself is formulated as follows: 5.3.1 Finding the maximum sized S P Let Y max be the largest tidset in S P . The problem of find-ing Y max can be optimally solved using a greedy algorithm which continuously takes transactions with the lowest num-ber of miss es, until the total number of miss es exceeds This algorithm takes O ( |T | ) iterations. By maintaining the number of transactions that miss the same number of items, the complexity can be reduced to O ( p ) . 5.3.2 Finding statistical information of S P As in FFT TI -pattern, we can find the statistical information by enumerating B in ILP red P (c.f. (7) and section 4.2). To show the bound of the number of solutions, we first intro-duce the term partition number [1].
 Definition 5. [P ARTITION NUMBER ] Partition number of an integer n means the number of distinct multi-sets of pos-itive integers that add-up to n , denoted as part ( example, part (3) = 3 , since 3 = 3, 2+1, and 1+1+1. part (4) = 5 , since 4 = 4, 3+1, 2+2, 2+1+1, and 1+1+1+1, and so on. Each multi-set that adds-up to n is called a par-tition of n .

Let the number of transactions missing i items be de-noted as n i . We show that |B| is bounded by part ( p ) . Lemma 3. |B| is bounded by part( p ).
 Proof. It should be clear that if the number of transactions that miss i items, n i =  X  for all i , then |B| is equal to part( p ). Now if the total number of miss es in B equals then it is a partition of p . Otherwise, b 1 = n 1 , i.e. all transactions missing one item are already considered in B . This is true, because if b 1 &lt;n 1 , we can always increase b 1 (i.e. we can add transactions missing one item to B ), implying that B was not maximal. Assuming we have n 1 =  X  , we can always increase b 1 until the number of misses in B equals p , so that it becomes a partition of p .This partition is a unique extension for any maximal B . Hence, all B are subsets of distinct partitions of p , implying that |B| is at most part(
Lemma 3 shows that the number of maximal B is bounded by part ( p ) , which is quite small for small p .For example, part (10) = 42 and part (20) = 627 . In a prac-tical situation, we don X  X  need p to be larger than 20, and hence enumerating all solutions is feasible.

The algorithm to generate B is same as the one in section 5.2.2. We iterate the variable from the most constrained (having most number of miss es), and most constraining (choosing the variable with highest value, so that we start with the largest number of transactions possible). The num-ber of iterations is bounded by O ( p  X  part ( p )) . It can be shown by assuming we have enough n 1 that this algorithm will generate subsets of partition of p (similar to the proof of Lemma 3).
All approaches are implemented in C++ and evaluated on an AMD 2.2 GHz machine with 2GB main memory. In all experiments the items are sorted in a non-decreasing or-der of appearances in the database. This performs best com-pared to other ordering techniques in our empirical studies.
For the experiments we used synthetic datasets gener-ated using the IBM market-basket data generator. We used two different datasets, a small database (400 items, 10,000 transactions) to show the effect of parameters and com-parison between approaches, and a practical-sized database (1,000 items, 100,000 transactions) to show the scalability of our approach in real world applications. The density of the databases is varied from 0.5% to 4% as in real-world market basket data. We demonstrate this problem using the small database. The result of FT-apriori algorithm isn X  X  plotted since it takes too long. Figure 2(a) shows the scalability of the algorithms while varying minimum support. We observe that in this case, BIAS(appear) performs best, followed closely by VB-FT-Mine then BIAS(bit). This is due to the operation X  X  com-plexity, while VB-FT-Mine only needs one  X  and  X  and one  X  or  X  operations, BIAS(bit) needs 2  X  and  X  X , 2  X  or  X  X , and 1  X  not  X  operations (refer to section 5.1).

However, VB-FT-Mine only finds the number of trans-actions which miss less than or equal to t items, while both BIAS(appear) and BIAS(bit) maintain the number of trans-actions that miss all 0 to t items. In the case this statistic is useful -as in other variants, VB-FT-Mine cannot be used (i.e. it needs post processing).
Figure 2(b) shows that BIAS(appear) is more affected by density compared to BIAS(bit). From this experiment, we can conclude that if we have a sparse database, we should use BIAS(appear) to maintain the aggregation statistic, and otherwise use BIAS(bit). All of these behaviors are as ex-pected as they follow the characteristics given in Table 1.
As we X  X e already mentioned, this problem tries to re-duce the number of FT-patterns by relaxing the constraint (it doesn X  X  consider item relaxation ). In practical-sized database and t &gt; 1 , this problem is intractable. To con-clude, this problem is not scalable in terms of database size and t as has also been discussed in [9].
For this problem, we use the practical-sized dataset. Fig-ure 2(c) shows the scalability of our algorithm. Even though CompleteQB [11] doesn X  X  tackle exactly the same problem, it is used as competitor because to the best of our knowl-edge, there are no other relevant references. In our work, the objective is to mine all frequent itemsets along with the statistical information of associated patterns, while that of [11] is to mine all maximal quasi-bicliques.

It can be seen that the number of frequent itemsets in-creases as the density increases and as the minimum sup-port decreases. Using the BIAS framework, the time taken is almost linear to the number of frequent itemsets. Com-pleteQB [11] algorithm takes longer than one hour (the operation was terminated), because the number of FFT-patterns is much larger than the number of frequent itemsets as shown in Figure 2(d). The results also show that enumer-ating all results in market-basket database is meaningless since we might get as many as 10 72 (!) FFT-patterns, while there are only 1,600 frequent itemsets.

Experimenting with the value of i , it is interesting to observe that the value of i doesn X  X  increase the number of frequent itemsets much, even though the number of FFT-patterns grows exponentially (Figure 2(e)). This fact can-not be discovered if we enumerate all patterns as in Com-pleteQB .
Since this variant hasn X  X  been mentioned previously, we can X  X  compare the efficiency of BIAS with any other ap-proach. However, the experimental results in a practical-sized dataset indicate that this algorithm is efficient and scalable. Figure 2(f) shows that the time needed is ap-proximately linear to the number of frequent itemsets. The number of frequent itemsets itself scales similar to classical frequent-itemsets, which grows exponentially as the density increases and/or as the minimum support decreases.
In this problem, the number of frequent itemsets is also much smaller compared to FFT P -patterns, even though the ratio is not as dramatic as in FFT TI -pattern. For example in database with 4% density and 0.5% minimum support, with FFT-patterns, which is around 7%.

As seen in Figure 2(g), the ratio becomes smaller as p increases and minimum support decreases. Similar to the previous problem, the value of p doesn X  X  affect the number of FFT-itemsets much (Figure 2(h)). We have generalized the problem of mining fixed-value FFT-patterns into relaxation criteria and constraints, and have shown that these criteria and constraints can be used to derive several available variants of FFT-patterns, as well as many new definitions. For FFT-patterns mining in trans-actional database, we proposed to mine only statistical in-formation of the corresponding FFT-patterns, and we have shown with several experiments that such statistics are suf-ficient to describe the characteristic of an itemset.
We have developed a new framework called BIAS framework for mining FFT-patterns based on backtracking algorithm, ILP constraints, and aggregation statistics. We have also shown that this framework can be used to effi-ciently mine several variants of FFT-patterns.

For future work, we plan to analyze the utility of statis-tical information in real world data. We are also interested in analyzing the impact of each relaxation criteria, and in researching the problem using proportional relaxation. This technique may also be applied to other problems such as sequential mining, stream mining, and graph mining. [1] M. Abramowitz and I. A. Stegun, eds. Handbook of
Mathematical Functions . Dover Publications, New York, 1964. [2] R. Agrawal, T. Imielinski, and A. N. Swami. Mining as-sociation rules between sets of items in large databases.
In Proc. of SIGMOD , pages 207 X 216, 1993. [3] J. Besson, R. G. Pensa, C. Robardet, and J-F. Boulicaut.
Constraint-based mining of fault-tolerant patterns from boolean data. In Proc. of KDID , pages 55 X 71, 2005. [4] T. Cormen, C. Leiserson, R. Rivest, and C. Stein. In-troduction to Algorithms . MIT Press, Cambridge, MA, 2001. [5] S. I. Gass. Linear Programming: Methods and Appli-cations . McGraw-Hill, New York, 1985. [6] J-L. Koh and P.-W. Yo. An efficient approach for min-ing fault-tolerant frequent patterns based on bit vector representations. In Proc. of DASFAA , pages 568 X 575, 2005. [7] J. Liu, S. Paulsen, X. Sun, W. Wang, A. B. Nobel, and
J. Prins. Mining approximate frequent itemsets in the presence of noise: Algorithm and analysis. In Proc. of
SDM , 2006. [8] K. Narita and H. Kitagawa. Mining frequent itemsets from noisy data. In Proc. of ICDEW , page 117, 2006. [9] J. Pei, A. K. H. Tung, and J. Han. Fault-tolerant fre-quent pattern mining: Problems and challenges. In Proc. of DMKD , 2001. [10] J. K. Sepp  X  anen and H. Mannila. Dense itemsets. In
Proc. of SIGKDD , pages 683 X 688, 2004. [11] K. Sim, J. Li, V. Gopalkrishnan, and G. Liu. Mining maximal quasi-bicliques to co-cluster stocks and finan-cial ratios for value investment. In Proc. of ICDM , pages 1059 X 1063, 2006. [12] M. Steinbach, P.-N. Tan, and V. Kumar. Support en-velopes: a technique for exploring the structure of asso-ciation patterns. In Proc. of SIGKDD , pages 296 X 305, 2004. [13] A. Veloso, B. Gusm  X  ao Rocha, M. de Carvalho, and W. Meira Jr. Real World Association Rule Mining. In
Proc. of BNCOD , pages 77 X 89, 2002. [14] C. Yang, U. M. Fayyad, and P. S. Bradley. Efficient discovery of error-tolerant frequent itemsets in high di-mensions. In Proc. of SIGKDD , pages 194 X 203, 2001.
