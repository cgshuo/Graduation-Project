 James Cheng  X  Yiping Ke  X  Wilfred Ng Abstract The increasing prominence of data streams arising in a wide range of advanced applications such as fraud detection and trend learning has led to the study of online mining of frequent itemsets (FIs). Unlike mining static databases, mining data streams poses many new challenges. In addition to the one-scan nature, the unbounded memory requirement and the high data arrival rate of data streams, the combinatorial explosion of itemsets exacerbates the mining task. The high complexity of the FI mining problem hinders the application of the stream mining techniques. We recognize that a critical review of existing techniques is needed in order to design and develop efficient mining algorithms and data structures that are able to match the processing rate of the mining with the high arrival rate of data streams. Within a unifying set of notations and terminologies, we describe in this paper the efforts and main techniques for mining data streams and present a comprehensive survey of a number of the state-of-the-art algorithms on mining frequent itemsets over data streams. We classify the stream-mining techniques into two categories based on the window model that they adopt in order to provide insights into how and why the techniques are useful. Then, we further analyze the algorithms according to whether they are exact or approximate and, for approx-imate approaches, whether they are false-positive or false-negative .Wealsodiscussvarious interesting issues, including the merits and limitations in existing research and substantive areas for future research.
 Keywords Frequent itemsets  X  Stream mining  X  Window models  X  Approximate algorithms 1 Introduction Frequent itemset mining [ 1 ] has been well recognized to be fundamental to many important classifiers [ 32 ] and clusters [ 43 ]. There is a great amount of work that studies mining frequent itemsets on static databases and many efficient algorithms [ 22 ] have been proposed.
Recently, the increasing prominence of data streams has led to the study of online mining of frequent itemsets, which is an important technique that is essential to a wide range of emerging applications [ 20 ], such as web log and click-stream mining, network traffic anal-ysis, trend analysis and fraud detection in telecommunications data, e-business and stock market analysis, and sensor networks. With the rapid emergence of these new application domains, it has become increasingly difficult to conduct advanced analysis and data mining over fast-arriving and large data streams in order to capture interesting trends, patterns and exceptions.

Unlike mining static databases, mining data streams poses many new challenges. First, it is unrealistic to keep the entire stream in the main memory or even in a secondary storage area, since a data stream comes continuously and the amount of data is unbounded. Second, traditional methods of mining on stored datasets by multiple scans are infeasible, since the streaming data is passed only once. Third, mining streams requires fast, real-time processing in order to keep up with the high data arrival rate and mining results are expected to be available within short response times. In addition, the combinatorial explosion 1 of itemsets exacerbates mining frequent itemsets over streams in terms of both memory consumption and processing efficiency. Due to these constraints, research studies have been conducted on approximating mining results, along with some reasonable guarantees on the quality of the approximation.
In this paper, we survey a number of representative state-of-the-art algorithms [ 9  X  11 , 17 , closed itemsets [ 37 ] over data streams. We organize the algorithms into two categories based on the window model that they adopt: the landmark window or the sliding window . Each window model is then classified as time-based or count-based . According to the number of transactions that are updated each time, the algorithms are further categorized into update per transaction or update per batch . Then, we classify the mining algorithms into two categories: exact or approximate . We also classify the approximate algorithms according to the results they return: the false-positive approach or the false-negative approach. The false-positive also some infrequent itemsets, while the false-negative approach [ 45 ] returns a set of itemsets that does not include any infrequent itemsets but misses some frequent itemsets. We discuss the different issues raised from the different window models and the nature of the algorithms. We also explain the underlying principle of the ten algorithms and analyze their merits and limitations.

The rest of this paper is organized as follows. We first give the preliminaries and the notationinSect. 2 . Then, in Sects. 3 and 4 , we discuss the underlying techniques of various representative algorithms for mining frequent itemsets and identify their main features such as window models, update modes and approximation types. We present an overall analysis of the algorithms in Sect. 5 and discuss some future research and related work in Sect. 6 . Finally, we conclude the paper in Sect. 7 . 2 Preliminaries itemset consisting of k items is called a k-itemset and is written as x 1 x 2  X  X  X  x k . We assume that the items in an itemset are lexicographically ordered. A transaction is a tuple, ( tid , Y ) , where tid is the ID of the transaction and Y is an itemset. The transaction supports an itemset, X ,if Y  X  X . For simplicity, we may omit the tid when the ID of a transaction is irrelevant to the underlying idea of a mining algorithm.

A transaction data stream is a sequence of incoming transactions and an excerpt of the stream is called a window . A window, W , can be (1) either time-based or count-based ,and(2) either a landmark window or a sliding window . W is time-based if W consists of a sequence of fixed-length time units, where a variable number of transactions may arrive within each time unit. W is count-based if W is composed of a sequence of batches, where each batch consists of an equal number of transactions. W is a landmark window if W = T 1 , T 2 ,..., T  X  ; W is a sliding window if W = T  X   X  w + 1 ,..., T  X  , where each T i is a time unit or a batch, T 1 and T  X  are the oldest and the current time unit or batch, and w is the number of time units or batches in the sliding window, depending on whether W is time-based or count-based. Note that a count-based window can also be captured by a time-based window by assuming that a uniform number of transactions arrive within each time unit.

The frequency of an itemset, X ,in W , denoted as freq ( X ) , is the number of transactions in W that support X .The support of X in W , denoted as sup ( X ) ,isdefinedasfreq ( X )/ N , where N is the total number of transactions received in W . X is a Frequent Itemset (FI) in W ,ifsup ( X )  X   X  ,where  X  (0  X   X   X  1) is a user-specified minimum support threshold . X is a Frequent Maximal Itemset (FMI) in W ,if X is an FI in W and there exists no itemset Y in W such that X  X  Y . X is a Frequent Closed Itemset (FCI) in W ,if X is an FI in W and there exists no itemset Y in W such that X  X  Y and freq ( X ) = freq ( Y ) .
 Given a transaction data stream and a minimum support threshold,  X  , the problem of FI/FMI/FCI mining over a window, W , in the transaction data stream is to find the set of all FI s /FMI s /FCI s over W .
 To mine FIs/FMIs/FCIs over a data stream, it is necessary to keep not only the FIs/FMIs/ FCIs, but also the infrequent itemsets, since an infrequent itemset may become frequent later in the stream. Therefore, existing approximate mining algorithms [ 9  X  11 , 21 , 31 , 34 , 45 ]usea relaxed minimum support threshold (also called a user-specified error parameter ), ,where 0  X   X   X   X  1, to obtain an extra set of itemsets that are potential to become frequent later. We call an itemset that has support no less than a sub-frequent itemset (sub-FI). Example 2.1 Ta b l e 1 records the transactions that arrive on the stream within three successive time units or batches, each of which consists of five transactions.

Let  X  = 0 . 6and = 0 . 4. Assume that the model is landmark window. We obtain three consecutive windows, W 1 = T 1 , W 2 = T 1 , T 2 and W 3 = T 1 , T 2 , T 3 . The minimum frequencies of FI ( sub-FI) in W 1 , W 2 and W 3 are 5  X  = 3(5 = 2), 10  X  = 6(10 = 4) and 15  X  = 9(15 = 6), respectively. Assume that the model is a sliding window and the window size is w = 2. There are two successive windows, W 1 = T 1 , T 2 and W 2 = T 2 , T 3 .The minimum frequencies of FI (sub-FI) in both W 1 and W 2 are 10  X  = 6(10 = 4).

In Table 2 , we show all the FIs in all the above-described windows, while we also show the sub-FIs that are not FIs in italics. The number in the brackets shows the frequency of the itemset. All the FIs, except a and c in T 1 and T 1 , T 2 , are also FCIs since they have no superset that has the same frequency in the same window. All the frequent 2-itemsets are also MFIs. We also note that ac only becomes an FI in T 1 , T 2 , T 3 and T 2 , T 3 ; therefore, if we do not keep ac in T 1 and T 1 , T 2 in which ac is not an FI, we will miss ac in T 1 , T 2 , T 3 and T 2 , T 3 . Thus, it is necessary to use a relaxed minimum support threshold, , to keep an extra set of sub-FIs that have the potential to become FIs later in the stream.

A prevalently used data structure to represent the itemsets is the prefix tree structure [ 9  X  Example 2 .1. The nodes in the prefix tree are ordered according to the lexicographic order of the items stored in the node. Each path in the prefix tree represents an itemset, where the integer kept in the last node on the path is the frequency of the itemset. For example, the left-most path from the node labelled  X  a,4  X  to the node labelled  X  c,2  X  represents the item-set abc and the number  X  2  X  in the node labelled  X  c,2  X  is the frequency of abc .InFig. 1 , the nodes represented by solid circles are FIs, while those represented by dotted circles are sub-FIs that are not FIs.

As we mentioned earlier, most existing studies focus on mining approximate results due to the high complexity of mining data streams. In the approximate mining algorithms we are going to discuss, the frequency (or support) of an itemset, X , is an approximation of its actual frequency (or actual support ). We call this frequency (or support) of X the computed frequency (or computed support )of X . We denote the computed frequency (or computed support) of X as freq ( X ) (or sup ( X ) ) to distinguish it from its actual frequency (or actual We denote the upper bound for the error in the computed frequency of X as err ( X ) ,such frequency (or support) of an itemset, we mean the actual frequency (or actual support) of the itemset. 3 Mining over a landmark window In this section, we describe six algorithms on mining FIs/FMIs over a landmark window. We recent itemsets from old ones and then three others [ 9 , 21 , 29 ], presented in Sects. 3.4 and 3.6 , that place more importance on recent itemsets of a data stream than the old ones. 3.1 Lossy counting algorithm Manku and Motwani [ 34 ] propose the Lossy Counting algorithm for computing an approxi-mate set of FIs over the entire history of a stream. The stream is divided into a sequence of buckets and each bucket consists of B = 1 / transactions. Each bucket is also given an ID and the ID of the current bucket, bid  X  ,isassignedasbid  X  = N / B ,where N is the number of transactions currently in the stream. Lossy Counting processes a batch of transactions arriving on the stream at a time, where each batch contains  X  buckets of transactions.
Lossy Counting maintains a set of tuples, D , for the stream of transactions. Each tu-ple in D is of the form ( X , freq ( X ), err ( X )) ,where X is a sub-FI, freq ( X ) is assigned as the frequency of X ,since X is inserted into D and err ( X ) is assigned as an upper bound of the frequency of X before X is inserted into D . Lossy Counting updates D according to the following two categories:  X  UpdateEntry : For each tuple, ( X , freq ( X ), err ( X ))  X  D , add the frequency of X in the  X  AddEntry : If the frequency of an itemset, X , is at least  X  in the current batch and X is not
Since B = 1 / and bid  X  = N / B ,wehavebid  X   X  N . An itemset, X , is removed we have freq ( X )&lt; N if an itemset, X , is not in any tuple in D . At the point just before the current batch, we have N = ( bid  X   X   X  ), since there are  X  buckets in the current batch. Therefore, when a new itemset, X , is added to D , its frequency before the current batch can be at most N = ( bid  X   X   X  ) and thus err ( X ) = ( bid  X   X   X  ). As a result, Lossy Counting ensures tuples, ( X , freq ( X ), err ( X ))  X  D if freq ( X )  X  ( X   X  ) N .
 Implementation: The implementation of Lossy Counting in [ 34 ] consists of the following three main modules: Buffer , Trie and SetGen .

The Buffer module repeatedly fills the available main memory with as many incoming transactions as possible. The module computes the frequency of every item, x  X  I ,inthe current batch and prunes those items whose frequency is less than N . Then, the remaining items in the transactions are sorted.
The Trie module maintains the set, D , as a forest of prefix trees, where the prefix trees are ordered by the labels of their roots. A node, v , in a prefix tree corresponds to an tuple, (
X , freq ( X ), err ( X ))  X  D and v is also assigned a label as the last item in X so that X is rep-resented by the label path from the root to v . Manku and Motwani implement the Trie forest the forest, where the level of a node is the distance of the node from the root. The Trie array is maintained as a set of chunks. On updating the Trie array, a new Trie array is created and chunks from the old Trie are freed as soon as they are not required.

The SetGen module generates the itemsets that are supported by the transactions in the applies an Apriori-like pruning rule [ 2 ] such that no superset of an itemset will be generated if the itemset has a frequency less than  X  in the current batch. SetGen employs a priority queue, called Heap , which initially contains pointers to the smallest items of all transactions in the buffer. Pointers pointing to identical items are grouped together as a single entry in Heap. SetGen repeatedly processes the smallest item in Heap to generate a 1-itemset. If this 1-itemset is in Trie after the AddEntry or the UpdateEntry operation is utilized, SetGen is recursively invoked with a new Heap created out of the items that follow the smallest items in the same transactions. During each call of SetGen, qualified old itemsets are copied to the new Trie array according to their orders in the old Trie array, while at the same time new itemsets are added to the new Trie array in lexicographic order. When the recursive call returns, the smallest entry in Heap is removed and the recursive process continues with the next smallest item in Heap.
 Merits and limitations: A distinguishing feature of the Lossy Counting algorithm is that it outputs a set of itemsets that have the following guarantees:  X  All FIs are outputted. There are no false-negatives.  X  No itemset whose actual frequency is less than ( X   X  ) N is outputted.  X  The computed frequency of an itemset is less than its actual frequency by at most N .
However, using a relaxed minimum support threshold, , to control the quality of the approximation of the mining result leads to a dilemma. The smaller the value of ,the more accurate is the approximation but the greater is the number of sub-FIs generated, which requires both more memory space and more CPU processing power. However, if approaches  X  , more false-positive answers will be included in the result, since all sub-FIs whose com-puted frequency is at least ( X   X  ) N  X  0 are outputted while the computed frequency of the sub-FIs can be less than their actual frequency by as much as  X  N . We note that this problem also exists in other mining algorithms [ 9  X  11 , 21 , 29 , 31 ] that use a relaxed minimum support threshold to control the accuracy of the mining result. 3.2 Item-suffix frequent itemset forest Li et al. [ 31 ] develop a prefix-tree-based, in-memory data structure, called Item-suffix Fre-quent Itemset forest (IsFI-forest), based on which an algorithm, called DSM-FI, is devised to mine an approximate set of FIs over the entire history of a stream.

DSM-FI also uses a relaxed minimum support threshold, , to control the accuracy of the mining results. All generated sub-FIs are kept in IsFI-forest, which consists of a set of paired components, Header Table (HT) and Sub-Frequent Itemset tree (SFI-tree). For each sub-frequent item, x , DSM-FI constructs an HT and an SFI-tree. Then, for each unique item, head-link) into the HT of x or increments freq ( y ) if y already exists in the HT, where batch-id is the ID of the processing batch into which the entry is inserted and head-link points to first node created due to y in the SFI-tree of x . Each node in the SFI-tree has four fields, item, freq, batch-id, and node-link. Note that the edges between the parent and children of the tree are implicitly assumed. A path from the root node of x  X  X  SFI-tree to a node, v ,representsa sub-FI, whose prefix and suffix are x and v .item, respectively. Thus, v . freq keeps the com-puted frequency of the sub-FI and v . batch-id is the ID of the batch on processing which the sub-FI is inserted into the SFI-tree. If there will be another node, whose item is the same as v .item, inserted into the SFI-tree, then v .node-link will point to that node; otherwise, v . node-link is a NULL-pointer. Therefore, by tracing the IsFI-forest, we can find all sub-FIs and their computed frequencies.

For each transaction, x 1 x 2  X  X  X  x k  X  1 x k , in an incoming batch, DSM-FI projects the trans-and x k . Then, these item-suffix transactions are inserted into the SFI-trees of the correspond-DSM-FI simply increments its computed frequency. Meanwhile, DSM-FI inserts an entry for each item in the item-suffix transaction that does not exist in the HT, while it increments the computed frequency of other items that are in the HT.

Periodically, DSM-FI prunes those itemsets whose computed support is less than .The pruning may require reconnection of the nodes in an SFI-tree, since each root-to-node path, P , that represents a sub-FI X , also carries the frequency information of a set of sub-FIs that are subsets of X and have the same prefix as X .
 Example 3.1 Figure 2 shows an example of constructing an IsFI-forest and pruning infre-quent itemsets from the IsFI-forest. We consider constructing an IsFI-forest for two successive batches of transactions, { abde , acd , abe }and{ bcde , abcde , acde }, with the IDs being equal to 1 and 2, respectively.

The IsFI-forest in each of the subfigures is a set of paired HTs and SFI-trees, for each of the unique items, a , b , c , d and e . The HT entries are linked to the corresponding nodes in the SFI-tree via the head-links, while nodes of the same item in an SFI-tree are linked via node-links in the order of their insertion time. Both head-links and node-links are represented by dotted lines in the subfigures, while the parent-child edges are represented by solid lines.
Figure 2 a X  X  show the IsFI-forest constructed after processing the transactions in the first batch, { abde , acd , abe }. For the transaction abde , DSM-FI inserts three entries, ( b ,1,1), asshowninFig. 2 a. Similarly for abde  X  X  item-suffix transactions, bde , de and e ,theHT entries and the SFI-tree nodes are inserted into the HT and the SFI-tree of the items, b , d and e , respectively.

In Fig. 2 b, we can see that after adding the transaction acd , the frequencies of the cor-responding HT entries and SFI-tree nodes are incremented to 2 and a new pair of HT and SFI-tree is added for the new item c . Since the path acd does not exist in a  X  X  SFI-tree, it is added and a node-link from the old node ( d ,1,1) is linked to the new node ( d ,1,1). A similar update is performed for the next transaction, abe , as shown in Fig. 2 c.

After processing the first batch, DSM-FI performs pruning of the IsFI-forest. We assume that = 0 . 35: that is, all items whose computed frequency is less than 2 will be pruned. Thus, the HT and the SFI-tree of item c are pruned from the IsFI-forest in Fig. 2 c. Then, we search for c in the HTs of the other items. Since the path acd in a  X  X  SFI-tree actually carries the frequency information of the itemsets, a , ac , ad and acd , we need to reconnect a to d after deleting c , as shown in Fig. 2 d. Note that after the reconnection, the infrequent itemsets ac and acd are removed.

We then add the HT and the SFI-tree of item c back to the IsFI-forest for the second batch of transactions, { bcde , abcde , acde }. Note that the batch-id of the new HT entries and SFI-tree nodes in Fig. 2 eis2.

The batch-id kept in an HT entry and in an SFI-tree node is used to estimate the actual fre-quency of the corresponding itemset, X , represented by a node, v ,where freq ( X ) = v. freq, as described by the following equation. We assume that the number of transactions in each batch is the batch-size .
To output the FIs, DSM-FI first follows the HT of each item, x , to generate a maximal itemset 2 that contains x and all items in the HT of x . Next, DSM-FI traverses the SFI-tree of x via the node-links to obtain the computed frequency of the maximal itemset. Then, DSM-FI checks whether the maximal itemset is frequent. This checking is done by testing whether the right side of Eq. ( 1 )isnolessthan  X  N ,where X is the maximal itemset and N is the total number of transactions received so far. If the maximal itemset is frequent, DSM-FI generates the FIs that are subsets of the maximal itemset directly based on the maximal itemset (note that, however, we may still need to compute their exact computed frequency from the HTs and SFI-trees of related items). Otherwise, DSM-FI repeats the process on the ( k  X  1 ) -itemsets that are subsets of the maximal itemset and share the prefix x , assuming the maximal itemset has k items. The process stops when k = 2, since the frequent 2-itemsets can be found directly by combining each item in the HT with x .
 Example 3.2 Assume that  X  = 0 . 5: that is, all itemsets whose frequency is no less than 6  X  = 3 are FIs. We consider computing the set of FIs from the IsFI-forest shown in Fig. 2 e.
We start with the item, a , and find the maximal itemset, abcde . Since the computed frequency of abcde is 1, abcde is infrequent. We continue with abcde  X  X  subsets that are 4-itemsets and find that none of them is frequent. Then, we continue with the 3-itemsets that are abcde  X  X  subsets. We find that both abe and ade have a computed frequency of 3; hence, we generate their subsets, a , b , d , e , ab , ad , ae , be , de , abe and ade . These subsets are FIs and their computed frequency is then obtained from the HTs and the SFI-trees. Since there is no maximal itemset in a  X  X  SFI-tree other than abcde , we continue with the next item, b , and then other items, in a similar way.
 Merits and limitations: An SFI-tree is a more compact data structure than is a prefix tree. is not an FCI, then it is also represented by the same two paths. We remark that the number of FCIs approaches that of FIs when the stream becomes large. Moreover, the compactness of the data structure is paid for by the price of a higher computational cost, since more tree traversals are needed to gather the frequency information of the itemsets. 3.3 A Chernoff-bound-based approach Yu et al. [ 45 ] propose FDPM, which is derived from the Chernoff bound [ 16 ], to approximate a set of FIs over a landmark window. Suppose that there is a sequence of N observations and consider the first n ( n N ) observations as independent coin flips such that Pr ( head ) = p and Pr ( tail ) = 1  X  p .Let r be the number of heads. Then, the expectation of r is np .The Chernoff bound states, for any  X &gt; 0, are By substituting  X  r = r / n and = p  X  ,Eq.( 2 ) becomes Let  X  = 2 e Then, from Eq. ( 3 ), we derive
Equation ( 5 ) states that the probability of being a  X  head  X  X n n coin flips,  X  r , is within the range of [ p  X  , p + ] with a probability of at least (1  X   X  ). Yu et al. apply the Chernoff bound in the context of mining frequent itemsets as follows. Consider the first n transac-tions of a stream of N transactions as a sequence of coin flips such that for an itemset, X , Pr ( a transaction supports X ) = p . By replacing  X  r with freq ( X )/ n (i.e., the support of X in the n transactions) and p with freq ( X )/ N (i.e., the probability of a transaction supporting X in the stream), the following statement is valid: the support of an itemset, X ,inthefirst n transactions of a stream is within  X  of the support of X in the entire stream with a probability of at least (1  X   X  ).

The Chernoff bound is then applied to derive the FI mining algorithm FDPM by substitut-ing p in Eqs. ( 4 )and( 5 ) with  X  . Note that p corresponds to the actual support of an itemset in the stream, which varies for different itemsets, but  X  is specified by the user. The rationale for using a constant  X  in place of a varying p is based on the heuristic that  X  is the minimum support of all FIs, such that if this minimum support is satisfied, then all other higher support values are also satisfied.

The underlying idea of the FDPM algorithm is explained as follows. First, a memory bound , n 0  X  ( 2 + 2ln ( 2 / X ))/ X  , is derived from Eqs. ( 4 )and( 5 ). Given a probability parameter,  X  , and an integer, k .The batch size , B , is given as k  X  n 0 . Then, for each batch of B transac-tions, FDPM employs an existing non-streaming FI mining algorithm to compute all itemsets whose support in the current batch is no less than ( X   X  B ) ,where B = (by Eq. 4 ). The set of itemsets computed are then merged with the set of itemsets obtained so far for the stream. If the total number of itemsets kept for the stream is larger than c  X  n 0 , where c is an empirically determined float number, then all itemsets whose support is less than ( X   X  N ) are pruned, where N is the number of transactions received so far in the stream and N = frequency is no less than  X  N .
 Merits and limitations: Given  X  and  X  , the Chernoff bound provides the following guaran-tees on the set of mined FIs:  X  All itemsets whose actual frequency is no less than  X  N are outputted with a probability  X  No itemset whose actual frequency is less than  X  N is outputted. There are no false- X  The probability that the computed frequency of an itemset equals its actual frequency is
However, Eqs. ( 2 ) X ( 5 ) are computed with respect to n of N observations and the result of these n observations is exact, as in the application of the Chernoff bound in sampling [ 41 , 48 ]. On the contrary, in FDPM, infrequent itemsets are pruned for each new batch of transactions and some sub-FIs are pruned whenever the total number of sub-FIs kept exceeds c  X  n 0 . Thus, the result of these n observations (of a stream of N observations) in FDPM is not exact but already approximate, while the error in the approximation due to each pruning will propagate to each of the following approximations. Consequently, the quality of the approximation is degraded and worsen for each propagation of error in the approximations. 3.4 Mining recent frequent itemsets Chang and Lee [ 9 ] propose to use a decay rate , d (0 &lt; d &lt; 1), to diminish the effect of old transactions on the mining result. As a new transaction comes in, the frequency of an old itemset is discounted by a factor of d . Thus, the set of FIs returned is called recent FIs .
Assume that the stream has received  X  transactions, Y 1 , Y 2 ,..., Y  X  .The decayed total number of transactions , N  X  ,andthe decayed frequency of an itemset, freq  X  ( X ) ,aredefined as follows:
Thus, whenever a transaction, say the  X  th transaction, Y  X  , arrives in the stream, N  X   X  1 and the new transaction, Y  X  )to d  X  N  X   X  1 , which then gives N  X  .If Y  X  supports X , we also add one Therefore, the more frequent X is supported by recent transactions, the greater is its decayed frequency freq  X  ( X ) .

The algorithm, called estDec , for maintaining recent FIs is an approximate algorithm that adopts the mechanism in Hidber [ 26 ] to estimate the frequency of the itemsets. The itemsets generated from the stream of transactions are maintained in a prefix tree structure, D .An decayed frequency ,err  X  ( X ) is X  X  X  upper bound decayed frequency error , and tid ( X ) is the ID of the most recent transaction that supports X .

Except the 1-itemsets, whose computed decayed frequency is the same as their actual decayed frequency, estDec estimates the computed decayed frequency of a new itemset, X ( |
X | X  2), from those of X  X  X  ( | X | X  1 ) -subsets, as described by the following equation:
When X is inserted into D at the  X  th transaction, estDec requires all its ( | X | X  1 ) -subsets to be present in D before the arrival of the  X  th transaction. Therefore, at least ( | X | X  1 ) transactions are required to insert X into D . When these ( | X | X  1 ) transactions are the most Thus, we obtain another upper bound for freq  X  ( X ) as follows:
In Eq. ( 9 ), ins (0  X  ins &lt; X  ) is the user-specified minimum insertion threshold by which estDec inserts an itemset into D if its decayed support is no less than ins .Theterm recent ( | X | X  1 ) transactions, while ( 1  X  d | X | X  1 )/( 1  X  d ) is the decayed frequency of X over the ( | X | X  1 ) transactions. By combining Eqs. ( 8 )and( 9 ), estDec assigns the decayed frequency of a new itemset, X , as follows: bound decayed frequency as described by the following equation. where
For each incoming transaction, say the  X  th transaction, Y  X  , estDec first updates N  X  . Then, for each subset, X ,of Y  X  that exists in D , estDec computes freq  X  ( X ) = freq tid ( X ) ( X )  X  d where prn (0  X  prn &lt; X  ) is the user-specified minimum pruning threshold ,then X and all its supersets are removed from D .However, X is still kept if it is a 1-itemset, since the frequency of a 1-itemset cannot be estimated later if it is pruned, as indicated by Eq. ( 8 ).
After updating the existing itemsets, estDec inserts new sub-FIs into D . First, each new 1-itemset, X , is inserted into D with freq  X  ( X ) = 1, err  X  ( X ) = 0, and tid ( X ) =  X  . Then, for each n -itemset, X ( n  X  2), that is a subset of Y  X  and not in D ,ifall X  X  X  ( n  X  1 ) -subsets freq  X  ( X )  X  ins N  X  , estDec inserts X into D , with err  X  ( X ) computed as described previously and tid ( X ) =  X  . Finally, estDec outputs all recent FIs in D whose decayed frequency is at least  X  N  X  .

As will be shown in our overall analysis in Sect. 5 , we derive the support error bound of a result itemset X and the false results returned by estDec as follows: Merits and limitations: The use of a decay rate diminishes the effect of the old and obsolete information of a data stream on the mining result. However, estimating the frequency of an itemset from the frequency of its subsets can produce a large error and the error may propagate all the way from the 2-subsets to the n -supersets, while the upper bound in Eq. ( 9 ) is too loose. Thus, it is difficult to formulate an error bound on the computed frequency of the resulting itemsets and a large number of false-positive results will be returned, since the computed frequency of an itemset may be much larger than its actual frequency. Moreover, the update for each incoming transaction (instead of a batch) may not be able to handle high-speed streams. 3.5 Mining FIs at multiple time granularities Giannella et al. [ 21 ] propose to mine an approximate set of FIs using a tilted-time window model [ 13 ], that is, the frequency of an itemset is kept at a finer granularity for more recent time frames and at a coarser granularity for older time frames. For example, we may keep the frequency of an FI in the last hour, the last 2 h, the last 4 h, and so on.

The itemsets are maintained in a data structure called FP-stream , which consists of two components: the pattern-tree and the tilted-time window . The pattern-tree is a prefix-tree-based structure. An itemset is represented by a root-to-node path and the end node of the path keeps a tilted-time window that maintains the frequency of the itemset at different time granularities. The pattern-tree can be constructed using the FP-tree construction algorithm in [ 25 ]. Figure 3 shows an example of an FP-stream. The tilted-time window of the itemset, bc , shows that bc has a computed frequency of 11, ( 11 + 12 ) = 23, ( 23 + 20 ) = 43 and ( 43 + 45 ) = 88 over the last 1, 2, 4 and 8 h, respectively. Based on this schema, we need only ( log 2 ( 365  X  24 ) + 1 ) = 15 frequency records instead of ( 365  X  24 ) = 8 , 760 records to keep one year X  X  frequency information. To retrieve the computed frequency of an itemset over the last T time units, the logarithmic tilted-time window guarantees that the time granularity error is at most T / 2 . Updating the frequency records is done by shifting the recent records to merge with older records and the logarithmic scale allows the update to be processed with O ( 1 ) amortized number of shifting and merging operations.

To reduce the number of frequency records in the tilted-time windows, the old frequency records of an itemset, X , are pruned as follows. Let freq j ( X ) be the computed frequency of X over a time unit T j and N j be the number of transactions received within T j ,where 1  X  j  X   X  .Forsome m ,where1  X  m  X   X  , the frequency records freq are pruned if the following condition holds:
The first line in Eq. ( 14 ) finds a point, n , in the stream such that before that point, the computed frequency of the itemset, X , is less than the minimum frequency required within every time unit, i.e., from T 1 to T n . Then, the second line in Eq. ( 14 ) computes the time unit, T , within T 1 and T n , such that at any time unit T l within T 1 and T m , the sum of the computed support of X from T 1 to T l is always less than the relaxed minimum support threshold, . Thus, the frequency records of X within T 1 and T m can be considered as unpromising and are pruned.

The pruning ensures that if we return all itemsets whose computed frequency is no less than ( X   X  ) N over a time interval, T ,where N is the total number of transactions received within T , then we will not miss any FIs over T and the computed frequency of the returned itemsets is less than their actual frequency by at most N .

The FP-streaming mining algorithm computes a set of sub-FIs at the relaxed minimum support threshold, , over each batch of incoming transactions by using the FI mining algo-rithm, FP-growth [ 25 ]. For each sub-FI X obtained, FP-streaming inserts X into the FP-stream if X is not in the FP-stream. If X is already in the FP-stream, then the computed frequency of X over the current batch is added to its tilted-time window. Next, pruning is performed on the tilted-time window of X and if the window becomes empty, FP-growth stops mining supersets of X by the Apriori property [ 2 ]. After all sub-FIs mined by FP-growth are updated in the FP-stream, the FP-streaming scans the FP-stream and, for each itemset X visited, if X is not updated by the current batch of transactions, the most recent frequency in X  X  X  tilted-time window is recorded as 0. Pruning is then performed on X . If the tilted-time window of some itemset visited is empty (as a result of pruning), the itemset is also pruned from the FP-stream. Merits and limitations: The tilted-time window model allows us to answer more expressive time-sensitive queries, at the expense of more than one frequency record kept for each item-set. The tilted-time window also places greater importance on recent data than on old data as does the sliding window model; however, it does not lose the information in the historical data completely. A drawback of the approach is that the FP-stream can become very large over time and updating and scanning such a large structure may degrade the mining throughput. 3.6 Mining frequent maximal itemsets Lee and Lee [ 29 ] extend the estDec algorithm [ 9 ] to approximate a set of FMIs. The same decay mechanism applied in estDec is also applied to their work. However, instead of using the simple prefix tree structure, the authors propose a compressed prefix tree structure called CP-tree . The structure of the CP-tree is described as follows.

Let D be the prefix tree used in estDec. Given a merging gap threshold  X  ,where0  X   X   X  1, if all the itemsets stored in a subtree S of D satisfy the following equation, then S is com-pressed into a node in the CP-tree. where X is the root of S and Y is an itemset in S .

Assume S is compressed into a node v in the CP-tree. The node v consists of the following the right-most leaf of S .
 Example 3.3 Figure 4 shows a prefix tree and its corresponding CP-tree. The subtree S in the prefix tree is compressed a single node v 3 in the CP-tree as indicated by the dotted arrow. The item-list of v 3 , b , c , corresponds to the labels, b and c , of the two nodes in S .The position of the item-list of v 2 in the CP-tree and the parent of the node c in S (i.e., b )isnow in the first position of the item-list of v 3 in the CP-tree.
The extended mining algorithm is the same as estDec, except that it is now performed on the compressed nodes. Since the nodes are compressed nodes, the FIs are processed using the item-list and the parent-list . To obtain the set of FMIs, the CP-tree is traversed to output the FMIs (cf. the details of checking of the checking of whether an itemset is an FMI can be consulted from [ 24 ]). The frequency of the FMIs is estimated using the same frequency estimation mechanism used in estDec. Note that for mining FMIs, only freq min  X  is needed, while freq max  X  is used to estimate the frequency of other FIs.
 Merits and limitations: The merits and limitations of estDec [ 9 ]alsoapplyto[ 29 ]. However, the use of the CP-tree results in the reduction of memory consumption, which is vital in mining data streams. The CP-tree can also be used to mine the FIs, however, the error rate of the computed frequency of the FIs, which is estimated from freq min  X  and freq max  X  , will be further increased. Thus, the CP-tree is more suitable for mining FMIs. 4 Mining over a sliding window In this section, we describe three algorithms on mining FIs/FCIs over a sliding window, the first two from Chang and Lee [ 10 , 11 ] are presented in Sect. 4.1 . They produce approximate results. The last one [ 17 ] is presented in Sect. 4.2 which computes exact mining results. 4.1 Mining FIs over a sliding window Algorithm estWin . Chang and Lee propose the estWin algorithm [ 10 ] to maintain FIs over a sliding window. The itemsets generated by estWin are maintained in a prefix tree structure (cf. see the discussion of the merits and limitations of [ 9 ] in Sect. 3.4 ), D . An itemset, X ,in D has the following three fields: freq ( X ) ,err ( X ) and tid ( X ) ,where freq ( X ) is assigned as the frequency of X in the current window since X is inserted into D ,err ( X ) is assigned as an upper bound for the frequency of X in the current window before X is inserted into D , and tid ( X ) is the ID of the transaction being processed, for X is inserted into D .
For each incoming transaction Y with an ID tid  X  , estWin increments the computed fre-quency of each subset of Y in D .Let N be the number of transactions in the window and tid 1 be the ID of the first transaction in the current window. We prune an itemset X and inserted into D at some transaction that arrived before the current sliding window, since tid 1 is the ID of the first transaction in the current window, and thus freq ( X ) is the actual frequency of X within the current window. On the other hand, the expression tid ( X )&gt; tid 1 means that X is inserted into D at some transaction that arrived within the current sliding window and hence the expression ( N  X  ( tid ( X )  X  tid 1 )) returns the number of transactions that arrived within the current window since the arrival of the transaction having the ID tid ( X ) .Wenote that X itself is not pruned if it is a 1-itemset, since estWin estimates the maximum frequency error of an itemset based on the computed frequency of its subsets [ 26 ] and thus the frequency of a 1-itemset cannot be estimated again if it is deleted.

After updating and pruning existing itemsets, estWin inserts new itemsets into D .Itfirst for each new itemset, X  X  Y ( | X | X  2), if all X  X  X  subsets having size ( | X | X  1 ) (or simply ( |
X | X  1 ) -subsets) are in D before the arrival of Y ,thenestWininserts X into D .estWin assigns freq ( X ) = 1 and tid ( X ) = tid  X  and estimates err ( X ) as described by the following equation:
For each expiring transaction of the sliding window, those itemsets in D that are subsets is decreased by 1; otherwise, no change is made since the itemset is inserted by a transaction that comes later than the expiring transaction. Then, pruning is performed on X as described before.

Finally, for each itemset, X ,in D , estWin outputs X as an FI if (1) tid ( X )  X  tid 1 and freq ( X )  X   X  N , or (2) tid ( X )&gt; tid 1 and ( freq ( X ) + err ( X ))  X   X  N . For our overall analysis in Sect. 5 , we derive the support error bound of a resulting itemset, X , and the false results returned by estWin as follows:
A lossy-counting-based algorithm. Chang and Lee also propose another similar method [ 11 ] to maintain FIs over a sliding window based on the estimation mechanism of the Lossy Counting algorithm [ 34 ]. The same prefix tree structure, D , is used to keep the itemsets. An itemset, X ,in D keeps freq ( X ) , which is assigned as the frequency of X in the current window since X is inserted into D , and tid ( X ) , which is the ID of the transaction under processing when X is inserted into D .

For each incoming transaction, Y , with an ID tid  X  , the algorithm increments the computed frequency of each subset of Y in D and inserts every new itemset, X  X  Y ,into D with freq ( X ) = 1 and tid ( X ) = tid  X  .

For each subset, X , of an expiring transaction, where X exists in D , if tid ( X )  X  tid 1 , then freq ( X ) is decreased by 1. We prune X and all X  X  X  supersets if (1) tid ( X )  X  tid 1 and ( tid ( X )  X  tid 1 ) is the maximum possible frequency of X in the current window before the arrival of the transaction having the ID tid ( X ) .
Finally, for each itemset, X ,in D , X is outputted as an FI, if (1) tid ( X )  X  tid 1 and freq ( X )  X   X  N , or (2) tid ( X )&gt; tid 1 and ( freq ( X ) + ( tid ( X )  X  tid 1 ) )  X   X  N . Merits and limitations: The sliding window model captures recent pattern changes and trends. However, performing the update for each incoming and expiring transaction is usu-ally much less efficient than batch-processing, especially in a large search space as in the case of FI mining using a relaxed minimum support threshold. Thus, these methods may not be able to cope with high-speed data streams that involve millions of transactions generated from some real-life applications. 4.2 Mining FCIs over a sliding window Chietal.[ 17 , 18 ] propose the Moment algorithm to incrementally update the set of FCIs over a sliding window. They design an in-memory prefix-tree-based structure, called the Closed Enumeration Tree (CET), to maintain a dynamically selected set of itemsets over a sliding-window.

Let v X be a node representing the itemset X in the CET. The dynamically selected set of itemsets (nodes) are classified into the following four types.  X  Infrequent Gateway Nodes ( IGN ): v X is an IGN if (1) X is infrequent, (2) v Y is the parent  X  Unpromising Gateway Nodes ( UGN ): v X is a UGN if (1) X is frequent, and (2)  X  Y  X  Intermediate Nodes ( IN ): v X is an IN if (1) X is frequent, (2) v X is the parent of v Y such  X  Closed Nodes ( CN ): v X is a CN if X is an FCI.
 Example 4.1 Figure 5 shows an example of a CET constructed for the set of transactions, { cd , ab , abc , abc }, where  X  = 0 . 5 and the number of transactions in each sliding window is 4. The CET is similar to the prefix tree shown in Example 2 .1 in Sect. 2 , except that there are four types of nodes. The nodes represented by dotted circles are IGNs, those by dotted squares are UGNs, those by solid circles are INs, and those by solid squares are CNs.
By the Apriori property [ 2 ], all supersets of an infrequent itemset are not frequent. Thus, an IGN, v X , has no descendants and there is no node, v Y , in the CET such that Y  X  X .If v X is a UGN, then none of v X  X  X  descendants is a CN; otherwise v X is a CN but not a UGN. A UGN, v X , also has no descendants, since no CNs can be found there. Thus, not all itemsets need to be kept in the CET, even though Moment computes the exact mining result.
For each incoming transaction, Moment traverses the parts of the CET that are related to the transaction. For each node, v X , visited, Moment increments its frequency and performs the following updates to the CET according to the change in v X  X  X  node type:  X  v X is an IGN: If X now becomes frequent, then (1) for each left sibling v Y of v X ,Moment  X  v X is a UGN: If v X now becomes an IN or a CN, then Moment checks if new descendants  X  v X is an IN: v X may now become a CN but no other update is made to the CET due to v X .  X  v X is a CN: v X will remain a CN and no update is made to the CET due to v X .
Note that for any node created for a new itemset, Moment needs to scan the current window to compute its frequency.
 Example 4.2 Assume that we have an incoming transaction acd . Now, we update the CET in Fig. 5 to give the CET in Fig. 6 . The frequency of all subsets of acd in Fig. 5 is incremented by one. The IN labelled  X  a,3  X  and the UGN labelled  X  c,2  X  X nFig. 5 now become CNs in Fig. 6 , since they have no supersets that have the same frequency as theirs. The IGN labelled  X  d,1  X  now becomes frequent; as a consequence, an IGN  X  d,1  X  X ndaCN X  d,2  X  are added to the CET. The IGN  X  d,1  X  X nFig. 5 becomes a UGN  X  d,2  X  X nFig. 6 because of the CN  X  d,2  X , which represents an FCI cd . The item b is not in acd and thus the subtree rooted at b in Fig. 5 is irrelevant to the update.
 When a transaction expires from the sliding window, Moment traverses the parts of the CET that are related to the transaction. For each node, v X , visited, Moment decrements its frequency and performs the following updates to the CET.  X  X is infrequent: v X remains an IGN and no update is made to the CET due to v X .  X  X is frequent: Example 4.3 Assume the transaction cd has expired. We now update the CET in Fig. 6 to give the CET in Fig. 7 . The frequency of all subsets of cd in Fig. 6 is decremented by one. The UGN  X  d,2  X  X nFig. 6 now becomes an IGN  X  d,1  X  X nFig. 7 . As a consequence, the IGN  X  d,1  X  X ndtheCN X  d,2  X  X nFig. 6 are deleted. The CN  X  c,4  X  X nFig. 6 also becomes a UGN  X  c,3  X  X nFig. 7 because it has the same frequency as its superset CN  X  c,3  X . Other nodes in Fig. 6 are irrelevant to the update and thus unchanged in Fig. 7 .
 Merits and limitations: The merit of Moment is that it computes the exact set of FCIs over a sliding window. Although an update to a node may result in a propagation of the node insertion and deletion in the CET, most of the nodes related to an incoming or expiring trans-action do not change their type often. Therefore, the average update cost in the CET is small. However, since Moment performs the update for each incoming transaction, it may not be efficient enough to handle bursts and very high-speed streams. Moreover, the CET can be huge for a large window, even though a subset of the itemsets can be derived from IGNs and UGNs. 5 An overall analysis FIs/MFIs/FCIs over data streams [ 9  X  11 , 17 , 21 , 29 , 31 , 34 , 45 ]thatwehavediscussedinthe previous sections of this paper. Then, we present an overall analysis of these algorithms by referencing Table 3 . 5.1 Window model and update interval Among the nine algorithms mentioned in Table 3 , six adopt a landmark window model. While the first three landmark window algorithms [ 31 , 34 , 45 ] lose the time information of the itemsets mined, the damped landmark window model [ 9 , 29 ] favors recent itemsets by diminishing exponentially the effect of old transactions and the tilted landmark window model [ 21 ] partitions the window according to a logarithmic scale with the recent frequency of an itemset recorded at a finer granularity. The other three algorithms [ 10 , 11 , 17 ] consider the most recent excerpt of a stream by adopting a sliding window model.

Out of the nice window models, two [ 21 , 31 ] are time-based while the other are count-based. In general, time-based windows are more flexible than count-based windows, since they do not need to accumulate a fixed number of transactions in buffer before the min-ing can be processed. Although a count-based window in which the update interval is per transaction still processes each expiring/incoming transaction at real time, processing each transaction against the entire stream in most cases is less efficient than processing a batch of transactions against the entire stream. In general, batch processing is more suitable for high-speed data streams. We note that batch processing here refers to processing a batch of trans-actions at a time and then using the mining results of the batch to update the results of the entire window seen so far, while we refer to the process of updating each transaction against the entire window as tuple processing .Thus,inTable 3 , the algorithms proposed by Manku and Motwani [ 34 ] and Li et al. [ 31 ] are actually by tuple processing, although their update interval is per batch. 5.2 Approximation type, support error bound and false results [ 45 ], which adopts a false-negative approach.

The false-positive approaches use a relaxed minimum support threshold, , to reduce the number of false-positive results and to obtain a more accurate frequency of the result item-sets. However, a larger set of sub-FIs will have to be kept for a smaller . The false-negative approach also uses a relaxed minimum support threshold, ; however, the use of this lowers the probability of discarding an infrequent itemset that may become frequent later. Although a more accurate answer also requires a smaller , which generates more sub-FIs, the false-negative approach uses a second relaxed minimum support threshold, , that is increased gradually over time. This threshold, , restricts the sub-FIs to be kept in memory to only those whose support is no less than . When a sufficient number of transactions have been received in the stream, approaches  X  and hence the number of sub-FIs kept is greatly reduced.
The error bound in the computed support and the possible false mining results of most of the false-positive approaches [ 11 , 21 , 31 , 34 ] are implied by The Lossy Counting algorithm [ 34 ]. The false-negative approach [ 45 ] claims that the computed support is the same as the actual support with probability of at least ( 1  X   X ) and each itemset in the exact mining result is outputted with probability of at least ( 1  X   X ) . We are not able to give unified equations to describe the support error bound and false mining results for the algorithms proposed by [ 9 , 10 , 29 ]. We refer the reader to the respective sections for the details.
Chi et al. [ 17 ] compute exact mining results over a sliding window. However, exact mining requires a huge amount of memory and CPU resources to keep track of all itemsets in the window and their actual frequency, even with a compact data structure as the one used in [ 17 ]. Mining FCIs may reduce the memory consumption since the set of FCIs is in general smaller than the set of FIs, but it still depends on the characteristics of the data stream. 5.3 Empirical analysis We analyze the performance of the algorithms according to the empirical studies in the respective papers that propose the algorithms.
 Li et al. [ 31 ] compare the performance of their DSM-FI algorithm to that of the Lossy Counting algorithm by Manku and Motwani [ 34 ] on a synthetic dataset. According to their experiments, DSM-FI is more efficient than Lossy Counting by up to an order of magnitude and consumes less memory. Moreover, both the processing time and memory consumption of DSM-FI are more stable than those of Lossy Counting.

Yu et al. [ 45 ] also compare their FDPM algorithm to Lossy Counting. With an increase in the minimum support threshold  X  , both the CPU time and the memory consumption of FDPM becomes significantly less than those of Lossy Counting. FDPM achieves high recall of over 95 and 100% precision, while Lossy Counting has 100% recall and at least 46% precision. The performance of FDPM is very stable for varying , while that of Lossy Counting is greatly influenced by .Forsmall , Lossy Counting achieves high precision, but consumes more memory and is slower, while for large , Lossy Counting uses small memory and runs faster, at the expense of lowered precision.
 Lee and Lee [ 29 ] compare their algorithm estDec+ with estDec [ 9 ]. Since estDec+ mines FMIs, the processing time of estDec+ is considerably smaller than that of estDec, which mines FIs. The memory consumption of estDec+ is also considerably smaller than that of estDec due to the use of a compressed prefix tree structure in estDec+.

The landmark window model that Giannella et al. [ 21 ] adopt is specialized in the context (i.e. tilted-time window), thus their algorithm is not comparable to the others. However, their experiments record high throughput and low memory consumption of their algorithm.
Chi et al. [ 17 ] mine FCIs instead of FIs; their algorithm is thus not comparable with those algorithms that mine FIs. However, they compare their performance with the mine-from-scratch approach, that is, using the FCI mining algorithm CHARM [ 47 ]tominethe set of FCIs for each sliding window. Their results show that their algorithm outperforms the mine-from-scratch approach by over an order of magnitude.

Of the three algorithms of sliding window model, the two proposed by Chang and Lee [ 10 , 11 ] only report the memory consumption in terms of the number of itemsets maintained and no comparison with other algorithms is provided. Thus, it is difficult for us to judge the performance of these algorithms. 6 Other issues of mining data streams We first discuss in Sects. 6.1  X  6.3 three important issues for the improvement of mining high-speed data streams. Then, we discuss the related work in Sect. 6.4 . 6.1 Exact mining versus approximate mining Exact mining requires keeping track of all itemsets in the window and their actual frequency, because any infrequent itemset may become frequent later in the stream. However, the num-ber of all itemsets is O ( 2 | I | ) , making exact mining computationally intractable, in terms of both CPU and memory. Although exact mining may still be applicable for small sliding windows and for streams with relatively low data arrival rates, it is more realistic to com-pute approximate mining results over landmark windows or large sliding windows. In fact, approximation is a widely adopted technique in most of the stream-processing applications [ 20 ]. In the context of data mining, in most cases the goal is to identify generic, interest-ing or  X  X ut-of-the-ordinary X  patterns rather than to provide results that are exact to the last decimal. Thus, approximate but instant answers, with reasonable accuracy, are particularly well-suited.

Approximating a set of FIs/FMIs/FCIs over a stream involves estimating both the set of 31 , 34 ], the set of sub-FIs kept is often too large in order to obtain a highly accurate answer. Thus, throughput is decreased and memory consumption is increased due to the processing of a large number of sub-FIs. A possible solution to this problem is first to use a constant low-ered minimum support threshold to compute a set of potential FIs and then to use a gradually increasing lowered minimum support threshold to control the total number of sub-FIs kept in memory, as do Yu et al. [ 45 ]. We may consider the characteristics of different data streams to design specific (non-decreasing) functions to monitor the minimum support threshold at different points of a stream, thereby more effectively improving the mining accuracy and efficiency. It is also possible to design approximate algorithms that are neither false-positive nor false-negative but achieve both high recall and precision. 6.2 Load shedding in processing high-speed data streams Data streams are push-based and data arrival rates are high and often bursty. When the load of mining exceeds the capacity of the system, load shedding is needed to keep up with the arrival rates of the input streams. Several issues need to be considered when applying load shedding to process mining on data streams. First, we need to approximate the processing rate; that is, the number of transactions per unit of time that the system is able to handle. Thus, we need to consider the characteristics of a stream, such as the average size of a transaction and of an FI, as well as the memory requirement at the particular processing rate. Then, when the arrival rate of a stream is higher than the processing rate, we need to determine a technique to shed the load, such as random sampling [ 41 , 48 ] or semantic drop and window reduction [ 40 ] or selective processing (i.e., processing only certain portions of the window). For the load shedding tech-nique chosen, we also need to analyze the quality of the approximate mining results obtained. 6.3 Different types of FIs The exploratory nature of FI mining often results in a large number of FIs generated and handling such a large number of itemsets severely degrades the mining efficiency. A possible The set of FCIs is a complete and non-redundant representation of the set of FIs [ 46 ]andthe former is often orders of magnitude smaller than the latter. This significant reduction in the size of the result set leads to faster speed and less memory consumption in computing FCIs than in computing FIs. In addition, the set of FCIs also facilitates the generation of a set of non-redundant association rules [ 46 ].

Although many efficient algorithms [ 42 , 47 ] on mining FCIs on static databases have been proposed, the only algorithm on mining FCIs (at the time of writing) is the Moment algorithm for data streams proposed by Chi et al. [ 17 ]. However, since Moment computes the exact set of FCIs and processes every transaction against the entire window, it is not efficient enough for handling high-speed streams and it consumes too much memory when the window becomes large. Therefore, a study of mining an approximate set of FCIs over a sliding window with reasonable guarantees on the quality of the approximation would be worthwhile. However, we note that it may not be feasible to mine FCIs over a landmark window since the number of FCIs approaches that of FIs when the window becomes very large.

When the number of FCIs is still too large, we may consider to mine FMIs [ 29 ]. Since the number of FMIs is orders of magnitude smaller than that of FIs and FCIs in most cases, it has been shown by Gouda and Zaki [ 24 ] that mining MFIs is significantly more efficient, in terms of both CPU and memory, than mining FIs and FCIs. However, a problem of FMIs is that FMIs lose the frequency information of their subset FIs and hence the error bound of the estimated frequency of the FIs recovered from the FMIs will be significantly increased. proposed. These concise representations of FIs are not only significantly smaller in size, but also able to recover the set of FIs with highly accurate frequency. Thus, it is also possible to consider mining these concise representations of FIs over the data streams. A challenge of mining these concise representations is how to efficiently update the concise set of FIs at the high arrival rate of the streaming data. Since each transaction may change the status of a large number of FIs (from concise FIs to normal FIs and vice versa), batch processing with efficient incremental update on a batch of transactions may be a better choice. 6.4 Other related work A closely related work to mining FIs over streams is the mining of frequent items over data However, mining FIs is far more challenging than counting singleton items due to the com-binatorial explosion of the number of itemsets.

Extensive research has been conducted on querying processing and data management in data streams. The issues of data models, query languages in the context of data streams are the main research topics. We refer readers to the excellent surveys by Babcock et al. [ 4 ]and Golab and  X zsu[ 23 ].

Some prior work on streaming algorithms for mining FIs include Carma [ 26 ]and SWF [ 30 ]. Carma scans a transaction database twice to mine the set of all FIs, where the first scan of Carma can be applied to compute a false-positive set of FIs over a landmark window. SWF mines the exact set of all FIs over a time-based sliding window. SWF first computes the set of all FIs over the first window and then it requires only one scan of the database for each incremental update. However, scanning the entire window for each slide may not be efficient enough to handle high-speed data streams.

For the recent development of FI/FCI mining over data streams, we are aware of the following two studies.
Jin and Agrawal [ 28 ]developthe StreamMining Algorithm using potential frequent 2-itemsets and the Apriori property to reduce the number of candidate itemsets. They also design a memory-resident summary data structure that implements a compact prefix tree us-ing a hash table. Their algorithm is approximate and false-positive, which has deterministic bounds on the accuracy. The window model they adopt is the landmark window and they do not distinguish recent data from old data.

Cheng et al. [ 14 ] adopt a sliding window model to approximately mine FIs over data streams. The main contribution of this work is that it proposes a progressively increasing minimum support function to address the dilemma caused by in most of the existing algo-rithms. When an itemset is retained in the window longer, the technqiue requires its minimum support threshold to approach the minimum support of an FI. As a result, it is able to increase to significantly improve the mining efficiency and save memory consumption, at the expense of only slightly degraded accuracy. The proposed algorithm of this work, called MineSW , is shown by Cheng et al. to outperform an improved version of the algorithm proposed by Chang and Lee [ 11 ] that apply Lossy Counting [ 34 ] algorithm to mine FIs over a sliding window. 7 Conclusions In this paper, we provide a survey of research on mining data streams. We focus on frequent itemset mining and have tried to cover both early and recent literature related to mining FIs or FCIs. In particular, we have discussed in detail a number of the state-of-the-art algorithms [ 9  X  11 , 17 , 21 , 29 , 31 , 34 , 45 ] on mining FIs, FMIs or FCIs over data streams. Moreover, we have addressed the merits and the limitations and presented an overall analysis of the algorithms, which can provide insights for end-users in applying or developing an appropriate algorithm for different streaming environments and various applications. We have also identified and discussed possible future research issues on mining algorithms.

We believe that as many new streaming applications and sensor network applications are becoming more mature and popular, streaming data and sensor data are also becoming richer. More high-speed data streams are generated in different application domains, such as mil-lions of transactions generated from retail chains, millions of calls from telecommunication companies, millions of ATM and credit card operations processed by large banks, and mil-lions of hits logged by popular Web sites. Mining techniques will then be very significant in order to conduct advanced analysis, such as determining trends and finding interesting patterns, on streaming data. It is our intention to present this survey to simulate interests in utilizing and developing the previous studies into emerging applications.
 References Authors Biography
