 Over the past few years, there has been consid-erable progress in the ability of manually created large-scale grammars, such as the English Resource Grammar (ERG, Copestake and Flickinger (2000)) or the ParGram grammars (Butt et al., 2002), to parse wide-coverage text and assign it deep seman-tic representations. While applications should ben-efit from these very precise semantic representa-tions, their usefulness is limited by the presence of semantic ambiguity: On the Rondane Treebank (Oepen et al., 2002), the ERG computes an aver-age of several million semantic representations for each sentence, even when the syntactic analysis is fixed. The problem of appropriately selecting one of them to work with would ideally be solved by statistical methods (Higgins and Sadock, 2003) or knowledge-based inferences. However, no such approach has been worked out in sufficient detail to support the disambiguation of treebank sentences.
As an alternative, Bos (2008) proposes to com-pute the weakest reading of each sentence and then use it instead of the  X  X rue X  reading of the sentence. This is based on the observation that the readings of a semantically ambiguous sentence are partially ordered with respect to logical entailment, and the weakest readings  X  the minimal (least informative) readings with respect to this order  X  only express  X  X afe X  information that is common to all other read-ings as well. However, when a sentence has mil-lions of readings, finding the weakest reading is a hard problem. It is of course completely infeasible to compute all readings and compare all pairs for entailment; but even the best known algorithm in the literature (Gabsdil and Striegnitz, 1999) is only an optimization of this basic strategy, and would take months to compute the weakest readings for the sentences in the Rondane Treebank.

In this paper, we propose a new, efficient ap-proach to the problem of computing weakest read-ings. We follow an underspecification approach to managing ambiguity: Rather than deriving all semantic representations from the syntactic analy-sis, we work with a single, compact underspecified semantic representation, from which the semantic representations can then be extracted by need. We then approximate entailment with a rewrite sys-tem that rewrites readings into logically weaker readings; the weakest readings are exactly those readings that cannot be rewritten into some other reading any more (the relative normal forms ). We present an algorithm that computes the relative nor-mal forms, and evaluate it on the underspecified de-scriptions that the ERG derives on a 624-sentence subcorpus of the Rondane Treebank. While the mean number of scope readings in the subcorpus is in the millions, our system computes on average 4.5 weakest readings for each sentence, in less than twenty milliseconds; over 80% of all sentences are reduced to at most two weakest readings. In other words, we make it feasible for the first time to build an application that uses the individual (weakest) semantic representations computed by the ERG, both in terms of the remaining ambiguity and in terms of performance. Our technique is not lim-ited to the ERG, but should be applicable to other underspecification-based grammars as well.

Technically, we use underspecified descriptions that are regular tree grammars derived from dom-inance graphs (Althaus et al., 2003; Koller et al., 2008). We compute the weakest readings by in-tersecting these grammars with other grammars representing the rewrite rules. This approach can be used much more generally than just for the com-putation of weakest readings; we illustrate this by showing how a more general version of the redun-dancy elimination algorithm by Koller et al. (2008) can be seen as a special case of our construction. Thus our system can serve as a general framework for removing unintended readings from an under-specified representation.

The paper is structured as follows. Section 2 starts by reviewing related work. We recall domi-nance graphs, regular tree grammars, and the basic ideas of underspecification in Section 3, before we show how to compute weakest readings (Section 4) and logical equivalences (Section 5). In Section 6, we define a weakening rewrite system for the ERG and evaluate it on the Rondane Treebank. Section 7 concludes and points to future work. The idea of deriving a single approximative seman-tic representation for ambiguous sentences goes back to Hobbs (1983); however, Hobbs only works his algorithm out for a restricted class of quantifiers, and his representations can be weaker than our weakest readings. Rules that weaken one reading into another were popular in the 1990s underspeci-fication literature (Reyle, 1995; Monz and de Rijke, 2001; van Deemter, 1996) because they simplify logical reasoning with underspecified representa-tions. From a linguistic perspective, Kempson and Cormack (1981) even go so far as to claim that the weakest reading should be taken as the  X  X asic X  reading of a sentence, and the other readings only seen as pragmatically licensed special cases.
The work presented here is related to other ap-proaches that reduce the set of readings of an un-derspecified semantic representation (USR). Koller and Niehren (2000) showed how to strengthen a dominance constraint using information about anaphoric accessibility; later, Koller et al. (2008) presented and evaluated an algorithm for redun-dancy elimination, which removes readings from an USR based on logical equivalence. Our system generalizes the latter approach and applies it to a new inference problem (weakest readings) which they could not solve.

This paper builds closely upon Koller and Thater (2010), which lays the formal groundwork for the Figure 1: A dominance graph describing the five readings of the sentence  X  X t is not the case that every representative of a company saw a sample. X  work presented here. Here we go beyond that paper by applying a concrete implementation of our RTG construction for weakest readings to a real-world grammar, evaluating the system on practical inputs, and combining weakest readings with redundancy elimination. This section briefly reviews two formalisms for specifying sets of trees: dominance graphs and regular tree grammars. Both of these formalisms can be used to model scope ambiguities compactly by regarding the semantic representations of a sen-tence as trees. Some example trees are shown in Fig. 2. These trees can be read as simplified for-mulas of predicate logic, or as formulas involv-ing generalized quantifiers (Barwise and Cooper, 1981). Formally, we assume a ranked signature  X  of tree constructors { f , g , a ,... } , each of which is equipped with an arity ar ( f )  X  0 . We take a (finite constructor) tree t as a finite tree in which each node is labelled with a symbol of  X  , and the number of children of the node is exactly the arity of this symbol. For instance, the signature of the constructor trees can be seen as ground terms over  X  that respect the arities. We write T (  X  ) for the finite constructor trees over  X  . 3.1 Dominance graphs A (labelled) dominance graph D (Althaus et al., 2003) is a directed graph that consists of a col-lection of trees called fragments , plus dominance edges relating nodes in different fragments. We dis-tinguish the roots W D of the fragments from their holes , which are the unlabelled leaves. We write L D : W D  X   X  for the labeling function of D .
The basic idea behind using dominance graphs to model scope underspecification is to specify the  X  X emantic material X  common to all readings as fragments, plus dominance relations between these fragments. An example dominance graph D is shown in Fig. 1. It represents the five read-ings of the sentence  X  X t is not the case that every representative of a company saw a sample. X 
Each reading is encoded as a (labeled) configura-tion of the dominance graph, which can be obtained by  X  X lugging X  the tree fragments into each other, in a way that respects the dominance edges: The source node of each dominance edge must dom-inate (be an ancestor of) the target node in each configuration. The trees in Fig. 2 are the five la-beled configurations of the example graph. 3.2 Regular tree grammars Regular tree grammars (RTGs) are a general gram-mar formalism for describing languages of trees (Comon et al., 2007). An RTG is a 4-tuple G = ( S , N ,  X  , P ) , where N and  X  are nonterminal and ter-minal alphabets, S  X  N is the start symbol, and P is a finite set of production rules. Unlike in context-free string grammars (which look super-ficially the same), the terminal symbols are tree constructors from  X  . The production rules are of the form A  X  t , where A is a nonterminal and t is a tree from T (  X   X  N ) ; nonterminals count as having arity zero, i.e. they must label leaves. A derivation starts with a tree containing a single node labeled with S . Then in each step of the derivation, some leaf u which is labelled with a nonterminal A is expanded with a rule A  X  t ; this results in a new tree in which u has been replaced by t , and the derivation proceeds with this new tree. The lan-guage L ( G ) generated by the grammar is the set of all trees in T (  X  ) that can be derived in this way.
Fig. 3 shows an RTG as an example. This gram-mar uses sets of root names from D as nonterminal symbols, and generates exactly the five configura-tions of the graph in Fig. 1.

The languages that can be accepted by regular tree grammars are called regular tree languages Figure 3: A regular tree grammar that generates the five trees in Fig. 2. (RTLs) , and regular tree grammars are equivalent to finite tree automata , which are defined essen-tially like the well-known finite string automata, except that they assign states to the nodes in a tree rather than the positions in a string. Regular tree languages enjoy many of the closure properties of regular string languages. In particular, we will later exploit that RTLs are closed under intersection and complement. 3.3 Dominance graphs as RTGs An important class of dominance graphs are hy-pernormally connected (hnc) dominance graphs (Koller et al., 2003). The precise definition of hnc graphs is not important here, but note that virtually all underspecified descriptions that are produced by current grammars are hypernormally connected (Flickinger et al., 2005), and we will restrict our-selves to hnc graphs for the rest of the paper.
Every hypernormally connected dominance graph D can be automatically translated into an equivalent RTG G D that generates exactly the same configurations (Koller et al., 2008); the RTG in Fig. 3 is an example. The nonterminals of G D are always hnc subgraphs of D . In the worst case, G D can be exponentially bigger than D , but in practice it turns out that the grammar size remains manage-able: even the RTG for the most ambiguous sen-tence in the Rondane Treebank, which has about 4 . 5  X  10 12 scope readings, has only about 75 000 rules and can be computed in a few seconds. Now we are ready to talk about computing the weakest readings of a hypernormally connected dominance graph. We will first explain how we ap-proximate logical weakening with rewrite systems. We will then discuss how weakest readings can be computed efficiently as the relative normal forms of these rewrite systems. 4.1 Weakening rewrite systems The different readings of a sentence with a scope ambiguity are not a random collection of formulas; they are partially ordered with respect to logical entailment, and are structurally related in a way that allows us to model this entailment relation with simpler technical means.

To illustrate this, consider the five configurations in Fig. 2. The formula represented by (d) logically entails (c); we say that (c) is a weaker reading than (d) because it is satisfied by more models. Similar entailment relations hold between (d) and (e), (e) and (b), and so on (see also Fig. 5). We can define the weakest readings of the dominance graph as the minimal elements of the entailment order; in the example, these are (b) and (c). Weakest read-ings capture  X  X afe X  information in that whichever reading of the sentence the speaker had in mind, any model of this reading also satisfies at least one weakest reading; in the absence of convincing dis-ambiguation methods, they can therefore serve as a practical approximation of the intended meaning of the sentence.

A naive algorithm for computing weakest read-ings would explicitly compute the entailment order, by running a theorem prover on each pair of config-urations, and then pick out the minimal elements. But this algorithm is quadratic in the number of configurations, and therefore impractically slow for real-life sentences.

Here we develop a fast algorithm for this prob-lem. The fundamental insight we exploit is that entailment among the configurations of a domi-nance graph can be approximated with rewriting rules (Baader and Nipkow, 1999). Consider the re-lation between (d) and (c). We can explain that (d) entails (c) by observing that (c) can be built from (d) by exchanging the positions of the adjacent quantifiers  X  x and  X  y ; more precisely, by applying the following rewrite rule: The body of the rule specifies that an occurrence of  X  x which is the direct parent of an occurrence of  X  y may change positions with it; the subformulas P , Q , and R must be copied appropriately. The annota-tion [  X  ] specifies that we must only apply the rule to subformulas in negative logical polarity: If the quantifiers in (d) were not in the scope of a nega-tion, then applying the rule would actually make the formula stronger . We say that the rule (1) is logically sound because applying it to a subformula with the correct polarity of some configuration t always makes the result t 0 logically weaker than t . We formalize these rewrite systems as follows. We assume a finite annotation alphabet Ann with a special starting annotation a 0  X  Ann ; in the exam-ple, we had Ann = { + ,  X  X  and a 0 = + . We also assume an annotator function ann : Ann  X   X   X  N  X  Ann . The function ann can be used to traverse a tree top-down and compute the annotation of each node from the annotation of its parent: Its first argument is the annotation and its second argu-ment the node label of the parent, and the third argument is the position of the child among the par-ent X  X  children. In our example, the annotator ann models logical polarity by mapping, for instance, etc. We have labelled each node of the configura-tions in Fig. 1 with the annotations that are com-puted in this way.
 Now we can define an annotated rewrite system R to be a finite set of pairs ( a , r ) where a is an anno-tation and r is an ordinary rewrite rule. The rule (1) above is an example of an annotated rewrite rule with a =  X  . A rewrite rule ( a , r ) can be applied at the node u of a tree t if ann assigns the annotation a to u and r is applicable at u as usual. The rule then rewrites t as described above. In other words, an-notated rewrite systems are rewrite systems where rule applications are restricted to subtrees with spe-cific annotations. We write t  X  R t 0 if some rule of R can be applied at a node of t , and the result of rewriting is t 0 . The rewrite system R is called linear if every variable that occurs on the left-hand side of a rule occurs on its right-hand side exactly once. 4.2 Relative normal forms The rewrite steps of a sound weakening rewrite sys-tem are related to the entailment order: Because ev-ery rewrite step transforms a reading into a weaker reading, an actual weakest readings must be such that there is no other configuration into which it can be rewritten. The converse is not always true, i.e. there can be non-rewritable configurations that are not weakest readings, but we will see in Sec-tion 6 that this approximation is good enough for practical use. So one way to solve the problem of computing weakest readings is to find readings that cannot be rewritten further.

One class of configurations that  X  X annot be rewritten X  with a rewrite system R is the set of nor-mal forms of R , i.e. those configurations to which no rule in R can be applied. In our example, (b) and (c) are indeed normal forms with respect to a rewrite system that consists only of the rule (1) . However, this is not exactly what we need here. Consider a rewrite system that also contains the fol-lowing annotated rewrite rule, which is also sound for logical entailment: This rule would allow us to rewrite the configuration (c) into the tree  X  ( comp z ,  X  (  X  y ( sample y ,  X  x ( repr  X  of x , z , see But this is no longer a configuration of the graph. If we were to equate weakest readings with normal forms, we would erroneously classify (c) as not being a weakest reading. The correct concept for characterizing weakest readings in terms of rewriting is that of a relative normal form . We define a configuration t of a dominance graph D to be a R -relative normal form of (the configurations of) D iff there is no other configuration t 0 of D such that t  X  R t 0 . These are the configurations that can X  X  be weakened further without obtaining a tree that is no longer a configuration of D . In other words, if R approximates entailment, then the R -relative normal forms approximate the weakest readings. 4.3 Computing relative normal forms We now show how the relative normal forms of a dominance graph can be computed efficiently. For lack of space, we only sketch the construction and omit all proofs. Details can be found in Koller and Thater (2010).

The key idea of the construction is to repre-sent the relation  X  R in terms of a context tree transducer M , and characterize the relative nor-mal forms of a tree language L in terms of the pre-image of L under M . Like ordinary regular tree transducers (Comon et al., 2007), context tree transducers read an input tree, assigning states to the nodes, while emitting an output tree. But while ordinary transducers read the input tree symbol by symbol, a context tree transducer can read multiple symbols at once. In this way, they are equivalent to the extended left-hand side transducers of Graehl et al. (2008).
 We will now define context tree transducers. Let  X  be a ranked signature, and let X m be a set of m variables. We write Con ( m ) (  X  ) for the contexts with m holes, i.e. those trees in T (  X   X  X m ) in which each element of X m occurs exactly once, and always as a leaf. If C  X  Con ( m ) (  X  ) , then C [ t 1 ,..., t ables from left to right.

A (top-down) context tree transducer from  X  to  X  is a 5-tuple M = ( Q ,  X  ,  X  , q 0 ,  X  ) .  X  and  X  are ranked signatures, Q is a finite set of states, and q 0  X  Q is the start state.  X  is a finite set of transition rules of the form q ( C [ x 1 ,..., x n ])  X  D [ q 1 ( x i where C  X  Con ( n ) (  X  ) and D  X  Con ( m ) (  X  ) .
If t  X  T (  X   X   X   X  Q ) , then we say that M derives t in one step from t , t  X  M t 0 , if t is of the form C [ q ( C [ t 1 ,..., t n ])] for some C 0  X  Con ( 1 ) (  X  ) , t of the form C 0 [ D [ q 1 ( t i a rule q ( C [ x 1 ,..., x n ])  X  D [ q 1 ( x i  X  . The derivation relation  X   X  M is the reflexive, transitive closure of  X  M . The translation relation  X 
M of M is  X 
M = { ( t , t
For each linear annotated rewrite system R , we can now build a context tree transducer M R such that t  X  R t 0 iff ( t , t 0 )  X   X  M traverses t from the root to the leaves, keeping track of the current annotation in its state. M R can nondeterministically choose to either copy the current symbol to the output tree unchanged, or to apply a rewrite rule from R . The rules are built in such a way that in each run, exactly one rewrite rule must be applied.

We achieve this as follows. M R takes as its states the set {  X  q } X  X  q a | a  X  Ann } and as its start state the state q a 0 . If M R reads a node u in state q , this means that the annotator assigns annota-tion a to u and M R will rewrite a subtree at or below u . If M R reads u in state  X  q , this means that M R will copy the subtree below u unchanged because the rewriting has taken place elsewhere. Thus M R has three types of rewrite rules. First, for any f  X   X  , we have a rule  X  q ( f ( x 1 ,..., x n ))  X  1  X  i  X  n , we have a rule q a ( f ( x 1 ,..., x n ))  X  deterministically chooses under which child the rewriting should take place, and assigns it the correct annotation. Finally, we have a rule q ( C [ x 1 ,..., x n ])  X  C 0 [  X  q ( x i rewrite rule C [ x 1 ,..., x n ]  X  C 0 [ x i notation a in R .

Now let X  X  put the different parts together. We know that for each hnc dominance graph D , there is a regular tree grammar G D such that L ( G D ) is the set of configurations of D . Furthermore, the pre-image  X   X  1 M ( L ) = { t | exists t 0  X  L with ( t , t 0 of a regular tree language L is also regular (Koller and Thater, 2010) if M is linear, and regular tree languages are closed under intersection and com-plement (Comon et al., 2007). So we can compute another RTG G 0 such that
L ( G 0 ) consists of the members of L ( G D ) which cannot be rewritten by M R into members of L ( G D ) ; that is, L ( G 0 ) is exactly the set of R -relative normal forms of D . In general, the complement construc-tion requires exponential time in the size of M R and G D . However, it can be shown that if the rules in R have at most depth two and G D is deterministic, then the entire above construction can be computed in time O ( | G D | X | R | ) (Koller and Thater, 2010).
In other words, we have shown how to compute the weakest readings of a hypernormally connected dominance graph D , as approximated by a weaken-ing rewrite system R , in time linear in the size of G
D and linear in the size of R . This is a dramatic im-provement over the best previous algorithm, which was quadratic in | conf ( D ) | . 4.4 An example Consider an annotated rewrite system that contains rule (1) plus the following rewrite rule:
This rewrite system translates into a top-down context tree transducer M R with the following tran-sition rules, omitting most rules of the first two Figure 4: RTG for the weakest readings of Fig. 1. types for lack of space. q  X  (  X  q  X  (  X 
The grammar G 0 for the relative normal forms is shown in Fig. 4 (omitting rules that involve un-productive nonterminals). We obtain it by starting with the example grammar G D in Fig. 3; then com-puting a deterministic RTG G R for  X   X  1 M and then intersecting the complement of G R with G
D . The nonterminals of G marked either with a set of states of M R or the sym-bol F , indicating that G R had no production rule for a given left-hand side. The start symbol of G 0 is marked with F because G 0 should only gener-ate trees that G R can not generate. As expected, G 0 generates precisely two trees, namely (b) and (c). The construction we just carried out  X  characterize the configurations we find interesting as the rela-tive normal forms of an annotated rewrite system R , translate it into a transducer M R , and intersect conf ( D ) with the complement of the pre-image un-der M R  X  is more generally useful than just for the computation of weakest readings. We illustrate this on the problem of redundancy elimination (Vestre, 1991; Chaves, 2003; Koller et al., 2008) by show-ing how a variant of the algorithm of Koller et al. (2008) falls out of our technique as a special case.
Redundancy elimination is the problem of com-puting, from a dominance graph D , another domi-nance graph D 0 such that conf ( D 0 )  X  conf ( D ) and every formula in conf ( D ) is logically equivalent to some formula in conf ( D 0 ) . We can approximate logical equivalence using a finite system of equa-tions such as indicating that  X  y and  X  z can be permuted without changing the models of the formula.

Following the approach of Section 4, we can solve the redundancy elimination problem by trans-forming the equation system into a rewrite system R such that t  X  R t 0 implies that t and t 0 are equiv-alent. To this end, we assume an arbitrary linear order &lt; on  X  , and orient all equations into rewrite rules that respect this order. If we assume  X  y &lt;  X  z , the example rule (4) translates into the annotated rewrite rules for all annotations a  X  Ann ; logical equivalence is not sensitive to the annotation. Finally, we can compute the relative normal forms of conf ( D ) un-der this rewrite system as above. The result will be an RTG G 0 describing a subset of conf ( D ) . Every tree t in conf ( D ) that is not in L ( G 0 ) is equivalent to some tree t 0 in L ( G 0 ) , because if t could not be rewritten into such a t 0 , then t would be in rela-tive normal form. That is, the algorithm solves the redundancy elimination problem. Furthermore, if the oriented rewrite system is confluent (Baader and Nipkow, 1999), no two trees in L ( G 0 ) will be equivalent to each other, i.e. we achieve complete reduction in the sense of Koller et al. (2008).
This solution shares much with that of Koller et al. (2008), in that we perform redundancy elimina-tion by intersecting tree grammars. However, the construction we present here is much more general: The algorithmic foundation for redundancy elim-ination is now exactly the same as that for weak-est readings, we only have to use an equivalence-preserving rewrite system instead of a weakening one. This new formal clarity also simplifies the specification of certain equations, as we will see in Section 6.

In addition, we can now combine the weakening rules (1) , (3) , and (5) into a single rewrite system, and then construct a tree grammar for the relative normal forms of the combined system. This algo-rithm performs redundancy elimination and com-putes weakest readings at the same time, and in our example retains only a single configuration, namely Figure 5: Structure of the configuration set of Fig. 1 in terms of rewriting. (b); the configuration (c) is rejected because it can be rewritten to (a) with (5) . The graph in Fig. 5 il-lustrates how the equivalence and weakening rules conspire to exclude all other configurations. In this section, we evaluate the effectiveness and efficiency of our weakest readings algorithm on a treebank. We compute RTGs for all sentences in the treebank and measure how many weakest readings remain after the intersection, and how much time this computation takes.
 Resources. For our experiment, we use the Ron-dane treebank (version of January 2006), a  X  X ed-woods style X  (Oepen et al., 2002) treebank con-taining underspecified representations (USRs) in the MRS formalism (Copestake et al., 2005) for sentences from the tourism domain.

Our implementation of the relative normal forms algorithm is based on Utool (Koller and Thater, 2005), which (among other things) can translate a large class of MRS descriptions into hypernormally connected dominance graphs and further into RTGs as in Section 3. The implementation exploits cer-tain properties of RTGs computed from dominance graphs to maximize efficiency. We will make this implementation publically available as part of the next Utool release.
 We use Utool to automatically translate the 999 MRS descriptions for which this is possible into RTGs. To simplify the specification of the rewrite systems, we restrict ourselves to the subcorpus in which all scope-taking operators (labels with arity &gt; 0 ) occur at least ten times. This subset contains 624 dominance graphs. We refer to this subset as  X  X ON10. X  Signature and annotations. For each domi-nance graph D that we obtain by converting an MRS description, we take G D as a grammar over the signature  X  = { f u | u  X  W D , f = L D ( u ) } . That is, we distinguish possible different occurrences of the same symbol in D by marking each occur-rence with the name of the node. This makes G D a deterministic grammar.

We then specify an annotator over  X  that assigns polarities for the weakening rewrite system. We distinguish three polarities: + for positive occur-rences,  X  for negative occurrences (as in predicate logic), and  X  for contexts in which a weakening rule neither weakens or strengthens the entire for-mula. The starting annotation is + .

Finally, we need to decide upon each scope-taking operator X  X  effects on these annotations. To this end, we build upon Barwise and Cooper X  X  (1981) classification of the monotonicity prop-erties of determiners. A determiner is upward (downward) monotonic if making the denotation of the determiner X  X  argument bigger (smaller) makes the sentence logically weaker. For instance, ev-ery is downward monotonic in its first argument and upward monotonic in its second argument, i.e. every girl kissed a boy entails every blond girl kissed someone . Thus ann ( every u , a , 1 ) =  X  a and ann ( every u , a , 2 ) = a (where u is a node name as above). There are also determiners with non-monotonic argument positions, which assign the annotation  X  to this argument. Negation reverses positive and negative polarity, and all other non-quantifiers simply pass on their annotation to the arguments.
 Weakest readings. We use the following weak-ening rewrite system for our experiment, where i  X  X  1 , 2 } : 1. [+] ( E / i , D / 1), ( D / 2 , D / 1) 2. [+] ( E / i , P / 1), ( D / 2 , P / 1) 3. [+] ( E / i , A / 2), ( D / 1 , A / 2) 4. [+] ( A / 2 , N / 1) 5. [+] ( N / 1 , E / i ), ( N / 1 , D / 2) 6. [+] ( E / i , M / 1), ( D / 1 , M / 1)
Here the symbols E , D , etc. stand for classes to be read as shorthand for a set of rewrite rules which rearrange a tree where the i -th child of a symbol from C is a symbol from C 0 into a tree where the symbol from C becomes the k -th child of the symbol from C 0 . For example, because we have all u  X  A and not v  X  N , Schema 4 licenses the following annotated rewrite rule:
We write E and D for existential and definite determiners. P stands for proper names and pro-nouns, A stands for universal determiners like all and each , N for the negation not, and M for modal operators like can or would . M also includes in-tensional verbs like have to and want . Notice that while the reverse rules are applicable in negative polarities, no rules are applicable in polarity  X  .
Rule schema 1 states, for instance, that the spe-cific (wide-scope) reading of the indefinite in the president of a company is logically stronger than the reading in which a company is within the re-striction of the definite determiner. The schema is intuitively plausible, and it can also be proved to be logically sound if we make the standard assumption that the definite determiner the means  X  X xactly one X  (Montague, 1974). A similar argument applies to rule schema 2.

Rule schema 3 encodes the classical entailment (1) . Schema 4 is similar to the rule (2) . Notice that it is not, strictly speaking, logically sound; however, because strong determiners like all or every carry a presupposition that their restrictions have a non-empty denotation (Lasersohn, 1993), the schema becomes sound for all instances that can be expressed in natural language. Similar ar-guments apply to rule schemas 5 and 6, which are potentially unsound for subtle reasons involving the logical interpretation of intensional expressions. However, these cases of unsoundness did not occur in our test corpus.
 Redundancy elimination. In addition, we as-sume the following equation system for redundancy elimination for i , j  X  X  1 , 2 } and k  X  N (again writ-ten in an analogous shorthand as above): 7. E / i = E / j 8. D / 1 = E / i , E / i = D / 1 9. D / 1 = D / 1 10.  X  / k = P / 2
These rule schemata state that permuting exis-tential determiners with each other is an equiva-lence transformation, and so is permuting definite determiners with existential and definite determin-ers if one determiner is the second argument (in the scope) of a definite. Schema 10 states that proper names and pronouns, which the ERG ana-lyzes as scope-bearing operators, can permute with any other label.

We orient these equalities into rewrite rules by ordering symbols in P before symbols that are not #conf = 1 8.5% 23.4% 34.9% 66.7% #conf  X  2 20.5% 40.9% 57.9% 80.6% avg(#conf) 3.2M 7603.1 119.0 4.5 med(#conf) 25 4 2 1 Figure 6: Analysis of the numbers of configurations in RON10. in P , and otherwise ordering a symbol f u before a symbol g v if u &lt; v by comparison of the (arbitrary) node names.
 Results. We used these rewrite systems to com-pute, for each USR in RON10, the number of all configurations, the number of configurations that remain after redundancy elimination, and the num-ber of weakest readings (i.e., the relative normal forms of the combined equivalence and weakening rewrite systems). The results are summarized in Fig. 6. By computing weakest readings (WR), we reduce the ambiguity of over 80% of all sentences to one or two readings; this is a clear improvement even over the results of the redundancy elimina-tion (RE). Computing weakest readings reduces the mean number of readings from several million to 4.5, and improves over the RE results by a factor of 30. Notice that the RE algorithm from Section 5 is itself an improvement over Koller et al. X  X  (2008) system ( X  X RT08 X  in the table), which could not process the rule schema 10.

Finally, computing the weakest readings takes only a tiny amount of extra runtime compared to the RE elimination or even the computation of the RTGs (reported as the runtime for  X  X ll X ). 1 This re-mains true on the entire Rondane corpus (although the reduction factor is lower because we have no rules for the rare scope-bearers): RE+WR compu-tation takes 32 seconds, compared to 30 seconds for RE. In other words, our algorithm brings the semantic ambiguity in the Rondane Treebank down to practically useful levels at a mean runtime in-vestment of a few milliseconds per sentence.
It is interesting to note how the different rule schemas contribute to this reduction. While the instances of Schemata 1 and 2 are applicable in 340 sentences, the other schemas 3 X 6 together are only applicable in 44 sentences. Nevertheless, where these rules do apply, they have a noticeable effect: Without them, the mean number of configurations in RON10 after RE+WR increases to 12 . 5. In this paper, we have shown how to compute the weakest readings of a dominance graph, charac-terized by an annotated rewrite system. Evaluat-ing our algorithm on a subcorpus of the Rondane Treebank, we reduced the mean number of config-urations of a sentence from several million to 4.5, in negligible runtime. Our algorithm can be ap-plied to other problems in which an underspecified representation is to be disambiguated, as long as the remaining readings can be characterized as the relative normal forms of a linear annotated rewrite system. We illustrated this for the case of redun-dancy elimination.

The algorithm presented here makes it possible, for the first time, to derive a single meaningful se-mantic representation from the syntactic analysis of a deep grammar on a large scale. In the future, it will be interesting to explore how these semantic representations can be used in applications. For in-stance, it seems straightforward to adapt MacCart-ney and Manning X  X  (2008)  X  X atural logic X -based Textual Entailment system, because our annotator already computes the polarities needed for their monotonicity inferences. We could then perform such inferences on (cleaner) semantic representa-tions, rather than strings (as they do).

On the other hand, it may be possible to re-duce the set of readings even further. We retain more readings than necessary in many treebank sen-tences because the combined weakening and equiv-alence rewrite system is not confluent, and there-fore may not recognize a logical relation between two configurations. The rewrite system could be made more powerful by running the Knuth-Bendix completion algorithm (Knuth and Bendix, 1970). Exploring the practical tradeoff between the further reduction in the number of remaining configura-tions and the increase in complexity of the rewrite system and the RTG would be worthwhile.
 Acknowledgments. We are indebted to Joachim Niehren, who pointed out a crucial simplification in the algorithm to us. We also thank our reviewers for their constructive comments.
