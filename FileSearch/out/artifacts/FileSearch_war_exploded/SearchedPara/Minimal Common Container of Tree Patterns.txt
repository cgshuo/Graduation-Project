 Tree patterns represent important fragments of XPath. In this paper, we show that some classes of tree patterns exhibit such a property that, given a finite number of tree patterns P ,...,P n , there exists another pattern P (tree pattern or DAG-pattern) such that P 1 ,...,P n are all contained in P , and for any tree pattern Q belonging to a given class C , P ,...,P n are contained in Q implies P is contained in Q . H.2.4 [ Query Processing ]: Miscellaneous Theory, Algorithms XPath, Tree Pattern, Containment Tree patterns represent important fragments of XPath. Over the last few years there have been extensive research on tree patterns. In particular, the containment of tree patterns has been investigated in several papers including [3], and some interesting structural pro perties of tree patterns have been observed, e.g., in [1, 4].

In this paper, we show that some tree patterns exhibit such a property that, given a finite number of compatible tree patterns P 1 ,...,P n , there exists another pattern P (tree pattern or DAG-pattern) such that P 1 ,...,P n are all con-tained in P , and for any tree pattern Q belonging to a given class C , P 1 ,...,P n are contained in Q if and only if P is con-tained in Q .Wecall P a minimal common container (MCC) of P 1 ,...,P n with respect to C . We provide a method for constructing such MCCs. The existence of MCCs has a number of applications. For example, it can be used in find-ing the maximal contained rewriting of tree pattern queries using views [2] under non-recursive, non-disjunctive DTDs and proving such a maximal contained rewriting can be rep-resented by a single tree pattern, for certain classes of queries and views.
Let  X  be an infinite set of tags. An xml tree (Xtree) is a tree with every node labeled with a tag in  X . A tree pattern (TP) is a tree with a unique distinguished node , and with every node labeled with a symbol in  X   X  X  X  X  (here * is the wildcard which represents any tag), and every edge labeled with either / or // . The path from the root to the distinguished node is called the distinguished path .Indraw-ing a tree pattern, we will use single and double lines to represent /-edges and //-edges respectively, and use a circle to indicate the distinguished node (see Figure 4). Let P be a TP. We will use DN ( P ), and DP ( P ) to denote the distin-guished node and the distinguished path of P respectively. Note: the TPs in our discussion correspond to the fragment studied in [3]. In particular, the subset P { /,//, [] } all TPs that do not have *-nodes. In this paper we are also interested in the subset of all TPs in P { /,//, [] ,  X  X  such that the root is not labeled *, no *-node is incident on a //-edge, and no leaf node is labeled *. We denote this subset by
In what follows, for any tree or rooted directed graph T , we will use N ( T )and rt ( T ) to denote the node set and the root of T respectively. We will also use label ( v )todenote the label of node v , and call a node labeled  X  a  X  -node. If ( v 1 ,v 2 ) is a /-edge (resp. //-edge) in T , we will say v /-child (resp. //-child) of v 1 .

A matching of a TP, P ,inanXtree, t , is a mapping  X  from N ( P )to N ( t ) satisfying the following conditions: (1) and (3) structure-preserving, i.e., for every edge ( x, y )in P , then  X  ( y ) is a descendant of  X  ( x ), i.e, there is a path from  X  ( x )to  X  ( y ). Each matching  X  produces a node  X  ( DN which is called an answer to the TP. We use P ( t )todenote the set of all answers of P over t .If T is a set of Xtrees, we use P ( T )todenote t  X  T P ( t ).

Let P and Q be TPs. P is said to be contained in Q , denoted P  X  Q , if for every Xtree t , P ( t )  X  Q ( t ). The equivalence of two TPs is defined as two-way containment as usual.

A boolean pattern [3] is a tree pattern without distin-guishednode. GivenanXtree t and a boolean pattern P , amatchingof P in t is a mapping which is root-preserving, label-preserving, and structure-preserving. Given two boolean patterns P 1 and P 2 ,wesay P 1 is contained in P 2 , denoted P 1  X  P 2 , if whenever P 1 has a matching in t , for all t , P will also have a matching in t . To explicitly distinguish boolean patterns from non-boolean patterns, we will use B { /,//, [] } to denote the set of boolean patterns correspond-the set of boolean patterns corresponding to tree patterns in
Throughout this section (and without loss of generality), we assume that the root labels of tree patterns P 1 ,...,P are identical. Definition 3.1: Let P 1 ,...,P n be patterns in B { /,//, [] } with identical root labels. A minimal common container (MCC) of P 1 ,...,P n wrt B { /,//, [] } , denoted MCC ( P (1) P 1 ,...,P n  X  P ,and (2) for any pattern Q  X  X  { /,//, [] } ,if P 1 ,...,P n  X  Q ,then Note that if P is the MCC of P 1 ,...,P n , then for any Q Furthermore, all MCCs of P 1 ,...,P n are equivalent.
Next we show MCC ( P 1 ,...,P n ) always exists. We will focus on the case n = 2 first, and extend it to the general case later.
 Definition 3.2: ( closest matching descendant pair )Two nodes v 1  X  P 1 and v 2  X  P 2 are said to be a matching pair if ing pair. Let [ v 1 ,v 2 ]and[ u 1 ,u 2 ] be matching pairs. If v is a descendant of u 1 , v 2 is a descendant of u 2 ,thenwesay [ v ,v 2 ]isa matching descendant pair of [ u 1 ,u 2 ]. If there is no matching descendant pair of [ x 1 ,x 2 ] such that [ v is a matching descendant pair of [ x 1 ,x 2 ], then we say that [ v ,v 2 ]isa closest matching descendant pair (CMDP) of [ u 1 ,u 2 ].

Note that every matching pair, except [ rt ( P 1 ) ,rt ( P a CMDP of one and only one other matching pair.
 Example 3.1: Consider the boolean patterns in Figure 1 (a) and (b). In the figure we use subscripts to distinguish nodes with the same label (e.g., b 1 , b 2 and b 3 represent three nodes labeled with b ). It can be seen that are all matching pairs wrt P 1 and P 2 ,and[ b 1 ,b 2 ], [ b [ c ,c 3 ], [ c 2 ,c 3 ], and [ d 1 ,d 2 ]areCMDPsof[ a 1 ,a 2 tion, [ e 1 ,e 2 ]isaCMDPof[ b 1 ,b 3 ], but it is not a CMDP of [ a ,a 2 ].
Given a matching pair [ v 1 ,v 2 ], we can construct a tree pattern T ( v 1 ,v 2 ) of height 1 as follows. 1. the root of T ( v 1 ,v 2 ) is labeled with label ( v 1 2. for every CMDP [ u 1 ,u 2 ]of[ v 1 ,v 2 ], add a child u to For example, for the patterns P 1 and P 2 in Figure 1, T ( a 1 ,a 2 ) is the pattern consisting of the root and all of its children in MCC ( P 1 ,P 2 )showninFigure1(c).

Note that every node in T ( v 1 ,v 2 ) corresponds to a CMDP of [ v 1 ,v 2 ].

We can now construct a boolean pattern P  X  X  { /,//, [] } as follows.
 Step 1: Initially, let P = T ( rt ( P 1 ) ,rt ( P 2 )).
Step 2: For every leaf node in P , if it corresponds to the
Step 3: Repeat Step 2 above until no more nodes can be Example 3.2: The pattern constructed for the patterns P 1 and P 2 inFigure1isasshowninFigure1(c). Itisobtained by replacing the node corresponding to [ b 1 ,b 3 ]in T ( a with T ( b 1 ,b 3 ).

Note that there is an 1:1 correspondence between the matching descendant pairs of [ rt ( P 1 ) ,rt ( P 2 )] and descen-dants of rt ( P ). We can prove the following theorem. Theorem 3.1: The boolean pattern P constructed above
Now suppose there are patterns P 1 , ..., P n  X  X  { /,//, [] } can construct a MCC of P 1 , ..., P n recursively using the for-mula MCC ( P 1 ,...,P n )= MCC ( P n , MCC ( P 1 ,...,P n  X  1 we have Theorem 3.2: For any finite number of boolean patterns P ,...,P n  X  X  { /,//, [] } that have identical root labels, there is a pattern P  X  X  { /,//, [] } which is a MCC of P 1 ,...,P
Note that, in the above theorem, there are no restrictions on the boolean patterns except that they do not involve *.
We call tree patterns with the same label for the roots and the same label for the distinguished nodes compatible patterns. Suppose P 1 ,...,P n  X  X  { /,//, [] } are compatible tree patterns satisfying the following conditions: (A) the labels on the distinguished paths follow a fixed (B) no label is repeated on the distinguished path of P i
With conditions (A) and (B) above, the common labels on DP ( P i )and DP ( P j ) occur in the same order in DP DP ( P j ), and for each common label there is a unique node in DP ( P i ) with that label (for i, j  X  [1 ,n ]).

Before describing the method to construct the MCC, we need to introduce some notations. Given a pattern P and a node v on the distinguished path of P ,weuse Sub v ( P )to denote the full subtree rooted at v ,andtreatitasaboolean pattern (by disregarding the distinguished node). We also use S v ( P ) to denote the boolean pattern corresponding to the subtree obtained from Sub v ( P )byremoving Sub u ( P ) if u is the child of v on the distinguished path. In other words, if v and u are nodes on DP ( P ), and u is a child of v , then S v ( P )= Sub v ( P )  X  Sub u ( P ). In the special case where v = DN ( P ), S v ( P )= Sub v ( P ) (See Figure 2).
We can now construct a pattern P from P 1 and P 2 as follows: 1. Find the common labels on DP ( P 1 )and DP ( P 2 ). With-2. Construct a temporary distinguished path 3. Suppose v 1 ,...,v n are the nodes labeled  X  1 ,..., X  n 4. For i  X  [1 ,n ], find MCC ( Sub v i ( P 1 ) ,Sub u i ( P The final pattern P obtained is illustrated in Figure 3. Example 3.3: Consider the patterns in Figure 4 (a) and (b). The pattern constructed using the above approach is shown in Figure 4 (c).
Figure 3: Structure of the constructed pattern P Figure 4: P 3 , 4 is the constructed MCC for P 3 and P 4
Note that we are not concerned with the complexity of the algorithm or the minimality of the constructed pattern, as our focus is the existence of a MCC.

We can show that P is a MCC of P 1 and P 2 (The defini-tion of MCC for non-boolean patterns is similar to that for boolean patterns, thus omitted here).
 Theorem 3.3: The above pattern P is a MCC of P 1 and P
The above result can be easily extended to any finite num-ber of compatible tree patterns in P { /,//, [] } . Corollary 3.1: For compatible TPs P 1 ,...,P n  X  X  { /,//, [] } that satisfy conditions (A) and (B), there exists P  X  X  { /,//, [] } such that (1) P 1 ,...,P n  X  P , and (2) for any Q  X  X  { /,//, [] } P ,...,P n  X  Q iff P  X  Q .

One may wonder when the MCC of P 1 ,...,P n is equiva-lent to P 1  X  X  X  X  X  P n . In other words, when MCC ( P 1 ,...,P P 1  X  X  X  X  X  P n . From [4] we know that for tree patterns in P { /,//, [] } , P  X  P 1  X  X  X  X  X  P n iff there is i  X  [1 ,n ] such that P  X  P i . Therefore, we have Corollary 3.2: For compatible TPs P 1 ,...,P n  X  X  { /,//, [] } if
MCC ( P 1 ,...,P n ) exists, then MCC ( P 1 ,...,P n )= P iff there is i  X  [1 ,n ] such that P j  X  P i for all j = i .
We now consider boolean tree patterns in B { /,//, [] ,  X  X  is the set of boolean patterns corresponding to tree patterns in
P { /,//, [] ,  X  X  . Recall that such tree patterns do not have *-nodes incident on //-edges, or dangling *-nodes (i.e., *-nodes which do not have a non-* descendant), and the root is not labeled *. As usual, we consider the case n = 2 first, and extend it to the general case later.
 Definition 3.3: ( label-matching pair and /-child pair ) Let P 1 ,P 2 be boolean patterns in B { /,//, [] ,  X  X  .Let v be nodes in P 1 and P 2 respectively. If label ( v 1 )= label ( v  X  ,thenwecall[ v 1 ,v 2 ]a label-matching pair .Wecall[ v 1 a /-child pair ,if v i (for i =1 , 2) is connected to its parent via a /-edge. A pair refers to either a label-matching pair or a /-child pair.

Given a pair [ u 1 ,u 2 ], if v 1  X  P 1 is a descendant of u v  X  P 2 is a descendant of u 2 ,and[ v 1 ,v 2 ] is a label-matching pair, then we call [ v 1 ,v 2 ]a label-matching descendant pair (LMDP) of [ u 1 ,u 2 ]. If there is no label-matching descendant pair [ x 1 ,x 2 ]of[ u 1 ,u 2 ] such that [ v 1 ,v 2 ]isalsoaLMDPof [ x 1 ,x 2 ], then we say [ v 1 ,v 2 ]isa closest LMDP (CLMDP) of [ u 1 ,u 2 ]. If v 1 is a /-child of u 1 , v 2 is a /-child of u say [ v 1 ,v 2 ] is a /-child pair of [ u 1 ,u 2 ].
Note that it is possible that [ v 1 ,v 2 ] is both a label-matching descendant pair of [ u 1 ,u 2 ], and a /-child pair of [ u
Given a label-matching pair or /-child pair [ v 1 ,v 2 ], we can construct a boolean tree pattern T ( v 1 ,v 2 ) of height 1 as follows. 1. The root of T ( v 1 ,v 2 ) is labeled with label ( v 1 2. For every /-child pair [ u 1 ,u 2 ]of[ v 1 ,v 2 ], add a /-child 3. If [ v 1 ,v 2 ] is a label matching pair, then for each CLMDP
We can now construct a boolean tree pattern P as follows: 1. Initially, let P = T ( rt ( P 1 ) ,rt ( P 2 )). 2. For every leaf node in P , if it corresponds to the pair 3. Repeat the above step until no more nodes can be 4. Remove dangling *-nodes.

It is easy to see that the pattern P is in B { /,//, [] ,  X  X  Example 3.4: The pattern constructed for the boolean patterns in Figure 5 (a) and (b) is shown in Figure 5 (c). Theorem 3.4: P is a MCC of P 1 and P 2 wrt B { /,//, [] ,  X  X  i.e., (1) P 1 ,P 2  X  P , and (2) for every boolean pattern Q
Similar to boolean patterns in B { /,//, [] } , in the general case, we can construct the MCC of P 1 ,...,P n recursively us-ing the fact MCC ( P 1 ,...,P n )= MCC ( MCC ( P 1 ,...,P hence proving the following result.
 Theorem 3.5: For any finite number of boolean patterns P ,...,P n  X  B { /,//, [] ,  X  X  that have identical root labels, there is a pattern in B { /,//, [] ,  X  X  which is a MCC of P 1 ,...,P Figure 6: DAG-pattern P 7 , 8 is the MCC of P 7 and P
Let P 1 ,...,P n be compatible TPs in P { /,//, [] ,  X  X  satisfying the two conditions below: (I) The distinguished path of each pattern does not have (II) The common labels (except *) on these paths appear We can show that there is a DAG-pattern P (see the def-inition below) such that P 1 ,...,P n  X  P ,andforany Q  X  minimal common container (MCC) of P 1 ,...,P n  X  P wrt P { /,//, [] ,  X  X  . For example, in Figure 6, DAG-pattern P
A DAG-pattern is a directed graph such that (1) every node is labeled with a tag in  X  or wildcard *, (2) every edge is labeled // or /, (3) there is a unique root which has incoming degree 0, and there is a unique distinguished node. In a DAG-pattern, there may be several paths from the root to the distinguished node. Each of these paths is called a distinguished path . The definitions of matching , containment ,and containment mapping of tree patterns can be extended straightforwardly to DAG-patterns.
 Theorem 3.6: For tree patterns P 1 ,...,P n  X  P { /,//, [] ,  X  X  that satisfy conditions (I) and (II), there is a DAG-pattern P with no *-nodes incident on //-edges and no dangling *-nodes, which contains P 1 ,...,P n . Furthermore, for any Q  X  P { /,//, [] ,  X  X  , P 1 ,...,P n  X  Q if and only if there is a CM from Q to P .
We showed the existence of MCCs for some tree patterns in such a MCC.
 Acknowledgement This work is supported by Griffith Uni-versity New Researcher X  X  Grant (GUNRG36621).
