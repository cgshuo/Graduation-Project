 A general re-weighting method, calle d contextualization, for more efficient element ranking in XML retrieval is introduced. Re-weighting is based on the idea of using the ancestors of an good interpreted as probability of relevance  X  its weight is increased in relevance scoring; if the element appears in a bad context, its weight is decreased. The formal presentation of contextualization is given in a general XML representation and manipulation frame, which is base d on utilization of structural indices. This provides a general approach independent of weighting schemas or query languages. Contextualization is evaluated with the INEX test collection. We tested four runs: no contextuali zation, parent, root and tower contextualizations. The contextua lization runs were significantly better than no contextualization. The root contextualization was the best among the re-weighted runs. H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval  X  retrieval models. H.3.4 [ Information Storage and Retrieval ]: Systems and Software  X  performance evaluation. H.2.1 [ Database Management ]: Logical Design -data models. organization/structure .
 Management, Measurement, Performance, Design, Experimentation, Languages. XML, Structured documents, Semi -structured data, Re-weighting, Contextualization, Structural indices, Dewey ordering. XML retrieval deals with the po ssibility to utilize hierarchical document structure in returning more specific text units than information retrieval instead of document retrieval. Text units derive part of their meaning from the context in which they appear. The previous and the following passages in a document determine the context of a text passage and give it an interpretative frame. A text passage can be viewed in contexts of different size. Any part of a doc ument which contains the passage is a possible context in which the passage can be viewed. Usually documents, e.g. scientific articles, involve an intrinsic structure in which a document is divided in to sections, subsections and paragraphs. This established divi sion gives natural contexts of different size. For example, a paragraph can be viewed in the context of an article, a secti on, and possible subsections. XML serves as a way to organize structured documents and to manipulate different levels of cont ext. However, in XML retrieval element appears. The context affects the interpretation of the element and gives hints about its relevance. Therefore, we propose a general re-weighting method for XML retrieval that takes into account the specified contexts of elements. An XML document consists of elements, which in turn may descendant of x . Typically, in weighting of an element the weights of its descendants affect th e weight of the element [e.g. 3, 12]. This approach has also been applied to the weighting of text passages in non-XML text retrieval [e.g. 1, 8]. Instead, there are only a few proposals where the weights of the ancestors of an element would be taken into account in weighting of the element [20, 14]. This approach seems reasonable because XML elements are not independent of their ances tors. Sigurbj X rnsson, Kamps and de Rijke [20] propose that the weight of an article should affect the weighting of any of its elements. Based on [15] Ogilvie and Callan [18] combine evidence from an element X  X  parent and children in estimation of a langua ge model for the element. We propose a method in which any hierarchy level of ancestors may be taken into account in the wei ghting of elements. The proposed method supports both increasing and decreasing the weights of elements. Likewise, our approach is not fixed to any collection, or predefined XML structure, or weighting method, or specific query language. We aim at general form al presentation that allows defining a context for any elemen t and using this context as evidence of the relevance of the element. The DTD independent manipulation of XML documents requires based on the structural indices, which have a long history in representing and manipulation of hierarchical data structures. They have been applied in the context of the hierarchical data model [16], the NF2 relational m odel [17], and composed objects in the object-oriented and deductive object-oriented data models [7]. Similar to these models, the XML data model requires management of hierarchical data structures. Therefore it is not surprising that a similar me thod based on Dewey decimal indexing has earlier been applied to representing XML structures inverted file for an XML collection, query evaluation, and re-weighting. In order to avoid ambi guity we refer to a structural retrieval, is referred to as an inverted file. In this paper we develop a nd present a re-weighting method contextualization function and its sample extensions used in the test environment. Our backgr ound assumption is that a text passage in a relevant context should be ranked higher than a similar passage in a non-relevant context. Our formal presentation is based on the standard set theory, which is an established and general representation approach. In Section 2 we present our XML retrieval system and in Section 3 the test setting. In Section Discussion and Conclusions are given in Section 5. The idea of structural indices in the context of XML is that the topmost (root) element is indexed by  X  1  X  and its children by  X  1,1  X  ,  X  1,2  X  ,  X  1,3  X  etc. Further, the children of the element with the index indexing enables analyzing of th e relationships among elements in a straightforward way. For example, the ancestors of the element labeled by  X  1,3,4,2  X  are associated with the indices index. In the present approach the XML documents in the collection are indexing this means that the docum ents are identified by indices {1,2,3,...}) refers to a root el ement and its descendants are indexed by the way described above. Now each document involves an index structure in which each index is initiated with the document identifier. This means that each element possesses a unique index and we manipulate the XML collection via one index set. For example, let us assume that the following XML index or the index of article ),  X  5,1  X  (the index of abstract ), paragraph ). &lt;article&gt; &lt;abstract&gt; This is the content of the abstract.&lt;/abstract&gt; &lt;section&gt; &lt;paragraph&gt; Here is the content of this paragraph.&lt;/paragraph&gt; &lt;/section&gt; &lt;/article&gt; A basic concept in our system is a content element , an element that has own textual content. He re we have made a deliberate practical choice to use the topmost content elements as the least their children are not indexed. This solution behaves well in the used test collection (see Section 3.1) where content elements, defined in this way, possess a natural granularity, for example, paragraphs and titles. In other words, this solution prevents division into too small fragments, such as single words or parts of words, mostly result from style-sheet marking. For example the following abstract element is interpreted as a content element, i.e. the elements bold and italic are not indexed. The content of this abstract element is interpreted without tags, or analogously with the ab stract element above. &lt;abstract&gt; This is the &lt;bold&gt;content&lt;/bold&gt; of the &lt;italic&gt;abstract&lt;/italic&gt;.&lt;/abstract&gt; Indexing also gives a sound and efficient foundation for designing an inverted file. Namely, each key in the inverted file may be associated with the set of the structural indices of the elements where the key appears. Actually, no more than the occurrences in content elements must be stored because indirect occurrences can be inferred based on structural indices. For example, if a key has of the content elements where the key occurs. In the inverted file an index may involve information on the number of the key occurrences and their positions in the text. In this paper it is assumed that only the number of occurrences is stored. This means that the inverted file can be represented as a binary occurrences of the element indexed by  X  . For example related to does not occur in any other element in the collection at hand. Occurrences in elements other than content elements are calculated based on the occurrences of their content elements. In ' content ' occurrences. In this paper the following notational conventions are associated with structural indices:  X  A structural index (briefly inde x) is a tuple, denoted between  X  The set of indices related to the XML collection at hand is  X  The index  X  i  X  consisting of an integer i (i.e. its length is 1) is  X  Let  X  be an index and i a positive integer then the cutting  X  The function content_elem (  X  ) gives the indices of the content  X  Let k be a search key then function num_of_keys ( k ,  X  ) yields XML notation does not determine how a document collection should be organized. For example, a collection of documents could be represented as a complex XML element where the collection is the root element. However, de facto, XML collections are organized so that the main referable units, e.g. scientific articles, are represented by root elements. Instead, top hierarchy levels (collection/jour nal/volume/issue) are manipulated by a directory structure or they are aggregated into an additional XML element where a reference mechanism based on explicit identifiers is used. Further, th e representation of documents in XML aims to follow the establis hed structure of documents. For example, a scientific article is typically composed of sections which consist of subsections et c. The lowest level of XML paragraph level in the source doc uments. This organization gives a natural starting point for mani pulating text passages at the established hierarchy levels of text documents. The idea of contextualization is based on the assumption that an element in a relevant context should be ranked higher than an identical element in a non-relevant context. Depending on how a collection is organized, an element may be viewed at various levels of context. For example, assuming that documents follow article-section-subsection-paragraph division, then the article, the section and the subsection form different levels of context for a paragraph. Further, a subsection can be viewed in the contexts of the section or the article. The length of the path from the context element to the element at hand determines the level of context. We say that the parent of an element determines the first level context; the ancestor with the path length 2 determines the second level context etc. The root element forms the topmost context. Let the present article and its sa mple XML representation below illustrate this. &lt;article&gt; ... &lt;section sec_no="1"&gt;...&lt;/section&gt; &lt;section sec_no="2"&gt; ... &lt;sub_section sec_no="2.1"&gt;...&lt;/sub_section&gt; ... &lt;sub_section sec_no="2.2"&gt; &lt;title&gt;Contextualization&lt;/title&gt; ... &lt;p&gt;Let us consider the present paragraph. Now Subsection 2.2 forms the first level context and Section 2 second level context of this paragraph. The article is the root element, or it determines the topmost context of this paragraph. In turn, Section 2 forms the first level context, and the article the second level (or topmost) context of Subsection 2.2. The article possesses no context.&lt;/p&gt; &lt;/sub_section&gt; &lt;/section&gt; ... &lt;/article&gt; Let us consider the present para graph. Now Subsection 2.2 forms paragraph. The article is the root element, or it determines the topmost context of this paragra ph. In turn, Section 2 forms the context of Subsection 2.2. Th e article possesses no context. In contextualization the weight of an element is modified by the basic weight of its context el ement(s). Contextualization is independent of the used query language and basic weighting schema for elements. Below we assume a basic weighting function w ( q ,  X  ) where q is a query expression and of the element to be weighted. In section 2.3 we specify a query language and a weighting functi on for the test environment. We define a general contextualization function C which has the following arguments: q ,  X  and g . The arguments q and same interpretation as in the context of the basic weighting function w above. The argument g is called contextualization vector and set-theoretically it is repr esented as a tuple, consisting of values by which elements between the root element and element are weighted in contextualization. The length of g is  X  ( a is the contextualization weight of the root element (i.e. the element with index  X  1 (  X  )), b is the contextualization weight of the  X  2,3  X  element (i.e. the element with index  X  2 weight of the  X  2,3,2  X  element (i.e. the element with the index  X  by weighted average based on contextualization vector and the index at hand. In the sample case above the contextualized weight / ( a + b + c ). Contextualization is applied only to those elements whose basic weight is not zero. Next we define the general contextualization function C formally: 0, if w ( q ,  X  ) = 0 C ( q ,  X  , g ) = term of g, different levels of the context can be weighted in various ways. For example, weighting may increase or decrease towards to the topmost context (root element). In this paper, however, we consider only such cases where g consists of the values 1 and 0. Zero value means that the corresponding element is not taken into account in cont extualization. Next we give setting below. Related to a query expression q the contextualization based on the first level (parent) context of the  X  element is calculated using the contextualization vector where two last elements have the value 1 and the others zero value. This function is denoted c p ( q , is defined as follows: c ( q ,  X  ) = C ( q ,  X  , g ) where g = g [ len (  X  )] = 1 g [ len (  X  ) -1] = 1, when len (  X  ) &gt; 1 The contextualization by the topmost context (or by the root element) is denoted by the function symbol c r and it calculated in weight 1 and the others zero value. c ( q ,  X  ) = C ( q ,  X  , g ) where g = g [ len (  X  )] = 1 g [1] = 1 The contextualization function c t is called tower contextualization This is achieved by the contextualization vector where each position is valued by 1. c ( q ,  X  ) = C ( q ,  X  , g ) where g = When no contextualization is applied, the element gives its basic weight. This is denoted by the function c n associated with the contextualization vector where the last position has the value 1 and the others the zero value. c ( q ,  X  ) = C ( q ,  X  , g ) where g = g [ len (  X  )] = 1 We tested the proposed extensions of contextualization in the sample data (INEX 2004, see Sec tion 3). Next, we introduce the used query language and its sema ntics based on indices; i.e. the weighting method formally. The present query language has features typical for query languages in best match retrieval sy stems. In it, search keys are separated from each other by a space and a phrase can be expressed between quotation marks. A key or phrase may involve +/-prefix to emphasize its importance or avoidance, respectively. The syntax of this language is given in Appendix 1. Next, we introduce the weighting-based seman tics of this syntax. We give the weighting function w which is defined following the syntax expressions in Appendix 1. The function w involves two arguments  X  first for a query expression and second for the index at hand. The weighting of keys is based on a modification of the BM25 weighting function [5, 19, see also 11]. The weight for the key k related to the index  X  is calculated as follows: where  X  kf  X  is the number of times k occurs in the  X  element, i.e.  X  N is the total number of con tent elements in the collection,  X  m is the number of content elements containing k in the  X   X  f c is the number of all descendant content elements of the  X   X  f k is the number of descendant content elements of the  X  v and b are constants for tuning the weighting. Their effects The weighting formula yields w eights scaled into the interval [0,...,1]. In queries one may express phrase conditions as a sequence of phrase searching as such. Ins tead, it supports liberal proximity searching by demanding that all the keys of the phrase appear in the same content element. This approximates phrase searching when content elements are rather short. We manipulate a phrase as a set of keys denoted by KS , i.e. KS = { k 1 ,..., k k " is the phrase_expr at hand. The weight for a phrase (a phrase_expr represented as KS ) related to the  X  calculated as follows: where  X  N , v , b and  X  f c have the same interpretation as above.  X  pf  X  gives the sum of the lowest frequencies, among the keys  X   X  f KS is the number of the desce ndant content elements of the  X  m KS is the number of the content elements containing all the A query term (a query_term ), denoted by qt below, is either a single key or a phrase with a possible +/-prefix. query term. In our system the weight of the query term is increased by taking a square root of the weight (NB! +qt the weight is calculated as follows: The  X - X  prefix in queries denotes an unwanted query term. For any minus_expr -qt the weight is decreased by changing the weight to its negation: In other words unwanted query terms are manipulated in the interval [-1,0]. In relevance scoring for ranking the weights of query terms are combined by taking an average of the weights. In other words, if query_expr then its weight is calculated as follows: This is our basic weighting schema for the element associated with an index  X  . We tested our system with the XML collection of INEX, and two sets of ad hoc topics from years 2003 and 2004. Topics of 2003 were used for tuning the parameters, and the results obtained with 2004 topics will be given in the next section. The INEX document collection consists of 12107 XML marked full-text documents with 494 megabytes of data. These documents are scientific articles of the IEEE Computer Society's publications from 12 magazines and 6 transactions. An article contains on average 1532 XML elements (totally over 8 million elements, the average depth of an element is 6.9). However the length and structure of the articles vary. Also the granular ities of the elements vary. [2, 4] INEX participants produce topics every year and also assess the relevance of the elements collected to a result pool from the submissions. There are two types of topics to be evaluated: content_only (CO) and content_and_structure (CAS) topics. The former gives conditions only about the content of elements to be structure of the results. [9, 13] In this evaluation we use only CO topics. In 2003 the number of CO topics with relevance assessments was 32, in 2004 the number was 34. In INEX 2004, only the titles of the topics were allowed in query formulation. Also in this study search keys and phrases were taken as given in titles. Words included in phrases were added to queries also as single keys. Relevance of elements was assessed in two dimensions, exhaustiveness and specificity, both on 4-point scale [10, 13]: These dimensions are not totally independent, e.g. a not exhaustive element may not be specific at any level. The evaluation measure used in INEX 2004 was mean average precision with different quantizati ons for relevance dimensions [4, exhaustive and highly specific are considered relevant, others non-relevant. In other quantizati on functions elements X  degree of relevance is taken into account by crediting elements according to their level of specificity and exhaustiveness. We will present our results using three official INEX measures: the aggregate mean average precision over all seven INEX quantizations (Aggr. MAP), generalized and specificity oriented mean average precision (General. MAP and SO MAP, see [22, 13]). The first gives an overview of the performance; the second treats exhaustiveness and specificity alike; and the third emphasizes specificity, which is important in XML retrieval. We use the set of relevance assessments with duplicate assessments, referred to as Ass. II in [13]. The quantizations may be expressed as a function Then, the generalized quantiza tion is defined as follows: and specificity oriented quantization is defined as follows: [22] We tested four different retrieval methods (see Section 2.2):  X  No contextualization, c n (Baseline)  X  Parent contextualization, c p (Parent)  X  Root contextualization , c r (Root)  X  Tower contextualization, c t (Tower) An overview of the four methods is given in Table 1. All contextualization methods improve the performance compared to the baseline. These improvements are also statistically significant (Friedman test). The best mean average precision is obtained with the root contextualization, but the difference between the root and tower contextualization is minor . The parent contextualization yields the smallest difference to the baseline; obviously it offers a too small context. The root c ontextualization is significantly better than the parent contextua lization; with generalized and specificity oriented precisions the root contextualization outperforms the tower contextualization significantly. As a comparison for the aggregate precision values in Table 1 we refer to the best official INEX 2004 aggregate MAP which was 0.139 [13]; INEX has not published the performance of the official submission runs with other measures. It is worth noting, that the difference in average mean precision does not necessarily imply statistical significance, because Friedman test takes into account the number of topics the method is able to improve rather than the absolute improvement shown in averages. 
Table 1. MAP scores for baseline and three contextualization Baseline 0.106 Parent 0.129 0.023* Root 0.152 0.046** 0.023** Tower 0.147 0.041** 0.018 -0.005 Baseline 0.080 Parent 0.106 0.026** Root 0.134 0.055** 0.028** Tower 0.126 0.047** 0.020 -0.008* Baseline 0.069 Parent 0.100 0.031** Root 0.139 0.070** 0.039** 
Tower 0.134 0.065** 0.034 -0.005* Legend: * p&lt; 0.05, ** p&lt;0.001 Figures 1-2 illustrate the performance of the methods as precision-recall curves. Regardless of the measure, the average contextualization gives a clear improvement over the baseline; the performances of the root and tower contextualization are close, contextualization. Obviously, the root gives the best evidence of relevance in most cases; the information of the plain tower contextualization is redundant. 
Figure 2 Recall-precision curves with specificity oriented In this study we have shown how manipulation  X  indexing and retrieval  X  of an XML collecti on is handled with structural indices. This is a general approach independent of the DTD of the collection, and thus it is app licable to heterogeneous XML collections. The structural indices are used as identifiers for elements. An inverted file stores the occurrences of keys in content elements only; the occurrences in other elements (ancestors) are deduced on the basis of the indices. Structural indices support straightforward manipulation of XML documents  X  not only element retrieval but also restructuring of documents, which is our forthcoming aim. In XML retrieval the content elements or leaf nodes tend to be short, which means that the vocabulary problem typical for text retrieval is even worse: all search keys do not appear in the same element and thus there might not be enough evidence of relevance. This problem could be facilitated by seeking evidence from the surrounding context of the element to be weighted. Taking the weight of the root element into account when weighting the element at hand was put forward in [20], also [14, 18] introduce similar approaches. We propose a more general re-weighting method, contextualization, in which not only the root but any context of the element along the hierarchical path may influence the weight of the el ement. This is achieved through contextualization vectors and indices: the vectors include contextualization weights for each hierarchical level found in indices. The proposed method both increases the weights of elements in probably relevant c ontexts and decreases the weights contextualization weights need not to be positive, and they may be adjusted according to assumed importance of the context. In the present study we tested only binary weighting (1 or 0). The effectiveness of contextualization was tested with three basic methods: parent, root and tower contextualization. In this evaluation, the root contextualization proved to be the best. However, it seems that the root might also carry false evidence, and context smaller than root a nd larger than parent could be evaluation of this study only one XML collection consisting of scientific articles and one wei ghting method were used, thus testing with other types of collections and matching models is needed. This research was supported by the Academy of Finland under grant number 52894. [1] Callan, J.P. Passage-level evidence in document retrieval. [2] Fuhr, N., Malik, S., and Lalmas, M. Overview of the [3] G X vert, N., Abolhassani, M., F uhr, N., and Grossjohan, K. [4] G X vert, N., and Kazai, G. Overview of the INitiative for the [5] Hawking, D., Thistlewaite, P., and Craswell, P. ANU/ACSys [6] ISO/IEC 14977. International standard ISO/IEC 14977 : [7] Junkkari, M. PSE: An object-oriented representation for [8] Kaszkiel, M., Zobel, J., and Sacks-Davis, R. Efficient [9] Kazai, G. Lalmas, M, and Malik, S. INEX  X 03 guidelines for [10] Kazai, G., Lalmas, M., and Piwowarski, B. INEX 2004 [11] Kek X l X inen, J., Junkkari, M., Ar vola, P., and Aalto, T. TRIX [12] Liu, S., Zou, Q., and Chu, W.W. Configurable indexing and [13] Malik, S., Lalmas, M., and Fuhr, N. Overview of INEX [14] Mass, Y., and Mandelbrod, M. Component ranking and [15] McCallum, A., and Nigam, K. Text classification by [16] Niemi, T. A seven-tuple representation for hierarchical data [17] Niemi, T., and J X rvelin K. The processing strategy for the [18] Ogilvie, P., and Callan, J. Hierarchical language models for [19] Robertson S.E., Walker, S., J ones, S., Hancock-Beaulieu, [20] Sigurbj X rnsson, B., Kamps J., and de Rijke, M. An element-[21] Tatarinov, I., Viglas, S., Beyer, K.S. Shanmugasundaram, J., [22] de Vries, A.P, Kazai, G., and Lalmas, M. Evaluation metrics Appendix 1: Syntax of CO queries (by Extented BNF [6])
