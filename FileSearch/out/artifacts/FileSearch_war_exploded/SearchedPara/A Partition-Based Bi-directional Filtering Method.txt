 perform the similarity join in an efficient and scalable way. late their similarity values, which bears a prohibitively O( n verified. And then, the current string is segmented and indexed. mentally proving the hypothesis, this paper claims the following contributions. filter-verification framework by enhancing its filtering capability. the backward filtering. directional filtering algorithm outperform the origin algorithm. make a conclusion in Section 6. tion-based filter-verification framework. 
In this paper, we only focus on the circumstance of R = S  X  = 3 , then &lt; s 1 , s 2 &gt; and &lt; s 4 , s 5 &gt; distance is not larger than  X  . Partition-base filtering is based on Lemma 1 [5]. based on the pigeonhole principle.

Given two strings r and s , and an edit-distance threshold pair can prune the pair &lt; r , s &gt; . 2.1 Partition Scheme Given a string, many plans could partition the string into a length ( l i ) of  X  | r |/(  X  +1)  X  or  X  | r |/(  X  +1)  X  +1 ments have length  X  | r |/(  X  +1)  X  +1 , and the first For example, for s 1 in Table 1 and  X  = 3 , the length of s has four segments { X  X i X ,  X  X i X ,  X  X ar X ,  X  X ty X  X . 2.2 The Partition-Based Filtering Mechanism For ease of presentation, we first introduce the notations used in the paper. strings with length of l . segment of strings with length of l . to  X  +1 segments and the segments are inserted into the inverted index Table 2 lists the inverted index of all strings in Table 1 for L matching a segment in L l i . of s , and checks each of them whether it appears in L l each r  X  L l i ( w ) , &lt; r , s &gt; are added to the candidate set ( r r , s r . Formally, if ED ( r l , s l )  X  i  X  1  X  ED ( r cation, we add the pair into the result set [5].
 capability. 3.1 Motivations ations. forward filtering. ferent direction can produce different candidate sets. similar. then perform backward filtering to generate candidate set C the intersection of C 1 and C 2 to get the final candidate set C . 3.2 The Framework of Bi-Filtering JOIN into six steps. We give the pseudo-code of our algorithm as Algorithm 1. strings with same length are sorted in alphabetical order (line 2). 
Step 2 : Substring selection. Consider the current string s with length 3-line 6), and save the selected substrings X  information of s ( information of all strings ( W ( S,l,i ) ) (line 7). If | s |  X   X   X  l  X  | s | s are prepared for matching a segment in inverted index matching the segment of visiting string in the future in backward filtering. 
Step 3 : Forward filtering. For each selected substring whether it appears in L l i . If it does, for each date set C 1 ( s ) (line 8-line 11). index L |s| i (1  X  i  X   X  +1) (line 12). Step 5 : Backward filtering. We pipeline the initial candidate set C ( s ) (line 13). 
Step 6 : Verification. We verify whether a candidate pair verification, it is added to the result set (line 14). the edit distance of two strings. 1 Begin 2 Sort S first by string length and second in 3 for s  X  S 4 for 1  X  i  X   X  +1 5 for | s |- X   X  l  X  | s |+  X  6 W ( s , l , i ) = SubstringSelection( s , l , i ) 7 Add W ( s , l , i ) into W ( S , l , i ) 8 if | s |- X   X  l  X  | s | then 9 for w  X  W ( s , l , i ) 10 if w is in L i l then 12 Partition s into  X  +1 segments and add s i into L i 13 C 2 ( s ) = ReverseFilter( s , C 1 , W ) 14 Verification( s , C 2 ,  X  ) 15 End 3.3 Pipelined Filtering steps and the pseudo-code is shown as Algorithm 2. current string s . substring to matches a segment of s . If the segment s i Algorithm 2 : ReverseFilter( s , C 1 , W ) Input : s : the current string 
Output : C2 : the final candidate set of s 1 Begin 2 for c  X  C 1 ( s ) 3 for 1  X  i  X   X  +1 4 if s i is in W ( c ,| s |, i ) then 5 Add c into C 2 ( s ) 6 End 3.4 Redesigned Substring Selection Function substring selection method should be redesigned. strings r and s , | r | = l and | s |  X   X   X  l  X  | s | segment of r , which is between pf min i pf i = min(| s |  X  l of s are shown in Table 3. two strings r and s , | r | = l and | s |  X   X   X  l  X  | s |+  X  segment of r is the same of the method for forward filtering. If ( r m = s m ), the left parts r l and s l , and the right parts r d = ED ( r l , s l )  X   X  l  X  i , d r = ED ( r r , s can discard s m and use the next matching segment. Thus let nimal start position is pb min pb l = min(| s |  X  l start position is pb min is pb between pb min i = max( pb min length difference of the two strings. in string, and adds the substrings into the s ( W ( s,l,i ) Algorithm 3 : SubstringSelection( s , l , i ) 
Input : s : The current visit string 
Output : W ( s , l , i ) : The selected substrings X  1 Begin 2 if | s |- X   X  l  X  | s | then 4 Add the substring of s with start position p 5 if | s |  X  l  X  | s |+  X  then 7 Add the substring of s with start position p 8 End sets and varying edit-distance thresholds.
 4.9.1. We run our programs on an Ubuntu machine with Intel Celeron E3500 2.7GHz processors and 4GB memory. respectively. 4.1 The Size of Candidate Sets respectively. Note that the vertical-axis is in logarithm scale. 
Several observations can be made:  X  creases.  X  pairs pruned by backward filtering of Bi-Filtering JOIN. When pruned by backward filtering.  X  set, and is at least 10% smaller than that of Pass-JOIN for DBLP dataset. 4.2 Response Time servations follow:  X  matching time.  X 
The larger size of candidate set needs the more processing time. Because the can-didate sizes on Word dataset are much larger than it on DBLP dataset as shown in 
Fig. 3, the runtime is also larger.  X 
JOIN.  X  pruned about 600 million and 1 million string pairs in Word and DBLP dataset re-Word dataset, and 10 seconds on the DBLP dataset. larity metrics. and r must share at least ( max(| s |, | r |)  X  q + 1) ing [6, 7] which mandates that s and r must share at least ( matching positional q -grams, length filtering [5, 10] which mandates that parts of a string in another string and then performs similarity verification. representative character-based metric is edit distance [5, 6, 15, 16]. on real-world datasets. verification. of China (grant No. 2012BAH04F02) . 
