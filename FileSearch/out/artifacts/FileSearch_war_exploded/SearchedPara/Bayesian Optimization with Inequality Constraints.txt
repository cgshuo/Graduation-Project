 Zhixiang (Eddie) Xu 1 XUZX @ CSE . WUSTL . EDU Kilian Q. Weinberger 1 KILIAN @ WUSTL . EDU John P. Cunningham 2 JPC 2181@ COLUMBIA . EDU Columbia University, 116th St and Broadway, New York, NY 10027 Bayesian optimization has become a popular tool to solve a variety of optimization problems where traditional nu-merical methods are insufficient. For many optimization problems, traditional global optimizers will effectively find minima (Liberti &amp; Maculan, 2006). However, these meth-ods require evaluating the objective function many times. Bayesian optimization is designed to deal specifically with objective functions that are prohibitively expensive to com-pute repeatedly, and therefore must be evaluated as few times as possible. A popular application is hyperparameter tuning, where the task is to minimize the validation error of a machine learning algorithm as a function of its hyperpa-rameters (Snoek et al., 2012; Bardenet et al., 2013; Swersky et al., 2013). In this setting, evaluating the objective func-tion (validation error) requires training the machine learn-ing algorithm and evaluating it on validation data. Another application is in experimental design, where the goal is to optimize the outcome of some laboratory experiment as a function of tunable parameters (Azimi et al., 2010b). In this setting, evaluating a specific parameter setting incurs resource costs X  X aterials, money, time, etc. X  X equired to run the experiment.
 In addition to expensive evaluations of the objective func-tion, many optimization programs have similarly expen-sive evaluations of constraint functions. For example, to speed up k-Nearest Neighbor classification (Cover &amp; Hart, 1967), one may deploy data structures for approximate nearest neighbor search. The parameters of such data struc-tures, e.g. locality sensitive hashing (LSH) (Gionis et al., 1999; Andoni &amp; Indyk, 2006), represent a trade-off be-tween test time and test accuracy. The goal of optimiz-ing these hyperparameters is to minimize test time, while constraining test accuracy: a parameter setting is only fea-sible if it achieves the same accuracy as the exact model. Similarly, in the experimental design setting, one may wish to maximize the yield of a chemical process, subject to the constraint that the amount of some unwanted byprod-uct produced is below a specific threshold. In computer micro-architecture, fine-tuning the particular specifications of a CPU ( e.g. L1-Cache size, branch predictor range, cy-cle time) needs to be carefully balanced to optimize CPU speed, while keeping the power usage strictly within a pre-specified budget. The speed and power usage of a particular configuration can only be evaluated with expensive simula-tion of typical workloads (Azizi et al., 2010). In all of these examples, the feasibility of an experiment is not known un-til after the experiment had been completed, and thus fea-sibility can not always be determined in advance. In the context of Bayesian optimization, we say that evaluating feasibility in these cases is also prohibitively expensive, of-ten on the same order of expense as evaluating the objective function. These problems are particularly difficult when the feasible region is relatively small, and it may be prohibitive to even find a feasible experiment, much less an optimal one.
 In this paper, we extend the Bayesian optimization frame-work naturally to scenarios of optimizing an expensive-to-evaluate function under equally expensive-to-evaluate con-straints. We evaluate our proposed framework on two sim-ulation studies and two real world learning tasks, based on LSH hyperparameter tuning (Gionis et al., 1999) and SVM model compression (Bucilu et al., 2006; Burges &amp; Sch  X  olkopf, 1997).
 Across all experiments, we outperform uniform sam-pling (Bergstra &amp; Bengio, 2012) on 13 out of 14 datasets X  including cases where uniform sampling fails to find even a single feasible experiment. To motivate constrained Bayesian optimization, we begin by presenting Bayesian optimization and the key object on which it relies, the Gaussian process. 2.1. Gaussian Processes A Gaussian process is an uncountable collection of random variables, any finite subset of which have a joint Gaussian distribution. A Gaussian process thus provides a distribu-ized by mean function  X  (  X  ) and covariance kernel k (  X  ,  X  ) , which are defined such that, for any pairs of input points x , x 0  X  R d , we have: Given a set of input points X = { x 1 ,..., x n } , the corre-sponding function evaluations ` ( X ) = { ` ( x 1 ) ,...,` ( x and some query point  X  x , the joint Gaussianity of all finite subsets implies: ` ( X ) where we have (in the standard way) overloaded the operation across their inputs. We then can calculate the posterior distribution of ` (  X  ) at the query point  X  x , which conditioning rules for Gaussian random variables, we see  X  ` (  X  x )  X  X   X   X  ` (  X  x ) ,  X   X  2 ` (  X  x ) , where:  X   X   X 
 X  ` (  X x ) = k (  X  x ,  X  x )  X  k (  X  x , X ) k ( X , X ) A full treatment of the use of Gaussian processes for ma-chine learning is Rasmussen (2006). In the context of this work, the critical takeaway is that, given observed function values ` ( X ) = { ` ( x 1 ) ,...,` ( x n ) } , we are able to update our posterior belief  X  ` (  X  x ) of the function ` (  X  ) at any query point, with simple linear algebra. 2.2. Bayesian optimization Bayesian optimization is a framework to solve programs: where the objective function ` ( x ) is considered pro-hibitively expensive to evaluate over a large set of values. Given this prohibitive expense, in the Bayesian formal-ism, the uncertainty of the objective ` (  X  ) across not-yet-evaluated input points is modeled as a probability distri-bution. Bayesian optimization models ` (  X  ) as a Gaussian process, which can be evaluated relatively cheaply and of-ten (Brochu et al., 2010). At each iteration the Gaussian process model is used to select the most promising candi-date x  X  for evaluation. The costly function ` is then only evaluated at ` ( x  X  ) in this iteration. Subsequently, the Gaus-sian process naturally updates its posterior belief  X  ` (  X  ) with the new data pair ( x  X  ,` ( x  X  )) , and that pair is added to the known experiment set T ` = { ( x 1 ,` ( x 1 )) ,..., ( x n This iteration can be repeated to iterate to an optimum. The critical step is the selection of the candidate point x which is done via an acquisition function that enables ac-tive learning of the objective ` (  X  ) (Settles, 2010). The per-formance of Bayesian optimization depends critically on the choice of acquisition function. A popular choice is the Expected improvement of a candidate point (Jones et al., 1998; Mockus et al., 1978). Let  X  x be some candidate point, and let  X  ` (  X  x ) be the Gaussian process posterior random vari-able for ` (  X  x ) . Let x + be the best point in T ` (evaluated thus far), namely: Following Mockus et al. (1978), we then define the im-provement of the candidate point  X  x as the decrease of ` (  X  x ) against ` ( x + ) , which due to our Gaussian process model is itself a random quantity: and thus the expected improvement (EI) acquisition func-tion is the expectation over this truncated Gaussian vari-able: Mockus et al. (1978); Jones et al. (1998) derive an easy-to-compute closed form for the EI acquisition function: where  X  is the standard normal cumulative distribution function, and  X  is the standard normal probability density function. In summary, the Gaussian process model within Bayesian optimization leads to the simple acquisition func-tion EI (  X  x ) that can be used to actively select candidate points. In this paper we extend Bayesian Optimization to incorpo-rate inequality constraints, allowing problems of the form where both ` ( x ) and c ( x ) are the results of some expensive experiment. These values may often be the result of the same experiment, and so when we conduct the experiment, we compute both the value of ` ( x ) and that of c ( x ) . 3.1. Constrained Acquisition Function Adding inequality constraints to Bayesian optimization is most directly done via the EI acquisition function, which needs to be modified in two ways. First, we augment our definition of x + to be the feasible point with the lowest function value observed in T . Second, we assign zero im-provement to all infeasible point. This leads to the follow-ing constrained improvement function for a candidate  X  x : where  X (  X  x )  X  X  0 , 1 } is a feasibility indicator function that is 1 if c (  X  x )  X   X  , and 0 otherwise.
 Because c ( x ) and ` ( x ) are both expensive to compute, we again use the Bayesian formalism to model each with a conditionally independent Gaussian process, given x . Dur-ing Bayesian optimization, after we have picked a candi-set T ` as previously, and we also now evaluate c (  X  x ) and add (  X  x ,c (  X  x )) to the set T c , which is then used to update the Gaussian process posterior  X  c ( x )  X  N (  X   X  c ( x ) , as above.
 With this model, our Gaussian process models the con-strained acquisition function as the random quantity:  X  I
C ( x ) = where the quantity  X   X ( x ) is a Bernoulli random variable with parameter: PF (  X  x ) : = Pr [  X  c ( x )  X   X  ] = Conveniently, due to the marginal Gaussianity of  X  c (  X  x ) , the quantity PF (  X  x ) is a simple univariate Gaussian cumulative distribution function.
 These steps lead to the expected constrained improvement acquisition function: where the third equality comes from the conditional inde-pendence of c ( x ) and ` ( x ) , given x .
 Thus the expected constrained improvement acquisition function EI C (  X  x ) is precisely the standard expected im-provement of  X  x over the best feasible point so far weighted by the probability that  X  x is feasible.
 It is worth noting that, while infeasible points are never considered our best experiment, they are still useful to add to T ` and T c to improve the Gaussian process poste-riors. Practically speaking, infeasible samples help to de-termine the shape and descent directions of c ( x ) , allow-ing the Gaussian process to discern which regions are more likely to be feasible without actually sampling there. This property X  X hat we do not need to sample in feasible regions to find them X  X ill prove highly useful in cases where the feasible region is relatively small, and uniform sampling would have difficulty finding these regions. 3.2. Multiple Inequality Constraints It is possible to extend the above derivation to perform Bayesian optimization with multiple inequality constraints, c ( x )  X   X  , where c ( x )= [ c 1 ( x ) ,...,c k ( x )] and  X  = [  X  1 ,..., X  k ] . We simply redefine dom variable with E h  X   X ( x ) i = p (  X  c 1 ( x )  X   X  1  X  ) , and the remainder of the EI c (  X  x ) constrained acquisi-tion function is unchanged.
 Gaussian probability. In the simplest case, we assume the constraints are conditionally independent given x , which conveniently factorizes the probability as Q k i =1 p (  X  c  X  ) , a product of univariate Gaussian cumulative distribu-tion functions. In the case of dependent constraints, this multivariate Gaussian probability can be calculated with available numerical methods (Cunningham et al., 2011). We evaluate our method, which we call constrained Bayesian Optimization (cBO) on two synthetic tasks and two real world applications. In all cases we compare cBO with function minimization by uniform sampling, an ap-proach that is generally considered competitive (Bergstra &amp; Bengio, 2012) and typically more efficient than grid-searching (Bishop, 2006). Our implementation is written in MATLAB TM . All GP hyperparameters were selected by maximizing the marginal likelihood. We will release our code and all scripts to reproduce the results in this sec-tion at http://tinyurl.com/kgj56vy. 4.1. Simulation Function For the purpose of visualizing our method, we first evalu-ate it on two simulations with 2D objective and constraint functions. We compare cBO to standard Bayesian opti-mization and uniform sampling. All methods are allowed 30 evaluations of ` (  X  ) and c (  X  ) .
 Simulation 1. For the first simulation, the objective func-tion is which we want to minimize subject to the constraint The top row of figure 1 depicts the contour plots of these functions, and the top row of figure 2 depicts the function evaluations initiated by all three methods during optimiza-tion. The infeasible regions are made opaque in figure 2. Black  X  symbols indicate infeasible locations at which ` (  X  ) and c (  X  ) were evaluated. Circles (black with white filling) indicate feasible evaluations.
 After a short amount of time, cBO narrows in on the global minimum of the constrained objective (the dark blue spot in the top right corner). In contrast, uniform sampling misses the optimum and wastes a lot of evaluations (22/30) outside the feasible region. It is noteworthy that cBO also initiates multiple evaluations outside the feasible regions (14/30), however these are very close to the global minimum (top right) or at the infeasible second minimum (dark blue spot at the bottom right), thus exploring the edge of feasibil-ity where it matters the most. BO without constraints my-opically optimizes to the infeasible global minimum (the bottom right corner), because it has no knowledge of the constraints.
 Simulation 2. In the second simulation, we demonstrate how cBO can quickly find the minimum feasible value of a function even when this feasible region is very small. Here, the objective function (to be minimized) is subject to the constraint The contour plots of these functions are in the bottom row of figure 1. The results of this simulation are displayed in the lower row of figure 2. The feasible regions are small enough that uniform sampling might take some time to sample a feasible point, and none of the 30 samples are feasible. BO without constraints manages to sample two feasible points, but without knowledge of the constraints, these were sampled by chance with the ultimate goal of BO being the global optimum in the lower right. By contrast, cBO is quickly able to use infeasible samples to sufficiently learn the constraint function c ( x,y ) to locate the feasible regions. 4.2. Locality Sensitive Hashing As a first real world task, we evaluate cBO by selecting pa-rameters for locality-sensitive hashing (LSH) (Gionis et al., 1999; Andoni &amp; Indyk, 2006) for approximate k-nearest neighbors ( k NN) (Cover &amp; Hart, 1967). We begin with a short description of LSH and the constrained optimization problem. We then present the performance of cBO along-side the uniform baseline. We do not compare against stan-dard BO, as without knowledge of the constraints, BO only samples feasible points by chance. INFEASIBLE BO Simulation 1 Simulation 2 Locality-sensitive hashing (LSH) is an approximate method for nearest neighbor search based on random pro-jections. The overall intuition is that nearest neighbors al-ways stay close after projections. LSH defines j random projections, or hash functions , h 1 ,...,h j . This  X  X ashing X  is performed multiple times, in sets of j hash functions, and each set is called a hash table .
 For further details we refer the interested reader to a review by Slaney &amp; Casey (2008). 1 The key idea is that these hyperparameters of LSH (the number of hash functions j and the number of hash tables L ) create a tradeoff between speed and accuracy.
 Ideally, one wants to search for the fastest setting that does not impact the classification error. Formally, the con-straint function c ( j,L ) is the leave-one-out (LOO) classi-fication error obtained with the LSH data structure with j hash functions and L hash tables. Let denote the LOO classification error without LSH. Then our constraint is c ( j,L )  X  . Our objective, ` ( j,L ) , is the time required to compute the LOO k NN classification error on the training set, which we aim to minimize.
 We allow both cBO and uniform sampling to perform 100 function evaluations to find feasible settings of j and L . Evaluation. Table 1 shows results for learning these LSH parameters under the LOO constraint on 8 popular datasets for face detection ( YaleFaces ) (Georghiades et al., 2001), insurance policy prediction ( COIL ), letter recognition from audio and font-specific features ( Isolet and Letters ), income and webpage classification ( Adult and W8a ), and optical character recognition ( USPS, MNIST ). We subsampled the training data of three of the larger datasets to 10% (marked in the table with an asterisk). We compare cBO with uni-form sampling of the LSH parameters (both optimized over the same range). The table shows the speedup obtained with the final LSH model over standard Euclidean k NN search. In all cases the cBO-selected model is, on average, faster than the one obtained with uniform sampling. Uniform sampling sometimes finds more feasible points than cBO. This is likely because the objective function is often decreasing at the boundary of the feasible region, for example, see the lower left corner of figure 3. This is be-cause the boundary represents the region where LSH be-comes too approximate, and sacrifices accuracy. cBO, in an effort to minimize the objective as much as possible, must explore this boundary to find its edge, resulting in more in-feasible points sampled.
 Figure 4 shows the traceplots of the fastest feasible LSH k NN time as a function of sample iterations on the Coil and Adult data sets. The red and blue dots depict iterations in which feasible points are selected. On the Coil dataset, after only 13 iterations, cBO finds a feasible setting of j and L that has a lower evaluation time than any setting discov-ered by uniform sampling. On Adult , it is able to further decrease the evaluation time from one that is similar to a setting eventually found by uniform sampling.
 Figure 3 shows a contour plot of the 2D objective surface on the USPS handwritten digits data set. The infeasible re-gion is masked out in light blue. Feasible evaluation points are marked as white circles, whereas infeasible evaluations are denoted as black crosses. cBO queries only a few in-feasible parameter settings and narrows in on the fastest model settings (dark blue feasible region). The majority of infeasible points sampled are near the feasibility border (bottom left). These points are nearly feasible and likely have low objective. Because of this and the thin regions of feasibility, cBO explores this region with the hopes of further minimizing ` (  X  ) . Although uniform sampling does evaluate parameters near the optimum, the final model only obtains a speedup of 3 . 03  X  whereas cBO returns a model with speedup 4 . 1  X  (see Table 1). 4.3. SVM Compression Our second real-world application is speeding up sup-port vector machines (SVM) (Cortes &amp; Vapnik, 1995) through hyperparameter search and support-vector  X  X om-pression X  (Burges &amp; Sch  X  olkopf, 1997). In this work, Burges &amp; Sch  X  olkopf (1997) describe a method for reduc-ing the number of SVM support vectors used for the kernel support vector machine. Their approach is to first train a kernel SVM and record the learned model and its predic-tions on the training set. Then, one selects an initial small subset of m support vectors and re-optimizes them so that an SVM with only m support vectors matches the predic-tions of the original model. This re-optimization can be done efficiently with conjugate gradient descent 2 and can be very effective at speeding up SVMs during test-time X  however it is highly dependent on several hyperparameters and has the potential to degrade a classifier X  X  performance. We restrict our setting to the popular radial basis function (RBF) kernel (Sch  X  olkopf &amp; Smola, 2001), which is sensitive to a width parameter  X  2 . To speed up SVM evaluation we need to select values for  X  2 , the SVM cost parameter C , and the number of support vectors m that minimize the validation evaluation time. However, to avoid degrading the performance of our classifier by using fewer support vectors, we need to constrain the validation error to increase by no more than s % over the original SVM model. To be precise, we first train an SVM on a particular data set (all hyperparameters are tuned with standard Bayesian optimization). We then compress this model to minimize validation evaluation time, while only minimally affecting its validation error (up to a relative increase of s % ). For a particular parameter setting  X  2 ,C,m , an evaluation of ` () and c () involves first compressing an SVM with param-eters  X  2 ,C down to m support vectors following Burges &amp; Sch  X  olkopf (1997), and then evaluating the resulting clas-sifier on the validation set. The value of ` (  X  2 ,C,m ) time required for the evaluation (not the compression), and the value of c (  X  2 ,C,m ) is the validation error. This er-ror is constrained to be no more than s % larger than the validation error of the original SVM. As in the LSH task, we allow both cBO and uniform sampling to perform 100 evaluations.
 Comparison. Table 2 shows results for learning  X  2 , C and m on six medium scale UCI datasets 3 including spam clas-sification ( Spam ), gamma particle and engine output de-tection ( Magic and IJCNN1 ), and tree type identification ( Forest ). We also evaluate on Adult and W8a , as with LSH. Similar to LSH, we subsampled the training data of five of the larger datasets to 10% (marked in the table with an as-terisk, the table shows the data set size after subsampling). We consider the two cases of s = 1% and s = 10% rel-ative validation error increase. The table presents the best speedups found by cBO and uniform sampling, the corre-sponding number of support vectors (SVs), as well as the percent of parameter settings that turned out to be infeasi-ble. cBO outperforms uniform sampling on all datasets in speedup. In the most extreme case ( Adult ), the compressed SVM model was 551  X  faster than the original with only 1% relative increase in validation error. On two data sets ( IJCNN1 and Forest ), uniform subsampling does not find a single compressed model that guarantees a validation error increase below 1% (as well as 10% for IJCNN1 ). The table also shows the number of support vectors m , to which the SVM is compressed. In all cases is the cBO model substan-tially smaller than the one obtained with uniform sampling. One interesting observation is that uniform sampling finds more feasible points for Adult and W8a datasets. A possible explanation for this is that a very fast parameter setting is right near the feasibility border. Indeed, it is likely for only m = 3 support vectors many settings of  X  2 and C will be infeasible. There has been a large amount of recent work on using sampling methods for blackbox optimization in machine learning. A popular application of these methods is hyper-parameter tuning for machine learning algorithms, or op-timizing the validation performance of a machine learning algorithm as a function of its hyperparameters. Bergstra &amp; Bengio (2012) demonstrates that uniform sampling per-forms significantly better than the common grid search ap-proach. They propose that the use of Bayesian optimization for this task is promising, and uniform sampling serves as a baseline for Bayesian optimization papers (Snoek et al., 2012).
 A large number of relevant papers have been published on the topic of hyperparameter tuning as well Hutter et al. (2011); Bergstra et al. (2011). Most similar to our work is Bernardo et al. (2011) and Snoek (2013). Constraints are considered in these, but only feasibility is observed. As a result, it is difficult to predict where feasible points will be before observing them. The method in these works is therefore less applicable in the less general scenario that we consider, where the constraint function is actually com-putable. Snoek et al. (2012) introduces Spearmint , a pop-ular tool for this application. Spearmint marginalizes over the Gaussian process hyperparameters using slice sampling rather than finding the maximum likelihood hyperparame-ters. Spearmint also introduces the EI per cost acquisition function, which X  X n addition to its applications with costs other than time X  X ften allows for faster optimization when some parameters affect the running time of an experiment. There has been other work on the hyperparameter tuning problem as well. A few papers have also been published dealing with multi task validation Bardenet et al. (2013); Swersky et al. (2013), where the goal is either to opti-mize multiple datasets simultaneously, or use the knowl-edge gained from tuning previous datasets to provide a warm start to the optimization of new datasets. Paralleliz-ing Bayesian optimization is an active research area (Azimi et al., 2010a; 2012; Snoek et al., 2012). Wang et al. (2013) adapts Bayesian optimization to very high dimensional set-tings.
 A number of other extensions to and applications of Bayesian optimization exist as well. Azimi et al. (2010b) extends Bayesian optimization to the case where one can-not control the precise value of some parameters in an ex-periment. Mahendran et al. (2012) applies Bayesian op-timization to perform adaptive MCMC. Finally, Hoffman et al. (2013) introduce constraints on the number of func-tion evaluations, rather than expensive-to-compute con-straints, which we model with cBO. In conclusion, in this paper we extended Bayesian Opti-mization to incorporate expensive to evaluate inequality constraints. We believe this algorithm has the potential to gain traction in the machine learning community and be-come a practical and valuable tool. Classical Bayesian op-timization provides an excellent means to get the most out of many machine learning algorithms. However, there are many algorithms X  X articularly approximate algorithms with the goal of speed X  X hat the standard Bayesian optimization framework is ill-suited to optimize. This is because it has no way of dealing with the tradeoff between speed and ac-curacy that these algorithms present.
 We extend the Bayesian optimization framework to deal with these tradeoffs via constrained optimization, and present two applications of our method that yield substan-tial speedups at little to no loss in accuracy for two of the most popular machine learning algorithms, kernel Support Vector Machines and k -Nearest Neighbors.
 Although not the primary focus of this paper, the strong results of our model-compression applications (Burges &amp; Sch  X  olkopf, 1997; Bucilu et al., 2006) demonstrate the high impact potential of cBO. The use of cBO eliminates all hy-perparameters from the compression algorithm and guar-antees that any output model matches the validation accu-racy of the original classifier. In our experiments we obtain speedups of several order of magnitudes with kernel SVM, making the algorithm by Burges &amp; Sch  X  olkopf (1997) (with cBO) suddenly a compelling option for many practitioners who care about test-time performance (Xu et al., 2012). In addition, we believe that our method will find use in ar-eas beyond machine learning as well. In particular, many industrial applications may have adjustable processes that produce unwanted byproducts X  X uch as carbon emissions in manufacturing, side reactions in drug synthesis, or heat in computing infrastructures (Azizi et al., 2010) X  X hat must be kept under certain levels. Our algorithm provides a way to quickly and cheaply tune these processes so that output is maximized while maintaining acceptable levels of byprod-uct. JRG, MJK, ZX, and KQW are supported by NSF grants 1149882 and 1137211. JPC is supported by the Gross-man Center for Statistics of Mind at Columbia Univer-sity.Computations were performed via the Washington University Center for High Performance Computing, par-tially provided by grant NCRR 1S10RR022984-01A1.

