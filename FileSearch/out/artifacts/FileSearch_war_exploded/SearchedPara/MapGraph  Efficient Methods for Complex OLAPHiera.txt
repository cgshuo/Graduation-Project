 Online Analytical Processing is a database paradigm that provides for the rich analysis of multi-dimensional data. OLAP is often supported by a logical structure known as the Cube. However, supporting efficient OLAP query resolution in en-terprise scale environments is an issue of considerable com-plexity. In practice, the difficulty of the problem is exacer-bated by the existence of dimension hierarchies that sub-divide core dimensions into aggregation layers of varying granularity. Common hierarchy-sensitive query operations such as Rollup and Drilldown can be very costly on large cubes. Moreover, facilities for the representation of more complex hierarchical relationships are not well supported by conventional techniques. This paper presents a robust hi-erarchy infrastructure called mapGraph that supports the efficient and transparent manipulation of attribute hierar-chies within OLAP environments. Experimental results ver-ify that, when compared to the alternatives, very little ad-ditional overhead is introduced, even when advanced func-tionality is exploited.
 H.2.4 [ Database Management ]: Systems X  Query Pro-cessing, Relational Databases Algorithms, Design, Performance OLAP, Data Cube, Attribute Hierarchies
Online Analytical Processing (OLAP) has become an im-portant component of contemporary Decision Support Sys-tems (DSS). Central to OLAP is the data cube, a multidi-mensional data model that presents an intuitive cube-like in-terface to both end users and DSS developers. In short, for a
An alternative approach to the generation and storage of fully materialized hierarchical cubes is to produce data cubes (or cuboids) containing hierarchies represented only at the finest level of granularity. Hierarchical rol l up or drill down is then done in real time during query resolution. There are, in fact, two distinct approaches in this regard. In the first case, we embed the hierarchical attributes within conven-tional relational tables and subsequently employ (possibly extended) SQL to process the appropriate hierarchical val-ues. However, while providing a clean interface for very simple hierarchies, the SQL-based approach is not easily ex-tendible to more complex hierarchical forms.

In the second case, we extend the relational model to in-clude hierarchy-sensitive data structures. Without the limi-tations imposed by a computational framework that was not explicitly designed to support complex hierarchies, the ex-tended model offers the potential to support more powerful hierarchical logic. In order for this approach to be feasible, of course, the associated overhead must be minimized.
In this paper we present mapGraph, a suite of algorithms and data structures for the manipulation of attribute hier-archies in  X  X eal time X . In particular, we support efficient query processing for two non-trivial but common hierarchi-cal forms  X  unbalanced and non-strict  X  that are not well supported in either the academic or commercial spaces. Be-cause it is important to ground performance sensitive query frameworks within viable, fully functionally database proto-types, we have integrated the new structures into our own Sidera ROLAP Server [4]. Our experimental results demon-strate that not only are the storage requirements  X  both in-memory and on-disk  X  quite small, but that real time processing overhead is equally modest.

The remainder of the paper is organized as follows. We discuss related work in Section 2, while Section 3 briefly introduces relevant preliminary material. Our new meth-ods and data structures for supporting unbalanced and non-strict hierarchies are then presented in Sections 4 and 5 re-spectively. Algorithms for hierarchy processing are then dis-cussed in Section 6. Experimental results are presented in Section 7, with final conclusion provided in Section 8.
The data cube model was formally introduced by Gray et al. [5]. In the succeeding years, a series of algorithms for the efficient computation of the data cube were presented [1, 2, 16, 19]. Most were based in some way upon the cube lattice presented by Harinarayan et al. that identified the relation-ships between group-bys sharing common attributes [6]. In most cases, simple non-hierarchical attributes were assumed.
More recent cube models have made an effort to support more realistic cube architectures. The CURE cube described by Morfonios and Ioannidis includes hierarchical attributes but relies on an augmented (and storage intensive) form of full cube materialization to support query resolution [13]. Sismanis et al. propose a complex tree-based model called DWARF that eliminates tuple redundancies to create a cube data structure that is both compressed and searchable along attribute hierarchies [18] . In both cases, however, support for complex hierarchies is quite limited.

Interestingly, a number of papers have discussed cube hi-erarchies in the context of conceptual modelling. Though the focus here is not upon the design or implementation of hierarchy sensitive data structures, a key benefit of this re-Figure 2: (a) The mapping model, illustrated with a simple three level Product hierarchy. (b) The hMap data structure. [ ] indicates a specific value within a given hierarchy level. Informally, we can say that if a hierarchy is linear, there is a contiguous range of values R ( j ) on A ( j ) that may be aggregated into a contiguous range R ( i ) on A ( i ) .Asacon-crete example, the day-month-year Time hierarchy is linear in that a contiguous range of day values  X  say, 15 to 41  X  can always be aggregated into a contiguous range of month values  X  in this case 1 to 2. In fact, we can refer to Time as an implicit hierarchy, one whose linearity is self-evident. The linearity of other attributes is not always immediately obvious (e.g., an alphanumeric Product Number).

The hMap data structure presented in [3] exploits the notion of attribute linearity in order to provide extremely efficient translation between the levels of what are known as symmetric hierarchies; that is, a hierarchy that be rep-resented as a balanced tree. Specifically, linearity is first enforced by building mapping tables that are ordered by di-mensions A ( k )  X  A ( k  X  1) ...A (1) . Figure 2(a) illustrates the mechanism for a three-level Product hierarchy. The map-ping table is then converted into an efficient in-memory data structure called the hMap that supports the following range translations : (i) mapping from a base level attribute value A (1) to the corresponding sub-attribute A i ( j ) ,j &gt; 1; (ii) mapping from a sub-attribute A i ( j ) to the corresponding range on the base attribute A i (1) .

The hMap is illustrated in Figure 2(b). Each core at-tribute A i in the d-dimensional problem space is associated with h A i  X  1 hierarchy maps, where h is the number of hi-erarchy levels for attribute A i (base level maps need not be stored in the hMap). For a given level A i ( j ) ,j &gt; 1, the as-sociated map is made up of the maximum value from the range on A i (1) corresponding to the current value of A i ( j ) . For example, Type 2 (Engine) corresponds to the base level (Product ID) range 3  X  5. The second cell of the Type map therefor contains the value 5.

Performance and storage requirements for the hMap are quite impressive. Worst case query time is bounded as nation level of the hierarchy on A i . Moreover, the collective size of a d -attribute hMap using non-base levels exclusively in the hierarchy for attribute A i and | l j ( A i ) | is the cardinal-Figure 4: The mapping table for a unbalanced Prod-uct hierarchy. the hMap model so that the query engine is able to support unbalanced hierarchies without sacrificing performance or introducing unacceptable complexity. As with the hMap, we must maintain the notion of attribute linearity and, in addition, we must provide translations between arbitrary levels of the now possibly asymmetric hierarchy. Again, we will use a mapping table to define the structure of the in-memory data structure. In this case, we begin by identifying the deepest level of the current hierarchy. Using Figure 3 as the running example, the maximum depth would be five. For all mapping records with less than five values, we then add stubs to fill out the unused fields. A multi-dimensional sort is then performed to produce the table depicted in Figure 4.
Note the following two characteristics of the new map-ping table. First, the base attributes (i.e., product num-bers), which are integer-based surrogate keys, are consecu-tively numbered and may cross level boundaries (they are displayed in grey). Second, Level IDs do not cross level boundaries and may be repeated in the same column.
Now that the mapping table has been constructed, we must use it to load the mapping data structure. Note, how-ever, that the three level vector of the hMap is no longer adequate. Instead, we propose a mapGraph extension called uMap. Figure 5 provides an illustration of the uMap tree , using the data of the running example. The tree is con-structed so as to provide an efficient representation of the original hierarchy. Like the hMap, it only stores base at-tribute delineation points . No additional data need be sup-plied.

Before proceeding with the explanation of the the uMap processing logic, we note that query specification for un-balanced hierarchies of arbitrary depth is somewhat more complex than would be the case for simple balanced hierar-chies. Specifically, it must be possible to define an arbitrary but exclusive path through the hierarchy tree. To do so, we employ an MDX-style syntax for query identification. For example, a hierarchical member from our running example might be identified as [Products].[Household].[Bathroom].-[Personal].[Children]. Here, the trailing  X  X hildren X  is a lan-guage keyword identifying all descendants of  X  X ersonal X .
Because the uMap contains only integers (alphanumeric
The formal characteristics of the uMap are similar, though not identical to those of the hMap. To map from a base level attribute value to the corresponding sub-attribute A i ( j ) ,j  X  1, we simply traverse the tree until the appropriate leaf-level position is found. A sub-attribute string is constructed with no additional cost. Consequently, the worst case bound on this form of translation is simply O | l max ( A i ) | ,effectivelythe longest path in the A i hierarchy. While the uMap has an ir-regular fan out (i.e. a non uniform number of children), note that the number of levels in the tree is directly related to the number of levels in the hierarchy. Specifically | l max ( A i ) | = levelCount( A i )-1.

When mapping from a sub-attribute to the base, we must first identify the level corresponding to the sub-attribute, and then perform the base attribute mapping on the ap-propriate tree node. Worst case mapping time is therefore O | depth of the hierarchy on A i while | l d ( A i ) | is the cardinality of the destination level of the hierarchy A i .

In terms of physical resources, we note that while the structure of the uMap is certainly different than that of the original hMap, its content is effectively the same. That is, it stores a compact representation of the non-base hierarchy levels for a given attribute. As such, the memory footprint for the uMap, in an asymptotic sense, is equivalent to that of the hMap.
The notion of linearity is central to the mapping struc-tures described thus far. In fact, one of the key features of dimension linearity is that the associated levels model one-to-many relationships between parent and children. We refer to such hierarchies as strict . In certain practical environ-ments, however, it is not unusual to encounter complex hi-erarchies in which many-to-many parent/child relationships exist. Clearly, the uMap alone is insufficient since we can no longer guarantee the linearity of base level members.
Figure 6 provides an illustration of a small but relatively typical non-strict hierarchy. In this case, we can see a many-to-many relationship between the leaf level and its immedi-ate parent. Further, we can see that the relevant edges have been augmented with numbers representing the distribution of resources for a given child. For example, the employee  X  X ike X  is a member of the Research, Sales, and Management departments. As such, his contribution to the cube measure relevant to this environment must be shared across all three divisions. In this case, the cube designers/builders have de-termined (in consultation with users) that an appropriate distribution would be 50%, 20%, and 30% respectively. It should be clear that the task of disambiguating query paths is now considerably more difficult.

Recall that mapGraph storage represents data at the most detailed granularity level. In a Rollup operation, this implies that measurement totals must be divided between nodes at the parent level. Clearly, this distribution information must be physically stored in order to permit this opera-tion. Though we know of no current OLAP application that directly targets many-to-many queries, one can  X  X anually X  support these operations using Bridging tables [8]. Here, left). The array itself represents the map associated with ID 1 at level k = 2, in this case the Research Department. The associated value pairs are [1 , 100] , [2 , 50]. This tells us that the Research Department contains two employees whose ID values at level k + 1 (i.e., 3) are 1 (Simon) and 2 (Mike). Moreover, we know that 100% of Simon X  X  contribution to the cube measure is associated with this department, while just 50% of Mike X  X  contribution is relevant to Research. Now let us examine nmap k +1 [5] to see how the second map is uti-lized. Here, the fifth list is associated with ID 5 (John) at the leaf level. For this employee, we learn that he is a mem-ber of two departments, 4 (Production) and 5(Shipping). In turn, his measurement values should be divided so as to link 40% to the first department and 60% to the latter.
In terms of the physical structure, note that the map-ping lists nmap k and nmap k +1 are defined as arrays of ar-rays , thereby allowing the internal lists to be of arbitrary size. Moreover, because the construction and loading of the maps is based upon the underlying ID maps, the ID values of the nMap are always listed in sorted order. It should also be clear that the ratios themselves are redun-dantly shared between nmap k and nmap k +1 . To minimize storage costs (particularly for floating point ratios) we re-duce the ratio value to a [ integer, decimal ] format (e.g., 34.55 = [34 , 55]). Clearly, the first component is limited by the interval (0 , 100] while, in practical environments, the second would be limited to the interval [0 , 99). We there-fore define the distribution value as consisting of the triple [ ID, ratio prefix , ratio suffix ]. As a result, the ratio pair need only occupy 7bits+7bits = 2 bytes of storage, signifi-cantly reducing the effect of ratio redundancy.

In terms of nMap processing, we note that the nMap and uMap are likely to coexist within a single dimension hierar-chy (i.e., one-to-many + many-to-many levels). Recall that the uMap (and the simpler hMap) rely upon a linear order-ing of base level attributes. In order to integrate the uMap and the nMap, however, linearity must be maintained for the uMap components. We ensure this as follows. For a uMap between level k and k + j , we define level k + j as the logical base . For all consecutive levels above k + j , the uMap stores the maximum values for the associated logical level. This process continues until either (i) we reach the root or (ii) another nMap level is encountered.

We now present the navigational model for the mixed mode uMap/nMap. For the purposes of illustration, we will assume that the nMap is housed at the base level though, as noted above, this is not required. Assuming the standard
As is the case for the hMap and the uMap, performance is of primary concern during the translation operations. In terms of the mapping from base to sub-attribute A i ( j ) ,j &gt; 1, we note the following. The first step in the process is the selection of the relevant array in the nMap data structure. Since the arrays are indexed by their pre-defined mapping values, this operation can be performed in O(1) time. Pro-cessing of the array itself is O ( k ), where k is equivalent to the parent count in the many-to-many mapping. In practice, however, the value of k is quite small in the OLAP content, typically &lt; 5. For each path j, j  X  k so defined, we traverse the mixed mode tree in the standard fashion (i.e., using the uMap). Consequently, the base to sub-attribute access cost can be bounded as O (1)+ O ( k )+ O ( k  X  ( levelCount A i  X  1)) = O ( k  X  ( levelCount A i )). Here, levelCount A i is the number of levels between the consecutive one-to-many relationships in hierarchy A i . Again, we note that the value of k is quite small so that the practical increase in processing cost is a small factor above that of the standard uMap.

With respect to the translation from sub-attributes to base, we begin by descending the uMap in the standard fash-ion to obtain the max/min range on the associated nMap. This is a simple O ( levelCount A i  X  1) operation. We must now process the O | l d ( A i ) | members we find there, where | l ( A i ) | refers to the cardinality of the destination level. For each of the members of this set, we record their k parent/ID pairings. The worst case cost of the operation is therefore O ( levelCount A i  X  1) + O ( k  X  X  l d ( A i ) | ). In practice the sec-ond component will dominate and will likely create a larger cost than the base to sub-attribute mapping. We note the following, however. First, the practical value of k is quite small, while | l d ( A i ) ) | overestimates the actual cost since only a small portion of a given level is likely to be delineated by a given max/min pair. Second, the processing of the par-ent/ID mappings is a minimal cost for any many-to-many hierarchy algorithm since all relevant ratios must be pro-cessed. Given that, the nMap provides its result with very little additional overhead.

In terms of the memory requirements, we note that the nMap is designed to minimize the storage requirements of the bridge table data. It represents all relevant informa-tion without the use of pointers and further minimizes ratio values with a compact two-byte format. In a mixed mode format, integration of the nMap has no impact upon the storage required for the associated uMap.
We have thus far described the mapGraph data structures and path navigation techniques used to support unbalanced and non-strict hierarchies. It is important to note that in ad-dition to providing computational efficiency, the uMap and nMap support query level transparency as well. In other words, they offer inter-level transformations without resort-ing to complex query logic. Our Sidera engine, for exam-ple, fully supports all three mapGraph data structures and requires nothing more than the simple path-aware syntax presented in the previous sections. Moreover, we note that while Sidera is a relational OLAP server, the mapGraph methods are equally applicable to MOLAP storage engines. Specifically, they are logically independent of the way in which measure values are stored.

Algorithm 1 describes the process by which Sidera trans-lates a user-defined hierarchical query into a query that can sets is an important consideration in many cube problems, our hierarchy framework is actually skew oblivious .Inother words, transformation performance is affected by the struc-ture of the hierarchy graph, not by the skew patterns in the raw data.

With respect to the data sets, we first generate a multi-dimensional Fact Table with dimension cardinalities arbi-trarily chosen in the range 2 X 1000. Fully materialized data cubes are then constructed from the fact table; the Sidera server is free to select the most appropriate level of aggre-gation for a given query. In terms of the hierarchies them-selves, we create a mix of hierarchy depths, from two to six levels, with non-base levels having cardinalities of 10 X  500. We also use the standard approach of timing queries in batch mode. In our case, an automated query generator constructs batches of 1000 range queries against symmetric, unbalanced, and non-strict hierarchies. High/low ranges are randomly generated for each of k dimensions, randomly se-lected from the d -dimensional space, k  X  d . Five batches of queries are generated and the average run-time is computed for each plotted point.
To evaluate the computational cost of uMap transforma-tions, we define a series of unbalanced hierarchies (as per the above description) on the base data cube. We then use our query generator to produce distinct batches of 1000 hi-erarchical and 1000 non-hierarchical queries on the same di-mensions. The hierarchical queries have ranges randomly defined on one or more levels of the dimension hierarchy.
Figure 8(a) provides the total response time for the two query forms. Results are displayed for 100K, one million, and 10 million records. The graph illustrates a very modest computational cost of approximately 15%-18% (the simpler hMap adds about 12% on the same test). We note that in a practical setting an increase in compute time of less than one fifth on average for a single query is likely to be imperceptible to users of the system.

To assess the overhead associated with the more complex nMap, the dimension hierarchies were redefined so as to in-clude a combination of strict and non-strict hierarchy levels (i.e., mixed mode). The results depicted in Figure 8(b) il-lustrates an overhead cost of about 35-39% on average. This cost increase is in keeping with the architectural model of the nMap, which must cope with a significant increase in the degree of information required in order to represent many-to-many relationships. Again, however, the effect on the end user is still quite small, given the added functionality.
In the absence of the kind of data structures described in this paper, options for hierarchical dimension processing are quite limited. Recall that for strict hierarchies, the stan-dard technique is to redundantly store hierarchy informa-tion in the dimension tables of the star schema and then, at query time, to join these tables with the relevant fact table or cuboid. To provide this comparison, we have extended Sidera so as to support the standard Sort-Merge join.
We provide a comparison in terms of both cuboid size and dimension count. To evaluate the former, we create 10 strict dimension hierarchies made up of an even mixture of symmetric and unbalanced forms. As always, we employ batches of 1000 queries, this time in hierarchical form only. Figure 9: (a) hMap and uMap versus the Sort Merge Join (b) hMap and uMap versus Sort merge, as a function of dimension count (c) hMap and uMap versus SQL Server.
In production environments, it is quite likely that OLAP users will be accessing systems that are larger than the ones that can be conveniently tested in academic settings. As a result, it is important to provide some understanding of performance as core parameters grow. Our scalability as-sessment begins with a look at performance patterns as the number of records increases from 100K to ten million. We use a 10-dimensional fact table, and we define the dimen-sions so as to contain symmetric, unbalanced and non-strict hierarchies.

Figure 10(a) shows the execution time for hierarchical queries as a function of data cube size. As can be seen in the figure, an increase in the number of records in the fact table is associated with a linear increase in execution time. In fact, this is as expected since the translation cost of a given mapping model is proportional to the path length of the hierarchy. As a result, the maps introduce an essentially constant overhead for the translation of individual columns.
To assess the impact of path hierarchy depth, we created a 10 dimensional fact table with one million records. We then set the depth of all 10 dimension hierarchies to be of size two, then four, then six (the practical limit for a single hierarchy). Figure 10(b) shows the results for the three di-mension depths. We may note two things. First, the impact Figure 11: (a) rate of overhead growth as a func-tion of hierarchy depth (b) nMap versus Pederson technique.
 Table 3: The 5-dimensional non-strict fact table and its correspondence in strict hierarchies. formations of the Pedersen method. Observe that the nMap structure is 15 to 20 times faster than the technique pro-posed by Pederson. Simply put, while we can verify that the Peterson method does in fact produce the appropriate result, it is complex to design and scales very poorly relative to the mapping structures we have presented.
The data cube has become an important theme in OLAP-based academic research. While a number of efficient algo-rithms for data cube generation have been presented in the literature, practical querying facilities have received less at-tention. Of particular importance is the ability to provide core OLAP query functionality on top of hierarchical fea-ture attributes. In this paper, we present algorithms and data structures that can efficiently and transparently sup-port complex but common hierarchy forms, and can do so in either ROLAP or MOLAP environments. Our new map-Graph methods do not require significant memory, storage resources, or complex DBMS integration, instead relying on efficient mapping and transformation services that can be cost-effectively applied at run-time. Experimental results demonstrate the effectiveness of the techniques on arbitrary query streams.
