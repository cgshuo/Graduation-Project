
Traditional query process for time-series data transforms data from the time domain into the frequency domain. It is less controllable by the end users, therefore isn X  X  well suited for queries that find patterns with many dynamically specified user constraints. For these queries we present a method to search time-series data which first transforms time sequences into symbol strings using change ratio between contiguous data points in time series. Next, a suffix tree is built to index all suffixes of the symbol strings. The focus of this paper is to demonstrate how this method can adapt to the processing of the dynamically constrained time-series queries. Many traditional approaches in time-series query processing are based on transforming data from the time domain into the frequency domain to optimize the indexes so that more efficient search and retrieval can be achieved [l, 3, 7, 15, 161. As a result, these approaches are well suited for searching patterns, such as the similarity-based queries (e.g., example query Ql). 
Time-series Query Processing, Data Mining, Pattern Matching. 
Many real-life database applications manage temporal data that are physically stored in time sequence. The examples of time-series data include the prices of mutual funds and stocks, the production outputs, weekly sale totals, and the daily temperatures. 
In many of these applications, it is highly desirable to tind patterns in their respective time-series data set. The result may help to improve the processes such as analyses, predictions, and data mining [2]. The followings are examples of time-series pattern matching queries: We in this paper explore solutions when no known patterns exist. For example, the upward trend constraint in Q2 is very general and includes shapes of various degrees. Therefore, methods for similarity-based pattern matching [l, 3, 7, 151 which focus on matching a specific shape may not be suitable for processing Q2. The example query Q3 is based on weekly totals and pre-built indexes based on daily totals may not be effective in processing this query. Other examples include matching based on different moving average window sizes, matching combinatorial patterns (e.g., patterns represented by regular expressions), matching patterns with different degrees of accur+cy specified for different sub-patterns, etc. In general, we focus time-series query processing with various dynamically specified constraints and present a new method called IMPACTS (the Interactive Matching of Patterns with Advanced Constraints in Time-Series databases). IMPACTS is divided into two stages, the off-line preprocess stage and the on-line query stage (Figure 1). Ql: Find all stocks that behave  X  X imilarly X  to a certain pattern. 
Q2: Find all factories in any n-day time periods in which the defect rates of their perspective factories show a consecutive upward trend. 
Q3: Find all head-and-shoulder patterns in all regions X  weekly sale totals based on 3-day moving averages. 
The example query Ql is a similarity query for time-series data or mutual fund performance. The query Q2 can be used as a warning system to detect a potential production problem. The query Q3 provides a useful marketing tool in analyzing the sale patterns among different regions. It is based on the moving average [6] to generalize trends. KDD-99 San Diego CA USA The pre-process stage of IMPACTS has two phases: the transfom? phase and the index phase (Figure 1). In the transform phase, each sequence of real numbers in the time-series data is transformed into a string of symbols. This is achieved by first segmenting the entire range of change ratios between any two consecutive time points into a finite number of non-overlapping smaller ranges (segments). Next, a unique symbol is used to represent each segment, thereby transforming a time sequence into a symbol string. 
In this paper, we present the different stages of IMPACTS as well as algorithms (based on the suffix tree structure) to compute time-series pattern matching queries with the abilities to dynamically process constraints such as the multiple degrees of accuracy, different moving average window sizes. We also describe how 
IMPACTS can be used to resolve advanced constraints such as a dynamically specified aggregate period and combinatorial patterns. Lastly, we present a performance evaluation to show that our method can be much faster than the naive approach. 
The rest of this paper is organized as follows: We first discuss related work in Section 2. Next, we present the pre-process stage in Section 3 and the query stage in Section 4 respectively. We present our performance evaluation in Section 5 and conclude the paper in Section 6. 
We categorize recent work in time-series pattern matching into two general approaches. The first approach maps time sequences into frequency domain; the second processes the time sequences directly in time domain. The frequency domain approach, pioneered by [l], in general computes a Discrete Fourier 
Transform [ 10, 141 for each sequence and selects the first few coefficients to index their respective original sequences. 
Sequences with matching coefficients are considered similar. The indexing mechanism is typically through a multi-dimensional index structure such as R-tree [9] or R*-tree [S]. 
While in [l], the focus is on whole sequence matching, the work in [7] generalizes the process to allow subsequence matching. In [ 151, moving average, time warping, and reversing are formulated and the indexing methods are further examined for approximate subsequence matching. 
The recent work in time domain [3, 161 focus on segmenting long sequences into smaller subsequences for approximation. A multi-dimensional index structure, such as R-tree [9] or R*-tree [5], is then used to index the small segments. In [3], an innovated approach is introduced based on atomic segments, called windows, which can be normalized with similar windows respectively stitched to form pairs of large similar subsequences. 
In [ 161, based on the divide-and-conquer approach, subsequences are identified and approximated by families of real-valued functions. 
The IMPACTS system also operates in time domain. But it differs from all the above approaches (both frequency and time domains) [ 1, 3, 7, 15, 161 in one significant way. The IMPACTS can preserve, to a very high degree of details, the shapes of the original sequences in its index structure (the suffix tree). A major advantage of detail preservation is the flexibility to dynamically process a diverse class of different time-series matching queries such as those based on different degrees of accuracy, moving window sizes, aggregate periods, and vague trends (see Section 4). For example, time-series matching queries with different moving window sizes, aggregate periods, or vague trends cannot be processed by the aforementioned approaches [ 1, 3, 7, 15, 161 without the restructure of their respective index structures. 
Therefore, the ability to dynamically process a diverse class of different matching queries makes IMPACT more suitable as an interactive time-series pattern matching approach. 
In [4], a shape-describing query language called SDL was proposed for time-series shape matching. An index structure was proposed but no performance data was given. The SDL model can be adopted by IMPACTS to formulate some of its query classes. The focus of this paper however is on the system aspect of 
IMPACTS, not on query language. The suffix tree index deployed by the IMPACTS system is used extensively in the string-matching problem [ll, 12, 13, 171. 
The first stage of IMPACTS is the preprocess stage in which the transform phase transforms the time-series data into symbol strings and the index phase build suffix tree indexes based on these strings. 
Transforming a time series into a symbol string can be achieved with various ways. In this paper, we present one method that is based on computing the change ratio from one time point to the next time point and dividing the variances of all change ratios into discrete segments such that change ratios that fall into one segment are represented by a unique symbol. We use an example (Figures 2) to illustrate this process. First, we define three parameters below: . The parameter min is the lower bound of all change ratios . The parameter max is the upper bound all change ratios . The parameter numsegmenf represents the number of 
In Figure 2, min and max are set to -47% and 63% while the numsegment parameter is set to 11. We equally divide the entire range between min and max by numseg-ment with each unit range set to 20%. In this example, II unique symbols are used to model the segments respectively and any change ratio will fall into one of the segments, therefore will be represented by one symbol. The larger numsegment is, the more accurately the transformation process captures the shape of a time series. 
However, a large number of unique symbols may more space to model each symbol, resulting in a larger and less space-efficient suffix tree. max 
A suffix tree [ 11, 12, 131 is a trie-like data structure that compactly stores all suffixes of a string such that each suftix is represented by a path from the root node to a certain node at a lower level. The compactness is achieved by suffixes having the same prefix share a node such that the path from the root node to this node represents the shared prefix. Because all suffixes of a string are each represented by a unique path in the suffix tree, finding a pattern in a string corresponds to traversing the suffix tree downwards along the path that matches the target pattern. 
Such a structure insures high efficiency in matching string patterns, therefore the suffix tree is widely used in the problem of string matching [ 11, 12, 131. Step 1: Insert ababc Step 2: Insert babe Step 3: Insert abc Step 4: Insert bc Step 5: insert c 
In the index phase, a generalized suffix tree is constructed to index the suffixes of all the transformed symbol strings for fast pattern matching. In Figure 3, we show the construction of a suffix tree based on the string ababc. The live steps in Figure 3 represent the shape of the tree after inserting the suffixes ababc, babe, abc, bc, and c respectively. Note that node splitting occurs in steps 3 and 4 because of the sharing of prefixes ab and b respectively. 
Inserting suffixes from multiple strings into a suffix tree creates a side effect that makes its structure more complex. The string along the path to a node can represent a suffix of an input string or a prefix of a suffix of an input string. For example in Figure 4, the path from root to the node ab in the middle branch represents the of the suffix babe of String 1. To preserve the knowledge that the middle ab node is an end node of a path representing a suffix of have a suffix represented by this node. 
Figure 4: A Suffix Tree with ababc, chub, cbc. ; 3;oi In our implementation, along with each string ID in the list, we also maintain the starting position in this string of the corresponding suffix. For example, the list associated with the middle ab node has a 2-tuple entry (Figure 4). The attributes 2 and 1 in this entry indicates that the suffix represented by the path from root to this node (i.e., bnb) starts at position 1 in String 2.The incorporation of the ID list helps to improve the efficiency in retrieving the matching suffixes. IMPACTS exploits the suffix tree structure and provides methods to process pattern matching queries on time series with dynamic user constraints such as the degree of accuracy and the average moving window size. In this section, we first describe how simple and dynamically constrained pattern matching queries are computed based on the suffix tree structure. Next, we discuss how IMPACTS can be used as an interactive pattern-matching tool to process a diverse class of advanced time-series pattern matching queries. To match a time-series pattern, the IMPACTS system first transforms the target time-series into a symbol string using the same transformation process discussed in Section 3.1. Note that it is possible that a change in the target sequence is beyond the min and max boundaries defined for the data set. In this case, we can use two additional symbols to respectively represent these two out-of-bound cases. Next, IMPACTS traverses, in a downward fashion, the suffix tree containing all the suffixes of the symbol strings. During the traversal, with each encountered tree node, the IMPACTS tries to match the prefix of the target string with the string associated with this node. If a match is found, the IMPACTS continues to traverse the children nodes of this node with a new target string created by removing the matching prefix from the original target string. If the string associated with the encountered node does not match any prefix of the target string, this search thread is discarded. A string that matches the original target is found when a search thread reaches a node whose associated string matches with the entire updated target string. Note that without specifying a dynamic constraint such as the degree of accuracy or an average moving window size, the pattern matching of IMPACTS is exactly the same as string matching on a suffix tree [ 11, 12, 131. With dynamically specified query constraints, the search process of IMPACTS becomes more complex. In our transformation model, the two pre-set parameters min and max define the entire range any movement from one number to the next in the sequence must fall into (see Section 3.1). The segmentation process divides this range into equal but non-overlapping segments with each segment represented by a unique symbol (see Figure 2). The min, max, and numsegment together determine the lower and upper bounds represented by each symbol. In the case of simple string matching, the accuracy of the result is determined by the range that each symbol models. High accuracy is achieved by very small segment range with the numsegment parameter set to a large value. In this model, two symbols are considered a match if and only if they are the same identical symbol. To process dynamic query constraints with different degrees of accuracy, IMPACTS relaxes this rule and allows for fuzzy matching in which a match for a target symbol can be a set of symbols, including the target symbol itself. 
More precisely, let r be the dynamically specified degree of accuracy, the match of a symbol s are any symbols representing segments that are within 1 -r from the segment represented by s. 
For example, in Figure 2, let the dynamically specified degree of accuracy be 15%. The match for the symbol a5 are symbols a3, u4, a,-, a6 and a,. This is because there exists a point in the segment associated with any of these symbols that is with 25% away from a point within the segment associated with the target symbol us. 
The average moving approach is a popular method in financial and stock analysis [6] to generalize trends. The result of applying an average moving window to a time series is a smoother curve with the smoothness enhanced by a wider moving window To process a time-series query with a moving average constraint, 
IMPACTS first transforms the target pattern into the moving average representation based on the user specified constraint (e.g., the window size). Next, IMPACTS traverses the suffix tree in a depth-first order. During tree traversal, IMPACTS computes the moving average for the strings along the search threads on the fly and then matches the dynamically computed moving average with the moving average represented by the target sequence. 
Initially, each search thread may have traversed strings which have less symbols than the dynamically specified moving average window size, say k. At this initial stage, IMPACTS queues up (queue size = k) these traversed prefixes along all search threads. 
When a search thread has traversed a string of k symbols on the suffix tree, it computes the average of the upper bounds and the average of the lower bounds associated with these k symbols. 
IMPACTS then checks to see if the first number in the moving average representation of the target sequence is within these upper and lower bound averages. If it is, IMPACTS declares it a match and goes on to traverse the next symbol on the tree for this thread. 
At this point, IMPACTS drops the first symbol in the queue and puts the next traversed symbol in the queue. New upper and lower bound averages are computed and matched with the next number in the moving average representation of the target sequence, and so on. If at any time during the matching process a mismatch happens, 
IMPACTS discards this search thread. If during traversal, all numbers in the moving average representation of the target sequence falls within the upper and lower bound averages, then the string of this search path matches the target sequence. 
A time series can be based on a fine-grained time unit such as day whereas a pattern-matching query can be specified with a dynamic constraint that is based on weekly totals. While to our knowledge no current systems can efficiently processing this kind of queries, 
IMPACTS can compute this query class in a dynamic fashion. For example, to search aggregate pattern based on weekly totals on the suffix tree with daily totals, IMPACTS traverses downwards each search threads while at the same time aggregates the lower and upper bounds respectively of the traversed symbols. When it encounters a symbols representing the proper ending time point (e.g., the last day of the week), 1MPACTS matches the aggregated upper bounds and lower bounds with the corresponding symbol in the target string. If a match is found, IMPACTS traverses the children nodes of the encountered node and starts aggregating again, and so on. 
Finding similar pattern based on biased criteria can be a very useful function. For example, a query finding a group of stocks or mutual funds that behave similarly to a certain pattern, but are in general more skewed upwards (or downwards) is one such query. 
IMPACTS can process this type of queries by setting up biased matching criteria. FOT example, when IMPACTS determines a match for a target symbol, it can allow for a wider degree of accuracy for symbols representing movements that are more upward skewed than the ones representing movements that are less upward skewed. In other words, IMPACTS uses two degrees of accuracy, one for upward symbols and one for downward ones. Searching a vague pattern such as the example query Q2 in 
Section 1 may generate results of many different shapes. The state-of-the-art similarity-based time-series matching approaches [1, 3, 7, 1.51 typically focus on matching more precise shapes, therefore are less suited than IMPACTS for processing this class of queries. For example, to search a continuous downward trend, the IMPACTS traverses the suffix tree and only follows the symbols representing downward movements. 
IMPACTS can incorporate a. X  X onstraint that allows for a certain number of mismatches. For example, a pattern matching query can be constrained to find all similar patterns allowing at most k mismatches. To process this kind of queries, IMPACTS searches the suffix tree and keeps a mismatch counter for each search thread. When a mismatch counter increases beyond the allowable value, its corresponding search thread is discarded. 
This class of queries means that different sections along the target string have a different accuracy constraint. While no current systems can efficiently process queries of this class, IMPACTS can dynamically process them in the same way as it computes the queries with consistent accuracy constraints, with only a minor extension. The extension is that during tree traversal, IMPACTS keeps track of what section of the target string that it is currently matching and uses the corresponding degree of accuracy for matching as specified by the query constraints. 
IMPACTS can be adapted to search a combinatorial pattern similar to one modeled by a regular expression. FOT example, the query manager, in matching a combinatorial pattern, can starts a multi-thread search over the suffix tree while keeping track of the current state for each search thread (much like the state of the finite state machine represented by an regular expression). A the target or when it reaches the bottom of the tree without having completely traversed the target pattern. 
We compare pattern-matching efficiency between IMPACTS and the sequential scanning method based on synthetic sequence data. 
Because of space limitation, we only show a small set of our results. We first randomly generated sequences with a length of 500 and varied the number of sequences from 100 to 1000. For the second set of experiments, we limited the number of sequences to 500 and varied the sequence length from 100 to 1000. For both sets of experiments, we set the moving average window size to 5 and the allowable error ration to 0.3%. Next, we process pattern matching with randomly selected target sequences and collected the averaged results. Both sets of results show that pattern matching by IMPACTS is much more efficient than by the sequential scanning method. 
We consider the problem of query processing for time-series data with various dynamically specified constraints. We present the 
IMPACTS system that maps atomic movements in a time series into a finite set of symbols to transform time series into symbol strings. Next, IMPACTS uses a suftix tree to index prefixes of these symbol strings. In this paper, we show that IMPACTS can be used to process queries with dynamically specified constraints such as moving average window sizes, aggregate time units, vague trends, and combinatorial patterns. We also present a portion of our performance studies which shows that IMPACTS can be much more efficient in processing queries with dynamic constraints than the sequential scanning method. [31 r41 El [71 r91 [lo] Hamming, R.W. Digital Filters. Prentice-Hall, 1977. [l l] Hui, L.C.K. Color set size problem with applications to [12] Landau, G.M. and Vishkin, U. Fast parallel and serial [ 131 McCreight, E.M. A space-economical suffix tree [14] Oppenheim, A.V. and Schafer, R.W. Digital Signal [15] Ratiei, D. and Mendelson, A. Similarity-based queries for [16] Shatkay, H. and Zdonik, S.B. Approximate queries and [17] Wang, J.T.L., Chim, G.W., Marr, T.G., and Shapiro, B. 
