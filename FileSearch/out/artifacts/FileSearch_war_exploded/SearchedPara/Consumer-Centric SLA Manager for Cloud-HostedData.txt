 We present an end-to-end framework for consumer-centric SLA management of virtualized database servers. The framework fa-cilitates adaptive and dynamic provisioning of the database tier of the software applications based on application-defined policies for satisfying their own SLA performance requirements, avoiding the cost of any SLA violation and controlling the monetary cost of the allocated computing resources. In this framework, the SLA of the consumer applications are declaratively defined in terms of goals which are subjected to a number of constraints that are specific to the application requirements. The framework continuously moni-tors the application-defined SLA and automatically triggers the ex-ecution of necessary corrective actions (scaling out/in the database tier) when required. The framework is database platform-agnostic, uses virtualization-based database replication mechanisms and re-quires zero source code changes of the cloud-hosted application. H.4 [ Information Systems Applications ]: Miscellaneous; D.2.8 [ Software Engineering ]: Metrics X  complexity measures, perfor-mance measures Cloud Database, Service Level Agreement (SLA).
Virtualization is a key technology of the cloud computing paradigm which is increasingly being used to improve the manageability of software systems and lower their total cost of ownership. They al-low resources to be allocated to different applications on demand and hide the complexity of resource sharing from cloud users by providing a powerful abstraction for application and resource pro-visioning. One approach for deploying data-intensive applications in cloud platforms is the virtualized database server approach [2, 12] where an existing database tier of a software application that has been designed to be used in a conventional data center can be directly ported to virtual machines in the public cloud. In this ap-proach, database servers, like any other software components, are migrated to run in virtual machines. One of the main advantages replication mechanism and requires zero changes in the line codes of the cloud-hosted software applications.
Although software applications which are deployed on a pub-lic cloud infrastructure can benefit highly from on-demand access to various computing resources at low prices, its service levels are highly likely to become more uncertain. In practice, traditional cloud monitoring technologies focus on low-level computing re-sources (e.g. CPU utilization, disk speed). In principle, translating the SLAs of applications X  transactions to the thresholds of utiliza-tion for low-level computing resources is a very challenging task and usually done in an ad-hoc manner due to the complexity and dynamism inherent in the interaction between the different tiers and components of the system. Therefore, it becomes a significant is-sue for the cloud consumer to monitor and adjust the deployment of their systems if they intend to offer viable service level agreements (SLAs) of a higher level of abstraction (e.g. business transaction or data freshness) to their end users. In principle, meeting SLAs which are agreed with end-users by consumer applications of cloud resources using the traditional techniques for resource provisioning is a very challenging task due to many reasons such as: In practice, it is a very challenging goal to delegate the manage-ment of the SLA requirements of the consumer applications to the side of the cloud infrastructure service provider. In order to tackle this challenge, our framework is designed to support cloud-hosted applications to achieve their defined SLA with a main focus on the database tier .
Figure 1 shows an overview of our framework architecture which consists of three main modules: the monitor module , the control module and the action module [12]. In this architecture, the moni-tor module is responsible for continuously tracking the application-defined SLAs and feeding the control module with the collected information. The control module is responsible for continuously checking the monitored SLA values against their associated application-defined SLAs and triggers the action module to scale out/in the database according to the application-defined action rules. The de-sign principles of our framework architecture are to be application-independent and to require no code modification on the consumer software applications that the framework will support. To achieve these goals, we rely on a database proxying mechanism which pro-vides the ability to forward database requests to the underlying databases using an intermediate piece of software, the proxy, and to return the results from those request transparently to the client program without the need of having any database drivers installed.
When the application load increases and the database tier be-comes the bottleneck in the stack of the software application, the define an associated maximum response time SLA( S i ) for each transaction type ( T i ) so that when an instance of the transaction type is presented to the system at time 0, the system is considered to be achieving its target if it finishes the execution of the trans-action at time t where ( t  X  S i ). Otherwise, if ( t &gt; S i ) then the instance of the transaction is considered to be violating its defined SLA and hence an instance of SLA violation is recorded. For ex-ample, a user login application request can define SLA of 100 ms as its maxim response time, a search request can define SLA of 600 ms while a request of submitting an order would define 1500 ms as its SLA. To achieve this goal, each application transaction is described, using an XML dialect, as a pattern of SQL commands where the transaction response time is computed as the total exe-cution time of these individual operations in the described pattern. The monitoring module uses the database proxy to correlate the re-ceived database operations based on their sender in order to detect the defined transaction patterns and feed the controller module with the computed value of the SLA metrics of the transaction instances.
The CAP theorem [1] shows that a shared-data system can only choose at most two out of three properties: C onsistency, A vailability, and tolerance to P artitions. Most of the cloud data management systems implement various forms of weaker consistency models (e.g. eventual consistency [9]) so that all replicas do not have to agree on the same value of a data item at every moment of time. In practice, the eventual consistency model has been accepted by many of the new generation of Web 2.0 applications (e.g. so-cial networks) which could be more tolerant with a wider win-dow of data staleness (replication delay). However, these appli-cations need to be supported by mechanisms that enable them to manage the extent to which inconsistencies can be tolerated. Our framework enables the consumer applications to define the toler-ated SLA replication delay ( S i ), in terms of time units, of each database replica ( R i ) which is hosted in the data center of the ge-ographic location ( L i ). The monitor module tracks the replication delay of each replica by continuously measuring the time difference of each two associated local timestamps committed on the master database and the target replica [11].
Clearly, optimizing the application-defined SLA while minimiz-ing the cost of used computing resources is vital goal for the con-sumer applications. However, the application workload demands can vary significantly. Thus, the application has to allocate suf-ficient resources to support the user workloads or risk the conse-quences of SLA violations in the form of lost revenue or dam-aged reputation. In particular, the application will have to scale out the database tier (adding more replicas) when it deems that ex-isting database replicas are insufficient to accommodate the incom-ing workload. Meanwhile, the application will have to scale in the database tier (removing existing replicas) if he can meet decreasing application workload with a less number of replicas. Our frame-work enables the application to declaratively define, using another XML dialect [11], application-specific action rules to adaptively scale out or scale in according to the status of the application-defined SLAs. Examples of these corrective actions are:
