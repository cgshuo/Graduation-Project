 1. Introduction
Probabilistic data has been widely investigated due to many potential applications such as information extraction, natural language processing and scientific experimental data management. These applications can generate and treat uncertain data, certainty levels should be returned with the query results. In most cases, the indication of the level of certainty can be a probability, and uncertain data can be represented by probabilistic data.

For the information extraction application, traditional information retrieval can retrieve documents containing specified keywords. Afterwards, it is extended to automatically extract information from retrieved text documents. This extracted information may have some form of certainty or probability associated with it. This information is probabilistic data and can be represented by probabilistic XML data. Especially, if the extracted information is unstructured or hierarchical, then the probabilistic XML data is more suitable for that. For example, when extracting some information about John from a text document which describes the information about John, the result of the retrieval for the age of John can be 35 with 0.3, 37  X  listic XML data model. Probabilistic queries about John can be processed on the given probabilistic XML data. The efficiency of query processing will depend on the probabilistic XML data model and probabilistic query processing method. This exam-uncertainty of data is inevitable because of the reliability of experiments.

To manage probabilistic data, there has been a lot of work on supporting probabilistic data in relational databases ( Deay and Sarkar, 1996; Eiter et al., 2000; Fuhr and R X lleke, 1997; Lakshmanan et al., 1997 ). They considered the modeling of uncertain data in the relational database, and there have been some issues such as the unit with which probabilities will be associated and whether the resulting database is to remain in the first normal form. Several methods proposed to solve these issues generated some drawbacks such as a large amount of redundant storage and the loss of information. One of the reasons for these drawbacks is the flat structure of relational databases, and it seems that XML is more flexible and allows greater heterogeneity of structure and incompleteness of information compared with relational data. These considerations make researches about probabilistic XML data.

The probabilistic XML data is XML data with uncertainty that may be represented by probabilities on elements, attributes and flexibility. Therefore, there is a growing interest in the data model and query processing for probabilistic XML data.
The researches about probabilistic XML data include data modeling and query processing of probabilistic XML data. The issues about probabilistic XML data are the expressiveness of the model, and the efficiency for the query processing which should generate the query results with the probability.
 Several researches ( Abiteboul and Senellart, 2006; Cohen et al., 2009; Hung et al., 2003a, 2003b; Kimelfeld et al., 2008;
Li et al., 2006; Nierman and Jagadish, 2002 ) studied the data modeling of probabilistic XML data. These studies proposed several data models for the representation of probabilistic XML data, such as the DTD adaptation method ( Nierman and Jagadish, 2002 ), possible worlds model ( Abiteboul and Senellart, 2006 ), a simple probabilistic tree model ( Abiteboul and probability on the existence of its parent node. Most of them proposed the query processing methods, which found data matches and calculated the possibility of the matches.

Query evaluation over probabilistic XML data needs not only to find data matches but also to compute the probability of each match. To find data matches, the previously proposed various methods such as indexing or labeling scheme ( Bruno et al., 2002; Chen et al., 2004; Chien et al., 2002; Li and Moon, 2001; Srivastava et al., 2002; Tatarinov et al., 2002; Wu et al., 2004; Zhang et al., 2001 ) can be applied, but to evaluate the probability of each answer, an additional process is needed. Some existing techniques for finding data matches lose their efficiencies and advantages by the additional process-ing for computing the probability of each result when they are applied to the query processing for probabilistic XML data.
The interval-based labeling scheme has advantages in the size of labels. The sizes of labels in the interval-based labeling scheme are the same for all nodes because the label is composed of two integers for the start position and the end position. delimiters cannot be ignored. In other words, the interval-based labeling schemes have good efficiency in the perspective of order to keep the probability information, we should extend the labels from previous labeling schemes. Therefore, in the terms of the size of labels, we choose the interval-based labeling scheme. In addition, the interval-based labeling scheme has advantages in processing queries including ancestor X  X escendant relationships.

In addition to the storage overhead, path-based method has another disadvantage in efficiency in the comparison be-tween labels. For path-based method, the comparison between labels is not simple such as the substring comparison, whereas for the interval-based method, the comparison is the integer comparison. This is another advantage of query pro-cessing in the interval-based method.

Previous XML query processing techniques based on interval-based labeling schemes ( Chien et al., 2002; Li and Moon, 2001; Srivastava et al., 2002; Zhang et al., 2001 ) have strong advantages in processing queries including ancestor X  X escen-dant relationships. They need not to know the full path information of the ancestor X  X escendant relationships for query pro-the path from ancestor to descendant in order to compute the probability of the result. For example, when considering a query /country//name , to calculate the probability of a query result using existing techniques, we need to traverse the data tree from the node matching country , retrieve the probabilities all the nodes in the path to the node matching efficiently handles descendant axis traversal via a labeling scheme without accessing intermediate data nodes, cannot be fully utilized to achieve the efficiency.

Our data model for probabilistic XML data is a probabilistic XML tree which has two types of nodes, ordinary and distri-the subsets of its children.

In this paper, we present an extended interval-based labeling scheme for probabilistic XML tree. The proposed labeling scheme extends the previous interval-based labeling scheme in order to manage not only ordinary nodes but also distribu-node to exist in possible XML trees. This labeling scheme makes it possible to combine the evaluation of query result prob-accessing all ancestors of nodes in the query result. Accordingly we can accomplish the improvement in the performance of probabilistic XML query processing.

Moreover, we propose an extended probabilistic XML query model with the predicates for the values of conditional or value, which is at least zero and at most one. Using the proposed index for probability, we improve the performance of query processing which has the conditions on probabilities.
 The contributions of this paper are the following:
We propose an extended interval-based labeling scheme, which extends the previous interval-based labeling scheme to manage not only ordinary nodes but also distributional nodes, and includes the values of conditional and existence probabilities.

We present procedures to process probabilistic XML queries efficiently using the extended interval-based labeling scheme. Our method accesses only the labels of data specified in queries and finds data matches simultaneously with evaluating the probability of results.

We present an extended probabilistic XML query model and a lightweight index for probabilities. This index makes it pos-sible to eliminate unnecessary accesses to data that will not be included in results.
 probabilistic XML tree and probabilistic XML query tree, while Section 4 discusses the extended interval-based labeling scheme. We describe the method of query processing in Section 5 . Section 6 reports experimental results and then Section 7 concludes the paper. 2. Related works 2.1. Probabilistic XML data processing Several probabilistic XML data models have been proposed in Nierman and Jagadish (2002), Hung et al. (2003a, 2003b), was presented in Nierman and Jagadish (2002) as the probabilistic XML data representation model. Each element could have the Prob attribute to represent the value of probability, and a new element type distribution among sibling elements which is either independent or mutual-exclusive. This model is similar to that of Kimel-feld and Sagiv (2007) . Moreover, Nierman and Jagadish (2002) describes a method to compute the result probabilities for queries in which child axes and branches are supported.

The probabilistic representation for semi-structured data expressed by acyclic directed graphs was proposed in Hung queries with child axes.
 A possible worlds model, a simple probabilistic tree model and a fuzzy tree model were considered in Abiteboul and the probability value of that node to be present assuming its parent is. In the fuzzy tree model, a probabilistic condition which is a conjunction of atomic events is assigned to each node, and each atomic event has probability. However, query processing method and query performance are not mentioned in Abiteboul and Senellart (2006) .
 A query-friendly probabilistic XML database, presented as PEPX (Probability Encoded Probabilistic XML), was described in
Li et al. (2006) . It represents a model for probabilistic XML data, which is similar to the model in Nierman and Jagadish queries, such that each subquery does not have branch nodes. Then, the intermediate results of subqueries are stitched using P-joins to compute the final query result.
 Recently, Kimelfeld et al. (2008, 2009) and Abiteboul et al. (2009) provide an abstract model for representing probabilistic
XML data as p-documents that are trees with two kinds of nodes, ordinary and distributional. They consider several types of distributional node. The det means that each child is chosen with probability 1, the ind means that the choices of distinct children are independent, the mux means that at most one child can be chosen, the exp means that the probability of choosing junction of probabilistically independent events, which can be used globally throughout the document. This model can rep-resent different families of p-documents in terms of the types of distributional nodes that are allowed which are denoted in types, and the model in Hung et al. (2003a, 2003b) is using the exp type if the data is tree-structured. Moreover, Kimelfeld et al. (2008) and Abiteboul et al. (2009) consider the expressive power of the families of p-documents. They study the pos-listic XML data as a p-document and a set of constraints. 2.2. Interval-based labeling scheme
In the interval-based labeling scheme, such as Li and Moon (2001) and Zhang et al. (2001) , the label of any node in an XML data tree is represented as the tuple ( DocID , StartPos , ment; (ii) StartPos and EndPos can be generated by counting the number of words from the beginning of the document with integers during the depth first traversal of the XML data tree; and (iii)
The ancestor X  X escendant or parent X  X hild relationship between two tree nodes N this fashion, such as ( D 1 , S 1 , E 1 , L 1 ) and ( D 2
N iff D 1 = D 2 , S 1 &lt; S 2 and E 2 &lt; E 1 ; (ii) parent X  X hild : N
There are major indications about efficiency of labeling schemes: the efficiency of the query processing using labels, the have strong advantages in processing queries including ancestor X  X escendant relationships. Secondly, if the size of labels is labels is large and incurs high storage overhead. Lastly, when there are insertions and deletions of nodes, if they do not change the labels of many existing nodes, then it is efficient in the perspective of the easiness of update processing. 3. Preliminaries 3.1. Probabilistic XML tree
Generally, the data model for probabilistic XML should present a probabilistic distribution over a set of ordinary XML doc-possible XML trees with probabilities.
In this paper, we present the probabilistic XML tree as the data model to represent the probabilistic XML data. The prob-abilistic XML tree is defined as a node-labeled tree with two types of nodes, ordinary and distributional. The ordinary node distributional node X  X  children and the sum of all subset X  X  probabilities equals one. Moreover, a node of type exp can choose exactly one subset. Surely a distributional node is neither the root nor a leaf.

The probabilistic XML tree in this paper is the family PrXML
Therefore we consider the probabilistic XML data model which is the most expressive among the previously proposed ones which could have efficient query evaluation algorithms. Even though the family PrXML tributional nodes and is more hierarchical than the data represented by the family PrXML set of edges. V = V ord [ V dist , where V ord and V dist node v has the label l ( v ). Especially the label l ( v ) of the distributional node the probabilistic distribution dist over its children v 1 1. ind type: dist ={( v k , p k ) j 1 6 k 6 n }, v chooses 2. mux type: dist  X f X  v k ; p k  X j 1 6 k 6 n and P p k 6 1 g ; 3. exp type: dist  X f X  s k ; p k  X j 1 6 k 6 m 6 2 n and P p the m subsets which are given probabilities.
 a subset of children and the probability of the subset for exp .

As the previous researches ( Abiteboul and Senellart, 2006; Cohen et al., 2009; Hung et al., 2003a, 2003b; Kimelfeld et al., 2008; Li et al., 2006; Nierman and Jagadish, 2002 ), each probability in the source XML data is assigned conditioned on the fact that the parent element exists and we call it conditional probability . For the probabilistic distribution t ={( v k , p k ) j 1 6 k 6 n } of each distributional node p ( ) is the parent node of v . When the type of distributional node is exp , the p s simultaneously exist given that the parent exists.

Actually, the probability that each node exists in possible XML trees could be computed by multiplying the conditional probabilities along the path from the node to the root by the Bayes X  formula as shown in Nierman and Jaga-dish (2002) and Li et al. (2006) , and we call it existence probability . Therefore, to compute the probability of a query result, it is inevitable to access all the ancestors of the nodes in a query result to get the conditional probabilities of ancestors.
 An example for the probabilistic XML tree is shown in Fig. 2 . Each node has an identifier that is marked inside the node. represented by a rectangle inside which the type is marked. Each distributional node has the probabilistic distribution over its children which is represented under the tree.

In order to get possible XML trees from a given probabilistic XML tree, firstly one subset of each distributional node is chosen and the remaining children and their descendants are deleted. And then all the distributional nodes are removed.
At this time, if an ordinary node loses the parent, then the proper ancestor becomes the new parent of that. 3.2. Probabilistic XML query tree
Generally, an XML query tree is the node-labeled tree with parent X  X hild edges depicted using a single line and ancestor X  descendant edges depicted using a double line. The label of node could be an element name, an attribute name, a text value or , where is satisfied by every label. Fig. 3 shows examples of the XML query tree.

A match of an XML query tree to an XML document is a mapping from the nodes of the query tree to those of the doc-ument, such that query node value predicates are satisfied by the corresponding data node, and the axes (/ or //) between query nodes are satisfied by the structural relationships between the corresponding data nodes. The XML query result is a set or a list of matches.

For example, the answer of the query tree in Fig. 3 b can be a list of matches. In this case, there is a match query tree and we know that XML is the title of the book and that Jane Doe is the name of the author according to the query tree.

The XML query tree can be used in order to issue a query over probabilistic XML data without recognizing the represen-tation format or the storage method for probability information. In this case, the XML query tree can be adopted without modifications. However, the user can require the restrictions on the values of probabilities as followings: (i) restrictions on the probabilities of matches in the query result such as ranking or a threshold and (ii) restrictions on probabilities of elements, attributes or values given in the query.

To support the case (ii), the syntax of XML query tree should be modified to represent the conditions for probabilities of elements, attributes or values.
 In this paper, we define probabilistic XML query tree that attaches the conditions for probabilities.
Definition 2. The probabilistic XML query tree is the node-labeled tree with parent X  X hild edges depicted using a single line and ancestor X  X escendant edges depicted using a double line. Each node an attribute name, a text value or . Also each node can have the probability conditions, which use an equality or an inequality operator. The probability can be either conditional probability p
Fig. 4 shows an example of the probabilistic XML query tree which limits the title element with existence probability more than 0.2 and the author element with conditional probability greater than 0.3 and less than 0.7. 4. Extended interval-based labeling scheme over all possible XML trees with probabilities that represent the certainty of obtaining a match when querying a possible uate a query over the whole possible XML trees because the number of possible XML trees is huge. Therefore, it is necessary to evaluate the query over a probabilistic XML tree without enumerating all possible XML trees.
The previous techniques for probabilistic XML query processing mostly take an approach that firstly matches data over a given probabilistic XML tree without considering the distributional nodes and probabilities, and then evaluates the proba-abilities are considered when evaluating the probability of each match.

Several methods have been proposed for efficient XML query processing. Especially the interval-based labeling scheme can decide the ancestor X  X escendant relationships easily only with integer comparisons and it can be used to find matches in probabilistic XML query processing. However, the set of resulting matches is a superset of the exact result, and the cal-additional data access is needed to treat the distributional nodes and probabilities.

In this paper, we propose an extended interval-based labeling scheme which makes it possible to avoid the additional data access and to process probabilistic XML queries only by accessing the labels of nodes in the query. By the extended interval-based labeling scheme, the label of each node in a probabilistic XML tree can be represented as (
Pos , EndPos , Level , Cprob , Eprob ) for an ordinary node and ( butional node, where (i) DocID is the identifier of the document; (ii) sequential assignment of positive integers during the depth first traversal of the probabilistic XML tree; (iii) depth of the node; (iv) Cprob and Eprob are the values of conditional probability and existence probability of the node, respectively; and (v) ChildList is the list of StartPos  X  X  of the children. In the case of exp , the conditional probability Cprob of each node is the sum of all probabilities each of which is the probability of the subset that includes the node.
Fig. 5 shows the probabilistic XML tree in Fig. 2 with node labels which are generated by the extended interval-based labeling scheme. According to presentation convenience, Cprob between the distributional node and children, and DocID , to the StartPos of that, and is represented under the tree. The exp node with the identifier 31 appears to have the proba-tion implies that an empty set with probability 0.1 is included.

When using the extended interval-based labeling scheme, the parent X  X hild or ancestor X  X escendant relationship between two tree nodes can be determined easily the same as the original interval-based labeling scheme. Moreover, the label of distributional node can remove needless matches, and the value of additional data access for evaluating the probability of the result.

When data updates occur, the extended interval-based labeling scheme has to re-compute the existence probabilities and change the values in the labels which are included in the subtree rooted by the node updated. We consider it as future works to efficiently handle this issue. 5. Probabilistic XML query processing
The probabilistic XML query tree can be considered in two cases, without or with probability conditions in nodes. The first case is similar to the previous XML query processing, but we should treat the distributional nodes and evaluate the proba-bilistic XML query processing in the two cases. 5.1. Without probability conditions in nodes
In this subsection, we describe a method to process a probabilistic XML query tree without probability conditions in nodes. The data is a probabilistic XML tree labeled by the extended interval-based labeling scheme. Each node in the prob-abilistic XML tree has the label by the extended interval-based labeling scheme and these labels are managed by lists. A distinct node name is associated with a list of labels each of which is given to a node with the name.
The parent X  X hild or ancestor X  X escendant relationship between two nodes in an XML query tree such as book//name can be processed by using two lists of nodes X  labels in the given probabilistic XML tree. For example, if consid-ering the relationship book/author , we must process the structural join between the list of labels for author sorted in StartPos .

However, to consider an XML query tree with more than two nodes, we should split the XML query tree into several bin-ary structural relationships which are XML queries with two nodes such as structural relationships and join the results of them in order to get the result of the XML query tree.
When joining the results of binary structural relationships, we should consider mutually exclusive or explicit relation-ships which can be considered by mux or exp distributional nodes in the probabilistic XML tree.
However, if we consider the mux distributional node, the result should include only (21, 24), (29, 32) as the pairs of ( At this time, each node is identified by the StartPos value.

Accordingly, when we do not consider distributional nodes, the result of query processing can be a superset of the result binary structural relationships. This cannot occur in simple path queries, but can occur in query trees with branch nodes. branch node of a query tree, cannot exist at the same time if a mux node exists under the node. In Fig. 6 a, dren of the branch node name . If this query is processed over the data in Fig. 5 , the and there are fn and ln under the mux . But these fn and ln included in the result. Therefore, we can improve the cost of joining process by removing these not-possible answers. This feature can be considered for exp node similarly.

As the above, when we consider the distributional node in query processing, the branch node in the query tree should be path separately.

Definition 3. For any two nodes n 1 and n 2 in a probabilistic XML tree, n with n 2 . n 1  X  n 2 means that the probability that n 1 and n simultaneously, denoted by n 1 n 2 .
 Lemma 1. Let node a be the ancestor of node d. If d exists, then a exists.
 Proof. This lemma holds by the property of the tree structure. h
Theorem 1. For any two nodes n 1 and n 2 in a probabilistic XML tree, if n simultaneously with n 2 or any descendant of n 2 .

Proof. Suppose that n 1 or a descendant of n 1 , denoted by d by d 2 .If d 1 and d 2 exist simultaneously, then, n 1 exists and n neously. h
In a probabilistic XML tree, two nodes n 1 and n 2 such that n lowing shows how n 1  X  n 2 occurs by mux or exp , and Fig. 7 shows the case of mux .

In the case of mux  X  X y Definition 1 of mux , for the children c 1 , c 2 , ... , c  X  X y Theorem 1 , for any two different children c i and c j
In the case of exp  X  X y Definition 1 of exp , for the children c 1 , c 2 , ... , c  X  X y Theorem 1 , for any two different children c i and c j
By checking cannot exist simultaneously relationships between data nodes, we can find not-possible answers before join-ing the results of binary structural relationships. In order to find not-possible answers, we examine an instance of matched data nodes for a branch node and all its children in a query tree.

Consider the branch node q r and its all children q 1 , q of the edges between q r and q 1 , ... , q n can be a single line or a double line. Let the matched data nodes be r , d as in Fig. 8 b. Then for all i ( i =1, ... , n ), r .startPos &lt; d neither mux nor exp distributional node which is descendant of r , then these data nodes can be a possible answer.
Otherwise, that is if there is mux or exp distributional node, we can find not-possible answers by checking cannot exist simultaneously relationships occurred by mux or exp . The distributional node mux or exp can include all d as in Fig. 8 c or only a part of d i (1 6 i 6 n )asin Fig. 8 d. Therefore, we should check cannot exist simultaneously relationships for the d i  X  X  whose startPos and endPos are included in the node.

The mux or exp distributional nodes which are descendants of r can be found by checking whether distributional node X  X  and mux or exp . For those mux or exp nodes, we can find not-possible answers by checking the following conditions. At this time, mux or exp node has a ChildList such as ( s 1 ; s 2 that exp node has probability subsets.

In the case of mux  X  If there are d i and d j ( d i  X  d j , mux.startPos &lt; d  X  If there is only one j (1 6 j 6 m ) such that for all d
In the case of exp  X  If there are d i and d j ( d i  X  d j , exp.startPos &lt; d  X  If there is a probability subset set p such that for all d
After checking cannot exist simultaneously relationships, we should evaluate the probability of each data match. If a query query tree with branch nodes is different. Consider the matched data nodes in Fig. 8 b. If d matched data tree and there is neither mux nor exp distributional node which is descendant of r, then the result probability is the product of the existence probabilities of d 1 , ... , d that the repeatedly multiplied part is eliminated by the division.

However, if there is a mux or exp distributional node which is a descendant of r and an ancestor of some d ability in these cases. At this time, the mux or exp node has a distributional node, d 1 , ... , d k are included in (r.startPos, r.endPos) and d
In the case of mux  X  Let s j be the one among s 1 , ... , s m such that for all d
In the case of exp  X  Let S be a set { e 1 , ... , e p } such that for all d i
For an example of the case in which there is a mux distributional node between the branch node and its children, if the query in Fig. 6 c is applied to the data in Fig. 5 , the probability of an instance (1, 8, 21, 24), where numbers are the the existence probability of the fn with startPos 21 and the existence probability of the by the existence probability of the name with startPos 20. This is the case in which there is a mux distributional node be-tween the branch node and its children.

For an example of the other case in which there is an exp distributional node between the branch node and its children, if a numbers are the startPos , in the result of (chapter, section, title, author) is 0.28. This is calculated by (0.63 0.49/ (0.63 0.49)) 0.28 which means that the product of the existence probability of the title with tence probability of the author with startPos 52 is divided by the product of the existence probability of the title with startPos 49 as the exp  X  X  child including the title and the existence probability of the author with child including the author, and then multiplied by the existence probability 0.28(0.7 0.4) of the subset that includes the title and the author.
 Fig. 9 shows the procedure for probabilistic XML query processing. The QueryProcessing procedure calls the subQuery-
Processing procedure in line 2 which has two parameters, the list of data nodes X  labels for the root node of the query tree and the query tree itself. After calling the subQueryProcessing procedure, the QueryProcessing procedure evaluates the prob-time, the procedure finds possible answers among the list of data nodes X  labels combinations by calling the getPossibleAn-swer procedure in line 18 and appends them to the output. Then, in lines 22 X 26, the subQueryProcessing is recursively called output parameter.

Fig. 10 shows the procedure to get possible answers. This procedure is called by the subQueryProcessing procedure in order to get the set of combinations ( r , d 1 , ... , d n shows the case when both mux nodes and exp nodes exist. Also, lines 13 X 17 show the case when only mux nodes exist and lines 18 X 22 show the case when only exp nodes exist. The procedure calls the getDistList procedure in Fig. 10 and of the given node r, and the second is to check the distributional nodes to determine whether the given combination can be type of d is exp is in lines 14 X 28. The bprob for each d i
Our query processing procedure in Fig. 9 uses the algorithm Tree-Merge-Anc ( Srivastava et al., 2002 ) to find ancestor X  unit of query tree at a time, where a unit is composed of a node q which are the roots of units in the next level. Therefore, the time complexity of our query processing is O  X 
P that the time complexity depends on the size of all the intermediate results including the sum of all input lists X  sizes and 6 . For the space complexity, the space for the output list of each unit can be reused. Therefore, the space complexity is O  X 
P 5.2. With probability conditions in nodes Each node in a probabilistic XML query tree can have a condition on the value of its conditional or existence probability. by the B+-tree index.

Secondly, we consider a new lightweight index which partitions (0, 1] into several blocks and keeps the information of (0, 1] into several blocks and the method to access the proper data in the list.

In partitioning (0, 1], we could consider a method which uses the distribution of probabilities and queries. However, in tion of probabilities and queries are not given, and we take the method that partitions (0, 1] into blocks with the same interval.
 and the last one whose probabilities are included in the interval of the partition. In this case, when we consider the list.
 whose probabilities are included in the interval of the partition. Using this method, although we should manage the linked list for each partition, we can access only the proper data. In this paper, taking the second one, we propose a lightweight index for the probability and call it the p-index .

In the p-index, the values of the probability are partitioned into eleven blocks such as (0.0, 0.1), [0.1, 0.2), all data included in one block. The common feature of all data in one block is that the first number under the decimal point more data to represent the characteristics of the p-index sufficiently.
 is almost the same as the delete processing of the linked list.

When nodes in a query tree have probability conditions, we can reduce the time of data access by using the p-index. To probability condition. For example, for the data in Fig. 12 , when the probability condition of name is p only three data nodes (10, 23, 74) by using the p-index. Otherwise, we should access the whole eleven data nodes. If the probability condition is a range, several linked lists should be considered such that they are combined by a merge sort in dure to get the list of data nodes X  labels which satisfy the given probability condition.

When data updates occur, the efficient update of p-indexes should be considered because the re-computation of existence probabilities needs the update of the p-indexes which are the p-indexes for the existence probabilities. We consider it as another future work. 6. Experimental results
Our experiments were carried out on an Intel Pentium 1.7 GHz with 1 GB memory, running Windows XP. All experiments were repeated 10 times independently and the average processing time was calculated disregarding the maximum and min-imum values. We implemented all procedures in Java and used the file system to store the list of labels and p-index. The experiments described in this section use three sets of test data. They are XMark 50%, XMark 100% ( XMark, 2001 ) and
Mondial (1999) . The two XMark data sets contain information about auctions and they are synthetic benchmark data sets generated by the XML Generator from XMark (2001) . XMark 50% is generated with parameter 0.5 which means that 50%
XMark data is generated. And XMark 100% is the full XMark data generated with parameter 1. The Mondial data set repre-sents geographical web data in the XML format. Characteristics of these data sets are summarized in Table 1 . The size in
Table 1 is the disk space used to store the original XML file, the nodes is the number of nodes, and the depth is the length of the longest simple path.

In order to perform the probabilistic XML query processing, we need probabilistic XML documents. Therefore, we imple-mented a procedure that generates a probabilistic XML document from an ordinary one. The procedure traverses the original
XML document in the depth-first order. At each node v in the original XML document, it randomly chooses the number of distributional nodes which become children of v . Then it randomly chooses the new parent of each original children of which is chosen among v and the newly created distributional nodes. And it determines probability distributions of new created distributional nodes randomly such that the distributions satisfy the constraints of the distributional nodes.
After generating a probabilistic XML document, we apply the extended interval-based labeling scheme to the created probabilistic XML document along with evaluating the existence probability of each node. Also we construct the p-index for each list of labels that is given to each distinct node name. By one traversing of the probabilistic XML document, we can apply node labeling scheme, evaluate existence probabilities of each node, and construct the p-index simultaneously. probabilities. We construct B+-tree index for each list of labels.

The size of a p-index is about 140 bytes, and it is not changed by the size of the data set because the structure of the p-index is always the same. However, the total size of all p-indexes for one XML document can be changed by the number of for the Mondial data set with 1.4 MB in size and 44 distinct nodes is about 14 KB ( 140 44 2). It is about 24 KB ( 140 78 2) for the XMark 100% data set with 115.7 MB in size and 78 distinct nodes. 6.1. Query processing without the p-index
In order to analyze the efficiency of the proposed node labeling scheme and query processing, we compare ours, which is called Extended from now, with the query processing in Kimelfeld et al. (2008) , which is called EvalDP.
Since Kimelfeld et al. (2008) does not provide the query set, we create queries such that they cover different query types,
Mondial and XMark 50%, to analyze the query performance. Table 2 shows the information about experimental queries. For the Mondial data set, we use four queries from Q1 to Q4, and for the XMark 50% data set, we use four queries from Q5 to Q8.
In Table 2 , the Results shows the number of combinations in query results for 1.4 MB Mondial data and 57.6 MB XMark 50% data.

Figs. 14 and 15 show the results of query processing for Mondial data set and XMark 50% data set, respectively. The per-formance of Extended is far better than EvalDP. Especially, as the number of combinations in query results increases, the query processing time of EvalDP increases remarkably. In EvalDP, the query processing procedure is composed of two phases.
The first phase is to find data matches without considering distributional nodes. Accordingly the data matches contain not possible answers. In the second phase, EvalDP repeatedly accesses the probabilistic XML document to evaluate the probabil-ity of each data match. Therefore, as the number of combinations in query results increases, the performance of EvalDP is degraded.

While the experimental queries in Table 2 have only 4 nodes, we additionally use harder and more complex queries for experiments which have 6, 8, 10, ... , 16 nodes as in Kimelfeld et al. (2008) . For two data sets, Mondial and XMark 50%, we create 18 queries for each data set that are three queries for each query node size. In other words, there are three 6-nodes queries, three 8-nodes queries, three 10-nodes queries, etc. Tables 3 and 4 show the information about these experimental queries. For the Mondial data set, we use 18 queries from M6-1 to M16-3 as shown in Table 3 , and Mx-y means that the erty, shallow, medium and deep queries are spread over the whole queries. For the ratio of the descendant edges property, we choose parent X  X hild edges because the EvalDP is more efficient in the case of parent X  X hild edges and our approach shows similar performance for both parent X  X hild relationships and ancestor X  X escendant relationships. For the XMark 50% data set,
Figs. 16 and 17 show the results of query processing from M6-1 to M16-3 in Table 3 over the Mondial data set and from X6-1 to X16-3 in Table 4 over the XMark 50% data set, respectively. The performance of Extended is far better than EvalDP. It is similar to the case of Figs. 14 and 15 that the query processing time of EvalDP increases remarkably as the number of com-
EvalDP. 6.2. Query processing with the p-index
In the previous researches about probabilistic XML data and query, the condition for the probability value of each node has not been considered. In this paper, we propose the condition for the probability value and a lightweight index to deal with the probability conditions. In this subsection, we analyze the performance of queries with the condition for the prob-ability value and the efficiency of the p-index.

We use some simple path queries and query trees under the XMark 100% data set. Table 5 shows the information about experimental queries. Query P1 and P2 are simple path queries and Query P3 is a query tree. Queries from P11 to P13 derived from P1 have probability conditions for query nodes. For example, P12 is the ancestor X  X escendant relationship between the person and the phone in which the phone is restricted to the ones that have 0.3 or more and 0.6 or less conditional proba-bility. The Results shows the number of combinations in query results.

Figs. 18 and 19 show the results of query processing with the p-index against without the p-index for XMark 100% data set. The performance of the p-index is far better than no index. Especially, as the number of data nodes restricted by the probability conditions increases, the time for query processing decreases.
 ments are stored in N disk blocks, we firstly access the p-index for conditional probabilities of title elements and then we ber of disk blocks which should be accessed is dependent on the data. But in many cases, the p-index can decrease the num-ber of disk blocks which should be accessed, and also make the size of input list to be decreased in the time and space is not affected by using the p-index. 7. Conclusions
In this paper, we propose an extended interval-based labeling scheme to provide efficient probabilistic XML query pro-cessing. The extended interval-based labeling scheme not only takes the advantages of the previous interval-based labeling scheme but also solves weak points of previously proposed probabilistic XML query processing methods. It accesses only the to eliminate unnecessary data matches.

Also, we present an extended probabilistic XML query model with the predicates for the values of probabilities and a lightweight index for those probabilities. The index helps not to access the data which should be eliminated by the proba-bility condition. Therefore the index reduces the time of data access and improves the performance of probabilistic XML query processing.

Experimental results show that our approach is significantly better than EvalDP, which is the most recent approach for probabilistic XML query processing, and improves the performance of query processing when the predicates for the values of probabilities are given.
 Acknowledgements
We would like to thank the editor and anonymous reviewers. This work was supported in part by WCU (World Class Uni-versity) program under the National Research Foundation of Korea funded by the Ministry of Education, Science and Tech-nology of Korea (No. R31-30007), and in part by the National Research Foundation of Korea grant funded by the Korea government (MEST) (No. 2011-0000377).
 References
