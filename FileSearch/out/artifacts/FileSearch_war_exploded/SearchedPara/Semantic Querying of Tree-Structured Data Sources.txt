 Nowadays, huge volumes of data are organized or exported in a tree-structured form. Querying capabilities are pro-vided through queries that are based on branching path ex-pression. Even for a single knowledge domain structural differences raise difficulties for querying data sources in a uniform way. In this paper, we present a method for seman-tically querying tree-structured data sources using partially specified tree patterns. Based on dimensions which are sets of semantically related nodes in tree structures, we define dimension graphs. Dimension graphs can be automatically extracted from trees and abstract their structural informa-tion. They are semantically rich constructs that support the formulation of queries and their efficient evaluation. We design a tree-pattern query language to query multiple tree-structured data sources. A central feature of this language is that the structure can be specified fully, partially, or not at all in the queries. Therefore, it can be used to query multiple trees with structural differences. We study the derivation of structural expressions in queries by introducing a set of in-ference rules for structural expressions. We define two types of query unsatisfiability and we provide necessary and suffi-cient conditions for checking each of them. Our approach is validated through experimental evaluation.
 Categories and Subject Descriptors: H.2.3 Languages, H.2.4 Information Search and Retrieval, H.3.3 Systems General Terms: management, experimentation, languages. Keywords: tree-structured data, tree-pattern queries, XML, query evaluation, query satisfiability
Nowadays, huge volumes of data are posted and retrieved through the Web. Tree structures provide the most pop-ular means for organizing the information. Taxonomies of thematic categories, concept hierarchies, e-commerce prod-uct catalogs are examples of such structures. The Extensi-ble Markup Language (XML) [1] is by far the most promi-nent example. Even if XML data is stored in relational databases, export mechanisms make it publicly available in tree-structure format [7].

Queries on tree-structured data are mainly based on the usage of branching path expressions. XPath [2] is a lan-guage that uses path expressions to navigate through the tree structure of an XML document, binding nodes to vari-ables. It lies at the core of W3C language proposals for XML querying and transformation (e.g. XQuery [3]). The problem. The major challenge in this context is to provide the means for the effective and efficient querying of multiple tree-structured data sources. This goal is ham-pered by the semistructured nature of this data. When there is no schema or when the structure of the data is not fully available, it is very difficult or even impossible for the user to specify the right query on a single tree struc-ture. Querying multiple tree-structured data sources usu-ally requires resolving structural differences. This is due to the different possible ways of organizing the same data in trees. For instance, a structural difference exists when a category Painter appears in a museum catalog but does not appear in another. Another structural difference ap-pears when, for example, a museum exports an XML doc-ument that records Picasso  X  X  self-portrait exhibition along the element sequence Artist , Work of Art , Exposure but records other artist X  X  creations along the element se-quence Exposure , Artist , Work of Art . Such differences raise major difficulties for querying multiple tree-structured data sources.
 Relevant approaches. One can distinguish three app-roaches to the problem that are based on branching path expressions. A traditional information integration approach attempts to cope with this problem by providing a global structure. Mapping rules are defined between the global structure and the local structures used in the sources [10]. For example, given the rules (Exposure/Work of Art)  X  (Work of Art/Exposure) for one source, query Artist/Exp-osure/Work of Art will become Artist/Work of Art/ Expo-sure in order to match another tree structure. Such ap-proaches require extensive manual effort since the global schema is difficult to construct and the rules should be hard-coded in the integration application. Moreover, the user should have exact knowledge of the global structure.
A naive approach executes the queries that result from all possible orderings of query elements and combine the answers. Clearly such an approach is unfeasible even for medium size queries.
An approximate approach evokes tree pattern query relax-ation methods. For instance, in [5], when the user explic-itly specifies a sequence for elements Exposure , Work of Art and Artist to retrieve data, the system can relax the initial query, by removing the element Work of Art and by replac-ing it by a descendant relationship between Exposure and Artist . Nevertheless, the answer is not exact with respect to the query posed by the user.

Approaches that are not based on branching path expres-sions but on keyword search [13, 11, 16] avoid the problem of unknown structure or the problem of multiple differently structured data sources. In this case knowledge of the struc-ture is not required for the queries. However, the total ab-sence of structure has a number of important drawbacks, since the user can neither impose structural conditions to filter out answers nor specify structural constraints within the query to speed up the computation of the answer. Our approach. In this paper we present a different ap-proach by adopting a tree-structured data model that ex-ploits semantic information, and by introducing a tree-pat-tern query language that allows a partial specification of the tree-patterns. Tree-structured data are called here value trees. We introduce dimensions which are sets of semanti-cally related nodes in value trees. Based on dimensions, we define dimension graphs. Dimension graphs are not schemas but semantically rich constructs that abstract the structural information of the value trees. Dimension graphs can be automatically extracted from value trees and support the formulation of the queries and their evaluation. Queries are specified on dimensions and are not cast on the structure of a specific value tree. Therefore, the query language can be used to effectively query tree-structured data whose struc-ture is not fully known or to integrate tree-structured data that have structural differences. Our approach differs from traditional data integration techniques in that it does not require the manual definition of transformation rules be-tween a virtual global tree structure and the structures in the local data sources. It differs from query relaxation tech-niques, since it returns exact and not approximate answers. Finally, it differs from keyword search approaches since it allows partial or complete specification of the tree structure in the queries.
 Contribution. The main contributions of this paper are the following:  X 
We design a query language to query value trees. Queries in this language provide a partial specification of a tree of dimensions annotated with sets of values. The user has the option to specify structural constraints -fully, par-tially, or not at all -when issuing queries on dimensions.  X 
Besides declarative, we also provide procedural seman-tics to our query language. Query evaluation is based on branching path expressions to be evaluated on the value trees. These expressions are generated using a dimension graph by determining completely specified tree-pattern queries (called dimension trees) that can possibly generate non-empty answers.  X 
The partial specification of the structure of the queries allows structural expressions to be derived from those explicitly specified in a query. We study the inference of structural expressions in queries by providing infer-ence rules used for detecting unsatisfiable queries and ef-ficiently computing dimension trees.  X 
We define two types of query unsatisfiability to identify queries that always produce empty answers. Unsatis-fiable queries can be detected during the generation of dimension trees. This saves the bulk of the workload of query evaluation since dimension graphs are typically much smaller than their value trees.  X 
We have implemented a prototype system to evaluate our approach. Our system is built on top of an XQuery en-gine. We carried out several experiments to compare our approach to one that does not exploit dimension graphs in the evaluation of queries on value trees. Our results demonstrate the superiority of our approach.
Many systems support querying and integration of struc-tured data using a predefined global structure and defining mapping rules between this structure and the local struc-tures used in the sources [14]. In the area of tree-structured data, the Xyleme system [10] exploits XML views to cope with the problem of integrating XML data sources. The Agora system [17] translates XQuery expressions over a given global XML schema to SQL queries on local data sources. In [9], YAT queries are posed on a global schema, pro-cessed using mapping rules, and then evaluated in the data sources. Our approach can support querying of multiple tree-structured data sources through the formulation of que-ries on dimensions spanning all the local value trees. There-fore, it does not require the manual definition of mapping rules.

Schema-based descriptions have been suggested for semi-structured databases [4]. Dataguides [15] are structural sum-maries for semistructured data, storing statistics about paths and nodes, and enabling query optimization. Statistical syn-opses for graph-structured XML databases are suggested in [18]. In [6], graph schemas are introduced to formulate and optimize queries for semistructured data. These approaches are purely syntactic. In contrast to our approach, they do not exploit semantic information. Query formulation is strictly dependent on the knowledge of structural irregular-ities in tree-structured data. In our approach, queries are not restricted by the structure of data. A problem similar to the one addressed in this paper is studied in [16]. The suggested language does not directly allow the specification of several nodes on a tree pattern path without specifying an order for these nodes. In [19, 12], a query language to query value trees without fully specifying the pattern is defined. However, the adopted data model is more appropriate for classification hierarchies while the query language supports only path patterns and not tree patterns.
We present below our data model for tree-structured data.
We assume an infinite set of values V that includes a special value r . For instance,  X  X . Picasso X ,  X  X oMA X , and  X  X elf-portrait X  are values of an application involving artists, museums, and works of art. A dimension set over V is a partition D of V that includes a set whose single element is value r . Each element of D is called dimension of D .The dimensions in D are assigned distinct names. In particular, the dimension { r } is named R . Intuitively, a dimension is a set of semantically related values. For instance, Artist can be a dimension that includes values  X  X . Picasso X ,  X  X . Miro X , and  X  X . Beckmann X . For the needs of this paper, we assume a single fixed dimension set D .

Definition 3.1. A value tree over D is a rooted node-labeled tree T , such that: (a) Each node label in T belongs to
V ,(b)Value r labels onl ythe root of T ,and(c)There are no two nodes on a path in T labeled b yvalues that belong to the same dimension in D .  X 
Example 3.1. Figure 1(a) shows a value tree T 1 that con-veys information about museums, artists, and works of art. Closed dotted lines labeled b ydimensions are used to show the partitioning of values in T 1 into dimensions. The same dimension might label multiple closed dotted lines in T 1 From a structural point of view, the information in T 1 is organized differentl yunder nodes collection and exhibition with respect to the dimensions.  X 
The semantic interpretation of the values of a value tree into dimensions can be provided by a user, or by an ontol-ogy. Different applications may require and apply different partitions of the values of the same value tree.
The values of some dimension may not be children or de-scendants of any value of some other dimension in a value tree. For instance, no value of dimension Exposure in the value tree T 1 of Figure 1 is a child or descendant of a value of any of the other dimensions in T 1 except R .Weusethecon-cept of dimension graph to capture this type of relationship between dimensions in a value tree.

Definition 3.2. Let T be a value tree over D .A dimen-sion graph of T is a graph ( N,E ) ,where N is a set of nodes and E is a set of edges defined as follows: (a) There is a node D in N if and onl yif there is a value in T that belongs to dimension D , and (b) There is a directed edge in E from node D i to node D j if and onl yif there are nodes n i and n j in T labeled b yvalues v i  X  D i and v j  X  D j , respectively, such that n j is a child node of n i in T .If G is a dimension graph of a value tree T , we sa ythat T underlies G .  X 
Figure 1(b) shows the dimension graph of the value tree T of Figure 1(a). Dimension names are abbreviated as shown in the same figure. The dimension graph of a value tree may have cycles. A double headed edge between two dimensions (e.g. the edge between W and A in Figure 1(b)) denotes a trivial cycle.

The following proposition provides properties that fully characterize dimension graphs on value trees.

Proposition 3.1. Let D be a dimension set. A directed graph G whose nodes are dimensions is a dimension graph of a value tree over D if and onl yif the following proper-ties hold: (a) Graph G does not have disconnected compo-nents. (b) There is exactl yone node in G having onl yout-going edges. We call this node root of G . (c) For every directed edge in G there is a simple path from the root of that comprises this edge.  X 
Queries are issued on dimension sets and are evaluated on values trees. We require that the evaluation of a query on a value tree yields a value tree. One reason for this closed-form requirement on queries is that it allows query composition.
A query on a dimension set provides a (possibly partial) specification of a tree of dimensions annotated with sets of values. The tree is rooted at dimension R .Aqueryspeci-fies such a tree through a set of (possibly partially specified) paths from the root of the tree. For brievity X  X  sake, in the following, PSP stands for partiall yspecified path .EachPSP is defined in a query by a set of annotated dimensions, and a set of precedence relationships (child and descendant rela-tionships) among these annotated dimensions. A query fur-ther indicates nodes (annotated dimensions) that are shared among different PSPs in the query tree. It also identifies a distinguished PSP called output path. The formal definition follows.

Definition 4.1. A query on a dimension set D is a triple (
P , S ,o ) ,where: (a) P is a nonempt yset of triples ( p, A , R ) ,where A and (a1) A is a set of expressions of the from D [ p ]= V ,where (a2) R is a set of expressions of the form D i [ p ]  X  D j (b) S is a set of expressions of the form D [ p i ]= D [ p (c) o is the name of one of the PSPs in P .ThisPSPis
Example 4.1. Let the dimension set D comprise the di-mensions shown in Figure 1. Let Q 1 =( P , S ,p 2 ) be a quer yon D ,where P = { ( p 1 , A 1 , R 1 ) , ( p 2 , A 2 { W [ p 1 ]=? ,Y [ p 1 ]= { 1937 , 1884 }} , R 1 = { W [ p A 2 = { W [ p 2 ]= { self-portrait } ,E [ p 2 ]=? ,A =? } , and S = { W [ p 1 ]= W [ p 2 ] } .  X  Query Q 1 of Example 4.1 is graphically represented in Figure 2(a).

In a graphical representation of a query Q , each PSP of Q is represented as a (not necessarily connected) graph. The name of each PSP is shown below the corresponding PSP graph. In particular, the name of the output PSP of Q is preceded by a . Each annotated dimension in a PSP is represented by a node labeled by the corresponding annotat-ing expression. PSP names are omitted in the annotating expressions for succinctness. Child and descendant prece-dence relationships in a PSP are depicted using single (  X  and double (  X  ) arrows between the respective nodes in the PSP graph. Two nodes (annotated dimensions) in different PSP graphs that participate in a node sharing expression of Q are linked in its graphical representation with a straight line labeled by the symbol  X   X   X .

Figures 2(b) and (c) show two other queries, query Q 2 and query Q 3 , both of them similar to query Q 1 .
The answer of a query Q on a value tree T is a value tree, subtree of T . Every path from the root to a leaf of T is the image of the output path of Q under an embedding of Q into T that preserves the precedence relationships and nodes sharing expressions of Q . More formally:
Definition 4.2. Let T be a value tree over a dimension set D ,and Q be a quer yon D .An embedding of Q into T is a mapping M of the annotated dimensions of the PSPs of Q to nodes in T such that: (a) The annotated dimensions of a PSP in Q are mapped to nodes in T that are on the same path from the root of T . (b) For ever yannotating expression D [ p i ]= V in Q ,thelabel of M ( D [ p i ]) is a value in V ,if V is a set, and it is a value of D ,if V is a  X ? X . (c) For ever ypr ecedence relationship D j [ p i ]  X  D k [ scendant) of M ( D j [ p i ]) in T . (d) For ever ynode sharing expression D [ p i ]  X  D [ p j M ( D [ p i ]) and M ( D [ p j ]) coincide.  X  Given an embedding M of a query Q into a value tree T , and a PSP p in Q , the path from the root of T that comprises all the images of the annotated dimensions of p under M and ends in one of them is called image of p under M and is denoted M ( p ). Notice that more than one PSP of Q may have their image in the same root-to-leaf path of T .
Definition 4.3. Let T be a value tree over a dimension set D ,and Q =( P , S ,o ) be a quer yon D .The answer of on T is a subtree T of T such that: (a) For ever yembedding of Q into T , the image of the output
PSP of Q is in T . (b) Ever yroot-to-leaf path of T is the image of the output PSP of Q under an embedding of Q into T .
 If there is no such a subtree T , we sa ythat the answer of Q on T is empty.  X 
Note that annotating a dimension with a  X ? X  in a PSP of a query is different than not annotating this node at all. Example 4.2. Consider the queries Q 1 , Q 2 and Q 3 of Figures 2(a), (b), and (c) respectively, and the value tree of Figure 1(a). The answer of Q 1 on T 1 isshowninFigure 3(a). There are two embeddings of Q 1 into T 1 which result in two distinct root-to-leaf paths in the answer of Q 1 on Notice that one of these embeddings maps the dimensions of both PSPs of Q 1 to nodes on the same path from the root of T 1 (r/exhibition/MoMa/M. Beckmann/self-portrait/1937) .
Figure 3(b) shows the answer of Q 2 on T 1 .Query Q 2 is more restricted than Q 1 . Onl yone of the embeddings of Q into T 1 is also an embedding of Q 2 into T 1 . The answer of Q 2 on T 1 has a single root-to-leaf path.

Query Q 3 is also more restricted than Q 1 .Itdoesnot have an yembedding into T 1 . Its answer on T 1 is empty.
The goal of this section is twofold: first to provide proce-dural semantics to the query language and second to show that query evaluation can be easily implemented on top of an XQuery [3] engine by generating branching path expressions. Such an implementation can benefit from the optimization techniques developed so far for XQuery. The evaluation of queries is based on the concept of dimension tree of a query on a dimension graph.
Given a query Q and a dimension graph G , a dimension tree of Q on G is a tree U whose nodes are labeled by an-notated dimensions and its root is labeled by the annotated dimension R . It also has a distinguished node called output node that defines a path from its root called output path .A dimension tree U of Q on G satisfies two properties. First, there is a mapping m from the nodes of U to the nodes of G that is root-preserving, and respects labeling dimensions and child relationships. Second, there is a mapping m from the annotated nodes of Q to the nodes of U that respects labeling dimensions, annotations (existentially), precedence relationships, and node sharing expressions. Intuitively, a dimension tree for Q on G represents an embedding of Q into G that respects labeling dimensions, precedence rela-tionships, node sharing expressions and annotations (exis-tentially). This embedding is the composition of m and m . The dimensions trees of Q on G represent all such possi-ble embeddings of Q into G . We skip the formal definition because of lack of space.
Q
Example 5.1. Consider query Q 1 of Figure 2(a) and the dimension graph G 1 of Figure 1(b). Figure 4 shows the di-mension trees of Q 1 on G 1 . The output nodes of the dimen-sion trees are shown filled with gra ycolor. All the nodes of a dimension tree are annotated. Annotations that are  X ? X  are not shown in the figure. Notice that mapping m maps the nodes of the two roof-to-leaf paths in U 7 to the nodes of the image in G , of the longest of these two paths. Of the seven dimension trees of Figure 4, the first three ( U 1 , U 2 ,and are the dimension trees of query Q 2 of Figure 2(b), while the first six ( U 1 to U 6 ) would be the dimension trees of query of Figure 2(c) if their output node labeled b ydimension A were annotated with the set { P . Picasso } .  X 
A dimension tree U of a query Q on a dimension graph G can also be viewed as a (structurally) completely specified query. Complete specification means that the query forms a tree pattern (without missing edges) involving only parent-child (and not ancestor-descendant) relationships. Thus, given dimension graph G ,query Q represents a set of com-pletely specified queries. We show in this subsection that the answer of Q on a value tree T underlying G can be constructed using the answers on T of all these completely specified queries.

Given a dimension tree U , the corresponding (completely specified) query Q U canbeformedinastraightforwardway by letting the root-to-leaf paths of U define the PSPs of query Q U . If the output node of U is a leaf node, the out-put PSP of Q U is the PSP in Q U that corresponds to the output root-to-leaf path of U . Otherwise, the output PSP of Q U is an additional PSP defined by the output path of U . The labeling dimensions and annotations of the nodes in the root-to-leaf paths of U define dimensions and their annotations in Q U . The edges in the root-to-leaf paths of induce the child precedence relationships of Q U . Finally, the common nodes of distinct root-to-leaf paths in U induce the node sharing expressions of Q U . In the following, we might identify a dimension tree with its corresponding query.
We assume that nodes in a value tree have a unique node identifier and these node identifiers are preserved in the an-swers of a query on this value tree. Let T 1 and T 2 be two value trees, subtrees of the same value tree. The merge of and T 2 , denoted T 1  X  T 2 , is the value tree obtained by merg-ing the nodes of T 1 and T 2 that have the same node identi-fiers (and the edges between merged nodes). Clearly, this op-eration is associative and commutative. If T 1 ,...T k ,k&gt; are value trees, subtrees of the same value tree,  X  i  X  [1 ,k ] denotes the merge of T 1 ,...T k .
 Proposition 5.1. Let Q be a quer yon a dimension set D , T be a value tree on D and G be the dimension graph of T Let U 1 ,...,U n ,n  X  1 , be the dimension trees of Q on G T ,...,T n are the answers of U 1 ,...,U n on T , respectively, then the answer of Q on T is  X  i  X  [1 ,n ] T i .  X 
Example 5.2. Consider the dimension trees U 1 ,...,U 7 of Figure 4. These are the dimension trees of query Q 1 of Figure 2(a) on the dimension graph G 1 of Figure 1(b). The answer of U 1 on the value tree T 1 of Figure 1(a) is the left root-to-leaf path, while that of of U 7 is the right root-to-leaf path in the value tree of Figure 3(a). Dimension trees U ,...,U 6 on T 1 return empt yanswers. Therefore, the an-swer of Q 2 on T 1 is the merge of the answers of U 1 and on T 1 . This merge is shown in Figure 3(a).  X 
Since dimension trees are completely specified queries, their answers can be computed by branching path expres-sions. We assume that the results of these branching path expressions are not nodes but paths from the root of the value tree.

The fragment of branching path expressions that we con-sider here involves node tests, the child axis (/), branch-ing path predicates (specified between square brackets  X  X  X  and  X  X  X ), and the union (i.e. logical or) symbol ( | ). The expression ( v 1 | ... | v k ) specifies any node label in the set { v 1 | ... | v k } . Our fragment involves also a restricted type of wildcard ( ): D denotes the expression ( v 1 | ... | v n ), where { v 1 ,...,v n } = D . The predicates may also involve the Boolean connective and .

We assume that membership of values to dimensions is implemented by maintaining a mapping from dimensions to sets of values. This implementation supports the efficient evaluation of expressions of the form D at a node n of a value tree. Clearly, D is satisfied at n when n is labeled by any value of dimension D . Thus, we assume that the dimension of the label of a node of a value tree is stored with the label or is directly available at the node.
Let U be a dimension tree U . Every node n of U is mapped toaconstruct t ( n ) (simple node test or union of node tests or restricted wildcard) using a function t on the nodes of t defined below: t ( n )=
A branching path expression that computes the answer of
U can now be easily constructed through a depth first traversal of U that uses function t defined above.
Example 5.3. The following branching path expressions correspond to the dimension trees U 3 and U 7 respectively: e : r / E / self-portrait [ M / A / ( 1937 | 1884 )] / A e : r / E / M / A / self-portrait [( 1937 | 1884 )] .  X 
Detecting unsatisfiable queries stops their evaluation at an early stage or even before it starts, thus saving valu-able query computation time. When a dimension graph is given, an otherwise satisfiable query may be unsatisfiable with respect to all the value trees that underlie the dimen-sion graph. This type of query unsatisfiability is expected to occur frequently in the environment of our approach be-cause: (a) the user might be unaware of the structure of a data source, and (b) different data sources may have sub-stantial structural differences and irregularities and a query which is issued against all of them may very well be un-satisfiable with respect to the dimension graphs of some of them. Detecting this type of query unsatisfiability using a dimension graph saves again valuable query computation time since it prevents accessing the value trees which are, in general, much larger than their dimension graphs.
In the context of our approach, checking query unsatisfia-bility becomes more complex. The reason is that the partial specification of the structure in the queries allows non-trivial structural expressions to be inferred from those explicitly specified in the queries. These inferred structural expres-sions need to be taken into account in determining query unsatisfiability. In this section, we first discuss structural expression inference before focusing on query unsatisfiabil-ity.
Given a query, new precedence relationships and/or node sharing expressions (collectively referred to as structural ex-pressions ) may be derived.

Definition 6.1. Let E be a set of structural expressions of a query Q on a dimension set D ,and e be a structural expression that involves PSP names and dimensions in E . We sa ythat e is implied from E if and onl yif for ever y value tree T over D and ever yembedding M of Q into T , M preserves e .If e can be implied from E we write E| = e
We provide now a set of inference rules for expressions and we show that it is sound and complete. Let A , B , and C be distinct dimensions of D and p , p 1 ,and p 2 be distinct PSP names. We use the symbol to denote that the expression(s) on its left hand side produce the expression on its right hand side. The absence of expressions in the left hand side of denotes trivially an inference rule (an axiom). Figure 5 shows a set of 12 inference rules. (IR 1) a structural expression that involves (IR 2) A [ p ]  X  B [ p ] A [ p ]  X  B [ p ] (IR 3) A [ p ]  X  B [ p ] ,B [ p ]  X  C [ p ] A [ p ]  X  C [ (IR 4) A [ p ]  X  B [ p ] ,A [ p ]  X  C [ p ] B [ p ]  X  C [ (IR 5) A [ p ]  X  B [ p ] ,C [ p ]  X  B [ p ] C [ p ]  X  A [ (IR 6) A [ p ]  X  B [ p ] ,  X  X  X  X  X  X  A,B } (IR 7) R [ p 1 ]  X  R [ p 2 ] (IR 8) A [ p 1 ]  X  A [ p 2 ] ,A [ p 2 ]  X  A [ p 3 ] (IR 9) A [ p 1 ]  X  B [ p 1 ] ,B [ p 1 ]  X  B [ p 2 ] (IR 10) A [ p 1 ]  X  B [ p 1 ] ,B [ p 1 ]  X  B [ p 2 ] (IR 11) A [ p 1 ]  X  B [ p 1 ] ,A [ p 1 ]  X  A [ p 2 ] ,R [ (IR 12) A [ p 1 ]  X  B [ p 1 ] ,B [ p 1 ]  X  B [ p 2 ] A [ p
If a structural expression e belongs to a set of structural expressions E or can be produced from E using the inference rules I.R. 1 -I.R. 12 above we say that e can be inferred from E and we write E e .
 Example 6.1. Consider query Q 4 shown in Figure 6(a). Let E be its set of structural expressions. Clearly, E C [ p 2 ]  X  A [ p 2 ] ,and E A [ p 2 ]  X  C [ p 2 ] . Consider also query Q 5 shown in Figure 6(b) with E being its set of structural expressions. It is eas yto see that E A [ p 1 ]  X  A [ p 2
The proposition below shows that the inference rules above can fully characterize the implication of precedence relation-ships and node sharing expressions.

Proposition 6.1. Let E be a set of structural expressions of a query Q ,and e be a structural expression that involves PSP names and dimensions in E .If E e then E| = e (the inference rules are sound ). If E| = e then E e (the inference rules are complete ).  X 
A sound set of inference rules is called redundant if there is a proper subset of it which is complete. Otherwise, it is called non-redundant . We can show that the set of inference rules I.R. 1 to I.R. 12 is non-redundant.

We call closure of a set of structural expressions E the set of structural expressions that can be implied from E . Because of Proposition 6.1 the closure of E can be computed by first initializing it to E and then repeatedly adding to it structural expressions produced by the inference rules I.R. 1 -I.R. 12 until no more new structural expressions can be added.
We can identify two notions of query unsatisfiability: a strong one which is independent of the value trees on which the query is evaluated, and a weak one which depends on the dimension graph of the trees on which the query is eval-uated. We present each of them in turn and we provide necessary and sufficient conditions for both types of query unsatisfiability.

Definition 6.2. A quer yon a dimension set D is called unsatisfiable if its answer is empt yon ever yvalue tree over D .Otherwise,itiscalled satisfiable .  X 
We qualify this type of unsatisfiability as strong , while unsatisfiable queries of this type are called strongl yunsatis-fiable .

Example 6.2. Consider query Q 4 of Figure 6(a). As we saw in example 6.1 the arrows of inferred precedence re-lationships of Q 4 form a cycle ( A [ p 2 ]  X  C [ p 2 ]  X  A Clearly, this condition implies the unsatisfiability of Q example 6.1 we showed that the node sharing expression A [ p 1 ]  X  A [ p 2 ] can be inferred from the structural expressions of
Q 5 . Clearly, this condition along with the annotating ex-pressions A [ p 1 ]= { 0 } and A [ p 2 ]= { 1 } implies that unsatisfiable.  X  More generally, we can show the following proposition. Proposition 6.2. Consider a query Q .Let N = { R [ p ]  X  D [ p ] | D is an annotated dimension in the PSP p of Q ,and D = R } .Let E be the set of structural expressions of Q and E = E X  X  . That is, E is the set of structural expressions of Q that includes also ancestor precedence relationships from dimension R to ever yannotated dimension in ever yPSP of Q .Letalso closure ( E ) denote the closure of E .Query Q is unsatisfiable if and onl yif one of the following conditions holds: (a) The double arrows (ancestor precedence relationships) form acyclein closure ( E ) . (b) There are two annotating expressions D [ p 1 ]= V 1 and
D [ p 2 ]= V 2 in Q such that V 1 =? , V 2 =? , V 1  X  V 2 and D [ p 1 ]  X  D [ p 2 ] belongs to closure ( E ) .  X 
A query is defined on a dimension set but it is to be eval-uated on a value tree which has a dimension graph. There can be multiple value trees that underlie the same dimension graph. The weak notion of unsatisfiability is defined with respect to a dimension graph.

Definition 6.3. Let G be a dimension graph on a dimen-sion set D . A quer yon D is unsatisfiable with respect to if its answer is empt yon ever yvalue tree underl ying G .
Given a dimension graph, we qualify this type of unsatis-fiability as weak , while unsatisfiable queries of this type are called weakl yunsatisfiable . A weakly unsatisfiable query is also strongly unsatisfiable. The opposite is not necessarily true.
 Proposition 6.3. Let Q beaqueryonadimensionset D ,and G be a dimension graph on D .Query Q is satisfiable with respect to G if and onl yif there is a dimension tree of Q on G .  X 
We experimentally evaluated our approach on a proto-type system. We used a set of ten synthetic value trees (with three random partitions each), and we measured the execution time for evaluating random queries. We imple-mented and compared the following two query evaluation approaches: A 1 : Queries are formed on dimension graphs. Every query is checked for satisfiability (strong and weak). If it is satisfiable, it is evaluated on the corresponding value tree.
Otherwise, its evaluation stops and an empty answer is returned. This is the approach suggested in this paper. A 2 : Queries are formed directly using sets of branching path expressions that involve values from value trees. Given these sets, the system generates all the possible order-ings of the values that respect the parent/child and an-cestor/descendant relationships specified in the branching path expressions. Each one of these orderings corresponds to a single branching path expression to be evaluated on a value tree. Note that the approach A 2 does not exploit dimension graphs for the evaluation of queries.
 We carried out three different types of experiments to study the differences in the execution time of random queries for the two query evaluation approaches. For every measure point, 10 queries per partition were generated. The recorded execution time per point is the average execution time for the involved queries.
 Varying the size of a query. We measured the execution time varying the percentage of arrows for different numbers of annotated dimensions in queries. The percentage of ar-rows is the ratio of the number of arrows to the total number of possible arrows in the queries. In Figure 7, we present the results obtained for queries with 2 and 3 PSPs, having 2 and 4 annotated dimensions, varying the percentage of arrows. The number of dimensions is fixed to 30. In each query, 50% of the arrows were single (child relationships) and 50% were double (descendant relationships).

For both approaches, as the percentage of arrows increases, the execution time drops. This is explained by the fact that, Figure 7: Exec. time vs. % arrows for different numbers of annotated dimensions in queries as the number of arrows increases, fewer branching path ex-pressions are generated by both approaches to be matched on the value tree.

For queries with 2 PSPs and 4 annotated dimensions, the approach A 1outperforms A 2 by more than 2 orders of mag-nitude.
 Varying the type of arrows in the query. We measured the execution time varying the percentage of single arrows in the total number of arrows in queries for different pairs of numbers of annotated dimensions and arrows.
 Figure 8 presents the results obtained for queries with 2 PSPs having (a) 3 annotated dimensions and 2 arrows, and (b) 3 annotated dimensions and 3 arrows. In any case, the approach A 1outperforms A 2 since it is able to exploit the dimension graph to detect unsatisfiable PSPs, and to reduce the number of branching path expressions generated.
We have addressed the problem of efficiently querying tree-structured data when their structure is not fully avail-able and the problem of querying in an integrated way dif-ferent tree-structured data sources with structural differ-ences. We have introduced a query language that allows full, partial, or no specification of structural constraints. By exploiting semantic information and summarized structural information of the data sources we have suggested efficient solutions to the aforementioned problems. Our approach bridges the gap between keyword search based approaches on the one side and fully specified tree pattern approaches on the other side.

Our future work includes extending our query language and studying ad-hoc optimization techniques for it.
