 Automated discovery of web services with desired functionality is an active research area because it is crucial for realising the envisioned advantages of the semantic web, such as functional reuse and automated co mposition. This scenario is expected to be frequently encountered in E-Commerce and application integration scenarios, but also in e-Science with Semantic Grid technology, with enterprises or end user applica-tions attempting to compose complex interactions from offered services in a variety of application contexts: brokering, purchasing, supply chain integration, or experiment assembly.

A web service discovery request typically consists of a functional requirement such as book a hotel room , a set of additional requirements such as price &lt; 100 , input and output (IO) requirements such as one of the service inputs should be of type CreditCard , Quality of Service (QoS) and o ther non-functional require ments. For a given web ser-vice discovery request, matchmaking is the process of discovering a set of web services from one or more repositories such that all the matched services provide the required functionality and satisfy the constraints imposed by the request. Earlier approaches to address the matchmaking problem adopted a keyword-based search mechanism [1]. In the web services context, keyword search schemes are ineffective in practice because of either the absence of sufficient textual descriptions or the ambiguity in the semantics of the textual descriptions [2], and formalisms to precisely represent service functionality are desired. OWL-S [3] attempts to address this problem with an approach based on the OWL family of Description Logics.

Several OWL-S based matchmaking approaches have been proposed for service dis-covery [4,5,6,7,8,9,10]. The approaches fall under two major categories: Input-Output (IO)-based and description-based. IO-based approaches [4,5,6] select matches by de-termining the relationship between the IO profile of a request and the IO profile of a service. While IO-based matching allows to eliminate some services from consider-ation, in general, a large number of inappr opriate services may remain because ser-vices with identical IO signatures yet diff erent functionality cannot be differentiated. Description-based approaches [7,8,10,9] adopt a more rigorous logical inference pro-cess to eliminate false positives by inferring subsumption relationships between a re-quest and a service specification. However, services with functionality contradicting the request may be returned, and a matching service may be ranked poorly if its description does not completely satisfy a request [9,11,12,13].

In this paper, we present a consistency-based matchmaking scheme to address these issues. Our matchmaking scheme is a two-stage process, where in the first stage, a set of conceptual service profiles that seem to match the request are shortlisted, and subsequently, in the second stage, the concrete information about these services is ob-tained by querying the services directly to determine whether the services do meet the requirements or not.

Our matchmaking process (shown in Figure 1) utilises both the general service de-scriptions and detailed information obtained from services. The conceptual descrip-tion of a service holds information that rep resents terminological or general knowledge about it. For example, an airline service might be described as  X  X ells airline tickets be-tween Australian cities for less than $ 100 X  . The concrete description of a service holds instance-level information. For example, the same airline service might provide infor-mation such as  X  X ells tickets between Adelaide and Melbourne for $ 69 X  . The concrete information of a service are specialisations of its conceptual description.

Given a set of service descriptions and a discovery request, our matchmaking ap-proach identifies the set of matching servi ces profiles in two stages: first, we deter-mine the set of conceptual descriptions that are consistent with the request ( potential matches ), and second, we restrict the selected candidates to those that indeed offer con-crete descriptions that are consistent with the request ( concrete matches ). Unlike ex-isting proposals, where only the conceptual knowledge is used to determine matching services, both conceptual and instance-level information are utilised in matchmaking. As a result, only the services that indeed satisfy the request are returned.
We evaluate our consistency-based matchmaking scheme in the context of the Dis-covery II and Simple Composition scenario proposed by the SWS Challenge group. We show that our matchmaking scheme (1) is ro bust with respect to overspecified service profiles, (2) always returns functional semantic matches (no false positives), and (3) is able to handle unspecified values in the service specifications.
The rest of the paper is organised as follows. The sales portal scenario used for evaluation is presented in Section 2. Related description-based matchmaking proposals and their shortcomings are discussed in Section 3. Our consistency-based matchmaking scheme is detailed in Section 4. In Section 5 we evaluate our approach in the context of the sales portal scenario. In Section 6, an overview of other related work is pre-sented, followed by a summary of our contributions and an outline of future directions in Section 7. We adopt the Discovery II and Simple Composition 1 scenario proposed by the SWS Challenge group as a platform to evaluate our consistency-based matchmaking scheme. The sales portal proposed in the scenario has two vendors ( Rummage and Hawker )who sell computers and accessories. The sales processes of these vendors are exposed as web services, where sales services offer a co mprehensive description of the available products. In the adopted scenario, Rummage offers 3 services and Hawker offers 1 service. The services, 4 representative reque sts, and expected matches for the requests in the sales portal scenario are presented in Table 1. Description-based semantic matchmaking is the process of identifying a set of services whose descriptions satisfy the requirements in a discovery request. A semantic ser-vice description (also referred to as a service profile ) is a representation of a service X  X  properties such as functionality, attributes, restrictions on attribute values etc., usually authored in a declarative formalism such as OWL DL and SHOIQ ( D ) . In general, a service description contains conceptual and instance-level information. The concep-tual layer holds information that represe nts terminological or general knowledge about a service, while the concrete layer holds instance-level or specific information about the service offerings. Both conceptual knowledge and concrete knowledge are essential to model service descriptions. Matchmaking processes in description-based schemes depend heavily on the completeness and quality of the service description. Descrip-tion logics provide the two abstractions in the form of TBox (terminological box) and ABox (assertive box). Since most DL based approaches operate only on the concep-tual level, instance information must be lifted to concepts and predicates. However, this approach does not scale well to large, detailed profiles [9,12]. 3.1 Formal Matchmaking Subsumption is the predominant inference mechanism for semantic matchmaking in most of the description-based approaches [7,5,8]. In general multiple degrees of match for a given request Q and service S are considered (in order of preference): exact ( S  X  Q ), plug-in ( Q S ), subsumed ( S Q ), intersection (  X  ( S Q  X  ) )and mis-match ( S Q  X  ). Even though the approach improves upon pure IO matchmaking, additional information in service profiles and the Open World Assumption (OWA) can lead to counter-intuitive results. Hence, false positives may be returned and profiles that provide the required functionality may be rated poorly. Table 2 shows the results of DL matchmaking applied to the scenario in Section 2. We use (+) to indicate that the ob-servations are consistent with the expectations listed in Table 1. For instance, the query Q01 is rightly matched with S01, S02, and S04. The inconsistent results are denoted as (  X  ) . Instances where the matches are poorly rated are denoted with (  X  ) . The results support the following observations: Intersection Matches. Subsumed matches are too strong in situations where a service description contains more information than what is requested 2 . Hence, the intersection match (  X  ( S Q  X  ) ) is required to select profiles that are similar to the request, but do not satisfy the requirements precisely. The intuition behind this type of match is that if a profile and request overlap, the service may be similar to the one requested. How-ever, undesirable service profiles may be returned: Consider the combination Q02 and S04. Even though S04 offers only Web cams it is matched with the request Q02 from a Notebook sales service because the dis jointness between Web cams and Notebooks cannot be derived under OWA. Such false positives also arise with the following pairs (Q03,S01), (Q03,S02), (Q03,S04), (Q04,S01), (Q04,S03), and (Q04,S04). Conversely, intersection matches cannot be ignored, since it is unlikely that a single profile will suit all requests (such as (Q01,S03) where S03 provides a modem that is not requested in Q01). Rather, intersection matches must be considered selectively to avoid false positives.
 Overspecified Profiles. The existence of additional information in a service profile that is not in a request will result in poor ranking [7]. We refer to such profiles as being overspecified profiles for the given request. For example, S01 is preferred over S03 for Q01 in Table 2. While both S01 and S03 match the query Q01, S03 matches only by intersection because S03 offers more information about its product than requested. This limitation is counter-intuitive since vendors prefer to furnish more information about their services to match a wide variety of requests.
 Unspecified Values. The OWA in DL matchmaking approaches implies that properties that are not constrained in a profile can take on any value and is therefore a potential intersection match to a query that requires that property. As a result, queries such as Q04 are not handled properly and result in false positives such as (Q04,S01), and (Q04,S03). The limitation of this approach is that there is no difference between a situation where an attribute has no value to that where an attribute does not exist at all. Our consistency-based matchmaking is a two staged approach where in the first stage a set of conceptual profiles that could match the request are identified based on conceptual information, and subsequently in the second stage the concrete services are queried to determine whether a service indeed meets the requirements.
Formally, every web service is augmented with two profiles: a conceptual profile and an instance profile. The conceptual profile represents the terminological knowl-edge about a service which is used to determine potential matches. The instance profile represents knowledge about the concrete cap abilities of a service. We assume that the instance profile can be obtained by querying the service directly. The purpose of divid-ing a service X  X  profile into two distinct parts is partly to ease the effort to describe a service and partly to support efficient discovery while avoiding undesired matches.
Our matchmaking process (shown in Figure 1) begins with a user formulating a service request for desired functionality and other requirements, such as QoS attributes. The consistency-based matchmaking scheme consists of two stages: Step 1. Identify potential matches Step 2. Filter those services that do not satisfy the request We refer to the instance profile build ing process described above as the on-line ap-proach. Alternatively, we are also able to operate with a database of instance profiles in an off-line setting. Due to amount and vol atility of information, most often it is not practical to map all the instance-level deta ils onto the conceptual domain. Conversely, it is not possible to completely ignore the conceptual knowledge in favour of instance-level knowledge because the conceptual knowl edge captures inherent relationships that may go unnoticed if only the instances are considered. Since all the concrete informa-tion available about a service can be queried, it can be assumed that the instance profile is complete.This allows us to apply the Closed World Assumption (CWA) where a par-ticular service that cannot be shown to definitely match a request is assumed to be a mismatch.

The consistency-based approach offers the following benefits.  X  Only the services that match both the con ceptual and the instance profile are re- X  The clear distinction of the conceptual an d instance profiles potentially reduces the  X  The approach is potentially more efficient than a pure instance level checking  X  The distinction between conceptual and instance profiles also provides the oppor-4.1 Matchmaking as a Constraint System Our consistency-based matchmaking scheme is modelled as a constraint system in which request and service profiles are repres ented as constraints. Note that the match-making scheme as such is generic and could be implemented using other methods that support logical entailment. We define a common template called service constraint to model both requests and service profiles.
 Definition 1 (Service Constraint). A service constraint p is defined as a triple p =
A, D, C where A = { a 1 ,...,a n } is a set of service attributes, D = { D a 1 ,...,D a n } is the set of domains such that D a is the set of allowed values of a , and C is a set of constraints specifying the conceptual properties of a service. A service constraint p = A ,D ,C specialises p iff A  X  A and C  X  C and  X  d  X  D, d  X  D : d  X  d .
 Let  X  denote the infeasible constraint representing either an empty profile that does not offer any service or a request that cannot be fulfilled.
 Example 1 (BudgetNotebooks). A conceptual profile for a service that sells notebook computers for at-most $1500 could be Example 2 (Q02). A service request for services that sell notebooks for $1600.0 or less could be To access advertised services, we assume the e xistence of a registry (e.g., UDDI [1] or semantic registry [14]) that publicises service profiles. We define both conceptual and instance profiles in our abstract representation of a service registry called Environment . Definition 2 (Environment). An environment E is defined as a tuple S, E C ,E I where, S is a set of concrete services, E C is the set of conceptual service profiles for ser-vices in S , and E I denotes the set of instance level profiles over S .Let suppliers ( p )  X  S denote the services that conform to instance-level profile p  X  E I .
 The environment that hosts the sales portal discussed in Section 2 is shown in Figure 2. EService is the generic profile that all the othe r profiles specialise. A profile is spe-cialised by adding constraints. For example in Figure 2, the BudgetNotebooks profile specialises the profile NotebookSales by restricting the value of the attribute price to at-most $1500.

In our approach, conceptual profiles allow complex constraints over its attributes, whereas specialisation into instance profiles is limited to equality predicates to assign values to attributes. Therefore, a conceptu al profile can be specialised into another con-ceptual or instance profile whereas all the instance profiles are specialised only by  X  . We refer to the specialisation of a concep tual profile into an instance profile as instan-tiation . For example in Figure 2, the instance profile S01 instantiates the conceptual profile BudgetNotebooks .
 Example 3 (S01). An instance profile that specia lises the conceptual profile from Consistency at the Conceptual Level. The conceptual profiles that are consistent with the request are shortlisted in this step. We use logical entailment as a means to determine whether a service profile matches a request or not. Our consistency check is formalised as a Constraint Satisfaction Problem (CSP). A CSP is defined as follows: Definition 3 (CSP). A CSP is defined as a triple X, V, R where  X  X is a set of variables { x 1 ,x 2 ,...,x n }  X  for each x  X  X , V x denotes the set of allowable values for variable v  X  R is a set of constraints that need to be satisfied for any given assignment to the ACSPis satisfiable if there exists at least one valid assignment for all the variables in X . A service constraint can be treated as a CSP where service attributes are the constraint variables ( X = A ) with appropriate domains ( V = D ) , and constraints ( R = C ) . A consistent conceptual profile is defined as follows: Definition 4 (Consistent Conceptual Profile). Given a service request Q = A, D, C and an environment E = S, E C ,E I , ccp E ( Q ) denotes the set of conceptual pro-files from E C that are consistent with Q : ccp E ( Q )= { A ,D ,C | A ,D ,C  X  E denotes the union combination 3 of corresponding domains in both operands.

If there is at least one solution for the CSP then S  X  ccp E ( Q ) otherwise S/  X  ccp E ( Q ) . For example, the CSP formulated to check for consistency between BudgetNotebooks and Q02 from Examples 1, 2 is V, D, R ,where
In this step only the conceptual profiles that have common attributes with the request and that have non-conflicting constraints are selected. This is similar to the intersection matches for selecting overlapping profiles. The consistency check can be performed using a constraint solver with flexible instance reasoning such as ILOG X  X  JConfigura-tor [15], or Seimens COCOS [16], or can be carried out using a (DL) reasoner such as Racer.

Aprofile S being in ccp E ( Q ) implies that the instance profiles that specialise S are potential matches for Q . All the concrete profiles that specialise any profile in ccp E ( Q ) are candidates for the second stage in our matchmaking process.
 Consistency at the Instance Level. The candidate services identified in the previous step are checked further to determine whether t heir instance profiles satisfy the require-ments in the request. Similar to the previous step, instance-level consistency is formu-lated as a CSP. This requires an additional restriction on some domains in the instance profile to accommodate the CWA for overspeci fied requests. Specifically, for a request
A, D, C and a matching instance profile A ,D ,C , we write  X  D to refer to the set of domains for attributes in A such that  X  D a =  X  if a  X  A \ A else  X  D a = D a  X  D a .We now formally define the consistent instance profile.
 Definition 5 (Consistent Instance Profile). Given an environment E , a request Q =
A, D, C , and a set of candidate instance profiles P = { S 1 ,...,S n } ,where P  X  E I , cip E ( Q, P ) denotes the set of instance profiles that are consistent with Q : cip E ( Q, P ) = { A ,D ,C | A ,D ,C  X  E If there is at least one solution for the CSP then S  X  cip E ( Q, P ) ;otherwise S/  X  cip E ( Q, P ) . In this step only the instance profiles with attribute values that definitely meet the restrictions in the request ar e selected. Matches for a given request Q are:  X   X  cip E ( Q,P ) , supplier ( S ) . For example, consistency check between the instance profile S01 and Q02 from Examples 3, 2 is modelled as a CSP V, D, R where
The consistency test at the instance level may alternatively be implemented in a num-ber of ways, including querying over a database of instance profiles, logic inference in FOL, and on-line querying of services. Since all the information about the service is rig-orously tested in this step to ascertain whether the service definitely meets the request, the matches returned in this step supersede the ones derived through pure conceptual reasoning (see Section 5). 4.2 On the Interpretations of Instance Profiles All the attributes A of the concrete profiles S = A, C  X  E I are bound to concrete values from the defined range using equality constraints. If no equality relationship is defined over an attribute then this implies the absence of any information about that attribute. Under the CWA, the meaning of unspecified attribute is that such an attribute does not exist. For example in Figure 2, the os property of the service S01 does not have a value associated with it hence S01 does not offer the os property ( V os =  X  ). That is, if a query restricts an unknown attribute of a profile then the service is not a match for the query. For example, S01 is not a match for the query Q03 that restricts the attribute os . It has been shown that under the CWA more accurate web service matches can be obtained than with the general open semantics [9,12].

Inspired by prior research in the databas e domain to provide additional semantics for null values, we explore the possibility of explicitly specifying that an attribute does not exist . In our approach, an attribute whose value is InvalidType implies that the at-tribute is not offered. InvalidType is an universal type whose instances can be assigned to attributes irrespective of their prescribed data type. For example in Figure 2, the os attribute of the service S02 is assigned to the special type InvalidType hence it is under-stood that S02 does not offer the property os . Service requests may be modelled to take advantage of this modelling style in order to search for services that do not offer certain properties. For example in Table 1, the query Q04 searches for services that do not offer the os property.
 Table 3a presents the possible interpretations of instance profiles. For example in S02 , the value of the attribute os is InvalidType which implies that SO2 does not offer os . Therefore, S02 is a potential match for a query like Q04 that requires the absence of the os attribute. The results of the evaluation of our consistency-based matchmaking scheme are pre-sented in this section. The services offered by Rummage and Hawker in the sales portal scenario were modelled within the abstract environment that holds conceptual and con-crete service details. The environment used in the evaluation is presented in Figure 2. The service discovery requests from Table 1 were modelled within our framework. For each of these requests, the consistency-based matchmaking scheme was applied. The candidate profiles that are selected in the conceptual matchmaking stage are the following: Q01: { BudgetNotebooks } ; Concrete profiles  X  X  S01,S03 } Q02: { BudgetNotebooks } ; Concrete profiles  X  X  S01,S03 } Q03: { BudgetNotebooks,StandardNotebooks } ; Concrete profiles  X  X  S01,S03,S02 } Q04: { BudgetNotebooks,StandardNotebooks } ; Concrete profiles  X  X  S01,S03,S02 } Subsequently, the respective concrete profiles were queried to isolate the services that do match the requests. The results are presented in Table 3b.
 Our results support that following observations: Absence of False Positives. All results are consistent with the expected results as spec-ified in Table 1; there are no false positives because of the rigorous testing at concrete layers of the service descriptions. Therefore, the false positives (Q02,S04), (Q03,S01), (Q03,S02), (Q03,S04), (Q04,S01), (Q04,S03), (Q04,S04) from Table 2 are not present in our approach.
 Overspecified Profiles. For the query Q01, subsumption-based matchmakers penalise the profile S03 for providing a more detailed description. In our approach, S01 and S03 both match equally well since the attrib utes that are not restricted by the service requests are ignored. Therefore, excess inf ormation that is not restricted in a request does not play any role in the matching process.
 Unspecified Values. The flexible modelling paradigm in our approach allows OWA, CWA and reified representation ( InvalidType ) to restrict the existence of certain at-tributes in queries. For example, query Q04 restricts the existence of the OS attribute. The matchmaking between Q04 and th e service S01 is interpreted as:  X  X ttribute  X  X s X  with an unknown value exists in the profile but the query restricts its existence X  .As shown in Table 3a, a mismatch is returned in this case. Profiles S02 and S03 are also checked in a similar fashion 4 .

Our preliminary evaluation suggests that our consistency-based matchmaking ap-proach is robust while handling additional information in service specifications, al-ways returns functional semantic matches (no false positives), and supports unspecified values.
 Our consistency-based matchmaking process has been implemented within the Model-Driven Architecture (MDA) framework to support the (semi-)automatic compo-sition of web services [17,18]. The combination of MDA and multi-level consistency-based matchmaking facilitates a more interactive composition process (if so desired). Other than the DL based approaches mentioned in the introduction, the following works are relevant in the context of this paper:
Our work is similar to [19] in that both the approaches advocate querying instance level information about the services to improve accuracy. However, different match-making schemes are employed. In [19], a set-theoretic matchmaking approach is used to assess suitability of a service with respect to a request. In this scheme, a service profile (or a goal) is modelled as  X  X ntentions X , that is, a universally (or existentially) quantified expression over a set of relevant objects (service capabilities), where the quantification determines whether a profile matches a goal. The main drawback of this approach is that explicit intention modelling is required; the absence of such information reduces the problem to subsumption reasoning and may result in counter-intuitive matches (see Section 3). There is no explicit consideration of gathering intention and its represen-tation in [19]. Conversely, our approach does not require any additional information besides the service profiles.

In our previous work [18], an interactive CSP-based algorithm that composes ser-vices by checking consistency between requirements and service specifications was presented. This work assumes the existence of a database of instance profiles prior to composition. Here, we present the characteristics of the consistency-based matchmak-ing scheme especially in situ ations where concrete details about the service capabilities cannot be predicted prior to matchmaking.

Carman and Serafini [20] propose interleaving planning and execution of service composition. The execution of services produces information that can be used to extend and revise a plan to ensure a request is met. This approach does not scale to handle all services because executing a service may have permanent effects and compensation actions may be required. Mo reover, the relationship between any two service interfaces have to be specified prior to planning. In our approach, no such pre-specification is required because consistenc y between services and requests is assessed during matchmaking by gathering instance level details when required. We presented a consistency-based matchmaking approach where services that poten-tially provide the requested functionality are identified, candidate services are queried for more information to isolate those services that indeed meet the request to prune undesired results. Our evaluation shows that our matchmaking scheme is robust while handling over-specified profiles, always returns matches where every individual match provides the requested functionality, avoids false positives, and is able to handle omit-ted attributes effectively. Further work in this direction includes developing a ranking mechanism based on an optimis ation scheme where attributes are qualified with weights and extending our work to situations where a service offers only a part of the required functionality. We also plan to incorporate our matchmaking process within a framework for semi-automated web service composition.

