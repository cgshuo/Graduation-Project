 This paper compares the performance of an SQL solution that implements a relational data model with a document store named MongoDB. We report on the performance of a single node configuration of each data store and assume the database is small enough to fit in main memory. We analyze utilization of the CPU cores and the network bandwidth to compare the two data stores. Our key findings are as fol-lows. First, for those social networking actions that read and write a small amount of data, the join operator of the SQL solution is not slower than the JSON representation of MongoDB. Second, with a mix of actions, the SQL solu-tion provides either the same performance as MongoDB or outperforms it by 20%. Third, a middle-tier cache enhances the performance of both data stores as query result look up is significantly faster than query processing with either system.
 H.3.4 [ Information Systems Applications ]: Systems and Software X  Performance evaluation(efficiency and effective-ness) Experimentation, Performance SQL, Document store, JSON, relational
There is an abundance of data stores with both the com-puter industry and the research arena contributing novel architectures and data models. In [10], Cattell surveys and classifies 22 data stores to motivate a quantitative analysis of the alternative designs and implementations. We study a specific aspect of this vast multi-faceted topic, namely, a comparison of an industrial strength relational database document store named MongoDB. While SQL-X implements a relational data model [12], MongoDB implements a JSON representation of data [14]. Each offers a rich set of design choices. We use the BG [5] benchmark to exercise the differ-ent capabilities of each data store. This social networking benchmark consists of a database and eleven actions (see Table 1) that either read or write a small amount of data from the database.

While SQL-X does not scale horizontally, MongoDB scales to a large number of nodes. In addition to impacting the performance of a single node instance of each data store, physical organization of data impacts the horizontal scal-ability of MongoDB. While both are important, we focus on the performance of a single node instance of each data store for the following reasons. First, it provides insights into the tradeoffs associated with two alternative logical data de-signs, namely, relational and JSON. An interesting finding is that the use of the join operator is not slower than the JSON representation, see Section 4.

Second, while BG X  X  interactive social networking actions are simple, they interact in complex ways to offer a wide range of design choices. We show it is beneficial to move the work of read actions to write actions when the workload is dominated by read actions. (According to Facebook, more than 99% of their workload is dominated by queries [3, 28].) Materialized views are not appropriate because they provide either a very low performance or a high amount of stale data, see Section 5.
 Members( userid , username, pw, f irstname, lastname, job, gen der, jdate, ldate, address, email, tel, prof ileImage, thumbnailImage ) Friends( \ inviterID, \ inviteeID , \ status ) Res ource( rid , \ creatorid, \ wal luserid, type, body, doc ) Manipulation( mid , modif ierid, c rid, \ c reatorid, timestamp, type, content ) Figure 1: Basic SQL-X database design. The under-lined attribute(s) denote the primary key of a table. Attributes with a hat denote the indexed attributes. of this system.
Thir d, BG X  X  social networking actions impose a small amount of work on a node and should be processed by a single node of a multi-node data store. Otherwise, the overhead of par-allelism limits the scalability of a data store [19, 15, 33]. By understanding factors that enhance the performance of a single node, we provide a solid foundation to investigate al-ternative designs that impact the scalability of a data store. These alternatives include partitioning strategies, replica-tion, and secondary indexes [15, 29].

Our primary contribution is a quantitative comparison of two different data store architectures to provide insights into their working operations. Data store architects may use these results to enhance the performance of their existing data store for social networking actions. Social networking sites may use these results to fine tune the performance of their existing deployments. For example, when computing the friends of a member [3], obtained results suggest join of two tables might be fast enough as long as images are represented effectively, see Section 3.
 Related work: An experimental comparison of RDBMS so-lutions with the NoSQL systems for interactive data-serving environments and decision support workloads is presented in [18]. Its key finding is that the SQL systems provide significant performance advantages and that NoSQL sys-tems are fairly competitive in many cases. It employs the YCSB benchmark [13] for its evaluation of interactive en-vironments. Our evaluation focuses on interactive social networking actions and considers a richer conceptual data model and workload. We explore a subset of a large space of possibilities including the use of caches, quantifying their tradeoffs.

The rest of this paper is organized as follows. Section 2 provides an overview of the BG social networking bench-mark. It includes an organization of data, termed Basic, with both SQL-X and MongoDB. Sections 3 to 6 present physical design enhancements to the Basic design of each system. This discussion includes a quantitative analysis to identify the best design decisions (termed Boosted) for each system. We use these designs to compare SQL-X with Mon-goDB in Section 7. Brief conclusions and future research directions are presented in Section 8.
BG [5] is a benchmark to rate data stores for interactive social networking actions and sessions. These actions and sessions either read or write a very small amount of the entire data set. BG uses a thread to emulate a member of a social networking site viewing either her own profile or that of another member, listing either her friends or those of another member, inviting another member to be friends, viewing her top-k resources (image, posting), and others. The first column of Table 1 lists all actions supported by BG. These actions are common to sites such as Facebook, LinkedIn, Twitter, FourSquare, and others [5].

BG models a database consisting of a fixed number of members ( M ) with a registered profile. Each member profile may consist of either zero or 2 images. With the latter, one image is a thumbnail and the second is a higher resolution image. While thumbnails are displayed when listing friends of a member, the higher resolution image is displayed when a member visits a user X  X  profile. An experiment starts with a fixed number of friends (  X  ) and resources per member (  X  ). This study assumes a database of 10,000 profiles with 2 KByte thumbnail images and 12 KByte profile images. We also consider databases with no images. All experiments start with 100 friends 2 and resources per user,  X  =  X  =100. (The time to load the database with MongoDB is slightly faster than SQL-X [7].) We have conducted experiments with a 100K member database. The reported observations (0.1%) Write (1%) Write (10%) Write and trends do not change as long as the benchmark database is smaller than the server memory.

BG computes a Social Action Rating (SoAR) of a data store based on a pre-specified service level agreement (SLA) by manipulating the number of threads (i.e., emulated mem-bers) that perform actions simultaneously. SoAR is the max-imum system throughput (actions per second) that satisfies the SLA. All SoAR ratings in this paper are established with the following SLA: 95% of requests observe a response time of 100 milliseconds or faster with unpredictable (stale) data lower than 0.1%. An ideal physical data design is one that maximizes SoAR of a system. Data designs using materi-alized views and cache augmented data stores may produce stale data. The former is because the RDBMS may propa-gate updates to the materialized view asynchronously. The latter is due to write-write race conditions between the data store and the cache [20].
 Figure 1 shows the relational design of BG X  X  database. The underlined attributes are the primary keys of the iden-tified tables. Index structures are constructed on these at-tributes to facilitate efficient processing of read actions. For example, with view profile action referencing a member with a specific userid, say 5, a hash index facilitate efficient re-trieval of the Member corresponding to this userid. Mem-bers table may store images as BLOBs. Alternatives are discussed in Section 3. Computing either list of friends or pending friends requires a join between Members and Friends table. Section 5 explores the use of materialized views and their alternatives to migrate the work of read ac-tions to write actions for computing simple analytics. We report SoAR of these designs with SQL-X.

Figure 2 shows the JSON design of BG X  X  database tailored for use with MongoDB. For each member M i , this design maintains three different arrays: 1) pendingFriends main-tains the id of members who have extended a friend invita-tion to M i , 2) confirmedFriends maintains the id of members who are friends with M i , and 3) wallResourceIds maintains the id of resources (e.g., images) posted on M i  X  X  profile. One may store profile and thumbnail image of each member ei-ther in the file system, MongoDB X  X  GridFS, or as an array of bytes. Figure 2 shows the last two choices. When images are stored in the GridFS, the profileimageid and thumbnail-imageid are stored as attributes of the Members collection (instead of the array of bytes shown in Figure 2). Section 3 shows one design provides a SoAR significantly higher than the other two.
 In the next 3 sections, we provide additional details about BG X  X  actions and their implementation using both the rela-tional and JSON representations. We discuss changes to the physical organization of data and their impact on the SoAR of SQL-X and MongoDB. We analyze SoAR of SQL-X with different mixes of actions, see Table 1. Post Comment and Delete Comment actions are eliminated because we have no improved designs to offer for these actions.

To simplify discussion, this paper classifies BG X  X  actions into those that either read or write data. A read action is one that queries data and retrieves data items without updating them. A write action is one that either inserts, deletes, or updates data items. Column 2 of Table 1 identifies different read and write actions.

All reported SoAR numbers are based on a dedicated hardware platform consisting of six PCs connected using a Gigabit Ethernet switch. Each PC consists of a 64 bit 3.4 GHz Intel Core i7-2600 processor (4 cores with 8 threads) configured with 16 GB of memory, 1.5 TB of storage, and All other nodes are used as BGClients to generate workload for this node. With all reported SoAR values greater than zero, either the disk, all cores, or the networking card of the server hosting a data store become fully utilized. We report on the use of two networking cards to eliminate the network as a limiting resource. When SoAR is reported as zero, this means a design failed to satisfy the SLA.
There is folklore that an RDMBS efficiently handles a large number of small images, while file systems are more efficient for storage and retrieval of large images [31]. With BG, we show physical organization of profile and thumbnail images in a data store impacts its SoAR rating dramatically. For example, if thumbnail images are not stored as a part of the profile structure representing a member then the per-formance of the system for processing the List Friend (LF) MongoDB is configured with two networking cards, each is a one Gigabit/second card. in all experiments. Figure 3: SoAR of List Friends (LF) with differ-ent organization of 2 KB thumbnail image, M=10K,  X  =100. action is degraded significantly. This holds true with both MongoDB and SQL-X. Performance of SQL-X is further en-hanced when profile images are stored in the file system. The same does not hold true with MongoDB. Below, we provide experimental results to demonstrate these observations.
The LF action of BG retrieves the thumbnail image and the profile information of each friend of a member (see at-tributes shown in Figure 1). Figure 3 shows the SoAR rat-ing of LF with SQL-X and MongoDB with 100 friends per member. While SQL-X performs a join between two tables (Members and Friends of Figure 1) to perform this action, MongoDB looks up an array of member identifiers (con-firmedFriends of Figure 2 for the referenced Member JSON instance) and retrieves the JSON object for each member. With SQL-X, we consider thumbnails stored in either the file system or inline with the record representing the mem-ber. With MongoDB, we consider thumbnails stored in its Grid File System (GridFS) or as an array of bytes in the JSON-like representation of a member. With both systems, storing the thumbnail image as a part of the Member pro-file enhances SoAR rating of the system from zero to a few hundred. In these experiments, the CPU of the the data store becomes 100% utilized. Note that, with a single node, the join operation of SQL-X is not necessarily slower than MongoDB X  X  processing of confirmedFriends array to retrieve documents corresponding to the friends of the member.
The performance of SQL-X for processing View Profile (VP) action of BG is enhanced when large profile images are not stored in the RDBMS, see Figure 4. An alternative is to store them in the file system with a member record maintaining the name of the file containing the correspond-ing profile image [31, 8]. Figure 4 shows the SoAR of SQL-X with these two alternatives for two different image sizes: 2 KB and 12 KB. (As a comparison, with no images, SoAR of SQL-X is 119,746 for this workload.) A small image size, 2 KB, enables SQL-X to store the image inline with the mem-ber record, outperforming the file system by a factor of 3. SQL-X stores images inline as long as they are smaller than 4 KB. Beyond this, for example with our assumed 12 KB image sizes, the performance of SQL-X diminishes dramati-cally, enabling the file system to outperform it by more than 40 folds.
 MongoDB X  X  GridFS provides effective support for images. Its SoAR is comparable to storing these images in the file system. It outperforms the file system by more than a fac-tor of two with very large profile images, e.g., 500 KB. It Figure 4: SoAR of SQL-X for processing a work-load c onsisting of 100% View Profile (VP) action with images stored as either BLOBs or in the FS, M =10K,  X  =100. is worth noting that SQL-X outperforms MongoDB with image sizes smaller than 4 KB by inlining them in profile records. Beyond this limit, MongoDB outperforms SQL-X. Similar to the thumbnail discussions, if profile image sizes are known to be small in advance then one may inline them with MongoDB by representing them as an array of bytes in the Members collection, see Figure 9. Key considerations include MongoDB X  X  limit of 16 Megabytes for the size of a document and the impact of large documents on actions that do not require the retrieval of the profile image. For exam-ple, the List Friend (LF) action does not require the profile image. MongoDB provides an interface to remove some at-tribute values of a document while constructing a query. For example, one may query the Members collection for a doc-ument with userid 1 and not retrieve the profile image of the qualifying document by issuing the following expression: db.member.find( {  X  X serid X :1, X  X rofileimage X :false } ).
The concept of friendship between two members is central to a social networking site. Most of BG X  X  actions model this concept, see Table 2. An important consideration is how to represent the thumbnail image of each member listed as a friend of a referenced member. This was discussed in Section 3. Hence, this section focuses on a BG database configured with no images.
With a relational design, one may represent pending and confirmed friendships as either one or two tables. With each alternative, a friendship might be represented as either one or two rows. We elaborate on these designs below. Subse-quently, we establish their SoAR rating. Obtained results show that a two table design is superior to a one table design.
Figure 1 shows a design that employs one table. It em-ploys an attribute named  X  X tatus X  to differentiate between pending and confirmed friendships: A  X  X  X  value denotes a confirmed friendship while a  X  X  X  value denotes a pending friendship. The second column of Table 2 shows the SQL commands issued to implement the alternative BG actions with this design. Note the use of disjuncts ( X  X r X ) in the qualification list of the SQL queries. A designer may sim-plify these queries and eliminate disjuncts by representing a friendship with two records. The resulting queries are shown in the third column of Table 2. The design changes of Figure 8. Figure 5: SoAR of SQL-X with either one or two tables for pending and confirmed friendships with two workloads, M =10K and  X  =100. Each friendship is represented as two records. the implementation of the Accept Friendship Request action (fourth row of Table 2) into a transaction consisting of two SQL statements. In our implementation, all transactions are implemented as stored procedures in SQL-X.

An alternative to the one table design is to employ two different tables and separate pending friend invitations from confirmed invitations, see physical design of Figure 8 and queries of Table 3. This eliminates the  X  X tatus X  attribute of the one table design. However, the data designer is still faced with the dilemma to represent a friendship either as one row or two rows in the table corresponding to the confirmed friends. The second and third row of Table 3 shows the SQL commands with these two possibilities. A key difference is that SQL queries are simpler with the two record design.
When comparing the alternative designs, the two record design requires more storage space than the one record de-sign. However, its resulting SQL queries are simpler to au-thor and reason about. With one user issuing requests (sin-gle threaded BG), the larger number of records does not impact the service time of issued queries and update com-mands because index structures facilitate retrieval and ma-nipulation of the relevant records. In a multi-user setting with a mix of read and write actions, see Table 1, the two table design outperforms the one table design when the fre-quency of write action is high enough to result in conflicts. Figure 5 shows SoAR of these two alternatives with each friendship represented as two records. Observed SoAR with a mix of very low (0.1%) write actions is almost identical for the two designs due to the use of index structures and a low conflict rate. With a mix of high (10%) write actions, the two table design outperforms the one table design by more than 30%. We speculate this is due to ACID property of transactions slowing down the one table design as it is used concurrently to process both pending and confirmed friendship transactions. The two table design reduces this contention among concurrently executing actions. For ex-ample, the query to compute the number of pending friend invitations for a member is no longer blocked by the trans-action that thaws friendship between two members.
With MongoDB, BG X  X  List Friend (LF) action is most interesting because it must retrieve the documents pertain-ing to the friends of a referenced member. These can be retrieved either one document at a time or all documents Figure 6: SoAR with the Basic SQL-X design of Figure 1, materialized views ( MV ) for aggregates as attributes with both synchronous and asynchronous mode of refresh, and developer maintained ( Man-ual ) aggregates as attributes, M =10K,  X  =100, BG database has no images. at once. With the former, LF is implemented by issuing a query to retrieve the basic profile information for each con-firmed friend. With the latter, the entire list of friends is used with the $in operator to construct the query issued to MongoDB. This operator selects all the documents whose identifiers match the values provided in the list. With an under utilized system (a few BG threads), the second ap-proach provides a response that is approximately 1.5 times faster than the first. This is because the first approach incurs the overhead of issuing multiple queries across the network for each document. The SoAR of these two alternatives is almost identical because the CPU of the server hosting Mon-goDB becomes 100% utilized.

MongoDB supports a host of write concerns, see [27] for details. We investigate two, termed normal and safe in MongoDB X  X  documentation. Both are implemented by Mon-goDB X  X  java client. The normal write concern returns con-trol once the write is issued to the driver of the client. The safe write concern returns control once it receives an ac-knowledgment from the server. With a low system load (BG with one thread), the normal write concern improves the average response time of MongoDB by 13%. It does not, however, improve the processing capability of the MongoDB server and has no impact on its SoAR when compared with the safe write concern. Moreover, it produced a very low ( &lt; 0.1%) amount of unpredictable reads.
Due to a high read to write ratio of the workload of social networking sites [28], one may enhance the average service time of the system by migrating the workload of reads to writes. With RDBMSs, one way to realize this is by using materialized views, MVs. Section 5.1 discusses this approach and shows that it slows down write actions so dramatically that it is difficult to argue they are interactive. It presents an alternative named Manual that does not suffer this lim-itation. However, Manual requires additional software and incurs the overhead of a development life cycle.
Social networking sites present their members with indi-vidualized  X  X mall analytics X  [32]. These are aggregate infor-mation such as a member X  X  number of friends. BG models these using its View Profile (VP) action that provides each member with her count of resources, friends, and pending friend invitations. One may implement these in two ways: 1) Compute the aggregates each time the VP action is in-voked, 2) Store the value of aggregates, look them up to process VP, and maintain them up to date in the presence of write actions that impact their value. An example SQL query that implements the former is illustrated in the first row of Table 2. The latter migrates the workload of read actions to write actions. It is appropriate when write ac-tions are infrequent. Below, we present two alternatives to implement the second approach.

One may use Materialized Views (MVs) of SQL-X to store the value of BG X  X  simple analytics and require the RDBMS to maintain their value up to date. This was implemented as follows. First, we define one MV for each aggregate of the VP action. The resulting 3 views have two columns: user-id and the corresponding aggregate attribute value. Next, we author a MV that joins these three views with the origi-nal Member table (using the user-id attribute value), imple-menting a table that consists of each member X  X  attributes along with 3 additional attribute values representing each aggregate for that member. This table is queried by the VP action to look up the value of its simple analytic instead of computing it.

One may configure SQL-X to refresh MVs either syn-chronously or asynchronously in the presence of updates. The asynchronous refresh is in the order of hours, causing the MV to contain stale data. BG quantifies these as unpre-dictable reads. Below, we discuss this in combination with the observed SoAR.

With no profile image and a read workload that invokes the VP action only, the authored MV improves SoAR of SQL-X more than six folds from 19,020 to 119,746 actions per second. With infrequent (0.1%) writes, asynchronous mode of processing updates enables MVs to enhance SoAR of SQL-X by almost a factor of two, see Figure 6. However, this causes 31% of read actions to observe unpredictable (stale) data. The amount of unpredictable data increases to 72% with a high frequency (10%) of write actions, enhancing SoAR of SQL-X by a modest 11%.

The synchronous refresh mode of MVs eliminates unpre-dictable data. However, as shown in Figure 6, it diminishes SoAR of SQL-X dramatically. This is because it slows down write actions. As an example, the service time of the Ac-cept Friend Request write action is slowed down from 1.7 i.e., one BG thread. These service times are not interactive, rendering MVs inappropriate for BG X  X  workload.

An alternative to MVs, named Manual , is for a software developer to implement aggregates as attributes by extend-ing the Member table with 3 additional columns, one for each aggregate. When a member registers a profile, these attribute values are initialized to zero. The developer au-thors additional software (either in the application software or in the RDBMS in the form of stored procedures and trig-gers) for the write actions that impact these attribute values to update them by either incrementing or decrementing their values by one. For example, the developer extends a write action that invites Member 1 to be friends with Member 2 to increment the number of pending friends for Member 1 by one as a part of the transaction that updates the Friends table, see Section 4.

Manual speeds up the VP action by transforming 4 SQL queries into one. The four queries include retrieval of the ref-erenced member X  X  profile attribute values, count of friends, count of pending friend invitations, and count of resources. In our experiments, Manual enhanced SoAR of SQL-X for processing the VP action by the same amount as MVs with asynchronous update. However, it produces no stale reads. When compared with Basic, Manual provides at most a 22% improvement as the VP action constitutes 35% to 40% of the workload, see Table 1.

A drawback of Manual is the additional software and its associated software development life cycle (design, imple-mentation, testing and debugging, and maintenance). Its key advantages include interactive response times for both the read and write actions with no unpredictable reads.
With both MongoDB and SQL-X, a developer may avoid issuing a query to the data store by caching its output, value , given its unique input, key . This is the main motivation for middle tier caches [23, 11, 36, 17, 16, 25, 1, 2, 30, 22, 28, 21]. This section focuses on a specific subclass that employs in-memory Key-Value Stores (KVS) with a simple put, get, delete interface [21, 28]. Its use case is as follows. The developer modifies each read action to convert its input to a key and use this key to look up the KVS for a value. If the KVS returns a value then the value is produced as the output of the action without executing the main body of the read action that issues data store queries. Otherwise, the body of the read action executes, issues data store queries to compute a value (i.e., output of the read action), stores the resulting key-value pair in the KVS for future use, and returns the output to BG.

The developer must modify each write action to invalidate key-value pairs that are impacted by its insert, delete, up-date command to the data store. For example, the write ac-tion that enables Member 1 to accept Member 2 X  X  friendship request must invalidate 5 key-value pairs. These correspond to Member 1 X  X  profile, list of friends and list of pending friends, and Member 2 X  X  profile and list of friends.
The maximum number of unique key-value pairs is a func-tion of the number of members/resources and read actions. With a database of 10,000 members, the view profile action of BG may populate the KVS with 10,000 unique key-value pairs. With View Comment on Resource (VCR) action and 100 resources per member, the KVS may consist of a mil-lion unique key-value pairs. The actual number of cached key-value pairs might be lower due to a skewed pattern of data access, e.g., a workload that employs a Zipfian distri-bution [6] to reference data items.
 There are two categories of in-memory KVSs: Client-Server (CS) and Shared Address Space (SAS) [21], see Fig-ure 7. With CS, the application server communicates with the cache via message passing. A popular CS KVS is mem-cached [26, 28]. With SAS, the KVS runs in the address space of the application. Examples include Terracotta X  X  Ehcache [34] and JBoss Cache [9]. SAS KVSs implement the concept of a transaction to atomically update all replicas of a key-value in different application instances. Both CS and SAS architectures may support replication of key-value pairs and implement consistent hashing to enhance availability of data and implement elasticity. A discussion of these topics is a digression from our focus. Instead, we focus on the per-formance of a single cache instance. With memcached, the cache server is a process hosted on a different server than the one hosting the data store. With Ehcache, the cache instance executes in the address space of the BGClient.
In the following, we focus on the impact of the KVS with a very low (0.1%) and a high (10%) frequency of writes. With these workloads, both MongoDB and SQL-X provide compa-rable SoARs as either the CPU or the network bandwidth of the server hosting the KVS becomes 100% utilized. Hence, without loss of generality, we present SoARs observed with SQL-X using either memcached or Ehcache.

Table 4 presents SoAR of the alternative designs when the database is configured with either no images or 12 KB pro-file image sizes with two different mixes of workloads. These Members( userid , username, pw, f irstname, lastname, job, gen der, jdate, ldate, address, email, tel, thumbnailImage ) Frds( \ f rdID 1 , \ f rdID 2 ) Pdg Frds( \ inviterID, \ inviteeID ) Reso urce( rid , \ creatorid, \ wal luserid, type, body, doc ) Manipulation( mid , modif ierid, c rid, \ c reatorid, timestamp, type, content ) Figure 8: Boosted SQL-X database design with pro-file images stored in the file system and thumbnail images as inline blobs. One record in the Frds ta-ble represents the friendship between two members. The underlined attribute(s) denote the primary key. Attributes with a hat denote the indexed attributes. results show Ehcache provides the highest SoAR, outper-forming memcached by more than a factor of 13 (5) with images (no images). This is because it runs in the same ad-dress space as the BGClient, avoiding the overhead of trans-mitting key-value pairs across the network and deserializing them. In these experiments, the four core CPU of the server hosting BGClient (and the Ehcache) becomes 100% utilized, dictating the overall system performance. (This bottleneck explains why there is no difference between SQL-X and Mon-goDB once extended with Ehcache.) It is interesting to note that the SoAR of Ehcache with 12 KB images is almost twice lower than that with no images. This is due to net-work transmission of images for invalidated key-value pairs, increasing network utilization from 30% to 88%.

With memcached, the four core CPU of its server be-comes 100% utilized when there are no images, dictating its SoAR rating. With 12 KB profile images, the network bandwidth becomes 100% utilized dictating SoAR of mem-cached. In these experiments, memcached could produce key-value pairs at a rate of up to 2 Gbps as its server was configured with two Gbps networking cards.
Table 4 shows SoAR of the Basic SQL-X and MongoDB data designs when compared with their Boosted alterna-tives. (See Figures 1 and 8 (2 and 9) for the Basic and Boosted SQL-X (MongoDB) data designs.) Boosted incor-porates all of the best practices presented in the previous X and MongoDB, the Basic data design is inferior to the Boosted alternative because it is inefficient and utilizes its 4 core CPU fully.

With Boosted and no images, the CPU of the server host-ing the data store becomes 100% utilized, dictating its SoAR. This is true with both SQL-X and MongoDB and the two workloads, 0.1% and 10% frequency of writes. These results suggest SQL-X processes BG X  X  workload more efficiently than MongoDB because its SoAR rating is two folds higher.
With 12 KB profile images, both SQL-X and MongoDB continue to utilize their CPU fully with the Basic data de-sign. With Boosted, the network becomes 100% utilized and Boosted data design. Figure 9: Boosted MongoDB design of BG X  X  database . dictates their SoAR rating. These results suggest SQL-X transmits less data than MongoDB to process BG X  X  work-load because its SoAR rating is 50% higher.

We have conducted experiments with a 100K member database. The reported trends and observations hold true for this and other databases as long as the available server memory is larger than the size of the benchmark database.
This experimental paper compares organization of a social networking database with two alternative data store archi-tectures: an industrial strength SQL solution and a NoSQL document store named MongoDB. We used the BG bench-mark for this comparison. The observed SoAR ratings are impacted by two key parameters of BG. First, the mix of actions that constitute the workload. Second, configuration of member profiles with either two images or no images. We analyzed alternative enhancements to both the relational representation of SQL-X and JSON representation of Mon-goDB. A summary of these enhancements are as follows, starting with SQL-X: A negative finding is that materialized views slow down the response time of write actions so dramatically that they can no longer be considered interactive.

With MongoDB, a key finding is to store the thumbnail image of a member as an array of bytes in the member X  X  JSON object. This results in a SoAR of seven thousand actions per second. If thumbnail images are stored in ei-ther MongoDB X  X  GridFS or the file system of the operating system, SoAR of MongoDB diminishes to zero.

With both MongoDB and SQL-X, one may extend the data store with a cache to look up query results instead of processing queries to compute results. We investigated both memcached and Ehcache. While both enhance system performance, the improvement is dramatic with Ehcache be-cause it eliminates the overhead of transmitting key-values across the network and deserializing them.

When comparing the best SQL-X and MongoDB physi-cal data designs, SoAR of SQL-X is 2.5 times higher than MongoDB when BG X  X  database is configured with no im-ages. With both systems, the CPU of the server hosting the data store becomes 100% utilized. This suggests SQL-X processes BG X  X  workload more efficiently than MongoDB. When BG X  X  database is configured with 12 KB images, the network (2 Gbps) becomes 100% utilized with both data stores. In this scenario, SoAR of SQL-X is 30% higher than MongoDB. This suggests SQL-X transmits less data than MongoDB when processing BG X  X  workload.

A key feature of MongoDB, memcached, and Ehcache is their ability to horizontally scale to a large number of nodes. VoltDB is an SQL solution that also scales to a large number of nodes [24, 29]. An on-going research effort is to quantify the scalability of these systems using BG. This will explore a host of new physical data designs such as different par-titioning strategies, replication, and secondary indexes [29]. It will include an interaction of these design choices with the boosted designs presented in this study.
We thank Mark Callaghan and the anonymous reviewers of CIKM 2013 for their insights and valuable comments. [1] C. Amza, A. L. Cox, and W. Zwaenepoel. A [2] C. Amza, G. Soundararajan, and E. Cecchet.
 [3] T. Armstrong, V. Ponnekanti, D. Borthakur, and [4] L. Backstrom. Anatomy of Facebook, [5] S. Barahmand and S. Ghandeharizadeh. BG: A [6] S. Barahmand and S. Ghandeharizadeh. D-Zipfian: A [7] S. Barahmand and S. Ghandeharizadeh. Expedited [8] D. Beaver, S. Kumar, H. Li, J. Sobel, and P. Vajgel. [9] J. Cache. JBoss Cache, [10] R. Cattell. Scalable SQL and NoSQL Data Stores. [11] J. Challenger, P. Dantzig, and A. Iyengar. A Scalable [12] E. F. Codd. A Relational Model of Data for Large [13] B. F. Cooper, A. Silberstein, E. Tam, [14] D. Crockford. The Application/JSON Media Type for [15] C. Curino, E. Jones, Y. Zhang, and S. Madden. [16] A. Datta, et. al. A Comparative Study of Alternative [17] L. Degenaro, A. Iyengar, I. Lipkind, and I. Rouvellou. [18] A. Floratou, et. al. Can the Elephants Handle the [19] S. Ghandeharizadeh and D. DeWitt. Hybrid-Range [20] S. Ghandeharizadeh and J. Yap. Gumball: A Race [21] S. Ghandeharizadeh and J. Yap. Cache Augmented [22] P. Gupta, N. Zeldovich, and S. Madden. A [23] A. Iyengar and J. Challenger. Improving Web Server [24] R. Kallman, et. al. H-Store: a High-Performance, [25] A. Labrinidis and N. Roussopoulos. Exploring the [26] memcached. Memcached, [27] MongoDB. Class WriteConcern, [28] R. Nishtala, et. al. Scaling Memcache at Facebook. In [29] A. Pavlo, C. Curino, and S. Zdonik. Skew-Aware [30] D. R. K. Ports, et. al. Transactional Consistency and [31] R. Sears, C. V. Ingen, and J. Gray. To BLOB or Not [32] M. Stonebraker. What Does  X  X ig Data X  Mean? [33] M. Stonebraker and R. Cattell. 10 Rules for Scalable [34] Terracotta. Ehcache, [35] J. Ugander, et. al. The Anatomy of the Facebook [36] K. Yagoub, et. al. Caching Strategies for
