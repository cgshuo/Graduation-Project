 Misha Denil mdenil@cs.ubc.ca David Matheson davidm@cs.ubc.ca Nando de Freitas nando@cs.ubc.ca University of British Columbia Random forests are a class of ensemble method whose base learners are a collection of randomized tree predictors, which are combined through averaging. The original random forests framework described in Breiman (2001) has been extremely influential (Svet-nik et al., 2003; Prasad et al., 2006; Cutler et al., 2007; Shotton et al., 2011; Criminisi et al., 2011).
 Despite their extensive use in practical settings, very little is known about the mathematical properties of these algorithms. A recent paper by one of the leading theoretical experts states that Theoretical work in this area typically focuses on styl-ized versions of the random forests algorithms used in practice. For example, Biau et al. (2008) prove the consistency of a variety of ensemble methods built by averaging base classifiers. Two of the models they study are direct simplifications of the forest growing algorithms used in practice; the others are stylized neighbourhood averaging rules, which can be viewed as simplifications of random forests through the lens of Lin &amp; Jeon (2002). An even further simplified ver-sion of random forests in one dimension is studied in Genuer (2010; 2012).
 In this paper we make further steps towards narrowing the gap between theory and practice. In particular, we present what is, to the best of our knowledge, the first consistency result for online random forests. Different variants of random forests are distinguished by the methods they use for growing the trees. The model described in Breiman (2001) builds each tree on a bootstrapped sample of the training set using the CART methodology (Breiman et al., 1984). The opti-mization in each leaf that searches for the optimal split point is restricted to a random selection of features, or linear combinations of features.
 The framework of Criminisi et al. (2011) operates slightly differently. Instead of choosing only features at random, this framework chooses entire decisions (i.e. both a feature or combination of features and a thresh-old together) at random and optimizes only over this set. Unlike the work of Breiman (2001), this frame-work chooses not to include bagging, preferring instead to train each tree on the entire data set and introduce randomness only in the splitting process. The authors argue that without bagging their model obtains max-margin properties.
 In addition to the frameworks mentioned above, many practitioners introduce their own variations on the ba-sic random forests algorithm, tailored to their specific problem domain. A variant from Bosch et al. (2007) is especially similar to the technique we use in this pa-per: When growing a tree the authors randomly select one third of the training data to determine the struc-ture of the tree and use the remaining two thirds to fit the leaf estimators. However, the authors consider this only as a technique for introducing randomness into the trees, whereas in our model the partitioning of data plays a central role in consistency.
 In addition to these offline methods, several re-searchers have focused on building online versions of random forests. Online models are attractive because they do not require that the entire training set be ac-cessible at once. These models are appropriate for streaming settings where training data is generated over time and should be incorporated into the model as quickly as possible. Several variants of online de-cision tree models are present in the MOA system of Bifet et al. (2010).
 The primary difficulty with building online decision trees is their recursive structure. Data encountered once a split has been made cannot be used to correct earlier decisions. A notable approach to this problem is the Hoeffding tree (Domingos &amp; Hulten, 2000) algo-rithm, which works by maintaining several candidate splits in each leaf. The quality of each split is esti-mated online as data arrive in the leaf, but since the entire training set is not available these quality mea-sures are only estimates. The Hoeffding bound is em-ployed in each leaf to control the amount of data which must be collected to ensure that the split chosen on the basis of these estimates is the true best split with high probability. Domingos &amp; Hulten (2000) prove that un-der reasonable assumptions the online Hoeffding tree converges to the offline tree with high probability. The Hoeffding tree algorithm is implemented in the system of Bifet et al. (2010).
 Alternative methods for controlling tree growth in an online setting have also been explored. Saffari et al. (2009) use the online bagging technique of Oza &amp; Rus-sel (2001) and control leaf splitting using two param-eters in their online random forest. One parameter specifies the minimum number of data points which must be seen in a leaf before it can be split, and an-other specifies a minimum quality threshold that the best split in a leaf must reach. This is similar in flavor to the technique used by Hoeffding trees, but trades theoretical guarantees for more interpretable parame-ters.
 One active avenue of research in online random forests involves tracking non-stationary distributions, also known as concept drift. Many of the online techniques incorporate features designed for this problem (Gama et al., 2005; Abdulsalam, 2008; Saffari et al., 2009; Bifet et al., 2009; 2012). However, tracking of non-stationarity is beyond the scope of this paper. The most well known theoretical result for random forests is that of Breiman (2001), which gives an up-per bound on the generalization error of the forest in terms of the correlation and strength of trees. Fol-lowing Breiman (2001), an interpretation of random forests as an adaptive neighborhood weighting scheme was published by Lin &amp; Jeon (2002). This was fol-lowed by the first consistency result in this area from Breiman (2004), who proves consistency of a simpli-fied model of the random forests used in practice. In the context of quantile regression the consistency of a certain model of random forests has been shown by Meinshausen (2006). A model of random forests for survival analysis was shown to be consistent in Ish-waran &amp; Kogalur (2010).
 Significant recent work in this direction comes from Biau et al. (2008) who prove the consistency of a vari-ety of ensemble methods built by averaging base clas-sifiers, as is done in random forests. A key feature of the consistency of the tree construction algorithms they present is a proposition that states that if the base classifier is consistent then the forest, which takes a majority vote of these classifiers, is itself consistent. The most recent theoretical study, and the one which achieves the closest match between theory and prac-tice, is that of Biau (2012). The most significant way in which their model differs from practice is that it requires a second data set which is not used to fit the leaf predictors in order to make decisions about vari-able importance when growing the trees. One of the innovations of the model we present in this paper is a way to circumvent this limitation in an online setting while maintaining consistency. In this section we describe the workings of our online random forest algorithm. A more precise (pseudo-code) description of the training procedure can be found in Appendix A. 3.1. Forest Construction The random forest classifier is constructed by building a collection of random tree classifiers in parallel. Each tree is built independently and in isolation from the other trees in the forest. Unlike many other random forest algorithms we do not perform bootstrapping or subsampling at this level; however, the individual trees each have their own optional mechanism for subsam-pling the data they receive.
 3.2. Tree Construction Each node of the tree is associated with a rectangular the collection of cells associated with the leafs of the tree forms a partition of R D . The root of the tree is ( X t ,Y t ) from the environment. Each point is assigned to one of two possible streams at random with fixed probability. We denote stream membership with the variable I t  X  { s,e } . How the tree is updated at each time step depends on which stream the corresponding data point is assigned to.
 We refer to the two streams as the structure stream and the estimation stream; points assigned to these streams are structure and estimation points, respec-tively. These names reflect the different uses of the two streams in the construction of the tree: Structure points are allowed to influence the struc-ture of the tree partition, i.e. the locations of candidate split points and the statistics used to choose between candidates, but they are not permitted to influence the predictions that are made in each leaf of the tree. Estimation points are not permitted to influence the shape of the tree partition, but can be used to estimate class membership probabilities in whichever leaf they are assigned to.
 Only two streams are needed to build a consistent for-est, but there is no reason we cannot have more. For instance, we explored the use of a third stream for points that the tree should ignore completely, which gives a form of online sub-sampling in each tree. We found empirically that including this third stream hurts performance of the algorithm, but its presence or absence does not affect the theoretical properties. 3.3. Leaf Splitting Mechanism When a leaf is created the number of candidate split dimensions for the new leaf is set to min(1 + Poisson(  X  ) ,D ), and this many distinct candidate di-mensions are selected uniformly at random. We then collect m candidate splits in each candidate dimen-sion ( m is a parameter of the algorithm) by projecting the first m structure points to arrive in the newly cre-ated leaf onto the candidate dimensions. We maintain several structural statistics for each candidate split. Specifically, for each candidate split we maintain class histograms for each of the new leafs it would create, us-ing data from the estimation stream. We also maintain structural statistics, computed from data in the struc-ture stream, which can be used to choose between the candidate splits. The specific form of the structural statistics does not affect the consistency of our model, but it is crucial that they depend only on data in the structure stream.
 Finally, we require two additional conditions which control when a leaf at depth d is split: 1. Before a candidate split can be chosen, the class 2. If any leaf receives more than  X  ( d ) estimation The first condition ensures that leafs are not split too often, and the second condition ensures that no branch of the tree ever stops growing completely. In order to ensure consistency we require that  X  ( d )  X   X  mono-tonically in d and that d/ X  ( d )  X  0. We also require that  X  ( d )  X   X  ( d ) for convenience.
 When a structure point arrives in a leaf, if the first condition is satisfied for some candidate split then the leaf may optionally be split at the corresponding point. The decision of whether to split the leaf or wait to collect more data is made on the basis of the structural statistics collected for the candidate splits in that leaf. 3.4. Structural Statistics In each candidate child we maintain an estimate of the posterior probability of each class, as well as the total number of points we have seen fall in the candidate child, both counted from the structure stream. In or-der to decide if a leaf should be split, we compute the information gain for each candidate split which satis-fies condition 1 from the previous section, Here S is the candidate split, A is the cell belonging to the leaf to be split, and A 0 and A 00 are the two leafs that would be created if A were split at S . The function H ( A ) is the discrete entropy, computed over the labels of the structure points which fall in the cell A .
 We select the candidate split with the largest informa-tion gain for splitting, provided this split achieves a minimum threshold in information gain,  X  . The value of  X  is a parameter of our algorithm.
 3.5. Prediction At any time the online forest can be used to make predictions for unlabelled data points using the model built from the labelled data it has seen so far. To make a prediction for a query point x at time t , each tree computes, for each class k , where A t ( x ) denotes the leaf of the tree containing x at time t , and N e ( A t ( x )) is the number of estimation points which have been counted in A t ( x ) during its lifetime. Similarly, the sum is over the labels of these points. The tree prediction is then the class which maximizes this value: The forest predicts the class which receives the most votes from the individual trees.
 Note that this requires that we maintain class his-tograms from both the structure and estimation streams separately for each candidate child in the fringe of the tree. The counts from the structure stream are used to select between candidate split points, and the counts from the estimation stream are used to initialize the parameters in the newly created leafs after a split is made. 3.6. Memory Management The typical approach to building trees online, which is employed in Domingos &amp; Hulten (2000) and Saf-fari et al. (2009), is to maintain a fringe of candidate children in each leaf of the tree. The algorithm col-lects statistics in each of these candidate children until some (algorithm dependent) criterion is met, at which point a pair of candidate children is selected to replace their parent. The selected children become leafs in the new tree, acquiring their own candidate children, and the process repeats. Our algorithm also uses this ap-proach.
 The difficulty here is that the trees must be grown breadth first, and maintaining the fringe of potential children is very memory intensive when the trees are large. Our algorithm also suffers from this deficiency, as maintaining the fringe requires O ( cmd ) statistics in each leaf, where d is the number of candidate split dimensions, m is the number of candidate split points (i.e. md pairs of candidate children per leaf) and c is the number of classes in the problem. These statistics can be quite large and for deep trees the memory cost becomes prohibitive.
 In practice the memory problem is resolved either by growing small trees, as in Saffari et al. (2009), or by bounding the number of nodes in the fringe of the tree, as in Domingos &amp; Hulten (2000). Other models of streaming random forests, such as those discussed in Abdulsalam (2008), build trees in sequence instead of in parallel, which reduces the total memory usage. Our algorithm makes use of a bounded fringe and adopts the technique of Domingos &amp; Hulten (2000) to control the policy for adding and removing leafs from the fringe.
 In each tree we partition the leafs into two sets: we have a set of active leafs, for which we collect split statistics as described in earlier sections, and a set of inactive leafs for which we store only two numbers. We call the set of active leafs the fringe of the tree, and describe a policy for controlling how inactive leafs are added to the fringe.
 In each inactive leaf A t we store the following two quantities  X   X  p ( A t ) which is an estimate of  X  ( A t ) = P ( X  X  A  X   X  e ( A t ) which is an estimate of e ( A ) = Both of these are estimated based on the estimation points which arrive in A t during its lifetime. From these two numbers we form the statistic  X  s ( A t ) =  X  p ( A t ) X  e ( A t ) (with corresponding true value s ( A p ( A t ) e ( A t )) which is an upper bound on the improve-ment in error rate that can be obtained by splitting A .
 Membership in the fringe is controlled by  X  s ( A t ). When a leaf is split it relinquishes its place in the fringe and the inactive leaf with the largest value of  X  s ( A t ) is cho-sen to take its place. The newly created leafs from the split are initially inactive and must compete with the other inactive leafs for entry into the fringe. Unlike Domingos &amp; Hulten (2000), who use this tech-nique only as a heuristic for managing memory use, we incorporate the memory management directly into our analysis. The analysis in Appendix B shows that our algorithm, including a limited size fringe, is consistent. In this section we state our main theoretical results and give an outline of the strategy for establishing consis-tency of our online random forest algorithm. In the interest of space and clarity we do not include proofs in this section. Unless otherwise noted, the proofs of all claims appear in Appendix B.
 We denote the tree partition created by our online ran-dom forest algorithm from t data points as g t . As t varies we obtain a sequence of classifiers, and we are interested in showing that the sequence { g t } is consis-tent, or more precisely that the probability of error of g converges in probability to the Bayes risk, i.e. as t  X   X  . Here ( X,Y ) is a random test point and Z denotes the randomness in the tree construction algo-rithm. D t is the training set (of size t ) and the proba-bility in the convergence is over the random selection of D t . The Bayes risk is the probability of error of the Bayes classifier, which is the classifier that makes predictions by choosing the class with the highest pos-terior probability, (where ties are broken in favour of the smaller index). The Bayes risk L ( g ) = L  X  is the minimum achievable risk of any classifier for the distribution of ( X,Y ). In order to ease notation, we drop the explicit dependence on D t in the remainder of this paper. More informa-tion about this setting can be found in Devroye et al. (1996).
 Our main result is the following theorem: Theorem 1. Suppose the distribution of X has a den-sity with respect to the Lebesgue measure and that this density is bounded from above and below. Then the online random forest classifier described in this paper is consistent.
 The first step in proving Theorem 1 is to show that the consistency of a voting classifier, such as a random for-est, follows from the consistency of the base classifiers. We prove the following proposition, which is a straight-forward generalization of a proposition from Biau et al. (2008), who prove the same result for two class ensem-bles.
 Proposition 2. Assume that the sequence { g t } of ran-domized classifiers is consistent for a certain distribu-tion of ( X,Y ) . Then the voting classifier, g ( M ) tained by taking the majority vote over M (not nec-essarily independent) copies of g t is also consistent. With Proposition 2 established, the remainder of the effort goes into proving the consistency of our tree con-struction.
 The first step is to separate the stream splitting ran-domness from the remaining randomness in the tree construction. We show that if a classifier is condition-ally consistent based on the outcome of some random variable, and the sampling process for this random variable generates acceptable values with probability 1, then the resulting classifier is unconditionally con-sistent.
 Proposition 3. Suppose { g t } is a sequence of classi-fiers whose probability of error converges conditionally in probability to the Bayes risk L  X  for a specified dis-tribution on ( X,Y ) , i.e.
 for all I  X  I and that  X  is a distribution on I . If  X  ( I ) = 1 then the probability of error converges un-conditionally in probability, i.e.
 In particular, { g t } is consistent for the specified distri-bution.
 Proposition 3 allows us to condition on the random variables { I t }  X  t =1 which partition the data stream into structure and estimation points in each tree. Provided that the random partitioning process produces accept-able sequences with probability 1, it is sufficient to show that the random tree classifier is consistent con-ditioned on such a sequence. In particular, in the re-mainder of the argument we assume that { I t }  X  t =1 is a fixed, deterministic sequence which assigns infinitely many points to each of the structure and estimation streams. We refer to such a sequence as a partitioning sequence .
 The reason this is useful is that conditioning on a par-titioning sequence breaks the dependence between the structure of the tree partition and the estimators in the leafs. This is a powerful tool because it gives us access to a class of consistency theorems which rely on this type of independence. However, before we are able to apply these theorems we must further reduce our problem to proving the consistency of estimators of the posterior distribution of each class.
 Proposition 4. Suppose we have regression esti-mates,  X  k t ( x ) , for each class posterior  X  k ( x ) = P ( Y = k | X = x ) , and that these estimates are each consistent. The classifier (where ties are broken in favour of the smaller index) is consistent for the corresponding multiclass classifi-cation problem.
 Proposition 4 allows us to reduce the consistency of the multiclass classifier to the problem of proving the consistency of several two class posterior estimates. Given a set of classes { 1 ,...,c } we can re-assign the labels using the map ( X,Y ) 7 X  ( X, I { Y = k } ) for any k  X  X  1 ,...,c } in order to get a two class problem where P ( Y = 1 | X = x ) in this new problem is equal to  X  k ( x ) in the original multiclass problem. Thus to prove con-sistency of the multiclass classifier it is enough to show that each of these two class posteriors is consistent. To this end we make use of the following theorem from De-vroye et al. (1996).
 Theorem 5. Consider a partitioning classification rule which builds a prediction  X  t ( x ) of  X  ( x ) = P ( Y = 1 | X = x ) by averaging the labels in each cell of the partition. If the labels of the voting points do not influence the structure of the partition then provided that 1. diam( A t ( X ))  X  0 in probability, 2. N e ( A t ( X ))  X  X  X  in probability.
 Proof. See Theorem 6.1 in Devroye et al. (1996). Here A t ( X ) refers to the cell of the tree partition con-taining a random test point X , and diam( A ) indicates the diameter of set A , which is defined as the maxi-mum distance between any two points falling in A , The quantity N e ( A t ( X )) is the number of points con-tributing to the estimation of the posterior at X . This theorem places two requirements on the cells of the partition. The first condition ensures that the cells are sufficiently small that small details of the posterior distribution can be represented. The second condition requires that the cells be large enough that we are able to obtain high quality estimates of the posterior probability in each cell.
 The leaf splitting mechanism described in Section 3.3 ensures that the second condition of Theorem 5 is sat-isfied. However, showing that our algorithm satisfies the first condition requires significantly more work. The chief difficulty lies in showing that every leaf of the tree will be split infinitely often in probability. Once this claim is established a relatively straightforward calculation shows that the expected size of each di-mension of a leaf is reduced each time it is split. So far we have described the approach to proving con-sistency of our algorithm with an unbounded fringe. If the tree is small (i.e. never has more leafs than the maximum fringe size) then the analysis is unchanged. However, since our trees are required to grow to un-bounded size this is not possible.
 In order to apply Theorem 5 in the case of an un-bounded fringe we have shown that every leaf will be split in finite time with arbitrarily high probability. To extend consistency to this setting we need only show that the probability of an inactive leaf not being acti-vated goes to zero as t  X   X  . This is sufficient, since once a leaf is activated it remains in the fringe until it is split and the argument from the unbounded fringe setting applies.
 In order to show that any leaf will be eventually added to the fringe, we consider an arbitrary leaf A and show that we can make the probability that  X  s ( A ) is not the largest  X  s ( A ) value among inactive leafs arbitrar-ily small by making t sufficiently large.
 These details are somewhat lengthy, so we refer the interested reader to Appendix B a full presentation, including proofs of the propositions stated in this sec-tion. In this section we demonstrate some empirical results in order to illustrate the properties of our algorithm. Code to reproduce all of the experiements in this sec-5.1. Advantage of a Forest Our first experiment demonstrates that although the individual trees are consistent classifiers, empirically the performance of the forest is significantly better than each of the trees for problems with finite data. We demonstrate this on a synthetic five class mixture of Gaussians problem with significant class overlap and variation in prior weights. For this experiment we used 100 trees and set  X  = 1, m = 10,  X  = 0 . 001,  X  ( d ) = 1 . 1 d ,  X  ( d ) = 1000  X  ( d ).
 From Figure 2 it is clear that the forest converges much more quickly than the individual trees. Result profiles of this kind are common in the boosting and random forests literature; however, in practice one often uses inconsistent base classifiers in the ensemble (e.g. boost-ing with decision stumps or random forests where the trees are grown to full size). This experiment demon-strates that although our base classifiers provably con-verge, empirically there is still a benefit from averaging in finite time. 5.2. Comparison to Offline In our second experiment, we demonstrate that our on-line algorithm is able to achieve similar performance to an offline implementation of random forests and also compare to an existing online random forests al-gorithm on a small non-synthetic problem.
 In particular, we demonstrate this on the USPS data set from the LibSVM repository (Chang &amp; Lin, 2011). We have chosen the USPS data for this experiment because it allows us to compare our results directly to those of Saffari et al. (2009), whose algorithm is very similar to our own. For both algorithms we use a forest of 100 trees. For our model we set  X  = 10, m = 10,  X  = 0 . 1,  X  ( d ) = 10(1 . 00001 d ) and  X  ( d ) = 10 4  X  ( d ). For the model of Saffari et al. (2009) we set the number of features and thresholds to sample at 10, the minimum information gain to 0.1 and the minimum number of samples to split at leaf at 50. We show results from both online algorithms with 15 passes through the data.
 Figure 3 shows that we are able to achieve performance very similar to the offline random forest on the full data. The performance we achieve is similar to the performance reported by Saffari et al. (2009) on this data set. 5.3. Microsoft Kinect For our final experiment we evaluate our online ran-dom forest algorithm on the challenging computer vi-sion problem of predicting human body part labels from a depth image. Our procedure closely follows the work of Shotton et al. (2011) which is used in the commercially successful Kinect system. Applying the same approach as Shotton et al. (2011), our online classifier predicts the body part label of a single pixel P in a depth image. To predict all the labels of a depth image, the classifier is applied to every pixel in parrallel.
 For our dataset, we generate pairs of 640x480 resolu-tion depth and body part images by rendering random poses from the CMU mocap dataset. The 19 body parts and one background class are represented by 20 unique color identifiers in the body part image. Figure 4 (left) visualizes the raw depth image, ground truth body part labels and body parts predicted by our clas-sifier for one pose. During training, we sample 50 pix-els without replacement for each body part class from each pose; thus, producing 1000 data points for each depth image. During testing we evaluate the predic-tion accuracy of all non background pixels as this pro-vides a more informative accuracy metric since most of the pixels are background and are relatively easy to predict. For this experiment we use a stream of 2000 poses for training and 500 poses for testing.
 Each node of each decision tree computes the depth difference between two pixels described by two off-sets from P (the pixel being classified). At training time, candidate pairs of offsets are sampled from a 2-dimensional Gaussian distributions with variance 75.0. The offsets are scaled by the depth of the pixel P to produce depth invariant features. Figure 4 (right) shows a candidate feature for the indicated pixel. The resulting feature value is the depth difference between the pixel in the red box and the pixel in the white box. In this experiment we construct a forest of 25 trees with 2000 candidate offsets (  X  ), 10 candidate splits ( m ) and a minimum information gain of 0.01 (  X  ). For Saffari et al. (2009) we set the number of sample points required to split to 25 and for our own algo-rithm we set  X  ( d ) = 25  X  (1 . 01 d ) and  X  ( d ) = 4  X   X  ( d ). With this parameter setting each active leaf stores 20  X  10  X  2000  X  2 = 400 , 000 statistics which requires 1.6MB of memory. By limiting the fringe to 1000 ac-tive leaves our algorithm requires 1.6GB of memory for leaf statistics. To limit the maximum memory used by Saffari et al. (2009) we set the maximum depth to 8 which uses up to 25  X  2 8 = 6400 active leaves which requires up to 10GB of memory for leaf statistics. Figure 5 shows that our algorithm achieves signifi-cantly better accuracy while requiring less memory. In this paper we described an algorithm for building online random forests and showed that our algorithm is consistent. To the best of our knowledge this is the first consistency result for online random forests. Growing trees online in the obvious way requires large amounts of memory, since the trees must be grown breadth first and each leaf must store are large num-ber of statistics in each of its potential children. We incorporated a memory management technique from Domingos &amp; Hulten (2000) in order to limit the num-ber of leafs in the fringe of the tree. This refinement is important, since it enables our algorithm to grow large trees. The analysis shows that our algorithm is still consistent with this refinement.
 The analysis we presented in this paper shows that our algorithm is consistent, but does not give rates of convergence to the Bayes risk. Analyzing the conver-gence rate of our algorithm is clear direction for future work, but the way to proceed does not appear to be straightforward.
 Finally, our current algorithm is restricted to axis aligned splits. Many implementations of random forests use more elaborate split shapes, such as random linear or quadratic combinations of features. These strategies can be highly effective in practice, especially in sparse or high dimensional settings. Understanding how to maintain consistency in these settings is an-other potentially interesting direction of inquiry. Some of the data used in this paper was obtained from mocap.cs.cmu.edu (funded by NSF EIA-0196217).

