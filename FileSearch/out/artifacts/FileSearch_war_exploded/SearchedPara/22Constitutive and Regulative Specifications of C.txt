 MATTEO BALDONI, CRISTINA BAROGLIO, ELISA MARENGO, and VIVIANA PATTI The term  X  X nteraction protocol X  refers to a pattern of behavior that allows a set of agents to become a MultiAgent System (MAS), by engaging expected cooperations. Particularly relevant are commitment protocols [Singh 2000; Yolum and Singh 2001; 2002]. Commitments are literals that can hold in the social state of the system, rep-resenting the fact that a debtor commits to a creditor to bring about some condition. All agents using a commitment protocol share the semantics of a set of actions which affect the social state. The greatest advantages of commitment protocols, with respect to other approaches to interaction, are that they do not overconstrain the specification by imposing unnecessary orderings on the execution of the shared actions, and that by giving a shared (i.e., public and agreed) meaning to the social actions, they allow working on actual knowledge rather than on beliefs about each others X  mental state, thus preserving the agents X  autonomy. Nonetheless, commitment protocols do not yet suit well those situations where the evolution of the social state is constrained by con-ventions, laws, preferences, or habits, because they do not allow the specification of legal patterns of interaction, although this kind of constraints makes sense in many practical situations, as noticed also in Singh and Chopra [2010].

In this work, we face this issue by adopting Searle X  X  [1969, 1995] distinction be-tween the constitutive and regulative specifications of interaction. Roughly speaking, constitutive rules, by identifying certain behaviors as foundational of a certain type of activity, create that activity. They do so by specifying the semantics of actions. Regula-tive rules, in contrast, contingently constrain a previously constituted activity. In other words, they rule the  X  X low of activity X , by capturing some important characteristics of how things should be carried on in specific contexts of interaction [Cherry 1973]. So, for instance, in the well-known contract-net protocol constitutive rules would be used to define the social meaning of the basic actions, like propose, reject, accept. On top of these it is possible to specify regulative rules, like the fact that proposals must follow a call-for-proposals, and that each proposal must be acknowledged with an accept or a reject. Notice that on top of the same basic actions it would be possible to specify other regulative rules, that may, for instance, correspond to variations of the contract-net protocol, fitting different contexts and needs. In these contexts, a proposal could, for instance, be considered even though no call was issued.

Given a domain, it is not easy to distinguish, in general, what is constitutive from what is regulative; this depends on the specific problem to be solved and on the abstrac-tion level that is required (analogously to what happens with the implementation of abstract data types) but once this has been defined, there is the need to represent both levels. A clear separation in such representation of the constitutive from the regulative specification would bring many advantages, mostly as direct effects of the obtained modularity: easier reuse of actions in different contexts, easier customization on the protocol, easier composition of protocols. As a consequence, MAS would gain greater openness, interoperability, and modularity of design. Interoperability would be better supported because it would be possible to verify it with respect to specific aspects (e.g., at the level of actions [Chopra and Singh 2008, 2009b; Chopra 2009] or at the level of regulation rules [Baldoni et al. 2011b]). Protocols would be more open in the sense that their modularity would allow designers to easily adapt them to different needs (see Section 4). Agents could also check individually (against the protocol specification) if they have actions that match with the constitutive rules independently from the regulative specification.

In the light of the distinction between constitutive and regulative rules, this work analyzes alternative proposals for the specification of interaction protocols based on commitments (Section 2), showing that, despite the fact that it is possible to recognize various attempts to capture both specifications, these proposals still miss the clear distinction postulated in Searle [1969] and Cherry [1973] and described earlier. We show that none allows the specification of both parts (1) in a decoupled way, (2) by means of first-class languages, (3) which allow flexible representations; either one of the two specifications is disregarded or it is too strict or the two representations are to some extent mixed. Section 3, then, proposes a model for commitment-based interac-tion protocols that separates the constitutive and the regulative parts. In particular, we extend commitment-based protocols, as proposed in Chopra and Singh [2008] and Chopra [2009], by adding to the constitutive specification of actions an explicit regula-tive specification, given as a set of constraints among commitments. For representing the regulative specification we propose the language 2CL , that allows the specification of different kinds of constraints. The language is characterized by a graphical nota-tion, aimed at supporting the designer in the specification of interaction protocols. It inherits from Pesic and van der Aalst [2006] andMontali et al. [2010] but it is very different from it in its basic principles. Indeed, 2CL builds on commitments, thus rul-ing the evolution of the social state, and not on events (actions). Section 4 shows how it is easy to tailor an interaction protocol, expressed in 2CL , to different contexts of use, by modifying the regulative specifications only. As a running example we chose the contract-net protocol (CNP) [Foundation for Intelligent Physical Agents 2002] but in Section 3.2 we also report a representation of a fragment of Robert X  X  Rules of Order, which is a more complex interaction protocol and, as such, helps at showing the use-fulness of a wider range of 2CL operators. In Section 5 we compare commitments and constraints for what concerns their use in the specification of regulative rules, with particular attention to the meaning of violation. In Section 6 we finish the comparison with the models in Section 2, showing that our proposal includes the others as a special case or overcomes their limits, and report the future directions of research. Let us consider commitment-based protocols. Commitments are directed from a debtor to a creditor. The notation C ( x , y , r , p ) denotes that agent x commits to an agent y to bring about consequent condition p when the antecedent condition r holds. In the special case when r equals true , we use the short notation C ( x social state that contains commitments and other literals that are relevant to their in-teraction. Every agent can affect the social state by executing actions, whose definition is given in terms of operations onto the social state (e.g., adding a new commitment, releasing another agent from some commitment, satisfying a commitment, etc.; see Yolum and Singh [2002]). On the other hand, the behavior of agents is affected by the commitments because the underlying assumption is that agents respect the commit-ments they have taken. In other words, commitments have a regulative nature.
Usually a commitment protocol is made of a set of actions, whose semantics is known to (and agreed upon by) all of the participants [Yolum and Singh 2002, 2001; Chopra 2009]. There are many definitions for actions in the literature. In UML and in the literature about workflows, actions are atomic executions. They are considered to take zero time, and cannot be interrupted, while activities represent more complex behaviors that may run for a long time, and may be interrupted by events. Most of works on agents adopt, instead, a precondition-effect view of actions. Preconditions can be of two kinds: preconditions to the action execution, and preconditions to some effect. The former are literals that must hold in the social state to make the action executable, the latter are additional conditions that, when holding, allow the production of the specific effect that they control. For instance, in order to pay by credit card it is necessary to own a credit card (precondition to the action). If a credit card owner uses it for paying, the payment will be done only if the card is valid (conditional effect). For example, in Chopra and Singh [2008] and Chopra [2009] actions have no preconditions of any kind, in Chopra and Singh [2006] and Kafali and Yolum [2009] actions have both preconditions to the executability and conditional effects, while Winikoff et al. [2005] use only preconditions to the execution of actions. Whatever representation is chosen, the protocol actions are specified by means of constitutive rules .

Commitments have a  X  X egulative X  nature in the sense that agents that take a com-mitment are bound to make the condition in the commitment become true, however, it is often necessary to specify patterns of interaction which require a degree of ex-pressiveness that, as we will show, commitments alone do not have. Contrarily to constitutive rules, which define new forms of behavior, these patterns regulate an-tecedently existing forms of behavior [Searle 1995]. Therefore, such rules regulate the social reality, defined by the constitutive rules. For this reason we refer to them as the  X  X egulative specification of the protocol X . For example, a purchase protocol may state that the payment must occur first in order for the shipment to proceed. By means of this rule, an agent whose goal is having the goods shipped would conclude that, in order to achieve its goal when interacting with partners that comply with this protocol, it must have the payment done first. A regulative specification may therefore be viewed as encoding a policy . Let us therefore overview the most relevant works in the context of commitment-based interaction protocols , with a particular focus on the way they specify regulative rules , in order to compare and discuss the proposed models, which are graphically summarized in Figure 1 and Figure 2.

Commitment-based protocols. Chopra and Singh [2008] introduce the distinction between constitutive and regulative specifications in the definition of commitment protocols but study in depth only the constitutive part. Each agent is publicly described by the effects of the actions it can execute (see preceding) which make the constitutive specification of the agent. Such specifications allow agents to agree on the meaning of their actions. This approach can be found also in Yolum and Singh [2002, 2001], Winikoff et al. [2005], Chopra and Singh [2006], Giordano et al. [2007], Chopra [2009], and El-Menshawy et al. [2010, 2011]. All these approaches do not account for regulative specifications, besides the one given by commitments. As a matter of fact, in this context, the flow can only be controlled by the preconditions to the (non-)executability of the actions, see Figure 1(a). So, in order to impose that sending goods should follow payment, the action send-goods should have as a precondition a literal that is made true as an effect of the action pay . This solution has two limits. The first, and most important one, is that it does not abide by the meaning of  X  X egulative X  rule, that is, to regulate antecedently existing forms of behavior. Preconditions are, in fact, part of the constitutive specification of the actions because they help defining the rules of the game and to specify the possibility of action [Conte 1983; Searle 1995; La Torre 2010; Grossi 2007]. Moreover, we can say that their use forces the regimentation of the regulation [Jones and Sergot 1994] because it is not possible to execute actions leading to violations. The adoption of regimentation, rather than enforcement, is, in our opinion, a choice that should be left up to the designer of the system and not be imposed by the specification framework [Grossi et al. 2007].
Preferences and dependencies. Mallya and Singh [2006], Figure 1(b), propose to order the possible executions according to a set of preferences that take into account the poli-cies of the various parties. No execution is strictly forbidden but a preference criterion is specified. The constitutive specification is given in terms of commitments but the preference rules are given in terms of actions. Preferences do not precisely correspond to regulative rules because they specify selection policies rather than defining what is allowed (or forbidden). For this reason they can be interpreted as guidelines. Never-theless, giving them in terms of actions makes the specification less flexible and less easily adaptable or open. The same limits, Figure 1(c), can be ascribed to the work to which Mallya and Singh [2006] is inspired, that is, Singh [2003], although in this work it is possible to recognize the introduction of a regulative specification, based on the before relation applied to events.

ConDec. Pesic and van der Aalst [2006], Figure 2(a), propose to use the declarative language ConDec for representing business processes. The approach does not build on commitments nor is set in the agents framework. In Montali [2010], Chesani et al. [2009] and Montali et al. [2010], the authors use this approach to specify interaction protocols and service choreographies. To this aim, they integrate ConDec with SCIFF thus giving a semantics to actions that is based on expectations [Alberti et al. 2004]. A ConDec process is defined by means of LTL temporal constraints. The operational se-mantics of a ConDec process is the B  X  uchi automaton that is obtained by translating the constraints, applying well-known algorithms from the field of model checking [Clarke and Peled 2001] and refined in Pesic et al. [2010]. The aim is to use the declarative approach to simplify the design of processes. The nature of the specification is consti-tutive because it defines a behavior rather than regulating an antecedently existing reality. The constitutive specification is given at two levels: the level of constraints that builds upon the level of the actions. Even in the case one uses the aforesaid model not just to design processes but with a regulative intent, other problems emerge, due to the fact that constraints are defined over actions (events); see Figure 2(a). This, in our opinion, clashes with the openness of MAS. Let us explain our view with an example. Let us suppose that payment should occur before sending the goods, and that the pro-tocol foresees the actions pay-by-credit-card and send-goods . Then, it will specify that pay-by-credit-card must occur before send-goods . Now, if a client arrives which can pay cash, it will not be in condition to take part in the interaction unless the specification is changed by adding a rule that says that paying cash should occur before sending the goods. This should be done even though the action has the same semantics of pay-by-credit-card in terms of commitments. The need of modifying the specification (even in the case when actions have the same semantics!) gives an undesired rigidity to the pro-tocol. Problems arise also in the case an agent can execute a sequence of actions which altogether implement one of those foreseen by the protocol. The fact that the specifica-tion is given in terms of actions implies that if an action name changes, one needs to revise the process definition as well. It is also easy to make mistakes by forgetting to update the specification when a new action is changed or when its semantics is changed. Fornara and Colombetti. Fornara [2003] and Fornara and Colombetti [2004a, 2004b], Figure 2(b), define a commitment-based semantics for the speech acts of agent commu-nication languages, like FIPA, and then use interaction diagrams to define the regu-lative specification. In this proposal, the social actions are represented by the speech acts and the constitutive specification is given in terms of commitments. The choice of relying on interaction diagrams is, however, very strong because it forces the ordering of action executions, losing, in our opinion, the flexibility aimed at by the adoption of commitments.

Summary. The distinction between a regulative and a constitutive specification is surely interesting but the current proposals show some limits in the realization of this model, each with its pros and cons. Fornara and Colombetti X  X  proposal is too rigid: the use of interaction diagrams conflicts with the desirable flexibility of commitments. In this respect, ConDec X  X  use of constraints is better: the declarative approach that is proposed is aligned with the declarative nature of commitments. The problem is that constraints are used with a constitutive and not with a regulative aim. In other words, the ConDec approach uses the constraints to define a process with its execution traces. Moreover, they are defined in terms of performing actions rather than of bringing about conditions. Chopra and Singh [2008] propose an implementation where the regulative specification is given on top of actions: while commitments are given on conditions and not on the actions that should bring them about, constraints are posed on the action execution, with the result that modularity is not obtained. The same holds for Winikoff et al. [2005], Giordano et al. [2007], Yolum and Singh [2002, 2001], Singh [2003], and El-Menshawy et al. [2010, 2011]. Our proposal (see Figure 3) aims at overcoming the listed limits. We extend commitment-based protocols by adding the possibility of defining expressive regulative specifications, that are not limited to commitments but that account for patterns of interaction. To this aim we propose the use of a declarative language, named 2CL , which allows the definition of constraints on the evolution of the social state. Such specifications preserve the flexibility that is typical of commitment protocols because, in general, they do not force agents to execute given paths but rather let them free to choose their courses of actions, as long as they respect the rules. 2CL constraints relate commitments and not actions/events. This modularity facilitates the design of interaction protocols because it allows for a separate specification of the actions and of the regulative part, once the vocabulary of terms (facts, commitments) that can appear in the social state is defined. It also facilitates the reuse of previously defined actions or regulations as long as the domain of discourse does not change. Regulations, in fact, are no longer hidden inside actions, and actions are no longer overspecified due to the need of including regulations in their preconditions. This is, for instance, useful in the case when a designer must tailor an interaction protocol to particular needs, a case that will be discussed in the following. Another characteristic of the proposed language is that it is a general tool that leaves the designer free to choose how to implement the specified regulations (e.g., by enforcement or by regimentation) rather than forcing him/her in any direction. In this work, we propose an approach to the definition of commitment-based interaction protocols which extends the classic approach, based on the constitutive specification of the meaning of the social actions, by adding a regulative specification which specifies the legal evolutions of the social state. Both are defined based on commitments.
Ro , F , A , C , where Ro is a set of roles identifying the interacting parties, F is a set of literals (including commitments) that can occur in the social state, A is a set of actions, and C is a set of constraints.

The set of social actions A , defined on F and on Ro , forms the constitutive specification of the protocol, while the set of constraints C , defined on F and on Ro too, forms the regulative specification of the protocol.

In the following, we use as a running example the well-known Contract-Net Protocol (CNP for short) [Foundation for Intelligent Physical Agents 2002]. Briefly, CNP includes two roles, the initiator ( i in the following) and the participant ( p ). The initiator calls for proposals. The participant may send a proposal or refuse to do it. When a proposal is received, the initiator may either reject or accept it. Notice that, for the sake of simplicity, we do not model the exchange of information concerning the proposal itself but only the interaction concerning the task assignment and solution. We report the CNP as represented according to our proposal, by giving its constitutive specification followed by its regulative specification.

Constitutive specification. For what concerns the constitutive specification of an ac-tion, we adopt the same representation as in Chopra [2009] and define its meaning in terms of how it affects the social state by adding or removing literals or by per-forming operations on the commitments (create, release, delete, etc.; see Singh [1999], Yolum and Singh [2001]). The constitutive specification follows the grammar given next, where the means construct amounts to a counts-as relation [Searle 1995; Jones and Sergot 1996].

Here protocolAction is the name of an interactive action of the protocol (not necessar-ily having the form of a communication or a message but possibly amounting to any ob-servable action); paramList denotes the possible parameter list of the action; Op is one of the operations on commitments; commitment is a commitment of form C ( x as specified in Section 2 (see also Chopra [2009, page 49]), where x and y are roles in Ro and r and p are formulas in disjunctive normal form of propositional literals in F ; and fact is a positive or negative proposition that does not concern commitments and which contributes to the social state (they are the conditions that are brought about; when necessary they are enriched by two parameters: the actor and the recipient).
As an example, let us consider the actions foreseen by CNP as expressed according to the preceding grammar. (a) send cfp ( i , p ) means CREATE ( C ( i , p , assigned task ( i (b) send proposal ( p , i ) means CREATE ( C ( p , i , sol (c) send refusal ( p , i ) means refused task ( p , i )  X  (d) send accept ( i , p ) means assigned task ( i , p ) (e) send reject ( i , p ) means rejected proposal ( i , p ) (f) send done ( p , i ) means sol v ed task ( p , i ) (g) send failure ( p , i ) means failed ( p , i )  X  DELETE
Since such definitions are quite straightforward, we get into the details of just a couple of them. The effect of action send cfp is to create the commitment C ( i assigned task ( i , p )). Intuitively, this commitment states the resolution of the initiator to assign a task to a participant because it needs someone to solve it. Indeed, during the execution the participant may refuse to solve the task or the initiator may reject a proposal because, for example, it is not convenient. The action send refusal ( p by which the participant refuses to solve a task, instead has as effect the action RELEASE ( C ( i , p , assigned task ( i , p ))), by which the participant releases the initiator from the commitment of assigning a task to it, and the fact refused task ( p meaning is clear.

Regulative specification. In order to represent the regulative specification, we pro-pose a declarative language named 2CL (the acronym stands for  X  X onstraints among Commitments Language X ). The language has also a graphical notation which is in-spired by ConDec [Pesic and van der Aalst 2006] and by Baldoni et al. [2011a]. By means of it, the designer can express many kinds of constraints describing the legal evolutions of the social state. As underlined in Pesic and van der Aalst [2006], Baldoni et al. [2011a], Montali [2010], constraint-based declarative representations provide ab-stractions which allow to explicitly capture what is mandatory and what is forbidden, without the need to express the set of possible executions extensionally. For this reason, models remain compact improving flexibility: they specify what is desired and unde-sired, leaving all that remains unconstrained. This is an advantage with respect to pro-cedural approaches, characterized by a prescriptive nature which requires the specifi-cation of all the allowed evolutions. It also accommodates naturally to the commitment-based approach, where a central issue is the respect of the agents X  autonomy. 2CL specifications follow the following grammar.
 C , see Definition. 3.1, is a set of constraints of the form AopB , where A and B are formulas of literals and op is one of the operators described shortly; literal can be either a commitment or a positive or negative proposition (where negation means that a certain literal does not hold in the social state).

The operators of 2CL are reported in Table I, together with their meaning. For each relation, there are two types of constraint: base and persistence . Constraints of type base express relations between the literals, saying what should become true in the social state and when. Constraints of type persistence capture the fact that a condition of interest should hold in all the traversed states, until another condition of interest becomes true. The graphical representation of the operators follows the lines of Pesic and van der Aalst [2006] and Baldoni et al. [2011a], therefore it respects a few conventions: single lines represent base operators, while triple lines represent persistence operators; the position of the dot intuitively denotes the occurrence of which condition activates the relation expressed by the constraint; arrows, when used, and their relative positions with respect to dots, denote the qualitative temporal nature of the constraint; negated operators are crossed by a line.

The proposed operators capture those kinds of constraints that the analysis of protocols like Contract Net, Net Bill [Baldoni et al. 2011b] and Robert X  X  Rules of Order [Baldoni et al. 2010b] (see Section 3.2) suggest being the most useful for the regulative specification of interaction protocols. Let us consider a few significant ones. Correlation (  X  ) is one of those operators expressing the fact that two conditions occur in a same execution. Specifically, the dot is on the left-hand side and this represents the fact that the constraint is triggered when the condition on that side becomes true. In this case, the execution is requested to contain some state in which also the condition on the right-hand side becomes true. The absence of arrows denotes that there is no requested temporal relation between this state and the former one. Therefore, in order for the execution to satisfy the constraint, the condition on the right-hand side may become true in the future or have been true in the past, or even in the same state as the one in which the left-hand side became true. The before (  X   X  temporal relation: in fact, an arrow appears at its rightmost end. Also the dot is at that end of the operator. This means that the constraint is triggered when, during an execution, the condition on the right-hand side of the constraint becomes true. Due to the temporal relation expressed by the arrow, the condition on the left-hand side must hold in some state of the same execution that precedes the former. The operator has two dots and one arrow: it captures a form of causality between the condition on the left-hand side and the one on the right-hand side, of the kind foreseen in Lamport [1978]. Negative constraints (e.g.,  X   X  ) denote evolutions of the social state that should be avoided. The meaning of the one used as an example is that when the condition on the left-hand side holds in some state of an execution, the other condition should not hold in any of its states. Persistence constraints denote conditions that hold along time. For instance, persistence response (  X   X   X   X  ) denotes the fact that the condition on the left-hand side should hold along all the states traversed by the execution from the state in which it becomes true through the state in which the condition on the right-hand side becomes true.
 The proposal corrects and extends some of the representation models discussed in Section 2. Specifically, we can model the regulative rules that Chopra and Singh [2006], as well as Giordano et al. [2007], Yolum and Singh [2001], and Winikoff et al. [2005], (which follow the same principles) represent by means of preconditions by introducing for each action a literal that is univocally associated to it, as an effect of the action, and, then, to define constraints (typically of kind premise ,  X  forcing the regimentation imposed when directly working on action preconditions. The use of constraints of kind premise also allows the designer to specify strict sequences of action, as in Fornara and Colombetti [2003, 2004a] and Fornara [2003]. Last but not the least, the proposal overcomes the limits of Pesic and van der Aalst [2006], Montali [2010], Chesani et al. [2009], and Montali et al. [2010] because it introduces a regulative specification that specifies the legal evolutions of the social state and does it at the level of commitments and not at the level of actions/events.

The operators can be used to write declarative constraints, which can also be given a graphical format, as in Figures 4 and 6. Here a rectangle denotes a conjunction of literals (commitments or facts) that can be in the social state; a 2CL operator connects different rectangles, hence defining a relation between the contents of the social state at different times. The related states do not need to be immediately subsequent. The set of all the relations specified by means of 2CL operators specifies how the social state is expected to evolve when the protocol is respected. The graphical notation also supplies elements for denoting conjunctions (circles), disjunctions (diamonds), and exclusive or X  X  (bordered diamonds, e.g., see Figure 4).

Going back to the Contract-Net Protocol example, the regulative rules can be specified as follows.
 c1: C ( i , p , assigned task ( i , p ))  X   X   X  C ( p , i , c2: C ( p , i , sol v ed task ( p , i ))  X   X   X  rejected proposal ( i c3: assigned task ( i , p )  X   X   X  sol v ed task ( p , i ) Figure 4 reports them as a graph; for the sake of readability, we omitted parameters of literals in the figures. The initiator declares its intention to assign a task (node n 1, C ( i , p , assigned task ( i , p ))). If this happens, afterwards the participant takes its decision and alternatively refuses or states its intention to solve the task. This is represented by the fact that the node n 1 is connected to the nodes n 2( C ( p The connector n 4 denotes the exclusive or of the two. The cause arrow the fact that when the initiator must assign a task, the participant necessarily has to either refuse the task or take the commitment to solve it. It is not obliged to take one of these two ways at the next step of its execution but sooner or later it is expected to do it. The specification foresees that the participant cannot take the initiative of proposing to solve a task (or of refusing to do something) if the initiator has not declared that there is a task to solve. This is the intuitive meaning of the circles at the two sides of the arrow c 1.

Notice that we have not mentioned which actions should be executed to change the social state. In this case, in fact, any action whose effect is compatible with the schema of evolution of the social state reported before is feasible (in the same way as it is not necessary, in commitment protocols, to say which action to take to satisfy a commitment). Notice, however, that the proposed approach can also capture the case in which it is necessary to achieve an effect by executing a specific action: this can be done by adding to the constitutive rule, that defines the action at issue, a literal that is univocally associated to it, as one of its effects, and then to define a proper constraint that uses this literal.

Moreover, the transition from one state to one of its next (with respect to the de-scription given by regulative specification) states may require the application of many actions (not necessarily one). The regulative specification does not give any procedure for achieving the social state change that it captures. In fact, constraints that define the legal evolutions of the social state are independent from the actions that are used by the agents. Both, however, are specified on top of the literals in the social state.
If the interaction continues because the participant has proposed to solve the task, the initiator must either reject the proposal or accept it and assign the task to the participant, which, in this case, is expected to execute it and to give back to the initiator an answer (the solution or the information that it has failed). The arrows in the graph between nodes n 2 and the alternative between n 5and n 6, on a side, and between n 6 and the alternative between n 8and n 9 are again causality operators. An interaction protocol specifies in a concise way a set of legal interactions. The in-teraction of a set of agents will be compliant to the protocol when all the commitments they have towards the others, and that are objectively inferrable from their observable behavior, are satisfied (as usual in the social approach), and the overall execution respects the constraints that make the regulative specification. For what concerns the formal semantics of the commitment-based protocols that were discussed in Section 2, some of them propose an operational semantics that relies on commitment machines to specify and execute protocols [Yolum and Singh 2002, 2001; Winikoff et al. 2005; Chopra and Singh 2006; Chopra 2009], some others, like Fornara and Colombetti [2004a, 2004b], use interaction diagrams, operationally specifying commitments as an abstract data type, and analying the commitment X  X  lifecycle as a trajectory in a suitable space. Other approaches rely on temporal logics to give a formal semantics to commitments and to the protocols defined upon them. Among these, Giordano et al. [2007] use DLTL, while Bentahar et al. [2009], El-Menshawy et al. [2010, 2011] adopt extensions of CTL*. Given the specification of a set of social actions, all these approaches allow the inference of those executions which are legal with respect to the protocol. Intuitively, the addition of a regulative specification by means of 2CL constraints restricts the set of acceptable executions.
 In particular, commitment machines [Yolum and Singh 2002] (later refined in Winikoff et al. [2005]) specify the possible states of an execution, the actions that are used for doing the transitions, and the possible final states of the protocol. The meaning associated with each state specifies which commitments are in force in that state, and the meaning associated with each action defines how the commitments are affected by the action, leading to a state change. Intuitively, commitment machines allow the formalization of legal executions by taking into account only the constitutive specification of the social actions. 2CL allows the expression of temporal constraints on execution paths. Since com-mitment machines express legal execution paths, temporal constraints can be used to restrict this set. A natural choice for formalizing such constraints is Linear Tem-poral Logic (LTL) [Emerson 1990], which includes temporal operators like next-time (  X  , the formula  X  holds in the immediately following state of the run), eventually (  X  ,  X  is guaranteed to eventually become true), always (  X  invariably true throughout a run), weak until (  X  U  X  , the formula  X  becomes true). This kind of logic allows the identification of those executions which satisfy the constraints of interest. We therefore introduce an LTL semantics to the operators of 2CL (Table II), formalizing the intuitive semantics given in Table I. In particular, the premise operator is the only one to express a temporal relation over subsequent states; for this reason the LTL formula is expressed by means of the LTL operator. Coexistence and cause , instead, derive respectively from correlation, and from before and response. Notice that the negated operators semantics (column 6) do not always correspond to the negation of the semantics of the corresponding positive operator (column 4). This is due to the intention of capturing the intuitive meaning of negations. We show this need by means of a couple of examples. For what concerns correlation, the negation of the formula in column 4, which is A because it says that A must hold sooner or later while B cannot hold. What we mean by negated coexistence, instead, is that if A becomes true then B must not occur in the execution. For completeness, the semantics of negated correlation is not equivalent to the semantics of A  X   X  X  B . For what concerns premise , by negating the semantics in column 4 we obtain ( B  X  X  A ) which says that B occurs in some state and A does not occur in the previous state. Instead, the intended meaning is that A does not have to hold in the states that precede those in which B holds (but B does not necessarily have to hold). Analogous considerations can be drawn for the other operators.

A legal execution of a commitment-based protocol, enriched by means of 2CL reg-ulative specifications, is an execution that is accepted by the commitment machine built upon the constitutive specification of the protocol, and that, when interpreted as a linear temporal model, satisfies the LTL formulas corresponding to the regulative specification of the protocol. Based on this characterization, it is possible to provide mechanisms for verifying that an agent is behaving in respect of the protocol. When this does not happen, we can say that a violation has occurred. So, if in a commitment-based protocol, made only of the constitutive specification of a set of actions, violations are de-tected only when in a final state a commitment remains unsatisfied, in our proposal we also detect violations during the execution, due to fact that a constraint is not respected. For what concerns the verification that a linear temporal model, corresponding to an execution, respects the 2CL constraints, one could envisage the use of model checking techniques, along the lines of what was done in a previous work [Baldoni et al. 2011a]. Let us now introduce a more complex and actually used interaction protocol (see also Pitt et al. [2006]), in order to test the effectiveness of the proposed specification: Robert X  X  Rules of Order (RONR for short [Robert et al. 2000]). RONR is a well-known regulation of the behavior to be followed by a democratic deliberative assembly, like the Parlia-ment, to discuss and decide about issues called motions . This protocol is interesting because not only does it specify the social actions but it also encompasses rules that govern the behavior of the assembly. Briefly, it states that before voting a motion, ev-erybody who wishes to speak must have the possibility of speaking; in order to speak it is necessary to have the floor, and it is not possible to speak while someone else is speaking. No limit is imposed on the duration of the discussion, and it is up to the chair to decide to whom to assign the floor. In the following we denote by c the chair of the assembly and by p a generic participant, P is the set of all the members of the assembly, and m is the discussed motion. This protocol will help at showing the usefulness of a wider range of 2CL operators.
 (a) motion ( c , m ) means  X  p (b) openDebate ( c , p , m ) means CREATE ( C ( c , p , assignFloor ( p (c) refuseFloor ( p , c , m ) means refusedFloor ( p , m ) (d) askFloor ( p , c , m ) means CREATE ( C ( p , c , discussed ( p (e) recognition ( c , p , m ) means assignFloor ( p , m ) (f) startT alk ( p , m ) means discussing ( p , m ) (g) stopTalk ( p , m ) means discussed ( p , m )  X  X  discussing ( p (h) timeOut ( c , p ) means discussed ( p , m )  X  X  discussing ( p (i) cf v ( c , m ) means cf v ( m ) (l) v ote ( p , m ) means v oted ( p , m ) All participants must be guaranteed to have the possibility to vote on the presented motion. To this aim, by action motion , the chair commits to each participant to let him/her vote on the motion, (a). These commitments will be discharged when the chair calls for votes, (i). The other actions are used in the discussion phase. For instance, the action askFloor is performed by one of the participants, who commits to discuss the motion, (d). This commitment is discharged by stopTalk , (g), which means that the participant has finished speaking and, for this reason, it loses the floor. The other actions are quite straightforward. Notice that, standing to the constitutive spec-ification only, actions could be executed in any order , so the constitutive specification is not sufficient to guarantee that all participants will have the possibility to discuss the presented motion and vote.
 The regulative rules of RONR can be specified in 2CL as follows. c1: C ( c , p , cf v ( m ))  X   X   X  C ( c , p , assignFloor ( p c2: C ( c , p , assignFloor ( p , m ))  X   X   X  c3: C ( p , c , discuss ( p , m ))  X   X   X  assignFloor ( p , c4: assignFloor ( p , m )  X   X   X   X  discussed ( p , m ) c5: assignFloor ( p , m )  X  discussing ( p , m ) c6: discussing ( p , m )  X   X  discussed ( p , m ) c7: discussed ( p , m )  X   X   X   X  assignFloor ( p , m ) c8: refusedFloor ( p , m ) OR discussed ( p , m )  X   X   X  cf c9: cf v ( m )  X   X  v oted ( p , m ) c10: assignFloor ( X , )  X   X   X   X   X  assignFloor ( Y , ) AND c1 , c2 , c3 (as well as, further shortly, c7 and c8 ) are again examples of use of the causes operator (  X   X   X  ): c1 states that if the chair committed to allow a participant to vote, then it must also commit to give that participant the floor; c2 that if the social state contains a commitment to assign the floor to a participant, that participant can alternatively commit to discuss or refuse to speak; c3 that if a participant committed to discuss a motion, sooner or later it will be given the floor. Instead, c4 ( persistence (persistence response): it states that when the floor is given to a participant, that participant will keep it until it will finish speaking. Constraint c5 ( two subsequent states, saying that the assignment of the floor is a premise to the discussion. Constraint c6 uses the response operator (  X   X  discuss a motion, sooner or later it has to finish. Constraint c7 ( a participant has finished speaking, then it will lose the floor; c8 (of the same kind) states that votes are to be called for only after each participant has either refused to speak or has already spoken. Let us recall, in fact, that the action motion creates a commitment of kind C ( c , p , cf v ( m )) for every participant. This is the reason why the call for votes can be done only after all of them have either spoken or refused to do it. Constraint c9 (  X   X  )usesthe before operator and states that voting can be done only after the proper call. Last but not the least constraint c10 ( negative operator : it states that the floor cannot be assigned to two participants at the same time. Figure 5 reports the same constraints as a graph.

RONR shows how in certain contexts the regulative specification of an interaction protocol is not just a guideline because it is fundamental in order to give guarantees to the participants. On the other hand, the protocol is flexible because, for instance, it does not specify a predefined number of rounds of discussion. A participant may raise his/her hand as many times as he/she wishes for obtaining the floor. This flexibility is maintained by the 2CL representation. In fact, the constraints do not specify a flow of action execution but rather, following the motto no flow in flow , they rule the evolution of the social state in a declarative way. Moreover, the language allows to easily modify the protocol so as to adapt it to different needs. For instance, by constraint c9 participants can abstain from voting. If one changes the constraint to would be expected to express his/her vote. Let us show the versatility of the proposed representation by showing how easy it is to vary a given protocol, by playing with its regulative specification separately from the constitutive specification of its actions. We show this by producing variations of the CNP which suit different needs. All the variations are produced by working exclusively on the regulative specification without modifying the constitutive specification. Of course, it is possible to do the opposite or to modify both parts if needed.

Lazy and zealous participant. The first two simple variants are obtained by changing a single arrow with another operator from Table II. With reference to Figure 6(a), if we substitute the cause relation in c 1witha before relation ( be obliged to answer with a proposal to the call of the initiator (it is allowed to have an unresponsive behavior). In constraints, the whole variant is as follows. c1: C ( i , p , assigned task ( i , p ))  X   X  C ( p , i , sol c2: C ( p , i , sol v ed task ( p , i ))  X   X   X  rejected proposal ( i c3: assigned task ( i , p )  X   X   X  sol v ed task ( p , i ) Instead, Figure 6(b), if one uses in c 1a response (  X   X  ) operator, the participant can also take the initiative to solve a task even though the initiator has not made any request (zealous participant), as happens in the case of advertisement, where a provider promotes its services. c1: C ( i , p , assigned task ( i , p ))  X   X  C ( p , i , sol c2: C ( p , i , sol v ed task ( p , i ))  X   X   X  rejected proposal ( i c3: assigned task ( i , p )  X   X   X  sol v ed task ( p , i ) These two variants correspond to protocols that differ from CNP but that can easily be obtained by working at the level of constraints among commitments, without modifying the constitutive specification.

CNP with anticipated failure. The next context that we consider is a call for bids, where an initiator publishes an open call, for example, in an official gazette, that does not require the subscribers to the gazette to answer. Figure 6(c) shows the new protocol: the fact that the participant is not obliged to send a bid is captured by the constraint c 1, which is a before (  X   X  ) instead of being a cause ( modified the CNP by changing the constraint c 3 in Figure 4, in order to capture the fact that a participant can notify a failure in the task solution also in the case in which the task has not been assigned to it yet but, for some reason, it has found out that it has become impossible for it to proceed with the solution, in case the task is assigned to it. Instead, it is not allowed to communicate the solution until the task is assigned to it. The new protocol can be obtained by modifying the regulative specification as in Figure 6(c). In rules, we have the following. c1: C ( i , p , assigned task ( i , p ))  X   X  C ( p , i , sol c2: C ( p , i , sol v ed task ( p , i ))  X   X   X  rejected proposal ( i c3: assigned task ( i , p )  X   X  sol v ed task ( p , i ) XOR c4: assigned task ( i , p )  X   X  sol v ed task ( p , i ) The changes concern the constraints after node n 6. In the new version, instead of having simply a cause constraint, we have a response (  X   X  straint because it does not forbid the alternatives specified by n 10 to hold before assigned task ( i , p ). For this reason, in order to enforce that the solution is commu-nicated only after the assignment, another constraint is to be added ( c 4). In this way, failure can be notified at any moment.

Soft CNP. The last example (Figure 6(d)) is a very soft interaction protocol that, differently than the previous ones, expresses just a few regulative constraints, leaving a much greater freedom of behavior to the initiator and to the participant. c1: C ( p , i , sol v ed task ( p , i ))  X   X  assigned task ( i c2: refused task ( p , i )  X   X   X  C ( p , i , sol v ed task ( p c3: rejected proposal ( i , p )  X   X   X  assigned task ( i , This example also shows the use of negative constraints. The only constraint that is imposed on the evolution of the social state is that a task cannot be assigned to a participant who has not yet committed to solve it. Moreover, there are two negative constraints (of kind  X   X   X  ) stating that proposal assignment and rejection are mutually exclusive ( c 3), and that the refusal of a task is mutually exclusive to the commitment to solve it ( c 2). So, for instance, a participant can express its intention to solve a task for which no call has been made, and it is also possible for it to give a solution before any assignment of the task has been made to it. On the other hand, the initiator can ignore the participant even though it has committed to solve the task by avoiding to answer to it. It can call for proposals even if it already has a commitment by the participant, and it can reject a participant even though it has not made any proposal. It is not even necessary that the initiator commits to assign the task. After the example and before the concluding remarks, this section discusses some rel-evant issues concerning the relation between commitments and constraints, including some considerations on the autonomy of the agents.

Can commitments substitute constraints? For what concerns whether constraints can be represented (and then substituted) by proper commitments, this is not possible because the expressive power of 2CL constraints and of commitments is different. Let us show this with the help of the CNP, used in Section 4, Figure 4. Here there is the need to express a temporal ordering between the assignment of a task to a participant and the fact that the participant has solved (or failed to solve) the task: the former condition is to be achieved first. The only way in which it is possible to express relations between conditions by means of commitments is by using a commitment of the kind By this commitment the participant p commits to the initiator i either to perform a given task or to declare that the task execution failed. Here xor denotes the logical connective. This is to be done conditioned to the fact that the initiator i assigned p the task at issue ( assigned task ( i , p )). Different evolutions of the interaction are allowed. In particular, if p happens to have solved the task before it is assigned to it, it can add to the social state sol v ed task ( p , i ) and the commitment is discharged. This means that the antecedent conditions (like assigned task ( i , p )) that are used inside commitments are not necessarily to be accomplished before the engagement to bring about the consequent conditions (like sol v ed task ( p , i ) xor failed ( p , be used to impose temporal orderings. Instead, constraints are specifically thought to express temporal relations. In the preceding case one could, for instance, specify (see also c 1 in Section 4) meaning that the two conditions are to be achieved sequentially.

Are there differences in the nature of engagements? Another important issue related to the (dis)similarities between constraints and commitments concerns the nature of the engagements that they represent. Ever since their introduction, commitments have been given an explicit normative nature [Castelfranchi 1995; Singh 1999]. Also con-straints the define the patterns of interaction of a protocol have a normative nature, in the sense that they represent what must hold in an execution for a protocol to be respected. Both constraints and commitments, due to their regulative nature, intro-duce a notion of violation . There are, however, some differences. An agent takes a commitment by autonomously deciding to execute an action, whose public and shared meaning includes that commitment. Afterwards, it is bound to make the condition in the commitment become true. As soon as the condition of the commitment is achieved, the commitment is discharged. The debtor paid its debt. On the other hand, an agent that accepts to interact according to a protocol accepts to stick to the patterns of inter-action that the protocol specifies. The agent is free to execute any action, as long as it respects the rules. While a commitment requires the debtor to satisfy it sooner or later, a constraint is to be respected for the whole interaction. A consequence of the different nature of commitments and of constraints concerns the time at which violations can be detected. Violations of commitments can be detected only at the end of the interaction: an ending state containing a commitment means that the debtor did not comply to what was expected from it. Violations to constraints, instead, can be detected during the interaction. A constraint is, in fact, like a boundary that should not be crossed.
So far, 2CL statements have not been given an explicit deontic semantics because in this stage of the work the focus was the identification of the most relevant kinds of constraints together with their intuitive semantics and with a formal characterization of it. We are currently working at a deontic characterization of the proposal that is based on dialectical commitments [Singh 2008]. These are similar in nature to the practical commitments used in this proposal because they have a regulative nature. However, they allow to express m aintenance, rather than achievement, as engagements as well as constraints do.

What about profiting of opportunities? The classical commitment-based approach is very respectful of the agents X  autonomy. Autonomy implies that each agent decides what is the best for itself. For this reason, protocols do not dictate agents when to execute specific actions. In particular, an agent can decide to take an opportunity, when one arises. This spirit is respected by our proposal, even though our protocols include a regulative specification which restricts the acceptable executions, because we do not regiment the regulative rules. An agent can always decide to break the rules if a situation it can take advantage of arises, although this amounts to a violation in our framework. Let us explain the meaning of opportunity, and the possibility to incur a violation, with the help of a simple example: suppose that at a summer school the official language everybody should speak is English. Every student at the school has a badge reporting the name and the nationality of the person. If a French attendee meets a colleague whose badge says she is from France, the first student might decide to speak in French with the other even though the official language she should speak is English. There is a clear expected advantage in doing so: a better understanding (see Figure 7). However, the violation of the rules of the protocol introduces a certain amount of risk. For example, if the second student by mistake took the badge of her roommate, she might not understand the former one because the protocol is not attended. This would not have happened if the first agent did not violate the rules.

Do one X  X  commitments commit others to commit? A final consideration concerns con-straints that relate commitments with different debtors, like, for instance, by which the commitment of the customer c to buy some goods ( C ( c , m , purchase ( goods ))) is to be followed by the commitment of the merchant m to sell the goods at some agreed price ( C ( m , c , sold ( goods , price ))). It may seem, in this case, that the autonomy of the merchant is reduced by the simple fact that another agent took some commitment, but it is not so. In fact, since constraints are supposed to be public and inspectable specifi-cations, an agent willing to play a role in a protocol has the means for understanding if that pattern of interaction meets its goals. By autonomously deciding whether to enter the protocol it, however, commits to respect its rules along the whole interaction. The fact that all agents accept to respect the rules has the advantage of making the course of interaction predictable and, therefore, of giving guarantees to all of the par-ticipants. In the example, the customer has the guarantee that the merchant will take the commitment to sell the goods after it commits to buy. Constitutive and regulative specifications have been recognized as fundamental com-ponents of the interaction based on communication starting from Searle [1969], Cherry [1973], and Searle [1995], and including various authors in the multiagent community, for example, Chopra and Singh [2008], Chopra [2009], Boella and van der Torre [2004], and Grossi [2007]. In this work we have presented a model of commitment-based inter-action protocols that includes an explicit representation of both constitutive and regu-lative specifications, and we have discussed its operational semantics. In particular, the model adopts an operational semantics of commitments, given by means of commitment machines, and adds to classical commitment-based protocols an explicit representation of articulated regulative specifications, expressed by means of constraints among commitments. In order to specify such constraints, we have proposed the language 2CL , which, from a graphical point of view, is inspired by Pesic and van der Aalst [2006] and Baldoni et al. [2011a]. The operators of 2CL have been formalized by means of LTL.

Other approaches, like Giordano et al. [2007], Singh [2008], Bentahar et al. [2009], and El-Menshawy et al. [2010, 2011], model commitments as modal connectors and ex-ploit semantic frameworks based on temporal logics. In particular, El-Menshawy et al. [2010, 2011] propose a branching-time logic that extends CTL*, named CTL main advantage of this approach stands in the fact that it supplies a logical seman-tics for the operations that are used to manipulate commitments. This approach was designed to perform verifications of agent interactions ruled by classical commitment-based protocols by exploiting symbolic model checking techniques. The properties that can be verified are inspired by the ones that are commonly checked in communica-tions protocols for distributed systems: fairness, safety, liveness, and reachability. As observed in Section 2, the regulative specification of the commitment-based protocols, used in these works, is limited to the use of commitments themselves. It would be inter-esting to integrate in this logical framework the 2CL constraints in order to combine the benefits of both approaches: on the one hand, the possibility to embed in the protocols expressive regulative specification, and, on the other hand, the possibility to exploit the logical framework to perform the listed verifications. Notice that this integration would be quite easy because the LTL meaning of 2CL constraints is preserved by a transformation in CTL*: it is sufficient to properly apply the universal path quantifier A to the formulas.
 An interesting connection can be observed between our proposal and the one in Marengo et al. [2011], where temporal regulations that capture a workflow of execution (defined on top of events) can be used as the antecedent or consequent conditions of commitments. This allows the reification of regulations into business relationships. The key difference is that while in our proposal constraints can be interpreted as maintenance engagements, in Marengo et al. [2011] workflows inside commitments amount to achievement engagements.

Commitment-based protocols, in general, can be seen as context dependent in that they allow the specification of the social meaning of any kind of action, not necessarily of communicative actions and not necessarily of standardized actions. Our proposal extends commitment-based protocols and for this reason it keeps the same generality. This characteristic is due to the fact that such protocols are thought as a  X  X tandard to define standards X . It does not prevent the use of standardized actions, when desired, but does not preclude the definition of other actions. Indeed, we agree with the claim made by Singh that  X  X c]ommunication is inherently sensitive to its social or organizational context. But context-sensitivity is at odds with standardization: how may we reconcile the two? I claim there cannot be a globally valid  X  X tandard X  definition of agent com-munication (AC) primitives. Researchers should give up looking for such definitions. Instead, I advocate a methodology by which a community of practice would create and maintain its own dialect. X  [Singh 2010]. The adaptation of commitment-based protocols to different contexts of use has been tackled in Chopra and Singh [2006]. The authors show how declarative approaches suit well this aim. Our proposal is set along this line. In fact, not only the constitutive rules are given in a declarative way but also the regu-lative specification is made of declarative constraints and it is possible to contextualize it by adding or removing constraints. The advantage with respect to Chopra and Singh [2006] is the modularity of the two specifications discussed along the paper.
For what concerns the future developments of this research, in Baldoni et al. [2010] we proposed to use our approach to protocol specification to give semantics to environments [Omicini et al. 2008]. The aim is to develop infrastructures that explicitly represent not only the agents but also the computational environment in terms of rules, conventions, resources, tools, and services that are functional to the coordination and cooperation of the agents. The inspiration is the MAS architecture sketched in Chopra and Singh [2009a], and the idea is to introduce also the possibility to detect violations as done in Electronic Institutions , like Esteva et al. [2004], Arcos et al. [2007], and Fornara et al. [2008], and in normative artifacts , like Dastani et al. [2008]. This latter proposal, as well as ours, is specifically designed to rule the observable behavior of agents but, differently than ours, the representation of norms takes into account the current state of execution only and, therefore, cannot express temporal relations like the ones that we have described. Along this line, another interesting proposal is made in H  X  ubner et al. [2010], where an organization is compiled into a normative system. Also this proposal is based on the use of computational environments, and exploits regimentation to implement the norms.

The new framework will enable the verification of interaction properties of MAS from the global point of view of the system as well as from the point of view of the single agents along the lines of the proposal in Baldoni et al. [2011b]. Specifically, we foresee three basic kinds of verifications: monitoring if the current executions comply with the constraints (or verifying if a recorded execution complies with the constraints); enabling agents to check whether their own procedures conform to the specifications, and whether playing according to the protocol rules will allow them to reach their goals; verifying properties of the interaction protocol itself. To these aims different techniques and tools could be used, ranging from model checking to theorem proving and to colored transition systems, as proposed in Sergot [2007]. For what concerns the third kind of verification, we can also envisage to study the possible uses of Normative Temporal Logic (NTL) [  X  Agotnes et al. 2007], a generalization of the branching-time temporal logic (CTL), where path quantifiers A and E are replaced by the deontic operators O  X  and P  X  respectively (the obligation and permission operators are applied to the normative system  X  ). NTL could, in fact, help to prove properties of a model of interaction as expressed in our proposal, where the set of possible executions is restricted according to specific regulations.

An approach similar to commitment-based protocols is the one introduced by Alberti et al. [2004], where expectation -based protocols are presented. Expectations concern events expected to happen (or not to happen) and can be associated to time points. Protocols are specified by constraining the times at which events occur. As for the pre-vious works, the limit of this approach is that it works directly on events (i.e., actions); by constraining actions the approach lacks the openness discussed in the Introduction and in the discussion about ConDec in Section 2. On the other hand, our proposal does not handle time explicitly so we cannot yet represent and handle timeouts and also compensation mechanisms. The aim of this article is, indeed, to present the idea of an explicit, declarative, and decoupled representation of both the constitutive and the reg-ulative specifications. We mean to tackle also issues concerning time, deadlines, faults and compensation, like in Torroni et al. [2010] (where commitments are implemented by means of expectations), in future work.

The work by Miller and McGinnis [2008] contains a comparison of various approaches to interaction protocols, including but not limited to commitment-based protocols. Specifically, also normative systems, algebraic and procedural approaches (like [Miller and McBurney 2008] and the seminal work in McBurney and Parsons [2002]), and Petri nets are considered. The comparison is done along many directions. The au-thors confirm our opinion that declarative approaches (like commitment-based ones) are very flexible. However, they claim that they are less readable (and sometimes more verbose) than algorithmic approaches. To support this consideration they cite some of the major existing tools for the designer (like AgentUML [FIPA Modeling TC 2007]), which are algorithmic. For verbosity, they cite the CNP representation in Alberti et al. [2004] which consists of seventeen rules. We underline that our regulative represen-tation of CNP consists instead of three rules only. The constitutive specification is made of seven rules (because there are seven actions). For what concerns commitment protocols, the difficulty in reading declarative specifications is, in our opinion, due to the lack of separation between the constitutive and the regulative specifications that many approaches show. Moreover, as van der Aalst et al. [2005] notice, there is a lack of graphical intuitive representations oriented to designers. We have tried to overcome these problems by decoupling the regulative and the constitutive specifications and by giving a graphical representation. This representation has the advantage of giving the perception of a flow in the execution, remaining however at a what rather than at a how level (we call this no-flow in-flow ). This representation also supports the compo-sitionality of the protocols. In fact, to put it simply, in order to produce a new protocol starting from existing ones, it is sufficient to draw together the sets of constraints of interest and produce a bigger graph without any effort. Protocols can then be designed bottom-up. We mean to study, as future work, a methodology that allows the achieve-ment of compositionality in declarative protocols. The intuition is that the decoupling of the regulative and constitutive specifications will facilitate the specification of a methodology.

