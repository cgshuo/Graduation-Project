 The Semantic Web is considered as the n ext-generation of the current Web, on which information is machine-understandable. The standard data model of the Semantic Web is the Resource Descr iption Framework (RDF) [1], which describes resources with triples of the form ( s, p, o )where s is the subject, p the predicate, and o the object. Since each triple stat es a relation from its subject to object, an RDF dataset, consisting of a set of triples, is represented as a directed labeled graph. Queries on RDF graphs belong to subgraph matching queries or path queries, rather than relational qu eries. Therefore, tr aditional RDBMS is not applicable for the management of large-scale RDF data. As a basic querying mechanism in RDF databases, RPQs are recognized as an essential operation to explore more complex relationship s between recourses in RDF graphs. In particular, researchers in some areas tha t have been equipped with relatively rich RDF datasets, such as bioinformatics [2] and social networking [3], have tried to use different forms of RPQs to gain new knowledge from large RDF graphs. In addition, as the current standard query language for RDF, SPARQL 1.1 [4] has introduced a new feature called property paths to realize the functionality of RPQs. Therefore, the efficiency of evaluating RPQs on large RDF graphs is of great importance.

Mendelzon and Wood [5] have proven that the evaluation of RPQs by simple paths on graph is NP-complete, which indicates regular path queries have a high complexity. In addition, the RDF graphs have proliferated significantly with the development of Linked Data [6], which posed serious challenges to graph data management. As a consequence, traditional methods based on triple indexes and sort-merge joins, which need to load large amounts of triples into memory, exhibit low performance and cannot be adapted to the big data scenario.
In this paper, we propose an efficient method for answering RPQs on large-scale RDF data. The contributions of our paper are summarized as follows:  X  We devise a double-layer bi-directional index structure that covers all regular  X  Based on this index structure, we propose a novel traversal-based algorithm,  X  We perform extensive experiments to evaluate and compare the performance The rest of the paper is organized as follows. After a review of related work in Section 2, we introduce the necessary definitions and formalize the RPQ problem in Section 3. In Section 4, we present the double-layer bi-directional index struc-ture that covers all regular path querie s and has a linear space complexity. In Section 5, we describe our algorithms which traverse RDF graphs bi-directionally in parallel. In Section 6 we evaluate our work by a series of experiments. Finally, we conclude the paper in Section 7. We focus on regular path queries on lar ge-scale RDF graphs and review related work from two aspects separately, i.e., RDF indexes and approaches to RPQs.
Indexes for RDF data can be divided into two categories, B + -tree-based in-dexes and Bigtable-based indexes. RDF-3X [7] introduces the concept of sextuple indexing based on B + -tree, and processes triple pattern queries efficiently. How-ever, RDF-3X also employees the multi-w ay join operations to implement more complex SPARQL queries, which may incur the high time overhead due to the large number of intermediate results. CumulusRDF [8] and Jingwei+ [9] both implement triple indexes based upon Bigtable, but their performance is lim-ited since the mechanism of the super-column may reduce the efficiency of the operations on triple indexes.

SPARQL is the W3C recommended query language for RDF. However, the functionality of RPQs has not been proposed until the property paths are in-troduced in SPARQL 1.1. In the past few years, researchers had concentrated on studying SPARQL including implementations, speeding up queries, and ex-tensions to support RPQs. Sesame and Jena are two state-of-the-art single-machine implementations of SPARQL, while they provide weak support for RPQs. PSPARQL [10] is an RPQ extension to SPARQL, but it does not pro-vide the implementation method for the language. SPARQLeR [11] also extends SPARQL with regular paths, and Koschmieder and Leser [12] propose to use rare labels for answering RPQs. However, both of these approaches are imple-mented as a bi-directional breadth-first search, which is obviously different from our approach. Besides, both approaches employ the counting paths semantics that has a PSPACE complexity.

Our approach differs from the above work significantly. On one hand, we use the flat structure to construct indexes on Bigtable, which achieves both high performance and scalability. The double-layer bi-directional index structure is built specifically for RPQs, which has superior performance for joining triples. On the other hand, our approach to answering RPQs is implemented as a depth-first search that has the tremendous performance advantages for finding paths on large-scale RDF graphs. In addition, we simplify the problem by restricting the semantics of queries, which can be tackled in polynomial time. Before introducing our work in detail, we give several definitions of RDF graphs, in/out-degree nodes of a predicate, and the syntax of our RPQ language. In this paper, we define an RDF graph as a set of triples that can be mapped to a general graph of the form G =( V,E ).
 Definition 1. An RDF graph is defined as T = { ( s, p, o ) | s  X  S, p  X  P,o  X  O } , in which we define the set of subjects as S = { s | s = lab ( v ) ,v  X  V,  X  v i  X  V, v,v i  X  E } , the set of predicates as P = { p | p = lab ( v i ,v j ) ,  X  v i ,v j  X  V, v i ,v j  X  E } and the set of objects as O = { o | o = lab ( v ) ,v  X  V,  X  v i  X  V, v i ,v  X  E } . lab () is the function that returns the label of a vertex or an edge.
Definition 1 describes the logical model of an RDF graph that differs from a general graph. If we define an RDF graph in the form of both T and G ,the but | E | | P | , since a subject s or an object o of a triple in T corresponds to a unique label of a vertex in G , while a predicate p may correspond to more than one edges in G .

In an RDF graph, a path is composed of consecutive edges, each edge is represented as a triple ( s, p, o ). If we consider the predicate p as a vertex, then it has both in-degree (subjects) nodes and out-degree (objects) nodes. Definition 2. We define in-degree subjects PS p = { s | X  s  X  S,  X  o  X  O, ( s, p ,o )  X  T } , in-degree subjects with specified object POS p o = { s | X  s  X  S, ( s, p ,o )  X  T } , out-degree objects PO objects with specified subject PSO p s = { o | X  o  X  O, ( s ,p ,o )  X  T } .
The formulas in Definition 2 describe the in/out-degree nodes of a specified predicate p , from which we obtain: (1) For a predicate p  X  P , PSO p s , POS p o , PS p and PO p are all not empty, iff  X  s  X  S,  X  o  X  O, ( s, p ,o )  X  T ;(2) POS p o  X  PS p , PSO p s  X  PO p ;and(3) POS p o = PS p ,iff PO p = { o } , and similarly, PSO p s = PO p ,iff PS p = { s } .
 Definition 3. The regular expression of path queries is defined as: r = p |  X  r | ( r/r ) | ( r | r ) | r  X  , p  X  P .WedefinethesyntaxofourRPQqueriesas respectively.

Definition 3 gives a recursive definition to the regular paths, which covers all the possible forms of RPQs. However, the complexity of RPQs with counting paths semantics is PSPACE-complete [5], which is considered infeasible for large-scale RDF graphs. To simplify the problem, in our RPQ semantics, we just find one satisfiable path for an RPQ (i.e., not counting paths), and we also allow non-simple paths as the answers. Definition 3 also introduces the syntax of our RPQ language. For example, if Tom wants to find that whether there exists a person who is a friend of his friends and that person also has a pet, then the query is expressed as: ( Tom, isFriend/isFriend/hasPet, ? y ). This section presents the double-layer bi-directional index structure that is ab-breviated as DB-Index. First we give a detailed introduction to DB-Index. Then we describe the procedure for the index construction. 4.1 DB-Index Definition 2 describes our new perspect ive of the primitive path edge. Under normal circumstances, there is no need to specify the in/out-degree nodes, while in the context of big data, the scale of triples under the same predicate p might be extremely large. Therefore, we speci fy these nodes and separate them into smaller units, which is also called the subject/object refinement. However, for a triple in RPQs, we do not know s or o in most cases, as a consequence, POS po and PSO ps do not seem to work. For example, we want to access all objects in PSO ps , but we get nothing if only p is specified.

To compensate for this defect, we define PS p and PO p to co-work with POS po and PSO ps . As a matter of fact, DB-Index is constructed on the basis of the formulas in Definition 3, in which we regard POS po and PSO ps as primary indexes, PS p and PO p as secondary indexes. The structure of DB-Index is shown in Fig. 1, of which the space complexity is O ( | T | ), and | T | is the size of the RDF graph T . We separate RPQs into atomic units, as mentioned before, which is the predicates of RPQs are never varia bles, as a consequence, there are four possibilities for a primitive edge of RPQs (? s | s, p, ? o | o ), all of which DB-Index covers. For example, ( s, p, ? o ) can be obtained by PSO ps ,(? s, p, o )by POS po , and (? s, p, ? o )by PSO ps with PS p . There is no need to query ( s, p, o ), since we have already obtained all terms of this triple. However, RPQs are much more complex than triple pattern queries, an d later in Section 5, we will present the algorithms.
 4.2 Index Construction In order to construct DB-Index, for each triple ( s, p, o )  X  T , s is inserted into POS po and PS p , o into PSO ps and PO p , as demonstrated in Fig. 1 and Algo-rithm 1. If s already exists in POS po and PS p , we skip this step, the same as o . The complexity of Algorithm 1 is O ( | T | ), in which | T | is the size of the RDF graph T . As shown in Fig. 1, we ensure the indexes are ordered by inserting elements into the appropriate positions, which are to be used in the sort-merge join operations.
 Algorithm 1. Constructing DB-Index In this section, we introduce a series of maintenance algorithms, called TraPath, which are based upon DB-Index, which is composed of three parts, the traversal-based search algorithm, the parallel evaluation algorithm and the scheduling al-gorithm. First, we present the traversal-based search algorithm, which is the core algorithm of this paper. Then, we introduce the parallel evaluation algorithm that accelerates our query. Finally, we d escribe the scheduling algorithm. The following theorems lay the theoretical foundation for the TraPath algorithms. Theorem 1. For two arbitrary edges p 1 ,p 2  X  P . There exists a path on them, Proof. There exists a path on two arbitrary edges, iff there exist a common vertex between them, i.e., the union of out-degree objects of p 1 and in-degree subjects of p 2 is not an empty set.
 Theorem 2. For two arbitrary edges p 1 ,p 2  X  P ,thein-degreeof p 1 is specified with s . There exists a path on them, if  X  e  X  PSO p 1 s , s.t PSO p 2 e =  X  . Proof. If PSO p 2 e =  X  ,then  X  ( e, p 2 ,o )  X  T , e  X  PS p 2 ,weknow PSO p 1 s  X  PO p 1 ,and e  X  PSO p 1 s ,then e  X  PO p 1 obviously. PO p 1  X  PS p 2 =  X  , according to Theorem 1, we have a path on p 1 and p 2 .
 The traversal-based search is devised on the basis of Theorem 2, and Theorem 1 plays an important role in the parallel evaluation algorithm. 5.1 Traversal Based Search The traversal based search algorithm (abbreviated as TBS) takes advantage of the depth-first traversal on the basis of Theorem 2, in which nested-loops join is used to bridge various edges. For each st ep of TBS of a forward search, two terms ofthetripleareknownofwhichtheformis( s, p, ? o ). s is obtained in different ways, from the previous step, PS p , or specified by users. We access objects from PSO ps , and then push an o into the next step, in which o is treated as s ,and PSO p s is invoked again with the next predicate p . We save the intermediate state, and push a next o if nothing obtained from PSO p s . The algorithm prints a result when a path is found, and exits when all elements of PSO ps have been traversed, in which p is the label of the first edge of RPQs.

The pseudo code of the traversal based search is shown in Algorithm 2, in which we traverse recursively on an RDF graph. The stacks are chosen to store regular path expressions due to their belonging to sequential sets. Line 4-8 makes it possible for us to search bi-directionally. For each step, the algorithm traverses once at least, and | list | times in the worse case. If we traverse | r | steps, then the complexity of Algorithm 1 is O ( n | r | ), where n is the max size of PSO ps or
Sort-merge joins can be also taken into account in the TBS. For example, there are two sequential predicates p 1 and p 2 , as described in Theorem 1, PO p 1 Algorithm 2. Traversal based search is joined with PS p 2 . This the complexity of TBS is O ( m + n ), which is better than the nested-loop join X  X  O ( m  X  n ). However, for a predicate p in a large-scale RDF graph T ,thesizeof PS p appears to be extremely large. All of the terms in both PO p 1 and PS p 2 need to be loaded into the memory, which exhibits a inferior performance. Our investigation and analysis of the real-world RDF graph, which will be introduced in detail in Section 6, indicates | PSO ps | | PS p | for the same predicate p and arbitrary s . As a consequence, for both methods of constituting a path as represented in Theorem 1 and 2, nested-loops join achieves superior performance than sort-merge join on large-scale RDF graphs, which prompts us to choose the nested-loops join as our basic method. 5.2 Parallel Evaluation The parallel evaluation algorithm parallelizes TBS to expedite the execution by separating paths. In the parallel evaluation process, there are several threads to process sub-paths invoking the TBS algorithm, cooperating with the mas-ter thread to collect partial results and bridge them together. For each TBS, counting paths are printed into the resu lt queues, nevertheless, we search for an existing path in the master. Algorithm 3 and 4 gives the pseudo code of our parallelization strategies. Each subPathProcessor processes a sub-path on the basis of TBS, the pathGenerator gathers partial resul ts and generates the path matching the regular expression r .Thecomplexityof pathGenerator is O ( m  X  n ), in which m is the max size of Queue [ i ]. The pathGenerator achieves superior performance, on one hand, the max | Queue [ i ] | could be quite small if the path is divided appropriately, on the other hand, pathGenerator starts with subPathProcessors simultaneously, which means they work in parallel. Algorithm 3. Parallel producer Algorithm 4. Parallel comsumer
Here we have a trade-off between parallel algorithms with higher complexity and serial algorithms with lower complexity. We choose the former since parallel algorithms cannot only withstand the pressure of large-scale data, but also have a good scalability, of which we could take advantage to expand our index and algorithm schemes. 5.3 Scheduling The parallel evaluation algorithm only works when no starting or ending node is initialized, of which the query expression is (? x, r, ? y ). It is worth mentioning that, if s or o is specified by users, it is more efficient to invoke the TBS algorithm directly. Therefore, the algorithms need to be scheduled in accordance to the form of the query syntax. The pseudo code of the scheduling algorithm is shown in Algorithm 5, which schedules different algorithms under various conditions. Algorithm 5. Scheduling 5.4 Alternation and Kleene Star The alternation and Kleene star operators with the existing path semantics can be both transformed to the basic paths of which the regular expressions are of the forms r = p | ( r/r ). We search an alternation path by permutation and combination. For example, for a query Q =(? s, ( p 1 | p 2 ) /p 3 , ? o ), the path p /p 3 and p 2 /p 3 are both taken into account. Fo r a path contains a Kleene star, the search begins with an empty path of the Kleene star, extends the path by repeating predicates, and ends with either a path obtained or no path found with a circle formed. In this section, we carry out a series of ex periments to evaluate our index struc-tures and algorithms. All experiments are conducted on a Dell OptiPlex 990 PC with a 3.10 GHz Intel i5-2400 quad-core CPU. We use Cassandra 1.1.6 as our underlying repository, and implement the algorithms with Java.
 6.1 Storage Performance We estimate the storage performance from two aspects including execution time of data loading and size of index structures, and use Lehigh University Bench-mark (LUBM) as the datasets of our storage performance experiments.

The Sesame repository can be deployed only in a stand-alone environment, for the sake of fairness, we load data in a single node to compare with Sesame. As shown in Fig. 2, our approach and Sesame are equally matched in terms of loading performance. Fig. 3 displays the size of our index structure and Sesame. The space of primary indexes is larger relatively, which carries most of the infor-mation of paths. As speculated, the storage performance experiments indicates that DB-Index has a linear space complexity.
 6.2 Query Performance We use DBpedia 3.6 as the dataset for quer y performance experiments since it is a real-world RDF data extracted from Wikipedia. For the in-depth understand-ing of the internal structure of DBpedia, we have analysed the experimental dataset, and the in/out-degree size distribution of predicates is demonstrated in Fig. 4. As is shown in the figure, the sizes of primary indexes mostly distribute in the range of e 0 to e 2 . It means almost all of POS po and PSO ps have a small size, which verifies our assumption. If we describe an instance with RDF triples as the form ( s, p, ? o ), there will not be too many objects. For example, if we have aquery( Aristotle, name, ? o ), and we can only obtain one object, since Aristotle has only one name. It is similar that we change the predicate as long as the subject is specified. As opposed to the primary indexes, the sizes of secondary indexes distribute more evenly, from e 0 to e 12 , which signifies that a lot of PS p and PO p have a large scale. For the above example, if we replace Aristotle with a variable, then the query becomes (? s, name, ? o ), and PS name is extremely large, since almost all of the instances in DBpedia have the predicate name .
We have devised several RPQ test cases, among which Q 2 is generated by random walking, Q 3 by predicates random selectin g, and the rest by artificial design. As shown in Table 1, Q 2 , Q 4 and Q 6 have the specified in/out-degree node, Q 4 -Q 6 belong to long paths. As mentioned before, the Sesame repository provides weak support for RPQs, for the fairness of the evaluations, we apply long paths instead of Kleene star.

We have implemented TraPath based upon DB-Index, in which there are two subPathProcessor s. For the purpose of comparison, we have removed the parallel algorithms so that there is only a serial algorithm with TBS. Besides, we have deployed Sesame 2.6.0 with its own native repository in our experimental environment. The experimental resul ts are shown in Fig. 5. As shown in the figure, our parallel approach exhibits better performance than Sesame, especially for longer RPQ paths. In this paper, we devise a double-layer bi-directional index structure, called DB-Index, which covers all possible forms of RPQs, and propose a novel traversal-based algorithm, named TraPath, which achieves the efficient execution of RPQs on large-scale RDF graphs by using the DB-Index. The experiment results show that DB-Index has a linear complexity and TraPath outperforms the state-of-the-art methods.
 Acknowledgments. This work is supported by the National Natural Science Foundation of China (Grant No. 61100049, 61373165) and the National High-tech R&amp;D Program of China (863 Program) (Grant No. 2013AA013204).
