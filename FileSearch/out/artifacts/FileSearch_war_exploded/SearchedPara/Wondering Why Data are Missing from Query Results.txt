 In analyzing and debugging data transformations, or more specif-ically relational queries, a subproblem is to understand why some data are not part of the query result. This problem has recently been addressed from different perspectives for various fragments of relational queries. The different perspectives yield different, yet complementary explanations of such missing-answers .

This paper first aims at unifying the different approaches by defin-ing a new type of explanation, called hybrid explanation, that en-compasses the variety of previously defined types of explanations. This solution goes beyond simply forming the union of explana-tions produced by different algorithms and is shown to be able to explain a larger set of missing-answers. Second, we present Con-seil , an algorithm to generate hybrid explanations. Conseil is also the first algorithm to handle non-monotonic queries. Experiments on efficiency and explanation quality show that Conseil is compa-rable to and even outperforms previous algorithms.
 H.4 [ Information Systems Applications ]: Miscellaneous Algorithms why-not data provenance, query-analysis
In designing data transformations, e.g., for data integration tasks, developers often face the problem that they cannot properly inspect or debug the individual steps of their transformation specification, which is commonly specified declaratively. Instead, when observ-ing result data that do not match their expectation, developers man-ually search for the reason for the unexpected behavior.
One important sub-problem in this context is the explanation of missing-answers , i.e., data missing from the query result (al-though the developer expected it). Recently, approaches to ex-plain missing-answers of relational and SQL queries have been pro-posed. These approaches generate either instance-based explana-tions [12, 13], query-based explanations [4], or modification-based explanations [18], which we illustrated by the following example. E XAMPLE 1. Fig. 1 shows an SQL query and sample input data. We assume ProdID is a primary key in Products .

Assume the tuple  X  P1, Car, v 1  X  is not in the query result, al-though the developer or an analyst expected it to be. Here, a variable standing for  X  X ould be any value X . An instance-based explanation for this missing-answer may indicate that the maxi-mum rating of the product with ProdID = P1 exceeds 2, i.e., Ratings  X  X rongly X  includes one or more tuples of the form  X  P1, v v 2 is a variable value that is required to be above 2 (in denot-ing such conditional tuples in the future, we will add the condi-tion as last attribute, e.g.,  X  P1, v 2 , v 2 &gt; 2  X  ). A query-based ex-planation may identify that, although the product exists in Prod-ucts together with corresponding ratings in Ratings , the selection predicate MAX(R.Rating)  X  2 is responsible for filtering the missing-answer. Finally, a modification-based explanation modifies the query such that the tuple appears in the result, e.g., it may raise the selec-tivity of the selection by changing it to MAX(R.Rating) &lt; =
Unfortunately, it is not guaranteed that, given a missing-answer, an algorithm finds an explanation. As the next example shows, it is even possible that no explanation of any type is returned.
E XAMPLE 2. Continuing our example, no explanation can be computed for the missing-answer  X  P3, Bus, 0  X  . Indeed, an instance-based explanation would have to insert tuple  X  P3, Bus, US Products (in addition to inserting the missing rating), which is how-ever not possible due to the constraint on ProdID [12, 13] 1 . Due to the lack of a rating of 0 in Ratings , neither a query-based expla-nation nor a modification-based explanation will be computed by state-of-the-art algorithms [4, 18] that assume the existence of data necessary to produce the missing-answer in the source tables.
Ideally, an explanation pointing out both the problem of miss-ing source data and the problem of problematic query operators would help a developer in analyzing the query in the above exam-ple. Therefore, we introduce a novel type of explanation that com-bines existing types of explanations and produces an explanation even in cases where no other individual approach produces a result. We refer to this new type of explanation as hybrid explanation . clude this solution by enforcing a trust constraint [13].
E XAMPLE 3. In the scenario of Ex. 2, a possible hybrid expla-nation inserts a tuple  X  P3, 0  X  into Ratings so as to fulfill the join with the existing tuple in Products . In addition, it points out that this combination of source data does not make it to the result be-cause of the selection predicate on location.
 To generate hybrid explanations, we present the Conseil algorithm. More specifically, we provide a formal definition of hybrid ex-planations and extend definitions of other types of explanations to also support non-monotonic queries. We also present the seil algorithm that computes hybrid explanations for a restricted class of non-monotonic queries and experimentally compare it to state-of-the art algorithms.
 In the rest of this paper, we first analyze related work in Sec. 2. Next, we formalize our framework to compute hybrid explanations in Sec. 3. Sec. 4 focuses on the Conseil algorithm, which is evalu-ated in Sec. 5 before we conclude in Sec. 6. A long version of this paper is available at http://nautilus.saclay.inria.fr/publications.
The problem of simplifying the analysis of the behavior of data transformations to more easily understand and verify transforma-tion behavior and semantics has been addressed by a variety of techniques [5, 9, 7, 11, 15, 17]. The work presented in this paper falls in the category of data provenance research [5], focusing on a specific sub-problem referred to as why-not provenance [4, 16]. We briefly review existing approaches for why-not provenance.
The Missing-Answers (MA) algorithm [13] computes instance-based explanations given a single missing tuple and a single select-project-join (SPJ) query. Essentially, it rewrites the SPJ query such that the result of the rewritten query corresponds to all possible instance-based explanations for the specified missing-answer. Instance-based explanations either insert or update the source data, and their number can be reduced by trusting tables (attributes), which pre-vents inserts (updates) on these.

Artemis [12] extends the MA algorithm in the sense that it ap-plies to a set of non-nested SQL queries that involve selection, pro-jection, join, union, and aggregation (SPJUA queries). Further-more, more than one missing-answer can be specified. Artemis also considers explanation side-effects for pruning explanations. A side-effect is any tuple that, upon changing the source data accord-ing to an instance-based explanation, appears in the result of any considered query in addition to the specified missing-answer.
Why-Not [4] computes query-based explanations. First, given a missing-answer, it identifies tuples in the source database that con-tain the constant values or that satisfy the conditions of the missing-answer and that are not part of the lineage [6] of any tuple in the query result. The values in those tuples are traced over the query operators to identify which operators have them as input but not as output. In [4] the algorithm is shown to work for one query involv-ing selection, projection, join, and union (SPJU query).
ConQueR [18], outputs modification-based explanations. Given a set of missing-answers, an SPJUA query, and a source database, it first determines if the necessary source data to produce the missing-answers are available. This is similar to Why-Not. The SQL query is then changed such that all missing-answers become part of the output, while side-effects are minimized.

The algorithm in [10] computes modification-based explanations while considering side-effects to answer why-not questions on top-k queries [10]. Its focus lies on changing k or preference weights to make the missing-answer appear in the query result.

Compared to previous work, Conseil is the first to consider non-monotonous queries and hybrid explanations. However, it does not consider side-effects nor top-k queries.
In defining our unified framework for why-not provenance, we first define the most general input scenario, referred to as debug-ging scenario (as in [12]). Our definition, relying on conditional tuples [14], covers the general case that considers multiple missing-answers and multiple queries and provably captures all previous definitions while offering enough freedom for further algorithms. tional tuple t =  X  a 1 , ... , a n , cond  X  is a tuple with attributes a n having constant or variable values, and cond being a boolean expression. The semantics are that tuple t represents all possible tuples that contain the same constants and that satisfy cond
To indicate the relation R a c-tuple t =  X  a 1 , ... , a n we use R  X  a 1 , ... , a n , cond  X  , and relation ( t ) = R to an attribute a within a c-tuple t using the notation t.a nario is a 5-tuple ( E, Q , Q ( D ) ,D, C ) , where Q is a set of queries, Q ( D ) is the result of these queries over some source instance is a set of missing-answers to be explained, specified as a set of c-tuples missing from Q ( D ) , and C being a set of constraints defined over the remaining four components of the debugging scenario.
Let us now turn to the definition of explanations, i.e., the out-put of an algorithm explaining missing-answers. Our definitions generalize previous definitions of query-based, instance-based, and modification-based explanations to cover queries involving opera-tors from relational algebra plus aggregation.

An instance-based explanation consists of labeled c-tuples. The definition of these relies on compatible c-tuples.
 patible with a c-tuple t 2 if (i)  X  a complements  X  a t satisfies t 1 .cond  X  t 2 .cond .
 We reuse existing definitions for subsumption and complementa-tion [2, 8], except that unlike these, we consider value NULL of the constant domain (and NULL equals NULL !), and unknown se-mantics are attributed to the variables of a c-tuple.

E XAMPLE 4. Consider c-tuples t 1 =  X  P1, Car, v 1 , v 1 6 = t Here, t 3 subsumes t 1 because t 3 matches all constants of has less unknown values and t 3 satisfies the condition of t .cond . Thus, t 3 is compatible with t 1 (but not vice versa). Fo-cusing on t 1 and t 2 , we see that these complement each other. The complement of t 1 and t 2 (without conditions) is  X  P1, Car, US for which it is easy to verify that both t 1 .cond and t 2 Hence, t 1 is compatible with t 2 (and vice versa).
 D EFINITION 4 (L ABELED C -TUPLE ). A labeled c-tuple t = L  X  a 1 , ... , a n , cond  X  w.r.t. some data set D is a c-tuple associated with a label L  X  { + ,  X  ,  X } that indicates whether a c-tuple com-patible with t is known to exist in D ( L =  X  ), needs to exist in ( L = + ), or must not exist in D ( L =  X  ).

When associated with label  X  , the c-tuple describes an existing tuple and hence its condition is always true. For brevity, we omit the condition true for tuples in D in the remainder of this paper. based explanation  X  IB for a debugging scenario describes modifi-cations to the database D that would yield the missing-answers of E in Q ( D ) while satisfying constraints C . The syntax of where L  X  a 1 , ... , a n , cond  X  refers to Def. 4, a a value (constant or variable), cop  X  { = ,&lt;,&gt;,  X  ,  X } an aggregation function over attribute a , and aCond a condition on the aggregated value of a . The semantics of  X  IB describe the sequence of operations [ T 1 ,..., T n ] needed to yield the missing tuples, the result being grouped and aggregated following
Intuitively, an instance-based explanation returns a set of modi-fications to the database, on which a grouping or aggregation con-straint of A may apply. A modification T either corresponds to a labeled c-tuple C or again  X  IB , necessary for nested queries.
E XAMPLE 5. The instance-based explanation of Ex. 1 is de-fined as follows, assuming that all ratings for P1 are above 2.
In the rest of this paper, we will simplify the notation when pos-sible, i.e., we will omit the subscript  X  when no aggregation applies.
Let us now shift our attention to query-based explanations, re-turned for instance by Why-Not [4].
 explanation  X  QB for a debugging scenario is a set of query opera-tors. Each operator op i  X   X  QB is responsible for pruning missing-answers of E from Q ( D ) and satisfies C . An operator op sponsible for pruning a missing answer e  X  E if data relevant to produce e is in the input of op i but not in its output.
The definition leaves open the choice of one or more operators in  X  QB and the choice of data relevant to produce e , as these are algorithm-specific.

E XAMPLE 6. Given the query of Ex. 1 and the missing-answer e =  X  P1, Car, v 1  X  , data relevant to produce e includes the tuple
P1, Car, US  X   X  Products and all tuples in Ratings . These data find  X  X uccessors X  in the output of all operators of the query, except for the selection  X  Max ( R.Rating )  X  2 (it is too selective). Conse-
The final type of explanations to define before we define hybrid explanations are modification-based explanations.
 modification-based explanation  X  MB for a debugging scenario is a rewriting of Q into a set of queries Q 0 such that all missing tuples in E occur in Q 0 ( D ) for a given source instance D and C is satisfied.
E XAMPLE 7. A modification-based explanation for our exam-ple replaces the existing HAVING -clause by HAVING MAX(R.Rating)
As illustrated in Ex. 2, the above explanation types may fail in returning explanations in some scenarios. To extend the set of de-bugging scenarios for which explanations can be returned, we de-fine a new type of explanation, namely hybrid explanation. tion  X  H for a debugging scenario S is a 3-tuple (  X  IB , X  s.t. the conjunction of all  X  i  X   X  H is a valid explanation, even though any conjunction of a subset of  X  i  X  X  is not necessarily an ex-planation. A hybrid explanation is valid if, once data modifications of  X  IB were applied,  X  QB (  X  MB ) would become valid query-based (modification-based) explanations w.r.t. S .

E XAMPLE 8. The hybrid explanation described in Ex. 3 is for-mally described as (  X  IB , X  QB ,  X  ) where
We now describe Conseil , an algorithm implementing our frame-work by computing hybrid explanations of the form ( X  IB ,  X  Conseil supports relational queries (i.e., queries involving selection  X  , projection  X  , join 1 , Cartesian product  X  , union difference \ ) with the restriction that it only supports one set dif-ference. It also supports aggregation  X  . The rationale behind the restriction to one set difference operator per query is based on both complexity (see Sec. 4.3) and usability. Despite this restriction, we believe that Conseil is still widely applicable in practice.
In its current version, Conseil does not consider side-effects and we so far focus on explaining one missing-answer e to the result Q ( D ) of a query Q over a relational instance D . However, Conseil exploits both referential constraints and unique constraints defined over D to estimate an explanation X  X  cost. These are formalized in C .

The above assumptions yield the following debugging scenario for Conseil : S Conseil = ( { e } , { Q } , { Q ( D ) } ,D, C )
Conseil operates in four main phases: First, (1) it computes a generic witness  X  that is then (2) annotated with passing properties determined over a canonical query tree representation (as defined in [6]). Based on the annotated generic witness, it (3) computes a set of derivations. Finally, (4) Conseil computes a hybrid explana-tion for each derivation, and returns these. We discuss each step in detail in the following. For illustration, we will use a more complex example than previously to cover more details.
 E XAMPLE 9. Fig. 2 shows the canonical query tree of a query Q over data in relations R , S , T , U , and V . Please ignore the rest of the figure for now. We define S Conseil with e =  X  a X , c X , d X  as in Fig. 2, Q ( D ) = {  X  a X , c, d  X  } , and C =  X  .
First, Conseil compute a generic witness that describes a pattern each explanation conforms to and that comprises an instance-based component  X  I and a query-based component  X  Q . Essentially, we use this generic witness to limit the search space explored in subse-quent steps. The generic witness can be computed efficiently based on e and Q (the complexity depending on the size of Q ).

The instance-based component  X  I describes in the form of c-tuples what data has to be present in the sources in order to pro-duce e .  X  Q , on the other hand, includes all operators that may be responsible for pruning e from the query result, i.e.,  X , 1
To define the generic witness  X  , we first need to distinguish be-tween missing-tuple constraints, subsequently called mt-constraints , and query-constraints, or q-constraints for short.

D EFINITION 9 ( MT -CONSTRAINT ). An mt-constraint is a con-straint that, given e and Q , can be identified as being imposed on the lineage [6] D  X  of e w.r.t. Q by the missing-tuple e .
D EFINITION 10 ( Q -CONSTRAINT ). A q-constraint is a con-straint that, given e and Q , can be identified as being imposed on the lineage D  X  of e w.r.t Q by the query Q .
 E XAMPLE 10. For Ex. 9, one mt-constraint is R.A = a 0 whereas U.B = u illustrates a q-constraint.
The only operators that introduce q-constraints are  X  and deed,  X  , X  , and  X  cannot be held responsible for pruning input tuples and \ does not impose a constraint on the lineage of lineage is defined solely by the tuples that need to be present.
We now define the generic witness for SPJD-queries, i.e., queries involving selection, projection, join, and set difference. We then comment on how to include union and aggregation.
 A generic witness  X  = ( X  I ,  X  Q ) for a SPJD-query is a 2-tuple of sets  X  I and  X  Q , where  X  I = { t i | relation ( t i )  X  D  X  t .cond the mt-constraint on t i } and  X  Q = { op i | op i  X  Q  X  op {  X , 1 , \}} .

E XAMPLE 11. The generic witness for the debugging scenario { 1
In case a query involves union operators, we create one generic witness for each alternative. For instance, Q = ( R 1 S )  X  T in two generic witnesses, whose instance-based components have the form { R ( ... ) ,S ( ... ) } and { T ( ... ) } , respectively.
When aggregation (together with grouping) is present, the c-tuples of the instance-based part of the generic witness are grouped accordingly, yielding a syntax for the generic witness similar to the syntax of the instance-based explanation, the main difference being that the c-tuples are not labeled and are sets instead of sequences (similar to the solution in [12]). For example, given a missing tuple
Having the generic witness in hand, the next step is to annotate it with passing properties. We define three passing properties, named passing , blocking , and ambiguous . An operator is passing if we are conditions, e.g., R  X  r 1 , r 2 | r 2 = s 1  X  r 1 = a  X  ,S  X  s certain that it is not responsible for pruning e from the result. If, on the contrary, we know that this operator is a culprit, we assign it the blocking annotation. In all other cases, we declare it as ambiguous. tated generic witness is a generic witness  X  where each c-tuple in  X 
I and each operator in  X  Q is assigned an annotation. The set of possible annotations is the set { A  X  , B  X  , P  X } , standing for ambigu-ous, blocking, and passing, respectively.

Conseil first canonicalizes its input query Q into its canonical tree representation T . If query Q contains a set difference, we split the query into the left and the right subtree of the set difference. On the right subtree v , we call the function annotate (described below) and, since we are in the negative part of the set difference, we revert passing annotations to blocking and vice versa. To cor-rectly determine passing properties, we register the output of the subquery v over D (denoted v ( D ) ) to V  X  X  topmost operator. We then process the left subtree, again calling annotate and return the final annotated canonical tree T A .

In discussing annotate , we invite the reader to follow the dis-cussion on Fig. 2. We assume a function getCTuple ( R,  X ) extracts the c-tuple in the generic witness  X  that imposes con-straints on relation R . We use this function to identify tuples in compatible with the returned c-tuple. The compatible source tuples in our example are underlined in Fig. 2. We also show annotations. Essentially, a source relation is passing if at least one compatible tuple is found and blocking otherwise.

Compatible tuples are subsequently traced in a bottom-up fash-ion through T . In Fig. 2, edge labels show the trace of compatible tuples or, in case a compatible tuple is  X  X ost X  at a query operator, an  X  X nvented X  c-tuple standing in as a place-holder for the lost com-patible tuple (marked with*). Tracing such fictive tuples ensures that we can identify further operators responsible for pruning other compatible data. Based on this trace, a query operator is passing if every compatible input tuple has a corresponding compatible out-put tuple. On the other hand, it is blocking if the compatible input tuple violates a q-constraint of the operator. In all other cases, we assign the annotation ambiguous.

Tab. 2 summarizes the annotated generic witness, whose annota-tions equal the annotations of corresponding nodes of T A
During derivation computation, Conseil refines the hybrid expla-nation pattern given by the generic witness by determining a set of patterns, called derivations .
Given a generic witness  X  = ( { t 1 ,...t n } , { op for an SPJD-query, where t i = R i ( a 1 ,...,a n {  X , 1 , \} , we determine a derivation  X  0 = ( X  0 I ,  X  0 the derivation rules summarized in Tab. 1. In general, derivation is an iterative process that transfers one q-constraint of into an mt-constraint in  X  I .

We first apply the derivation rules to translate all passing oper-ators of T A into mt-constraints and corresponding c-tuples to be added to  X  I . The intuition behind this is that a passing operator will never contribute to a the query-based component of a hybrid explanation. However, the conditions making it passing need to be satisfied by any instance-based component of a hybrid explanation. We apply the same idea to ambiguous operators next. However, as these operators stand for the possibility that the operator can be either passing or blocking, we create a derivation corresponding to each case. In general, assuming k is the number of ambiguous op-annotations. These can be easily deduced during the derivation pro-cedure based on a set of rules (omitted due to space constraints).
We can conceptually extend our derivation procedure to general relational queries involving more than one set difference operator. However, for Conseil , we exclude this case, because for generating actual explanations in the next step of the algorithm, we have to solve the view-update problem where updates are tuple deletions, for which solutions limit to conjunctive queries [3].

When dealing with queries involving union operators, we have seen that these will result in multiple generic witnesses, i.e., one for each subquery. In this case, we perform derivation for each pro-duced generic witness. As for aggregation, we push conditions that the c-tuples belonging to the grouped and aggregated sub-query (for MIN and MAX ) or to agg itself (for COUNT , SUM , AVG son for this differentiation lies in the fact that we do not actually want to update the source, and an explanation inserting or delet-ing a possibly large number of tuples just to match a certain count, sum, or average score is more difficult to interpret than just telling  X  X here is a count, but it does not match your expectation X .
E XAMPLE 12. The derivations shown in Tab. 2 correspond to the derivation of all passing operators (line 1), 1 R.B = S.B 1
R.B = T.B (line 3), and finally both joins (line 4).
In its final step, Conseil computes, for each derivation, a corre-sponding hybrid explanation with minimal cost. We first focus on determining the label assignment of the instance-based component of each derivation.

Given a derivation d , we preprocess it such that all unambiguous label assignments are determined beforehand. More specifically, we assign the label  X  to all non-existential c-tuples (tuples not pre-ceded by 6 X  in the d ) that are passing. On the other hand, if they are blocking, they are assigned the + -label. For the existential c-tuple (if any), we can remove it from the derivation X  X  instance-based part if it is passing. If it is either ambiguous or blocking, we compute its lineage w.r.t. the view v . If the lineage is empty, it can be removed as well, otherwise, we assign it the  X  -label.

As a result of pre-processing, only ambiguous non-existential c-tuples remain to be further processed. The first step of this process-ing is to form clusters of relations for a given derivation each cluster corresponds to the non-labeled relations of a connected component of the join graph of the instance-based component.
E XAMPLE 13. For the last derivation in Tab. 2, preprocessing results in the partial c-tuple label assignment { R  X  ,a X , v + T  X  v A , v B , ? , d X   X  ,U  X  v A , u  X  } and the clusters
For each cluster, we first establish a partial order of relations in a cluster based on a cost model (details omitted due to space constraints). More specifically, each relation X has one associated maxCost ( X ) and minCost ( X ) . MaxCost ( X ) quantifies the estimated worst case cost of modifying D in order to satisfy the constraints described by the c-tuple on X whereas minCost ( X ) quantifies the cost of reusing existing data in D (that already satis-fies the constraints). Based on this partial order, we span a binary search tree where a node N represents a relation and whose two edges to children have labels  X  and + , respectively, standing for the two possible label-assignments for the c-tuple of the relation represents. The root node corresponds to the relation with maxi-mum maxCost and its child nodes correspond to the next relation as determined by our order relation. The same applies for all sub-sequent levels. Using a branch-and-bound algorithm, we traverse this search-space and prune sub-trees if possible to eventually de-termine an instance-based component of a hybrid explanation with minimal cost.

The query-based component retains all query operators of the derivation X  X  query-based component whose q-constraints are not satisfied by the determined instance-based component. The final minimal-cost hybrid explanations for our running example are sum-marized in Tab. 2.
We implemented Conseil , Artemis [12], and Why-Not [4] in Java 1.6.. We ran all experiments on a Windows 7 installation running on a 1.7 GHz Intel Core i5 MacBook Air with 2 MB of main mem-ory. We used a local installation of Postgres 9.2 as database sys-tem. As described in [4], lineage tracing relies on the Trio sys-tem(http://infolab.stanford.edu/trio/), which we also used in our im-plementation. For Artemis, we additionally uses Minion (available at http://minion.sourceforge.net).

We report results on an excerpt of our test queries, summarized in Tab. 3. We selected these queries as they are supported by all three algorithms. The queries originate from three different scenar-ios. The first scenario reuses the crime scenario used to evaluate Why-Not in [4]. The two other scenarios are based on real-world data from the movie and government domains [11]. To obtain com-petitive runtimes for Artemis, we added trust conditions on all but one table in all scenarios where necessary (i.e., all but MOV2). Runtime comparison. From the results reported in Tab. 4, we see that both Why-Not and Conseil outperform Artemis and allow for interactive query debugging. The reason for this is that Artemis computes all possible instance-based explanations and needs to con-sider a large amount of alternatives. Opposed to that, both Why-Not and Conseil limit the result to the  X  X est X  explanations, provid-ing a substantial advantage when considering runtime. Focusing on the relative performance of Why-Not and Conseil , we see that Conseil is slower than Why-Not in CRIME2, MOV2, and GOV3. Upon further analysis, we explain this based on the fact that in these cases, Why-Not stops very early in the process when the culprit op-erator is detected closely to the leaf nodes of the query tree, whereas Conseil performs more computations, as it also checks for possible culprit operators at higher levels by  X  X nventing X  c-tuples at the out-put of the first culprit operator. In CRIME1 and GOV1, Conseil is faster than Why-Not, as the just mentioned additional processing Conseil requires is compensated by the time Why-Not spends on computing the lineage of data in Q ( D ) that is excluded from the data traced through the query.
 Qualitative discussion. To briefly address the question of expla-nation quality, we report in Tab. 4 the number of explanations each algorithm returns. We observe that Artemis is not only slower than other algorithms, it also often produces too many instance-based explanations that may overwhelm the user. For CRIME1, we ob-serve that Artemis returns no results, which is due to the fact that the crime to laugh is not present in the database, but it cannot be inserted by an instance-based explanation due to the trust condition on table c (the crime relation). This would also cause zero query-based explanations for Why-Not, if the first join of the canonical tree representation was a join involving this table. However, in our implementation, the join between p and sp comes first, which hap-pens to also be a culprit operator (it filters the person named Roger). Opposed to that, Conseil returns two explanations. The first adds label + to c-tuples on sp , w , and c , describing that both the crime c of laughing and a witness w that observed c (as described in table sp ) are missing. The second explanation corresponds to a hybrid explanation that identifies both the missing crime being witnessed (i.e., + c and + w ) and the failing join between p and sp interesting query is GOV3, where Why-Not does not return any re-sult as necessary source data is missing, i.e., the state  X  X A X  (which is  X  X alifornia X  in the database). In all other cases, Conseil covers the query-based explanation of Why-Not as well as one (minimal-cost) instance-based explanation of Artemis. We presented Conseil , an algorithm that explains why data are Table 4: Runtime (s) and #explanations for different algorithms missing from a query result using novel hybrid explanations. Op-posed to previous work, Conseil also considers queries including set difference. We first set the theoretical foundation by providing a general framework to address the problem of explaining missing-answers. We then concentrated on defining Conseil to compute hybrid-explanations in four phases, namely generic witness com-putation, passing property annotation, derivation, and explanation generation. Experiments demonstrated that Conseil combines fast runtime with an explanation quality superior to explanations pro-duced by other algorithms.

Next, we plan to consider side-effects and more general debug-ging scenarios. We also plan to further study efficiency improve-ments and cost models and to make a more thorough usability study.
