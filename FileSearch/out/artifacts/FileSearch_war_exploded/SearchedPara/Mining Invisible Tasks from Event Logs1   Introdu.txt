 Although quite a lot of work has been done on process mining, there are still some challenging problems left [9,10,11], i.e., short loops, duplicated tasks, in-visible tasks, non-free-choice construc ts, time, noise, incompleteness, etc. The issue of short loops is solved in [2]. For discussion about duplicated tasks, read-ers are referred to [1,3]. [7,12] attempts to resolve most kinds of non-free-choice constructs. Time issue is partially considered in [8]. Noise and incompleteness are discussed in [5]. Here, we will investigate how to mine invisible tasks from event logs.

Invisible tasks are difficult to mine because they do not appear in any event trace. The following situations can lead to invisible tasks:  X  There are meaningless tasks for routing purpose only in process models.  X  There are real tasks that have been executed lost in some event traces.  X  The enactment services of process models allow skipping or redoing current
The problems encountered when mining process models using the classical  X  algorithm from event logs containing invisible tasks will be investigated here. In Figure 1, N 1 to N 6 are the original WF-nets and N 1 to N 6 are the corresponding mined models derived from the complete event logs W 1 to W 6 respectively by using  X  algorithm. The black block transitions without labels represent invisible tasks. All the original WF-nets are sound, but the mined models have various issues. Tasks B and C as well as B and D are parallel in N 1 , while they are mutually exclusive in N 1 .Here N 1 is not a sound WF-net because a deadlock will always occur. Although N 2 is a sound WF-net, C cannot directly follow A and there is an implicit place in it. As a result, the behavior of N 2 is not equivalent with that of N 2 .In N 3 , B behaves like a length-one-loop task. However, C never directly follows A . There will not a place connecting A and C in N 3 ,which should be the only place associated with B .Here N 3 is not a WF-net at all. N 4 , N 5 and N 6 are all WF-nets but not sound. N 4 is more general than N 2 and N 3 is a special case of N 5 . The steps for constructing the mined model in  X  algorithm result in the above issues. In this paper, new mining algorithm will be proposed based on  X  algorithm, in which invisible t asks can be derived correctly.
The remainder of the paper is organized as follows. Section 2 introduces re-lated work on mining invisible tasks. Section 3 gives the classification of invisible tasks according to their functional features. The detection methods of invisible tasks are proposed in Section 4. The new mining algorithm  X  # is illustrated thor-oughly in Section 5. Section 6 shows the evaluation results on the new algorithm. Section 7 concludes the paper and gives future work. Here only process mining algorithms based on Petri net are considered. For other mining algorithms, their emphases are focused on the efficient identification of relationships between each pair of input/output arcs of the same task.
A Synchro-net based mining algorithm is proposed in [4]. The authors state that short loops and invisible tasks can be handled with ease. However, neither the original model nor the mined model contains any invisible task. [6] attempts to mine decisions from p rocess logs, which emphasizes detect-ing data dependencies that affect the routings of cases. When interpreting the semantics of the control flows in the mined decisions, the authors propose a descriptive method to identify decision branches starting from invisible tasks. This method cannot handle all kinds of invisible tasks. Even when there are other decision points with join nodes on one decision branch, the method fails.
By far the genetic mining algorithm is the only method that natively sup-ports the detection of invisible tasks [7]. It uses the basic idea of the genetic algorithm and defines two genetic operators for process mining, i.e., crossover and mutation. It aims at supporting duplicated tasks, invisible tasks, non-free-choice constructs. However, this algor ithm needs many user-defined parameters and it cannot always guarantee to return the most appropriate results.
In summary, there is still not any efficient solution that can handle invisible tasks well. This paper will focus on mining process models from event logs with invisible tasks based on the classical  X  algorithm proposed in [11]. Before detecting invisible tasks from event logs, we will first classify invisible tasks into four types by their functionalities. All types (i.e., SIDE, SKIP, REDO and SWITCH) of invisible tasks are shown in Figure 1.

The invisible task in N 1 is SIDE type and invisible tasks of this type directly connect with the source place or the sink place. The invisible tasks in N 2 and N 4 are SKIP type. Invisible tasks of SKIP type are used to skip the executions of some tasks. The invisible tasks in N 3 and N 5 are REDO type. Invisible tasks of REDO type are used to repeat the executions of some tasks. The invisible task in N 6 is SWITCH type and invisible tasks of this type are used to switch the execution rights among multiple alternative branches. When there are invisible tasks in process models, the causal dependencies be-tween tasks detected from event logs are not always correct any more. Such dependencies are called mendacious dependencies .Themostimportantstepof detecting invisible tasks from event logs is identifying all the mendacious de-pendencies out of the causal dependencies. The basic ordering relations between tasks derived from event logs are first listed below. For more detailed explanation about these basic ordering relations, readers are referred to [11,2]. Definition 1 (Basic ordering relations). Let N =( P, T, F ) be a sound WF-net, W be an event log of N (i.e., W  X  T  X  ). Let a, b  X  T ,then:  X  a W b iff a W b  X  b W a ,  X  a  X  W b iff a&gt; W b  X  ( b  X  W a  X  a W b ) ,  X  a # W b iff a &gt; W b  X  b  X  W b ,and  X  a W b iff a&gt; W b  X  b&gt; W b  X  a W b .
 The requirement for the completeness of an event log is the same as the one proposed in [2] (i.e., loop-complete). Now advanced ordering relations for men-dacious dependencies can be derived from the basic ordering relations. Definition 2 (Advanced ordering relations). Let N =( P, T, F ) be a sound WF-net, W be a loop-complete event log of N (i.e., W  X  T  X  ). Let a, b  X  T ,then: a W b iff a  X  W b  X  X  X  x, y  X  T : a  X  W x  X  y  X  W b  X  y  X  W x  X  x  X  W b . W reflects the mendacious dependencies associated with invisible tasks of SKIP,REDO and SWITCH types and this kind of ordering relation can be used to construct invisible tasks. From the logs shown in Figure 1, A W C , B W B , A W D , C W B and A W D can be detected from W 2 to W 6 respectively. To illustrate the derivation of W , see Figure 2.

In Figure 2, there is an invisible task t in the snippet of a WF-net and as-sume that t can be detected from the correspo nding log. The correctness of the detection method corresponding to W can be proved theoretically based on SWF-net. If y is equal to x , t is S-SKIP type. If y is reachable from x , t is L-SKIP type. If a is equal to b , t is S-REDO type. If a is reachable from b , t is L-REDO type. Otherwise, t is SWITCH type, i.e., a to x and y to b are two alternative paths. Detecting invisible tasks of SIDE t ype is relatively direct (see Section 5). However, invisible tasks of SIDE type should be detected first because they will affect the detection of invisible tasks of other types.

After detecting all mendacious dependenc ies between tasks, the corresponding causal dependencies should be eliminated, i.e., a W b  X  a W b .More precisely, the equation a W b  X  a  X  W b holds. For process models containing only causa l relations between tasks, there is a one-to-one correspondence between invisible tasks and mendacious dependencies. However, this is not always the case because selective and parallel relations are so common in real-life processes. Constructing invisible tasks is not such a trivial task. See Figure 3 for detail explanation.

The process model N 9 is a sound SWF-net and one of its complete log is W 9 = { ACDDFGHI, BCEEFHGI, ADEDEGHI, AEDGHI, BEDHGI, BDEHGI } . t 1 corresponds to D W D , D W E , E W D and E W E .
 Similar things happen to t 2 and t 3 . Furthermore, there are situations where multiple invisible tasks correspond to one mendacious dependency.
The construction algorithm for invisible tasks of SIDE type (i.e., ConSideIT ) is omitted here. The algorithm for constructing invisible tasks of all types is given below, which is the core of the  X  # algorithm. The two functions P reSet and PostSet are used to construct the input and output places of a task. Definition 3 (Construction algorithm ConIT). Let W be a loop-complete event log over a task set T (i.e., W  X  T  X  ). ConIT(W) is defined as follows. 1. ( T W ,T I ,T O ,D S )= ConSideIT ( W ) , 2. D M = { ( a, b ) | a  X  T W  X  b  X  T W  X  a W b } , 5. D S = D S  X  X  ( t ( P 6. D P = { ( t ( P 7. T W = T W  X  X  t ( P 8. ConIT ( W )=( T W ,T I ,T O ,D S ,D P ,D M ) .
 The algorithm ConIT works as follows. Step 1 invokes the algorithm ConSide IT to construct invisible tasks of SIDE type, fix first and last task sets and add nec-essary causal relations. All mendacious d ependencies between tasks are detected in step 2. Steps 3 and 4 are used to construct invisible tasks of SKIP/REDO/SWITCH types (stored in Y I ) reflected by the mendacious dependencies. These two steps are the most important ones in the whole algorithm. In steps 5 and 6, new causal and parallel relations between invisible tasks as well as the ones between invisible tasks and visible tasks are added. Finally, the task set T W are extended by new constructed invisible tasks in Step 7 and Step 8 returns the necessary results.
Based on the algorithms proposed above, the mining algorithm named  X  # can be defined as follows. It returns the mined model in WF-net.
 Definition 4 (Mining algorithm  X  # ). Let W be a loop-complete event log over a task set T (i.e., W  X  T  X  ).  X  # ( W ) is defined as follows. 1. ( T W ,T I ,T O ,D S ,D P ,D M )= ConIT ( W ) , 2. X W = { ( A, B ) | A  X  T W  X  B  X  T W  X  (  X  a  X  A, b  X  B :( a  X  W b  X  ( a, b )  X  3. Y W = { ( A, B )  X  X W | X  ( A ,B )  X  X W : A  X  A  X  B  X  B  X  ( A, B )= 4. P W = { P ( A,B ) | ( A, B )  X  Y W } X  X  i W ,o W } , 6. N W =( P W ,T W ,F W ) .
 The  X  # algorithm is relatively simple and easy to understand, which works as follows. Step 1 invokes the algorithm ConIT to construct all invisible tasks and fix the causal/parallel relations between tasks. All pairs of task sets related to possible places are constru cted in Step 2. This step takes into account invisible tasks and length-one-loop tasks at the same time. Steps 3 to 6 are directly borrowed from [11], in which the places together with the connecting arcs are constructed and the mined proces s model in WF-net is returned. The  X  # algorithm has been implemented as a ProM plug-in and can be down-loaded from www.processmining.org .

The  X  # plug-in of ProM has been applied to several real-life logs and many smaller artificial logs. The evaluation cr iteria is the three co nformance testing metrics between a given event log and a process model proposed in [7], i.e., f (fitness), aB (behavioral appropriateness) and aS (structural appropriateness). For any successful mining, the value of f should be 1.0 and the values of aB and aS should be as big as possible.

There are totally 96 artificial examples in WF-nets evaluated. The correspond-ing complete logs are generated manually. The maximum number of tasks in one process model is less than 20 and the number of cases in one event log is less than 30. Although thirty process models are not SWF-nets, the evaluation re-sults show that all the mined process models fit the corresponding logs. The conformance testing results are shown in Figure 4.

Ten real-life logs are obtained from Kinglong Company in Xiamen, Fujian province, China, which are all about processes for routing engineering docu-ments. All the conformance testing results are shown in Table ?? .Itisobvious that all the experiments are successful. The proportion for invisible tasks out of all tasks is 59/(59+88)=40.1%. The evaluation results show that so long as the event logs are complete, the  X  # algorithm can mine all n ecessary invisible tasks in all SWF-nets and most WF-nets successfully.
 Based on the analysis of mining problems encountered using the classical  X  al-gorithm, a new mining algorithm based on Petri net named  X  # algorithm is proposed. Invisible tasks are classified into four types according to their func-tionalities for the first time, i.e., SIDE, SKIP, REDO and SWITCH. The uni-versal detection method for invisible tasks of SKIP/REDO/SWITCH types is illustrated in detail and the correctness of the method can be proved theoret-ically. The construction algorithms for all types of invisible tasks and the pro-cess models in WF-nets are proposed and explained too. The  X  # algorithm has been implemented as a plug-in of ProM and evaluated using a lot of artificial logs and a few real-life logs. The evaluation results show that the algorithm is pragmatic.

Our future work will mainly focus on the following two aspects. Firstly, more real-life logs will be gathered for further evaluating the  X  # algorithm and the implemented plug-in. Secondly, theoretical analysis will be done to explore the exact mining capacity of the  X  # algorithm.
 This work is supported by the 973 Project of China (No. 2002CB312006) and the Project of National Natural Sci ence Foundation of China (No. 60373011).
