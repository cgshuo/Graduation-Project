 Research on the problem of morphological disam-biguation of Arabic has noted that techniques de-veloped for lexical disambiguation in English do not easily transfer over, since the affixation present in Arabic creates a very different tag set than for English, in terms of the number and complexity of tags. In additional to inflectional morphology, the POS tags encode more complex tokenization sequences, such as preposition + noun or noun + possessive pronoun .

One approach taken to this problem is to use a morphological analyzer such as BAMA-v2.0 (Buckwalter, 2004) or SAMA-v3.1 (Maamouri et al., 2009c) 1 , which generates a list of all possi-ble morphological analyses for a given token. Ma-chine learning approaches can model separate as-pects of a solution (e.g.,  X  X as a pronominal clitic X ) and then combine them to select the most appro-priate solution from among this list. A benefit of this approach is that by picking a single solu-tion from the morphological analyzer, the part-of-speech and tokenization comes as a unit (Habash and Rambow, 2005; Roth et al., 2008).
In contrast, other approaches have used a pipelined approach, with separate models to first do tokenization and then part-of-speech tagging (Diab et al., 2007; Diab, 2009). While these ap-proaches have somewhat lower performance than the joint approach, they have the advantage that they do not rely on the presence of a full-blown morphological analyzer, which may not always be available or appropriate as the data shifts to differ-ent genres or Arabic dialects.

In this work we present a novel approach to this problem that allows us to do simultaneous to-kenization and core part-of-speech tagging with a simple classifier, without using a full-blown morphological analyzer. We distinguish between closed-class and open-class categories of words, and encode regular expressions that express the morphological patterns for the former, and simple regular expressions for the latter that provide only the generic templates for affixation. We find that a simple baseline for the closed-class words already works very well, and for the open-class words we classify only the possible stems for all such ex-pressions. This is however sufficient for tokeniza-tion and core POS tagging, since the stem identi-fies the appropriate regular expression, which then in turn makes explicit, simultaneously, the tok-enization and part-of-speech information. The Arabic Treebank (ATB) contains a full mor-phological analysis of each  X  X ource token X , a whitespace/punctuation-delimited string from the source text. The SAMA analysis includes four fields, as shown in the first part of Table 1. 2 TEXT is the actual source token text, to be analyzed. VOC is the vocalized form, including diacritics. Each VOC segment has associated with it a POS tag and Table 1: Example analysis of one source token Table 2: Collapsing of ATB core tags into reduced core tags GLOSS . While  X  X okenization X  can be done in dif-ferent ways on top of this analysis, the ATB splits the VOC/POS/GLOSS segments up based on the POS tags to form the  X  X ree tokens X  necessary for treebanking. As shown in the second part of Table 1, the first two segments remain together as one tree token, and the pronoun is separated as a sep-arate tree token. In addition, the input TEXT is separated among the two tree tokens. 3
Each tree token X  X  POS tag therefore consists of what can be considered an  X  X TB core tag X , together with inflectional material (case, gender, number). For example, in Table 1, the  X  X ore tag X  of the first tree token is NOUN . In this work, we aim to recover the separation of a source token TEXT into the corresponding separate tree token TEXT s, together with a  X  X educed core tag X  for each tree to-ken. By  X  X educed core tag X , we mean an ATB core tag that has been reduced in two ways: (1) All inflectional material [infl] is stripped (2) Collapsing of some ATB core tags, as listed in Table 2.

These two steps result in a total of 40 reduced core tags, and each tree token has exactly one such reduced core tag. We work with the ATB3-v3.2 re-lease of the ATB (Maamouri et al., 2009b), which Table 3: The 40  X  X educed core tags X , and their fre-quencies in ATB3-v3.2. The total count is 402291, which is the number of tree tokens in ATB3-v3.2. has 339710 source tokens and 402291 tree tokens, where the latter are derived from the former as dis-cussed above. Table 3 lists the 40 reduced tags we use, and their frequency among the ATB3-v3.2 tree tokens. Given a source token, we wish to recover (1) the tree tokens (which amounts to recovering the ATB tokenization), and (2) the reduced core POS tag for each tree token. For example, in Table 1, given the input source token TEXT ktbh , we wish to recover the tree tokens ktb /NOA and h /POSS PRON.

As mentioned in the introduction, we use reg-ular expressions that encode all the tokenization and POS tag possibilities. Each  X  X roup X  (substring unit) in a regular expression (regex) is assigned an internal name, and a list is maintained of the pos-sible reduced core POS tags that can occur with that regex group. It is possible, and indeed usu-ally the case for groups representing affixes, that more than one such POS tag is possible. How-ever, it is crucial for our approach that while some given source token TEXT may match many regu-lar expressions (regexes), when the POS tag is also taken into account, there can be only one match among all the (open or closed-class) regexes. We say a source token  X  X os-matches X  a regex if the TEXT matches and POS tags match, and  X  X ext-matches X  if the TEXT matches the regex regard-less of the POS. During training, the pos-matching (REGEX #1) [w | f]lm (REGEX #2) [w | f]lm regex for a source token TEXT is stored as the gold solution for closed-class patterns, or used to create the gold label for the open-class classifier. We consider the open-class tags in Table 3 to be: NOUN PROP, NOA, IV, CV, PV, VERB. A source token is considered to have an open-class solution if any of the tree tokens in that solution have an open-class tag. For example, ktbh in Table 1 has an open-class solution because one of the tree to-kens has an open-class tag (NOA), even though the other is closed-class (POSS PRON).

We encode the possible solutions for closed-class source tokens using the lists in the ATB mor-phological guidelines (Maamouri et al., 2009a). For example, Figure 1 shows two of the closed-class regexes. The text wlm can text-match either REGEX #1 or #2, but when the POS tag for lm is taken into account, only one can pos-match. We return to the closed-class regexes in Section 4.
We also encode regular expression for the open-class source tokens, but these are simply generic templates expressing the usual affix possibilities, such as: [wf] [blk] stem NOA poss pronoun where there is no list of possible strings for stem_NOA , but which instead can match any-thing. While all parts except for the stem are op-tional, we do not make such parts optional in a single expression. Instead, we multiple out the possibilities into different expressions with differ-ent parts (e.g., [wf]) being obligatory). The reason for this is that we give different names to the stem in each case, and this is the basis of the features for the classifier. As with the closed-class regexes, we associate a list of possible POS tags for each named group within a regular expression. Here the stem NOA group can only have the tag NOA.
We create features for a classifier for the open-class words as follows. Each word is run through all of the open-class regular expressions. For each expression that text-matches, we make a feature which is the name of the stem part of the regular expression, along with the characters that match the stem. The stem name encodes whether there is a prefix or suffix, but does not include a POS tag. However, the source token pos-matches ex-actly one of the regular expressions, and the pos tag for the stem is appended to the named stem for that expression to form the gold label for training and the target for testing.

For example, Table 4 lists the matching regular expression for three words. The first, yjry , text-matches the generic regular expressions for any string /NOA, any string /IV, etc. These are sum-marized in one listing, yjry /all. The name of the stem for all these expressions is the same, just stem , and so they all give rise to the same feature, stem=yjry . It also matches the expression for a NOA with a possessive pronoun 4 , and in this case the stem name in the regular expression is stem_spp (which stands for  X  X tem with a pos-sessive pronoun suffix X ), and this gives rise to the feature stem_spp=yjr . Similarly, for wAfAdt the stem of the second expression has the name p_stem , for a prefix. The third example shows the different stem names that occur when there are both prefix and suffix possibilities. For each exam-ple, there is exactly one regex that not only text-matches, but also pos-matches. The combination of the stem name in these cases together with the gold tag forms the gold label, as indicated in col-umn 3.

Therefore, for each source token TEXT, the features include the ones arising from the named stems of all the regexes that text-match that TEXT, as shown in column 4, and the gold label is the appropriate stem name together with the POS tag, as shown in column 3. We also include some typical features for each stem, such as first and last two letters of each stem, etc. For ex-ample, wAfAdt would also have the features stem_fl=w , p_stem_fl=A , indicating that the first letter of stem is w and the first letter of p_stem is A . We also extract a list of proper nouns from SAMA-v3.1 as a temporary proxy for a named entity list, and include a feature for a stem if that stem is in the list ( stem_in_list , p_stem_in_list , etc.)
We do not model separate classifiers for prefix possibilities. There is a dependency between the pos-matches, which results in the gold label, shown in column 3. possibility of a prefix and the likelihood of the re-maining stem, and so we focus on the likelihood of the possible stems, where the open-class regexes enumerate the possible stems. A gold label to-gether with the source token TEXT maps back to a single regex, and so for a given label, the TEXT is parsed by that regular expression, resulting in a tokenization along with list of possible POS tags for each affix group in the regex. 5
During training and testing, we run each word through all the open and closed regexes. Text-matches for an open-class regex give rise to fea-tures as just described. Also, if the word matches any closed-class regex, it receives the feature MATCHES CLOSED . During training, if the cor-rect match for the word is one of the closed-class expressions, then the gold label is CLOSED . The classifier is used only to get solutions for the open-class words, although we wish to give the classifier all the words for the sentence. The cross-product of the stem name and (open-class) reduced core POS tags, plus the CLOSED tag, yields 24 labels for a CRF classifier in Mallet (McCallum, 2002). We worked with ATB3-v3.2, following the train-ing/devtest split in (Roth et al., 2008) on a pre-vious release of the same data. We keep a list-ing (List #1) of all (source token TEXT, solution) pairs seen during training. For an open-class so-lution,  X  X olution X  is the gold label as described in Section 3. For a closed-class solution,  X  X olution X  is the name of the single pos-matching regex. In addition, for every regex seen during training that pos-matches some source token TEXT, we keep a listing (List #2) of all ((regex-group-name, text), POS-tag) tuples. We use the information in List #1 to choose a solution for all words seen in train-ing in the Baseline and Run 2 below, and in Run 3, for words text-matching a closed-class expres-sion. We use List #2 to disambiguate all remain-ing cases of POS ambiguity, wherever a solution comes from.

For example, if wlm is seen during testing, List #1 will be consulted to find the most common so-lution (REGEX #1 or #2), and in either case, List #2 will be consulted to determine the most fre-quent tag for w as a prefix. While there is certainly room for improvement here, this works quite well since the tags for the affixes do not vary much.
We score the solution for a source token in-stance as correct for tokenization if it exactly matches the TEXT split for the tree tokens derived from that source token instance in the ATB. It is correct for POS if correct for tokenization and if each tree token has the same POS tag as the re-duced core tag for that tree token in the ATB.
For a simple baseline, if a source token TEXT is in List #1 then we simply use the most fre-quent stored solution. Otherwise we run the TEXT through all the regexes. If it text-matches any closed-class expression, we pick a random choice from among those regexes and otherwise from the open-class regexes that it text-matches. Any POS ambiguities for a regex group are disambiguated Solution Baseline Run 2 Run 3 Origin # tokens Tok POS # tokens Tok POS # tokens Tok POS Stored 46072 99.8% 96.6% 46072 99.8% 96.6% 16145 99.6% 96.4% Closed 27 81.5% 59.3% 27 81.5% 63.0% 27 81.5% 63.0% Mallet 0 5555 96.0% 83.8% 35481 99.1% 94.5% using List #2, as discussed above. The results are shown in Table 5. The score is very high for the words seen during training, but much lower for open-class words that were not. As expected, almost all (except 27) instances of closed-class words were seen during training.

For run 2, we continue to use the stored solution if the token was seen in training. If not, then if the TEXT matches one or more closed-class regexes, we randomly choose one. Otherwise, if the CRF classifier has produced an open-class match for that token, we use that (and otherwise, in only 10 cases, use a random open-class match). There is a significant improvement in the score for the open-class items, and therefore in the overall results.
For run 3, we put more of a burden on the clas-sifier. If a word matches any closed-class expres-sion, we either use the most frequent occurence during training (if it was seen), or use a random maching closed-class expression (if not). If the word doesn X  X  match a closed-class expression, we use the mallet result. The mallet score goes up, al-most certainly because the score is now including results on words that were seen during training. The overall POS result for run 3 is slightly less than run 2. (95.099% compared to 95.147%).

It is not a simple matter to compare results with previous work, due to differing evaluation tech-niques, data sets, and POS tag sets. With differ-ent data sets and training sizes, Habash and Ram-bow (2005) report 99.3% word accuracy on tok-enization, and Diab et al. (2007) reports a score of 99.1%. Habash and Rambow (2005) reported 97.6% on the LDC-supplied reduced tag set, and Diab et al. (2007) reported 96.6%. The LDC-supplied tag set used is smaller than the one in this paper (24 tags), but does distinguish between NOUN and ADJ. However, both (Habash and Rambow, 2005; Diab et al., 2007) assume gold tokenization for evaluation of POS results, which we do not. The  X  X orphPOS X  task in (Roth et al., 2008), 96.4%, is somewhat similar to ours in that it scores on a  X  X ore tag X , but unlike for us there is only one such tag for a source token (easier) but it distinguishes between NOUN and ADJ (harder).
We would like to do a direct comparison by sim-ply runing the above systems on the exact same data and evaluating them the same way. However, this unfortunately has to wait until new versions are released that work with the current version of the SAMA morphological analyzer and ATB. Obvious future work starts with the need to in-clude determiner information in the POS tags and the important NOUN/ADJ distinction. There are various possibilities for recovering this informa-tion, such as (1) using a different module combin-ing NOUN/ADJ disambiguation together with NP chunking, or (2) simply including NOUN/ADJ in the current classifier instead of NOA. We will be implementing and comparing these alternatives. We also will be using this system as a preprocess-ing step for a parser, as part of a complete Arabic NLP pipeline.
 We thank Ann Bies, David Graff, Nizar Habash, Mohamed Maamouri, and Mitch Marcus for helpful discussions and comments. This work was supported by the Defense Advanced Re-search Projects Agency, GALE Program Grant No. HR0011-06-1-0003 and by the GALE pro-gram, DARPA/CMO Contract No. HR0011-06-C-0022. The content of this paper does not nec-essarily reflect the position or the policy of the Government, and no official endorsement should be inferred.
