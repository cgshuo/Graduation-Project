 Semistructured data has become prevalent in both web applications and database sys-tems. It acts as a hinge technology between the data exchanged on the web and the data represented in a database system. This rapid growth in use makes the design of good semistructured data essential. Many data modeling languages [1, 3, 5, 10] for semistructured data have been introduced to capture more detailed semantic informa-tion. The Object Relationship Attribute model for Semistructured data (ORA-SS) [4, 9] is a semantic enriched graphical notation for designing an d representing semistructured data [8, 9, 11]. The ORA-SS data model not only reflects the nested structure of semi-structured data, but also distinguishes betw een object classes, rel ationship types and attributes. The main advantages of ORA-SS over other data models is its ability to ex-press the degree of an n-ary relationship type, and distinguish between the attributes of relationship types and the attributes of object classes. This semantic information is essential, even crucial for semistruct ured data representation and management, but it is lacking in other existing semistructured data modeling notations.

A major concern in designing a good semistructured data model using ORA-SS for a particular application is to reveal any possible inconsistencies at both the schema and instance levels. Inconsistencies at the schema level arise if a customized ORA-SS schema model does not conform to the ORA-SS notation. Inconsistencies at the instance level arise if an instance document is not consistent with its ORA-SS schema definition. For example, an inconsistency that might arise at the schema level is the specification of a ternary relationship between only two object classes. An inconsistency that might arise at the instance level is a many to many relationship between elements when a one to many relationship is specified in the schema. These two aspects of validation are essential in the semistructured data design process. Thus, the provision of formal semantics and automated reasoning support for validating ORA-SS semistructured data modeling is very beneficial.

Recent research on the World Wide Web has extended to the semantics of web con-tent. More meaningful information is embedded into the web content, which makes it possible for intelligent agent programs to retrieve relevant semantic as well as structural information based on their requirements. The Semantic Web [2] approach proposed by the World Wide Web Consortium (W3C) attracts the most attention. It is regarded as the next generation of the web. The Ontology Web Language (OWL) is an ontology language for the Semantic Web. OWL can provide not only the structural information of the web content but also meaningful semantics for the information presented. The aim of this paper is to encode the semantics of the ORA-SS notation into the Web On-tology Language (OWL) and automatically verify the semistructured data design using the OWL reasoning tool RACER [6].

The reason that we chose OWL to fulfil our goal is due to the nature of the semistruc-tured data and its strong connections to web technologies. Semistructured data is typi-cally represented using eXtensible Markup Language (XML). XML is a commonly used exchange format in many web and database applications. The introduction of the Seman-tic Web is to overcome the structure-only information of XML, and to provide deeper semantic meanings to th e data. The ORA-SS data model is a semantically enriched data modeling language for describing semistructured data. From the point of capturing more semantic informatio n in semistructured data, OWL and ORA-SS are two approaches that fulfil the same goal, where the former is rooted from the web community and the latter has its basis in the database community. We believe that Semantic Web and its reasoning tools can contribute to the verification phase of the semistructured data design. In this paper, we propose a methodology to validate semistructured data design using OWL and its reasoner RACER. Firstly, we define an ontology model of the ORA-SS data modeling language in OWL. It provides a rigorous semantic basis for the ORA-SS graphical notation and enable us to represent any ORA-SS data model and its instances in OWL. Furthermore, RACER is used to perform the automated verification of the correctness in a semistructured data design. Our approach is able to provide automatic consistency checking on large semist ructured data models and their instances.
The remainder of the paper is organized as follows. Section 2 briefly introduces the background knowledge for the semistructured data modeling language ORA-SS, Semantic Web ontology language OWL and its reasoning tool RACER. Section 3 presents OWL semantics of the ORA-SS notation and its data models. Section 4 demon-strates a case study on a complete ontology reasoning process for verifying semistruc-tured data design. Examples of both class-level reasoning and instance-level reasoning are presented. Finally, Section 5 concludes the paper. 2.1 The ORA-SS Data Modeling Language The Object Relationship Attribute model for Semistructured data (ORA-SS) data mod-eling language [4, 9] consists of four basic concepts: object class, relationship type, attribute and reference. It represents these concepts through four diagrams: schema di-agram, instance diagram, functional dependency diagram and inheritance diagram. We will focus on the schema and instance diagram in this paper since they are sufficient for our purposes. A full description of the ORA-SS data modeling language can be found in [4, 9].  X  An object class is like an entity type in an ER diagram, a class in an object-oriented diagram or an element in an XML document. The object classes are represented as labeled rectangles in an ORA-SS diagram.  X  A relationship type represents a nesting relationship among object classes. It is de-scribed as a labeled edge by a tuple ( name , n , p , c ), where the name denotes the name of relationship type, integer n indicates degree of relationship type, p repre-sents participation constraint of parent object class in relationship type and c repre-sents participation constraint of ch ild object class in relationship type.  X  Attributes represent properties and are denoted by labeled circle. An attribute can be a key attribute which has a unique value and represented as a filled circle. Other types of attributes include single valued attribute, multi-valued attribute, required attribute, composite attribute, etc. An attribute can be a property of an object class or a property of a relationship type.  X  An object class can reference another object class to model recursive and symmetric relationships, or to reduce redundancy especially for many-to-many relationships. It is represented by a labeled dashed edge.

For the design of semistructured data, an ORA-SS schema diagram constrains the relationships, participations and cardinalities among the instances of the object classes in a semistructured data model. For example, Fig. 1 represents an ORA-SS schema di-agram of a Course-Student data model. In the diagram, each course has code , title , exam venue as its attributes. A relationship type cs , which indicates the relationship between a course object class and a student object class is binary, and each course consists of 4 to many students and each student can select 3 to 8 courses. The student object class in the cs relationship type has a reference pointing to its complete definition. The grade attribute is an attribute belonging to the cs relation-ship type. Based on the above schema definition, two levels of validation can be carried out. Firstly, consistency checking can be performed to determine whether the defined schema model is correct with respect to the ORA-SS language. Secondly, consistency checking can be performed to determine whether a particular instance of semistruc-tured data satisfies the defined ORA-SS schema model. Hence automated tool support for validating the consistency in an ORA-SS data model would be highly desirable. 2.2 Semantic Web  X  OWL and RACER Description logics are logical formalisms for representing information about knowledge in a particular domain. It is a subset of first-order predicate logic and is well-known for the trade-off between expressivity and decidability.
 The Web Ontology Language (OWL) [7] is the de-facto ontology language for the Semantic Web. It consists of three increasingly expressive sublanguages: OWL Lite, DL and Full. OWL DL is very expressive yet decidable. As a result, core inference prob-lems, namely concept subsumption, consistency and instantiation, can be performed fully automatically. In OWL, conceptual entities are organized as classes in hierarchies. Individual entities are grouped under classes and are called instances of the classes. Classes and individuals can be related by properties. We will be using a synatx similar to that presented in [7].

RACER, the R enamed A Box and C oncept E xpression R easoner [6], is a reasoning engine for ontologies languages DAML+OIL and OWL. It implements a TBox and ABox reasoner for the description logic ALCQHI R + ( D )  X  [6]. It is fully automated for reasoning over OWL Lite and DL ontologies. In this section, we show the modeling of ORA-SS schema and instance diagrams as OWL ontologies in three parts. Firstly, we define the ORA-SS ontology in Section 3.1, which contains the OWL definitions of essential ORA-SS concepts. Secondly, in the next 3 subsections, we show how individual schema diagram ontology can be con-structed based on the ORA-SS ontology. Finally, in Section 3.5, we show how instance diagrams can be represented in OWL.
Our modeling approach can be regarded as a methodology for creating the OWL rep-resentation of ORA-SS diagrams. By strictly following this methodology, a lot of poten-tial modeling errors can be avoided, which will become more evident as we present the approach below. To effectively illustrate the modeling approach, the schema diagram in Fig. 1 is used as a running example. 3.1 The ORA-SS Ontology The ORA-SS ontology 1 contains the OWL definitions for ORA-SS concepts such as object class, relationship t ype, attribute, etc. We will model these definitions as OWL classes. The basic assumption here is that all named OWL classes are by default mu-tually disjoint, which is implied in the ORA-SS diagrams. Essential properties are also defined in the ontology. This ontology, with a namespace of ora-ss , can be used later to define ontologies for ORA-SS schema diagrams.
 Entities. As each object class and relationship type can be associated with attributes and other object classes or relationship types, we define an OWL class ENTITY to represent the super class of both object class and relationship type. The OWL class structure is shown as follows.
 It may not seem very intuitive to define relationship types as OWL classes. In ORA-SS, relationship types are used to relate various object classes and relationship types, it might be natural to model relationship types as OWL properties. However, there are two reasons that we decide to model relationship types as OWL classes. Firstly, the domain of ORA-SS relationship types can be relationship types themselves, which describes the relationships of ternary and more. Secondly, classes and properties in OWL DL are disjoint. In our model, a relationship type class consists of instances which are actually pointers to the pairs of object cla sses or relationship types that this relationship relates.
As ORA-SS is a modeling notation for semistructured data, we need to cater to un-structured data. We define a subclass of ATTRIBUTE called ANY as a place holder to denote any unstructured data appearing in a model. In ORA-SS, a composite attribute is an attribute composed of other attributes. We also define it as a subclass of ATTRIBUTE . Properties. A number of essential properties are defined in the ora-ss ontology. Properties Among Entities In ORA-SS, object classes and relationship types are inter-related to form new relation-ship types. As mentioned above, since we model relationship types as OWL classes, we need additional properties to connect various obj ect classes and relationship types.
Firstly , this is accomplished by introducing two object-properties, parent and child , which map a RELATIONSHIP to its domain and range ENTITY s. The following state-ments define the domain and range of parent and child . As in ORA-SS, the domain of a relationship ( parent ) can be either an object class or another relationship type, i.e., an ENTITY . The range ( child )mustbean OBJECT . These two properties are functional as one relationship type has exactly one domain and one range node. Moreover, we assert that only relationship types can have parent s and child but object classes cannot.
Secondly , we define two more object-properties: p-ENTITY-OBJECT and p-OBJECT-ENTITY . These two properties are inverse of each other and they serve as the super properties of the properties that are to be defined in later ontologies of ORA-SS schema diagrams. Those properties will model the restrictions imposed on the relationship types.

The domain and range of p-ENTITY-OBJECT are ENTITY and OBJECT , respec-tively. Since the two properties are inverse, the domain and range of p-OBJECT-ENTITY can be deduced. Properties Between Entities and Attributes First of all, we define an object-property has-ATTRIBUTE , whose domain is ENTITY and range is ATTRIBUTE .Every ENTITY must have ATTRIBUTE as the range of has-ATTRIBUTE .
For modeling the ORA-SS candidate and primary keys, we define two new ob-ject properties that are sub-properties of has-ATTRIBUTE . We also make the property has-primary-key inverse functional and state that each ENTITY must have at most one primary key. Moreover, we restrict the range of has-candidate-key to be ATTRIBUTE . 3.2 Object Classes In this subsection, we present how ORA-SS object classes in a schema diagram are rep-resented in OWL. Moreover, we will discuss how object class referencing is modeled. Example 1. The schema diagram in Fig. 1 contains a number of object classes 2 . Referencing. In ORA-SS, an object class can reference another object class to refer to its definition, which we say that a reference object class references a referenced object class. In our model, we model the reference object class a sub class of the referenced object class. If the two object classes are of the same name, the reference object class is renamed. By doing so, we ensure that all the attributes and relationship types of the referenced object classes are reachable (meaningful). Note that there are no disjointness axioms among the reference and referenced object classes.
 Example 2. In Fig. 1, the object class student is referenced by object classes student and member. Hence, we rename the reference student to student 1 and add the following axioms in to the model. 3.3 Relationship Types In this subsection, we present the details of how ORA-SS relationship types are modeled in OWL. Various kinds of relationship types, such as disjunctive relationship types and recursive relationship types are also modeled. We begin with an example to show the basic modeling of relationship types.

For example, Fig. 1 contains 5 relationship types, namely cs , sh , sm , cp and cst .The relationship type cs is bound by the parent / child properties as follows. We use both allValuesFrom and someValuesFrom restriction to make sure that only the intended class can be the parent/child class of cs . Auxiliary Properties. As discussed in Section 3.1, for each ORA-SS relationship type we define two object-properties that are the inverse of each other.
 Example 3. Ta ke cs as an example, we construct two object-properties: p-course-student and p-student-course . Their domain and range are also defined. Participation Constraints. One of the important advantages that ORA-SS has over XML Schema language is the ability to express participation constraints for parent/child nodes of a relationship type. This ability expresses the cardinality restrictions that must be satisfied by ORA-SS instances.

Using the terminology defined previously, ORA-SS parent participation constraints are expressed using cardinality restrictions in OWL on a sub-property of p-ENTITY-OBJECT to restrict the parent class Prt . Child participation constraints can be similarly modeled, using a sub property of p-OBJECT-ENTITY .
 Example 4. In Fig. 1, the constraints captured by the relationship type cs state that a course must have at least 4 students; and a student must take at least 3 and at most 8 courses. The following axioms are added to the ontology. The two object-properties defined above capture the relationship type between course and student . Disjunctive Relationship Types. In ORA-SS, a disjunctive relationship type is used to represent disjunctive object classes, where only one object can be selected from a set of object classes. To model this in OWL, we will create a dummy class as the union of the disjoint classes and use it as the range of the object-property representing the relationship type. Together with the cardinality constraint that exactly one individual of the range can be selected, the disjunctive relationship type can be precisely modeled. Example 5. In Fig. 1, sh is a disjunctive relationship type where a student must live in exactly one hostel or one home, but not both. We use the following OWL statements to model this situation. Note that p-student-sh is an object-property that maps student to its range class home hostel , which is the union of hostel and home .
Given the above definitions, the disjunctive relationship type sh in the schema dia-gram can be modeled as follows. 3.4 Attributes The semantically rich ORA-SS model notation defines many kinds of attributes for object classes and relationship types. These include candidate and primary keys, single-valued and multi-valued attributes, required and optional attributes, etc. In this subsec-tion, we will discuss how these attributes can be modeled.
 Example 6. The schema diagram in Fig. 1 includes attributes such as code , title and exam venue , which are all sub classes of ATTRIBUTE . Modeling of Various Definitions. As OWL adopts the Open World Assumption [7] and an ORA-SS model is closed, we need to find ways to make the OWL model capture the intended meaning of the original diagram. The following are some modeling tricks .  X  For each ENTITY , we use an allValuesFrom restriction on has-ATTRIBUTE over the union of all the ATTRIBUTE classes this ENTITY has in the ORA-SS model to denote the complete set of attributes it holds.

Example 7. In the running example, the object class student has student number and name as its attributes.  X  Each entity (object class or relationship type) can have a number of attributes. For each of the entity-attribute pairs in an ORA-SS schema diagram, we define an object-property, whose domain is the entity and range is the attribute.

Example 8. In Fig. 1, the object class sport club has an attribute name . It can be modeled as follows. Required and Optional Attributes. We use cardinality restrictions of respective object-properties on the owning ENTITY to model the attribute cardinality constraints in the ORA-SS model. The default is (0:1). We use a cardinality  X  1 restriction to state a required attribute.
 Single-Valued vs. Multi-valued Attributes. Single-valued attributes can be modeled by specifying the respective object-property as functional. Multi-valued attributes, on the contrary, are not functional. An attribute is by default single valued. Primary Key Attributes. For an entity with a primary key attribute, we use an all-ValuesFrom restriction on the property has-primary-key to constrain it. Since we have specified that has-primary-key is inverse functional, this suffices to show that two dif-ferent objects will have different primary keys. Moreover, for every attribute that is the primary key attribute, we assert that the corresponding object property is a sub property of has-primary-key .
 Disjunctive Attributes. Similar to the treatment of disjunctive relationship types, we create a class as the union of a set of disjunctive attribute classes. Together with the cardinality  X  1 restriction, disjunctive attributes can be represented in OWL. 3.5 Instance Diagrams in OWL The representation of ORA-SS instance diagrams in OWL is a straightforward task. As the name suggests, instance diagrams are semist ructured data instances of a particular ORA-SS schema diagram. The translation of an instance diagram to an OWL ontology is done by the following 3 steps: 1. Defining individuals and stating the membership of these individuals, by declaring them as instances of the respective OWL classe s of object classes, relationship types and attributes defined in the schema diagram ontology. 2. For each OWL class, we state that all its instances are different from each other. 3. By making use of the object-properties defined in the schema diagram ontology, we state the relationships among the individuals. In this section, we demonstrate the validation of ORA-SS schema and instance diagrams using OWL and RACER. We will again use Fig. 1 as the running example. 4.1 Validation of Schema Diagram Ontologies In order to ensure the correctness of an ORA-SS schema diagram, a number of proper-ties have to be checked, such as:  X  The parent of a relationship type should be either a relationship type or an object class, where the child should only be an object class.  X  The parent of a higher-degree relationship type (higher than 2) must be a relationship type.  X  An object class or relationship type can have at most one primary key, which must be part of the candidate keys.

To manually check the validity of a given schema diagram against these constraints is a highly laborious and error-prone task. By following the methodology presented in this section systematically, a lot of potential violation of the above constraints can be avoided. Moreover, the highly efficient OWL reasoners such as RACER can check the consistency of ORA-SS schema diagrams in OWL fully automatically. For example, suppose that in the case study, the child of relationship type cs is mistakenly put as cst instead of student 1 . Hence, the axiom !" X  child . OBJECT is violated. This error can be picked up by RACER automatically, as shown in Fig. 2. Three classes, cs , cst and tutor are highlighted as inconsistent. Classes cst and tutor are inconsistent because they are both related to cs using existential or cardinality restrictions. Other types of checking can be similarly performed.

It can be seen from Fig. 2 that the detection of inconsistencies in the ORA-SS schema ontology by RACER is quite efficient. On a Pentium IV 2.4GHz machine with 1GB memory, the consistency checking by RACER took only 0.75 second. 4.2 Validation of Instance Diagram Ontologies After transforming an ORA-SS instance diagram into an OWL ontology. Validation of the consistency of the instance ontology can be done fully automatically by invoking ontology reasoners capable of ABox reasoning. We will use RACER to demonstrate the checking of the above ontology using a few examples.  X  Entity/attribute cardinality constraints
In Fig. 1, each instance of relationship type cst has exactly one tutor . Suppose that in the instance ontology, cs 1 is mapped to two tutors, tutor 1 and tutor 2 by cst .  X  Primary key related properties
Suppose that by accident, two students, student 4 and student 5 , are both assigned to the same student number.
By using RACER And RacerPorter (a graphical front-end of RACER) together, the instance ontology is detected to be inconsistent automatically in the above two cases. In each case, RACER takes less than 1 second to conclude the incoherence of the ontology. In this paper, we explored the synergy between the Semantic Web and the database mod-eling approaches in the context of verifying semistructured data design. We demonstrate the approach of using the OWL and its reasoning tool for the consistency checking of the ORA-SS data model and its instances. The advantages of our approach lie in the fol-lowing perspectives. Firstly, we defined a Semantic Web ontology model for the ORA-SS data modeling language. It not only provides a formal semantic for the ORA-SS graphical notation, but also demonstrates that Semantic Web languages such as OWL can be used to capture more semantic information of a semistructured data. Further-more, such a semantics can be adopted by many Semantic Web applications that use the ORA-SS semistructured data model. Secondly, ontology reasoning tool was adopted to perform automated verification on a semistructured data model. The RACER reasoner was used to check the consistency of an ORA-SS schema model and its instances. We illustrated the various checking tasks through a Course-Student example model. In our previous work, we used the Alloy Analyzer for the validation of the ORA-SS data model. The main advantage of our current OWL approach over this is that consistency checking on large ORA-SS models are made feasible, as one of the shortcomings of the current Alloy Analyzer is its limited abilities on verifying large-scale models. More-over, as Semantic Web reasoners employ highly optimized tableaux-based algorithms, the performance in terms of time is also significantly better than Alloy Analyzer.
