 In this paper, we propose to query correlated graph in a data stream scenario, where given a query graph q an algorithm is required to retrieve all the subgraphs whose Pearson X  X  corre-lation coefficients with q are greater than a threshold  X  over some graph data flowing in a stream fashion. Due to the dynamic changing nature of the stream data and the inher-ent complexity of the graph query process, treating graph streams as static datasets is computationally infeasible or ineffective. In the paper, we propose a novel algorithm, CGStream, to identify correlated graphs from data stream, by using a sliding window which covers a number of con-secutive batches of stream data records. Our theme is to regard stream query as the traversing along a data stream and the query is achieved at a number of outlooks over the data stream. For each outlook, we derive a lower frequency bound to mine a set of frequent subgraph candidates, where the lower bound guarantees that no pattern is missing from the current outlook to the next outlook. On top of that, we derive an upper correlation bound and a heuristic rule to prune the candidate size, which helps reduce the computa-tion cost at each outlook. Experimental results demonstrate that the proposed algorithm is several times, or even an or-der of magnitude, more efficient than the straightforward algorithm. Meanwhile, our algorithm achieves good perfor-mance in terms of query precision.
 H.2.8 [ Data Management ]: Database Applications X  Data Mining Algorithm Correlated Graph, Data Stream, Pearson X  X  Correlation Co-efficient
Correlation mining draws extensive attention in the re-search community due to its uniqueness and advantages in uncovering underlying dependencies between objects. In past years, there have been considerable studies on corre-lation mining in applications including market transaction databases [16, 18], quantitative databases [8], and time se-ries data [12], and this topic has been recently extended to graph databases, where data records or instances are linked through relationships [7, 10].

In the context of graph data, the correlation between two graphs measures their occurrence distributions. Given a graph database, correlated graph search (CGS) [7] tries to discover a set of correlated graphs whose Pearson correla-tion coefficients [6] with a query graph are above a given correlation threshold  X  .

CGS is very useful for revealing interesting patterns in many graph representation scenarios. For instance, a user X  X  browsing history in a web site can be represented as graphs. Correlated graphs retrieved from the user transversal graphs represent graphs with similar distributions and suggest a group of users sharing common interests. Analyzing these correlated graphs helps web site owners understand user be-haviors so that they can improve the web site structures and detect abnormal behaviors, which are very important in E-commerce [10].
 Current CGS [7] is only performed in static database. In practice, applications may involve data which constantly change or evolve over time ( e.g. , data streams). For instance, in a communication network, the links between different nodes are changing continuously, so the network topology (which can be regarded as a graph) will dynamically change. In a chemical reaction process, the structures of chemical compounds are also change from time to time, so the in-teractions between compounds (which can be regarded as graphs) also change dynamically. Noticing the importance of the pattern discovery from graph streams, there have been several researches on continuously querying graphs in a data stream setting [14], or mining frequent graphs in a data stream scenario [2]. However, to the best our knowledge, there is no existing research on correlated graph pattern query in data streams.

In this paper, we study correlated graph query for data streams, where the main challenges are as follows
Intuitively, a straightforward approach to solve our prob-lem is exhaustive search, which uses a sliding window to scan the stream and computes the correlation by employing a static graph database based algorithm, such as CGSearch [7] 1 , to query the correlated graphs in each window. While this exhaustive approach can ensure the results being com-plete and correct, it is computationally ineffective because the reoccurring query process in each window involves fre-quent subgraph mining procedure and subgraph frequency counting procedure, both of which are expensive operations, especially when the window size is considerable large. An in-cremental method for stream-based correlated graph query is highly demanded.

In this paper, we propose a solution to incrementally re-trieve correlated graphs over stream. Our theme is to re-gard each query q as an operator, who constantly queries subgraph patterns correlated to itself while traversing along the graph stream. To answer the query in an efficient way, we propose to maintain a number of outlooks ( O )overthe data stream. For each query q , each outlook ( O i ) carefully maintains a candidate list with two properties: (1) all sub-graph patterns correlated to the query q ,withrespectto the current sliding window, are included in this list; and (2) before reaching the next outlook ( O i +1 ), no subgraph pat-tern correlated to the query q is missing. Accordingly, the correlated graph query can be achieved by querying the lists maintained at each outlook. Because the mining procedure is only triggered at each outlook, we can significantly reduce the computational cost by using effective methods to build and maintain the candidate list.

The candidate list at each outlook is vitally important to determine the system efficiency. If the list is infinitely long and includes all possible subgraphs, a query will not miss any patterns but scanning such an infinite list will be inef-ficient. Meanwhile, because each outlook requires a signifi-cant amount of computational cost to build and maintain its candidate list, a query system is going to be very inefficient if there are a large number of outlooks in the stream. To ensure the system runtime performance, we need to main-tain as few stream outlooks as possible, yet the candidate list in each outlook should also be sufficient to ensure the query quality. In the paper, we derive a set of theoretical bounds to maintain the length of the candidate list, and also propose some forecasting procedures to minimize the num-ber of outlooks through which we can accelerate the system runtime performance.

The main contributions of this paper can be summarized as follows:
The algorithm for CGS problem is named CGSearch in [7].
The rest of this paper is structured as follows: The prelim-inaries and formulation of our research problem are given in Section 2. We derive a new frequency(support) lower bound for candidate generation in Section 3. In Section 4, we fur-ther derive a correlation upper bound and a heuristic rule for candidate pruning. The algorithm is presented in Sec-tion 5, and experimental results are presented in Section 6. The related work is reviewed in Section 7 and we conclude the paper in Section 8.
We consider undirected, labeled connected graphs in this paper. A graph is denoted as g =( V,E, ), where V is the vertices set, E istheedgeset,and is a labeling function to assign labels to a node or an edge. Given two graphs g 1 = ( V 1 ,E 1 , 1 )and g 2 =( V 2 ,E 2 , 2 ), a subgraph isomorphism from g 1 to g 2 is an injective function f : V 1  X  V 2 , such that  X  ( u, v )  X  E 1 ,wehave( f ( u ) ,f ( v ))  X  E 2 , 1 ( u )= subgraph isomorphism is an NP-complete problem [5]. A graph g 1 is a subgraph of another graph g 2 ( g 1  X  g 2 )if there is a subgraph isomorphism from g 1 to g 2 .
Given a graph database D , the projected dataset with respect to a graph g is a subset of D which contains g ,de-noted as D g = { g | g  X  g ,g  X  D } , whose frequency N g and support supp ( g ) is denoted as N g = | D g | and supp ( g )= |
D g | / | D | ,where | X | denotes the cardinality of the set
For two graphs g and q in D , their joint frequency are the number of graphs in D which contains both graph g and q , denoted as N gq = | D q D g | , and their joint support is supp ( g,q )= | D q D g | / | D | . Given a query graph q ,athreshold  X  , and a graph stream G , we emphasize on discover correlated graphs whose cor-relations with q are above  X  from G .Because G repre-sents a dynamic changing graph stream, we assume that graph data arrives batch by batch, and use a sliding window gion of the graph stream, where G  X  ,j  X  w +1  X   X   X  j rep-resents a batch of graphs and G j isthemostrecentbatch. Then our problem is to monitor and report the correlated Figure 1: A framework of sliding window based cor-related graph query for data streams. At time point T , the sliding window (dashed red rectangle) covers batches G 1 ,G 2 ,...,G 10 .Anewbatch G 11 arrives at time point T 2 ( G 11 becomes the most recent batch), the sliding window updates to cover G 2 ,G 3 ,...,G 11 (solid red rectangle). Continuous correlated graph query intends to discover the correlated graphs in every sliding window. Outlooks are specific time points where we build and update the potential can-didate list PG (such as O i and O i +1 ). At any other time points between two outlooks (like time points T 2 and T 3 ), we only update the frequency of can-didates and output the correlated graphs, without carrying out any pattern mining process. graphs whose Pearson X  X  correlations [6] with q in a sliding window are greater than  X  (in the most recent w batches). A typical correlated graph query in a data stream with window size w =10 is shown in Figure 1.

Definition 1. Pearson X  X  Correlation Coefficient: Given two graphs g and q , their supports and joint support over a number of N graphs are denoted as supp ( g ), supp ( q ), and supp ( g,q ), respectively. The Pearson X  X  Correlation Coeffi-cient [6] between g and q ,  X  ( g,q ), is defined as follows [16]:  X  ( g,q )= supp ( g,q ) When supp ( g )or supp ( q )isequalto0or1,  X  ( g,q )) is defined to be 0. The range of  X  ( g,q ) falls into [0 , 1], as we only consider the positive correlated graphs in this paper.
The Pearson X  X  correlation coefficient over a set containing anumberof N graphs can be rearranged into another form in terms of frequency [18]: N , N q ,and N gq denote for the N graphs, the number of graphs containing g , q ,and g and q , respectively.
A main challenge of correlated graph search (CGS) for data stream is that the correlation is constantly changing over time and recomputing the correlation for each candi-date is time-consuming. This is because computing  X  ( g,q ) involves graph isomorphism testing when counting the fre-quency of g ( i.e. N g ), which is NP-Complete. In addition, because a graph consists of an exponential number of sub-graphs and each of which is a potential correlated graph candidate to the query q , the search space of CGS, for data stream, is extremely large.

In this paper, we propose a CGStream algorithm to ad-dress the problem and ensure that each correlated graph query can be answered in an efficient and accurate way. Our solution is inspired by a checkpoint idea in [18], and our theme is to create a number of outlooks ( O )overstream. The framework of CGStream is illustrated in Fig. 1.
In summary, an outlook ( O i ) is a specific time point which can help to derive some theoretical correlation bounds, so that a CGS algorithm only needs to maintain a small set of potential candidates without referring to the original graph stream data to answer the query. The rationale behind is as follows: given a graph stream and a sliding window which covers a number of graphs, assume at a outlook O i the slid-ing window covers N graphs in the stream. Suppose that  X  N new graphs ( X  N N ) will arrive at next outlook O i +1 and there are also  X  N graphs are removed from the monitor window D , we can build and maintain a candidate list PG at time point O i such that any patterns not belonging to the PG are not going to satisfy the query before reaching time point O i +1 . As a result, only the candidates remaining in the PG list are promising for future investigation. In this case, the increment  X  N betweentwooutlookscanbere-garded as a computation buffer (outlook buffer). For graph stream between two adjacent outlooks (e.g., T 2 and T 3 in Fig. 1), we just need to check the PG list to output the correlated graphs with query graph q , without reoccurring the query process in the whole window of data.

While maintaining the PG list, two issues should be con-sidered: 1. To achieve high retrieval precision, the PG list for each 2. To meet the requirement of high speed of data stream, While the above two issues are contradictory to each other, we address each of them by employing the stream outlooks as follows.

On the one hand, for each outlook ( O i ), we derive a lower frequency bound lower ( N gq ), and transfer the CGS prob-lem to a frequent subgraph mining problem, which can be addressed by some existing graph mining algorithms such as gspan algorithm [17]. More specifically, instead of mining from the original window of graph data, we mine a set of cor-related graph as potential graphs (PG) from the projected database of a query graph q . The PG list has taken the in-crement ( X  N ) between two adjacent outlooks ( O i and O i into consideration and guarantees that all potential candi-dates are stored as long as the number of increment graphs (between O i and O i +1 ) containing the query graph q , i.e.  X  N q , is within a certain range  X   X   X  N q  X   X  .Bydoingso, we can ensure that the PG list maintained at each outlook O i is as complete as possible.
On the other hand, when the lower bound lower ( N gq )is relatively small, the size of the PG list may be too large, which will significantly slow down the query process. In the paper, we further derive an upper correlation bound to reduce the size of the PG list. On top of that, some heuristic rules are also applied to the candidate checking procedure to speed up the mining process. As a result, we can guarantees the efficiency of our algorithm.

In the following sections, we will first derive the frequency lower bound to generate the PG list (Sect. 3), and then illustrate the derivation of the correlation upper bound and the heuristic rules to further reduce the PG list (Sect. 4). Motivated by the existing CGSearch algorithm [7], our CGStream algorithm transfers the CGS for data stream prob-lem to a frequent subgraph mining problem. In other words, instead of mining from the original window of graph data, we mine a set of frequent graphs as potential graphs (PG) from the projected database D q of the query graph q .As D q is a much smaller subset of D , the search space and time consumption can be greatly reduced. Accordingly, the first technical challenge of our algorithm is:
How to derive a lower bound for frequent subgraph mining from D q , so that those frequent subgraphs from D q are not only potential correlated graphs in the current outlook ( in Fig. 1), but are also potential before reaching the next outlook ( O i +1 in Fig. 1)?
If we can derive such a lower bound, the re-computation process can be greatly reduced. For instance, at time stamps T 2 and T 3 in Fig. 1, we only need to update the frequency of the candidates and then output the results quickly without querying from the entire sliding window.
Lemma 1. Given a query graph q , the maximum corre-lation of graph g with q will be achieved when supp ( g )= supp ( g,q ), or N g = N gq
Proof. From Eq. (1), we know that when we fix supp ( g,q ) and supp ( q ),  X  ( g,q ) monotonically decreases with supp ( g ). As supp ( g,q )  X  supp ( g )  X  1,  X  ( g,q ) will achieve its max-imum value when supp ( g )= supp ( g,q ). Similarly, we can prove that when N g = N gq ,  X  ( g,q )achievesitsmaximum value according to Eq. (2).
 In Eq. (3), N is a constant variable, and N q can be eas-ily computed after obtaining the projected database D q . Then for each subgraph g , we need to count N gq to check if it is a potential candidate ( g is a potential candidate if  X  max ( g,q )  X   X  ). Here we derive a new lower bound of N gq by using outlooks as a number of stream processing nodes.
Suppose with the arriving of data stream, there are  X  N new graphs (outlook buffer) flowing into the sliding window. Meanwhile,  X  N graphs will become outdated and be re-moved from the sliding window (We consider the case when the sliding window is full, so the total number of graphs in the sliding window remain the same). Similarly, the num-ber of N q will increase with  X  N q ,and X  N q will be removed from the sliding window.

Let  X  = X  N q =  X  N q  X   X  N q be the number of increment of N q between two outlooks.  X  can be either  X  0(if  X  N q  X  N q )or  X  0. Then Eq. (3) can be rearranged as follows: We know that  X  max ( g,q ) monotonically increases with N  X  N gq accordingtoEq.(4),and X  N gq  X |  X  | ,themaximum correlation will be Because we can estimate the mean and variance of N q in each batch from the data stream,  X  can be estimated from the historical stream data from stream. In Sec. 3.2, we will propose techniques to estimate the range of  X  with  X   X  [  X ,  X  ],  X   X  0 , X   X  0.

Assume that we need to find out the correlated graph with correlation above  X  (with  X  increment of N q )within the outlook buffer, i.e. , we have a requirement From Eq. (5) and Eq. (6), we know when  X   X  0, we have Then we have minimum N gq for  X   X  0 Taking the partial derivative of  X  ,wehave f (  X  )=  X  As  X   X  N q  X  N and  X   X  1, the first term of f 1 (  X  )  X  0, and the second term  X  0. As a result, f 1 (  X  )  X  0. f 1 (  X  )is a monotonic increase function, so the minimum of f 1 (  X  )is f (  X  )(  X   X   X   X  0).
 Similarly, we can compute the minimum N gq when  X   X  0 Itcanbeprovedthat f 2 (  X  ) is a monotonic decrease function with  X  ,0  X   X   X   X  , so the minimum of f 2 (  X  )is f 2 (  X  );
Theorem 1. Given N , N q ,  X  ,  X   X   X   X   X  , if a graph is a potential candidate before reaching the next outlook, its minimum frequency in the projected database D q at current outlook is at least where f 1 (  X  ) and f 2 (  X  ) are defined in Eq. (7) and Eq.(8).
We can use lower ( N gq ) as a frequency bound to mine a set of frequent subgraphs from the projected database, these frequent subgraphs are potential candidates after tak-ing next outlook into consideration. In other words, when  X  N graphs (outlook buffer) flow into the sliding window, as long as the increment of N q ,say  X   X   X   X   X  ,allthetrue correlated graphs will be kept as candidates.
From Eq. (9) it is clear that to get lower ( N gq ), we must know  X  and  X  , i.e. the range of  X  = X  N q  X  [  X ,  X  ]. In fact, because N q is always larger than 0, it is easy to find that  X  will fall into the range [  X   X  N q ,  X  N ]. However, a loose and large  X  (  X  = X  N in this case) will result in a relatively small lower ( N gq ) value, which in turn increases the system runtime for frequent subgraph mining. So a tight range of  X  (small  X  or  X  ) is preferred. Because we can easily collect N in each batch over stream, we maintain a list of frequency record of N q , and use Poisson distribution/Skellam distribu-tion [13] to estimate the range of  X  .

Assume that the frequency of occurrence for the query graph q in a fixed time period (in a batch) follows a Pois-son distribution. The incoming graphs containing q fol-lows  X  N q = P ( x = k ;  X  1 )=  X  k 1 e outdated graphs (which will be discarded as we only fo-cus on the most w batches of data) containing q follows  X  N q = P ( x = k ;  X  2 )=  X  k 2 e difference between these two Poisson distribution follows a Skellam distribution [13]. where I k ( z ) is the modified Bessel function of the first kind [4].

In our setting, we set the average of N q in the most recent w/ 2 batches (half size of the sliding window) as  X  1 ,andthe average of N q in the oldest w/ 2 batches (half window) as  X 
The Skellam distribution f ( k ;  X  1 , X  2 ) has mean  X  =  X   X  ,variance  X  2 =  X  1 +  X  2 .Thenweset  X  =  X   X  3  X  =  X  +3 the range within the three-standard-deviation range of the mean, as the probability that a point falls into this range is over 0.99 for a Skellam distribution.
After obtaining the estimated value of  X  ,wecanminethe frequent subgraphs from the projected data using lower ( N as a lower bound of threshold (Eq. (9)), and then add these frequent graphs into the candidate set. In the incoming batches before reaching next outlook, we can quickly output the correlated graphs without involving the candidate build-ing procedure from the scratch, which will greatly reduce the system computation cost.

In reality, when lower ( N gq ) value is relatively small, it may end up with a large candidate set, which requires a significant amount of time to query for each candidate graph g . In this subsection, we further reduce the candidate set by deriving a new correlation bound. The idea is as follows: For any outlook O i , based on current statistics of N g , N q we can compute and predict the upper bound correlation value between each graph g and the query q ,  X  max ( g,q ), with respect to the  X  N increment graphs. If  X  max ( g,q )is lower than the given correlation threshold, we can removed it safely.

Suppose when  X  N new graphs arrive, there are also  X  N graphs are removed. The increments for N gq , N g , N q are  X  N gq , X  N g ,and X  N q =  X  , respectively. Let Then the new correlation at the next outlook ( O i +1 )for graph g is Here, we are trying to calculate the maximum value of  X  ( g,q ) the next outlook buffer, we can safely prune g .  X  max ( g,q ) can be achieved by maximizing the numerator (  X  ) and minimizing denominator (  X  and  X  ) simultaneously.
In order to maximize  X  ,let X  N gq = y ,  X  = y + c 1 , X  N g y + c 2 ,then Similar to the estimation process for  X  which concludes that  X   X   X   X   X  , the increment  X  N g can be estimated in the same way as we estimate  X  N q ,whichresultsin  X  g  X   X  N g  X   X  g As a result, we have the following inequalities: Lemma 2. For a stream outlook O i ,given N , N g , N gq , N ,and X  N ,  X   X   X   X   X  ,  X  g  X   X  N g  X   X  g ,themaximum possible value for  X  , the numerator of the  X  ( g,q )atthe next outlook O i +1 is: Here we have h  X  ( y )= N ( N gq + y )  X  ( N g + y +  X  g )( N t = N  X  N g  X  N q  X   X  g ,and X  y =( N  X  N g  X  N q  X   X  g  X   X  ) / 2.
Proof. The maximum value of  X  can be derived by tak-ing first and second partial derivatives.  X  X   X  X  1 =  X  ( N c )  X  0.  X  increases monotonically as c 1 decreases. So  X  achieves maximum value in the minimum value of c 1 , i.e., c =  X  . Similarly,  X  X   X  X  2 =  X  ( N q + y + c 1 )  X  0, so  X  is maxi-mized when c 2 =  X  g ; So  X  has the maximum value at  X  X   X  X  =0. Thesolutionfor this equation is  X  y =( N  X  N g  X  N q  X   X  g  X   X  ) / 2. However,  X   X  y  X   X  , the above value can be reached only if 3  X   X  N  X  N q  X  N g  X   X  g  X  2  X  +  X  .If N  X  N q  X  N g  X   X  g &gt; 2  X  +  X  , 0.  X  will achieve maximum value at y =  X  ; Similarly, if N  X  N q  X  N g  X   X  g &lt; 3  X  ,  X  X  maximum value at y =  X  . Now the Lemma 2 is proven.
Lemma 3. Given N , N q ,and X  N ,  X   X   X   X   X  , the mini-mum possible value for  X  is: where h  X  ( x )= x ( N  X  x );
Proof. Since h  X  ( x ) is a quadratic function of x ,itiscon-cave and symmetric with respect to x = N/ 2. Its minimum value will be located at either N q +  X  or N q +  X  .Sothe Lemma 3 is proven.

Lemma 4. Given N , N q ,and X  N ,  X  g  X   X  N g  X   X  g ,the minimum possible value for  X  is: where h  X  ( x )= x ( N  X  x ); Similar to Lemma 3, we can easily obtain Lemma 4.
Theorem 2. For any candidate graph g in the PG list of the current outlook O i , its correlation upper bound to the query graph q before reaching the next outlook O i +1 is: where  X  and follows Lemma 2,  X  follows Lemma 3, and  X  follows Lemma 4.

Proof.  X  max ( g,q ) is achieved by maximizing the numer-ator (  X  ) and minimizing denominator (  X  and  X  )simulta-neously according to Eq. (11). The theorem has been proven.
To speed up the candidate pruning procedure, we derive a heuristic rule as follows.
 Lemma 5. Let f ( a, b )=(  X  a ( N  X  a ) b ( N  X  b )+ ab ) /N . Given current outlook O i , two graphs g 1 and g 2 , g 2  X  N g 1 +  X  g 1  X  N/ 2, the correlation between g 2 and q at the next outlook O i +1
Proof. Since g 2  X  g 1 ,wehave N g 1 &lt;N g 2 , N g 1 + X  N N g 2 + X  N g 2 . Taking the partial derivative of f with respect to a , we can easily know that, with a  X  N/ 2, f monoton-ically increases with a . Similarly, with b  X  N/ 2, f mono-tonically increases with b .Sowehave N
Here, N g 2 q +  X  is the maximum possible value of N g 2 q at outlook O i +1 .Let x = N g 2 + X  N g 2 , y = N q + X  N q As z  X  N g 2 q +  X &lt;f ( x ,y ), replacing z with f ( x ,y )in the Eq. (16), we have  X  ( g 2 ,q ) &lt; Algorithm 1 Correlated subgraph search for data stream 2: while A new graph batch G j arrives do 7: else 9: for each g  X  PG do 12: end for 13: end if 14: for each g  X  PG do 15: if  X  ( g,q )  X   X  then 17: end if 18: end for 20: end while ; Note that if N g 2 q +  X &lt;f ( N g 1 +  X  g 1 ,N q +  X  ), so is N This is because N g 1 &lt;N g 2 , N g 1 +  X &lt;N g 2 +  X  .Itmeans that  X  ( g 1 ,q ) &lt; X  . Now we have proven the lemma 5. Applying the heuristic rule: The heuristic rule is inte-grated with the candidate checking process. Specifically, if we find that a graph g 1 is not a potential candidate, we check all its subgraphs in the candidate set. For each g 2  X  g 1  X  ( g 2 ,q ) &lt; X  , we can prune it according to lemma 5.
Algorithm 1 lists the detailed procedures of the proposed algorithm for correlated graph query in data streams.
Our algorithm handles the data stream in a batch by batch manner. As soon as a new data batch G j arrives at time point T j , the sliding window will discard the most outdated data batch to ensure that the window covers w data batches, including the newly coming data batch (step 3 in Algorithm 1). Then we check whether time point T j is an outlook O (step 4). If T j is an outlook, we call Algorithm 2 to rebuild the candidate list PG (steps 5-6); otherwise, we update the frequency information of each candidate g ( g  X  PG ), from the outdated and newly arriving data batches (steps 8-12). Next, if a candidate X  X  correlation is above  X  , we add it into the answer set A g (step 14-17). Finally, we output the an-swer set A g when there is a demand from the user.
Our candidate building procedure for each outlook O is illustrated in Algorithm 2. We use Poisson/Skellam Distri-bution to estimate  X  ,  X   X   X   X   X  in the next outlook (line 2 of Algorithm 2). Because graph isomorphism is NP-complete, we reduce the number of graph isomorphism test by retriev-Algorithm 2 Building the candidate list 1: PG =  X  ; 2: Estimate the statistics of  X  ,  X   X   X   X   X  ; 4: Mining the frequent subgraphs C from D q with the lower 6: for each g  X  X  do 7: Compute upper (  X  ( g, q )) according to Theorem 2; 8: if upper (  X  ( g,q ))  X   X  then 9: PG  X  PG g ; 10: else 12: C X  X  X  H ; 13: end if 14: end for 15: return PG ; ing from the projected database of query graph q rather than using the original windows of graph. In step 4, We mine a set of frequent subgraphs from D q using a lower bound of threshold lower ( N gq ), which is determined by Theorem 1. This threshold takes the possible frequency increment quan-tity of N q into consideration and guarantees that the graph is a possible graph with N q in the range of [ N q  X   X , N In this way, all the potential candidates will be kept before reaching next outlook. In steps (6-14), for each candidate graph, we compute its correlation upper bound. If a graph g  X  X  upper correlation bound is greater than the given thresh-old  X  ,weadd g into PG list, otherwise, we apply a heuristic rule to prune the candidates and speed up the process.
In this section, we report our experimental results. The graph data stream is collected from a real-world dataset of the NCI Open Database Compounds 2 , which contains com-pound structures of cancer and AIDS data. The original dataset contains about 249,000 graphs. After preprocess-ing and removing some disconnected graphs, we have a data stream with about 233,000 graphs.

We compare our algorithms with an exhaustive search method (denoted as rCGSearch ) in terms of system run-time 3 . When implementing rCGSearch , i.e. , whenever a new batch of graphs arrives, rCGSearch restarts to in-volve the CGSearch algorithm [7] in the sliding window. rCGSearch is a precise method in the sense that it can re-turn all the true answers with zero false positives and false negatives, but it is computationally expensive which makes it unsuitable for stream based applications. http://cactus.nci.nih.gov/ncidb2/download.html
Note that the memory consumption of CGStream and rCGSearch are almost the same and fixed, as they both store the window of graphs for query process.

Precision and recall are widely used to measure the per-formance of an algorithm [1]. Suppose the true answer set of correlated graphs is T g , and the answer set returned by our algorithm is A g .The precision is defined as | T g A g | and the recall is denoted as | T g A g | / | T g | .
Because we maintain a candidate set PG over stream and update the frequency information of each candidate, the an-swer will be returned as long as it is stored in PG .Inother words, the genuine correlation values of the retrieved graphs to the query graph q are all above  X  , which asserts that the recall of our algorithm is 1.

To calculate the query precision values, we randomly se-lect 30 graphs as the query graphs. For each selected query graph, its support value in the whole data stream is in range [0.02, 0.05]. During the query process, we sequentially move the sliding window one batch at a time and evaluate the pre-cision of the correlated graphs in each sliding window over the whole stream. Suppose there are  X  batches of graphs over data stream. The average precision on a data stream for a query is computed as P recision = 1  X   X   X  =1 P  X  ,where P  X  is the precision in window D = { G  X  | n  X  w +1  X   X   X  n (the most recent w batches). We calculate average runtime in a similar way. The results for 30 graphs in terms of these measures are averaged again and reported as the final re-sults.

We study the performance of our algorithm with various parameters. Unless specify otherwise, we set the default values  X  =0.7, w =20, m =10, and | G j | =3000. Prunning Effectiveness of CGStream: In order to as-sess the effectiveness of different parts of pruning techniques in our CGStream algorithm, we first remove the heuristic rules, and then remove both heuristic rules and the upper correlation bound to investigate the system runtime perfor-mance. Table 1 summarizes the system runtime in each time point (including outlook points and non-outlook points) and the accumulative runtime of the whole stream.

The results in Table. 1 show that the system runtime at the outlooks is significantly larger than at the non-outlook points. This is because CGStream needs to query from the whole window D at outlooks while at non-outlook points it only needs to check the PG list. Meanwhile, it can be seen that after we remove the heuristic rule, the runtime at the outlooks increases significantly, which reflects the contribu-tions of the simple heuristic rule for prunning. Furthermore, if we remove both heuristic rule and upper correlation bound from CGStream algorithm, it will not only increases the run-time at outlooks substantially, but also increases the runtime at non-outlook points. Overall, the accumulative time (col-umn 4 in table 1) in the whole stream will increase if we remove either heuristic rule or upper correlation bound.
The above results conclude that the upper correlation bound and heuristics are essential for CGStream.
 Algorithm performances with Different Query Thresh-olds: To study the performance of our algorithm with re-spect to different query threshold (  X  )values,wevarythe  X  values and report the the system runtime at each time point ( i.e. each sliding window) and total system accumulative runtime in Fig. 2 and Fig. 3.

Fig. 2 shows that the proposed CGStream algorithm sig-nificantly outperforms the exhaustive algorithm in terms of system runtime. Take  X  =0 . 6asanexample,itonlytakes system accumulative runtime in each time point. Table 1: Effectiveness of Pruning in CGStream with  X  =0 . 8 (seconds)[Acc. Time -accumulative runtime] about 15 seconds for CGStream to retrieve the answers at most time stamps, whereas rCGSearch needs about 380-400 seconds. CGStream is more than 20 times efficient than rCGSearch. Even at the outlooks, CGStream needs less time (occasional a little more time) than rCGSearch to build the candidate list, this is because our loose correlation up-per bound and heuristic rule can reduce the candidate and speed up the computation process.

We also illustrate the accumulative runtime in each time point in Fig. 3. It is clear that the accumulative runtime of rCGSearch increases dramatically as streaming batch data continuously arrives. In contrast, CGStream X  X  accumula-tive time climbs very slowly except for outlooks, where large jumps can be observed.

The results in Fig 2 and Fig. 3 show that when the thresh-old  X  is relatively small, both rCGSearch and CGStream need more time to retrieve the results in each batch. This is because a smaller threshold  X  results in more candidates re-turned by the frequent subgraph mining step, which in turn calls for more time to check and prune the candidate list. Algorithm performances with Different w Values: In Fig. 4 and Fig. 5, we also report algorithm performance with respect to different sliding window sizes.

As expected, Fig. 4 shows that CGStream increases much more slowly than rCGSearch in terms of system accumula-tive runtime when we vary w values. The results are con-sistent with that we reported for  X  previously. Meanwhile, when we increase the window size, Fig. 5.(A) and Fig. 5.(B) show that CGStream requires more time to build the candi-date list at the outlooks, which results in a larger jump in ac-cumulative system runtime at the outlooks in Fig. 5.(C) and Fig. 5.(D). This is because the algorithm needs to go though more graphs when we increase the window size. In real ap-plications, the appropriate size of window may depend on the domains of application and specific user settings. Algorithm performances with Different Batch Sizes: Fig. 6 illustrates the results when using different batch sizes ( i.e. different | G j | Values). The experimental results, once again, demonstrate that CGStream can greatly reduce the computation cost required by rCGSearch, because it avoids involving CGSearch algorithm repeatedly when updating Figure 8: Comparison on different m values. (A) system runtime, (B) system accumulative runtime. the sliding window.
 Algorithm Performances w.r.t. Different Outlook Frequencies In Fig. 8 we also report the algorithm perfor-mance with respect to different m values, i.e. ,howfrequent we set a stream outlook and rebuild the candidate list (the m value also determine the number of graphs  X  N between two outlooks). It is obvious that the larger the m values, the less accumulative time is needed by CGStream algorithm, because it involves less outlooks and less candidate rebuild-ing procedures (which is the most time consuming process). However, as we will see in latter section, the precision may decrease if we increase m values. There is a tradeoff between time consumptions and precision.
In Fig. 7, we report the query performance of the CGStream algorithm with respect to different parameters.

Fig. 7.(A) shows that the precision drops slightly when we decrease the  X  values. However, the precision is above 0.99 in our algorithm for all  X  values, which reflects the high accuracy of our algorithm.

In Fig. 7.(B), the results show that the increasing of m values (outlook buffer size) will decrease the query precision. As we have mentioned in Sect. 6.2, increasing the m values reduces the number of outlooks in the stream. Because out-looks consumes most of the system runtime, increasing m values reduces the accumulative time taken by CGStream algorithm. On the other hand, with a relatively large m value, the outlook buffer size will increase accordingly, which will make the parameter estimations for  X   X   X   X   X  to be less accurate. As a result, it will decrease the algorithm X  X  query precision. The tradeoff between the runtime consump-tion and precision may be determined depending on domain applications domains and user requirements.

Fig. 7.(C) and Fig. 7.(D) show that the precision will change slightly when we vary either window size w or batch size | G j | . Nevertheless, the query precision is always very close to 1, which indicates that our algorithm is a highly accurate in practice.
Mining correlation has been widely studied in various do-mains in the literature. For market-basket database, exten-sive studies have addressed the correlation between items [16, 18]. While these methods were proposed to identify correlation defined by Pearson X  X  correlation coefficient, some other measures such as  X  2 test [3], h-confidence [15], and m -pattern measure [11] are also investigated in the community.
In the context of static graph databases, there are several works related to correlation mining. Given a query graph, CGSearch [7] mines the correlated graphs whose correlation is above a given threshold, TopCor [10] discovers the top-k correlated graphs with the highest correlation in a graph database. These two works carry out the query based on a given query graph q , whereas the work in [9] does not require users to specify any query. In other words, it tries to find out all correlated graph pairs in database. In comparison, all existing works in this category only limit their scopes to static databases, whereas our work is designed for dynamic graph streams.

In data stream environments, recently there are some works on graph search [14] and closed frequent subgraph mining [2]. But to the best of our knowledge, no existing works/studies exist for correlated graph query for data streams.
In this paper, we investigated the problem of query cor-related graphs from data stream, by using a sliding win-dow which covers a number of consecutive batches of stream data records. We argued that, for data streams with dy-namic increasing volumes, simple exhaustive search for cor-related graphs needs to repeatedly carry out the query pro-cess, which is computationally expensive. By setting stream outlooks and considering the possible increment of query graph within two adjacent outlooks, we derived a lower fre-quency bound to mine a set of frequent subgraphs as can-didates. An upper correlation bound and a heuristic rule are also derived to prune the candidates in the process of candidate checking. Experimental results demonstrate that our proposed algorithm CGStream is several times more ef-ficient than the exhaustive search method in terms of the system runtime consumption, and achieve high performance in terms of query precision.
This work was supported by the Australian Research Coun-cil (ARC) Future Fellowship under Gra nt No. FT100100971. [1] R. A. Baeza-Yates and B. Ribeiro-Neto. Modern [2] A. Bifet, G. Holmes, B. Pfahringer, and R. Gavald` a. [3] S. Brin, R. Motwani, and C. D. Silverstein. Beyond [4] F. Cajori. A history of mathematical notation ,volume [5] S. A. Cook. The complexity of theorem-proving [6] L. J. Hubert. Matching models in the analysis of [7] Y. Ke, J. Cheng, and N. Wilfred. Correlation search in [8] Y. Ke, J. Cheng, and N. Wilfred. Correlated pattern [9] Y. Ke, J. Cheng, and J. X. Yu. Efficient Discovery of [10] Y.Ke,J.Cheng,andJ.X.Yu.Top-kCorrelative [11] S. Ma and J. L. Hellerstein. Mining Mutually [12] A. Mueen, S. Nath, and J. Liu. Fast approximate [13] J. Skellam. The frequency distribution of the [14] C. Wang and L. Chen. Continuous Subgraph Pattern [15] H. Xiong, P. ning Tan, and V. Kumar. Hyperclique [16] H. Xiong, S. Shekhar, P.-N. Tan, and V. Kumar. [17] X. Yan and J. Han. gSpan: Graph-Based Substructure [18] W. Zhou and H. Xiong. Volatile correlation
