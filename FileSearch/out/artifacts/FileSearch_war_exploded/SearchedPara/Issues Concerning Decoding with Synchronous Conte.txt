 Synchronous context-free grammar (SCFG) is widely used for machine translation. There are many different ways to extract SCFGs from data. Hiero (Chiang, 2005) represents a more restricted form of SCFG, while GHKM (Galley et al., 2004) uses a gen-eral form of SCFG.

In this paper, we discuss some of the practical is-sues that arise from decoding general SCFGs that are seldom discussed in the literature. We focus on parsing grammars extracted using the method put forth by Galley et al. (2004), but the solutions to these issues are applicable to other general forms of SCFG with many nonterminals.

The GHKM grammar extraction method produces a large number of unary rules. Unary rules are the rules that have exactly one nonterminal and no ter-minals on the source side. They may be problematic for decoders since they may create cycles, which are unary production chains that contain duplicated dy-namic programming states. In later sections, we dis-cuss why unary rules are problematic and investigate two possible solutions.

GHKM grammars often have rules with many right-hand-side nonterminals and require binariza-tion to ensure O ( n 3 ) time parsing. However, bina-rization creates a large number of virtual nontermi-nals. We discuss the challenges of, and possible so-lutions to, issues arising from having a large num-ber of virtual nonterminals. We also compare bina-rizing the grammar with filtering rules according to scope , a concept introduced by Hopkins and Lang-mead (2010). By explicitly considering the effect of anchoring terminals on input sentences, scope-3 rules encompass a much larger set of rules than Chomsky normal form but they can still be parsed in O ( n 3 ) time.

Unlike phrase-based machine translation, GHKM grammars are less flexible in how they can seg-ment sentence pairs into phrases because they are restricted not only by alignments between words in sentence pairs, but also by target-side parse trees. In general, GHKM grammars suffer more from data sparsity than phrasal rules. To alleviate this issue, we discuss adding glue rules and phrases extracted using methods commonly used in phrase-based ma-chine translation. Unary rules are common in GHKM grammars. We observed that as many as 10% of the rules extracted from a Chinese-English parallel corpus are unary.
Some unary rules are the result of alignment er-rors, but other ones might be useful. For example, Chinese lacks determiners, and English determiners usually remain unaligned to any Chinese words. Ex-tracted grammars include rules that reflect this fact:
However, unary rules can be problematic:  X  Unary production cycles corrupt the translation  X  The existence of many unary rules of the form
The most obvious way of eliminating problem-atic unary rules would be converting grammars into Chomsky normal form. However, this may result in bloated grammars. In this section, we present two different ways to handle unary rules. The first involves modifying the grammar extraction method, and the second involves modifying the decoder. 2.1 Modifying grammar extraction We can modify the grammar extraction method such that it does not extract any unary rules. Galley et al. (2004) extracts rules by segmenting the target-side parse parse tree based on frontier nodes . We modify the definition of a frontier node in the following way. We label frontier nodes in the English parse tree, and examine the Chinese span each frontier node cov-ers. If a frontier node covers the same span as the frontier node that immediately dominates it, then the dominated node is no longer considered a frontier. This modification prevents unary rules from being extracted.

Figure 1 shows an example of an English-Chinese sentence pair with the English side automatically parsed. Frontier nodes in the tree in the original GHKM rule extraction method are marked with a box. With the modification, only the top bold-faced NP would be considered a frontier node. The GHKM rule extraction results in the following rules: With the change, only the following rule is extracted:
We examine the effect of this modification has on translation performance in Section 5. 2.2 Modifying the decoder Modifying how grammars are extracted has an ob-vious down side, i.e., the loss of generality. In the previous example, the modification results in a bad rule, which is the result of bad alignments. Before the modification, the rule set includes a good rule: which can be applied at test time. Because of this, one may still want to decode with all available unary rules. We handle unary rules inside the decoder in the following ways:  X  Unary cycle detection  X  Ban negative cost unary rules 3.1 Filtering and binarization Synchronous binarization (Zhang et al., 2006) is an effective method to reduce SCFG parsing com-plexity and allow early language model integration. However, it creates virtual nonterminals which re-quire special attention at parsing time. Alternatively, we can filter rules that have more than scope-3 to parse in O ( n 3 ) time with unbinarized rules. This requires Earley (Earley, 1970) style parsing, which does implicit binarization at decoding time. Scope-filtering may filter out unnecessarily long rules that may never be applied, but it may also throw out rules with useful contextual information. In addi-tion, scope-filtering does not accommodate early lan-guage model state integration. We compare the two with an experiment. For the rest of the section, we discuss issues created by virtual nonterminals. 3.2 Handling virtual nonterminals One aspect of grammar binarization that is rarely mentioned is how to assign probabilities to binarized grammar rules. The na  X  ve solution is to assign prob-ability one to any rule whose left-hand side is a vir-tual nonterminal. This maintains the original model. However, it is generally not fair to put chart items of virtual nonterminals and those of regular nontermi-nals in the same bin, because virtual items have arti-ficially low costs. One possible solution is adding a heuristic to push up the cost of virtual items for fair comparison.

For our experiments, we use an outside estimate as a heuristic for a virtual item. Consider the follow-ing rule binarization (only the source side shown):  X  BCD is the orginal rule and  X  log( p ) is the cost of the rule. In decoding time, when a chart item is generated from the binarized rule V  X  BC , we add  X  log( p ) to its total cost as an optimistic estimate of the cost to build the original unbinarized rule. The heuristic is used only for pruning purposes, and it does not change the real cost. The idea is similar to A* parsing (Klein and Manning, 2003). One com-plication is that a binarized rule can arise from multi-ple different unbinarized rules. In this case, we pick the lowest cost among the unbinarized rules as the heuristic.

Another approach for handling virtual nontermi-nals would be giving virtual items separate bins and avoiding pruning them at all. This is usually not practical for GHKM grammars, because of the large number of nonterminals. 4.1 Glue rules Because of data sparsity, an SCFG extracted from data may fail to parse sentences at test time. For example, consider the following rules:
This set of rules is able to parse the word sequence c  X  X P  X  JJ JJ NN X  at training time. Because SCFGs neither model adjunction, nor are they markovized, with a small amount of data, such problems can oc-cur. Therefore, we may opt to add glue rules as used in Hiero (Chiang, 2005): where S is the goal state and C is the glue nonter-minal that can produce any nonterminals. We re-fer to these glue rules as the monotonic glue rules. We rely on GHKM rules for reordering when we use the monotonic glue rules. However, we can also al-low glue rules to reorder constituents. Wu (1997) presents a better-constrained grammar designed to only produce tail-recursive parses. See Table 1 for the complete set of rules. We refer to these rules as ABC glue rules. These rules always generate left-heavy derivations, weeding out ambiguity and mak-ing search more efficient. We learn probabilities of ABC glue rules by using expectation maximization (Dempster et al., 1977) to train a word-level Inver-sion Transduction Grammar from data.

In our experiments, depending on the configura-tion, the decoder failed to parse about 5% of sen-tences without glue rules, which illustrates their ne-cessity. Although it is reasonable to believe that re-ordering should always have evidence in data, as with GHKM rules, we may wish to reorder based on evidence from the language model. In our ex-periments, we compare the ABC glue rules with the monotonic glue rules. 4.2 Adding phrases GHKM grammars are more restricted than the phrase extraction methods used in phrase-based models, since, in GHKM grammar extraction, phrase segmentation is constrained by parse trees. This may be a good thing, but it suffers from loss of flexibility, and it also cannot use non-constituent phrases. We use the method of Koehn et al. (2003) to extract phrases, and, for each phrase, we add a rule with the glue nonterminal as the left-hand side and the phrase pair as the right-hand side. We exper-iment to see whether adding phrases is beneficial.
There have been other efforts to extend GHKM grammar to allow more flexible rule extraction. Gal-ley et al. (2006) introduce composed rules where minimal GHKM rules are fused to form larger rules. Zollmann and Venugopal (2006) introduce a model that allows more generalized rules to be extracted. 5.1 Setup We extracted a GHKM grammar from a Chinese-English parallel corpus with the English side parsed. The corpus consists of 250K sentence pairs, which is 6.3M words on the English side. Terminal-aware synchronous binarization (Fang et al., 2011) was ap-plied to all GHKM grammars that are not scope-filtered. MERT (Och, 2003) was used to tune pa-rameters. We used a 392-sentence development set with four references for parameter tuning, and a 428-sentence test set with four references for testing. Our in-house decoder was used for experiments with a trigram language model. The decoder is capable of both CNF parsing and Earley-style parsing with cube-pruning (Chiang, 2007).

For the experiment that incorporated phrases, the phrase pairs were extracted from the same corpus with the same set of alignments. We have limited the maximum size of phrases to be four. 5.2 Results Our result is summarized in Table 2. The baseline GHKM grammar with monotonic glue rules yielded a worse result than the no-unary grammar with the same glue rules. The difference is statistically signif-icant at p &lt; 0 . 05 based on 1000 iterations of paired bootstrap resampling (Koehn, 2004).
 Compared to using monotonic glue rules, using ABC glue rules brought slight improvements for both the no-unary setting and the scope-filtered set-ting, but the differences are not statistically signifi-cant. In terms of decoding speed and memory usage, using ABC glues and monotonic glue rules were vir-tually identical. The fact that glue rules are seldom used at decoding time may account for why there is little difference in using monotonic glue rules and us-ing ABC glue rules. Out of all the rules that were ap-plied to decoding our test set, less than one percent were glue rules, and among the glue rules, straight glue rules outnumbered inverted ones by three to one.

Compared with binarized no-unary rules, scope-3 filtered no-unary rules retained 87% of the rules but still managed to have slightly better BLEU score. However, the score difference is not statistically sig-nificant. Because the size of the grammar is smaller, compared to using no-unary grammar, it used less memory at decoding time. However, decoding speed was somewhat slower. This is because the decoder employs Early-style dotted rules to handle unbina-rized rules, and in order to decode with scope-3 rules, the decoder needs to build dotted items, which are not pruned until a rule is completely matched, thus leading to slower decoding.

Adding phrases made the translation result slightly worse. The difference is not statistically significant. There are two possible explanations for this. Since there were more features to tune, MERT may have not done a good job. We believe the more important reason is that once a phrase is used, only glue rules can be used to continue the deriva-tion, thereby losing the richer information offered by GHKM grammar. In this paper, we discussed several issues concerning decoding with synchronous context-free grammars, focusing on grammars resulting from the GHKM extraction method. We discussed different ways to handle cycles. We presented a modified grammar extraction scheme that eliminates unary rules. We also presented a way to decode with unary rules in the grammar, and examined several different issues resulting from binarizing SCFGs. We finally dis-cussed adding flexibility to SCFGs by adding glue rules and phrases.
 Acknowledgments We would like to thank the anonymous reviewers for their helpful comments. This work was supported by NSF grants IIS-0546554 and IIS-0910611.

