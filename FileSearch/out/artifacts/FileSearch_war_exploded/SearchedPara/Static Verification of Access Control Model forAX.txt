 The management and access control of di stributed sensitive data such as pa-tient records are increasing ly becoming challenging issu es; however existing ap-proaches [4,6] focus on the centralized regulation of access to data. For this reason, Abiteboul et al.[1] provided a novel solution to unify the enforcement of access control mechanism based on GUP ster ( Generic User Profile + Napster )[10] and the distributed data integration by AXML (Active XML) documents[3] in a P2P architecture.

Verification of the access control mo del for AXML is non-trivial due to some challenging characteristics in itself (embedded service call, query language, and query filtering). The primary motivation of our approach is to transform the se-mantics of the access control model for AXML to CSP (Communicating Sequen-tial Processes)[9] model and verify corr ectness of query filtering for secure data access and the enforcement of combined r ules using FDR (Failure-Divergence Refinements)[5] model checker. This approach ensures that evaluation of query q over AXML document D returns only information in D that the peer is allowed to see. The main contributions of this paper are the following:
We present a static verification metho d of the access control model for AXML documents. To conduct this, first, we present how to describe an equivalent CSP model against an XSquirrel path expression, in order to express a hierarchical nature of a schema with embedded calls, q uery, and access control policy. Second, we construct CSP processes for a query ex pression, an access control policy, and a schema specific to AXML documents, by assigning the concurrency semantics of CSP language. Third, we show how to model a rewritten query created by the filtering service combined with the regula tion of access control rules. Finally, we verify access control policies against queries over AXML documents using the FDR model checking tool, by illustrating how to elicit a property model and a system model.

The remainder of this paper is organized as follows. Section 2 describes some related works. In Section 3, we illustrate the scenario of our running example. In Section 4, we define the semantics of XSquirrel expressi on, access control model in GUP ster , and query transformation. In Section 5, we show how to construct the CSP models for schema, query, policy, and query transformation. In Section 6, we illustrate how to perform static verification of the access control policies for AXML documents. Finally, we give our conclusions in Section 7. Access control for generic XML documents is a non-trivial i ssue, so fine-grained access control for them has been studied by many researchers.

Sahuguet et al.[10] developed the access control model named GUP ster ,which could support for 1) integration of highly distributed user profile XML data in a convergence network, and 2) access con trol written in the XSquirrel query language which expresses users permissions and data sources (e.g., the location of resources mapping to a query).

There has been several works to verify access control policies in the research area of databases a nd Web services[2].

Bryans[2] showed how to reason about access control policies by taking into ac-count a standard access con trol language, XACML. Fur thermore, the author pre-sented how to use CSP semantics to describe the semantics of XACML and showed how the two access control polices can be c ompared with the FDR model checking.
We consider the query transformati on and access control semantics of GUP ster for modelling and analyzing access control policies using CSP and FDR. In this regard, our research is different from related works. We give a brief overview of major concepts in an AXML document, schema, and GUP ster access control mechanism through a running example in Fig. 1. Armed with this example, we will also explain the concept of query filtering service to protect sensitive AXML data by filterin g a query according to a schema-level access control policy in GUP ster .

In this example, we assume that the peer Dr. Kim wants to see the patient record for a patient named  X  X uzzane X  before diagnos ing her. Dr. Kim is already registered in Paris hospital so that both of them are in a trust relationship. Dr. Kim already knows that the patient ID is  X 123 X  and a relevant patient record for the patient is stored in Rennes hospital after consultation with the patient. 4.1 XSquirrel Expression XSquirrel[10] is a simple XML path expression language defined in GUP ster in order to express: 1) the mappings between global document X  X  schema and remote and 3) queries over documents. This language uses a similar syntax to XPath, however it can express the view of more than one path in AXML documents by allowing a more flexible expression such as the (union) operator. For the rest of this paper, we use the simplified XSquirrel expression and semantics. Definition 1. Given an absolute XSquirrel expression q consisting of path ex-character  X / X  as in XPath expression, or  X  (union operator) X . In addition, the notation q[D] stands for an answer set of q, so it denotes the the sub-document which is presented after evaluation of semantics of the path expression. It is com-posed of all descendant leaf nodes of the requested nodes and their ancestors up to the root of the initial document. The notation Eval(q[D]) returns the mapping nodes against query evaluation of q.
 For example, given an absolute XSquirrel query q : over the document D (in Fig. 1), q[D] is the union of each XPath expression, as given below: Then, q[D] covers two branches for patient records and still retains the original document structure unlike XPath . However, Eval(q[D]) returns only two nodes VisitDate and Physid ,andtheir atomic values:
In the remainder of this paper, we use the notations q and q[D] indiscrimi-nately. The path expression may allow a conditional expression (also called pred-icates ). For example, /PatientRecord/Patient[ID="123"] returns the sub-document specific to the patient ID= X 123 X . 4.2 Query Transformation A query transformation ( query filtering ) in the combined framework of AXML documents and GUP ster is a technique which 1) protects privacy-conscious re-source from unauthorized requester by e nforcing the access control rules, and 2) leads a peer to access a third-peer ho lding a requested resource by giving a filtered query.

Recall the motivating example in Fig. 1. When Dr. Kim sends a request query q for medical resources to Paris hospital, q is rewritten into q X  through the filterACL service call enforcing the access control rules on a schema s in Paris hospital. A document of filtered query q X  , q X  X D] , is the authorized view that a peer is permitted to read a requested resource. Such an authorized view of a requester on a document depends on th e access permissions defined by an access control policy. Then, Paris hospital returns a filtered query to Dr. Kim and he can receive the restricted parts of the req uested resource from Rennes hospital, within the context that the permissions are allowed (see Fig. 1).

A simplified version of the schema for patient records is shown in Fig. 2. We assume that the data mapping and access c ontrol rules are defined in XSquirrel language as given in Fig. 3. The flo w of generating a filtered query q X  from a query q , against access control rules, can be sequentialized as below: 1) GUP ster finds all of the relevant access control rules, i ACR i , against a 2) It rewrites the query q into q X  by applying the relevant access control rules. 3) Then, it performs data integration by mapping the sub-document of a query
As an example, suppose that q from Dr. Kim is: Next, all the relevant rules Rule 1 and Rule 2 for Dr. Kim are unified based on grant overwrites 1 . Then, the combined rules are composed with the query q and the filtered query q X  is obtained with the intersection of q and the combined rules (see Fig. 3(c)): In this section, we show how to describe CSP models in a tree structure for a schema, query, access control policy and filtered query, based on the automata theory in [8]. We also assume that the conditional expression in XSquirrel is always satisfied when constructing CS P models. For example, the expression /PatientRecord/Patient[ID="123"] for CSP model will be simplified as /PatientRecord/Patient . 5.1 Modelling Schema Thus, the motivating example shown in Fig. 2 can be modelled in CSP language:
For the sake of readability, we will omit the description of sub-processes in the following CSP models. Instead, we will use the parenthesis () to rep-resent a tree structure in CSP description. In addition, the termination process ( N S , ADDRS S , BIRTH S , VISIT S , PHYSID S , DIAG S ) will be replaced with STOP or SKIP . 5.2 Modelling Query Given a query expression q , it can be modelled as a CSP process by describing the sub-document after interpreting a path expression, in XSquirrel language. For example, let us assume that there is the query q as shown in Fig. 3(c): The answer set of q , q[D] , can be modelled in CSP language as the following: 5.3 Modelling Access Control Policy An access control policy (ACP) is the compo sition of access control rules (ACR). Thus, the tuple of &lt; Requester, Resource, Action &gt; showninsection6.2canbe modelled using a compound channel in CSP. Here, we define the action read as the channel name, declare the type of the channel to be Requester , and model ACP as a Resource in a tree data structure to which can be accessed after performing read event: where PEER 1 .. n  X  Requester , and a peer can take a form of events as read.p 1 on the read channel.

As mentioned earlier, ACP is the view of a document restricted by all of relevant access control rules i ACR i . Therefore, we construct a CSP model for ACP by using interleaving parallel operator ||| to reflect on the grant-overwrites semantics in ACP. For example, let us assume that there is the peer Dr. Kim who sends a query request for some reso urces of patients record documents. Then, the ACP model for Dr. Kim can be modelled in CSP language as below: where ACR 1 and ACR 2 are the CSP processes for Rule 1 and Rule 2 , respectively, in Fig. 3(b). 5.4 Modelling Query Transformation Given a query expression q , a rewritten query q X  against ACRs is created using the intersection operator  X  and union operator , respectively:
In Section 5.3, we have already shown that the union operator is well suited with an interleaving parallel operator ||| in CSP expression. Here, we insist that the semantics of  X  operator is well described with a synchronized parallel operator | [ A ] | where A is a set of events in a process model. For a better understanding, let us consider an example of showing how the CSP model Q X  for a rewritten query q X  denoted in Section 4.3, can be modelled using with the synchronized parallel operator: where A is a set of events such that A =  X  (Q)  X   X  (S)  X   X  (ACR 1 )  X   X  (ACR 2 ) . Note that the parallel composition between S , and the union of ACR 1 and ACR 2 represents a schema-level access control model for AXML documents.
 6.1 Analysis of Access Control Policy In this subsection, we show how to specify Spec model and System model to analyze desired properties such as:  X  A query is evaluated against an access control policy.  X  A policy should be defined in order to prevent the leakage of sensitive data  X  A policy should be defined in order to a llow a peer to access a uthorized data.
The requester X  X  query q against an access control policy is always-granted if a set of trace events of the query process Q is a subset of those of both the schema process S and the policy process ACP : where A is the event set between S and ACP such that A =  X  ( S )  X   X  ( ACP ), and assert is the reserved word for equivalence checking in FDR. Note that the parallel process S | [ A ] | ACP represents a schema-level access control model for AXML documents. For example, let us assume that the query q from Dr. Kim is : Then, we can confirm that S | [ A ] | ACP T Q is satisfied using FDR tool. However, if the query q is:
Then the CSP model Q for its answer set q [ D ], means the following process semantically, according to the definition in Section 4.1:
In this case, the FDR model checker shows the counterexample of: patientrecord , policy rewrites q into q X  to protect privacy-conscious Xray data by enforcing all the relevant rules, and then the filtered query q X  is: We have presented a verification metho d for analyzing an access control model for restricting query access to AXML documents by modelling query, schema, and access control policy as tree data str ucture in CSP language. We have also shown how to translate the declarative s emantics of an access control policy of GUP ster and the rewritten query created by a filtering service to CSP models. Thereby, given CSP models for a query, access control policy, and schema for AXML document, our static verification can not only determine whether the requested query is permitted by the schema-level access control policy or not, but also show a hierarchical path i f access to data is allowed or not.
