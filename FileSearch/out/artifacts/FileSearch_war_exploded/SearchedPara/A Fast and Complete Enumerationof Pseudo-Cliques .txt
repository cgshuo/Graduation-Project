 Hongjie Zhai 1 , Makoto Haraguchi 1( Detecting communities in a network has been an important task in Social Net-work Analysis [ 10 ]. Cliques are typical vertex sets understood as potential com-munities [ 11 ]. Moreover, the class of cliques has an anti-monotonicity property helpful in designing an efficient enumerator for them. In a real world network, however, the clique model is too restrictive to capture various communities because it is rare for actual communities to appear as cliques. This would moti-vates us to study clique relaxation models and various pseudo-clique models have been proposed [ 11 ].
 partitioning methods are well known to be useful (e.g. [ 8 , 9 ]). However, when we aim at obtaining smaller communities, we shall use (pseudo-)clique detectors instead of those methods because they usually suppose small numbers of clus-ters whose sizes are consequently non-small and hence our targets are invisibly merged and absorbed into those larger clusters.
 suring the density of vertex sets are presented. Unlike the clique model, since this class of pseudo-cliques do not satisfy the anti-monotonicity property, effi-cient but heuristic detectors have often been proposed for searching them [ 7 ]. We therefore might loose some vertex sets possibly valuable for us. Moreover, even if we have a complete detector, it cannot process large scale networks because of the hugeness of the number of pseudo-cliques. In spite of these difficulties, it is still important to develop an efficient complete enumerator that can handle large networks because such an enumerator is useful not only for community discovery but also for analyzing the nature of large networks in terms of statistics about (pseudo-)cliques [ 18 ].
 As another clique relaxation models, a distance-based model, k -clique [ 2 ], and diameter-based models, k -club and k -clan [ 3 , 4 ], have been proposed. The parameter k controls admissible distances among vertices. As discussed in [ 5 ], when we allow a longer distance, large dense subgraphs appear which are almost cliques even when its subgraphs w.r.t. the original edge connection are not dense. On the other hand, a k -Plex model [ 6 ] discusses the density in terms of original connection by setting an upper bound for the number of missing edges among vertices. The class of k -Plexes has an anti-monotonicity property which helps us to design a simple bottom-up enumerator [ 1 , 15 ]. For this reason, we discuss k -Plexes in this paper, introducing new constraints that can cover its weakness we discuss just below.
 A vertex set is called a k -Plex if, for each vertex x in it, the number of vertices not adjacent to x is at most k . Disconnection Upper Bound (DUB) thus specified by the parameter k . Note that a k -Plex could be non-connected. However, since it seems not interesting as a community, we exclude those ones from our consideration.
 For a very small k , connected k -Plex is in fact dense if its size is relatively larger than k . On the other hand, as the size of densely connected vertex set increases, the number of disconnected vertices, k per each vertex, shall be non-small depending on density requirement. In other words, we think some con-straint taking the sizes of targeted pseudo-cliques into account is important. When we suppose a k -Plexofsize n , then each vertex has at least n vertices, where n  X  k must be a certain number provided we admit the vertex set as a densely connected one. We thus introduce another constraint using a para-meter j designating Connection Lower Bound (CLB) . Then we try to enumerate all maximal connected k -Plexes meeting the CLB constraint.
 A naive strategy, computing maximal k -Plexes and then checking the CLB constraint, does not work well when we consider non-small k because every vertex set with size no larger than k is trivially a k -Plex so we have to examine exponential number of such sets. The key to solve this problem lies in another fact that, if a connected k -Plex X can be extendable to a maximal connected k -Plex under the CLB constraint, X is involved in a  X  X ore X  of X together with candidates that are potential vertices to be added to X , where the term  X  X ore X  means the largest subset of vertices with at least j adjacents in the subset [ 19 ]. In this paper, j is fixed beforehand depending on the targeted vertex set size. The monotonicity of core operation is suitable to standard k -Plex enumerator enjoying the anti-monotonicity of k -Plexness. Based on the monotonicities, we can design an efficient complete depth-first algorithm which can exclude numer-ous hopeless k -Plexes that cannot be extended to maximal ones meeting our requirement. This realizes much improvement of performance of k -Plex enumer-ator. In our experimentation, we compare our algorithm with a state-of-the-art maximal k -Plex enumerator proposed very recently [ 1 ] from the viewpoints of computational performance and quality of solution k -Plexes as pseudo-cliques. For synthetic and real world large networks including a Web graph with over 800,000 vertices, it is verified that the CLB constraint as well as our pruning mechanisms are quite effective and as the results, the proposed algorithm can work very well as a practical tool for detecting dense pseudo-cliques. An undirected graph is denoted by ( V,  X  ), where V = { v vertices and  X  ( v n )= { v m  X  V | v n ,v m are adjacent include v n itself. An ordering  X  over V is defined by v i younger than v j iff i&lt;j . If the identifiers, i of v i prefer the notation for vertices as v, x, u and so on. For a vertex set X G [ X ] is a subgraph of G induced by X .Foravertex x  X  X ,  X   X  ( x )  X  X . |  X  X ( x ) | is often referred to as deg X is easy to see that for a k -Plex Y , any subset X of Y is also a k -Plex, Thus, the class of k -Plexes has an anti-monotonicity. A vertex y/ Plex candidate if Xy is still a k -Plex, where Xy is an abbreviation of X Cand ( X ) denotes the set of all k -Plex candidates of X . We especially discuss in this paper connected k -Plexes (c-k -Plexes, for short).
 is given by the minimum length of paths in G from X to y , where dist ( X, x )=0 whenever x  X  X . dist ( X, y )=  X  only when y is not reachable from X . D is defined as { y  X  V | dist ( X, y )= n } . K 1 ( X )= D Plex candidates directly connected to X , plays a key role in discussing c-k -Plexes and is called a K 1 -candidate set at X . A maximal c-k -Plex, abbreviated as k -MPC, is a c-k -Plex that is maximal among c-k -Plexes. It is clear a c-k -Plex X is extendable to its super c-k -Plex iff K  X  . Thus, the extension is made by adding K 1 -candidates at X to X . { v its formation ends at Z = Z f | Z | with K 1 ( Z )=  X  .
 We have multiple formations Z f for a k -MPC Z , depending on the order of vertex addition. In fact, for an arbitrary initial vertex v addition of v n i  X  Z such that v n i is adjacent to some vertex added prior to v Then any intermediate X i (  X  Z )isac-k -Plex by the monotonicity of k -Plexes and Z f with the index f such that f ( i )= n i gives a formation of Z . In Sect. 5 , we introduce some control rules to disregard useless formations under the restric-tion that formations must be those for k -MPCs whose density is guaranteed by another parameter j . In this section, we define a class of k -MPCs, as our targets, which are dense in the sense that each vertex has at least j adjacents in them. We then discuss how to enumerate those targets completely and efficiently.
 Given a graph G =( V,  X  ), a vertex set X is said to be j -cored if deg for any x  X  X . The largest j -cored set, denoted by core G [ X ]. We can observe a monotonicity of j -core operation.
 Fact (Monotonicity of j -Cores): For vertex sets X 1 ,X 2 core ( X 2 ) holds whenever X 1  X  X 2 .
 The construction of core j ( X )foravertexset X is simple. Roughly speaking, it can be obtained by iteratively removing vertices with degree less than j from X . Since removing some vertices in general decreases degree of other vertices, we can iterate such a removal until no vertex can newly be removed. A behavior of j -core operation is illustrated in Fig. 1 . Any connection towards v are firstly removed as deg X ( x i )=2 &lt;j = 3. By this removal, auxdeg ( x becomes 2. So x 5 is furthermore removed. Then, no more removal is made by degree lower bound constraint in this case, since all remaining vertices x and x 4 still have at least j adjacents even after the removals so far. MPCs (( j, k )-MPCs, for short). The following discussion is devoted to an efficient algorithm for enumerating every ( j, k )-MPCs.
 monotonicity property. In spite of this fact, we can give a sufficient condition for c-k -Plexestogrowto j -cored ones. Then, we can use the condition conversely to reject hopeless c-k -Plexes appearing in formations.
 Fact (Hopeful c-k -Plex): Let X be a c-k -Plex extendable to some ( j, k )-MPCby adding vertices to X . Then satisfying the negation of ( 2 ). j -core is weak particularly for small X with its size less than k . In that case, a large number of vertices appear as k -Plex candidates independently of the length of paths connecting X and candidates. As X is extended to include vertex y more distant from X , the shortest path connecting X and y in the extension becomes longer. Consequently, such an extended Y will not be k -Plex, because there exist many vertices not adjacent to y on the path. As long as we target connected k -Plexes including X , the distance limit becomes a key to define U ( X )= U ( X )  X  D 1 ( X ) as a set of potential candidates to obtain ( j, k )-MPCs. suggests that the construction of U ( X ) depends on the sizes of X . In the right figure, for a singleton Y of the black circle y , Y  X  Cand ( Y ) is the whole vertex set that is j -cored, where j = 2. Nothing is therefore removed by taking j -core for Y  X  Cand ( Y ). Nevertheless, note that the vertex z cannot be consistent with Y to make a c-k -Plex, as dist ( Y, z )=4 &gt;k = 3. More precisely, on the paths connecting y and z , there are 4 vertices not adjacent to z including z itself. Hence, there is no c-3-Plex involving Yz . For this reason we removed z before we test if Y is extendable to j -cored c-k -Plexes. N candidates together with Y . Then core j ( N 3 )=  X  asserting that there exists no j -cored c-k -Plex containing Y .
 On the other hand, the left figure shows a case of X with larly, when k = 3, vertices with dist ( X, z ) &gt; 3 cannot be members of c-3-Plex including X . After excluding vertices violating the distance limit, we take 3-core. y 2 ,y 3 are firstly removed, and then y 1 is. The remaining part, surrounded by dotted line and filled by pattern, is 3-cored and is a maximal 3-Plex in this case. 4.1 Small C-k -Plex small size is a c-k -Plex. In this case, therefore, Cand ( X ) is given as V is generally large. To disregard useless candidates, we make a question whether there exists some c-k -Plex Z such that Xy  X  Z for a small c-k -Plex X and y/  X 
X . When dist ( X, y )=1, Z = Xy is a trivial positive answer, so we analyze the case of = dist ( X, y )  X  2. Consider the shortest path p =( y from X to y in G [ Z ], where y 0  X  X and y 1 , ..., y  X  Z . Then, not adjacent to X , y 1 , ..., y  X  2 and y = y itself. Z is a k -Plex, so it must be |
X | +(  X  2) + 1  X  k . Hence we have  X   X  k  X  X  X | + 1. In other words, y with dist ( X, y ) &gt;k  X  X  X | + 1 can never be a member of any c-k -Plex including X . So, we have more accurate definition for U ( X ) for small case as follows. The distance limit decreases as X enlarges, so K ( X ) is monotonic decreasing. 4.2 Medium c-k -Plex any vertex whose distance from X is greater than 1 is never a k -Plex candidate, as it has no connection with at least k vertices in X . Hence, Cand ( X )= K and U ( X ) is exactly given as 4.3 Large c-k -Plex We say that c-k -Plex X is large if | X | X  j + k . Any large X is j -cored, as j  X |
 X  X ( x ) | is derived from j + k  X | X | and | X  X   X  X ( x ) We need not take j -core, that is, U ( X )= X  X  Cand ( X ). So we have the rule for updating U as follows.
 The rule for large case is the same as one for k -Plexes. 4.4 Formations Revised for ( j,k )-MPCs Using U ( X ) thus defined depending on | X | , a formation Z of ( j, k )-MPC Z satisfies ( 6 ) is stronger than ( 1 ) since U 1 ( Z f i )  X  K 1 ( Z U ( Z )  X  K 1 ( Z )and K 1 ( Z )=  X  by the property of ( j, k )-MPC as a k -MPC. As a c-k -Plex Z is more densely connected, the number of possible formations of Z increases. For our efficient computation, we can enjoy two search control rules, right and left rules, to avoid useless and duplicated formations. useless formations. A formation Z f =( v f (1) ,...,v f ( extending an intermediate Z f i with a vertex in U 1 ( Z f plete enumeration of formations, we have to examine every vertex in U extend Z f i . Some of them, however, result in non-maximal k -Plexes. Extending an idea discussed in [ 13 , 14 ], we can identify the candidate set, R ( Z property that adding member vertices in R ( Z f i ) only to the present Z achieves a maximal k -Plex. Thus, the set of vertices actually used to extend Z here can be regarded as an extended version of RCCs in [ 15 ] in the sense that it is much more applicable for non-small Z f i than that in [ 15 ]. Although we skip the details due to space limitation, interested readers can refer to [ 16 ]. LCC) with which just one formation for each ( j, k )-MPC can be composed. LCC is in some sense a standard technique for set enumeration [ 17 ] and is almost sim-ilar to what is stated in [ 13 ]. Roughly speaking, when we extend an intermediate Z i , we do not need to care any vertex y such that y didate, because any formation obtained by extending Z f i composed by extending another intermediate formation with some left candi-date ( = y ). Thus, the set of vertices we actually use to extend Z not go into the details, effects of the control rules in the form of search tree are illustrated in the next section. We present an algorithm in Fig. 4 for making formations for ( j, k )-MPCs. The algorithm is written using recursive calls of procedure Expand . This realizes a depth-first search of ( j, k )-MPCs.
 We depict in Fig. 3 the invocation process of Expand in the form of search tree  X  , to a leaf just corresponds to a formation of c-k -Plex. Dark circle shows hopeless c-k -Plexes from which no branch is expanded. Double circle is a ( j, k )-MPC. Single circle has chance of extension by choosing some of NR ( X ) Dark triangle is a c-k -Plex P such that every non-right candidate is left. This means that ( j, k )-MPC Z obtained by extending X is generated by another branch with some left candidates along the path. In other words, with some initial segment X of Z and its non-left  X  NR ( X ), Z appears in the subtree rooted by X . Finally, white square J is a j -cored c-k -Plex which is not k -MPC. It is maximal in the sense that there exists no j -cored c-k -Plexes including J . Although it is straightforward to exclude such a J with the condition K we allow to output J in addition to all possible ( j, k )-MPCs.
 Another point we have to note here is that every ( j, k )-MPC is a subset of components, and since our targets must be connected, we make the algorithm run for each connected component C of core j ( V ).
 For setting parameters k and j , we assume a preferable size range [ n and a density parameter  X  . Then the connection lower bound will be j = n and the disconnection upper bound k = n 2  X  (1  X   X  ).
 We present in this section our experimental results. The proposed system, referred to as JKMPC , has been coded in Java and executed on a PC with Intel Core TM -i7 (1.7 GHz) processor and 8 GB memory. For several datasets, we observe computation times and quality of solutions as pseudo-cliques. MaxKplexEnum , a state-of-the-art maximal connected k -Plex enumerator [ 1 ] 2 . as WS , based on Watt-Strogatzs Model [ 20 ]. As real datasets, we have prepared benchmark networks, DBLP and Google [ 21 ]. DBLP is a collaboration network constructed from the DBLP Computer Science Bibliography. Authors as nodes are connected if they have published a paper together. Google is a Web graph consisting of web pages and their hyperlinks. Scale and degree distributions of those networks are presented in Fig. 5 .
 MPCs. In this sense, it is difficult to farely compare JKMPC with others. However, our target k -MPCs can be obtained by any maximal k -Plex enumerator with j -coreness check. Therefore, we here observe computational performance of a state-of-the-art enumerator, MaxKplexEnum [ 1 ], and our JKMPC in order to verify practical efficiency of our system. Given a network, MaxKplexEnum can enumerate a designated number N of maximal k -Plexes. That is, in order to completely obtain our target ( j, k )-MPCs with MaxKplexEnum , we have to give an adequate value of N which can provide a set of candidates completely including all of our solutions. It is, how-ever, impossible to identify such a suitable N in advance. Therefore, in our comparison here, we first run JKMPC and identify the number of our solutions, say  X 
N . Then, we try to detect  X  N maximal k -Plexes by MaxKplexEnum . It is noted here that those k -Plexes extracted by MaxKplexEnum do not always contain all of our solution ( j, k )-MPCs. That is, the value of  X  N can provide MaxKplexEnum the best-case scenario. 7.1 Computational Performance Figure 6 shows computation times by both systems, where solid lines are for JKMPC and dotted lines for MaxKplexEnum . Data points for each k -value are dis-tinguished by point types (e.g.  X  , ). Moreover, missing points mean we have failed to extract all solutions within 12-hours.
 The larger a j -value is, the smaller the number of ( j, k )-MPCs becomes. That is, the task of MaxKplexEnum would be easier at a higher range of j because MaxKplexEnum can run much faster than ours at higher ranges of j . However, its performance suddenly gets worse, as j becomes slightly smaller. In most of the cases, it has failed to complete enumerations within the time limit. For example, in case of WS with k =3and j = 9, the number of solutions MaxKplexEnum has to extract is about 20 times larger than that in case with j = 10. The difference has caused a rapid increase of computation time.
 quite hard for MaxKplexEnum , our system can enumerate all solutions. In other words, JKMPC has an ability for extracting ( j, k )-MPCs even with relatively small size. This is a remarkable advantage of our system because it is quite difficult for standard methods of graph clustering and partitioning to detect such small dense subgraphs. Thus, it is verified that JKMPC is an efficient and practical system for enumerating ( j, k )-MPCs. 7.2 Quality of Solutions as Pseudo-Cliques Since the notion of k -Plex has originally been proposed as a relaxation model of clique, any maximal k -Plexes with lower densities would be undesirable. In order to examine quality of solution k -Plexes from the view point of pseudo-cliques, we observe density distributions of solutions obtained by MaxKplexEnum and JKMPC . figures are distributions by MaxKplexEnum and lowers by JKMPC .For WS , solutions by MaxKplexEnum have density of 0 . 80 on average with the standard deviation of 0 . 14. For DBLP and Google , the average densities are 0 . 65 and 0 . 75 on average, where their standard deviations are 0 . 15 and 0 . 17, respectively. On the other hand, for WS , the average density by JKMPC is 0 . 95 and the standard deviation is less than 0 . 018. For both DBLP and Google , moreover, their average densities are about 0 . 99 with the standard deviations less than 0 . 0018. It is obvious that solutions by JKMPC have sufficient densities. All of them would be regarded as pseudo-cliques without any doubt. However, solutions by MaxKplexEnum include many maximal k -Plexes with relatively low densities. In other words, quality of solutions by MaxKplexEnum is unstable. Thus, JKMPC can practically work as an effective pseudo-clique detector. In this paper, we designed an efficient complete algorithm for enumerating ( j, k )-MPCs. For efficient computation, we discussed several search mechanisms which can effectively prune many useless search nodes. Our experimental results showed the algorithm can work well as a practical tool for extracting densely-connected pseudo cliques in large networks.
 Although our j -coreness constraint can drastically reduce the number of solu-tions to be enumerated, we would still suffer its hugeness when we are concerned with much larger scale networks. It is, therefore, worth introducing some addi-tional constraint which more tightly targets our solutions. The authors are cur-rently developing a reasonable constraint, taking distance among communities or separateness between clusters into account. Based on the consideration, we expect efficiency of our algorithm can further be improved and it can practically work even for huge networks with over million vertices.

