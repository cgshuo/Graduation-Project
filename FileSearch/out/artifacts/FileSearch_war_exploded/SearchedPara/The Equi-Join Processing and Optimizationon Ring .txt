 In the age of information explosion, very large data sets pose a new challenge for the data storage systems. Companies (e.g. Google) need to analyze petabytes of information from web pages. Facebook wants to find the relationship among hundreds of millions of people. The traditional relational database has been unable to meet the requirements. To achieve high reliability and scalability, many data storage systems have adopted th e distributed archit ecture. According to the difference of the architectures, t he distributed data storage systems can be classified into two categories. One is the master-slave architecture distributed system (e.g. Hadoop [1]). This kind of system is designed for the data warehouse which has poor performance in data random access. The other kind is ring architecture distributed system which has higher availability. This kind of system is appropriate for storing the data which often updates (e.g. web information), for instance, Cassandra [2] in Facebook and Dynamo [3] in Amazon.

For many data analysis tasks, join query especially the equi-join is very essen-tial. The MapReduce [4] framework is highly desirable for performing scalable parallel data analysis on MSADS and equi-join can be implemented by utilizing MapReduce [5,6]. Recently, some open sour ce projects (e.g. Pig [7] and Hive [8]) have already realized this function. Moreover, some more in-depth research has been done, for instance, multi-way join [9] and inequality-join [10] based on the MapReduce framework. However, accord ing to our survey, most of the research does not consider the situation in which the original data updates frequently.
Because there is no mater node and each node in the cluster is parallel, RADS cannot support the MapReduce framework directly. For the data analysis tasks, there is no universal paradigm on RADS. For the equi-join process, the developed algorithm on MSADS using MapReduce framework can X  X  be utilized on RADS as well. This issue poses a new challenge for the data analysis on RADS.
In this paper we propose a novel algorithm that enable efficient parallel exe-cution of equi-join on RADS without MapReduce. Furthermore , we design the update method on RADS. In particular, we make the following contributions. 1. Based on the ColumnFamily data model, we propose CVI on ColumnValue, 2. In order to further improve efficiency, we build MI, and use MI to reduce 3. By utilizing CVI and MI, a new algorithm, called Pre-join Table Genera-4. For the alteration of the join result caused by the original data updating, The rest of the paper is organized as fo llows. Section 2 briefly introduces the related knowledge and our devise goals. Section 3 discusses the details of our proposed PJTG algorithm. Section 4 explains the update approach of join result as the extension of PJTG. Section 5 describes the experimental results and related analysis. Finally, the conclusion of this paper is stated in Section 6. 2.1 Overview of Distributed Architecture As we explained earlier, there are two types of distributed systems, MSADS and RADS. For MSADS, master node is the single director of the cluster and it stores the meta-data of the entire system, and each slave node is only responsible for the local data storage. For RADS, there is no mater node, each node in the cluster is parallel. RADS utilizes the consistent hashing algorithm [11] to organize and manage the cluster. Figure 1 illustrates the architecture of MSADS and RADS. As Figure 1(a) shows, for MSADS, while the MapReduce task starts, the JobTracker on the master node m becomes the task controller, it is responsible for the task allocation and maintains the balance of workload on each slave node. Slave nodes (e.g. s 1 , s 2 ) become the workers on which the subtask is executed, and there is no communication between slave nodes. As we have seen, in a sense, the master node is the key of MapReduce. In Figure 1(b), there is no mater node, each node is parallel in RADS. All the nodes maintain the route information of the entire cluster. Therefore, RADS has high availability without single point of failure. However, unfortunately, it is unable to process the traditional MapReduce task directly on RADS. 2.2 ColumnFamily Data Model ColumnFamily data model comes from BigTable [12]. A ColumnFamily is equiv-alent to a Table in RDBMS. Figure 2 illustrates an instance of ColumnFamily.
As figure 2 shows, ColumnFamily contains a plenty of rows and each row is a key/value pair. The key of a row is defined as RowKey (e.g. k 1 ) and it is one and only in order to distinguish other rows. The value of a row is a set of columns. A column is a key/value pair with a timestamp. We define the key of column as ColumnKey (e.g. c 1 ) and the value as ColumnValue (e.g. v 1 ). Note that there is no independent index on column because each data can be obtained only by utilizing the RowKey in the key/value data storage systems . In order to facilitate the expression, we use Row( k ) to represent the row whose RowKey is k ,Col( c ) to represent the column whose ColumnKey is c . 2.3 Join Conditions Based on ColumnFamily According to the definition above, the condition of equi-join based on Colum-nFamily data model can be redefined into three types. For Col( c 1 ) in Column-Family cf 1 and Col( c 2 )in cf 2 , the three types of conditions are: Condition 1 means the join condition of two ColumnFamilies is that the Rowkey of cf 1 is equal to the Rowkey of cf 2 . Condition 2 means the join condition is the ColumnValue of Col( c 1 )in cf 1 is equal to the Rowkey of cf 2 . Condition 3 means the join condition is the ColumnValue of Col( c 1 )in cf 1 is equal to the ColumnValue of Col( c 2 )in cf 2 . Obviously, the third type is the most representative and the other two are the simplified models from it. Therefore, in this paper, we mainly study on the third type of equi-join. 2.4 Optimization Goals Unlike the MapReduce framework, there is no control centre while executing data analysis task on RADS. Therefore, the approach we design must be able to be executed on each node of the cluster independently which has low mutual constraint and high parallel processing capability. Moreover, as we mentioned in Section 1, the data stored on RADS updates frequently. Hence, while the original data changes after the equi-join task achieves, the join result must update to keep validity. The situation of update needs to be considered in our algorithm. The PJTG contains three phases. Firstly, two CVIs for the join-condition columns should be built. Secondly, find the rows with the same RowKey in both CVIs, and MI is built to avoid the useless disk read. Finally, accomplish the euqi-join and generate the join result. The detail is as follows. 3.1 Build CVI For the equi-join condition 3, firstly, CVI, which is similar to the secondary in-dex [13], should be built for each join-condition column(e.g. c 1 ,c 2 )oftheColum-nFamily . In detail, CVI is a ColumnFamily structure logically, and it is designed to search the RowKey for a given ColumnValue of a specified column. Figure 3 illustrates an instance of CVI.
 As Figure 3 shows, CVI cf 1 c 1 is built for Col( c 1 ) in ColumnFamily cf 1 .Inthe CVI, RowKeys are the ColumnValues of Col( c 1 )in cf 1 .ForaRow( v 1 )inCVI, ColumnKeys(e.g. k 1 ,k 3 ) are the RowKeys whose ColumnValue of Col( c 1 )in cf 1 is v 1 , and the ColumnValue is null . Via CVI cf 1 c 1 , for a given ColumnValue v 1 of Col( c 1 )in cf 1 , we can get all the RowKeys whose ColumnValue of Col( c 1 )is v 1 and all the information of those rows in cf 1 .
 For the storage of CVI, the consistent hashing algorithm is employed. Assume CVI for Col( c ) in ColumnFamily cf needs to be built, for a given hash function h and a data storage node i ,foreachRow( k )in cf on node i , the ColumnValue v of Col( c ) could be obtained easily. Via h ( v ), the address p where the Row( v ) of CVI cf c stores could also be computed. Finally, the insert message is sent to the node whose address is p .

Each node of the cluster could perform ance the above period of process in-dependently. Hence, there is no need for t he control centre to keep parallel. In addition, the MD5 random hash function is utilized to maintain the load bal-ance. According to our simulation experiment, workload on each node is almost the same. For the join condition 3, CVI cf 1 c 1 ,cf 2 c 2 should be built accord-ing to the approach above. The mission of next phase is to find the rows with the same RowKey in CVI cf 1 c 1 ,cf 2 col 2 and get the set of ColumnKeys of each row. Note that owe to the consistent hash distributed storage type of the CVI, the rows with the same RowKey mu st be stored at the same node. Hence, the second phase can also be executed on each node independently without the communications between nodes. 3.2 Build Memory Index To achieve the mission of the second phase, at local address of each node, the general method is that for each RowKey k which is get from CVI cf 1 c 1 (this operation contains one disk read), find the Row whose RowKey is equal to k in CVI cf 2 c 2 (this operation contains another disk read). Maybe there is no such row in CVI cf 2 c 2 , but we still have to perform two disk read operations at least to make sure that. This series of operations especially the disk read are time-consuming and useless. This situation is called MissRead . In some practical applications, the MissRead is very frequent and causes the obvious performance degradation. Therefore, this case mu st be considered in our algorithm.
To avoid MissRead, an index maintained in the memory, MI, is built on each node independently. In detail, MI is a hashmap. The key of MI is the RowKey of both CVI cf 1 c 1 and cf 2 c 2 at local address. The value of a key k should be small enough to enable mass index, but the pointer which points to the disk position of Row( k ) is not appropriate. Because in RADS, the storage position of a row is adjusted sometimes(e.g. the data compaction). In that case, a plenty of the pointers will change, which causes the MI updates in a large scale. Hence the way making the pointer as the value of MI is unseemly. In our algorithm, for a key k of MI, the value is a array with two items, and each item is a counter which flags the amount of columns in Row( k ) of one CVI. For instance, assume that the first item of the array is the counter for CVI cf 1 c 1 and second is for cf 2 c 2 , a insert message SET( cf 1 c 1 , v,k,null ) is received at node i , which means insert adataintoCVI cf 1 c 1 with RowKey v , ColumnKey k , ColumnValue null .Then browse MI to get the value flags of key v ,andmake flags [0] plus 1. Note that for a key k in MI, when neither the two items of the value are equal to 0, the Row( k ) must be the one which cannot cause MissRead, so we can store k into a set V . Finally, the set V is all the exact RowKeys we need.

Obviously, when the system finishes building the CVI, the MI is accomplished too. Moreover, join-condition columns (e.g. c 1 , c 2 ) is either the major key or the foreign key in a ColumnFamily commonly. Therefore the schema of the Column-Family can be confirmed while creating, and all the phases above can be executed as pretreatment before join operation. The pretreatment will greatly reduce the time cost of the whole process. 3.3 Accomplish the Join Process In the final phase, firstly for each v in the set V generated in the second phase, get the ColumnKey set ck 1 which belongs to the Row( v )inCVI cf 1 c 1 ,and ck 2 in cf 2 c 2 with the same way. Make cartesian product of ck 1 and ck 2 to get the result set keys . According to each ordered pair in keys , we can return to cf 1 and cf 2 to extract the rows we need, and insert them to the join result ColumnFamily ResultCF . The RowKey is named as k 1 k 2 if a Row( k 1 k 2 )in ResultCF is the join result of Row( k 1 )in cf 1 and Row( k 2 )in cf 2 . 3.4 PJTG Description Algorithm 1 describes the flow path of th e whole process. Firstly, some neces-sary variable is initialized(Line 1). Secondly, call function createIndex( cf , c , la , i )(See Algorithm 2 and 3 for detail) to generate CVI, MI, and the RowKey set of CVI without MissRead V (Line 2 -3). Then, for each Rowkey v in set V , get the ColumnKey sets of both CVI and make cartesian product to generate decareList (Line 4 -8). Finally for each ordered pair ! k 1 ,k 2 " in decareList ,re-turn to the ColumnFamily cf 1 , cf 2 and get the data we need, then insert it into the join result(Line 9 -13). Note that we utilize the predicate pre 1 , pre 2 to extract the exact columns we want and reduce the size of join result.
Algorithm 1. PJTG algorithm
Function createIndex( cf , c , la , i ) mentioned in Algorithm 1(Line 2 -3) is used to create CVI, MI, and the RowKey set V , which contains two parallel threads a for the main data process at local address(described in Algorithm 2) and b for monitoring the message from other nodes(described in Algorithm 3).

Algorithm 2. createIndex( cf , c , la , i ) (thread a )
In Algorithm 2, Firstly for each Row( k )of cf at local address, get the Colum-nValue v of Col( c )(Line 2 -3) and compute the storage node address ad of v as RowKey of CVI cf c (Line 4). If ad is equal to local address la , insert this data into CVI cf c locally and call function MIInsert( h , v , i )(See Algorithm 4 for detail)(Line 5 -7). Else, send the insert message to the node with address ad (Line 8 -9). At last, broadcast the message over the cluster to indicate the accomplishment and make count plus 1(Line 10 -11).

In Algorithm 3, a message m is received from the listen port(Line 1). If m is a insert message, insert this data into CVI cf c locally and call function MIInsert( h , v , i )(Line 2 -4). If m is an accomplishment message, add 1 to count (Line 5 -6). When count is equal to the total number n ,whichmeansall the nodes in the cluster finish this period of process, the algorithm ends.
Algorithm 3. createIndex( cf , c , la , i ) (thread b )
Algorithm 4 describes the function MIInsert( h , v , i ) which arise in Algo-rithm 2(Line 7) and 3(Line 4). Firstly, get the value temp of the key v in the hashmap(Line 1). If temp is an empty set, initialize an integer array flags and turn flags [ i ] to 1, then insert pair( v,flags )into h (line 2 -5). If temp is not an empty set and temp [ i ]is0,add1to temp [ i ]. Note that this is the first time neither item of temp is 0, which means RowKey v is not able to cause MissRead, so insert v into V (Line 6 -9). If temp isnotanemptysetand temp [ i ] is not 0, add 1 to temp [ i ] only(Line 10 -11).

Algorithm 4. MIInsert( h, v, i ) As we mentioned in the introduction, the data stored in RADS updates fre-quently. After the equi-join achieves, the data structures we build such as CVI, MI and the join result ColumnFamily need to keep update when the original data changes. Hence, in this section, we will introduce the approach for update. As a prerequisite condition, for condition 3, the result ColumnFamily ResultCF for ColumnFamily cf 1 , cf 2 has been built by utilizing PJTG algorithm.
The approach for the update caused by the join-condition column contains two types of operations, DELETE and INSERT. In addition, INSERT contains INC and MOD operation. The detail is described as follow.
 For DELETE( cf 1 , k 1 , c 1 ) which means the join condition column, Col( c 1 )of Row( k 1 )in cf 1 , is asked to be deleted, before this operation is done, the original ColumnValue v of Row( k 1 ), Col( c 1 )in cf 1 must be obtained. Then on the node where the Row( v )ofCVI cf 1 c 1 stores, CVI cf 1 c 1 and MI need update. Then get the ColumnKey set keys of Row( v )inCVI cf 2 c 2 .Foreach k in keys , delete Row( k 1 k )in ResultCF .

For INSERT( cf 1 , k 1 , c 1 , v 1 ) which means a ColumnValue v 1 is asked to insert Col( c 1 )in cf 1 must be obtained. If v is  X  , which means this is a new write operation, this operation can be transformed to INC( cf 1 , k 1 , c 1 , v 1 ). In this case, on the node where the Row( v 1 )ofCVI cf 1 c 1 stores, CVI cf 1 c 1 and MI need update. Then get the ColumnKey set keys of Row( v )inCVI cf 2 c 2 .For each k in keys ,newRow( k 1 k )joinedbyRow( k 1 )in cf 1 and Row( k )in cf 2 is wrote into ResultCF .

If v is not  X  , which means this is a modification operation, this operation can be transformed to MOD( cf 1 , k 1 , c 1 , v 1 ). In this case, before INSERT done, DELETE( cf 1 , k 1 , c 1 ) needs to be executed to delete the overdue data. Then
The approach for the update caused by the none-join-condition column is straightforward because there is no alterations of CVI and MI. For DELETE( cf 1 , k , c 0 ) which means the none-join-condition column, Col( c 0 )ofRow( k 1 )in cf 1 , is asked to be deleted. Firstly, ColumnValue v of Row( k 1 ), Col( c 1 )(the join-condition column) in cf 1 needs to be obtained. Then on the node where the Row( v )ofCVI cf 1 c 1 stores, get the ColumnKey set keys of Row( v )inCVI cf 2 c 2 .Foreach k in keys , delete Col( c 0 )ofRow( k 1 k )in ResultCF .TheIN-SERT operation is similar to DELETE, then we omit the details. In this section, we will evaluate the p erformance of our proposed PJTG ap-proach by simulation experiment with JAVA programming language. In detail, our PJTG algorithm is implemented based on the open source RADS Cassandra and a part of the code is modified for actual requirement. All the experiments are executed on the cluster built by 20 no-shared personal computers with Intel Core i7 870 CPU, 8G DDR3 memory, 500GB hard disk. In contrast, we process equi-join utilizing MapReduce framework on MSADS Hadoop. The cluster is built by 20 data nodes and 1 name node with the same hardware configuration.
We use runtime to evaluate the efficiency of our PJTG algorithm. The co-efficient of variation of the data size of join result on each node C D and the coefficient of variation of the runtime of process on each node C T is employed to evaluate the expansibility and the degree of parallelism of PJTG. The exper-iment data sets are synthetic. In both of the original ColumnFamilies, each row has 50 columns and we extract 10 columns to compose the join result Column-Family. The runtime of PJTG at the rate of MissRead 33% is showed in Figure 4(a), and 50% in Figure 4(b). Figure 4(a) shows the runtime of equi-join with different data size of original ColumnFamilies at the rate of Missread 33%. The abscissa represents data size and the ordinate represents runtime. Th e experiment result shows that our PJTG is very efficiency and the relationship between data size and runtime is almost linear. In contrast, the same equi-joi nisexecutedonHadoopwiththesame original data sets. As we see, equi-join using our PJTG on RADS is nearly 20% faster than using MapReduce framework on MASDS. This increase is mainly because that there is no need of communi cation between slave node and master node, and MissRead is avoided in our PJTG algorithm.

Figure 4(b) shows the runtime of equi-join at the rate of MissRead 50%. The solid line represents equi-join using our PJTG and the dotted line represents the same query on Hadoop. Our PJTG on RADS is nearly 28% faster than MapReduce. Hence, the experiment sho ws that with the increase of MissRead, our PJTG shows higher performance.

In Figure 5, the data size of the join result on each node is showed. In detail, the size of original data sets is 160GB a nd contain two ColumnFamilies. Both the ColumnFamilies contain 40 millions rows. The join result ColumnFamily is nearly 64GB and contain 80 millions rows. The rate of MisstRead is 33%. As the Figure 5 shows, Owe to the distributed hash algorithm, C D = 0.00229, which means the data distribution on each node is very balanced.

Figure 6 shows the runtime of our approach on each node with the same experiment data sets in Figure 5. C T = 0.00238, which means the process on each node almost achieves at the same time. The consequence of Figure 5 and Figure 6 illustrates that PJTG has very high expansibility and degree of parallelism.
Finally, for the update of the join result ColumnFamily caused by the alter-ation of original data, we also measure the runtime of update operations. The size of join result ColumnFamily is 64GB and each update time is the average time of 10000 same operations. Table 1 shows the update time of DELETE, INSERT(INC) and INSERT(MOD) operations on join-condition column and DELETE and INSERT operations on non-join-condition column. As Table 1 shows, the update operation is very fast and can meet the practical require-ments. In addition, commonly, operations on the join-condition column is slower than that on the non-join-condition column because that while we modify the data on join condition column, there will be some time cost for the alteration on CVI and MI.

Through the experiments above, we can conclude that the PJTG algorithm has high expansibility and degree of parallelism. It is very efficiency and shows high performance while the situation of MissRead arise frequently. the time cost of update is also very low, which makes our approach more practical. Data analysis task especially equi-join over huge data sets stored on Key/Value database is very necessary in many applications. MapReduce is a appropriate framework to solve this issue on MSADS, but there is no general approach for equi-join on RADS. Therefore, in this pa per, we focus on the parallel execution of equi-join on RADS. Through in-depth analysis of RADS, CVI and MI is proposed firstly. Then based on the data structure we propose, a novel approach, called PJTG, is proposed to performanc e equi-join task on RADS efficiently. Moreover, the update method for the join result is also designed as the extension of PJTG. Finally, a large number of experiments verify that our proposed PJTG is an efficient algorithm with high parallelism and availability, and can meet the practical requirements. There are still some limitations of the study such as system flexibility and fault tolerance. Next, we will focus on these problems, and design a more general framework of parallel process on RADS. In order to further improve the performance, we will also design the physics storage unit on RADS for our framework.
 Acknowledgement. This research is supported by the State Key Program of National Natural Science of China (Grant No. 61033007), the National Natural Science Foundation of China (Grant No. 60973021, 61003060).

