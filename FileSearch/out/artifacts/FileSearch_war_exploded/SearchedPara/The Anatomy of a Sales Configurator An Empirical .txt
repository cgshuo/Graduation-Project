 In many markets, being competitive echoes with the ability to propose cus-tomised products at the same cost and delivery rate as standard ones. These customised products are often characterised by hundreds of configuration op-tions . For many customers, this repertoire of inter-related options can be dis-concerting. To assist them during decision making, sales configurators (SCs) were developed. As an example, Figure 1 shows a snapshot of a typical car con-figurator (the circled letters and legend can be ignored for now). A SC provides an interactive graphical user interface (GUIs) that guides the users through the configuration process, verifies constraints between options, propagates user decisions, and handles co nflictual decisions [1 X 3].

SCs represent a significant portion of the configurators used in modern in-formation systems. Configurators are used in many B2B and B2C applications to personalize products and services. They are used in installation wizards and preference managers. They are also extensively used in software product lines (SPLs) where multiple information system variants are derived from a base of reusable artefacts according to the speci fic characteristics of the targeted cus-tomer or market segment [4 X 7]. As privileged channels for identifying customer needs and placing orders, configurators are key assets for companies. In this paper, we focus on web configurators supporting online sales.
 A significant share of existing SCs is web-based, irrespective of the market. The configurator database maintained by Cyledge is a striking evidence [8]. Since 2007, Cyledge collected more than 800 web SCs coming from 29 different industry sectors, including automotive, apparel, sport, and art. These configurators vary significantly. They each have their own characteristics, spanning visual aspects (GUI elements) to constraint management. The web SC of Audi appearing in Figure 1 is thus only one example. It displays different options through specific widgets (radio buttons and check boxes  X  A and B , respectively). These options can be in different states s uch as activated (e.g.,  X  X rivacy glass X  is flagged with ) or unavailable (e.g.,  X  X win-pane UV and heat-insulating glass X  is greyed out). Additionally, these options are organised in different tabs (e.g.,  X  X quipment X  ) and sub-tabs (e.g.,  X  X quipment packages X  ) which denote a series of steps ( C )in the configuration process (e.g.,  X 1. Model X  is followed by  X 2. Engine X   X  D ). A SC can also implement cross-cutting 1 constraints between options ( E ). These are usually hidden to the user but they determine valid combinations of options. For instance, the selection of  X  X rivacy glass X  implies the deselection of  X  X win-pane UV and heat-insulating glass X  , meaning that the user cannot select the latter if the former is selected. Moreover, descriptive information ( F ) is sometimes associated to an option (e.g., its price).
Despite the abundance of SCs, a consistent body of knowledge dedicated to their engineering is still missing. This absence of standard guidelines often trans-lates into correctness or runtime efficie ncy issues, mismatches between the con-straints exposed to the user and those actually implemented, and an unclear separation of concerns between the GUI and business logic. These issues in turn lead to expensive development and maintenance. Some of our industry partners face similar problems and are now trying to migrate their legacy SCs to more reliable, efficient, and maintainable solutions [9]. Our long-term objective is to develop a set of methods, guidelines, languages, and tools to systematically (re-)engineer SCs. This encompasses three activities: (a) reverse engineering legacy SCs, (b) encoding the extracted data into dedicated formalisms, and (c) forward engineering new improved SCs [9].

However, to realize this vision, we first need to understand the intrinsic charac-teristics of SCs. We conduct an empirical study of 111 web SCs from 21 different industry sectors (Section 2). We analyze the client-side code of these SCs with semi-automated code inspection tools. We classify and analyse the results along three dimensions: configuration options , constraints ,and configuration process (Section 3). For each dimension, we present quantitative empirical results and report on good and bad practices we observed (Section 4). We also describe the reverse engineering issues we faced (Section 5). We discuss the threats to validity (Section 6) and related wor k (Section 7). Finally, we summarize the results and propose a research agenda for the (re-)engineering of SCs (Section 8). (Re-)engineering web SCs requires a deep understanding of how they are cur-rently implemented. We choose to start this journey by analysing the visible part of SCs: the web client . We analyse client-side code because (1) it is the entry point for customer orders, (2) the techni ques used to implement web clients and web servers differ significantly, and (3) large portions of that code are publicly available. We leave for future work the study of server-side code and the inte-gration of client-and server-side analyses. In this paper, we set out to answer three research questions: RQ1 How are configuration options visually represented and what are their se-RQ2 What kinds of constraints are supported by the SCs, and how are they en-RQ3 How is the configuration process enforced by the configurators? The con-2.1 Configurator Selection To collect a representative sample of w eb SCs, we used Cyledge X  X  configurator database, which contains 800+ entries from a wide variety of domains. The first step of our configurator selection process consisted in filtering out non-English configurators. For simplicity, we only kept configurators registered in one of these countries: Australia , Britain , Canada , Ireland , New Zealand ,and USA . This returned 388 configurators and discarded four industry sectors. Secondly, we excluded 26 configurators that are no longer available. We considered a site unavailable either when it is not online anymore or requires credentials we do not have. Thirdly, we randomly selected 25% of the configurators in each sec-tor. We then checked each selected configurator with Firebug 2 to ensure that configuration options, constraints, and constraint handling procedures do not use Flash. We excluded configurators using Flash because the Firebug extension we implemented (see next section) does not support that technology. We also excluded  X  X alse configurators X . By this we mean 3D design websites that allow to build physical objects by piecing gra phical elements together, sites that just allow to fill simple forms with personal information, and sites that only describe products in natural language. The end result is a sample set of 93 configurators from 21 industry sectors. Finally, we added 18 configurators that we already knew for having used them in preliminary stages of this study. We used them to become familiar with web SCs and test/improve our reverse engineering tools, as discussed below. This raised the total number of web SCs to 111. 2.2 Data Extraction Process To answer the first two research questions, we need to extract the types of widgets used to represent options (RQ1), the types of constraints and their implementation strategies (RQ2). To extract all this information, we developed a Firebug extension (3 KLOC, 1 person-month) that implements ( a )asupervised learning-based data extraction approach [10], ( b ) support for advanced searches, and ( c )DOM 3 traversing.

Our approach relies on a training session during which we inspect the source code of the web page to identify which code patterns are used to implement configuration options and their graphical widgets. These patterns vary from simple (e.g., tag[attribute:value] ) to complex cases (e.g., a sequence of HTML tags). We then feed these patterns to our Firebug extension to extract all options. In essence, our extension offers a search engine able to ( a ) search given code patterns, and ( b ) simulate user actions. It uses jQuery selectors and code clone detection to search matching elements, extract an option name, its widget type, place of occurrence, and discover constraints between options (RQ3). Practically, the simulator selects/deselects each option and logs the existence of possible constraints based on the previous state of the page. This section summarises the results of our empirical study 4 . Table 1 highlights our key findings. Each subsection answers the questions posed in Section 2. 3.1 Configuration Options (RQ1) Option Representation. The diversity of representations for an option is one of the most striking results, as shown in Figure 2. In decreasing order, the most popular widgets are: combo box item , image 5 , radio button , check box and text box . We also observed that some widgets were combined with images, namely, check box , radio button ,and combo box item . Option selection is performed by either choosing the image or using the widget. The Other category contains various less frequent widgets like slider , label , file chooser , date picker , colour picker , image needle ,and grid .
 Grouping. Grouping is a way to organise related options together. For instance, a group can contain a set of colours or the options for an engine. Three differ-ent semantic constraints can apply to a group. For alternative groups, one and only one option must be selected (e.g., the Models in Figure 1  X  G ), and for multiple choice groups, at least one option mus t be selected (e.g., stone and band to put on a ring). In an interval group (a.k.a. cardinality [11]), the specific lower and upper bounds on the number of selectable options is determined (e.g., flavours in a milkshake). The Semantic Constructs row in Table 1 shows that alternative groups are the most frequent with 97% of SCs implementing them. We also observed multiple choice questions and interval groups in 8% and 4% of configurators, respectively.  X  X andatory Options X  and  X  X ptional Options X . Non-grouped options can be either mandatory (the user has to enter a value) or optional (the user does not have to enter a value). By definition, configurators must ensure that all mandatory options are properly set before finishing the configuration process. We identified three patterns for dealing with mandatory options:  X  Default Configuration (46%): When the configuration environment is loaded,  X  Notification (47%): Constraints are checked at the end of the configuration  X  Transition Checking (13%): The user is not allowed to move to the next We noticed that 4% of the configurators either lack interactive strategies for handling mandatory options or have only optional options.
Mandatory options can be distinguished from optional ones through high-lighting . For that, SCs use symbolic annotations (e.g., * usually for mandatory options), textual keywords (e.g., required , not required ,or optional ), or special text formatting (e.g., boldfaced, coloured text). We observed that only 14% of the SCs highlight mandatory or optional options, while 70% of the SCs have optional options in their configuration environments.
 Cloning. Cloning means that the user determines how many instances of an option are included in the final product [12] (e.g., a text element to be printed on a t-shirt can be instantiated multiple times and configured differently). We observed cloning mechanisms in only 5% of the configurators. 3.2 Constraints (RQ2) Formatting Constraint. A formatting constraint ensures that the value set by the user is valid .Examplesare:(1) type correctness (strongly typed, e.g. String, Integer, and Real), (2) range control (e.g., upper and lower bounds, slider domain, and valid characters), (3) formatted values (e.g., date, email, and file extension), and (4) case-sensitive values .

We observed that configurators provide two different patterns for checking constraint violation. The first is to prevent illegal values. For example, stop accepting input characters if the maximum number is reached, define a slider domain, use a date picker, disable illegal options, etc. The second is to ver-ify the values entered by the user a posteriori, and, for example, highlight, re-move or correct illegal values. These patterns are not mutually exclusive, and configurators can use them for different subsets of options. Among the 66 config-urators supporting formatting constraints, 62% implement prevention and 41% implement verification patterns. We also noticed that 26% of the configurators do not check constraints during the configuration session even if they are de-scribed in the interface. In some rare cases, the validation of the configuration was performed off-line, and feedback later sent back to the user.
 Group Constraint. A group constraint defines the number of options that can be selected from a group of options. In essence, constraints implied by multi-ple choice-, alternative-and interval-groups are group constraints. Widget types used to implement these groups directly handle those constraints. For instance, radio buttons and single-selection combo boxes are commonly used to imple-ment alternative groups. We identified group constraints in 99% of the analysed configurators.
 Cross-Cutting Constraint. A cross-cutting constraint is defined over two or more options regardless of their inclusion in a group. Require (selecting A im-plies selecting B) and Exclude (selecting A prevents selecting B and vice-versa) constraints are the most common. More complex constraints exist too. Cross-cutting constraints were observed in 61 configurators (55%) and are either coded in the client side (e.g., using JavaScript) or in the server side (e.g., using PHP). Irrespective of the implementation te chnique, we noticed that only 11% of the configurators describe them in the GUI with a textual explanation.
 Visibility Constraint. Some constraints d etermine when options are shown or hidden in the GUI. They are called visibility constraint [13]. Automatically adding options to a combo box upon modification of another option also falls in this constraint category. From the 61 configurators with cross-cutting con-straints, 89% implement visibility constraints.

We now focus on the capabilities of the reasoning procedures, namely decision propagation , consistency checking and undo .
 Decision Propagation. In some configurators, when an option is given a new value and one or more constraints apply, the reasoning procedure automatically propagates the required changes to all the impacted options. We call it automatic propagation (97%). In other cases, the reasoning procedure asks to confirm or discard a decision before altering other options. We call this controlled propaga-tion (8%). Finally, we also observed some cases of guided propagation (3%). For example, if option A requires to select option B or C, the reasoning procedure cannot decide whether B or C should be selected knowing A. In this case, the configurator proposes a choice to the user. Some of the configurators implement multiple patterns.
 Consistency Checking. An important issue in handling formatting and cross-cutting constraints is when the reasoning procedure instantiates the constraints and checks the consistency. In an interactive setting, the reasoning procedure interactively checks that the configuration is still consistent as soon as a decision is made by the user. For example, the permanent control of the number of letters in a text field with a maximum length const raint is considered interactive. In some cases, the reasoning procedure checks the consistency of the configuration upon request, for instance, when the user moves to the next configuration step. We call this batch consistency checking. Among the 83 configurators support-ing both formatting and cross-cutting constraints, 76% implement interactive and 59% implement batch consistency checking patterns. Some configurators implement both mechanisms, depending on the constraint type.
 Undo. This operation allows users to roll back on their last decision(s). Among all configurators in the survey, only 11% support undo. 3.3 Configuration Process (RQ3) Process Pattern. A configuration process is divided into a sequence of steps, each of which includes a subset of options. Each step is also visually identified in the GUI with containers such as navigation tabs, menus, etc. Users follow these steps to complete the configuration. We identified three different configuration process patterns:  X  Single-step (48%): All the options are displayed to the user in a single graph- X  Basic Multi-step (45%): The configurator presents the options either across  X  Hierarchical Multi-step (7%): It is the same as a multi-step except that a Activation. Among the 58 multi-step configurators, we noticed two exclusive step activation strategies. In step-by-step activation (59%), only the first step is available and the other steps become available as soon as all the options in the previous step have been config ured. Alternatively, in a full-step activation (41%) strategy, all steps are available to the user from the beginning.
 Backward Navigation. Another important parameter in multi-step config-uration processes is the ability to navigate back to a previous step. In some configurators, the user can go back to any previous step and all configuration choices are saved. We call it the stateful arbitrary pattern (69%). In other cases, the user can go back to any previous step but all configuration choices made in steps following the one reached are discarded. We call it stateless arbitrary pattern (14%). We observed that all full-step activation configurators follow the stateful arbitrary navigation pattern. We also noticed that 17% of multi-step configurators do not support backward navigation. The previous section focused on technica l characteristics of SCs. We now take a step back from the code to look at the results from the qualitative and functional angles. We discuss below the bad and good practices we observed. This classifica-tion reflects our practical experience with configurators and general knowledge reported in the literature [1 X 3, 14, 15]. Note that the impact of marketing or sales decisions on the behaviour of SCs falls outside our scope of investigation. We focus here on their perception by end-customers that are likely to influence the way SCs are implemented. 4.1 Bad Practices  X  Absence of propagation notification : In many cases, options are automatically  X  Incomplete reasoning: Reasoning procedures are not always complete. Some  X  Counter-intuitive representation : The visual discrepancies between option  X  Stateless backward navigation : Stateless configurators lose all decisions when  X  Automatic step transition : The user is guided to the next step once all options  X  Visibility Constraints : When a visibility constraint applies, options are hid- X  Decision revision : In a few cases, configurators neither provide an undo op-4.2 Good Practices  X  Guided Consistency Checking : 3% of the SCs assist users during the config- X  Auto-completion allows users to configure some desired options and then  X  Self-explanatory process : A configurator should provide clear guidance during  X  Self-explanatory widgets : Whenever possible, configurators should use stan- X  Stateful backward navigation and undo : These are must-have functionalities Our long-term objective, viz. developing methods to systematically re-engineer web SCs, requires accurate data extraction techniques. For the purpose of this study, we implemented a semi-automated t ool to retrieve options, constraints and configuration processes (see Section 2.2). This tool can serve as a basis for the reverse-engineering part of the futu re re-engineering toolset. This section outlines the main technical challenges we faced and how we overcame them. The impact of our design decisions on our re sults are explored in the next section. The envisaged future development s are sketched in the conclusion.
 Discarding Irrelevant Data. To produce accurate data, we need to sort out relevant from irrelevant data. For inst ance, some widgets represent configura-tion while others contain product shipment information, agreement check boxes, etc. A more subtle example is the inclusion of false options such as blank (rep-resenting  X  X o option selected X ), none or select an item values in combo boxes. Although obviously invalid, values such as none indicate optionality, which must be documented. To filter out false positi ve widgets, we either delimited a search region in the GUI, or forced the search engine to ignore some widgets (e.g., widgets with a given [attribute:value] pair).
 Unconventional Widget Implementations. Some standard widgets, like ra-dio buttons and check boxes, had unconventional implementations. Some were, for instance, implemented with images r epresenting their status (selected, re-jected, undecided, etc.). This forced us to use image-based search parameters to extract the option types and interpret their semantics. To identify those param-eters, we had to manually browse the source of the web page to map peculiar implementations to standard widget types.
 Detecting Constraints. To detect cross-cutting cons traints, we simulate click events of the user, i.e., selecting/deselecting options. When an event is triggered, we monitor changes in the states of the options to track the presence of a con-straint. We had to take the cascading effect of variable changes into account in order to identify constraints individually rather than as a monolithic block. Once detected, the constraint is extracted. Once again, the differences in nature (e.g., natural language descriptions of options, requires/excludes attributes, on-the-fly injection of new content...), technology and implementation tactics further complicated our task. We thus had to define heuristics to extract valuable data from these different contents as well as from the DOM tree.
 Discriminating between Option Groups and Configuration Steps. An option group and a configuration step are both option containers. But while the former describes logical dependenc ies between options, the latter denotes a process. To classify those containers, we defined four criteria: (1) a step is a coarse-grained container, meaning that a step might include several groups; (2) steps might be numbered; (3) the term  X  X t ep X  or its synonyms are used in labels; and (4) a step might capture constraints between options. If these criteria did not determine whether it was a step or a group, we considered it a group.
The above issues give a sense of the challenges that we had to face for extract-ing relevant data from the SCs. They are t he basic data extraction heuristics that a SC reverse-engineering tool shoul d follow, and hence represent a major step towards our long-term goal. The main external threat to validity is our web SC selection process. Although we tried to collect a representative total of 111 configurators from 21 industry sectors, we depend on the representativ eness of the sample source, i.e. Cyledge X  X  database.
 The main internal threat to validity is that our approach is semi-automated. First, the reliability of the developed reverse engineering techniques might have biased the results. Our tool extracts options and detects cross-cutting constraints by using jQuery selectors, a code clone detector, and a simulator. For instance, to detect all cross-cutting constraints, all possible option combinations must be investigated but combinatorial blowup precludes it. The impact this has on the completeness of our results is hard to predict. This, however, does not affect our observations related to the absence of verification of constraints textually documented in the web pages.

Second, arbitrary manual decisions had to be made when analysing config-urators. For example, some configurators allow to customise several product categories. In such cases, we randomly s elected and analysed one of them. If an-other had been chosen, the number of options and constraints could have been different. We also had to manually select some options to load invisible options in the source code. We have probably missed some.

The manual part of the study was conducted by the first author. His choices, interpretations and possible errors influenced the results. To mitigate this threat, the authors of the paper interacted freq uently to refine the process, agree on the terminology, and discuss issues, which eventually led to redoing some analyses. The collected data was regularly checked and heavily discussed. Yet, a replication study could further increase the robustness of the conclusions. Variability. Valid combinations of configuration options are often referred to as variability in the academic community. Over the years, academic research has defined and studied many variability modelling languages such as feature models and decision models [17]. Yet, thorough evaluations of the adequacy and impact of such languages in practice are still missing [18], specifically for configurators. A notable exception is Berger et al. [13] who study two variability modelling lan-guages used in the operating system domain. The authors compared the syntax, semantics, usage and GUI-based configuration tools of the two languages. They focus on one domain and two configurators while we study how variability con-cepts are implemented in a wide range of web SCs. Several authors have already addressed the (semi-automatic) reverse engineering of variability models from existing artefacts [19 X 26]. Sources include user documentation, natural language requirements, formal requirements, product descriptions, dependencies, source code, architecture, etc. To the best of o ur knowledge, none of existing reverse-engineering approaches tackles the extraction of variability patterns from SCs. GUIs and Web. Approaches have been proposed to reverse engineer GUIs and web pages. Memon et al. proposed  X  X UI ripping X  to extract models of the GUI X  X  structure and behaviour for testing [27]. Staiger presents an approach to detect GUI widgets and their hierarchy [28]. With VAQUISTA [29], Vanderdonckt et al. reverse engineered the presentation model of a web page. The WARE approach seeks to understand, maintain and evolve undocumented web applications by reverse engineering them to UML diagrams [30]. None of these approaches con-siders configuration aspects (e.g., configuration semantics of widgets) nor specific properties of web SCs.
 Studies of Configurators. Rogoll et al. [1] performed a qualitative study of 10+ web SCs. The authors reported on usability and how visual techniques as-sist customers in configuring products. Our study is larger (100+ configurators), and our goal and methodology differ significantly. We aim at understanding how the underlying concepts of web SCs are represented, managed and implemented, without studying specifically the usability of web SCs. Yet, the quantitative and qualitative insights of our study can be used for this purpose. Streichsbier et al. [2] analysed 126 web SCs among those in [8]. The authors question the ex-istence of standards for GUI (frequency of product images, back-and forward-buttons, selection boxes, etc.) in three industries. Our study is more ambitious and also includes non-visual aspects of web SCs. Interestingly, our findings can help identify and validate existing standards in web SCs. For example, our study reveals that in more than half of the SCs the selected product components are summarised at the end of the process, which is in line with [2]. Trentin et al. [3] conducted a user study of 630 web SCs to validate five capabilities: focused nav-igation , flexible navigation , easy comparison , benefit-cost communication ,and user-friendly product-space description . We adopted a more technical point of view. Moreover, their observations are purely qualitative and no automated re-verse engineering procedure is applied to produce quantitative observations. In this paper, we presented an empirical study of 111 web SCs along three dimensions: configuration options, constraints and configuration process. Quantitative Insights. We quantified numerous properties of SCs using code inspection tools. Among a diversi ty of widgets used to represent configuration options , combo box items and images are the most common. We also observed that in many cases configuration options, though not visually grouped together, logically dependent on one another: more than half of the configurators have cross-cutting constraints , which are implemented in many different ways. As for the configuration process , half of the configurators propose multi-step configura-tion, two thirds of which enable stateful backward navigation.
 Qualitative Insights. The empirical analysis of web SCs reveals reliability is-sues when handling constraints. These problems come from the configurators X  lack of convincing support for consistency checking and decision propagation. For instance, although verifying mandatory options and constraints are basic operations for configurators, our observations show that they are not completely implemented. Moreover, the investigation of client-side code implementation ver-ifies, in part, that no systematic method (e.g., solver-based) is applied to imple-ment reasoning operations. We also noticed that usability is rather weak in many cases (e.g., counter-intuitive re presentations, lack of guidance).
 Future Work. We provided empirical evidence that SCs are complex informa-tion systems for which qualities like usability and correctness are not always sat-isfied. The contribution of this paper is a first step toward their understanding, and a foundation for devising effective (re-)engineering solutions. Our ongoing work is to extend the search engine with advanced data extraction procedures so as to obtain all other necessary information (e.g., option hierarchy, descrip-tive information, CSS data). Moreover, at the moment, constraints are detected either by manual inspection or by simulating simple scenarios, which only cov-ers a subset of the possible constraints. To increase completeness, we are now integrating web crawling and  X  X idden web X  techniques [31] in our simulator and search engine. Furthermore, we believe that the use of variability models to for-mally capture configuration options and constraints, and solvers used in more academic configuration tools (e.g., SAT and SMT) to reason about these models, would provide more effective and reliable bases. Yet a lot more effort is needed for providing a systematic and comprehensive solution to practitioners. Acknowledgements. This work was supported by the University of Namur (FSR programme) and by the Walloon Region under the NAPLES project.

