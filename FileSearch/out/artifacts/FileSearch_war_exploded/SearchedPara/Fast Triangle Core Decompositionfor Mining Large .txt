 largest clique in G , hence  X  ( G ) &lt;K ( G )+1.
 in the worst case.
 requirements considerably (s ee comparison in Section 5). triangle core number, which is surprisingly tight for sparse graphs. 2.1 Wedges, Triangles, and Cliques A wedge is a 2-length path. The number of wedges W u centered at u is given by W u = d u ( d u d forms a triangle ifthereexistsanedge( u,v ). Let tr ( u )and tr ( u,v ) be the number of triangles cen-tered at vertex u and edge ( u,v ), respectively. Fur-and a large fraction of vertices must form a clique. 2.2 Triangle Core Decomposition and a clique of size 4 is within the 4-core (See Figure 1). 2 &gt;k ,and H k is the maximum subgraph with this property. Definition 3 ( Triangle Core Number): The triangle core number denoted Definition 4 ( Maximum Triangle Core): The maximum triangle core of G k to exist. 2.3 Cliques, Triangle Cores, and K-cores triangles.
 relationship between vertex degree and a triangle core number below. Property 2 : Each vertex in the k triangle core has degree d v  X  k  X  1 . must form at least k + 1 edges with v .
 Property 3 : The k triangle core is contained within the ( k  X  1) -core. k  X  1 core must be within the k triangle core.
 Property 4 : The maximum triangle core number is bounded above by K and This section describes our exact par-allel triangle algorithms and their im-plementation for large graphs.
 3.1 Parallel Triangle Counting problems that arise with vertex-centric parallelization (see Table 1).
The parallel edge triangle counting algorithm is given in Alg. 1. The triangle counting computations are performed by dynamically allocating blocks of edges to workers. The work-ers then compute the number of triangles centered at each edge and store the counts into the edge-indexed array. Locks are avoided by assigning unique ids to the edges, which map to locks are avoided completely (See Figure 5). 3.2 Triangle Core Decomposition Edge CSC Format. Edge-based compressed sparse column (ECSC) format the practical importance of ECSC was previously shown in Table 1. Triangle Core Arrays. The triangle core decomposition uses ESCS and four additional smaller arrays. This reduced storage cost is due to emap which provides O (1) time access to a unique edge and its vertices (stored con-secutively). The edge-indexed T array stores for each edge ( u,v ) the number of triangles that it participated. An index k of the emap array also directly indexes T using k/ 2since T stores only the unique edges. The bin array is indexed by an integer repre-senting triangles, and stores the given edge in the sorted es array.
 starting positions of the bins.
 continue with the next neigh-boring edge. However, if both edges have not been removed, then we have found a valid tri-angle to remove. For each of the neighboring edges with a larger triangle core number, we decrease its number of trian-gles by 1 and move it one bin to the left. All these operations are O (1) time using ECSC. Ob-serve that each of the neighbor-ing edges ( u,w )and( v,w )are swapped with the first edge in its bin, respectively. We then swap their positions in the pos array and increase the previ-ous bin and decrease the cur-rent bin of the edge by 1.
 Lines 20 X 33 are repeated for all neighboring edges of (u,v) that form unprocessed trian-gles with a triangle count that is currently larger than its own.
 Finally, the edge is marked as processed and X is reset (line 34 X 35). bigdata(SeeSection6). 4.1 Top K Triangle Cores Algorithm 3 Top-K Triangle Cores Using property 3 as a basis, we propose a parallel method that leverages a relationship between the k-core and triangle core for computing only the top-k trian-gle cores. Key to our approach is the heuristic clique finder which allows us to obtain a fast lower-bound.
 Problem 1 ( Top K Triangle triangle core numbers greater than k .
 subgraphs (see Section 6.3).

The first step in Alg 3 computes the k-core numbers denoted K of G .This 4.2 Max Triangle Core Algorithm 4 Dense Triangle Subgraph In many applications, the cost of computing the full triangle core decomposition is too expensive and/or not needed. For instance, the maximum triangle core may significantly speedup the termi-nation of maximum clique al-gorithms when used for prun-ing. Thus, we solve the following problem instead: Problem 2 ( Maximum Triangle Core Number): Given a graph G , find the maximum triangle core number T ( G ) directly.
 and give this smaller graph to the triangle core rou-tine. Observe that  X  T is a fast but accurate approx-imation of the maximum triangle core. In this section, we systematically investigate the performance and accuracy of our methods on over 150 graphs. The experiments are designed to answer the following questions:
 X  Triangle core decomposition. How fast is our algorithm for computing  X  Parallel edge triangle counting. Does our parallelization scheme work?
 X  Performance of variants. How fast can we solve each variant? and how
 X  Clique upper bound . How tight are the triangle core upper bounds com-5.1 Performance of Proposed Algorithm graphs and dense graphs, respectively.
Notably, the proposed algo-rithm counts 18B triangles in 8 seconds, while taking 315 seconds for triangle cores. For these graphs, the triangle core algorithm adapts the graph rep-resentation and computation to better exploit the structure. This includes using an adj structure for O (1) time lookups, selecting much less from the diagonal.
 terminates.
 5.2 Parallel Edge Triangle Counting The proposed parallel edge triangle counting algorithm is fast and scalable as shown in Table 2. Moreover, we also find that it out-performs a recent MapReduce triangle count-ing algorithm [15]. In that work, it takes 319 seconds using a MapReduce cluster of 1636 nodes to compute triangles for LiveJournal whereas it takes us only 2.09 seconds (See Table 1).
 Speedup. Fig 5 shows that our approach scales well, especially for sparse graphs. Ob-serve that for dense graphs, triangles are more uniformly distributed and thus the im-proved load balancing from our approach does not help as much. We also find that on average, less time is spent per triangle for dense graphs.
 counter is 22x faster. 5.3 Performance of Variants Results are shown in Table 4. We compare the greedy maximum triangle core to the ex-act triangle core decomposition on the ba-sis of speed and accuracy. Table 4 clearly demonstrates the effect iveness of the greedy maximum triangle core procedure. In some instances, a speedup of over 650x is observed while also returning the exact maximum tri-brevity, but are later used for finding temporal strong components. 5.4 Bounds Table 4. Performance and accuracy of greedy max-This section evaluates the tri-angle core clique bound on sparse and dense graphs. In Table 2, we find that the triangle core upper bound is sometimes significantly tighter than the k-core upper bound, especially for sparse graphs that exhibit a weak power-law rithms for a variety of graph mining applications. 6.1 Maximum Clique Algorithms This gives rise to the following:  X   X  T ( N ( v ))  X  K ( N ( v ))  X  d ( N ( v )). The ap-proach proceeds similar to pmcx from [12] which uses k-core bounds with greedy col-oring applied at each step. After pruning the vertex neighborhoods, we compute the density of the subgraph denoted  X  ( N ( v )) and use neighborhood triangle cores only if  X  ( N ( v )) &gt; 0 . 85, otherwise, we proceed same as pmcx above. Intuitively, if density is large enough, then edges are pruned using the neighborhood cores. We compare trmc against two recent state-of-the-art finders: bbmc [14] and pmcx [12]. Let us note that bbmc uses a bitset encoding for set intersec-trmc outperforms bbmc on every graph, but outperforms pmcx on only a few instances.
 6.2 Temporal SCC Table 5. Max temporal-SCC via triangle cores We use the algorithms from sec-tion 3 to explore the effective-ness of the top-k triangle cores for computing the largest tem-poral strongly connected compo-whereas the fast top-k algorithm takes only 11 seconds. 6.3 Dense Subgraph Mining A particularly useful property of the greedy maximum triangle core is that it returns a relatively dense subgraph. In Table 4 we find the density of the as-skitter subgraph returned by the greedy maximum triangle core method is 0 . 50 with 345 vertices with an average degree dense subgraphs. and clique finding algorithms.
