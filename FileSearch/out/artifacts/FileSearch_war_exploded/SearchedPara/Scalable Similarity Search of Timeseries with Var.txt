 Timeseries can be similar in shape but differ in length. For example, the sound waves produced by the same word spo-ken twice have roughly the same shape, but one may be shorter in duration. Stream data mining, approximate query-ing of image and video databases, data compression, and near duplicate detection are applications that need to be able to classify or cluster such timeseries, and to search for and rank timeseries that are similar to a chosen timeseries. We demonstrate software for clustering and performing simi-larity search in databases of timeseries data, where the time-series have high and variable dimensionality. Our demon-stration uses Timeseries Sensitive Hashing (TSH) [3] to in-dex the timeseries. TSH adapts Locality Sensitive Hash-ing (LSH), which is an approximate algorithm to index data points in a d -dimensional space under some (e.g., Euclidean) distance function. TSH, unlike LSH, can index points that do not have the same dimensionality. As examples of the potential of TSH, the demonstration will index and classify timeseries from an image database and timeseries describing human motion extracted from a video stream and a motion capture system.
 H.3.3 Information Systems [ Information Storage and Re-trieval ]: [Information Search and Retrieval] Algorithms Multimedia Data, Scalable Indexing, Search and Structuring
The goal of the research presented in this demonstration is to make it easier for applications to index and query time-series that are of high and variable dimensionality. These (conference) iSAX [8] (KDD08)
TS-Tree [1] (EDBT08) Scaled and Warped
Matching [4] (VLDB08)
Exact in-dexing of
DTW [6] (VLDB02) Table 1: High-dimensional datasets and reduction tech-niques considered in recent papers on timeseries indexing. timeseries are found in many application areas, such as im-age and video processing, data stream mining, data com-pression, and near duplicate detection. For instance, a time-series of variable dimensionality is generated when a process (e.g., the trajectory of a person while walking in a video) is measured over uniform time intervals, but with no prede-termined length (e.g., not every video or activity within a video has the same duration). Previous research has develo-ped efficient algorithms to index and query timeseries that are vectors of fixed dimensionality. Current practice is to normalize variable dimensionality timeseries to some fixed dimensionality. But when processing a live video stream, for instance, new timeseries are continually being produced and the a priori (incorrect) choice of a single, fixed dimen-sionality may lead to important data in a timeseries being manufactured or discarded. It would be better to index each timeseries without normalizing it.

Table 1 summarizes a few of the key papers in previous research. All of the papers listed target high-dimensional datasets. Each chooses to normalize by reducing the dimen-sionality of the data to some fixed dimensionality, and in most of the cases that dimensionality is relatively small.
In this demonstration, we will show how to index time-series without normalizing or reducing dimensionality using an indexing technique called Timeseries Sensitive Hashing (TSH) [3]. In contrast to other approaches, TSH has linear or sublinear time complexity for both indexing and search-ing without reducing the timeseries to a fixed dimensionality. As we will demonstrate, TSH is especially suited to stream data processing such as motion capture, real-time video anal-ysis, speech recognition, and sensor networks, where time-series with different lengths continuously arrive, preprocess-ing steps are not always possible, one-scan algorithms are needed, and low error rates are necessary.
This section gives a short tutorial on TSH. The demon-stration will use a web application to take the audience through a series of multimedia queries of increasing com-plexity, from image to motion capture and video data. The web application allows a user to perform four main activities: 1) initialize the interface with a random sampling of objects chosen from a database, 2) report how elements are dis-tributed in hash buckets, 3) visualize a hierarchical cluster-ing of the entire dataset, and 4) perform a similarity search. We invite readers to visit the TSH project website to exper-iment with TSH in the on-line demo and download the Java implementation 1 . The hash tables are persistently stored using BerkleyDB [2], so the software can scale to support large datasets (i.e., it is not limited by available memory).
TSH is an index that clusters timeseries with similar shape which are close in the &lt; 1 space. TSH employs the con-cept of general dot product to compare two vectors of differ-ent dimensionality using a non-linear alignment of elements, rather than using the Euclidean norm in the &lt; n space.
TSH embeds general dot product into a number of hash functions, which allows each timeseries to be projected into &lt; 1 (e.g., a bucket) with high probability of finding simi-lar elements in the same bucket. TSH chooses timeseries from the database to construct the hash functions, which we previously observed did improve precision [3]. Addition-ally, TSH uses multiple hash tables, performs a search by hashing within each table, and unions the partial results. In summary, TSH is formed of L hash tables, each one defined by K hash functions that project elements to buckets of a chosen width in &lt; 1 (the width is a parameter that can be used to tune TSH). http://omarflorez.info/index.php?id=tsh
Figure 1 (a) shows a random sampling of a Primate Skulls dataset. We generate a timeseries for each image by com-puting its centroid and then evaluating distances from that point to the pixels in the border of the skull. The result-ing timeseries is expressive enough to distinguish important features such as nose angle, depth of the lower jaw, and prominent forehead.

Figure 1 (b) shows a screenshot of the application when a user clicks on an image performing a query of an adult female Sooty Mangabeys primate. This primate lives on the west coast of Africa and belongs to the Cercopithecidae fami-ly and Catarrhini infraorder. While 80% of the neighbors retrieved by TSH ( a , b , c , d , e , and g ) belong to the Cata-rrhini infraorder and share important features such as long fangs, similar forehead, and very convex napes, the remain-ing 20% ( f and g ) also exhibits those visual features, but they belong to the Platyrrini infraorder. Both Catarrhini and Platyrrini are two close instances of five possible in-fraorders for primates. This example shows that timeseries can be used to evaluate similarity queries for image data. The title of the application also contains relevant informa-tion about the query such as precision / recall of the subset retrieved and the time / memory spent during the query in the system. Additionally, the demo reports variance in the dimensionality ( min / max length ) associated to the result set.

In the above example, we took advantage of the same orientation and uniform background to extract well defined timeseries and obtain consistent results in the Primate Skull database. However, the timeseries extracted from motion capture data are more challenging and complex to analyze since the motion performed by different actors can be in any direction, be composed of other small movements, and have a larger variance in duration, as shown in Figure 2 (a). The timeseries defined for each instance of the database repre-sents the position of the right hand of each actor in the z-axis. The result of querying the running activity 09 05 is illustrated in Figure 2 (b). It shows the retrieval of ten videos, each one containing different actors doing the ac-tivity 09 . The recall is lower in this case (58 . 8%) than in Figure 1 (b) since more than ten elements belong to this class, but TSH only retrieves a subset of them. In other retrieved belong to the same running activity. words, TSH only retrieves the timeseries projected to the same buckets in multiple hash tables with high precision (100%). The user can obtain higher recall values by in-creasing the bucket width, but at the cost of increasing the response time.

Additionally, we show search effectiveness with a subset of 100,000 elements of The Million Song Dataset 2 , a freely-available collection of audio features and metadata. TSH will provide consistent results if the result set obtained by a 10-NN query is included in the one retrieved by a linear scan, a brute force algorithm that yields complete precision. Figure 3 reports average precision of TSH, with respect to a sequential search, which ranges between 92% and 95% over different database sizes.

The demo will also allow users to explore the notion of using a general dot product to create a hierarchical cluster-ing. TSH projects similar timeseries to the same buckets in multiple hash tables, forming a particular neighborhood in the projected space. Those points that have more than T elements and are within a distance of D are denominated as core points .

TSH aggregates clusters into increasingly larger clusters in a hierarchy as follows. Pairs of clusters that have the shortest distance between their members can be connected. Those timeseries that are not core points can be considered as outliers and safely removed. The algorithm stops when a single cluster is reached. Otherwise, we increase the value of http://labrosa.ee.columbia.edu/millionsong/ D to merge distant clusters. TSH reduces the time complex-ity of the original hierarchical linkage clustering algorithm from O ( n log n ) to O ( n ) because of its constant response time for nearest neighbor queries.

Figure 4 (a) shows a random selection from the Motion from Video dataset. It contains six types of activities per-formed by 19 actors with dimensionality varying from 112 to 184 dimensions. A timeseries is extracted from each video by defining intensity gradients and then evaluating their spa-tial distribution over time. The clustering on this data with TSH, as shown in Figure 4 (b), reports some relevant char-acteristics underlying the dataset.

First, note that five groups were discovered, each one shown in a different color. Each group is a type of mo-tion performed by an actor. While the cluster in red ( a ) merges two types of similar activities (jogging and running), the other clusters shows a proportional distribution of ele-ments. Next, the highest link in the display shows the exis-tence of two large groups ( { a, b, c } and { d, e } ). In practice, those groups correspond to hand-related (hand waving, hand clapping, and boxing) and feet-related (walking, jogging, and running) activities. While clustering is approximated with TSH, it quickly groups elements projected similarly in &lt; and uses the general dot product to find similar timeseries from video. Those timeseries are often more challenging since they contain noise related to illumination, shadows, and camera motion. Our implementation builds on the Jetty HTTP server and Java Servlet container, which provides both dynamic content interaction with multimedia databases and the TSH index.
Before we can execute similarity queries on objects, we need to find its timeseries representation in the Data layer. The technique to extract those features from an object will vary according to the nature of its underlying data (images, music, video, motion capture, etc). In our running examples, we showed multimedia objects to the user, each one linked to a timeseries in the Presentation layer. Those timeseries are encoded in &lt; key, value &gt; pairs within TSH; key is an in-teger representing a bucket id in TSH and value is a string representing the path to the file containing the timeseries pattern on hard-disk. Thus, mappings allow us to save space by not storing the entire timeseries in main memory. The in-dex will perform similarity queries and clustering by quickly obtaining keys in multiple tables and collecting the time-series found into a single result set in the Structure layer. Eventually, TSH will contain more mappings than permit-ted in main memory. TSH supports the insertion of large multimedia databases with fast lookup operations in TSH by extending the HashMap representation of BerkeleyDB to thus enable persistence in the Persistence layer.
Previous research on efficiently indexing timeseries typi-cally relies on dimensionality reduction to eliminate variable dimensionality. As discussed in Section 1, current practice is to employ on dimensionality reduction techniques (iSAX [8], PAA [1], Uniform Scaling [6], etc.) to make timeseries more tractable to compute. These indexing techniques fall into two categories: region-based and lexicographic. R-tree is a region-based index commonly used for experiments with timeseries. Its main downside is the presence of overlap be-tween regions for high-dimensional data. One example of a lexicographic index is TS-tree [1], which avoids subtree overlap during insertion. There are (at least) two clustering techniques that employ a hashing approach [7, 9]. However, they only consider the case where points have the same di-mensionality and Euclidean distance is the only option as a similarity measure.
The demonstration will guide the audience through ex-amples in a new index called TSH. We demonstrate the po-tential of TSH to perform quick analysis of complex time-series in multimedia data. Particularly, queries in TSH show high precision and visual soundness and the hierar-chical clustering seems to group similar elements coherently. The audience can download our Java implementation from the project X  X  website and try their own queries during the demonstration.
We thank the Glendale College Anthropology Department for its skull images, Eamonn Keogh for sharing the images, Ivan Laptev for the motion video dataset, the CMU Graph-ics Lab for its motion capture dataset, and IBM for funding part of the research with a Scalable Data Analytics 2010 Innovation Award. [1] I. Assent, R. Krieger, F. Afschari, and T. Seidl. The [2] BerkleyDB. [3] O. U. Florez, A. Ocsa, and C. E. Dyreson. Sublinear [4] A. W.-c. Fu, E. Keogh, L. Y. H. Lau, and C. A.
 [5] A. Guttman. R-trees: A dynamic index structure for [6] E. Keogh and C. A. Ratanamahatana. Exact indexing [7] H. Koga, T. Ishibashi, and T. Watanabe. Fast [8] J. Shieh and E. Keogh. iSAX: indexing and mining [9] Y.-P. Wu, J.-J. Guo, and X.-J. Zhang. A linear DBScan
