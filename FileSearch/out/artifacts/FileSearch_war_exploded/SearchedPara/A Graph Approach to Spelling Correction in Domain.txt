 An abundance of applications require spelling cor-rection , which (at the high level) is the following task. The user intends to type a chunk q of text, but types instead the chunk s that contains spelling errors (which we discuss in detail later), due to un-careful typing or lack of knowledge of the exact spelling of q . The goal is to restore q , when given s . Spelling correction has been extensively studied in the literature, and we refer the reader to compre-hensive summaries of prior work (Peterson, 1980; Kukich, 1992; Jurafsky and Martin, 2000; Mitton, 2010). The focus of this paper is on the special case where q is a search query , and where s instead of q is submitted to a search engine (with the goal of re-trieving documents that match the search query q ). Spelling correction for search queries is important, because a significant portion of posed queries may be misspelled (Cucerzan and Brill, 2004). Effective spelling correction has a major effect on the expe-rience and effort of the user, who is otherwise re-quired to ensure the exact spellings of her queries. Furthermore, it is critical when the exact spelling is unknown (e.g., person names like Schwarzenegger ). 1.1 Spelling Errors The more common and studied type of spelling error is word-to-word error: a single word w is misspelled into another single word w 0 . The specific spelling er-rors involved include omission of a character (e.g., atachment ), inclusion of a redundant character (e.g., attachement ), and replacement of charac-ters (e.g., attachemnt ). The fact that w 0 is a mis-spelling of (and should be corrected to) w is denoted by w 0  X  w (e.g., atachment  X  attachment ).

Additional common spelling errors are splitting of a word, and merging two (or more) words:  X  attach ment  X  attachment  X  emailattachment  X  email attachment
Part of our experiments, as well as most of our examples, are from the domain of (personal) email search. An email from the Enron email collec-tion (Klimt and Yang, 2004) is shown in Figure 1. Our running example is the following misspelling of a search query, involving multiple types of errors. In this example, correction entails fixing sadeep , splitting excellatach , fixing excell , merging atach ment , and fixing atachment . Beyond the complexity of errors, this example also illustrates other challenges in spelling correction for search. We need to identify not only that sadeep is mis-spelled, but also that kohli is correctly spelled. Just having kohli in a dictionary is not enough. For example, in kohli coupons the user may very well mean kohls coupons if Sandeep Kohli has nothing to do with coupons (in contrast to the store chain Kohl X  X ). A similar example is the word nail , which is a legitimate English word, but in the con-text of email the query nail box is likely to be a misspelling of mail box (unless nail boxes are indeed relevant to the user X  X  email collection). Fi-nally, while the word kohli is relevant to some email users (e.g., Kohli X  X  colleagues), it may have no meaning at all to other users. 1.2 Domain Knowledge The common approach to spelling correction uti-lizes statistical information (Kernighan et al., 1990; Schierle et al., 2007; Mitton, 2010). As a sim-ple example, if we want to avoid maintaining a manually-crafted dictionary to accommodate the wealth of new terms introduced every day (e.g., ipod and ipad ), we may decide that atachment is a misspelling of attachment due to both the (relative) proximity between the words, and the fact that attachment is significantly more pop-ular than atachment . As another example, the fact that the expression sandeep kohli is fre-quent in the domain increases our confidence in sadeep kohli  X  sandeep kohli (rather than, e.g., sadeep kohli  X  sudeep kohli ). One can further note that, in email search, the fact that Sandeep Kohli sent multiple excel attachments in-creases our confidence in excell  X  excel .

A source of statistics widely used in prior work is the query log (Cucerzan and Brill, 2004; Ahmad and Kondrak, 2005; Li et al., 2006a; Chen et al., 2007; Sun et al., 2010). However, while query logs are abundant in the context of Web search, in many other search applications (e.g. email search, desktop search, and even small-enterprise search) query logs are too scarce to provide statistical information that is sufficient for effective spelling correction. Even an email provider of a massive scale (such as GMail) may need to rely on the (possibly tiny) query log of the single user at hand, due to privacy or security concerns; moreover, as noted earlier about kohli , the statistics of one user may be relevant to one user, while irrelevant to another.

The focus of this paper is on spelling correction for search applications like the above, where query-log analysis is impossible or undesirable (with email search being a prominent example). Our approach relies mainly on the corpus data (e.g., the collection of emails of the user at hand) and external, generic dictionaries (e.g., English). As shown in Figure 1, the corpus data may very well contain misspelled words (like query logs do), and such noise is a part of the challenge. Relying on the corpus has been shown to be successful in spelling correction for text clean-ing (Schierle et al., 2007). Nevertheless, as we later explain, our approach can still incorporate query-log data as features involved in the correction, as well as means to refine the parameters. 1.3 Contribution and Outline As said above, our goal is to devise spelling cor-rection that relies on the corpus. The corpus often contains various types of information, with different levels of reliability (e.g., n -grams from email sub-jects and sender information, vs. those from email bodies). The major question is how to effectively exploit that information while addressing the vari-ous types of spelling errors such as those discussed in Section 1.1. The key contribution of this work is a novel graph-based algorithm, MaxPaths , that han-dles the different types of errors and incorporates the corpus data in a uniform (and simple) fashion. We describe MaxPaths in Section 2. We evaluate the effectiveness of our algorithm via an experimental study in Section 3. Finally, we make concluding re-marks and discuss future directions in Section 4. In this section, we describe our algorithm for spelling correction. Recall that given a search query s of a user who intends to phrase q , the goal is to find q . Our corpus is essentially a collection D of unstructured or semistructured documents . For ex-ample, in email search such a document is an email with a title, a body, one or more recipients, and so on. As conventional in spelling correction, we de-vise a scoring function score D ( r | s ) that estimates our confidence in r being the correction of s (i.e., that r is equal to q ). Eventually, we suggest a se-quence r from a set C D ( s ) of candidates , such that score D ( r | s ) is maximal among all the candidates in C D ( s ) . In this section, we describe our graph-based approach to finding C D ( s ) and to determining score D ( r | s ) .

We first give some basic notation. We fix an al-phabet  X  of characters that does not include any of the conventional whitespace characters. By  X   X  we denote the set of all the words , namely, fi-nite sequences over  X  . A search query s is a sequence w 1 , . . . , w n , where each w i is a word. For convenience, in our examples we use whites-pace instead of comma (e.g., sandeep kohli in-stead of sandeep , kohli ). We use the Damerau-Levenshtein edit distance (as implemented by the Jazzy tool) as our primary edit distance between two words r 1 , r 2  X   X   X  , and we denote this distance by ed ( r 1 , r 2 ) . 2.1 Word-Level Correction We first handle a restriction of our problem, where the search query is a single word w (rather than a general sequence s of words). Moreover, we consider only candidate suggestions that are words (rather than sequences of words that account for the case where w is obtained by merging keywords). Later, we will use the solution for this restricted problem as a basic component in our algorithm for the general problem.

Let U D  X   X   X  be a finite universal lexicon , which (conceptually) consists of all the words in the corpus D . (In practice, one may want add to D words of auxiliary sources, like English dictionary, and to fil-ter out noisy words; we did so in the site-search do-main that is discussed in Section 3.) The set C D ( w ) of candidates is defined by
C D ( w ) def = { w } X  X  w 0  X  U D | ed ( w, w 0 )  X   X  } . for some fixed number  X  . Note that C D ( w ) contains w even if w is misspelled; furthermore, C D ( w ) may contain other misspelled words (with a small edit distance to w ) that appear in D .

We now define score D ( w 0 | w ) . Here, our cor-pus D is translated into a set WF D of word features , where each feature f  X  WF D gives a scoring func-tion score f ( w 0 | w ) . The function score D ( w 0 | w ) is simply a linear combination of the score f ( w 0 | w ) : As a concrete example, the features of WF D we used in the email domain are listed in Table 1; the result-ing score f ( w 0 | w ) is in the spirit of the noisy channel model (Kernighan et al., 1990). Note that additional features could be used, like ones involving the stems of w and w 0 , and even query-log statistics (when available). Rather than manually tuning the param-eters a f , we learned them using the well known Support Vector Machine , abbreviated SVM (Cortes and Vapnik, 1995), as also done by Schaback and Li (2007) for spelling correction. We further discuss this learning step in Section 3.

We fix a natural number k , and in the sequel we denote by top D ( w ) a set of k words w 0  X  C D ( w ) with the highest score D ( w 0 | w ) . If |C D ( w ) | &lt; k , then top D ( w ) is simply C D ( w ) . 2.2 Query-Level Correction: MaxPaths We now describe our algorithm, MaxPaths , for spelling correction. The input is a (possibly mis-spelled) search query s = s 1 , . . . , s n . As done in the word-level correction, the algorithm produces a set C D ( s ) of suggestions and determines the values Algorithm 1 MaxPaths
Output: a set C D ( s ) of candidate suggestions r , 1: Find the strongly plausible tokens 2: Construct the correction graph 3: Find top-k full paths (with the largest weights) 4: Re-rank the paths by word correlation score D ( r | s ) , for all r  X  C D ( s ) , in order to rank C
D ( s ) . A high-level overview of MaxPaths is given in the pseudo-code of Algorithm 1. In the rest of this section, we will detail each of the four steps in Al-gorithm 1. The name MaxPaths will become clear towards the end of this section.

We use the following notation. For a word w = c  X  X  X  c m of m characters c i and integers i &lt; j in { 1 , . . . , m + 1 } , we denote by w [ i,j ) the word c  X  X  X  c j  X  1 . For two words w 1 , w 2  X   X   X  , the word w 1 w 2  X   X   X  is obtained by concatenating w 1 and w 2 . Note that for the search query s = s 1 , . . . , s n it holds that s 1  X  X  X  s n is a single word (in  X   X  ). We denote the word s 1  X  X  X  s n by b s c . For example, if s 1 = sadeep and s 2 = kohli , then s corresponds to the query sadeep kohli while b s c is the word sadeepkohli ; furthermore, b s c [1 , 7) = sadeep . 2.2.1 Plausible Tokens
To support merging and splitting, we first iden-tify the possible tokens of the given query s . For example, in excellatach ment we would like to identify excell and atach ment as tokens, since those are indeed the tokens that the user has in mind. Formally, suppose that b s c = c 1  X  X  X  c m . A token is a word b s c [ i,j ) where 1  X  i &lt; j  X  m + 1 . To simplify the presentation, we make the (often false) assumption that a token b s c [ i,j ) uniquely identifies j 6 = j 0 ); in reality, we should define a token as a triple ( b s c [ i,j ) , i, j ) . In principle, every token b s c could be viewed as a possible word that user meant to phrase. However, such liberty would require our algorithm to process a search space that is too large to manage in reasonable time. Instead, we restrict to strongly plausible tokens , which we define next.
A token w = b s c [ i,j ) is plausible if w is a word of s , or there is a word w 0  X  C D ( w ) (as defined in Section 2.1) such that score D ( w 0 | w ) &gt;  X  for some fixed number  X  . Intuitively, w is plausible if it is an original token of s , or we have a high confidence in our word-level suggestion to correct w (note that the suggested correction for w can be w itself). Recall that b s c = c 1  X  X  X  c m . A tokenization of s is a se-quence j 1 , . . . , j l , such that j 1 = 1 , j l = m + 1 , and j &lt; j i +1 for 1  X  i &lt; l . The tokenization j 1 , . . . , j induces the tokens b s c [ j enization is plausible if each of its induced tokens is plausible. Observe that a plausible token is not necessarily induced by any plausible tokenization; in that case, the plausible token is useless to us. Thus, we define a strongly plausible token , abbre-viated sp-token , which is a token that is induced by some plausible tokenization. As a concrete example, for the query excellatach ment , the sp-tokens in our implementation include excellatach , ment , excell , and atachment .

As the first step (line 1 in Algorithm 1), we find the sp-tokens by employing an efficient (and fairly straightforward) dynamic-programming algorithm. 2.2.2 Correction Graph
In the next step (line 2 in Algorithm 1), we con-struct the correction graph , which we denote by G D ( s ) . The construction is as follows.

We first find the set top D ( w ) (defined in Sec-tion 2.1) for each sp-token w . Table 2 shows the sp-tokens and suggestions thereon in our running exam-ple. This example shows the actual execution of our implementation within email search, where s is the query sadeep kohli excellatach ment ; for clarity of presentation, we omitted a few sp-tokens and suggested corrections. Observe that some of the corrections in the table are actually misspelled words (as those naturally occur in the corpus).
A node of the graph G D ( s ) is a pair  X  w, w 0  X  , where w is an sp-token and w 0  X  top D ( w ) . Recall our simplifying assumption that a token b s c [ i,j ) uniquely identifies the indices i and j . The graph G D ( s ) con-tains a (directed) edge from a node  X  w 1 , w 0 1  X  to a node  X  w 2 , w 0 2  X  if w 2 immediately follows w 1 in b q c ; in other words, G D ( s ) has an edge from  X  w 1 , w to  X  w 2 , w 0 2  X  whenever there exist indices i , j and k , such that w 1 = b s c [ i,j ) and w 2 = b s c [ j,k ) . Observe that G D ( s ) is a directed acyclic graph (DAG).
For example, Figure 2 shows G D ( s ) for the query sadeep kohli excellatach ment , with the sp-tokens w and the sets top D ( w ) being those of Table 2. For now, the reader should ignore the node in the grey box (containing sandeep kohli ) and its incident edges. For simplicity, in this figure we depict each node  X  w, w 0  X  by just mentioning w 0 ; the word w is in the first row of Table 2, above w 0 . 2.2.3 Top-k Paths
Let P =  X  w 1 , w 0 1  X   X   X  X  X   X   X  w k , w 0 k  X  be a path in G D ( s ) . We say that P is full if  X  w 1 , w 0 1  X  has no incoming edges in G D ( s ) , and  X  w k , w 0 k  X  has no out-going edges in G D ( s ) . An easy observation is that, since we consider only strongly plausible tokens, if P is full then w 1  X  X  X  w k = b s c ; in that case, the se-quence w 0 1 , . . . , w 0 k is a suggestion for spelling cor-rection, and we denote it by crc ( P ) . As an example, Figure 3 shows two full paths P 1 and P 2 in the graph G
D ( s ) of Figure 2. The corrections crc ( P i ) , for i = 1 , 2 , are jaideep kohli excellent ment and sandeep kohli excel attachement , re-spectively.

To obtain corrections crc ( P ) with high quality, we produce a set of k full paths with the largest weights, for some fixed k ; we denote this set by topPaths D ( s ) . The weight of a path P , denoted weight( P ) , is the sum of the weights of all the nodes and edges in P , and we define the weights of nodes and edges next. To find these paths, we use a well known efficient algorithm (Eppstein, 1994).
Consider a node u =  X  w, w 0  X  of G D ( s ) . In the construction of G D ( s ) , zero or more merges of (part of) original tokens have been applied to obtain the token w ; let #merges( w ) be that number. Consider an edge e of G D ( s ) from a node u 1 =  X  w 1 , w 0 1  X  to u 2 =  X  w 2 , w 0 2  X  . In s , either w 1 and w 2 belong to different words (i.e., there is a whitespace between them) or not; in the former case define #splits( e ) = 0 , and in the latter #splits( e ) = 1 . We define: weight( u ) def = score D ( w 0 | w ) + a m  X  #merges( w ) weight( e ) def = a s  X  #splits( e ) Note that a m and a s are negative, as they penalize for merges and splits, respectively. Again, in our implementations, we learned a m and a s by means of SVM.

Recall that topPaths D ( s ) is the set of k full paths (in the graph G D ( s ) ) with the largest weights. From topPaths D ( s ) we get the set C D ( s ) of candidate suggestions: 2.2.4 Word Correlation
To compute score D ( r | s ) for r  X  X  D ( s ) , we incor-porate correlation among the words of r . Intuitively, we would like to reward a candidate with pairs of words that are likely to co-exist in a query. For that, we assume a (symmetric) numerical function crl ( w 0 1 , w 0 2 ) that estimates the extent to which the words w 0 1 and w 0 2 are correlated. As an example, in the email domain we would like crl ( kohli , excel ) to be high if Kohli sent many emails with excel at-tachments. Our implementation of crl ( w 0 1 , w 0 2 ) es-sentially employs pointwise mutual information that has also been used in (Schierle et al., 2007), and that compares the number of documents (emails) con-taining w 0 1 and w 0 2 separately and jointly.
Let P  X  topPaths D ( s ) be a path. We de-note by crl ( P ) a function that aggregates the num-bers crl ( w 0 1 , w 0 2 ) for nodes  X  w 1 , w 0 1  X  and  X  w of P (where  X  w 1 , w 0 1  X  and  X  w 2 , w 0 2  X  are not nec-essarily neighbors in P ). Over the email domain, our crl ( P ) is the minimum of the crl ( w 0 1 , w 0 2 ) . We define score D ( P ) = weight( P ) + crl ( P ) . To improve the performance, in our implementation we learned again (re-trained) all the parameters in-volved in score D ( P ) .

Finally, as the top suggestions we take crc ( P ) for full paths P with highest score D ( P ) . Note that crc ( P ) is not necessarily injective; that is, there can be two full paths P 1 6 = P 2 satisfying crc ( P 1 ) = crc ( P 2 ) . Thus, in effect, score D ( r | s ) is determined by the best evidence of r ; that is, score D ( r | s ) def = max { score D ( P ) | crc ( P ) = r  X  Note that our final scoring function essentially views P as a clique rather than a path. In principle, we could define G D ( s ) in a way that we would extract the maximal cliques directly without find-ing topPaths D ( s ) first. However, we chose our method (finding top paths first, and then re-ranking) to avoid the inherent computational hardness in-volved in finding maximal cliques. 2.3 Handling Expressions We now briefly discuss our handling of frequent n -grams (expressions). We handle n -grams by intro-ducing new nodes to the graph G D ( s ) ; such a new node u is a pair  X  t , t 0  X  , where t is a sequence of n consecutive sp-tokens and t 0 is a n -gram. The weight of such a node u is rewarded for consti-tuting a frequent or important n -gram. An exam-ple of such a node is in the grey box of Figure 2, where sandeep kohli is a bigram. Observe that sandeep kohli may be deemed an important bi-gram because it occurs as a sender of an email, and not necessarily because it is frequent.

An advantage of our approach is avoidance of over-scoring due to conflicting n -grams . For example, consider the query textile import expert , and assume that both textile import and import export (with an  X  X  X  rather than an  X  X  X ) are frequent bigrams. If the user referred to the bigram textile import , then expert is likely to be correct. But if she meant for import export , then expert is misspelled. However, only one of these two options can hold true, and we would like textile import export to be rewarded only once X  X or the bigram import export . This is achieved in our approach, since a full path in G D ( s ) may contain either a node for textile import or a node for import export , but it cannot contain nodes for both of these bigrams.

Finally, we note that our algorithm is in the spirit of that of Cucerzan and Brill (2004), with a few in-herent differences. In essence, a node in the graph they construct corresponds to what we denote here as  X  w, w 0  X  in the special case where w is an actual word of the query; that is, no re-tokenization is ap-plied. They can split a word by comparing it to a bi-gram. However, it is not clear how they can split into non-bigrams (without a huge index) and to handle si-multaneous merging and splitting as in our running example (1). Furthermore, they translate bigram in-formation into edge weights, which implies that the above problem of over-rewarding due to conflicting bigrams occurs. Our experimental study aims to investigate the ef-fectiveness of our approach in various settings, as we explain next. 3.1 Experimental Setup We first describe our experimental setup, and specif-ically the datasets and general methodology.
 Datasets. The focus of our experimental study is on personal email search ; later on (Section 3.6), we will consider (and give experimental results for) a totally different setting X  X ite search over www. ibm.com , which is a massive and open domain. Our dataset (for the email domain) is obtained from the Enron email collection (Bekkerman et al., 2004; Klimt and Yang, 2004). Specifically, we chose the three users with the largest number of emails. We re-fer to the three email collections by the last names of their owners: Farmer , Kaminski and Kitchen . Each user mailbox is a separate domain, with a separate corpus D , that one can search upon. Due to the ab-sence of real user queries, we constructed our dataset by conducting a user study, as described next.
For each user, we randomly sampled 50 emails and divided them into 5 disjoint sets of 10 emails each. We gave each 10-email set to a unique hu-man subject that was asked to phrase two search queries for each email: one for the entire email con-tent ( general query ), and the other for the From and X-From fields ( sender query ). (Figure 1 shows ex-amples of the From and X-From fields.) The latter represents queries posed against a specific field (e.g., using  X  X dvanced search X ). The participants were not told about the goal of this study (i.e., spelling correc-tion), and the collected queries have no spelling er-rors. For generating spelling errors, we implemented a typo generator. 1 This generator extends an online typo generator (Seobook, 2010) that produces a vari-ety of spelling errors, including skipped letter, dou-bled letter, reversed letter, skipped space (merge), missed key and inserted key; in addition, our gener-ator produces inserted space (split). When applied to a search query, our generator adds random typos to each word, independently, with a specified prob-ability p that is 50% by default. For each collected query (and for each considered value of p ) we gener-ated 5 misspelled queries, and thereby obtained 250 instances of misspelled general queries and 250 in-stances of misspelled sender queries.
 Methodology. We compared the accuracy of MaxPaths (Section 2) with three alternatives. The first alternative is the open-source Jazzy , which is a widely used spelling-correction tool based on (weighted) edit distance. The second alternative is the spelling correction provided by Google . We provided Jazzy with our unigram index (as a dic-tionary). However, we were not able to do so with Google, as we used remote access via its Java API (Google, 2010); hence, the Google tool is un-aware of our domain, but is rather based on its own statistics (from the World Wide Web). The third alternative is what we call WordWise , which applies word-level correction (Section 2.1) to each input query term, independently. More precisely, WordWise is a simplified version of MaxPaths , where we forbid splitting and merging of words (i.e., only the original tokens are considered), and where we do not take correlation into account.

Our emphasis is on correcting misspelled queries , rather than recognizing correctly spelled queries , due to the role of spelling in a search engine: we wish to provide the user with the correct query upon misspelling, but there is no harm in making a sug-gestion for correctly spelled queries, except for vi-sual discomfort. Hence, by default accuracy means the number of properly corrected queries (within the top-k suggestions) divided by the number of the misspelled queries. An exception is in Section 3.5, where we study the accuracy on correct queries.
Since MaxPaths and WordWise involve parame-ter learning (SVM), the results for them are consis-tently obtained by performing 5 -folder cross valida-tion over each collection of misspelled queries. 3.2 Fixed Error Probability Here, we compare MaxPaths to the alternatives when the error probability p is fixed ( 0 . 5 ). We con-sider only the Kaminski dataset; the results for the other two datasets are similar. Figure 4(a) shows the accuracy, for general queries, of top-k suggestions for k = 1 , k = 3 and k = 10 . Note that we can get only one (top-1 ) suggestion from Google. As can be seen, MaxPaths has the highest accuracy in all cases. Moreover, the advantage of MaxPaths over the alternatives increases as k increases, which indi-cates potential for further improving MaxPaths .
Figure 4(b) shows the accuracy of top-k sugges-tions for sender queries. Overall, the results are sim-ilar to those of Figure 4(a), except that top-1 of both WordWise and MaxPaths has a higher accuracy in sender queries than in general queries. This is due to the fact that the dictionaries of person names and email addresses extracted from the X-From and From fields, respectively, provide strong features for the scoring function, since a sender query refers to these two fields. In addition, the accuracy of MaxPaths is further enhanced by exploiting the cor-relation between the first and last name of a person. 3.3 Impact of Error Probability We now study the impact of the complexity of spelling errors on our algorithm. For that, we mea-sure the accuracy while the error probability p varies from 10% to 90% (with gaps of 20% ). The re-sults are in Figure 4(c). Again, we show the results only for Kaminski, since we get similar results for the other two datasets. As expected, in all exam-ined methods the accuracy decreases as p increases. Now, not only does MaxPaths outperform the alter-natives, its decrease (as well as that of WordWise ) is the mildest X  13% as p increases from 10% to 90% (while Google and Jazzy decrease by 23% or more). We got similar results for the sender queries (and for each of the three users). 3.4 Adaptiveness of Parameters Obtaining the labeled data needed for parameter learning entails a nontrivial manual effort. Ideally, we would like to learn the parameters of MaxPaths in one domain, and use them in similar domains. More specifically, our desire is to use the parame-ters learned over one corpus (e.g., the email collec-tion of one user) on a second corpus (e.g., the email collection of another user), rather than learning the parameters again over the second corpus. In this set of experiments, we examine the feasibility of that approach. Specifically, we consider the user Farmer and observe the accuracy of our algorithm with two sets of parameters: the first, denoted by MaxPaths in Figures 5(a) and 5(b), is learned within the Farmer dataset, and the second, denoted by MaxPaths ? , is learned within the Kaminski dataset. Figures 5(a) and 5(b) show the accuracy of the top-1 suggestion for general queries and sender queries, respectively, with varying error probabilities. As can be seen, these results mean good news X  X he accuracies of MaxPaths ? and MaxPaths are extremely close (their curves are barely distinguishable, as in most cases the difference is smaller than 1% ). We repeated this experiment for Kitchen and Kaminski, and got sim-ilar results. 3.5 Accuracy for Correct Queries Next, we study the accuracy on correct queries, where the task is to recognize the given query as cor-rect by returning it as the top suggestion. For each of the three users, we considered the 50 + 50 (gen-eral + sender) collected queries (having no spelling errors), and measured the accuracy , which is the percentage of queries that are equal to the top sug-gestion. Table 3 shows the results. Since Jazzy is based on edit distance, it almost always gives the in-put query as the top suggestion; the misses of Jazzy are for queries that contain a word that is not the cor-pus. MaxPaths is fairly close to the upper bound set by Jazzy. Google (having no access to the domain) also performs well, partly because it returns the in-put query if no reasonable suggestion is found. 3.6 Applicability to Large-Scale Site Search Up to now, our focus has been on email search, which represents a restricted (closed) domain with specialized knowledge (e.g., sender names). In this part, we examine the effectiveness of our algorithm in a totally different setting X  large-scale site search within www.ibm.com , a domain that is popular on a world scale. There, the accuracy of Google is very high, due to this domain X  X  popularity, scale, and full accessibility on the Web. We crawled 10 million documents in that domain to obtain the corpus. We manually collected 1348 misspelled queries from the log of search issued against developerWorks ( www.ibm.com/developerworks/ ) during a week. To facilitate the manual collection of these queries, we inspected each query with two or fewer search results, after applying a random permutation to those queries. Figure 6 shows the accuracy of top-k suggestions. Note that the performance of MaxPaths is very close to that of Google X  X nly 2% lower for top-1 . For k = 3 and k = 10 , MaxPaths outperforms Jazzy and the top-1 of Google (from which we cannot obtain top-k for k &gt; 1 ). 3.7 Summary To conclude, our experiments demonstrate various important qualities of MaxPaths . First, it outper-forms its alternatives, in both accuracy (Section 3.2) and robustness to varying error complexities (Sec-tion 3.3). Second, the parameters learned in one domain (e.g., an email user) can be applied to sim-ilar domains (e.g., other email users) with essen-tially no loss in performance (Section 3.4). Third, it is highly accurate in recognition of correct queries (Section 3.5). Fourth, even when applied to large (open) domains, it achieves a comparable perfor-mance to the state-of-the-art Google spelling correc-tion (Section 3.6). Finally, the higher performance of MaxPaths on top-3 and top-10 corrections sug-gests a potential for further improvement of top-1 (which is important since search engines often re-strict their interfaces to only one suggestion). We presented the algorithm MaxPaths for spelling correction in domain-centric search. This algo-rithm relies primarily on corpus statistics and do-main knowledge (rather than on query logs). It can handle a variety of spelling errors, and can incor-porate different levels of spelling reliability among different parts of the corpus. Our experimental study demonstrates the superiority of MaxPaths over ex-isting alternatives in the domain of email search, and indicates its effectiveness beyond that domain.
In future work, we plan to explore how to utilize additional domain knowledge to better estimate the correlation between words. Particularly, from avail-able auxiliary data (Fagin et al., 2010) and tools like information extraction (Chiticariu et al., 2010), we can infer and utilize type information from the cor-pus (Li et al., 2006b; Zhu et al., 2007). For instance, if kohli is of type person , and phone is highly cor-related with person instances, then phone is highly correlated with kohli even if the two words do not frequently co-occur. We also plan to explore as-pects of corpus maintenance in dynamic (constantly changing) domains.
