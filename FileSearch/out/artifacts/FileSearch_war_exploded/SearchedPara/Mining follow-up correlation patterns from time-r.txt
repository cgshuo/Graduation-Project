 Shichao Zhang  X  Zifang Huang  X  Jilian Zhang  X  Xiaofeng Zhu Abstract Research on traditional association rules has gained a great attention during the past decade. Generally, an association rule A  X  B is used to predict that B likely occurs when A occurs. This is a kind of strong correlation, and indicates that the two events will probably happen simultaneously. However, in real world applications such as bioinformatics and medical research, there are many follow-up correlations between itemsets A and B ,such as, B is likely to occur n times after A has occurred m times. That is, the correlative itemsets do not belong to the same transaction. We refer to this relation as a follow-up correlation pattern (FCP). The task of mining FCP patterns brings more challenges on efficient processing than normal pattern discovery because the number of potentially interesting patterns becomes extremely large as the length limit of transactions no longer exists. In this paper, we develop an efficient algorithm to identify FCP patterns in time-related databases. We also experimentally evaluate our approach, and provide extensive results on mining this new kind of patterns. Keywords Data mining  X  Time-related database  X  Correlation mining  X  Follow-up correlation pattern 1 Introduction The problem of discovering association rules from a large database has been studied extensively in the last decade. Intuitively, the goal of mining association rules is to cap-ture and model useful associated correlations or patterns from large databases. According to the definition in [ 1 ], an association rule is an implication in the form of A  X  B ,where A and B are frequent itemsets in a transaction database. In practical applications, the rule A  X  B can be used to predict that  X  X f A occurs in a transaction, B is also likely to occur in the same transaction X , and we can employ this association rule to predict that the occurrence of A implies the occurrence of B in marketing. Such applications are expected to increase product sales and provide more convenience to supermarkets and customers. Therefore, mi-ning association rules in databases, rooted in market basket analysis [ 1 , 2 ], has been an active research topic in data mining.

Although association rule mining techniques have advanced to a mature stage, there is another type of interesting patterns among objects or itemsets that is useful and different from the association rules but cannot yet be discovered with existing association rule mining algorithms in many real world applications. It has a form of  X  X temset B is likely to occur n times after itemset A has occurred m times X . We refer to this follow-up correlation between two itemsets as a Follow-up Correlation Pattern (denoted as FCP), and use the form of an ordered pair, A m , B n , to represent the FCP pattern, where m and n represent the numbers of appearances of itemsets A and B , respectively. In this paper, we define this new kind of interesting patterns and develop techniques to mine them.

Take a military case as an example. Association rule mining may contribute to predicting battlefield situations and raising the situation awareness ability. We can construct a command database as follows: there is one record for each campaigning day and each branch of the armed force corresponds to a field in the record. The value of a field shows whether the branch of the armed force is active or not. Applying traditional association rule mining, we can possibly discover rules like:
When the enemy sends out helicopters, at 70% of probability the enemy sends out mus-keteers and panzers on the same day.

Although the association rule above expresses some relationships among the branches of the armed force, the prediction function is limited. Military leaders would be more interested in the following type of rules:
If the enemy sends out helicopters one day, the enemy will probably send out musketeers and panzers in the following 2 days.

According to the analysis of the command database, we can evaluate the battlefield situation and adopt a proper strategy to cope with the probable military environment. A FCP pattern A m , B n can be used to predict that  X  X f A has occurred m times, B is likely to occur n times in the following transactions X . Like association rules, we can also apply the FCP patterns to predict customer behavior in marketing and in other domains.

The main contributions of this paper are as follows.  X  A new kind of patterns called follow-up correlation patterns in the form of itemset pairs is  X  An algorithm is proposed to mine FCP patterns from a time-related database.  X  In order to reduce the search space, a pruning strategy is proposed. The strategy can prune  X  In order to make the mining process more efficient, we adopt another optimization
The rest of this paper is organized as follows. Section 2 reviews related work. Section 3 defines FCP patterns formally. Section 4 describes an algorithm to mine FCP patterns. In Sect. 5 , performance studies and experiments are presented. Finally we conclude this paper in Sect. 6 and present our future work. 2 Related work Agarwal et al. [ 3 ] first introduced the problem of discovering frequent sequential patterns from transaction databases. This work is based on a set of sequences called data-sequences. The main goal is to find all frequent sequential patterns with a user-specified minimum sup-port, where the support of a sequential pattern is the percentage of data-sequences that contain the concerned pattern. AprioriALL [ 3 ]andGSP[ 20 ] are such two algorithms designed to mine sequential patterns in a level-wise manner. Since then, many efficient algorithms have been proposed to deal with sequential pattern mining, such as FreeS-ployed additional useful constraints in the mining process [ 10 , 22 ]. Similar to the sequen-tial patterns, researchers have proposed frequent episodes from a sequence of events [ 18 ]. in three different manners. They are essentially acyclic graphs of events whose edges specify the temporal before-and-after relationship but without timing-interval restrictions.
 segment-wise periodic patterns [ 11 ], and cyclically repeated patterns [ 14 , 15 ] are different from association rules. These studies extended association rules to a general form or a sequential form, which can well model the underlying sequential relationship between objects. Some researchers [ 19 ] assumed that the transactional data to be analyzed is time-stamped and that time intervals are specified by the user to divide the data into disjoint seg-ments, and then they discover such regularities in the behavior of association rules over time. The work of [ 11 ], which can mine the segment-wise or point-wise periodicity in time-related data sets, differs from the cyclic association rules which aim to find full-cycle periodicity for all the segments in selected sequences of data. The cyclic association rules and segment-wise periodic patterns are both special cases of sequential patterns proposed in [ 3 ]. Mannila et al. [ 18 ] discovered frequent episodes in sequences of events, such as the serial episodes and parallel episodes. Our proposed FCP patterns are similar to the above patterns, but are also different significantly from them.

As an extension of association rules, the cyclic association rules consider the problem of mining patterns in a range of possible periods [ 19 ]. But in fact, a pattern of this kind is an association rule appearing in a specific short period of time instead of appearing in the whole period. It is necessary to point out that although there is a sequential component, in other words, there is a temporal component in the example given above, an FCP pattern is also different from a sequential pattern in a transaction database, which was first brought up by [ 3 ]. That is, an FCP pattern is a kind of inter-transaction association rule with quan-tity, even though it contains some differences from the inter-transaction association rules introduced in [ 17 ] while a sequential pattern is a kind of intra-transaction association rule essentially, because each sequence is actually taken as one transaction and the aim of the mining process is to find an interesting similar portion among the sequences based on given parameters.

Inter-transaction association rules proposed by Lu et al. [ 17 ] are implication rules whose two sides are totally-ordered episodes with timing-interval restrictions on the events in the episodes and on the two sides. Bettini et al. [ 4 ] considered a generalization of inter-transaction association rules: these are essential rules whose left-hand and right-hand sides are episodes with time-interval restrictions. The mining of cyclic association rules by Ozden et al. [ 19 ] also considered mining some patterns in a range of possible periods. In practice, not every portion in the time series would contribute to the periodicity; this type of looser periodicity isoftenreferredtoas partial periodicity . The work of Han et al. [ 13 ], Yang et al. [ 21 ], and Elfeky et al. [ 8 ] can deal with mining partial periodic patterns. Among them, the strategy proposed in [ 8 ] can efficiently mine obscure periodic patterns at the cost of one database pass, by using the Fast Fourier Transform (FFT) technique.

Based on the previous studies, association rule mining tends to find such a pattern that the relative elements appear simultaneously in a transaction. Different from the association rule mining, the discovery of our FCP patterns in this paper is an identification of another kind of interesting pattern that the relative elements do not appear simultaneously, i.e., they occur in an asynchronous way.

We introduced follow-up correlation itemset pairs for the first time in [ 24 ] and adopted a series of experiments to show the performance of the algorithm presented in that paper. From the initial results, it is evident that the follow-up correlation itemset pairs do have some merits over the traditional association analysis, while it is also true that the presented algorithm in [ 24 ] cost a higher time expense than traditional association rule mining, as the length limit of transactions is no longer existent, even though we adopted some pruning strategies. In order to improve the efficiency of that algorithm, we extend follow-up correlation itemset pairs in this paper through adding necessary constraints. Existing work on the efficiency of constraint-based association mining [ 6 , 7 , 9 , 16 ] is applicable to our follow-up correlation itemset pairs. In addition, users may also have certain interesting follow-up correlation intervals in mind. If we can utilize the information to guide the mining process, our mining algorithm would be more efficient. For example, users may want to know how the helicopters X  appearances today will affect other branches of the armed force in the range of several following days or within the next week. A rule like  X  X f the enemy sends out helicopters today, the panzers will be sent out three times 365 days later X  probably cannot inspire much confidence in military leaders. Thus, the major contribution of this paper is that we make it clearer how useful the proposed new kind of patterns is and that we adopt one more optimization technique in the form of a generalized constraint on correlation intervals. We demonstrate the perfor-mance of the technique through a series of experiments that will be represented in a later section. 3 Problem definition with examples for FCP patterns Several examples for our FCP patterns are given as illustration below.
 Example 1 Consider a given database D with randomly appended transactions. Let A and B be two itemsets in D . Delete other itemsets and those transactions that contain neither itemsets A nor B . (For simplicity, we use a 1-item itemset, or an item, to illustrate an itemset in this paper.) We have the following data for example.
 where  X 1 X  indicates that item A occurs in a transaction and  X 0 X  indicates that item A does not occur in the transaction.
 According to the support-confidence framework, we can see that the support count of AB is 2 and it is very small. Consequently, itemset AB may not be interesting. However, the above data has shown a kind of interesting follow-up correlation: B occurs once after A has occurred once. In addition, in last two transactions B occurs once when A has occurred once. According to our method (which will be developed in this paper), we can identify an interesting follow-up correlation itemset pair A , B with frequency 10.
 Example 2 Consider the same database D in Example 1 . Assume that we have the following data set,
According to the support-confidence framework, we can obtain an association rule A  X  B with confidence 0.333. It would not be interesting if the confidence is smaller than the given minimum confidence. However, the above data has also shown another interesting follow-up correlation: B occurs once after A has occurred three times. Using our method to be develo-ped in this paper, we can discover an interesting follow-up correlation itemset pair A 3 , B 1 with frequency 6. We can identify the same follow-up correlation from, for example, the following data.

Certainly, the association rule A  X  B with support 1 is probably not of interest according to the support-confidence framework.

Also, we can identify an interesting follow-up correlation itemset pairs A 4 , B 2 with frequency 4 from the following data.

Generally, we can obtain a common form of follow-up correlation itemset pairs C n , A m with frequency s from a database, where C and A denote the condition itemset that occurs at first and the action itemset that occurs successively respectively; m and n denote the times of appearances of itemsets C and A , respectively. Take Example 2 for instance. The itemset pair
A 3 , B 1 would be pruned away in association rule mining settings. Accordingly, we name this new kind of follow-up correlation as FCP. A FCP pattern is represented as ( C n , A m , s ) , where s is the frequency of the ordered pair C n , A m in a database.

FCP is very useful in many real world applications. There are some examples of FCP patterns below.
 Example 3 In a daily stock exchange database, there are three attributes: the stock name, the percentage change of its value in terms of its previous day X  X  value, and the date. From this database, it is possible to discover patterns related to stock value increases and decreases. Instead of real percentage values, we use some notations, such as D (representing more than 10% of the daily value decrease), I (representing more than 20% of the daily value Increase) and O (other kinds of changes). We then use these notations to transform the original data of the stock exchange database into a new form of data. Consider the transformed sequence  X  X DIIIODDDIIIIODDD X  for stock A and  X  X ODDOIDODODDODODD X  for stock sequence, set the value in the corresponding position to 1, otherwise, set it to 0. So, the increasing sequence of stock A is 10111000011110000 and stock B is 10000100000000000. We can find an approximate phenomenon that after the real percentage value of stock B increases once, stock A will increase four times (we omit those zero values that appear in the same position of stocks A and B , and after deletion, the sequences of A and B are 111101111 and 100010000, respectively). This observation can be utilized to predict the trend of stock A based on the trend of stock B . On the contrary, we can also infer the trend of stock B based on the analysis of A X  X  sequences.
 Example 4 This is an investment and profits example. Suppose a person X invests in a company C in time T 1. After several investments in times T 2 , T 3, etc, X will begin to receive profits from C in time Ti if the company is well developing. The time of investments varies because of the uncertain factors of the economy; meanwhile, the times of return profits to X also vary according to the development strategy of the company C . A possible structure of investment and profits is shown in Fig. 1 .
 In a real database, we can hardly use a formula to describe the principle behind the data. Therefore, it is helpful to mine follow-up correlation itemset pairs to mend the investment strategy in most cases of the business realm.

From the above examples, we can find that the follow-up correlation itemset pairs are interesting and generally hidden in many real world applications, and can reveal the un-derlying relationship between objects that occurs one after another. We will give a formal definition of the FCP patterns in a later stage, and propose an algorithm to mine these inter-esting patterns from a sequential dataset efficiently.

Below we first use an example to illustrate the follow-up correlation itemset pairs from a market basket database perspective, and then give a general description of this type of patterns.
 Example 5 Given a customer transaction database in a supermarket, see Fig. 2 ,which contains 9 transactions. Each transaction consists of a different number of items, representing the corresponding commodities purchased simultaneously by a customer.

The left table of Fig. 2 is the original transaction database, while the right is a transformed database of the left table. We use 0 and 1 to indicate that an item occurs or does not occur in a transaction. From the transformed database, we can find some interesting patterns. For instance, item c is likely to appear twice or three times after item d has occurred twice. We use ordered pairs d 2 , c 3 and d 2 , c 2 to represent the follow-up correlations. Note that for the fourth time of the occurrence of item d , item c also occurs at the same time (in transaction 7) and it appears again in transaction 8. This kind of patterns, like d 2 , c 2 , is called a strong follow-up correlation itemset pair (SFCP); while for the other patterns, such as d 2 , c 3 ,we call them a lagging follow-up correlation itemset pair (LFCP). As for items d and f , neither of them occurs in transactions 3, 4, 5 and 9, so we omit these non-occurring sequences. In this case, the resulting sequence of item d is  X 11110 X ; the sequence of f is  X 01101 X . Finally, we can get the FCP patterns from the sequences of the two items as d 1 , f 2 , d 2 , f 2 and d 4 , f 1 . Note that we omit the non-occurring transactions only for finding the FCP patterns. Some Traditional association rule mining cannot capture this kind of patterns. Take the items c and d for example. The support of itemset cd is 1 / 9 = 0 . 11, which is fairly small. This itemset is likely to be pruned away while generating interesting patterns. Using our proposed algorithm below, one can efficiently grasp such kind of interesting follow-up correlation patterns to provide more useful information for the decision maker.

Our proposed patterns are different from the sequential patterns that were first brought up by [ 3 ]. The difference is that the sequential patterns do not consider the quantities of items bought in a transaction, which may lead to the loss of important and interesting information.
 Item occurring sequence Given a database D with T transactions, the occurrence sequence t  X  X  1 , T ] , indicating that item I occurs or doesn X  X  occur in transaction t respectively. And I is in front of I t + 1 in the sequence for all t = 1 , 2 ,..., T  X  1.

An appearance sequence of item I , S 1 I , is a subsequence of S I , in which item I occurs consecutively, that is, S 1 I = I m ,..., I n ,where I t = 1 , t = m ,..., n , and 1  X  m  X  n  X  T . The length of S 1 I is S 1 I = n  X  m + 1. Similarly, the non-appearance sequence of item I is defined as S 0 I = I m ,..., I n ,where I t = 0 , t = m ,..., n and 1  X  m  X  n  X  T .The length of S 0 I is S 0 I = n  X  m + 1. Thus an item occurring sequence is decomposed into the appearance sequences and non-appearance sequences that are interleaved with each other. The transaction database D is transformed into item occurring sequences in order to facilitate mining the FCP, which will be discussed below.
 Follow-up correlation itemset pairs A FCP is an ordered pair C , A ,where C and A (representing the Condition itemset and the Action itemset, respectively) are both appearance sequences ,thatis, C = S 1 C = C m ,..., C n ,where1  X  m  X  n  X  T ;and A = S 1 A =
A k ,..., A l ,where k  X  X  n , n + 1 } , k  X  l  X  T ;and C m  X  1 = C n + 1 = 0, if 1 &lt; m  X  n &lt; T ; A  X  1 = A l + 1 = 0, if 1 &lt; k  X  l &lt; T . The pair C , A is called the Lagging Follow-up correlation itemset Pairs if k = n + 1; and it is called the Strong Follow-up correlation itemset Pairs if k = n .

Take the following sequences as an example. C =  X 111011101110 X , D =  X 000100010001 X  and E = X 001100110011 X . We can get LFCP C 3 , D 1 and SFCP C 3 , E 2 from them. Bet-ween sequence A =  X 101010101010 X  and sequence B =  X 010101010101 X , A 1 , B 1 and
B 1 , A 1 are different FCP patterns because FCP is an order pair. FC P A 1 , B 1 is LFCP and its frequency is 6; and FCP B 1 , A 1 is LFCP as well but its frequency is 5. Without loss of generality, we use the general form of the FCP, C L 1 , A L 2 ,where L 1 and L 2 are the lengths of the condition and the action itemset appearance sequences, respectively, that is, L 1 = | C | = n  X  m + 1and L 2 = | A | = l  X  k + 1.

A FCP pattern p = C , A ,where C = C m ,..., C n and A = A k ,..., A l ,isa subpair of the FCP pattern p = C , A ,where C = C m ,..., C n and A = A k ,..., A l , only if m m  X  n = n and k = k  X  l l . A subpair p is called a ( j 1 , j 2 ) -subpair of p if j = C = n  X  m + 1, and j 2 = A = l  X  k + 1.
 Frequency of FCP The frequency of a FCP pattern p = C L 1 , A L 2 is the occurring times of p in a database D .

We can get the frequency of a pattern p by scanning the whole database and count the number of times that p occurs. The users can take advantage of those FCP patterns that have a higher frequency count, because FCP patterns with a high frequency may be more useful in decision making.

There are some interesting properties of the FCP patterns, which can be utilized to facilitate the mining process. We present some of them below.

Property 1 If a FCP pattern p has a frequency of s , and each of its subpairs has a frequency, say s , which is at least equal to or larger than the frequency of p , i.e., S  X  S .
This property called anti-monotone, which is similar to that of frequent itemsets in association rule mining, is used to prune away the infrequent candidate itemsets in advance. Different from the association rule mining process [ 1 ], we find the longest (which will be defined later) FCP pattern p at each time without counting all its subpairs. The traditional as-sociation rules mining framework uses a strategy that fully traverses the candidate k -itemsets through the joining results over the frequent k -itemsets. That is, one needs to identify shorter frequent itemsets in order to generate longer frequent itemsets. But in our algorithm, we only need to find out the longest FCP patterns, because we can generate all its shorter FCP patterns directly without generating the shorter FCP patterns at first. This could increase the performance of the algorithm for mining FCP pattern. After checking the whole database, we generate p for the user and all its subpairs as well. This can substantially reduce the search space.

We give the definition of the longest FCP as follows. Given two appearance sequences of itemset C , C m ,..., C n , and itemset A , A k ,..., A l ,where1  X  m  X  n  X  T , m &lt; k  X  l  X  T and k  X  n + 1, the longest FCP pattern of these two appearance sequences is a pair p = C , A ,where C = C m ,..., C The number of longest FCP patterns of the appearance sequences of two itemsets is equal to the number of transactions that these two itemsets both occur simultaneously. So we can get the second property of FCP.
 Property 2 The occurring times of the SFCP p = C 1 , A 1 between two itemsets, C and A , are approximately equal to the support count of the 2-itemset CA in a database D .
This can be proved from the previous definitions of SFCP and the longest pattern, because the support count of an itemset in database is the total number of transactions that contain the itemset.
It is interesting that the identification of the frequent itemsets of traditional association rule mining is close to the discovery of our proposed patterns. Take Property 2 as an instance. We can see that the support of the 2-itemset is a special case of our proposed SFCP patterns. This observation can give us a deep understanding of the relationship between association rule mining and the mining problem of our proposed patterns, i.e., association rule mining tries to find those itemsets that occur together in each transaction, which can be called synchronized occurring ; while in our model we want to search the itemsets that appear one after another, which can be called asynchronous occurring .

Given a database D , our goal is to find the frequency of FCP from database D according to a user defined minimal support count (currently, we only address the mining problem of FCP patterns that consists of two items). The task of mining such patterns is different from traditional association rule mining because the association rule mining algorithm generates necessary for our algorithm to generate candidate FCP patterns. Our algorithm searches the sequences of two items from end to end, counting each longest FCP pattern that it encountered. After the counting process, all the frequency of FCPs and its subpairs are presented to users. The mining algorithm of FCP will be discussed in Sect. 4 . 4 Algorithm design 4.1 The mining algorithm Our algorithm for mining FCP patterns from a database consists of two steps. First, sequentia-lize the data. That is, convert the transactional form of items into sequences. Second, search the sequences in order to find the longest FCP patterns within a generalized constraint on intervals. The detailed algorithm is presented in Fig. 3 .
 Sequentializing phase In the first step, we read in the data and build a list for each item of the database that stores the appearance and the non-appearance sequences of the items. In practice, the database is usually very large. It tends to hinder the construction of the sequences of items. We devise a technique, called Lazy Counting , in order to save storage space and speed up the process of sequentialization for items. The main idea of Lazy Counting is that we do not count the information about an item when it does not occur in a transaction. We adopt the same database in Example 1 to illustrate the sequentialization algorithm and the Lazy Counting technique.

In Fig. 4 , there is an illustration of the sequentialization process. The  X  X ame X ,  X  X ail X  and  X  X hild X  denote the name of each item, the pointer that points to a tail node of the list and the consecutive child list respectively. The  X  X ail X  pointer is used for speeding up the access of the list, because we should add a new node to the end of the list and the  X  X ail X  pointer helps us find the end of the list efficiently. The fields  X  S  X , X  E  X  X nd X  P  X  denote the Start position, End position and a successive Pointer to next node, respectively.  X  S  X  X nd X  E  X  record the start number and the end number of transactions for each item. An item appears continuously between the start and the end transactions. For instance, item  X  a  X  occurs from the third transaction to the fifth transaction, so its  X  S  X  X nd X  E  X  fields are filled with 3 and 5, respectively. When we access the first node of item a  X  X  list, we can easily find that the first appearance of the a position is 3. Consequently, we can infer that item a does not occur in both the first transaction and the second transaction. In addition, for each item, we do not need to count in the information of their  X 0 X  sequences (which do not appear in transactions); instead, only the information of their  X 1 X  sequences (which appear in transactions) will be recorded. We name this strategy as Lazy Counting , which is lazy for ignoring the  X 0 X  sequences. Obviously, we can save a mass of memory space so as to raise the memory utilization ratio. When all the transactions are processed, the list table is presented in Fig. 5 .

Because of the principle of Lazy Counting , after processing all the transactions, we get a final list table of items in Fig. 5 . The last appearances of items b and g are both in the eight transaction, while the total number of transactions of the database D is 9, so we can infer that items b and g do not occur in the remained transactions.

After the sequentialzing process, all the items of database D are transformed into a long sequence, which consists of consecutive appearance sequences. They can be expressed by mutually disjoint intervals. This information is important for the next step of finding the longest FCP patterns.
 Finding FCP patterns phase After constructing the list table for all items in D ,wethen search the sequences of each two items in order to find all FCP patterns. The search process is relatively straightforward, because we have got all the appearance sequences of each item; the next thing we should do is comparing the endpoints and the overlapping region of these mutually disjoint intervals for each two sequences and count up all the longest FCP patterns.
BasedonProperty1inSect. 3 , the subpairs of the FCP patterns are also counted up, and finally, the results are presented to the user. 4.2 The pruning strategies Generally, the search space for FCP patterns is very large, and it will degrade the performance of our algorithm. In this section, we present a pruning strategy in order to reduce the huge amount of itemset pairs that need to be traversed for FCP patterns. This strategy is based on mutual information (MI).

The mining algorithm aims to find the FCP patterns between each two items from a database, which can lead to a huge number of combinations of itemset pairs. For example, if there are 1,000 distinct items in a database D , the algorithm needs to check as many as 1 , 000  X  ( 1 , 000  X  1 ) = 999 , 000 sequence pairs of items, resulting in great inefficiency in performance. This problem will be getting worse when D contains a larger quantity of items. Actually, it is not necessary to check all these itemset pairs. For instance, item A may have relations with item C , while item B may have weak or none relationship with item C ,so we only need to search the sequence pair of items A and C , and do not need to check the sequence pair of items B and C .

In order to measure the relationship between items, we employ MI to evaluate the relation between items instead of the Chi-squared test [5]. If two items are independent, the MI value between them is zero. If the two items are strongly dependent, such as that one is a function of the other, the MI between them is large. In other words, the value of MI between two items indicates the strength of the relativity between these two items. We adopt MI because it can measure the general (non-linear) dependence, while a correlation function measures linear dependence. In most cases in real world applications, we usually do not know the exact relationship between items, so adopting MI is an appropriate choice. We give an example here to illustrate the computation of MI between two items. Suppose we want to compute the MI between items a and b in Fig. 2 . To begin with, we generate the contingency table for a and b . The result is presented in Table 1 .
 The MI value between items a and b is calculated as: Where P ij , P . j and P i . are the corresponding values from Table 1 . The MI between items a and b is 0.0488 based on the above equation.

After computing the MI for all itemset pairs, we sort the MI values and only process the top K percentage of largest MI values of itemset pairs in the database, where the parameter K is given by the user. This method can reduce the search space substantially. 4.3 A generalized constraint on intervals: MaxInt From a practical point of view, it is necessary to add a generalized constraint on intervals X  Maximum Interval (MaxInt). The efficiency of constraint-based association mining for tradi-tional association rules has been demonstrated through the literature. We adopt this method in follow-up correlation itemset pair mining. In practice, when we concentrate on two rele-vant items, if the interval of an ordered pair is larger than the given threshold, MaxInt here, the ordered pair contributes little to the corresponding pattern and we call it a noneffective ordered pair. Because the ordered pair with quite a big interval tends to be random, irregular or unpredictable in the real world, it is natural to ignore this kind of patterns. Also we can simplify the traversal course when we skip a lot of ordered pairs in this way. 4.4 Output of the interesting FCP patterns Generally, the number of FCP patterns in a database is usually very large and it would probably go beyond the user X  X  ability to process the data. Even if we adopt some pruning strategies, such as the strategy described in Sect. 4.2, there is still a large amount of FCP patterns derived from the database. As we have mentioned in Sect. 3 , a FCP pattern p can be represented as p = ( C m , A n , s ) ,where s is the frequency, or support count, of the ordered itemsets pair C m , A n . We can use a support count threshold given by the user or obtained by using an intelligent method [ 23 ] in order to throw away the uninteresting FCP patterns whose frequency is below the threshold and generate the interesting FCP patterns whose frequency is equal to or larger than the threshold.
Another commonly used technique is the Top-k method. We can present the top k per-centage patterns from all the generated FCP patterns. The generated patterns are sorted in descending order according to their frequencies. Here we assume that if a FCP pattern p has a larger frequency count than that of pattern q , we can conclude that the pattern p is more interesting than the pattern q . 5 Experimental study Extensive experiments have been performed in order to evaluate the performance of our proposed algorithm of finding FCP patterns in databases. The datasets in the experiments are generated in the same way as in [ 2 ], and we use the same notations to describe the features of the datasets. i.e., we use T to denote the average length of each transaction, I the average length of patterns and D the number of transactions in each dataset. We assume that each generated transactional dataset is time-related, and the natural order of transactions implies that they are added into the database one after another. We report below our experimental results of mining FCP patterns from several aspects, such as the number of FCP patterns generated, the execution time and the relationship between frequent itemsets obtained by using association rule mining, under various settings of each dataset. Because the number of varying-length FCP patterns is very large, that is, there are many combinations of m and n , and due to a huge amount of the FCP patterns generated, we only report experimental results on two kinds of FCP patterns, C 1 , A 1 and C 3 , A 1 . Throughout this section, we use  X  X attern 1 X  and  X  X attern 2 X  to denote the above FCP patterns C 1 , A 1 and C 3 , A 1 , respectively. Note that there are no comparisons with other association rules or sequential pattern mining algorithms, because the existing algorithms cannot be modified easily for the mining of our FCP patterns.

The experiments have been conducted on a PC with P4 2.1 GHz CPU and 256 M main memory, and the operating system is WINDOWS XP. 5.1 Performances on various numbers of items Patterns describe interesting follow-up correlations between items in databases. Generally, there are a large number of items, which may be above 1,000, in super-market databases; and in biological databases, the number of items (commonly called attributes) is only too huge to be handled. So we aim to evaluate our algorithm to find FCP patterns from databases that contain different numbers of items in this subsection. We adopt two kinds of databases with different sizes, T10I4D10K and T10I4D100K . Each of them is generated with 50, 100, 200, 500 and 1,000 items, respectively. Then we use our algorithm to extract two kinds of FCP patterns, C 1 , A 1 and C 3 , A 1 from various databases mentioned above without the constraint on intervals. K is set to 50%, i.e., we only present the top 50% of all generated FCP patterns, which are sorted by their frequencies. The mining results are presented in Figs. 6 and 7 .

From the above figures, we can see that the execution time increases approximately linearly when the number of distinct items increases. In Fig. 7 , the number of generated FCP patterns increases greatly when the number of items is large. It is evident that the increase of the number of short FCP patterns ( C , A 1 in Fig. 7 ) is much faster than that of the long FCP patterns ( C 3 , A 1 in Fig. 7 ). 5.2 Performances on different sizes of databases In this subsection, we use databases with different sizes to test our algorithm. The databases in this experiment contain 10,000, 20,000, 50,000, 100,000 and 250,000 transactions, res-pectively. All these databases have a fixed number of 400 distinct items, and the average length of transactions is set to 10 without the constraint on the interval. K is set to 50%, and the average length of patterns is set to 10. The results are listed in Figs. 8 and 9 .
In Figs. 8 and 9 , we can see the same trend as that has been showed in Figs. 6 and 7 .Our algorithm of finding FCP patterns can scale up to large datasets well, which is promising in real world applications.
 5.3 Performances on different K s Generally, the number of items in a database is very large, resulting in huge combinations of itemset pairs that need to be checked for FCP patterns. In order to reduce the search spaces, we adopt the pruning strategy in Sect. 4.2. We present the mining results by using the MI based pruning strategy along with the Top-k method. The settings of the database are shown as follows. The number of items is 1,000, the average length of transactions is 10 and the total number of transactions is 100,000 without the constraint on intervals. The average length of patterns is set to 10. The execution time and the number of generated FCP patterns under different K are presented in Figs. 10 and 11 .

From Fig. 11 , the number of FCP patterns decreased significantly if one can select an appropriate K value.
 5.4 Performances on different average lengths of transactions of transactions in databases. Consequently, we generated several databases with different average lengths of transactions, i.e., T4, T6, T10, T15 and T 20. We fix the number of distinct items to 400, and the total number of transactions to 100,000 without the constraint on the interval. K is set to 50%, s and the average length of patterns are both set to 10. The experimental results of our algorithm under the above settings are presented in Figs. 12 and 13 . 5.5 Performances on different average lengths of patterns We also take into account the average length of maximal patterns in the settings of the data generator (the parameter I ), that may impact the discovering process of the FCP patterns. We adopt several datasets under different I, I4, I6, I8, I10 ,and I12 , to test the performances of our algorithm. The number of the items is fixed to 1,000, the maximal length of transactions is set to 15 ( T15 ), and the number of transactions is 100,000 ( D100 K) without the constraint on intervals. K is set to 50%. The experimental results of our algorithm under above settings are presented in Figs. 14 and 15 . 5.6 Performances on different MaxInt values In order to enhance the efficiency of searching FCP patterns, we adopt the optimization this experiment, we set the parameter X  X axInt X  X o 5, 10, 15, 20, and 25, respectively. The settings of the databases are shown as follows. All databases have a fixed number of 400 distinct items, K is set to 50%, the average length of transactions and the average length of patterns are both set to 10, and the total number of transactions is 100,000. The experimental results of our algorithm under the above settings are presented in Figs. 16 and 17 . Comparing the two figures with the figures presented above, it is obvious that this strategy cuts down the execution time significantly and extracts the most useful patterns. The smaller the MaxInts is selected, the more efficient is the algorithm. 6 Conclusion and future work In this paper, we have presented a model to identify a new type of patterns called Follow-up correlation Patterns (FCP) in a sequential database. A FCP pattern is a pair of itemsets. When the condition itemset occurs m times, the action itemset would likely appear n times in the sequential database. The model consists of defining the FCP patterns and finding those patterns from sequences of itemsets. Our FCP patterns are different from the frequent itemsets of traditional association rule mining, and they are also different from sequential patterns and cyclic patterns. In many real world applications, FCP patterns are useful in modeling the underlying relationship between objects, which is usually less considered by existing models of finding association rules, sequential patterns and cyclic patterns.
 We have developed an algorithm to mine the FCP patterns from a sequential database. Moreover, we have conducted extensive experiments under various settings. The results of the experiments have shows that our algorithm is efficient in finding the FCP patterns.
Although it is a fundamental structure in introducing this new kind of patterns that both the condition part and the action part of a pair are a single item, an extension of this pattern for more items would have more merits. Therefore, in the future work, we will extend the FCP patterns so that the condition part and the action part of a pair is each a collective itemset instead of a single item at present. Moreover, we will try to find some proper real-world temporal data sets to better demonstrate the usefulness of the FCP patterns.
 References Authors Biography
