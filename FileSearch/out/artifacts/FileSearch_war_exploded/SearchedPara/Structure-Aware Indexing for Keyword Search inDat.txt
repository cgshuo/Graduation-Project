 Most of existing methods of keyword search over relational databases find the Steiner trees composed of relevant tuples as the answers. They identify the Steiner trees by discov-ering the rich structural relationships between tuples, and neglect the fact that such structural relationships can be pre-computed and indexed. Tuple units that are composed of most relevant tuples are proposed to address this prob-lem. Tuple units can be precomputed and indexed. Ex-isting methods identify a single tuple unit to answer key-word queries. They, however, may involve false negatives as in many cases a single tuple unit cannot answer a key-word query. Instead, multiple tuple units should be inte-grated to answer keyword queries. To address this problem, in this paper, we study how to integrate multiple related tuple units to effectively answer keyword queries. We de-vise novel indices and incorporate the structural relation-ships between different tuple units into the indices. We use the indices to efficiently and progressively identify the top -k relevant answers. We have implemented our method in real database systems, and the experimental results show that our approach achieves high search efficiency and accuracy, and outperforms state-of-the-art methods significantly. H.2.8 [ Database Applications ]; H.3.3 [ Information Stor-age and Retrieval ]: Information Search and Retrieval Algorithms, Experimentation, Performance Keyword Search, Database, Tuple Unit, Ranking, Indexing
Keyword search is a proven and widely accepted mech-anism for querying in textual document systems and the World Wide Web. The database research community has recently recognized the benefits of keyword search and has been introducing keyword search capabilities into relational databases [2, 4]. One important advantage of keyword search is that it enables users to search for information without having to know complex query languages such as SQL and XQuery or prior knowledge about the structure of the under-lying data. Keyword search provides an alternative means of querying relational databases, which is simple to most internet users.

The alternative approaches of keyword search on rela-tional databases can be broadly classified into candidate net-work based methods [4, 7], Steiner tree based algorithms [2, 3], and tuple unit based approaches [5, 8]. Li et al. [5] (Su et al. [8]) proposed the concept of tuple units (text objects) to efficiently answer keyword queries, which are composed of the most relevant tuples. The tuple units can be gen-erated and indexed to improve search efficiency. However, existing methods identify a single tuple unit to answer key-word queries. They neglect the fact that in many cases a single tuple unit cannot answer a keyword query. It is promising to integrate several related tuple units to effec-tively answer keyword queries. In this paper, we propose a structure-aware index based method to integrate multiple related tuple units to effectively answer keyword queries. We discover the structural relationships between different tuple units and store them into structure-aware indices, and progressively find the top-k answers using such indices. We propose a novel method, namely Saint (Structure-Aware INdexing for finding and ranking Tuple units), to answer keyword queries over relational databases.
Given a database with m connected tables, the tuples, which can be joined together through the primary-foreign-key relationships, should be very relevant to each other. We can materialized them to facilitate keyword search. Consider a database D with m connected tables, R 1 , R 2 ,  X  X  X  , R R denote their join result, i.e., R = m i =1 R i . Each tuple in R is called a tuple unit [5]. Li et al. [5] have studied the techniques of identifying and ranking a single tuple unit to answer keyword queries. However, we noticed that differ-ent tuple units may be interrelated through primary-foreign keys and thus can be integrated together to answer a query. To address this problem, in this paper, we study how to integrate multiple tuple units to answer keyword queries.
We model the tuple units of a relational database as a graph G =( V , E ), where nodes ( V ) are tuple units and edges (
E ) are the relationships between two tuple units. Given two tuple units, if they share the same value on any primary key attribute, they will be related, and thus we connect the two tuple units. Different from Steiner tree based graphs in which nodes are tuples in relational tables and edges are primary-foreign-key relationships between tuples in different tables [2], we note that the graph we constructed has much smaller size, as we group many tuples into a compact tuple unit. Our constructed graph has less nodes and edges than the Steiner tree based graph, and thus is much easier to be manipulated.

We adopt the boolean adjacency matrix BAM to represent the modeled graph. The rows or columns of BAM are tuple units, and the value at the i -throwandthe j -th column is 1 if and only if there is an edge between u i and u j ; otherwise the value is 0. Given a database, we first identify the tuple units and then transform the tuple units into a graph. Finally, we model the graph as a matrix. For example, we model the graph in Figure 1 as a BAM asshowninTable1( a ), where the italic characters denote the keywords contained in the corresponding unit. For instance, u 4 contains four keywords of a, c, c, d . We will take this graph as a running example throughout this paper.
To measure the relationship between two tuple units, we employ the minimal distance between any two tuple units and construct another matrix, minimal distance matrix ,ab-breviated as MDM . Different from BAM , the value of the i -throwandthe j -th column of MDM is the minimal dis-tance of the two tuple units u i and u j . In order to preserve the paths between two nodes with minimal distance, we in-troduce another matrix, minimal path matrix , abbreviated as MPM .Theentryof &lt;u i ,u j &gt; in MPM preserves the path with minimal distance between u i and u j . For example, we can construct MDM and MPM of the graph in Figure 1 as illustrated in Table 1 ( b ) and Table 1 ( c ) respectively. In MDM ,thevalueofentry &lt;u 4 , u 2 &gt; is 3. This means that the minimal distance from u 4 to u 2 is 3. In MPM ,the from u 4 to u 2 is u 4 -u 3 -u 1 -u 2 . Traditional methods employ TF  X  IDF -based methods in IR literature to score tuple units (or documents). They score the tuple units that directly contain input keywords. How-ever, the tuple units which indirectly contain keywords may also be relevant to the keywords, as different tuple units are interrelated through primary-foreign-key relationships. This section presents how to score a tuple unit w.r.t. an input keyword that is directly contained by the tuple unit, and Section 2.4 describes how to score a tuple unit w.r.t. an input keyword that is indirectly contained by the tuple unit.
We model every tuple unit as a document and take the terms in the tuple units as keywords. Accordingly, the TF  X  IDF -based methods in IR literature can be borrowed to score tuple units [5]. For example, consider the tuple units in Figure 1, we can compute the scores as illustrated in Ta-ble 2 ( d ). Especially, we give the tf , idf and ntl in Table 2 ( a )-( c ) to help users understand.

Although the TF  X  IDF -based scoring method in IR liter-ature can rank the tuple units which directly contain input keywords, they cannot capture the structural compactness between relevant tuple units and will lead to ineffectiveness. Even if a tuple unit indirectly contains an input keyword, this tuple unit may also be relevant to the input keyword through the primary-foreign-key relationships. Most impor-tantly, the structural information between relevant tuple units is at least as important as the textual information, and is even much more crucial in many cases. To address this issue, we propose a novel scoring method to score the tuple units which indirectly contain keywords in Section 2.4.
This section proposes how to score tuple units w.r.t. input keywords that are indirectly contained by the tuple units and extends the score functions. For ease of presentation, we introduce a notion of key tuple unit ,whichcanbeusedto measure the relationship between a keyword and a tuple unit that indirectly contains this keyword. Given a keyword k and a tuple unit u i that indirectly contains k j , the tuple unit ku ( k j ,u i ) , which directly contains k j and has the minimal distance with u i in the corresponding graph, is called a key tuple unit  X  .Thatis, ku ( k j ,u i ) = argmin u r {  X  ( u u r directly contains k j and  X  ( u r , u i ) denotes the distance between u r and u i } .

It is obvious that the smaller distance between two tuple units, the more relevant between them. Based on this obser-vation, given a keyword k j and a tuple unit u i that indirectly contains k j , we first identify the key tuple unit ku ( k u i and k j , which directly contains k j and has the minimal distance with u i among all the tuple units. Then, we score u w.r.t. k j as formalized in Equation 1.

We note that Score IR ( ku ( k j ,u i ) ,k j ) can be computed based on TF*IDF based method as ku ( k j ,u i ) directly contains k  X  ( ku ( k j ,u i ) ,u i ) can be gotten from the minimal distance ma-trix. If u i directly contains k j , we adopt TF*IDF based methods to score u i w.r.t. k j ;otherwiseif u i indirectly con-tains k j , we use Equation 1.

Accordingly, based on the minimal distance matrix and the scores of tuple units which directly contain input key-words, we can efficiently score the tuple units that indirectly contain the keywords. To maintain the scores w.r.t. every tuple unit and every input keyword, we construct a score matrix , where each row is a tuple unit and each column is a keyword. The value at the i -th row and the j -th column of score matrix is denoted by Score IR ( u i ,k j ), which is the score of u i directly or indirectly containing keyword k j directly contains k j , we compute the score based on TF*IDF based methods; otherwise, we compute the score of u i indi-rectly containing k j by using Equation 1.

In order to identify and construct the relevant answers composed of related tuple units, we introduce another ma-trix, key tuple unit matrix , where each row is the tuple unit and each column is a keyword, and the value at the i -th row and the j -th column, is the path with minimal distance from tuple unit u i to the key tuple unit ku ( k j ,u i ) ingly, the path from u i to the corresponding key tuple unit is preserved in key tuple unit matrix, which can be used to reconstruct the answers of keyword queries. Note that, key tuple unit matrix and score matrix can be obtained according to MDM , MPM ,andthescores.

Given a keyword query Q = { k 1 ,k 2 ,  X  X  X  ,k n } and a rela-tional database, we take the sum of the IR scores of u on every k i , i.e., Score IR ( u, k i ), as the total score of a tuple unit u on Q . To answer such a keyword query, we first iden-tify the tuple units with the top -k highest scores and then construct the subtrees rooted at each identified tuple unit and containing the paths from the tuple unit to the corresponding key tuple units , finally take the subtrees as the answers.
To retrieve the most meaningful and relevant answers com-posed of related tuple units with the top -k highest scores, we propose the single-keyword-based structure-aware index, SKSA-Index , which is similar to the traditional inverted in-dex. The entries of SKSA-Index are also the keywords, which are contained in the underlying database. Different from inverted indices which only maintain the tuple units that directly contain the keyword, each entry of SKSA-Index pre-serves the tuple units that directly or indirectly contain the keyword in the form of a triple &lt; Unit, Score, UnitLists &gt; , where the Score is the assigned score of the keyword in the tuple unit Unit ,and UnitLists preserves tuple unit lists from Unit to the corresponding key tuple units , which can be ob-tained from the key tuple unit matrix. Tuple units are sorted by the corresponding scores in descending order. Most im-portantly, SKSA-Index captures the rich structural relation-ships, as each entry preserves the paths from a given unit to the corresponding key tuple unit and also keeps structure-aware scores of tuple units indirectly containing keywords.
Based on the SKSA-Index , we can efficiently answer a query as follows. Consider query Q = { k 1 , k 2 ,  X  X  X  , k retrieve the relevant tuple units w.r.t. each input keyword, and then compute the score of each relevant tuple unit. Fi-nally, we rank the tuple units and return the top -k answers with the highest scores.
We compared our algorithm with the state-of-the-art algo-rithms, Retune [5] and SPARK [7]. We employed the DBLP  X  and IMDB  X  datasets to compare these algorithms. We con-verted the DBLP dataset into four relational tables, pa-per,author,paper-author,paper-reference .Theraw file of the DBLP dataset was about 470MB. IMDB con-tains approximately one million anonymous ratings of 3900 movies made by 6040 users. We selected one hundred key-word queries with different numbers of input keywords to compare the algorithms.

All the experiments were conducted on a computer with an Intel(R) Core(TM) 2@2.0GHz CPU, a 2GB of RAM and a 120G Disk r unning Windows XP, and all the algorithms were implemented in C++.

We first evaluated search efficiency. Figures 2 summarizes the experimental results on the two datasets. We observe that our algorithm achieves much higher search efficiency than SPARK, as we use structure-aware indices to efficiently identify the answers, which can help to identify the answers through our indexed tuples units, and thus our method can significantly improve the search efficiency. Saint is a bit slower than Retune, as Retune only identifies a single tuple unit and need not discover the relationships between dif-ferent tuple units. We will prove that Retune leads to low search effectiveness later.

We then evaluated search quality. The correct results are the answers returned by the c orresponding schema-aware languages such as SQL. Given an input keyword query, we enumerate all possible SQL queries for a set of keywords to generate our baseline query re sults, which are assumed as accurate and complete. Figure 3 illustrates the experimen-tal results obtained. We observe that Saint achieves much higher precision than the alternative methods such as Re-tune and SPARK. For example, on IMDB dataset, Saint achieves nearly 90% precision, which leads to about 20-30 percent over those of Retune and SPARK. Note that Retune may achieve low precision as they cannot integrate multiple tuple units to answer queries.
We have studied the problem of effective keyword search over relational databases. We proposed to identify and in-tegrate multiple relevant tuple units to effectively answer keyword queries. We devised novel structure-aware indices, which incorporate the structural compactness between tuple units and the textual relevancy between input keywords into the indices. We have implemented our method on real data sets, and the experimental results show that our method achieves high performance and outperforms state-of-the-art approaches significantly. The work was supported by the National Natural Science Foundation of China unde r Grant No. 60873065, the Na-tional High Technology Development 863 Program of China under Grant No. 2007AA01Z152 &amp; No. 2009AA011906, and the National Grand Fundamental Research 973 Program of China under Gra nt No. 2006CB303103. [1] S. Agrawal, S. Chaudhuri, and G. Das. Dbxplorer: A [2] G. Bhalotia, A. Hulgeri, C. Nakhe, S. Chakrabarti, [3] H. He, H. Wang, J. Yang, and P. Yu. Blinks: Ranked [4] V. Hristidis and Y. Papakonstantinou. Discover: [5] G. Li, J. Feng, and L. Zhou. Retrieving and [6] G.Li,B.C.Ooi,J.Feng,J.Wang,andL.Zhou.Ease: [7] Y. Luo, X. Lin, W. Wang, and X. Zhou. Spark: Top-k [8] Q. Su and J. Widom. Indexing relational database
