 Processes supported by information systems need to comply with regulations, laws and service level agreements set by both internal and external stakeholders. Failing to comply may be costly, therefore organizations need to continuously check whether processes are executed within a given set of boundaries. Deviations of the observed be-havior from the specified compliant behavior may point to fraud, malpractice, risks, and inefficiencies. Five types of compliance-related activities can be identified [8,23,7,19]: (1) determine compliance requirements that have to be satisfied by the particular pro-cess and system, (2) formalize compliance requirements in a suitable form, (3) imple-ment and configure information systems such that they fulfil compliance requirements, (4) check whether compliance requirements are met, and (5) improve the process and underlying systems based on diagnostic information to improve compliance.

Compliance checking is gaining importance because of the availability of event data on one hand and changing legislations on the other hand. The organizations are not only required to obey the laws and regulations but often required to comply with stan-dards and contractual obligations. In many standards such as clinical guidelines and constraints governing cooperative business such as service level agreements, time is of utmost significance. In processes that are s ubject to such guidelines and agreements, it is often extremely important to meet deadlines, optimize response time, stay compli-ant about durations, adhere to constraints a bout delay between activities and periodic repetition of actions. At the same time, ne w technologies are pro viding opportunities to systematically observe processes at a deta iled level by recording all process relevant events.

There are two basic types of compliance checking: (1) forward compliance checking aims to design and implement processes where compliant behavior is enforced and (2) backward compliance checking aims at detecting and localizing non-compliant behav-ior. This paper focuses on backward co mpliance checking based on event data.
The compliance requirements considered in this paper constrain at which time ac-tivities may, must or must not occur. Comp liance violations regarding time cannot be detected using existing control-flow checking techniques such as [21]; as these tech-niques abstract from a concrete notion of time, both when specifying compliance rules and when checking reality recorded in the event log against specified behavior. There-fore for temporal compliance checking, it is required to express temporal constraints with an explicit notion of time, capture notion of time in the event log and compare the specified time in temporal constraints with time recorded in the event log.
This paper addresses the problem of backward compliance checking for temporal compliance requirements (i.e., compliance requirements restricting process time). We propose a technique for temporal compliance checking that seamlessly integrates with control-flow compliance checking. Most importantly, the technique provides detailed diagnostic information in case of non-co mpliant behavior: it shows for each case which events violated temporal requirements and when the event should have occurred to be compliant. Our temporal compliance c hecking technique leverages a recent data-aware conformance checking technique [13] that allows to check conformance of a log with respect to a data-aware Petri net . We show that every temporal compliance requirement discussed in literature (and many more) can be formalized in a simple data-aware Petri net, by making time a data attribute of the specification. The conformance checker [13] then compares the observed temporal behavior in the event data to the compliant tem-poral behavior specified in the Petri net. In case of deviations, the conformance checker highlights which events occurred out of order, and by how much time an event deviated from the compliant behavior. Moreover, we show how this temporal compliance check-ing can be combined with control-flow compliance checking to check complex compli-ance requirements involving control-flow and temporal aspects. The technique has been implemented as a ProM plug-in and has been applied in a case study using event data and compliance requirements for a real-life business process in the public sector.
The remainder of this paper is organized as follows. We recall conformance checking techniques for control-flow and data-flow in Sect. 2. In Sect. 3 introduces the problem of temporal compliance checking and our proposed solution. Experimental results are presented and discussed in Sect. 4. We discuss related work in Sect. 5 and conclude in Sect. 6. This section recalls basic conformance checking notions for control-flow conformance [1,3] and data-flow conformance [13] on which we build for temporal compliance checking.
 Logs. Conformance checking relates behavior that has happened and was recorded in an event log L to a formal specification S that describes which behavior should have happened . In this context, an event log L is a set of traces . Each trace  X  L  X  L describes a particular case (i.e., a process instance) as a sequence of events  X  L = e 1 e 2 ...e n .An event e has a number of attributes, typically referring to the activity executed or the time of its execution. For instance, we write e. activity = a and e. time = t to refer to the value of the activity and of the time attribute of event e , respectively; as a shorthand, we may write e =( a, t ) . An example of a log trace is  X  L = ( A, 1)( C, 3)( C, 7)( D, 12) stating A happened at time 1 , C happened at 3 , another C happened at 7 and finally D happened at 12 .
 Specified Behaviors. The specification of behavior that should have happened can straints [12] or predicate logic. In e ssence, each specification describes a set S of ad-missible behaviors, again being sequences of events having attributes. Typically, the set S is very large, varying over all admissible attribute value combinations. The set S is the semantic notion of all comp liant traces. For example, a specification could describe the traces S shown in Fig. 1(left). The traces state that A happens at time 1 , B happens at time 4 , C happens any time between 1 . 1 and 7 ,and D always happens 10 time units after C . Note that the ordering of B and C depends on the times of their occurrences.
In this paper, we use Petri nets to specify the admissible behavior S in a compact form. Figure 1(right) shows a Petri net variant, called data-aware Petri net [13], that specifies the above admissible sequences of events including the values of the time attribute . That is, the firing sequences of the Petri net N S is the set S giveninFig.1(left). In N S , transitions have additional annotations that specify attribute values of the event e that is created by the occurrence of a tr ansition. For instance, the guard [ e.time =1] of transition A expresses that the event e created by A has the value 1 of its time attribute. Likewise, an event created by B has value 4 of its time attribute. The guard of C permits any value between 1 . 1 and 7 for attribute time of C . The relation between events of C and D is expressed by the help of variable t C .The time value of the most recent event produced by C is stored in variable t C , expressed by the write statement { t
C = e. time D has to be exactly 10 time units after the value stored in t C . Note that the net in Fig. 1 has no explicit notion of time; the annotations simply constrain numerical values of the event attribute time .
 Aligning Observed to Specified Behaviors. An observed trace in a log may deviate from specified behaviors. For instance, the non-compliant trace  X  L = ( A, 1)( C, 3) ( C, 7)( D, 12) is not specified by N S of Fig. 1. To understand where and how  X  L devi-ates from the behaviors S ,we align  X  L to S , as follows [1,3,13].

Theideaistofindaspecifiedtrace  X  S  X  S that is as similar as possible to  X  L ; the differences between  X  S and  X  L then indicate deviations. We relate  X  L to any trace  X  ties. Intuitively, an event f of the specification S pairs with an event e in the log L if e. activity  X  ( f. activity ) .

Let E L and E S be the universe of all possible log events and of all specification events, respectively. A move of (  X  L and S )isapair ( x, y )  X  ( E L  X  X } )  X  ( E S  X  X } ) \{ ( , ) } .For x  X  X  L and y  X  X  S , we call 1. ( x, ) a move on log , 2. ( ,y ) a move on specification S , 3. ( x, y ) a synchronous move iff x. activity  X  ( y. activity ) and x. attr = y. attr for 4. ( x, y ) a synchronous move with data deviation iff x. activity  X  ( y. activity ) and An alignment of a trace  X  L  X  L to S is a sequence  X  = ( x 1 ,y 1 ) ... ( x n ,y n ) of moves (of  X  L and S ) such that the projection x 1 ...x n to E L is the original trace  X  L y
For example, the trace  X  L = ( A, 1)( C, 3)( C, 7)( D, 12) has among others the fol- X  yield the same specified trace ( A, 1)( C, 2)( B, 4)( D, 12) ;  X  3 yields a different trace ( A, 1)( B, 4)( C, 7)( D, 17) .
 Diagnostic Information from Deviations. All alignments differ in the kind of devi-ations they show. A move on log ( x, ) indicates that trace  X  L hadanevent x that was not supposed to happen according to specification S whereas a move on specifica-tion S ( ,y ) indicates that  X  L was missing an event that was expected according to S . Synchronous moves with data deviations indicate that the observed event had other attribute values than specified. As the alignment preserves the position relative to trace  X  , we can locate the exact position where  X  L had an event too much or missed an event compared to S .

According to  X  1 ,the time attribute of the first C is wrong (it should have been 2 instead of 3 according to the synchronous move with data deviation ), B should have occurred (according to the move on S ), and the second C should not have occurred (move on log). According to  X  2 , none of the C events was correct, but there should have been another C event at time 2 . According to  X  3 , the second C event was correct at time 7 ,thefirst C event at time 3 was wrong, and D should instead have occurred at time 17 (synchronous move with data deviation ).
 Computing Alignments. The conformance checking problem in this setting is to find for a given trace  X  L and specification S a best alignment  X  of  X  L to S s.t. no other align-ment has fewer non-synchronous moves or move s with data deviations. The techniques of [1,3] and [13] find such a best alignment using a cost-based approach: a cost-function  X  assigns each move ( x, y ) acost  X  ( x, y ) s.t. a synchronous move (without data devia-tions) has cost 0 and all other types of moves have cost &gt; 0 . The choice of costs depends on the particular domain and can be set for instance based on how likely a particular deviation is known to happen. By giving freque nt deviations fewer costs than infrequent deviations, the best alignment is the one giving the most probable compliant trace. For example, assuming cost 10 for all non-synchronous moves (knowing control-flow is usually followed), cost 3 for data deviations by C (typically happens as specified) and costs 1 for data deviations by D (typically known to deviate),  X  1 has cost 23 ,  X  2 has cost 40 ,and  X  3 has cost 21 ,making  X  3 the best alignment to the most probable trace.
The A -based search on the space of (all prefixes of) all alignments of  X  L to S described in [1,3] can be used to find a best alignment for  X  L and S (when attributes other than activity are ignored). This approach is extended in [13] to find data-aware alignments ; an ILP solver finds among all synchronous moves values for attribute of S such that the data deviations are minimized. In the following, we apply alignments for temporal compliance checking. This section presents our main contribution, an approach for checking temporal com-pliance on past executions recorded in even t logs. We first recall different dimensions of compliance requirements. After that we present our approach that allows to inte-grate checking for control-flow and temporal compliance requirements together with a generic framework for formalizing various temporal requirements. 3.1 Compliance Requirements Compliance requirements prescribe how inter nal or cross-organizational business pro-cesses have to be designed or executed. They originate from legislations and restrict one or several perspectives of a process (control flow, data flow, process time or orga-nizational aspects), they can restrict each case individually or a group of cases, or pre-scribe properties of process executions or process design [21]. These different aspects of compliance give rise to the compliance rule framework shown in Fig. 2. A complex compliance requirement covering several p erspectives of a process can be decomposed into smaller compliance rules, each cove ring a single aspect along the dimensions of this framework.

For example, a compliance requirement might state:  X  X he treatment with antibiotics must be administered with one dose per day for 3 days in a row. After each cycle of 3 treatments, in case of necessity, the treatment can be extended for other cycles; but there should be delay of at least one week between two subsequent cycles of treatment X .
This requirement can be divided into three different compliance rules: (1) (control flow)  X  X ntibiotics must be administered in cycles of 3 occurrences X , (2) (process time)  X  X etween two subsequent administration of antibi-otics in a cycle, there should be one day delay X , and (3) (process time)  X  X etween two subsequent cycles, there should be at least one week de lay X , each taking only one perspective (control flow or process time) into account.
 The compliance checking technique of [21] is able to check control-flow compliance rules, but does not pro-vide a notion of time and therefore cannot check tempo-ral compliance rules. In the following, we investigate the relation between the control-flow and time perspective, then present a new technique that supports time to check temporal compliance rules, and finally show how to integrate diagnostic information from both perspectives for comprehensive compliance diagnostics. 3.2 Separating Temporal-and Control-Flow Compliance Checking We conducted an extensive literature survey and identified numerous works [11,18,10,24,14,2] discussing temporal compliance rules and their formalization. Typi-cally every compliance requirement restricting the process time implies a control flow compliance rule in addition to a temporal compliance rule. Even if the ordering of ac-tivities is not restricted in the compliance requirement, at least the existence of some activities is specified. In the general case, the control-flow rule constrains more than just the existence of activities, for instance that  X  X ntibiotics must be administered in cycles of 3 occurrences X . This leads to a simple assumption for temporal compliance requirements: a temporal compliance rule constrains the occurrences of events specified in a given control-flow rule (e.g.,  X  X etween two subsequent administration of antibiotics in a cycle, there should be one day delay X ); a  X  X arger X  temporal rule simply implies a larger control-flow rule.

A control-flow rule may have to hold multiple times in a trace [16], based on repeated occurrences of events. For instance, if antibiotics are administered 6 times in total, the control-flow rule given above has to hold twi ce; the associated temporal rule has to hold whenever the control-flow rule occurs. We co llected and categorized available temporal compliance rules (15 temporal compliance rules) in a framework distributed over 7 categories shown in Tab. 1.

Some example rules with their category are given next. The complete collection of compliance rules and their forma lization is described in [22].  X  Repetition.Rule2 :  X  X he delay between execution of two subsequent activities A and  X  Instance Duration.Rule1 :  X  X very occurrence of a control flow rule must be com- X  Validity.Rule1 :  X  X very activity A within all occurrence of a control flow rule must  X  Time Restricted Existence.Rule1 :  X  X very activity A within all occurrences of a con- X  Time Dependent Variability.Rule1 :  X  X ithin all occurrences of a control flow rule, The dependency between control-flow rules and temporal rules raises a challenge for temporal compliance checking: we first have to identify the different occurrences of a control-flow rule, for which then the tem poral rule can be checked. This gives rise to our approach shown in Fig. 3.

We decompose a complex compliance requirement into a control-flow rule and a temporal rule. The event log is first aligned to the control-flow rule using the technique of Sect. 2 to identify control-flow violations in terms of missing or inserted events; this alignment will also distinguish multiple occurrences of the same control-flow rule within one trace. For each alignment, we enri ch the log with info rmation about multiple occurrences of rules and control-flow violations. The enriched log is then used to check temporal compliance using the dat a-aware alignments of Sect. 2.

However, there is a small challenge in decomposing control-flow and temporal com-pliance checking. In case a control-flow violation can be attributed to different occur-rences of a control-flow rule, there exist more than one alignment of a trace to the control-flow rule. Picking the wrong control-flow alignment could introduce false pos-itives on temporal compliance, which we e liminate as follows: we compute for each trace all its control-flow alignments; each alignment leads to an enriched trace variant for which we compute temporal compliance; the trace variant with the best temporal compliance (containing only real violations) is returned and all other variants (contain-ing false positives) are discarded.

Aligning control-flow and temporal checking has an advantage regarding diagnostic information. A severe control-flow violation implies a violation of the temporal compli-ance rule. Checking temporal compliance alone might obscure insights into the nature of the violation. By integrating control-flow and temporal compliance checking, we can present more meaningful diagnostic information to a user. For this, the existing control-flow checking technique has to be extended, as we describe next. 3.3 Extended Control-Flow Compliance Checking A control-flow compliance checking technique based on alignments was presented in [21]. In this technique, a compliance rule is f ormalized as a Petri net that describes all admissible sequences of activities. A collection of over typical 50 control-flow com-pliance rules and their formalization as par ameterized Petri net patterns are available from a comprehensive repository [22]. In this section, we show how to extend the pat-terns of [21] to distinguish multiple occurre nces of the same rule in a trace. Checking control-flow compliance of a log to an extended pattern then allows to enrich the log with information needed for t emporal compliance checking.
 For example, the Petri net pattern of Fig. 4 formalizes the compliance rule  X  X c-tivity A must be executed in groups of k occurrences X  (shown for k =3 ). The core of the rule is formalized in the grey-shaded part between transitions I st and I cmp . The rule becomes active when I st occurs. Then activity A has to occur 3 times before the rule can complete (each time A occurs, one token is taken from todo and put on done ). In between, arbitrary other activities can occur, expressed by transi-tion  X  . The compliance rule may hold multiple times in a trace; this behavior is cap-tured by the cycle involving I st and I cmp . Whenever I st occurs, it puts 3 tokens in the place todo which activates a new instance of the rule  X  X ctivity A occurs in groups of 3 X ; the instance completes with transition I cmp which removes all tokens from done and puts a token on p 1 . The entire Petri net of Fig. 4 thus allows for multiple instances of the compliance rule, each instance is framed by the I st and I cmp transitions; between two instances arbitrary other activities are allowed as expressed by the  X  -transition at-tached to place p 1 . The net has a dedicated place Initial and a place Final ,a Start and an End transition. A compliant behavior takes the net from the initial marking to the final marking (just one token in Final ) showing arbitrary many instances of the compliance rule. Every Petri net of [21] formalizing a control-flow rule can be extended in this way to distinguish multiple instances of the sam e rule in a trace; see [22] for the complete pattern repository.

The alignments of Sect. 2 can be used to ch eck compliance of a trace to the compli-ance rule  X  X ctivity A must be executed in groups of k occurrences X . Assume the trace  X  = ( B, 1)( A, 2)( A, 30)( A, 54)( A, 100)( C, 123)( A, 162)( D, 173) to be given. For control-flow compliance checking, we ignore attributes other than activity and thus align the trace  X  = BAAAACAD to the net of Fig. 4. When aligning  X  , A maps to A and  X  maps to all other events B,C,D which are not relevant for the rule. Addition-ally, we assume transitions Start , End , I st and I cmp to be silent so that moves on the specification (without corresponding event in  X  )havecost 0 . The approach of Sect. 2 of the rule with 3 occurrences of A and 1 instance of the rule with 2 occurrences of A . The alignment also shows a missing event A in the second instance by the move on specification ( ,A ) . Note that  X  has 6 more best alignments to the net of Fig. 4 vary-ing in where the move ( ,A ) is placed. The subsequent steps (shown for  X  1 ) would have to be executed for each of these alignments.

To align temporal compliance checking with control-flow compliance checking, we enrich the original trace  X  with information about rule instances and control-flow devi-ations, as follows. (1) Translate each move of the alignment  X  into a log event, where each event originating in a non-synchronous move is marked by a special  X  X ove X  at-tribute. (2) Enrich each event of a synchr onous move with all attributes of the origi-nal event in trace  X  . (3) Provide each event of a move on specification with missing attributes, in particular an event without a time attribute gets the time value of the di-rectly preceding event (except Start and I st which get the time value of the succeeding event).

For example, using alignment  X  1 we enrich trace  X  given above to the traces  X   X , 1 = 123 , missing )( A, 162)( I cmp , 162)( D, 173)( End , 173) . This traces now contains enough information to check temporal compliance. 3.4 Formalizing and Checking Temporal Compliance Rules This section introduces a new technique to check temporal compliance. We express temporal compliance rules using the data-aware Petri nets of Sect. 2, which allow to describe and constrain time in processes. The corresponding alignments of a data-aware Petri net to a log [13] will then allow to check for temporal compliance and provide detailed diagnostic information. For the alignment, we use the enriched log provided by the technique of Sect. 3.3. This enriched log distinguishes all different instances of the control-flow rule that underlies the tempor al rule to be checked. In addition, it allows to integrate diagnostic information for violations in the control-flow and the temporal perspective.
 Formalizing Temporal Constraints. We explain the formalization of temporal compli-ance rules by the first temporal rule of our running example. The concrete temporal rule reads  X  X etween two subsequent administration of antibiotics in a cycle, there should be one day delay, X  which we abstract to  X  X he delay between two subsequent executions of activity A in an instance of a control-flow rule, must be within [  X ,  X  ] time units. X  The data-aware Petri net of Fig. 5(right) formalizes this rule.

The Petri net has a very simple control-flow structure that just distinguishes begin and end of a trace (places Initial and Final ), and whether the trace is within an instance of a control-flow rule (after I st occurred) or outside a control-flow rule (after I cmp occurred). Transitions labeled  X  allow occurrences of all other activities not constrained by the temporal rule. The actual temporal aspect is described by the variable t A and the data annotations at transition A and I st . Annotation { t A = e.time } at A ensures that t A holds the timestamp of the most recent occurrence of activity A .Themost important annotation is the guard [ delay ( A,  X ,  X  )] defined by delay ( A,  X ,  X  )  X  t A  X  [ t
A +  X , t A +  X  ] of A hastobeintheinterval [ t A +  X , t A +  X  ] ,where t A is the timestamp of the most recent occurrence of A . As the rule only ranges over occurrences of A within the same instance of the control-flow rule, we have to take special care for the first occurrence of A in an instance. The annotation at I st initializes t A = undef so that the guard of A also holds for the first A . By setting parameters A = antibiotic administration and  X  =  X  =24 hours, the pattern of Fig. 5 formalizes the given temporal rule.
 Checking Tempora l Compliance. We check compliance of a trace to the formalized rule on the enriched log trace obtained in Sect. 3.3, for instance trace  X   X , 1 . The data-aware alignment technique explained in Sect. 2 compares the time stamp of events in  X   X , 1 with admissible time stamps defined in the guards of the data-aware Petri net and will give a
As is shown in the alignment  X  t 1 the second A in the first instance occurred 28 time units after the preceding A , which violates the temporal rule. The data-aware alignment in addition returns the time at which the e vent should have occurred at the bottom row of the alignment. In the same way, two deviations in the second iteration are highlighted. However, the  X  X orrect X  timestamps 124 and 148 suggested by the alignment have to be inspected carefully as in th e second instance the second A was missing in the original log (a control-flow violation indicated by the attribute value missing ). Recall from Sect. 3.2 that we may have to check several e nriched variants of the same original trace (differing in control-flow violations); after checking all variants, the one with the least temporal violations is returned and all other are discarded. A Generic Temporal Pattern. As said in Sect. 3.2, we identified 15 generic temporal compliance rules [22]. Each rule can be form alized in a data-aware Petri net similar to Fig. 5(right). The generic pattern is shown in Fig. 5(left). It permits to constrain occurrences of n generic activities X 1 ,...,X n ,aswellasthe Start and End of a trace and start and end of each instance (by I st and I cmp ). Each formalization of a compliance rule assigns a guard to one or more transitions of the pattern, depending on the particular temporal property. We show some more formalizations next.

The rule  X  X he delay between execution of two subsequent instances of a control-flow rule, must be within [  X ,  X  ] time units. X  (which expresses the second temporal rule of our running example of Sect. 3.1.) The formalization of this rule instantiates Fig. 5(left) with t is only allowed to occur between t I cmp +  X  and t I cmp +  X  where t I cmp is the last time I cmp occurred (if there was a last occurren ce). Checking temporal compliance of  X   X , 1 of Sect. 3.3 to this rule for  X  =7 days and  X  =  X  (and mapping all activities to  X  ), we obtain the following data-aware alignment:  X  The alignment  X  t 3 highlights a deviation for the start of the second instance of  X  3 admin-istrations of antibiotics . X  According to the log, the second administration started just 46 hours after the preceding treatment where t he rule requires a delay of at least 1 week (= 168 hours); the correct time is shown in the bottom row of the alignment.

Also compliance rules requiring the absen ce of an activity in a particular interval can be formalized:  X  X o activity A within all instances of a control flow pattern may be executed within [  X ,  X  ] time units since time t . X  For this temporal rule, the generic temporal pattern of Fig. 5, has n =1 transition. The guard for this temporal rule is: negation activity execution ( X 1 ,t, X , X  )  X  t X be a fixed time, or the time of some other activity (e.g., include X 2 in the pattern and define t = t X 2 ).

Many temporal compliance requirement s found in literature combine several con-straints on the relation between the start and completion of two different activities; for in-time units after activity A starts, and activity B must complete within [  X  cmp , X  cmp ] time units before activity A completes. X  For this temporal rule, the generic temporal pattern of Fig. 5, has n =4 transitions labeled A st , A cmp , B st and B cmp express-ing the start and completion of A and B , respectively. The pattern uses the generic guard after ( X,Y, X , X  )  X  t Y  X  [ t X +  X , t X +  X  ]  X  t X = undef twice: once as at transition A cmp . Other combinations of this temporal constraint can be expressed in the same way varying the parameters of the guards.

Similarly, all other identified temporal compliance constraints identified in literature can be formalized by instantiating the generic temporal pattern of Fig. 5; see [22] for details. Each formalization is then eligible for temporal compliance checking using data-aware alignments. Our temporal compliance checking technique is not limited to predefined control-flow rules and temporal rules, but is extendible. In Sect. 4 we show how we can adapt a generic temporal compliance rule for compound and complex tem-poral restrictions. Our temporal compliance checking technique is implemented in Process Mining Toolkit ProM, available from www.promtools.org , and was applied in a case study on real-life logs. We briefly discuss the implementation in ProM and then provide details on the case study.
 Implementation in ProM. The temporal compliance check er is available in the pack-age Compliance that provides 2 user-friendly plugins for temporal compliance checking. The first plugin provides control-flow compliance checking as described in Sect. 3.3: it takes as input a log and returns compliance diagnostics in form of an alignment, the control-flow rule to check compliance for is picked by the user from a rule repository[22] using a wizard. The second plugin takes the control-flow alignment, produces an en-riched log and then checks tem poral compliance of the log to a temporal rule that can be specified by the user through a wizard. The r esulting alignment then provides diagnos-tic information by showing control-flow compliance violations and temporal violations projected into the events of the original log.
 Case Study. We applied this implementation of the compliance checker in a case study for checking compliance of the building permit processes of five Dutch municipalities.
The municipalities may carry out the building permit process in different ways, as long as it is compliant to a number of regulations issued by the Dutch legislative. To test the feasibility of our temporal compliance checking technique, we selected a rather involved temporal compliance requirement that combines static and dynamic temporal aspects.

The compliance requirement was given informally:  X  X very application must be pro-cessed within at most 8 weeks from the date of a submitted request. If during the pro-cessing of the request, the organization re quires additional information from the appli-cant, the time interval between asking for additional information and providing the in-formation by the client must be added to the 8 weeks. X  This requirement is decomposed into two control-flow compliance rules and one temporal compliance rule: Control-Flow Compliance Rule 1:  X  X very time activity A is executed, it must be fol-lowed eventually by activity D . X  Control-Flow Compliance Rule 2:  X  X he sequence of activities B and C may only be executed after the execution of activity A and before the execution of activity D . X  Temporal Compliance Rule:  X  X he delay between execution of two subsequent activi-ties A and D in all instances of a control-flow pattern, must be [  X ,  X  +  X  2 ] time units since time t ,where  X  2 is the time between executing B and C . X  We formalized the two control-flow compliance rules by instantiating a corresponding Petri net pattern from the compliance rule repository in [22]. Their generic parameters were mapped as follows: A = submit request , B = request additional information , C = receive additional information and D = publish result . The formalization of the temporal compliance rule was derived by instantiating the generic temporal pattern of Fig. 5(left) as follows. The temporal rule requires 4 activities A , B , C ,and D and a variation of the guard delay2 introduced earlier. The guard delay3 ( A, B, C, D,  X ,  X  )  X  t  X  =0 and  X  = 8 weeks . As activities B and C are optional, we have to provide valid time stamps in variables t B and t C in each iteration. Therefore, the instance start transition I st of the temporal pattern (Fig. 5(left)) initializes both variables to 0 , i.e., { t
B =0 ,t C =0
In order to check compliance of the building permit process to these requirements, we obtained five event logs, each coming from a different municipality. Each log was extracted from the municipality X  X  case handling system and contained all activities per-formed for a case together with time stamps and resource information. In total we ob-tained 1408 cases as shown in Table 2 together containing 35352 events. Cases had 37 events in average and 97 events at most, dis tributed over 178 different event classes.
We first checked for compliance violations of the control-flow rules, followed by temporal compliance checking. In our analysis of the control-flow violations, we found 4 real violations and 40 false positives out of total number of 1408 cases in all munici-palities. Most of the false positives occurred due to inaccurate time stamps and mistakes in data entries by a human user. The remaining real violations were mostly caused by the publication of the result before the municipality processed the additional informa-tion provided by the applicants. In general, the control-flow violations have not been severe because the process under analy sis is quite standardized in all 5 municipalities. However the temporal violations in all municipalities seem to be significant. Table 2 shows the result of temporal compliance checking in different municipalities.
Based on the diagnostic information we got from the temporal compliance check-ing, we investigated the cause of the high number of temporal violations. We found that in compliant cases requests for additional information were issued no later than 2 months after receiving the application. In all violating cases, requests for additional in-formation were made only later than 2 months after receiving the application, i.e., when compliance was violated already. This suggests that the process primarily needs to be improved in the initial phase when employ ees gather and assess information about a particular application.

Another influential factor in increasing the violations, is the number of handovers among employees working on a case. The diagram of Fig. 6 shows the distribution of cases and the percentage of violating cases over the number of resource handovers happening in a case, for M1 . The red squares indicate for a particular value x on the x -axis how many cases of M1 had x handovers of work; the blue diamond at x indicate the percentage of cases with x handovers of work that had a compliance violation. The share of violations increases as handovers increase. This observation suggests that less compliance violations occur when an employee handles several subsequent activities of a case. Though, further analysis on organizational structure and division of work in M1 is required. A process oriented division of work could decrease the number of handovers. In addition, a job rotation programme could enrich the skill set of employees to be able to execute more activities with respect to one case, hence decreasing the number of handovers and improve compliance.

Applying the technique presented in this paper, we were able to check compliance of all the traces in the event logs rather than being limited to sample based compliance checking. The technique is fast and works on large event logs because we can focus on events relevant to a specific compliance rule and abstract from all other events. The remaining effort for a human user is in formalizing the compliance requirements and analyzing results. The effort in formalizing requirements was kept low in our case study. We could pick available control-flow compliance patterns from an existing repository. A wizard helped in selecting the right pattern. The main effort was in expressing the tem-poral compliance requirement as the guard delay3 ( A, B, C, D,  X ,  X  ) presented earlier; once the guard was identified, the constraint could quickly be formalized by instantiat-ing the generic pattern through a wizard. Note that this formalization need to be done once. Checking could then be continue d for all cases automatically.

The technique could identify, locate, and determine the extent of deviations. These diagnostic information can be used by the business analyst to analyze the cause of the deviations. Existing work in temporal compliance checking primarily focuses on verification at design time or at run time.

It is possible to derive temporal properties of acyclic process models by annotating tasks with intervals of execution and waiting times; execution times and waiting times of the entire process can then be derived by interval computations and compared against predefined constraints of total execution tim es [5]. In addition, the time-critical paths of a process model can be computed [20]. In a similar fashion, the approach in [15] for-mulates temporal constraints in terms of deadlines for completing an activity (relative to another activity). Reasoning on time intervals is used to verify whether a constraint is violated.

For verifying that a process with loops satisfies a general time-related constraint, typ-ically temporal model checking techniques are applied. The properties of interest are metric temporal constraints, e.g., deadline on execution of activities in a business pro-cess. Metric temporal logic (MTL), a temporal logic with metric temporal constraints, can express typical compliance requirements as presented in this paper. Unfortunately, the model checking problem for MTL is undecidable over models with infinite traces [9]. By introducing so called observers on atomic propositions, the prob-lem whether a process model, given as a timed transition system (TTS), satisfies an MTL formula becomes decidable by a reduction to LTL model checking [2]. This approach allows to check te mporal compliance of a real-time extension of Dwyer X  X  specification patterns [4]. A similar approach is followed in [6] for checking whether an extended CCSL (Clock Constraint Specification Language) specification holds in a timed Petri net; CCSL is less expressive than the constraints that can be expressed and checked with our technique.

An alternative approach to describe temporal constraints is timed Declare [24] in which LTL-like constraints are extended with the notion of time. By a translation to timed automata, such constraints can be monitored at runtime to evaluate whether a process instance might or will violate a temporal constraint. A similar approach is pro-posed in [17].

In comparison, the technique presented in t his paper focuses on backwards check-ing of temporal constraints in execution logs. The generic Petri net pattern proposed in Sect. 3.4 is capable to express all temporal constraints that we encountered in the works discussed above, and other temporal constraints such as cyclic temporal constraints not discussed elsewhere; see [22] for a detailed discussion. Our technique detects all tem-poral violations in a trace, not just the first t emporal violation encountered as it happens in model checking approaches. In case of violations also the compliant behavior (when a non-compliant event should have happened) is returned as diagnostic information. In this paper, we provided an approach for t emporal compliance ch ecking of behavior recorded in execution logs. We developed a generic technique for formalizing all kinds of temporal compliance constraints, including all temporal compliance constraints doc-umented in literature. In addition, we provide a general temporal compliance checking technique based on alignments. Our technique separates control-flow and temporal com-pliance checking to the possible extent, and provides integrated diagnostic information about both control-flow violations and temporal compliance violations. In particular, our technique is capable of finding all violations in a trace and highlights what the most likely compliant behavior should have been.

We provide a repository of compliance rules and an implementation of our compli-ance checker in the Compliance package of ProM. The softw are has been tested in a case study involving real-life logs from five Dutch municipalities. The results are en-couraging: we were able to uncover various violations and no performance issues were encountered.

Future research aims at making the approach more user friendly. Eliciting and for-malizing compliance rules, and mapping compliance diagnostics back to the original data is still a challenging step. Hence, higher-level compliance languages and more intuitive diagnostics are needed for end-users.
 Acknowledgements. We thank Massimiliano de Leoni, Joos C.A.M.Buijs for their substantial support in writing this paper.

