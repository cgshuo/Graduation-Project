 Cho-Jui Hsieh b92085@csie.ntu.edu.tw Kai-Wei Chang b92084@csie.ntu.edu.tw Chih-Jen Lin cjlin@csie.ntu.edu.tw S. Sathiya Keerthi selvarak@yahoo-inc.com Yahoo! Research, Santa Clara, USA S. Sundararajan ssrajan@yahoo-inc.com Yahoo! Labs, Bangalore, India Support vector machines (SVM) (Boser et al., 1992) are useful for data classification. Given a set of instance-label pairs ( x i ,y i ) ,i = 1 ,...,l, x i  X  R n , y { X  1 , +1 } , SVM requires the solution of the following unconstrained optimization problem: where  X  ( w ; x i ,y i ) is a loss function, and C  X  0 is a penalty parameter. Two common loss functions are: max(1  X  y i w T x i , 0) and max(1  X  y i w T x i , 0) 2 . (2) The former is called L1-SVM, while the latter is L2-SVM. In some applications, an SVM problem appears with a bias term b . One often deal with this term by appending each instance with an additional dimension: Problem (1) is often referred to as the primal form of SVM. One may instead solve its dual problem: where  X  Q = Q + D , D is a diagonal matrix, and Q ij = y y j x T i x j . For L1-SVM, U = C and D ii = 0 ,  X  i . For L2-SVM, U =  X  and D ii = 1 / (2 C ) ,  X  i .
 An SVM usually maps training vectors into a high-dimensional space via a nonlinear function  X  ( x ). Due to the high dimensionality of the vector variable w , one solves the dual problem (4) by the kernel trick such a problem as a nonlinear SVM. In some applica-tions, data appear in a rich dimensional feature space, the performances are similar with/without nonlinear mapping. If data are not mapped, we can often train much larger data sets. We indicate such cases as linear SVM; these are often encountered in applications such as document classification. In this paper, we aim at solving very large linear SVM problems.
 Recently, many methods have been proposed for lin-ear SVM in large-scale scenarios. For L1-SVM, Zhang (2004), Shalev-Shwartz et al. (2007), Bottou (2007) propose various stochastic gradient descent methods. Collins et al. (2008) apply an exponentiated gradi-ent method. SVM perf (Joachims, 2006) uses a cutting plane technique. Smola et al. (2008) apply bundle methods, and view SVM perf as a special case. For L2-SVM, Keerthi and DeCoste (2005) propose mod-ified Newton methods. A trust region Newton method ( TRON ) (Lin et al., 2008) is proposed for logistic re-gression and L2-SVM. These algorithms focus on dif-ferent aspects of the training speed. Some aim at quickly obtaining a usable model, but some achieve fast final convergence of solving the optimization prob-lem in (1) or (4). Moreover, among these methods, Joachims (2006), Smola et al. (2008) and Collins et al. (2008) solve SVM via the dual (4). Others consider the primal form (1). The decision of using primal or dual is of course related to the algorithm design.
 Very recently, Chang et al. (2007) propose using co-ordinate descent methods for solving primal L2-SVM. Experiments show that their approach more quickly obtains a useful model than some of the above meth-ods. Coordinate descent, a popular optimization tech-nique, updates one variable at a time by minimizing a single-variable sub-problem. If one can efficiently solve this sub-problem, then it can be a competitive opti-mization method. Due to the non-differentiability of the primal L1-SVM, Chang et al X  X  work is restricted to L2-SVM. Moreover, as primal L2-SVM is differentiable but not twice differentiable, certain considerations are needed in solving the single-variable sub-problem. While the dual form (4) involves bound constraints 0  X   X  i  X  U , its objective function is twice differentiable for both L1-and L2-SVM. In this paper, we investi-gate coordinate descent methods for the dual problem (4). We prove that an -optimal solution is obtained in O (log(1 / )) iterations. We propose an implemen-tation using a random order of sub-problems at each iteration, which leads to very fast training. Experi-ments indicate that our method is more efficient than the primal coordinate descent method. As Chang et al. (2007) solve the primal, they require the easy access of a feature X  X  corresponding data values. However, in practice one often has an easier access of values per in-stance. Solving the dual takes this advantage, so our implementation is simpler than Chang et al. (2007). Early SVM papers (Mangasarian &amp; Musicant, 1999; Friess et al., 1998) have discussed coordinate descent methods for the SVM dual form. However, they do not focus on large data using the linear kernel. Crammer and Singer (2003) proposed an online setting for multi-class SVM without considering large sparse data. Re-cently, Bordes et al. (2007) applied a coordinate de-scent method to multi-class SVM, but they focus on nonlinear kernels. In this paper, we point out that dual coordinate descent methods make crucial advan-tage of the linear kernel and outperform other solvers when the numbers of data and features are both large. Coordinate descent methods for (4) are related to the popular decomposition methods for training nonlinear SVM. In this paper, we show their key differences and explain why earlier studies on decomposition meth-ods failed to modify their algorithms in an efficient way like ours for large-scale linear SVM. We also dis-cuss the connection to other linear SVM works such as (Crammer &amp; Singer, 2003; Collins et al., 2008; Shalev-Shwartz et al., 2007).
 This paper is organized as follows. In Section 2, we de-scribe our proposed algorithm. Implementation issues are investigated in Section 3. Section 4 discusses the connection to other methods. In Section 5, we compare our method with state of the art implementations for large linear SVM. Results show that the new method is more efficient. Proofs can be found at http://www. csie.ntu.edu.tw/ ~ cjlin/papers/cddual.pdf . In this section, we describe our coordinate descent method for L1-and L2-SVM. The optimization pro-cess starts from an initial point  X  0  X  R l and generates a sequence of vectors {  X  k }  X  k =0 . We refer to the process from  X  k to  X  k +1 as an outer iteration. In each outer iteration we have l inner iterations, so that sequen-tially  X  1 , X  2 ,..., X  l are updated. Each outer iteration thus generates vectors  X  k,i  X  R l , i = 1 ,...,l + 1, such For updating  X  k,i to  X  k,i +1 , we solve the following one-variable sub-problem: min where e i = [0 ,..., 0 , 1 , 0 ,..., 0] T . The objective func-tion of (5) is a simple quadratic function of d : f (  X  k,i + d e i ) = where  X  i f is the i th component of the gradient  X  f . One can easily see that (5) has an optimum at d = 0 (i.e., no need to update  X  i ) if and only if where  X  P f (  X  ) means the projected gradient  X  P i f (  X  ) = If (7) holds, we move to the index i + 1 without updat-ing  X  k,i i . Otherwise, we must find the optimal solution of (5). If  X  Q ii &gt; 0, easily the solution is: Algorithm 1 A dual coordinate descent method for Linear SVM  X  Given  X  and the corresponding w = P i y i  X  i x i .  X  While  X  is not optimal We thus need to calculate  X  Q ii and  X  i f (  X  k,i ). First,  X  Q ii = x T i x i + D ii can be precomputed and stored in the memory. Second, to evaluate  X  i f (  X  k,i ), we use  X  Q may be too large to be stored, so one calculates  X  Q  X  X  i th row when doing (10). If  X  n is the average number of nonzero elements per instance, and O (  X  n ) is needed for each kernel evaluation, then calculating the i th row of the kernel matrix takes O ( l  X  n ). Such operations are expensive. However, for a linear SVM, we can define so (10) becomes To evaluate (12), the main cost is O (  X  n ) for calculating w
T x i . This is much smaller than O ( l  X  n ). To apply (12), w must be maintained throughout the coordinate descent procedure. Calculating w by (11) takes O ( l  X  n ) operations, which are too expensive. Fortunately, if  X   X  i is the current value and  X  i is the value after the updating, we can maintain w by The number of operations is only O (  X  n ). To have the first w , one can use  X  0 = 0 so w = 0 . In the end, we obtain the optimal w of the primal problem (1) as the primal-dual relationship implies (11).
 If  X 
Q ii = 0, we have D ii = 0, Q ii = x T i x i = 0, and hence x i = 0 . This occurs only in L1-SVM without the bias term by (3). From (12), if x i = 0 , then  X  f (  X  k,i ) =  X  1 . As U = C &lt;  X  for L1-SVM, the solution of (5) makes the new  X  k,i +1 i = U . We can easily include this case in (9) by setting 1 /  X  Q ii =  X  . Briefly, our algorithm uses (12) to compute  X  i f (  X  k,i checks the optimality of the sub-problem (5) by (7), updates  X  i by (9), and then maintains w by (13). A description is in Algorithm 1. The cost per iteration (i.e., from  X  k to  X  k +1 ) is O ( l  X  n ). The main memory requirement is on storing x 1 ,..., x l . For the conver-gence, we prove the following theorem using techniques in (Luo &amp; Tseng, 1992): Theorem 1 For L1-SVM and L2-SVM, {  X  k,i } gen-erated by Algorithm 1 globally converges to an optimal solution  X   X  . The convergence rate is at least linear: there are 0 &lt;  X  &lt; 1 and an iteration k 0 such that f (  X  k +1 )  X  f (  X   X  )  X   X  ( f (  X  k )  X  f (  X   X  )) ,  X  k  X  k The global convergence result is quite remarkable. Usually for a convex but not strictly convex problem (e.g., L1-SVM), one can only obtain that any limit point is optimal. We define an -accurate solution  X  if f (  X  )  X  f (  X   X  ) + . By (14), our algorithm obtains an -accurate solution in O (log(1 / )) iterations. 3.1. Random Permutation of Sub-problems In Algorithm 1, the coordinate descent algorithm solves the one-variable sub-problems in the order of  X  ,..., X  l . Past results such as (Chang et al., 2007) show that solving sub-problems in an arbitrary order may give faster convergence. This inspires us to ran-domly permute the sub-problems at each outer itera-tion. Formally, at the k th outer iteration, we permute { 1 ,...,l } to {  X  (1) ,..., X  ( l ) } , and solve sub-problems gorithm 1, the algorithm generates a sequence {  X  k,i } The update from  X  k,i to  X  k,i +1 is by  X  t =  X  We prove that Theorem 1 is still valid. Hence, the new setting obtains an -accurate solution in O (log(1 / )) it-erations. A simple experiment reveals that this setting of permuting sub-problems is much faster than Algo-rithm 1. The improvement is also bigger than that observed in (Chang et al., 2007) for primal coordinate descent methods.
 Algorithm 2 Coordinate descent algorithm with ran-domly selecting one instance at a time  X  Given  X  and the corresponding w = P i y i  X  i x i .  X  While  X  is not optimal 3.2. Shrinking Eq. (4) contains constraints 0  X   X  i  X  U . If an  X  i is 0 or U for many iterations, it may remain the same. To speed up decomposition methods for non-linear SVM (discussed in Section 4.1), the shrinking technique (Joachims, 1998) reduces the size of the op-timization problem without considering some bounded variables. Below we show it is much easier to apply this technique to linear SVM than the nonlinear case. If A is the subset after removing some elements and  X  A = { 1 ,...,l }\ A , then the new problem is subject to 0  X   X  i  X  U,i  X  A, (15) where  X  Q AA ,  X  Q A  X  A are sub-matrices of  X  Q , and  X  considered as a constant vector. Solving this smaller problem consumes less time and memory. Once (15) is solved, we must check if the vector  X  is optimal for (4). This check needs the whole gradient  X  f (  X  ). Since already have  X  i f (  X  ). However, for all i /  X  A , we must calculate the corresponding rows of  X  Q . This step, re-ferred to as the reconstruction of gradients in training nonlinear SVM, is very time consuming. It may cost up to O ( l 2  X  n ) if each kernel evaluation is O (  X  n ). For linear SVM, in solving the smaller problem (15), we still have the vector though only the first part P i  X  A y i  X  i x i is updated. Therefore, using (12),  X  f (  X  ) is easily available. Below we demonstrate a shrinking implementation so that re-constructing the whole  X  f (  X  ) is never needed. Our method is related to what LIBSVM (Chang &amp; Lin, 2001) uses. From the optimality condition of bound-constrained problems,  X  is optimal for (4) if and only if  X  P f (  X  ) = 0 , where  X  P f (  X  ) is the projected gradient defined in (8). We then prove the following result: Theorem 2 Let  X   X  be the convergent point of {  X  k,i } . 1. If  X   X  i = 0 and  X  i f (  X   X  ) &gt; 0 , then  X  k i such that 2. If  X   X  i = U and  X  i f (  X   X  ) &lt; 0 , then  X  k i such that 3. lim During the optimization procedure,  X  P f (  X  k ) 6 = 0 , so in general max j  X  P j f (  X  k ) &gt; 0 and min j  X  P j f (  X  These two values measure how the current solution vi-olates the optimality condition. In our iterative proce-dure, what we have are  X  i f (  X  k,i ) , i = 1 ,...,l . Hence, at the ( k  X  1)st iteration, we obtain M Then at each inner step of the k th iteration, before updating  X  k,i i to  X  k,i +1 i , this element is shrunken if one of the following two conditions holds: where In (16),  X  M k  X  1 must be strictly positive, so we set it be  X  if M k  X  1 = 0. From Theorem 2, elements satisfying the  X  X f condition X  of properties 1 and 2 meet (16) after certain iterations, and are then correctly removed for optimization. To have a more aggressive shrinking, one may multiply both  X  M k  X  1 and  X  m k  X  1 in (16) by a threshold smaller than one.
 Property 3 of Theorem 2 indicates that with a toler-ance , is satisfied after a finite number of iterations. Hence (17) is a valid stopping condition. We also use it for smaller problems (15). If at the k th iteration, (17) for (15) is reached, we enlarge A to { 1 ,...,l } , set  X  M k =  X  ,  X  m k =  X  X  X  (so no shrinking at the ( k + 1)st iteration), and continue regular iterations. Thus, we do shrinking without reconstructing gradients. 3.3. An Online Setting In some applications, the number of instances is huge, so going over all  X  1 ,..., X  l causes an expensive outer iteration. Instead, one can randomly choose an index i k at a time, and update only  X  i k at the k th outer iteration. A description is in Algorithm 2. The setting is related to (Crammer &amp; Singer, 2003; Collins et al., 2008). See also the discussion in Section 4.2. Update  X  i O (1) O ( l  X  n ) O (1) O (  X  n )
Maintain  X  f (  X  ) O ( l  X  n ) NA O ( l  X  n ) NA 4.1. Decomposition Methods for Nonlinear Decomposition methods are one of the most popular approaches for training nonlinear SVM. As the kernel matrix is dense and cannot be stored in the computer memory, decomposition methods solve a sub-problem of few variables at each iteration. Only a small num-ber of corresponding kernel columns are needed, so the memory problem is resolved. If the number of vari-ables is restricted to one, a decomposition method is like the online coordinate descent in Section 3.3, but it differs in the way it selects variables for updating. It has been shown (Keerthi &amp; DeCoste, 2005) that, for linear SVM decomposition methods are inefficient. On the other hand, here we are pointing out that dual coordinate descent is efficient for linear SVM. There-fore, it is important to discuss the relationship between decomposition methods and our method.
 In early decomposition methods that were first pro-posed (Osuna et al., 1997; Platt, 1998), variables min-imized at an iteration are selected by certain heuristics. However, subsequent developments (Joachims, 1998; Chang &amp; Lin, 2001; Keerthi et al., 2001) all use gra-dient information to conduct the selection. The main reason is that maintaining the whole gradient does not introduce extra cost. Here we explain the detail by as-suming that one variable of  X  is chosen and updated at a time 1 . To set-up and solve the sub-problem (6), one uses (10) to calculate  X  i f (  X  ). If O (  X  n ) effort is needed for each kernel evaluation, obtaining the i th row of maintains the whole gradient, then  X  i f (  X  ) is directly available. After updating  X  k,i i to  X  k,i +1 i , we obtain i th column (same as the i th row due to the symmetry of  X 
Q ), and calculate the new whole gradient: for  X  Q : ,i and O ( l ) for (18). Therefore, maintaining the whole gradient does not cost more. As using the whole gradient implies fewer iterations (i.e., faster conver-gence due to the ability to choose for updating the vari-able that violates optimality most), one should take this advantage. However, the situation for linear SVM is very different. With the different way (12) to calcu-we still maintain the whole gradient, evaluating (12) l times takes O ( l  X  n ) effort. We gather this comparison of different situations in Table 1. Clearly, for nonlinear SVM, one should use decomposition methods by main-taining the whole gradient. However, for linear SVM, if l is large, the cost per iteration without maintaining gradients is much smaller than that with. Hence, the coordinate descent method can be faster than the de-composition method by using many cheap iterations. An earlier attempt to speed up decomposition methods for linear SVM is (Kao et al., 2004). However, it failed to derive our method here because it does not give up maintaining gradients. 4.2. Existing Linear SVM Methods We discussed in Section 1 and other places the dif-ference between our method and a primal coordinate descent method (Chang et al., 2007). Below we de-scribe the relations with other linear SVM methods. We mentioned in Section 3.3 that our Algorithm 2 is related to the online mode in (Collins et al., 2008). They aim at solving multi-class and structured prob-lems. At each iteration an instance is used; then a sub-problem of several variables is solved. They ap-proximately minimize the sub-problem, but for two-class case, one can exactly solve it by (9). For the batch setting, our approach is different from theirs. The algorithm for multi-class problems in (Crammer &amp; Singer, 2003) is also similar to our online setting. For the two-class case, it solves (1) with the loss function max(  X  y i w T x i , 0), which is different from (2). They do not study data with a large number of features. Next, we discuss the connection to stochastic gradient descent (Shalev-Shwartz et al., 2007; Bottou, 2007). The most important step of this method is the follow-ing update of w : where  X  w ( y i , x i ) is the sub-gradient of the approxi-mate objective function: and  X  is the learning rate (or the step size). While our method is dual-based, throughout the iterations we maintain w by (13). Both (13) and (19) use one single instance x i , but they take different directions y i x i  X  w ( y i , x i ). The selection of the learning rate  X  may be the subtlest thing in stochastic gradient descent, but for our method this is never a concern. The step size (  X  i  X   X   X  i ) in (13) is governed by solving a sub-problem from the dual. In this section, we analyze the performance of our dual coordinate descent algorithm for L1-and L2-SVM. We compare our implementation with state of the art lin-ear SVM solvers. We also investigate how the shrink-ing technique improves our algorithm.
 Table 2 lists the statistics of data sets. Four of them ( a9a , real-sim , news20 , rcv1 ) are at http://www.csie. ntu.edu.tw/ ~ cjlin/libsvmtools/datasets . The set astro-physic is available upon request from Thorsten Joachims. Except a9a , all others are from document classification. Past results show that lin-ear SVM performs as well as kernelized ones for such data. To estimate the testing accuracy, we use a strat-ified selection to split each set to 4 / 5 training and 1 / 5 testing. We briefly describe each set below. Details can be found in (Joachims, 2006) ( astro-physic ) and (Lin et al., 2008) (others). a9a is from the UCI  X  X dult X  data set. real-sim includes Usenet articles. astro-physic includes documents from Physics Arxiv. news20 is a collection of news documents. yahoo-japan and yahoo-korea are obtained from Yahoo!. rcv1 is an archive of manually categorized newswire stories from Reuters. We compare six implementations of linear SVM. Three solve L1-SVM, and three solve L2-SVM.
 DCDL1 and DCDL2 : the dual coordinate descent method with sub-problems permuted at each outer it-eration (see Section 3.1). DCDL1 solves L1-SVM while DCDL2 solves L2-SVM. We omit the shrinking setting . Pegasos : the primal estimated sub-gradient solver (Shalev-Shwartz et al., 2007) for L1-SVM. The source is at http://ttic.uchicago.edu/ ~ shai/code .
 SVM perf (Joachims, 2006): a cutting plane method for L1-SVM. We use the latest version 2.1. The source is at http://svmlight.joachims.org/svm_perf.html . TRON : a trust region Newton method (Lin et al., 2008) for L2-SVM. We use the software LIBLINEAR version 1.22 with option -s 2 ( http://www.csie.ntu.edu. tw/ ~ cjlin/liblinear ).
 PCD : a primal coordinate descent method for L2-SVM (Chang et al., 2007).
 Since (Bottou, 2007) is related to Pegasos , we do not present its results. We do not compare with another online method Vowpal Wabbit (Langford et al., 2007) either as it has been made available only very recently. Though a code for the bundle method (Smola et al., 2008) is available, we do not include it for comparison due to its closeness to SVM perf . All sources used for our comparisons are available at http://csie.ntu. edu.tw/ ~ cjlin/liblinear/exp.html .
 We set the penalty parameter C = 1 for comparison 2 . For all data sets, the testing accuracy does not increase after C  X  4. All the above methods are implemented in C/C++ with double precision. Some implementa-tions such as (Bottou, 2007) use single precision to reduce training time, but numerical inaccuracy may occur. We do not include the bias term by (3). To compare these solvers, we consider the CPU time of reducing the relative difference between the primal objective value and the optimum to within 0.01: where f P is the objective function of (1), and f P ( w  X  is the optimal value. Note that for consistency, we use primal objective values even for dual solvers. The ref-erence solutions of L1-and L2-SVM are respectively obtained by solving DCDL1 and DCDL2 until the du-ality gaps are less than 10  X  6 . Table 2 lists the re-sults. Clearly, our dual coordinate descent method for both L1-and L2-SVM is significantly faster than other solvers. To check details, we choose astro-physic , news20 , rcv1 , and show the relative error along time in Figure 1. In Section 3.2, we pointed out that the shrinking technique is very suitable for DCD . In Fig-ure 1, we also include them ( DCDL1-S and DCDL2-S ) for comparison. Like in Table 2, our solvers are effi-cient for both L1-and L2-SVM. With shrinking, its performance is even better.
 Another evaluation is to consider how fast a solver ob-tains a model with reasonable testing accuracy. Using the optimal solutions from the above experiment, we generate the reference models for L1-and L2-SVM. We evaluate the testing accuracy difference between the current model and the reference model along the train-ing time. Figure 2 shows the results. Overall, DCDL1 and DCDL2 are more efficient than other solvers. Note that we omit DCDL1-S and DCDL2-S in Figure 2, as the performances with/without shrinking are similar. Among L1-SVM solvers, SVM perf is competitive with Pegasos for small data. But in the case of a huge num-ber of instances, Pegasos outperforms SVM perf . How-ever, Pegasos has slower convergence than DCDL1 . As discussed in Section 4.2, the learning rate of stochas-tic gradient descent may be the cause, but for DCDL1 we exactly solve sub-problems to obtain the step size in updating w . Also, Pegasos has a jumpy test set performance while DCDL1 gives a stable behavior. In the comparison of L2-SVM solvers, DCDL2 and PCD are both coordinate descent methods. The former one is applied to the dual, but the latter one to the pri-mal. DCDL2 has a closed form solution for each sub-problem, but PCD has not. The cost per PCD outer iteration is thus higher than that of DCDL2 . There-fore, while PCD is very competitive (only second to DCDL1 / DCDL2 in Table 2), DCDL2 is even better. Regarding TRON , as a Newton method, it possesses fast final convergence. However, since it takes signifi-cant effort at each iteration, it hardly generates a rea-sonable model quickly. From the experiment results, DCDL2 converges as fast as TRON , but also performs well in early iterations.
 Due to the space limitation, we give the following ob-servations without details. First, Figure 1 indicates that our coordinate descent method converges faster for L2-SVM than L1-SVM. As L2-SVM has the diag-onal matrix D with D ii = 1 / (2 C ), we suspect that its  X  Q is better conditioned, and hence leads to faster convergence. Second, all methods have slower conver-gence when C is large. However, small C  X  X  are usually enough as the accuracy is stable after a threshold. In practice, one thus should try from a small C . More-over, if n l and C is too large, then our DCDL2 is slower than TRON or PCD (see problem a9a in Table 2, where the accuracy does not change after C  X  0 . 25). If n l , clearly one should solve the primal, whose number of variables is just n . Such data are not our fo-cus. Indeed, with a small number of features, one usu-ally maps data to a higher space and train a nonlinear SVM. Third, we have checked the online Algorithm 2. Its performance is similar to DCDL1 and DCDL2 (i.e., batch setting without shrinking). Fourth, we have in-vestigated real document classification which involves many two-class problems. Using the proposed method as the solver is more efficient than using others. We can apply the proposed method to solve regular-ized least square problems, which have the loss func-tion (1  X  y i w T x i ) 2 in (1). The dual is simply (4) with-out constraints, so the implementation is simpler. In summary, we present and analyze an efficient dual coordinate decent method for large linear SVM. It is very simple to implement, and possesses sound op-timization properties. Experiments show that our method is faster than state of the art implementations. Bordes, A., Bottou, L., Gallinari, P., &amp; Weston, J. (2007). Solving multiclass support vector machines with LaRank. ICML .
 Boser, B. E., Guyon, I., &amp; Vapnik, V. (1992). A train-ing algorithm for optimal margin classifiers. COLT . Bottou, L. (2007). Stochastic gradient descent exam-ples. http://leon.bottou.org/projects/sgd .
 Chang, C.-C., &amp; Lin, C.-J. (2001). LIBSVM: a library for support vector machines . Software available at http://www.csie.ntu.edu.tw/ ~ cjlin/libsvm .
 Chang, K.-W., Hsieh, C.-J., &amp; Lin, C.-J. (2007). Coor-dinate descent method for large-scale L2-loss linear
SVM (Technical Report). http://www.csie.ntu. edu.tw/ ~ cjlin/papers/cdl2.pdf .
 Collins, M., Globerson, A., Koo, T., Carreras, X., &amp; Bartlett, P. (2008). Exponentiated gradient al-gorithms for conditional random fields and max-margin markov networks. JMLR . To appear.
 Crammer, K., &amp; Singer, Y. (2003). Ultraconservative online algorithms for multiclass problems. JMLR , 3 , 951 X 991.
 Friess, T.-T., Cristianini, N., &amp; Campbell, C. (1998).
The kernel adatron algorithm: a fast and sim-ple learning procedure for support vector machines. ICML .
 Joachims, T. (1998). Making large-scale SVM learning practical. Advances in Kernel Methods -Support Vector Learning . Cambridge, MA: MIT Press.
 Joachims, T. (2006). Training linear SVMs in linear time. ACM KDD .
 Kao, W.-C., Chung, K.-M., Sun, C.-L., &amp; Lin, C.-J. (2004). Decomposition methods for linear support vector machines. Neural Comput. , 16 , 1689 X 1704. Keerthi, S. S., &amp; DeCoste, D. (2005). A modified finite Newton method for fast solution of large scale linear SVMs. JMLR , 6 , 341 X 361.
 Keerthi, S. S., Shevade, S. K., Bhattacharyya, C., &amp; Murthy, K. R. K. (2001). Improvements to Platt X  X  SMO algorithm for SVM classifier design. Neural Comput. , 13 , 637 X 649.
 Langford, J., Li, L., &amp; Strehl, A. (2007). Vowpal Wab-bit. http://hunch.net/ ~ vw .
 Lin, C.-J., Weng, R. C., &amp; Keerthi, S. S. (2008). Trust region Newton method for large-scale logistic regres-sion. JMLR , 9 , 623 X 646.
 Luo, Z.-Q., &amp; Tseng, P. (1992). On the convergence of coordinate descent method for convex differentiable minimization. J. Optim. Theory Appl. , 72 , 7 X 35. Mangasarian, O. L., &amp; Musicant, D. R. (1999). Suc-cessive overrelaxation for support vector machines. IEEE Trans. Neural Networks , 10 , 1032 X 1037.
 Osuna, E., Freund, R., &amp; Girosi, F. (1997). Train-ing support vector machines: An application to face detection. CVPR .
 Platt, J. C. (1998). Fast training of support vector ma-chines using sequential minimal optimization. Ad-vances in Kernel Methods -Support Vector Learn-ing . Cambridge, MA: MIT Press.
 Shalev-Shwartz, S., Singer, Y., &amp; Srebro, N. (2007). Pegasos: primal estimated sub-gradient solver for SVM. ICML .
 Smola, A. J., Vishwanathan, S. V. N., &amp; Le, Q. (2008). Bundle methods for machine learning. NIPS .
 Zhang, T. (2004). Solving large scale linear predic-tion problems using stochastic gradient descent al-
