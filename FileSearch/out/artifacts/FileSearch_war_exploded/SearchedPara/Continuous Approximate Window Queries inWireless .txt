 Wireless sensor networks are utilized in a wide variety of scenarios, such as monitoring farm belt, large-scale habitat, or environmental disaster, tracing ab-normities or events for military surveillance and reconnaissance tasks, scheduling real-time supply chain management and so on.

As we known, sensor nodes are often powered by limited batteries. Energy-efficient query processing techniques [1,2,3,4,5,6] and routing protocols [7] have been widely explored recently. In some a pplications, people may want to collect sensor data from a specified region [8,9], for example,  X  X etrieving the average humidity from region A. X  Such query is called window query. For simplicity, we assume the region is shaped as a two-dimensional rectangle.

Often a user wants to continuously mon itor environments in the specified region for a long time, take an example,  X  X etrieving the average rainfall from region X every ten seconds, for three months. X  To answer such a continuous window query, it is not desired to forwarding all sensor readings in the region to the sink for each time step, since the energy consumption is huge. In this paper, we address the problem of providing an energy-efficient approximate window query approach. That is, given a sensor network with a fixed sink, a user specifies a window R [( x 1 ,y 1 ) , ( x 2 ,y 2 )] and a query  X  X ELECT * FREQ f WITHIN  X   X  OVER R [( x 1 ,y 1 ) , ( x 2 ,y 2 )]. X 
With the consideration of spatial correlation between sensors [8], we partition the query region into several clusters for each time step. Each cluster constructs a clique based on their similar sensor readings. This Clique-based Window Query (CWQ) approach does not require to collect or forward all sensor readings to the sink, instead, only part of sensors are chosen to report their readings. The key technical challenges of this work are listed as follows.  X  A sensor may join or leave from a cluster when its reading exceeds the value  X  We provide techniques to find a minimal forwarding path to routing all 1.1 Related Work Existing window-based queries processing techniques can be divided into infra-structure-based query execu tion [2,10,11] and infrastructure-free query execu-tion [12]. Based on the size of the infrastructure, infrastructure-based query execution can be further classified into n etwork spanning infrastructure (NSI) and window spanning infrastructure (WSI). In [2] (shown in Fig. 1(a)), an NSI is usually built when deploying the network and is maintained during the entire network lifetime. For window-query, NSI involves many irrelevant nodes out-side the query window for query processing, which costs many extra resources. WSI approaches [10,11] (shown in Fig. 1(b)) adopt Geo-routing protocol (e.g., GPSR [13]) to transmit the query from the query originator node to query win-dow. Once the query reaches the query window, an infrastructure within the query window is built along with the query propagation. Data collection execute along the same infrastructure (e.g., a tree or a cluster). However, construct-ing and maintaining the infrastructure also incurs noticeable overhead and time latency.

To overcome the problems of infrastruct ure-based query execution, an infra-structure-free window-based query processing technique for sensor networks is proposed in [12], called itinerary-based window query execution (IWQE), shown in Fig. 1(c). [12] combines query propagation and data collection into one single stage and a well-designed itinerary inside the query window is used to navigate the query processing. Differ from infrastructure-based techniques, IWQE does not maintain any infrastructure and hen ce improves energy efficiency and reduces the query response time.

The most closed work to ours is snapshot query proposed by Kotidis [14], which exploits local models and correlations, and elects a small set of repre-sentative nodes to answer the queries. There are two major difference between snapshot and CWQ, which are (i) snapshot need spend energy to choose repre-sentative node, whereas CWQ can rando mly choose a sensor in the cluster as routing node to forward sensor readings, and (ii) each representative node using snapshot needs choose a minimal path from each cluster to the sink to forward readings, whereas, CWQ tries to find a global minimal routing path in the query region. These two aspects makes CWQ more energy-efficient than snapshot. We begin by formalizing the problem and proposing an approximate window query framework. To illustrate it, we use a network model as follows. Note, how-ever, that our approach can be applied to more complicated environments. Sensor Network. A sensor network consists of a set of fixed-location sensors, each of which has a unique ID. Two sensors are said to be neighbors if they are within the transmission range of each other. Each sensor knows its location as well as the location of its neighbors. Without loss of generality, we assume that the sink node is fixed, has unlimited energy, and initially broadcasts the locations of all sensors.

The primary consumption of energy in sensor nodes is for radio communi-cation, whereas computation cost is rel atively much lower than communication  X  X ELECT * FREQ f WITHIN  X  OVER R [( x 1 ,y 1 ) , ( x 2 ,y 2 )] X  to the network. Problem Definition. Given a sensor network that continuously sensing values at each time step and a sink that requires an -loss approximation of the sensing protocol in the region R that costs network ener gy as less as possible.
In this paper, we propose an approximate continuous query processing method to fulfill the requirements of the above problem. Specifically, by utilizing the spa-tial correlation among sensor readings, sensors are first grouped into value-based connected clusters, called VCC, with a distributed clustering algorithm, which will be discussed in Section 3. Then, a single routing path will be chosen to connect all VCCs and forwards readings of the VCCs to the sink. A valid data route is proposed in Section 4 to guide the sensors inside each VCC to send their readings to the sink with a  X  X inimal X  route. We show our experimental results in Section 5. Finally, Section 6 concludes the paper. As illustrated in Section 1, the spatial correlation determines that sensor readings in a certain region are the same or quiet similar. We can separate the whole sensing region into several disjoint regions according to their sensor readings.
In order to simplify the presentation, we assume that there is a single mea-surement s i collected on each sensor node. In practice there can be as many measurements as the number of sensing elements installed on a node. Our ap-proach can also solve the problem.
 Definition 1. (Value-based Cluster) Given a region R [( x 1 ,y 1 ) , ( x 2 ,y 2 )] in the wireless sensor network, a set of sensor measurements S ( R ) = { s 1 , ..., s m } belong to a value-based cluster C , iff for any two sensor measurements s i ,s j  X  S ( R ) , of s at time step t .
 Definition 2. (Disjoint cluster model) A cluster model is denoted as C v = C , ..., C k ,where k is number of VCCs and for any two C i and C j ,theyare disjoint.
 construct different VCCs and discovery a  X  X ood X  data routing to forward their readings to the sink using as less energies as possible. In this section, we present our cluster construction approach, we then propose an approach to concatenate VCCs in Section 4. 3.1 Clusters Construction Once a continuous query is submitted to the sink, the sink can choose a set of sensors in the specified region R to construct disjoint VCCs. Each chosen sensor actively invites their neighbors to join in its cluster. We call such chosen sensors seeds .

In order to let all sensors to involve in the clustering procedure simultane-ously, seeds are desired to distribute uniformly in the network. That is, for any asensor s in the network, either s is a seed, or s is a neighbor to a seed. The problem of choosing seeds is a typical problem of constructing a dominating set over the topology graph in the region R . We can use a greedy approach to choose seeds. That is, we (i) start with the network and an empty set S ; (ii) pick a sen-sor with most neighbors not already in the set S and add it to S ; (iii) repeat step (ii) until all sensors are in S or adjacent to the sensors in S . This greedy approach can guarantee O ( n ) complexity, where n is the number of sensors in R .

Algorithms 1 and 2 are used to construct disjoint VCCs. Algorithm 1 illus-trates that a seed constructs a set of di sjoint VCCs. After receiving the start message sent from the sink, each seed broad casts its sensor reading and receives neighbors responses. Lines 3, 18, and 20 in Algorithm 1 show behaviors of a seed s according to its neighbors X  responses. If s gets responses, then it clusters its neighbors who satisfy the value constraints into its group. Lines 4 to 6 in Algorithm 1 show a conservative way of adding member sensor measurements to the VCC of s . Lines 8 to 16 greedy add more member sensors in the VCC, where the value distance between V I ( s )=[ v l ,v u ]and v t ( s )isdefinedinEquation1. If s does not receive any response, then it ei ther joins to another seed X  X  group (Lines 18 to 19) or builds a VCC (Lines 20 to 21) that contains itself. Using Algorithm 1, a seed only need to send two messages to construct a VCC. Al-gorithm 2 describes that a non-seed beha viors. Line 2 in Algorithm 2 describes the case where a non-seed receives invitat ions from seeds. It chooses a seed who has the closest value with its reading. If there is no invitation, then the non-seed sensor changes it to a seed sensor and uses Algorithm 1 to construct its VCC. We can see a non-seed uses at most four messages to make it a member of a VCC.
For example, Fig. 2(a) shows the sensor topology in a query region. Fig. 2(b) shows three constructe d clusters using seeds s 1 ,s 7 ,and s 8 . 3.2 Clusters Maintenance At time step t ,ifasensor s in C detects an update, i.e. v t ( s )  X  V I t  X  1 ( C ), then s forwards v t ( s ) to the sink along its routing path (We show how to find a routing path in Section 4). The neighbors of s can listen such information using Gossip protocol [16]. Generally, neigh bor sensors detects a similar value to v t ( s ). If the neighbors of s cannot detect such update s, then we assume that v t ( s ) is a noise (or outlier). If there is at least one neighbor s detects update and | v ( s )  X  v t ( s ) | X  ,then s uses Algorithm 1 to build up a new VCC.
Figs. 2(c), (d), and (e) show the possible three cases when dist ( V I t .InFig.2(c), s 4 and s 5 leave from their clusters, respectively and construct a new cluster; In Fig. 2(d), s 4 joins in cluster { s 6 ,s 7 ,s 9 } ,andFig.2(e)shows s 4 cannot find a cluster to join in, so s 4 might produce a noise and there is no need to forward its update to the sink. After we get a set of VCCs, a crucial pro blem that we need to address is how to find a  X  X inimal X  route to catenate all VCCs.

As discussed in [12], one path routing saves more energy than a tree rout-ing. Ideally, sensors can independently find one minimal route to convey sensor readings of all VCCs to the sink.
 Definition 3. (Valid data route) Given a set of disjoint VCCs C 1 , ..., C k and sink s ,aroute s 1  X  ...  X  s m  X  s is valid, if and only if for each VCC C i ,there exists at least one routing sensor s j  X  C i ( 1  X  j  X  m ).
 Minimal valid data route. Given a set of disjoint VCCs C 1 , ..., C k and a start sensor s in the specified region R , find a valid data route s  X  s 1  X  ...  X  s m  X  s ,where s is a sensor outside of the region. The valid route is minimal if (i) s 1 is disconnected to s after removing s j (1  X  j  X  m ) from the route, and (ii) only updates are transmitted to s .

In this section, we propose a self-adaptive routing protocol to decrease num-bers and sizes of forwarding messages, and balance the energy consumption of sensors in the specified region R . We show that using our proposed routing, sensors are smart to find a  X  X inimal X  valid route to forward messages. 4.1 Choosing Routing Sensors In the region R , no sensor has global knowledge about other VCCs. In order to let sensors intelligently build up a routing tree, we extend the Tag tree technique.
Each sensor in the region R has a routing table to record a tuple &lt; level , routed-clusters &gt; ,where level denotes the length of the route path in R ,and routed-clusters denotes the routed clusters represented using seed in each cluster. For example, the seeds in Fig. 2 are s 1 , s 4 , s 7 ,and s 8 .Forastartsensor s , s forwards the query request q to the region R . It marks itself as the 0 level routing node and adds its cluster X  X  seed to its routing table. Then s broadcasts its routing message to its neighbors. For each sensor in R , the routing strategy is listed as follows.  X  If non sensor in a cluster is routed, then sensors in the cluster broadcasts  X  Each sensor increases its routing paren t X  X  level by 1 and add its cluster X  X  seed
Fig. 3 shows two routing paths start from different sensors. The routing path in Fig. 3(a) is s 8  X  s 7  X  s 4  X  s 2 . The routing path in Fig. 3(b) is s 5  X  s 10  X  s  X  s 4.2 Continuous Query In order to balance the energy consumption of sensors, CWQ builds up different routes periodically. During one period of time T , the route is expected to be the same so that only updates need forward. We first describe how to forward messages when a new route is built up. Then, we then discuss forwarding updates to the sink along the constructed route. Rule 1 describes how to forward messages along the route at the time a new route is built up.
 Rule 1. If there are more than one sensors in a VCC has been routed, then only the last routing sensor needs append message.
 For different period of routing time, sensors finds a different route to balance the energy consumption in the network. Note that for each period, we only build a single route, not multiple routes, thus, the energy consumption is approximately the same.

We next discuss how CWQ self-adaptively builds up a new valid route to balance the energy consumption in the network. Each sensor in the network keeps its routing history and is aware of its remaining energy. Also, CWQ utilizes Gossip protocol [16] to intelligently find the new valid route. For instance, at the first step of a new time period T , a new routing sensor s a is chosen and selects sensor s b as its downstream routing node. s b checks its routing history and remaining energy. In case that s b serves a routing sensor in recently time period or has not enough energy to forward messages, it will not forward messages further. After s a sends message to s b , it can listen messages sent from s b although those messages are not sent to s a according to Go ssip protocol. If s a cannot listen message from s b ,then s a knows that s b does not forward its message. So, s a chooses another sensor s b . In this way, a sensor can self-determine its role of routing according to its own sta tus. There is one exception that s a failed to monitor the broadcast message from s b ,then s a chooses another routing sensor and meanwhile s b continues to forward messages. Therefore, there are at least two routes arrive the sink. We conducted experiments to evaluate the effect of our proposed CWQ technique by simulating light monitoring experien ce in our lab. In this section we report the experimental results.
 All the experiments were implemented in C++, and run on an Intel Pentium IV 2.0GHz PC with 512MB RAM.

In the simulation, we generated the synthetic data we generated values that follow a random walk pattern. In order to simulate a network with large number of sensors, we developed a simulator to construct a network by expanding the deployment of sensors in our lab. We built up a 100  X  100 two-dimensional area, where N =100 sensor nodes are randomly placed in the area. We generated a density sensor network such that for eac h sensor, its 70% neig hbors are connected with each other.
 We consider two types of data sets and analyze the effect of them on CWQ. For each type of data set, we generated 5 groups of data to compute the average values.
 Type 1 : Updates of sensor readings in the region are similar.
 Type 2 : Small percentage of updates change significantly than the other sensor readings. 5.1 Comparison Results We compared energy consumptions of the tree-based approach, cluster-based approach, and CWQ using two types of data sets. In the tree-based approach, the network topology is a tree in the query window. Similarly, in the cluster-based approach, a cluster head is chosen to answer the query.
 We let be 1, a transmit range (maximal length of each sensor transmission) L be 30 in the 100  X  100 query region. For a query request q in the query region, we collected sensor readings co ntinuously every 4 time steps.
 Fig. 4 shows the energy consumption of the three approaches using two types of data sets. Figs.4(a) and (b) show that the performance of CWQ is better than the other two approaches. At the first time step, CWQ needs construct clusters and choose valid date route, which more energies than tree-based and cluster-based approaches. In the 40th time steps, the clusters and data routes get stable, there-fore, CWQ does not require all sensors to forward their readings, which consumes less energy. The energy consumption of the tree-based approach is the highest, since it probes all sensors in the query region. Comparison of energy consumptions between the effects of two different types of data sets using CWQ is depicted in Fig. 4(c). As we can see, Type 1 data set consumes less energy than Type 2 data set does, since updates in the former data set are similar. The figure also shows that CWQ performs good when some sensor readings changes lot. 5.2 Effect of Transmission Range and Error Threshold Consider the definition of clique, we know that the error threshold and trans-mission rang L are of great importance to partitioning clique. Fig. 5(a) shows the effect of transmission range L . Let the error threshold be 1. When increasing the transmission range, the density of sensors in the network increase, which results in high probability to cluster more sensors into one group. Fig. 5(b) shows the effect of varying when fixing the transmission range L = 30. It is not surprising to see that under the same sensor distribution, the number of clusters decreases when increasing . 5.3 Effect of Sensor Density Fig. 6 shows that the energy consumption of the three approaches: tree-based, cluster-based approaches and CWQ. We let the transmission range L =30and = 1. We calculated the average energy co nsumption (# of forwarding messages) of all sensors in the region. CWQ consumes much less energy than the tree-based approach. However, as the node density d ecreases, every cluster contains less nodes. When the node density decreases to a small enough value, the network topology becomes a tree structure, wh ich results in CWQ and cluster-based approach behaving like tree-based approach, therefore, the energy consumption become closer. In this paper, we described the processing problem of window-based approxi-mate continuous queries in w ireless sensor network an d proposed cluster-based approximate continuous window-based query processing technique (CWQ). Ex-isting techniques for window-based do not support continuous queries with long lifetime. In CWQ, the network is partitioned into some clusters and a small number of sensors are intelligently chosen as routing nodes to forward sensing readings. The experimental results showed that CWQ performs better in terms of energy consumption under different factors.

