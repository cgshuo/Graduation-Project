 Schema matching is widely studied in database research [1] [5], with the aim to bridge relational and semi-structured data models, or to integrate data with either homogeneous or heterogeneous data models [8]. Schemas are usually modeled as trees and tree matching has inevitably become one of the main issues in Schema matching. A number of intuitively appealing techniques have been proposed including Cupid [5], similarity flooding [6], LSD [2], ISSDE [11], SKAT [7] and COMA [5]. The most formal approach is tree matching based on edit distance. Those for unor-dered tree matching [10] and [3] are more useful than for ordered tree matching [12]. Unfortunately, matching algorithms for unordered trees suffer from exponential com-plexity. In practice, researchers propose approximate algorithms. This is the case in [9] and [13] where, under the constraints of ancestor preserving and exact node-to-node mapping, subtree similarities are iteratively calculated in a bottom-up way. 
In our work, we also model an XML Schema as an unordered, labeled and rooted tree. We are more interested in the overall similarity between two XML Schemas than the correspondence of individual elements. Our algorithm identifies the structural relations by extracting approximate common substructures in two trees. Several heu-ristics have been proposed to drastically re duce the search space in order to achieve a good trade-off between matching optimality and time complexity. The modeling phase, the computation of node similarity and some detailed experimental results are matching algorithm that has been designed for computing the structural similarities. The algorithms discussed in Section 1 are not adequate for two reasons. One is the efficiency problem in dealing with large schemas. Another relates to the constraint imposed by ancestor relation preserving. To understand this latter point, let us con-sider the two schemas in Figure 1. They are not similar because of the structural dif-ference. However, they do share a common substructure and an approximate common substructure as shown in Figure 2. Their extraction would allow some further interest-ing comparison between the two Schemas. The goal of our algorithm is to extract a disjoint set of the largest approximate common substructures (ACS) between two trees. This set of ACSs represents the most likely matches between substructures in the two schemas. Indeed, the algorithm computes structure similarity for each pair of substructures by comparing  X  X oot parts X  of subtrees while still taking into account the 2.1 Approximate Common Substructure (ACS) Given two trees T 1 and T 2 , the concept of ACS is related to subtree matching. A qual-ity measure, defined as the structure similarity, is necessary to distinguish between a  X  X ood X  ACS and a  X  X ot very good X  ACS. Formally, the structure similarity between two substructures, subStr 1 from T 1 and subStr 2 from T 2 , can be defined as: conditions: 1) M p u  X  ) , (, M q v  X  ) , (and v u = imply q p = ; 2) M is ancestor pre-serving. The similarity measure C ( M ) should satisfy the following two conditions: 1) number of unmatched nodes. Unfortunately, computing ) , ( 2 1 subStr subStr structSim is similarity function () treeSim , while i subStr are limited to rooted subtrees. Another denote the ACS rooted at u and p , |ACS ( u, p ) | to denote the number of matched node pairs, then we have reaches a trade-off between the structure similarity and the matching percentage. 
The algorithm aims to find a unified mapping schema M composed of the set of all the mappings derived from disjoint ACSs percentage beyond a fixed threshold. It is important to notice that while ancestral relations are preserved within each ACS i ; they do not have to be preserved in the uni-paper that makes the matching of the above car-driver Schemas possible. 2.2 The Matching Algorithm Given a node pair ( u, p ), where 1 T u  X  and 2 T p  X  respectively, the structure similar-ity, treeSim(u, p) , between the subtrees rooted at u and p is defined as follows: where subTreeSim(u, p) represents the similarity computed based on the subtrees rooted at u and p , and is the major concern of the algorithm.  X  is a factor whose value is between 0 and 1, reflecting the weight of the two parts. This definition, easily justi-fiable for a large number of real applications , is deliberately in favor of the root parts of the two subtrees and suggests a recurs ive approach to matching the two trees. Fig-ure 4 outlines the general idea of the approach adopted for the new algorithm. 
The subtree similarity corresponds in fact to the similarity between two forests un-der u and p . Since the size of each subtree in the forests can be very large, we trim the size of each subtree to two levels by considering each subtree beyond the level 2 as a super-node as shown in the forest under ( p ) in Figure 3. The procedure for computing node similarities. The following conditions ha ve been taken into account: 1) preserva-moved up to become children of the parent of 1 u ; 3) if at least one of the two nodes is a super-node, then ) , ( ) , ( 1 1 1 1 p u treeSim p u Sim forestNode = . where | descendants | denotes the number of descendants of the non-leaf node. 1 is a penalty factor that reflects the difference between the two forests under u and p .  X  is a user-defined parameter, set to 0.3 in our experiments? In this equation, M is any mapping built following the above conditions 1 and 2, i.e. M is an ancestor order preserving mapping between the remained forest under u and NbLF is the number of nodes in the larger (remained) forest. The formula (3) can be interpreted as follows. between the matched nodes which will be penalized by two factors: one is related to deleted nodes (division by ld deletedChi + 1 ) and the other one is related to percent-age of non-matched nodes (multiplication by NbLF M ). This formula materializes the goal of the matching, which is to search the best ancestor order preserving corre-spondence between the two forests in terms of the similarity and the number, while limiting the number of deletions. The matching process starts with leaf n odes of the two trees and goes upwards. Each pair of subtrees will be matched after all their pairs of subtrees have been matched. The output of the matching algorithm is all the similarity and the corre-sponding mapping for each pair of subtrees. 2.3 Identifying ACSs Both treeSim ( u, p ) and mPer ( u, p ) should be considered to determine qualified ACSs for the final mapping schema M . If we project these two values for every node pair into a two-dimension-plane, we will get a scatter chart like the one in Figure 4. Each point denotes the result of an ACS candidate. Point A ( 1, 1 ) represents an ideal matching  X  both the structural similarity and matching percentage reach the maximum value. represent the poorest candidates  X  low similarity and low matching percentage, and values is high. Generally, most points fall into the area in between. 
To determine good ACSs from the scatter chart, we use the Euclidian distance from the node to the perfect matching point A . The idea of this approach is shown in Figure 4: the arc represents those points whose distance to point A is equal to the threshold, therefore the points covered by the sector wi ll be considered as admissible candidates to generate the ACSs. Details of the ex traction procedure are omitted because of space limit. 2.4 Reporting Results  X  Mappings and Schema Similarity Retrieving mappings is relatively straightforward once schema M is identified. Each root element (always  X  X chema X ) to this matched element, and the names are delimited by slash. e.g. schema/car/driver/first and schema/driver/firstName. Note that the root element of an XML Schema is always  X  X chema X  , so we do not treat the root to root as a mapping. The similarity of the two Schemas is simply the structure similarity of the The system has been tested extensively using about 600 XML Schemas in total. We evaluated both matching accuracy and computational efficiency of our system. Com-parisons were made with the traditional edit distance tree matching algorithm [12] and a popular XML Schema matching system COMA [1]. The results show that our new tree matching algorithm outperforms these two methods, and can be used to match larger schemas that contain hundreds of elements. A more detailed report of the ex-periment is described in our previous paper [4]. Compared with the edit distance tree matching algorithm, our new tree matching algorithm is both faster and more accurate in terms of precision and recall. Compared with COMA, our matching system is also satisfying. Our experiments results show that, under the condition of no human inter-ference, our matching system works better than COMA. Finally, our algorithm allows to effectively matching Schemas containing hundreds, or even thousands of nodes. 
