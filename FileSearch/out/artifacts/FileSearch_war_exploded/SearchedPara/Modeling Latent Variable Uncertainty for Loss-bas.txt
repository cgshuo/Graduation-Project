 M. Pawan Kumar pawan.kumar@ecp.fr Center for Visual Computing,  X  Ecole Centrale Paris, France  X  Equipe Galen, INRIA Saclay,  X  Ile-de-France, France Ben Packer bpacker@cs.stanford.edu Stanford University, Stanford, CA 94305, USA Daphne Koller koller@cs.stanford.edu Stanford University, Stanford, CA 94305, USA Latent variable models ( lvm s) provide an elegant for-mulation for learning with weakly supervised datasets. For example, in computer vision, we may wish to learn a model for detecting an object such as  X  X eer X  from im-ages where the location of the deer is unknown, and is therefore treated as a latent variable. In compu-tational medicine, we may wish to diagnose a patient based on the observed symptoms as well as other un-known factors, such as the family X  X  medical history, which can be represented using latent variables. Typically, an lvm employs a single distribution over three types of variables: (i) the observed variables, or input, whose values are known during both training and testing; (ii) the unobserved variables, or output, whose values are known only during training; and (iii) the unknown latent variables. In this setting, a natu-ral framework would be to model the uncertainty in the value of the latent variables and learn an lvm by marginalizing them out (for example, in the case of the expectation-maximization, or em , algorithm). However, such an approach is unsuited for applications that require an accurate prediction of the latent vari-ables during test time. For example, in the above deer detection application, we would like to infer not only whether an image contains a deer, but also the exact location of the deer. Alternately, we can use a delta distribution that provides a pointwise estimate of the output and the latent variables (for example, in the case of the latent support vector machines, or lsvm , framework). However, discarding the uncertainty in latent variables can make such an approach prone to error due to noise (for example, background clutter that can be confused with a deer in feature space). The above argument illustrates the deficiency of us-ing a single joint distribution over the output and the latent variables to address two separate tasks: (i) mod-eling the uncertainty over latent variables during train-ing; and (ii) making accurate predictions during test-ing. We address this deficiency by proposing a novel framework that consists of two distributions: (i) a conditional distribution to model the uncertainty of the latent variables for a given input-output pair; and (ii) a delta distribution to predict the output and the latent variables for a given input. In order to learn the distributions from a training dataset, we build on the intuition that they should agree with each other, that is, (i) the output predicted by the delta distribu-tion should match the ground-truth output; and (ii) the latent variables predicted by the delta distribu-tion should have a high probability according to the conditional distribution. Due to the limited represen-tational power of any model we may not be able to achieve complete agreement (that is, all outputs are predicted correctly, and all predicted latent variables have probability 1). In order to make the two distri-butions as similar as possible, we minimize a regular-ized upper bound on a loss-based dissimilarity mea-sure (Rao, 1982) between the distributions.
 Unlike previous loss-based learning frameworks for lvm s, such as lsvm , we consider a general loss func-tion that not only depends on the output but also the latent variables. Such a loss function is essential when solving problems that require the accurate prediction of latent variables (for example, the aforementioned object detection problem). By not restricting the form of the loss function, our framework greatly enhances the applicability of loss-based learning with latent vari-ables. In fact, our framework can be viewed as a strict generalization of lsvm in the sense that, when the loss function is independent of the true (unknown) value of the latent variables, it reduces to an lsvm . Throughout this paper, we will assume that the latent variables are helpful in predicting the correct output of a sample. For example, if we want to distinguish be-tween images of deers and elephants, we would expect that the background clutter to have similar appearance for both categories, and an accurate object localization to be essential for correct prediction. There may be cases where this assumption does not hold. For exam-ple, images of deers and cars could be distinguished by detecting roads, or other objects that are more com-monly found in urban environments. However, even in such cases, we may be able to learn to detect the object by providing fully supervised annotations for a small fraction of training images, which would help guide the learner towards the correct object locations in other weakly supervised training images. The most commonly used method for learning the parameters of an lvm is the em algorithm (Demp-ster et al., 1977; Sundberg, 1974), or its many vari-ants (Gelman et al., 1995). While the em algorithm has an elegant probabilistic interpretation of maxi-mizing the likelihood of the ground-truth output, it marginalizes out the latent variables, which makes it unsuited to problems that require the accurate pre-diction of latent variables. Furthermore, it does not employ a user-specified loss function, which captures the user X  X  assessment of the quality of the solution. The most related works to our approach are lsvm (Felzenszwalb et al., 2008; Yu &amp; Joachims, 2009) and its recently proposed generalization called max-margin min-entropy models (or m3e for short) (Miller et al., 2012). The parameters of an lsvm or an m3e are learned by minimizing a regularized upper bound of the training loss. However, the loss function is restricted to be independent of the true (unknown) value of the latent variables. While such loss func-tions are useful, and in fact have been successfully em-ployed in practice (Blaschko et al., 2010; Felzenszwalb et al., 2008; Kumar et al., 2010; Miller et al., 2012; Yu &amp; Joachims, 2009), they cannot model several im-portant problems, including the two employed in our experiments X  X bject detection and action detection. In contrast, our framework allows the use of a general loss function. In section 4 we will show that, for loss functions that are independent of the true value of the latent variable, our framework reduces to an lsvm . In our earlier work (Kumar et al., 2011), we proposed an iterative lsvm strategy (or ilsvm for short) with the aim of using a general loss function. In section 5, we show that ilsvm corresponds to using delta func-tions to model the conditional distribution of the latent variables given the input and the output. In our ex-periments, we show that using a non-delta conditional distribution significantly outperforms ilsvm . Notation. We denote the input by x  X  X , the out-put by y  X  X  and the latent variables by h  X  X  . The training dataset D = { s i = ( x i , y i ) , i = 1 , , n } con-sists of n input-output pairs (or samples) s i . We denote the parameters of the delta distribution, which predicts the output and the latent variables for a given input, as w . The parameters of the conditional distribution of the latent variables given the input and the output are denoted by  X  .
 We assume that the user specifies a loss function  X ( y 1 , h 1 , y 2 , h 2 ) that measures the difference between ( y 1 , h 1 ) and ( y 2 , h 2 ). Similar to previous approaches, we assume that  X ( y 1 , h 1 , y 2 , h 2 ) = 0 if y 1 = y 2 h 1 = h 2 . Otherwise,  X ( y 1 , h 1 , y 2 , h 2 )  X  0. Rao X  X  Dissimilarity Coefficient. We provide a brief description of the dissimilarity measure used in our framework, which was first introduced by Rao (1982). Given a loss function  X ( z 1 , z 2 ), where z 1 , z Z , the diversity coefficient of two distributions P i ( z ) and P j ( z ) is defined as the expected loss between two samples drawn randomly from the two distributions respectively, that is,
H (P i , P j ) = X Using the diversity coefficient, the dissimilarity coeffi-cient between the two distributions can be defined as the following Jensen difference: D (P i , P j ) = H (P i , P j )  X   X H (P i , P i )  X  (1  X   X  ) H (P where  X   X  (0 , 1). Note that Rao (1982) fixed  X  = 0 . 5 in order to ensure that the dissimilarity coefficient is symmetric for P i and P j . However, dissimilarity coeffi-cients do not necessarily have to be symmetric (for ex-ample, the well-known Kullback-Liebler divergence is non-symmetric); hence we use the more general version shown in equation (2). Rao (1982) showed that the above formulation generalizes other commonly used dissimilarity coefficients such as the Mahalanobis dis-tance and the Gini-Simpson index. We refer the reader to (Rao, 1982) for details. Using the above notation and definitions, we now pro-vide the details of our learning framework. We begin by describing the distributions represented by the lvm . 4.1. Distributions We wish to address two separate tasks: (i) to accu-rately model the distribution of the latent variables for a given input-output pair; and (ii) to accurately pre-dict the output and latent variables for a given input (where accuracy is measured by a user-defined loss). Instead of addressing these two tasks with a single dis-tribution as in previous works, we define two separate distributions, each focused on a single task. Given an input x , we define a delta distribution pa-rameterized by w that predicts the output and the latent variables according to the following rule: Here,  X ( x , y , h ) is a joint feature vector of the input x , the output y and the latent variables h . Note that, al-though for simplicity we defined a linear rule in w , we can also employ a non-linear kernel within our frame-work. Formally, the delta distribution is given by As mentioned earlier, since the true value of the la-tent variables is unknown, we would like to model the uncertainty in their values. To this end, we define a separate conditional distribution parameterized by  X  such that where Z ( s i ;  X  ) is the partition function, which ensures that the distribution sums to one and  X ( x i , y i , h i ) is a joint feature vector of the input x i , the output y i and the latent variables h i . This feature vector can be dif-ferent than the joint feature vector used to specify the delta distribution P w ( ). Once again, a log-linear dis-tribution is used only to simplify the description. Our framework is valid for any general form of the distribu-tion P  X  ( ). Using the above conditional distribution, we also specify a joint distribution as follows: As will be seen shortly, this joint distribution would allow us to employ Rao X  X  dissimilarity coefficient in our learning framework. 4.2. The Learning Objective Given a dataset D and a loss function  X ( ), we pro-pose to learn the parameters w and  X  such that it min-imizes the corresponding dissimilarity coefficient over all training samples. Before delving into the details, we give a broad overview of our objective function. For a fixed w , if the predicted output y i ( w ) is similar to the ground-truth output y i , our objective encour-ages the probability of the corresponding latent vari-ables, that is P  X  ( h i ( w ) | s i ), and other similar latent variables, to be high. If the predicted output y i ( w ) is dissimilar to the ground-truth output y i , our objective encourages the diversity coefficient of the correspond-ing distribution, that is P  X  ( | s i ), to be high. In other words, for a correctly predicting sample, the condi-tional distribution is peaky , while for an incorrectly predicted sample, the conditional distribution is flat . For a fixed  X  , our objective minimizes the expected loss of the prediction ( y i ( w ) , h i ( w ))) over all the training samples s i . This is a key point of our formulation, as the expected loss incorporates the uncertainty of the latent variable values while learning the parameters w . Formally, the expected loss of a pair of output and latent variables ( y , h ) for the sample s i , measured with respect to P  X  ( | s i ), is defined as that is, it is the expectation of the loss between ( y , h ) and ( y i , h i ), where the expectation is taken over the distribution of the unknown latent variables h i . We now provide a mathematical description of our learning framework. However, throughout this section and the next, we will reiterate the above intuition at the appropriate places. Our training objective is the sum of the dissimilarity coefficient between P w ( ) and P  X  ( ) over all training samples. Using the definition of dissimilarity coefficient in equation (2), the objective can be written in terms of expected loss as Note that the diversity coefficient of P w ( ) is 0 since it is a delta distribution. Hence, the term H i ( w ) vanishes from the above objective.
 Minimizing the objective (8) encourages two desirable properties: (i) the predicted output y i ( w ) should be similar to the ground-truth output y i ; and (ii) the pre-dicted latent variable h i ( w ) should be similar to the latent variables with high probabilities P  X  ( h i | x i , y Importantly, the similarity (or, to be more precise, the dissimilarity) of the outputs and the latent variables is specified by the loss function  X ( ). Hence, during learning, the parameters w and  X  are tuned according to the user X  X  domain knowledge regarding the quality of a solution. This ability to learn loss-specific param-eters is absent in traditional frameworks such as em and its variants. 4.3. Upper Bound on the Learning Objective While the objective (8) is smooth and differentiable in  X  , for most commonly used choices of the loss function it is highly non-smooth in w . The non-smoothness of the objective results in a difficult optimization prob-lem, which makes the learner prone to bad local min-imum solutions. In order to overcome this deficiency, we minimize an upper bound on the objective, similar to the lsvm formulation (Yu &amp; Joachims, 2009). Specifically, we upper bound the term H i ( w ,  X  ), which depends on w , using  X  i ( w ,  X  ) defined as follows.  X  ( w ,  X  )  X  max y , h w  X   X ( x i , y , h ) +  X  i ( y , h ;  X  ) Using the above inequalities, the objective D ( w ,  X  ) can be upper bounded as However, if we learn the parameters w and  X  by mini-mizing the above upper bound (or indeed the original objective function), we run the risk of overfitting to the training data. In order to prevent this, we introduce regularization terms for the parameters. For this work, we use  X  2 norms, though other norms may also be em-ployed. To summarize, the parameters are learned by solving the following optimization problem: ( w  X  ,  X   X  ) = argmin where the hyperparameters J and C are the rela-tive weights for the regularization of  X  and the up-per bound of the dissimilarity coefficient respectively. Note that the upper bound derivation and the re-sulting optimization problem are similar to the lsvm framework. In fact, the problem can be shown to be a strict generalization of lsvm .
 Observation 1. When the loss function does not de-pend on the value of the latent variables, problem (11) is equivalent to the problem of learning an lsvm . This observation follows from the fact that, when the loss function is independent of the latent variables, H (  X  ) =  X  i ( y i ;  X  ) P h  X  optimization problem is equivalent to minimizing the sum of the regularization of w and  X  i ( w ,  X  ) (which are equivalent to the slack variables that model the up-per bound of the loss function for the sample s i in lsvm ). In fact, even if the loss function does depend on the predicted latent variable h i ( w ), the optimiza-tion problem (11) still generalizes lsvm . This follows from the fact that, in this case, the lsvm problem is equivalent to using delta distributions to model P  X  ( ). Formal proofs are omitted. While the upper bound derived in the previous section still results in a non-smooth and non-convex optimiza-tion problem, we obtain an approximate solution using block coordinate descent. Specifically, starting with some initial estimate of parameters, we alternately fix one of the two sets of parameters (either w or  X  ) while optimizing problem (11) over the other set of param-eters. The process is said to terminate when the de-crease in the objective falls below C X  , where C is the hyperparameter in problem (11) and  X  is a user spec-ified tolerance. The following subsections provide the details of the optimization over each set of parameters. 5.1. Optimization over w For a fixed  X  , problem (11) can be interpreted as mini-mizing a regularized upper bound on the expected loss induced by w , that is, since the term H i (  X  ) is a constant for all samples s i The expected loss is an intuitive objective: it gives more weight to the loss corresponding to the latent variables that have a high probability and less weight to those corresponding to the latent variables with low probability. Formally, for a fixed  X  , the optimization problem (11) reduces to the following: min s.t.  X  i = max y , h w  X   X ( x i , y , h ) +  X  i ( y , h ;  X  ) The following observation provides us with an efficient algorithm for the above optimization problem. Observation 2. Problem (13) is a difference-of-convex program.
 The regularization term || w || 2 is convex. The term  X  ( w ,  X  ) is a difference of two functions that are the pointwise maximum of a set of linear functions. Since the pointwise maximum of convex functions is convex, the observation follows. Similar to lsvm , a local min-imum or saddle point solution of problem (13) can be found using the concave-convex procedure ( cccp ) (Yu &amp; Joachims, 2009). The main steps of cccp are out-lined in Algorithm 1. It iteratively estimates the value of the latent variables using the current estimate of w , and updates the parameters by solving a convex optimization problem (14). There are several efficient algorithms for problem (14), for example (Joachims et al., 2009; Shalev-Shwartz et al., 2009; Tsochan-taridis et al., 2004). In this work, we use the 1-slack reformulation method proposed by Joachims et al. (2009). We can also solve problem (13) using the self-paced learning algorithm (Kumar et al., 2010), which can potentially improve the performance of our frame-work. However, in this paper, we restrict ourselves to the simpler and more efficient cccp algorithm. Algorithm 1 The cccp algorithm for optimizing w . input Dataset D , initial estimate w 0 , tolerance  X  . 1: t  X  0. 2: repeat 3: Update h  X  i = argmax h 4: Estimate the updated parameter w t +1 by solv-5: t  X  t + 1. 6: until Objective cannot be decreased below C X  . Problem (13) requires the computation of the expected loss  X  i ( y , h ;  X  ) as defined in equation (7), which can be found in O ( |H| ) time for each pair of ( y , h ) (where H is the space of all latent variables). For a suffi-ciently small H this operation is computationally fea-sible. For a large latent variable space H , we have two options. First, we can choose the joint feature vector  X ( x , y , h ) for the conditional distribution P  X  ( ) to be decomposable in such a manner as to facilitate efficient computation of sufficient statistics (for example, a low tree-width model). Note that this still allows us to use a more complex joint feature vector  X ( x , y , h ) to make predictions for a given test sample. Second, if the problem requires a complex  X ( x , y , h ) to encode the conditional distribution, then we can resort to using one of several inference techniques to compute the ap-proximate sufficient statistics. However, we note that several important problems in machine learning can be formulated using latent variables whose space is suf-ficiently small to allow for exact computations of the expected loss, including motif finding (Yu &amp; Joachims, 2009), image classification (Kumar et al., 2010; Miller et al., 2012), digit recognition (Kumar et al., 2010), and the two problems used in our experiments, namely object detection and action detection. 5.2. Optimization over  X  For a fixed w , problem (11) can be interpreted as a regularized upper bound on the following objective where the divergence coefficients H i ( w ,  X  ) and H i (  X  ) are defined in equation (8). To gain an understanding of the above objective, let us consider a simple 0/1 loss (that is, the loss is 0 if both the outputs are equal and both the latent variables are equal, otherwise 1). If y ( w ) = y i , that is, w predicts the correct output for the sample s i , then the first term of the above objec-tive dominates the second. In this case, the parameter  X  is encouraged to assign a high probability to the predicted latent variables h i ( w ), and other similar la-tent variables, in order to minimize the objective. If y ( w ) 6 = y i , the first term is a constant. Thus, the parameter  X  is encouraged to maximize the diversity of the conditional distribution P  X  ( ). In other words, for a correct prediction of output, we learn a peaky dis-tribution and for an incorrect prediction of output, we learn a flat distribution. Formally, for a fixed w , the optimization problem (11) reduces to the following: where U ( w ,  X  ) is defined in equation (10). We obtain an approximate solution to the above problem using stochastic subgradient descent ( ssd ). The main steps of ssd are outlined in Algorithm 2.
 Algorithm 2 The ssd algorithm for optimizing  X  . input Dataset D , initial estimate  X  0 , T &gt; 0. 1: t  X  0.  X   X  J/C . 2: repeat 3: Choose a sample s i randomly from D . 4: Compute the stochastic subgradient g t as 5: t  X  t + 1. 7: until Number of iterations t = T .
 Each iteration of ssd takes O ( |H| 2 ) time (since the subgradient g t requires a quadratic sum to compute H (  X  )). Similar to the expected loss, this can be per-formed exactly for a sufficiently small space of latent variables, or the appropriate choice of the joint feature vector  X ( x , y , h ). For a large latent variable space and a complex joint feature vector, we would have to resort to approximate inference. 5.3. Comparison with ilsvm Our overall approach is similar in flavor to the ilsvm algorithm (Kumar et al., 2011), which iterates over the following two steps until convergence: (i) obtain the value of the latent variables for all training sam-ples using the current estimate of the parameters; (ii) update the parameters by solving an lsvm , where the loss function is measured using the latent variables es-timated in the first step instead of the true latent vari-ables. The following observation shows that ilsvm is a special case of our framework.
 Observation 3. The first step of ilsvm minimizes the objective (15) when P  X  ( ) are restricted to be delta distributions. The second step of ilsvm solves an lsvm problem similar to the one described in the previous subsection for optimizing over w .
 The observation regarding the second step is straight-forward. For the first step, it follows from the fact that ilsvm minimizes H i ( w ,  X  ). As the second di-vergence coefficient H i (  X  ) vanishes when using delta conditional distributions, ilsvm effectively minimizes objective (15) for a fixed w . A formal proof is omitted. We now demonstrate the efficacy of our framework on two challenging machine learning applications: ob-ject detection and action detection. Specifically, we show how our approach, which models the uncertainty in the values of the latent variables during training, outperforms the previous loss-based learning frame-works, namely lsvm and ilsvm , which only estimate the most likely assignment of the latent variables. All three methods used in our experiments share a com-mon hyperparameter C (the relative weight for the upper bounds  X  i ), which we vary to take values from the set { 10  X  4 , 10  X  3 , , 10 2 } . In addition, our frame-work introduces two more hyperparameters: J (the relative weight for the regularization of  X  ) and  X  (the hyperparameter for Rao X  X  dissimilarity coefficient). In all our experiments, we set J = 0 . 1 and  X  = 0 . 1. How-ever, we may obtain better results by carefully tuning these hyperparameters. The tolerance value for all the methods was set to  X  = 10  X  3 . 6.1. Object Detection Problem Formulation. The aim of this application is to learn discriminative object models that predict the category (for example,  X  X eer X  or  X  X lephant X ) and the location of the object present in an image. In a fully supervised setting, we would be required to spec-ify a tight bounding box around the object present in each of the training samples. As the collection of such annotations is onerous and expensive, we would like to learn the object models using image-level la-bels (that is, labels indicating the presence or absence of an object category in an image), which are consid-erably easier to obtain. Formally, for each sample, the input x is an image. The output y  X  X  0 , 1 , , c  X  1 } , where c is the number of object categories. The latent variable h models the tight bounding box around the object in the image. Similar to previous works (Ku-mar et al., 2010; Miller et al., 2012), the joint feature vectors  X ( x , y , h ) and  X ( x , y , h ) are defined using the hog descriptor (Dalal &amp; Triggs, 2005; Felzenszwalb et al., 2008) extracted using the pixels of the bounding box. In our experiments, we consider non-overlapping putative bounding boxes that are 8 pixels apart, which results in a maximum of 350 bounding boxes for each image in our dataset. This allows us to compute the exact expected loss and the exact subgradients during learning. We employ two different loss functions, 0/1 loss and overlap loss, which are defined below.  X  O ( y 1 , h 1 , y 2 , h 2 ) = where O ( h 1 , h 2 )  X  [0 , 1] is the ratio of the area of the intersection and the area of the union of the two bounding boxes (Everingham et al., 2010). Both the loss functions not only encourage the models to pre-dict the right category but also the right location of the object. We note that a similar experimental setup was also used by Blaschko et al. (2010).
 Dataset. We use images of 6 different mammals (ap-proximately 45 images per mammal) that have been previously employed for image classification (Kumar et al., 2010; Miller et al., 2012). We split the images of each category into approximately 60% for training and 40% for testing. We report results using 5 folds. Results. Figure 1 shows the test loss for lsvm , ilsvm and our method using the 7 different C val-ues. The test loss is computed using the ground-truth labels and bounding boxes for the test samples. Re-call that, during training, only the ground-truth labels were assumed to be known, while the bounding boxes were modeled as latent variables.
 While lsvm was initially proposed for loss functions that do not depend on the value of the true latent vari-able, we adopted a similar approach to the cccp algo-rithm for lsvm to solve the object detection problem. Briefly, we iterate over two steps: estimating the value of the latent variables and solving a convex structured svm problem until the objective function could not be decreased below a user-specified tolerance. In our ex-periments, this approach provided similar results to the ilsvm method.
 By incorporating the uncertainty in latent variables, our approach outperformed both lsvm and ilsvm . Specifically, for the 0 / 1 loss, the best test loss (over all C values) for lsvm , ilsvm and our method is 64 . 82  X  4 . 96, 68 . 53  X  5 . 52 and 47 . 76  X  2 . 53 respec-tively (where the loss has been scaled to lie between 0 and 100). For the overlap loss, the best test loss is 44 . 93  X  1 . 84, 47 . 26  X  3 . 87 and 42 . 27  X  3 . 64 respec-tively. While the improvement in the overlap loss is not statistically significant according to paired t-test, the improvement in the 0/1 loss is statistically signifi-cant with p &lt; 10  X  4 .
 6.2. Action Detection Problem Formulation. The aim of this application is to learn human action models that predict the ac-tion class (for example,  X  X unning X  or  X  X umping X ) and the location of the person present in an image. Similar to object detection, a fully supervised dataset would re-quire annotating each training image with the person bounding box. Instead, we use image-level labels that indicate which action is being performed by a person in the image. Formally, for each sample, the input x is an image. The output y  X  { 0 , 1 , , c  X  1 } , where c is the number of action classes. The latent variable h models the tight bounding box around the person in the image. The joint feature vectors are the Poselet descriptor (Maji et al., 2011) of the bounding box. We consider approximately 20 putative bounding boxes for each image, which are obtained automatically using a standard person detector (Felzenszwalb et al., 2008). The small search space for the latent variables avoids the need for approximate inference. Once again, we report results using both 0/1 loss and overlap loss. Dataset. We use the pascal voc 2011  X  X rainval X  dataset (Everingham et al., 2010), which consists of approximately 2500 images of 10 different action classes. We split the images of each class into ap-proximately 60% for training and 40% for testing, and report results using 5 folds. In addition to the de-tected persons, we introduce the largest ground-truth bounding box into the latent variable space.
 Results. Figure 2 shows the test loss for the three methods, computed using ground-truth labels and bounding boxes. For 0/1 loss, the best test loss over all C values for lsvm , ilsvm and our method is 93 . 18  X  1 . 95, 92 . 89  X  3 . 70 and 76 . 10  X  0 . 71 respec-tively. For overlap loss, the best test loss is 70 . 66  X  0 . 76, 71 . 33  X  1 . 14 and 67 . 16  X  0 . 32 respectively. Our method significantly outperforms both lsvm and ilsvm , as confirmed by the paired t-test with p &lt; 10  X  3 . We proposed a novel framework for parameter estima-tion using weakly supervised datasets. Our framework consists of two distributions: a conditional distribution that captures the uncertainty in the latent variables, and a delta distribution that predicts the output and latent variable values. The parameters of the distri-butions are learned by minimizing a loss-based dis-similarity coefficient between the two distributions for all samples in the training dataset. We empirically demonstrate the benefit of our approach over previous loss-based learning frameworks using publicly available datasets of two challenging problems X  X bject detec-tion and action detection.
 The proposed optimization requires the computation of the expected loss  X  i ( y , h |  X  ) (shown in equation (7)) when learning the delta distribution and the loss-dependent subgradient g t (shown in equation (17)) when learning the conditional distribution. In spe-cial cases (for example, low tree-width models), these terms can be computed exactly. In general, we would have to resort to one of several existing approximate inference techniques or to design customized algo-rithms to compute the sufficient statistics. Note that, since the conditional distribution is not used during testing, an approximate estimate of its parameters, which is able to accurately model the uncertainty in the latent variables, would suffice in practice. Acknowledgments. This work is partially funded
