 In distributed software development, two sorts of dependencies can arise. The structure of the software system itself can create dependencies between software elements, while the structure of the development process can create depe ndencies between software developers. Each of these both shapes and reflects the development process. Our research concerns the extent to which, by looking uniformly at artifacts and activities, we can uncover the structures of software projects, and the w ays in which development processes are inscribed into software artifacts. We show how a range of organizational processes and arrangements can be uncovered in software repositories, with implications for collaborative work in large distributed groups such as open source communities. D.2.2 [ Software Engineering ]: Design Tools and Techniques  X  user interfaces. D.2.10 [ Software Engineering ]: Design  X  representation. H.5.3 [ Information Systems and Presentation ]: Group and Or ganizational Interfaces  X  computer -supported cooperative work.
 Design, Human Factors, Measurement.
 Social networks, software repositories, data mining, socio -technical systems. Studies of the social organizati on of technical work have repeatedly drawn attention to the complex interactions between social practice and technological artifacts [e.g. 2, 24, 31]. The artifacts that mediate and support technical work reflect not just technical constraints and needs bu t simultaneously reflect working arrangements, divisions of labor, and aspects of expected practice. This dual role is exhibited not simply by technological hardware, but by other  X  X echnical X  artifacts such as classification schemes and formal representati ons. For example, Bowker and Star [4] discuss the social embedding of classification schemes. Drawing on a number of examples, but most particularly the International Classification of Diseases, they illustrate how classification schemes reflect a social order as much as a natural order, making the phenomena they describe amenable to forms of analysis, interpretation and computation that reflect the social arrangements of the work. Lynch [25, 26] explores the central role of image -making in scientific pra ctice and communication, and discusses the  X  X endering practices X  by which features of messy reality are transformed into more portable and broadly consumable visual forms, designed again for particular sorts of comparison and discussion. Fujimura [17] desc ribes how scientific discoveries are transformed into standardized packages of techniques and technologies that allow them to be moved between sites, and which in turn influence how scientists see problems as  X  X o -able X  and amenable to particular solution a pproaches.
 Latour refers to this phenomenon as  X  X nscription X  X 23]. Drawing on anthropological studies of scientific laboratory practice [24], he describes how social arrangements, debates, divisions of labor, and patterns of work become inscribed into the a rtifacts and representations in which science trucks. Inscription is a process through which social practice and technological artifacts become inextricably intertwined. For example, standardized processes imply divisions of labor, standardizations of skil l, etc. [34]; formal models imply ways of uniformly disambiguating between  X  X nteresting X  and  X  X ninteresting X  (or  X  X elevant X  and  X  X rrelevant X ) phenomena [3]; instruments and devices imply particular ways of working and available infrastructures [33]; and me thods and models create conventional and acceptable ways of formulating problems [17, 18]. One domain of technological practice that has been of particular interest to researchers in CSCW is software systems development [13, 20, 21]. Inscription issues ar e particularly relevant to software development practice, since software artifacts are pure inscriptions; free from traditional physical constraints, they are written forms that describe the forms and patterns of software system structure and operation. So ftware mechanisms are, in general, subject to much less external constraint than physical mechanisms, which is a source of tension in joint hardware/software development teams [32]. In short, there are very many different ways of producing working software systems. The discipline of Software Engineering is, arguably, primarily concerned with developing software systems that satisfy not simply internal functional constraints but also external constraints of modularity, reusability, maintenance, comprehensibi lity, documentation, etc, which themselves reflect organizational and social expectations of how, where, when, and why the software system may be used. For instance, Conway [9] recognized over 30 years ago that the structure of the system mirrors the struc ture of the organization that designed it, while Parnas defined a software module as  X  X  responsibility assignment rather than a subprogram X  [29]. Software development, then, is a particularly fruitful domain in which to study the relationship between tech nological artifacts and the social structures that shape them. It is this relationship that drives the work presented here. In particular, we want to explore aspects of the relationship between software artifacts and software development processes. Althou gh processes are more or less well -defined in formal organizations, informal software development, such as that associated with the free and open source software movement, has a different character. Open source projects must essentially produce their own s tructures. These structures are emergent rather than formal, implicit in the development practice rather than explicitly codified. While this allows open source projects to be flexible, it also makes them more complicated for participants to understand or explain; software development processes are a means for organizational accountability as well as organizational regulation [19]. Our work has been motivated by the question of whether aspects of informal software process can be found in the structure of th e software artifact itself. Using a software visualization tool, Augur, we have been conducting an analysis of the artifacts of a number of software projects, a  X  X oftware archeology X  to explore the relationships between artifacts and activities as they are negotiated in distributed software development through mining software repositories. The paper is structured as follows: in the following section we discuss in greater detail the sources of complexity in software development. Next, we present our visuali zation -based approach for analyzing software projects. We then explore open -source software projects in greater detail with examples. Finally, we discuss the implications of our results for the understanding of open -source projects, followed by some conclu ding remarks. Software development teams face two sources of complexity in their work  X  the complexity of the artifact, and the complexity of the activities that surround it. By the complexity of t he artifact, we mean the inherent complexity of the software system  X  the appropriate design and use of algorithms, architecture, structure, parallelism, scale, dynamic behavior, etc. The creation of software is a skilled practice, and much of this skill i s in understanding the opportunities and limitations of different approaches to technical problem -solving and different software designs. This sort of complexity is inherent in software system design; it characterizes even the creation of small -scale softw are systems by individuals, such as in programming assignments to be solved by students, personal programming projects, etc, and many empirical studies of programming practice have pointed to aspects of the problem -solving process [e.g., 11]. However, sinc e most professional software development (and even much amateur software development, in the open source world) is conducted not by individuals but by teams, then a second source of complexity arises  X  the complexity of the development activities themselve s. By this we mean the complexity introduced by the fact that multiple people are creating and modifying the software system at the same time, requiring developers to coordinate parallel and distributed work, identify, avoid and recover from conflicts, ant icipate problems, share goals, formulate strategies, and achieve a coherent concerted effect. Many empirical studies of software development teams focus on these coordination problems [e.g. 22].
 Many researchers have studied the complexity of software deve lopment practices with an eye to developing new technologies that can help developers deal with these complexities. Reflecting these two sources of complexity, two technological strategies have emerged to deal with them and help developers in their day to day work The first focuses on the complexity of software artifacts, and attempts to give software developers better tools for understanding, interpreting and manipulating the software artifact itself. For example, many forms of software analysis help the p rogrammer to understand the structure of the software system. Software systems exhibit two forms of structure, static and dynamic. The static structure of the software system concerns the relationship between the units that the programmer creates  X  classes , methods, modules, variables, and other components out of which software systems are built. The dynamic structure of a software system concerns how this program will give rise to a running process  X  where the program X  X  static structure specifies potential action, the program X  X  dynamic structure concerns actual behavior. Each of these may be analyzed and made available to software developers as ways to help them in the process of software development. For instance, static analysis can uncover certain kinds of potential security concerns [35] and uncover potential error states that might arise at run -time, as well as helping programmers understand the relationship between different elements in the software system [5]. Dynamic analysis can be used to create pr ofiles of a program X  X  run -time behavior, determining which elements of the program consume the majority of memory, activity, etc. Especially when programs grow large, providing automatic tools to understand these structural properties of software systems c an relieve developers of a considerable practical burden, and can help them to create systems that operate effectively.
 The second focuses on the complexity of development activities. These tools are, perhaps, more familiar to researchers working in Comput er -Supported Cooperative Work, since the mechanisms that have been developed to support software development have also been applied in other domains. The most widespread set of tools are those based on formal descriptions of the software development proces s  X  models that specify how the software development task is broken down into a series of sub -tasks, and how those subtasks are to be coordinated. Configuration Management (CM) systems describe how software systems are arranged, and the relationship betwee n elements within a development process; they enforce rules that prevent simple conflicts from taking place by regulating access to the software artifact under construction (ensuring that only one developer can be working on a specific module at a time, fo r example.) Like workflow systems, these process -based software development systems impose an order on the software development activities in order to prevent breakdown situations from arising. An alternative approach has been to support more open -ended fo rms of coordination based on mutual visibility, awareness, and end -user coordination rather than formal process -based coordination. Of course, these two modes of operation are not exclusive. Grinter has particularly drawn attention to this issue; in her em pirical studies of software engineering, she has noted how users of CM systems use the information it provides to maintain an informal awareness of each other X  X  activity and to interpret and anticipate potential consequences for their own [19].
 However, al though these two sources of complexity (the artifacts and the development process) are typically addressed in isolation, empirical studies of software development practice suggest that, for programmers and developers, they manifest themselves as part of a common problem. For example, one of our recent studies looked at a team of software developers engaged in the maintenance of a software system called MVP [12]. This team used a state -of -the -art CM tool to manage their coordination issues surrounding the ch anges in the source code. However, in addition, they had to adopt an email convention that advised developers to send an email to the team X  X  mailing list with a brief description of the impact that their work (changes) would have on other X  X  work. By doing that, MVP developers allowed their colleagues to prepare for and reflect about the effect of their changes. This suggests that the software artifact being developed and its development activities need to be somehow integrated. In this case, the source -code dependencies affected the software development activities adopted by the MVP team. Aiming to address this problem by providing developers with a more comprehensive view of the software development process we developed Augur, that brings together views of the artifact and views of its surrounding activity. Augur is explored in the next section. The explorations that we describe here have been conducted using a tool called Augur, a system for visualizing software systems [16] . Augur is a visualization system based on the Seesoft paradigm [15], in which properties of the software system are mapped to color and other features of a graphical display of the source code itself. For instance, in the most common case, we might show a n overview of the system in which each line of source code is represented by an equivalent line of pixels, colored to indicate how recently each line was modified. This view allows a developer or manager to see which areas of the system are  X  X ctive. X  Our initial system, described elsewhere [16], integrated simple code analysis with analysis of activity records, and made these accessible in a single visual frame providing coordinated views. In addition to displaying the pattern of activity over the source c ode, it also displays aspects of the structure of the source code. This coordinated view allows developers to understand the character of the activity carried out  X  not just that a modification has been carried out, but what sort of a modification it is ( the addition of a new method, code  X  X ommented out X , a revision to existing functionality, etc.) 
Temporal view of weekly developer activity.
 The basic Augur interface is shown in Figure 1 . Each pane displays a differ ent aspect of the system being examined: changes in one view are immediately reflected in the others. The large central pane shows the line -oriented view of the source code. In the figure, the color of each pixel line indicates how recently it was modified ; this allows a developer, at a glance, to see how much activity has taken place recently and where that activity has been located.
 In our informal evaluations, developers involved in distributed software development projects relied upon both the activity information and the structure information in coordination to develop a holistic view of software development activity.
 As noted above, Augur was originally developed as a tool for software developers, providing them with a flexible visualization of system activity. However, as we explored the range of ways in which people used the tool, and the set of extensions that they proposed, we found that it might provide value too as an analytic tool. In particular, as users asked for mechanisms that would help them explore the structure of the system with finer granularity, we noted that these structures might also provide the basis for an  X  X rcheological X  exploration of a software repository. In our more recent work, we have been extending the richness of the repres entations that Augur provides, in response both to user requests and to the new opportunities for analysis. In particular, we have been exploring the use of call -graph analysis and network analysis as ways of forming richer pictures of distributed developm ent activities. Insights from our previous fieldwork with commercial software development [13] also suggest this avenue of research. The original version of Augur incorporated only a simple static form of structural analysis, one that c lassified lines of code according to their type, and so allowed a developer to see each line of code in terms of the larger structures within which it was embedded. In our more recent versions of the system, we have begun to augment this view with informat ion that explores the dynamic structure of code.
 In particular, we have incorporated call -graph analysis. A call graph is a data structure that describes which elements of a software system make use of which other elements. Software systems are constructed in terms of procedures (or  X  X unctions X  or  X  X ethods X ), which may in turn make use of the results of other procedures, just as, in mathematics, a function can be defined which makes use of the results of other functions (e.g. if f(x) = sqrt(x) + 1 , then the function f makes use of the function sqrt ). A call graph lists all the procedures in a software system, and, for each procedure, shows what other procedures it makes use of.
 A call graph, then, reveals the potential dynamic structure of a software system, although it can be derived using static analysis techniques (i.e., it can be extracted directly from the source code, without examining a running instance.) More importantly, in demarking dependencies within the code (between one procedure and another), i t also begins to suggest dependencies within the development team (between the maintainer of one procedure and the maintainer of another) [13]. The relationship between members of the development team is made more explicit in the network view. In this view, Augur draws views of the network of contributors to a project, relating them according to patterns in their development activity. For example, a simple graph shows the relationship between project members who have contributed code to th e same modules. This view abandons the source code as the primary spatial framework for displaying activity information; instead, it adopts a conventional graph (node and line) structure to show the relationships between people directly.
 The network view c an use different graphical properties to indicate different features of the relationship between individuals. For example, in the graphs shown in Figure 1 , each node (circle) represents a specific individual, while the lines betwe en the circles indicate that the developers have both contributed code to the same module. The size of the circle indicates how many lines of code someone has contributed, while the thickness of the line indicates how many lines they have contributed to fi les in common. Finally, the color of the lines indicates how recent this activity is, with brighter colors indicating more recent activity. While useful individually and in combination with the other views that Au gur provided, we found that these two perspectives could be fruitfully combined to tackle the problem noted in our earlier empirical work  X  that is, the ways in which software developers must orient towards dependencies between their own work and the work of others.
 Essentially, these perspectives highlight two sets of relationships in the software development process  X  the relationships between elements of the system (in particular, dependency relationships between different components), and relationships between the people who work on those components. Bringing these together begins to uncover the ways in which dependencies between parts of the software system can reflect or lead to dependencies between the developers themselves. They provide a technical m eans to explore the question that we raise at the start of this paper  X  that is, the extent to which software artifacts have inscribed into them patterns of interaction and participation. Augur, with these facilities, allows these questions to be explored empirically.
 There are two ways in which we have been exploring this. First, we have combined the two sources of information to replace the module -dependency graphs that arise from the call -graph analysis with author -dependency graphs that detail the relat ionships between authors. In particular, this allows us to resolve some problems that the engineers in our field study need to resolve, which is to determine who is likely to be affected by upcoming changes (or, conversely, whose work is likely to have an impact upon my own.) Second, by using the revision history features of the underlying CM system, we are able to look at patterns in the evolution of both technical and social structure of the system  X  how people join and leave a project, how participation patterns change over time, and how these changes might be related to the evolution of the software system itself. The particular focus for our analysis is open source software development. Open source is an approach to software system development in which loosely -knit collections of volunteers, collaborating over the public Internet, create sof tware systems whose source code is available to all (rather than being protected as a trade secret, as it is in most commercial development.) Proponents of open source development models claim many advantages for this approach, both practically and politic ally, including faster and more responsive development cycles, and more secure and robust software products. Unencumbered access to the source code and the development process is the central feature of the open source model, although its details vary from project to project. Although it is most commonly associated with non -commercial software development, many open source projects are at least partially funded by commercial activities and involve professional software developers whose participation is spons ored by their employers [36]. However, since open source projects exist either partly or entirely outside an organizational context, development processes and procedures do not follow organizationally mandated models [1]. Indeed, in advocating open source development models, open source analysts explicitly contrast regularized management and oversight (what is called the  X  X athedral X  approach) with the more informal and ad hoc arrangements of open source projects (the  X  X azaar X ). Since open source projects m ust, therefore, evolve their own working arrangements and means of enforcing them, they are a particularly interesting object of study. This section describes different analysis that we performed in different open -source projects using Augur, in particula r combining network and software structure, as discussed in the previous section. By looking at the networks of relationships between developers as indicated by dependencies between code modules, we can see how different approaches to pro ject organization are reflected or  X  X nscribed X  in the source -code itself of each project. In a centralized approach, the control is potentially reflected in a call -graph structure where other developers X  code is called by the  X  X rchitect X  X  code. This develo per X  X  code is the  X  X lue X  that connects the whole project together, all other developers X  code does not interact among themselves. That is not to say that the other code is not important nor relevant, we are just arguing that the architect X  X  code is the one integrating the whole project. Figure 2 a illustrates this example; it is possible to identify a high degree of centralization around developer  X  X t78, X  the  X  X rchitect X  developer in this project. Figure 2 b illustrates a different structure, which we call d ensely networked . Instead of a single developer being responsible for integrating the whole project, now, this responsibility is evenly divided among a group of six different developers with a high degree of interdependence between them. There is no centra l  X  X rchitect X , but a group of developers interconnected. These densely networked projects are marked by a high degree of interdependence between different modules and developers, often approaching a  X  X ully connected X  state in which each developer depends o n the code of each other developer. The degree of participation may vary (it is rare for all members of the project to contribute equally, and a set of primary developers normally emerges), but they cannot be easily distinguished in terms of their particul ar roles and responsibilities as developers. Finally, Figure 2c shows a variation of the previous structures where not only a core of seven developers strongly connected can be found, but also a medium sized set of other four developers in the periphery o f the project, that is, whose code does not interact. In this case, called the core and periphery division, a core phalanx of major developers are surrounded by a peripheral set of developers, less strongly connected. Note, again, that this is not a distin ction between degrees of participation, but between forms of participation, as characterized by the interdependencies of the work. This is not an arrangement where a core group of developers is doing the majority of the work; rather, it is an arrangement w here a core set of developers generate code that is strongly interdependent, while a peripheral set of developers tend to be more isolated from each other. We can further distinguish between various forms of peripheral par ticipation. By tracing dependencies, we can see whether peripheral members are dependent on core members, or vice versa. Clearly, in some cases, the dependencies are mutual; these often characterize a peripheral developer who is playing a traditional role in the project, yet tends to be responsible for only some small portion of the system. More interesting, perhaps, are peripheral participants whose connection to the core is a one -way dependency; either core modules depend on peripheral ones, or peripheral ones on core modules. Dependency, in our case, is a call from one component to another (or form the components of one developer to those of another.) So, peripheral modules that are called from core modules is a structure that is often associated with pl ugins, extensible component -based systems, or other systems in similar styles. In this case, a peripheral developer might develop a relatively self -contained module, which must be activated from the system core. We typically see, then, that the core develo pers, whose code is tightly interdependent, are associated with central functionality; the plug -in or self -contained module is peripheral in both functionality and in connectedness.
 The inverse relationship characterizes a peripheral developer whose periph eral relationship is one of dependence on core functionality. Most commonly, we find this when a developer writes a test case, a novel user interface or application, or some other  X  X rapper X  function that calls or relies upon the functionality of the rest o f the system . Earlier discussions of core and periphery focus on static structure, but we are interested in the dynamics of software processes, and in how participation shifts between core and peripheral participation. This phenomenon has been classified as both a learning and a political process, where one has to identify allies that back up a developer,  X  X ust like a statement in a scientific paper when it is accompanied by a large number of references and citations X  [14].
 This shift can be observed by examining the same open -source project at two different moments. By looking at the dependency structures in the source code, we can identify a developer X  X  contributions and their impact. In a shift from the periphery to the core, we expe ct to identify developers who initially contribute code that performs some function by calling others X  code. When these developers become more and more important in the project, their code starts to be called by other developers. Figure 3 illustrates this in the project Megamek developer Hawkprime was located on the edge of the project, as measured by connections in the network. At left, he is connected to one other developer through his code (indicated by the directions of the interdependenci es edges: from Hawkprime to the other). The reason for this is that BMazur is the principal interface author, consequently more central than Hawkprime. Later (right), Hawkprime assumes a more central role in the project. Now, he is also a source of depende ncies because he is the author of an interface being implemented by others ; now, other developers depend on his work. Furthermore, instead of only being connected to one other developer, he is now connected to six of them. Again, the shift can be noticed b ased on the relative importance of the code being contributed. Using a similar approach, we identified the opposite effect, a developer X  X  shift from the core to the periphery of another project, ANT 2 . This time, the developer Umagesh initially had a centr al participation in the project. This can be observed by the five edges directed to him in the graph. Later, Umagesh shifted to the periphery of the project ( Figure 4 ). http://megamek.sourceforge.net http://ant.apache.org/ As in previous examples, the important issue here is not so much that these shifts tak e place; the movement of people between peripheral and central positions is both common -sense and empirically well observed. The important issue is the way in which it can be found in the data record; that is, that the pattern of participation is manifest within the inscription, and can be analyzed structurally through dependency analysis of the software artifacts. One of the arguably factors leading to open -source success is the freedom in allowing developers to join and leave open sourc e projects. Some authors indeed use the term active developers to indicate the developers who have contributed to the project in a specified time period. Of course, authorship information extracted from the configuration management repository will provide this information for those interested. Figure 5 shows these transitions for two separate project s . This figure displays a bipartite graph where square nodes are authors and the slim, oval nodes are files. Author nodes are never connected directly to one an other but instead are connected through their relationship to shared source files. The file node, then, becomes the link between author nodes. Figure 5a (left) , this project (sugarcrm 3 ) relied on a few authors who implemented nearly all components in the s ystem. More recently, however, work has been split among five or six different authors, as indicated by the different colors in the right side of Figure 5a . That is, code in the system initially developed by one author has shifted ownership over time to ot her authors.
 Adopting the same approach, we identified an author domination effect, where the code starts out owned by multiple authors and then a developer begins to take over ( Figure 5 b ) . In this case, the green and yellow authors X  code has begun to perv ade nearly every aspect of two separate sub -modules in the project parrot Finally, our last observation is with regards to patterns of stability and change in open source projects. For this example, we use data from the Python 5 project to explore stability and change within the context of the file tree structure of the project. Files and packages are nodes in this graph colored by authors. They are linked by containment relationships (between a package and a file). There is no connection between two files.
 These graphs show how the structure of the source code (its organization in packages) is being used to structure the activities of the developers. For instance, Figure 6A describes a particular part of the source code in itially implemented by a single developer. Later in the project, Figure 7A, it is possible to note that this developer remains the sole author of that module . That is, there was no change in the authorship of that code from one time snapshot to another . In contrast, part B of Figures 6 and 7 reveal how the authorship of code changes over time . Initially, in Figure 6B, the highlighted section was primarily authored by one author, but overtime, this section was distributed amongst many authors. http://sugarcrm.sourceforge.net http://cvs.perl.org http://www.python.org/ Augur provid es us with a way to place software modules and software developers within the same frame of reference, and describe their relationships. By analyzing dependencies and activities, it highlights not just the links between people and code, but the links betwe en people and others through code, and vice versa. This homogeneous analytic perspective is reminiscent of the actor -network approach [6, 7, 8, 23]. Actor -Network Theory maintains a deliberate agnosticism as to sources of agency, and insists that human and technological  X  X ctants X  be given analytic parity. Latour [23] points out that functions embedded in social settings may also be delegated to technology; for instance, rather than have a policeman monitor road traffic to ensure conformance with speed limit s, we can lay down  X  X peed bumps X  to achieve the same effect. (In the UK, speed bumps are sometimes known as  X  X leeping policemen, X  in vivid testimony to the potential relationship between physical and social elements.) Technological arrangements, as much as social arrangements, can be used to produce control and conformance with social norms. Actor Networks, then, bring together heterogeneous elements, including technologies, artifacts, and people.
 Latour and Woolgar discuss the social processes that shape s cientific practice and discourse [24]. Scientific processes, he suggests, are a means to  X  X elete modalities, X  that is, to remove the conditions on truth statements. So, through this process, statements of the form  X  X n the fourth experimental run, a correla tion was observed between inputs and outputs X  might be transformed into  X  X ur research suggests that outputs are proportional to inputs X , which in turn can be transformed into  X  X  = k.I X ; at each stage, some of the conditional elements are removed, and more universal statements can be made. Part of successful scientific practice, then, is the construction of networks that can help to  X  X tabilize X  particular results, deleting modalities by establishing the reliability of observations, results and conclusions. I n this view, prestigious institutional affiliations, sensitive laboratory equipment, experimental verification, and solid theoretical foundations are not simply historical or technical; they are elements in the network, playing a strategic role in the stab ilization of scientific facts.
 One concept arising from this perspective on scientific processes is that of the  X  X bligatory passage point X   X  a narrowing of the network that designates some particular element as one that must be navigated in order to achiev e a result. As befits the homogeneous treatment of heterogeneous elements in actor -network theory, this might be any sort of entity. Professional certification might play such a role, for example; so might a particular theory, a scientific leader, a partic ular laboratory, and so forth. We can see how this can operate in open source domains. Figure 6 -Stability and Changes -First Moment In general, the relevance of these concepts to the work present ed here is the light that they cast on the interplay between social and technical in distributed activities. A number of authors have explored aspects of the social structure of open source projects [10, 27, 28, 36]. Our approach has been to look at the wa ys in which aspects of the social and organizational structure are both inscribed into and achieved through the technological organization of the underlying artifact, the software source code. The central lesson here is two -fold. First, that while the rhet oric of open source is of openness and access, the practice of open source is about closedness and regulation; essentially, a central consideration in managing a successful technical project is to ensure the consistency and quality of the technological art ifact under production, which is managed by vetting both contributors and contributions, and so a structure must be produced by which such a vetting can be achieved. Second, this structure is manifest collectively by the social and technical organization o f the project. The same engineering principles by which software systems can be organized to achieve technical properties (modularity, extensibility robustness, etc.) are also ones by which activities can be partitioned and managed, and access to the syste m limited. What we see in these examples, then, is essentially the emergence of obligatory passage points within software development practices. Those points may be technical or human elements. As presented among the forms of peripheral participation, ther e may be a particular module or component into which others must be hooked; a dispatch table, an event loop, or so forth.
 That these structures should emerge in successful software projects is not surprising; these projects, after all, require careful coor dination, and some mechanisms are needed to ensure that this takes place. That they should emerge within open source projects, while not surprising, is nonetheless interesting , in light of the open source movement X  X  focus on participation and accessibility . What is particularly interesting, though, is that these processual elements of software production can, themselves, be found within the software structures that are the focus of activity. While Latour and others argue that processes and social structures are inscribed into scientific and technical artifacts, our experiences with Augur point to the ways in which, for software artifacts, they might be  X  X ead off X  again. Our empirical examinations demonstrate that both software components (modules) and softwa re developers can act, for example as obligatory points of passage; the structure of a software project both reflects and constrains the development process. An important piece of further work concerns the automatic recognition and extraction of these patt erns; our work was oriented first towards determining whether process patterns could be found within software repositories. The answer is yes. Distributed software development presents two sources of complexity to its participants  X  the complex ity of the software artifacts under development, and the complexity of the process of developing those artifacts. We have presented a study of software artifacts, conducted using a visualization tool, which demonstrates how these twin sources of complexity are intertwined. Software artifacts are not merely the objects of software development processes, but are also the means by which those processes are enacted and regulated. The structure of the artifact both reflects the processes by which it has been cre ated and can be used to control those processes by centralizing points of access, by regulating the relationships between independent activities, and by making visible the relationships between individuals. It is a means, then, by which the articulation wo rk of the project can be carried out [30].
 The intertwining of artifacts and activities is no surprise to CSCW researchers, of course. What is of interest here is to see how it happens in one particular case. Free and open source development is a particula rly enlightening domain within which to study these concerns. On a mundane level, the artifacts of open source development are easily available; but more significantly, the inter -or extra -organizational context of much open source development means that t he tools of the trade  X  CM systems, web sites, and the source code itself  X  are the site at which access and activity structure are negotiated. In particular, we have shown how both individuals and software components may act as  X  X bligatory passage points , X  constrictions in the loose network of artifacts and activities that can be used to achieve local and partial stabilizations of dynamics socio -technical settings. Further, we have shown the use of computational tools to help make these structures visible .
 Our approach has been methodologically unusual, since we have been conducting, essentially, an  X  X rcheology X  of software development processes. The critical next step is a more immersive engagement with large -scale distributed software development enterpr ises, in order to gain a better understanding of these processes  X  X lose up. X  These open source settings provide a valuable site for examining the evolution of practice around technological artifacts  X  a central consideration for CSCW. Our explorations dem onstrate that software artifacts can reveal the relationship between technical and social structure of large -scale development projects, and so suggest that collaborative tools can exploit not only technical but also social structures in supporting collabo rative software development. This work was supported in part by the National Science Foundation under awards IIS -0133749, IIS -0205724 and IIS -0326105, by Intel Research, and by the Brazilian Government under CAPES grant BEX 1312/99 -5. [1] Adler, P. (2003). Practice and Process: The socialization of [2] Bannon, L. &amp; B X dker, S. 1999. Constructing Common [3] Bowers, J. 1992. The Politics of Formalism. In Lea (ed), [4] Bowker, G. and Star, S.L. 1997. Sorting Things Out: [5] Brooks, R. 1983. Towards a Theory of the Comprehension of [6] Callon, M. 1986. Some elements of a sociology of [7] Callon, M. 1986. The Sociology of an Actor -Network: The [8] Callon, M. 1991. Techno -Economic Networks and [9] Conway, M. E. (1968). "How Do Committ ees invent?" [10] Crowston, K. and Howison, J. 2004. The Social Structure of [11] Davis, S. 1990. The Nature and Development of [12] de Souza, C., Redmiles, D., and Dourish, P. 2003. Breaking [13] de Souza, C.R.B., Redm iles, D., Cheng, L. -T., Millen, D. and [14] Ducheneaut, N. "The reproduction of Open Source software [15] Eick, S., Steffan, J., and Sumner, E. 1992. Seesoft: A Tool [16] Froehlich, J. and Dourish, P. 2004. Unifying Artifacts and [17] Fujimura, J. 1987. Constructing  X  X o -Able X  Problems in [18] Fujimura, J. 1997. The Molecular Biological Bandwagon in [19] Grinter, R. 1995. Using a Configuration Management Tool to [20] Grinter, R. 1998. Recom position: Putting it All Together [21] Herbsleb, J. and Grinter, R. 1999. Splutting the Organization [22] Herbsleb, J., Mockus, A., Finholt, T. and Grinter, R. 2000. [23] Latour, B. 1994. Where are the missing masses? The [24] Latour, B. and Woolgar, S. 1979. Laboratory Life: The [25] Lynch, M. 1985. Discipline and the Material Form of [26] Lynch, M. 1988. The Externalized Retina: Selection and [27] Mockus, A.,, Fielding, R. and Herbsleb, J. 2000. A Case [28] O X  X ahoney, S. and Ferraro, F. 2004. Managing the [29] Parnas, D. L. (1972). On the Criteria to be Used in [30] Schmidt, K. and Bannon, L. 1992. Taking CSCW Seriously: [31] Schmidt, K and Wagner, I. 2004. Ordering systems: [32] Sharrock, W. and Button, G. 1997. Engineering [33] Star, S.L. and Ruhleder , K. 1994. Steps Towards an Ecology [34] Suchman, L. 1983. Office Procedures as Practical Action: [35] Wagner, D. and Dean, D. 2001. Intrusion Detection via Static [36] West, J. and O X  X ahoney, S. 2005. Contrasting Community 
