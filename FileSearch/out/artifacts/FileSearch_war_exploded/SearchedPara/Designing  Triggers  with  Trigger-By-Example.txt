
Triggers provide a facility to autonomously react to database events by evaluating a data-dependent condition and by executing a reaction whenever the condition is satisfied. Such triggers are regarded as an important database feature and are im-plemented by most major database vendors. Despite their diverse potential usages, one of the obstacles that hinder triggers from their wide deployment is the lack of tools that aid users in creating complex trigger rules. In many environments, the correctness of the written trigger rules is crucial since the semantics encoded in the trigger rules are shared by many applications. Although the majority of the users of triggers are DBAs or savvy end-users, writing correct and complex trigger rules is still a daunting task.
 introduction decades ago and its variants ar e currently being used in most modern database products. As it is based on domain relational calculus, its expressive power proves to be equivalent to that of SQL, which is based on tuple relational calculus (Codd 1972). As opposed to SQL, in which the user must conform to the phrase structure strictly, QBE users may enter any expression as an entry insofar as it is user can only specify admissible queries (Zloof 1977). We proposed TBE (Trigger-By-Example) (Lee et al. 2000b) as a novel graphical interface for writing triggers.
Since most trigger rules are complex combinations of SQL statements, by using QBE as a user interface for triggers the user may create only admissible trigger rules. TBE uses QBE in a declarative fashion for writing the procedural trigger rules (Cochrane et al. 1996). In this paper, we discuss the design and implementation issues of TBE .
Further, we present a design to make TBE a universal trigger rule formation tool that hides much of the peculiarity of the underlying trigger systems. However, it is worthwhile to point out that, in this paper, we do not address other important and arguably harder problems related to triggers (e.g., precise semantics of composite triggers, complex interaction among multip le triggers). A preliminary discussion of our work appeared in Lee et al. (2000a,b). This paper unifies and integrates these two research results.
 following subsections.
Triggers play an important role in monitoring and reacting to specific changes that occur to database systems. In SQL3, triggers , also known as event-condition-action discussion on the ANSI X3H2 SQL3 working draft (Melton (ed.) 1999). The fol-lowing is a definition of SQL3:
Example 1. SQL3 triggers definition. 1.2. QBE (Query-By-Example)
QBE is a query language as well as a visual user interface. In QBE , programming is done within two-dimensional skeleton tab les. This is accomplished by filling in an example of the answer in the appropriate ta ble spaces (thus the name  X  X y-example X ).
Another two-dimensional object is the condition box , which is used to express one or more desired conditions difficult to express in the skeleton tables. By QBE conven-tion, variable names are lowercase alphabets prefixed with  X  X  X , system commands are uppercase alphabets suffixed with  X .  X , and constants are denoted without quotes unlike SQL3. Let us see a QBE example. The following schema is used throughout the paper.

Example 2. Define the emp and dept relations with keys underlined. emp.DeptNo and dept.MgrNo are foreign keys referencing dept.Dno and emp.Eno attributes, re-spectively. Example 3 shows two equivalent representations of the query in SQL3 and QBE . Example 3. Who is being managed by the manager Tom?
The rest of this paper is organized as follows. Section 2 gives a detailed description of TBE . Then, Sect. 3 illustrates a few complex TBE examples. The design and implementation of TBE , especially its translation algorithms, are discussed in Sect. 4. Section 5 presents the design of some extensions that we are planning for the TBE .
Related work and concluding remarks are given in Sects. 6 and 7, respectively. We propose to use QBE as a user interface for writing trigger rules. Our tool is called Trigger-By-Example ( TBE ) and has the same spirit as that of QBE . The philosophy of
QBE is to require the user to know very little in order to get started and to minimize the number of concepts that he or she subsequently has to learn to understand and use the whole language (Zloof 1977). By using QBE as an interface, we attain the same benefits for creating trigger rules. 2.1. Difficulty of Expressing Procedural Triggers in Declarative QBE
Triggers in SQL3 are procedural in nature. Trigger actions can be arbitrary SQL procedural statements, allowing not only SQL data statements (i.e., select, project, join) but also transaction, c onnection, session statements. action statements needs to be obeyed faithfully to preserve the correct semantics.
On the contrary, QBE is a declarative query language. While writing a query, the user does not have to know if the first row in the skeleton tables must be exe-cuted before the second row or not. That is, the order is immaterial. Also QBE is specifically designed as a tool for only 1) d ata retrieval queries (i.e., SELECT), 2) data modification queries (i.e., INSERT, DELETE, UPDATE), and 3) schema definition and manipulation queries. Therefore, QBE cannot really handle other pro-cedural SQL statements such as transaction or user-defined functions in a simple manner. Thus, our goal is to develop a tool that can represent the procedural SQL3 triggers in its entirety while retaining the declarative nature of QBE as much as possible.
 design options were available, and which option was chosen by what rationale, etc. 2.2. TBE Model
SQL3 triggers use the ECA (Event, Condition and Action) model. Therefore, trig-gers are represented by three independent E, C, and A parts. In TBE , each E, C, and
A part maps to the corresponding skeleton ta bles and condition boxes separately. To differentiate among these three parts, each skeleton table name is prefixed with its corresponding flags, E. , C. ,or A. . The condition box in QBE is extended simi-larly. For instance, a trigger condition statement can be specified in the C. prefixed skeleton table and/or condition box.
 SQL3 triggers allow only INSERT, DELETE, and UPDATE as legal event types.
QBE uses I. , D. ,and U. to describe the corresponding data manipulations. TBE thus uses these constructs to describe the trigger event types. Since INSERT and
DELETE always affect the whole t uple, not individual columns, I. and D. must be filled in the leftmost column of the skeleton table. Since UPDATE event can affect individual columns, U. must be filled in the corresponding columns. Otherwise, U. is filled in the leftmost column to represent that UPDATE event is monitored on all columns. Consider the following example.

Example 4. Skeleton tables (1) and (2) depict INSERT and DELETE events on the dept table, respectively. (3) depicts UPDATE event of columns Dname and MgrNo . Thus, changes occurring on other columns do not fire the trigger. (4) depicts
UPDATE events of any columns on the dept table.
Note also that since the SQL3 triggers de finition requires that each trigger rule mon-itors only one event, there cannot be more than one row having an I. , D. ,or U. flag. Therefore, the same trigger action for different events (e.g.,  X  X bort when ei-ther INSERT or DELETE occurs X ) needs to be expressed as separate trigger rules in SQL3 triggers. the name box , where the user can fill in an arbitr ary identifier as shown below:
Typically, the user first decides the tri gger name and then proceeds to the subse-quent tasks. There are often cases when multiple trigger rules are written together in a single TBE query. For such cases, the user needs to provide a unique trigger name for each rule in the TBE query separately. In what follows, when there is only name in the interest of briefness.
The SQL3 triggers have a notion of the event activation time that specifies if the trigger is executed before or after its event and the granularity that defines how many times the trigger is executed for the particular event. 1. The activation time can have two modes, before and after .The before mode triggers execute before their event and are useful for conditioning the input data.
The after mode triggers execute after their event and are typically used to embed application logic (Cochrane et al. 1996). In TBE , two corresponding constructs,
BFR. and AFT. , are introduced to denote these modes. The  X . X  is appended to denote that these are built-in system commands. 2. The granularity of a trigger can be specified as either for each row or for each statement , referred to as row-level and statement-level triggers, respectively. The row-level triggers are executed after each modification to tuple, whereas the statement-level triggers are executed once for an event regardless of the num-ber of the tuples affected. In TBE notation, R. and S. are used to denote the row-level and statement-le vel triggers, respectively.
 Consider the following illustrating example.

Example 5. SQL3 and TBE representation for a trigger with after activation time and row-level granularity.

When an event occurs and values change, trigger rules often need to refer to the before and after values of certain attributes. These values are referred to as the transition values . In SQL3, these transition values can be accessed by either transi-tion variables (i.e., OLD , NEW ) or tables (i.e., OLD_TABLE , NEW_TABLE ) depending on the type of triggers, whether they are row-level or statement-level. Furthermore, in SQL3, the INSERT event trigger can only use NEW or NEW_TABLE , while the DELETE event trigger can only use OLD or OLD_TABLE to access transition values.
However, the UPDATE event trigger can use both transition variables and tables. We have considered the following two appro aches to introduce the transition values in
TBE . 1. Using the new built-in functions : Special built-in functions (i.e., OLD_TABLE() 2. Using modified skeleton tables : Depending on the event type, skeleton tables are modified accordingly; additional col umns may appear in the skeleton tables.
For the INSERT event, a keyword NEW_ is prepended to the existing column names in the skeleton table to denote that these are newly inserted ones. For the
DELETE event, a keyword OLD_ is prepended similarly. For the UPDATE event, akeyword OLD_ is prepended to the existing column names whose values are updated in the skeleton table to denote values before the UPDATE. At the same time, additional columns with a keyword NEW_ appear to denote values after the UPDATE. If the UPDATE event is for all columns, then OLD_ column-name and NEW_ column-name appear for all columns.
 Consider an event  X  X hen John X  X  salary i s doubled within the same department X .
Here, we need to monitor two attributes  X  Sal and DeptNo . First, the user may type the event activation time and granularity information at the leftmost col-umn as shown in the first table. Then, the skeleton table changes its format to accommodate the UPDATE event effect, as shown in the second table. That is, two more columns appear and the U. construct is relocated to the leftmost col-umn.

Then, the user fills in variables into the proper columns to represent the condi-tions. For instance,  X  X ame d epartment X  is expressed by using same variable _d in both OLD_DeptNo and NEW_DeptNo columns.
 We chose the approach using new built-in functions to introduce transition values into
TBE . Although there is no difference with respect to the expressive power between two approaches, the first one does not incur any modifications to the skeleton tables, thus minimizing clutteri ng of the user interface.
SQL3 allows the renaming of transition variables or tables using the REFERENCING construct for the user X  X  convenience. In TBE , this construct is not needed since the transition values are directly referred to by the variables filled in the skeleton tables.
When arbitrary SQL procedur al statements (i.e., IF, CASE, assignment statements, represent them in TBE due to their procedural nature. B ecause their expressive power is beyond what the declarative QBE , and thus TBE described so far, can achieve, we instead provide a special kind of box, called statement box , similar to the condition box. The user can write arbitrary SQL procedural statements delimited by  X ; X  in the statement box. Since the statement box is only allowed for the action part of the triggers, the prefix A. is always prepended. For example,
SQL3 allows multiple action statements in triggers, each of which is executed ac-cording to the order they are written. To represent triggers whose semantics depend on the assumed sequential execution, TBE uses an implicit agreement; like Prolog, the execution order follows from top to bottom. Special care needs to be taken in translation time for such action statements as follows:  X  The action skeleton tables appearing before are translated prior to that appearing  X  In the same action skeleton tables, action statements written at the top row are 2.9. Expressing Conditions in TBE
In most active database triggers languages, the event part of the triggers language is exclusively concerned with what has ha ppened and cannot perform tests on values associated with the event. Some triggers la nguages (e.g., Ode (Agrawal and Gehani 1989), SAMOS (Gatziu and Dittrich 1998), Chimera (Ceri et al. 1996)), however, provide filtering mechanisms that perform tests on event parameters (see Paton (ed.) (1998), Chap. 4). Event filtering mechanisms can be very useful in optimizing trigger module to avoid unnecessary expensive condition evaluations.
 ter filter (PF) type and 2) general constraint (GC) type. SQL3 triggers definition does not have PF type; event language specifies only the event type, activation time and granularity information, and all conditions (both PF and GC types) need to be expressed in the WHEN clause. In TBE , however, we decided to allow users to be able to differentiate PF and GC types by providing separate condition boxes (i.e.,
E. and C. prefixed ones) although it is not required for SQL3. This is because we wanted to support other trigger languages that have both PF and GC types in future. 1. Parameter Filter Type : Since this type tests the event parameters, the condi-tion must use the transition variables or tables. Event examples such as  X  X very time more than 10 new employees are inserted X  or  X  X hen salary is doubled X  in
Sect. 2.5 are these types. In TBE , this type is typically represented in the E. prefixed condition box. 2. General Constraint Type : This type expresses general conditions regardless of the event type. In TBE , this type is typically represented in the C. prefixed condition boxes. One such example is illustrated in Example 6.

Example 6. When an employee X  X  salary is increased more than twice within the same year (a variable CURRENT_YEAR contains the current year value), log changes into the log(Eno, Sal) table. Assume that there is another table sal-change(Eno, Cnt, Year) to keep track of the employee X  X  salary changes.

Here, the condition part of the trigger rule (i.e., WHEN clause) checks the Cnt value of the sal-change table to check how many times salary was increased in the same year, and thus, does not involve testing any transition values. Therefore, it makes more sense to represent such a condition as GC type, not PF type. Note that the headers of the sal-change and condition box have the C. prefixes.
 A trigger rule to maintain the foreign key constraint is shown below.
Example 7. When a manager is deleted, all employees in his or her department are deleted too.

In this example, the WHEN clause is deliberately missing; that is, the trigger rule does not check if the deleted employee is in fact a manager or not because the rule deletes only the employee whose manager is just deleted. Note how _e variable is used to join the emp and dept tables to find the department whose manager is just deleted. The same query could have been written with a condition test in a more explicit manner as follows: Another example is shown below.

Example 8. When employees are inserted into emp table, abort the transaction if there is one violating the foreign key constraint.

In this example, if the granularity were R. instead of S. , then the same TBE query would represent different SQL3 triggers. That is, row-level triggers generated from the same TBE representation would have been:
We believe that this is a good example illustrating why TBE is useful in writing trigger rules. That is, when the only difference between two rules is the trigger granularity, a simple change between R. and S. is sufficient in TBE . However, in
SQL3, users should devise quite different rule syntaxes as demonstrated above.
Suppose a company maintains the following view derived from the emp and dept schema.

Example 9. Create a view HighPaidDept that has at least one  X  X ich X  employee earning more than 100K.

The straightforward way to maintain the views upon changes to the base tables is to re-compute all views from scratch. Although incrementally maintaining the view is more efficient than this method, for the sake of trigger example, let us implement the naive scheme below. The following is only for an UPDATE event case. Example 10. Refresh the HighPaidDept when UPDATE occurs on emp table.
 By the implicit ordering of TBE , the DELETE statement executes prior to the IN-
SERT statement.
Now let us consider the problem of maintaining replicated copies in synchronization with the original copy. Suppose that all changes are made to the primary copy while the secondary copy is asynchronously updated by triggering rules. Actual changes to the primary copy are recorded in Delta tables. Then, deltas are applied to the secondary copy . This logic is implemented by five trigger rules below. The first three rules monitor the base table for INSERT, DELETE, UPDATE events, respectively, and the last two r ules implement the actual synchronization.
Example 11. Maintain the replicated copy dept_copy when the original dept table changes.

Note how multiple trigger rules (i.e., 5 rules) can be written in a unified TBE repre-sentation. This feature is particularly useful to represent multiple yet  X  X elated X  trigger
However, it is worthwhile to point out that TBE does not currently support ordering among multiple trigger rules.
A preliminary version of TBE prototype is implemented in Java using jdk 1.2.1 and swing 1.1 as shown in Fig. 1. More discussion about implementation-related issues can be found in Lee et al. (2000a).

Our algorithm is an extension of the algorithm by McLeod (1976), which trans-lates from QBE to SQL. Its input is a list of skeleton tables and the condition boxes, while its output is a SQL query string. Let us denote the McLeod X  X  algorithm as qbe2sql ( &lt; input &gt; ) and ours as tbe2triggers . 4.1. The qbe2sql Algorithm
We have implemented basic features of the qbe2sql algorithm in McLeod (1976), in the exception of queries having the GROUP-BY construct. The algorithm first determines the type of query statement. The basic cases involve operators, such as
SELECT, UPDATE, INSERT, and DELETE. Special cases use UNION, EXCEPT, and INTERSECT where the statements are p rocessed recursively. General steps of the translation implemented in TBE are as follows: 1. Duplicate tables are renamed. (e.g.,  X  X ROM supply , supply  X  is converted into  X  X ROM supply S1, supply S2 X ) 2. SELECT clause (or other type) is printed by searching through TBETables X  fields for projection (i.e., P. command). Then, FROM clause is printed from TBETable table names. 3. Example variables are extracted from TBE Tables by searching for tokens starting with  X  X  X . Variables with the same names indicate table joins; table names and corresponding column names of the variables are stored.
 4. Process conditions. Variables are matched with previously extracted variables and 4.2. The tbe2triggers Algorithm
Let us assume that _ v ar is an example variable filled in some column of the skeleton table. colname (_ v ar ) is a function to return the column name given the variable name _ v ar . Skeleton tables and condition or statement boxes are collectively referred to as entries . 1. Preprocessing : This step does two tasks: 1) reducing the TBE query to an equiva-2. Build event clause : Input all the E. prefixed entries. The  X  CREATE TRIGGER determine the activation time and granularity of the triggers. The event type can also be detected by constructs (e.g., I. , D. , U. ). If U. is found in the individual columns, then the  X  AFTER UPDATE OF &lt; column-names &gt; by enumerating all column names in an arbitrary order. Then, (a) Convert all variables _ v ar i used with I. event into NEW( _ (b) Convert all variables _ v ar i used with D. event into OLD( _ (c) If there is a condition box or a column having comparison operators (e.g., 3. Build condition clause : Input all the C. prefixed entries as well as the E. prefixed entries passed from the previous step. (a) Convert all built-in functions for transition values and aggregate operators into (b) Fill P. command in the table name column (i.e., leftmost one) of all the C. (c) Gather all entries into the &lt; input &gt; list and invoke the qbe2sql ( 4. Build action clause : Input all the A. prefixed entries. (a) Convert all built-in functions for transition values and aggregate operators (b) Partition the entries into distinct gr oups. That is, gather entries with identi-(c) For each group G i , invoke the qbe2sql ( &lt; G i
At present, TBE supports only SQL3 triggers syntax. Although SQL3 is close to its final form, many database vendors are alr eady shipping their products with their own proprietary triggers syntax. When multiple databases are interconnected or integrat-ing one database to another, these divers ities can introduce significant problems. To remedy this problem, one can use TBE as a universal triggers construction tool. The user can create trigge r rules using the TBE interface and save them as TBE  X  X  internal format. When there is a need to change one database to another, the user can reset the target system (e.g., from Oracle to DB2) to re-generate new trigger rules. ative fashion. That is, given a new triggers system, a user needs only to describe what kind of syntax the triggers use. Then, TBE should be able to generate the tar-get trigger rules without further intervention from the user. Two inputs to TBE are needed to add new database triggers: the trigger syntax rule and trigger composi-the triggers is encoded by the declarativ e language. In a trigger composition rule, information as to how to compose the trigger rule (i.e., English sentence) using the trigger syntax rule is specified. The behaviour and output of TBE conforms to the specifics defined in the meta rules of the selected target trigger system. When a user chooses the target trigger system in the in terface, corresponding trigger syntax and composition rules are loaded from the meta rule database into the TBE system. The high-level overview is shown in Fig. 2.
TBE provides a declarative language to describe trigger syntax, whose EBNF is shown below:
Although the detailed discussion of the language constructs is beyond the scope of this paper, the essence of the language has the form  X  X ommand as value X , meaning the trigger feature command is supported and represented by the keyword value .For instance, a clause NEW_TABLE as INSERTED for Starburst system would mean that  X  X tarburst supports statement-level triggering and uses the keyword INSERTED to access transition values X .

Example 12. SQL3 trigger syntax can be described as follows: event has ( ); condition has ( ); action has ( );
The interpretation of this meta rule should be self-describing. For instance, the fact that there is no clause S. as ... implies that SQL3 triggers do not support event monitoring on the selection operation. In addition, the clause T. as STATEMENT implies that SQL3 triggers support table-level event monitoring using the keyword  X  X OR EACH STATEMENT X .

The partial comparison of the trigger syntax of SQL3, Starburst, Postgres, Ora-cle and DB2 system is shown in Table 1. The leftmost column contains TBE com-mands while other columns contain equivalent keywords of the corresponding trigger system.  X  X /A X  means the feature is not supported and  X  X rue X  means the feature is supported by default. Using the language constructs defined above, these syntax can be easily encoded into the trigger syntax rule. Note that our language is limited to triggers based on the ECA and the relational data model.
After the syntax is encoded, TBE still needs information on how to compose English
In a trigger composition rule, a macro variable is surrounded by the $ sign and substituted with actual values during rule generation time.
 Example 13. The following is a SQL3 trigger composition rule:
CREATE TRIGGER $trigger-name$
In rule generation time, for instance, vari able $activation-time$ is replaced with the value either BEFORE or AFTER since those two are the only valid values according to the trigger syntax rule in Example 12. In addition, variables $condition-statement$ and $action-statement$ are r eplaced with statements genera ted by the translation al-gorithm in Sect. 4.
Past active database research has focused on active database rule languages (Agrawal and Gehani 1989), rule execution semantics (Cochrane et al. 1996), or rule man-agement and system architecture issu es (Simon and Kotz-Dittrich 1995). In add-ition, research on visual querying has b een done in traditional database research (Embley 1989; Zloof 1977; Benzi et al. 1999). To a greater or lesser extent, all of this research focused on devising novel vis ual querying schemes to replace the data retrieval aspects of SQL language. Although some have considered data definition aspects (Collet and Brunel 1992) or manipulation aspects, none have extensively con-sidered the trigger aspects of SQL, especially from t he user interface point of view. have attempted to build graphical triggers description tools, too. Using IFO can describe how different objects interact through events, thus giving priority to an overview of the system. Argonaut from the IDEA project (Ceri et al. 1996) focused on the automatic generation of active rules that correct integrity violation based on declarative integrity constr aint specification and active rul es that incrementally main-tain materialized views based on view definition. TBE , on the other hand, tries to help users directly design active rules with minimal learning.
 visual querying mechanism as well (Yao et al. 1984; Embley 1989). For instance,
Embley (1989) proposes the NFQL as a communication language between humans and database systems. It uses forms in a strictly nonprocedural manner to represent query. Other work using forms focused on the querying aspect of the visual interface (Collet and Brunel 1992). To the best of our knowledge, the only work that is directly comparable to ours is RBE (Chang and Chen 1997). TBE is different from RBE in the following aspects:  X 
Since TBE is designed with SQL3 triggers in mind, it is capable of creating all the complex SQL3 trigger rules. Since RBE X  X  capability is limited to OPS5-style production rules, it cannot express the subtle difference of the trigger activation time or granularity.  X 
Since RBE focuses on building an activ e database system in which RBE is only a small part, no evident suggestion of QBE as a user interface to trigger con-struction is given. On the contrary, TBE is specifically aimed for that purpose.  X 
The implementation of RBE is tightly coupled with the underlying rule system and database so that it cannot easily support multiple heterogeneous database trig-gers. Since TBE implementation is a thin layer utilizing a translation from a visual representation to the underlying trigge rs, it is loosely coupled with the database.
In this paper, we presented the design and implementation of TBE , a visual trigger rule specification interface. QBE was extended to handle features specific to ECA trigger rules. TBE extends the visual querying mechanism from QBE and applies it to triggers construction applications. Examples were given to demonstrate SQL3-based trigger rule generation procedures as well as the TBE to SQL3 trigger translation algorithm. Extension of TBE toward universal trigger rule interface was also included. For a trigger system T , we can declaratively speci fy the syntax mapping between
TBE and T ,sothat TBE can be used not only as a trigger rule formation tool, but also as a universal intermediary translations between supported systems.
McLeod (1976) has a QBE to SQL translation algorithm in notations somewhat dif-ferent (and obsolete) from what most current DB textbooks use. In this section, we clear up those confusions and re-write all example queries in the paper in a familiar notation. This is necessary since our tbe2triggers algorithm is based on the McLeod X  X  qbe2sql algorithm. First, examples ar e based on following schema:
In what follows, both the recommended QBE and SQL representations of the given query are presented. Note that there could be many other representations equivalent to what is presented here. We only showed here what we believe to be the most reasonable ones.

In this section, basic QBE queries and their SQL translation are introduced. The first qbe2sql implementation needs to be able to handle at least all the simple queries in this section.

