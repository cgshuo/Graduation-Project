 Service description deals with specifying all the information necessary in order to access and use a service. The descrip tion should be rich, containing both functional and non-functional aspects while it may also contain information on the internal processes of the service, depending on whether the service provider or owner decides to expose such information. Service descriptions should be written in a formal, well-defined specification language that allows for automated processing and validation of the documents produced.

Formal specifications are indispensable in engineering systems based on Ser-vice Oriented Architecture (SOA) since they can be used as a basis to construct a service or to check that an existing ser vice meets a set of requirements. Fur-thermore, they can assist in auditing processes that check third party or legacy code conformance to specifications, while also playing a major role in validation and verification techniques, as well as in t he evaluation of the results of service adaptation or service evolution. Specifications are also beneficial in service com-position, as they can assist in deducing the composability of a set of services, by detecting inconsistencies among their specifications.

Service specifications rely on the expression of conditions that should hold before and after service execution. Such specifications are prone to a family of problems, known in the AI literature as the frame, ramification and qualification problems. While research in other fields such as programming specifications or reasoning about action and change has come up with satisfying solutions to these problems, research in Web services has largely ignored them, at the same time ignoring their effects.
 To address the aforementioned issues in service description, we propose the Web Service Specification Language (WSSL), designed with the explicit purpose of describing Web service behavior by means of complete specifications. WSSL X  X  foundation is the fluent calculus [23], a specification language and system for robots that offers solutions to the frame, ramification and qualification problems, while resource and data representation is inspired by the Web Service Modeling Language (WSML) [24], a recent large-s cale effort in service description.
It is important to stress the fact that WSSL is independent of service design models. The language design was driven by traditional SOAP-based Web ser-vices as well as Semantic Web services, but WSSL specifications can describe the behavior of any service-based system or application, including RESTful Web ser-vices [19], and could be exposed in a strai ghtforward way as Linked Services [18].
To demonstrate some initial capabilities that can be achieved through service specifications, a WSSL validation tool prototype was implemented. This tool translates WSSL specifications to FLUX [22] programs and allows user-defined goals to be validated against the specifications. Evaluation of the prototype indicates promising results with respect to scalability.

The rest of this paper is organized as fo llows. Section 2 offers a short descrip-tion of the frame, ramification and qualification problems as well as a motivating example illustrating their effects in ser vice specification. Section 3 provides an overview of the fluent calculus and a detailed definition of WSSL in terms of its syntax and semantics. Section 4 extends WSSL in order to support solutions to the ramification and qualification problems and also discusses complexity, de-cidability and applicability issues. Section 5 analyzes the implementation and evaluation of the WSSL validation tool. Section 6 offers a brief description of related work and Section 7 concludes and points out topics for future work. In this section, we present a motivating example to illustrate the need for a service specification language that addresses the frame, ramification and qual-ification problems. The example is based on the E-Government case study of the European Network of Excellence S-Cube [7]. In this case study, citizens sub-mit applications to request some government-related service, such as obtaining government-issued documents, following the process in Fig. 1. Users log into the system and fill in forms regarding their request as well as payment details, which are then simultaneously checked before the payment process can begin. Certification of the final documents is op tional and depends on user preferences.
For our purposes, we can assume that the individual tasks described above are implemented as Web services. A possible fi rst-order logic specification of these services, in terms of their inputs, outputs, preconditions and postconditions is offered in Table 1.
 2.1 The Frame Problem As it was identified in [5], formal specifications that employ the pre-and postcon-dition notation are prone to a family of problems related to the frame problem, a long-standing issue in the field of Artificial Intelligence. The frame problem stems from the fact that including clauses that state only what is changed when preparing formal specifications is inadeq uate, since it may lead to inconsistencies and compromise the capacity of formally proving properties of specifications.
For example, the specification of the CheckPayment service includes post-condition Valid ( payForm, user ), linking a successful execution to attributing validity to the specific payment form/user combination. Based on such a specifi-cation, we cannot answer definitively whether the execution of CheckPayment affects the state of the world in any other way, e.g. attributing validity to any other payment form belonging to some other user. Similarly, it is not provable whether the postcondition PayCompleted ( doc, user ) affects any other pair of document and user variables. Failure to address the frame problem in this ex-ample compromises any validation checks, such as answering which accounts have been affected after a successful execution of the payment process. 2.2 The Ramification Problem The frame problem is closely related to the ramification problem, defined in [17] as the problem of adequately representing and inferring information about the knock-on and indirect effects (also known as ramifications) that might accom-pany the direct effects of an action. The r elation of the frame and ramification problems is somewhat contradicting: an overly restrictive solution to the frame problem precludes any solution to the ramification problem.
 Suppose that we want to express the fact that a side effect of postcondition PayCompleted ( doc, user )ofthe ExecPayment service is the invalidation of the user X  X  credit card under certain circumstances, e.g. when a daily spending limit has been reached. In order to do that, we need a representation that not only takes ramifications into account, but also achieves that by staying consistent with the way the frame problem is solved.

Ramifications are particularly important in service compositions, as they al-low the expression of relationships bet ween effects of services participating in a composition. By making sure that these relationships are taken into account, inconsistencies between parts of a composition may be avoided. For instance, suppose that the following ramification holds for the motivating example: ef-fects Valid ( request, user )and Valid ( payForm, user ) have the knock-on effect expressed by Approved ( transaction, user ), which also happens to be a precondi-tion for ExecPayment . This ramification essentially expresses the composability of CheckRequest / CheckPayment and ExecPayment and can be checked to en-sure the validity of the composition of Fig. 1 before attempting an execution. 2.3 The Qualification Problem While the ramification problem deals with the effects of an action, the qualifi-cation problem deals with the circums tances and conditions that must be met prior to the execution of an action. In the case of services, we deal with the so-called exogenous qualification problem, defined in [17] as the problem of dealing with qualifications that are outside the scope of our knowledge and result in contradicting some effects of an a ction due to inconsistencies.
 In our motivating example, suppose that we know that both preconditions of ExecPayment are true before execution. Thus, we should expect that after a successful execution, the postcondition PayCompleted ( doc, user ) holds. If, how-ever, due to some unforeseen circumstance, we find out that it doesn X  X  hold, then we result in an inconsistency between th e specification and the actual observed behavior. To address this, service specifications need to account for qualifications that are outside the scope of our knowledge in order to consistently model all possible behaviors of the service. WSSL is a novel language for Web service specifications that aims to address the issues of the frame, ramification and qualification problems, by applying the solutions proposed in the definition of the fluent calculus [23] and its follow-up extensions. Employing a formalism designed for the domain of Reasoning about Action and Change (RAC) allows us to specify the effects of a service execution more accurately, by describin g the state of the world before and after an execution. The rationale behind choosing the fluent calculus over other RAC formalisms such as the situation and event calculi is detailed in Sect. 6. 3.1 The Fluent Calculus Before analyzing the syntax and semantics of WSSL, it is important to provide an overview of the fluent calculus [23]. The fundamental entity of the fluent calculus is the fluent , a single atomic property of the physical world which may change in the course of time. In the initial calculus definition as a specification language for robots, this change is the result of manipulation by the robot. In our case, a fluent changes value as a result of a service execution. A state is a snapshot of the environment at a certain moment. A fluent is equivalent to a state where only this particular fluent holds. There is also the notion of the empty state , denoted by  X  and of state composition (combining states to fo rm a new one), denoted by the function  X  .An action represents high-level actions, i.e. executions of service operations. Finally, a situation is a history of action performances. The initial situation, where no actions have been initiated, is denoted by S 0 .
A fluent f is said to hold in a state z ,if z can be decomposed into two states, one of which is f .Themacro Holds ( f,z ) is introduced for notational convenience: Holds ( f,z ) def =(  X  z )  X  z = z  X  f . Holds formulas can be combined to create more complex state description formulas. Such a first-order formula  X  ( z ) is called a state formula ,if z is the only free state variable, with states occurring exclusively in Holds formulas, without any actions or situations.
In order to formalize preconditions, a predefined predicate named Poss is introduced. Given an action A ( x ), a situation s and a situation formula  X  A ( s ) with free variables among x, s ,an action precondition axiom is: Poss ( A ( x ) ,s )  X   X 
A ( x, s ) with the semantics that action A is possible at situation s if and only if  X  A is true. There are also two predefined functions: Do maps an action and a situation to the situation after performing the action, while State maps a situation to the state of the environment in that situation. States are governed by a set of foundational axioms, detailed in [23].
 Solving the Frame Problem. The fluent calculus bases its solution to both the representational and inferential aspects of the frame problem on the notion of states. Change is modeled as the diff erence between two states. Actions are deterministic and result in a bounded number of direct effects and can be pos-itive or negative, with fluents added to or removed from a state, respectively. Postconditions are expressed as state update axioms in the following form: following semantics: provided that an action A is possible at a situation s ,then executing A at s results in a successor state which is defined by the previous state ( State ( s )) if we add fluents that have been made true ( positive effects  X  + ) and we subtract fluents that have been made false ( negative effects  X   X  ), under possible additional conditions expressed by formula  X  ( s ). Under the assumption that  X  + and  X   X  are disjoint, state update axioms are a provably correct solution to the representational aspect of the frame problem (see Theorem 7 in [21]). Representing Inputs and Outputs. While service preconditions and post-conditions are directly associated with action precondition axioms and state update axioms of the fluent calculus, the translation is not as direct in the case of inputs and outputs. We propose to represent the properties of having an input or producing an output as fluents. To that end, we define two reserved unary function symbols corresponding to fluents, namely HasInput and HasOutput . HasInput denotes that the associated variable is available to the service as an input while HasOutput denotes that the associated variable is produced as a service output. We define an input formula in z as a state formula I ( z ) with just one free state variable z , which is composed exclusively of HasInput fluents. An output formula O ( z ) is defined equivalently. 3.2 WSSL Abstract Syntax A WSSL specification is a 5-tuple S = service , input , output , pre , post where:  X  X ervice is a set of identifiers offering gener al information about the service  X  input is a set of WSSL logical expressions defining input formulas ,  X  output is a set of WSSL logical expressions defining output formulas ,  X  X re is a set of WSSL logical expressions defining action precondition axioms  X  X ost is a set of WSSL logical expressions defining state update axioms that Each of the input, output, precondition and postcondition logical expressions is associated with an IRI [8] that acts as an identifier. WSSL identifiers can be any Unicode character sequence, provided that it represents a valid and absolute IRI. Preconditions and postconditions of a service are not limited to functional conditions but can represent the full spectrum of conditions that define a com-plete behavior specification of a service. It goes without saying that this includes specification of non-functional conditions. Since WSSL supports IRI sequences, any ontology-based QoS models can be employed, such as OWL-Q [13].

Apart from IRIs, data can also be expressed in WSSL. As in WSML, data val-ues can either be elementary , corresponding to the three primitive XML Schema datatypes (integer, decimal or string) or constructed ,createdusinga datatype wrapper , which consists of an IRI corresponding to any non-primitive datatype and a set of arguments, which can be elementary data values or variables . WSSL variables must start with a question mark (?) to identify them from other symbol sequences, especially in logical expressions.
 WSSL Logical Expressions. A WSSL logical expression is defined using a first-order fragment of the fluent calculus, as defined in [23]. The alphabet con-sists of the following sets of symbols:  X  A countable set S S S of sorts . S = FLUENT,STATE,ACTION,SIT,BOOL  X  Logical connectives :  X  (negation),  X  (conjunction),  X  (disjunction),  X  (im- X  Quantifiers and Equality : For every sort s  X  S ,  X  s (for all),  X  s (exists), = s .  X  Nonlogical symbols :Aset L L L consisting of a countable, nonempty set FS FS FS of Note that the explicit mention of the sort in symbols such as existential and uni-versal quantifiers can be omitted if the particular sort can be otherwise derived. All elements of sets V,FS,PS are represented by IRIs. Finally, the macro Holds , as well as adding and subtracting fluents from states can also be used in WSSL logical expressions. Terms and atomic formulae are defined as in many-sorted first-order logic. Table 2 offers a WSSL specification of the payment services in the motivating example (omitting Poss clauses and with ? z in = State (? s in ) and ? z out = State ( Do ( A (? x ) , ? s in ) for each service). 3.3 WSSL Semantics The semantics for WSSL is defined based on the standard model theory for classical first-order logic, augmented by the semantics for IRIs as defined in WSML [24]. The main additional aspect brought on by the need to interpret IRIs is the notion of abstract and concrete domains. An abstract domain gives us flexibility in interpreting IRIs as any kind of abstract object, while a concrete domain allows for the interpretation of elementary data values. A concrete do-main needs to support all three element ary data types used by WSSL (integer, decimal and string). For instance, it can be equal to the union of the sets of integer numbers, finite-length sequen ces of decimal digits (preceded or not by the minus symbol) and finite-length sequences of Unicode characters.
A WSSL interpretation is a 6-tuple I = U, D, I C , I F , I P ,B where:  X  U is the abstract domain of interpretation, a non-empty countable set used  X  D is the concrete domain of interpretation, a non-empty set disjoint from U ,  X  I C ,I F ,I P are mappings from individual constants, function symbols and  X  B is an assignment from a variable to an element of U  X  D The interpretation of constants depends on whether the constant is an IRI or an elementary data value. In the former case, I C ( c )= u  X  U , while in the latter case I C ( c )= d  X  D . A similar distinction applies to function symbols. If the function symbol represents a datatype wrapper function (that creates a constructed data value), it is interpreted as a function over the concrete domain: I
F ( f ) i = D i  X  D , with i denoting the arity. Otherwise, we work on the abstract domain and I F ( f ) i = U i  X  U . Predicate symbols are interpreted as a subset of both domains: I P ( p )  X  D  X  U .
 In order to define the interpretation of terms, we first need to handle variables. For each variable, there can be a number of variable assignments B , assigning each variable v to an individual v B  X  U  X  D . A variable assignment in the concrete domain v B  X  D is called a concrete variable while a variable assignment in the union of the domains v B  X  U  X  D is called an abstract variable. Given that definition, if a term is a variable with assignment B, then t I ,B = t B , while if a Due to lack of space, we omit a detailed presentation of formula interpretation. Satisfaction and entailment follow the definition of classical first-order logic, slightly modified to include variable assignment. 4.1 Solving the Ramification Problem At the heart of the solution to the ramification problem in the fluent calculus lie causal relationships (see Chap. 9 in [23]). A ramification is always linked to the direct effect (or another ramification) that brings it about, hence that relation-ship needs to be modeled. In order to achieve that, the fluent calculus is extended with a new predefined predicate named Causes , with 6 state variables and one situation variable as arguments. The semantics of Causes ( z,p,n,z ,p ,n ,s )is the following: in situation s , the occurred positive and negative effects p and n possibly cause an automatic update from state z to state z , with positive and negative effects p and n . Essentially, the Causes predicate is a relation between two state-effect triples with respect to a situation. The general form of a causal relationship allows for expressing separately the set  X  of conditions that drive such a relationship: (  X  )(  X   X  Causes ( z,p,n,z ,p ,n ,s ).

Note that in [23], causal relationshi ps are generalized to include the tran-sitive closure of Causes , in order to express the notion of arbitrary chains of ramifications. However, in the case of se rvices, specification requirements are much simpler: since causal relationships are not always expected to be expressed by providers, some relationships can be derived given a set of services that participate in a service composition, in order to determine the consistency of the composition. Hence, there is no need to express arbitrary chains, since the derivation will yield concrete direct caus al relationships between condition pairs. Taking this into account, the inference of ramifications is expressed by a sim-plified version of the Ramify macro defined in [23]: Ramify ( z,p,n,z ,s ) def = (  X  p ,n )( Causes ( z  X  n + p, p, n, p ,n ,s ).

The final step for solving the ramification problem is integrating ramifications into state update axioms, so that they offer a complete view of what is caused af-ter the execution of an action. The state update axioms with ramifications are de-WSSL with Ramifications. In order to support specification of ramifications, the WSSL signature needs to be extended to include the Causes predicate and the Ramify macro, in order to be able to express causal relationships and ramifi-cation inference. Returning to our motiva ting example, expressing the side effect of credit card invalidation under certain circumstances yields the following causal relationship: DailyLimitReached (? cCrd, ? user )  X  Causes (? z,V alid (? payForm, ? user )+ the behavior that whenever the daily limit condition holds and we are in a state where the postconditions of ExecPayment have been made true, then we move toanewstatewherethe Valid fluent has been removed (falsified) for the par-ticular user and credit card. 4.2 Solving the Qualification Problem Solving the (exogenous) qualification problem involves taking into account ex-pectations that are otherwise assumed to be always satisfied, but which can explain unsuccessful executions when all known preconditions hold. To account for such accidents, the fluent calculus signature is further extended with a new sort ACCIDENT and C , a finite set of function symbols into sort ACCIDENT (see Chap. 10 in [23]). Also, a new predefined predicate named Acc is introduced, with two variables, one of sort ACCIDENT and one of sort SIT . Acc ( c, s )car-ries the semantics that accident c happened in situation s .
 In order to assume away accidents , a default logic theory must be employed: called observations and  X  is the domain axiomatization. The rule is essentially a single universal default on the non-occurrence of all accidents: as long as the observations are in line with the expect ed effects of an action, then no accident needs to be considered as having taken place.

Accidents are then integrated into state update and action precondition ax-ioms. To express the default case, where no accident has taken place, we include the conjunct (  X  c )  X  Acc ( c, s ) in the right-hand side of the state update axiom. Action precondition axioms are rewritten in the following form: Poss ( A ( x ) ,s )  X  [(  X  c )  X  Acc ( c, s )  X   X  provided that no accidents have happened and the preconditions are true.
Apart from these default modifications, where no accident has happened, we may want to express the effects that are brought upon by a particular accident happening. This can be accomplished by adding a disjunct to the state update axiom of the action that expresses that connection, essentially providing more than one possible state updates for the same action, depending on whether an accident has occurred and which accident it was.
 WSSL with Qualifications. In the spirit of the extensions performed to sup-port ramifications, WSSL can be further extended to include qualifications, by introducing the new sort ACCIDENT and the predefined predicate Acc .Ac-tion precondition and state update axioms also need to be rewritten to follow the guidelines expressed previously (st ating preconditions and effects in case no accidents happen and optional additional effects in case an accident occurs). Furthermore, a set of defaults should be attached to every WSSL specification, expressing the occurrence or not of accidents by default.

Returning to our motivating example, in order to solve the exogenous qualifi-which assumes all accidents do not hold by default. Then, we modify the postcon-ditions of each service to account for acci dents. For instance, the postcondition for ExecPayment can now express the fact that if we observe no change after a seemingly successful execution, the n some accident must have happened: ? z in + HasOutput (? payCCnf )+ Valid (? payForm, ? user )+ PayCompleted (? doc, ? user )  X  X  X  ? c ( Acc (? c, ? s )  X  ? z out =? z in ) 4.3 Complexity and Decidability WSSL and its extensions were designed with high expressivity as a fundamental goal in order to be able to support solutions to the frame, ramification and qual-ification problems. Decidability results for the simple fluent calculus obtained by Lehmann [14] and H  X  olldobler [11] show that considerable restrictions must be made to both the calculus definition and the queries that can be decided. How-ever, in [20], Schiffel and Thielscher pres ent a complete and co rrect bidirectional translation process between the situation calculus and the fluent calculus. Based on this work, one can argue that any decidability results that have been obtained for the situation calculus can be applied for the fluent calculus as well, given the fact that the translation process guara ntees the equivalence of the entailment procedures for the two calculi.

One case of decidability results in the situation calculus that is of particular interest because of its expressiveness is presented in [10]. The authors restrict situation calculus to a two-variable fragment with counting, C 2 , which has been proven to be decidable in NExpTime and also add Description Logic capabilities such as the expression of TBox and RBox statements. The authors examine the expressivity of such an action language for the case of service domains, pointing out the fact that if both atomic services and properties affected by them can be expressed using only two parameter s, then they can be expressed using C 2 , with decidable entailment. In his thesis, Milicic [16] proves that the C 2 fragment of the situation calculus is more expressive than any of the DL fragments considered in relation to action formalisms.

As far as the extensions of WSSL are concerned, decidability is affected only by the inclusion of a default theory. In the case of defaults without prerequisites (such as the one used in the solution to the qualification problem), decidability is possible provided that consequences and axioms in the default are predefinite variable clauses (function-free and all the variables occurring in a positive literal also occur in a negative one). 4.4 Applicability and Practical Concerns WSSL is designed as a language at the level of OWL-S and WSML, focusing on the completeness of service descriptio ns with regard to the frame, ramification and qualification problems. As such, WSSL is related to existing Web service description languages in two different ways. First, WSDL (and SAWSDL) can be employed as ground languages so that WSSL specifications can be associated with concrete realizations of services an d service executions, benefitting greatly from the wide acceptance and use of WSDL as a descriptive interface to services. Second, existing OWL-S and WSML descriptions can be ported to WSSL using translation mechanisms, as well as annotation facilities to fill up information that is exclusive to WSSL (such as causal relationships). Moreover, given the strong foundations provided by the fluent calculus, WSSL specifications can facilitate not only service validation and verification, as detailed in the next section, but also service composition, by applying fluent calculus-based planning. To exploit the expressive capabilities of WSSL, we implemented a validation tool that takes a WSSL specification as input and allows the user to express goals that are validated against the specification. The validation process involves 3 basic steps. First, the WSSL document (written in XML following the syntax defined later on) is translated into a FLUX [22] program. Then the tool expects a WSSL goal to be expressed by the user, which is also translated in FLUX (the user can also express FLUX queries directly). The final step involves automati-cally loading the program in the ECL i PS e Constraint Programming System [1], validating the goal and returning the results to the user.

FLUX (FLUent eXecutor) is a method t hat essentially offers an implementa-tion of the fluent calculus in logic programming with constraint handling. FLUX has a restricted expressive ness that enables an excellent computational behavior, offering reasoning in linear time with regard to the size of state representation. It is expressive enough, however, to be able to support any WSSL specification. Table 3 offers a mapping from WSSL elements to FLUX clauses. Note that pre-conditions are combined to a single poss clause (and postconditions to a single state_update one) to preserve correct serv ice execution semantics.
 The  X  denotes that the particular clause has been suitably translated in FLUX. Note that for efficiency reasons, translation of postconditions omits the verifi-cation of the precondition, assuming that services are executed only in states it is possible. If the user wants to verify them, then they should be included in the query expression. Also, the situation argument is suppressed in the transla-tion of Ramify and Causes . As far as accidents are concerned, FLUX avoids the explicit encoding of the predicate Acc and the default theory, by producing one state_update clause for the normal case, and one ab_state_update clause, containing all state updates that are associated with accidents in the order they are expressed in the initial representation.

The translation process can be trivially proven to be sound since it follows the soundness of the encoding of the fluent calculus in FLUX. For instance, the tool produces the FLUX clause B: holds(f,Z) from a WSSL expression A: Holds ( f,z ) for a fluent f and a state variable z. B is indeed the FLUX encoding of the fluent calculus macro Holds , hence the translation is sound and the same applies to all WSSL element translations in Table 3.

An example FLUX query fed to the validation tool, given the service spec-ification of ExecPayment in Table 2 is: poss(execpayment(payform), Z), state_update(Z, execpayment(payform), Z1). which would yield the result Z=[hasinput(payform),valid(payform, user),valid(ccrd, user)] and Z1=[Z, hasoutput(payccnf), paycompleted(doc, user)] . 5.1 WSSL/XML In order to provide machine readability for WSSL documents, so that they are parsed in a standardized way by the validation tool, an XML syntax for WSSL is proposed in this section, named WSSL/XML. The syntax includes the extensions covered in Sect. 4; such elements are co nsidered optional. The XML schema for WSSL/XML can be found online at www.cs d.uoc.gr/  X gmparg/research.html. Translation of WSSL logical expressions is based on the XML syntaxes for WSML and RuleML. Table 4 shows some indicative cases. expr i stands for any arbitrary WSSL logical expression.
 5.2 Evaluation The WSSL validation tool essentially consists of a translation mechanism from WSSL to FLUX, followed by a query execution in the ECL i PS e constraint programming system. In this section, we evaluate the overhead of the translation process in terms of runtime and memory consumption. For efficiency results with regard to running FLUX queries in ECL i PS e , refer to [22] and the FLUX website (http://www.fluxagent.org).

The tool was implemented as a Java application and can be found online at http://www.csd.uoc.gr/  X gmparg/resea rch.html. We investigated the scalabil-ity of the translation process in terms of runtime and memory consumption by translating WSSL specifications that contained from 1 to 500 pairs of pre-and postconditions containing randomly generated, uniquely named fluents. The run-time values are an average of 10 runs, while memory consumption is presented Core TM i7-740QM processor running at 1.73GHz, with 6 GB RAM.
As we can see in Fig. 2, runtime stays less than 600ms even for specifications containing 500 pairs of pre-and postconditions, and actual memory consumption peaks at around 8000KB. Based on these results and the fact that actual service specifications contain at most tens of pre/post pairs, even in the case of service composition, we can safely assume that the overhead posed by the translation process from WSSL to FLUX is insignificant. The frame, ramification and qualification problems have been largely ignored by every service description language that has been proposed in recent years (SAWSDL [9], OWL-S [15] and WSML [24]), although it was considered (but not included) in WSML to label postconditions as complete (framed) or incomplete. WSSL employs the resource and data representation of WSML but uses the fluent calculus as a knowledge foundation, which allows for efficient solutions to the aforementioned problems, while WSML X  X  DL foundation does not.

In previous work [3], we identified the existence of the frame problem in Web service specifications and proposed a solution that involves expressing state up-date axioms in OWL-S and WSML descriptions. While this solution is more compatible with existing service descriptions than WSSL (which would require either a grounding or a translation mechanism), it doesn X  X  provide a unified solution framework that includes the ramification and qualification problems.
To the best of our knowledge, the only efforts to use the fluent calculus in ser-vice research are those of Chifu et al. [6], followed by [4]. In these works, OWL-S service descriptions are translated to fluent calculus theories for the purpose of automated service composit ion. The authors, however, use the simple fluent cal-culus, without the extensions that solve the ramification and qualification prob-lems. Also, their choice to represent inputs and outputs using the extension of the fluent calculus to support knowledge and sensing is invalid since Thielscher X  X  intent for this extension was to represe nt incomplete state knowledge. In our work, inputs and outputs are represented in a natural way by special fluents.
The fluent calculus is not the only formalism that offers a solution to knowl-edge representation problems. The frame problem has been addressed in the situation and event calculi, while Kakas et al. [12] present an event calculus the-ory that solves the ramification and qualification problems as well. The reason for choosing the fluent over the event calculus in our work is two-fold. First and fore-most, service specification requires a non-narrative-based formalism, since there is no need for an explicit notion of time: we only need to recognize the state before and the state after execution. S econd, FLUX provides an efficient imple-mentation of the complete fluent calculus, allowing us to implement more easily tools that require reasoning, such as the validation tool presented in Sect. 5. In this paper, we proposed WSSL, a novel specification language for Web services based on the fluent calculus, that provides solutions to representational issues caused by the frame, ramification and qualification problems. Also, a validation tool for WSSL specifications was implemented and evaluated. WSSL allows ser-vice providers to accurately express t he behavior of a service, by defining con-ditions before and after execution, expressing or inferring causal relationships among conditions and accounting for unexpected unsuccessful executions. Such rich behavior specifications can then be exploited for the purposes of service validation, verification and composition.

Future work includes supporting compatibility with existing description lan-guages, as detailed in Sect. 4.4, as well as developing a service composition approach for WSSL services, based on planning with FLUX. Also, support for composite service specification will be extended based on our previous work on deriving composite service specificatio ns [2] as well as deriving ramifications based on the individual specifications of services participating in a composition. Acknowledgments. This research was partially funded by the PaaSage (FP7-317715) EU project, as well as the Special Account for Research Grants, Uni-versity of Crete (Grant No. 3742).

