 Xingquan Zhu XQZHU @ CS . UVM . EDU Xindong Wu XWU @ CS . UVM . EDU Qijun Chen QCHEN @ CS . UVM . EDU The goal of an inductive learning algorithm is to form a generalization from a set of training instances such that its classification accuracy on previously unobserved instances is maximized. This maximum accuracy is determined by two most important factors: (1) the quality of the training data; and (2) the inductive bias of the learning algorithm. Given a learning algorithm, it X  X  obvious that its classification accuracy depends vitally on the quality of the training data. Accordingly, the most feasible and direct way to improve the system effectiveness is to clean up the noise from the training data. Generally, there are two types of noise sources (Wu, 1995): (a) attribute noise; and (b) class noise. The former is the errors that are introduced in the attribute values of the instances. There are two possible sources for class noise: (1) contradictory examples, i.e., the same examples with different class labels; and (2) misclassifications: instances labeled with wrong classes. Due to the fact that class noise is caused by mislabeling, in this paper, we call it mislabeled errors, and will identify this type of noise. Quinlan (1986) demonstrated that, for higher levels of noise, removing noise from attribute information decreases the predictive accuracy of the resulting classifier if the same attribute noise is present when the classifier is subsequently used. However, for class noise, the opposite is true: cleaning the training data will result in a classifier with a higher predictive accuracy. The use of pruning and learning ensembles partially addresses the problem, but noise can still drastically affect the accuracy. Hence, many research efforts have been made on eliminating mislabeled errors for effective learning. Generally, the most challenging task in identifying class noise is how to distinguish the mislabeled errors from the exceptions to general rules (Srinivasan et al . 1992). When an instance is an exception to general cases, it can also appear as if it is incorrectly labeled. Guyon et al. (1996) provided an approach that uses an information criterion to measure an instance X  X  typicality; and atypical instances are then presented to a human expert to determine whether they are mislabeled errors or exceptions. The noise detection algorithm of Gamberger et al. (2000) is based on the observation that the elimination of noisy examples reduces the CLCH (Complexity of the Least Complex correct Hypothesis) value of the training set. They called their noise elimination algorithm the Saturation filter since it employs the CLCH measure to test whether the training set is saturated. Brodley &amp; Friedl (1996; 1999) simplified noise elimination as a filtering operation (John, 1995) where multiple classifiers learned from a noise corrupted dataset are used to identify noise, and the noise is characterized as the instances that are incorrectly classified by the multiple classifiers. Similar schemes have been widely adopted by others (Gamberger et al. , 1999; Verbaeten, 2002). Instead of using multiple classifiers learned from the same training set for noise identification, Gamberger et al . (1999) s uggested a Classification Filter approach, in which the training set E is partitioned into n subsets, a set of classifiers H y from the aggregation of any n -1 subsets are used to classify the instances in the complementary (excluded) subset, and the instances that are incorrectly classified by H are identified as noise. To perform noise elimination, most approaches above make two assumptions: (1) the dataset is relatively small for learning at one time; and (2) the dataset is right at hand for learning. This is because that most of them adopt a major set based strategy: Given a dataset E , it is separated into two parts: a major set and a minor set, and the major set is used to induce classifiers to identify the noise from the minor set. Nevertheless, the machine learning community is currently facing the challenge of large and distributed datasets, which might be too large to be handled at one time. Hence, the above assumptions are too strong in realistic situations. One may argue that in the case of a large dataset, scaling-up inductive algorithms (Provost et al. , 1999), e.g., boosting and meta-learning, could be adopted. Unfortunately, Chan X  X  (1996) research has shown that in general the classification accuracy from scaling-up algorithms is worse than the accuracy from the whole dataset, especially in noisy environments. This is because that scaling-up algorithms induce rules from sampled data where many exceptions in the sampled data are actually valuable instances in the original dataset. Consequently, while dealing with large datasets, most noise elimination approaches are inadequate. For distributed datasets, the problem with existing approaches is even more severe. They assume that all data is at hand for processing. Unfortunately, in realistic situations, it X  X  either technically infeasible (e.g., bandwidth limitations) or forbidden (e.g., for security or privacy reasons) to share or download data from other sites. One can execute noise elimination algorithms on each single site respectively, but it may inevitably eliminate some instances that are noise for the current site but useful for other sites. In this paper, we present a new strategy to eliminate mislabeled instances from large datasets, and we also analyze its availability for distributed datasets. Because it X  X  a partition-based scheme, we call it Partitioning Filter (PF). Our experimental results on real-world datasets will demonstrate the effectiveness of our approach: with datasets from the UCI repository (Blake and Merz, 1998), at any noise level (even 40%), the classifier learned from the dataset that has been processed by PF always shows remarkably improved classification accuracy. The flowchart of our proposed scheme (Partitioning Filter) is depicted in Figure 1, and the various procedures in Figure 1 are given in Figures 2 and 3. The intuitive assumption behind our approach in distinguishing exceptions and noise is that once we can select good rules from induced classifiers, the behaviors of the exceptions and noise would be different with the good rules: exceptions are usually not covered by the selected good rules, whereas noisy instances are likely covered by the good rules but produce a wrong classification. Based on this assumption, we first partition the whole dataset E into several subsets. Given any subset P i , we learn a set of classification rules R i , then select a good rule set ( GR from R i , and use the GR i to evaluate the whole dataset E . variables, le count), to record the behavior of I k with GR i from P (1) If I k belongs to P i and I k  X  X  classification from GR (2) If I k does not belong to P i and I k  X  X  classification from After we execute the same procedure on all subsets, the I is mislabeled. As we stated above, due to the different behaviors of exceptions and noise with good rules, mislabeled instances will hopefully receive large values 
I and ge k I than exceptions. Then two noise identification schemes, majority and non-objection, are adopted, as shown in Figure 3. In the majority threshold scheme, an instance is identified as noise only if more than one half of the subsets identify it as noise. In the non-objection scheme, the instance won X  X  be judged as noise until its classification results from all subsets are different from its original label. For both schemes, one premise to identify I k as a mislabeled error is that I should be classified as noise by its host subset (subset P to which I k belongs), as shown in Step (1) of Figure 3, because a classifier usually has a higher accuracy with the instances in its training set. Procedure : PartitioningFilter () Input : E (training set with S examples) Parameters : (1) The scheme and threshold to select good rules (default: Best-L rules); (2)  X  , the rate of good examples to be removed in each round (default:  X  =0.5 ). Output : A (detected noise subset of E ) (1) B  X   X , for any instance I k  X  E , le (2) Partition E into N subsets. (3) For i = 1 , . . , N do (4) For each subset P i , learn a rule set R i from P (5) GoodRulesSelection ( GR i , R i ). // See Section 2.1 (6) For k =1,.., S do (7) Given instance I k , I k  X  E , if I k  X  P (9) If I k  X  P i , I (11) Else if I k  X  P i (12) If I k fires GR i and its classification from (14) End for (15) End for (16) For k = 1 ,.., S do (17) Given instance I k , if Noise ( lused (18) B  X  B  X  { I k } (19) End for (20) Remove identified noise and a certain portion (21) E  X  E \ { B  X  G }; A  X  A  X  B ; (22) Exit if the stopping criterion has been satisfied. (23) Otherwise: Goto Step (1); // Repeat the procedure Procedure : Noise ( lused (2) If Majority Scheme: (4) Else if Non-objection Scheme: (6) Else Return (0); 2.1 Good Rule Selection To select good rules from each subset, a consistency check should be adopted. For each rule r learned from subset P i , we compute two factors, SubPrec ( r , P SubCov ( r , P i ) which indicate the classification precision and coverage of r with subset P i . The criteria we have adopted for selecting good rules consist of two parts: (1) The estimated SubPrec ( r , P i ) has to be significantly (2) A rule that covers very few examples cannot be With the two criteria above, the parameter  X  plays an important role in selecting good rules for each subset P We adopt three schemes to determine this threshold: (1) Adaptive Threshold : The user specifies a value that is relatively close to the actual noise level (assuming the user knows about the noise level in the dataset); (2) Fixed Threshold : The system automatically assigns a value for  X  , where possible values of  X  are specified by experiences or empirical results; and (3) Best-L Rules : We rank all rules of P i by their SubPrec ( r , P the best L rules with the highest precisions. Meanwhile, all selected rules should have their SubPrec ( r , P than a threshold  X  w (we set  X  w = 0.6 in our system). To determine L for a given dataset, we calculate the average number of rules induced from each subset, and L is assigned as  X % of this average number. Our experimental results suggest that  X  =70 can usually provide a good performance on our evaluate datasets. With the Best-L Rules scheme, the more complicated the dataset, the larger is the number L . 2.2 Deduction with the Good Rule Set Given an instance I k and a good rule set GR i takes place to evaluate how well GR i classifies I follows. If I k is not covered by any rule in GR i , I unclassified; If I k is covered by at least one rule in GR and these rules have the same classification, I classified. However, in the case that I k matches more than one rule in GR i , and there are disagreements among these rules, the confidence of each rule is used to determine the classification of I k , where the confidence is determined by the coverage and accuracy of each rule (Clark &amp; Boswell 1991; Wu, 1998). With the above deduction strategy, the good rule set GR only classifies the instances on which GR i has confidence in its classification. Consequently, exceptions and noise are likely to be treated in different ways: the exceptions are usually not covered by the good rules, but the noisy instances would likely deny the good rules (covered but with a different classification). The error count variables of misclassified examples will receive larger values than non-noisy examples. 2.3 Multi-Round Execution and Stopping Criterion Instead of trying to accomplish noise elimination at one time, we identify noise in multiple rounds until the following stopping criterion has been satisfied: in T continuous rounds, if the number of identified noisy examples in each round is less than T 2 , noise elimination will stop. In our system, we set T 1 =3 and T 2 where X is the number of examples in the training set. After each round, we remove the identified noisy examples, and also remove a certain number of good examples (this number is smaller than the number of identified noisy examples) from the training set. Our experimental results (Zhu et al. , 2003) demonstrate that when we keep reducing the noise level, eliminating a small portion of good examples will not have much influence with the system performance. The benefit of eliminating good examples is that it can shrink the dataset size, and consequently, when executing data partitioning in the next round, we can have a smaller number of subsets. Therefore, the exceptions in the subsets of the last round may form new rules in the next round. While both equal to zero are selected as good examples. To eliminate noise from distributed datasets, an intuitive way is to apply the mechanism above on the dataset at each site separately. However, with this scheme, it may not be rare that instances eliminated from one site might be useful for other sites. Meanwhile, for various reasons, sharing or downloading the data from each site might be impossible, but sharing the rules is usually allowable. Accordingly, we can treat all datasets from different sites elimination. In the first stage, the system executes data partitioning on each distributed dataset by considering the dataset size. After that, the procedure in Section 2 is adopted to induce and construct a good rule set from each data subset. Then, the good rule sets are used to evaluate all data in E  X  : while using a good rule set GR identify noise from other sites, e.g., P j , only the GR is passed to P j . Therefore, no data from any site would leak out. After noise identification on all subsets is completed, each data site removes identified noise and a small portion of good examples from its own dataset. After the same procedure has been executed on all datasets, it will repeat the same procedure until the stopping criterion has been satisfied. With the above strategy, only induced rules are shared, the privacy and security of the data are maintained. Moreover, the noise is determined by not only the local site but also all other distributed datasets. 4.1 Experiment Settings To construct classification rules and base classifiers, C4.5rules (Quinlan, 1993) is adopted in our system. We have evaluated our noise elimination strategy extensively on both synthetic and realistic datasets, and more details can be found in Zhu et al . (2003). Due to size restrictions, here we will mainly report the results of two relatively large datasets from the UCI data repository, Adult and Mushroom. To add noise, we adopt a pairwise scheme: given a pair of classes ( X , Y ) and a noise level x , an instance with its label X has a x  X  100 % chance to be corrupted and mislabeled as Y , so does an instance of class Y . We use this method because in realistic situations, only certain types of classes are likely to be mislabeled. Using this method, the percentage of the entire training set that is corrupted will be less than x  X  100 % because only some pairs of classes are considered problematic. In the sections below, we corrupt only one pair of classes (usually the pair of classes having the highest proportion of instances, except the Splice dataset, where we corrupt the classes EI and IE) and report only the value x in all tables and figures. For each experiment, we perform 10-fold cross-validation and use the average accuracy as the final result. In each run, the dataset is randomly (with a proportional partitioning scheme) divided into a training set and a test set, and we corrupt the training set by adding noise with the above method, and use the test set to evaluate the system performance. In the sections below, the original dataset means the noise corrupted training set. For a better evaluation, we adopt three factors: ER and Noise Elimination Precision ( NEP ). ER 1 occurs when a non-noisy instance is tagged as noise; and ER 2 when a noisy example is tagged as a correctly labeled instance. Their equational definitions are given by Eq. (3). where || X || denotes the number of examples in set X ; F is the set of examples that are identified as noise and have been removed; F noisy examples and M is the set of noise. 4.2 Threshold Schemes for Noise Identification In this subsection, we compare the performances of the majority and non-objection threshold schemes in noise identification. We first split the original dataset into 5 subsets by using a proportional partitioning scheme (a detailed analysis on the number of subsets will be provided in Section 4.4). To select good rules, we use an adaptive threshold scheme (in Section 2.1): when processing a dataset with a noise level of x , we randomly select a value for  X  with the constraint in Eq. (4).  X  (4) We tabulate the results of noise elimination in Tables 1 and 2 and depict the accuracy improvements in Figure 4. From Tables 1 and 2, we can find that the non-objection threshold scheme is much safer than the majority scheme, and rarely (usually less than 2%) identifies good examples as noise ( ER 1 errors). The noise elimination precision ( NEP ) from the non-objection scheme is much better than the majority scheme. However, as a tradeoff, it shows a relatively severe problem in preventing too much noise from being removed ( ER 2 errors). One of the serious problems with ER 2 errors is that they cause the classifier learned from the cleaned dataset to still suffer from the low accuracy problem. As shown in Figure 4, its classification improvement is relatively limited in comparison with the majority scheme. These observations suggest that we may not always want the NEP to be maintained at a high level, and that a more aggressive scheme is needed if this scheme can keep its ER 1 errors at an acceptable level. From Tables 1 and 2, we can find that the majority scheme provides a remarkable tradeoff between the system performance and the NEP . This scheme can remove about 80% noise from most datasets at different noise levels (the results from the Adult dataset are relatively poor). As a result, it receives more improvement on its classification accuracy. From Figure 4, take the noise level at 20% as an example. Although both majority and non-objection schemes receive remarkable accuracy improvements compared with the original noise corrupted training set, but the majority scheme has about 2% and 4% more improvements for the Mushroom and Adult datasets respectively. In the sections below, unless specified otherwise, we will use the majority scheme for noise identification. (%) NEP P ( ER 1 ) P ( ER 2 ) NEP P ( ER 1 ) P ( ER (%) NEP P ( ER 1 ) P ( ER 2 ) NEP P ( ER 1 ) P ( ER 4.3 Good Rule Selection Schemes In this subsection, we compare the system performance with three good rule selection schemes in Section 2.1: (1) the adaptive threshold scheme, with Eq. (4) for determining the value for  X  ; (2) the fixed threshold scheme, with three typical fixed values  X  =0.9, 0.75 and 0.6 ; and (3) the Best-L rules scheme, with  X  =70 which usually generates L =10 and L =20 for the Mushroom and Adult datasets respectively. Figure 5 presents the experimental results. From Figure 5, one can easily conclude that the adaptive threshold scheme is the best in almost all situations. With the fixed threshold scheme, when the noise level is less than 1- X  , its performance is a little worse than the performance of the adaptive threshold scheme; however, once the noise level is higher than the given threshold, the system performance declines rapidly (as demonstrated when  X  =0.9 and 0.75 ). Our analysis shows that when the noise level x is less than 1- X  , the system tends to take more insignificant rules into the good rule set, and as a result, more good examples are identified as noise. On the other hand, when the noise level is higher than 1-good rules X  precision would tend to be less than 1-noise corrupts the good rules X  precision), and most good rules would not be taken into the good rule set. Hence, less noise is eliminated, which critically affects the system performance. As indicated in Figure 5, the results from  X  =0.6 are acceptable to some degree, even when worse performances have been found from the lower noise levels. Hence, in the case that the user has no idea about the noise level, we may specify a small value for  X  One can find that the results from the Best-L rules scheme are very attractive. Usually, it has a slightly worse performance than the adaptive threshold scheme. These situations usually happen when the noise level is relatively high. For the Mushroom dataset, when L =10 and the noise level is 30% , the Best-L rules scheme receives about 2% less improvement than the adaptive scheme and is similar to the fixed threshold scheme, but in low noise level environments, it is better than the fixed threshold scheme. The same conclusion can be drawn from other datasets. One can image that in general situations, the user usually has no idea about the noise level, and from this viewpoint, the Best-L rules scheme might be the best choice to select good rules. In the following sections, unless specified otherwise, we use the Best-L rules scheme to select good rule for each subset. 4.4 Number of Subsets on System Performance Due to the fact that our approach uses the minor set (one single subset) to identify noise from the major set (all other subsets), we need to evaluate how the number of subsets affects the system performance. If the system performance is very sensitive to the number of subsets, it would imply that this method might not work well in realistic situations. For any given dataset at a certain noise level (20%), we use a proportional partitioning scheme to construct various numbers of subsets, and use both the non-objection and majority threshold schemes to identify noise. The results of noise elimination and classification accuracy improvements are given in Table 3. Table 3 demonstrates that when using more subsets, the non-objection scheme prevents more noise from being eliminated. One of the worst consequences of keeping much noise is that the classifier learned for the dataset would have very limited improvement (sometimes no improvement). The classification accuracy of the non-objection scheme decreases rapidly with the increasing number of subsets. The majority scheme, on the other hand, sacrifices a small portion of ER 1 errors but gains considerable improvement on ER 2 errors. With this scheme, the number of subsets has less impact on the system performance. Comparing the results with 3 and 39 subsets respectively, the ER 1 errors of the majority scheme increases from 5.82% to 14.62%, but we still receive remarkable improvement on the classification accuracy. Actually, there is a contradiction between the number of subsets and the system performance: the more the subsets, the larger is the number of decision committee members (because we take each subset as a decision maker to identify noise), and meanwhile, the weaker is the ability of each committee member (because with the increase of the subset number, less information is contained in each subset). From Table 3, one can intuitively conclude that the larger the number of subsets, the worse is the system performance. Actually, at the beginning, there is a trend that the accuracy increases with the increase of the subset number, but after a certain number it begins to drop. However, even in the extreme case, e.g., 127 subsets, Table 3 indicates that the majority scheme can still attain a good performance. In most of our experiments, we use 5 subsets. 4.5 Multiple Rounds of Execution While most existing methods perform noise identification in one round, we execute the procedure for multiple rounds until the stopping criterion is satisfied. One may ask whether it X  X  necessary to perform multiple rounds if one round of execution can attain satisfactory results. We have recorded the percentage of eliminated noise after the execution of each round (at different noise levels), and show the results in Figure 6, where the x-axis denotes the number of execution rounds and the y -axis represents the percentage of identified noise until this round. Figure 6 demonstrates that with the Adult dataset, at any noise level, the first round can only eliminate about 40% of noise; however, running the same procedure for 5 rounds will increase this percentage to 60%. Actually, our experimental results from other datasets (e.g., Mushroom) indicate that when the noise level is relatively low (less than 30%), the results from one round of execution are basically good eno ugh (about 90% of the noise could be eliminated). However, when the noise level goes higher, it X  X  necessary to execute the same procedure more than once. Generally, since the Adult dataset contains many exceptions, its classification accuracy is relatively low (85%) even without any mislabeled error. Hence, we believe the results from the Adult dataset are representative for large datasets. More experiments show that in most situations, the first five rounds usually eliminate most noise (over 85%) that the system can identify. Accordingly, instead of using the stopping criterion in Section 2.3, another possible empirical operation to stop the program is to execute the procedure for a certain number of rounds. 4.6 More Experimental Results In addition to the results from the Mushroom and Adult datasets, Table 5 shows more experiments on 7 other datasets. More details can be found in Zhu et al. , (2003). Also, for comparative studies, we have implemented the Classification Filter proposed by Gamberger et al . (1999) (with 10 subsets, as recommended by these authors). In Table 5, the first column indicates the noise level and the other columns present accuracies from different datasets, where OG indicates the classification accuracy of the classifier learned from the original dataset, CF represents the accuracy from the Classification Filter, and PF denotes the results from our approach (Partitioning Filter). From the results in Table 5, the system performance can always improve with noise elimination. With all seven datasets, noise elimination can contribute from 1% to over 20% to the system performance improvment, varying from noise levels and datasets. One can also find that when the noise level is relatively low (less than 15%), the CF method outperforms the PF scheme on 4 out of 7 datasets. However, when the noise level becomes higher, the performance of CF decreases rapidly. When the noise level is at 35%, for example, CF outperforms PF on only 1 out of 7 datasets. Actually, this only dataset is Splice, in which the instances of the corrupted classes occupy only 50% of the instances in the whole dataset, i.e., the actual noise in the dataset is one half of the noise level x . Further analysis provides an answer for this phenomenon: since CF learns its classifiers from the major sets and uses them to identify noise in the minor sets, when the noise level is low, the learned base classifiers would behave well and have relatively good performances in identifying noise; but when the noise level increases, the learned classifiers tend to make more mistakes, which will in turn either wrongly identify some good instances as noise or keep noisy examples as good instances. Our approach selects good rules, and the increase of noise has less impact on the system performance. Moreover, instead of fully relying on any single classifier (as the CF scheme does), we perform noise identification from all subsets, and our scheme is more robust in noisy environments. In addition to the classification accuracy, we also compare the efficiency between CF and PF. Table 4 shows the execution times of the two methods at different noise levels. We used a PC with Pentium 4, a 2GHz processor, and 512 MB memory to implement both methods. The PF scheme is much better than the CF approach in terms of time efficiency. When the noise level is 0 and 40%, PF is about 3.4 and 40 times faster than CF respectively. Our results from other datasets indicate that on average, PF is about 10 times faster than CF. Actually, the larger the dataset, and the higher the noise level, the more efficient is PF compared to CF. Part of the reason is that the time complexity of C4.5rules nonlinearly increases with the noise level and the number of instances. If adopting different inductive algorithms, the impact of noise might be less significant, but we believe PF will still be much more efficient than CF. 
Methods Our approach is related to the Classification Filter (CF) proposed in Gamberger et al. (1999). However, there are three key distinctions between them even though they both adopt a partitioning scheme: (1) CF learns the base classifier from the aggregation of any n -1 subsets (the major set) to identify noise from the complementary (excluded) subset, while our approach learns a classifier from each single subset (the minor set) to evaluate the whole dataset; (2) when identifying noisy examples, CF fully trusts each base classifier, i.e., the instances incorrectly classified by the base classifier are directly identified as noise, but our approach takes each base classifier as a committee member for noise identification; and (3) the base classifier in our approach processes only instances on which it has the confidence. Consequently, our approach is more efficient in handling large and very noisy datasets. Meanwhile, one can find that the result of the CF scheme critically depends on the performance of adopted learning algorithms. Assuming an inductive algorithm has a  X  % classification accuracy with a noise-free dataset E  X  X  , the CF scheme will inevitably identify about 100%- X  % of the instances as noise, even if there is no noise in E  X  X  . This is because it unconditionally trusts each base classifier. This strategy obviously neglects the fact that inductive algorithms cannot work perfectly, even with noise-free datasets. Our experimental results (Zhu et al. , 2003) indicate that the CF scheme is usually more aggressive than our approach, eliminates more instances, and makes more ER 1 errors. This might be another reason that it occasionally works better than PF when the noise level is low, because removing a certain portion of exceptions likely increases the classification accuracy of some datasets. An inherent disadvantage of existing approaches in identifying class noise is that they are less efficient in handling large, distributed datasets. In this paper, we have presented a Partitioning Filter approach for noise identification from large, distributed datasets. Given a dataset E , we first partition it into N subsets. For any subset P i , a set of good rules are induced and selected to evaluate all instances in E . For any instance I error count variables are used to record how this instance behaves with the good rule sets from all subsets. Due to the fact that exceptions usually do not fire the good rules and noise more likely denies the good rules, the noise has a higher probability of receiving large error values in comparison with non-noisy examples. We have adopted different threshold schemes to identify noise. After each round, the identified noise and a certain portion of good examples are removed, and the same procedure is repeated until the stopping criterion is satisfied. Experimental evaluations and comparative studies have shown that our proposed approach is effective and robust in identifying noise and improving the classification accuracy. This research is supported by the U.S. Army Research Laboratory and the U.S. Army Research Office under grant number DAAD19-02-1-0178. The authors would like to thank the anonymous reviewers for their constructive comments on an earlier version of this paper. Blake, C.L. &amp; Merz, C.J. (1998). UCI Repository of machine learning databases . Breiman, L., Friedman, J.H., Olshen, R., &amp; Stone, C. (1984). Classification and Regression Trees . Wadsworth &amp; Brooks, CA. Brodley, C.E. &amp; Friedl, M.A. (1996). Identifying and eliminating mislabeled training instances, Proc. of 13 National conf. on artificial intelligence , pp.799-805. Brodley, C.E. &amp; Friedl, M.A. (1999). Identifying mislabeled training data, Journal of Artificial Intelligence Research , vol. 11: 131-167. Chan, P. K.-W. (1996). An extensive meta-learning approach for scalable and accurate inductive learning, Ph.D Thesis, Columbia University . Clark, P., &amp; Boswell, R. (1991). Rule induction with CN2: some recent improvement, Proc. of 5 th ECML , Berlin, Springer-Verlag. Gamberger, D., Lavrac, N., &amp; Groselj C. (1999). Experiments with noise filtering in a medical domain, Proc. of 16 th ICML , pp. 143-151, San Francisco, CA. Gamberger, D., Lavrac, N., &amp; Dzeroski, S. (2000) Noise detection and elimination in data preprocessing: experiments in medical domains. Applied Artificial Intellig. , vol. 14: 205-223. Guyon, I., Matic, N., &amp; Vapnik, V. (1996). Discovering information patterns and data cleaning. Advances in Knowledge Discovery and Data Mining , pp.181-203. AAAI/MIT Press. John, G. H. (1995). Robust decision trees: Removing outliers from databases. Proc. of 1 st international conf. on knowledge discovery and data mining , pp.174-179. Quinlan, J.R. (1986). Induction of decision trees. Machine Learning , 1(1): 81-106. Quinlan, J.R. (1993). C4.5: programs for machine learning , Morgan Kaufmann, San Mateo, CA. Provost, F., &amp; Kolluri, V. (1999). A Survey of Methods for Scaling Up Inductive Algorithms . Data mining and knowledge discovery , 3(2):131-169. Srinivasan, A., Muggleton, S., &amp; Bain, M. ( 1992). 
Distinguishing exception from noise in non-monotonic learning. Proc. of 2 th ILP Workshop , pp.97-107. Verbaeten, S. (2002). Identifying mislabeled training examples in ILP classification problems, Proc. of Machine learning conf. of Belgium and the Netherlands . Wu, X. (1995), Knowledge acquisition from database , Ablex Pulishing Corp., USA. Wu, X. (1998), Rule Induction with Extension Matrices, American Society for Inform. Science , 49(5):435-454. Zhu, X., Wu, X. &amp; Chen Q. (2003). Identifying class noise in large, distributed datasets, Technical Report, 
