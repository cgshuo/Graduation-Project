 Grid workflow systems which are evoking a high degree of interest aim to support modeling, redesign and execution of large-scale sophisticated e-science and e-business processes [2, 3, 9, 10, 11, 12]. In Open Grid Services Architecture (OGSA), a grid workflow can be defined as the automation of a Grid process, in whole or part, during which documents, information or data are passed from one grid service to can be seen as a Web service with additional grid-oriented features [11, 12]. Concep-tually, a grid workflow is a collection of activities, and the dependencies between sequential, parallel, selective and iterativ e. These activities are implemented and exe-cuted by corresponding grid services. The whole work process of grid workflow sys-tems can be divided into three stages: build-time stage, run-time instantiation stage and run-time execution stage. At the build-time stage, grid workflow specifications are defined by some grid workflow definition languages such as Grid Services Flow Language (GSFL), Service Workflow Language (SWFL) and Grid Workflow Execu-tion Language (GWEL) [2, 3, 11, 12]. At the instantiation stage, grid workflow in-stances are created, and especially grid services specified in the build-time definition documents are discovered. This could include an instantiation service that is a high-level grid service and responsible for finding factories on the Grid, downloading them to the local system and instantiating them [2 , 3, 12]. At the execution stage, the grid workflow instances are executed, and the execution is coordinated between grid ser-vices by a grid workflow engine which itself is a high-level grid service, hence auto-matically grid aware [2, 3, 12]. 
To control the temporal correctness of the grid workflow execution, some temporal constraints mainly including upper bound, lower bound and fixed-date constraints must be set when a grid workflow is defined at build time [4, 5, 7, 21] and the tempo-ral verification is carried out at the different stages. Currently, some relevant temporal verification works have been done. In [17, 18, 19], the authors propose some algo-rithms to adjust activity deadlines and esti mate the escalations and assign the predic-tive deadlines. [7] uses the modified Critical Path Method (CPM) to calculate tempo-reasoning at both build-time and run-time. [15, 16] present a method for dynamic verification of absolute and relative deadline constraints. However, these works and some others such as [1, 8, 13, 14, 20] do not take into consideration the dependency between temporal constraints. Although [4, 5] address the temporal dependency, they do not discuss it for fixed-date constraints, only for upper bound and lower bound constraints. In grid workflow systems, due to the complexity of large-scale sophisti-cated e-science and e-business processes, multiple fixed-date temporal constraints need to be set simultaneously. Hence the dependency between them must also be considered. Therefore, in this paper, we an alyse this dependency and its impact on the temporal verification in depth, and furthermore, we develop some new temporal veri-fication methods and algorithms. The comparison and evaluation show that these methods and algorithms can achieve better verification effectiveness and efficiency. 
The remainder of the paper is organised as follows. Section 2 describes some pre-liminaries. Section 3 discusses the dependency between fixed-date constraints. Sec-tion 4 describes the build-time fixed-date constraint verification considering the de-pendency. Section 5 discusses how to conduct the fixed-date constraint verification more efficiently based on the temporal dependency at the run-time instantiation and execution stages. Section 6 shows the benefits of our work through a comparison and evaluation. Section 7 concludes our contributions and points out the future work. Based on directed graph, a grid workflow can be represented by a grid workflow graph, where nodes correspond to activities and edges correspond to dependencies between activities, called flows. Here, we assume that execution dependencies be-tween activities form an acyclic graph and the grid workflow is well structured. Be-same way. Therefore, for convenience, in the remainder of this paper, we will use from Cie(w) , the corresponding grid workflow instances can be enacted. For each a i , we denote the minimum duration, maximum duration, start time at run-time, end time respectively [4, 5, 15, 16, 17, 18, 19]. If there is a fixed-date constraint at a i , we de-the minimum duration and the run-time real completion duration between them as discussion, in the remainder of this paper, we consider one execution path in the grid workflow and assume all activities which we will address are on this execution path. For every other execution path, the discussion is very similar. In addition, we assume tures between a i and a j , we can use the following two formulas to compute them. If there are parallel or selective structures between a i and a j , for each structure, we use the largest of the maximum durations of all branches as the maximum duration of the structure, and use the largest of the minimum durations of all branches as the mini-mum duration of the structure. Then, if we see each structure as an activity in terms of time, we are still able to use (1) and (2) to compute D(a i , a j ) and d(a i , a j ) . Rcd(a i ,a j )  X  D(a i , a j ) . 
The temporal verification is conducted stage by stage, from build-time stage, to run-time instantiation stage, and finally to run-time execution stage. At each stage, we can take it for granted that the temporal verification at previous stages is consistent. In addition, at the execution stage, we only conduct the temporal verification at some selected checkpoints because normally it is unnecessary to do so at each activity point constraints before the execution of a i are consistent. If at a certain stage or at a point, one of fixed-date constraints is violated, we may take some time adjustment measures to make it consistent. 
In terms of the consistency of fixed-date constraints, based on [7, 15, 16], we give the following definitions which are easy to understand. So, we do not explain them. stage if and only if D(a 1 , a i )  X  fd(a i )-Cie(w) . stage if and only if D(a 1 , a i )  X  fd(a i )-S(a 1 ) . a )+D(a p+1 , a i )  X  fd(a i )-S(a 1 ) . Definition 4. The fixed-date constraint at activity a i is consistent at a checkpoint after a at the execution stage if and only if Rcd(a 1 , a i )  X  fd(a i )-S(a 1 ) . Because all fixed-date constraints have the same start point, i.e. start activity a 1 , and are nested one after another, based on Allen X  X  interval logic [6, 22], we can conclude that there are two types of basic relationships between fixed-date constraints, as de-picted in Figure 1 and Figure 2 respectively. Figure 2 is the extension of Figure 1. 
In Figure 1, if fd(B)  X  fd(A) , then, if B is consistent, A must be consistent. If B is not consistent, even if A is consistent, we need to adjust the setting of B, which inevi-tably addresses A because A is included in B, and results in the necessity of re-verification of A. So, the current setting of A is unnecessary. Therefore, in Figure 1, we have fd(A) &lt; fd(B) . Now, we consider a more complicated situation. Based on Defi-nition 1 and the above discussion, if A and B are consistent and necessary, we have: 
Considering a grid workflow where fd(A)-Cie(w) =9.5, fd(B)-Cie(w) =11, D(a 1 , a ) =8 and D(a 1 , a j ) =10. Obviously, the above three inequations hold. In addition, we have: fd(A)-Cie(w)+D(a i+1 , a j )=fd(A)-Cie(w)+D(a 1 , a j )-D(a 1 , a i )= 9.5+10-8=11.5. Clearly, 11.5 is more than 11, which means: fd(A)-Cie(w)+D(a i+1 , a j ) &gt; fd(B)-we adjust the setting of B, we inevitably address the setting of A and need to re-verify the consistency of A. Therefore, the current setting of A is unnecessary. So, for the necessity of the existence of fixed-date constraints, in Figure 1, we have: fd(A)-Cie(w)+D(a i+1 , a j )  X  fd(B)-Cie(w) , namely, D(a i+1 , a j )  X  fd(B)-fd(A) . have: D(a 1 , a i )  X  fd(A)-Cie(w) (3) D(a 1 , a j )  X  fd(B)-Cie(w) (4) Then, if we omit the dependency between them, at the execution stage, we face the according to Definition 3, we must make sure that the following inequation holds: Rcd(a 1 , a i )+ D(a i+1 , a j )  X  fd(B)-S(a 1 ) (5)
Considering an extreme case where E(a i ) is equal to fd(A) , then, we have: Rcd(a 1 , a ) = fd(A) -S(a 1 ) . If we apply this equation to (5) , we can deduce that we must ensure: D(a i+1 , a j )  X  fd(B)-fd(A) (6)
The problem is that we cannot derive (6) from (3) and (4) that we only have. In fact, In overall terms, we can see that we must consider the dependency and we have: Definition 5. In Figure 1, the dependency between fixed-date constraints A and B is consistent if and only if D(a i+1 , a j )  X  fd(B)-fd(A) . 
Definition 5 ensures the consistency of the dependency between two fixed-date constraints. However, we still need to consider the dependency between multiple ones, as shown in Figure 2. The following theorem solves this problem. Theorem 1. In Figure 2, if the dependency between any two adjacent fixed-date con-straints is consistent, the dependency between any two non-adjacent fixed-date con-straints must also be consistent. the dependency between a j2 and a j3 is consistent, according to Definition 5, we have: D(a j1+1 , a j2 )  X  fd(a j2 )-fd(a j1 ) (7) D(a j2+1 , a j3 )  X  fd(a j3 )-fd(a j2 ) (8)
Now we prove that the dependency between a j1 and a j3 is also consistent. That is to say, the consistency is transitive. In fact, if we add (7) and (8) together, we can derive: D(a j1+1 , a j3 )  X  fd(a j3 )-fd(a j1 ) (9) consistent. So, Theorem 1 holds. At the build-time stage, accord ing to Section 3, for the effectiveness of the temporal verification, in addition to the verification of fixed-date temporal constraints them-selves, we still need to verify their temporal dependency. 
For each fixed-date constraint, say at a i , we compute D(a 1 , a i ) . Then, we compare it tent. Otherwise, it is violated. In addition, we still need to verify the dependency be-tween fixed-date constraints. Based on Definition 5 and Theorem 1, we only need to consider the dependency between any two adjacent fixed-date constraints. Taking Figure 1 as an example, to verify the consistency of the dependency between A and B difference, according to Definition 5, the dependency is consistent. Otherwise, the dependency is not consistent. 
Based on the above discussion, we can further derive Algorithm 1 for build-time verification. 5.1 Instantiation Stage Verification At the instantiation stage, grid workflow instances are enacted and we can get abso-lute start times. For a specific grid workflow instance, because its absolute start time may be different from the build-time expected time Cie(w) , the build-time consistency of the fixed-date constraints cannot ensure that they are still consistent at the instantia-tion stage. Therefore, we need to re-verify them. For each fixed-date constraint, say at a , we compute D(a 1 , a i ) . Then, we compare it with the difference between fd(a i ) and inconsistent. Otherwise, it is consistent. In terms of the dependency between fixed-date constraints, according to Definition 5, it has nothing to do with the absolute start time and the build-time expected time. Hence, we need not re-verify it. 5.2 Execution Stage Verification In this section, we will see that based on the temporal dependency discussed in Sec-tion 3, we can conduct the temporal verification more efficiently. According to Defi-nitions 3 and 4, actually, we only need to consider those fixed-date temporal con-straints which include the checkpoints [5, 15, 16]. 
Regarding the temporal verification of fixed-date temporal constraints in Figure 1, we have: Theorem 2. In Figure 1, given the build-time consistency of the temporal dependency between fixed-date constraints, at checkpoint a p between a 1 and a i , if A is consistent, B must be consistent. Proof: Because A is consistent, according to Definition 3, we have: Rcd(a 1 , a p )+D(a p+1 , a i )  X  fd(A)-S(a 1 ) (10)
In addition, according to the build-time c onsistency of the temporal dependency between fixed-date constraints, we have: D(a i+1 , a j )  X  fd(B)-fd(A) (11) tion 3, the fixed-date temporal constraint B at a j is consistent. So, Theorem 2 holds. Accordingly, regarding the temporal verification in Figure 2, we have: Theorem 3. In Figure 2, given the build-time consistency of the temporal dependency between fixed-date constraints, when the execution of a grid workflow instance reaches a checkpoint at activity a p , if a fixed-date constraint at an activity after a p is consistent, any fixed-date constraint after this consistent fixed-date constraint must also be consistent. point a p , the fixed-date constraint at a jk is consistent. Now, we prove that the fixed-date constraint at a jl must be consistent. Because the fixed-date constraint at a jk is consistent, according to De finition 3, we have: Rcd(a 1 , a p )+D(a p+1 , a jk )  X  fd(a jk )-S(a 1 ) (12)
At the same time, according to the build-t ime consistency of the temporal depend-ency between fixed-date temporal constraints at a jk and a jl , we have: D(a jk+1 , a jl )  X  fd(a jl )-fd(a jk ) (13) According to Definition 3, the fixed-date constraint at a jl is consistent. So, Theorem 3 holds. 
According to Theorems 2 and 3, when we conduct the temporal verification for fixed-date constraints in Figure 1 and Figure 2 at a checkpoint, starting from the first fixed-date constraint after it, we conduct the verification computation one after an-other until we meet a consistent fixed-date constraint or finish all fixed-date constraint verification. Suppose we now reach the fixed-date constraint at a jk and the checkpoint derive a sum. Then, we compare the sum with the difference between fd(a jk ) and S(a 1 ) . If the sum is less than or equal to the difference, the fixed-date constraint at a jk is consistent and according to Theorem 2, we need not conduct further verification computations and improve the efficiency of the temporal verification. If the sum is to verify the next one. 
Based on the above discussion, we can further derive Algorithm 2 for run-time verification. Comparing with the previous relevant verification work, in our paper, the clear differ-ences are that we have analysed the dependency between fixed-date constraints and its impact on the temporal verification of them in depth. The discussion in Sections 3 and 4 has shown its impact on the effectiveness of the temporal verification. We can see that, regardless of the temporal dependency, some temporal verifications are not based on the temporal dependency, we have derived some new methods and algo-rithms for more effective and efficient temporal verification. For the temporal verifi-cation effectiveness, we can see its improv ement clearly from the discussion in Sec-tions 3 and 4. 
To better understand the improvement on the temporal verification efficiency, we give the quantitative analyses detailed below. We take the situation in Figure 2 as an example to demonstrate the efficiency improvement because Figure 2 is more repre-sentative than Figure 1. In Figure 2, suppose there is a checkpoint, a p , between a 1 and a , and there are N fixed-date temporal constraints. When we conduct the temporal verification, the main computation is focused on the sum of the maximum durations between two activities. Therefore, we take each computation for addition as a compu-tation unit. And we compare the number of the computation units based on the tempo-ral dependency, i.e. with the temporal dependency, with that neglecting the temporal dependency, i.e. without the temporal dependency. We denote these two numbers as fd with and fd without respectively. Because in real-wor ld grid workflow environments, normally there are lots of grid workfl ow instances, we discuss the values of fd with and fd without in a statistical way. Suppose there are M inconsistent fixed-date constraints in units is jk-p . Therefore, we can derive the following three computing formulas: Intuitively, fd with is less than or equal to fd without because M  X  N . Now, we further ana-number M changing. For simplicity, we assume the distance between any two adja-cent fixed-date constraints in Figure 2 is the same, denoted as Q. Then, based on (14) , We take a set of values to see how they perform. Suppose Q=3, j1-p= 4, N= 10. The choice of these values does not affect our analyses because what we want is to see the trend of how fd with is less than fd without with the inconsistent fixed-date constraint num-fd From the above computing formulas and Table 1, we can see the following points: temporal verification for the first fixed-date constraint. This is the best case and cause all N or N -1 fixed-date constraints are inconsistent. For all other M , fd with is less than fd without , as indicated in Table 1 clearly. dependency, the more consistent fixed-date constraints, the less the amount of the ways the same. This means that, if we neglect the temporal dependency, no matter how we improve the activity execution for more consistent fixed-date constraints, we always conduct the same amount of the verification computation. In conclusion, only under the worst cases where all N or N -1 fixed-date constraints are violated, the amount of the fixed-date constraint verification computation based on the temporal dependency is equal to that neglecting the temporal dependency. In all other cases, based on the temporal dependency, we can conduct more efficient tempo-ral verification. In real-world grid workflow system environments, normally, the above two worst cases seldom happen. Otherwise, the corresponding grid workflow specifications or grid workflow execution environments would be difficult to use and need to be improved. More importantly, if based on the temporal dependency, when we improve the activity execution by grid services and the grid workflow specifica-tions in terms of the execution time and allowed maximum durations, we can improve the temporal verification efficiency significantly. However, if we neglect the temporal dependency, it does not make any difference. 
The proposed concepts, principles and new verification methods and algorithms can be regarded as a refinement of the grid workflow temporal verification. Firstly, at the build-time stage, besides the temporal verification for all fixed-date temporal constraints, we still need to verify the dependency between them. Secondly, at the execution stage, we use these new verification methods and algorithms based on the temporal dependency to verify fixed-date constraints as described in this paper. In this paper, the temporal dependency between fixed-date constraints in grid work-flow systems is explored and its impact on the temporal verification is analysed. Fur-thermore, based on the temporal dependency, some new verification methods and algorithms are presented. The comparison and evaluation show that based on the temporal dependency, with these new methods and algorithms, we can conduct more effective and efficient temporal verification for fixed-date constraints. All these dis-cussions, relevant concepts, principles and new verification methods and algorithms further reinforce the grid workflow time management. With these contributions, we can further consider some problems such as temporal adjustment methods when a fixed-date constraint is violated, the predictive mecha-nisms by which we can predict future possible violations. The work reported in this paper is partly supported by Swinburne Vice Chancellor X  X  Strategic Research Initiative Grant 2002-2004. It is also partly supported by the Na-tional Natural Science Foundation of China under grant No.60273026 and grant No.60273043. 
