 Michael Schnall-Levin mschnall@math.mit.edu Leonid Chindelevitch leonidus@math.mit.edu Bonnie Berger 1 bab@mit.edu Probabilistic grammatical formalisms such as hidden Markov models (HMMs) and stochastic context-free grammars (SCFGs) have found many applications in areas such as computational biology and natural lan-guage processing. Because of their intuitive repre-sentation, their power to capture some of the essen-tial relationships present in data, and the existence of polynomial-time algorithms (such as the Viterbi al-gorithm) and practical training procedures (such as the Baum-Welch algorithm), these formalisms have en-joyed tremendous popularity in the past decades. Three natural problems for a model have been de-scribed: the decoding problem (given a model and a sequence, find the most likely derivation), the evalua-tion problem (given a model and a sequence, find the likelihood of the sequence being generated), and the learning problem (given a set of sequences, learn the parameters of the underlying model). In this paper, we identify another natural problem on HMMs and SCFGs, which is the inverse of the decoding problem: given a derivation and a model, find a sequence for which this derivation is the most likely one. Because the decoding problem is solved by the Viterbi algo-rithm in HMMs and by the CKY algorithm in SCFGs, we refer to our problem for these two models as the Inverse-Viterbi and the Inverse-CKY problem, respec-tively.
 The motivation for our problem comes from protein and RNA design. The design of biological molecules with a desired structure is a long sought-after goal in computational biology. While a number of achieve-ments have been made in protein structure design, the problem remains difficult (Butterfoss &amp; Kuhlman, 2005; Park et al., 2004; Pokala &amp; M., 2001). For RNA, there has been recent interest in secondary structure design (Breaker, 1996), and a number of fairly suc-cessful heuristics have been developed to solve this problem (Hofacker, 1994; Andronescu, 2004; Busch &amp; Backofen, 2006). Generally, structure design can be divided into two goals: the positive-design aspect of finding a sequence that has low energy in the desired structure, and the negative-design aspect of blocking the sequence from having low energy in other struc-tures. While some work has explored the negative-design aspect in protein structure design (Butterfoss &amp; Kuhlman, 2005), most work has focused solely on the positive-design aspect. In RNA secondary struc-ture design, the positive-design aspect is largely triv-ial (desired paired positions in the secondary structure can simply be chosen to be complementary bases) and the negative-design aspect, which involves attempting to block erroneous base pairings in other structures, is central to solving the problem.
 Our goal in formulating the Inverse-Viterbi and Inverse-CKY problems is to simultaneously capture the positive-design and negative-design aspects of the design problem. Our framework for viewing design within the context of HMMs or SCFGs is the follow-ing. When HMMs (SCFGs) are used for structure prediction, the emitted string represents the biologi-cal sequence and the goal is to find the hidden state-path (derivation tree for SCFGs) that represents the structure this sequence will adopt. A state-path of high probability for that sequence is the analogue of a structure with low energy. By inverting this problem, we can use the same HMM (SCFG) for design. Now, a state-path (derivation tree) representing the desired structure is known and the goal is to find a sequence which will adopt this structure (i.e. a string for which this state-path is optimal).
 Our Contribution. We have defined a novel prob-lem (the Inverse-Viterbi problem) on HMMs and its analogue on SCFGs, that as far as we know has never been studied before. We show that the problem is NP-hard for HMMs (and as a result for SCFGs). We then give approaches for making the problem tractable. In particular, for HMMs we give a branch-and-bound al-gorithm. This algorithm can be shown to have fixed-parameter tractable running time: if there are K states, the emission alphabet is  X , the path length is n , and all of the log-probabilities in the model are greater than  X  B (so that there are no 0 transition probabili-ties and all the probabilities in the model are greater than e  X  B ) and are defined to a precision  X  , then the branch-and-bound algorithm has worst-case running time O ((2 B/ X  ) K  X  2 nK 2 |  X  | ), which is exponential in the number of states but linear in the path length. We also show how to cast the problem as a simple Mixed Integer Linear Program.
 Our hardness proof shows that the RNA secondary structure design problem is hard in a certain sense: a polynomial-time algorithm that only depends on the energy model for RNA secondary structure be-ing SCFG-like, as is the case for the Zuker energy model (the most successful model curently available for RNA secondary structure prediction (Zuker &amp; Stiegler, 1981)), without making additional assump-tions on the particular form of the energy model, is not possible unless P = N P .
 In presenting an abstract formulation of the design problem and giving the theoretical results derived in this paper, our goal is not to provide methods that will necessarily be immediately applied to the protein or RNA structure design problems. Instead, we believe that the abstract framework given in this paper may prove to be useful in understanding the design problem and facilitating the development of new methods for design. The Inverse-Viterbi and Inverse-CKY prob-lems are novel and natural problems on HMMs and SCFGs, and so we believe a theoretical exploration is interesting in its own right. 2.1. Definition of the Models An HMM consists of a set N of K states and an al-phabet  X , with N  X   X  =  X  . The symbols in  X  are emitted on transitions between the states. The proba-bility of emitting the symbol a when transitioning from the state s k to the state s l is specified by the value of the parameter p a s HMM. We assume (without loss of generality) that there is a unique initial state S .
 The normalization condition requires that Similarly, an SCFG consists of a set N of K non-terminal symbols, and a set  X  of terminal symbols, with N  X   X  =  X  . The non-terminals are rewritten according to a set R of rewriting rules. The prob-ability of applying each rewriting rule  X  is specified by the value of the parameter p  X  . These parameters determine the SCFG. We assume (without loss of gen-erality) that there is a unique starting non-terminal symbol S .
 Every rule  X  replaces a single non-terminal with a string  X  of non-terminals and terminals: Here N k (the terminal symbol being rewritten) is re-ferred to as the left-hand side of the rule, abbreviated as l (  X  ).
 The normalization condition requires that We do not insist that the SCFG be in Chomsky Nor-mal Form (CNF) because in some applications (such as RNA secondary structure design), the correspon-dence between the design and inverse problem defined in this paper may only be natural if the SCFG is not converted to CNF.
 We use boldface letters to indicate sequences of sym-bols. A state-path of length n in the HMM is written as  X  =  X  1 . . .  X  n , where each  X  i is a state in the HMM. Such a path emits a sequence of n  X  1 emission sym-bols,  X  =  X  1 . . .  X  n  X  1 where each  X  i is a symbol from  X . The joint probability of a state-path  X  and an emis-sion sequence  X  is given by Pr(  X  ,  X  ) = Q n  X  1 i =1 p  X  It is frequently more convenient to deal with sums rather than products, and so we work in log-space, tak-ing q a s P A derivation of length n in the SCFG is the suc-cessive application of rewriting rules, beginning with the starting symbol S , which generates a yield  X  =  X  1 . . .  X  n where each  X  i is a symbol from  X . The derivation can be summarized in the form of a tree T . The joint probability of a derivation tree T and a yield  X  is given by Pr( T ,  X  ) = Q  X   X  X  ( T ) p  X  , where R ( T ) denotes the multiset of rewriting rules used to derive T . As with HMMs, it is convenient to work instead with the log-probabilities, q  X  := log p  X  , which gives log(Pr( T ,  X  )) = P  X   X  X  ( T ) q  X  . 2.2. Definition of the Direct Problem In the original Viterbi problem, one is given an emis-sion sequence  X  0 from an HMM and the goal is to find the most likely state-path to have generated  X  0 : the  X  that maximizes the conditional probability given the emission Pr(  X  |  X  0 ). Since Pr(  X  |  X  0 ) = Pr(  X  ,  X  0  X  0 is fixed, it is equivalent to simply maximize the joint probability Pr(  X  ,  X  0 ). The Viterbi problem can therefore be expressed as: given  X  0 , find an element of arg max  X  Pr(  X  ,  X  0 ) (we consider arg max as the set of all arguments maximizing the function). For an HMM with K states and an emission of length n , the Viterbi algorithm finds the best state-path using dynamic pro-gramming in time O ( nK 2 |  X  | ) (Viterbi, 1967). Similarly, the direct problem for an SCFG is formu-lated as follows: given a yield  X  , find the deriva-tion tree T which maximizes the joint probability Pr( T ,  X  ). In other words, given  X  , we find an ele-ment of arg max T Pr( T ,  X  ). The optimal derivation is referred to as the Viterbi parse of  X  . For a deriva-tion of length n in an SCFG with rewriting rules R in Chomsky Normal Form, the CKY algorithm finds the Viterbi parse in time O ( n 3 |R| ) (Durbin et al., 1999). Modified versions of the CKY algorithm can also han-dle SCFGs in similar forms, such as those used in RNA structure prediction, with the same time complexity (for example see (Dowell &amp; Eddy, 2004)). 2.3. Definition of the Inverse Problem In the Inverse-Viterbi problem, a desired output of the Viterbi algorithm is known and the goal is to de-sign an input to the Viterbi algorithm that will re-turn this output. In mathematical terms the problem is: given a state-path  X  0 , find an  X  so that  X  0 is in arg max  X  Pr(  X  ,  X  ), or determine that none exists. In an HMM used for structure prediction, the above definition of the inverse problem captures what it means to do structure design: one knows the struc-ture (state-path) and tries to find a sequence that has a higher score with that structure than with any other structure. It is important to emphasize that for many  X  there will be no such  X  . In fact, it can be shown that only polynomially many paths are designable (Elizalde &amp; Woods, 2006). This captures the notion that many structures are not designable: there is no sequence that will lead to these structures.
 To illustrate this distinction, consider the 2-state HMM shown in Figure 1. Say that the desired state-path to design is B n = B . . . B . The most likely emis-sion given this state-path is a n  X  1 = a . . . a , but when run on such a path the Viterbi algorithm will not re-turn B n . In fact, the only sequence that the Viterbi algorithm will return B n on is b n  X  1 . This simple case illustrates that to design a path of all B  X  X  it is impor-tant not just to pick emissions likely given this path, but to simulatenously block other possible paths, in this case those paths containing A  X  X . Note further that the probability of b n  X  1 being emitted from B n at ran-dom is (0 . 2) n  X  1 . Therefore, neither picking the most likely emission sequence nor randomly generating se-quences from the state-path will in general solve the Inverse-Viterbi problem with probability greater than exponentially small in the length of the state-path. We incorporate one generalization into our definition of the problem of inverting the Viterbi algorithm, be-cause it seems natural to the design problem. We allow constraints on the emissions that can be chosen in any position (given as the  X  i below). The algorithms we develop in this paper handle this generalization with-out any added complexity.
 INVERSE-VITERBI : Input: An HMM, a state-path  X  0 of length n and for every position i in 1 , . . . , n a set  X  i  X   X  giving allowed emissions at position i .
 Output: An  X  where each  X  i  X   X  i so that  X  0 is in arg max  X  Pr(  X  ,  X  ), or  X  if no such  X  exists. Similarly, the inverse problem for an SCFG requires one to find an input that corresponds to a given out-put. In other words, given a derivation T 0 , we would like to find an  X  such that T 0 is in arg max T Pr( T ,  X  ), or determine that none exists. Note that this problem only makes sense if the tree T 0 has had all of its leaves removed (we will call such a tree  X  X aked X ); in other words, the tree includes the specification of non-terminals but not the terminal symbols produced. INVERSE-CKY: Input: An SCFG, a naked derivation tree T 0 that corresponds to an emitted string of n terminals and for every position i in 1 , . . . , n a set  X  i  X   X  giving the allowed emissions at position i .
 Output: An  X  where each  X  i  X   X  i so that T 0 is in arg max T Pr( T ,  X  ), or  X  if no such  X  exists. 2.4. NP-hardness of the Inverse Problem We now prove that the Inverse-Viterbi problem is NP-hard. To do so, we introduce the decision problem corresponding to Inverse-Viterbi: DESIGNABLE : Input: An HMM and a state-path  X  0 Output: YES if there is an  X  so that  X  0 is in arg max  X  Pr(  X  ,  X  ), otherwise NO.
 An algorithm that solves Inverse-Viterbi would also solve Designable and so by proving Designable is NP-complete, we show that Inverse-Viterbi is NP-hard.
 Theorem 1. Designable is NP-Complete.
 Proof. Clearly Designable is in NP so we just need to show Designable is NP-hard. We do so by presenting a polynomial-time reduction from 3-SAT to Designable. In outline, the construction is achieved by creating an HMM with one component that can emit all possi-ble non-satisfying assignments for the 3-SAT problem along with a special state outside of this component that can emit all binary strings, but that does so with smaller probability. Because this probability is small, the path consisting of repeatedly being in the special state is only designable if a specific sequence of 0 X  X  and 1 X  X  could not possibly be emitted by the component corresponding to the 3-SAT formula. And such a se-quence is, by the construction, a satisfying assignment of the 3-SAT formula.
 In full detail, the construction is as follows (see Fig-ure 2 for an illustration). Assume the 3-SAT formula consists of m variables and r clauses. The HMM con-sists of a begin state B , two special states S and T and r ( m + 1) states labelled X i,j where 1  X  i  X  r and 1  X  j  X  m + 1. The emission alphabet consists of 0, 1, and the special symbol #. The state B transitions to either S or any of X i, 1 with equal probability, 1 r +1 while emitting #. The state S transitions to itself while emitting 0 or 1, each with probability 1 2 . The state T transitions to itself with probability 1 while emitting #. The r sets of states X i, 1 , . . . , X i,m +1 1  X  i  X  r are arranged in independent chains, each corresponding to the i th clause, that emit all strings { 0 , 1 } m that do not satisfy the i th clause. Such a chain is constructed by the following: if the i th clause con-tains the j th variable un-negated then X i,j transitions to X i,j +1 while emitting 0 with probabilty 1, if the i th clause contains the j th variable negated then X i,j transitions to X i,j +1 while emitting 1 with probabilty 1, and if the i th clause doesn X  X  contain the j th variable then X i,j transitions to X i,j +1 while emitting 0 or 1 each with probability 1 2 . Finally, X i,m +1 transitions to T while emitting # with probability 1.
 The state-path to design is BS m +1 . We observe that the joint probability of this state-path and an emis-sion sequence of the form # { 0 , 1 } m is ( 1 r +1 )( 1 2 that only emissions of this form have non-zero proba-bility for this state-path. We further observe that the only other state-path that could emit such a sequence must be of the form BX i, 1 . . . X i,m +1 , and the joint probability of such a sequence and such a state-path is ( 1 r +1 )( 1 2 ) m  X  3 if the emission sequence contains a # followed by a non-satisfying assignment to the 3-SAT formula, but the joint probability is zero if the emis-sion sequence contains a # followed by a satisfying as-sequence that could design BS m +1 is a # followed by a satisfying assignment and therefore BS m +1 is des-ignable if and only if there is a satisfying assignment to the 3-SAT formula.
 The above construction is done in polynomial time, and therefore we have successfully given a polynomial reduction from 3-SAT to Designable.
 Corollary 1. Inverse-CKY is NP-hard.
 Proof. An HMM can be thought of as an SCFG with a non-terminal corresponding to each state and a ter-minal to each letter in the emission alphabet. Every branching rule rewrites a state as a letter and another state, so that all derivation trees are right-branching. Since the problem is hard on HMMs it is also hard on the extended class of SCFGs.
 In this section, we give two approaches for finding a solution to the inverse problem, a branch-and-bound algorithm and a formulation of the problem as a Mixed Integer Linear Program. Both of these are derived from the same basic approach, based on a set of con-straints we develop that are satisfied by an  X  if and only if it is a solution to the inverse problem. Below we first develop these constraints. Similar constraints and a Mixed Integer Linear Program can be developed for SCFGs. For reasons of space and simplicity of presen-tation, we only give the details for HMMs in this sec-tion. We illustrate the formulation of constraints and a Mixed Integer Linear Program for an SCFG used for RNA secondary structure prediction in a supplement. 2 3.1. Constraint Formulation Conceptually, the set of inequalities for HMMs is de-rived by looking at how the Viterbi algorithm works and enforcing constraints on  X  so that the Viterbi al-gorithm is forced to return the desired state-path  X  0 . The Viterbi algorithm calculates an n by K table of values M i,s of the best log-probability scores for the state-path from positions 1 to i with final state s . Be-cause of the special form of the HMM score, this table can be filled in iteratively: (1) M 1 ,S = 0 and M 1 ,s =  X  X  X  for all s 6 = S all s The best state in the n th position is then read off as  X  n  X  arg max s ( M n,s ), and the earlier ones are read off by a traceback routine: the best state in position n  X  1 From the above we can directly read off the con-straints on the emission symbol  X  i in position i for 1  X  i  X  n  X  1, that need to be satisfied in order to design a state-path with states  X  i . For the Viterbi algorithm to return the desired path, we need for every state in this path to traceback to the previous state in the desired path and for the last state in this path to have the best log-probability score: 1  X  i  X  n  X  1 3.2. Branch-and-Bound Algorithm What is particularly nice about inequalities (1)-(4) is that they allow for an inductive method for choosing possible  X  i in an emission sequence based only on the choices of  X  j for 1  X  j  X  i  X  1. This is because the inequality constraining the choice of  X  i (inequality 3 above) only depends on the values for M i,s . And the values for M i,s only depend on the choices made for  X  1 through  X  i  X  1 . This naturally leads to a branch-and-bound algorithm. Branch-and-bound algorithms are frequently useful in solving computationally hard problems. A branch-and-bound algorithm is complete (it always finds the correct answer) and frequently ef-ficient on many problem instances.
 The branch-and-bound algorithm steps through posi-tion i from 1 to n  X  1, at each step maintaining a list of emission sequences of length i that could be extended to possible length n  X  1 sequences the algorithm will ultimately return. At each step i , the algorithm forms emission sequences of length i from the emission se-quences of length i  X  1 stored in the previous stage by appending possible emission symbols onto the se-quences from the previous stage. In order to avoid performing an exhaustive search, at every stage the algorithm prunes the search space by applying two elimination rules. The first elimination rule ensures that for a given length i  X  1 sequence from the previ-ous stage, an  X  i is only appended onto this sequence to form a length i sequence if the traceback constraint (constraint 3) is satisfied by the choice  X  i . The sec-ond elimination rule examines pairs  X  and  X   X  of partial strings of length i that remain after the application of the first elimination rule. It eliminates  X  due to  X   X  , if given that  X  can be extended to a solution to the de-sign problem, then  X   X  must also be able to be extended to a solution.
 Specifically, the second elimination rule is based on the following observation. If for all states s , M it is under  X  (i.e. if for all states s , the relative prefer-ence of  X   X  for  X  i to state s is at least as large as that of  X  ), then the traceback constraints (inequality 3 above) on all positions j for j &gt; i and the ending constraints (inequality 4 above) can only be easier to satisfy when extending  X   X  than when extending  X  .
 It is important to note that for the case of a 2-state HMM the branch-and-bound is an exact polynomial-time algorithm. This is because there is only one M  X  i on (there is only one state s other than  X  i at every position since there are only 2 states to choose from), and so there is always a best choice for  X  i at every position based on the past choices.
 The above branch-and-bound algorithm is exact for all HMMs, but has no guaranteed worst-case running time. If we make additional assumptions about our HMM, however, we can show that the algorithm also has fixed-parameter tractable running time. Specifi-cally, we assume that all q values (the log-probabilities) Algorithm 1 Branch-and-Bound Algorithm
Input: An HMM, a desired state-path  X  0 of length n , and for every position i in 1 , . . . , n a set  X  i  X   X  giving the allowed emissions at position i
Output: A sequence  X  such that  X  0 is in arg max  X  Pr(  X  ,  X  ) or  X  if no such sequence exists.
Variables: A list L i of all partial sequences of length i considered at the i th iteration each together with its corresponding K -vector of values M i,s .
Initialize: L 0 = { ( , 0 ) } for i = 1 to n  X  1 do end for end for Return: An element of L n  X  1 or  X  if L n  X  1 is empty.
Elim Rule 1: Eliminate  X  i if M i, X  i + q  X  i  X 
Elim Rule 2: Eliminate  X  i due to  X   X  i if  X   X  i  X  L i has ( K  X  1)-vector u componentwise  X  that of w i satisfy q  X   X  B and that there are no zero probabili-ties in the model. Furthermore, we assume that these q values have been rounded off to precision  X  . Under these assumptions, we can see that any two val-follows from the definitions: M M Let the maximum in the expression for M i,s be at-tained with s 0 . Then so that, upon rearranging, and by symmetry, we also get M i,s 0  X  M i,s  X  B , so In particular, only 2 B/ X  distinct values are possible for each of the ( K  X  1) possible M i, X  i  X  M i,s values. In the branch-and-bound algorithm, it is only impossible to remove either  X  or  X   X  (both of length i ) due to the other if they are incomparable: the values one gives for M i, X  i  X  M i,s are larger for some s and smaller for some other s . But there are only (2 B/ X  ) K  X  2 incomparable values: for two sequences that share the first ( K  X  2) M i, X  i  X  M i,s values, any values for the last M i, X  i  X  M will make them comparable.
 Therefore, in the branch-and-bound algorithm there are at most (2 B/ X  ) K  X  2 sequence possibilities that must be retained at any stage, and so with a care-ful implementation the running time of the algorithm is O ((2 B/ X  ) K  X  2 nK 2 |  X  | ). This bound is exponential in the number of states, but linear in the length of the structure to be designed. (This bound is inde-pendent of the base used to get the q values (log-probabilities), because changing the base introduces a factor into both B and  X  that cancels.) For SCFGs in CNF, a similar idea allows one to obtain an exact algorithm that runs in polynomial time if there are only 2 non-terminal symbols. However, the idea used above for candidate string elimination does not immediately generalize to SCFGs because of their non-linear nature; an HMM outputs one symbol per state, but a non-terminal in an SCFG can generally end up producing any substring of the output string. 3.3. Casting the Problem as a Mixed Integer We can also start with the inequalities that must be satisfied for  X  and cast the inverse problem as the problem of finding a feasible solution to a Mixed In-teger Linear Program. We provide this simple formu-lation because it allows both practical and theoretical tools developed for integer programming to be applied directly to our problem.
 The formulation as a Mixed Integer Linear Program is done by defining 0-1 variables i,j , where i,j = 1 indicates that the j th emission symbol is chosen for  X  . Enforcing that there is only one emission choice made at every position is equivalent to requiring P j i,j = 1 for i = 1 to n  X  1. Each maximum in the constraints is replaced by  X  , while the traceback constraints are enforced by additional equalities. Integer Linear Program For HMMs: Objective: Feasible Solution Variables: i,j , 0-1 valued, for 1  X  i  X  n  X  1 and 1  X  j  X |  X  | M i,s , for 1  X  i  X  n and 1  X  s  X  K Constraints: P j i,j = 1 for all 1  X  i  X  n  X  1 i,j = 0 if j /  X   X  i for all 1  X  i  X  n  X  1 M 1 ,S = 0 and M 1 ,s =  X  X  X  for all s 6 = S M i  X  2 M M We implemented our branch-and-bound algorithm and examined its running time on synthetic data in or-der to demonstrate that in practice the algorithm fre-quently runs fast when an exhaustive search would be infeasible. In order to do this, we randomly generated HMMs by drawing each-transition-emission pair prob-ability from the uniform distribution and then normal-izing the values, rounding off to precision  X  = 0 . 01. We then separately generated both arbitrary state-paths and designable state-paths at random from this HMM (the latter by randomly sampling emission sequences and running the Viterbi algorithm on these sequences) and timed our branch-and-bound algorithm on these instances. We found that our algorithm ran signifi-cantly faster on arbitrary paths, the majority of which are not designable, than on arbitrary designable paths (taking milliseconds rather than seconds per run). Figure 3 shows running times of simulations on ran-dom designable state-paths for different numbers of states K and path lengths n , with fixed emission al-phabet of size |  X  | = 20. For each pair of K and n val-ues, 10 HMMs were generated at random and for each of these HMMs, 10 designable paths were generated at random, as described above. The branch-and-bound algorithm was then run and the average time to design a sequence over these 100 runs was recorded. On these problem instances, the running time of the algorithm scales roughly linearly with path length n . Interest-ingly, while the running times initially increased with increasing K values, the running times were lower for K = 50 and K = 100 than for K = 20, an observa-tion that was repeated for multiple experiments. The longest run of the algorithm took 80 seconds. A so-lution by exhaustive search would require examining |  X  | n possible sequences, which for that run would have been 20 400 sequences. All code was implemented in Matlab and run on a 3.06 GHz Intel Xeon PC. We have introduced a novel problem on HMMs and SCFGs, the Inverse-Viterbi problem, inspired by pro-tein and RNA structure design, and have given a num-ber of theoretical results for the problem. In partic-ular, our hardness result demonstrates that a polyno-mial time algorithm for RNA secondary structure de-sign that only exploits the general form of the Zuker energy or similar SCFG models (and not the particu-lars of a specific model) is not possible unless P = N P . There are a number of possible extensions to this work. Developing more efficient algorithms on both HMMs and SCFGs may be possible and in particular, extend-ing our branch-and-bound algorithm to SCFGs would be useful. It is also possible to explore extensions of the problem to more general probabilistic models such as Markov Random Fields. The framework given here may also be useful for developing new algorithms for design in specific applications. Areas where the negative-design aspect plays a large role, such as RNA secondary structure design, are the most likely can-didates to benefit from such an approach. Given the widespread use of grammars, the inverse problem we have defined here may find applications to other fields. The authors thank Andreas Schulz, Michael Baym, J  X er X ome Waldisp  X uhl, Mathieu Blanchette, and partic-ularly Michael Collins for advice and helpful discus-sions. M. Schnall-Levin is supported by NDSEG and Hertz Foundation fellowships and L. Chindelevitch is supported in part by an NSERC PGS-D Scholarship. Andronescu, M. e. a. (2004). A new algorithm for RNA secondary structure design. Journal of Molecular Biology , 336 , 607 X 624.
 Breaker, R. R. (1996). Are engineered proteins get-ting competition from RNA? Current Opinion in Biotechnology , 7 , 442 X 448.
 Busch, A., &amp; Backofen, R. (2006). INFO-RNA-a fast approach to inverse RNA folding. Bioinformatics , 22 , 1823 X 1831.
 Butterfoss, G., &amp; Kuhlman, B. (2005). Computer-based design of novel protein structures. Annual
Review of Biophysics and Biomolecular Structure , 35 , 49 X 65.
 Dowell, R., &amp; Eddy, S. (2004). Evaluation of sev-eral lightweight stochastic context-free grammars for
RNA secondary structure prediction. BMC Bioin-formatics , 5 .
 Durbin, R., Eddy, S., Krogh, A., &amp; Mitchison, G. (1999). Biological sequence analysis: Probablistic models of proteins and nucleic acids . Cambridge University Press.
 Elizalde, S., &amp; Woods, K. (2006). Bounds on the number of inference functions of a graphical model. ArXiv Mathematics e-prints , math/0610233 .
 Hofacker, I. L. e. a. (1994). Fast folding and compar-ison of RNA secondary structures. Monatshefte f. Chemie , 125 , 167 X 188.
 Park, S., Yang, X., &amp; Saven, J. G. (2004). Advances in computational protein design. Current Opinion in Structural Biology , 14 , 487 X 494.
 Pokala, N., &amp; M., H. T. (2001). Review: Protein design-where we were, where we are, where we X  X e going. Journal of Structural Biology , 134 , 269 X 281. Viterbi, A. J. (1967). Error bounds for convolution codes and an asymptotically optimum decoding al-gorithm. IEEE Transactions on Information The-ory , 13 , 260 X 269.
 Zuker, M., &amp; Stiegler, P. (1981). Optimal computer folding of large RNA sequences using thermodynam-ics and auxiliary information. Nucleic Acids Re-
