 SimRank is a useful and important similarity measure exploiting the relationships be-tween vertices (web documents) on web graphs. It has been widely studied in the lit-their neighbors are similar . SimRank has broad applications involving  X  X ind-similar-document X  query, search engine optimization, graph clustering, etc.

Existing techniques for SimRank computation can be distinguished into two cate-gories: (i) probabilistic method [3,4] that estimates SimRank by the expected value for vertices a and b ,and c  X  (0 , 1) is a decay factor; (ii) deterministic method [1,5,6,7] that computes SimRank iteratively for finding a fixed point of the SimRank function s ( a, b ) . Since the latter approach produces be tter accuracy with high time complexity compared to the proba bilistic method, there has been a g rowing interest in SimRank deterministic optimization over the recen t years. To the best of our knowledge, there are several interesting pieces of work whic h can efficiently reduce the time complexity of SimRank deterministic computation. One work [1] is mainly based on a partial sums function reducing the computational time from O Kn 4 to O Kn 3 in the worst case. Another work [7] oriented on matrix representations takes O ( K m in ( mn, n r )) time, where m is the number of edges, and r  X  ( 2 , lo g 2 7 ] is a positive constant. Li et al. [10] develop a novel approximate SimRank computation algorithm for static and dy-namic information networks. They claim that their optimization technique is based on the non-iterative framework; however, the singular value decomposition (SVD) method they used for low-rank approximation inherently requires numerical iterations. Hence, their method is in essence iterative, not non-iterative. Details are described in the Re-lated Work section.
 Motivations: In spite of the substantial improvement achieved by these existing tech-niques [1,7], high performance of SimRank computation involving fast algorithms and parallel implementation is still a challenging problem. However, the time requirements of the available SimRank deterministic algorithms are still about cubic in the number of vertices for each iteration, which is costly over large web graphs. Additionally, in terms of parallelization strategies for SimRank computation, there is only one research work concerning SimRank optimization [3]. That work is based on SimRank probabilistic computation. As for SimRank deterministic computation, parallel implementation has not been addressed in scientific literature yet. This motivates our further exploration of SimRank deterministic optimization.
 Contributions: In this paper, we provide efficient techniques for SimRank determinis-tic computation and parallelization on undirected graphs. The interesting aspect of our algorithm is that it uses a variant of eigenvector centrality measure , and we are able to prove strong theoretical guarantees on its performance. In summary, we make the following contributions:  X  We present an efficient spectral decomposition based algorithm for SimRank com- X  We develop a block partition technique in combination with the Parallel Linear  X  We perform extensive evaluations of our proposed methods by using synthetic and Organizations: The rest of this paper is organized as follows. Sect. 2 provides formal definition of SimRank similarity measure. Sect. 3 details optimization techniques for AUG-SimRank algorithm. Sect. 4 presents a p arallel implementation of AUG-SimRank algorithm. We present experimental evaluati ons in Sect. 5. Sect. 6 reviews related work. And Sect. 7 concludes this paper. In this section, we briefly introduce the fundamental concepts, and formulate the basic problem of SimRank similarity scoring on undirected graphs. More details can be found in [2,1,7]. 2.1 Problem Statement Assume an undirected web graph G =( V, E ) ,where V is the set of vertices represent-ing web documents, and E is the set of edges. Each edge ( p, q )  X  E between documents p and q corresponds to a reference between p and q . We denote the derived graph as G 2 = V 2 ,E 2 , where (a) each vertex in V 2 = V  X  V represents a pair ( p, q ) of ver-Definition 1 (SimRank similarity [2]). For two arbitrary vertices a and b ,let s : V 2  X  [0 , 1]  X  R be a real-valued function on G 2 defined by where c  X  (0 , 1) is a constant decay factor , N ( a ) denotes the set of vertices neigh-is referred to as N i ( a )(1  X  i  X | N ( a ) | ) . The scalar s ( a, b ) is called a SimRank similarity score between vertices a and b .
 the following iterations to a fixed point.
 Lemma 1 (SimRank iterative computation [1]). For two arbitrary vertices a and b , s ( by the following iterations: s And the sequence s ( k ) nondecreasingly converges pointwise to a unique fixed point s , i.e., In matrix forms [7], Eq.(2) and Eq.(3) can be written as similarity score between documents i and j at the k -th iteration.
 2.2 Symbol Definitions In Table 1, we list the notations used throughout this paper. Note that symbols defined and referenced in a local context are not listed here.
 In this section, we show an efficient algorithm to optimize the iterative SimRank com-putation over undirected graphs. We first formally introduce the notion of a graph spec-trum in our paper 1 .
 Definition 2 (web graph spectrum). Given a web graph G ,let Q G denote its transition probability matrix (i.e. the transpose of a colu mn-normalized adja cency matrix). The spectrum of a web graph G is defined to be the set of the eigenvalues of Q G . In symbols, Generally, for an arbitrary graph G , the elements in  X  ( G ) , given by the roots of the characteristic polynomial of the matrix Q G , might be complex numbers. However, for undirected graphs, due to its symmetric adjacency matrix, we have the following special property of the spectrum.
 Theorem 1. Given an undirected graph G , all the eigenvalues of its transition proba-bility matrix Q G are real numbers associated with a complete set of orthonormal eigen-vectors.
 Proof. Recall from linear algebra that an elementary row transformation on any row of Q corresponds to a row-multiplying operation on Q [11]. Therefore, Q G can be denoted as Q =  X   X  P ,where  X  is the real diagonal matrix normalizing P ,and P is the real symmetric adjacency matrix of G .

Then we assume that Q contains complex eigenvalues. Let  X   X  , X  P , X  Q  X  C be the eigenvalues of  X  , P and Q respectively. We need to show that  X  Q =  X  Q for all  X  Taking complex conjugate of both sides, and noticing that  X  =  X  T , P = P T ,we obtain Hence,
Also,
Thus, Therefore, for an undirected graph, every eig envalue of the trans ition probability matrix Q G is a real number.

Additionally, the characteristic polynomial det ( Q  X   X  Q  X  I n ) has n roots, which implies that there exists a complete spectral decomposition for undirected graphs. ! Theorem 1 presents a sufficient condition that Q G has a complete real spectral decom-position, which can be applied to optimize SimRank iterative similarity computation over undirected graphs as follows.
 Theorem 2. For an undirected graph G ,let Q = U  X   X   X  U  X  1 be a complete spectral decomposition of its tr ansition probability matrix Q ,where U is an orthogonal matrix with real entities whose columns are eigenvectors of Q , and  X  is a real diagonal matrix whose diagonal entities give the corresponding eigenvalues. Then we can construct the following iteration: where diag (  X  ) is a column vector whose ele ments are the main diagonal of  X  , and " is an element-wise matrix multiplication operator 2 .
 And SimRank similarity can be thereby obtained as follows: Proof. When k&gt; 0 , we substitute Q = U  X   X   X  U  X  1 back into the naive SimRank matrix equation (5) to get Theorem 1 guarantees that the decomposition Q = U  X   X   X  U  X  1 is complete, which implies that U and  X  are nonsingular. Now we premultip ly and postmultiply both sides of Eq.(8), respectively, by U  X  1 and U to produce U Applying U  X  1  X  U = I n and U  X  T = U to the above equation yields We may assume that  X  S k := U  X  1  X  S k  X  U , and obtain When k =0 , it follows from our assumption  X  S k := U  X  1  X  S k  X  U that In the following, we show that  X   X   X  S  X   X  = diag (  X  )  X  diag (  X  ) T trick to reduce the time complexity from O n 3 to O n 2 per iteration.
 As all the off-diagonal entries of  X  are zeros, then On the other hand, Hence, Finally, we substitute Eq.(10) back into Eq.(9), which establishes Eq.(6) and completes the proof. ! Theorem 2 provides an efficient accelerativ e technique for SimRank computation based on the following algorithm.
 Algorithm 1. AUG-SimRank: Accelerative S imRank for Undirected Graphs
Now we describe the overall idea of Algorithm 1 which involves the following three steps. (i) Spectral Predecomposition (Line 2-3). The first step in our algorithm is to di-(ii) Iterative Element-wise Matrix M ultiplication (Line 4-8). In this step, we de-(iii) SimRank Matrix Computation (Line 9). In the final step, we obtain the Sim-Analyzing the computational complexity, we now summarize the above discussion in the following result.
 Theorem 3. For undirected graphs, Algorithm 1 can perform the SimRank computa-tion for K iterations in O n 3 + K  X  n 2 time in the worst case, where n is the number of vertices, and n # K .
 Proof. For Algorithm 1, Step (i) and (iii) are performed only once during the whole procedure, and their computational complexities involve O n 3 operations in the worst case. In Step (ii), due to the element-wise matrix products, the computational time re-quired for K iterations is O K  X  n 2 . Hence, the total time required for K iterations of this algorithm is O n 3 + K  X  n 2 in the worst case. ! In this section, we parallelize the AUG-SimRank algorithm which is highly efficient on distributed multiprocessors. To implement our parallel SimRank algorithm, we utilize the available PLAPACK [13] (Parallel Linear Algebra Package) in combination with our matrix partition techniques on distributed memory architectures. PLAPACK is a parallel ARPACK version based on MPI (Message Passing Interface) for constructing parallel linear algebra libraries. It provides a high-level object-oriented programming interface so that coding of parallel linear algebra routines becomes a straightforward translation of algorithms.
 We now show how to parallelize Algorithm 1 for each step.

In the spectral predecomposition step, we deploy a parallel solver that is capable of spectral factorization. Several works have studied parallel eigen-decomposition [14,13]. We adopt a PLAPACK eigen-solver in this step to decompose matrix Q due to its better performance exhibited for large-scale problems.

In the iterative element-wise matrix multiplication step, the parallel implementation of  X 
S k = M "  X  S k  X  1  X  I n ( k =1 , 2 ,  X  X  X  ) is our main concern. We first vertically partition n ( i =1 , 2 ,  X  X  X  ,N ) ,and N is the number of partitions. Then, we have It follows that Note that in Eq.(11), there are no dependencies among the partitions, so they can all be executed in parallel. Observe that  X  S k and M are symmetric, and therefore we only need to compute the upper (or lower) triangular portion of these matrices.

In the SimRank matrix computation step, we focus our attention on the parallel com-putation of S k  X  U  X   X  S k  X  U  X  1 . This operation can be performed by the following substeps: (a) V k  X   X  S k  X  U  X  1 as a symmetric matrix-matrix multiplication. (b) S k  X  U  X  V k , which requires a matrix-matrix m ultiplication that only updates the Substep (a) is a standard matrix-matrix operation which can be parallelized in PLA-PACK, whereas Substep (b) is not one of those existing widely used kernels.
We now apply matrix partitioning techniques to parallelize Substep (b). We partition the matrix U and V k as and N i =1 n i = n ( i =1 , 2 ,  X  X  X  ,N ) ,and N is the number of partitions. Then, we obtain Hence, Substep (b) can be parallelized by updating the upper (or lower) triangular part of S k  X  S k + U ( i )  X  V ( i ) k (  X  i =1 ,  X  X  X  ,N ) for each loop.

We now summarize the above parallel techniques for SimRank computation. We present the following parallel SimRank algorithm that utilizes PLAPACK and matrix partitioning techniques.

Algorithm 2 provides a parallel version of SimRank computation over undirected web graphs. In Line 2 and 12, operations can be performed in parallel by calling the corresponding PLAPACK X  X  routines respect ively. In Line 4-10 and Line 14-15, each of Algorithm 2. PAUG-SimRank: Parallel Accelerative SimRank for Undirected Graphs the loops is decomposed into smaller tasks which can be executed simultaneously on the different processors of a parallel computer. In this section, we conduct experimental studies to evaluate the efficiency of our algo-rithms (i.e. AUG-SimRank and PAUG-SimRank) on both synthetic and real data sets. We compare their performances with the most efficient existing algorithms proposed in [1] and [7]. The experiments were done on 2.0GHz Pentium(R) Dual-Core CPU with 2GB main memory, running Windows Vista OS. All the algorithms were implemented in C++ and compiled using Visual C++ 6.0 compiler. 5.1 Experimental Data Sets We use two data sets for evaluation in our experiments.
 Synthetic Data Sets. We randomly generated 10 undirected web graphs with vertices ranging from 1K to 10K respectively. For each generated graph, every vertex has an av-erage of  X  links, where  X  is a random variable satisfying  X   X  uniform [0 , 15] .Theweb graphs are represented in the MATLAB sparse storage organization, using a ( x, y, val ) triple to describe the index and the value of the element.
 Real-life Data Sets. We use a full English Wikipedia data set exported in October 2007 to show the high efficiency of our proposed algorithms. The Wikipedia link graph contains 3.2M articles (vertices) with 110M intra-wiki links (edges). SimRank compu-tation over the Wikipedia data set has the semantics of obtaining similarity scores for encyclopedic concept pairs. We build the Wikipedia graph, choosing the relationship  X  a category contains an article  X  to be an edge between the category and the article. 5.2 Comparison Methods and Evaluation We compare the performances of the following algorithms:  X  SimRank with partial sums. [1] This algorithm employs a partial sums function  X  SOR SimRank. [7] This algorithm develops a successive over-relaxation method  X  AUG SimRank. This is our proposed algorithm based on the graph spectral de- X  PAUG SimRank. This is a parallel version of AUG SimRank that combines PLA-Evaluation Measures. We u s e CPU time and absolute speedup as two measures to evaluate the computational complexity and parallel efficiency of these algorithms re-spectively. The definition of absolute speedup is as follows [13]: where p is the number of processors, T 1 is the execution time of the best sequential algorithm on one processor, and T p is the time taken on p processors.
 Parameter Settings. In the experiments, we set the decay factor c =0 . 8 ,andthe accuracy =0 . 05 (unless otherwise specified). 5.3 Time Efficiency Evaluation Figure 1(a) shows the total computational time comparison among the three methods on 10 generated graphs when we set the vertices number n = 1K,  X  X  X  ,10K. For each algorithm, a least-squares polynomial is used to fit the bar series that are nonlinear. It can be seen from the chart that AUG-SimRank outperforms the other two algorithms significantly as n is growing, and CPU time value by AUG-SimRank remains a steady increase around 1.5K. This is because the time complexity of AUG-SimRank has a constant cubic coefficient that is i ndependent of the iteration number.

Figure 1(b) and 1(c) present the results of accuracy factor that influences the compu-tational time for our three test algorithms on a 10K synthetic graph and a Wikipedia real data set, respectively. We set the decay factor c =0 . 6 when testing results on Wikipedia data set. Note that different scale is chosen across the vertical axis in Figure 1(b) and 1(c) for providing a more illustrative look for each data set. We notice that both SOR-SimRank and SimRank with partial sums algorithms make a massive drop in CPU time while we are varying from 0.03 to 0.15, due to the more iterations needed for achiev-ing a high accuracy. However, the trend of AUG-SimRank computational time shows a slight downward turn as is increasing, which also implies that AUG-SimRank is insensitive to the iteration number.

Figure 1(d) compares computational accura cy with respect to the number of itera-tions among the three algorithms on the Wikipedia data set. It shows that for all the algorithms, decreases dramatically while the number of iterations is increasing. The accuracy values by AUG-SimRank and SimRan k with partial sums algorithms are close. This demonstrates that AUG-SimRank retai ns the convergence power of the SimRank with partial sums algorithm. For all of the algorithms, the figure also shows a logarith-mic growth in CPU time when K is growing, since Figure 1(d) is in logarithm scale, and all these algorithms approximately exhibit linear descending tendencies. Figure 1(e) precisely visualizes the C PU time consumption of each step for AUG-SimRank algorithm on a 10K generated data set. Specifically, we plot the computational time of (a) Spectral Predecomposition, (b) Iterative Elementwise Matrix Multiplication, and (c) SimRank Matrix Computation in the same chart. Note that the time consumed by Iterative Elementwise Matrix Multiplication is minimal and remains relatively stable, whereas the operation time for the other two steps rises substantially as n is increasing. This is because K % n so that the step of Iterative Elementwise Matrix Multiplication takes quadratic time after K iterations, whereas the other two steps require cubic time, making a large portion of the total AUG-SimRank time. 5.4 Parallel Efficiency Evaluation We test our parallel algorithm PAUG-SimRank on a distributed memory multiprocessor over synthetic and real-life data sets resp ectively. We obtain the following computa-tional results.

The parallel efficiency E p of PAUG-SimRank can be computed by the following equation.
 where S p is the speedup on p processors defined by Eq.(13). We use the execution time of the best sequential algorithm on one processor as T 1 . We present the speedup and parallel efficiency of PAUG-SimRank algorithm in the tables and charts below.
Figure 2(a) illustrates how the PAUG-SimRank implementation scales with the num-ber of processors over a 10K generated graph and a Wikipedia data set, respectively. On both two data sets, the speedup is acceptable but not ideal due to the time required to communicate among the processors is grow ing. Note that there has been a dramatic increase in speedup when we have less than 4 processors. This is because of the cache effect resulting from the various memory hierarchies of a modern computer. Figure 2(b) visualizes the parallel efficiency of PAUG-SimRank on two data sets. Notice that the parallel efficiency makes a general decrease due to the same arguments as for the speedup above. For each data set, we obtain a mean of approx. 67% efficiency which has been shown in the chart with hollow markers. Hyperlink-based approaches for similarity computation on web graphs have become popular since the famous result of Page et. al. [15] on Google PageRank citation rank-ing. Since then, there has been a surge of papers aiming at various problems in the optimization of web ranking algorithms, such as HITS [16], ReCom [17], SimRank [2], SimFusion [18], P-Rank [19], etc. In particular, there has been significant attention to computing SimRank similarities as they provide a simple and intuitive graph-theoretic model recursively refining the cocitation measure that says  X  similar objects are refer-enced by similar objects  X . Recent SimRank results incl ude randomized a pproximations [3,4], estimating a precise accuracy for iterati ve computation [1,5,7], graph clustering [20], query rewriting for sponsored search [6], etc.

Jeh and Widom [2] first proposed a SimRank model based on the idea that  X  vertices are similar if their neighbors are similar  X . Unfortunately the computational time of this model is very costly as it takes O Kn 2 d 2 time, where n is the number of vertices, and d is the average degree of a web graph. Hence, the naive SimRank algorithm is not suitable for practical use.

Fogaras and Racz [3,4] adopted a probabilistic method called Monte Carlo to op-timize SimRank computation. The main idea of their approach is to generate a finger where  X  ( a,b ) is the first meeting time for a pair of random walks started in nodes a and b . Though this probabilistic model can significan tly reduce the computational complex-ity, it does not predict deterministic quantities of SimRank scores but rather stochastic estimates of these quantities.

In comparison to the work on stochastic SimRank approximation, the work on op-timizing deterministic SimRank computation is limite d. Recent years have witnessed a growing interest in the optimization issue of iterative SimRank algorithms.
A very interesting piece of work is due to Li zorkin et al. [1] who give approaches to significantly reducing the computational time complexity from O Kn 2 d 2 to O Kn 2 d . Their study is not under the stochastic framework; rather, they use a partial operations. They also give the number of iterations required for achieving the desired accuracy. Given an error of and a decay factor c , the upper bound of the total number of iterations is K = lo g c +1 .

There has also been work on deterministic SimRank optimization. Antonellis et al. [6] present two SimRank extensions: one exploits the weights of the edges in the click graph, and the other that takes into account the  X  evidence  X  supporting the sim-plication for dense graph to further reduce the time complexity from O Kn 2 d to oped optimization techniques for minimizing matrix bandwidths to improve the I/O efficiency of SimRank iteration. Li et al. [10] proposed a novel approximate SimRank computation algorithm for static and dynamic information networks. They claim that their optimization technique is based on the non-iterative framework; however, the sin-gular value decomposition (SVD) method they used for low-rank approximation in-herently requires numerical iterations. Hence, their method is in essence iterative, not non-iterative. The Kronecker product in their approach is prohibitively costly in com-putational time and therefore is not preferable. Li et al. [21] developed a BlockSimRank algorithm that partitions the web graph into several blocks to efficiently compute simi-larity of each node-pair in the graph. Their approach takes O ( n 4 3 ) time, which is based on the random walk model. Zhao et al. [19] proposed a new structural similarity mea-sure called P-Rank (Penetrating Rank) that says  X  X wo entities are similar if (a) they are referenced by similar entities; and (b) they reference similar entities. X  This similarity takes into account of both in-and out-link rel ationships of entity pairs and penetrates the structural similarity computation beyond neighborhood of vertices to the entire in-formation network.
 In this paper, we study the problem of optimizing SimRank computation on undirected graphs. An efficient AUG-SimRank algorithm has been proposed to significantly re-duce the SimRank computational time from O K  X  n 3 to O n 3 + K  X  n 2 after K iterations in the worst case. We also present a parallel version of the AUG-SimRank al-gorithm on distributed memory multi-processors as we combine the PLAPACK solvers with our partition techniques. Extensive experimental evaluations on synthetic and real data sets show the proposed methods outperform the existing techniques in terms of total computation cost and parallelization.
 We would like to thank the anonymous reviewers for their valuable comments. The sec-ond author was supported by three ARC DPs (DP0666428, DP0881035, and DP0987557) and a Google research award.

