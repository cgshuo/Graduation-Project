 Aspect-based sentiment analysis (ABSA) has been found to play a significant role in many applica-tions such as opinion mining on product or restau-rant reviews. It is a task to determine an attitude, opinion and emotions of people toward aspects in a sentence. For example, given a sentence  X  X xcept the design, the phone is bad for me X , the system should classify positive and negative as the senti-ments for the aspects  X  X esign X  and  X  X hone X , respec-tively.

The simple approach is to calculate a sentiment score of a given aspect as the weighted sum of opinion scores, which are defined by a sentiment lexicon, of all words in the sentence (Liu and Zhang, 2012; Pang and Lee, 2008). This method is further improved by identifying the aspect-opinion relations using tree kernel method (Nguyen and Shirai, 2015a).

Other researches have attempted to use unsuper-vised topic modeling methods. To identify the sen-timent category of the aspect, topic models which can simultaneously exploit aspect and sentiment have been proposed, such as TSLDA (Nguyen and Shirai, 2015b), ASUM (Jo and Oh, 2011), JST (Lin and He, 2009) and FACTS model (Lakkaraju et al., 2011).

Recursive Neural Network (RNN) is a kind of deep neural network. Using distributed represen-tations of words (aka word embedding) (Bengio et al., 2003; Hinton, 1986), RNN merges word rep-resentations to represent phrases or sentences. It is one of the best methods to predict sentiment la-bels for the phrases (Socher et al., 2011; Socher et al., 2012; Socher et al., 2013). AdaRNN (Adap-tive Recursive Neural Network) is an extension of RNN for Twitter sentiment classification (Dong et al., 2014a; Dong et al., 2014b).

This paper proposes a new method PhraseRNN for ABSA. It is an extended model of RNN and AdaRNN, which are briefly introduced in Section 2. The basic idea is to make the representation of the target aspect richer by using syntactic infor-mation from both the dependency and constituent trees of the sentence. In RNN and AdaRNN, given a sentence contain-ing a target aspect,  X  X inary dependency tree X  is built from a dependency tree of the sentence. Intu-itively, it represents syntactic relations associated with the aspect. Each word (leaf) or phrase (inter-nal node) in the binary dependency tree is repre-sented as a d-dimensional vector. From bottom to up, the representations of a parent node v is calcu-lated by combination of left and right child vector representations ( v l and v r ) using a global function g in RNN: b  X  &lt; d is the bias vector. Then v = f ( g ( v l ,v r where f is a nonlinear function such as tanh . Instead of using only a global function g , AdaRNN employed n compositional functions G = { g 1 ,  X  X  X  ,g n } and selected them depending on the linguistic tags and combined vectors as fol-lows: g given the child vectors v l , v r and external fea-ture vector e . The probabilities are estimated as Equation (3).  X   X  where  X   X  &lt; is a hyper-parameter, and R  X 
The vector of the root node of the binary depen-dency tree is regarded as a representation of the target aspect. It is fed to a logistic regression to predict the sentiment category of the aspect. In this model, a representation of an aspect will be obtained from a  X  X arget dependent binary phrase dependency tree X  constructed by combining the constituent and dependency trees. In addition, in-stead of using a list of global functions G as in AdaRNN, two kinds of composition functions G in inner-phrase and H in outer-phrase are used. 3.1 Building Hierarchical Structure First, the basic phrases (noun phrases, verb phrases, preposition phrases and so on) are ex-tracted from the constituent tree of the sentence. For example, a list of phrases P = { PP[Except the design], NP[the phone], VP[is bad for me] } is ex-tracted from the constituent tree in Figure 1.
Given a dependency tree and a list of phrases, a phrase dependency tree is created by Algorithm 1. The input is a dependency tree T = ( V,E ) consisting of a set of vertices V = { v 1 ,  X  X  X  ,v | V | } between two vertices, and a list of phrases P = { p 1 ,  X  X  X  ,p K } extracted from the constituent tree. The output is a phrase dependency tree pT = ( pV,pE ) where pV = { T 1 ,  X  X  X  ,T K } ( T i = ( V i ,E i ) is a subtree) and pE = { ( r ji ,T i ,T j ) } (a set of relations between two subtrees). With the dependency tree and the phrase list in Figure 2(a), the algorithm will output a phrase dependency tree in Figure 2(b).
 Algorithm 1: Convert to Phrase Dependency Tree
Input : dependency tree T = ( V,E ) , phrase
Output : phrase dependency tree: for each phrase p i  X  P do end for each edge ( r nm ,v m ,v n )  X  E do 6 if k = l then 8 else 9 pE  X  pE  X  X  ( r nm ,T k ,T l ) } end
The phrase dependency tree is transformed into a target dependent binary phrase dependency tree bpT by Algorithm 2. The input of the algorithm is a phrase dependency tree pT = ( pV,pE ) and a target word v t (the aspect word we want to predict the sentiment category). The output is the binary tree bpT . Note that the leaves of the binary tree bpT are binary subtrees bT 1 ,  X  X  X  ,bT K which are the binary versions of subtrees T 1 ,  X  X  X  ,T K . On the other hand, the leaves of binary subtree bT i are the words in phrase p i . bpT and bT i are obtained by convert function defined as Algorithm 3. It can 2(c) and Figure 3 show the outputs for the aspect  X  X esign X  and  X  X hone X , respectively. 3.2 Constructing the Aspect Representation Each node in the binary tree is represented as a d-dimensional vector. In this research, we use the algorithms (Mikolov et al., 2013). Each word is (c) Target Dependent Binary Phrase Dependency Tree
Algorithm 2: Convert to Target Dependent Bi-nary Phrase Dependency Tree
Input : phrase dependency tree:
Output : target dependent binary phrase for T i = ( V i ,E i )  X  pV do 2 if v t  X  V i then 3 h  X  v t 4 else 5 h  X  vertex having no head in E i 6 end 7 bT i  X  convert ( E i ,h ) end bpT  X  convert ( pE,T v Replace all T i in bpT with bT i
Algorithm 3: Convert to a Binary Tree
Function convert( E , v t ) : 2 v  X  v t 3 for v i  X  v t , v t  X  v i in E do 4 if v t  X  v i then 5 E 0  X  E \{ v t  X  v i } 6 w  X  [ convert ( E,v i ) ,v ] 7 else 8 E 0  X  E \{ v i  X  v t } 9 w  X  [ v,convert ( E,v i )] 13 return v end Figure 3: Another Target Dependent Binary Phrase Dependency Tree (Target Aspect  X  X hone X ) represented as a 300-dimensional vector in this pre-trained dataset.

PhraseRNN uses two kinds of composition function G = { g 1 ,  X  X  X  ,g n } for inner-phrase and H = { h 1 ,  X  X  X  ,h m } for outer-phrase. n and m are the number of functions in G and H , respectively.
The vector of the parent node v in in the binary subtree bT i , where v l and v r are the vectors of the left and right children, is computed as: where e in is the external feature vector. g i given the child vectors v l , v r and e in . It is defined as Equation (5).  X   X  where  X   X  &lt; is a hyper-parameter, and R  X 
In the target dependent binary phrase depen-dency tree bpT , the vector of the parent node v out , where the vectors of the left and right children are v and v r , is computed as: given the child vectors v l , v r and external feature vector e out as shown in Equation (7).
The external features e i ( e in and e out ) of the node v i consists of three types of features: Label l , Label r and DepType i . Label l and Label r are the labels of the left and right child nodes, respec-tively. If node v l is a leaf word, Label l is the POS of the word v l . Otherwise, it is the non-terminal symbol of the lowest common parent of descen-dants of v l in the constituent tree. For example, the Label of the node combined from  X  X he X  and  X  X esign X  in Figure 2(c) is  X  X P X  which is the low-est common parent of these two words in the con-stituent tree in Figure 1. DepType i is the depen-children of v i are leaf nodes, it is the direct relation in the dependency tree between them. Otherwise, DepType i is the relation between head words of the left and right nodes. For instance, in Figure 2(c), let a be the parent of  X  X s X  and  X  X ad X , b is the parent of  X  X or X  and  X  X e X , c is the parent of a and b . DepType of a and b are  X  X OP X  and  X  X OBJ X  that are direct relations between two child nodes in the dependency tree in Figure 2(a). While, DepType of c is  X  X REP X  that is the dependency relation be-tween two head words  X  X ad X  and  X  X or X . e i is a bi-nary vector where the weight of the vector repre-sents the presence of each feature.

We suppose a batch training data consist-The goal is to minimize the loss function which is the sum of the mean of negative log likelihood and L2 regularization penalty in a batch training set as in Equation (8).
 where  X  is a constant controlling the degree of penalty,  X  is all the parameters in the model.
Stochastic gradient descent is used to optimize the loss function. Backpropagation is employed to propagate the errors from the top node to the leaf nodes. The derivatives of parameters are used to update the parameters. We use the restaurant reviews dataset in Se-mEval2014 Task 4 consisting of over 3000 English sentences. For each aspect,  X  X ositive X ,  X  X egative X  or  X  X eutral X  is annotated as its polarity. Dataset is divided into three parts: 70% training, 10% devel-opment and 20% test.
 We compare the following methods:
ASA w/o RE : It defines a sentiment score of a given aspect as the weighted sum of opinion scores of all words in the sentence, where the weight is defined by the distance from the aspect (Liu and Zhang, 2012; Pang and Lee, 2008).

ASA with RE : It improves  X  X SA w/o RE X  by firstly identifying the aspect-opinion relations us-ing tree kernel, then integrating them to the senti-ment calculation (Nguyen and Shirai, 2015a).
RNN : It uses only one global function g 1 over the binary dependency tree.
 AdaRNN : It uses multi-composition functions G = { g 1 ,  X  X  X  ,g n } over a binary dependency tree (Dong et al., 2014a).

PhraseRNN-1 : our PhraseRNN with only one global function: G = H = g 1
PhraseRNN-2 : our PhraseRNN with two global functions. One for inner-phrase, the other for outer-phrase: G = g 1 and H = h 1
PhraseRNN-3 : our PhraseRNN with multiple global functions: G = H = { g 1 ,  X  X  X  ,g n }
PhraseRNN-4 : our PhraseRNN with two lists of global functions. One for inner-phrase, the other for outer-phrase: G = { g 1 ,  X  X  X  ,g n } and H = { h 1 ,  X  X  X  ,h m }
Stanford CoreNLP (Manning et al., 2014) is used to parse the sentence and obtain constituent and dependency trees. For RNN, AdaRNN and PhraseRNN, the optimal parameters, which mini-mize the error in the development set, are used for the sentiment classification of the test set. We set  X  = 1 for AdaRNN and PhraseRNN since it is re-ported that  X  = 1 is the best parameter (Dong et al., 2014a). The optimized number of composition functions n and m = n with n = { 2 , 4 , 6 , 8 , 10 } on the development set.  X  = 0 . 0001 is employed. Accuracy ( A ), Preci-sion ( P ), Recall ( R ) and F-measure ( F ) are used as
Table 1 shows the results of the methods. Dif-ferences of PhraseRNN and RNN are verified by statistical significance tests. We use the paired randomization test because it does not require additional assumption about distribution of out-puts (Smucker et al., 2007). The results indi-cate that four variations of our PhraseRNN out-perform  X  X SA w/o RE X ,  X  X SA with RE X , RNN and AdaRNN methods from 5.35% to 19.44% ac-curacy and 8% to 16.48% F-measure. Among four variations, PhraseRNN-2 and PhraseRNN-3 achieved the best performance. By using dif-ferent global functions in the inner and outer phrases, PhraseRNN-2 improves PhraseRNN-1 by 2.54% F-measure while keeping the comparable accuracy. Using multi-composition functions is also effective since PhraseRNN-3 was better than PhraseRNN-1 by 1.55% accuracy. PhraseRNN-4 improved PhraseRNN-3 by 6.38% precision while keeping comparable in other metrics.

Since our PhraseRNN-1 and PhraseRNN-3 out-perform RNN and AdaRNN (the models rely-ing on the binary dependency tree) respectively, we can conclude that our target dependent binary phrase dependency tree is much effective than bi-nary dependency tree for ABSA.

In the data used in (Dong et al., 2014a), one sen-tence contains only one aspect. On the other hand, two or more aspects can be appeared in one sen-tence in SemEval 2014 data. It is common in the real text. To examine in which cases our method is better than the others, we conduct an additional ex-periment by dividing the test set into three disjoint subsets. The first subset ( S1 ) contains sentences having only one aspect. The second subset ( S2 ) ASA w/o RE 46.76 54.63 46.76 48.06 ASA with RE 52.39 53.91 52.39 52.54 Table 2: The Number of Correctly Identified As-pects in Subsets S1, S2 and S3 and third subset ( S3 ) have two or more aspects in each sentence. All aspects in a sentence in S2 have the same sentiment category, while different sen-timent categories in S3. The number of aspects in S1, S2 and S3 are 200, 323 and 187, respectively.
Table 2 shows the number of aspects where their sentiments are correctly identified by the methods in the subsets S1, S2 and S3. The accuracies are also shown in parentheses. Among three subsets, S3 is the most difficult and ambiguous case. In all methods, the performance in S3 is worse than S1 and S2. Comparing with other methods in each subset, PhraseRNN improves the accuracy in S2 more than in S1 and S3. We proposed PhraseRNN to identify the sentiment of the aspect in the sentence. Propagating the semantics through the binary dependency tree in RNN and AdaRNN could not be enough to rep-resent the sentiment of the aspect. A new hierar-chical structure was constructed by integrating the dependency relations and phrases. The results in-dicated that our PhraseRNN outperformed  X  X SA w/o RE X ,  X  X SA with RE X , RNN and AdaRNN.
