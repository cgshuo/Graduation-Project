 Probabilistic parsers are usually trained on treebanks composed of few thousands sentences. While this amount of data seems reasonable for learning syn-tactic phenomena and, to some extent, very frequent lexical phenomena involving closed parts of speech (POS), it proves inadequate when modeling lexical dependencies between open POS, such as nouns, verbs and adjectives. This fact was first recognized by (Bikel, 2004) who showed that bilexical depen-dencies were barely used in Michael Collins X  parser.
The work reported in this paper aims at a better modeling of such phenomena by using a raw corpus that is several orders of magnitude larger than the treebank used for training the parser. The raw cor-pus is first parsed and the computed lexical affinities between lemmas, in specific lexico-syntactic config-urations, are then injected back in the parser. Two outcomes are expected from this procedure, the first is, as mentioned above, a better modeling of bilexi-cal dependencies and the second is a method to adapt a parser to new domains.

The paper is organized as follows. Section 2 re-views some work on the same topic and highlights their differences with ours. In section 3, we describe the parser that we use in our experiments and give a detailed description of the frequent attachment er-rors. Section 4 describes how lexical affinities be-tween lemmas are calculated and their impact is then evaluated with respect to the attachment errors made by the parser. Section 5 describes three ways to in-tegrate the lexical affinities in the parser and reports the results obtained with the three methods. Coping with lexical sparsity of treebanks using raw corpora has been an active direction of research for many years.

One simple and effective way to tackle this prob-lem is to put together words that share, in a large raw corpus, similar linear contexts, into word clus-ters . The word occurrences of the training treebank are then replaced by their cluster identifier and a new parser is trained on the transformed treebank. Us-ing such techniques (Koo et al., 2008) report signi-ficative improvement on the Penn Treebank (Marcus et al., 1993) and so do (Candito and Seddah, 2010; Candito and Crabb  X  e, 2009) on the French Treebank (Abeill  X  e et al., 2003).

Another series of papers (Volk, 2001; Nakov and Hearst, 2005; Pitler et al., 2010; Zhou et al., 2011) directly model word co-occurrences. Co-occurrences of pairs of words are first collected in a raw corpus or internet n -grams. Based on the counts produced, lexical affinity scores are computed. The detection of pairs of words co-occurrences is gen-erally very simple, it is either based on the direct adjacency of the words in the string or their co-occurrence in a window of a few words. (Bansal and Klein, 2011; Nakov and Hearst, 2005) rely on the same sort of techniques but use more sophisti-cated patterns, based on simple paraphrase rules, for identifying co-occurrences.

Our work departs from those approaches by the fact that we do not extract the lexical information directly on a raw corpus, but we first parse it and then extract the co-occurrences on the parse trees, based on some predetermined lexico-syntactic pat-terns. The first reason for this choice is that the lin-guistic phenomena that we are interested in, such as as PP attachment, coordination, verb subject and ob-ject can range over long distances, beyond what is generally taken into account when working on lim-ited windows. The second reason for this choice was to show that the performances that the NLP commu-nity has reached on parsing, combined with the use of confidence measures allow to use parsers to ex-tract accurate lexico-syntactic information, beyond what can be found in limited annotated corpora.
Our work can also be compared with self train-ing approaches to parsing (McClosky et al., 2006; Suzuki et al., 2009; Steedman et al., 2003; Sagae and Tsujii, 2007) where a parser is first trained on a treebank and then used to parse a large raw cor-pus. The parses produced are then added to the ini-tial treebank and a new parser is trained. The main difference between these approaches and ours is that we do not directly add the output of the parser to the training corpus, but extract precise lexical informa-tion that is then re-injected in the parser. In the self training approach, (Chen et al., 2009) is quite close to our work: instead of adding new parses to the tree-bank, the occurrence of simple interesting subtrees are detected in the parses and introduced as new fea-tures in the parser.

The way we introduce lexical affinity measures in the parser, in 5.1, shares some ideas with (Anguiano and Candito, 2011), who modify some attachments in the parser output, based on lexical information. The main difference is that we only take attachments that appear in an n -best parse list into account, while they consider the first best parse and compute all po-tential alternative attachments, that may not actually occur in the n -best forests. The parser used in this work is the second order graph based parser (McDonald et al., 2005; K  X  ubler et al., 2009) implementation of (Bohnet, 2010). The parser was trained on the French Treebank (Abeill  X  e et al., 2003) which was transformed into dependency trees by (Candito et al., 2009). The size of the tree-bank and its decomposition into train, development and test sets is represented in table 1. FTB TRAIN 9 881 278 083 FTB DEV 1 239 36 508 FTB TEST 1 235 36 340
The part of speech tagging was performed with the MELT tagger (Denis and Sagot, 2010) and lem-matized with the MACAON tool suite (Nasr et al., 2011). The parser gave state of the art results for parsing of French, reported in table 2.
Figure 1 shows the distribution of the 100 most common error types made by the parser. In this figure, x axis shows the error types and y axis shows the error ratio of the related error type ( type by the POS tag of the governor and the POS tag of the dependent. The figure presents a typical Zipfian distribution with a low number of frequent error types and a large number of unfrequent error types. The shape of the curve shows that concen-trating on some specific frequent errors in order to increase the parser accuracy is a good strategy.
Table 3 gives a finer description of the most com-mon types of error made by the parser. Here we define more precise patterns for errors, where some lexical values are specified (for prepositions) and, in some cases, the nature of the dependency is taken into account. Every line of the table corresponds to one type of error. The first column describes the error type. The second column indicates the fre-quency of this type of dependency in the corpus. The third one displays the accuracy for this type of de-pendency (the number of dependencies of this type correctly analyzed by the parser divided by the to-tal number of dependencies of this type). The fourth column shows the contribution of the errors made on this type of dependency to the global error rate. The last column associates a name with some of the error types that will prove useful in the remainder of the paper to refer to the error type.

Table 3 shows two different kinds of errors that impact the global error rate. The first one concerns very common dependencies that have a high accu-racy but, due to their frequency, hurt the global er-ror rate of the parser. The second one concerns low frequency, low accuracy dependency types. Lines 2 and 3 , respectively attachment of the preposition ` a to a verb and the subject dependency illustrate such a contrast. They both impact the total error rate in the same way ( 2 . 53% of the errors). But the first one is a low frequency low accuracy type (respectively 0 . 88% and 69 . 11% ) while the second is a high fre-quency high accuracy type (respectively 3 . 43% and 93 . 03% ). We will see in 4.2.2 that our method be-haves quite differently on these two types of error. dependency freq. acc. contrib. name N  X  N 1 . 50 72 . 23 2 . 91 V  X  ` a 0 . 88 69 . 11 2 . 53 VaN V X  X uj  X  N 3 . 43 93 . 03 2 . 53 SBJ N  X  CC 0 . 77 69 . 78 2 . 05 NcN N  X  de 3 . 70 92 . 07 2 . 05 NdeN V  X  de 0 . 66 74 . 68 1 . 62 VdeN V X  X bj  X  N 2 . 74 90 . 43 1 . 60 OBJ V  X  en 0 . 66 81 . 20 1 . 24 V  X  pour 0 . 46 67 . 78 1 . 10 N  X  ADJ 6 . 18 96 . 60 0 . 96 ADJ N  X  ` a 0 . 29 70 . 64 0 . 72 NaN N  X  pour 0 . 12 38 . 64 0 . 67 N  X  en 0 . 15 47 . 69 0 . 57 The lexical resource is a collection of tuples  X  C,g,d,s  X  where C is a lexico-syntactic configu-ration, g is a lemma, called the governor of the configuration, d is another lemma called the depen-dent and s is a numerical value between 0 and 1 , called the lexical affinity score, which accounts for the strength of the association between g and d in the context C . For example the tuple  X  ( V,g ) obj ( N,d ) , eat , oyster , 0 . 23  X  defines a simple configu-ration ( V,g ) obj  X  ( N,d ) that is an object depen-dency between verb g and noun d . When replac-ing variables g and d in C respectively with eat and oyster , we obtain the fully specified lexico syn-tactic pattern ( V, eat ) obj  X  ( N, oyster ) , that we call an instantiated configuration. The numerical value 0 . 23 accounts for how much eat and oyster like to co-occur in the verb-object configuration. Con-figurations can be of arbitrary complexity but they have to be generic enough in order to occur fre-quently in a corpus yet be specific enough to model a precise lexico syntactic phenomenon. The context (  X  ,g )  X   X  (  X  ,d ) , for example is very generic but does not model a precise linguistic phenomenon, as selec-tional preferences of a verb, for example. Moreover, configurations need to be error-prone. In the per-spective of increasing a parser performances, there is no point in computing lexical affinity scores be-tween words that appear in a configuration for which the parser never makes mistakes.

The creation of the lexical resource is a three stage process. The first step is the definition of configura-tions, the second one is the collection of raw counts from the machine parsed corpora and the third one is the computation of lexical affinities based on the raw counts. The three steps are described in the follow-ing subsection while the evaluation of the created resource is reported in subsection 4.2. 4.1 Computing Lexical Affinities A set of 9 configurations have been defined. Their selection is a manual process based on the analysis of the errors made by the parser, described in sec-tion 3, as well as on the linguistic phenomena they model. The list of the 9 configurations is described in Table 4. As one can see on this table, configu-rations are usually simple, made up of one or two dependencies. Linguistically, configurations OBJ and SBJ concern subject and object attachments, configuration ADJ is related to attachments of ad-jectives to nouns and configurations NdeN, VdeN, VaN, and NaN indicate prepositional attachments. We have restricted ourselves here to two common French prepositions ` a and de . Configurations NcN and VcV deal respectively with noun and verb coor-dination.

The computation of the number of occurrences of an instantiated configuration in the corpus is quite straightforward, it consists in traversing the depen-dency trees produced by the parser and detect the occurrences of this configuration.
 At the end of the counts collection, we have gath-ered for every lemma l its number of occurrences as governor (resp. dependent) of configuration C in the corpus, noted C ( C,l,  X  ) (resp. C ( C,  X  ,l ) ), as well as the number of occurrences of configuration C with lemma l g as a governor and lemma l d as a depen-dent, noted C ( C,l g ,l d ) . We are now in a position to compute the score s ( C,l g ,l d ) . This score should reflect the tendency of l g and l d to appear together in configuration C . It should be maximal if when-ever l g occurs as the governor of configuration C , the dependent position is occupied by l d and, sym-metrically, if whenever l d occurs as the dependent of configuration C , the governor position is occupied by l g . A function that conforms such a behavior is the following: s ( C,l g ,l d ) = it takes its values between 0 ( l g and l d never co-occur) and 1 ( g and d always co-occur). This function is close to pointwise mutual information (Church and Hanks, 1990) but takes its values be-tween 0 and 1 . 4.2 Evaluation Lexical affinities were computed on three corpora of slightly different genres. The first one, is a collection of news report of the French press agency Agence France Presse , the second is a collection of news-paper articles from a local French newspaper : l X  X st R  X  epublicain . The third one is a collection of articles from the French Wikipedia. The size of the different corpora are detailed in table 5. The corpus was first POS tagged, lemmatized and parsed in order to get the 50 best parses for every sentence. Then the lexi-cal resource was built, based on the 9 configurations described in table 4.
 The lexical resource has been evaluated on FTB DEV with respect to two measures: coverage and correction rate, described in the next two sec-tions. 4.2.1 Coverage
Coverage measures the instantiated configura-tions present in the evaluation corpus that are in the resource. The results are presented in table 6. Every line represents a configuration, the second column indicates the number of different instantiations of this configuration in the evaluation corpus, the third one indicates the number of instantiated configura-tions that were actually found in the lexical resource and the fourth column shows the coverage for this configuration, which is the ratio third column over the second. Last column represents the coverage of the training corpus (the lexical resource is extracted on the training corpus) and the last line represents the same quantities computed on all configurations.
Table 6 shows two interesting results: firstly the high variability of coverage with respect to configu-rations, and secondly the low coverage when the lex-ical resource is computed on the training corpus, this fact being consistent with the conclusions of (Bikel, 2004). A parser trained on a treebank cannot be ex-pected to reliably select the correct governor in lex-ically sensitive cases.
 4.2.2 Correction Rate
While coverage measures how many instantiated configurations that occur in the treebank are actu-ally present in the lexical resource, it does not mea-sure if the information present in the lexical resource can actually help correcting the errors made by the parser.

We define Correction Rate (CR) as a way to ap-proximate the usefulness of the data. Given a word d present in a sentence S and a configuration C , the set of all potential governors of d in configuration C , in all the n -best parses produced by the parser is computed. This set is noted G = { g 1 ,...,g j } . Let us note G L the element of G that maximizes the lex-ical affinity score. When the lexical resource gives no score to any of the elements of G , G L is left un-specified.

Ideally, G should not be the set of governors in the n -best parses but the set of all possible governors for d in sentence S . Since we have no simple way to compute the latter, we will content ourselves with the former as an approximation of the latter.
Let us note G H the governor of d in the (first) best parse produced and G R the governor of d in the correct parse. CR measures the effect of replacing G H with G L .

We have represented in table 7 the different sce-narios that can happen when comparing G H , G R and G L .

In scenarios CC and CE, the parser did not make a mistake (the first letter, C, stands for correct). In scenario CC, the lexical affinity score was compat-ible with the choice of the parser or the lexical re-source did not select any candidate. In scenario CE, the lexical resource introduced an error. In scenar-ios EC and EE, the parser made an error. In EC, the error was corrected by the lexical resource while in EE, it wasn X  X . Either because the lexical resource candidate was not the correct governor or it was un-specified. The last case, NA, indicates that the cor-rect governor does not appear in any of the n -best parses. Technically this case could be integrated in EE (an error made by the parser was not corrected by the lexical resource) but we chose to keep it apart since it represents a case where the right solution could not be found in the n -best parse list (the cor-rect governor is not a member of set G ).

Let X  X  note n S the number of occurrences of sce-nario S for a given configuration. We compute CR for this configuration in the following way:
CR =
When CR is equal to 0 , the correction did not have any impact on the error rate. When CR &gt; 0 , the error rate is reduced and if CR &lt; 0 it is increased 1 . CR for each configuration is reported in table 8. The counts of the different scenarios have also been reported.

Table 8 shows very different results among con-figurations. Results for PP attachments VdeN, VaN and NaN are quite good (a CR of 75% for a given configuration, as VdeN indicates that the number of errors on such a configuration is decreased by 25% ). It is interesting to note that the parser behaves quite badly on these attachments: their accuracy (as re-ported in table 3) is, respectively 74 . 68 , 69 . 1 and 70 . 64 . Lexical affinity helps in such cases. On the other hand, some attachments like configuration ADJ and NdeN, for which the parser showed very good accuracy ( 96 . 6 and 92 . 2 ) show very poor per-formances. In such cases, taking into account lexical affinity creates new errors.
On average, using the lexical resource with this simple strategy of systematically replacing G H with G
L allows to decrease by 20% the errors made on our 9 configurations and by 2 . 5% the global error rate of the parser. 4.3 Filtering Data with Ambiguity Threshold The data used to extract counts is noisy: it con-tains errors made by the parser. Ideally, we would like to take into account only non ambiguous sen-tences, for which the parser outputs a single parse hypothesis, hopefully the good one. Such an ap-proach is obviously doomed to fail since almost ev-ery sentence will be associated to several parses. Another solution would be to select sentences for which the parser has a high confidence, using confi-dence measures as proposed in (S  X  anchez-S  X  aez et al., 2009; Hwa, 2004). But since we are only interested in some parts of sentences (usually one attachment), we don X  X  need high confidence for the whole sen-tence. We have instead used a parameter, defined on single dependencies, called the ambiguity measure .
Given the n best parses of a sentence and a depen-dency  X  , present in at least one of the n best parses, let us note C (  X  ) the number of occurrences of  X  in the n best parse set. We note AM (  X  ) the ambiguity measure associated to  X  . It is computed as follows:
An ambiguity measure of 0 indicates that  X  is non ambiguous in the set of the n best parses (the word that constitutes the dependent in  X  is attached to the word that constitutes the governor in  X  in all the n -best analyses). When n gets large enough this mea-sure approximates the non ambiguity of a depen-dency in a given sentence.

Ambiguity measure is used to filter the data when counting the number of occurrences of a configura-tion: only occurrences that are made of dependen-cies  X  such that AM (  X  )  X   X  are taken into account.  X  is called the ambiguity threshold.

The results of coverage and CR given above were computed for  X  equal to 1 , which means that, when collecting counts, all the dependencies are taken into account whatever their ambiguity is. Table 9 shows coverage and CR for different values of  X  . As ex-pected, coverage decreases with  X  . But, interest-ingly, decreasing  X  , from 1 down to 0 . 2 has a posi-tive influence on CR. Ambiguity threshold plays the role we expected: it allows to reduce noise in the data, and corrects more errors. We have devised three methods for taking into ac-count lexical affinity scores in the parser. The first two are post-processing methods, that take as input the n -best parses produced by the parser and mod-ify some attachments with respect to the information given by the lexical resource. The third method in-troduces the lexical affinity scores as new features in the parsing model. The three methods are described in 5.1, 5.2 and 5.3. They are evaluated in 5.4. 5.1 Post Processing Method The post processing method is quite simple. It is very close to the method that was used to compute the Correction Rate of the lexical resource, in 4.2.2: it takes as input the n -best parses produced by the parser and, for every configuration occurrence C found in the first best parse, the set ( G ) of all po-tential governors of C , in the n -best parses, is com-puted and among them, the word that maximizes the lexical affinity score ( G L ) is identified.
Once G L is identified, one can replace the choice of the parser ( G H ) with G L . This method is quite crude since it does not take into account the confi-dence the parser has in the solution proposed. We observed, in 4.2.2 that CR was very low for configu-rations for which the parser achieves good accuracy. In order to introduce the parser confidence in the fi-nal choice of a governor, we compute C ( G H ) and C ( G L ) which respectively represent the number of times G H and G L appear as the governor of config-uration C . The choice of the final governor, noted  X  G , depends on the ratio of C ( G H ) and C ( G L ) . The complete selection strategy is the following: 1. if G H = G L or G L is unspecified,  X  G = G H . 2. if G H 6 = G L ,  X  G is determined as follows:
We have reported, in table 10 the values of CR, for the 9 different features, using this strategy, for  X  = 1 . We do not report the values of CR for other values of  X  since they are very close to each other. The table shows several noticeable facts. First, the new strategy performs much better than the former one (crudely replacing G H by G L ), the value of CR increased from 0 . 2 to 0 . 4 , which means that the er-rors made on the nine configurations are now de-creased by 40% . Second, CR is now positive for ev-ery configuration: the number of errors is decreased for every configuration.
 5.2 Double Parsing Method The post processing method performs better than the naive strategy that was used in 4.2.2. But it has an important drawback: it creates inconsistent parses. Recall that the parser we are using is based on a sec-ond order model, which means that the score of a de-pendency depends on some neighboring ones. Since with the post processing method only a subset of the dependencies are modified, the resulting parse is in-consistent: the score of some dependencies is com-puted on the basis of other dependencies that have been modified.
In order to compute a new optimal parse tree that preserves the modified dependencies, we have used a technique proposed in (Mirroshandel and Nasr, 2011) that modifies the scoring function of the parser in such a way that the dependencies that we want to keep in the parser output get better scores than all competing dependencies.

The double parsing method is therefore a three stage method. First, sentence S is parsed, producing the n -best parses. Then, the post processing method is used, modifying the first best parse. Let X  X  note D the set of dependencies that were changed in this process. In the last stage, a new parse is produced, that preserves D . 5.3 Feature Based Method In the feature based method, new features are added to the parser that rely on lexical affinity scores. These features are of the following form:  X  C,l g ,l d , X  C ( s )  X  , where C is a configuration num-ber, s is the lexical affinity score ( s = s ( C,l g ,l d and  X  c (  X  ) is a discretization function.

Discretization of the lexical affinity scores is nec-essary in order to fight against data sparseness. In this work, we have used Weka software (Hall et al., 2009) to discretize the scores with unsupervised bin-ning. Binning is a simple process which divides the range of possible values a parameter can take into subranges called bins. Two methods are im-plemented in Weka to find the optimal number of bins: equal-frequency and equal-width. In equal-frequency binning, the range of possible values are divided into k bins, each of which holds the same number of instances. In equal-width binning, which is the method we have used, the range are divided into k subranges of the same size. The optimal num-ber of bins is the one that minimizes the entropy of the data. Weka computes different number of bins for different configurations, ranging from 4 to 10 . The number of new features added to the parser is equal to P C B ( C ) where C is a configuration and B ( C ) is the number of bins for configuration C . 5.4 Evaluation The three methods described above have been evalu-ated on FTB TEST . Results are reported in table 11. The three methods outperformed the baseline (the state of the art parser for French which is a second order graph based method) (Bohnet, 2010). The best performances were obtained by the Double Parsing method that achieved a labeled relative error reduc-tion of 7 , 1% on predicted POS tags, yielding the best parsing results on the French Treebank. It per-forms better than the Post Processing method, which means that the second parsing stage corrects some inconsistencies introduced in the Post Processing method. The performances of the Feature Based method are disappointing, it achieves an error reduc-tion of 1 . 4% . This result is not easy to interpret. It is probably due to the limited number of new fea-tures introduced in the parser. These new features probably have a hard time competing with the large number of other features in the training process. Computing lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate has shown to be an effective way to increase the performances of a parser. We have proposed in this paper one method to compute lexi-cal affinity scores as well as three ways to introduce this new information in a parser. Experiments on a French corpus showed a relative decrease of the er-ror rate of 7 . 1% Labeled Accuracy Score.
 This work has been funded by the French Agence Nationale pour la Recherche, through the projects SEQUOIA (ANR-08-EMER-013) and EDYLEX (ANR-08-CORD-009).
