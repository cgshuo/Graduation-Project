 1. Introduction
Literature search is one of the major work tasks for scientists. Two paradigms for supporting this task can be distinguished: When the searcher has some knowledge about her information need (e.g., when she knows the title or authors of a particular paper), she poses a query and investigates the returned ranked list of poten-tially relevant documents. When a researcher needs to get an overview (e.g., over the state-of-the-art in a par-ticular field), it is difficult or even impossible to specify a useful query. Here, the system has to present the whole collection in such a way that a user can easily browse through the available documents.

Documents are stored in digital libraries (DLs for short), e.g. the ACM digital library, or personal collec-tions with technical reports. Typically, multiple DLs have to be combined for satisfying an information need.
Manual searching in such a distributed environment, i.e. searching each digital library in isolation, is cumber-some and frustrating. Users typically want a single-stop solution which efficiently supports the search process in the underlying libraries and solves the problems arising from heterogeneous metadata schemas (e.g., Bib-TeX, Dublin Core, MARC).

As one such solution, this paper proposes a peer-to-peer network of distributed heterogeneous, reusable services, which is currently implemented in the Pepper prototype. maintain her own collection of documents which forms the basis of retrieval and browsing. This structure makes it particularly easy to provide, e.g., fulltexts (as PDFs) of personal publications or metadata collections (e.g., in BibTeX style) to the public. Other peers can wrap web portals like ACM. Special services deal with the heterogeneity of collections by transforming queries or documents.

Basically, a service provides a modular piece of functionality which can be reused in different applications or for different scenarios: For example, the task of storing and providing statistics about document collections, or the task of transforming documents into different schemas are required for both retrieval and browsing.
The Pepper system integrates more than a dozen services which facilitate searching, browsing, or both. For efficiency, the design is based on a hierarchical network, where the peers are divided into two distinct classes, i.e. hubs (directory server peers) and leaves (typically running on a user machine). JXTA-SOAP is employed for communication, although other middlewares can be plugged in as well.

The following section describes the proposed architecture and the set of services. Section 3 introduces the concept and generation of statistical metadata of collections, called  X  X  X esource descriptions X  X . The problems of efficient query routing and of providing browsing functionality are discussed in Sections 4 and 5 . In Section 6 , we tackle the issue of integrating data from heterogeneous schemas. Section 7 reflects related work in the fields of architectures and distributed retrieval and browsing. 2. A service-oriented peer-to-peer network
The architecture of the Pepper prototype is built on the ideas of service-oriented architectures and peer-to-peer networks. Fig. 1 depicts the layers which are involved. They are described throughout this section. 2.1. Network topology
Pepper borrows an important idea from other peer-to-peer networks like KaZaA or JXTA Search ( Water-house, 2001 ): The set of peers is partitioned into two disjoint classes, hubs (sometimes also called super peers or ultra peers) and leaves (also called DL peers):
Hubs are static dedicated peers with large memory and high-computation power, which remain online for most of the time. Hubs work as directory peers, which means that other hubs or leaves register (some of) their services at a hub. As a consequence, hubs are, e.g., responsible for query routing.

Leaves host user-oriented services. For example, if a user wants to share the documents with others in the network, a search service is running on his PC which allows for retrieval on that local collection (on that  X  X  X igital library X  X ). Leaves are only connected to hubs; there is no direct connection between leaf peers.
The hub-to-hub connections can form an arbitrary peer-to-peer network, or the hubs can be arranged in a more specific topology. In Section 4 , we compare three different topologies and corresponding resource selec-tion approaches: an arbitrary hub network, a hub HyperCube ( Schlosser, Sintek, Decker, S, &amp; Nejdl, 2005 ), and a DHT-based global index distributed over the hubs (which imposes a ring structure on the hub network ( Stoica, Morris, Karger, Kaashoek, &amp; Balakrishnan, 2001 )). Other topologies for the hub network are con-ceivable as well.

This family of topologies (with a hub network and leaf peers attached to the hubs) is called a hierarchical network. The advantage of such a topology is the smaller number of peers that are involved in the query rout-ing process, and the lower number of messages required. The impact of churn (arbitrary peers dynamically joining and leaving the network) is reduced, if the hubs, at least, are designed to remain online and stable most of the time. Together, hierarchical networks scale better than unstructured networks, as the scalability prob-lem is shifted to the smaller hub sub-network. 2.2. Services in Pepper
Pepper employs a flexible architecture where services (written in Java) do not depend on the underlying middleware. Any class can be used as a service; another service can invoke all methods which are defined in one or more interfaces. If a service wants to interact with its environment (e.g., to find other services), it has to implement two methods which allow to set and retrieve a  X  X  X ervice environment X  X  object. The services found are returned as simple objects; if a remote service method has to be invoked, this is covered by an ordin-ary local Java method call.

A single peer can provide multiple services, which can be retrieved by its name. The Pepper system hosts a for supporting different routing and retrieval strategies. The functionality of the services is described in the following sections. 2.3. The JXTA-WS framework
As the Pepper services do not depend on any particular middleware, the same implementation can be used in different contexts. By default, Pepper uses the JXTA-WS (JXTA web services) framework, a combination of web services and peer-to-peer networks we have created. It is built upon JXTA ( Gong, 2001 ) and JXTA-SOAP. 2 JXTA is one of the state-of-the-art peer-to-peer frameworks and defines a set of open, XML-based protocols for connecting a variety of devices, e.g. PCs, PDAs or mobile phones. The JXTA reference imple-mentation is written in Java. 3 The sub-project JXTA-SOAP is used for communication in JXTA-WS, as it allows to send SOAP messages 4 through a JXTA network.

JXTA-WS dynamically creates  X  X  X tubs X  X  for remote services. A stub is a class which implements all service interfaces, and redirects calls to the remote peer via JXTA-SOAP. Thus, the SOAP communication is com-pletely hidden to the service developer. JXTA-WS automatically instantiates services on peers and provides convenient configuration support for single services (specifying properties for service classes and their instances) and whole peers (defining the services which are instantiated on each peer). It also adds capabilities for finding services (described by JXTA advertisements) running on the local or on remote peers.
Although Pepper seamlessly interoperates with JXTA-WS, the latter is general enough that it can be used in other projects without changes. On the other hand, Pepper could also use alternative middlewares. A simula-tor, for instance, could provide a functionality similar to JXTA-WS by running several peers in the same pro-gram, with direct Java calls to remote services. This could be useful for both network simulations and testing, as a simulation is much more efficient and faster to set up than real networks. 3. Retrieval model and resource descriptions
This section introduces the theoretical basis of the search and browse tasks (see Sections 4 and 5 ): We first describe our probabilistic retrieval model, and then present an efficient way of representing statistical metadata about the collections involved, called  X  X  X esource description X  X , which is required for distributed retrieval and browsing. In particular for the browsing task, we consider resource descriptions of different granularity, organised in a resource description hierarchy. 3.1. Probabilistic retrieval model
Pepper employs a simple, linear probabilistic retrieval model, which boils down to the scalar product in the its importance), and ~ q  X  t  X  X  Pr  X  q j t  X 2 X  0 ; 1 be the weight of the term in query q with uments and queries are considered as vectors with a probabilistic interpretation of the weights. Assuming dis-jointness of query terms ( Wong &amp; Yao, 1995 ), retrieval status values (RSVs) are computed as the scalar product (a weighted linear sum) of the document and the query vector. These RSVs are then mapped onto the probability Pr(rel j q , d ) that d is relevant to q with a suitable constant c :
The model can be theoretically justified following Rijsbergen X  X  paradigm of Uncertain Inference ( van Rijsber-gen, 1986 ), by using the interpretations:
Different indexing schemes can be used, e.g. normalised term frequencies or BM25 ( Robertson, Walker, Han-cock-Beaulieu, Gull, &amp; Lau, 1992 ). It has been shown in Nottelmann and Fuhr (2006) that local IDF values, which are computed for each DL autonomously, are outperformed by hub-global ones. The latter are com-puted on each hub H for each term t from the term X  X  document frequency in the combination of the DLs which are directly connected to H (i.e., the DLs in the directly neighbourhood of hub H , see Section 3.3 ).
Pepper is able to deal with simple schemas, in which documents are modelled as a linear list of attributes is Dublin Core ( Dublin Core Metadata Initiative, 1999 ). Such documents can be easily expressed as XML documents (with only two levels of elements), or as binary relations (as used in Section 6 for declarative def-initions of schema mappings). As a consequence, the single document vector vector which combines document vectors for each attribute. For simplicity, we ignore this detail in the follow-ing descriptions of retrieval and browsing; both access modes can be extended towards linear schemas in a straight-forward way. 3.2. A hierarchical organisation of resource descriptions
A  X  X  X esource description X  X  contains statistical metadata about a collection, which can be exploited for quencies, while resource descriptions have the form of language models in the resource selection approach with the same name.

Resource descriptions in Pepper are different: They are considered as probabilistic vectors ~
A  X  t  X  X  Pr  X  t j A  X 2 X  0 ; 1 which are the centroids of the descriptions of a set of documents A ={ d other words, the values in the description vector are defined as the average term weights of the documents in the set A :
Here, j A j denotes the cardinality of A , i.e. the number of documents in the set. If a term t does not appear in any document in A , then ~ A  X  t  X  X  0.
 Resource descriptions are defined at different granularities ( X  X  X evel of abstraction X  X ):
In the easiest case, the set A ={ d } contains exactly one document. Then, such a description vector on the document level is equivalent to the document vector (defining the indexing weights of the terms): other words, the document index (i.e., the document vectors descriptions.

The other extreme is a single description vector for the whole collection DL . In this case, the vector tains all terms in the collection and the average of the indexing weights in this single collection.
In a more general setting, the resource description contains 1 6 n 6 j DL j description vectors, each repre-senting a cluster. If such a cluster C is split into sub-clusters C are already computed, then ~ C can be computed efficiently by directly combining ( X  X  X ggregating X  X ) these description vectors:
These different kinds of resource descriptions form a hierarchy (see Fig. 2 ), with the document vectors as leaves, the collection vector as root, and description vectors computed by aggregating description vectors on lower levels of the hierarchy. By relying on this hierarchical organisation and on a probabilistic retrieval model, we are able to model resource descriptions at different granularities smoothly.

The hierarchy can be computed by any hierarchical clustering algorithm, or by repeated application of a partitioning algorithm, provided that the resulting clusters do not overlap. Currently, we employ Buckshot ( Cutting, Pedersen, Karger, &amp; Tukey, 1992 ), a variant of k -means, with the scalar product of the document term vectors as similarity measure. This corresponds to the RSV (Eq. (1) ) in our retrieval model, if the terms of one document are treated as a query which is compared to the other document.

In addition to the term statistics, we compute a homogeneity score h ( C mean similarity of the individual elements (resource descriptions in the cluster) d to the cluster centroid c
This homogeneity score is important for the browsing service (see Section 5 ). In the more general context of resource descriptions, it is an indicator for the level of abstraction of a given resource description.
As described on the document level, Pepper is able to deal with simple schemas. As a consequence, docu-ments and resource descriptions may consist of attributes and separate values for each attribute. For comput-ing the cluster hierarchies, these separate values can be combined in a straight-forward way into one term vector. Thus, the scalar similarity measure can be used for simple schemas as well, and the resource description service will still create one single hierarchy. 3.3. Resource descriptions and cluster hierarchies for hubs
The neighbourhood of a hub H is the set of DL leaves which can be visited through H . In a simple yet effec-tive and efficient scenario, this neighbourhood of H contains exactly all leaf peers (with their DLs) which are directly connected to hub H . The description of hub H can be formed by aggregating the resource descriptions of the DL j following Eq. (4) .

In order to extend the concept of the resource description hierarchy to hubs, we could compute a cluster hierarchy from all the documents in a hub X  X  neighbourhood. However, when a leaf left or joined this neigh-bourhood, we might have to touch and adapt each cluster in the whole hierarchy. Therefore, we chose a com-promise solution: Instead of single documents from each leaf, we use the leaves X  resource descriptions to compute the hierarchy on the hub. In this case, when a leaf joins or leaves the network, only one path of the hub X  X  cluster hierarchy will be affected. An abstract representation of such a cluster hierarchy is depicted in Fig. 2 a. The squares and hexagons in the figure symbolise semantically similar content. The content on each leaf (DL) is rather homogeneous, so that a leaf X  X  resource descriptions represents its content quite accurately. the hub X  X  cluster hierarchy.

On the other hand, if the individual DLs contain rather heterogeneous content themselves, then a leaf description will already be a very generalised representation of the leaf X  X  content and may not differ much from a neighbouring leaf description. Such a situation is depicted in Fig. 2 b. The resource descriptions of the two leaves are similar, while both contain documents about two different topics (symbolised by the squares and hexagons). If those topics are to be present in the hub hierarchy as well, then the hub hierarchy must be com-puted from a deeper layer of the leaf hierachies. Regardless of the chosen depth, however, the content of the roots on hubs and leaves themselves does not change. In both cases, a leaf description is the aggregation of all document descriptions in its DL, and a hub description is ultimately the aggregation of all document descrip-tions in the hub X  X  neighbourhood.

Hub descriptions are used for decentralised resource selection (Section 4 ), where a hub H may store the hub descriptions of its adjacent hubs H i , in addition to its own hub description. Moreover, the proposed browsing approach requires a global cluster hierarchy, which  X  in its first implementation  X  has to be computed from all hub descriptions in the network (see Section 5 ). 3.4. Resource description services
Two closely related services are responsible for creating, storing and handling resource descriptions in leaves and in hubs:
Leaf inventory services ( LIS ) store the documents in a single collection, the resource description with its clusters and description vectors (including the document index, i.e. the clusters with a single document), and provide full documents and resource descriptions upon request. As the name suggests, a LIS runs on a leaf.

Hub inventory services ( HIS ) store resource descriptions of multiple collections (from leaves and hubs) and provide them upon request. HIS are running on hubs.

These resource descriptions can be used by a variety of other services. For example, the search service uses the single-document description vectors for providing retrieval capabilities on the collection. The resource selection service (see next section) uses the resource description with a single vector for the whole collection, while browsing (see Section 5 ) is based on different levels of the cluster hierarchy. So, the same service imple-mentation and the same techniques of creating resource descriptions can be employed for different scenarios.
Peer-to-peer networks are characterised by a dynamic behaviour, where peers appear and disappear at any time. In such an environment, transferring resource descriptions becomes a crucial efficiency issue. Several countermeasures are used in Pepper for improved efficiency: Each resource description is quite small, 2 MB on average for leaf peers (for about 26,500 documents).
These descriptions can further be pruned ( Lu &amp; Callan, 2002 ), i.e. only the terms with the highest weights are included. For browsing, the same principle was already employed in Cutting et al. (1992) . There, the top 50 X 100 terms sufficed for browsing purposes.

Each leaf aims to connect to the same hub it has been connected before, as no new transfer has to be ini-tiated in that case.
 When a single new document is inserted into a collection, the resource descriptions are kept untouched. Updates are performed only after a certain number of insertions, or after a predefined time limit.
When a peer joins a hub neighbourhood, its description is inserted into the hub X  X  cluster hierarchy following the path of the cluster descriptions which are most similar to the peer description, from the root downward.
Thus, of the cluster descriptions used for browsing (see Section 5 ), only one of the hub X  X  several top clusters is changed and its description has to be resent for the next request. The hierarchy on the hub is recomputed after a predefined time limit. Peers leaving the network are handled accordingly.

When a hub fails, its peers will get a time-out as soon as they try to contact the peer-to-peer network. Then, they will attach themselves to other, available hubs. If a hub leaves the network in a controlled way, then it can notify its leaves, so that they will not need to wait for the time-out. 4. Resource selection
It is too expensive to send the query to all search services. Resource selection is the task to decide to which peers a query should be broadcasted, and how many documents have to be retrieved from each selected peer. This decision is based on the resource description introduced in the previous section.

In the remainder, we assume that a user specifies the number n of documents she wants to receive; this num-ber is sent in combination with the query q through the network. The detailed task then is to compute, for every DL i , the number s i of documents which have to be retrieved from DL a user-specified value n . 4.1. Decision-theoretic framework
Traditional resource ranking approaches first find the best collections, and then select a constant number of documents from each selected collection (i.e., s i 2 {0,const}). In contrast, the decision-theoretic framework (DTF) ( Nottelmann &amp; Fuhr, 2003; Fuhr, 1999 ) returns those s
Costs are introduced in DTF as a general-purpose optimisation criterion: Similar to the probability ranking principle (PRP) ( Robertson, 1977 ), costs are assigned to relevant and non-relevant documents. In other words. retrieval quality is measured as the number r i ( s i , q ) of relevant documents in the result set of s
Computation time in the DL (which is often assumed to be constant), and communication time for sending the documents (proportional to the number of documents s i are mainly per-document charges.

Actual costs are unknown at query time, thus expected costs EC considered. They are computed as the weighted sum of the expected costs for the different cost criteria; a user
The goal is then to compute a selection vector ~ s  X  X  s 1
Retrieval quality, i.e. the expected number E [ r i ( s i estimated in two steps: tion vectors ~ DL and the constant c , the expected number E (rel j q , DL ) of relevant documents in the whole collection is estimated as In a second step, an approximation for the recall-precision function of the retrieval system associated with DL is employed for estimating retrieval quality in the top ranks, i.e. for transforming E (rel j q , DL ) onto E [ r i ( s i , q )].

Please note that in this context the linear retrieval model uses no metadata apart from the resource descrip-tions, which consist (as described in Section 3 ) of one term-weight vector per resource (document or DL) for unstructured text data. In the case of a simple, linear schema, the resource descriptions are composed of one term-weight vector per resource and attribute.
 together in one list, without further normalisation. 4.2. Different strategies and topologies for resource selection Based on the principle of hierarchical networks, different topologies can be considered (see Nottelmann &amp; Fuhr, 2006 for a detailed overview): In the default case, no restrictions on the hub sub-network are imposed.
Similar to Lu and Callan (2004) , resource selection is then applied in a decentralised way: Each hub receiving the query selects those neighbour leaves and neighbour hubs which minimise overall costs, employing resource descriptions of all neighbours (including hub descriptions). Fig. 3 a depicts the message flow in the whole net-work; here, thick lines denote connections over which messages are sent (the numbers indicate the order), while thin dotted lines are other connections. In this example, hub 1 is the  X  X  X nitial hub X  X , the first hub which receives the query. DTF at hub 1 selects one of its neighbour leaves and hub 2 (and forwards the query to these peers), but not hub 3. Hub 2, however, computes a local optimum selection which now includes hub 3. DTF-based selection is deterministic with respect to the initial hub, i.e. barring churn, it yields the same set of documents. For different initial hubs, however, the optimal set of documents may differ, because the costs for obtaining the documents (e.g., communication costs) generally depend on the requesting hub.

Cycles in the hub sub-network impose several problems. In particular, efficiency decreases as the same hub can be contacted several times. As one solution, an alternative topology based on HyperCubes ( Schlosser et al., 2005 ) can be employed. A HyperCube is a regular d -dimensional structure, where each peer is connected to exactly d other peers (one per dimension, see Fig. 3 b). Messages arriving via a connection on dimension l 2 {0,1, ... , d 1} can only be forwarded to peers on strictly higher dimensions l starts on hub 1, this hub 1 can forward the query to hubs 2, 3 and 5. Hub 3 can only forward the query to its DL neighbours and hub 7 when it is contacted by hub 1; the dimensionality of the link to hub 4 is too small.
However, if the search starts from hub, and it contacts hub 3 on dimension 0, then hub 3 can forward the query both to hub 1 on dimension 1 and to hub 7 on dimension 2, because the dimensions of those connections are greater than the dimension on which hub 3 was reached. Thus, the dimensions define (starting from an arbitrary peer) a spanning tree on the network, which ensures that there is exactly one path from one peer to another peer. It also corresponds to a clearly defined partition of the whole network, which is exploited for creating resource descriptions. Resource selection is performed as before, where each hub computes an optimum selection of its neighbour peers (which can be reached in the HyperCube topology).

A third option is to employ distributed hash tables (DHTs). Similar to traditional hash tables, they provide fast insert and lookup functionality for keys based on hash functions. The DHT system Chord ( Stoica et al., 2001 ) (see Fig. 3 c) maps peers and keys onto numbers using the same hash function. Peers are ordered in a ring according to the hash values, and each peer is responsible for storing the values for all keys mapped onto its hash value (and all values higher than the preceding peer). In Fig. 3 c, one term which is mapped onto the hash value 4 is stored on the peer whose key has the same hash value. In contrast, another term is mapped onto hash value 2, which does not correspond to any peer. Thus, peer 4 is responsible for storing that term, too. Each peer maintains a  X  X  X inger list X  X  of peers in exponentially increasing distance, which contains all known peers and allows for efficient routing in O  X  log m  X  hops for m peers (ignoring the hub-to-hub connections in the two other to contact peer 11, which is the closest known peer preceding peer 13 (which is responsible for that key).
For Pepper, a natural choice is to use hubs only for the DHT, to use terms t as keys and the corresponding selection takes place. This contrasts other DHT approaches, where either the whole document index is kept in the DHT ( Harren et al., 2002 ), or DHTs are used for resource selection in unstructured networks (Minerva,
Bender, Michel, Zimmer, &amp; Weikum, 2004 ). A variant only stores hub descriptions in the DHT (yielding much smaller inverted lists), so that an additional selection step is required at selected hubs. The advantage of DHTs is that cost estimations can be collected faster, as only a small number of lookups is required. 4.3. Resource selection services
Each leaf hosts arbitrarily many leaf inventory services and attached search services. Hubs host several ser-vice instances which are involved in query processing:
A DTF cost estimation service returns for a given query a cost estimation of all known neighbour search services.
 An optimum selection service receives cost estimations, and returns an optimum selection.

A resource selection service in general returns a selection. Different variants for the three topologies are employed, based on the DTF cost estimation and the optimum selection service. However, a different (e.g., CORI-based) selection could easily be implemented by creating a new service instance which is inde-pendent from these two services.
 A result merging service receives the results from different search services and returns a single ranked list. Currently, the documents are re-ranked according to their original weights (probabilities of relevance).
A (hub) search service receives the query, just like a search service backed by a DL, and utilises other ser-vices on the hub and on neighbour peers for retrieving results.

The hub inventory service instance stores one description vector for each collection, together with further information like the number j DL j of documents in the collection or the constant c .

When distributed hash tables are employed for a faster centralised selection, a DHT service is responsible for maintaining the distributed hash table.

Alternatively, a HyperCube service might be used for creating the HyperCube topology (if required during runtime).

In environments with heterogeneous schemas, schema mapping services have to be employed (see Section 6 for a detailed description). 4.4. Experimental results
The decision-theoretic framework has been proven to be effective, and to yield competitive results com-pared to CORI ( Nottelmann &amp; Fuhr, 2003 ). This section reports the quality of DTF applied to peer-to-peer networks (an extended evaluation is carried out in Nottelmann &amp; Fuhr (2006) ).

Experiments have been conducted on a large test-bed: 2500 collections (each on a leaf) and 25 hubs, which have been created from part of the WT10g collection ( Lu &amp; Callan, 2003 ). The WT10g collection was divided into 11,485 subcollections according to the document URLs, and the 2500 leaf collections were chosen ran-domly from this set of subcollections. Similar collections were assigned to the same hub (per hub, at least 13 and at most 1013 leaves), while the connections between the hubs were generated randomly, with each hub having between 1 and 7 neighbour hubs. The overall test-bed is rather heterogeneous. One thousand short queries are applied onto this network. As no relevance judgements are given, pseudo-relevance data is used, created from combining all 2500 collections into one centralised collection, ranking the documents w.r.t. their probabilities of relevance for a given query, and marking the 50 top-ranked documents as  X  X  X elevant X  X . Thus, the experiments measure how well distributed retrieval with the different topologies and resource selection strategies approximates a centralised collection.

The decentralised selection used in Pepper has been compared to a centralised selection (both, however, on the distributed collection ). In the latter, the query is flooded through the hub-sub-networks, and each contacted hub returns cost estimations of all neighbour leaves. Finally, a single selection is performed based on all col-lected cost estimations. Thus, only the cost estimation is distributed, computing a selection and contacting the selected DLs is centralised. Results are depicted in Table 2 . Not surprisingly, centralised selection outperforms the decentralised variant in terms of effectiveness: Precision in the top ranks, average precision and set-based recall and precision are 6 X 13% worse for decentralised selection. However, an important advantage of decen-are required for this cost collection phase) Thus, decentralised selection requires 42% less hops. HyperCubes and DHT perform worse in the top ranks, but outperform the centralised hierarchical network variant in lower ranks, in terms of mean average precision (MAP) and set-based recall and precision.

A comparison of our results with other methods is difficult, as these experiments are not comparable. How-ever, the decentralised DTF selection approach seems to be competitive to the results reported in Lu and
Callan (2004) and Lu and Callan (2003) . Future work should concentrate on a direct comparison of the dif-ferent approaches.
 5. Browsing
The browsing service in Pepper enables Scatter/Gather browsing ( Cutting et al., 1992 ) on the whole distrib-uted document collection. Scatter/Gather browsing is a highly interactive, cluster-based browsing paradigm in which an overview of the whole dataset or of a selected subset is generated by clustering and presented to the user. The user can then again select parts of the overview (or the whole) for further inspection, and so on.
Fig. 4 a shows the general principle. A given data set, the focus set , is clustered by the system. This is the so-called scatter step, depicted by the dashed lines in the figure. The user selects one or more of the presented clusters (solid lines), which are then merged (gather step) and form the new focus set, etc. Eventually, the user reaches a sufficiently small focus set which mainly contains relevant items.

Cluster-based browsing is an alternative to search, in cases where the user has little knowledge of the doc-ument collection. In that situation, she may not be able to formulate a useful query, and will need to gain an overview of the data first. Providing overviews is therefore the main objective of Scatter/Gather browsing in
Pepper. In contrast to other top X  X own browsing approaches, e.g. a browsing through a classification hierar-titioning of the data is most meaningful to her. This is particularly useful in heterogeneous document collections where there might be several ways to cluster documents together to build an overview. The user herself can steer the process easily in each interaction step, simply by selecting the most promising parts of the data.
 5.1. A three-tier hierarchy
In pre-processed Scatter/Gather ( Cutting, Karger, &amp; Pedersen, 1993 ), it was shown that the clusterings do not have to be computed directly from the underlying documents. It suffices to consider representatives of datasets instead, which contain the most important statistical properties. Cutting et al. (1993) used cluster summaries from a pre-computed cluster hierarchy. In Pepper, we already have a hierarchy of resource descrip-tions on each leaf peer and on the hubs, which can serve the same purpose.

In contrast to Cutting et al., however, we do not generate one global cluster hierarchy for the document collection, which would be impossible in the highly dynamic environment of a peer-to-peer network. Instead, as described in Section 3 , the resource description hierarchy is calculated separately for each leaf and repre-sents the content of the leaf only. Similarly, the hierarchy on a hub represents the content in its neighbourhood only, building on the description hierarchies on its leaves. Therefore, the resource description hierarchy for a hub neighbourhood already contains two tiers: the cluster hierarchies on the leaves, and the cluster hierarchy on the hub (which is formed from the topmost clusters on the leaves, as described in Section 3.3 ). For an over-view of the whole content available at a certain point of time, we introduce a third, global tier.
For the current, preliminary implementation of the browsing service, we assume that each hub knows all other hubs in the network. 5 Each hub collects the descriptions of all other hubs, and combines them into a global hierarchy. Fig. 4 b shows the resulting three-tiered hierarchy of resource descriptions, where each tier consists of the cluster hierarchies on that level (leaf, hub, or global).

In smaller networks, the global hierarchy may be computed just in time for a browsing request, while in larger networks, it should be precomputed and updated or recalculated in intervals.

Due to peer dynamics (peers joining and leaving the network) and content dynamics (documents being added, deleted, or changed), the resource description hierarchies on hubs and leaves have to be updated con-tinuously. In Section 3.4 , we listed some countermeasures to reduce the effort of these updates and keep changes as local as possible. However, the effectiveness of these measures, and their limitations, will have to be investigated in more detail in dedicated experiments. 5.2. Scatter/Gather browsing in Pepper
When the user starts browsing, the browsing service (running on a peer) requests the initial overview over the whole collection from its hub. The hub inventory service sends the uppermost layer of its global resource description hierarchy, which is presented to the user as a set of clusters.

The user selects one or more clusters, the focus set, for further inspection. Using the homogeneity scores h ( C i ) (Eq. (5) ), this focus set is expanded by replacing the most heterogeneous resource descriptions with their children, i.e. with a higher number of resource descriptions for the same set of data, representing the data in more detail. The focus set is expanded further by the same method, until its size reaches the maximum number of elements which can be clustered fast enough for online browsing. This expansion step is very similar to the expansion step in Cutting et al. (1993) , except that we expand the most heterogeneous clusters rather than the largest ones.

Fig. 5 shows the expansion step in a simplified example: Let a given focus set consist of only one cluster with resource description A (homogeneity 0.08). This cluster may have been created by online clustering in the previous scatter step, or it may already stem from a pre-computed resource description hierarchy from a hub or leaf peer. Let the maximum number of items in the focus set, before it has to be clustered for re-presentation, be 5. As the focus set in this example has not reached its maximum size yet, the resource descrip-tion with the lowest homogeneity score, i.e. A, is selected for expansion. A is removed from the focus set and replaced by its children B and C, which are requested from the appropriate inventory services. Now, the focus set has a size of two, which is still below the maximum. Therefore, the resource description with the lowest homogeneity score, B, is selected and replaced by its children D and E, and the process continues until the focus set contains five items. The numbers at the resource description symbols in Fig. 5 a indicate the whole expansion sequence, and Fig. 5 b shows the changing focus set. Finally, the focus set contains the resource descriptions D, H, I, F, and G. Note that these resource descriptions represent the same set of documents as A, but in more detail.

As soon as the focus set has reached its maximum size, the resource descriptions in the focus set are clus-tered online and presented to the user for further browsing. In the example, the focus set is partitioned into two clusters ( Fig. 5 c), and the user would therefore see two resource descriptions from which to select the sub-set for the next browsing step. 5.3. Discussion
Presenting an overview of the whole distributed content to the user is an inherently more difficult task than an explicit search. Therefore, for the browsing service, several problems remain to be solved.
The most basic question to our proposed approach for browsing is: Can a tiered hierarchy of resource iments ( Fischer &amp; Nurzenski, 2005 ), we compared a global cluster hierarchy (configuration  X  X lobal X ) to two tiered hierarchies, one where the leaf peers were assigned to hubs randomly (configuration  X  X andom X ), and one where leaves with similar content were clustered together and assigned to the same hub (configuration  X  X luster X ). Both tiered hierarchies performed nearly as well as the global hierarchy, and we deem these first results encouraging enough to continue the approach of tiered hierarchies and investigate its problems and possible solutions in more detail.

In particular, future experiments should clarify why there was hardly a difference between the  X  X andom X  and  X  X luster X  configurations (i.e. between the two tiered cluster hierarchies, which differed in the setup of the net-work only). A possible explanation might be that the leaf clustering was not effective, so that the sets of leaves which were gained by clustering were not significantly different from the sets of leaves which were chosen ran-domly. This means that the cluster hypothesis should be checked with respect to the leaf clusters. Still, as both tiered hierarchies were reasonably close in performance to the centralised, global setup, this unresolved ques-tion does not refute our optimistic judgement of the approach of tiered hierarchies as a whole. Instead, it should be taken into account in future experimentation.

Another important issue is communication costs. During browsing, the limitation on the size of the focus set guarantees that only a limited number of peers have to be contacted during the expansion phase. The num-ber of resource descriptions which have to be transferred for this step depends on the desired size of the focus set. Cluster resource descriptions are retrieved only as far as necessary (with the IDs of their direct children instead of the complete underlying hierarchies). Furthermore, hubs can cache resource descriptions. Each hub remembers which resource descriptions have changed (due to leaf peer dynamics), and when. The request-ing hub which collects resource descriptions for browsing can send a time stamp with the request, and only those descriptions which have changed since then are sent again. In this context, the impact of churn will have to be considered in more detail as well.

Still, in comparison with the resource selection scenario, the proposed solution for browsing has a major drawback: The computation of the initial overview requires contacting all hubs in the network and then clus-tering their resource descriptions online. Although the resource descriptions can be pruned for this purpose to a very small number of terms, this approach is not scalable beyond a certain number of hubs. To ameliorate this problem, the overview over the hub descriptions could be created regularly and offline, instead of online and for each browsing session individually. This approach would be based on the supposition that the content of a hub region changes slowly even if the individual peers show more dynamics. Even then, however, the hubs would still have to maintain a list of all other hubs. Instead, hub descriptions could be spread through the network by gossiping, for instance, or we could drop the assumption that the entire content in the network must be represented, in favour of obtaining a representative selection of the available content. The latter idea would lead to a kind of resource selection for hub descriptions, in analogy to the resource selection approach for documents in Section 4 . Whether that solution is preferable, this question depends primarily on the user X  X  needs in browsing. Hence, different browsing approaches are currently under research.

Finally, apart from heterogeneity on the content level, the documents in a peer-to-peer network may also show structural heterogeneity, i.e. different schemas.

In this case, resource descriptions and documents have to be translated to the browsing schema (the schema which the user selected for the browsing session). This is the task of schema mapping services (described in the next section). 6. Schema mapping
As mentioned in Section 3 , documents with simple schemas are modelled as a linear list of attributes. Exam-ples for such schemas are Dublin Core or BibTeX.

Schema mapping services assist other services in heterogeneous environments. When collections employ dif-ferent schemas, documents and queries have to be converted. This task is accomplished by three kinds of schema mapping services: query transformation services (for converting the user query into the DL schema), document transformation services (for results) and resource description transformation services (for resource selection and browsing).
 Each schema mapping service is specialised in mapping from one fixed schema onto another fixed schema.
Multiple schema mapping services have to be chained to map between two schemas for which no direct map-ping is available. Pepper employs the sPLMap framework ( Nottelmann &amp; Straccia, 2005 ), which allows for uncertain mappings. These are required when schemas of different granularity are investigated. For instance, if a schema with the general attribute  X  X  X reator X  X  has to be mapped onto a schema with two attributes  X  X  X uthor X  X  and  X  X  X ditor X  X , there is no precise mapping.

The sPLMap framework follows a declarative approach for human-readable schema mappings. The schema attributes are mapped onto relations in probabilistic Datalog ( Fuhr, 2000 ), a probabilistic extension to Horn logics. Queries are logical rules. Schema mappings are defined by rules in a declarative way, e.g.: These rules state that a creator is an author with probability of 70%, and an editor with probability of 30%.
These simple rules can be augmented if the query transformation also has to include search operators (when a specific search operator is not available in the target schema, e.g. soundex similarity for author names), or when the values have to be converted (for instance between different date formats, e.g. from  X  X 2004-31-12 X  X  to the German  X  X 31. Dezember 2004 X  X ).

For document transformation, documents have to be converted into pDatalog facts. Then, the rules are applied, and the resulting facts are converted back into documents (which now might have a probabilistic weight for each attribute). Queries, on the other hand, have to be unfolded using the mapping rules. For exam-7. Related work
This section reflects research which is related to this paper w.r.t. to the architecture or its major components (resource selection and browsing). 7.1. Database-oriented query routing in peer-to-peer networks
Most research on peer-to-peer networks has focused on database-oriented approaches for sending ( X  X  X out-ing X  X ) a query through the network, which ignores the degree of usefulness of a resource (contrasting tradi-tional IR-based resource selection techniques, see Section 7.2 ). Early unstructured peer-to-peer networks do not scale: Napster ( Saroiu, Gummadi, &amp; Gribble, 2002 ) with its centralised document index has a single point of failure. Flooding the query through the whole network like in Gnutella ( Ritter, 2001 ) imposes too high a load.

The effect of flooding can be reduced in hierarchical networks like KaZaA 2001 ), which partition the peers into hubs (super-peers) and leaves. This architecture is also used, for example, in the more recent project P2P-DIET ( Idreos, Koubarakis, &amp; Tryfonopoulos, 2004 ) which combines ad-hoc search and continuous querying in super-peer networks.
 Structured networks, on the other hand, have a regular topology which can be exploited for query routing.
Distributed hash tables (DHT) like Chord ( Stoica et al., 2001 ) guarantee efficient lookup. A hash function is applied onto keys (terms and peer identifiers), each peer stores values for whose hash values are in the interval between the preceding peer and itself.

DHTs can be used to implement semantically global structures on a distributed physical basis. ODISSEA ( Suel et al., 2003 ), for instance, uses a DHT structure to store a global inverted term-document in a peer-to-peer network, while GridVine ( Aberer, Cudre-Mauroux, Hauswirth, &amp; van Pelt, 2004 ) implements a semantic overlay for managing and mapping RDF triples and schemas, over a distributed, DHT-based physical layer. Another approach for efficient routings are HyperCubes ( Nejdl et al., 2003 ), symmetric regular networks.
HyperCubes assign a dimension with each connection, and allow routing only over dimensions larger than the one over which the message arrived. Thus, they impose spanning trees on the network and thus avoid cycles. All three approaches  X  hierarchical networks, DHTs and HyperCubes  X  have been described in detail in
Section 4.2 . 7.2. IR-based resource selection
Resource selection is the task to decide to which digital libraries (or peers) a query should be forwarded, and how many documents have to be retrieved from each selected DL. In contrast to the query routing meth-ods described in the previous section, the decision is not based on the network topology alone, but rather on an estimation of the usefulness and in some cases, the potential costs of contacting a certain peer.
For federated digital libraries with their centralised selection component, this problem has been investi-gated for about a decade. Different to Pepper X  X  decision-theoretic framework, most of the other selection algo-rithms rank the digital libraries (DLs) w.r.t. their similarity to the query, and retrieve a constant number of documents from the top-ranked libraries. Popular examples are the INQUERY-based method CORI ( Callan et al., 1995 ) and the language model approach presented by Si, Jin, Callan, and Ogilvie (2002) . PlanetP ( Cuenca-Acuna, Peery, Martin, &amp; Nguyen, 2002 ) is a peer-to-peer adaptation of the resource selection con-cepts from CORI and GlOSS ( Gravano, Garcia-Molina, &amp; Tomasic, 1994 ) and relies on gossiping to spread rich, 2005 ), which allows peers to store a self-selected number of peer descriptions instead of a complete term-to-peer index, but does not take user-defined costs into account.
 Other recent projects like GALANX ( Wang, Galanis, &amp; DeWitt, 2003 ) and MINERVA ( Bender, Michel,
Triantafillou, Weikum, &amp; Zimmer, 2005 ) use DHTs to distribute a global term-to-peer index, which is used for centralised resource (peer) selection. MINERVA balances the usefulness of a distant peer against the commu-nication costs. Pepper generalises this concept in the decision-theoretic framework, allowing cost estimation for (possibly many) different aspects, for which the user may define different degrees of importance.
Another problem connected with resource selection is merging the results from selected DLs. In CORI, the library score is used to normalise the document score. The language model approach computes final scores based on the original (collection-biased) document probabilities, the DL scores and a smoothing factor. The quality of this approach is slightly better than CORI.

The language model approach has been extended towards hierarchical peer-to-peer networks with decen-gating the descriptions of DLs in a neighbourhood, where the influence of term frequencies of distant DLs is exponentially decreased.

All of these IR-based resource selection techniques require resource descriptions, e.g. document frequencies for CORI or a collection language model. Resource descriptions can be provided by the collection itself, or discovered via query-based sampling ( Callan &amp; Connell, 2001 ). 7.3. Cluster-based browsing The browsing method which we propose for our peer-to-peer architecture is an adaptation of pre-processed
Scatter/Gather ( Cutting et al., 1993 ). In the previous approach, one global cluster hierarchy is computed off-line, and most of the browsing and online clustering then uses the cluster descriptions, instead of the contained documents. To the best of our knowledge, Scatter/Gather has not previously been generalised to the highly distributed environment of peer-to-peer networks.

Content-based clustering as such, on the other hand, has already been employed in peer-to-peer networks as well. In Eisenhardt, Mu  X  ller, and Henrich (2003) , a distributed version of the k-means algorithm is per-formed in a peer-to-peer network, profiting from the parallelisation thus made possible. While the documents do not have to be transferred to one single peer for clustering, cluster centres are propagated to all participat-ing peers in each clustering step. The approach does not deal with peer dynamics.

Klampanos and Jose (2004) apply clustering on two levels. The documents on each peer are clustered in order to find the topics present on the peer. On joining the network, the peers themselves are assigned into context-aware groups (CAGs), which form an overlapping clustering on the basis of the topics on the peers.
The centroids of the resulting CAGs are then used for query routing. Both the clustering of peers into CAGs, and the query routing are tasks performed by hubs which have to maintain a list of all CAG centroids.
Both approaches use a local clustering of documents as well as a global list of cluster centroids. Yet, neither one addresses browsing. In Sections 3and5 , we followed similar principles to create a distributed, three-tiered cluster hierarchy for Scatter/Gather browsing. 7.4. Architectures
Service-oriented architectures (SOA) become more and more popular. Services for managing knowledge bases, planning purposes and semantic registries are provided in a hierarchical peer-to-peer network in Giold-asis, Pappas, Kazasis, Anestis, and Christodoulakis (2004) . Hing and S X lvberg (2004) combine SOA digital libraries and the peer-to-peer network software JXTA. As Pepper, they use distributed hash tables, but employ
Hilbert Space Filling Curves instead of Chord, and the DHT stores service descriptions. Content-based resource selection is not supported. Furmento, Hau, Lee, Newhouse, and Darlington (2003) present a general service-oriented architecture where the same service implementation can be used on top of the different trans-port layers, including Jini, JXTA and the Open Grid Service Infrastructure (OGSI). They claim that the major problems with JXTA are lack of security and  X  more important for digital libraries  X  performance, and rec-ommend the usage of Jini. 8. Conclusion and outlook
This paper describes the Pepper system, a peer-to-peer system for information retrieval in federated digital libraries. The flexible Pepper architecture seamlessly combines a service-oriented architecture with hierarchical peer-to-peer networks. The current implementation uses JXTA-SOAP as its basis, but this middleware could be replaced by others. On top of this architecture, several services provide two information access modes, searching and browsing.

Searching and browsing employ the same statistical data about the digital libraries. Hence, a common ser-vice collects and stores these statistical descriptions of collections, and can be utilised for both access modes.
This shows one of the major advantages of our approach: Services can be reused for different aspects of the search process, namely retrieval vs. browsing.

Another advantage of our architecture is that it is particularly easy to replace a service implementation by a new, better one as long as the service interface remains unchanged. For example, retrieval in hubs is split into different services like the resource selection service, the result merging service and a common hub search ser-vice which calls the other services. Thus, a new resource selection approach can be easily integrated by replac-ing that single service, keeping, e.g., the result merging service and the hub search service unchanged.
Future work in the Pepper project should aim at improving the single components. For resource selection, we have considered creating better hub descriptions. Hub descriptions should not only take direct DL neigh-bours into account, but should rather represent a network region. In addition, time costs (i.e., the number of hops) should be estimated in peer-to-peer networks. The browsing process will be further decentralised, and the application of other similarity measures and clustering algorithms will be investigated. In addition, the two access modes could be coupled more tightly.

In an advanced scenario, dynamic cost-based selection could be applied not only to DLs during search, but also to the services themselves which are required for solving an arbitrary user task. A logic-based approach to this problem is proposed in Nottelmann and Fuhr (2004) . Here, services are semantically described using
OWL-S, 7 mainly by defining input and output parameters. Similar to resource selection, services are annotated
Then, the selection services (located in the hubs) apply recursive match-making rules for finding suitable ser-vices and their execution order, and use the cost estimations for computing an optimum selection (similar to resource selection). 9. Note Henrik Nottelmann passed away in April 2006, before we could submit a revised version of this paper.
Although the Pepper project will be continued by others, it will take a considerable amount of time and effort for any successor to resume Henrik X  X  research. We, his colleagues in Duisburg, hope to continue his work after a necessary intermission, in his memory.
 Acknowledgements
Part of this work is supported in part by the DFG (project  X  X  X epper X  X , grant BIB47 DOuv 02-01). We wish to thank Alexej Titarenko and Andre  X  Nurzenski for their help with the implementation and the concepts used in Pepper. References
