 Although, many applications use unstructured meshes, there is no specialized mesh database which supports storing and querying mesh data. Existing mesh libraries do not support declarative querying and are expensive to maintain. A mesh database can benefit the domains in several ways such as: declarative query language, ease of maintenance, etc.
In this paper, we propose the Incidence multi-Graph Com-plex (ImG-Complex) data model for storing topological as-pects of meshes in a database. ImG-Complex extends inci-dence graph (IG) model with multi-incidence information to represent a new object class which we call ImG-Complexes. We introduce optional and application-specific constraints to limit the ImG model to smaller object classes and val-idate mesh structures based on the modeled object class properties. We show how Neo4j graph database can be used to query mesh topology based on the (possibly constrained) ImG model. Finally, we experiment Neo4j and PostgreSQL performance on executing topological mesh queries. H.2 [ Database Management ]; H.2.1 [ Logical Design ]: Data models; H.2.3 [ Languages ]: Query languages CW-Complex, Databases, Data Model, Graph Database, Multi-Incidence, Topology, Unstructured Mesh
Meshes appear in many application domains, e.g., com-puter graphics, computer aided design, solid modeling, sci-entific simulation, oceanography, climate modeling, GIS, etc. Meshes are used as (approximate) representations of phys-ical objects. Meshes subdivide a domain into smaller and simpler geometric elements (called cells , e.g., triangles, tetra-hedrons, or other simple polyhedrons) [13]. Cells are con-nected by incidence relationships. The subdivision of a do-main allows computational manipulation of complicated phys-ical structures. In principle, finer subdivisions increase accu-racy in the representation and approximation of the domain.
Although meshes are used in many domains, there is no specialized mesh database with build-in mesh operations and functionalities. Researchers have aimed at identifying re-quirements for mesh algorithms and at defining of algebraic framework to manipulate meshes [9][4]. However, to the best of our knowledge there is no database vendor which support unstructured mesh features. Utilizing relational databases for meshes is not efficient and it does not offer sufficient abstraction mechanisms to deal with meshes [10].

Existing mesh applications are written in mostly in C++ and often low-level file-based APIs are used for I/O. While it is possible to design data-structure neutral interfaces, the development of queries based on such APIs requires deep programming knowledge and is limited to a single language. More often, even the possible abstraction mechanisms (e.g., by a C++ API) are not used, and such implementations rely highly on input file structure and internal mesh representa-tion, i.e., any changes in the structure require changes in the implementation. Hence, they are less reusable and their maintenance cost is high.

A mesh database offers the following advantages: 1) declar-ative querying, 2) ease of maintenance, 3) hiding mesh stor-age structure from applications (physical data independence), and 4) transparent query optimization.

In this paper, we propose the ImG-Complex model to store mesh topology in a database system. The model has very few inherent limitations and thus its object domain en-compasses the requirements of many of the mesh domains. We instrument ImG with sets of optional and application-specific constraints to check validity of meshes.
Real-world mesh applications have similar queries, e.g., neighbor search, subsetting (i.e., to find cells contained or overlapping with a query bounding box), mapping data from one mesh to another, etc.

One of the mesh domain is oceanography . Unstructured meshes are used in oceanography for tidal, coastal and global ocean modeling. Two advantages of unstructured meshes for ocean modeling are: 1) variable resolution which is very important for focused regional modeling, and 2) continuous representation of coastlines [6]. Figure 1 shows bathymetry of North Atlantic modeled as unstructured mesh [6]. Figure 1: B athymetry of North Atlantic modeled as
The mathematical study of unstructured meshes encom-passes concepts from discrete mathematics, topology and geometry, as it involves both discrete and continuous struc-tures. In the following, we give a short informal introduc-tion to the basic notions and concepts; for a more formal and complete overview, the reader is referred to Chapter 3 of [4] and the references therein.

Mathematically, a mesh of dimension d is the union of k-cells (0  X  k  X  d ), e.g., 0-cells ( vertices ), 1-cells ( edges ), 2-cells ( faces ), up to d -cells of dimension d . The set of cells of a mesh must satisfy certain conditions e.g., the intersection of two cells is either empty or another cell of the mesh (of lower dimension). The boundary of each cell is formed of cells of lower dimension. For instance, in Figure 2 left, we see a mesh consisting of a single tetrahedron  X  , four faces f , six edges (i,.e., a , b , . . . , f ), and four vertices X, Y, Z, W . The intersection of f 3 and f 2 is the edge f and the vertices Z and W , and the boundary of f 3 is formed by the edges f, d, e and the vertices X, Z, W , or, equivalently, we say that f, d, e and X, Z, W are the sides of f 3 , in a short notation expressed as e  X  f 3 (read  X  e is a side of f 3  X ). We also say that f 3 and its sides are incident , and we call f 3 f 2 adjacent because they share a common edge. The side-of relationship determines the combinatorial structure of a mesh. It defines a partial order on the mesh, which in well-behaved meshes is graded , i.e., the boundary of a k -cell is made of ( k  X  1)-cells. In that case it can be depicted by a Hasse diagram (a.k.a incidence graph ) like in Figure 2 right, where the cells are ordered into layers of equal dimension and the side-of relationship is shown only between cells of dimensions differing by 1.
 Figure 2: Tetrahedron (left) and its corresponding I G (right).
Existing mesh representation models in the literature aim to restrict the CW -complexes to smaller object domains, because CW -complexes are too general for many practical applications (in particular w.r.t. geometry). However, in some cases the representations are very limited.

Winged-edge. Winged-edge, a widely used data struc-ture in CAD systems, uses edges to keep track of vertices and faces. Each edge keeps information about its two vertices, the two incident faces, and the four edges that immediately follow in the boundary of its two faces [3]. Euler opera-tions can be used to construct such objects. Winged-edge and similar models (e.g., quad-edge) are special cases of the cell-tuple structure (see below). It can only represent 2D manifold.

Cell-Tuple. The cell-tuple represents a mesh as a pair ( T, switch i ) (0  X  i  X  d ) where T is a set of ( d +1)-tuples and switch i is a set of operators. Each tuple ( c 0 , c 1 , . . . , c is a maximal chain in the corresponding mesh poset: c 0  X  c  X  ..  X  c d  X  1  X  c d holds. The switch operator maps each tuple to a unique tuple differing in only one dimension [5]. A generalized combinatorial map (GMap) is similar to the cell-tuple [12]. Both are limited to manifold objects and both models suffer from scalability issues [9].

Indexed Cell Set (ICS). ICS is a compact mesh rep-resentation which stores coordinates of 0-cells and d -cells as ordered list of its vertices. ICS needs to infer information about k -cells which grows fast for k &gt; 3 [18]. ICS makes an implicit assumption about topological structure of cells, i.e., there is only one sensible topological structure. In cases such as quad, we must know the order of vertices to extract edges. ICS can represent manifold, some non-manifold, and multi-incidence objects.

Incidence Graph. Incidence graph uses the directed side-of relationship as its representation. Indexed Cell Set (ICS) is a special case of IG with the implicit assumption. The cell-tuple graph is more redundant than the IG, e.g., the cell-tuple graph of a tetrahedron has 24 nodes 72 links, while IG needs only 15 nodes and 50 links, if all sides are referenced, or 28 links, if only sides of dim ( k  X  1) are stored for each k -cell. IG does not support multi-incidence and does not directly give access to order information. Further-more, constraints on topological structures must be added and checked explicitly. IG encompasses all object classes representable with previous models and more. Our model supports multi-incidences and add checkable constraints.
Mesh-Enabled Relational Model. Topology of un-structured meshes can also be represented in relational mod-els using two relational tables, i.e., one for cells and one for side-of relationships. In [17], a new efficient indexing tech-nique for tetrahedral meshes called Directed Local Search (DLS) was introduced which increases the performance mesh queries. There is a guideline on how to implement DLS in Microsoft SQL Server 2005, but there is no official support in SQL Server for meshes [7][8]. Utilizing relational databases for meshes suffers from scalability problems [14] [9]. More-over, it does not offer sufficient abstraction mechanisms to deal with meshes.
 Table 1 shows a comparison of the models above. Object Domain describes different topological models supported by each model (i.e., how cells are connected to each other). Di-mension Independence (DI) means that it is possible to rep-resent a d -mesh recursively using cells of lower dimensions [11]. Integrity Constraint (IC) checks structural validity of objects based on the object domain properties. Order de-scribes if a model preserves how lower dimensional cells are l ocated around a higher dimensional cell.

It is worth mentioning that geodatabases, e.g., PostGIS o r ArcGIS (partially) implement Simple Features , OGC and ISO standard (ISO 19125), for only 2D geographical data and do not support pure topological mesh queries such as neighbor search or subsetting [15].
Our data model is built on the IG model. It is a multi-graph data model (i.e., allows multiple links in the incidence graph) which supports representation of multi-incidences that can occur in geometric modeling. For instance, consider a torus defined by identifying the opposite edges of a square. The resulting mesh has only a single vertex, two edges and a single face. However, if we look at that face and  X  X ut it out X  of the torus, we obtain 4 copies of the vertex, and we say it is multi-incident to the face (more precisely, 4-incident). Like-wise, the edges are 2-incident to the face. A simple incidence graph cannot represent this mesh.
 Definition 1. Incidence Multi-Graph: Incidence multi-Graph (ImG) extends the graph of IG ( N, E ) to a multi-graph ( N, E m ), where each edge e  X  E is replicated k times in E m if the corresponding side-of relationship is a k -incidence.
This leads to the definition of the ImG-Complex data model:
Definition 2. ImG-Complex: A cell complex is called an Incidence multi-Graph Complex (ImG-Complex) if its cells and incidence relationships form an incidence multi graph.

The definition of ImG-complex is very general and covers a wide range of mesh application domains. For a given ImG-complex, we need to store all side-of relationships I ij where 0  X  i  X  ( d  X  1) , 1  X  j  X  d, i &lt; j . For efficiency reasons, some of the inverse relationships should also be stored. If the shapes of the cells are known (e.g., triangle, tetrahedron, etc.), then it suffices to store only I 0 d (similar to the ICS representation) and infer other incidence relationship from it.

Although, ImG can represent meshes which incidence graph cannot, topologically different meshes may have the same ImG model, e.g., torus (with one cell) and Kelin bottle. In such cases, users should ensure sufficient subdivision if they need a unique representation
It can be shown that order of vertices and edges around a given face can be extracted from ImG model using the switch operator [5].

ImG model has two main advantages: 1) representing a broad class of meshes, and 2) several admissible mesh classes (see Section 6).

In comparison to specialized models for simplicial meshes, a general model like ImG-Complex cannot help in processing and can exhibit performance problems. We can augment the ImG as a general data structure by maintaining simpler aux-iliary structures (depending on additional constraints satis-fied by the mesh) which facilitate query processing. For instance, to retrieve neighbors of a given d -cell, we can pre-compute and store those neighbors for each cell. Thus, query operations can be speed up transparently, at the expense of additional precomputing work and storage. Note that the query interface will hide representation specific details.
The ImG-Complex model can represent a large class of objects, however, in practice we usually need to restrict our-selves to a specific class of objects. One class of objects which plays a central role is the manifold. However, in prac-tice manifolds are too restrictive, i.e., the union of all cells of a mesh may not form a manifold but rather form a pseudo-manifold. We built sets of constraints to validate different classes of objects such as manifold, simplicial manifold, and pseudo-manifold. Due to space constrain, we only show the sets of constraints for manifold meshes. The constraints are not specific to ImG model and can be used with any other general mesh model.

In principle, we must check that each point of a d -mesh fulfills the manifold property. The following constraints en-sure that a given mesh dataset represent a valid manifold: 1. Graded IG: The poset of a manifold IG-Complex must be graded, i.e., every maximal chain has the same length. (Otherwise, there would not be a d -dimensional neighborhood for some points). 2. Diamond Property: If f 1  X  f 2 and f 1 and f 2 are faces of dimension ( k  X  1) and ( k + 1) (i.e., dim ( f dim ( f 1 ) = 2), then the interval ( f 1 , f 2 ) contains exactly two faces f 3 , f 4 of dimension k such that f 1  X  f 3 , f 4  X  f The diamond property is proved for convex polytopes [19]. It guarantees that each ( d  X  1)-cell f has exactly two incident d -cells and thus each interior point of f is a manifold point.
To check the diamond property in a graph, we focus on ( k + 1)-cell c 1 and ( k  X  1)-cell c 2 such that c 2  X  c then, if the diamond property holds, there must be exactly two cells of dimension k in interval ( c 2 , c 1 ) incident to both c and c 2 . (If we look from another ( k + 1)-cell, then there will be 2 different k -cells.) 3. Cell Ring: What is missing now is the manifold prop-erty for points on cells of dimension k  X  ( d  X  2). However, we can use some properties stemming from the diamond prop-erty: If c d  X  2  X  c d +1 in a mesh having the diamond property, all the cells in the interval [ c d  X  2 , c d +1 ] form a set of circu-larly ordered rings. Note that c d  X  2 or c d +1 may be improper cells. For instance, edges and faces around a vertex (which are incident to the same 3-cell c in a 3D mesh) form a vertex ring, faces and 3-cells around an edge form an edge ring.
In a 2D mesh, the only points remaining to be checked for manifold property are vertices. We can do so by verifying algorithmically that there is exactly one vertex ring, and hence this ring forms the appropriate neighborhood.
Algorithm 1 checks if edges and faces around each vertex v of a n -mesh create one ring. It starts with an arbitrary pair ( e, f ) such that v  X  e, f . Then, it traverses all the edges and faces around the vertex using switch 1 and switch operators. If the set ring is equal to the set of cells which the vertex is side-of, then that vertex satisfies the manifold property. Algorithm 1 C hecking Vertex Ring Property In a 3D mesh, we need to check vertex ring and edge ring. F or edges, we check that there is a single edge ring around each edge.

Definition 3. Vertex Star: For vertex v , the (open) star of v is the set of cells which v is side-of: st( v ) = S v  X  c
For each vertex v we need to check that st( v ) is a neigh-borhood of v : first, v 6 X   X  st( v ) ( v is not side of any cell in  X  st( v )) and second, st( v ) is equivalent to D 3 , i.e.,  X  st( v ) is a 2D manifold-mesh which is a 2-sphere. Now this is essen-tially the 2D case, where we can use the 2D Euler charac-teristic  X  = V  X  E + F  X  2 (where V, E, F are the number of vertices, edges, faces of the mesh, respectively) to check that in addition  X  st( v ) has the right topological genus and thus is homeomorphic to a sphere. Unfortunately, in higher dimen-sions, the Euler characteristic is not sufficient to guarantee topological equivalence between manifolds.
We consolidated a list of recurrent mesh topological queries which appear in many domains [4][9].

Q1. Enumeration of cells in a mesh (e.g., total number of cells, vertices, edges, etc. in a mesh).

Q2. Iteration over cells e.g., all cells of a mesh, cells of a particular dimension, etc.
 Q3. Check if the vertex set of each facet is unique.
Q4. Get list of cells which a particular cell is side-of, e.g., for a given vertex v , find all edges e such that v  X  e .
Q5. Get list of cells which are side-of a particular cell, e.g., for a given edge e , find all vertices v such that v  X  e .
Q6. Get the number of neighbors (adjacent) of a cell and iterating over them, e.g., for a given vertex v , find all its adjacent vertices.
ImG is a theoretical model to represent a broad class of meshes. Selecting the data structure for ImG is an imple-mentation detail. For instance, one option is to use graph databases. However, more efficient data structures can be used when the object class is known.

Graph databases model objects and the relationships be-tween objects. They represent data by nodes, links and properties. Nodes represent objects and links show the re-lationship between nodes. A typical graph data model con-tains two main components: 1) nodes with properties, and 2) named relationships with properties. Some graph models also contain hypergraph [2].

In this section, we show how topological mesh queries can be formulated as Neo4j graph database queries. Neo4j is an open source NOSQL graph database which is schema-less, supports ACID properties, and can do high performance graph operations [1]. Neo4j X  X  data model is property multi-graph , i.e., data is stored in nodes and links (both with pairs of key-values properties) of a pseudo-graph. Relationships are directed, but graph traversal can be done bidirectional at equal speed. Figure 3 depicts the graph data model which we uses to model mesh data.

Cypher is Neo4j X  X  query language. The user only needs to specify the starting point and the desired outcome us-ing graph pattern matching and Neo4j adapts the algorithm based on the user query. We refer the interested reader to Neo4j documentation for further details about Cypher [1]. Only some of the mesh queries can be expressed as single Neo4j query e.g., Q1 , Q2 ; Q4 can be expressed only when the length of maximal chain is known; Q3 needs a Java API and Q6 in its general form is cumbersome to write as graph query. We show Q6 in Cypher language.
 Q6. This query appears in many application domains. There are four variations of k -adjacent in a 3D cell-complex, e.g., vertex-to-vertex, edge-to-edge, etc. Depending on pa-rameter k , the queries have different length in MATCH clause. For instance, the query below extracts adjacent edges to edge  X  X  X  which share a common vertex: The pattern has two parts. The part a-[:INCIDENT]-&gt; v ex-tracts all the vertices of edge  X  X  X . The parts v &lt; -[:INCIDENT]-e finds all the edges which the vertices are side-of. The set  X  X  X  does not contain edge  X  X  X . Note that here we used directed relationships, because the direction matters.  X  X NCIDENT X  in the query is the type of the relationship between nodes of the graph.

In summary, we can write some of the topological queries as a single graph query, but not the others e.g., Q6 , Q3 , and switch operator. Depending on some input parameter (e.g., parameter k in Q6 and switch operator) several graph queries might be possible. Furthermore, graph databases do not support the constraints. Some of the constraints such as vertex (edge) ring cannot be written as a graph-only query and we need an API for each. Note that general graphs do n ot support geometric queries.
We conducted experiments to investigate alternatives for a mesh-enabled database. To this end, we execute four topological queries, namely, Q4 and Q6 , Euler formula , and graded constraint on Neo4j graph and PostgreSQL databases. Due to space constraint, we only report results for Q6 and graded constraint . Five synthetic datasets are used. In the current experiments, we used only synthetic datasets. We plan to use real datasets in the future, but our conjecture is that the application domains in real large mesh datasets tend to be locally regular, e.g., in terms of number of incidences. In contrast, using synthetic meshes allow us to control aspect such as size of incidence relationship.
The synthetic generator for Cartesian meshes defines a for each ( i, j ). Then, the results meshes are converted to ap-propriate format to be imported to Neo4j and PostgreSQL. Table 2 shows the number of cells and side-of relationships in each dataset.
 Table 2: Number of cells and side-of relationships in each dataset.

We do not define a new benchmark for unstructured meshes b ut rather the goal is to test performance of graph and rela-tional databases for supporting the meshes . Also, we report disk usage of the databases for dataset and compare sim-plicity of query writing.

The experiments were run on a system with four cores (2.4 GHz processor) with 8GB of RAM and Ubuntu 12.10 operating system. In each experiment, we run one query ten times over the five datasets. The response time is averaged over ten trials for each dataset.
 The relational schema in PostgreSQL contains two tables as follows: The incidence table contains V  X  E , E  X  F , and F  X  B relationships. PostgreSQL uses B-tree indexes on all the columns.

In the Neo4j schema, each node has two properties and there is one relationship type: INCIDENCE (see Section 8.1). Index on all properties are built.
 Figure 4: S ize of each dataset on Neo4j and PostgreSQL.
We can observe that the disk usage of Neo4j is bigger than PostgreSQL for all the datasets. On average it is 45% bigger than PostgreSQL. The reason is that, Neo4j uses key-value store for nodes X  properties: the name of attributes is repeated for all nodes which requires more disk space.
The first query is Q6 (see Section 8.2). The following listing presents the related SQL query for Q6 . The query contains a sub-query which join two instances of incidence with cell to find all edges which share one vertex with edge  X  X  X . Then, the outer query retrieves the names of those edges from the cell . The corresponding graph query is simpler and easier to understand.
 Figure 5 depicts response time of Q6 . PostgreSQL is almost seven times faster than Neo4j.
 Figure 5: P erformance of Q6 on Neo4j and PostgreSQL.
The second query is graded constraint. The SQL query for the constraint is as follows: Three instances of incidence are left joined to capture all paths from the root to vertices. Left join allows to cap-ture paths with length less than three, e.g., an isolated edge which is not connected to any faces and is directly linked to the root. The WHERE clause counts all rows which con-tains at least one NULL value, i.e., path with length less than three. and the Neo4J query is:
The graph query is much simpler than the SQL one: pat-tern [:INCIDENCE*1..2]-&gt; v captures all paths of length one or two between root cell and cell  X  X  X  X here  X  X  X  X s conditioned to be a vertex. Existence of such paths mean that the graph is not graded.
 Figure 6 illustrates response time of graded constraint. Neo4j outperforms PostgreSQL in checking graded constraint, i.e., it is almost eleven times faster. This query needs to check the length of all the paths from the root element (the mesh itself) to all vertices and make sure they are all of t he same length. This is where the true power of a graph database such as Neo4j resides, i.e., path-intensive queries. It must be noted that both systems have low variance for Figure 6: P erformance of graded constraint on Neo4j response time over 10 trials which suggests the experiments X  environment is stable. Overall, PostgreSQL has lower vari-ance in comparison to Neo4j.

From the experiments, we can conclude that both Neo4j and Postgre perform well on some mesh queries. Postgre performs better on local queries (e.g., Q6 ) and Neo4j per-forms better on global queries (e.g., graded constraint). Our original hypothesis was that PostgreSQL will perform poorly when self-joining the incidence table several times to do path-intensive operations, but with the current datasets only one experiment (i.e., graded constraint query) supports this. Real world mesh datasets are 3D or 4D which means three to four times self-joining of the incidence table. Join on such small incidence table is not costly for relational systems. A real performance experiment on the databases should investigate increasingly higher dimensional meshes, but we doubt the practical usefulness of such meshes.
In almost all the experiments, the graph queries are shorter, more intuitive, and readable (w.r.t. the semantics of the queries) than the SQL queries.
In this paper, we discussed the motivation behind the need for a specialized mesh database. We presented the ImG-Complex model for topological aspect of meshes. Sets of constraints were introduced which limits ImG to smaller object subclasses. We designed the algorithm for validating manifold property. We presented how ImG model can be implemented using Neo4j graph database. We discussed po-tentials and limitation of graph databases for implementing the ImG model. Our experiments show that in compari-son to PostgreSQL, Neo4j performs better on path-intensive queries.

In the future, we want to extend the ImG model to sup-port geometric embedding and data association, augment the model with indexing techniques (e.g., storing neighbors) to overcome performance issues and implement the model using an existing database. Additional experiments which use big mesh datasets and other topological mesh queries to define conditions on which graphs (relational model) per-forms better will be conducted. Furthermore, mesh libraries such as GrAL will be included in the the experiments. [1] http://neo4j.org. [2] R. Angles and C. Gutierrez. Survey of graph database [3] B. G. Baumgart. A polyhedron representation for [4] G. Berti. Generic software components for Scientific [5] E. Brisson. Representing geometric structures in d [6] S. Danilov et al. Modeling ocean circulation on [7] G. Heber and J. Gray. Supporting finite element [8] G. Heber and J. Gray. Supporting finite element [9] B. Howe. Gridfields: model-driven data transformation [10] B. Howe and D. Maier. Algebraic manipulation of [11] B. Levy and J.-L. Mallet. Cellular modelling in [12] P. Lienhardt. Topological models for boundary [13] D. W. Moore. Simplicial mesh generation with [14] R. Musick and T. Critchlow. Practical lessons in [15] OGC. Opengis simple features specification for sql. [16] C. C. Pain et al. Three-dimensional unstructured mesh [17] S. Papadomanolakis et al. Efficient query processing [18] C. Silva, Y. jen Chiang, W. Corr X ea, J. El-sana, and [19] G. M. Ziegler. Lectures on polytopes . Springer-Verlag,
