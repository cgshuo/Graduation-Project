 One of the contemporary demanding NLP tasks is information extraction, which is the procedure of extracting structured information such as entities, relations, and events from free text documents. As an information extraction sub-task, semantic relation extraction is the procedure of finding predefined semantic relations between textual entity mentions. For instance, assuming a semantic relation with type Physical and subtype Located between an entity of type Person and another entity of type Location , the sentence " Police arrested Mark at the airport last week. " conveys two mentions of this relation between "Mark" and "airport" and also between "police" and "airport" that can be shown in the following format. Relation extraction is a key step towards question answering systems by which vital structured data is acquired from underlying free text resources. Detection of protein interactions i n biomedical corpora (Li et al., 2008) is another valuable application of relation extraction. Relation extraction can be approached by a standard classification learning method. We particularly use SVM (Boser et al., 1992; Cortes and Vapnik, 1995) and kernel functions as our classification method. A kernel is a function that calculates the inner product of two transformed vectors of a high dimensional feature space using the original feature vectors as shown in eq. 1. Kernel functions can implicitly capture a large amount of features efficiently; thus, they have bee n widely used in various NLP tasks. Various types of features have been exploited so far for relation extraction. In (Bunescu and Mooney, 2005b) sequence of words features are utilized using a sub-sequence kernel. In (Bunescu and Mooney, 2005a) dependency graph features are exploited, and in (Zhang et al., 2006a) syntactic features are employed for relation extraction. Although in order to achieve the best performance, it is necessary to use a proper combination of thes e features (Zhou et al., 2005), in this paper, we wil l concentrate on how to better capture the syntactic features for relation extraction. In CD X 01 (Collins and Duffy, 2001) a convolution syntactic tree kernel is proposed that generally measures the syntactic similarity between parse trees. In this paper, a generalized version of CD X 01 convolution tree kernel is proposed by associating generic weights to the nodes and sub-trees of the parse tree. These weights can be used to incorporate domain knowledge into the kernel and make it more flexible and customizable. The generalized kernel can be conveniently used to generate a variety of syntactic sub-kernels (including the original CD X 01 kernel), by adopting appropriate weighting mechanisms. As a result, in this paper, novel syntactic sub-kernels are generated from the generalized kernel for the task of relation extraction. Evaluations demonstrate that these kernels outperform the original CD X 01 kernel in the extraction of ACE-2005 main relation types The remainder of this paper is structured as follows. In section 2, the most related works are briefly reviewed. In section 3, CD X 01 tree kernel i s described. The proposed generalized convolution tree kernel is explained in section 4 and its produced sub-kernels for relation extraction are illustrated in section 5. The experimental results are discussed in section 6. Our work is concluded in section 7 and some possible future works are presented in section 8. In (Collins and Duffy, 2001), a convolution parse tree kernel has been introduced. This kernel is generally designed to measure syntactic similarity between parse trees and is especially exploited for parsing English sentences in their paper. Since then, the kernel has been widely used in different applications such as semantic role labeling (Moschitti, 2006b) and relation extraction (Zhang et al. , 2006a; Zhang et al., 2006b; Zhou et al., 2007; Li et al. 2008) . For the first time, in (Zhang et al., 2006a), this convolution tree kernel was used for relation extraction. Since the whole syntactic parse tree of the sentence that holds the relation arguments contains a plenty of misleading features, several parse tree portions are studied to find the most feature-rich portion of the syntactic tree for relation extraction, and Path-Enclosed Tree (PT) is finally found to be the best performing tree portion. PT is a portion of parse tree that is enclosed by the shortest path between the two relation arguments. Moreover, this tree kernel is combined with an entity kernel to form a reportedly high quality composite kernel in (Zhang et al., 2006b). In (Collins and Duffy, 2001), a convolution tree kernel has been introduced that measures the syntactic similarity between parse trees. This kernel computes the inner products of the following feature vector. Each feature of this vector is the occurrence count of a sub-tree type in the parse tree decayed exponentially by the parameter  X  . Without this decaying mechanism used to retain the kernel values within a fairly small range, the value of th e kernel for identical trees becomes far higher than its value for different trees. Term i size is defined to be the number of rules or internal nodes of the i th sub-tree type. Samples of such sub-trees are shown in Fig. 1 for a simple parse tree. Since the number of sub-trees of a tree is exponential in its size (Collins and Duffy, 2001), direct inner product calculation is computationally infeasible. Consequently, Collins and Duffy (2001) proposed an ingenious kernel function that implicitly calculates the inner product in ) ( 2 1 N N O  X  time on the trees of size 1 N and 2 N . In order to describe the kernel, a feature vector over the syntactic parse tree is firstly defined in eq. (3), in which the i th feature equals the weighted sum of the number of instances of sub-tree type i th in the tree. Function ) ( n I returns 1 if the node n and 0 otherwise. As described in eq. (4), function tw(T) (which stands for "tree weight") assigns a weight to a tree T which is equal to the product of the weights of all its nodes. Since each node of the whole syntactic tree can either happen as an internal node or as an external node of a supposed sub-tree (presuming its existence in the sub-tree), two types of weights ar e respectively associated to each node by the functions ) ( n inw and ) ( n enw (which respectively stand for "internal node weight" and "external node weight"). For instance, in Fig. 1, the node with label PP is an external node for sub-trees (1) and (7) while it is an internal node of sub-trees (3) a nd (4). = As shown in eq. (5), A similar procedure to (Collins and Duffy, 2001) can be employed to develop a kernel function for the calculation of do t products on H(T) vectors. According to eq. (5) the calculation of the kernel finally leads to the sum of a ) , ( 2 1 n n C gc function over all tree node pairs of T and T 2 . Function ) , ( 2 1 n n C gc is the weighted sum of the common sub-trees rooted at 1 n and n 2 , and can be recursively computed in a similar way to function ) , ( follows. (1) if the production rules of nodes n 1 and n 2 (2) else if n 1 and n 2 are the same pre-terminals (the (3) else if both n 1 and n 2 have the same production In the first case, when the two nodes represent different production rules they can't accordingly have any sub-trees in common. In the second case, there is exactly one common sub-tree of size two. It should be noted that all the leaf nodes of the t ree (or words of the sentence) are considered identical in the calculation of the tree kernel. The value of the function in this case is the weight of this common sub-tree. In the third case, when the nodes generally represent the same production rules the weighted sum of the common sub-trees are calculated recursively. The equation holds because the existence of common sub-trees rooted at n 1 and n implies the existence of common sub-trees rooted at their corresponding children, which can be combined multiplicatively to form their parents' common sub-trees. Due to the equivalent procedure of kernel calculation, this generalized version of the tree kernel preserves the nice ) ( 2 1 N N O  X  time complexity property of the original kernel. It is worthy of note that in (Moschitti, 2006b) a sorting based method is proposed for the fast implementation of such tree kernels that reduces The generalized kernel can be converted to CD X 01 kernel by defining  X  = ) ( n inw and utilized to produce other useful sub-kernels. In this section, three sub-kernels of the generaliz ed convolution tree kernel will be proposed for relation extraction. Using the embedded weights of the generalized kernel, these sub-kernels differentiate among sub-trees based on their expected relevance to semantic relations. More specifically, the sub-trees are weighted according to how their nodes interact to the arguments of the relation. 5.1 Argument Ancestor Path Kernel (AAP) Definition of weighting functions is shown in eq. (6) and (7). Parameter 1 0  X  &lt;  X  is a decaying parameter similar to  X  . This weighting method is equivalent to applying CD X 01 tree kernel (by setting 2  X   X  = ) on a portion of the parse tree that exclusively includes the arguments ancestor nodes and their direct children. 5.2 Argument Ancestor Path Distance Kernel Definition of weighting functions is shown in eq. (8) and (9). Both functions have identical definitions for this kernel. Function AAPDist(n,arg) calculates the distance of the node n from the argument arg on the parse tree as illustrated by Fig. 2. MAX_DIST is used for normalization, and is the maximum of AAPDist(n,arg) in the whole tree. In this way, the closer a tree node is to one of the arguments ancestor path, the less it is decayed by this weighting method. 5.3 Threshold Sensitive Argument Ancestor This kernel is intuitively similar to the previous kernel but uses a rough threshold based decaying technique instead of a smooth one. The definition of weighting functions is shown in eq. (10) and (11). Both functions are again identical in this ca se. 6.1 Experiments Setting The proposed kernels are evaluated on ACE-2005 multilingual corpus (Walker et al., 2006). In order to avoid parsing problems, the more formal parts of the corpus in "news wire" and "broadcast news" sections are used for evaluation as in (Zhang et al ., 2006b). We have used LIBSVM (Chang and Lin 2001) java source for the SVM classification and Stanford NLP package 1 for tokenization, sentence segmentation and parsing. Following [Bunescu and Mooney, 2007], every pair of entities within a sentence is regarded as a negative relation instance unless it is annotated a s a positive relation in the corpus. The total number o f negative training instances, constructed in this way, is about 20 times more than the number of annotated positive instances. Thus, we also imposed the restriction of maximum argument distance of 10 words. This constraint eliminates half of the negative constructed instances while slightly decreases positive instances. Nevertheless , since the resulted training set is still unbalanced , we used LIBSVM weighting mechanism. Precisely, if there are P positive and N negative instances in the training set, a weight value of default weight value of 1 is used for negative ones . A binary SVM is trained for every relation type separately, and type compatible annotated and constructed relation instances are used to train it . For each relation type, only type compatible relation instances are exploited for training. For example to learn an ORG-AFF relation (which applies to (PER, ORG) or (ORG, ORG) argument types) it is meaningless to use a relation instance between two entities of type PERSON. Moreover, the total number of training instances used for training every relation type is restricted to 5000 instances to shorten the duration of the evaluation process. The reported results are achieved using a 5-fold cross validation method. The kernels AAP, AAPD and TSAAPD-0 (TSAAPD with threshold = 0) and TSAAPD-1 (TSAAPD with threshold = 1) are compared with CD X 01 convolution tree kernel. All the kernels except for AAP are computed on the PT portion described in section 2. AAP is computed over the MCT tree portion which is also proposed by (Zhang et al., 2006a) and is the sub-tree rooted at the first common ancestor of relation arguments. For the proposed kernels  X  is set to 0.44 which is tuned on a development set that contained 5000 instances of type PHYS. The  X  parameter of CD X 01 kernel is set to 0.4 according to (Zhang et al., 2006a). The C parameter of SVM classification is set to 2.4 for all the kernels after tuning it individually for each kernel on the mentioned development set. 6.2 Experiments Results The results of the experiments are shown in Table 1. The proposed kernels outperform the original CD X 01 kernel in four of the six relation types. The performance of TSAAPD-1 is especially remarkable because it is the best kernel in ORG-AFF and PER-SOC relations. It particularly performs very well in the extraction of PER-SOC relation with an F 1 -measure of 0.73. It should be noted that the general low performance of all the kernels on the GEN-AFF type is because of its extremely small number of annotated instances in the training set (40 in 5000). The AAPD kernel has the best performance with a remarkable improvement over the Collins kernel in GEN-AFF relation type. The results clearly demonstrate that the nodes closer to the ancestor path of relation arguments contain the most useful syntactic features for relation extraction In this paper, we proposed a generalized convolution tree kernel that can generate various syntactic sub-kernels including the CD X 01 kernel. The kernel is generalized by assigning weights to the sub-trees. The weight of a sub-tree is the product of the weights assigned to its nodes by two types of weighting functions. In this way, impacts of the tree nodes on the kernel value can be discriminated purposely based on the application. Context information can also be injected to the kernel via context sensitive weighting mechanisms. Using the generalized kernel, various sub-kernels can be produced by different definitions of the two weighting functions. We consequently used the generalized kernel for systematic generation of useful kernels in relation extraction . In these kernels, the closer a node is to the relat ion arguments ancestor paths, the less it is decayed by the weighting functions. Evaluation on the ACE-2005 main relation types demonstrates the effectiveness of the proposed kernels. They show remarkable performance improvement over CD X 01 kernel. Although the path-enclosed tree portion (PT) (Zhang et al., 2006a) seems to be an appropriate portion of the syntactic tree for relation extracti on, it only takes into account the syntactic informatio n between the relation arguments, and discards many useful features (before and after the arguments features). It seems that the generalized kernel can be used with larger tree portions that contain syntactic features before and after the arguments, because it can be more easily targeted to related features. Currently, the proposed weighting mechanisms are solely based on the location of the tree nodes in the parse tree; however other useful information such as labels of nodes can also be used in weighting. Another future work can be utilizing the generalized kernel for other applicable NLP tasks such as co-reference resolution. 
