 There is currently considerable interest in syntax-based models for statistical machine translation that are based on the extraction of a synchronous gram-mar from a corpus of word-aligned parallel texts; see for instance Chiang (2007) and the references therein. One practical problem with this approach, apart from the sheer number of the rules that result from the extraction procedure, is that the parsing complexity of all synchronous formalisms that we are aware of is exponential in the rank of a rule, defined as the number of nonterminals on the right-hand side. Therefore, it is important that the rules of the extracted grammar are transformed so as to minimise this quantity. Not only is this beneficial in terms of parsing complexity, but smaller rules can also improve a translation model X  X  ability to gener-alize to new data (Zhang et al., 2006).

Optimal algorithms exist for minimising the size of rules in a Synchronous Context-Free Gram-mar (SCFG) (Uno and Yagiura, 2000; Zhang et al., 2008). However, the SCFG formalism is limited to modelling word-to-word alignments in which a single continuous phrase in the source language is aligned with a single continuous phrase in the tar-get language; as defined below, this amounts to saying that SCFG have a fan-out of 2 . This re-striction appears to render SCFG empirically inad-equate. In particular, Wellington et al. (2006) find that the coverage of a translation model can increase dramatically when one allows a bilingual phrase to stretch out over three rather than two continuous substrings. This observation is in line with empir-ical studies in the context of dependency parsing, where the need for formalisms with higher fan-out has been observed even in standard, single language texts (Kuhlmann and Nivre, 2006).

In this paper, we present an algorithm that com-putes optimal decompositions of rules in the for-malism of Linear Context-Free Rewriting Systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS was originally introduced as a generalization of sev-eral so-called mildly context-sensitive grammar for-malisms. In the context of machine translation, LCFRS is an interesting generalization of SCFG be-cause it does not restrict the fan-out to 2 , allow-ing productions with arbitrary fan-out (and arbitrary rank). Given an LCFRS, our algorithm computes a strongly equivalent grammar with rank 2 and min-imal increase in fan-out. 1 In this context, strong equivalence means that the derivations of the orig-inal grammar can be reconstructed using some sim-ple homomorphism (c.f. Nijholt, 1980). Our contri-bution is significant because the existing algorithms for decomposing SCFG, based on Uno and Yagiura (2000), cannot be applied to LCFRS, as they rely on the crucial property that components of biphrases are strictly separated in the generated string: Given a pair of synchronized nonterminal symbols, the ma-terial derived from the source nonterminal must pre-cede the material derived from the target nontermi-nal, or vice versa. The problem that we solve has been previously addressed by Melamed et al. (2004), but in contrast to our result, their algorithm does not guarantee an optimal (minimal) increase in the fan-out of the resulting grammar. However, this is essen-tial for the practical applicability of the transformed grammar, as the parsing complexity of LCFRS is ex-ponential in both the rank and the fan-out.
 Structure of the paper The remainder of the pa-per is structured as follows. Section 2 introduces the terminology and notation that we use for LCFRS. In Section 3, we present the technical background of our algorithm; the algorithm itself is discussed in Section 4. Section 5 concludes the paper by dis-cussing related work and open problems.
 General notation The set of non-negative integers is denoted by N . For i,j  X  N , we write [ i,j ] to denote the interval { k  X  N | i  X  k  X  j } , and use [ i ] as a shorthand for [1 ,i ] . Given an alphabet V , we We briefly summarize the terminology and notation that we adopt for LCFRS; for detailed definitions, see Vijay-Shanker et al. (1987). 2.1 Linear, non-erasing functions Let V be an alphabet. For natural numbers r  X  0 and f,f 1 ,...,f r  X  1 , a function is called a linear, non-erasing function over V of type f 1  X  X  X  X  X  f r  X  f , if it can be defined by an equation of the form g (  X  x where  X  g =  X   X  g, 1 ,..., X  g,f  X  is an f -tuple of strings over the variables on the left-hand side of the equa-tion and symbols in V that contains exactly one oc-currence of each variable. We call the value r the rank of g , the value f its fan-out , and write  X  ( g ) and  X  ( g ) , respectively, to denote these quantities. Note that, if we assume the variables on the left-hand side of the defining equation of g to be named according to the specific schema given above, then g is uniquely determined by  X  g . 2.2 Linear context-free rewriting systems A linear context-free rewriting system (LCFRS) is a construct G = ( V N ,V T ,P,S ) , where: V N is an alphabet of nonterminal symbols in which each symbol A  X  V N is associated with a value  X  ( A ) , called its fan-out ; V T is an alphabet of terminal symbols; S  X  N is a distinguished start symbol with  X  (
S ) = 1 ; and P is a set of productions of the form where A,B 1 ,...,B r  X  V N , and g is a linear, non-erasing function over the terminal alphabet V T of type  X  ( B 1 )  X  X  X  X  X   X  ( B r )  X   X  ( A ) . In a deriva-tion of an LCFRS, the production p can be used to transform a sequence of r tuples of strings, gener-ated by the nonterminals B 1 ,...,B r , into a single  X  (
A ) -tuple of strings, associated with the nonter-minal A . The values  X  ( g ) and  X  ( g ) are called the rank and fan-out of p , respectively, and we write  X  ( p ) and  X  ( p ) , respectively, to denote these quan-tities. The rank and fan-out of G , written  X  ( G and  X  ( G ) , respectively, are the maximum rank and fan-out among all of its productions. Given that  X  (
S ) = 1 , a derivation will associate S with a set of one-component tuples of strings over V T ; this forms the string language generated by G .
 Example 1 The following LCFRS generates the string language { a n b n c n d n | n  X  N } . We only specify the set of productions; the remaining com-ponents of the grammar are obvious from that. R  X  g 3 g 3 =  X   X , X   X  The functions g 1 and g 2 have rank 1 ; the function g 3 has rank 0 . The functions g 2 and g 3 have fan-out 2 ; the function g 1 has fan-out 1 . The general idea behind our algorithm is to replace each production of an LCFRS with a set of  X  X horter X  productions that jointly are equivalent to the original production. Before formalizing this idea, we first in-troduce a specialized representation for the produc-tions of an LCFRS.

We distinguish between occurrences of symbols within a string by exploiting two different notations. Let  X  = a 1 a 2  X  X  X  a n be a string. The occurrence a i in  X  can be denoted by means of its position index i  X  [ n ] , or else by means of its two (left and right) endpoints , i  X  1 and i ; here, the left (right) endpoint denotes a boundary between occurrence a i and the previous (subsequent) occurrence, or the beginning (end) of the string  X  . Similarly, a substring a i  X  X  X  a j of  X  with i  X  j can be denoted by the positions i,i + 1 ,...,j of its occurrences, or else by means of its left and right endpoints, i  X  1 and j . 3.1 Production representation For the remainder of this section, let us fix an LCFRS G = ( V N ,V T ,P,S ) and a production p : A  X  g ( B in Section 2.1. We define Let $ be a fresh symbol that does not occur in G . We define the characteristic string of the production p as and the variable string of p as the string  X  N ( p ) ob-tained from  X  ( p ) by removing all the occurrences of symbols in V T .
 Example 2 We will illustrate the concepts intro-duced in this section using the concrete production p In this case, we have Let I be an index set, I  X  [ r ] . Consider the set B of occurrences B i in the right-hand side of p such that i  X  I . 2 We define the position set of B , denoted by  X  B , as the set of all positions 1  X  j  X  |  X  N ( p ) | such that the j th symbol in  X  N ( p ) is a variable of the form x i,h , for i  X  I and some h  X  1 .
 Example 3 Some position sets of p
 X  A position set  X  B can be uniquely expressed as the union of f  X  1 intervals [ l 1 + 1 ,r 1 ] ,..., [ l f + 1 such that r i  X  1 &lt; l i for every 1 &lt; i  X  f . Thus we define the set of endpoints of  X  B as The quantity f is called the fan-out of  X  B , writ-ten  X  (  X  B ) . Notice that the fan-out of a position set  X  of the non-terminal B in the underlying LCFRS. A set with 2 f endpoints always corresponds to a posi-tion set of fan-out f .
 Example 4 For our running example, we have  X  { 4 , 6 } . Consequently, the fan-out of  X  { B the fan-out of  X  fan-out of the non-terminal B 3 is 2 . We drop B from  X  B and  X  B whenever this set is understood from the context or it is not relevant. Given a set of endpoints  X  = { i 1 ,...,i 2 f } with i &lt;  X  X  X  &lt; i 2 f , we obtain its corresponding position set by calculating the closure of  X  , defined as 3.2 Reductions Assume that r &gt; 2 . The reduction of p by the non-terminal occurrences B r  X  1 ,B r is the ordered pair of productions ( p 1 ,p 2 ) that is defined as follows. Let  X  ,..., X  n be the maximal substrings of  X  ( p ) that contain only variables x i,j with r  X  1  X  i  X  r and terminal symbols, and at least one variable. Then where X is a fresh nonterminal symbol, the char-acteristic string  X  ( p 1 ) is the string obtained from  X  ( p ) by replacing each substring  X  i by the vari-string  X  1 $  X  X  X  $  X  n .

Note that the defining equations of neither g 1 nor g 2 are in the specific form discussed in Sec-tion 2.1; however, they can be brought into this form by a consistent renaming of the variables. We will silently assume this renaming to take place.
 Example 5 The reduction of p occurrences B 2 and B 3 has p 1 : A  X  g 1 ( B 1 ,X ) and p 2 : X  X  g 2 ( B 2 ,B 3 ) with or, after renaming and in standard notation, g It is easy to check that a reduction provides us with a pair of productions that are equivalent to the original production p , in terms of generative capacity, since g for all tuples of strings generated from the nontermi-nals B 1 ,...,B r , respectively. Note also that the fan-out of production p 1 equals the fan-out of p . How-ever, the fan-out of p 2 (the value n ) may be greater than the fan-out of p , depending on the way vari-ables are arranged in  X  ( p ) . Thus, a reduction does not necessarily preserve the fan-out of the original production. In the worst case, the fan-out of p 2 can be as large as  X  ( B r  X  1 ) +  X  ( B r ) . 2: result  X  X  X  ; 3: currentProd  X  p ; 4: while  X  ( currentProd ) &gt; 2 do 5: ( p 1 ,p 2 )  X  any reduction of currentProd; 6: result  X  result  X  p 2 ; 7: currentProd  X  p 1 ; 8: return result  X  currentProd;
We have defined reductions only for the last two occurrences of nonterminals in the right-hand side of a production p . However, it is easy to see that we can also define the concept for two arbitrary (not neces-sarily adjacent) occurrences of nonterminals, at the cost of making the notation more complicated. Let G be an LCFRS with  X  ( G ) = f and  X  ( G ) = r , and let f 0  X  f be a target fan-out. We will now present an algorithm that computes an equivalent most 2 , if such an LCFRS exists in the first place. The algorithm works by exhaustively reducing all productions in G . 4.1 Naive algorithm Given an LCFRS production p , a naive algorithm to compute an equivalent set of productions whose rank is at most 2 is given in Figure 1. By ap-plying this algorithm to all the productions in the LCFRS G , we can obtain an equivalent LCFRS with rank 2 . We will call such an LCFRS a binarization of G .

The fan-out of the obtained LCFRS will depend on the nonterminals that we choose for the reduc-tions in line 5. It is not difficult to see that, in the worst case, the resulting fan-out can be as high as d e X  f . This occurs when we choose d r minals with fan-out f that have associated variables in the string  X  N ( p ) that do not occur at consecutive positions.

The algorithm that we develop in Section 4.3 im-proves on the naive algorithm in that it can be ex-ploited to find a sequence of reductions that results in a binarization of G that is optimal, i.e., leads to an LCFRS with minimal fan-out. The algorithm is based on a technical concept called adjacency . 4.2 Adjacency Let p be some production in the LCFRS G , and let  X  sets of nonterminal occurrences in p . We say that  X  1 and  X  2 overlap if the intersection of their closures holds if and only if the associated sets of nontermi-nal occurrences are not disjoint. If  X  1 and  X  2 do not overlap, we define their merge as It is easy to see that [  X  (  X  1 ,  X  2 )] = [  X  1 ]  X  [  X  We say that  X  1 and  X  2 are adjacent for a given fan-out f , written  X  1  X  f  X  2 , if  X  1 and  X  2 do not overlap, and  X  ([  X  (  X  1 ,  X  2 )])  X  f .
 Example 6 For the production p we have  X  (  X   X  showing that  X   X  4.3 Bounded binarization algorithm The adjacency-based binarization algorithm is given in Figure 2. It starts with a working set contain-ing the endpoint sets corresponding to each non-terminal occurrence in the input production p . Re-ductions of p are only explored for nonterminal oc-currences whose endpoint sets are adjacent for the constraint would produce productions with fan-out gorithm produces a new endpoint set, associated to the fresh nonterminal that it introduces, and this new endpoint set is added to the working set and poten-tially used in further reductions.

From the definition of the adjacency relation  X  f , it follows that at lines 9 and 10 of B OUNDED -B
INARIZATION we only pick up reductions for p that do not exceed the fan-out bound of f 0 . This implies soundness for our algorithm. Completeness means that the algorithm fails only if there exists no binarization for p of fan-out not greater than f 0 . This 2: workingSet  X  X  X  ; 3: agenda  X  X  X  ; 4: for all i from 1 to  X  ( p ) do 5: workingSet  X  workingSet  X  X   X  { B 6: agenda  X  agenda  X  X   X  { B 7: while agenda 6 =  X  do 8:  X   X  pop some endpoint set from agenda; 9: for all  X  1  X  workingSet with  X  1  X  f 0  X  do 11: if  X  2 /  X  workingSet then 12: workingSet  X  workingSet  X  X   X  2 } ; 13: agenda  X  agenda  X  X   X  2 } ; 15: return true ; 16: else 17: return false ; property is intuitive if one observes that our algo-rithm is a specialization of standard algorithms for the computation of the closure of binary relations. A formal proof of this fact is rather long and te-dious, and will not be reported here. We notice that there is a very close similarity between algorithm B cedure proposed by Shieber et al. (1995) for parsing. We discuss this more at length in Section 5.

Note that we have expressed the algorithm as a decision function that will return true if there exists a binarization of p with fan-out not greater than f 0 , and false otherwise. However, the algorithm can easily be modified to return a reduction producing such a binarization, by adding to each endpoint set  X   X  workingSet two pointers to the adjacent end-point sets that were used to obtain it. If the algorithm is successful, the tree obtained by following these pointers from the final endpoint set  X  workingSet gives us a tree of reductions that will produce a binarization of p with fan-out not greater than f 0 , where each node labeled with the set  X  corresponds to the nonterminal B i , and nodes la-beled with other endpoint sets correspond to the fresh nonterminals created by the reductions. 4.4 Implementation In order to implement B OUNDED -B INARIZATION , we can represent endpoint sets in a canonical way and with some special null value used to fill posi-tions for endpoint sets with fan-out strictly smaller is larger than any other integer.

We also need to provide some appropriate repre-sentation for the set workingSet, in order to guar-antee efficient performance for the membership test and the insertion operation. Both operations can be implemented in constant time if we represent work-ingSet as an (2  X  f 0 ) -dimensional table with Boolean entries. Each dimension is indexed by values in [0 ,n ] plus our special null value; here n is the length this has the disadvantage of using space  X ( n 2 f 0 ) even in case workingSet is sparse, and is affordable only for quite small values of f 0 . Alternatively, we can more compactly represent workingSet as a trie data structure. This representation has size certainly smaller than 2 f 0  X  q , where q is the size of the set workingSet. However, both membership and inser-tion operations take now an amount of time O (2 f 0 ) . We now analyse the time complexity of algorithm B already observed, the number of possible endpoint sets is bounded by O ( n 2 f 0 ) . Furthermore, because of the test at line 11, no endpoint set is ever inserted into the agenda variable more than once in a sin-gle run of the algorithm. We then conclude that our while-loop cycles a number of times O ( n 2 f 0 ) .
We now focus on the choice of the endpoint set  X  1 in the inner for-loop at lines 9 to 13. Let us fix  X  as in line 8. It is not difficult to see that any  X  1 with  X  Let I  X   X  , and consider all endpoint sets  X  1 with  X   X   X  1 = I . Given (1), we also have This means that, for each  X  coming out of the agenda, at line 9 we can choose all endpoint sets  X  1 such that  X  1  X  f 0  X  by performing the following steps:  X  arbitrarily choose a set I  X   X  ;  X  choose endpoints in set  X  1 \ I subject to (2);  X  test whether  X  1 belongs to workingSet and
We claim that, in the above steps, the number of involved endpoints does not exceed 3 f 0 . To see this, we observe that from (2) we can derive | I |  X   X  (  X  ) +  X  (  X  1 )  X  f 0 . The total number e = 2  X  (  X  ) + 2  X  (  X  above inequality we have e  X  2  X  (  X  ) + 2  X  (  X  1 )  X   X  (  X  )  X   X  (  X  1 ) + f 0 as claimed. Since each endpoint takes values in choices. For each such choice, we need to clas-sify an endpoint as belonging to either  X  \ I ,  X  1 \ I , or I . This amounts to an additional O (3 3 f 0 ) dif-ferent choices. Overall, we have a total number of O the test for membership in workingSet for  X  1 takes constant time in case we use a multi-dimensional ta-ble, or else O ( | p | ) in case we use a trie. The ad-jacency test and the merge operations can easily be carried out in time O ( | p | ) .

Putting all of the above observations together, and using the already observed fact that n = O ( | p | ) , we can conclude that the total amount of time re-quired by the while-loop at lines 7 to 13 is bounded workingSet is represented as a multi-dimensional ta-ble or as a trie. This is also a bound on the running time of the whole algorithm. 4.5 Minimal binarization of a complete LCFRS The algorithm defined in Section 4.3 can be used to binarize an LCFRS in such a way that each rule in the resulting binarization has the minimum pos-sible fan-out. This can be done by applying the B
OUNDED -B INARIZATION algorithm to each pro-duction p , until we find the minimum value for the 2: p b =  X  X  Set of binarized productions } 3: for all production p of G do 4: f 0 = fan-out ( p ) ; 8: return p b ; tion. For a production with rank r and fan-out f , we know that this optimal value of f 0 must be in the interval [ f, d r duction cannot reduce its fan-out, and the N AIVE -B
INARIZATION algorithm seen in Section 4.1 can binarize any production by increasing fan-out to d e X  f in the worst case.

The simplest way of finding out the optimal value starting with  X  ( p ) and going upwards, as in the algo-rithm in Figure 3. Note that the upper bound d r that we have given for f 0 guarantees that the while-loop in this algorithm always terminates.

In the worst case, we may need f  X  ( d r executions of the B OUNDED -B INARIZATION algo-rithm to find the optimal binarization of a production in
G . This complexity can be reduced by changing the strategy to search for the optimal f 0 : for exam-ple, we can perform a binary search within the inter-val [ f, d r rization in b log( f  X  ( d r B
OUNDED -B INARIZATION . However, this will not result in a practical improvement, since B OUNDED -B
INARIZATION is exponential in the value of f 0 and intermediate strategy between the two is to apply exponential backoff to try the sequence of values f  X  1 + 2 i (for i = 0 , 1 , 2 ... ). When we find the first i such that B OUNDED -B INARIZATION does not fail, if i &gt; 0 , we apply the same strategy to the interval [ shrink the interval until B OUNDED -B INARIZATION does not fail for i = 0 , giving us our optimal f 0 . With this strategy, the amount of executions of the algorithm that we need in the worst case is where  X  = f  X  ( d r unnecessarily large values of f 0 . To conclude this paper, we now discuss a number of aspects of the results that we have presented, includ-ing various other pieces of research that are particu-larly relevant to this paper. 5.1 The tradeoff between rank and fan-out The algorithm introduced in this paper can be used to transform an LCFRS into an equivalent form with rank 2 . This will result into a more effi-ciently parsable LCFRS, since rank exponentially affects parsing complexity. However, we must take into account that parsing complexity is also influ-enced by fan-out. Our algorithm guarantees a min-imal increase in fan-out. In practical cases it seems such an increase is quite small. For example, in the context of dependency parsing, both G  X  omez-Rodr  X   X guez et al. (2009) and Kuhlmann and Satta (2009) show that all the structures in several well-known non-projective dependency treebanks are bi-narizable without any increase in their fan-out.
More in general, it has been shown by Seki et al. (1991) that parsing of LCFRS can be carried out in string and p M is the production in the grammar with largest size. 3 Thus, there may be cases in which one has to find an optimal tradeoff between rank and fan-out, in order to minimize the size of p M . This re-quires some kind of Viterbi search over the space of all possible binarizations, constructed as described at the end of Subsection 4.3, for some appropriate value of the fan-out f 0 . 5.2 Extension to general LCFRS This paper has focussed on string-based LCFRS. As discussed in Vijay-Shanker et al. (1987), LCFRS provide a more general framework where the pro-ductions are viewed as generating a set of abstract derivation trees. These trees can be used to specify how structures other than tuples of strings are com-posed. For example, LCFRS derivation trees can be used to specify how the elementary trees of a Tree Adjoining Grammar can be composed to produced derived tree. However, the results in this paper also apply to non-string-based LCFRS, since by limit-ing attention to the terminal string yield of whatever structures are under consideration, the composition operations can be defined using the string-based ver-sion of LCFRS that is discussed here. 5.3 Similar algorithmic techniques The N AIVE -B INARIZATION algorithm given in Fig-an algorithm developed in Melamed et al. (2004) for generalized multitext grammars, a formalism weakly equivalent to LCFRS that has been intro-duced for syntax-based machine translation. How-ever, the grammar produced by our algorithm has optimal (minimal) fan-out. This is an important im-provement over the result in (Melamed et al., 2004), as this quantity enters into the parsing complexity of both multitext grammars and LCFRS as an expo-nential factor, and therefore must be kept as low as possible to ensure practically viable parsing.
Rank reduction is also investigated in Nesson et al. (2008) for synchronous tree-adjoining gram-mars, a synchronous rewriting formalism based on tree-adjoining grammars Joshi and Schabes (1992). In this case the search space of possible reductions is strongly restricted by the tree structures specified by the formalism, resulting in simplified computa-tion for the reduction algorithms. This feature is not present in the case of LCFRS.

There is a close parallel between the technique used in the M INIMAL -B INARIZATION algorithm and deductive parsing techniques as proposed by Shieber et al. (1995), that are usually implemented by means of tabular methods. The idea of exploit-ing tabular parsing in production factorization was first expressed in Zhang et al. (2006). In fact, the particular approach presented here has been used to improve efficiency of parsing algorithms that use discontinuous syntactic models, in particular, non-projective dependency grammars, as discussed in G  X  omez-Rodr  X   X guez et al. (2009). 5.4 Open problems The bounded binarization algorithm that we have presented has exponential run-time in the value of the input fan-out bound f 0 . It remains an open ques-tion whether the bounded binarization problem for LCFRS can be solved in deterministic polynomial time. Even in the restricted case of f 0 =  X  ( p ) , that is, when no increase in the fan-out of the input pro-duction is allowed, we do not know whether p can be binarized using only deterministic polynomial time in the value of p  X  X  fan-out. However, our bounded binarization algorithm shows that the latter problem can be solved in polynomial time when the fan-out of the input LCFRS is bounded by some constant.
Whether the bounded binarization problem can be solved in polynomial time in the value of the stricted case of synchronous context-free grammars, a special case of an LCFRS of fan-out two with a strict separation between the two components of each nonterminal in the right-hand side of a produc-tion, as discussed in the introduction. An interesting analysis of this restricted problem can be found in Gildea and Stefankovic (2007).
 Acknowledgements The work of Carlos G  X  omez-Rodr  X   X guez was funded by Ministerio de Educaci  X  on y Ciencia and FEDER (HUM2007-66607-C04) and Xunta de Galicia (PGIDIT07SIN005206PR, IN-CITE08E1R104022ES, INCITE08ENA305025ES, INCITE08PXIB302179PR and Rede Galega de Procesamento da Linguaxe e Recuperaci  X  on de Infor-maci  X  on). The work of Marco Kuhlmann was funded by the Swedish Research Council. The work of Giorgio Satta was supported by MIUR under project PRIN No. 2007TJNZRE 002. We are grateful to an anonymous reviewer for a very detailed review with a number of particularly useful suggestions. David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics , 33(2):201 X 228.
 Daniel Gildea and Daniel Stefankovic. 2007. Worst-case synchronous grammar rules. In Human Lan-guage Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics; Proceedings of the
Main Conference , pages 147 X 154. Association for Computational Linguistics, Rochester, New York.
 Carlos G  X  omez-Rodr  X   X guez, David J. Weir, and John
Carroll. 2009. Parsing mildly non-projective de-pendency structures. In Twelfth Conference of the
European Chapter of the Association for Compu-tational Linguistics (EACL) . To appear.
 A. K. Joshi and Y. Schabes. 1992. Tree adjoining grammars and lexicalized grammars. In M. Nivat and A. Podelsky, editors, Tree Automata and Lan-guages . Elsevier, Amsterdam, The Netherlands. Marco Kuhlmann and Joakim Nivre. 2006. Mildly non-projective dependency structures. In 21st
International Conference on Computational Lin-guistics and 44th Annual Meeting of the Asso-ciation for Computational Linguistics (COLING-
ACL), Main Conference Poster Sessions , pages 507 X 514. Sydney, Australia.
 Marco Kuhlmann and Giorgio Satta. 2009. Tree-bank grammar techniques for non-projective de-pendency parsing. In Twelfth Conference of the
European Chapter of the Association for Compu-tational Linguistics (EACL) . To appear.
 I. Dan Melamed, Benjamin Wellington, and Gior-gio Satta. 2004. Generalized multitext gram-mars. In 42nd Annual Meeting of the Association for Computational Linguistics (ACL) , pages 661 X  668. Barcelona, Spain.
 Rebecca Nesson, Giorgio Satta, and Stuart M.
Shieber. 2008. Optimal k -arization of syn-chronous tree-adjoining grammar. In Proceedings of ACL-08: HLT , pages 604 X 612. Association for Computational Linguistics, Columbus, Ohio.
 A. Nijholt. 1980. Context-Free Grammars: Cov-ers, Normal Forms, and Parsing , volume 93. Springer-Verlag, Berlin, Germany.
 Owen Rambow and Giorgio Satta. 1999. Indepen-dent parallelism in finite copying parallel rewrit-ing systems. Theoretical Computer Science , 223(1 X 2):87 X 120.
 Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii, and Tadao Kasami. 1991. On Multiple Context-
Free Grammars. Theoretical Computer Science , 88(2):191 X 229.
 Stuart M. Shieber, Yves Schabes, and Fernando
Pereira. 1995. Principles and implementation of deductive parsing. Journal of Logic Program-ming , 24(1 X 2):3 X 36.
 Takeaki Uno and Mutsunori Yagiura. 2000. Fast al-gorithms to enumerate all common intervals of two permutations. Algorithmica , 26(2):290 X 309. K. Vijay-Shanker, David J. Weir, and Aravind K.
Joshi. 1987. Characterizing structural descrip-tions produced by various grammatical for-malisms. In 25th Annual Meeting of the Associ-ation for Computational Linguistics (ACL) , pages 104 X 111. Stanford, CA, USA.
 Benjamin Wellington, Sonjia Waxmonsky, and
I. Dan Melamed. 2006. Empirical lower bounds on the complexity of translational equivalence. In 21st International Conference on Computational
Linguistics and 44th Annual Meeting of the Asso-ciation for Computational Linguistics (COLING-ACL) , pages 977 X 984. Sydney, Australia.
 Hao Zhang, Daniel Gildea, and David Chiang. 2008. Extracting synchronous grammar rules from word-level alignments in linear time. In 22nd International Conference on Computational
Linguistics (Coling) , pages 1081 X 1088. Manch-ester, England, UK.
 Hao Zhang, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for ma-chine translation. In Human Language Technol-ogy Conference of the North American Chapter of the Association for Computational Linguistics , pages 256 X 263. New York, USA.
