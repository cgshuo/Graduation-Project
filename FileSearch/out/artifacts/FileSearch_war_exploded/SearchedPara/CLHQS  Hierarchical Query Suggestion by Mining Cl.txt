
Depin Chen 1,* , Ning Liu 2 , Zhijun Yin 3 , Yang Tong 2 , Jun Yan 2 , and Zheng Chen 2 query, the search engine returns the search results, together with a small number (up usually laid at the top or bottom of the result page. 
Query suggestion has been studied intensively in research community. Traditional candidate query. These methods are limited in computational cost and also do not take user feedback information into account. Many following works [4, 5, 7, 9, 11] make use of the clickthrough logs. Some of them [4, 5, 7] are based on query-url graph or based method. What is common in these methods is that they all adopt a ranked query list as output and try to put the most appealing ones on top. We argue that a single list queries (generalization, extension and specialization) are needed. 
In this paper, we propose a novel method CLHQS, aiming to facilitate the usage of query suggestion and improve user experience. The rest of our paper is organized as follows. In Section 2, we describe the query suggestion problem. Section 3 introduces our method for query suggestion in detail. Then in Section 4, we report our experimental results, followed by Section 5 which concludes this paper. user intentions. information about a general related concept. For example, a user would like to search information about the manufacturer of the software suite  X  X ffice X  . Since the user does  X  X ffice X  , it would accelerate the search process and improve user experience. searches  X  X oogle X  to find out the services provided by Google [1]. If the search engine concepts of  X  X oogle X  , the user can easily find the most interesting service to him. (3) Extension. Besides the two scenarios above, users may also be interested in some example, users searching  X  X box X  may be also interested in information about  X  X s3 X  , since both of them are within the concept of  X  X ame player X  . 
Observing this, we propose to present the suggested queries in a hierarchy structure specialized ones. Users can explore the hier archy and locate the ideal query at ease. 3.1 Candidate Set Generation To generate the candidate set, we adopt the assumption that related queries are likely flow chart of candidate set generation for a specific query q . mostly clicked urls 
Second, for each of the k frequent urls u frequently and add them into the candidate set. Here, times set of query  X  X icrosoft X  . 
Third, we find the related queries recursively with the candidate set getting larger queries in the candidate set. For instance, the candidate set of query  X  X icrosoft X  may  X  X ircosoft X  is a misspelled version of  X  X icrosoft X  . These queries mean exactly the same with  X  X icrosoft X  and should be merged. We use the Levenshtein distance [6] to automatically detect queries which should be merged. Levenshtein distance is used to compute the similarity between two strings in information theory. It is defined as the minimum number of operations needed to transform one string into the other, where Levenshtein distance, them. 3.2 Pair-Wise Relationship Building After getting the candidate set, we examine the pair-wise relationships between each two queries. The parent is a general concept of the child. 
Intuitively, the frequent urls of a parent query should subsume the ones of a child frequent urls, 
First, we normalize  X 
Then, we compute the () b a P | and () a b P | , which represent how probable query a subsumes query b and query b subsumes query a , respectively. relationship. 3.3 Query Hierarchy Construction Then, we trim and merge redundant edges conforming to the following two rules. a the edge between a and c and remove query c . 
Fig. 3 and 4 give examples of the two rules. In Fig. 3(a), the edge between  X  X box X  edge between  X  X box X  and  X  X box games X  should not be trimmed, since  X  X box 360 X  is  X  X arvard X  and query  X  X arvard university X  , and  X  X arvard X  and  X  X arvard university X  have the same meaning. Hence we merge them into  X  X arvard X  according to Rule 2. We design a series of experiments to demonstrate the effectiveness and efficiency of our method. The dataset used in our experiments is randomly sampled by 5% from a commercial search engine. 4.1 Candidate Set Evaluation 10% queries with highest click frequency. We generate 20 candidate queries for each of them using our method. The volunteers are asked to label each candidate query as query with no concept overlap, containing redundant information or misspelling terms will be labeled as  X  X ot relevant X . The final label for each candidate query is decided by majority voting among the five volunteers. 
Finally, we calculate the precision, recall,  X  In the following, we set  X  to be 0.1 to get optimal performance. 4.2 Pair-Wise Relationship Evaluation CLHQS with the ones generated by the Substring method. The assumption of the b for the reason that there is more constraint on b than on a.

In our method CLHQS, we set the parameters as 1 . 0 =  X  , 8 . 0 = = them. To evaluate the performance of CLHQS, we calculate the precision, recall and calculated as follows. C is the correct pairs generated by CLHQS. 
Table 1 summarizes the evaluation result. Although the Substring method reaches higher precision, it can only find the straightforward subsumption relationships when omitting lots of meaningful ones. Our method CLHQS outperforms the Substring method in recall and relationships found by our method CLHQS are not the substring cases. 3 Hierarchy vs. Ranked List There are two main kinds of user behavior when served by query suggestion. User behavior 1. The user would like to read through the queries first and then make and then choose the favorite. For the hierarch y, users read all the queries in the peer level and then decide which query to continue their exploration (drill down, level up or stop). User behavior 2. The user would like to stop once an interesting query is located. For hierarchy, the user reads the queries in the same level one by one and stops whenever encountering the interesting query. Then the user drills down/level up from this query, or stops the exploration. 
In the candidate set, we build the hierarchy structure with n queries {} start query to destination queries. in Table 2. We find that, for most queries, users need fewer steps in the hierarchy than (p-value &lt; 0.05). Taking the 100 queries as a whole, we also calculate the following values. 
For user behavior 1, % 60 . 79 = behavior 2, % 47 . 67 = to find interesting queries is reduced signif icantly with the suggested query hierarchy. 4.4 Case Study In order to show the practical use of our method, we take query  X  X icrosoft X  as case hierarchy based on them. Here, we choose 8 . 0 = = restriction, we only demonstrate the main part of the hierarchy in Fig. 6. In this paper, we propose a novel method CLHQS, to generate the hierarchy structure which is more reasonable than the queries suggested based on term match. 
