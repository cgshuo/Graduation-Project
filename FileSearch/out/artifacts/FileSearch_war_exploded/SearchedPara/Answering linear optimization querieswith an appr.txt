 Gang Luo  X  Kun-Lung Wu  X  Philip S. Yu Abstract We propose a SAO index to approximately answer arbitrary linear optimization queries in a sliding window of a data stream. It uses limited memory to maintain the most  X  X mportant X  tuples. At any time, for any linear optimization query, we can retrieve the approx-imate top-K tuples in the sliding window almost instantly. The larger the amount of available memory, the better the quality of the answers is. More importantly, for a given amount of memory, the quality of the answers can be further improved by dynamically allocating a larger portion of the memory to the outer layers of the SAO index.
 Keywords Indexing method  X  Query processing  X  Relational database  X  Stream processing  X  Linear optimization query 1 Introduction Data stream applications are becoming popular [ 1 , 3 , 9 , 35  X  37 ]. Many of such applications that maximize or minimize the linearly weighted sums of certain attribute values. For exam-ple, in environmental epidemiological applications, various linear models that incorporate remotely sensed images, weather information, and demographic information are used to pre-dict the outbreak of certain environmental epidemic diseases, like Hantavirus Pulmonary Syndrome [ 24 ]. In oil/gas exploration applications, linear models that incorporate drill sen-sor measurements and seismic information are used to guide the drilling direction [ 25 ]. In financial applications, linear models that incorporate personal credit history, income level, and employment history are used to evaluate credit risks for loan approvals [ 24 ].
In all the above applications, data continuously stream in (say, from satellites and sensors) at a rapid rate. Users frequently pose linear optimization queries and want answers back as soon as possible. Moreover, different individuals may pose queries that have divergent weights and K  X  X . This is because the  X  X ptimal X  weights may vary from one location to another (in oil/gas exploration), the weights may be adjusted as the model is continually trained with historical data collected more recently (in environmental epidemiology and finance), and different users may have differing preferences.

In a read-mostly environment, Chang et al. [ 8 ] first proposed an onion index to speed up the evaluation of linear optimization queries against a large database relation. An onion index organizes all the tuples in the database relation into one or more convex layers, where each convex layer is a convex hull. For each i  X  1, the ( i + 1 ) th convex layer is contained within the i th convex layer. For any linear optimization query, to find the top-K tuples, we need to search no more than all the vertices of the first K outer convex layers in the onion index.
However, due to the extremely high cost of computing precise convex hulls [ 28 , 29 ], both onion index requires lots of storage because it keeps track of all the tuples in a relation. In a streaming environment, tuples keep arriving rapidly while available memory is limited. Hence, it is impossible to maintain a precise onion index for a data stream, let alone using it to provide exact answers to linear optimization queries.

To address these problems, we propose a SAO (Stream Approximate Onion-like structure) index for a data stream. The index provides high-quality, approximate answers to arbitrary linear optimization queries almost instantly. Our key observation is that the precise onion index typically contains a large number of convex layers, but most inner layers are not needed for answering linear optimization queries. Hence, the SAO index maintains only the first few outer convex layers. Moreover, each layer in the SAO index only keeps some of the most  X  X mportant X  vertices rather than all the vertices. As a result, the amortized maintenance cost of a SAO index is rather small because the great majority of the incoming tuples, more than 95% in most cases, do not cause any changes to the index and are quickly discarded, even though individual inserts or deletes might have non-trivial costs.

A key challenge in designing a SAO index is: for a given amount of memory, how do we properly allocate it among the layers so that the quality of the answers can be maximized? To do that, a dynamic, error-minimizing storage allocation strategy is used so that a larger portion of the available memory tends to be allocated to the outer layers than to the inner layers. In this way, both storage and maintenance overheads of the SAO index are greatly reduced. More importantly, the errors introduced into the approximate answers are also minimized.
With limited memory and continually arriving tuples, there are intrinsic errors in any stream application. It is difficult to provide an upper bound on these errors for linear opti-mization queries because the amount of inaccuracies depends on the specific sequence of tuples in a stream. Similar to what was shown in Yi et al. [ 33 ], such errors can be substantial in a pathological case where the available memory is not sufficient to hold all the tuples within a sliding window of a stream and the sequence of arriving tuples happens to maximize the errors. However, in practice, the exact errors can be measured based on stream traces. As shown in the experiments conducted in this paper, the actual errors are relatively minor (often less than 1%) even if the SAO index holds only a tiny fraction (less than 0.1%) of the tuples in the sliding window. This is because, statistically, only few tuples cause errors. Moreover, the impact of any error, no matter how large it may be, disappears immediately once the tuple causing the error has moved out of the sliding window.
For some stream applications, the linear optimization queries are known in advance and the entire history, not just a sliding window, of the stream is considered. In this case, for each query, an in-memory materialized view can be maintained to continuously keep track of the top-K tuples. However, if there are many such queries, it may not be feasible to keep all these materialized views in memory and/or to maintain them in real time. As a consequence, the SAO index method is still needed under such circumstances.

We implemented the SAO index by modifying a widely-used Qhull package [ 5 ]. Our experimental results on both real and synthetic data sets show that the SAO index can han-dle high tuple arrival rates, be maintained efficiently in real time, and provide high-quality answers to linear optimization queries almost instantly.

A preliminary version of this paper appeared in ICDE X 07 [ 34 ]. However, we have provided in the current paper with a significant amount of new technical materials. In Luo et al. [ 34 ], only the high level idea of the algorithm is described. It omits many important details, such as mathematical derivations, justification of decisions made in the design of the algorithm, and illustrations of how the algorithm works. In contrast, these critical details are elaborated in the current paper. Moreover, in Luo et al. [ 34 ], only a brief performance study is included with only two initial performance figures, whereas in the current paper, a comprehensive set of additional performance studies is provided including many sensitivity analyses.
The rest of the paper is organized as follows. Section 2 briefly reviews the traditional onion index. Section 3 describes our SAO index. Section 4 presents results from a prototype implementation of our techniques. We discuss related work in Sect. 5 and conclude in Sect. 6 . 2 Review of the traditional onion index We briefly review the earlier onion index [ 8 ] for linear optimization queries against a large database relation. Suppose each tuple contains n  X  1 numerical feature attributes and m  X  0 other non-feature attributes. A top-K linear optimization query asks for the top-K tuples that of the j th tuple. Note that a linear optimization query may alternatively ask for the K minimal linear combination values. In this case, we can turn such a query into a maximization query by switching the signs of the weights. Without loss of generality, we focus on maximization queries in this paper.

A set of tuples S can be mapped to a set of points in an n -dimensional space according to K tuples with the largest projection values along the query direction. Linear programming theory has the following theorem: Theorem 1 [ 14 ] Given a linear maximization criterion and a set of tuples S, the maximum linear combination value is achieved at one or more vertices of the convex hull of S.
Utilizing this property, the onion index in Chang et al. [ 8 ] organizes all the tuples into one or more convex layers. The first convex layer l 1 is the convex hull of all the tuples in S .The see that for each i  X  1, l i + 1 is contained within l i . Figure 1 shows an example onion index in two-dimensional space.
From Theorem 1 , the maximum linear combination value at each l i ( i  X  1 ) is larger than all the linear combination values from l i  X  X  inner layers. Also, there may be multiple tuples on l whose linear combination values are larger than the maximum linear combination value of l 1 . Hence, we have the following property: Property 1 For any linear optimization query, suppose all the tuples are sorted in descending convex layers.

Given a top-K linear optimization query, the search procedure of the onion index starts from l 1 and searches the convex layers one by one. On each convex layer, all its vertices are checked. Based on Property 1 , the search procedure can find the top-K tuples by searching no more than the first K outer convex layers.

During a tuple insertion or deletion, one or more convex layers may need to be recon-structed in order to maintain the onion index (the detailed onion index maintenance procedure is available in Chang et al. [ 8 ]. We do not review it here). Both the creation and the main-tenance of the onion index require computing convex hulls. This is expensive, as given N points in n -dimensional space, the worst-case computational complexity of constructing the convex hull is O ( N ln N + N n / 2 ) [ 28 ]. 3 SAO index the original onion index is also computationally costly, making it difficult to meet the real-time requirement of data streams. Actually typical tuple arrival rates are often several orders of magnitude higher than the speed that the original onion index can be maintained.
To address these problems, we propose a SAO index for linear optimization queries against a data stream. Our key idea is to reduce both the index storage and maintenance overheads by keeping only a subset of the tuples in a data stream in the SAO index. We focus on the count-based sliding window model for data streams, with W denoting the sliding window size. That is, the tuples under consideration are the last W tuples that we have seen. Our techniques can be easily extended to the case of time-based sliding windows or the case that the entire history of the stream is considered.
 Suppose the available memory can hold M + 1 tuples. In the steady state, no more than M tuples are kept in the SAO index. That is, the storage budget is M tuples. In a transition period, M + 1 tuples can be kept in the SAO index temporarily. Our techniques can be extended to the case where memory is measured in bytes. In general, a tuple contains both feature and non-feature attributes. We are interested in finding all the attributes of the top-K tuples. Hence, all the attributes of those tuples in the SAO index are kept in memory. Even if the convex hull for feature attributes occupy only a small amount of space, the non-feature attributes may still dominate the storage requirement. For example, in the earlier-mentioned, environmental epidemiology application, each tuple has a large non-feature image attribute, which is also kept in memory. Note that the image cannot be stored on disk, even if we like to do so, because the tuple arrival rate can be too high for even the fastest disk to keep up with the rapidly arriving tuples. For example, satellite image transfer rate can easily become close to 1 Gbps [ 6 ].

Our design principle is as follows. To provide high-quality answers to linear optimization queries, the SAO index carefully controls the number of tuples on each layer. It dynamically allocates proper amount of storage to individual layers so that a larger portion of the available memory tends to be allocated to the outer layers. As such, the quality of the answers can be maximized without increasing the storage requirement. In case of overflow, the SAO index keeps the most  X  X mportant X  tuples and throws away the less  X  X mportant X  ones. Moreover, to minimize the computation overhead, the creation and maintenance algorithms of the SAO index are optimized.

The rest of Sect. 3 is organized as follows. Section 3.1 provides some background on approximate answers. Section 3.2 describes the SAO index organization. Sections 3.3 and 3.4 discuss memory allocation strategies. Sections 3.5 and 3.6 show how to create and how to maintain the SAO index, respectively. Section 3.7 presents the query evaluation method. Section 3.8 addresses parallel processing. 3.1 A little background on approximate answers Users submitting linear optimization queries against data streams generally must accept approximate answers. If W  X  M ,all W tuples in the sliding window can be kept in memory. Then for any linear optimization query, the exact answer can always be computed by checking the last W tuples. However, if W &gt; M , which is common in practice, it is impossible to keep the last W tuples in memory. Then for any linear optimization query, the return of exact answers cannot always be guaranteed. The reason is similar to what has been shown in Yi monotonically, the memory cannot always hold those K  X  X alid X  tuples with the largest linear combination values. Consequently, users have to accept approximate answers.

In the rest of this paper, we focus on the case of W &gt; M . In this case, it is impossible to keep the precise onion index in memory. Rather, we propose a SAO index, which can provide approximate answers to linear optimization queries almost instantaneously. 3.2 Index organization The SAO index is based on a key observation: an onion index typically contains a large number of convex layers, but most inner layers are not needed for answering the majority of linear optimization queries. For example, as mentioned in Sect. 2 , to answer a top-K linear optimization query, at most the first K outer convex layers need to be searched. Hence, the SAO index keeps only the first few outer convex layers rather than all the convex layers. More specifically, the user who creates the SAO index will specify a number L .TheSAO index keeps only the first L outer convex layers.

Intuitively, if most linear optimization queries use a large K (say, 20), L could be smaller than that K (say, L = 10 ) . However, if most linear optimization queries use a very small K beshowninSect. 3.3 below, when K is very small, a few backup convex layers are preferred. This is to prevent the undesirable situation where a few tuples on the first K outer convex layers expire and large errors are introduced into the approximate answers to some linear optimization queries. On the other hand, when K is large, for a top-K linear optimization query, it is likely that the top-K tuples can be found on the first J outer convex layers, where J &lt; K . In this case, if a few tuples on these J convex layers expire, the other convex layers can serve as backups automatically. Hence, L does not need to be larger than K .
Since M is limited, the SAO index cannot always keep the precise first L outer convex layers. For example, in the worst case, all W tuples in the sliding window may reside on the first convex layer rather than spread over multiple convex layers. Therefore, for each of the first L outer convex layers, the SAO index may only keep some of the most  X  X mportant X  tuples rather than all the tuples belonging to that layer. In other words, each layer in the SAO index is an approximate convex layer (ACL) in the sense that it is an approximation to the corresponding precise convex layer in the onion index. For each i (1  X  i  X  L ) , l i is used to denote the i th ACL.

The SAO index maintains the following properties. Each ACL is the convex hull of all the number of tuples on all L ACLs is no more than M (recall that in a transition period, M + 1 tuples can be kept in the SAO index temporarily).
 AsshowninFig. 2 all the tuples in the SAO index are kept as a sorted, doubly linked list L dl . The sorting criterion is a tuple X  X  remaining lifetime. The first tuple in L dl is going to expire the soonest. In this way, we can quickly check whether any tuple in the SAO index expires, which is needed at Step 2 of Sect. 3.6 below. Also, we can easily delete tuples that are in the middle of L dl , which is necessary when the available memory is exhausted and a tuple needs to be deleted from the SAO index (see Sect. 3.4 below).

For each ACL, a standard convex hull data structure [ 29 ] is maintained. The vertices of to which tuple t belongs. This label is used when a tuple expires and needs to be removed from the corresponding ACL (see Sect. 3.6 below). 3.3 Allocating proper memory to each layer A key challenge in designing a SAO index is: for a given amount of memory, how do we prop-erly allocate the memory to each layer so that the quality of the answers can be maximized? In the following sections, we first illustrate why such careful allocation is needed, then we describe three allocation strategies: a simple, uniform strategy; a static, error-minimizing strategy; and a dynamic, error-minimizing strategy. 3.3.1 Necessity of a storage allocation strategy The SAO index needs to control the number of tuples on each ACL. Otherwise, one or a few ACLs may use up all the storage budget M . As a result, the SAO index may not provide good-quality answers to certain queries.
 For example, suppose l 1 , the first ACL, uses up all the storage budget M and all the other L  X  1 ACLs are empty, as shown in Fig. 3 (we adopt the convention in Chang et al. [ 8 ]of using dotted polygons to represent ACLs). In this case, the information about all the tuples inside l 1 is lost. These tuples are represented by the hollow circles in Fig. 3 and thus called hollow tuples.

Consider a top-1 linear optimization query q whose direction is represented by the arrow in Fig. 3 . When tuple t expires from the sliding window, the SAO index cannot provide a good-quality answer to q . This is because the linear combination values of those hollow tuples are all much larger than the maximal linear combination value of the remaining tuples on l 1 . However, those hollow tuples are not kept in the SAO index.

Now suppose the SAO index controls the number of tuples on each ACL. For example, the storage budget M is divided among all L ACLs in a more balanced way, as shown in Fig. 4 a. This has the effect that some of the information contained in l 1 is lost while some other information can be kept in the other L  X  1ACLs.

Then after tuple t expires, l 1 can be  X  X ecovered X  by using the information contained in l 2 (the recovery procedure is described in Sect. 3.6 ),asshowninFig. 4 b. As a result, the SAO index can still provide a good-quality answer to the linear optimization query q . 3.3.2 A simple, uniform storage allocation strategy A simple storage allocation strategy is to divide the storage budget M evenly among all L ACLs. Each ACL cannot keep more than M / L tuples. However, this simple, uniform method is far from being optimal. The reason is as follows. In the precise onion index, according to Property 1 , for a linear optimization query, we tend to find more of the top-K tuples on the outer convex layers than on the inner convex layers. For example, consider a top-20 linear optimization query. The precise onion index may find the largest ten tuples on the first convex layer, the next largest six tuples on the second convex layer, and the remaining largest four tuples on the third convex layer. This is consistent with the effect observed in Chang et al. [ 8 ]: to retrieve the top-K tuples, typically we only need to access a few outer convex layers rather than all the first K outer convex layers in the precise onion index. Similar to the precise onion index, we tend to find more of the top-K tuples on the outer ACLs than on the inner ACLs. Intuitively, the more tuples allocated to an ACL l i (1  X  i  X  L ) , the closer l i is to the corresponding precise convex layer and thus the more precise the top tuples we will find on l i . Moreover, as discussed below, compared to the top tuples that are found on the inner ACLs, the top tuples that are found on the outer ACLs are ranked higher and thus more important. Therefore, in order to provide high-quality answers to linear optimization queries, the SAO index should allocate more tuples to the outer ACLs than to the inner ACLs. 3.3.3 Static, error-minimizing storage allocation Now we describe a static, error-minimizing storage allocation strategy when resource is limited. We determine the optimal numbers of tuples the SAO index should allocate to the L ACLs. By resource being limited, we mean that each ACL needs more tuples than can be actually allocated to it. We will describe next a dynamic, error-minimizing storage allocation strategy that is based on the results derived in this section. For each i (1  X  i  X  L ) ,let N i denote the optimal number of tuples that should be allocated to l i .Then
In general, the values of N i s depend on the exact data distribution. Since the data distribu-tion is usually not known in advance, N i s cannot be precisely determined. In our derivation, a few simplified assumptions are made. This makes our derived N i s heuristic in nature rather than exactly optimal. In the performance of Sect. 4 , we show that our heuristics indeed work well in practice.

Consider a top-L linear optimization query. For each i (1  X  i  X  L ) ,let t i represent the exact i th largest tuple, and t i represent the i th largest tuple that is found in the SAO index. relative error of t i is defined as
For the top-L tuples ( t i ) that are returned by the SAO index, a weighted mean of their relative errors is used as the performance metric e : relative error. Hence, u i should be a non-increasing function of i . We would like to minimize the mean of e for all top-L linear optimization queries, which is how N i s are derived. Our idea is to represent the mean of e as a function of N i s and find its minimal value under condition (1). According to our derivation whose details are in the Appendix, we can show that N i  X  3.4 Dynamic, error-minimizing storage allocation If for each i (1  X  i  X  L ) , l i ,the i th ACL, always needs more than N i tuples, then the SAO index can use a static storage allocation strategy so that l i gets a fixed storage quota of N i tuples. However, the real world is more dynamic. At any time, some ACLs may need more than N i tuples while other ACLs may need fewer than N i tuples. As tuples keep entering and leaving the sliding window, the storage requirements of different ACLs change continuously. If the SAO index sticks with the static storage allocation, the total storage quota of M tuples cannot always be fully utilized. For example, this is the case if some ACLs do not use up their storage quota N i . This will hurt the quality of the answers.

To ensure the best quality of the answers, the SAO index needs to fully utilize the storage budget M as much as possible. Therefore, instead of static storage allocation, it does dynamic storage allocation. In this way, the ACLs that need extra storage quota can  X  X orrow X  some quota from those ACLs that have spare quota.

Now we describe the dynamic storage allocation strategy. Our design principle is: when-ever possible, the storage budget M is used up. At the same time, the SAO index tries its best to maintain the condition that the number of tuples on l i is proportional to
The concrete method is as follows. For each i (1  X  i  X  L ) ,let M i denote the number of tuples on l i . The SAO index continuously monitors these M i s. At any time, there are two possible cases. In the first case, L i = 1 M i  X  M . This is a normal case and nothing needs to be done, as the storage budget M has not been used up. In the second case, L i = 1 M i = M + 1 (according to Sect. 3.6 , L i = 1 M i can never be larger than M + 1). This is an overflow case, as the storage budget M is exceeded by one. We need to pick a candidate ACL and delete one tuple from it.

Note that the dynamic storage allocation strategy is of a fine granularity. Each time when memory is exhausted, one tuple is deleted from the SAO index. The reader might wonder if we could use a coarser granularity. That is, multiple tuples (rather than a single tuple) are deleted at once from the SAO index. Then it will take longer before memory is exhausted again. However, such a method is not desirable in our environment. This is because our storage budget is precious, as M may be small. We want to fully utilize the limited storage budget as much as possible so that the SAO index can provide the best-quality answers to linear optimization queries. Moreover, as can be seen from Sect. 3.6 (Step 1), the insertion of a new tuple into the SAO index may cause multiple tuples to be expelled from l L and then some storage becomes available automatically. 3.4.1 Choosing a candidate approximate convex layer We first discuss how to choose the candidate ACL. For each i (1  X  i  X  L ) ,let r i = M i / N i . i (1  X  i  X  L ) , r i  X  1. This leads to L i = 1 M i  X  L i = 1 N i = M , which conflicts with the condition that L i = 1 M i = M + 1. l j is chosen as the candidate ACL.

This method is based on the intuition that the candidate ACL l j should satisfy the following two conditions. First, l j has used up its fixed quota N j . Second, among all the ACLs that way, we can be fair to those ACLs that have not used up their fixed quota N i . Also, the SAO index can maintain the condition M i  X  3.4.2 Choosing a candidate tuple Now one candidate tuple needs to be deleted from the candidate ACL l j . Intuitively, this candidate tuple t should have a close neighbor so that deleting t will have little impact on the shape of l j . Two tuples on an ACL are neighbors if they are connected by an edge.
For any tuple t on l j ,let R t denote the Euclidean distance between tuple t and its nearest neighbor on l j . The candidate tuple is chosen to be the tuple that has the smallest R t (usually there are a pair of such tuples and the older one, i.e., the sooner-to-expire one, is picked). Note that R t is not the smallest distance between tuple t and any other tuple on l j .Rather,in computing R t , only tuple t  X  X  neighbors are considered.
 We use an example to illustrate the reasoning. Consider the candidate ACL l j shown in Fig. 5 .If R t denotes the smallest distance between tuple t and any other tuple on l j ,then as the candidate tuple and deleted from l j . This greatly influences the shape of l j .Thereare two possible cases, and we can run into trouble in either case: (1) j = L . Consider a top-K linear optimization query q whose direction is shown in Fig. 5 .
In contrast, if R t is the distance between tuple t and its nearest neighbor on l j , then tuples t a minor change to the shape of l j and thus we are not likely to run into the trouble described above. 3.4.3 Deleting candidate tuple Finally, after choosing the candidate tuple t , we use the method that is described in Step 2 of Sect. 3.6 below to delete t from l j and then adjust the affected ACLs. 3.5 Index creation At the beginning, the SAO index is empty. We keep receiving new tuples until there are M tuples. Then a standard convex hull construction algorithm, such as the quickhull method whose worst-case computational complexity is O ( N ln N + N n / 2 ) given N points in n -dimensional space [ 5 ], is used to create the L ACLs in batch. This is mainly for effi-ciency purposes, as creating convex hulls in batch is less expensive than constructing convex hulls incrementally (i.e., each time adding one new tuple) [ 5 ]. Note that it is possible that some of the innermost ACLs are empty. From now on, each time a new tuple arrives, we use the method in Sect. 3.6 to incrementally maintain the SAO index. 3.6 Index maintenance In a typical data streaming environment, we expect that W &gt;&gt; M , i.e., only a small fraction of all W tuples in the sliding window are stored in the SAO index. Intuitively, this means that tuples on the ACLs can be regarded as anomalies with extreme feature attribute values. The smaller the i (1  X  i  X  L ) is, the more anomalous the tuples on l i are. As a result, we have the following heuristic (not exact) property: Property 2 Most new tuples are  X  X ormal X  tuples and thus inside l L . Moreover, for a new less likely is tuple t between l L  X  2 and l L  X  1 ,etc.
 According to our storage allocation strategy described in Sects. 3.3 and 3.4 , the inner ACLs tend to have fewer tuples than the outer ACLs. From computational geometry literature [ 28 , 29 ], it is known that given a point p , the complexity of checking whether p is inside a convex polytope P increases with the number of vertices of P . Therefore, we have the following property: Property 3 For a tuple t , it is typically faster to check whether t is inside an inner ACL than to check whether t is inside an outer ACL.

Upon the arrival of a new tuple t , Properties 2 and 3 are used to reduce the SAO index maintenance overhead. We proceed in three steps. Step 1 checks whether tuple t needs to be inserted into the SAO index. Step 2 checks whether any tuple in the SAO index expires. Step 3 handles memory overflow.
 Step 1: tuple insertion . All ACLs are checked one by one, starting from l L . That is, our checking direction is from the innermost ACL to the outermost ACL. From Properties 2 and 3 together with the procedure described below, it can be seen that this checking direction is the most efficient one.

There are two possible cases. In the first case, tuple t is inside l L . According to Property 2 , this is the mostly likely case. Also, according to Property 3 , it can be discovered quickly whether tuple t is inside l L . In this first case, tuple t will not change any of the L ACLs and thus can be thrown away immediately. Since no new tuple is introduced into the SAO index, there will be no memory overflow. Hence, Step 3 can be skipped, although Step 2 still needs to be performed. Note: If l L is empty, we think that tuple t is outside of l L because t needs to be inserted into the SAO index.

In the second case, a number k (1  X  k  X  L ) can be located such that tuple t is inside l k  X  1 but outside of l k (if k = 1, tuple t is outside of all L ACLs). In this case, tuple t needs to be inserted into the SAO index. This insertion will affect l k and maybe some ACLs inside l k . However, none of the first k  X  1 ACLs will be affected.

This insertion is done in the following way. The new l k is computed by considering both tuple t and all the tuples on the existing l k , using any standard incremental convex hull maintenance algorithm, like the beneath-beyond method whose update computational complexity is O ( N n / 2 ) given a convex hull with N points in n -dimensional space [ 28 , 29 ]. This may cause one or more tuples to be expelled from l k . If that happens, the expelled tuples expel some tuples from l k + 1 . The iteration continues until either l L is reached or no more tuples are expelled. Figure 6 shows an example of inserting a new tuple t into a SAO index. The insertion procedure is described below in pseudo-code.
Let set S ={ t }; i = k ; while ( | S | &gt; 0&amp;&amp; i  X  L ) { } Step 2: tuple expiration . The arrival of tuple t will cause at most one tuple in the SAO index to expire from the sliding window. Let t denote the first tuple in the doubly linked list L dl . Recall that all the tuples in L dl are sorted in ascending order of their remaining lifetimes. Hence, only tuple t needs to be checked, as t is the only tuple in the SAO index that may expire from the sliding window.

There are two possible cases. In the first case, tuple t has not expired. We proceed to Step 3 directly.
 In the second case, tuple t has expired and thus needs to be deleted from the SAO index. Suppose tuple t is on l k (1  X  k  X  L ) . The deletion of tuple t will affect l k and maybe some ACLs inside l k . However, none of the first k  X  1 ACLs will be affected.

This deletion is done in the following way. The new l k is computed by considering both all on l k + 1 aremoveduptothenew l k , the new l k + 1 needs to be further computed by considering both the remaining tuples on l k + 1 and all the tuples on l k + 2 . The iteration continues until either l L is reached or no more tuples are moved up. Since this iteration procedure reduces the number of tuples in the SAO index by one, there will be no memory overflow and thus Step 3 can be skipped. Figure 7 shows an example of deleting a tuple t from a SAO index. The deletion procedure is described below in pseudo code.

Let set S ={ t }; i = k ; while ( | S | &gt; 0&amp;&amp; i  X  L ) { } Step 3: handling memory overflow In the above two steps, at most one new tuple is introduced into the SAO index while one or more tuples may be deleted (e.g., tuples may get expelled from l L in Step 1). Now we check whether condition L i = 1 M i  X  M still holds (recall that M i denotes the number of tuples on l i ). If not, L i = 1 M i = M + 1 must be true. In this case, we use the procedure that is described in Sect. 3.4 to delete one tuple from the SAO index. 3.6.1 Discussion From the above description, we can see that it is computationally expensive to either insert a new tuple into the SAO index or delete an existing tuple from the SAO index, as multiple ACLs may need to be reconstructed. Fortunately, upon the arrival of a new tuple, the amortized overhead of maintaining the SAO index is not that high. The reason is as follows. First, according to Property 2 , in most cases, the new tuple will be inside the innermost ACL l L and thus can be thrown away immediately. Also, the number of tuples in the SAO index is at most M + 1, which is usually much smaller than the sliding window size W . On average, after approximately W / M new tuples are received, one tuple in the SAO index expires. Therefore, we rarely need to either insert a new tuple into the SAO index or delete a tuple from the SAO index.

Second, M is typically not very large. Then for each i (1  X  i  X  L ) , M i , the number of tuples on l i , is also not very large. This reduces the reconstruction overhead of ACLs, and also the overhead of checking whether the new tuple is inside an ACL.

Third, our SAO index maintenance algorithm has been optimized. For example, an efficient checking direction is used in Step 1. 3.7 Query evaluation To provide approximate answer to a top-K linear optimization query ( K can be larger than L ) , we use the onion index search procedure that is described in Chang et al. [ 8 ]. We start from l 1 and search the ACLs one by one. This search terminates when one of the following two conditions are satisfied: (1) all L ACLs have been searched (in this case, all L ACLs are treated as previous ACLs), (2) the K th largest tuple on the previous ACLs has larger linear combination value than the largest tuple on the current ACL. Then the top-K tuples on the previous ACLs are returned to the user. According to Theorem 1 ,these K tuples are the top-K tuples in the SAO index. 3.8 Parallel processing The above discussion assumes that there is only one computer. If tuples arrive so rapidly that one computer cannot handle all of them, multiple (say, C ) computers can be used. The concrete method is as follows. All the tuples are partitioned into C sets (say, using round-robin partitioning [ 15 ]). Each computer maintains a SAO index and handles a different set of tuples. When the user submits a top-K linear optimization query, the local top-K tuples are obtained on each computer. All these local top-K tuples are merged together to get the global top-K tuples. This is our answer to the top-K query. 4 Performance evaluation We implemented our techniques by modifying the widely used Qhull (version 2003.1) soft-ware package [ 5 ], which implements efficient constructs for the creation of convex hulls. Our measurements were performed on a computer with one 1.6 GHz processor, 1 GB main memory, one 75 GB disk, and running the Microsoft Windows XP.

Our evaluation used both real and synthetic data sets. The real data set came from the 2005 UC data mining competition [ 31 ]. Among all the attributes, we used the three ( n = 3) attributes that carried the most information (i.e., had the largest number of distinct values) as the feature attributes. The purpose for using this real data set is to show that our techniques work well for at least one real data distribution (in addition to several synthetic data distrib-utions) rather than trying to draw any specific conclusion from this data set. Also, this data set is freely available for verification.
 The synthetic data sets contain only feature attributes and are described as follows: Drifting Gaussian distribution data set : Each attribute value follows a Gaussian distribution with variance=1 and mean oscillating between  X  D and D at a uniform speed. The oscillation period is 4 W ,where W is the sliding window size.
 Skewed uniform distribution data set : For each attribute value, with probability p , it is uni-between  X  0.5 and  X  0.1; with probability ( 1  X  p )/ 2, it is uniformly distributed between 0.1 and 0.5. This p controls the degree of distribution skew of the data set.

Seven experiments were performed. Each was repeated twenty times (twenty runs). Unless otherwise specified, all the reported numbers are averaged over these runs. In each experiment, after the system has run for enough time and reaches a steady state, we posed 100 top-K linear optimization queries, whose weights were uniformly distributed between  X  1 and 1. As in Sect. 3.3 and the Appendix, for each top-K linear optimization query, the weighted choices of u i can be used. The results are similar and thus omitted here). The following three performance metrics were used: (1) Max error . The maximum e observed for the 100 top-K linear optimization queries. (2) Avg error . The average e observed for the 100 top-K linear optimization queries. (3) Throughput . In the steady state, the average number of tuples that can be processed per In the rest of this section, by default the sliding window size is W = 1 , 000 , 000. The SAO index contains L = 4 ACLs. The number of top tuples is K = 10. The storage budget M is 500 tuples. The dimensionality n (i.e., the number of feature attributes) of the data set is 3. 4.1 Storage budget size In this experiment, the real data set was used. We varied the storage budget M from 200 tuples to 700 tuples. We compared the following four storage allocation methods: (1) Dynamic error-minimizing method : we used the dynamic storage allocation strategy (2) Dynamic uniform method : we used the dynamic storage allocation strategy described (3) Static error-minimizing method : we used the static storage allocation strategy described (4) Static uniform method : we used the static storage allocation strategy described in
Figure 8 shows the impact of M / W ratio on the weighted relative error. For any M / W ratio, among all four storage allocation methods, the dynamic error-minimizing method achieves both the smallest max error and the smallest avg error. The error-minimizing storage allocation strategy always works better than the uniform one. This is consistent with the explanation we gave in Sect. 3.3 about why more tuples should be allocated to the outer ACLs than to the inner ACLs. Moreover, the dynamic storage allocation strategy always works better than the static one. This is consistent with the explanation we gave in Sect. 3.4 about why storage quota needs to be allocated dynamically. For the rest of Sect. 4 , we focus on the dynamic error-minimizing method.

The larger the M / W ratio is, the more information can be kept in the SAO index and thus the better the quality of the answers is. Hence, both the max error and the avg error decrease as M / W ratio increases. When M / W = 0 . 05%, the avg error is 0.5% while the max error is 3%, both fairly small. In other words, even with a storage budget that is only a very small fraction of the sliding window size, the SAO index can provide fairly accurate answers. The filtering ratio is defined as the probability that a new tuple is inside the innermost ACL l L and thus can be thrown away immediately. The higher the filtering ratio, the better it is in terms of reducing the cost of maintaining a SAO index. Figure 9 shows the impact of M / W ratio on the filtering ratio. As M / W ratio increases, more tuples are stored in the SAO index over all the layers, including the innermost one, l L . Incoming tuples are more likely to be filtered as the size of l L increases. More importantly, in all of the cases, the filtering ratios are always very close to 1. In other words, most new tuples are thrown away rather than being inserted into the SAO index. Note that even when M / W is only as small as 0.02%, the filtering ratio is as high as 89%. When M / W = 0 . 05%, 99.8% of newly arriving tuples will be dropped immediately.

Figure 10 shows the impact of M / W ratio on the throughput. The throughput first increases with M / W ratio. After M / W ratio reaches a threshold 0.04%, the throughput decreases as M / W ratio increases. This is because the throughput depends on two factors: the filtering ratio and the tuple expiration rate (i.e., the speed that tuples in the SAO index expire). Both factors increase with M / W ratio. If a new tuple is not inside l L , expensive convex hull computation needs to be performed to insert this tuple into the SAO index. Similarly, when a tuple in the SAO index expires, expensive convex hull computation needs to be performed to maintain the SAO index. Before M / W ratio reaches a threshold, the filtering ratio increases faster than the tuple expiration rate does. Thus, the throughput first increases with M / W ratio. After M / W ratio reaches this threshold, the volume of l L starts to increase slowly. Then the tuple expiration rate increases faster than the filtering ratio. As a result, the throughput decreases as M / W ratio increases further.

From Figs. 8 , 9 ,and 10 , we can see that even with a very small storage budget ( M / W = 0 . 05% ) , the SAO index can filter out 99.8% of new tuples, support a throughput of over 100,000 tuples/s, and achieve fairly accurate estimates with the avg error of 0.5%.
We repeated the storage budget size experiment by replacing the real data set with the synthetic drifting Gaussian distribution data set, where D = 0. The results for the Gaussian distribution data set are shown in Figs. 11 , 12 ,and 13 . They are similar to the results for the real data set. 4.2 Sliding window size In this experiment, the real data set was used. We varied the sliding window size W from 250,000 to 1,500,000. Figure 14 shows the impact of W on the weighted relative error. The larger the W is, the smaller M / W ratio becomes and thus relatively less information is kept in the SAO index. Therefore, when W  X  750 , 000, both the avg error and the max error increase slowly with W .However,when W &lt; 750 , 000, not so many tuples are in the sliding window and these tuples are scattered in the entire data space. If one top tuple is missed for a query, we may have a large weighted relative error. The smaller the W is, the larger the chance of having a large weighted relative error. Hence, when W &lt; 750 , 000, both the avg error and the max error increase as W decreases.

Figure 15 shows the impact of W on the throughput. The larger the W is, the smaller the tuple expiration rate. Therefore, the throughput increases with W . 4.3 Number of layers In this experiment, the real data set was used. We varied the number of layers L in the SAO index from 1 to 7. Figure 16 shows the impact of L on the weighted relative error. The more layers in the SAO index, the more likely we can find the exact top-K tuples. Hence, both the avg error and the max error decrease as L increases.
Figure 17 shows the impact of L on the throughput. The larger the L is, the more ACLs need to be re-computed during the SAO index maintenance. In other words, the SAO index maintenance overhead increases with L . As a result, the throughput decreases as L increases. 4.4 Number of top tuples In this experiment, the real data set was used. We varied the number of top tuples K from 6 to 14. Figure 18 shows the impact of K on the weighted relative error. The larger the K is, the less likely we can find the exact top-K tuples. Therefore, both the avg error and the max error increase with K . 4.5 Dimensionality dimensionality n (i.e., the number of feature attributes) of the data set from two to four. Figure 19 shows the impact of n on the weighted relative error. The larger the n is, the more scattered tuples are distributed in the entire data space and the larger the penalty of missing one top tuple becomes for a linear optimization query. Therefore, both the avg error and the max error generally increase with n .
Figure 20 shows the impact of n on the throughput. Note that the y -axisuseslogarithmic scale. Given the same number of points, the larger the n , the more expensive the overhead of constructing a convex hull becomes. Hence, the throughput decreases as n increases. 4.6 Distribution skew In this experiment, the synthetic skewed uniform distribution data set was used. Recall that p controls the degree of distribution skew of that data set. We varied p from 0.2 to 0.9. When p = 0 . 2, attribute values are uniformly distributed between 0 and 1. The larger the p is, the more skewed the distribution of attribute values becomes.

Figure 21 shows the impact of p on the weighted relative error. The more skewed the distribution of attribute values is, the more scattered the largest tuples are distributed in the entire data space and the larger the penalty of missing one top tuple becomes for a linear optimization query. As a result, the max error increases with p , while the avg error remains fairly stable and shows the robustness of the SAO index approach.

Figure 22 shows the impact of p on the throughput. The more skewed the distribution of attribute values is, the more likely a new tuple is inside l L and thus can be thrown away immediately. Hence, the throughput increases with p . 4.7 Degree of drifting In this experiment, the synthetic drifting Gaussian distribution data set was used. Recall that D controls the degree of drifting of that data set. We varied D from 0 to 1. Figure 23 shows the impact of D on the weighted relative error. The larger the degree of drifting is, the more likely some top tuples are missed for a linear optimization query (the reason is similar to that in Sect. 3.1 ). As a result, the max error increases with D , while the avg error remains fairly stable and shows the robustness of the SAO index approach.

Figure 24 shows the impact of D on the throughput. The larger the degree of drifting is, the more likely a new tuple is outside l 1 and thus the SAO index needs to be maintained. Hence, the throughput decreases as D increases.

In summary, in all the above seven experiments, using the SAO index to answer a top-K linear optimization query always takes less than 0.00002 second. Using a fairly small amount of memory space, the SAO index provides good approximate answers to top-K linear op-timization queries, and the quality of approximate answers improves with the amount of available memory. Even under a rapid tuple arrival rate, the SAO index can still be main-tained efficiently in real time. Hence, the SAO index can provide good support for answering linear optimization queries against a data stream. 5 Related work Hristidis et al. [ 20 ] proposed using materialized views to answer linear optimization queries. The method in Hristidis et al. [ 20 ] keeps multiple materialized views, each of which contains a copy of the entire data set. Hence, that method does not work in a data streaming environment, where available storage space is limited.

Yi et al. [ 33 ] proposed keeping extra tuples to reduce the maintenance overhead of top-K materialized views. In their environment, the query, which is defined by the top-K materi-alized view, is known in advance. In our case, the linear optimization queries may not be known in advance.

Top-K query evaluation algorithms have been proposed for a variety of scenarios: RDBMS works addresses the data streaming environment, where available storage space is limited.
Recently, various methods [ 2 , 12 , 22 ] have been proposed for maintaining approximate convex hulls. The method in Agarwal et al. [ 2 ] cannot handle tuple deletion. The storage in Hershberger et al. [ 22 ] only works in the two-dimensional case and cannot handle tuple deletion. Therefore, none of these methods applies to our environment, where available space is limited and both tuple insertion and deletion need to be handled.
B X hm et al. [ 7 ] proposed two methods for computing the precise convex hull that were based on multi-dimensional index structures. Clarkson et al. [ 13 ] proposed a method for maintaining the precise convex hull under insertion and deletion of data points. All those methods require keeping all data points and thus do not work in our environment, where available storage space is limited.

Mouratidis et al. [ 27 ] uses multi-layer skybands to answer top-K monotonic queries over sliding window against a data stream. Mouratidis et al. [ 27 ] assumes that (1) the memory is large enough to hold all the tuples in the sliding window, and (2) all the attributes have minimal and maximal values that are known beforehand. These two assumptions are invalid in our environment.
 Recently, various synopsis data structures have been proposed for data streams [ 19 ]. Our SAO index can be regarded as one kind of synopsis. However, none of the previously proposed synopsis data structures can be used to answer linear optimization queries.

Proportional-share resource management has been studied in the operating system lit-erature [ 30 , 32 ]. There, the resource under consideration is usually continuous (e.g., CPU, network bandwidth). If one server increases its share of resources, typically multiple other servers will be affected and decrease their shares of resources simultaneously. In our case, the resource under consideration (tuples) is discrete. If memory is exhausted and one ACL requires an extra tuple, our dynamic storage allocation strategy only forces one other ACL to give up one of its tuples. 6Conclusion This paper proposes a SAO index to support the answering of arbitrary linear optimization queries against a data stream. With a limited amount of memory, a dynamic, error-minimizing storage allocation strategy is used to maximize the quality of the approximate answers by allocating more memory to the outer layers of the SAO index. The maintenance of the SAO index is very efficient, as most of the newly arriving tuples are thrown away immediately without causing any changes to the SAO index. The efficiency of the SAO index is evaluated through a prototype implementation.

Like that of the original onion index, the maintenance cost of the SAO index increases rapidly with the number of feature attributes. In the case that there are many candidate feature attributes, we need to use an appropriate feature selection method [ 38 ] to control the number of used feature attributes so that the SAO index can still be maintained in real time while good approximate answers can be provided to linear optimization queries.
 Appendix Let p ij (1  X  i  X  L ,1  X  j  X  L ) represent the probability that for a top-L linear optimization query, tuple t i is on the j th convex layer in the onion index. We assume that in this case, tuple t i is also on l j ,the j th ACL in the SAO index. Furthermore, the mean of e i for all the closer l j is to the j th precise convex layer in the onion index and thus the smaller the e i .
A heuristic justification for the assumption of 1 / N j is as follows. It is not mathematically rigorous. Rather, it is only used to illustrate our reasoning process. We project all the N j tuples on l j along the query direction, as shown in Fig. 25 . Each projection is a point. For these N j points, let d denote the average distance between two adjacent points. Assume that j , the mean of e i is
Now we return to the goal of minimizing e , the mean of e . For each i (1  X  i  X  L ) , tuple t must be on one of the L convex layers in the onion index. Hence, e i , the mean of e i ,isa weighted average over all j  X  X  (1  X  j  X  L ): From ( 3 ), Define We h ave From ( 1 ), we get To minimize e , the following weighted arithmetic-harmonic means inequality is used: x ,..., x L , we have weighted arithmetic mean  X  weighted harmonic mean, with equality only when x 1 = x 2 =  X  X  X  = x L . That is, After transforming ( 8 ), we have Let w j = C j and x j = N j / C j .Using( 6 ), ( 7 ), and ( 9 ), we know that e (or alternatively, the left side of ( 6 )) is minimized when the following condition holds: Then from ( 1 ), we get
According to Property 1 , we know that if i &lt; j , p ij = 0. If we assume that t i , the exact i th largest tuple, has equal probability to be on any one of the first i outer convex layers in the onion index, then p ij = 1 u = 1 / i . (Other choices of u i can be used. The results are similar and thus omitted here.) Then from ( 5 ), we have References Author biographies
