 It has been observed that queries over XML data sources are often unsatisfiable. Unsatisfiability may stem from several different sources, e.g., the user may be insufficiently famil-iar with the labels appearing the documents, or may not be intimately aware of the hierarchical structure of the docu-ments. This difficulty may be compounded by the fact that errors in query formulation lead to an empty answer, and not to some sort of compilation error.

To deal with query and document mismatches, previous research has considered returning answers that maximally satisfy (in some sense) the query, instead of only returning strictly satisfying answers. However, this breaks the golden database rule that only strictly satisfying answers are re-turned when querying. Indeed, the relationship between the query and answers is no longer clear, when unsatisfying answers are returned. To revive the golden database rule, this paper proposes a framework for deriving self-correcting queries over XML. This framework generates similar satisfi-able queries, when the user query is unsatisfiable. The user can then choose a satisfiable query of interest, and receive exactly satisfying answers to this query.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Storage and Retrieval]: Information Search and Re-trieval General Terms: Algorithms, Languages, Theory
Querying a database of XML documents is often a diffi-cult undertaking. Slight misunderstandings of the document structure can easily lead to the formulation of unsatisfiable queries. This is troublesome, especially in light of the fact that such queries yield empty answers, and not compilation errors. Hence, discovering an d fixing errors in query struc-ture is challenging.  X 
This work was partially supported by the ISF (Grant 1032/05).
 CIKM X 0 7 , N ov em b er 6 X 8, 2007, L is boa, P ortugal. Copyright 2007 ACM 978-1-59593-803-9/07/0011... $ 5.00..
Previous work has recognized the difficulty to formulate satisfiable queries over XML. Hence, much work, e.g., [12, 13, 6, 1, 2], has been done on returning answers that max-imally satisfy (in some sense) the query, instead of only re-turning strictly satisfying answers. This is often an excellent solution for the query-document mismatch problem. How-ever, this solution breaks the golden database rule that only strictly satisfying answers are returned when querying. In-deed, the relationship between the query and answers is no longer clear, when unsatisfying answers are returned, since answers that satisfy several different exact queries may be returned.

This paper presents an alternative solution to the query-document mismatch problem. To revive the golden database rule, we proposes a framework for deriving self-correcting queries over XML. This framework generates similar satisfi-able queries, when the user query is unsatisfiable. The user can then choose a satisfiable query of interest, and receive exactly satisfying answers to this query. We also show how to generate similar satisfiable queries efficiently. Related Work. Query correction has been studied in the past in the context of keyword search. In particular, spelling correction of queries has been studied for keyword search, e.g. [14, 17, 8]. Techniques for spelling correction are orthog-onal to our framework and can be incorporated into our node relaxing functions. A variati on of the query correction prob-lem, called query expansion, has been studied extensively, e.g, [16, 18]. Query expansion d iffers from query correction in that it attempts to  X  X mprove X  the query, instead of cor-recting the query. Query expansion for XML queries is a fascinating problem that is left for future research.
In the context of XML queries, there is no previous work on query correction. However, as discussed above, there is a wealth of work on finding inexact query answers, e.g. [12, 13, 6, 1, 2]. Beyond the difference in their setting, these papers also differ in their approaches significantly from this work. For example, [12, 13, 6] do not attempt to quantify the inexactness of a query answer (and such ability is critical in our context to ensure that optimal self-corrected queries are returned). [1, 2] also significantly differ from the current paper, e.g., they consider only tree queries, which is a severe limitation when the exact document hierarchy is unfamiliar. Contributions. The main contributions of this paper are as follows. First, we present a general framework for self-correcting queries (Section 3). This framework can be ac-commodate different scoring functions to allow for varied self-correction strategies. Second, a provably efficient al-gorithm for self correcting queries using our framework is presented (Sections 4 and 5). Third, useful variations and extensions to our approach are discussed, e.g., forcing self-corrections to form tree queries (Section 6). Fourth, experi-mental validation of the efficiency of our approach is shown (Section 7).
XML documents, as well as queries and schemas, are mod-eled as directed, rooted, labeled, acyclic graphs. The details of these structures follow.

Physically, an XML document has a tree-like hierarchical structure. Formally, we will model an XML document as a directed, rooted, labeled acyclic graph X ( r, V, E ). The  X  X d-ditional edges X  that turn the tree into a dag stem from im-plicit joins appearing in the document, e.g., from ID-IDREF attributes. Such implicit joins are of especial importance when correcting an XML query, since a likely error in query formulation is an incorrect understanding of the document hierarchy (e.g., see Example 2.1 below).

A physical XML document, as well as its dag representa-tion X 1 , appear below. Dashed arrows are used to represent implicit joins. Note that the actual data values in the doc-ument are not of interest in this paper, and hence are not included in the model.
Remark 1. ID-IDREF values may, in fact, give rise to a cyclic structure. We consider such documents (as well as cyclic schemas) later in Section 6.

A schema S =( r, V, E ) is a directed, rooted, labeled, acyclic graph that describes a set of valid document in-stances. Observe that our schemas may have multiple nodes labeled with the same label (as in, e.g., XSchema). However, one can also consider schemas which do not have recurring labels (as in DTDs) as a special case. As an example, con-sider schema S 1 . The schema S 1 has two occurrences of personalInfo . Note that multiple occurrences of the same tag give greater expressive power, e.g., by allowing us to state that the personalInfo of author and editor differ.
While in an XML document, the dag structure follows from implicit data joins, a schema may have two distinct sources for its dag structure. First, as in a document, multi-ple incoming edges may be used to reflect an implicit join of elements, e.g., which would be modeled by a DTD with ID and IDREF attributes. For example, consider the schema S .The author is located physically in the document un-der the bib tag. However, each article has IDREFs to each corresponding author .Thus, author has two incom-ing edges. A second source for multiple incoming edges is that a label may be used in multiple contexts . For example, in S 1 title has two incoming edges, since both a journal and an article each have a title .

To reflect these two types of nodes, we assume that there is a function type : V  X  X  join , mc } which associates each schema node with either join (to denote that it participates in an implicit join) or with mc (to denote that it is a multiple context node). To differentiate between these types of nodes in our figures, we place a rectangle around nodes of type join .
Remark 2. As a simplification, we associate each schema node with a single type. In reality a node might actually be used in multiple contexts and participate in an implicit join. This would not pose any technical difficulties, but would only add some notational clutter.

Finally, a query over an XML document is a directed, rooted, labeled, acyclic graph. Queries may contain edges of two different types, called child-edges and descendent-edges . Hence, we denote a query as Q ( r, V, E c ,E d )where E c E d are the child and descendent edges of Q , respectively. Intuitively, nodes with multiple incoming edges in a query correspond to joins over document subtrees, according to the implicit document joins.

Example 2.1. Consider, for example, the following two queries. Note that descendent edges are denoted with double lines. Query Q 1 asks for authors, along with pairs of their articles and Q 2 asks for articles with two authors. Both queries assume that the articles in the document are grouped by authors, whereas according to schema S 1 , authors are actually grouped by articles. In the absence of information about the hierarchy of the schema, a user might naturally use this formulation.

Remark 3. Throughout this paper, we always assume that a schema is given. It is also possible to self-correct a query with respect to a document, even if a schema is not explic-itly given. Any method of schema (or structural summary) extraction from an XML document, e.g., [4, 9], can be used for this purpose. See Section 6 for additional details.
When denoting document and query nodes we will use letters from the end of the alphabet, e.g., u , v , w and when denoting schema nodes, we will use letters from the begin-ning of the alphabet, e.g., a , b , c . As a shorthand notation, we use r ( X ), r ( Q )and r ( S ) to denote the root of X , Q and S respectively. Similarly, V ( X ), V ( Q )and V ( S )denotethe nodes of X , Q and S ,and E ( X ), E ( Q )and E ( S )denote the edges of X , Q and S .( E ( Q ) is the union of the set of child and descendent edges of Q .) We use l ( v ), where v is a node, to denote the label of v . We say that a document X is a valid instance of a schema S if there is a document validation mapping  X  : V ( X )  X  V ( S ) such that For example, X 1 is a valid instance of S 1 .

The semantics of a query Q are as expected. Thus, ap-plying a query Q to a document X results in the set of all mappings  X  of Q to X that satisfy the query constraints in the standard fashion (i.e., that map root to root, map labels correctly, map child-edges to parent-child pairs and map descendent edges to ancestor-descendent pairs).
Aquery Q is satisfiable with respect to a schema S if there is some valid instance of S for which Q returns a non-empty result. By considering our definition of a valid instance, we immediately derive that Q is satisfiable if and only if there is a query validation mapping  X  : V ( Q )  X  V ( S ) such that We use SatQ ( S ) to denote the (infinite) set of all queries that are satisfiable with respect to S .

Example 2.2. Observe that neither Q 1 nor Q 2 is in SatQ ( S For example, both queries requires an ( author , article ) child edge, which does not appear in S 1 . On the other hand, both of the following queries are in SatQ ( S 1 ).
It is sometimes convenient to consider a succinct version of a query, i.e., a query that is represented in a succinct fashion. Formally, a succinct version of a query is a four-tuple Q ( r, V, E c ,E d ), as before. In addition, the function type associates each node v with either join or mc .Thereisa simple translation from a succinct query to a standard query, as defined above. Intuitively, our translation simply creates as many copies of each mc -node, as it has incoming edges. Formally, in a top-down fashion (i.e., in reverse topological order), we iterate over each node v such that type ( v )= mc . Suppose that v has k incoming edges. Then, we replace v with k nodes v 1 ,..., v k . Each parent of v retains an edge with a single copy of v i . Each of the nodes v i has all the same children as v . 1
A query can have many succinct versions. For example, by takingaquery Q and associating each node with more than one incoming edge with join and all other nodes with mc ,we derive a succinct version. A succinct version of a query may also differ more significantly from the query. Thus, query Q 5 is a different succinct version of Q 1 .

For the remainder of this paper, unless otherwise stated, we only consider succinct versions of queries (i.e., queries with an associated type function), and will call these simply queries, for short. In our figures, we use rectangles to denote nodes of type join . Succinct versions of queries are useful when comparing queries, since queries will be compared by mean of a bijective mapping.
Suppose we are given a query Q and a schema S ,such that Q is not satisfiable with respect to S . Insuchacase, we would like to return a different query Q (or possibly several queries) such that Q is satisfiable with respect to S and Q is as similar as possible to Q . In order to find such aquery Q one must be able to quantify similarity between
Note that this process does not necessarily yield a tree, since only mc -nodes are duplicated. queries. However, how should such similarity be quantified? It would seem that there is no single  X  X orrect X  answer to this question. Instead, the best way to determine similarity may be highly dependent on the particular problem setting and additional information available.

We present a general framework, that can accommodate different methods of measuring query similarity. We will also discuss some particular instances of this framework that are of interest. However, we emphasize that our main contri-bution is the definition of the framework, and the efficient evaluation algorithms that can be instantiated with many different instances of our framework.

We will be using similarity mappings , i.e., mappings be-tween queries, to determine query similarity. Given such a mapping, we take into consideration three issues: (1) Given anode v in Q , how similar is v to a node in Q ?(2)Given an edge ( v , w )in Q , how similar the structural relationship defined by ( v , w ) is to that of a pair of nodes v , w in Q ? (3) Suppose that we can answer Questions 1 and 2. How can the various similarity values be aggregated together to determine a global similarity value? To answer our three questions, we formally present the notions of similarity map-pings, and of a relaxation framework . Consider queries Q and Q .A similarity mapping  X  from Q to Q is a mapping from V ( Q )to V ( Q )  X  X  X } that is bijective on V ( Q )  X  X  r ( Q ) } , i.e., every node in V ( Q ) { r ( Q ) } is in the image of exactly one node in Q .(The node r ( Q ) can be in the image of any number of nodes of V ( Q ), or of no nodes in V ( Q ).) In addition, we require that every edge of Q , that is not incident to r ( Q ), must be in the image of an edge of Q . Finally, we require similarity mappings to map connected portions of Q , i.e., for all non-root nodes v  X  V ( Q ), if  X  ( v ) =  X  ,then  X  ( u ) =  X  ,forsome parent u of v .
 A similarity mapping from Q to Q defines the nodes in Q that correspond to each node of Q . Observe that nodes in Q may be mapped to  X  , called the null node . The nodes mapped to  X  are, in a sense,  X  X eleted X  in the query Q ,since they have no corresponding node. Thus, both the nodes themselves, as well as the relationships between these nodes, are lost. This will be taken into account in our relaxation frameworks, presented below. Observe also that all nodes in Q , besides its root, must be in the image of  X  .This requirement is needed to ensure that (1) Q does not have any additional requirements, not emanating from Q and (2) Q has a node corresponding to the schema root, even if Q did not. The requirement of edges being in the image of edges follows from the same reasoning.

Example 3.1. Consider queries Q 1 and Q 3 . Let the nodes of Q 1 be v 1 ,..., v 7 and the nodes of Q 3 be u 1 ,..., u the node numbering is as in the figures). We define the similarity mappings  X  1 and  X  2 as follows: 2  X  = { ( v 1 , u 4 ) , ( v 2 , u 7 ) , ( v 3 ,  X  ) , ( v 4 , u }  X  = { ( v 1 , u 2 ) , ( v 2 , u 3 ) , ( v 3 , u 3 ) , ( v 4 } Observe that  X  1 maps nodes to nodes with similar labels (except email node v 3 , which is mapped to  X  ), but does not always map edges to edges. On the other hand,  X  2 does not
We use a set of pairs notation when writing mappings. necessarily map nodes according to their labels, however, it preserves most edges.
A relaxation framework is used to quantify the quality of a similarity mapping. Formally, a relaxation framework for aquery Q is a triple R (  X  , X  V , X  E )where We require  X  to be monotonic in the following sense. For any three rationals k , k and l ,if k  X  k then k  X  l  X  k  X 
We explain the intuitive meaning of the values { child , parent , desc , anc , none , undef } . Suppose we are given the queries Q ( r, V, E c ,E d )and Q ( r ,V ,E c ,E d ), and a similar-ity mapping  X  . We will use  X  E to determine how well the  X  -image of an edge ( v , w ) satisfies the relationship defined bytheedge( v , w ). Thus,  X  E will be called with  X  ( v ) second parameter, defined formally as: It is natural to have the value of  X  E be dependent both onthetypeofedge( v , w )andon  X  ( v )  X  ( w ) . Note that when  X  ( w ) = undef , then one of the nodes v or w are mapped to  X  (i.e., are  X  X eleted X  from Q ), whereas when  X  ( v )  X  ( w both nodes are mapped, but their image satisfies neither the parent-child nor the ancestor-descendent relationship.
We note that  X  V (respectively,  X  E ) may behave differently for different nodes (respectiv ely, edges). However, it often useful to define uniform functions that behave similarly, re-gardless of their first parameter. We demonstrate some ways to define a relaxation framework in the following examples.
Example 3.2. The purpose of  X  V is to determine the similarity between two query nodes. Depending on the ap-plication, different definitions of  X  V may be useful. Often  X  will be a function of the labels of its node parameters. For example,  X  V ( v , v ) can be defined simply as the characteris-tic function that returns 1 if v and v have the same label, and 0 otherwise. In addition,  X  V might impose some penalty (e.g., by returning a negative value) if v =  X  .Amoreso-phisticated definition of  X  V might take into consideration the similarity of the labels of v and v , using an (inverse of an) edit-distance or token-distance function, or might return a different value, depending on type ( v ). (See [7] for a survey of string comparison methods.) Given additional ontology information, such a sub-typing, one can define yet another function  X  V , in the spirit of the label relaxations of [1].
The edge-relaxing function  X  E is used to determine how closely a query edge ( v , w ) is satisfied by nodes with the re-and return 0 otherwise. Other useful definitions of  X  E might give different values depending on how similar the relation-way with certain query edges that are known in some way to be of particular importance.

Finally, we consider the binary operation  X  .Using  X  V and  X  E we can determine the similarity of individual portions of Q to similar units of Q . However, since Q may contain many nodes and edges, we will use  X  to aggregate together the individual values. As with the other components of a relaxation framework,  X  may be defined in various ways. For example, we can use ordinary addition, or the max function, as  X  . We can also use product as  X  if we are certain that  X 
V and  X  E always return non-negative values. (In this case, product is monotonic.) Example 3.3. We define a specific relaxation framework R 1 =(  X  1 , X  V 1 , X  E 1 ), that will be used later on. We choose  X  1 as ordinary addition, and  X  V 1 and  X  E 1 are defined as follows.

The edit distance e ( l 1 ,l 2 )ofstrings l 1 and l 2 is the number of insert, delete and replace operations needed to change l to l 2 (see [3] for a formal definition). Let v and v be nodes. | l | is the length of l i . Then, we define Intuitively,  X  V 1 gives a higher score to pairs of nodes with similar labels, and prefers the null node  X  over pairing v with a node that has a significantly different label.
We say that an edge ( v , w ) and a value exactly match if they express the exact same relationship (either child or descendent). We say that ( v , w )and almost match if ( v , w ) is a child edge and is desc or vice-versa. Now, we define  X  E 1 (( v , w ) , )= Thus,  X  E 1 prefers matching an edge to a null relationship, than matching to a pair of nodes with no relationship, and prefers, in general, closer matches of ( v , w )to .
Now, consider queries Q and Q , a similarity mapping  X  from Q to Q and a relaxation framework R .The score of  X  , denoted s (  X  ), is defined as Intuitively, the score of  X  represents the combined score of each node and each edge mapped (along with the penalty provided by  X  V and  X  E for the nodes and edges not mapped). Example 3.4. Recall similarity mappings  X  1 and  X  2 from Example 3.1 and the relaxation framework R 1 from Exam-ple 3.3. Then, s (  X  1 )=10 . 55 and s (  X  2 )=7 . 22. To see this, for  X  1 ,observethat Theotherscoreiscomputedsimilarly.
Now consider a query Q and a schema S . Our goal is to  X  X orrect X  Q , i.e., to find a query Q  X  SatQ ( S )that is as similar as possible to Q . For this purpose we use the score function. Formally, the similarity of Q and Q , written Sim ( Q, Q ), is defined as We use BestSim ( Q, S ) to denote the maximal similarity of any query in SatQ ( S )to Q , i.e., Finally, we use BestQueries ( Q, S )todenotethesetofall queries Q  X  SatQ ( S )forwhich Sim ( Q, Q ) is maximal, i.e., for which Sim ( Q, Q )= BestSim ( Q, S ). Depending on the definition of the relaxation framework, Q may or may not be in BestQueries ( Q, S ), when Q is satisfiable. For natural definitions of a relaxation framework, which give exact matchings higher grades, such as R 1 ,wehave BestQueries ( Q, S )= { Q } , whenever Q  X  SatQ ( S ). In this paper we are interested in the following problems. Problem 1 (Single Self-Correction). Given a query Q and schema S ,returnatriple ( Q , X , X  ) such that (1) Q  X  BestQueries ( Q, S ) ,(2)  X  is a similarity mapping with s (  X  )= Sim ( Q, Q ) , and (3)  X  is a query validation mapping from Q to S .

Problem 2 (Complete Self-Correction). Given a query Q and schema S ,returnalltriples ( Q , X , X  ) which satisfy the three conditions of the single self-correction prob-lem.
 Problem 3 (Top-k Self-Correction). Given a query Q and schema S ,return k triples ( Q , X , X  ) with the high-est values for s (  X  ) such that (1) Q  X  SatQ ( S ) ,(2)  X  is a similarity mapping with from Q to Q , and (3)  X  is a query validation mapping from Q to S .

Note that we are interested, not only in the query, but also in a similarity mapping and a query validation mapping. The similarity mapping  X  is important to provide the user with information as to how the new query corresponds to the query that she provided. The query validation mapping  X  can be used to understand the relationship between the new query Q and the schema.

Our goal is to solve each of these problems efficiently, i.e., in polynomial time. However, as the following theorem shows, this is not always possible.

Theorem 3.5. If Q is a directed acyclic graph, then the single self-correction problem is NP-hard.

Thus, Theorem 3.5 implies that none of the three prob-lems considered can be solved efficiently in the general case. Due to this problem, we focus on the case where Q is a tree. Therefore, unless otherwise stated, we will assume that all user queries are trees. In Section 6 we present a method to correct dag queries whose complexity depends on the exact structure of Q .

If Q is a tree, both the single self-correction problem and top-k self-correction problem (for a given constant k )can be solved in polynomial time. However, even if Q is a tree, BestQueries ( Q, S ) may sometimes be very large, or even exponential, in the size of Q and S . Therefore, polyno-mial time is unachievable for the complete self-correction problem and a different yardstick of complexity is needed when addressing this problem. To be precise, we sill use the complexity measure polynomial delay [11]. Formally, an algorithm is said to run in polynomial delay , if the delay be-tween two successive results is polynomial in the size of the input. In particular, this means that for any fixed k ,itis possible to return k results in polynomial time in the size of the input and k .

All three problems can be solved in a very similar fash-ion. We focus on the complete self-correction problem and present efficient algorithms for this problem. Later we dis-cuss the adaptations needed to these algorithms to solve the other two problems. We employ a two-phase approach to the complete self-correction problem. In this first phase (dis-cussed in Section 4) we first find mappings from the query Q to the schema S , that are in some sense maximal .Inthe second phase (Section 5) we use the mappings that we have found to create queries in BestQueries ( Q, S ).
In this section we deal with the first phase needed to solve our problems of interest. For this purpose, we adapt the no-tion of a similarity mapping to mappings of a query to a schema. These mappings will be called construction map-pings . We then show how to generate all maximum con-struction mappings efficiently.
Let Q be a query and S be a schema. A construction mapping  X  from Q to S is a mapping from V ( Q )to V ( S ) { X } . Similarly to before, we also require that construction mappings map connected portions of Q , i.e., for all non-root nodes v  X  V ( Q ), if  X  ( v ) =  X  ,then  X  ( u ) =  X  ,where u is the parent of v .(Node v has one parent, since Q is a tree, by assumption.) Unlike similarity mappings, construction mappings are not necessarily bijective.
 We extend the function a b to pairs of nodes in a schema S (and not in a query, as before). Formally, Note, however, that a b from Equation 2, may not be well defined, e.g., since it is possible for b to be both a child and a strict descendent of a , via different paths. To simplify the discussion and notation, we assume that this is not the case, i.e., there is a single relationship between any pair of nodes. Lifting this assumption does not increase the complexity of our algorithms.

Finally, the score of a construction mapping  X  is defined as in Equation 1.

Example 4.1. Consider query Q 1 and schema S 1 .Let the nodes of Q 1 be v 1 ,..., v 7 and the nodes of S 1 be a (where the numbering is as in the figures). We define the construction mappings  X  1 and  X  2 .  X  1 = { ( v 1 , a 5 ) , ( v 2 , a 8 ) , ( v 3 ,  X  ) , ( v 4  X  2 = { ( v 1 , a 3 ) , ( v 2 , a 4 ) , ( v 3 , a 4 )( v 4 , a When considering the relaxation framework R 1 ,wederive that s (  X  1 )=10 . 55 and s (  X  2 )=7 . 22, similarly to the scores of  X  1 and  X  2 . This similarity is not coincidental and will be discussed later on.

Notethatthesamescorewouldhavebederivedif  X  3 had mapped v 2 to a 9 , instead of to a 8 . In fact, one can show that exactly these two construction mappings from Q 1 to S 1 have the maximal possible score.
We present a dynamic programming algorithm to find all construction mappings that have maximal score. Our algo-rithm has two major stages. First, we fill a matrix M with information about maximum mappings. Second, we gener-ate all maximum construction mappings from this matrix.
The first stage of our algorithm appears in Figure 1. The algorithm FillMatrix receives as parameters a query Q , schema S and relaxation framework R . We start by creating amatrixofsize | V ( Q ) | by | V ( S )+1 | . Intuitively, there is a cell in the matrix for each pair of a query node and either a schema or null node.

The basic idea of the dynamic algorithm can be under-stood as follows. Consider a node v in Q , and the subtree Q of Q ,rootedat v . Now, consider a node a  X  V ( S )  X  X  X } .Our algorithm finds the maximal score of any construction map-ping from Q v to S that maps v to a . This value will be stored in a hash table H , that contains, for each child w of v ,theset of nodes W in V ( S )  X  X  X } to which w can be mapped, while achieving the score M [ v , a ] . grade .

The matrix M is filled in a bottom-up manner by ordering the nodes of Q according to their topological order. We note that special care has to be taken when mapping a node v to the value  X  , to ensure that all descendents of v are also mapped to  X  . This special case is dealt with in FillNull The remaining case, i.e., where v is mapped to a non-null node, is considered in FillCell . Note that the loop of Line 3 in FillCell is used to find best mappings for children w of v . The inner loop of Line 6 (in the same algorithm) iterates over all possible choices of mappings of w and finds schema nodes b for which a maximal score will be achieved. One can show several important properties of FillMatrix . To simplify these results we introduce some notation. We use BestMap | a ( Q, S ) to denote the set of construction map-pings from Q to S that have maximal scores, among those mappings that map r ( Q )to a . In addition, we use s  X  | to denote the score of the mappings in BestMap | a ( Q, S ). Finally, suppose that v  X  V ( Q )and a  X  V ( S )  X  X  X } . We define the set of mappings MatMaps M ( v , a )inthefol-lowing manner. If v is a leaf, then MatMaps M ( v , a )= { ( v , a ) } . Otherwise, let w 1 ,..., w n be the children of v .Let W 1 ,...,W n be the sets stored in M [ v , a ] . childMaps for each of these children, respectively. Then, MatMaps M ( v , a )isthe
FillCell ( Q, S, R, v , a , M ) 2
H X  createEmptyHash () 3 for each child w of v 4 do maxGrade  X  X  X  X  5 W  X  X  X  6 for each b in V ( S )  X  X  X } 8 if grade &gt; maxGrade 9 then maxGrade  X  grade 10 W  X  X  b } 11 elseif grade = maxGrade 12 then W  X  W  X  X  b } 13 H . insert ( w ,W ) 14 total  X  total  X  maxGrade 15
M [ v , a ] . grade  X  total 16 M [ v , a ] . childMaps  X  X  set of construction mappings Intuitively, each mapping in MatMaps M ( v , a )contains( v , a ), as well as a mapping from MatMaps M ( w i , b i ) for each child w of v , and each node b i in the corresponding set W i . We can now show the following results.

Theorem 4.2. Let Q be a query, S be a schema and R be a relaxation framework. Suppose that v  X  V ( Q ) and a V ( S )  X  X  X } .Let Q v be the subtree of Q rooted at v . Then, at the end of the execution of FillMatrix , the following hold:
Theorem 4.3. Let Q be a query with n nodes, S be a schema with m nodes, and R be a relaxation framework. Let f
V and f E be the complexity of evaluating  X  V and  X  E ,re-spectively. Then, FillMatrix runs in O ( nmf V + nm 2 f E
Recall that the goal of this section is to find all maxi-mum construction mappings from Q to S . According the Theorem 4.2, these can be found in the following man-ner: First, find the set of nodes a  X  V ( S )  X  X  X } for which M [ r ( Q ) , a ] . grade is maximal. Let A be this set of nodes. Then, the set of maximum construction mappings can be created by simply generating MatMaps M ( r ( Q ) , a ), for all a  X  A . In the following we discuss how to generate the set MatMaps M ( r ( Q ) , a ) efficiently, i.e., with polynomial delay.
As discussed earlier, there may be an exponential num-ber of maximum construction mappings. A simple bottom-up traversal of M that generates all maximum construction mappings would not return a single mapping, until all were generated. Instead, we present a recursive algorithm that generates all maximum construction mappings with polyno-mial delay between answers.

To achieve polynomial delay, we use a programming con-struct called an iterator (e.g., as in [5]). An iterator makes it possible to iterate over the results of an enumeration al-gorithm, and even pause the computation while retaining the internal state. Formally, an iterator is an object that operates on top of a specific execution of an enumeration al-gorithm. The iterator outputs each result of the underlying algorithm only upon an explicit next request.
 Consider an enumeration algorithm E and an input x . An iterator I over E ( x )isconstructed by the operation I  X  new Iterator ( E, x ). Suppose that E ( x )enumerates { e 1 ,...,e m } . When executing I. next () for the first time, the execution of E ( x ) starts and continues until the first re-sult e 1 is generated. Specifically, the command output ( Y ) in the execution of E ( x ) returns both the value of Y and the control of the execution to the procedure that called I. next (). Note that the value of Y is returned to the user (i.e., printed) only when output ( Y ) is executed by the out-ermost procedure. When I. next () is executed again, the execution of E ( x ) is resumed until e 2 is generated and so on. Hence, the elements e 1 ,...,e m are enumerated by re-peatedly executing m times the command I. next (). The cost of executing these m calls to I. next () is the total cost of executing E ( x ).

The operation I. hasNext () returns true if there are more elements to be generated; otherwise, it returns false .Note that I can implement hasNext () by actually continuing the execution of E ( x ) to check if another result is generated. For our purpose, we use two enumeration algorithms, namely BuildMapping and Combine (Figure 2), which call one an-other recursively. In each case, recursive calls are performed using the iterator mechanism to ensure polynomial delay. The algorithm BuildMapping is called with nodes v , w  X  V ( Q )and a  X  V ( S )  X  X  X } ,where w is a child of v . BuildMap-ping returns all mappings in MatMaps M ( w , b ), for all b M [ v , a ] . childMaps . getValue ( w ). In other words, the al-gorithm BuildMapping returns sub-mappings of the set MatMaps M ( v , a ), that map the subtree Q w .

The algorithm Combine is called with query node v ,schema node a , and a subset W of the children of v . Combine re-turns sub-mappings of the set MatMaps M ( v , a ), that map
BuildMapping ( v , a , w , M ) 1 H X  X  [ v , a ] . childMaps 2 for each b in H. getValue ( w ) 3 do C  X  new Iterator ( Combine , 4 while C. hasNext () 5 do  X   X  C. next () 6 output (  X   X  X  w , b } )
Combine ( v , a ,W, M ) 10 output (  X   X   X  ) Figure 2: Recursive procedures that produce the construction mappings. all of the subtrees Q w ,for w  X  W . Therefore, if W is empty, Combine returns the empty mapping  X   X  . Otherwise, using BuildMapping , the mappings for an arbitrary child w  X  W are generated. Each of these mappings are combined with all possible mappings for the remaining children in W (gen-erated by the recursive call to Combine in Line 7). We can now show the following results.

Theorem 4.4. Let Q be a query, S be a schema and R be a relaxation framework. Let M be the result of cal ling FillMatrix ( Q, S, R ) .Let v be a node in Q and a be a node in S ,andlet W be the set of all children of v .Let  X  be the set of mappings returned by Combine ( v , a ,W, M ) .Then,
Using Theorems 4.2 and 4.4 we immediately derive a method to generate the maximum mappings of Q to S .Itremains to show that Combine runs efficiently.

Theorem 4.5. Combine runs in polynomial delay, with a delay of | V ( Q ) | between each successive output.
In the previous section, we showed how to generate all maximum construction mappings for a query Q ,schema S and relaxation framework R . In this section, we show how such mappings can guide us in creating satisfiable queries. In fact, the query Q  X  that we will create from  X  will have the same similarity score with respect to Q ,as  X  , i.e., s (  X  )= Sim ( Q, Q  X  ).

Let  X  be a construction mapping from Q to S .Wewish to create the query Q  X  ( r  X  ,V  X  ,E  X  c ,E  X  d ), corresponding to  X  . Since we want Q  X  to be satisfiable with respect to S ,we start by creating the root node r  X  with the same label as r ( S ). In addition, we will add as nodes in V  X  the  X  -image of each node in Q . Formally, for each node v  X  Q such that  X  ( v ) =  X  and  X  ( v ) = r ( S ), we add a distinct node v V  X  ,withlabel l (  X  ( v )).

We have now defined the query nodes, and must add in query edges. These will be created quite naturally from the schema. To aid in constructing the query edges, we define the function copy ( v ) in the following manner. Now, we define E  X  c and E  X  d as follows: where ( v , w )  X  E ( Q )and copy ( v ) =  X  , copy ( w ) =
Next, we define the value of the function type for each node v  X   X  V  X  , as follows: type ( v  X  ):= Note that copy  X  1 ( v  X  ) is well defined for any node with more than one parent, since such a node cannot be the root (and copy is injective on all nodes other than the root).
At this point, it is possible that the graph derived is not connected. To rectify this, for each node v  X  (other than the root) that has no parents, we add the edge ( r  X  , v  X  )to E Example 5.1. Consider the construction mapping  X  1 from Q 1 to S 1 in Example 4.1. Applying the process described above to this mapping will yield the query Q 3 .Notethat author node u 4 will have type join ,since copy  X  1 ( u 4 and  X  1 ( v 1 )= a 5 ,whichisanodeoftype join .
 We can now show the main results of this section.

Theorem 5.2. Let Q be a query, S be a schema and  X  be a construction mapping. Then, s (  X  )  X  Sim ( Q, Q  X  Moreover, if  X  is a maximum construction mapping, then s (  X  )= Sim ( Q, Q  X  ) .
 Theorem 5.3. Let Q be a query, S be a schema and Q  X  SatQ ( S ) . Suppose that there exists a similarity mapping from Q to Q .Let  X  be the similarity mapping from Q to Q for which s (  X  ) is maximal. Then, there exists a construction mapping  X  from Q to S such that s (  X  )= s (  X  ) .
Using Theorems 4.2, 5.2 and 5.3 we can solve the complete self-correction problem by simply finding all maximum con-struction mappings (as described in Section 4), and then using these to create satisfiable queries (as described in this section). Moreover, each query Q  X  constructed in this fash-ion should be returned with the similarity mapping copy , and the schema validation mapping in which each node v  X  is mapped to  X  ( v ).

Example 5.4. Consider again query Q 1 ,schema S 1 and relaxation framework R 1 . There are two maximum con-struction mappings from Q 1 to S 1 , as stated in Example 4.1. Thus, when solving the complete self-correction problem, two queries will be returned: Q 3 , and a query identical to Q ,exceptthatithas fname instead of lname .
 TheSingleSelf-CorrectionandTop-k Self-Correction Problems. Up until now we focused on the complete self-correction problem. The single self-correction problem can be solved in polynomial time by simply stopping the algo-rithm Combine after the first answer is returned. (Actually, both FillMatrix and Combine can be simplified for this case, since it is sufficient to store a single schema node for each child node, instead of an entire set W .)
The top-k self-correction problem can be solved using a variation of the algorithms for the complete self-correction problem. The main changes that must be made are as fol-lows. First, the matrix M should store at each cell the k -best mappings for each child (instead of only the best map-pings). Second, Combine should be modified to return the mappings in decreasing score order. Acyclic Query Input. According to Theorem 3.5, all problems considered in this paper are intractable if the user input is a dag query and not a tree query. On the other hand, self-correcting such queries is clearly still of interest. There-fore, we suggest the following process to self-correct a dag query Q .First, expand the dag query to derive a tree query Q
T in the standard fashion. (Basically, in reverse topolog-ical order, we replace each node v with k parents, with k copies of v .) Second, we self-correct the tree query Q T ing the process described in the previous sections. Third, as a post-processing step, we can collapse each output Q T of our self-correction process by uniting nodes that emanate from duplicated versions of the same nodes in Q (and for which all descendents are mapped identically). Due to lack of space we do not describe this process in detail, but rather, demonstrate with an example.
 Example 6.1. Recall query Q 2 from Example 2.1. Since Q 2 is a dag, we can apply the process described above to self-correct Q 2 .First,weexpand Q 2 to derive Q 6 .Observe that the nodes numbered 4 and 5 have been added to this graph. Then, we self-correct Q 6 and derive query Q 7 (as well as a queries identical to Q 7 , but with fname instead of occurences of lname ). In Q 7 the nodes numbered 2 and 2 eminate from duplicated copies 4 and 4 . Their subgraphs stem from identical construction mappings of their children. The same is the case for nodes 3 and 3 .Hence,wecan collapse together each of these pairs of nodes, to derive the self-corrected result Q 4 from Example 2.2.

Note that the complexity of the self-correction process depends on how  X  X lose X  the user query Q istoatree. Inthe worst case, expanding Q can incur an exponential blowup. Tree Query Output. Even when the user provides a tree query, the output of our self-correction process may not be a tree. Many methods for query optimization, presented in the past, apply only to tree queries. Thus, we might want to apply our ideas within a system that requires all queries to be of tree form. In this case, we must avoid self-correcting a tree query into a dag. Fortunately, it is not difficult to achieve this, by changing the range of values for the second argument of  X  E . Tobeexact,wemustallowonly  X  { child , desc , undef , none } (where none is assigned whenever child , desc and undef are inapplicable). The remainder of the algorithms and query construction can proceed as described. It is not difficult to prove that the queries constructed in this fashion will be trees.
 Cyclic Schemas. In this paper, we restricted our schemas (and hence, our documents) to be acyclic. In practice, it may also be of interest to consider cyclic schemas.
If we allow queries to be cyclic, then a completely new strategy must be devised for self-correction, since our ex-pansion process (described above) is applicable only to dag queries. On the other hand, suppose that user queries are acyclic, but the schema is cyclic. All our algorithms can be applied in this scenario without change, but the result of our query construction may be cyclic. If this is tolerable, then our algorithms can be applied as is.
 Queries with Selections. Our queries do not contain any data value selections. However, real queries are likely to con-tain selections. We propose to self-correct such queries by simply to ignoring the selections during the self-correction process, and restoring them at the end.

An alternative would be to augment the schema with in-formation about the data values appearing within the con-text of each label. Then, the relaxation framework can take into consideration data values in much the same fashion as it considers labels. This method rather hazardous, however. Consider the query Q 8 ,andtheschema S 1 .
 When ignoring the selection, we derive the query Q SatQ ( S 1 ). However, suppose we know (using our augmented data structure) that the word Smith never appears in an author , but may appear in an editor . Should the query Q 8 be corrected to Q 9 , in this case? The answer to this question is not clear. On the one hand, leaving Q 8 as is yields an unsatisfiable query. On the other hand, we believe that the query Q 8 should return an empty answer, since its structure is satisfied, yet there are no author s named Smith. In such cases, correcting only t he structural errors seems to be a superior approach.
 Schema Variations. In this paper, we assumed a simple schema structure. It is also of interest to consider schemas that involve regular expressions. In general, determining satisfiability over such schemas is already NP-hard [10, 15]. Hence, we cannot hope to find an efficient method for self-correcting queries. Figure 3: Time to fill matrix, as a function of the query size.

We also note that we can self-correct queries with respect to a document, and not only with respect to a schema. This is possible, since documents and schemas are modeled in the same fashion. Observe that performing our self-correction over a document, is actually similar to computing the set of all maximal answers with respect to a query.
In the previous sections we have shown that our algo-rithms are theoretically efficient. In this section we show that our algorithms run quickly in practice, and are scal-able to large queries and schemas. We focus, in particular, on FillMatrix and Combine , which create the maximum construction mappings. Translating each such mapping into a query is obviously a speedy process. All experiments were run on a personal computer with 2.4GHz processor speed and 256MB of RAM.

First, we consider the time required to initialize the ma-trix M , i.e., the runtime of FillMatrix . We generated three random schemas with 200 nodes (that differed in the number of edges), and random queries with progressively more nodes. For each query, we calculated the amount of time to run FillMatrix . The result of this experiment ap-pears in Figure 3. A similar trend in runtime appears when the query remains constant and the schema is progressively increased. Due to lack of space, we omit this result.
Now, we consider the delay between returning successive answers by Combine . The average delay observed was usu-ally very small (about 6 milliseconds), so we focus instead on the maximum delay between answers. Once again, we gener-ated a random schema with 200 nodes, and random queries with progressively more nodes. For each query, we calcu-lated the maximum time between each of the first 100 suc-cessive answers. The maximum delay appears in Figure 4. Observe that the maximum delay is consistently proportion-ate to the number of query nodes, as proven in Theorem 4.5.
The above experiments show that our algorithms are ef-ficient. We leave as future work a thorough case study to examine which instantiations of a relaxation framework re-turn the  X  X est X  query corrections.
We have presented a general fra mework for self-correcting queries. Algorithms that correct queries using this frame-work were presented. These algorithms are shown to be efficient, both theoretically and practically.
 Figure 4: Maximum delay between answers, as a function of the query size.

Important future work includes user case studies to de-termine effective instantiations of our relaxation framework. Another related problem of interest is performing query ex-pansion for XML queries.
