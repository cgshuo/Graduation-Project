 1. Introduction
Nowadays software developers have to face incessant technological challenges to achieve more efficient sys-tems. Although these new technologies could be used when systems are built from scratch, more frequently they must be applied where existing systems have to be adapted, evolved or integrated with others. All aspects of any current system: database systems and applications. On many occasions, existing databases must be adapted for several reasons (i.e. changes in business procedure, need of open-environments  X  such as
Internet-integration). For this reason, a framework allowing these adaptations to be realized without jeopar-dizing data or schema integrity would be a highly valuable tool.

In this paper we propose MeDEA ,a Me tamodel-based D atabase E volution A rchitecture for managing evo-lution when all the components of the database (conceptual schema, logical schema and extension) are avail-explained in its entirety and in a general way independently of the specific application context. MeDEA pro-vides a general framework which makes it feasible to handle changes within the different phases of the data-base life cycle, from early design stages to exploitation and maintenance, so that consistency among different database design levels is kept.

In order to do this, different kinds of models, at different levels of abstraction, must be managed and changes performed in a model must be automatically propagated to the others. One way of tackling this issue is to ensure the traceability of the translation process between levels. However, there is no agreement about which artifacts and mechanisms are needed for assuring traceability [29,36] .

The way in which we propose to achieve traceability is making use of a specific translation component in which information related with the translation process is explicitly stored. The knowledge stored in this com-ponent avoids having to apply the translation algorithm from scratch when an evolution is performed. The idea of using an explicit component to store the elements related with the translation process and the way in which this knowledge is used during the database evolution process represent a significant contribution of our work. Furthermore, within our proposal, when an evolution process is carried out, the data are also modified to accommodate them to the new model. This fact allows us to achieve the  X  X ncremental consistency X  proposed as a desirable feature of transformation frameworks such as MDA [18] .

A metamodeling approach [12,22] has been followed for the definition of MeDEA . Within this setting, three metamodels are considered which capture the conceptual, logical and translation modeling knowledge.
We have chosen this approach because it allows modeling knowledge to be represented and because it has been proven that it facilitates the definition of data model translations [22] . The adoption of a metamodel-ing approach brings to our architecture the property of being independent of any particular modeling tech-nique. However, in order to clarify the way the architecture works we will be considering a particular example, and for this reason some specific techniques must be established. For this example, we have chosen two widely accepted standard modeling languages: the Entity-Relationship Model at the conceptual level and the relational model at the logical level. So as to show a particular application of MeDEA , we present a current Oracle implementation. It should be noted that we have chosen these specific models and imple-mentation only with the aim of illustrating our architecture. However, MeDEA is of general applicability and therefore can also be applied to other approaches (UML, object-oriented models, XML, etc.). For instance, in [8] we have applied MeDEA to the case of UML at the conceptual level and XML at the logical level.

The paper is organized as follows. In the following section the database evolution issue is described. Section 3 is devoted to presenting MeDEA , explaining its structure and its way of working. In order to clarify the way and outline future work. 2. The database evolution issue
There is a consensus about the process to be followed in order to develop a database system. Firstly, the application requirements are analyzed giving rise to a conceptual database schema S sented by means of a modeling formalism such as (Extended) Entity-Relationship or UML. Secondly, the con-ceptual schema is translated into a logical database schema S object-relational schema. Finally, the logical schema is implemented by means of a DBMS and the database is then populated to create a consistent database state r (see left branch of Fig. 1 a).

Once the database system is developed, or even during the development process itself, various reasons (changes in the environment requirements [15,33] , detection of deficiencies in the performance [17] , decision to migrate to a new platform [28] , etc.) can require modifications to be made to the database. These changes can be managed preserving older versions of the schemas (schema versioning according to [30] ) or not (schema evolution [30] ). In this paper, we tackle the database evolution issue using a schema evolution approach, so that we consider that only one version of the database is maintained.

The changes to be performed can imply modifications within different elements of the development process: conceptual schema S C , logical schema S L or database state r . In any case, these modifications must be prop-agated to the rest of the artifacts. Depending on the case, a forward or a backward database maintenance strategy must be followed [16] . We are going to suppose that the changes are performed in the conceptual schema so that a forward strategy is followed. The application of our proposal in a context in which forward and backward strategies are considered remains an ongoing project.

Summing up, the standard forward evolution issue (see Fig. 1 a) can be stated in a general way rephras-ing the ideas explained in [33] as follows. For various reasons the conceptual schema S erating a new conceptual schema S 0 C . These changes must be automatically propagated down to the logical schema and its population. That is, the logical schema S L logical representation S 0 L and the database state r has to be mapped into a new database state r 0 consistent with S 0 L .

The changes to be performed in the conceptual database schema in order to carry out the desired evolution can be expressed by means of schema transformations [17] . A schema transformation accomplishes modifica-tions in the structure of the database and maps the population of the source schema into an allowable pop-ulation of the resultant schema [4,17] .

Within this context the challenge is to keep the consistency between the different artifacts when a concep-tual database evolution occurs. In order to do this, our proposal is to store knowledge about the translation process explicitly in a component, which we will call translation base , in the same way that the conceptual, logical and extensional information is stored, giving rise to an enhanced forward database evolution proposal (see Fig. 1 b). The aim of this component is to store explicit information about the way in which specific con-ceptual elements are translated into logical ones.

We think that the consideration, within the database evolution issue, of our proposal of translation base brings several advantages. On the one hand, this component ensures the traceability of the translation process, which is established as a desirable feature of transformations [18] and included as such, for instance, in the
QVT request for proposals [27] . Besides, this component allows the extensional changes to be analyzed in terms of conceptual changes so that, for example, conceptual notions such as relationship or specialization
Finally, the knowledge stored in the translation base avoids having to recalculate the logical elements that result from the conceptual elements that have not been modified, it being unnecessary to apply once again the translation algorithm from scratch. This is important not only for avoiding waste of computational resources, but also because the DBA or data designer has to make decisions only in relation to the modified elements. 3. MeDEA : a database evolution architecture
As an application of the database evolution approach described in the previous section, in this paper we propose MeDEA as a database evolution architecture. MeDEA aims at providing a general framework which makes it feasible to manage database evolution following a forward maintenance strategy. The more related with the translation process.

In order to explain the architecture we proceed in the following way. Firstly we will describe the different components that shape MeDEA (Section 3.1 ), and next we will present the way in which it comes into play (Section 3.2 ). 3.1. The structure of MeDEA
The architecture is configured making use of a structural artifact that consists of three components: a schema, an information base and a processor [14] . The schema defines all the knowledge relevant to the sys-tem, the base describes the specific objects perceived in the Universe of Discourse, and the processor receives messages reporting the occurrence of events in the environment. The inspiration for the way in which we bring four times in order to store, respectively, the conceptual modeling knowledge, the translation process, the log-ical modeling knowledge and the extension. In the three former cases, given the nature of the stored informa-tion, we decided to follow a metamodeling approach, whereas a modeling approach was followed with regard to the extensional information. The resulting components as well as the way in which they are related appear in Fig. 2 . The name of each one of these components has been adapted in order to capture the type of knowl-edge that they store.

It must be noted that three different abstraction levels are involved in the architecture. On the one hand, the (meta-)schemas of the three former components are situated at the most abstract level (metamodel layer according to [35] ) and, on the other hand, the information base which stores the population of the database [35] .

The conceptual component captures machine-independent knowledge of the real world. For instance, in the case of database evolution, this component could deal with entity-relationship schemas or with UML class diagrams modeling the domain. The logical component captures tool X  X ndependent knowledge describing the data structures in an abstract way. In database evolution, this component could deal with schemas from the (object-)relational model, as for instance by means of standard SQL, or with XML schemas. The exten-sional component captures tool dependent knowledge using the implementation language. In databases, it could deal with the specific database in question, populated with data, and expressed in the SQL of the DBMS of choice or in textual XML documents conforming to an XML schema.

Let us note that, in Fig. 2 , the logical database schema is surrounded with both the information base and schema symbols. This is because the logical database schema can be seen as the information base of the logical component (as we have explained) or as the schema of the extensional component. For this reason two different elements of our architecture store the same information. This fact obliges us to define some rules, called correspondence rules (in the same sense as in [20] ). These rules govern the correspondence between the elements of each one of the two components (see Section 3.2 ).

A more detailed description of the translation component is worthwhile as this is the novelty of our pro-posal. The aim of the translation component is to store all the information necessary to enable any change per-formed in the conceptual database schema to be automatically reflected in the logical schema. In order to achieve this goal, we propose several changes to the traditional way in which conceptual schemas are trans-lated into logical schemas.

Usually this transformation process consists of applying a set of transformation rules to a conceptual schema in order to obtain a logical one. In the literature, there is a multitude of sources where sets of trans-formation rules are presented (see [13,25] ). However, within MeDEA the transformation rules are defined in a particular way giving rise to a different translation algorithm . When this algorithm is applied to a model, it produces not only another model (as usual) but also a set of elementary translations stored in the translation component.
 idea is that a translation rule not only specifies how the conceptual elements are translated into logical ele-ments but also the process to be followed to store in the translation component the trace of the translation.
Our proposal is that this trace gathers the applied rule together with its effects on the conceptual and logical schemas. In order to store the effects of each rule we introduce the notion of elementary translation defined as the smallest piece of information reflecting the correspondence between a conceptual element and a logical one. In this way the effect of the application of a rule is stored by means of a set of elementary translations. The notions introduced above allow us to propose a translation metamodel pattern which appears in Fig. 3 .
This pattern shows that the translation component stores the translation rules applied to the conceptual schema together with the set of elementary translations describing which conceptual elements have been trans-lated into which logical ones. This pattern has several variation points which have been specified by using the conform extension to UML for developing generic models.

The variation points of this pattern must be determined when the architecture is applied to a specific evo-lution setting. In particular, the specific conceptual and logical elements of the conceptual and logical meta-models must be fixed as well as the types of translation rules and elementary translations considered (see
Section 4 ). 3.2. The way of working of MeDEA
As we have explained previously, in order to develop a database system, firstly a conceptual database schema is designed which has to be translated into a logical database schema following a translation algo-rithm. According to our proposal, the application of a translation algorithm implies the execution of a set ones, (2) the logical elements of the logical schema and (3) the extensional schema.

In general, different translation rules can be applied for a conceptual element. In our approach, the trans-lation rule to be applied can be chosen by the DBA or data designer. In this way, the translation process for each translated element consists of five steps: Step (b): The translation rule selected in step (a) is stored in the translation base.

Step (c): The translation rule is applied. Several conceptual elements can be involved in the translation pro-
Step (d): For each conceptual element translated into a logical element an elementary translation is added to
Step (e): The correspondence rules are applied in order to determine the schema of the extensional
Steps (b) and (d) are not included in the traditional translation proposals, and they are the steps that guar-antee the traceability of the process. Once the translation algorithm is applied, the database can be used and, in particular, the extensional schema can be populated.

For various reasons, the data structure may need to be changed. In this case, the data designer must issue the appropriate evolution transformations to the conceptual schema. When an evolution occurs the processors of the architecture come into play in order to keep the consistency among the different components.
Firstly, the conceptual processor reacts to external events received from the environment. Within our archi-tecture we consider two types of external events, (1) those that perform a modification of the conceptual schema and (2) those that change the translation rule applied to an instance of the initial conceptual schema during the translation process. Each one of these types is handled in a different way.

With regard to (1) the external events performing a change in the conceptual schema, these are defined as a set of conceptual transformations. We propose to define this set taking into account the conceptual metamodel so that this set is a set of model transformations (adding, deleting or modifying elements of the conceptual schema). We propose to classify the transformations into primitive (which cannot be defined as a composition of the others) and compound transformations. In this respect, it is important to note that each transformation would imply not only schema modifications but also database extension changes.

In a context in which the database extension would not have to be considered, every transformation per-forming a schema modification would be a compound transformation since every modification could be defined as a composition of transformations deleting the schema elements to be modified and transformations creating the new elements. This is not suitable in a context such as ours, in which schema changes must be propagated to the extension, since the deletion of a schema element would imply the elimination of its instances, which could not be recovered.

Each event performing a conceptual schema modification is handled by the conceptual processor which formation is executed by the conceptual processor performing the modification of the conceptual database schema according to the semantics of the transformation.

With regard to (2) the external events changing the applied translation rule, these are also handled by the conceptual processor but the change does not modify the conceptual schema so that they are directly issued to the translation processor.

The modifications requested by the DBA or data designer by means of external events must be propagated to the rest of the components so that their stored information must be appropriately changed. As for the trans-lation and logical components, the approach is the same as that in the conceptual one. A set of translation transformations and a set of logical transformations are defined taking into account the corresponding metamodels.

The conceptual changes are propagated to the translation and logical components by means of propagation rules . Each one of these rules determines the translation and logical transformations that must be performed by the corresponding processors. Afterwards, the logical changes are propagated to the extensional compo-nent by means of the correspondence rules .

The approach followed in order to specify the propagation and the correspondence rules is the same. Both have to determine the changes to be performed in some elements as a result of a previous event. We have con-sidered that this pattern of action can be easily specified by means of an Event X  X ondition X  X ction (ECA) rule [13] adapting appropriately the meaning of each one of its components.

Propagation rules. As for the propagation rules, the meaning of their components is the following: 1. The event that triggers the rule: this is a conceptual transformation. 2. The condition that determines whether the rule action should be executed: this is expressed in terms of the conceptual elements involved in the transformation and in terms of the applied translation rules. 3. The action : the translation and logical transformations that must be performed are determined.
The propagation rules must be defined in such a way that, for each conceptual transformation, the prop-agation rules to be executed are determined univocally. When a conceptual change is issued, the propagation rules whose event matches with the conceptual transformation and for which the condition of the rule is true are searched. In the action part of the ECA rules, the changes in the translation base and the logical schema are made.

By means of the execution of a propagation rule, the consistency between the conceptual and logical com-ponents is kept and the translation base is updated in order to reflect the new trace of the translation process after the evolution. In this way, the translation base now reflects the correspondence between the new concep-tual and logical schemas according to the translation rules selected by the DBA or data designer. The condi-tions of the propagation rules (and the conditions of the correspondence rules which are explained later) are carefully designed in order to ensure that the changes performed do not interfere with each other.
Correspondence rules. Regarding the correspondence rules, the meaning of their components is the following: 1. The event that triggers the rule: this is a logical transformation. 2. The condition that determines whether the rule action should be executed: this is expressed in terms of the logical elements involved in the transformation. 3. The action : this is the set of procedures which generate SQL sentences that change the extensional schema and the data in a consistent way.

Like the propagation rules, the correspondence rules must be defined in such a way that, for each logical transformation, the correspondence rules to be executed are determined univocally. In the action part of the
ECA rules, the changes in the schema of the database and in its extension are made. In particular, the exten-sion modifications are performed by data load procedures . Each data load procedure has a precondition asso-ciated to it which states the circumstances in which it can be applied. In this respect, the main issue is that whenever a data load is used in an ECA rule, the condition of the ECA rule must ensure that the precondition of the data load holds.

It must be noted that this is the only case in which the processor changes not only the information base but also the schema of the component. But this is not surprising since this component is at one level of abstraction lower than the others so that the schema is a model whereas in the other cases they are metamodels (which are not changed in our proposed architecture).

Definition of evolution architecture instances. The evolution architecture we have defined is generic in the sense that its definition is independent of the particular languages that will be used in each one of the levels of abstraction involved (conceptual, logical and physical). This feature has been achieved by including a meta-model level which allows the architecture to be independent of specific modeling languages. The artifacts to be used in each component of the architecture must be determined in order to apply the architecture to a specific when the different generic elements of the architecture are settled giving rise to a particular evolution framework.

In order to determine an evolution architecture instance nine artifacts must be established: 1. The conceptual metamodel of the chosen conceptual modeling language. 2. The translation metamodel which follows the proposed translation metamodel pattern. 3. The logical metamodel of the chosen logical modeling language. 4. The translation algorithm which translates a conceptual model to a logical one. 5. The set of conceptual transformations for evolving the conceptual schema. 6. The set of translation transformations for evolving the translation base. 7. The set of logical transformations for evolving the logical schema. 8. The set of propagation rules from the conceptual schema to the logical schema, through the translation base. 9. The set of correspondence rules between the logical schema and the database state.

Note that the conceptual and logical transformations establish not only the syntax of the transformation (the structural mapping) but also its semantics (the instance mapping). For this reason, in the same way as determines the way in which a (conceptual or logical, respectively) source schema is transformed into another schema, and the second mapping determines the way in which any instance of a source schema is transformed into an instance of the resultant schema.

In the next section, an example of an evolution architecture instance is given, so that all the nine artifacts are established. 4. Case study: EER and relational models
As we have said previously, the architecture has been developed with the property of being independent of any particular modeling technique, by means of the adoption of a metamodeling approach. However, in order to clarify the way the architecture works we will be considering a particular example, and for this reason some specific techniques must be established. For this example, we have chosen the most common techniques in the context of the database field: an enhanced entity-relationship (EER) model as the conceptual modeling tech-nique and the relational model as the logical modeling technique. Another example of an application of MeDEA can be found in [8] , where UML Class Diagram is used as conceptual modeling technique and XML Schema is used as logical modeling technique.

In this section, we present the particular artifacts that shape the evolution architecture instance with regard to the EER and relational models. Previously we introduce an example to which we will apply this architecture instance and that allows us to explain the several artifacts more easily. 4.1. Running example
In order to illustrate an example of database evolution, we will use the schema of Fig. 4 a as the EER schema, which has been obtained combining different examples included in [19] . In this example, entity types, relationship types and attributes are represented, respectively, by rectangles, diamonds and ovals. This schema represents a company where it is perceived that there are employees and projects. Furthermore, the employees can be administrative staff (working for projects or auditing projects).

The proposed example of EER schema has been translated into a relational model (see Fig. 4 b). Since there are different suitable translation rules, the DBA or data designer may choose the translation rules which are applied to each element type of the EER schema. For example, we suppose that the DBA has chosen to trans-late all the 1 n relationships types into foreign keys (represented by means of arrows) and the ISA hierar-chies into a relation schema for each entity type. 4.2. Conceptual, translation and logical metamodels For this case study, we have developed the different necessary metamodels following the guidelines of the
Noesis Metamodeling Technique [11] . This technique provides a full detailed, structured definition of what a metamodel must be, based on a central notion of  X  X oncept X . In particular, the Noesis technique indicates that every metamodel must include a graphical representation of the main concepts (namely a support ), and pro-vides a specific graphical notation. However, in this paper, for the sake of understandability, we use a UML notation for the diagrammatic part of the metamodels. Furthermore, we have included only the essential com-ponents of each metamodel.

The conceptual metamodel representing the EER model is shown in Fig. 5 . It is worth noting several aspects of this metamodel. The metamodel includes a concept called IsaSet , which is used to refer to a set of ISA relationships that follows the same criterion of specialization and that shares the same  X  X arent X . This last property is considered a  X  X ocal constraint X  in the Noesis Technique, and its expression using OCL as con-straint language can be seen in Table 1 . A similar notion to IsaSet has been included in the recent UML 2.0 specification [35] . Furthermore, the metamodel includes the concept of IsaHierarchy , which refers to a set of enforced by the constraints in Table 1 .

The translation metamodel is shown in Fig. 6 . This metamodel follows the pattern of translation metamod-el we have described in Section 3.1 , fixing the variation points to the particular case we are presenting as an example. In particular, the conceptual and logical elements have been fixed as EER and enhanced relational elements, respectively. With regard to the translation rules and elementary translations types, these will be explained in the next subsection where the translation algorithm is described.

Lastly, the logical metamodel representing the enhanced relational model is shown in Fig. 7 . This metamod-el conceptualizes the different elements that conform to a relational model [13] . Furthermore, it includes the notion of check constraint that is not included in the formal definition of relational model but that is implemented in many database management systems. The reason for including this concept is that several conceptual elements are translated into a check constraint, for example, the attributes of covering and disjoint mented in the extensional component. 4.3. Translation algorithm
In Fig. 8 , the translation algorithm from EER to enhanced relational is shown. This algorithm has been determined following the translation algorithm proposed in [13] . As architect designers, we have decided ples of translation rules are shown in Table 2 .

For example, in Fig. 9 the algorithm of the RelSchemaPerEntityType01 translation rule for ISA hierarchies is shown. This rule creates a relation schema for each entity type of the hierarchy. Among the different actions executed by this rule we want to highlight the addition of elementary translations in order to store a trace of the translation. They appear explicitly as AddElementaryTranslation or they are included in the application of the translation rule for an EER element. As we have mentioned previously, the elementary translations can be of different types. The most representative types of elementary translations are shown in Table 3 .
For example, we can apply the translation algorithm EER2Relational to the EER schema of Fig. 4 a. Let us suppose that the following rules are chosen during the execution of the algorithm: EntityType01 for entity types, NotReifyRelationshipType01 for relationship types and RelSchemaPerEntityType01 for ISA hierarchies.
Then the algorithm generates a set of elementary translations (regarding the example the most relevant of them are shown in Table 4 ) as well as the relational model of Fig. 4 b. 4.4. Conceptual, translation and logical transformations
In order to carry out the EER schema evolution we have defined a family of conceptual transformations, taking into account other transformations proposed in the literature [1,32] (see Table 5 ). The full relation of conceptual transformations appears in the Appendix . A formal proof that ensures the completeness and soundness of this relation remains an open issue. We have developed similar tasks in a metamodeling context [11] , and other works in the database evolution context can be used as Ref. [24] .

Additionally, we have defined the transformation changeTranslationRule( E : conceptualElement, T lationRule) which changes the translation rule applied to an element during the translation process.
The propagation of a conceptual transformation gives rise to a set of translation and logical changes expressed by means of the translation and logical transformations shown in Tables 6 and 7 , respectively. Some examples of these transformations will be shown in the following sections. 4.5. Propagation rules
As we have explained in Section 3.2 , by means of the propagation rules, each conceptual transformation is translated into a set of translation and logical changes expressed by means of the translation transformations and the logical transformations. The modifications performed by each set of logical transformations re-estab-lish the consistency of the logical schema with respect to the conceptual schema resulting after the application of each conceptual transformation. The set of logical transformations and their arguments are determined making use of the information stored in the translation component. Furthermore, the translation component is also updated in order to ensure the traceability of the translation process between the new conceptual and logical schemas.

For instance, let us consider three examples of evolution of the conceptual schema of Fig. 4 a. One is the case in which the audits relationship type, together with its instances, must be deleted. As a second example, we are going to suppose that the attribute ssn is settled as a new key of the entity type employee . Finally, as another example of modification that affects the ISA hierarchy, a new entity type technician is added, being defined as a subtype of employee .

We also want to consider, as another type of change, the modification of the translation rules applied dur-ing the translation process. As an example of this change, let us consider that the user decides to change the archy is established.

In order to perform these conceptual evolutions, the following conceptual transformations must be issued:  X  deleteRelationshipType(audits) ,  X  changeKey(employee, { ssn } ) ,  X  createSubtypeAndIsaSet(employee,  X  X echnician X , true, {  X  X echgrade X  } , { administrativeISAEmployee } ,  X  X ob X , true, false) ,  X  changeTranslationRule(employeeISAHierarchy, RelSchemaForRoot01) .
 Let us consider how the propagation algorithm deals with each one of these conceptual transformations.
Conceptual transformation deleteRelationshipType . The propagation of the first example of conceptual transformation seems to be very simple but it is more complex than it appears. Moreover, it will serve to illus-trate the necessity of the translation component we include in our proposed architecture. According to the the foreign key and the table project to which the attribute belongs. The problem is that this relation schema information about the specific process followed for obtaining the logical schema of Fig. 4 b, it is not known which attribute should be deleted. However, according to the elementary translations of Table 4 , the audits relationship type has been translated into the relation schema project (elementary translation 18) by adding to it the attribute id _ administrative _ 2 (elementary translation 16). So this is the attribute which must be deleted.

The propagation rule triggered by the deleteRelationshipType transformation appears in Table 8 . Let us see how this propagation rule works for our running example. Line (1) of the action finds the foreign key of the trative is deleted and in line (8) the project.id _ administrative _ 2 attribute is deleted.
Conceptual transformation changeKey . In this transformation, the attribute employee.ssn has to be settled as the new primary key of entity type employee . The propagation of this simple conceptual transformation is dif-ponent, so that it is known that the translation of the primary key has been performed inside the translation rule RelSchemaPerEntityType01 . This information together with the elementary translations are used by the propagation algorithm in order to determine the set of changes that must be performed in the logical schema.
When we change the key of the root of an ISA hierarchy, then, at the logical level, new attributes (which will be the new attributes of the primary key of the relation schema) must be added to each relation schema of each subtype of the ISA hierarchy.

Conceptual transformation createSubtypeAndIsaSet . This transformation creates a new entity type techni-cian , and is defined as a subtype of employee . Besides, it creates an isaSet with the subtypes technician and administrative and with the property isDisjoint set to true and the property isCovering set to false. As in the previous example, the propagation of this conceptual transformation takes into account that the ISA hierar-chy has been translated by means of the translation rule RelSchemaPerEntityType01 .

These two examples show that, thanks to our architecture, the logical changes are analyzed in terms of con-ceptual changes. As a consequence, for example, ISA evolution issues can be analyzed within the relational model (which lacks the ISA concept). From our point of view, this is one of the most noteworthy contribu-tions of our approach.
 Transformation changeTranslationRule . As a final evolution example, the translation rule to translate the
ISA hierarchy is changed. The translation rule RelSchemaForRoot01 (only one relation schema for the root of the hierarchy) must be used instead of RelSchemaPerEntityType01 (one relation schema for each entity type). 4.6. Correspondence rules
The changes performed in the logical schema are propagated to the extensional component by means of the correspondence rules. As we have mentioned previously, the correspondence rules have to determine two types of SQL sentences: (1) those that modify the structure of the physical database and (2) those that change the extension of the database by means of data load procedures . Each data load procedure has a precondition asso-ciated to it so that whenever a data load is used in a correspondence rule the precondition must hold.
For example, the logical transformation addAndCopyAttributes must be translated into SQL sentences that, at the physical level, create the corresponding columns and that populate them with the values of other col-umns. This is the goal of the populateNewColumns correspondence rule (see Table 9 ) whose action executes (1) the procedure SQLNewColumns which determines the SQL sentences that add new columns to a table of the physical database and (2) the data load procedure columnDataLoad which determines the SQL sentences that populate the new columns. In this action, the function getColumnsForeignKey returns the columns of a foreign key and the function getReferredColumnsForeignKey returns the columns to which the columns of a foreign key refer.

The columnDataLoad procedure adds values to columns of a target table, these values are taken from col-umns of another source table (see Table 10 ). In this case the precondition establishes that a unique row exists in the source table each time values are obtained from the source columns. The verification of this precondi-tion is ensured by the populateNewColumns correspondence rule thanks to the foreign key that exists from the target relation schema to the source relation schema.

For instance, in our running example, when the key of the root of the ISA hierarchy is changed by means of the conceptual transformation changeKey(employee, { ssn } ) then, among other things, the following logical transformation is carried out in the logical schema: addAndCopyAttributes ( administrative, {  X  X dministrative.ssn X  } , { integer } , employee, { employee.ssn } , AdmToEmplFK)
In turn, this logical transformation triggers the correspondence rule populateNewColumns which executes the following procedures:
SQLNewColumns( { administrative.ssn } , { INTEGER } , administrative) trative } , { employee.id } )
The first action adds the column ssn to the table administrative . The second action loads the new column with data coming from the column employee.ssn . The particular context of this change ensures the precondi-tion of the columnDataLoad procedure since the foreign key from administrative to employee allows a unique row satisfying the join condition to be determined.

For the complete running example, the generated SQL sentences can be seen in Table 11 . Sentences (a) X (b) correspond to the logical changes due to the conceptual transformation deleteRelationshipType , sentences (c) to (n) to the transformation changeKey , sentences (o) to (r) to the transformation createSubtypeAndIsaSet and sentences (s) to the end to the transformation changeTranslationRule . 4.7. Implementation
In this section, we describe a specific implementation of our architecture. This implementation is based on the RDBMS Oracle 10g Release 2 and the programming language PL/SQL 10g Release 2 [34] .

The processor of the conceptual component has been implemented as a set of PL/SQL procedures, one for each of the established conceptual transformations. For example, the procedure deleteRelationshipType accomplishes the task of deleting a relationship type at the conceptual level.

The processor of the translation component implements the propagation rules as a collection of PL/SQL triggers which are fired by the insert, delete or update operations performed on the conceptual database. For example, the propagation rule deleteForeignKeys of Table 8 has been implemented as a PL/SQL trigger named trgDeleteForeignKeys .
 The processor of the logical component is also implemented as a collection of PL/SQL procedures and PL/
SQL triggers which are fired by the insert, delete or update operations performed on the translation base. For example, as a consequence of the execution of the trigger trgDeleteForeignKeys the procedure deleteConstraint deletes the foreign key into which the audits relationship type was translated.

The extensional component stores the Oracle 10g database schema and its data. The processor of this com-ponent implements the correspondence rules as a collection of PL/SQL triggers which are fired by the insert, delete or update operations performed in the logical database. These triggers automatically generate and exe-cute the SQL sentences against the Oracle 10g database in order to reach a consistent database state. For example, the correspondence rule populateNewColumns of Table 9 is implemented by means of the trigger trg-PopulateNewColumns and is fired, for example, as a consequence of executing the procedure change-Key(employee, { ssn } ) , which changes the primary key of the entity type employee .

The implementation has been tested in several prototypes developed within our master studies. From this experience, we have drawn several conclusions about the helpfulness of the architecture. The first conclusion is that the architecture has proven to be of great value for keeping an updated conceptual schema, unlike tra-ditional systems in which the conceptual X  X ogical correspondence is rapidly lost. Secondly, it has been very manual restructuring. However, we have also found that it is not quite so helpful as expected when we had to apply complex transformations that we have not been able to express as a combination of more primitive ones.
As a consequence, some manual adjustments of the components storing the schemas have been made when some of these primitives should have been issued against the architecture. 5. Related work
Database evolution has been widely discussed in the literature and therefore very varied approaches have been proposed. The evolution of object-oriented databases and relational databases, including the propagation of changes automatically down to the extension of the database, has received great attention and the research results have been included in prototypes or in commercial DBMS (see, for example [1] ). However, they lack the consideration of a conceptual level which allows the designer to work at a higher level of abstraction [20] .
In [16] , an abstract framework which takes into account both conceptual and logical levels is presented and the necessity of automatically propagating down (forward strategy) the changes performed at the conceptual level is stated. The various papers dealing with forward engineering mainly differ in two aspects (which are related) (1) the mechanisms they use for preserving the consistency between levels and (2) the way they address the propagation of the conceptual changes down to the logical schema and to the extension.
With regard to the consistency between levels, several mechanisms have been proposed in the literature for keeping data in a consistent state after schema changes occur. The data conversion mechanism we have adopted is the strict conversion method, in which changes are immediately propagated to the data. As is pointed out in [31] , this mechanism, in contrast to the other two options (lazy and logical), has longer schema modification time but reduces subsequent data access time. In general three dimensions can be considered in order to evaluate our architecture from a performance point of view: database size, database modification time and database access time. We estimate that MeDEA is particularly well suited for small or medium size dat-abases and for large databases that are not expected to have many changes. For these kinds of databases the database modification time is compensated for by a faster database access time. However, in large databases with very frequent changes, the data modification time is so long that we would not recommend the use of our architecture.

As for the way the conceptual changes are propagated down to the logical schema and to the exten-sion, several approaches have been proposed. For example, a taxonomical approach is followed in [30] , which proposes a taxonomy of changes for ER structures and the impact of these changes on relational schemes is analyzed. However, this paper does not study how to reflect the schema evolution in the exten-sion of the database. We tackle this problem by ensuring the traceability of the translation process between levels, so that information stored about the translation process allows the propagation to be done more easily.

The necessity of capturing information about translations performed between models has been recognized in the literature and very varied approaches have been proposed. In the Model-Driven Architecture (MDA) approach [21] , mapping techniques between Platform Independent Models (PIM) or between Platform Spe-cific Models (PSM) are considered as association classes so that a mapping will be represented as an object (relating models) and not only as a link. With respect to PIM to PSM mappings, the MDA approach proposes of the translation component.

The innovative trend of model management [2,5] also advocates the representation of mappings by means aims to be generic in the sense that it can be applied to different kinds of models while our work is specific to database evolution issues.

In the Query-View-Transformation (QVT) proposal [27] the traceability elements are deduced from the translation algorithm (and so they depend on it). However, in our proposal the traceability component is pre-viously given, independently of the algorithm. The algorithm can be changed and the component continues to be the same.

In [15] , the traceability is achieved by storing all the sequence (called history) of operations performed dur-ing the translation of the conceptual schema into a logical one. In this way the mappings affected by the changes can be detected and modified, whereas the rest can be re-executed without any modification. The main difference between this approach and ours is the type of information stored for assuring traceability. Whereas in [15] the idea is to store the history of the process performed (probably with redundancies), in our case the goal of the elementary translations is to reflect the correspondence between the conceptual elements and the formations carried out are not stored so that there is room for ambiguities, the DBA or data designer inter-vention being necessary in order to perform the evolution process. Another difference is that we follow a metamodeling approach.

A metamodeling approach is also proposed in [20,26,23] . In the case of [20] only a conceptual metamodel is considered whereas we also make use of a logical and a translation metamodel. With respect to [26] , the authors make use of a metamodeling approach with a different goal since the paper deals with the definition of a query language for evolving information systems. In [23] , a generalization of the traditional information system notion similar to ours has been proposed. However, some differences with respect to our proposal are behavior specification. Secondly, in [23] only the conceptual level is under consideration so that the proposed architecture includes only one information system. Finally, the information processor of an information sys-tem is concerned with the modification of the structure and also of the population, instead of using different information processors for each one of these processes as we propose. 6. Conclusions and future work
In this paper we have presented MeDEA , a generic architecture for database evolution. We have shown how the metamodeling perspective that has been used in the development of this architecture allows it to be used whatever the chosen modeling techniques. Moreover, and with the aim of presenting the functionality of the architecture more completely, in this paper, we have presented a specific application setting of MeDEA . In this detailed case study the most usual database modeling languages are used, that is the
Entity-Relationship Model as conceptual modeling language and the relational model as logical modeling language.

One of the most noteworthy characteristics of MeDEA is the inclusion of a translation component , devoted to storing, by means of a model-based structure, the translation of conceptual schemas to logical ones. When an evolution event is issued against a conceptual schema, the translation component allows that changes to be propagated towards the logical schema, the physical schema and the extension, in such a way that the only elements that are modified are precisely those elements that are affected by the evolution task.
This approach has several advantages, from an improvement of the performance of the evolution process to a saving in the number of possible errors that could be made if elements not strictly involved were included in the process.

In this work, we assume that all the artifacts involved (conceptual schema, logical schema, extension) are available when an evolution task is carried out, in such a way that the problem is addressed from a  X  X orward maintenance X  point of view. One of the most obvious lines of future work is the analysis of the problem of  X  X ackward maintenance X  which is closely related to inverse engineering issues. We will have to investigate whether MeDEA fits adequately to this setting or not, and in the latter case what kind of adaptations should be made to the architecture.

Another research line is the generalization to other contexts. In its conception, MeDEA is an architecture tied to the database field. However, similar evolution problems arise when the target artifacts are different kinds of storage structures other than databases, such as for instance XML documents. In particular, a poten-tially fruitful area would be the study of evolution problems in healthcare contexts. Some previous work undertaken by our research group [6] has proven that evolution issues naturally occur within this field. Acknowledgements
The authors of the paper greatly appreciate the comments of the referees, since their comments have been of great help in improving the paper.
 Appendix A. Conceptual transformations
A.1. Conceptual transformations of creation 1. createEntityType ( N : name, Strong ? : boolean) 2. createRelationshipTypeAndRoles ( N : name, LE : listOfEntityTypes, [ LN : listOfNamesOfRoles], LC : list-3. createAttribute ( N : name, [ D : domain], [ DT : data type]) 4. addAttributeToEntityType ( A : attribute, E : entityType) 5. addAttributeToRelationshipType ( A : attribute, R : relationshipType) 6. specifyCompoundAttribute ( A : attribute, LA : listOfAttributes) 7. specifyMultivaluedAttribute ( A : attribute, [ LB : lowerBound], [ UB : upperBound]) 8. specifyDerivedAttribute ( A : attribute, DR : derivationRule, [ LA : listOfAttributes]) 9. createKeyOfStrongEntityType ( E : entityType, LA : listOfAttributes) 10. createPartialKeyOfEntityType ( E : entityType, LA : listOfAttributes) 11. createISa ( P : entityType, C : entityType) 12. createIsaSet ( LI : listOfIsas, [ Disc : discriminant], [ Disj ? :boolean], [ Cov ? :boolean])
A.2. Conceptual transformations of elimination 13. deleteEntityType ( E : entityType) 14. deleteRelationshipType ( R : relationshipType) 15. deleteAttribute ( A : attribute) 16. deleteAttributeFromEntityType ( A : attribute, E : entityType) 17. deleteAttributeFromRelationshipType ( A : attribute, R : relationshipType) 18. deleteKeyFromStrongEntityType ( E : entityType, K : key) 19. deletePartialKeyFromEntityType ( E : entityType, PK : partialKey) 20. deleteISa ( I : isa) 21. deleteIsaSet ( IS : isaSet)
A.3. Conceptual transformations of modification 22. renameEntityType ( E : entityType, N : name) 23. renameRelationshipType ( R : relationshipType, N : name) 24. renameAttribute ( A : attribute, N : name) 25. renameDomain ( D : domain, N : name) 26. renameRole ( R : role, N : name) 27. includeAttributeInCompositeAttribute ( A : attribute, CA : compositeAttribute) 28. includeAttributeInDerivedAttribute ( A : attribute, DA : derivedAttribute) 29. includeAttributeInKey ( A : attribute, K : key) 30. includeAttributeInPartialKey ( A : attribute, PK : partialKey) 31. includeIsaInIsaSet ( I : isa, IS : isaSet) 32. removeAttributeFromCompositeAttribute ( A : attribute, CA : compositeAttribute) 33. removeAttributeFromDerivedAttribute ( A : attribute, DA : derivedAttribute) 34. removeAttributeFromKey ( A : attribute, K :key) 35. removeAttributeFromPartialKey ( A : attribute, PK : partialKey) 36. removeIsaFromIsaSet ( I : isa, IS : isaSet) 37. changeCardinalityOfRole ( R : role, C : pairOfCardinalities) 38. changeDataTypeOfDomain ( D : domain, DT : dataType) 39. changeLowerBoundOfMultivaluedAttribute ( A : attribute, LB : lowerBound) 40. changeUpperBoundOfMultivaluedAttribute ( A : attribute, UB : upperBound) 41. changeDerivationRuleOfDerivedAttribute ( A : attribute, DR : derivationRule) 42. changeIsDisjointOfIsaSet ( IS : isaSet, Disj ? : boolean) 43. changeIsCoveringOfIsaSet ( IS : isaSet, Cov ? : boolean) 44. changeDiscriminantOfIsaSet ( IS : isaSet, Dis : discriminant) 45. changeDomainOfAttribute ( A : attribute, D : domain, [ DT : dataType]) 46. turnAttrributeIntoEntityType ( A : attribute, E : entityType, Strong ? : boolean) 47. turnRelationshipTypeIntoEntityType ( R : relationshipType, E : entityType, Strong ? : boolean) 48. inheritanceOfAttribute ( I : isa, A : attribute) 49. inheritanceOfRelationshipType ( I : isa, R : relationshipType) 50. disinheritanceOfAttribute ( I : isa, A : attribute) 51. disinheritanceOfRelationshipType ( I : isa, IS : isaSet) 52. includeEntityTypeInRelationshipType ( E : entityType, R : relationshipType, [ N : nameOfRole], C : 53. removeEntityTypeFromRelationshipType ( E : entityType, R : relationshipType)
A.4. Compound conceptual transformations 54. changeKey ( E : entityType, LA : listOfAttributes) = deleteKey  X  E  X  + addKey  X  E ; LA  X  55. createSubtypeAndIsaSet ( P : entityType, N : nameOfEntityType, Strong ? : boolean, [ LN : listOfNamesOfAt-
References
