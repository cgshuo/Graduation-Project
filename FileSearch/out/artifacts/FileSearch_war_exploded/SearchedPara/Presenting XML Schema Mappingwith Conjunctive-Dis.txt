 Schema mapping of XML documents is an interesting and important topic in XML data integration and exchange. In relational data integration[1] and exchange[2], the mapping is often denoted by the source-to-target dependency formula  X  S ( x )  X  X  X  y. X  T ( x, y )where  X  S is a conjunction of atoms (an atom is an expression R(t) where R is a relation symbol and t is a tuple of variables) over the source schema S and  X  T is a conjunction of atoms over the target schema T. XML document is essentially different from relational database in that the data elements in XML document are often i n various structural relationships, i.e., the parent-children, the ancestor-descendants, the sibling and the document order relationships. Some studies try to present simple XML schema mappings by establishing connectio ns between attributes in two schemas[3], which lacks expressiveness in presenti ng common data restructuring in integrating heteroge-neous XML sources. Most studies on XML schema mapping languages usually adopt certain structural patterns, i.e., variables structurally composed with tags, to indicate that the data elements matching the patterns be in the structural relationships accordingly. The structural patterns can be roughly classified as path ones [4][5][6][7]and tree-like ones[8][9][10].

In these mapping languages, the variables in structural patterns are implic-itly combined conjunctively and thus treated as a variable tuple x .Thusthe above formula is employed in XML schema mapping with little modification. However, this tuple-oriented schema mapping is insufficient to specify complex XML mapping requests involving hierarchical and heterogeneous data elements. The common solution is to use many mapping rules to specify various kinds of correspondences between variable tuples, which degrades the readability and the expressiveness of schema mapping specification.

In this paper, we propose a new approach to presenting XML schema map-pings which deploys tree-like patterns composed with logical operators to present the requests on mapping hierarchical and heterogeneous data. In comparison with existing studies, our work contributes to presenting XML schema mapping in two sides: on one hand, we propose a novel pattern-based view named Conjunctive-Disjunctive Views (CDV) which uses conjunctive and disjunctive operators to compose patterns and the data elements accordingly. To our knowledge, it is the first attempt to introduce disjunctive operators in XML schema mappings[9]; b) on the other hand, we adopt a simple but expressive deductive mechanism to spec-ify and resolve data transformation following certain restructuring rules. These re-structuring rules are coherent with the conjunctive-disjunctive relationships among data elements indicated by CDVs, and they lay the foundation of building data hierarchy and handling heterogeneity.

The remainder of the paper is organized as follows. In Section 2, the design issues and the features of CDV are intro duced. In Section 3, certain schema map-pingswithCDVaredemonstratedwitht ypical examples. Section 4 concludes the paper. The Conjunctive-Disjunctive View (CDV) is a pattern-based view for specify-ing logical and semantic relationships among data elements in an XML docu-ment fragment. The core of a CDV is a tree-like pattern named Conjunctive-Disjunctive Pattern (CDP) whose grammar is listed below.

As shown in Fig.1, a CDP (denoted by p ) can be an atomic pattern (denoted by a ), an element pattern (denoted by e ) and a composite pattern. For an atomic pattern, the notation denotes a null value indicating the absence of an element, and s denotes a document fragment, e.g., a value or an element, indicating the existence of such a fragment under current context. An element pattern is composed of an optional location prefix, a label and an optional variable. An element pattern without location prefix denotes an element locating under the current context, and one with the prefix  X // X  denotes a descendant element. The label l denotes an element tag or an attribute name, and the variable x is used to bind the matching values. For example, matching the pattern title($t) with
A composite CDP can be a tree pattern e[p] , a conjunctive pattern p 1 *p 2 ,an option pattern p 1 | p 2 , a disjoint pattern p 1 +p 2 and a group pattern { p } .Thetree pattern e[p] is to match a document element where e matches the root tag and p matches the content of the element. The conjunctive pattern p 1 *p 2 indicates that the data respectively matching p 1 and p 2 be associated conjunctively. The option pattern p 1 | p 2 indicates that a matching elem ent match either the pattern p 1 or the pattern p 2 . The disjoint pattern p 1 +p 2 indicates that the data respectively matching the pattern p 1 and p 2 should be disjoint from each other and be gathered disjunctively. The group pattern { p } is actually a recursive option of disjoint patterns that { p } = p | p+p | p+...+p | ... , and it indicates that the data matching the pattern p be disjoint from each other and are gathered as a set of independent elements.

Matching a composite CDP with a document fragment results in a compound variable binding composed of the element variable bindings in the similar struc-ture of the CDP. CDV adopts an expression named matching term to denote the structure of these bindings, which exactly corresponds to the CDP struc-ture. A matching term of a CDP is composed of the variables in a CDP with the correspondent conjunctive and disjunctive operators. For example, the CDP course($c)[ { //course($cr) } *title($t)] has the matching term $c* { $cr } *$t ,and would generate the binding like $c  X  c 1 *($cr  X  c 2 +$cr  X  c 3 )*$t  X  t 1 .
A CDV is an extension of a CDP by embedding the constraints into the pattern to restrict the matching values of the pattern. A constraint is a predicate function which uses the matching term of the associated CDP as the actual argument. For example, the CDV (teacher($x), ($x/lastname)= X  X i X ) indicates that there be a teacher element bound to the variable $x which has the last name  X  Li  X ; (class(&amp;c1)[teacher($x1)]*class(&amp;c2)[teacher($x2)], ($x1=$x2) and (&amp;c1!=&amp;c2)) indicates that there be two different class elements, denoted as &amp;c1!=&amp;c2 where &amp;x is a location variable, which are conjunctively combined and have common teacher ; ( { (teacher($x), ($x/lastname)= X  X i X ) } ,count( { $x } ) &gt; 2) indicates that there be some teacher elements which have the last name  X  Li  X  and are combined as a set having more th an 2 members. Additionally, since the bindings of the sub-patterns of a disjunctive pattern are independent to each other, the CDVs based on the disjunctive views like v 1 | v 2 or v 1 +v 2 need not constraint. XML schema mappings can naturally be presented as mappings between CDVs where a fundamental issue is to coherently transform the source data elements into the expected structure com patible with the target document. We thus deploy a deductive mechanism of the matching terms, using a set of rewrit-ing rules to specify how one matching term can be restructured to another.
The rules in Fig.2 are designed on the purposes of: a) coherently maintaining the conjunctive-disjunctive relationships among the data elements during data transformation; and b) flexibly reorganizing the data structure to be compliant to the target document. This idea comes from our previous study on XML query and for the further theoretical p roperties please refer to [11] . Based on CDVs, a XML schema mapping can be presented following a formula  X 
S ( mt s ( x )) over the matching term mt( x ) and  X  T ( mt t ( x, y )) denotes a target CDV over the matching term mt( x, y ) . Here the variables y are fresh ones denoting the values in the target CDV, and the variables x are bound ones originated from the source views. Generally, a CDV-based mapping is specified as the expression  X  from source-view to target-view X . A source view is sp ecified as a source document or a schema with a CDV, indicating how the data from local sources be mapped to the target view. The structur al and semantic requirements of the target document are defined by the target views.

Currently CDV only works on the documents with DTD schemas and thus only allows some kinds of simple constraints indicating common features of DTD schemas. The available predicates in constraints include filtering elements with constants and one-argument functions, e.g., $x/last-name= X  X i X  , judging value element in set, e.g., $a in { $b } . Additionally, certain pragmatic paradigms for presenting common mappings are provided to facilitate processing where some special constraints are allowed.

Fig.3 shows a simple case of XML integration. The course and the class docu-ments respectively following the s1.dtd and s2.dtd schemas are to be transformed and integrated into a target document following t.dtd .Thereisa X  pre-required  X  ( prereq ) relationship between courses indicating that a course be studied after certain courses. During the i ntegration, the recursively-defined course elements in s1.dtd should be flattened as a list of course elements in t.dtd ,andthe pre-required relationship should be interpreted to the  X  required-by  X ( reqby )rela-tionship. In this list, the sub-element  X  cno  X  is the key for each course element, and a course should locate before its  X  reqby  X  courses. The class information in s2.dtd should be grouped by  X  courseno  X  X r X  classno  X  and then combined into t.dtd accordingly. Here the content of  X  classno  X  should be changed to a  X  courseno  X  by a function ch() . These schema mapping requests can be presented with the mapping CDVs in the following examples.
 Example 1. Extract the course information f rom the original course elements into a temporary document containing the fragments compliant to the target document. Example 1 transforms a recursive data hierarchy into a flat set. In the source CDV all the pairs of courses constituting the pre-required relation are extracted as { $ n* $ n1 } , and then set is folded to { $ n1%* $ n% } indicating the required-by relation in the target schema.
 Example 2. Group the courses in the class elements by its  X  courseno  X  X r X  classno  X  to generate a temporary document containing the fragments compliant to the target document. In this example, the source term { ($n1 | $n2)*($t | null)*$y*$x } is restructured to { ($n1 | $n2)%* { ($n1 | $n2)*($t | null)*$y*$x }} , and further to { ($n1 | $n2)%*( { $t } | null)* { $y*$x }} in the target CDV. The target CDV directly uses ($n1 | $n2)% and { $y*$x } in CDP, and introduces a fresh variable $t1 with the constraint { $t } &lt; = { $t1 } to indicate that all the bound values of $t should be used to instantiate $t1 . Here the set inclusion rather than set equivalence is used because the mapping just constructs partial information of the target document. Example 3. Join the course elements from two temporary documents into the target document. XML schema mapping is an important and interesting topic in XML integration and exchange. Existing studies often follow the conventional approach to pre-senting the mapping as the dependence between variable tuples. In this paper, We introduced a pattern-based approach named CDV to present XML schema mapping as the correspondence between different but compatible structures of variables composed of logical operators. CDV adopts disjunctive as well as con-junctive operators to compose sub-patterns and the associating semantic con-straints, and is convenient to present c omplex mapping requests on hierarchical and heterogeneous data. Due to the tight space constraints, only the basic ideas of designing CDV are illustrated in this paper. For more details of the theoretical issues of CDV and the examples, please refer to the full report[12].

