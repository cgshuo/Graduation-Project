 Interactive Annotation Learning is a supervised ap-proach to learning annotations with the goal of min-imizing the total annotation cost. In this work, we demonstrate that with additional supervision per ex-ample, such as distinguishing discriminant features, same performance can be achieved with less anno-tated data. Supervision for simple features has been explored in the literature (Raghavan et al., 2006; Druck et al., 2008; Haghighi and Klein, 2006). In this work, we propose an approach that seeks super-vision from the user on structured features.
Features that capture the linguistic structure in text such as n-grams and syntactic patterns, referred to as structured features in this work, have been found to be useful for supervised learning of annota-tions. For example, Pradhan et al. (2004) show that using features like syntactic path from constituent to predicate improves performance of a semantic parser. However, often such features are  X  X and-crafted X  by domain experts and do not generalize to other tasks and domains. In this work, we propose a general graph representation for automatically ex-tracting structured features from tokens and prior an-notations such as part of speech, dependency triples, etc. Gamon (2004) shows that an approach using a large set of structured features and a feature selec-tion procedure performs better than an approach that uses a few  X  X andcrafted X  features. Our hypothesis is that structured features are important for super-vised annotation learning and can be automatically derived from tokens and prior annotations. We test our hypothesis and present our results for opinion mining from product reviews.

Deriving features from the annotation graph gives us a large number of very sparse features. Fea-ture selection based on class association scores such as mutual information and chi-square have often been used to identify the most discriminant features (Manning et al., 2008). However, these scores are calculated from labeled data and they are not very meaningful when the dataset is small. Supervised feature selection, i.e. asking the user to vote for the most discriminant features, has been used as an al-ternative when the training dataset is small. Ragha-van et al. (2006) and Druck et al. (2008) seek feed-back on unigram features from the user for docu-ment classification tasks. Haghighi and Klein (2006) ask the user to suggest a few prototypes (examples) for each class and use those as features. These ap-proaches ask the annotators to identify globally rel-evant features, but certain features are difficult to vote on without the context and may take on very different meanings in different contexts. Also, all these approaches have been demonstrated for uni-gram features and it is not clear how they can be extended straightforwardly to structured features.
We propose an indirect approach to interactive feature selection that makes use of highlighted ra-tionales from the user. A rationale (Zaidan et al., 2007) is the span of text a user highlights in support of his/her annotation. Rationales also allow us to seek feedback on features in context. Our hypothe-sis is that with rationales, we can achieve same per-formance with lower annotation cost and we demon-strate this for opinion mining from movie reviews.
In Section 2, we describe the annotation graph representation and motivate the use of structured features with results on learning opinions from prod-uct reviews. In Section 3, we show how rationales can be used for identifying the most discriminant features for opinion classification with less training data. We then list the conclusions we can draw from this work, followed by suggestions for future work. In this section, we demonstrate that structured fea-tures help in improving performance and propose a formal graph representation for deriving these fea-tures automatically. 2.1 Opinions and Structured Features Unigram features such as tokens are not sufficient for recognizing all kinds of opinions. For example, a unigram feature good may seem useful for identi-fying opinions, however, consider the following two comments in a review: 1) This camera has good fea-tures and 2) I did a good month X  X  worth of research before buying this camera . In the first example, the unigram good is a useful feature. However, in the second example, good is not complementing the camera and hence will mislead the classifier. Struc-tured features such as part-of-speech, dependency relations etc. are needed to capture the language structure that unigram features fail to capture. 2.2 Annotation Graph and Features We define the annotation graph as a quadruple: G = (
N,E,  X  , X  ) , where N is the set of nodes, E is the set of edges E  X  N  X  N ,  X  =  X  N  X   X  E is a set of labels for nodes and edges.  X  is the label-ing function  X  : N  X  E  X   X  , that assigns labels to nodes and edges. In this work, we define the set of labels for nodes,  X  N as tokens, part of speech and dependency annotations and set of labels for edges,  X 
E as relations,  X  E The leftOf relation is defined between two adjacent nodes. The parentOf relation is defined between the dependency type and its attributes. For example, for the dependency triple  X  X subj perfect camera X , there is a parentOf relation between the dependency type  X  X subj X  and tokens  X  X erfect X  and  X  X amera X . The re-stricts relation exists between two nodes a and b if their textual spans overlap completely and a restricts how b is interpreted. For a word with multiple senses the restricts relation between the word and its part of speech, restricts the way the word is interpreted, by capturing the sense of the word in the given context. The Stanford POS tagger (Toutanova and Manning, 2000) and the Stanford parser (Klein and Manning, 2003) were used to produce the part of speech and dependency annotations.

Features are defined as subgraphs, G 0 = ( N 0 ,E 0 ,  X  0 , X  0 ) in the annotation graph G , such that N 0  X  N , E 0  X  N 0  X  N 0 and E 0  X  E ,  X  0 =  X  0 vocabulary and E =  X  and  X  E =  X  (where  X  is the null set). We define the degree of a feature subgraph as the number of edges it contains. For example, the unigram features are the feature subgraphs with no edges i.e. degree = 0 . Degree  X  1 features are the feature subgraphs with two nodes and an edge. In this paper, we present results for feature subgraphs with degree = 0 and degree = 1 .

Figure 1 shows the partial annotation graph for two comments discussed above. The feature sub-graph that captures the opinion expressed in 1(a), can be described in simple words as  X  X amera has features that are good X . This kind of subject-object relationship with the same verb, between the  X  X am-era X  and what X  X  being modified by  X  X ood X , is not present in the second example (1(b)). A slight modi-fication of 1(b), I did a month X  X  worth of research be-fore buying this good camera does express an opin-ion about the camera. A bag of words approach that uses only unigram features will not be able to differ-entiate between these two examples; structured fea-tures like dependency relation subgraphs can capture this linguistic distinction between the two examples. 2.3 Experiments and Results The dataset we used is a collection of 244 Amazon X  X  customer reviews (2962 comments) for five products (Hu and Liu, 2004). A review comment is annotated as an opinion if it expresses an opinion about an as-pect of the product and the aspect is explicitly men-tioned in the sentence. We performed 10-fold cross validation (CV) using the Support Vector Machine (SVM) classifier in MinorThird (Cohen, 2004) with the default linear kernel and chi-square feature se-lection to select the top 5000 features. As can be seen in Table 1, an approach using degree  X  0 fea-tures, i.e. unigrams, part of speech and dependency triples together, outperforms using any of those fea-tures alone and this difference is significant. Us-ing degree  X  1 features with two nodes and an edge improves performance further. However, using degree  X  0 features in addition to degree  X  1 features does not improve performance. This suggests that when using higher degree features, we may leave out the features with lower degree that they subsume. We propose an indirect feature voting approach that uses user-highlighted rationales to identify the most discriminant features. We present our results on Movie Review data annotated with rationales. 3.1 Data and Experimental Setup The data set by Pang and Lee (2004) consists of 2000 movie reviews (1000-pos, 1000-neg) from the IMDb review archive. Zaidan et al. (2007) provide rationales for 1800 reviews (900-pos, 900-neg). The annotation guidelines for marking rationales are de-scribed in (Zaidan et al., 2007). An example of a rationale is:  X  X he movie is so badly put together that even the most casual viewer may notice the mis-erable pacing and stray plot threads  X . For a test dataset of 200 reviews, randomly selected from 1800 reviews, we varied the training data size from 50 to 500 reviews, adding 50 reviews at a time. Training examples were randomly selected from the remain-ing 1600 reviews. During testing, information about rationales is not used.

We used tokens 1 , part of speech and dependency triples as features. We used the KStem stemmer (Krovetz, 1993) to stem the token features. In or-der to compare the approaches at their best perform-ing feature configuration, we varied the total num-ber of features used, choosing from the set: { 1000, 2000, 5000, 10000, 50000 } . We used chi-square feature selection (Manning et al., 2008) and the SVM learner with default settings from the Minor-third package (Cohen, 2004) for these experiments. We compare the following approaches:
Base Training Dataset ( BTD ) : We train a model from the labeled data with no feature voting. Rationale annotated Training Dataset ( RTD ) : We experimented with two different settings for in-direct feature voting: 1) only using features that overlap with rationales ( RTD (1 , 0) ); 2) features from rationales weighted twice as much as features from other parts of the text ( RTD (2 , 1) ). In general, R ( i,j ) describes an experimental condition where features from rationales are weighted i times and other features are weighted j times. In Minorthird, weighing a feature two times more than other fea-tures is equivalent to that feature occurring twice as much.

Oracle voted Training Data (OTD): In order to compare indirect feature voting to direct voting on features, we simulate the user X  X  vote on the features with class association scores from a large dataset (all 1600 documents used for selecting training doc-uments). This is based on the assumption that the class association scores, such as chi-square, from a large dataset can be used as a reliable discriminator of the most relevant features. This approach of sim-ulating the oracle with large amount of labeled data has been used previously in feature voting (Ragha-van et al., 2006). 3.2 Results and Discussion In Table 2, we present the accuracy results for the four approaches described in the previous section. We compare the best performing feature configura-tions for three approaches -BTD , RTD (1 , 0) and RTD (2,0). As can be seen, RTD (1 , 0) always per-forms better than BTD . As expected, improvement with rationales is greater and it is significant when the training dataset is small. The performance of all approaches converge as the training data size in-creases and hence we only present results up to train-ing dataset size of 500 examples in this paper.
Since our goal is to evaluate the use of rationales independently of how many features the model uses, we also compared the four approaches in terms of the accuracy averaged over five feature configura-tions. Due to space constraints, we do not include the table of results. On average RTD (1 , 0) signif-icantly outperforms BTD when the total training dataset is less than 350 examples. When the train-ing data has fewer than 400 examples, RTD (1 , 0) also significantly outperforms RTD (2 , 1) .
OTD with simulated user is an approximate up-per bound for rationale based approaches. It tells us how far we are from direct supervision on struc-tured features. On average, OTD significantly out-performed RTD (1 , 0) for training data size of 100 , 150 , 400 , 450 and 500 examples but not always. As can be seen from Table 2, difference between OTD and RTD (1 , 0) reduces with more training data, since with more data and hence more rationales we get better feature coverage.

Results presented here show that for a given train-ing dataset, we can boost the performance by ask-ing the user to label rationales. However, there is an additional cost associated with the rationales. It is important to evaluate how much total annotation cost rationales can save us while achieving the de-sired performance. In Figure 2, we compare the number of training examples an approach needs to achieve a given level of performance. As can be seen, RTD (1 , 0) needs fewer training examples to achieve the same performance as BTD . The differ-ence is large initially when the total number of train-ing examples is small ( 50 for RTD (1 , 0) and 150 for BTD to achieve a performance between 66  X  67 ).
Comparison with Zaidan et al. (2007): Zaidan et al. (2007) conclude that using only features from rationales performs worse than both: 1) using all the features in the documents, and 2) using features that do not overlap with the rationales. The results pre-sented in this paper seem to contradict their results. However, they only experimented with unigram fea-tures and only one approach to using features from rationales, RTD (1 , 0) and not RTD (2 , 1) . In order to compare our work directly with theirs, we exper-imented with an equivalent set of unigram features. In Table 3, we present the results using same num-ber of total features (17744) as Zaidan et al. (2007). As can be seen from the table, when only unigram features are used, RTD (2 , 1) outperforms BTD but RTD (1 , 0) performs worse than BTD . Thus, our results are consistent with (Zaidan et al., 2007) i.e. using unigram features only from the rationales does not boost performance.

From Table 3, we also analyze the improvement in performance when part of speech and depen-dency features are used in addition to the unigram features i.e. using all degree  X  0 subgraph fea-tures. For RTD (1 , 0) , adding these features im-proves performance for all data sizes with signifi-cant improvement for dataset size of 300 and 500 ex-amples. RTD (1 , 0) also significantly outperforms BTD when all three features are used. For direct voting on features ( OTD ), a significant improve-ment with these structured features is seen when the training dataset size is greater than 200 examples. For BTD and RTD (2 , 1) approaches, there is no significant improvement with these additional fea-tures. In the future, we plan to investigate further the benefit of using higher degree subgraph features for opinion mining from the movie review data.
Comparing ranking of features: We also com-pared the features that the rationales capture to what the oracle will vote for as the most relevant features. Features are ranked based on chi-square scores used in feature selection. We compare the ranked list of features from RTD (1 , 0) , BTD and OTD and use a weighted F-measure score for evaluating the top 100 ranked features by each approach. This measure is inspired by the Pyramid measure used in Summa-rization (Nenkova and Passonneau, 2004). Instead of using counts in calculating F-measure, we used the chi-square score assigned to the features by the oracle dataset, in order to give more weight to the more discriminant features. As can be seen from Table 4, RTD (1 , 0) outperforms BTD in captur-ing the important features when the datasize set is small ( &lt; 300 ) and this difference is significant. Be-yond 300 examples, as the data size increases, BTD outperforms RTD (1 , 0) . This implies that the ra-tionales alone are able to capture the most relevant features when the dataset is small. In this work, we demonstrated that using structured features boosts performance of supervised annota-tion learning. We proposed a formal annotation graph representation that can be used to derive these features automatically. However, the space of pos-sible feature subgraphs can grow very large with more prior annotations. Standard feature selection techniques based on class association scores are less effective when the dataset is small. Feature voting from the user for identifying the relevant features is limited to simple features. Supplementary input from the user in terms of highlighted rationales can be used instead to prune the feature space. The pro-posed approach is general and can be applied to a variety of problems and features.

In this work, we presented our results with degree  X  0 and degree  X  1 feature subgraphs. We will extend our algorithm to automatically ex-tract higher degree features from the annotation graph. For the rationale annotated training data (
RTD ( i,j ) ), we experimented with two possible values for i and j . We aim to learn these weights empirically using a held out dataset. Rationales are associated with an additional cost per example and hence two approaches, with and without the ratio-nales, are not directly comparable in terms of the number of examples. In the future, we will conduct an annotation experiment with real users to evaluate the usefulness of rationales in terms of clock time. We would like to thank Dr. Carolyn P. Rose for her help with statistical analysis of the results. We would also like to thank all the anonymous review-ers for their helpful comments.

