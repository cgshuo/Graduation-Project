 Vo Thi Ngoc Chau, Suphamit Chittayasothorn * 1. Introduction
Temporal database management has been much investigated for a long time due to the inherently temporal nature of everything. A temporal database is defined as a database supporting some aspect of time, not counting user-defined time.
Two main temporal aspects of data are valid time and transaction time [26]. Based on the existing non-temporal data mod-ment has been carried out for some temporal data semantics: point-based and interval-based [49]. Temporal data representation has been formed with two different timestamping schemes: tuple/object and attribute. Temporal data manipulation has been supported by many temporal extensions to relational algebra/tuple calculus, QUEL, OQL, and SQL. sion in order to allow users to express temporal queries against a temporal database by means of temporal operators (ALWAYS, ANYTIME, NEXT, PREV, and UNTIL) in a non-procedural manner. 1.1. Motivation
This subsection addresses the motivations from which the significance of this work can be derived. 1.2. Contribution ency environment is proposed. 2. Related work done with both tuple/object and attribute timestamping schemes. The former scheme regards the timestamp as a special of interest are modeled together in a single tuple/object [46]. Furthermore, the former one might produce temporal data tuples and in several relations. To overcome such unexpected anomalies, the latter shifts data timestamping to the finer the attribute level. For the tuple timestamping scheme, the existing works [6,9 X 12,14,15,30,41 X 43,52,54] have been re-searched on many issues of a temporal database including temporal data representations, integrity constraints, querying, modifications, and implementations. In comparison with temporal database systems with the tuple timestamping scheme, temporal database systems with the attribute timestamping scheme are less in number. Indeed, [7] provides an overview on temporal database system implementations. Among these temporal database systems, only the TDBMS system associated ations PACK and UNPACK follows the attribute timestamping scheme while the others follow the tuple timestamping attributes, the number of temporal database systems that support the attribute timestamping scheme in the literature has gradually increased and a few recent system implementations can be found in [16,17,23,32,44] . Our research work, which 28,32,33,44,46,48] which use the attribute timestamping scheme for a valid time support.

Secondly, a so-called built-in temporal support is examined in some existing SQL standards and commercial DBMSs. As withdrawn and not yet implemented in any existing commercial DBMS although introduced a long time ago. Nevertheless, commercial database vendors are working on a transaction time support, e.g. Oracle with FlashDB [37] and MS SQL Server with ImmortalDB [29]. To our best knowledge, valid time support is provided by Oracle Workspace Manager [38] and no valid time support from Informix, IBM DB2, and MS SQL Server. However, the Oracle valid time support [36] follows the tuple ?tul?&gt; timestamping scheme and provides temporal DB users only with relationship checking operators between two periods (wm_overlaps, wm_contains, wm_meets, wm_equals, wm_lessthan, and wm_greaterthan) and set operators (wm_intersection, wm_ldiff, and wm_rdiff). In general, the implementation of a temporal database management system
With no built-in temporal support, a non-temporal DB language has to be employed for temporal data management. As the attribute timestamping scheme.
 attribute level is given as follows for a comparison with our work.

A research work in [17] introduces a temporal relational database system which provides DB users with attribute time-stamping while the tuple timestamping scheme is used for their underlying implementation. Their temporal extension to the WHERE clause is evaluated with the principle of temporal upward compatibility. There is no discussion about joins, this approach cannot generally overcome the time-varying of data. So, the proliferation of temporal operators might take place for each individual data type.

With the nested relational data model, [20,22,46,48] provide a temporal algebra/calculus with no consideration on time non-restrictiveness (non-sequenced) feature mentioned in [9,43] .

On the employment of an ORDBMS, [27,28] use temporal versions of data types. However, their approach is not general-ized because valid timestamps are attached to a particular type such as NUMBER. Moreover, temporal data manipulations data representation is defined with instant timestamps that might result in data redundancy as compared to temporal ele-
Oracle 10g Workspace Manager, their temporal support includes only temporal relationship operators. Temporal upward on an ORDBMS. The main difference between valid time and transaction time is that transaction time is system-supplied while valid time user-supplied according to the modeled world. No modification on transaction time is directly allowed while valid time can be supported towards the future. However, valid time and transaction time are orthogonal to each other. Despite our focus on valid time support, our work can be nicely extended to cover transaction time as well. This BMS in order to become bi-temporal.

On the use of the object oriented data model, [16,23,44] use the concept of history while [19,33] define a parameterized called semantic assumptions which might have an impact on some degrees of data precision in temporal data management. produces no history oriented preservation in the SELECT clause and does not perform temporal joins when two pieces of historical containment constraints on temporal data while others have no discussions on integrity constraints related to time-varying attributes. With a temporal extension to ODL/OQL, the implementations introduced in [16,19,44] are carried out on top of an OODBMS while the implementation in [23] is from scratch. That is, a new interface is provided to users so that the temporal support can be built-in to them. So, users X  effort might be required for temporal data management via their new interfaces if their temporal database languages are employed.

In this paper, we propose a novel temporal database language as a temporal extension to the object relational SQL lan-of temporal data definitions (schemas, schema evolutions, and integrity constraints on temporal tables and temporal col-umns), temporal data querying, and temporal data modifications (insertions, deletions, and updates) without restrictions disadvantages of a layered implementation approach [50,51,54] , our implementation is achieved as an add-on that can be integrated into a non-temporal ORDBMS by taking advantage of the extensibility of an ORDBMS. Therefore, the proposed level conveniently through the existing interfaces of an employed ORDBMS. 3. Temporal data representation 3.1. Object relational database defined as the fusion of the relational data model and the object data model.
 of an underlying ORDBMS. Thus, the existence of this column can replace the concept of the primary key in the relational the foreign key in the relational model.
 In this paper, an OR database, a table, and a structured type are formally defined as follows.
Let ST = {ST 1 ,ST 2 , ... ,ST i , ... ,ST m } be a finite collection of structured types. Each structured type ST contains a list of n attributes each of which A j for any j in 1.. n is of any AT type.
Definition 1 ( Structured type ,ST i ). ST i =( A 1 : AT 1
Definition 2 ( Table , ut k ). ut k ={ ... , (av 1 ,av 2 , ... ,av
A table ut k which is a 1NF, non-1NF, or a typed table is defined as a finite unordered collection of rows/tuples. If ut 1NF or non-1NF table not defined on any structured type, one row/tuple (av sian product D 1 D 2 D j D n of n domains D 1 , D 2 , ... , D or non-atomic permitted values which are all of a data type AT either atomic or non-atomic, and located at the column named A for any i in 1.. m , one row/tuple (av 1 ,av 2 , ... ,av j 1.. n , the value av j at the column corresponding to the A a reference referring to a row in ut k is of the reference type REF (ST [2].

With the definitions of a structured type ST i for any i in 1.. m and a table ut defined as follows.

Definition 3 ( Object relational database, DB ). DB = { ut
The language accompanying the OR data model for manipulations on an OR database is the one with the ad-hoc capability statements for data querying. Modifications against tables are made by INSERT, DELETE, and UPDATE statements also spec-ified in the OR SQL language. An INSERT statement is used to insert a new row into a table; a DELETE statement to remove of abstract data types, user-defined methods (functions/procedures), and operators. Therefore, the employment of the OR data model for temporal data management is promising. 3.2. A sample database and 2 , the time-varying information of employees and the departments where they work is captured. REFC is an extra col-closed-open interval; i.e. the starting point vtStart is included while the end point vtEnd is excluded. 3.3. Temporal object relational database
Our temporal data management will be based on the object relational data model and our temporal database language will be based on the object relational SQL language [2].
 that comprises one or many temporal attributes each of which corresponds to a temporal column. poral table, Name, Salary, and Dept are temporal columns while Gender and D_birth are non-temporal columns. In the Dept temporal table, Manager and Budget are temporal columns while Department is a non-temporal column. These two tempo-ral tables can be temporal 1NF or non-1NF tables or temporal typed tables defined on temporal structured types Emp_t and Dept_t, respectively. There are temporal attributes Name, Salary, and Dept in the Emp_t temporal structured type while
Manager and Budget in the Dept_t temporal structured type. 3.3.1. Temporal column
Firstly, the data representation of a temporal column A j
This general temporal support leads to no difference between a temporal column of type VARCHAR, a temporal column of type NUMERIC, a temporal column of type REF, etc.

Consider a data item av j at the A j column of a row (av 1 of the AT j type. If A j is temporal, the representation of the av known as a time granularity [26]. All observations for A j value. An observation results in a temporal composition c , where c = (av  X  c represents the fact that av j , c is true in vt j , c  X  X v j , c is a (snapshot) value of the AT j data type which is not related to date and time. av ponent of c . that is not included in the period. vt j , c is called the time component of c .

Definition 5 ( Attribute history, av j ). An attribute history of A av alent duplicates [43], and no data redundancy. First, each period of time contained in any vt starting point is less than the end point in time. Second, all values av observations are based on the same granularity g j . Third, these values av each other to avoid value-equivalent duplicates. Finally, the disjointness of vt different values av j , c 1 and av j , c 2 from being true at the same time for no data redundancy.
Also, we define some basic functions on a collection of temporal compositions av  X  To retrieve all periods of validity: LIFESPAN(av j ) = UNION( vt periods. These operators follow the temporal algebra semantics as defined in [22].  X  To retrieve a value true at some moment t in reality: TVALUE(av  X  To access the time-dependent and time components of a temporal composition, i.e. c = (av VALIDTIME( c )= vt j , c .
 which allow the non-atomicity of attributes to represent their histories.

For an illustration, the Salary temporal column of the Emp temporal table in Table 1 is examined. We consider the row identified by  X  X 1 X . A corresponding value av j of the Salary temporal column that is an attribute history is av 1982, 6/1/1982)}), (30, {[6/1/1982, 2/1/1985)}), (40, {[2/1/1985, 2/1/1987), [4/1/1987, 12/31/9999)})} where (20, {[2/1/ 1/1982)} is the time component. Also, av j satisfies all the inherent integrity constraints stated above. 3.3.2. Temporal attribute and temporal structured type
Consider a structured type ST i for i in 1.. m . For j in 1.. n , an attribute A of A j is taken into account. As a result, ST i is a temporal structured type. Each value assigned to the A obey the temporal data representation of a temporal column. 3.3.3. Temporal table
With the notions of a temporal column, a temporal attribute, and a temporal structured type, the temporal data repre-ut of TDB contains at least one temporal column. From the object database point of view, a temporal table ut tories might depend on each other according to particular application requirements. As a result, columns of ut corresponding to the temporal attributes A j are temporal and others are non-temporal. Each row of ut cation [33].
 Consider operations on temporal tables. In comparison with a conventional table defined in an OR SQL language (SQL:3, are not related to any temporal column or the temporal aspect of involved temporal columns is ignored. Hence, for each (expressions in general) which are returned to users by means of projection. The temporal aspect of a column also needs might be removed on demand. So, a new temporal deletion operation at the attribute level is defined.
Unlike operations on temporal tables which can be derived from their counterparts on non-temporal ones, operations on not the same. Thus, we have defined a set of temporal methods associated with temporal data types which are used to form the structure of temporal attributes of any data type. Our temporal methods are then used for the transformation of our temporal SQL statements into non-temporal SQL statements executable to an employed ORDBMS. Furthermore, these methods can be directly and non-restrictively used by DB users who have a deep knowledge of the representation of temporal columns and abilities in handling temporal data on their own. Above all, the use of our temporal methods can models. 4. The temporal object relational SQL language with attribute timestamping and temporal columns, temporal data querying, and temporal data modifications on a temporal OR database defined in Sec-semantic defaults and the denotational-semantics-style mapping of temporal SQL statements to SQL statements enhanced
ATSQL and other existing languages following the attribute timestamping scheme because the new constructs of our lan-guage for temporal data querying are obtained from temporal logic.

As displayed in Fig. 1 , the proposed language basically satisfies the five requirements in [43]. iii. Temporal upward compatibility is ensured. The proposed language guarantees that all manipulations on a temporal
In short, our language aims at a variety of DB users with different awarenesses of the temporal aspect of a database and various abilities of data manipulations on a temporal database. Its DB users can be both non-temporal and temporal. It are not part of the standard SQL syntax are presented for the formulation of temporal SQL statements with our sequenced variants. Non-terminal symbols are in the form of &lt;xxx&gt; and terminal symbols in the form of XXX. 5. Temporal extension for data definitions 5.1. Temporal database schema definitions
The main focus of the proposed temporal database schema definition is the definition of a temporal structured type and a this paper. Nevertheless, the DBMS-supplied methods related to date and time might be helpful for granularity-based data retrieval. &lt;column_definition&gt; ::= &lt;non_temporal_column_definition&gt; j &lt;temporal_column_definition&gt; &lt;temporal_column_definition&gt; ::= &lt;column_name&gt;[&lt;data_type_or_domain_name&gt;] &lt;attribute_definition&gt; ::= &lt;non_temporal_attribute_definition&gt; j &lt;temporal_attribute_definition&gt; &lt;granularity&gt;::= YEAR j MONTH j WEEK j DAY j HOUR j MINUTE j SECOND j MILISECOND &lt;periods_default&gt;::= &lt;periods&gt; &lt;periods&gt;::= &lt;a_period&gt; j PERIODS &lt;left_paren&gt; &lt;period_list&gt; &lt;right_paren&gt; &lt;period_list&gt;::= &lt;a_period&gt; j &lt;a_period&gt; &lt;comma&gt; &lt;period_list&gt;
Both &lt;column_definition&gt; and &lt;attribute_definition&gt; can derive either non-temporal or temporal variants. The tional definitions of a column and an attribute in the non-temporal OR SQL language, respectively. The &lt;temporal_col-&lt;temporal_aspect&gt; at the end of a corresponding definition.

With the new specification of a column, the existing definition CREATE TABLE of a 1NF or non-1NF table is reused for the not investigated in this paper.

On the inheritance of structured types, the OR SQL language allows super type/sub type relationships and inheritance. As types. So, all sub types of a temporal super type are temporal.

Besides, another difference between the definition of a non-temporal table and a temporal table is the inclusion of the specification of integrity constraints on temporal columns which is not supported by the non-temporal OR SQL language. The declaration of integrity constraints on non-temporal columns is kept unchanged. Hence, the conventional constraint part will be presented in Section 5.3.

Example 1. As an illustration on the sample database, two temporal structured types Emp_t and Dept_t and two temporal typed tables Emp and Dept based on these two types are defined as follows.
 CREATE TYPE Emp_t AS ( CREATE TYPE Dept_t AS ( ALTER TYPE Emp_t ADD ATTRIBUTE Dept REF(Dept_t) VALIDTIME ( MONTH ); CREATE TABLE Dept OF Dept_t ( CREATE TABLE Emp OF Emp_t ( 5.2. Temporal database schema evolution definitions changes of these elements on demand. These requirements lead to several kinds of temporal evolutions at both type and
TER statements. More consideration on schema evolutions in object oriented databases over the time has been given in [21,34] .

At the type level, the ALTER TYPE definition is enhanced with new alter type actions for the addition and dropping of a temporal aspect of an attribute will turn a non-temporal structured type into a temporal structured type if the type has no temporal attribute before the alter type action. Thus, this action enables the temporal enhancement on a non-temporal database so that new applications can refer to temporal data while non-temporal applications run on the same database. existing contents of all typed tables defined on altered structured types. The enhanced ALTER TYPE statement syntax is shown below. &lt;alter_type_stmt&gt;::= ALTER TYPE &lt;schema_resolved_tsql_user_defined_type_name&gt; &lt;alter_type_action&gt; &lt;add_temporal_attribute_specification&gt;::= MODIFY ATTRIBUTE &lt;temporal_attribute_name&gt; &lt;drop_temporal_attribute_specification&gt;::= MODIFY ATTRIBUTE &lt;temporal_attribute_name&gt; columns, ALTER TABLE statements are formed by using the conventional production rules of the non-temporal OR SQL not accepted. 5.3. Integrity constraint definitions on temporal columns and temporal tables cation requirements. They can be declared by DB users in CREATE TABLE or ALTER TABLE statements.
Since object identifiers and references can be employed, the conventional referential integrity constraints are not dis-cussed. Uniqueness constraints and CHECK constraints are considered and generalized with respect to valid time. They of temporal integrity constraints, namely VALIDTIME HOMOGENEITY, VALIDTIME UNIQUE, VALIDTIME REFERENCES, and
VALIDTIME CHECK. The syntax of these integrity constraint definitions on temporal columns and temporal tables is defined ble constraint and &lt;temporal_column_constraint_definition&gt; which is a constraint on temporal columns. &lt;table_constraint&gt; ::= &lt;non_temporal_table_constraint&gt; j &lt;temporal_column_constraint_definition&gt; &lt;temporal_column_constraint_definition&gt;::=
Firstly, a VALIDTIME HOMOGENEITY constraint is flexibly allowed to hold so that the support of homogeneous tuples/ time independently of each other. The homogeneity is an option in our temporal data management in contrast to other re-lated works whose models are either homogeneous [20] or heterogeneous [46] to DB users.
 Example 2. To express the time-varying dependence of the salary and the department of an employee, a VALIDTIME HOMOGENEITY constraint needs to be defined as follows: ALTER TABLE Emp ADD CONSTRAINT Salary_Dept_hm VALIDTIME HOMOGENEITY ( Salary, Dept );
Secondly, a valid time uniqueness constraint VALIDTIME UNIQUE is defined over a selected temporal column to specify the uniqueness of the value combination of these constrained columns over time so that no two tuples/rows of a temporal table have the same combination of values at the same time. This is a generalization of the conventional non-temporal temporal column to guarantee that no two employees have the same name at each common point in time.
Thirdly, a valid time referential integrity constraint VALIDTIME REFERENCES is defined as an analogy to non-temporal constraints on columns associated with attributes whose data types are reference types introduced in the OR data model. tifiers, references, and valid time.

Example 3. To express the referential relationship between an employee and a department where the employee works for temporal attribute of a reference type.
 ALTER TABLE Emp ADD CONSTRAINT Dept_ref REF ATTRIBUTE ( Dept ) VALIDTIME REFERENCES Dept ; will be taken into account in Section 6.2.

Example 4. A VALIDTIME CHECK constraint is defined below on the Salary temporal column of the Emp temporal table. It specifies that the salary of any employee is always greater than 15.
 ALTER TABLE Emp ADD CONSTRAINT Salary_chk VALIDTIME CHECK ( ALWAYS { Salary &gt; 15 }); tion operation will be rejected. Otherwise, it will be accepted. 6. Temporal extension for data querying Temporal data querying in this section is associated with temporal logic [18] by employing temporal operators ALWAYS,
ANYTIME, NEXT, PREV, and UNTIL. For data retrieval from temporal tables ut
SELECT statement as shown above where the ORDER BY clause is ignored. More complex queries can be achieved from the further refinement of the results of less-complex queries or from the direct use of our temporal methods within non-se-quenced statements.
 and they are not affected by the temporal aspect of any column of an input table. Therefore, temporal tables become non-temporal ones with regard to these operations and the union compatibility checking is performed on temporal columns as usual. 6.1. FROM clauses join.

To simplify and minimize our temporal extension, a join operation on temporal tables is explicitly formed by DB users with the Cartesian product in the FROM clause and search conditions in the WHERE clause. So, the FROM clause in our lan-mas. Its syntax is specified as follows: &lt;table_reference&gt;::= &lt;table_name&gt; [[AS] &lt;table_alias&gt;] 6.2. WHERE clauses Consider the WHERE clause: &lt;where_clause&gt; ::= WHERE &lt;search_condition&gt;.
 along with the change of referenced temporal columns. Thus, the employment of temporal logic [18] to describe how the truth value of a predicate changes by means of typical temporal operators ALWAYS, ANYTIME (EVENTUALLY), NEXT, PREV (LAST), and UNTIL is appropriate. In order to express the time-varying aspect of a predicate containing temporal column references, we extend the set of
Boolean primaries with temporal predicates TP as shown below. A temporal predicate is a predicate whose truth value of a predicate defined in [2] so that conventional predicates become arguments of temporal operators. Temporal operators which are based on temporal logic are ALWAYS, ANYTIME, NEXT, PREV, and UNTIL along the time line (past, NOW, and fu-search condition. These temporal predicates are shown below: Let p and q be two predicates shaped by production rules in [2] with none of our new temporal constructs. tc tc We elaborately formulate the sequenced semantics of these temporal predicates as follows.
INFINITY+ is the one towards the future. NOW + 1 is the next instant of NOW towards the future and NOW 1 the previous instant of NOW towards the past.
 Secondly, we define the meaning of truth of each group of temporal predicates TP1 ... TP14.
TP1  X  ALWAYS f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP2  X  ALWAYS &lt; periods &gt; f p  X  tc p 1 ; ... ; tc p i
TP3  X  pALWAYS f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP4  X  fALWAYS f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP5  X  ANYTIME f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP6  X  ANYTIME &lt;periods&gt; f p  X  tc p 1 ; ... ; tc p i TP7  X  pANYTIME f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n TP8  X  fANYTIME f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n
TP9  X  NEXT f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP10  X  PREV f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X g X  TRUE if and only if
TP11  X  UNTIL f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X  ; q  X  tc
TP12  X  UNTIL &lt;periods&gt; f p  X  tc p 1 ; ... ; tc p i ; ... ; tc
TP13  X  pUNTIL f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X  ; q  X  tc
TP14  X  fUNTIL f p  X  tc p 1 ; ... ; tc p i ; ... ; tc p n  X  ; q  X  tc Finally, we intuitively state the meaning of truth of each group of temporal predicates TP1 ... TP14. TP1  X  ALWAYS { p } p is always true along the time line stretching the past, present, and future. TP2  X  ALWAYS &lt;periods&gt; { p } p is always true for some periods of time.
 TP3  X  pALWAYS { p } p is always true in the past.
 TP4  X  fALWAYS { p } p is always true in the future.
 TP5  X  ANYTIME { p } p is true sometime along the time line stretching the past, present, and future. TP6  X  ANYTIME &lt;periods&gt; { p } p is true sometime for some periods of time.
 TP7  X  pANYTIME { p } p is true sometime in the past.
 TP8  X  fANYTIME { p } p is true sometime in the future.
 TP9  X  NEXT { p } p is true next time with a common granularity of all referenced temporal columns. TP10  X  PREV { p } p is true last time with a common granularity of all referenced temporal columns. TP11  X  UNTIL { p , q } q is true sometime along the time line and p is true till that moment. TP12  X  UNTIL&lt;periods&gt;{ p , q } q is true sometime for some time periods and p is true till that moment. TP13  X  pUNTIL { p , q } q is true sometime in the past and p is true till that moment.
 TP14  X  fUNTIL { p , q } q is true sometime in the future and p is true till that moment.

For illustration, we present a few examples of SELECT statements on the two Emp and Dept temporal tables of the sample database. Examples 12 X 15 are temporal SELECT statements with join conditions.

Example 5. A non-temporal (current) query on the Emp temporal table with the principle of temporal upward compatibility: List employees who (now) work in the Sales department.
 SELECT e.REFC AS ID FROM Emp e
WHERE e.Dept.Department= X  X ales X ; ID E4
Example 6. A temporal query on the Emp temporal table using the ALWAYS temporal operator for a selection condition and ment during 1990 X 1995? SELECT e.REFC AS ID, ASELECT PERIOD( X 01-01-1990 X , X 01-01-1996 X ) {e.Name OF VARCHAR} AS NAME, FROM Emp e WHERE ALWAYS PERIOD ( X  01 -01 -1990  X , X  01 -01 -1996  X ) { e . Dept . Department = X  Sales  X  X ;
ID NAME SALARY E4 Jack 1/1/1990 1/1/1996 50 1/1/1990 1/1/1996
Example 7. A temporal query with the pALWAYS past temporal operator: Who are now the managers of the departments whose budgets are currently less than 500 and were always greater than 100? SELECT d.REFC AS ID, d.Manager AS MANAGER FROM Dept d WHERE d.Budget &lt; 500 AND pALWAYS { d . Budget &gt; 100 }; ID MANAGER D2 E1 D3 E4 D4 E3
Example 8. A temporal query with the pANYTIME past temporal operator: What are the name and salary histories of those employees who worked sometime in the Sales department in the past? SELECT e.REFC AS ID, ASELECT{e.Name OF VARCHAR} AS NAME, ASELECT{e.Salary OF NUMERIC} AS SALARY FROM Emp e WHERE pANYTIME { e . Dept . Department = X  Sales  X  X ;
ID NAME SALARY
E4 Jack 5/15/1950 12/31/9999 40 1/1/1980 1/1/1984
E5 White 12/1/1960 12/31/9999 30 1/1/1980 1/1/1984
Example 9. A temporal query with the PREV temporal operator: List employees whose salary of last month was greater than 40.
 SELECT e.REFC AS ID FROM Emp e WHERE PREV { e . Salary &gt; 40 }; ID E2 E3 E4 E5
Example 10. A temporal query with the NEXT temporal operator: List employees who are going to move to the Sales depart-ment next month.
 SELECT e.REFC AS ID FROM Emp e WHERE NEXT { e . Dept . Department =  X  X ales X  }; ID E4
Example 11. A temporal query with the pUNTIL past temporal operator: What are the name and salary histories of the employees who worked only in the Sales department until changing to the Marketing department in the past? SELECT e.REFC AS ID, ASELECT{e.Name OF VARCHAR} AS NAME, ASELECT{e.Salary OF NUMERIC} AS SALARY FROM Emp e WHERE pUNTIL { e . Dept . Department =  X  X ales X  , e . Dept . Department =  X  X arketing X  };
ID NAME SALARY
E5 White 12/1/1960 12/31/9999 30 1/1/1980 1/1/1984 Example 12. A non-temporal join on the Emp temporal table: List employees who have the same salary. SELECT e1.REFC AS ID1, e2.REFC AS ID2 FROM Emp e1, Emp e2 WHERE e1.REFC &lt; e2.REFC AND e1.Salary = e2.Salary; ID1 ID2 E2 E4
Example 13. A temporal join using the ALWAYS temporal operator on the Emp temporal table: List all employees who have had the same salary for February 1985 X  X ebruary 1986.
 SELECT e1.REFC AS ID1, e2.REFC AS ID2 FROM Emp e1, Emp e2 WHERE e1.REFC &lt; e2.REFC AND ALWAYS PERIOD (  X 02 -01 -1985 X  ,  X 03 -01 -1986 X  ){ e1 . Salary = e2 . Salary }; ID1 ID2 E1 E2 E1 E5
E2 E5
Example 14. A temporal join using the pUNTIL past temporal operator: List departments which always got the same budget as the Sales department until the Sales department got a greater amount.
 SELECT d1.REFC AS ID, d1.Department AS DEPARTMENT FROM Dept d1, Dept d2 WHERE d1.REFC &lt;&gt; d2.REFC AND d2.Department= X  X ales X  AND pUNTIL { d1 . Budget = d2 . Budget , d1 . Budget &lt; d2 . Budget }; ID DEPARTMENT D1 Toy
Example 15. A temporal join with the fALWAYS and pANYTIME temporal operators: List employees who always work in the same department from now but got different salaries sometime in the past.
 SELECT e1.REFC AS ID1, e2.REFC AS ID2 FROM Emp e1, Emp e2 WHERE e1.REFC &lt; e2.REFC AND fALWAYS { e1 . Dept = e2 . Dept } AND pANYTIME { e1 . Salary ! = e2 . Salary }; ID1 ID2 E3 E5
Although we allow the temporal operators to be applied to predicates, the following distributivity relations between the temporal operators and the Boolean connectives (NOT, AND, and OR) can be utilized for more complex temporal require-ments. Let p , q , and r be conventional predicates.
 ALWAYS { p AND q } ALWAYS { p } AND ALWAYS { q }.
 ALWAYS {NOT p } NOT ANYTIME { p }.
 ANYTIME { p OR q } ANYTIME { p } OR ANYTIME { q }.
 ANYTIME {NOT p } NOT ALWAYS { p }.
 NEXT { p OR q } NEXT { p } OR NEXT { q }.
 NEXT { p AND q } NEXT { p } AND NEXT { q }.
 NEXT {NOT p } NOT NEXT { p }.
 PREV { p AND q } PREV { p } AND PREV { q }.
 PREV { p OR q } PREV { p } OR PREV { q }.
 PREV {NOT q } NOT PREV { q }.
 UNTIL { p AND q , r } UNTIL { p , r } AND UNTIL { q , r }.
 UNTIL { p , q OR r } UNTIL { p , q } OR UNTIL { p , r }.
 queries by means of temporal operators as demonstrated in the examples. 6.3. SELECT clauses of temporal columns returned to DB users: A &lt;select_sublist&gt; is either a &lt;derived_non_temporal_column&gt; or a &lt;derived_temporal_column&gt;. [2]. In this case, no temporal aspect is concerned. A derived column can be any value expression that is defined in the non-temporal OR SQL language or in the core of SQL:2003, implemented in any existing ORDBMS. So, the evaluation of a derived non-temporal column is checked with regard to the presence of any temporal column reference.
If there is no presence of any temporal column reference, no temporal aspect exists. The evaluation of the derived non-temporal column that is being considered is usual.
 rived column is evaluated with current states of temporal columns. These temporal columns are treated as if non-temporal according to the principle of temporal upward compatibility.

Example 16. We want to know the current name of each employee. The Name temporal attribute is treated as if it were a non-temporal one.
 SELECT e.REFC AS ID, e . Name AS NAME FROM Emp e; ID NAME E1 Edward E2 Di E3 Johnson E4 Jack E5 White
Different from a &lt;derived_non_temporal_column&gt;, a &lt;derived_temporal_column&gt; is defined below.
The ASELECT construct provides the notion of history oriented selection examined on one or many attribute histories of
FROM and WHERE clauses. For the evaluation of a &lt;derived_temporal_column&gt;, we consider three main parts of a three parts will be detailed as follows in the semantics explanations S1, S2, and S3, respectively. S1  X  &lt;value_expression&gt; OF &lt;type_name&gt; language [2] or in the core of SQL:2003, implemented in an ORDBMS.

If ASELECT wraps no column reference that refers to an attribute history at a temporal column, sequenced semantics has no impact on the returned value. The evaluation of a derived temporal column is the same as the one of a derived non-temporal column without the ASELECT construct.

If one or many attribute histories involve in a &lt;value_expression&gt; via one or many column references which are now supplied type (e.g. MDSYS.SDO_GEOMETRY on Oracle 10g), a user-defined type (e.g. T3D.TYPE1, which is a user-defined type under the T3D schema), or a REF type (e.g. REF(Dept_t)), etc. This data type will be the data type of the time-dependent component of every temporal composition of the resultant collection at a derived temporal column.
Let {(av j ,1 , vt j ,1 ), ... ,(av j , c , vt j , c ), ... ,(av tc
We can rewrite a &lt;value_expression&gt; as F ( tc 1 , ... , tc tc 1) 2 tc3 = F ( tc 1, tc 2, tc 3).

The evaluation S1 of a &lt;value_expression&gt; with sequenced semantics is shown below to compute each temporal composition (av j , c , vt j , c ) in the result of the evaluation S1. " c 1 in 1.. h 1, ... , ci in 1.. hi , ... , cn in 1.. hn , Example 17. We can think of the whole history of something/someone, e.g. the history of each employee X  X  name. SELECT REFC AS ID, ASELECT { Name OF VARCHAR } AS NAME FROM Emp;
ID NAME E1 Ed 2/1/1982 1/1/1988 E2 Di 1/1/1982 12/31/9999 E3 John 1/1/1962 1/1/1978 E4 Jack 5/15/1950 12/31/9999 E5 White 12/1/1960 12/31/9999 S2  X  ON &lt;search_condition&gt;
If specified, this part allows some conditions to be specified on the time-dependent component of each temporal compo-uation S1 with extra consideration on a &lt;search_condition&gt; to gain the evaluation S2 in Fig. 2 . Let tc tc data type of a returned value. A returned value of P is either TRUE or FALSE.
 compute each temporal composition (av j , c , vt j , c ) in the result of the evaluation S2. " c 1 in 1.. h 1, ... , ci in 1.. hi , ... , cn in 1.. hn ,
A sample result of the illustration in Fig. 2 is obtained: ASELECT { F ( tc vt Example 18. We can think of the history of each employee X  X  name different from  X  X ohn X .
 SELECT REFC AS ID, ASELECT { Name OF VARCHAR ON Name ! =  X  X ohn X  } AS NAME FROM Emp;
ID NAME E1 Ed 2/1/1982 1/1/1988 E2 Di 1/1/1982 12/31/9999 E3 Johnson 1/1/1978 12/31/9999 E4 Jack 5/15/1950 12/31/9999 E5 White 12/1/1960 12/31/9999 S3  X  &lt;periods&gt;
If &lt;periods&gt; is not specified, the resultant collection of temporal compositions {(av obtained from the evaluations S1 and S2 will be returned to temporal DB users.
 positions is returned at a derived temporal column to form a temporal table for temporal DB users. With a confinement on validity, a resultant collection is {(av j ,1 , vt j ,1 vt j , h \ &lt;periods&gt;)}. If vt j , c \ &lt;periods&gt; is an empty set, ( av employee X  X  name different from  X  X ohn X  in 1985 X 1990.

SELECT REFC AS ID , ASELECT PERIOD (  X 01 -01 -1985 X  ,  X 01 -01 -1991 X  ){ Name OF VARCHAR ON Name ! =  X  X ohn X  } AS NAME FROM Emp;
ID NAME E1 Ed 1/1/1985 1/1/1988 E2 Di 1/1/1985 1/1/1991 E3 Johnson 1/1/1985 1/1/1991 E4 Jack 1/1/1985 1/1/1991
E5 White 1/1/1985 1/1/1991 6.4. GROUP BY and HAVING clauses
Regarding temporal aggregations, [8] gives an overview on existing works that provide a support for aggregating tempo-[2] with the GROUP BY and/or HAVING clauses and aggregate functions in consideration on the temporal aspect of involved [55] shows how complicated temporal data aggregation is with the use of the non-temporal standard SQL language where the coalescing of resultant rows is explicitly done by DB users.
 poral columns and unable to derived temporal columns. So, part of a temporal extension for the support of the GROUP BY and/or HAVING clauses in our language is a collection of our temporal aggregate functions. These functions are tCOUNT{}, tMAX{}, tMIN{}, tAVG{}, and tSUM{} where tCOUNT{} can be applied to temporal data of any data type, tMAX{} and tMIN{} can be applied to temporal data of a data type with a partial ordering such as alphanumeric and DATE data types, and the others only to temporal numeric data. Each of them takes one derived temporal column as an input. The formulation of a SELECT statement with aggregate functions is also described in the form of SELECT..FROM..WHERE shown in three previous
Sections 6.1 X 6.3 . Example 20. List the number of employees whose names are always different from  X  X ohn X  and their highest salaries. SELECT COUNT ( REFC ) AS EMP#, tMAX { ASELECT { Salary OF NUMERIC }} AS SAL_MAX FROM Emp WHERE ALWAYS {Name != X  X ohn X  X ;
EMP# SAL_MAX 4 40 1/1/1980 1/1/1984
If specified, the GROUP BY and HAVING clauses are shaped with conventional production rules in [2]. Like derived non-temporal columns, derived temporal columns might be present in the two clauses and aggregate functions. As we know, one in Section 6.2 with or without aggregate function invocations and applied to each group from the partitioning of the rows of the input table returned by the evaluation of the GROUP BY clause. Using the specification of the GROUP BY and/ or HAVING clauses, existing non-temporal aggregate functions, and our temporal aggregate functions, we show a non-pro-cedural formulation of grouping and aggregation on a temporal table. The temporal semantics are examined below for three cases: grouping with temporal upward compatibility, grouping with no temporal aspect, and grouping with the temporal aspect. i. Grouping with temporal upward compatibility
In this case, temporal column references might be present in the SELECT, GROUP BY, and/or HAVING clauses but their temporal aspect is not considered. None of our new temporal constructs is allowed in the SELECT, GROUP BY, and/or HAVING clauses. So, existing non-temporal aggregate functions are applied to temporal columns instead of our temporal aggregate functions. These temporal columns are treated as if they were non-temporal with the principle of temporal upward compatibility.
 Example 21. List the highest salary at each department at present.
 SELECT Dept AS DEPT_ID, MAX(Salary) AS SAL_MAX FROM Emp GROUP BY Dept; DEPT_ID SAL_MAX D2 40 D1 50 D4 55
D3 50 ii. Grouping with no temporal aspect
Grouping with no temporal aspect is done with a &lt;grouping_element_list&gt; that contains one or many derived non-tem-poral columns and no derived temporal column. One or many non-temporal aggregate functions are independently invoked on derived non-temporal columns, and one or many temporal aggregate functions independently on derived temporal col-ation step, an input of this function is an attribute history at the derived temporal column of each row in the group poral aggregate function at the termination stage of the aggregation after the coalescing of temporal compositions. Each temporal composition (av j , c , vt j , c ) of the resultant attribute history shows aggregation av follows for each group g of n rows determined by the grouping derived non-temporal columns. Let r 1 , ... , r i , r i +1 , ... , r n be n rows of the g group for n P 1 and i in 1.. n .
Let A j be a derived temporal column on which a temporal aggregate function tAGG is invoked. tAGG can be tCOUNT{}, tMAX{}, tMIN{}, tAVG{}, or tSUM{}. At each iteration of aggregation, A bute history of the derived temporal column in one r i row.

For tCOUNT{} without the DISTINCT keyword, let Ag ={(av_count
For tMAX{}, Ag ={(av_max j ,1 , vt _max j ,1 ), ... ,(av_max
For tMIN{}, Ag ={(av_min j ,1 , vt _min j ,1 ), ... ,(av_min
For tAVG{}, Ag _sum={(av_sum j ,1 , vt j ,1 ), ... ,(av_sum vt
For tSUM{}, Ag = {(av_sum j ,1 , vt _sum j ,1 ), ... ,(av_sum
Step 2. Create a set tinterval of all intervals of time from tpoint : tinterval ={[ P
Step 3. Calculate an aggregation Ag for the current stage by examining the outcome of the previous stage and then the A
For all temporal compositions (av k , vt k 1 ), (av k , vt new temporal composition (av k , vt k 1 [ vt k 2 [[ vt kc tions (av k , vt k 1 ), (av k , vt k 2 ), ... , and (av k dent component of a temporal composition is an aggregation value for some time periods.

Example 22. For each gender, list the number of employees and the highest salary that employees have been paid along time.
 SELECT Gender, COUNT(REFC) AS EMP#, tMAX { ASELECT { Salary OF NUMERIC }} AS SAL_MAX FROM Emp
GROUP BY Gender;
Gender EMP# SAL_MAX
M 3 40 1/1/1980 1/1/1984
F 2 30 1/1/1980 1/1/1984 iii. Grouping with the temporal aspect temporal column and no derived non-temporal column. As of this moment, our language allows only one grouping column groups. Each group is associated with a distinct value at the grouping derived temporal column and a period of time when that value is true in reality. In particular, let g 1 , ... , g column. For any k in 1.. m , the g k group is associated with ( v of some temporal composition at the derived temporal column and p and g k 2 groups for any k 1 and k 2 in 1.. m and k 1&lt;&gt; k 2, there is a constraint such that v equal to v k 2 then p k 1 must be disjoint from p k 2 .

After the grouping along the time axis, non-temporal/temporal aggregation can be made on each g input table with one or many non-temporal/temporal aggregate functions independently invoked on derived non-temporal/ 6.4.ii.

The evaluation steps of the GROUP BY clause with a grouping derived temporal column A
A column of the input temporal table ut1 after the evaluation of the FROM and WHERE clauses are shown below. Let
NA , NA 2 , ... , and NA n 1 be n 1 derived non-temporal columns on which non-temporal aggregate functions AGG and AGG n 1 () are invoked, respectively. Let TA 1 , TA 2 ments that can be executed by an ORDBMS.
 The transformation steps are presented as follows. Given the following statement:
SELECT ASELECT [&lt;periods_ A j &gt;] { A j OF &lt;type_name&gt; [ON &lt;search_condition&gt;]}, AGG FROM ut1 GROUP BY ASELECT [&lt;periods&gt;] { A j OF &lt;type_name&gt; [ON &lt;search_condition&gt;]} HAVING &lt;search_condition&gt;; Step 2. Create a set tpoint of all distinct points in time at the grouping derived temporal column. Step 3. Create a set tinterval of all adjacent intervals of time.

Step 5. Partition the rows of ut3 and compute non-temporal/temporal aggregations with non-temporal/temporal aggregate CREATE TABLE tresult AS SELECT DISTINCT f.vtStart, l.vtEnd, f. A j , f.Ag FROM taggregation f, taggregation l
WHERE f.vtStart &lt; l.vtEnd AND f. A j =l. A j AND f. Ag
AND tEqual(f. TAg 1 ,l. TAg 1 ) =  X  X RUE X  AND ... AND tEqual(f. TAg AND NOT EXISTS (SELECT FROM taggregation m AND NOT EXISTS (SELECT FROM taggregation r2 Example 23. List the number of employees whose names always start with  X  X  X  at each department in 1980-1985. SELECT ASELECT PERIOD( X 01-01-1980 X , X 01-01-1986 X ) {Dept OF REF(DEPT_T)} AS DEPT_ID, COUNT(REFC) AS EMP# FROM Emp WHERE ALWAYS {Name LIKE  X  X % X  X  GROUP BY ASELECT PERIOD (  X 01 -01 -1980 X  ,  X 01 -01 -1986 X  ){ Dept OF REF ( DEPT _ T )}; DEPT_ID vtStart vtEnd EMP# D4 1/1/1980 1/1/1986 1 D3 1/1/1984 1/1/1986 1 Example 24. List the highest salary at each department that has had less than 20 employees along time. SELECT ASELECT {Dept OF REF(DEPT_T)} AS DEPT_ID, tMAX { ASELECT { Salary OF NUMERIC }} AS SAL_MAX FROM Emp GROUP BY ASELECT { Dept OF REF ( DEPT _ T )}
HAVING COUNT (REFC) &lt;20;
DEPT_ID vtStart vtEnd SAL_MAX
D1 1/1/1982 12/31/9999 30 1/1/1982 8/1/1984 D2 4/1/1987 12/31/9999 40 4/1/1987 12/31/9999 D4 1/1/1980 1/1/1984 40 1/1/1980 1/1/1984
D4 1/1/1984 12/31/9999 45 1/1/1984 1/1/1989 D3 1/1/1980 1/1/1984 30 1/1/1980 1/1/1984
D3 1/1/1984 12/31/9999 50 1/1/1984 12/31/9999 7. Temporal extension for data modifications
Temporal data modifications are made on temporal tables. These modifications include insert, delete, and update activ-a column to another value true for some periods of time. Among existing INSERT, DELETE, and UPDATE statements, only the UPDATE statements perform at the attribute level while INSERT and DELETE statements at the tuple/object level.
All existing SQL modification statements work in our proposed language. Based on the principle of temporal upward com-period [NOW, INFINITY+) of valid time.

Moreover, we introduce a new temporal construct VALIDTIME to all conventional SQL modification statements in order to include into each modification the periods of applicability provided by users. Also, we define a new temporal statement
ADELETE which is a counterpart of the DELETE statement at the attribute level. The function of ADELETE is to remove the temporal fact is formed and a temporal update statement is issued instead. 7.1. INSERT statements
The syntax of the INSERT statement of our language is as follows. &lt;insert_value_list&gt;::= &lt;value_expression&gt; j &lt;insert_value_list&gt; &lt;comma&gt; &lt;value_expression&gt; &lt;temporal_value_expression&gt; ::= &lt;value_expression&gt; VALIDTIME &lt;periods&gt;
A temporal INSERT statement is different from a non-temporal INSERT statement since it includes one or many &lt;tempo-lection of combinations each of which comprises a value expression and the VALIDTIME clause. Each are determined as normal.

Example 25. A new department has been established. The name is RD. The manager has not yet been assigned. The given budget is approximately 300. The information of the new department is now recorded using a non-temporal (current) insertion on the Dept temporal table.
 INSERT INTO Dept (Department, Manager, Budget) VALUES ( X  X D X , NULL, 300); Example 26. Consider a temporal insertion on a temporal table. The statement is issued with the use of the new construct
VALIDTIME to record the information of a new employee according to an employment plan with different periods of validity provided by the user. A new employee has a current name Jane. She was born on 01/21/1970. She hopefully works in the new department RD from 01/01/2010. Besides, her salary is known to be 35 in 1990 X 1994 and 40 from 1995. INSERT INTO Emp (Name, Gender, D_birth, Salary, Dept)
VALUES (  X  X ane X  ,  X  X  X , TO_DATE( X 01-21-1970 X ,  X  X m-dd-yyyy X ), 7.2. DELETE statements tion 6.2. Otherwise, all rows present in a temporal table are taken into consideration. The syntax of a DELETE/ADELETE statement is described as follows. the evaluation of the WHERE clause if specified. Otherwise, let r be one row of the input temporal table. Let r . A fact grouped in the r row. Using the definitions in Section 3.3, r . A
D1  X  A DELETE statement formed by the production rule D1 will be evaluated at the tuple level according to the principle of time. Each temporal fact is achieved as: r . A j = {(av (av j , h ,vt j , h -{[NOW, INFINITY+)})}. If vt j , c -{[NOW, INFINITY+)} is an empty set, av
Example 27. Remove all data of the employees who currently work in the Sales department as the Sales department is going the tuple level.
 DELETE FROM Emp WHERE Dept.Department= X  X ales X ;
D2  X  A DELETE statement formed by the production rule D2 will be evaluated in the same way as the one by D1 with the r . A j = {(av j ,1 , vt j ,1 -&lt;periods&gt;), ... , (av j , c excluded for c in 1.. h .

Example 28. A temporal deletion at the tuple level: Remove all data of the employee whose name is Ed, true for 1985-1986 because it is realized that he has been absent from his department for 1985-1986.
 DELETE FROM Emp VALIDTIME PERIOD (  X 01 -01 -1985 X  ,  X 01 -01 -1987 X  ) WHERE ALWAYS PERIOD( X 01-01-1985 X , X 01-01-1987 X ) {Name= X  X d X  X ;
D3  X  The production rule D3 adapts the DELETE statement with a new temporal clause ADELETE at the attribute level to in a single row. Each removal of a temporal elementary fact is also made for some user-supplied periods of time in a new temporal clause ATTRIBUTES. The evaluation of an ADELETE statement is the same as the one of D2 for specified temporal facts, not for all. So, r . A j = {(av j ,1 , vt j ,1 -&lt;periods&gt;), ... , (av
ATTRIBUTES clause. If vt j , c -&lt;periods&gt; is an empty set, av
Example 29. Remove the salary data of the period 1988 X 1990 of all employees working at the Marketing department some Emp temporal table at the attribute level is issued below.
 ADELETE FROM Emp ATTRIBUTES ( Salary VALIDTIME PERIOD (  X 01 -01 -1988 X  ,  X 01 -01 -1991 X  ))
WHERE ANYTIME {Dept.Department= X  X arketing X  X ; 7.3. UPDATE statements
The syntax of an UPDATE statement in the proposed language is defined as follows: &lt;tsql_update_stmt&gt;::= UPDATE &lt;temporal_table_name&gt; SET &lt;set_list&gt; [WHERE &lt;search_condition&gt;] &lt;set_list&gt;::= &lt;column_assignment&gt; j &lt;set_list&gt; &lt;comma&gt; &lt;column_assignment&gt; &lt;column_assignment&gt; :  X  &lt;column_name&gt; &lt;equals_operator&gt; &lt;value_expression&gt; j &lt;column_name&gt; &lt;equals_operator&gt; &lt;value_expression&gt; VALIDTIME &lt;periods&gt;
For the semantics explanation, let r be one row in the resultant collection of rows after the evaluation of the WHERE input temporal table. Let A j be a temporal column specified in the SET clause and r . A row. From Section 3.3, r . A j = {(av j ,1 , vt j ,1 ), (av signed to A j in the SET clause. The data type of av new is AT
If A j is specified in the SET clause without the VALIDTIME clause, the evaluation of A poral upward compatibility. The attribute history of a temporal fact corresponding to A poral compositions each of which is  X  av j ; c 0 , vt j ; c 0  X  " c in 1.. h ,ifav j , c !=av new and vt j , c  X  {[NOW, INFINITY+)} != ; , then av  X  " c in 1.. h ,ifav j , c != av new and vt j , c  X  {[NOW, INFINITY+)}= ; , then (av  X  " c in 1.. h ,ifav j , c =av new , then av j ; c 0  X  av ral composition (av new , {[NOW, INFINITY+)}) is included.
 Example 30. Consider a non-temporal (current) update on the Emp temporal table. The employee whose current name is White has decided to move to the new department  X  X D X . So, her department is now  X  X D X .
 UPDATE Emp SET Dept =( SELECT d . REFC FROM Dept d WHERE d . Department =  X  X D X  ) WHERE Name= X  X hite X ;
If A j is specified in the SET clause with the VALIDTIME clause, the evaluation of A same as the one without the VALIDTIME clause for the periods of time supplied by temporal DB users instead of [NOW,
INFINITY+). The attribute history of a temporal fact corresponding to A  X  " c in 1.. h ,ifav j , c != av new and vt j , c -&lt;periods&gt; ! = ; , then av  X  " c in 1.. h ,ifav j , c != av new and vt j , c -&lt;periods&gt;= ; , then (av  X  " c in 1.. h ,ifav j , c =av new , then av j ; c 0  X  av position (av new , &lt;periods&gt;) is included.

Example 31. Consider a temporal update on the Salary temporal attribute of the Emp temporal table: the salary of an employee will be 60 for 1990 X 1995 if he/she works in the Sales department for 1990 X 1995.
 UPDATE Emp SET Salary = 60 VALIDTIME PERIOD (  X 01 -01 -1990 X  ,  X 01 -01 -1996 X  )
WHERE ALWAYS PERIOD ( X 01-01-1990 X , X 01-01-1996 X ) 8. Language implementation
In this section, an overview on our language implementation is presented with the architecture of our temporal object relational database system in Fig. 3 .

The implementation is carried out using Oracle 10g for both embedded and interactive SQL modes. Using object relational technology, all existing interfaces can be inherited to offer non-temporal and temporal DB users a temporal transparency environment. However, our implementation is not product-specific to the employed Oracle ORDBMS. It can be a portal to any ORDBMS that allows the extensibility of user-defined types, user-defined methods, and optimization methods.
The temporal extension is a temporal data cartridge easily and directly integrated into the non-temporal ORDBMS. It in-8.5 for the transformation of temporal SQL statements into conventional SQL statements temporally enhanced with our tem-poral data types and methods. Wrapped in our appropriate translation stored-procedure, a temporal SQL statement is di-rectly submitted to the non-temporal ORDBMS with our temporal extension via an existing interface. 8.1. Meta tables butes, temporal columns, and integrity constraints on temporal columns and tables. They are ALL_T_TYPES, ALL_T_TABS,
ALL_T_ATTRS, ALL_T_COLS, and ALL_T_CONS, respectively. Metadata is populated into an appropriate meta table from the transformation of a temporal data manipulation statement (SELECT, INSERT, DELETE/ADELETE, or UPDATE). 8.2. Temporal data types Corresponding to a period of time, a set of periods of time, a temporal composition, and an attribute history defined in Section 3.3, four temporal data types: VTPERIOD, VTPERIODS, ANYTEMPORALVALUE, and ANYTEMPORALDATA are defined. The VTPERIODS type is a collection type of the VTPERIOD type and ANYTEMPORALDATA of ANYTEMPORALVALUE. The
SYS.ANYDATA opaque data type provided by an ORDBMS is used as the data type of the time-dependent component of a temporal composition so that our temporal support is given to data of any type. 8.3. Temporal methods
We classify our temporal methods into three following groups. These methods can be non-restrictively used in the same way as built-in and DBMS-supplied methods. So, nonsequenced statements are allowed.
 Group 3. Group 3 includes functions GetXXX(SYS.ANYDATA) to extract data of any type from an instance of the SYS.ANYDA-8.4. Translation of temporal SQL data definition statements Using the ANYTEMPORALDATA temporal data type, the translation of a temporal SQL data definition statement is made. poral SQL statements in Example 1 is partially shown below.
 CREATE TYPE Dept_t ( CREATE TABLE Dept OF Dept_t ( ) OBJECT IDENTIFIER IS SYSTEM GENERATED NESTED TABLE Manager STORE AS Manager_nt (NESTED TABLE ValidTime STORE AS Manager_vt_nt)
NESTED TABLE Budget STORE AS Budget_nt (NESTED TABLE ValidTime STORE AS Budget_vt_nt); 8.5. Translation of temporal SQL data manipulation statements
Using the temporal methods in Section 8.3, the translation of temporal SQL data manipulation statements is performed in for sequenced semantics are not understood by the employed ORDBMS. In contrast, non-sequenced SQL statements with the direct use of our temporal data types and methods are executable by the ORDBMS which is extended with our temporal extension. For a demonstration, we show the translation results of Example 12 for the use of current methods, Example 22 for the use of a temporal aggregate function, and Example 29 for the use of a sequenced deletion method. Example 12  X  SELECT e1.ROWID AS ID1, e2.ROWID AS ID2
Example 22  X  SELECT Gender, COUNT(ROWID) AS EMP#, Example 29  X  UPDATE Emp 9. Conclusion In this paper, a temporal object relational SQL language with the valid time support at the attribute level is proposed. orientation can be reached. Moreover, our temporal support is generalized and independent of the time-varying of data of data warehouses such as the one proposed in [31].

In summary, the proposed language allows upward compatibility with normal SQL, temporal upward compatibility, tem-management in a non-procedural manner and serves a wide range of both non-temporal and temporal users. With the use of poral aspect. By means of temporal operators ALWAYS, ANYTIME, NEXT, PREV, and UNTIL which are from the temporal logic, users can deal with temporal data querying with ease and intuition. Furthermore, users are not required to study any new interface for the submission of temporal SQL statements to an ORDBMS with our integrated temporal extension, which is now part of the employed ORDBMS. The proposed language has been examined based on examples adapted from those found in [25]. Although only attribute timestamping has been done in our language, tuple timestamping can be supported in a non-sequenced manner using our temporal data types and methods.
 the scope of this paper.

References
