 In this paper we describe an approach for service discovery sup-ported by semantic annotations. We propose a metamodel repre-sentation of both the WSDL documents and the associated semantic annotations. Based on this metamodel, effective service discovery is achieved by a Datalog engine implementing flexible matchmak-ing techniques that allow both exact and partial matches among search results. The metamodel is supported by a storage system that ensures scalability of the entire process. Finally we illustrate experiments on a public dataset of semantic service descriptions. H.2.1 [ Database Management ]: Logical Design; H.2.4 [ Database Management ]: Systems X  query processing ; H.3.5 [ Database Man-agement ]: Online Information Services X  Web-based services Management, Performance Semantic Web Service, Service Matchmaking, Datalog, Metamodel
Web services promise easy access to remote content and appli-cation functionality, regardless of what is the provider X  X  platform, the location, the service implementation, or the data format. Web Service Description Language (WSDL) allows a structured way to standardize the description of Web service interfaces. WSDL only supports syntactical comparison between interfaces. To enable the automation of all tasks associated with Web services application (i.e., discovery, composition and invocation), Semantic Web tech-nologies have been applied to extend Web service representation. Several semantic models have been proposed and built on top of the WSDL standard (e.g., WSMO , OWL-S , SAWSDL ), on which automa-tion of Web service discovery and composition rely. An alternative solution is to provide a mapping between WSDL and RDF , enabling the ability to read WSDL documents as RDF files. Kopecky 1 a representation of WSDL2.0 into RDF and OWL models, and il-lustrates a mapping procedure for transforming WSDL descriptions into their RDF form. However the use of RDF model, as it is, pro-vides relevant issues of efficient data management (i.e., storage and scalability).
 This paper aims at addressing interoperability issues in Semantic Web service discovery due to different Semantic Web Service mod-els by compiling both the service interface and the semantic model into a metamodel representation. The approach presented here is built for the efficient management of Semantic Web data, which provides advanced and up-to-date ontology reasoning capabilities based on Datalog  X  [3], a Datalog-like formalism that allows rule-based querying and reasoning over ontologies. We follow a process that starts with the definition of a meta-representation of the chosen data model at a conceptual level. We select a fragment of our meta-model, we map the service interface and the semantic model into that fragment and we perform a logical translation for a relational database. At the physical level, we choose optimization techniques based on indexing and partitioning. Finally, we implement a flex-ible semantic service matchmaking algorithm, properly translated into Datalog  X  programs and executed on the Semantic Web service descriptions stored in our system. Following recent service match-making solutions [2, 5, 7], our implemented algorithm allows for partial matches among search results. Available solutions apply in a combined way deductive techniques and heuristics based on IR al-gorithms for ensuring better precision and recall, but they are based on complex semantic models (such as OWL-S and WSMO )andthey also suffer from scalability problems. With respect to the existing efforts, our metamodel constitutes a generic representation of ser-vice interface, instead of considering ad-hoc solutions. For what concerns service matchmaking, the metamodel is supported by a storage system that relies on well established and efficient database technologies, ensuring better scal ability, as shown in preliminary experiments. In the following, we briefly present the metamodel (Section 2), the service retrieval approach (Section 3) and the ex-perimental evaluation (Section 4). Finally we sketch conclusion and future work (Section 5).
Figure 1 sketches an UML-like representation of our metamodel (inspired by [1]), where the dashed line divides schema constructs from instance constructs. The marked boxes represent constructs with corresponding attributes and the arrows are references be-tween constructs. The storage system based on the metamodel is characterized by three levels as follows: (i) a conceptual level , http://www.w3.org/TR/wsdl20-rdf/ containing the conceptual model shown in Figure 1; (ii) a logical level , implementing our conceptual model into a logical one (in our case we use the relational model); (iii) a physical level , defining the physical design and optimization details. The detailed presentation of the metamodel can be found in [4]. Here we will focus on the representation of Semantic Web services within the metamodel and we will use a running example to simplify the presentation of our approach.
 We consider a Semantic Web service as a pair S , A ,where the WSDL-based service interface description and A is the corre-sponding semantic annotation. We import both S and A separately in the storage system and then we link S to A . To import a WSDL document, we characterize the set of basic constructs which de-scribe the document, that we will call WSDL metamodel . We select a fragment of the metamodel illustrated in Figure 1 (enclosed in the dashed box) and we define a mapping between the two collections of constructs. M WSDL  X  basic represents the core set of constructs to describe a WSDL document (according to the WSDL 2.0 pro-posal 2 ). Formally we define: The main component is C description having the attribute target-Namespace to identify the WSDL components occurring in the document. C description is related to four elements. C types scribes the format of messages used for service inputs and out-puts. C interface describes the abstract functionalities of the ser-vice. C binding specifies the implementation details necessary to access the service, that is, a concrete message format and commu-nication protocols for each operation. Finally C service describes where the service can be accessed.

As a running example, let X  X  consider a Web service S 1 to book an accomodation in a given city specified as input. The service also provides the available activities at the reserved structure, as expressed in the following using the SAWSDL language: Figure 2: Representation of a sample service in the metamodel. Figure 2 shows the representation of the service with metamodel constructs. Nodes correspond to C Individual and C Class , while logical level, we import the document as illustrated in Figure 3, where we considered instance constructs. Each table presents the
Figure 3: Instance constructs to model the running example. references to the corresponding schema constructs. URIs assigned to entries of the Individual table are composed by three parts: (i) the namespace of the document, (ii) information about the consid-ered component (e.g. an operation, a message and so on), and (iii) the path to reach the component following the XPointer syntax In the figure we used short names as uriService or uriInterface to simplify the notation.

To import the annotation we follow a similar procedure and at the end we link the annotation with the corresponding WSDL. For instance, Figure 4 shows how the semantic annotation associated to
S 1 is imported in our system. We introduced two entries Book-ing and City in Class table representing the two concepts in an external ontology and one entry linkTO in ObjectProperty ta-ble, representing the reference annotation between a WSDL ele-ment and a concept. In this case we had to introduce the entry Thing because the domain and range of linkTO are generic (un-known). Moreover, we have two entries in Individual table, identified by OIDs ind5 and ind6 , representing instances (e.g., annotations) of Booking and City , respectively, and two entries in the i-ObjectProperty table, identified by OIDs obj4 and obj5 , representing instances of linkTO .

The resulting tables of logical level could be very large. To this aim at physical level we use a p artitioning tec hnique, where one large table is splitted into smalle r physical pieces. T he partitioning of a table is processed by the range defined on it. In other words the table is divided into different partitions defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions (see [4] for more details).
To enable efficiency and scalability, Web Service discovery is performed on the proposed storage system through Datalog  X  grams and rules that use predicates, classes and roles presented in the previous section. A unary predicate corresponds to each class and a binary predicate corresponds to each role. For instance, the atom Service ( X ) corresponds to the class Service and the atom implements ( X, Y ) corresponds to the role implements .These are called first-level ontology predicates (FLOPs) . Moreover, by means of the rules, users can define their own predicates, of any arity. FLOPs are used to express queries for service retrieval. We classified different kinds of matches, according to the definitions found in literature for hybrid serv ice matching approaches [2]: Exact -constitutes a very strong cond ition, according to which the retrieved results present exactly the required operation and the re-quired inputs/outputs; Plug-in -constitutes a relaxed version of exact match, according to which the retrieved results present the required operation, all the required outputs and present at most the inputs in the query, allow-ing as operation name or input/output names also sub-concepts of those specified in the query; http://www.w3.org/TR/xptr/ Partial -to include among the retrieved results those services that present the required operation (or a more specific one) and at least one of the required inputs/outputs; Mismatch -otherwise.

The use of Datalog rules enables precision in search results, as shown in logic-based service discovery approaches [6]. Since ex-act matches are not frequent, inclusion of partial matches also im-proves query recall. Our storage system ensures better scalability with respect to existing solutions (see experiments in the next sec-tion). Given a service query S , where an operation op S and a set of outputs { out i S } are required, the set of services that present an E XACT match with S is given by the following Datalog rule r1 : where ? x denotes a Datalog variable. In particular, OP( ? x denotes the set of services that provide the operation semantically annotated with a concept op S , as shown in the following rule r2 : Similarly, OUT( ? x , out i S ) denotes the set of services which provide the output semantically annotated with a concept out i S ,asshown in the following rule r3 : The Datalog rule which retrieves services which present an input semantically annotated with a concept in j S , denoted as IN( is evaluated in the same way.
 Example. The service S 1 introduced in the previous section ( re-servationService ) executes the booking operation, that is semantically annotated through a Booking concept, and requires the input that is annotated through the City concept (see tables in Fig. 3).

The requirements that must be satisfied to obtain an E XACT are very restrictive. To improve recall of query results, we relaxed the E XACT match by allowing that operations (respectively, inputs, outputs) are annotated with more specific concepts with respect to those annotating operations (respectively, inputs, outputs) in the re-quired service. The set of services that present a P LUG -with S is given by the following Datalog rule r4 : In particular, d OP ( ? x , op ) (resp., OUT ( ? x , out ), notes the set of services which provide an operation (resp., an out-put, an input) annotated with a concept op (resp., out , in specific concept. This is formally expressed through the following recursive Datalog program p1 : Finally, we further relaxed the P LUG -IN match, considering the P ARTIAL match definition. The set of services which present a P
ARTIAL match with S is given by the following recursive Datalog program p2 : Note that the set of partial matches includes the set of plug-in matches, that in turn includes the set of exact matches.
Several experiments have been done to evaluate the performance and effectiveness of our framework, that we call SeeVa . Our bench-marck system is a dual quad core 2.66GHz Intel Xeon, running Linux Gentoo, with 8 GB of memory, 6 MB cache, and a 2-disk 1Tbyte striped RAID array. We implemented our experiments us-ing PostgreSQL 8.3. We used two versions of a public available dataset expressed both in OWL-S and SAWSDL respectively. The first version is OWL-S Service Retrieval Test Collection (OWLS-TC v2.2) 4 . It is a OWL-S service retrieval test collection to support the evaluation of the performance of OWL-S semantic Web service matchmaking algorithms. This dataset consists of 1,077 Web ser-vices. The second version is the SAWSDL Service Retrieval Test Collection 5 (semi-automatically derived from OWLS-TC 2.2), in-tended to support the evaluation of the performance of SAWSDL service matchmaking algorithms. We compared efficiency and per-formance of three systems: OWLS-MX [5], SAWSDL-MX [8] and our system that we called Seeva . In particular, for OWLS-MX we adopted the pure logic semantic matching (i.e. OWLS-M0), and the logic-based variant for SAWSDL-MX. We submitted the 29 queries of the benchmark to each system.

The goal of our experiments is to evaluate both efficiency and effectiveness of our approach. The efficiency evaluation measures the scalability of the system with respect to the increasing number of services. Figure 5 shows the average response time (msec) with respect to EXACT , PLUGIN and PARTIAL match of our system and the OWLS-M0 performance. The results are very promising. For each kind of match the average query response time is always in the range [0, 300] msec. This is due to the internal data organiza-tion of our system at each level of abstraction (i.e., construct-based organization and partitioning). SeeVa outperforms OWLS-M0 in any case. The evaluation results for SAWSDL-MX are in line with the performance of OWLS-M0.

The effectiveness is evaluated by the interpolation between pre-cision and recall as shown in Figure 6. For each standard level of recall (i.e. 0.1, 0.2, ... , 1.0) we calculate the average max pre-cision of queries in [ r j ,r j +1 ] ,i.e. P ( r j )= max Also in this case SeeVa shows more effective (and correct) results than both OWLS-M0 and SAWSDL-MX. This experiment demon-strates how we have an overall best value of recall with respect to high values of precision. In despite of advanced features provided by much expressive semantic models (e.g. OWL-DL), in this con-
Available at http://projects.semwebcentral.org/frs/
Available at http://projects.semwebcentral.org/ text many available ontologies are just simple taxonomies. There-fore while the reasoners of other systems embed a complete expres-siveness, our framework focuses on a tractable fragment. In fact, the precision values in the range [0 . 8 , 0 . 9] are due to the subsump-tion between concepts used for the service annotation, such that the PARTIAL match introduces some failed results. In this paper we proposed a metamodel-based approach to describe the semantics associated to a Web service and we used Datalog to query and reason over large amounts of Semantic Web Services. Through Datalog  X  programs we retrieved suitable services for a given service request. In this way, capabilities of semantic mod-els are merged together with well-known, efficient techniques of database management systems and Datalog query engines. Experi-mental results demonstrated the effectiveness and efficiency of the proposal. Future work will be devoted to the study of other kinds of reasoning capabilities. Moreover the framework will be extended to offer automatic web service composition capabilities. [1] P. Atzeni, P. Cappellari, R. Torlone, P. A. Bernstein, G. [2] D. Bianchini, V. De Antonellis, M. Melchiori. Flexible [3] A. Cal X , G. Gottlob, and T. Lukasiewicz. A General [4] R. De Virgilio. Management of Semantic Web Services. [5] M. Klusch, B. Fries and K. Sycara. OWLS-MX: a hybrid [6] I. Horrocks and L. Li. A Software Framework for [7] F. Kaufer and M. Klusch. WSMO-MX: A Logic [8] M. Klusch, P. Kapahnke. Semantic Web Service Selection
