 Selecting and precomputing indexes and materialized views, with the goal of improving query-processing performance, is an important part of database-performance tuning. The significant complexity of the view-and index-selection prob-lem may result in high total cost of ownership for database systems. In this paper, we develop efficient methods that deliver user-specified quality of the set of selected views and indexes when given view-and index-based plans as problem inputs. Here, quality means proximity to the globally opti-mum performance for the input query workload given the input query plans. Our experimental results and compar-isons on synthetic and benchmark instances demonstrate the competitiveness of our approach and show that it provides a winning combination with end-to-end view-and index-selection frameworks such as those of [1, 2].
 Categories and Subject Descriptors:
G.1.6 [Numerical Analysis]: Optimization; G.4 [Mathe-matical Software]: Algorithm Design and Analysis; H.2.1 [Database Management]: Logical Design.
 General Terms: Algorithms, Design, Experimentation, Performance.
This paper addresses the problem of selecting and precom-puting indexes and materialized views in a database system, with the goal of improving the processing performance for frequent and important queries. 1 Our specific optimization problem, which we refer to as VISP (for View and Index Selection), is as follows: Given a set of possible plans for each query, choose a subset of plans that provides the great-est reduction in query costs. Each plan requires the mate-rialization of a set of views and/or indexes, and cannot be executed unless all of the required views and indexes are ma-terialized. The total size of materialized views and indexes must not exceed a given space (disk) bound. This version of the view-and index-selection problem is NP hard [3], and is
This paper is an abridged outline of our results; the details can be found in [5].
 need a single constraint (2) for each query and view/index. Recall that v t  X  p ij means that the j -th plan for query i requires view/index v t . That is, if v t is not selected ( y t = 0), none of the plans using v t can be chosen (all x ij = 0 where v t  X  p ij ). Constraint (3) says that the total size of the selected views/indexes cannot exceed the input storage limit B . These constraints fully define our view-and index-selection problem VISP. Branch and bound (B&amp;B) obtains optimum solutions to ILPs at the expense of worst-case exponential runtime. The algorithm starts with the root node of a tree, which repre-sents the initial problem instance. Other nodes represent smaller instances based on fixed variable assignments. A subtree can be pruned if the best gain its root can achieve (its upper bound ) is no better than the gain of a known fea-sible solution, the global lower bound . The success of B&amp;B in quickly obtaining optimal solutions relies on the quality of heuristics for obtaining upper and lower bounds.
Our experiments show that our upper-and lower-bound computations yield good scalability w.r.t. instance size, bet-ter solution quality as compared with the heuristic [1] when terminated early, and promising tradeoffs between runtime and solution quality. Please see [5] for the details.
In our work, we use Lagrangian Relaxation (LAR) (see, e.g., [4]) for obtaining upper bounds. LaR requires choosing the constraints to relax. The relaxed constraints are then incorporated into the objective function, so that there is a penalty associated with an unmet constraint. The details of this step can be found in [5]. LaR has several key advantages in the B&amp;B context, as LaR can be used: We use Lagrangian heuristics to obtain good lower bounds. Our algorithm transforms a solution to the Lagrangian re-laxation into a feasible solution. The idea of the Lagrangian heuristics is to take a (infeasible) solution to the Lagrangian relaxation of the original problem and to modify it as little as possible to get a feasible solution. The idea is to first take a feasible part of the solution to the LaR, and to then greedily fill in the remaining free space thus maximizing the benefit of the solution, see [5] for the details.
Figure 1 shows the scalability of our algorithm for differ-ent maximum allowed errors. Each curve corresponds to a relative error bound specified explicitly by the user; the al-gorithm does not terminate unless the current solution is within that bound of optimal.

In another experiment, see Figure 2, we used a ten-query instance with a big difference between the initial upper and lower bounds, and tested the runtime against various max-imum allowed errors. The runtime decreases not only be-cause of the more easily satisfied stopping criterion, but also
