 1. Introduction
MPEG-7 [1] is a standard for describing the content of different types of multimedia data. As the first stan-dard of the Moving Picture Experts Group to focus not on compression, but rather on metadata or metadata like Dublin Core [2] and TV-Anytime [3] . MPEG-7 documents can be defined and modified with the help of the Description Definition Language (DDL), which is based on XML Schema with extensions to sup-port array, matrix and some temporal data types. Fig. 1 shows an MPEG-7 description example. MPEG-7 provides a comprehensive standardized tool set for the detailed description of audiovisual media. level (spatiotemporal region, color histogram, timbre, texture) can be used as the base of all application domains making use of multimedia, such as classic multimedia archives, broadcast media selection, digital libraries, home entertainment, e-commerce and AI.

With MPEG-7, multimedia content can be exchanged between heterogeneous systems; plain text files can be used to store and share multimedia information; and multimedia data will be readily available to most users. Thanks to these advantages, more and more applications are based on MPEG-7 descriptions, and the amount of MPEG-7 descriptions is inevitably increasing dramatically. Therefore, a critical requirement has arisen: how to develop an adequate database solution for the management of larger numbers of MPEG-7 descriptions.

As discussed in [4] , a suitable MPEG-7 storage solution should satisfy several critical requirements: fine-sional index structures and multidimensional index structures for efficient access and query, and providing path indexing to navigate through the hierarchical structure of MPEG-7 documents and efficiently extract desired information. In addition to these requirements, an appropriate MPEG-7 management solution should emphasize other special issues. As pointed out in [4] , one challenge of the management of MPEG-7 descrip-tions is how to make use of MPEG-7 schemas and fulfill the requirement of accessing and processing arrays and matrices within the MPEG-7 documents which make up low-level multimedia content. Another challenge is to provide an extensible high-dimension index structure to support efficient multimedia retrieval applica-tions based on MPEG-7 media descriptions.

In order to provide an adequate storage solution for the management of MPEG-7 descriptions, in this paper we introduce a novel XML storage method known as IXMDB, abbreviated from  X  X  I ntegrated X ML-
Enabled M PEG-7 Descriptions D ata b ase  X  X . 1 The motivation of IXMDB is to integrate the advantages of two main RDBMS-based XML storage approaches: schema-conscious approach and schema-oblivious approach. It offers adequate means to fulfill fine-grained and typed representation and access requirements for the MPEG-7 description storage. In addition to benefiting from the sophisticated index structures provided by RDBMS, our technique provides the path index structure for MPEG-7 documents navigation. The flexible storage schema defined by our technique makes it efficient to store and manipulate the special datatypes within
MPEG-7 descriptions, such as array, matrix, basicTimePoint and basicDuration . Furthermore, the extensible high-dimensional index mechanism could be created on these array or matrix data to support multimedia con-tent retrieval. Our MPEG-7 descriptions storage solution could be used as the back-end MPEG-7 data repos-itory for all kinds of MPEG-7-based multimedia applications.

The remainder of the paper is organized as follows: Section 2 elaborates the limitations of existing XML storage approaches for the management of MPEG-7 descriptions, and further represents the motivation of our work. Section 3 summarizes our novel approach for the storage of MPEG-7 descriptions with RDBMS. Section 4 presents the database schema of our proposed approach: IXMDB. We will describe how an
MPEG-7 description is mapped into an RDBMS using IXMDB. In Section 5 , we will explain the insertion and extraction algorithm for IXMDB. In Section 6 , we present how to translate XML queries to SQL in
IXMDB and the optimization technique to improve query performance. This is followed by a discussion of the support of multimedia content retrieval in IXMDB. The performance results of IXMDB and corre-sponding analysis are given in Section 7 . We give an introduction to the existing RDBMS-based XML stor-age solutions and MPEG-7 descriptions management systems in Section 8 . Finally, in Section 9 the conclusions are presented. 2. Motivation Since MPEG-7 descriptions are also XML documents, the first consideration of the management of
MPEG-7 descriptions is how to employ an XML document storage schema to fulfill the MPEG-7 descrip-tions storage requirements. There exist many XML storage solutions: Native XML database solutions [20 X  22] , XML extensions of leading DBMS [25 X 28] , and third-part middleware for RDBMS-based XML management.
 To store XML documents efficiently and effectively in a relational database, there is a need to map the
XML DTD/Schema to the database schema. The RDBMS-based XML storage solutions can be classified into two major categories according to their mapping schemas: schema-conscious approach and schema-oblivious approach. In schema-conscious approach, design of the database is based on the understanding of DTD or XML Schema. It defines a relation for each DTD subgraph and uses primary-key and for-eign-key to describe the parent X  X hild relationship between two elements. While in schema-oblivious approach, a fixed database schema is used to store the structure and the data of any XML documents without the assistance of document schema. The schema-conscious approach supports typed representation and access for XML data. It has better query performance than schema-oblivious approach since it par-titions XML data based on DTD/XML Schema. While the schema-oblivious approach keeps the whole hierarchical structure information of an XML document. It will thus perform complex XPath-based query more efficiently and make it easier to re-construct the data back into XML format than schema-conscious approach.

Since there exist various XML storage solutions with different efficiency and functions [15 X 18,11,12,19,29] , the most puzzling problem is which one is the most suitable choice for the MPEG-7 documents storage.
Native XML databases are designed especially for XML documents storage. Its fundamental logical stor-age unit is XML document, which is represented as text format. Traditional Native XML databases cannot support typed representations of the data within MPEG-7 documents since they represent the contents of an
XML document as text. Recent research works on native XML database have proposed the powerful XML storage schemas to support appropriate access to non-textual data, e.g., Berkeley DB XML [23] and TDOM [24] . However, Berkeley DB XML is not extensible with index structures to support the index on individual items in the array/matrix datatype, and the multidimensional index on the multimedia data of which the MPEG-7 media description tools make heavy use. TDOM is designed to represent the basic contents of an
XML document in a typed fashion and constitute a solid foundation for an XML database solution enabling the adequate management of MPEG-7 media descriptions [24] . However, as the other DOM-based native XML databases, it is costly to build in-memory trees of very large documents and then query those trees.
Furthermore, it is difficult for the Native XML database systems to create a flexible and extensible index structure on the data with various datatypes and query multimedia information across multiple MPEG-7 doc-uments efficiently.

While for RDBMS-based XML storage solutions, no matter what approach we use, schema-conscious approach or schema-oblivious approach, we also cannot avoid their intrinsic drawbacks. Fig. 2 shows the rela-tional schema for storing an MPEG-7 example shown in Fig. 1 with the basic idea of the schema-conscious approach and the schema-oblivious approach, respectively. For the schema-conscious approach, it provides weak support for hierarchical structure of the original XML documents. As shown in Fig. 2 , only the par-ent X  X hild relationship between two elements can be reserved by creating the primary-foreign keys between cor-responding tables, whereas the path expression from root element to an arbitrary element and the whole hierarchical structure information, including ancestor X  X escendant relationships, will be lost. This drawback makes it difficult to efficiently perform complex XPath-based queries. Furthermore, the process of re-con-structing data from RDBMS into XML format may be expensive due to access to multiple tables and inflex-ible representations of structure information.

As shown in Fig. 2 , due to using a fixed table to store each element or attribute and the mapping process without the assistant of the DTD or the XML schema, the schema-oblivious approach has to establish only a single value column for storing the value of each element and attribute within XML documents as strings, the string type.

All the leading database systems, such as IBM DB2, Microsoft SQL Server and Oracle, provide XML stor-age and management technology in their database products. However, as analyzed in [4] , none of them can fulfill all the MPEG-7 descriptions storage requirements. Furthermore, although these XML-Enabled databases support the queries of XML documents based on XPath, these XPath operations are evaluated by constructing DOM from CLOB and using functional evaluations. This can be very expensive when performing operations on large collections of documents.

In addition to the drawbacks mentioned above, none of the existing XML storage solutions address the problem of storage of the special datatypes introduced in the MPEG-7 DDL, such as array, matrix, basic-
TimePoint and basicDuration . One of the critical challenges for MPEG-7 descriptions management solution is to provide an extensible multidimensional index mechanism to support multimedia content retrieval. Unfor-tunately, the multidimensional access methods are rarely available in the most of current RDBMS-based
XML storage solutions. 3. Overview of our approach
An MPEG-7 document can be viewed as an XML tree. In this tree structure, the internal node, the element type with element contents, represents the structure of document and can be viewed as the node that is only the node that is only useful for holding value. IXMDB was designed to use schema-oblivious approach to store all the internal nodes and schema-conscious method to store all the leaf nodes. Since all the leaf nodes are stored with schema-conscious approach, the contents of MPEG-7 documents can be mapped into RDBMS with fine-grained manner and appropriate data types. As all the internal nodes are mapped with schema-obliv-ious approach, the complete hierarchical structure information of the original MPEG-7 documents can be kept in the database. Based on the fundamental scheme of IXMDB, we propose a method for storing complex datatypes within MPEG-7 descriptions with relational tables and integrate the GiST framework [10] for index-ing high-dimensional data.
 We carried out a set of experiments to investigate the storage efficiency and query performance of IXMDB.
The amount of storage space IXMDB consumed is between that of the existing schema-conscious methods (e.g., Shared-Inlining ) and schema-oblivious methods (e.g., SUCXENT++ ). The performance of mapping
XML documents to RDBMS with IXMDB is similar to SUCXENT++ and slightly slower than Shared-Inlin-ing . IXMDB can reconstruct original XML documents from RDBMS up to two times faster than Shared-
Inlining , and the same as SUCXENT++ . For the XPath-based queries, IXMDB outperforms SUCXENT++ by up to 12 times and Shared-Inlining by up to 20 times for most testing queries, including recursive queries and ordered XPath queries. Since IXMDB provides a special storage schema for the complex datatypes defined in MPEG-7 DDL, e.g. basicTimePoint, basicDuration, array and matrix , IXMDB outperforms all the other approaches for the queries on these datatypes. The reasons for the different performance between our technique and the existing approaches will be discussed in Section 7 . 4. Relation schema of IXMDB
An XML document is often represented as an XML tree. In an XML tree, the internal nodes correspond to the element types with element content in the XML document, while the leaf nodes correspond to the single-valued attributes and element types with PCDATA-only content in the XML document. In order to illustrate the tree structure of the XML documents and later introduce the storage scheme of IXMDB, an MPEG-7 document showed in Fig. 1 is used as an example and its tree representation is shown in Fig. 3 .
The idea of IXMDB is to use schema-oblivious approach to map all the internal nodes and use schema-conscious approach to map all the leaf nodes. In an XML tree, the internal nodes depict the structure of the
XML document and are only useful for document navigation. Storing them by using schema-oblivious method, which can provide complete structure information of an XML document, can support efficient and easy document traversal. The leaf nodes hold all the data of XML document. They are the  X  X eaves X  in the XML tree, so they have little usage for the XML tree navigation. They can be considered as the nodes only for storing the data of XML document. Using schema-conscious approach to store them can bet-storage requests. 4.1. Internal node storage
To speed up the processing of XML tree navigation, it is important to adopt an efficient numbering scheme to encode the nodes of a tree and quickly determine ancestor X  X escendant relationship between arbitrary two nodes in the XML tree based on such a numbering scheme. Thus, for RDBMS-based XML storage solutions, most pure schema-oblivious methods that label all the nodes in an XML tree, our approach only needs to encode internal nodes.

Motivated by searching XML documents efficiently, several research efforts have addressed the problem of numbering scheme specification. In [6] , the authors proposed three order encoding methods that can be used to represent XML order in the relational data model. These three methods are Global Order, Local Order and
Dewey Order . Among them, as claimed by the authors, Dewey Order performs reasonably well on both queries and updates. With Dewey Order , each node is assigned an id value, a sequence of numeric values separated by a dot that represents the path from the document X  X  root to the node. The root node is assigned a single numeric value. Child node id starts with the id of the parent node appended by a dot and the local order of the node, as illustrated in Fig. 3 .

With Dewey Order , the ancestor X  X escendant relationship can be determined using only the id value. How-ever, the id length depends on the tree depth and a string comparison of the ids may degrade the query per-the authors provided a solution for avoiding these shortcomings and proposed a novel hierarchical labeling scheme called ORDPATH .
 ORDPATH provides a compressed binary representation of Dewey Order . It uses successive variable-length
L / O i bitstrings to represent the id value of each node. Each L prefix-free encoding, specifies the length in bits of the succeeding O 01 is assigned length 3, this L i will indicate a 3-bit O
With ORDPATH , the id value of each node is constructed as binary string and document order can be pre-served and yielded by simple bitstring comparison. The ancestor X  X escendent relationships between any two nodes X and Y can be determined equally simply: X as a strict substring of Y or vice versa implies there is an ancestry relationship.

IXMDB uses ORDPATH to encode the position of each internal node and construct the document struc-ture information in the relational database model. Following are the relational schemas to store internal nodes: xpath (xpathid, length, xpathexp) internalnode (uid, xpathid, nodename, ordpath, parent, grdesc, lid, oid, tablename)
The semantics of the attributes in the above relations are as follows:  X  The xpath table records the XPath information of the XML tree. xpathid and xpathexp represent the
XPath identifier and the path expression. The number of edges for an XPath is recorded in the attribute length ; node. ordpath records the ORDPATH of this internal node. lid is the internal node local identifier, which depicts the position of a node among sibling nodes. oid is useful for the queries that include index predi-cates. It is an index of the node that occurs more than once in the XML document. tablename is used to indicate which table stores the value of this internal node X  X  leaf nodes children; and  X  The attributes parent and grdesc in the internalnode table are used for ancestor X  X escendant relationship determination between two internal nodes. In [7] , the authors introduced two functions to determine the parent and an upper bound on all descendents of a given node. One is PARENT(ORDPATH X), which presents the parent of X, the other is GRDESC(ORDPATH X), which is the smallest ORD-
PATH-like value greater than any descendent of a node with ORDPATH X. We can use the user-defined functions (UDF) in RDBMS to implement these two functions. However, not all RDBMS support to cre-ate index on function, e.g., DB2. In order to benefit from index mechanism in RDBMS and improve query process, we introduce two columns, parent and grdesc ,inthe internalnode table to store the parent of corresponding internal node and the smallest value greater than any descendent of this node rather than using UDF. 4.2. Leaf node storage
In order to identify the datatype of each leaf node and map them into database by using schema-conscious approach, a mapping schema is created to represent how to map them into database schema. The mapping schema is defined via mapping processing definition (MPD) file, which is also an XML file. The functionality of MPD file is like the DAD file in DB2 XML Extender, which provides a map of any XML data that is to be stored in the database. Currently, the MPD file is created manually. In the future work, we will develop an application to automatically generate a MPD file and a set of CREATE TABLE statements from a DTD or an XML schema. The end users can modify the MPD files according to their storage requirements.
Fig. 4 shows the DTD defined for MPD file and an example of MPD file for mapping the DominantColor descriptor.

IXMDB views an XML document as a tree of objects and then uses MPD file to map these objects to a relational database. In this view, an internal node is usually viewed as a class and mapped to a table. For example, as shown in Fig. 4 , the following declares the internal node Descriptor to be a class and maps it to the dominantcolor table: h InternalNodeClass Name= 00 Descriptor 00 ToTable= 00 dominantcolor 00 h /InternalNodeClass i
The leaf nodes are usually viewed as properties and mapped to columns. For example, the following schema, which is nested inside the above mapping schema, declares the xsi:type and size attributes and the
SpatialCoherency element to be properties and maps them to the xsitype, size and spatialcoherency columns, respectively. h
AttributeClass i h /AttributeClass i h
AttributeClass i h /AttributeClass i h
LeafNodeClass i h /LeafNodeClass i
Our mapping schema for the leaf nodes is much simpler than the existing schema-conscious methods. The information needed to map a single internal node class only includes the table to which the internal node is ships have been mapped to the relational model via schema-oblivious technique.

The database schema for the MPEG-7 document example shown in Fig. 1 is shown in Fig. 5 . 4.3. Complex datatype representation
As introduced previously, MPEG-7 descriptions not only use the standard datatypes, but also add the extension datatypes, including array, matrix, basicTimePoint and basicDuration . The appropriate MPEG-7 storage solution should fit for two application requirements: multimedia information exchange, and multime-these two requirements. However, it raises an efficiency problem that the storage schema for the above exten-sion datatypes has to give attention to both multimedia information exchange and multimedia data manipu-lation. Undoubtedly, text-based format is the most efficient storage model for data exchange since it is not limited to any computer platforms and languages. Thus, storing the above special datatypes with text format in RDBMS enables the extraction of them from database without any additional operations and exchange of them between normally incompatible systems efficiently. However, such a storage schema makes it inefficient to manipulate these special datatypes due to the expensive process of character string parsing and datatype conversion. In this subsection, we will introduce how to store these complex datatypes in relational database and avoid the above efficiency problem. 4.3.1. Array and matrix
In order to manipulate the array or matrix data efficiently, we can store individual cells in the array or matrix in a pure relational table with appropriate datatype. There are three relational schemas for array and matrix storage ( Fig. 6 illustrates these three schemas):  X  Normalized schema  X  in this schema, each row will identify a cell in the array or matrix. The schema would be (ARRAYID, COLUMNID, VALUE) for array, or (MATRIXID, COLUMNID, ROWID, VALUE) for matrix;  X  Semi-normalized schema  X  in this schema, each row will store a row in the matrix. The corresponding schema would be (MATRIXID, ROWID, COL0, COL1, ... , COLn) for m  X  n matrix; and  X  Denormalized schema  X  in this schema, each row will record one array or matrix. It would be (ARRAYID, COL0, COL1, ... , COLn) for array, or (MATRIXID, R0_C0, R0_C1, ... , Rm_Cn) for m  X  n matrix. tion and query. To evaluate the performance of these three array/matrix storage schemas, we performed a set ces extracted from SoundClassificationModel DS . The experimental results are shown in Fig. 7 .
For the semi-normalized and denormalized schemas, the length of the array or matrix must be fixed, while the normalized schema is flexible enough to store the arrays or matrices of arbitrary cardinality. However, compared to the semi-normalized and denormalized schemas, the normalized schema needs to load many more tuples when performing insertion process, and need more joins to locate the desired individual items when performing queries. For array, the semi-normalized and denormalized schemas have the same storage schema; therefore, they have the same performance on insertion, extraction and query. For matrix, the denor-malized schema has better performance on insertion and query than the semi-normalized schema because it inserts fewer tuples and needs fewer joins for the query process. With the semi-normalized schema, each for the semi-normalized schema to compose the data in the database to original matrix format. Thus, for extraction operation, the semi-normalized schema has the best performance, while the normalized schema per-forms the worst as it stores the array or matrix data fragmentally.
As a performance trade-off on the operations of insertion, extraction and query, the semi-normalized schema can be used to store the arrays or matrices with fixed cardinality. However, only normalized schema can be adopted to store the arrays or matrices with arbitrary length.

Even though the individual cell in the array or matrix could be stored in the special table with appropriate the operations of reconstructing the data into XML format and exchanging required information between incompatible systems. In addition, we define a column for storing ARRAYID or MATRIXID , which points to the corresponding record in the ARRAY or MATRIX table, which are defined to store array or matrix data. points to the records in the ARRAY table. The corresponding example of database schema can be found in Fig. 5 .
 Note that it is not necessary that the users use the above schema to store all the arrays and matrices in
MPEG-7 descriptions. This schema is designed to speed up the operations on the individual items of an array/matrix. For many arrays or matrices, however, no one is interested in a certain individual item, e.g., the arrays in ColorStructure descriptor. The common operations on these arrays or matrices require all the items in them. The above schema cannot improve such operations since it needs more joins to get correspond-ing data and the index on individual items is meaningless for such operations. They can be only stored with character string datatype in the database.

The above storage schema, which stores the array/matrix data twice, may raise the problem of data con-sistency and integrity. This problem can occur during the updating of the array/matrix data. To solve this problem, we can define the triggers in the relational database to support the data consistency and integrity.
If the array/matrix values stored as character string type are updated, the triggers can perform the actions to update the corresponding values stored in ARRAY/MATRIX table. In addition, one limitation of this stor-the storage of MPEG-7 descriptions. basicTimePoint and basicDuration
The basicTimePoint datatype is used to describe a time point according to the Gregorian dates, day time and the time zone. It is represented in the following lexical format:  X  X  X  is the delimiter for the time specification and  X  X  X  stands for the number of fractions of one second.  X  X  X h:mm X  represents the time zone.

The basicDuration datatype is used to specify the interval of time according to days and time of day. The lexical format of this type is given by:
In this format, the separators specify the semantic of the number n : D (days), H (hours), M (minutes), S (seconds), N (number of fractions), f (for a decimal expression of fractions), F (number of fractions of one second) [8] .

All the leading database systems support time point type, e.g.,  X  X imestamp X  datatype in DB2 and Oracle, and  X  X atetime X  datatype in SQL Server. Although the basicTimePoint datatype is based on ISO 8601, it is slightly different from the format accepted by the database system. We cannot directly insert this type into a relational table with built-in time point type in RDBMS without conversion. We also use two columns in relational table to store the data with basicTimePoint datatype to give attention to data exchange and manip-defined as built-in time point datatype, e.g., timestamp in DB2, for time data operation. One of the most important operations on the time point data is time comparison. The original time point values in MPEG-with different time zones. During the mapping process, we first convert the time point data in MPEG-7 descriptions into a format acceptable to the database system, translate the time point data into local time, and store them into relational table with timestamp datatype; thereby utilizing the relational DB functional-ities to directly and efficiently compare time point values.

The duration type may be involved in date and time arithmetic operations. All leading database systems support such operations as addition and subtraction. However, they differ in date arithmetic operations and the representation of duration operand. This article focuses on how to store basicDuration type in DB2. DB2 introduces four types of durations: labeled-duration, date duration, time duration and timestamp duration.
Since the basicTimePoint type is stored as timestamp datatype, the timestamp duration type, which is expressed as a decimal number with precision 20 and scale 6, is the best mode to represent basicDuration type and then utilize the date and time arithmetic operations in DB2. For basicDuration type, we also use two columns, one for storage as character string, and the other for manipulating and recording as timestamp duration type.
 icTimePoint and basicDuration types. The date and time operations between MediaTimePoint and MediaDuration can be easily implemented with date and time functionalities provided by RDBMS. For example, if a user would like to get the result of adding MediaDuration to MediaTimePoint , the following simple SQL could be issued:
SELECT timestamp + decimal(timestampduration,20,6) FROM mediatime 4.4. Summary
According to the above storage schema, all the leaf nodes within MPEG-7 descriptions are mapped in fine-grained manner to corresponding columns with appropriate datatype. For the complex datatypes defined by MPEG-7 DDL, such as array, matrix, basicTimePoint and basicDuration , a special storage schema is designed to store them in relational database. Although such a storage schema need more storage space and an additional mechanism to keep data consistency, it can speed up the special queries on these complex datatypes. It is somewhat similar to the data warehousing technique in RDBMS, which stores the operational data repeatedly and increases the complexity of storage process, but provides the powerful query capability. IXMDB can provide the most support for the fine-grained and typed representation and access of the contents of the MPEG-7 descriptions. With such storage schema, the MPEG-7 description content can be indexed easily by built-in database indexes. Since the path expressions of all the internal nodes are kept and each internal node is labelled by ORDPATH , the sufficient structure information of
MPEG-7 documents can be stored in RDBMS. 5. Insertion and extraction 5.1. Insertion algorithm
The algorithm for inserting MPEG-7 data into RDBMS is shown in the Fig. 9 . The input of the algorithm is the original MPEG-7 document. At the end of the algorithm, all the data and structure information of the MPEG-7 document would be stored in the relational database. The insertion proceeds as follows: (1) The original MPEG-7 document is first parsed and the corresponding document tree is generated (line 3); (2) Obtain the root element and corresponding XPath and ORDPath of root element (lines 4 X 6); (3) Call the function mappingNode( ) to process the root element (line 7); (4) Generate  X  X nsert X  SQL statements (lines 8 X 9); and (5) The function mappingNode is used to map each internal node which proceeds as follows (refer to Fig. 9 b): 5.2. Extraction algorithm base, and then reconstruct them to revert to original XML format. The algorithm for reconstruction is pre-sented in Fig. 10 . The extraction proceeds as follows: (1) Extract all the internal nodes data and leaf nodes data from the database as the input parameters of (2) The variables n and p are the instance of NodeClass class that records XML node and its level informa-6. Querying MPEG-7 6.1. XPath-based query
With IXMDB, applications can directly use SQL to access the contents of media descriptions in a fine-grained manner. However, the database schema of MPEG-7 storage solution is often not transparent to the users or applications. They prefer to access MPEG-7 media descriptions through some form of declarative
XML query language, e.g., XPath and XQuery. In order to support the requirement of XML query language, it is necessary for the MPEG-7 description management solution to be powerful enough to provide appropri-ate translators from XPath and XQuery to SQL.

XQuery [9] is a query language built on XPath expressions to find and extract elements and attributes from XML documents. It has been broadly applicable across many types of XML data sources. XQuery offers iterative and transformative capabilities through FLWOR expressions, which stand for the five major clauses: for, let, where, order by and return . To support XQuery in IXMDB, we developed a trans-lation mechanism for converting XQuery to SQL. This mechanism supports many features of XQuery, which include simple or recursive path expressions, predicate expressions (including order predicate and value comparison predicate), arithmetic expressions, comparison expressions and logical expressions [9] .
However, due to the complexity of XQuery and the gaps between XQuery and SQL, it is difficult to trans-late all the features of XQuery into SQL. Fig. 11 demonstrates the XQuery expression. 6.1.1. Query translation algorithm XQuery and then generate corresponding parse tree. One example of a parser generator tool is JavaCC, the parser generator used with Java applications. The second step is to walk this parse tree and generate all the
PathExpr and ComparisonExpr within the XQuery in question. In XQuery, PathExpr represents a path expression that can be used to locate nodes within XML tree, and ComparisonExpr represents a comparison expression that allows two values to be compared. For example, in the XQuery shown in Fig. 11 , the Path-
Exprs and ComparisonExprs are listed in Fig. 12 . Finally, these PathExprs and ComparisonExprs can be trans-lated into corresponding SQL component. Fig. 13 shows the translation algorithm for IXMDB.

The translation proceeds as follows: (1) Parse the XQuery and generate parse tree (line 1). Then, walk the parse tree and generate all the Path-(2) Process all the PathExprs (lines 6 X 11). Procedure processPathExpr will be called to generate correspond-(3) Procedure processComparisonExpr is called to process all the ComparisonExprs (lines 12 X 14).
Procedure of processPathExpr is shown in Fig. 14 and this procedure proceeds as follows: (1) Since the path expressions are stored in  X  X path X  table and the internal node information is stored in (2) If the end node of this path expression is leaf node, add corresponding table name to FROM clause (lines
Fig. 15 shows the procedure of processComparisonExpr . This procedure follows: (1) Obtain left and right operands and operator in the comparison expression (lines 1 X 3); and (2) Two types of comparison expression need to be handled.
The SQL result for translating the XQuery example in Fig. 11 according to the above translation algorithm is shown in the right panel in Fig. 11 .

With the aid of the XPath expressions in XQuery and the position information of related nodes stored in corresponding parts of extraction algorithm. 6.1.2. Query rewriting
To evaluate the performance of the above translation procedure, we captured information about the access plan of the above SQL statement. The captured information helps us understand how individual SQL state-based on 1GB MPEG-7 dataset is shown in the Fig. 16 a.

In this access plan graph, rectangles represent tables and diamonds represent operators. Operator is either an action that must be performed on data, or the output from a table or an index, when the access plan for an SQL statement is executed. The operators occurred in this graph are explained as follows: RETURN  X  Represents the return of data from the query to the user; MSJOIN  X  Represents a merge join, where both outer and inner tables must be in join-predicate order; NLJOIN  X  Represents a nested loop join that accesses an inner table once for each row of the outer table; FILTER  X  Filters data by applying one or more predicates to it; TBSCAN  X  Retrieves rows by reading all required data directly from the data pages; and FETCH  X  Fetches columns from a table using a specific record identifier.

The number under each operator indicates the total cost that is the estimated total resource usage necessary to execute corresponding operation. Cost is derived from a combination of CPU cost (in number of instruc-tions) and I/O cost (in numbers of seeks and page transfers).

In our optimization study with access plan, we noticed that the joins between the xpath and internalnode tables consumed a considerable portion of the query processing time, and the cost of such joins cannot be decreased with the query optimizer of database system. The main effects of the joins between xpath and inter-table increase the size of joins between xpath and internalnode tables dramatically.

In order to avoid these time-consuming joins, we re-wrote the queries to optimize the query process. This process is similar to the optimization technique discussed in SUCXENT++ [11] . In the query rewriting pro-cess, the join expression: xpath.xpathexp = xpath and internalnode.xpathid = xpath.xpathid would be placed with: internalnode.xpathid = n expression: xpath.xpathexp like xpath % and internalnode.xpathid = xpath.xpathid is replaced with: internalnode.xpathid in ( ... ) where the value in the parentheses is the set of xpathid values corresponding to the path expression in the value corresponding to the path expression; second, using these values to write the final SQL statement and then perform it to get the final result. The optimized access plan for SQL in Fig. 11 is shown in Fig. 16 b.
Although such optimized query process need to access database multiple times, it avoids the joins between xpath and internalnode tables. When there exists a large amount of data in internalnode table, the query per-formance is improved dramatically (up to 10 times in our experiment). 6.2. Multimedia content retrieval
To enhance our system to support extensible indexing mechanism, we integrated the GiST framework [10] into IXMDB. GiST provides a framework for building any kind of balanced index tree on multidimensional data. However, the GiST framework runs as its own process separately from the database system. In order to connect our RDBMS-based MPEG-7 storage solution to the GiST framework, we developed a set of user tem via simple SQL statements. The current GiST version is prepackaged with extensions for some spatial searching function based on metric space, the M-tree [36] , a representative of metric-based indices is added in IXMDB. 7. Experimental results
In order to check the effectiveness of our method we have implemented IXMDB using JDK1.5 and carried ent the elapsed time for insertion and extraction executions and storage space requirements of IXMDB. We compare it with SUCXENT++ [11] , which has been proven to outperform the other existing schema-oblivious we compare the query performances of IXMDB to these approaches. To test how our system supports the queries from multimedia perspective efficiently, we performed a set of experiments to evaluate the efficiency of the multidimensional index system. The hardware platform used is a Dell PowerEdge 2650 with Xeon
CPU 2.8 GHz and 1.00GB RAM running Windows Server 2003 Enterprise Edition. The data base system is IBM DB2 Universal Database Enterprise Server Edition V8.1. The application has been developed and the running environment is Java JDK 1.5. 7.1. Data set
We used two experimental data sets. One is a synthetic dataset, which is from the XMark project [13] ,a benchmark for XML data management. The other is a real dataset, which consists of MPEG-7 descriptions.
These two data sets were used for comparison of storage size, insertion and extraction times. Since MPEG-7 descriptions are also XML documents, in order to test the effectiveness of IXMDB from XML perspective, we used XMark benchmark data as one of experimental data sets. We generated the XMark benchmark data with different scale factors. Three different sizes of data are used: BENCH001 (which means 1% of the original
BENCH) with 1.1MB size, BENCH01 with 11.3MB size and BENCH with 113MB size. The MPEG-7 descriptions data set with the size of 1GB includes four Description Schemes: UserDescription DS , Object
DS (including SpatialMask D ), StateTransitionModel DS and SoundClassificationModel DS , and eight low-level descriptors extracted from about 240,000 pictures: ColorLayout, ColorStructure, ContourShape, Domi-nantColor, EdgeHistogram, HomogeneousTexture, RegionShape and ScalableColor . Fig. 17 summarizes the characteristics of the experimental data sets.

Test queries need to be carefully selected for the performance study. XMark issues 20 benchmark queries that cover different aspects of XML queries for accessing XML data. to test query performance on MPEG-7 documents. These queries are shown in Fig. 18 . In our performance study, we labelled the XMark queries as Q1 X  X 20, and the MPEG-7 queries as MQ1 X  X Q12. The correspond-ing SQLs with IXMDB for these queries are shown in Appendix A . To evaluate the effectiveness of the mul-tidimensional index system, we performed similarity search on four low-level descriptors with different dimensions. 7.2. Insertion performance and storage size
Fig. 19 presents the insertion performance (including index creation during insertion process) for different sample data set. This figure shows that the Shared-Inlining is the best, while IXMDB and SUCXENT++ have similar performance. This is because these methods store different amounts of data during insertion process.
Shared-Inlining method creates tables for the internal nodes, and their leaf node children, and some of leaf node descendants may be inlined into these tables. Therefore, the number of inserted tuples with
Shared-Inlining is close to the number of internal nodes. SUCXENT++ only stores leaf nodes, thus the number of its inserted tuples is equal to the number of leaf nodes. For IXMDB, all internal nodes need to be inserted; and for each internal node that has attributes or leaf nodes, one tuple would be inserted to store its leaf node children. Therefore, the number of inserted tuples with IXMDB is close to double of the number of internal nodes. Compared to SUCXENT++, Shared-Inlining and IXMDB have a disad-vantage for insertion process. That is, they need to insert data into more tables than SUCXENT++ does.
However, such disadvantages can be compensated by the smaller size of inserted tuples and less elapsed time for index creation with Shared-Inlining and IXMDB. Since SUCXENT++ stores the data in several fixed information into the columns other than the column that records the value of leaf node in the table. While for Shared-Inlining and IXMDB, the value of each leaf node is stored in corresponding column and do not raise additional storage requirement. Furthermore, SUCXENT++ needs to create the index on all the val-ues with character string type, while IXMDB and Shared-Inlining generate the indexes on the required col-umns with different datatypes. Thus, IXMDB and Shared-Inlining take less time to create indexes. In summary, these methods have slight difference in insertion performance due to their intrinsic advantage and disadvantage in insertion process.
 Fig. 20 shows their different storage requirements. The above discussions can also explain why SUCX-
ENT++ needs more storage space to store the values of leaf nodes and consumes more storage size for indexes. 7.3. Extraction performance
Fig. 21 shows the extraction performance of these approaches. Extraction is the reverse operation of insertion process. That means extraction operation is the process to extract the data from database and reconstruct them with original XML format. The extraction time is made up of the time taken to extract the relevant data from database and main memory processing time to reconstruct the data into XML doc-ument. Fig. 21 also shows the running time of these methods in terms of the two steps of extraction pro-cess. Based on this figure, we observe the followings: there are slight difference between IXMDB and
SUCXENT++, and they are about 50% faster than Shared-Inlining method in terms of extraction performance.

In the process of extracting relevant data from database, the performance of SUCXENT++ is the best since it only retrieves the data of leaf nodes. IXMDB needs to retrieve all internal nodes and corresponding leaf node children. Note that it is not necessary to join internalnode table and each leaf nodes table to get the leaf nodes data, since with the aid of MPD file and the given document identifier, it is easy to extract all the leaf nodes value from database without any internal nodes information.

However, for the process of reconstructing the extracted data into XML format, SUCXENT++ performs the worst due to its storage schema. SUCXENT++ only stores the path expressions of leaf nodes and there is a lack of the information about each internal node. When SUCXENT++ creates the XML document tree, it and then decide the appropriate positions of these internal nodes and leaf nodes in the document tree. There-fore, with SUCXENT++, although the performance of extracting data from database is better, the time taken for reconstruction is more. IXMDB consumes the least memory processing time to reconstruct XML docu-ment becuase it creates the document tree by only organizing the internal nodes. With the aid of an MPD file document tree.

Although Shared-Inlining returns the smallest number of tuples among these approaches when extracting data from database, the performance is worse than the others because Shared-Inlining uses primary key and foreign key to represent the parent X  X hild relationship between two nodes. Such relationship information needs to be gained to generate XML document tree. This means a large amount of join queries need to be executed to extract data. The extraction process would become more expensive when there exist many relations for stor-ing XML documents. 7.4. Query performance 7.4.1. Queries from the XML perspective
Fig. 22 represents the query performance of each approach for different queries introduced in the beginning of this section. This figure shows that IXMDB has encouraging query performance for most of the queries.
Fig. 23 summarizes the number of queries that each method performed best or worst, and also shows the query performance statistic, including the minimum, maximum, average, and standard deviation of the query performance for all the test queries. According to Fig. 23 a, we can observe that IXMDB primely converges the advantages of schema-conscious approach and schema-oblivious approach (having the largest number of que-ries with the best performance), and avoids their intrinsic disadvantages (no queries with the worst perfor-mance). We discuss the observations in detail as follows.
 IXMDB vs. SUCXENT++
The common feature of the above queries is to apply predicates related to several sub-elements. In general, for such queries, the schema-conscious approach outperforms the schema-oblivious approach due to the reason described in [14] . Schema-conscious approach clusters elements corresponding to the same real world object while schema-oblivious approach loses such benefit and it has to issue more SQL joins to capture the par-ent X  X hildren or ancestor X  X escendant relationships between XML elements. Consider the following XQuery: //Descriptor/Values[Percentage &gt; 5]/ColorValueIndex With schema-conscious approach, elements Percentage and ColorValueIndex , which are children of element SQL: select colorvalueindex from values where percentage &gt; 5 where table values corresponds to the element Values and columns percentage and colorvalueindex correspond to the elements Percentage and ColorValueIndex , respectively. While with schema-oblivious approach, these two elements cannot be clustered and would be stored in separate rows. Schema-oblivious approach needs more joins to check sibling relationship between elements Percentage and ColorValueIndex . Fig. 24 shows another example, the translated SQL with SUCXENT++ for the XQuery shown in Fig. 11 . According to its storage schema, IXMDB can also benefit from the above advantage of schema-conscious approach. Thus, SUCXENT++ needs more joins to check sibling relationships in comparison with the translated SQL with IXMDB shown in Fig. 11 .

Schema-conscious approach and IXMDB store the leaf nodes value in many different tables, while schema-oblivious approach, e.g. SUCXENT++, stores all leaf nodes value within a single table. Therefore, schema-conscious approach and IXMDB require the join of many smaller tables when performing queries, whereas schema-oblivious approach needs to self-join a single large table. The performance of schema-oblivious approach is substantially degraded when large collections of XML documents exist. Fig. 25 shows the access plan for MQ3 with IXMDB and SUCXENT++, respectively. According to this figure, we can observe that SUCXENT++ requires more joins and performs this query at a much higher cost.
 The above analysis explains why IXMDB outperforms SUCXENT++ for queries Q1, Q8 X 10, Q14, Q17, MQ1 X 3, etc.

Furthermore, schema-oblivious approach cannot provide the typed representation and access of the content within the XML documents. With schema-oblivious approach, the data within the XML documents will be
However, IXMDB and schema-conscious approach can benefit from the efficient index mechanism created on all kinds of datatypes. For some test queries, SUCXENT++ has to spend time to convert datatype, for exam-ple, Q5, Q11, Q12 and Q18, which include numeric comparison.

Compared to the other schema-oblivious approaches, SUCXENT++ only stores the leaf nodes information implement the queries with conditions on internal nodes, for example, Q2 X 4, MQ5, MQ7 and MQ8, which are ordered access queries, and Q6 and Q7, which are to count the occurrence of given internal nodes. To perform these queries, SUCXENT++ needs the assistance of an additional programming code.

Because the required data are stored in several tables and the extraction process involves several joins with IXMDB; for reconstructing a fragment of original XML document, e.g., Q13, MQ5 and MQ7,
IXMDB performs worse than SUCXENT++. According to Fig. 21 , the extraction performance of IXMDB is slightly better than SUCXENT++. However, for IXMDB, the process of reconstructing a fragment of document is different from the process of reconstructing the whole document. During the former process, several joins between the leaf node tables and the internal node tables are involved when extracting the required data, while for reconstructing the whole document, these joins are not necessary, since with the document identifier and the table information kept in MPD file, we can extract the required data from leaf node tables directly.
 IXMDB vs. Shared-Inlining
The main drawback of the schema-conscious approach, like Shared-Inlining, is the lack of path expres-sion information and path index. For the recursive queries (e.g. Q6, Q7, Q14 and Q19) and the queries including longer path expressions (e.g. Q15 and Q16), the Shared-Inlining method performs worse than
IXMDB and the schema-oblivious approaches. Shared-Inlining only keeps the parent X  X hildren relationships by defining a set of primary keys and foreign keys. IXMDB only requests two h -joins to check the ances-tor X  X escendent relationships, while Shared-Inlining may perform large number of equijoins to check ances-tor X  X escendent relationships or travel from root node to destination node along the path expression to access appropriate data. The number of equijoins depends on the depth of the path expression. Therefore, the recursive queries in which the exact depth is unknown and the path expression with large depth affect the query performance of Shared-Inlining. Fig. 26 shows the access plan for Q15 with IXMDB and
Shared-Inlining, respectively, and illustrates the great impact of the long path expression on the perfor-mance of Shared-Inlining.
 Queries on complex datatypes in MPEG-7 descriptions MQ4 and MQ8 X 12 are the queries for testing the performance on complex datatypes defined in MPEG-7 DDL. None of the existing XML storage solutions provide the schema to handle the complex datatypes in
MPEG-7 descriptions. These datatypes are only stored as character string type in the database. It makes manipulation on these datatypes very inefficient.

MQ4 is to test the performance of date arithmetic operation on basicTimePoint and basicDuration types. As these types are stored as character string, the existing XML solutions need additional program code to implement date arithmetic operations. While IXMDB only requests a single SQL to implement this query.

Queries MQ8 X 12 include the operations on array and matrix data. The detailed discussion can be found in the following subsection.
 7.4.2. Performance on array and matrix data To evaluate further the efficiency of our storage schema for array and matrix data, we generated additional MPEG-7 description data sets with the size of 1MB, 10MB and 100MB, which include DominantColor D,
Object DS, StateTransitionModel DS and SoundClassificationModel DS . DominantColor D has the array data with three dimensions and we used semi-normalized schema to store them. StateTransitionModel DS has 3  X  3 matrices, while the matrices in Object DS and SoundClassificationModel DS have the dimensions of 2  X  4, of these three data sets and the table sizes of IXMDB for storing these arrays and matrices. We used MQ8 X 12 for testing and Fig. 28 shows the experimental results.

Queries MQ8 and MQ9 include the operations on the individual item within the array data. For example, for the DominantColor descriptor, if the colour space is HMMD , the value of ColorValueIndex , which is defined as array type with 3 length, would be a set of three components: Hue, Diff and Sum . As shown in  X  X  X he value of Hue should be from 160 to 210 X  X  (this value range specifies the blue colour). According to the storage schema for the array or matrix data designed with IXMDB, IXMDB can benefit from the index on the individual items of the array data and speed up these queries. However, the other methods, which store the array data as character string, need to parse each candidate array string, get the individual item within the array string, convert the datatype, and then test whether it accords with the query condition. Thus, IXMDB outperforms them undoubtedly.

Queries MQ10 X 12 are the queries for testing the performance on the matrix datatype. They are issued against Object DS , StateTransitionModel DS and SoundClassificationModel DS , respectively. Same as the per-formance on array data, SUCXENT++ and Shared-Inlining underperform IXMDB due to the additional operations on character string parsing, datatype conversion and without index on the individual items of the matrices. Furthermore, to parse the character string, SUCXENT++ and Shared-Inlining need the value SUCXENT++ to get the value of dim that corresponds to the matrix in question.
 our array/matrix storage schema has a disadvantage. It needs more joins (joins between leaf node table and array/matrix table) to get required array/matrix data. Compared to the other methods without the indices on index mechanism in IXMDB results in the significant efficient performance. 7.4.3. Queries from the multimedia perspective
As mentioned in the previous section, the GiST framework is connected with our RDBMS-based MPEG-7 storage system via a set of UDFs. This enables our system to support efficient multimedia-related queries. To test the performance from the multimedia perspective, we performed a similarity search on four low-level
MPEG-7 descriptors extracted from 300,000 pictures. The tested descriptors include ColorLayout(CLD) with 12 dimensions, RegionShape(RSD) with 35 dimensions, EdgeHistogram(EHD) with 80 dimensions, and Col-orStructure(CSD) with 128 dimensions. The similarity search in our experiment is to find the top 10 objects that are the most similar to the given object based on each descriptor. In this experiment, we adopted M-Tree in IXMDB, since M-Tree is based on distance function. Fig. 29 presents the corresponding experimental result.
 According to this figure, IXMDB outperforms the existing XML storage systems for similarity searching.
Due to lack of efficient high-dimensional index mechanism, the existing XML storage systems can only per-form sequence scan to achieve similarity matching, while IXMDB can benefit from the GiST framework. Fur-thermore, the existing XML storage systems need to extract desired multimedia content from their MPEG-7 descriptions repository before performing similarity searching. The performance of this extraction process depends on the complexity of related multimedia content and their storage schema. Such an extraction process may be expensive. For example, for the ColorLayout descriptor, the related multimedia content is stored in several elements. Thus, SUCXENT++ needs several joins to extract related information and this operation is expensive. 8. Related research
As introduced in the previous section, the existing RDBMS-based XML storage approaches can be classi-fied into two major categories: schema-conscious approach and schema-oblivious approach. Some typical examples of schema-oblivious approach include The Edge Approach [15] , Monet [16] , Xrel [17] , XParent [18] , SUCXENT++ [11] , etc. The Edge approach stores XML data graphs (a directed graph) in a single Edge table. As a variation of the Edge approach, Monet partitions the schema of XML documents by all possible paths. For each unique path, Monet creates a table. Unlike Monet, XRel explicitly keeps all unique path of numbers that represents the start and end positions, respectively, of a node in an XML document. XParent is a four (or five) table database schema and materializes the ancestor X  X escendant relationship in a special table. SUCXENT++ is different from the above approaches in that it only stores leaf nodes and their asso-ciated paths.
 Some examples of schema-conscious approach can be found in Basic, Shared and Hybrid Inlining
Technique [12] and LegoDB [19] . The Inlining technique is an early proposal of schema-conscious approach. With this approach, complex DTD specifications are first simplified with a set of transformation rules and corresponding transformed DTD graphs are obtained. Then, three techniques, including Basic
Inlining, Shared Inlining and Hybrid Inlining, are used for converting the simplified DTD to a relational schema. The LegoDB can automatically find an efficient relational configuration for a target XML application.

The database products of leading database system vendors have extended their relational database func-tions to support the XML documents storage. They can be viewed as XML-Enabled databases, which also provide RDBMS-based XML storage solutions. Some products of these include DB2 XML Extender [25] ,
XML Support in SQL Server [26,27] and Oracle XML DB [28] . These XML-Enabled database systems intro-duce one or more special datatypes for XML storage and provide a set of functions on these datatypes to sup-port XML management. The intact XML content can be stored in a column with VARCHAR or CLOB datatype. A set of powerful built-in functions or methods is provided to query and modify XML instances and they also accept XQuery.

There exist some research works that focus on the hybrid relational and XML database system, e.g. Sys-tem RX [29] , which enables XML and relational data to co-exist and complement each other. Some other research works focus on how to implement XQuery in a relational database. These works can be found in [30,31] .

There are a few research works on the MPEG-7 descriptions management systems. The examples of these works are the MPEG-7 Multimedia Data Cartridge (MDC) [37] and PTDOM [38] . MPEG-7 MDC is a system extension of the Oracle 9i DBMS to provide a new indexing and query framework for various types of retrie-val operations and a semantically rich metadata model for multimedia content relying on the MPEG-7 stan-dard. Although the MPEG-7 MDC provides a robust storage solution for MPEG-7 descriptions, it falls short when evaluated in terms of the requirements listed in [4] . First, MDC is a system extension of the Oracle 9i
DBMS. It defines a set of object types to map the MPEG-7 standard into a database model. The data within such object types, e.g., XMLType object type, may not be represented and accessed in fine-grained and typed manner. Second, the predefined object types may not be suitable for the non-fixed MPEG-7 descriptions with mation within MPEG-7 descriptions. PTDOM is a schema-aware native XML database system originally developed for the management of MPEG-7 descriptions. The core of PTDOM is made up of a schema catalog capable of managing schema definitions written in MPEG-7 DDL [38] . To represent the contents of the
MPEG-7 descriptions, the document manager of PTDOM applies the TDOM [24] , an object model in the tra-dition of DOM. 9. Conclusions
In this paper, IXMDB, a new approach to mapping, indexing and retrieving MPEG-7 documents and other data-centric XML documents using relational database system, has been described. IXMDB inte-grates the advantages of schema-conscious approach and schema-oblivious approach. Unlike the schema-conscious method, IXMDB supports XPath-based query efficiently without involving many joins in
SQL. Compared with the schema-oblivious method, IXMDB solves the datatype problem in schema-obliv-ious approach without sacrificing the performance, and IXMDB even performs better than most schema-oblivious approach in the case of many XPath based queries. Furthermore, IXMDB provides a flexible storage schema to satisfy all kinds of storage requirements, especially for the special datatypes within
MPEG-7 descriptions, such as array, matrix, basicTimePoint and basicDuration . Although IXMDB cannot avoid the assistance of MPEG-7 scheme, it can support arbitrary MPEG-7 description storage. IXMDB supports the most critical requirements for the MPEG-7 descriptions management, such as fine grained and typed representation and access, index system and XPath-based query. Finally, we also introduced a multidimensional index system based on extensible GiST framework to support multimedia content retrieval.
 Appendix A. SQL queries in IXMDB
We do not list all the SQLs. The unlisted queries are similar to the following queries, or cannot be imple-mented with single SQL.

References
