 In recommendation systems, a ce ntral host typically requires recommendations. This access, however, undermines user privacy; the more information is revealed to the host, the more the user X  X  privacy is compromised. In this paper, we propose a novel end-to-end encrypted recommendation mechanism which encrypts sensitive private data at the user end, without ever exposing plaintext private data to the host server. Unlike previously proposed privacy-preserving recommendation mechanisms, the data in this proposed system are lossless  X  a pivotal feature to many applications, e.g., in health informatics, business analytics, cyber security, etc. We achieve this goal by developing encrypted-domain polynomial ring homomorphi sm cryptographic algorithms to compute similarity of encrypted scores on the server, so that collaborative recommendations can be computed in the encryption domain and only an authorized person can decrypt the exact results. We also propose a novel ke y management system to make sure private information retrieval and recommendation computations can be executed in th e encrypted domain in practice. Our experiments show that the proposed scheme offers robust security and lossless accurate recommendation, as well as high efficiency. Our preliminary results show the recommendation accuracy is 21% better than the existing statistical lossy privacy-preserving mechanisms based on random perturbation and user profile distribution. This new appr oach can potentially be applied to various data mining and clo ud computing environments and significantly alleviates the privacy concerns of users. H.3.3 [Information Search and Retrieval]: Information Filtering; Algorithms, Design, Securi ty, Experimentation. Recommender Systems, Pe rsonalization, Privacy. Users can be overwhelmed by the huge number of choices available on the Internet. Recommendation systems are widely used to narrow down their choices, for items of any type: books, movies, sports, restaurants, touris t destinations, online news, etc. User profiles such as age range, gender, and location, as well as web activity history such as s earch keywords and click-through sequences all can be used to find dating prospects over the Internet. The widely-used colla borative recommendation systems rely on the similarity of user tastes: if two users have similar preferences for certain items, one us er will probably be interested in the items that the other is interested in. Thus, the more information each user gives to the recommender system about his interests, the more meaningful the recommendations will be. A recommendation system creates user profiles by collecting information about user preferences for different items. The preferences of a user in the past can facilitate the prediction of other matching information that mi ght also be of interest to the user in the future. In order to recommend items to users, a recommendation host must access the user X  X  profiles, which contain various person-identifiable information. These profiles are usually stored in the host repositories. Currently, users of any recommendation system must allow the host access to the complete contents of their profiles and trust (or, in most cases, just hope) that the host company and the server administrators will keep this information private. Allowing  X  X laintext X  information, which is readable by the server, leads to many thorny privacy issues. First, if a user X  X  real identity is known to the host, the host can associate the user X  X  personal profile, which contains his private in formation, to his real identity. This is an obvious privacy breach , considering that although using the service, the user does not want the link between his real identity and his profile to be revealed. This threat becomes more obvious when users reveal sensitive personal data, such as age, height, weight, sexual orientation, and religion. Second, even if the real identity of a user is not known to the server, it can attempt to de-anonymize the user X  X  identity by correlating the information contained in the user X  X  profile and information obtained from other related databases. Third, hosts may collect personal information about their users and resell it to various vendors for sales and marketing to gain significant financial benefits. Today, there is much such user data to be had. However, user data is vulnerable to criminals; it can affect one X  X  reputation, business operations, etc. From a privacy perspective, it is obvious that hiding personal information from the host is a good thing. To do so, an end-to-end encrypted recommendation computing system such as that proposed in this pape r is probably the best solution. It leaves private information in ea ch individual X  X  possession, while allowing the server to conduct recommendation computations in the encrypted domain without know ing the original plaintext profiles. Several techniques have been proposed to preserve user privacy in recommendation systems. The three main categories for privacy preservation in recommendation systems are user score perturbation, cryptographic approach es, and distributed storage of user profiles. Randomized pertur bation [1][2] techniques have been used to preserve privacy in collaborative recommendations. In this approach, user data ar e modified by adding random noise in order to prevent the central server from deriving the actual user rating. However, the added noise prevents the server from being able to estimate the actual values for similarity measurements; moreover, additional security flaws are caused by small user space sizes. Canny [3][4] proposed a community-based cryptographic privacy-preserving collaborative filtering method. A community of users can compute a public  X  X ggregate X  of their data without disclosing any individual user X  X  data. This aggregation allows personalized referrals to be computed by members of the community. A partially homomorphic encryption like RSA [5] is employed to allow sums of encrypted vectors to be computed and decrypted without exposing individua l data, but this approach still has accuracy problems. Thus both randomized perturbation and cryptography-based aggregate computation entail a compromise between recommendation accuracy and personal data security. The third option is to store user profiles locally and run the recommendation system in a distributed manner by revealing partial information, without rely ing on a centralized server [8] X  [12]. In this case, although serv ers only know partial information, eventually, an end-to-end service provider may still be able to assemble the information from each individual server which knows part of the information. Fo r instance, dividing my personal information into 10 pieces and te lling 10 different people does not really protect my privacy. Our contributions are as follows. In this paper, we first propose a novel system solution for privacy-preserving recommendations in which we do not require several customers to be online simultaneously, nor do we in troduce random perturbations. Second, we conduct encrypted-domain addition and multiplication operations based on polynomial rings, so that we can generate the same collaborative filtering results as that obtained from the plaintext data. Third, we propos e a ring homomorphic encryption algorithm which makes the encrypted-domain recommendation calculations highly computationally efficient, a key step toward making encrypted-domain recommendations feasible. As our approach is based on lossless number theory, recommendation results are the same as recomme ndations made based on plaintext data. This solves the many drawbacks described above, and is the goal of this paper. The rest of this paper is organi zed as follows. We review related work in Section 2. In Section 3, we describe in detail our privacy-preserving system, including how to handle the key management of collaborative recommendation a nd how to compute the user-to-user similarity entirely in the encryption domain. In Section 4 we analyze the security, efficiency, and accuracy of the proposed system, and in Section 5 we conc lude and suggest directions for future work. In the randomized perturbation sche me, each user disguises his or her personal data and then sends it to a central place (the data collector) such that the data co llector cannot derive the user X  X  actual private information. This scheme should still be able to allow the data collector to conduct collaborative filtering using the disguised data. Polat and Du [1][ 2] proposed a technique in which user ratings are modified by addi ng random noise to them in order to prevent the central server from deriving the actual user ratings. The challenge is to find a perturbation algorithm that imposes the smallest error on the recommendation process. Users enjoy a high level of privacy if the server is not able to estimate the actual ratings that they assigned to the items. However, the perturbed list of items rated by the users is revealed, regardless of the perturbation level. This overlo oks the fact that keeping the connection between users and items is more crucial (in order to preserve users X  privacy) than disguising the ratings assigned to those connections. Also, revealing the places visited by the users to the server enables it to track users over space and time, whether they liked those places or not. Recommendation schemes based on partially homomorphic cryptography as proposed by Canny et al. [3][4] require user participation in the distributed sy stem, which may not reflect real-world usage such as cloud computing. Recently, in cryptography, Gentry et al. proposed a breakthrough fully homomorphic encryption scheme using lattice-ba sed cryptography that supports computation in the encrypted domain [6][7]. To the best of our knowledge, we are not aware of any prior work applying such a fully homomorphic scheme to r ecommendation applications (or, perhaps, any data mining applica tion). In practice, their scheme may need substantial improvements in order to be used in practical applications, because the ciphertext size and computation time increase sharply as one increases the security level. Their constructions are limited to ev aluating low-degree polynomials over encrypted data. Moreover, the scheme allows only single bit operations, and even that is computationally prohibitive. Also, the scheme does not offer a practica l key management solution where all of the users share the same public key for a full homomorphic encryption application. Another option is to store user profiles locally and to run the recommender system in a distribu ted manner, without relying on any server. Miller et al. [8] proposed transmitting only the similarity measures over the netw ork and keeping users X  profiles secret on their sides to preserve privacy. Berkovsky et al. [9] proposed a distributed P2P system to avoid storing users X  profiles on a single server. Although these methods eliminate the main source of threat against users X  privacy, they require high recommendations. Every user pays the price of using this method, regardless of his interest in protect ing privacy. Lathia et al. [10] proposed a concordance measure to estimate the similarity between two users in a distributed system without revealing their actual profiles to each other. Lathia X  X  method demands that users recommendation system based on thousands of users [11][12]. The most common form of collaborative recommendation is the neighborhood-based approach, which works by computing the similarity between all pairs of users; predictions are made by aggregating ratings of the target item by the user's neighbors or the user's ratings of items that are neighbors of the target item. Algorithms within these families differ in the definition of similarity and the formulation of neighborhoods. Finding a particular consumer's neighborhood w ith similar tastes or interests and quantifying the strength of similarity are the most crucial steps for making a collaborative recommendation. Recently, algorithms based on a weighted user-item bipartite-graph soft clustering [15] [16] have been proposed which yield higher accuracies than classical collaborative filtering approaches. This serves as the kernel of our collaborative recommendation system. We summarize the relationshi p among users, items, and the corresponding item scores,  X   X  X , using the bipartite graph  X  X  X  X   X  X  X  , X   X  X  X  X  , X   X  X   X  shown in Figure 1 (a). In the graph, the nodes at the left denote the groups of n users, the nodes at the right denote the m items, and user groups and item objects are connected by edges associated with corresponding weighting scores. The corresponding user affinities are shown in Figure 1 (b). As pre-scribed, let  X  X  X  X   X  X  X  , X   X  X  X  X  , X   X  X   X  denote a bipartite graph, vertex sets and  X   X  X  denote all the edges that connect  X   X   X  X  X  X  . Let  X   X  X   X  X  X e  X  X   X  X  X   X  denote the  X  X  X  adjacency matrix with e  X  X  X   X 0 being the the correspondi ng item score between u i  X  . The bipartite graph induces a similarity between u u  X  , that is, where  X  X  X iag  X   X   X  , X ,  X   X   X  , and  X   X   X   X  e  X  X   X  X  X   X   X  X  X  X  the perspective of Markov random walks on graphs. stationary probability of the direct transition between u and u  X  X  X   X  . However, this shows only the similarity between users. To measure the similarity of the whole group, we have the following matrix formulation: SIM X  X   X  W  X  ,  X 2 X  where W X  Z  X  X  X  X   X  is a non-negative  X  X  X  matrix. For the components of this matrix, one column corresponds to one user and one row to one item, i.e., w  X  X   X  X  X  is the score of item i by user u  X  X  X   X  .  X  is an  X  X  X  non-negative diagonal matrix within which  X   X  indicates the user X  X  le vel of participation. It is well-known that such collaborative filtering can be realized by the calculation of user-to-user similarity so as to recommend users. We use the following example to describe our privacy-preserving encrypted-domain recommendation syst em. In health informatics, patient privacy must be carefully protected. Therefore, after seeing the doctor, the patient encrypts the more sensitive parts of his or her own medical record  X  for instance, psychological treatments, infertility treatments, or cosmetic procedures  X  and then transmits them to the server at the hospital or insurance company via a secure channel. Thus sensitive data stored in the central database is totally encrypted. When another doctor diagnoses a new patient, in order to find the most appropriate treatment, he or she looks for similar patients with similar symptoms in the encrypted database to see how other doctors diagnosed them, and then takes this into account to give their own patient the best treatment. Figure 2 illustrates our privacy-preserving recommendation scheme for this particular case. In order to achieve the above fu nctions, our system requires three encryption mechanisms. The firs t one is the ring homomorphic encryption. To ensure privacy, the patient should encrypt his or her own data. The goal is that every patient X  X  sensitive medical records are encrypted and that similarity measurements on this data are evaluated in the encryption domain. Thus, ring homomorphic encryption provides the first tier of data protection, allowing for computing multiplication and addition in the encryption domain and inducing these two operations for the underlying plaintext. Homomorphic key distribution is conducted at the key manager server. Thus, when the inspection data is obtained at the clinic, the key management server delivers the homomorphic key to the patients, who encrypt their own private medical information and send it to the hospital databa se server via a secure channel.

Figure 1. Illustration of soft communities: (a) the bipartite graph representing user-to-item relations, and ( b ) the induced user cluster affinities.
 Figure 2. Privacy-preserving recommendation scheme. The channel between the parties, such as from the user to the server, may be vulnerable to eav esdropping and malicious attacks, including man-meet-in-the-middle and replay. Also, to ensure the confidentiality of medical records, we must hide the identity of the patients. Thus, another important issue is how to send these medical records in a way that preserves the patient X  X  privacy and anonymity. Ring homomorphic encryption calculation alone cannot ensure information security. Thus, we here apply the second tier of communication secu rity mechanisms using the improved Diffie-Hellman-based prot ocols, which enable us to securely send the patient X  X  encrypted data to the server. Also, instead of using digital signatures, our scheme hides patient identities by using a hash function . Effective key generation and management is critical for a complete, end-to-end encrypted domain recommendation system. The key for the secure channel by our improved Diffie-Hellman-bas ed protocol is based on the secret sharing principle. Hence the session key is obtained by the two communication parties. When the doctor submits an encrypted request to the server to calculate the similarity of private information, the similarity measure is calculated in the encryption domain. Therefore, the server needs not be trusted sin ce it knows nothing about the real medical information. Our homomorphic encryption and private information retrieval procedures are illustrated in Figure 3. After the encryption-domain similarity measurement is completed, the doctor provides order-preserving encryption keys to the server database. The third-tier order-preserving encryption is applied to transform these encryption similarity results, which are then sent homomorphic private key to decrypt the transformed similarity results, it still is limited to calculating rankings, and has no way of knowing the real similarity value. The case ranked most similar to the information is then returned in encrypted form to the doctor, who can use his or her private key to participate the order-preserving data encryption. In this way the doctor takes into account the treatment for similar patients when deciding on the best treatment for the current patient, as shown in Figure 4. Homomorphic encryption is a form of encryption where a specific algebraic operation performed on the plaintext is equivalent to another (possibly different) alge braic operation performed on the ciphertext. The commonly used RSA code is only homomorphic with respect to multiplication. Given public key  X   X , X   X  ,  X  is encrypted as  X   X   X  mod . Since  X  X   X   X  X  X  X   X  X  X   X   X   X   X   X  X  X   X   X   X  X  X  X  X   X  , X   X  X  X  it follows that the encrypted form of  X  X  is the product of the codes for  X  and  X  . Hence we can correctly multiply two encrypted numbers without ever knowing what the numbers were, and obtain a lossless result. Multiplication-only homomorphic cryptosystems such as RSA are not enough for end-to-end encrypted-domain recommendation. For this task fully homomorphic en cryption is required. The utility of fully homomorphic encryption has been long recognized. However, it was not considered feasible until 2009, when Gentry et al. [6] proposed the first fu lly homomorphic encryption scheme based on lattice-based cryptograp hy. The scheme is limited to evaluating low-degree polynomials over encrypted data, and thus a modified bootstrable scheme was applied to improve its efficiency [7]. One obstacle of these methods is that the key operations are based on one binary bit [6][7]. We propose an efficient ring homomorphic encryption system based on polynomial rings which dire ctly calculates integers in the encrypted domain, and is thus more efficient for tasks such as collaborative filtering based recommendations. A ring homomorphism is a f unction between two rings which respects the operations of addition and multiplication. With ring homomorphic encryption, you subm it an encrypted copy of all Figure 3. Homomorphic encryption and private information retrieval via end-to-end secure channel. 
Figure 4. Order preserving encryption and encrypted similarity ranking. your private data and get back an encrypted copy of the actual scalar matching result you are lo oking for, without revealing any of your private data. A ring homomorphism function, in our scheme, is a function between tw o polynomial rings with respect to the operations of addition and multiplication. More precisely, if R and S are polynomial rings, then a ring homomorphism is a function  X  :  X   X  X  such that  X   X   X  X  X   X   X  X   X   X   X   X  X   X   X   X   X  4  X  We need to derive encrypted-domain calculations, including both multiplications and additions. In (2), we have SIM X  X   X  W where W X  Z  X  X  X   X  is a non-negative matrix and its entry component represents the weighting of the relationship between each user and each item. To preserve user privacy we must define a method for measuring similarity in the encryption domain. Based on equations  X 1 X  and  X 2 X  , we have where  X   X . X  stands for the ring homomorphic encryption algorithms and  X   X   X  denotes the weight of the relationship between user  X  and item  X  , which is the simplified notation for w Equations  X 2 X  for describing the graph model. For all users and items we also have, in matrix form, the soft clustering formulation for a group of people in the encryption domain as follows: where  X  is an  X  X  X  non-negative diagonal matrix with  X  indicating how often a user par ticipates in a given activity. We propose polynomial ring homomorphism, which is described in this section also with details in Section 4, to realize equation (4) in practice. After the server-side encrypted-domain computation, the encrypted recommendation results are returned to each user, again via a secure channel, with which the authorized user can decrypt the results using his or her private key. Thus from the user side to information is encrypted, transferred, and computed in the encrypted domain. The encrypted-domain computation is based on the polynomial ring homomorphism. In this section, we derive a new ring homomorphism based on the concept of lattice-based cryptosystems [14]. Lattice-based cryptographic sc hemes hold great promise even against quantum computers, as they boast very strong security proofs based on worst-case har dness, relatively efficient implementations, and great simp licity. Compared to modular exponentiation (RSA) as well as repeated squaring and doubling (ECC), lattice-based polynomial ring homomorphic encryption provides not only strong encryption-domain summation and multiplication, but also boasts  X  X  X   X   X  performance or even  X   X   X  X  X  X  X   X  when applying FFT. Note that both RSA and ECC are of complexity  X  X  X   X   X  . This is because polynomial ring convolution operations are faster than the other approaches. Moreover, the cryptosystem uses the polynomial ring  X   X   X   X   X  Z  X   X   X   X   X   X   X   X 1  X  and P  X   X   X   X   X  X   X   X   X   X   X   X   X   X 1  X  ,  X  where  X  is positive prime, Z denotes the ring of integers, and Z  X  modulo  X  . Therefore the encryption capability associated with the the degree  X  is 7, the total representation plaintext number can reach 17  X  . Thus the throughput of the proposed encryption scheme is far greater than Gentry et al X  X  single-bit representation with only 2  X  options. This shows that our system lends itself to real-world implementations. As shown in Figure 5, a lattice is a regular array of points in space: note that we can connect the dots to form parallelograms. The lattice may be described by giving basis vectors that span such a parallelogram. The closest vector problem (CVP) is that given closest to P without knowing L, the basis of the lattice. In this section we describe the encryption and decryption scheme. User-side encryption is conducted as follows. Score mapping to polynomial rings. Alice transfers the integer score for a item to a polynomial. For example, 3 is mapped to  X 1 X  , 5 is mapped to  X   X   X 1, and 11 to  X   X   X 1 X  X  . This approach in effect spreads an integer over several coefficients of a polynomial. This idea is the basis for the secrecy, efficiency, and encryption-domain operation of our proposed approaches.
 Parameter settings. Three positive inte gral parameters  X   X , X , X   X  are chosen for the key generation which satisfy the following are relatively prime to each other, i.e.,  X  X  X   X   X , X   X   X  X  X  X   X   X , X   X   X  1 . The values of  X   X , X , X   X  can be known to the public. Polynomials chosen. There are four sets of polynomials  X   X  , and  X   X  respectively defined in the polynomial ring  X   X   X   X   X  Z  X   X   X   X   X   X   X   X 1  X  . The coefficients of these polynomials are constrained by the choice of parameter  X  , i.e. all the operations are defined in the polynomial ring R  X   X   X   X   X  Z  X   X   X   X   X   X   X   X 1  X  X  X  , which is equivalent to the operati ons defined by taking modulo  X   X  1  X  on polynomials and modulo  X  on polynomial coefficients simultaneously. Key generation. Homomorphic key generation is a crucial part of an encryption scheme. In our sche me, the key is embedded in the coefficient of the polynomials as follows.
 We first define Since  X   X   X   X  is a trinary polynomial, the system chooses a  X  X  X  X  X  X   X   X   X , X 1 X   X  as his or her private key which is used to decrypt the Figure 5. Example of lattice-based cryptography, where 
Q is the encrypted point of P, and the basis of the lattice encrypted-domain recommendation result. Alice then randomly selects a polynomial  X  X  X  X  X  X  X   X  such that  X  X  X  X  X  has an inverse both in modulo  X  and modulo  X  , i.e., the inverses exist in both R That is, the system can compute the two inverses of  X   X   X   X  ,  X  and  X   X   X   X   X  , respectively in R  X   X   X   X  and R  X   X   X   X  as Then Alice randomly selects a trinary polynomial  X   X   X   X   X   X   X  which in  X   X   X   X  X   X   X , X   X  and then computes Alice uses the polynomial  X   X   X   X  as her public key, and  X  X  X  X  X  and  X   X  X  X  X  becomes her private key for decryption [15].
 Centered lift coefficients. Alice keeps each coefficient of the plaintext score polynomial  X   X   X   X   X   X  within the range  X  X  ensure correct encryption and decryption, maintaining the one-to-one and onto property between the plaintext and the cipher text, where  X  is the number of plaintexts we are going to encrypt and  X  is the modulo we have chosen. It is well known that if we take integers 2 modulo 7, we can express 2 as  X 12, X 5, 2 ,9,16 and so on. Now, we define the centered lift operation  X  CLO  X  to restrict the coefficients to be centered around 0. That is, every coefficient  X   X   X   X   X  of  X   X   X   X   X   X  satisfies  X   X  After applying CLO, the representation for each of the coefficient is unique. As an example, if we choose p= 4 and n= 1 , then  X  Encryption. Alice encrypts her score for item  X  (denoted as  X   X   X   X   X  ) using the public key  X   X   X   X  and the randomly blinding key  X   X  X  X  X  as to make each cipher as unique as if a one-time pad were applied. Likewise, she encrypts her score for item  X  (denote as  X  using the public key  X   X   X   X  and the blinding key  X   X   X   X  X  X  X  As each group of attendees encrypts their own scores for each item using different randomly chosen blinding keys  X  X  X  X  X  X  X  encryption of participant  X   X  X  score polynomial  X   X   X   X  When the server receives the encrypted scores e  X  can only multiply the encrypted scores, yielding As we can see in the formula, although the encrypted m m plaintext score multiplication  X   X   X   X   X   X   X   X   X   X  domain , it still induces multiplication of the underlying plaintext  X   X   X   X   X   X   X   X   X   X   X  , which is the exact, lossless multiplication score of the plaintext, to which is no perturbed noise or distribution. The homomorphic private key owner decrypts the  X   X   X   X   X   X   X  owner side. When the owner re ceives the encrypted product  X  key  X  X  X  X  X   X  and proceeds as follows: After the private key owner applies  X  X  X  X  X   X  over R  X   X   X   X  , we have Correct encryption and decryption needs to maintain the isomorphism, i.e., one-to-one a nd onto, between plaintexts and ciphertexts, where the coefficients of  X  should fall within the interval  X   X  is bounded from modulo  X  , and the second is the number of coefficients of  X  X  X  X  X  equals to 1 and  X 1 , respectively. If we select appropriate values fo r multiplication modulo  X  as well as  X  , the number of the coefficients equals 1 in the trinary polynomial  X   X   X   X  ,  X   X   X   X  and the homomorphic private key, and then applies the second private key  X   X   X  X  X  X   X  and takes operations modulo p as  X  X  X  as an example. Taking N  X 491531  X   X 29, and X  X 7, ,  X   X 24  X   X 15 X  X 4 and the inverse  X   X   X   X   X  of  X   X   X   X  modulo  X  is  X 318457 X 470762 . The public key  X   X   X   X  is  X   X   X   X   X  X   X   X   X   X   X   X   X   X  R  X  X  X  Plaintext scores given from Users  X  and  X  The random blinding keys for the encryption of each score are as follows: Encryption Similarity measurement in the encryption domain Decryption We then recover the exact plaintext similarity measurement results. We have thus demonstrated the complete procedure of ring homomorphic encryption-domain sim ilarity measurement. Note that in this paper, our focus is to fundamentally solve the system, key management, and algorithmic challenges of recommendations in the end-to-end encrypted domain. Therefore, we omit the homomorphism, which is outside the scope of this paper. We here present an order-preserv ing encryption scheme for data which allows any comparison operation to be directly applied on the encrypted data. Figure 4 shows the use of this order-preserving encryption ranking proxy in the overall system. In the original proxyless scenario, when the encryption-domain computation is completed, the server sends back the encrypted weights to the proxy, which decrypts the results using a homomorphic private key. In the or iginal scenario, only the doctor can decrypt the results. Therefore, in order to identify the most similar patient, the server mu st conduct pairwise encrypted-domain similarity measures between the patient and all other people in the database and then return all the encrypted measurements to the doctor. We derive an order-preserving encryption ranking that makes use of a proxy. As this result is protected by the doctor with order-preserving encryption, the proxy does not know the actual si milarity measurement results, as this would allow access to private patient data. Thus the proxy is allowed only to see rankings and not the similarity measurements. This is an important aspect, because the proxy needs to know the rankings of the patients and thus only return the most relevant ones to the doctor. Without this order-preserving encryption ranking procedure, the server would be required to return to the doctor all pairwise similarity measurements, which are not known by the server. It sends the ranking results to the doctor via a secure channel, after which the doctor uses his or her order-preserving private key to decipher the real measurement results. We have thus shown that a scalar product-based algorithm can be implemented in the encryption domain, which in turn shows that a privacy-preserving collaborative recommendation system can be realized accordingly. Order-preserving encryption ranking is accomplished as follows: after the server implemented the encryption-domain similarity measurement stated in Section 3.4, if it were to directly carry out ranking, the proxy might be able to obtain the actual similarity measure values, which would be a breach of the patient X  X  privacy. Thus we apply order-preserving encryption at the server to rescale the actual similarity measurement value with the order-preserving encryption secret key provided by the doctor. The encrypted similarity measurement is then where  X  X e X   X  X   X   X  and  X  X e X   X  X   X   X  are the order-preserving encryption keys provided by the doctor. e  X  W  X  X  X   X  is the original encryption-domain similarity measurement results, and  X  X  X  similarity measurement results after applying order-preserving encryption. This idea is derived from the affine transform function In the finite-dimensional case, each affine transformation is given by a matrix A and a vector  X  . This transformation satisfies the following two properties: (1) the collinearity relation between points; i.e., points which lie on a line continue to be collinear after the transformation. (2) The ratios of distances along a line; i.e., for distinct collinear points  X   X  ,  X   X  , and  X   X  the ratio |  X  is preserved. With this property we can encrypt the real similarity result but still preserve the order of the underlying similarity scores for comparison. After proxy ranking, the group of patients the doctor is looking for is sent to the doctor via a secure channel. The doctor then decrypts this data to gain access to the reference information that he or she needs. The spirit of our end-to-end encryption domain recommendation e.g., the client, the information is encrypted and sent to the server to measure similarity in the encryption domain and then sent to the proxy for ranking, also in the encryption domain. The most correlated patient X  X  clinical information is sent to the doctor so as to assist the doctor in deciding on an effective treatment. Secure channels are required for every c onnections involved, e.g., client to server, server to proxy, and proxy to doctor . The Diffie X  X ellman key exchange protocols allow two parties that have no prior knowledge of e ach other to establish a shared secret key jointly over an insecure communications channel to provide end-to-end security. This key can then be used to encrypt subsequent communications usi ng a symmetric key cipher. As shown in figure 6, we adopted Diffie-Hellman-based protocols because it offers the following advantages: first, it provides anonymity: our proposed protocols use hash functions instead of digital signatures to confirm identities. In our scheme, a user does not need to sign for his or he r private data as this would compromise the user X  X  identity. S econd, due to the nature of this protocol, our scheme is protec ted from man-meet-in-the-middle and replay attacks. Mo reover, our scheme is effective and simple, since we adopt a uniform data format and because the hash function is more efficient than the use of digital signatures. In the Diffie-Hellman key protocol, Alice and Bob agree on a public  X  that generates multiplicative group G . They then select random values  X   X  and  X   X  , respectably, in the range between 1 and the order of G , and Alice calculates  X   X   X  X   X   X   X   X  X   X   X  , after which they exchange these values. Due to the group homomorphic property, the shared secret key  X  generated as  X   X  X   X  X   X   X   X   X  X   X   X   X  . In thus doing, Alice and Bob agree on, but do not confirm, th e key. We use the hash function  X   X  .  X  and message authentication code with key  X  denoted as  X  X  X   X   X  .  X  with challenge with response nounces  X  encrypted using public keys  X   X   X  .  X  and  X  compromising the key agreement information. To demonstrate end-to-end encrypted domain recommendation, we implemented the proposed algor ithms as a prototype system using Microsoft Windows 7 (32-bit) operation system, an Intel Core 2 Quad CPU, and 2 GB RAM. We also used this system to evaluate our system security, recommendation accuracy, and system performance. In our experiments, we use the Jester and Book-Crossing datasets to evaluate the accuracy of the encrypted-domain recommender. We used the recommendation algorithm described in Section 2, and then compared the results with those from the proposed privacy-preserving collaborative recommendation scheme. We also compared our approaches with randomized perturbation [2] based on the same traditional recommendation method. The Jester dataset is a web-based joke recommendation system, developed at the University of California, Berkeley, collected between April 1999 and May 2003, this database has 4.1 million continuous ratings (from  X  10 to  X  10) of 100 jokes from 73,421 users. The Book-Crossing dataset has been mi ned by Cai-Nicolas Ziegler, DBIS Freiburg, and includes 1,1 49,780 integer ratings (from 0 to 10) of 271,379 books from 278,858 users. Compared with the standard recommendation system, our system requires a longer running time. This is because we execute end-to-end encryption to secure user information and calculate similarities and ranks in the encryption domain. This is reflected in figure 7, which illustrates the roles that more users and stronger encryption play in increasing r untimes. However, as shown in Section 4, in our privacy information retrieval system, encryption can be done in advance; decryption is a process separate from encryption. Hence in the figure we isolate the running times for the encryption-domain and non-privacy-preserving similarity measurements. These indicate that the difference is limited. Since our approaches are based on number theory with ring homomorphic encryption, our lossless privacy-preserving recommendation scheme provides exac tly the same results as the standard non-privacy-preserving recommendation. This is in notable contrast to statistics-based approaches to privacy-preserving recommendation: such approaches yield only approximate results. We evaluate the system accuracy using the most common criterion: mean absolute error (MAE). This quantity is used to Figure 7. Efficiency comparison between a standard non-privacy preserving recommendation system and the proposed system. 
Figure 6. The protocol uses hashes and the MAC function to provide anonymity and identify confirmation. measure how close forecas ts or predictions are to the actual outcomes. The mean absolute error is given by We compare MAE as the accu racy for our privacy-preserving approach with that for the non-privacy preserving approach. We also compare the results of the random perturbation and user profile compare the results of clustering on the original data with the clustering results for the privacy-preserving approach. Since our approaches are based on ring homomorphism number theory, we obtain exact the same perturbation and user profile distri bution approaches, both of which the user X  X  privacy. As shown in Figure 8, in contrast to our approaches, these two methods do not result in higher accuracy. recommendation systems [2], if there is little user data, or if the data is randomly distributed, recommendation results suffer dramatically. For our system, since we calculate the Euclidean metric in the encryption domain, we have no such limitation . One serious problem with other privacy-preserving recommendation systems is that us ers do not encrypt their own data but instead must trust other potentially un-trusted parties to encrypt the data for them. Thus, besides lacking encryption during some parts of the procedure, user pri vacy is left in the hands of a third party. In comparison, our system provides a level of security that other systems do not provide. Since we implement an end-to-end encryption security environment, it creates a security domain amongst the user's terminal, the se rvice provider, and the database. In Table 1, we compare the recommendation schemes for the other two kinds of privacy-preserving systems. As one of post-quantum cryptosy stems, our proposed lattice-based encrypted algorithm is stronger than any other lightweight based encryption [1][2][3]. The measurement of the hardness of the system is similar to that of a public key cryptosystem which is usually judged by the most effective known attacks against it. The corresponding most effective kn own attack is the meet-in-the-middle and the lattice reduction algorithms. When compared to our approach, the randomized perturbation privacy-preserving scheme has the following security problems. First, the privacy is not sufficiently protected, becaus e in order to obtain more accurate recommendation results their systems must fit the perturbation random numbers to a Gaussian distribution with zero mean. This limits their encryption strength. Whereas big plaintext scores and relatively small amount s of random noise render such privacy preservation useless, larger amplitude noise vectors to mask the original data lower prediction accuracy. The second problem is that the system is vulnerable to chosen plaintext attacks. A malicious user who submits scores of zero may be able to compromise the system X  X  ra ndom perturbation number. The third security concern is that this approach requires the revealing of extra information to maintain the accuracy of the random perturbation scalar product. For privacy preservation via fact or analysis for user profile distribution, which involves a se cure computation technique using partially homomorphic encryptions, user scores are stored as encrypted vectors and aggregates of the data are provided in the recommendations explicitly. The partially homomorphic encryptions of this approach, such as RSA and ECC, allow for homomorphic computation of only one operation (either addition or multiplication) on plaintext. Therefore, the similarity measurements it yields are not as accurate as those yielded with our ring homomorphic algorithm, which supports both addition and multiplication in the encryption domain. We compare the security of various privacy-preserving recommendation approaches in table 1. 
Figure 8. Comparison with the average accuracy of other approaches of privacy-preserving recommendation.  X   X  X  X   X  Since our approaches are based on number theory with ring homomorphic encryption, our lossless privacy-preserving recommendation scheme provides exac tly the same results as the standard non-privacy-preserving recommendation. This is in notable contrast to statistics-based approaches to privacy-preserving recommendation: such approaches yield only approximate results. We evaluate the system accuracy using the most common criterion: mean absolute error (MAE). This quantity is used to  X  3/ X  X  . This will yield stronger security. Experiments indicate that our decryption process requires more computation time, due to our squaring of the private key. However, as our system is ba sed on polynomial rings, the main speed improvements can be made by optimizing polynomial ring operations. The most time-consuming operation is ring inversion. As shown in the experiments, the key part of arithmetic is the ring multiplication operation. Our implementation uses a naive multiplication algorithm. The encryption and decryption performance of our implementation could be improved by implementing a better multiplication algorithm and optimizing it. In a newer version of our system, we pre-calculate the square operation and use a table lookup to retrieve the private key to reduce decryption key generation time. We ran a series of tests and extrapolated the data in a conservative manner. A system that works well in practice must get a lot of details right, including security and scalability, respect to the operations on plaintext data. Since the criteria and parameters are more complicated than those for the standard NTRU systems [17], the performance of our system differs from theirs. To make our message space the same as that of the standard NTRU, our system would have to use a larger  X  and , X  which would require more computation time. However, since the operation is done on  X  X  X  X  X  X  polynomials over indecipherable encrypted data. Our simulation using the data in Section 4.2 shows each recommendation takes, in average, 1.7 min for 200 users, which is fast enough for some applications e.g. the healthcare informatics scenario mentioned in Section 3.1. To the best of our knowledge, we are the first team to propose an end-to-end encrypted domain recommender system which fully protects privacy without the drawback of adding noise or partially revealing information. Our key management protocol and the ring homomorphism mechanism are the key to make a real recommendation work. Our solution makes it possible for servers to collect private data from users without compromising privacy. Our experiments have shown that our solution is accurate, effective, and highly secure. We see a potential advantage in using such an approach for various privacy-preserving mining tasks in people X  X  daily activities. In contrast to the randomized pe rturbation scheme which adds randomized perturbation to real data, thus yielding only approximate results, our system provides exact measurements. Instead of storing user profiles in a distributed manner, our approach meets the criteria of a centralized scheme, which would work well for cloud computing. Moreover, we provide an effective cryptosystem with ring homomorphism which we have proven not only secure but also practical and implementable as compared to ideal lattice-based approaches, which only allow one bit operation. In the future, we will study how these kinds of operations can be extended to techniques such as singular value decomposition in the encryption domain for other privacy-preserving data mining tasks. [1] Polat, H. and Du, W. 2006. Privacy-Preserving Collaborative [2] Polat, H. and Du, W. 2006. Achieving private [3] Canny, J. 2002. Collaborative filtering with privacy. In [4] Canny, J. 2002. Collaborative filtering with privacy via [5] Rivest, R. L., Shamir, A., a nd Adleman, L. 1978. A method [6] Gentry, C. 2009. Fully Homomorphic Encryption Using [7] van Dijk, M., Gentry, C., Halevi , S., and Vaikuntanathan, V. [8] Miller, B. N., Konstan, J. A., and Riedl, J. 2004. Pocketlens: [9] Berkovsky, S., Eytani, Y., Kuf lik, T., and Ricci, F. 2007. [10] Lathia, N., Hailes, S., and Capra, L. 2007. Private distributed [11] Miller, B. N., Konstan, J. A., and Riedl, J. 2004. Pocketlens: [12] Luo, B. and Hancock, E. R. 2001. Structural graph matching [13] NIST, 2006. Recommendation for Pair-Wise Key [14] Regev, O. 2006. Lattice-based cryptography. In Advances in [15] Yu, K., Yu, S., and Tresp, V. 200 5. Soft Clustering on [16] Sarwar, B., Karypis, G., Kons tan, J., and Riedl, J. 2001. [17] Hoffstein, J., Pipher, J., and Silverman, J. H. 1998. NTRU, A 
