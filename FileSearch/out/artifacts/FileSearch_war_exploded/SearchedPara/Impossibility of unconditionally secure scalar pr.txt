 1. Introduction
For almost three decades the cryptographic community has known that any distributed algorithm we may think of can, at solution which rely on cryptographic primitives. In this paper we focus on cryptographic approaches approach.
A quick survey of the research in data mining will soon reveal that some problems occur again and again; as for example computation such as privacy preserving data mining, scientific computing, and web personalisation. Indeed, Kargupta and
There are many concrete examples of the use of scalar products in data mining and machine learning. Support vector ma-tributed data. Clifton and Vaidya show how to securely perform the apriori algorithm used in association rule mining by programming. A central element of his approach is the secure scalar product protocol from [14].
The standard ways to compute scalar products are to use homomorphic encryption, secret sharing, or solutions based on oblivious transfer [14]. However, some researchers have expressed concern that these techniques give too much communi-cure scalar products [2,28,17,24,20] .
 secure scalar products.
 product of binary vectors can be used compute Boolean and gates. However, unconditionally secure computation of and ally secure scalar products by showing a reduction from commitment schemes to scalar products. More than that, we show that secure scalar products exist in alternative models where commitment schemes have been demonstrated. the communication overhead of the scalar product protocol from [14] in the case of computing scalar products over small fields.
 very small, and the resulting protocol is efficient enough to be of interest in practical protocols.
Our contributions are: (1) the impossibility of scalar products, secure against semi-honest adversaries without extra assumptions, (2) a lower bound on the information leaked in any scalar product protocol when the adversary is computa-tionally unbounded, and (3) two efficient scalar product protocols which are secure in two different models.
This paper is organised as follows: In Section 2, we give a brief discussion of the model we work in. In Section 2.3,we posed scalar product protocols. We give some concluding remarks in Section 6. 2. Preliminaries
When implementing cryptologic protocols it is important to be precise about the model which guarantees security of the extra assumptions are made, but that efficient and secure implementations exists in other models. 2.1. Security models tocol which is secure against active adversaries is also secure against semi-honest adversaries.
In the following we give an informal overview of the cryptographic definition of secure protocols. For more details see The natural way to model a distributed algorithm for computing a function, f , is with two randomised Turing machines, P ing machine P A f writes m to the communication tape, and that the Turing machine P ism semi-honest simply means that Alice and Bob really do run the Turing machines P munication and other things observed by Alice allow her to learn something about the input of Bob, which she should not have learned (and vice versa for Bob)? Formally, the things observed by Alice are described by random variable view contains the input ( A ), output  X  f  X  A ; B  X  X  , random choices (the Turing machine P ing the execution of the protocol, and prior knowledge (and view antee that Alice cannot compute anything from her view that she cannot compute from her own input, A , and the output f  X  A ; B  X  . Notice that this is the same as saying that view protocol (and thus without view A ). Clearly, if we can device an algorithm which can simulate view simulator S such that for all distinguisher functions D bility distributions of the simulated and the real view are close to within . In this case we write If  X  0 the simulation has exactly the same probability distribution as the real view. In this case we write tocol is computationally secure. In this case we write A protocol for computing f is secure, if a simulator S exists for both Alice and Bob. distinguisher (that it is computationally bounded), or on the model itself (i.e. the presence of a third party). 2.2. Commitment schemes and oblivious transfer
A class of protocols of particular interest in this paper are commitment schemes. In a commitment scheme Alice  X  X  X om-the semi-honest model is not meaningful for commitment schemes. The whole point of a commitment is to make sure that honest during the commitment phase, but that she tries to change her mind in the opening phase.
We will not study oblivious transfer in detail in this paper, but the strong relationship between commitment schemes, transfer  X  OT 1 2  X  Alice (the sender) has two input messages m which message Bob received). It can be shown that both commitment schemes and oblivious transfer can be implemented fer exists. Even though oblivious transfer cannot be unconditionally secure, secure implementations have been demon-strated under several assumptions. It is known that oblivious transfer based on different kinds of noisy channels exist model [23,12,3] .
 commitment schemes is valid for any set. Throughout the paper we use the notation x 2 dom from the set S according to the uniform distribution. 2.3. Commitment schemes  X  formal definition
A commitment scheme consists of two protocols: (1) a commitment protocol, and (2) an opening protocol. In the com-
Hiding. At the end of the commitment protocol Bob knows nothing about s (that he did not know in advance)  X  formally, there exists a simulator, S , such that S  X ? X  view B , where ? means no input (either perfect, statistically, or computationally).
 that V  X  commit  X  s  X  ; open  X  s 0  X  X  X  1, if and only if s  X  s 0 .
 the information leaked to an computationally unbounded adversary: the commitment protocol: Bob knows that Alice committed to some s 2 S, and Alice can open to any s 0 2 S.
 commitment protocol (all messages sent forth and back), and let view tocol, but before the open protocol (the random choices made by Bob, his private knowledge, and the conversation c ). Let V B  X  s 0  X  be the set of all views Bob can have after a commitment to s 0 . Define S strings which have a commitment that would give Bob view B If a string s 0 2 S B , then there would be a commitment to s 0 where Bob would have view current commitment is to s or s 0 .
 If Alice can open to a string s 0  X  s , then s 0 2 S B .
 Now let C  X  s 0  X  be the set of all possible conversations when committing to s 0 , and let S strings which have a commitment with conversation c . Observe that had committed to s 0 and can thus open to s 0 .
 If Alice can open to s 0  X  s , then c must be a possible conversation when committing to s 0 (since c is part of view We finally show that S  X  S A  X  S B . First assume that s 0 2 S Now, let s 0 2 S B , then there is commitment to s 0 which would give Bob view is a valid conversation for both s and s 0 ,so s 0 2 S A , implying that S
It follows from the theorem that any unconditionally hiding commitment scheme must be such that S  X  F (all strings are consistent with what Bob has seen during the commitment protocol). An unconditional binding commitment scheme, how-must rely on an extra assumption. 3. No unconditionally secure scalar product the scalar product without revealing  X  X  X oo much X  about their input vectors. 2 call this approach determined SSSP. Fig. 1 shows the determined SSSP protocol.
 It is easily seen that determined SSSP and SSSP are equivalent. We can turn an implementation of SSSP into a determined
SSSP by letting Alice set her own secret share to a value a of her choice. She then computes b share she got from the SSSP, and sends b 0 to Bob. Bob sets his own secret share to be b  X  b products in Section 5.
 but also a bound in the amount of information leaked by the more general scalar product protocols. 3.1. Commitment schemes from scalar products
We now show that a commitment scheme can be implemented by one call to determined SSSP. We reduce a commitment to be the same as the field of the commitment scheme.

Let A 2 G be the random variable describing the input of Alice to the commitment scheme, and let F d be a vector space such that j F d j is at least as large as the support of A . Furthermore, let f : F w 2 sets his chosen secret share to a . The output, b , of the scalar product is the commitment. opens a  X  f  X  v  X  . An outline of this protocol can be seen in Fig. 2 .
 perfectly hiding and binding when the parties are semi-honest in the commitment protocol. which is random, so the commitment is hiding.
 a 0 a  X  X  v 0 v  X  w . Since f  X  v  X  X  a  X  a 0  X  f  X  v 0  X  the two vectors are different, so v 0 v the sender can only open to one message. So the protocol is binding. h commitment scheme with the same security. The fact that no unconditionally secure commitment scheme exists implies that the commitment scheme can be directly translated into information leakage in the scalar product.
Theorem 2. In any scalar product protocol, after each invocation, there exists a natural number 0 &lt; n such that Alice learns at least n 1 scalar products with w and Pr  X  E  X  view
Proof. Let a scalar product protocol be given, and let V 2 F implement a commitment scheme where Alice commits to a value from the same vector space, F of the vectors in F d . Alice X  X  input to the commitment scheme is described by random variable A , where bution to the scalar product.
 From Theorem 1 we know that there exists a set S # F , known to both Alice and Bob, such that Bob knows that a 2 S and
Alice can open to any a 0 2 S . Let f X  a i ; v i  X g be the set of all opening messages, where v
As in the proof of Lemma 1 above, we see that Alice learns  X  v learns at least j S j 1 distinct scalar products.
 independently of a , from S . Setting n  X j S j yields the desired result. h secure without extra assumptions.

Corollary 1. No unconditionally secure scalar product exists. 4. Application to previous scalar product protocol vector of Bob is 1 = p d 2 , where input vectors are from the field F
In the protocol by Malek and Miri vectors from F d q are mapped into elements from F isomorphic). A basis of F q d over F q is a set of elements f a unique sum u  X  u 1 a 1  X  X  u d a d , for u 1 ; ... ; u d 2 F
Let F q be a finite field and let F q d be an extension field of F
The trace function gives rise to the definition of dual bases , where bases f a (where d i ; j is Kronecker X  X  delta). It follows (see [20] for details) that for two vectors v ; w 2 F d f a 1 ; ... ; a d g and f b 1 ; ... ; b d g , the scalar product of v and w is: the notation in [20]). more scalar product than guaranteed by the theorem. This shows that our information leakage bound is (almost) tight.
Proof. First, note that so V is a linear combination of the two elements X and Y . Since h is an isomorphism v is also a linear combination of h
Next, note that for all a ; b 2 F q .
 We consider two cases: (1) X  X  Y , where both are non-zero, and (2) X  X  Y , or either X or Y is 0. compute q 2 distinct scalar products with w .
 Similarly (9) only allows Alice to compute q scalar products. h
Bob can guess the input vector of Alice is small, while Alice a large number of scalar products. 5. Efficient and secure scalar products under various assumptions 5.1. Encryption based
A computationally secure implementation of the scalar product was given by Goethals et al. [14]. Their protocol can be be such an encryption scheme and assume that both Alice and Bob know the public key of Bob, but only Bob knows the cor-responding secret key. If Alice and Bob have vectors v  X  X  v proceeds as shown in Fig. 4 .

A good candidate for the homomorphic encryption is the Paillier encryption scheme [22], which takes plaintexts from Z and gives ciphertexts in Z n 2 where n is an RSA prime. Goethals et al. use the Paillier scheme in their paper.
One of the primary arguments against using schemes based on homomorphic encryptions is the blowup in the message unacceptable when working with massive data sets. To overcome the large communication overhead, we need an alternative homomorphic encryption which has less overhead when computing scalar products over small fields. To this end we propose 640-bit ciphertext for the same level of security as 1024-bit RSA.
 curve point Q  X  sP is the public key of Alice while s is her private key. Therefore, the encryption of  X  w forms elliptic curve point multiplication and obtains  X  v of her secret share a 2 R F :  X  rP ; rQ  X  a G  X  , and performs elliptic curve additions to obtain r  X  a  X  P v i w i  X  X  G  X  . Decryption of this ciphertext by Bob will result in sages are chosen over a small field, the brute-force does not pose a problem as shown in the timing results below.
We used the MIRACL library [19] to implement the secure scalar product protocol on an Intel Dual-Core Centrino PC with use the ElGamal encryption scheme.

We implemented the Paillier scheme using the same experimental setting and found that Alice and Bob spends about 500 the maximum of 160 bits).
 When the ElGamal scheme is used for scalar products of binary vectors, the overhead is a factor of 640. When using the overhead of the suggested efficient protocol of Atallah and Du [2] which has a communication overhead of approximately suggested by Goethals et al., the communication overhead can be further reduced. 5.2. Trusted third party to be of practical use. However, our protocol relies on three ideas which makes it efficient: bits as described below. 2. Use the Karatsuba multiplication algorithm [18] to reduce the number of and-gates. shared between the two players. This means that after evaluating a gate g Alice and Bob get values g field element g 1 and sends it to Bob. Alice keeps g 0  X  a g are teated in the same fashion.
 known constant. To multiply two secret field elements, we use the Karatsuba multiplication algorithm explained below to gates.
 protocol. Suppose that Bob has an input bit b 2f 0 ; 1 g , which we have to multiply with secret value a  X  a
Alice knows a 0 and Bob knows a 1 . Since ab  X  a 0 b  X  a 1 new values z 0  X  z 0  X  a 0 b , such that Alice only knows z
Alice is the sender and Bob is the receiver. Alice first chooses a random field element z m z  X  z 1  X  z 0  X  z 0  X  ba 1  X  ab .
 tions to multiply two elements from F 2 n . To multiply x ; y 2 F that n is a power of 2), we can then split x and y into smaller parts, x and recursively compute the three multiplications A  X  x h tiplication as described above.
 the oblivious transfer by Rivest, the trusted initializer generates two random strings x ious transfer. To realize a real oblivious transfer of messages m where c is the index of the message he wants to learn. The sender replies with the message  X  m 0 for i  X  0 ; 1. The receiver can now recover m c  X  m 0 c x
Putting together the peaces above, we can compute the scalar product of two vectors v  X  X  v known to Alice and Bob, respectively. The scalar product of the two vectors is done by the arithmetic expression tree is connected to the final output gate of the circuit. 5.2.1. Security relies on the security of the oblivious transfer protocol used (Rivest oblivious transfer in our case). 5.2.2. Efficiency
To multiply two elements from the field F 2 n , Karatsuba needs approximately n log the 2 d field elements, and then perform d multiplications, so we expect to send approximately 2 dn  X  7 n log products between vectors in F d 2 32 .
 one round of communication.

The computational cost of the algorithm is minimal, since no cryptographic operations are involved  X  only simple field arithmetic. 5.3. Comparison of scalar product protocols
We evaluate the performance of the two proposed scalar product protocols in a real-world scenario, and compare them to the scalar product based on Paillier encryption [14], and a trivial (insecure) scalar product.
The apriori algorithm is commonly used in association rule mining. Clifton and Vaidya showed [28] how to securely cases, the benefit earned is small compared to the overall timings in distributed environment shown below.
Our experimental setting consists of four virtual machines running on a quad-core computer. One of the virtual machines work, and use the FreeBSD software router as internet gateway, thus giving full control over bandwidth and latency. A tutorial for setting up the software router can be found at [10]. The host computer is an Intel Core 2 Quad Q6600 with 2.4 GHz CPU and 4 GB of ram memory running Debian. Each virtual machine is given only 256 MB of memory to prevent swapping on the host computer.

Fig. 5 a shows the time it takes to perform the apriori algorithm on the voting records dataset for different bandwidth when the node to node latency is fixed at 50 ms. Fig. 5 b shows the effect on latency on the timing when then bandwidth if fixed to 100 kbps. All timings are computed as average of five experiments.

Fig. 5 a clearly shows that the improvement proposed in Section 5.1 (marked ElGamal in the figure) gives a considerable a trusted third party, proposed in Section 5.2, has the best performance among the secure protocols for bandwidth.
Fig. 5 b shows similar results. However, the performance of the third party based protocol drops considerably for high third party in one message at the beginning of the protocol would reduce the number of communication rounds to two per tocol would perform best in all scenarios. 6. Conclusion
We show that no unconditionally secure protocol for scalar product exists for two semi-honest parties without extra In particular, we show that in any attempt to implement a scalar product protocol without any extra assumptions, either
On the other hand, we demonstrated two efficient scalar product protocols which are secure in alternative models. The rity relies on a  X  X  X rusted initializer X .

References
