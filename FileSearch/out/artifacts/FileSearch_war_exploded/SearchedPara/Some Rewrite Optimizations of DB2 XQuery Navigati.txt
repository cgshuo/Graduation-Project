 IBM X  DB2 X  9 is a truly hybrid commercial database system that combines XML and relational data. It provides native support for XML storage and indexing, and query evaluation support for XQuery. By building a hybrid system, the designers of DB2 9 were able to use the existing SQL query evaluation and optimization techniques to devel op similar methods for XQuery. However, SQL and XQuery are sufficiently different that new optimization techniques can and ar e being developed in the new XQuery domain. This paper descri bes a few such techniques, all based on static rewrites of XQuery expressions. H.2.4 [Database Mana gement]: Systems General Terms: Algorithms, Experimentation, Performance Keywords: DB2, Optimization, XML, XQuery IBM DB2 9 is the first truly hybrid commercial database system that combines XML and relational data. By building a hybrid system, the designers of DB2 9 we re able to use the existing SQL query evaluation and optimization techniques to develop similar methods for XQuery. However, SQL and XQuery are sufficiently different that new optimizati on techniques can and should be developed for the new XQuery domain. Similarly to SQL optimization, XQuery optimization can be done in two stages: as logical query optimization (sometimes also called query rewrite) and physical query optimization (also called plan optimization). Physical query optimization techniques depend on the storage method of the data being queried. Unfortunately, there is no uniformly accepted framework for storing and accessing XML documents yet. This makes any physical optimization technique specific to the particular method used for storing and accessing XML documents. Unlike physical query optimization, logical query optimization or query rewrite is largely independent of the underlying storage system. The purpose of techniques in this category is to make the query more compact or logically simpler or to make the logical data flow implied by the query more efficient. Logical XQuery optimization methods are thus more general in the sense that they can be implemented in a variety of XML storage systems. In most of cases, navigation of XML document accounts for most of the cost of evaluating an XQuery statement, specifically the XPath expressions in the XQuery statement. For a single XQuery statement, a straightforward implementation of an XQuery engine usually results in, multiple navigations of the same XML documents or an unnecessary full navigation of an XML document (every node is visited) The optimizations described in this paper result in rewrites of XQuery statements to avoid duplicate and full navigations. In this paper we describe two rewrite optimization techniques of XQuery. We begin with a review of related work on query optimization in XML in Section 2. In section 3, we describe the optimization techniques and their implementation in DB2 9. The results of experimental evaluati on of the implementation follow in Section 4, and we provide conclusions in Section 5. One of the strategies for storing and accessing XML data is to use a relational DBMS. In such a system, an XML document is either shredded into relational table tuples [28][10], or saved as a Character Long Object (CLOB) [19] or Binary Long Object (BLOB) [22]. An XML Query is then translated into a SQL query and evaluated by the SQL query engine. However, as argued in [25], there are many problems with this solution, such as the following ones:  X  Some XQuery constructs cannot be expressed in SQL.  X  Order preserving of nodes in XML documents is difficult to  X  A simple XQuery might be translated into a SQL query that  X  Expensive reparsing of the XML document during query [23] describes an XML storage system implemented in Microsoft X  X  X  SQL Server. It is essentially a relational-based XML storage system. In the system, XML documents or fragments are transformed into a binary representation. The binary representation is then stored in a relational database column as a BLOB. The structure properties of the XML document are captured using an index structure called ORDPATH [22]. Also the existing SQL processing framework is extended to accommodate XQuery processing. An XQuery statement is first compiled into an internal structure called an XML algebra tree. The XML algebra tree is then transformed into a relational operator tree. Then the relational operator tree is passed to a relational query processor for evaluation. The physical query optimization for XQuery is the same as for SQL, and the logical query optimization is applied to the XML algebra tree in a rule-based fashion. Another approach to storing XML da ta is to store it in its native form as XML documents in a pa rsed, structured, type-annotated format [4][11][14]. [16] proposes a technique that is capable of evaluating multiple XPath expressions over an XML stream. Multiple XPath expressions are represented by a single pattern tree with multiple extraction points. Each extraction point in this pattern tree represents the output of one of the XPath expressions. Because an XML stream can be treated as a pre-order traversal of an XML document tree, this tec hnique can be applied to any XML storage system that supports efficient document traversal, such as a native XML storage system or the CLOB or BLOB format of XML document. [2] provides a description of a na tive XML database system called ToX. ToXop, the query optimizer of ToX, uses a path index structure called ToXin. ToXin is conceptually a path summary that contains structure informati on of all documents stored in a database. ToXin is similar to the DB2 path index catalog table SYSXMLPATHS [4]. However, unlike the DB2 catalog table, which contains only the unique path s in all documents, ToXin, as an index facility for XML document, contains some other structures as well. For example, it includes a value table that records the content of each node (the text content of elements and values of attribute nodes) and a navigational table to support top-down navigation of XML documents . The query optimizer ToXop is an algebra, (Tree Algebra for XML, or TAX [15]) processing engine. There are two main query optimization techniques proposed in ToXop: holistic path summary pruning and access-order selection. Both of them use path summary ToXin to facilitate access methods. Holistic path summary pruning eliminate unnecessary sub-tree navigation during XPath expression evaluation. Access-or der selection uses the path summary to decide how to eval uate an XPath expression: top-down from root to required nodes or bottom-up from the last step of the XPath expression up to the root. [30] addresses the problem of structure join order selection in the TIMBER Native XML database sy stem [14]. The problem is similar to join order selection a in relational database system. Five algorithms for structural join order selection are proposed in this paper, including the famous Dynamic Programming (DP) algorithm used in relational data base systems. The experiments documented in this paper show that many relational rules of thumb are not appropriate in a native XML database system. For example, the dynamic programming method is not as efficient as in a relational system. The generalized tree pattern (GTP ) for concise representation of an XQuery expression is introduced in [8]. The nodes in a GTP are element or attribute names in XML documents. There are two types of edges in a GTP: the first represents the parent-child relationship of nodes in GTP and the second represents the ancestor-descendant relationship of nodes. The evaluation of an XQuery query can be reduced to finding matches in XML documents for its GTP. Schema information of an XML document, if available, can be used to optimize an XQuery query by simplifying its GTP. Translating an XQuery query to a GTP and generating query plan by using a GTP have been implemented in the TIMBER native XML database system [14]. A number of papers have addresse d logical query optimization of XQuery queries. [20] describe s several techniques based on XQuery formal semantics [33]. It shows how optimizations developed for functional progr amming languages and database languages can be applied to XQuery. It also presents some open problems faced by the formal semantics approach, for example, duplication elimination during step-by-step evaluation of an XPath expression. [18] describes a general logical optimization framework that uses diverse types of constraints encode d in a schema associated with a collection of XML documents. The framework computes a so-called path equivalence classe s (PECs) from a given schema. Conceptually, a PEC contains all paths from a schema such that, for any given XML document that is an instance of the schema, evaluating these paths results in same set of nodes of the XML document. PECs can then be us ed during query compilation time to identify redundant predicates, simplify predicates, or remove contradictory predicates. [18] mentions a path expansion technique similar to our desce ndant step expansion, where a descendant step in a path in a PEC is expanded with a single path without a descendant step in the same PEC. Their path expansion technique covers the wildcard (*) path step as well. Our descendant step expansion tec hnique goes further by expanding the descendant step with a set of paths whose union is equivalent to the descendant step. Galax [9], an implementation of XQuery, has an architecture for processing XQuery based on the XQuery Formal Semantics [33]. The semantics define a proper subset of the XQuery language, called the XQuery Core language, and give rules to rewrite or normalize every XQuery expression as an XQuery Core expression. (Compared to the XQuery expression, the resulting Core expression typically has si mpler explicit semantics but ones that are more verbose) Using these rules, Galax parses and normalizes an XQuery expression into an XQuery Core internal structure. The query optimization is applied mostly to Core expressions. Two set of technique s are mentioned in [9]: type-based optimization and logical optimizations. Type-based techniques use schema type cons traints to simplify XQuery Core typeswitch and existential quan tification expressions. Logical optimization techniques apply gene ral rewrite techniques such as predicate push-down or pull-up, join reordering, and eliminating redundant sort operations to Core expressions. Finally, [28] proposes three schema-based optimization techniques that focus on XML stream processing. They are mentioned here because we believe that these techniques can also be applied to persistent XML data. Parsing an XML CLOB or BLOB, or navigating an XML document tree in a native XML database is quite similar to pr ocessing an XML stream. Each of the described techniques uses a different type of constraint defined in a schema. The first technique, called the occurrence rule, relies on the constraint that a child element can have a minimum or maximum occurrence under a parent element. The second technique, called the exclus ive rule, uses the constraint that some child elements cannot co-exist under certain parent elements. The last technique, called the order rule, uses the constraint that some child elements must appear in a pre-defined order under certain parent elements . All three rules can be applied to querying persistent XML data either by pruning tree navigation and XML CLOB or BLOB parsing, or by simplifying XQuery expressions. As mentioned previously, DB2 9 is a hybrid relational and XML system. 1 It introduces a storage system called the XML Store for storing and querying XML documents. The XML Store is separate from and coexists with th e relational data storage system in a DB2 database. The XML Store stores XML data in its native format. The basic storage unit in the XML Store is a node of a particular type as defined in the XQuery Data Model (XDM) [31]. Common node types include element, attribute, document, text, namespace, processing instruction and comment . Each node contains pointers to its parent node and child node, if applicable. A disk page holds one or more node s. A node can be stored in one disk page or in more than one disk pages if the size of the node is larger than the disk page, for example, a long text node in an XML document. In every disk page, all nodes that are from the same XML document are logically linked through the parent and child pointers to form a fragment of the document tree. Such a fragment is called a region. All fragments of an XML document tree are organized logically into a complete XML document tree through an index structure called a region index. Like a RID in relational data storage, each node is assigned a unique identifier (NID) that gives the node both a logical and physical addressability that can be used for indexing and query evaluation. The NID can identify a node within a document by using a Dewey node identifier [29] and can provide quick access to a node in the XML store. Thus , given a reference (NID) to a node, the node can be located on disk, and its ancestors and descendants can be reached by using the parent and child pointers document node, then the whole XML document stored in the XML Store is accessible by using the NID of the document node. This provides efficient navigati on of the XML document, and is also beneficial for evaluating XQuery statements. In this section, we describe onl y the features of IBM DB2 9 that are relevant for understanding the optimization techniques described in Section 4. For a co mprehensive survey of System RX (the research prototype of IBM DB2 9), refer to [4]. The XQuery language uses node reference semantics in its expression results. The result of any XQuery expression must be a sequence containing either constant values or references (NIDs) to nodes in a document. In XQuery, it is common to further navigate a document fragment as a result of an XQuery expression. SYSXMLPATHS is an important catalog table that was introduced for XML data indexing. In this catalog table, path information similar to a path summary [2][20], is saved for all XML documents in XML Store. This table maps each unique path in the XML documents to an integer. Steps in these paths are saved in this table in reversed or der. Conceptually similar to the path summary tree [2][20] of XML documents, the group of these paths gives a structural descri ption of all documents in XML store. Consider the following XML instance tree. Given the document tree instance, the rows shown in Table 1 are inserted into the SYSXMLPATHS table. Paths are stored in reversed steps for indexing purposes [4]. DB2 9 introduced a number of changes to the Query Graph Model (QGM), the internal data struct ure for representing queries. QGM represents XQuery XPath expressions as follows. XPath expression is represented during query compilation as a parse tree (PID tree). Each node in a PID tree is a PID QGM entity. A new type of PID called XPath Step (XPS) has been introduced [1]. Each XPS node has four positional child PID nodes. The first child PID node represents the step axis: that is, child, parent, descendant, self, and so on. The second child PID node represents wildcard test (*). The third child PID node represents the predicates of the step. The fourth child is another XPS representing the next step or is NU LL if the step is the final step 
PATHID PATHTYPE PATH 10 element site/ 11 element item/site/ 12 element regions/site/ 13 element asia/regions/site/ 14 element item/asia/regions/site/ 15 element europe/regions/site/ of the represented XPath expre ssion. If the XPath expression has a context represented by an XQuery variable (this is where a PID tree could reference an XQuery variable), the first child PID node is a null PID node and the second child PID node is a variable reference PID node. Consider the following query from XMARK, an XML benchmark project [26], which we describe brie fly in section 5. This is query Q06: How many items are listed on all continents? let $auction := db2-fn:XMLCOLUMN("AUCTION.XMLCOL") return In its QGM representation, the sequence of document nodes generated by the db2-fn.XMLCOLUMN() function is bound to an XQuery variable named $auction. The variable $auction is then referenced by the PID tree representing the XPath expression $auction//site/regions. The PID tr ee for this XPath expression is shown in Figure 2. The first XPS node (a PID node of type XPS) takes in the context variable as a variable refe rence PID. The second XPS node represents the descendant-or-sel f step //site. The last XPS node represents the last child step /regions. In this section, we introduce two rewrite-based optimization techniques. These techniques use ideas from the fields of programming-language compilers , SQL optimization, and schema-based optimization. Both techniques have been implemented as prototypes in DB 2 9. The experiment results are presented in Section 5. The example queries that we use here are from the XMARK benchmark project. In all queries from XMARK we replaced the XQuery standard function fn:doc() with an equivalent function in db2-fn:xmlcolumn() . Figure 3 provides a partial tree representation of the schema of XMARK. Only elements and attributes that are used in the ex amples in this s ection are shown. The idea of rewrite-based optimization has been introduced in relational databases and led to dramatic query performance improvements. We present a simple example of such a rewrite in the context of XQuery. Consider the following XQuery statement (a modified version of query Q01 from XMARK: Return the name of a person with ID  X  X erson0 X ): let $auction := db2-fn:xmlcolumn return The result of the query comes from the XPath expression $b/name/text(). T he intermediate value of XPath expression $auction/site/ regions//item is not used anywhere in the query. In other word, the final result is not influenced by some of the expressions in the query. Evaluating these expressions does not ma ke any contribution when computing the final result. T hus, these expressions can be removed before query evaluation to save computational cost. As we show in the experiment results in Section 5, even such trivial rewrites can lead to substantial cost savings. Optimization of common sub-expre ssions is well established in SQL query processing. If a query contains multiple sub-query blocks that yield the same resu lt, only one of them must be evaluated; the consumers of the other sub-query blocks can reuse the result of the one that was evaluated. The same idea can be adapted in XQuery processing. In XQuery, most of the I/O cost comes from evaluating XPath expr essions. It is not uncommon that one XPath expression occurs multiple times in an XQuery statement. Consider query Q12 from XMARK (For each richer-than-average person, list the num ber of items currently on sale whose price does not exceed 0.02% of the person X  X  income): let $auction := db2-fn:XMLCOLUMN("AUCTION.XMLCOL") return The XPath expression $p/profile/@in come occurs three times in Q12. If a query engine is not capable of discovering that they are identical, the expression is evaluated three times. However, the expression can be evaluated once, and all of its consumers can share the result. We can rewrite th is query as follows to improve its performance: let $auction := db2-fn:XMLCOLUMN ("AUCTION.XMLCOL") return $p/profile/@income is evaluated once, and its result is bound to a temporary variable $tmp. All cons umer expressions of this XPath expression simply refer to $tmp to use that result. In our prototype implementation, we automated th is kind of rewrite during query compilation. The general problem of deciding whether two XPath expressions are semantically equivalent is hard because it is a form of query containment problem [27]. To reduce the complexity of our prototype implementation, we consid ered a simple version of this problem: only identical XPath expr essions are considered to be semantically equivalent. We create XPath common sub-expression only from XPath expressions that are identical in an XQuery query. Consider two instances of the same XPath expression: One as part of a LET clause and the other as part of a FOR clause. The intention is to keep one of th e XPath instances and reuse the output for the other instance. There are two types of consumers. One requires LET semantics on the result of the XPath expression, that is, all result nodes in one sequence. The other requires FOR semantics, that is, each result node represented as a sequence. We deal with this problem by introducing compensation processing. First we introduce a compensation operation that uses the results of the LET processing of the XPath expression that is kept. Then, using this LET compensation operation result as a common sub-expression, we create a new compensation consumer operati on that performs an un-nest operation to transfer the result of the common sub-expression into the FOR semantics usage. If ther e are multiple LET usages of the XPath expression, they take the CSE result as input prior to the un-nest compensation processing. Similarly all FOR consumers take the CSE result after the un-nest compensation operation. Similarly to the way that common sub-expressions are handled in SQL, if the result of an XPath common sub-expression is too big to fit in the available memory, the result is written to disk and read back from disk for its consumers. This requires extra disk I/O and might offset the improvement introduced by our procedure to some extent. Another potential issue occurs when the identical XPath expressions are too light weight. A lightweight XPath expression operates on the input sequence with little computational cost, either processor or I/O cost. The cost of rewriting them and the cost of compensation processing might outweigh the savings in query evaluation time. The decision of whether to perform the rewrite for a given set of identical XPath expressions and a given amount of available memory, requires estimating the size of the result and the cost of evaluating these XPath expressions. Disk I/O is the major cost in query evaluation on dataset of a significant size. This is true for both SQL and XQuery. In XQuery, a path expression is the only expression that can directly access data stored in an XML document. Other kinds of expressions operate on data gene rated from an XPath expression. In DB2 9, there are two methods for accessing the XML documents stored in the XML Store [4]. The first method is the index method. A set of XML document nodes in the XML Store that match a path pattern, can be indexed by using a B+ tree. The path pattern is a restricted XPath expression. When an XQuery query contains an XPath expression required nodes in the XML store [4]. Consider query Q05 from XMARK (How many sold items cost more than 40): let $auction := db2-fn:XMLCOLUMN("AUCTION.XMLCOL") return /site/closed_auctions/closed_auc tion/price on column XMLCOL of XML type in table AUCTION into which the AUCTION.XML document is inserted [21]. Thus, during evaluation of the by using the index. The set of nodes must be of a certain data type, as defined in XDM [4], to be indexed. For in stance, the above path pattern /site/closed_auctions/ closed_auction/ price can be indexed as type DOUBLE, or as any data type that can be derived from the type annotation of the nodes in the XML Store. Theoretically, an index can be defined on any node in an XML document. However, if an index is defined on a node that is not of an atomic type as defined in XDM (these kinds of nodes are element nodes that have child element node) the node is indexed as string data type using its string (serialized) representation as the index key. This kind of indexes might be as large as the document itself, and is not very helpful because it is rare to query an XML document using the string representation of its nodes. Hence, in DB2 9, efficient indexes can be defined only on nodes that have atomic data types. (These nodes are attribute nodes and leaf element nodes). The second access method is the navigation method. Similar to the table scan in SQL, XML navigation involves traversing an XML document tree in pre-order. Each node visited is tested against the criteria provided in the query. In DB2 9, the criteria provided in the query are represente d as a tree pattern to facilitate the navigation [4][16]. The navi gation operation might be very expensive if the tree pattern is too general; for example, in the case of a query requesting all item elements anywhere in the document. Such a query can be represented as an XPath expression $doc//item, where $doc is a variable representing the document node. To speed up the evaluation of the previous sample query, one can define an index for path pattern //item as an appropriate data type. This works only if all item elements are leaf elements and of the same data type. When there is no index available for the query, the evaluation engine must traverse the entire document tree examining every element node in the tree for item element. This might be very expensive if the required nodes are sparsely spread in the document tree. The problem is that most of the computation time is spend on visiting irrelevant nodes. However, if we have schema information about the que ried documents, we could scale down the traversal of the document trees to some specific paths in expressions with descendant or descendant-or-self step, where the dataset being queried has no ava ilable index defined for these queries. Consider the XMARK query Q6 (How many items are listed on all continents?): let $auction := db2-fn:XMLCOLUMN("AUCTION.XMLCOL") return $auction//site/regions and $b//item. Both of them contain descendant-or-self steps. For $auction//site/ regions, according to the schema information (path index) given at the beginning of this section, we know that element s ite is the root node of every document being queried. Thus, ther e is no need to navigate the whole document for the site element. We could simple replace the descendant-or-self step with a child step. This XPath expression can then be rewritten to $auction/site/regions without changing the semantics of the original one. Similarly, for XPath expression $b//item, the context variable $b represents all region elements. It asks for all item elements in sub-trees (fragments) rooted at ev ery region node in the context variable $b. Without the rewrite, DB2 has to visit every node in every sub-tree. Again, according to the given schema (path index), item element exists only as a child element of elements: africa, asia, austra lia, europe, namerica or samerica , which exist only as child element of regions. W ith this information, we could replace the descendant-or-self step with the union of a set of specific paths. XPath expression $b//item can then be rewritten as $b/(africa | asia | australia | europe | namerica | samerica)/item. Although this XPath expression is longer and more complex than the original one, the evaluation of it is faster, because only specific nodes are visited. In order to implement our idea, schema information (or more precisely, path information) must be available during query compilation. The information we need is similar to a path summary [2][20] for XML documen ts. A path summary describes every path of a document. From a path summary, we can derive a set of paths for any node in the XML document, such that the node element node regions, the path set is [/site/regions], for element /site/regions/europe/item, /s ite/regions/namerica/item, /site/regions/samerica/item ]. This in formation is readily available in the DB2 catalog table SYSXMLPATHS (described in Section 3) which stores exact path summaries for all XML documents stored in the DB2 XML Store. The implementation of this technique is straightforward. First we examine every XPath expression in the query QGM graph. Second, for each XPath expression that matches the form 2 want, we collect a set of paths from the catalog table that could be used to expand the descendant step. Last, we create a QGM sub-graph for the union of all paths in the set, and replace the descendant step or steps with this subgraph. A problem with this technique is that it might introduce a large union operation into the QGM graph. When the path set found in the catalog contains large number of paths, the resulting QGM graph might be too big to be pr ocessed by DB2 query compiler. To deal with this problem, a th reshold on the number of paths is introduced. When the actual number of paths in the set found in the catalog exceeds the threshold, the compiler does not perform the rewrite. The bigger the number of paths, the bigger the ratio of the number of required XML nodes to the total number of XML nodes in the document, which imp lies smaller I/O savings. In the extreme case, a rewritten query would have to visit all nodes in a document providing no performance im provement over that of the original query. Setting up a threshold on the numbe r of expanded paths is also necessary for another reason. The sequence of paths found in the catalog might not represent the order of these paths in the XML document. Thus, before the result of evaluating the union of these paths is processed any further, it must be sorted in the document order. We constrain this extra co st by limiting the number of paths that can be generated through the rewrite. Another potential issue is comm on for any schema based query optimization technique and is related to the volatility of schema of XML documents. In DB2, the co mpiled query is saved as a package in the system. Subsequent running of the same query needs no compilation if the package has not been invalidated. However, if the schema of the da ta has changed, the query must be recompiled. The experimental evaluation of our optimization techniques has been performed on the XMARK benchmark [26]. The XMARK benchmark has been designed specifically to evaluate the performance of query execution against XML data. We note that not all XPaths qualify for this type of rewrite. We leave out the details here. The sample data models a databa se application deployed as an Internet auction site. The schema information for the XML documents generated by the benc hmark is provided in DTD and in XML schema. The main entities are person, open_auction, closed_auction, item, and category. A part of the schema is shown in Figure 4. There are 20 queries in XMARK. They have been crafted to cover most of the features specific to XML and XQuery. The database AUCTION.XML, with the size of 102.6 MB. The number of paths stored in SYSXMLPATHS (a s described in Section 3) is 1046. Of the 20 XMARK queries, two queries qualify for a rewrite using the XPath Common Sub-Expr ession (CSE) method and four qualify for a rewrite using the E xpansion of XPath Descendent Steps (EDS) method. We also include in the result table (Table 2) the trivial rewrite of query Q01 (eliminating redundant variables, or ERV) described in the begi nning of Section 4.1. All other tested queries are shown below. Q03: Return the IDs of all open auctions whose current increase is at least twice as hi gh as the initial increase Q12 : For each richer-than-average person, list the number of items currently on sale whose price does not exceed 0.02% of the person's income. Q06: How many items are listed on all continents? Q07 : How many pieces of prose are in our database? Q14: Return the names of all items whose description contains the word  X  X old X . Q19: Give an alphabetically ordered list of all items along with their location. "empty greatest" removed, DB2 not support this syntax The experiments were done on AIX X  5.2 UNIX X  operating system running on the following platform: System Model: IBM, PowerPC_POWER4, # of Processo rs: 8, Memory Size: 16GB, Database System: IBM DB2 9, service level: build n060629. The queries were run in single-user mode. Each query was submitted separately with an excl usive database connection using the DB2 benchmark tool db2batch, so that the environment for each query was independent. The results of the experiments ar e shown in Table 2. The numbers represent the averages of five runs. 
Query number Original Q12 57118.71 48341.37 15.37% CSE The experiments show a consistent improvement in query elapsed times. The magnitude of the improvement depended on the relative cost of evaluating re dundant variables (ERV), common sub-expression (CSE), or retrie ving non-relevant parts of the document (EDS) in the original query. Consider, for example, queries Q06 and Q07, both modifi ed using EDS. The elapsed time improvement for Q06 (81.37%) is much bigger than that of query Q07 (19.72%). The reason is quite clear: the XPath expression $auction//site/regions in Q06 is expanded into a single path because the required node site occurs only once in the document. However, the nodes in all three XPath expressions in Q07 are densely distributed in the XML document; hence, their expansion does not save much in required tree traversal. Two new rewrite optimization tec hniques that were implemented in DB2 9 are described in this paper. Although conceptually simple (or, perhaps, because of that), the techniques proved to be powerful in improving query performance. The future focus might optimization approaches; an obvious example of such technology transfer is answering queries using materialized views. The second might be the use of XQuery-specific optimizations, through both automatic query rewrite and plan optimization. [1] A. Balmin, F. Ozcan, K. S. Beyer, R. J. Cochrane, H. [2] A. Barta, M. P. Consens, A. O. Mendelzon. Benefits of Path [3] K. Beyer, D. Chamberlin, L. S. Colby, F. Ozcan, H. [4] K. S. Beyer, R. Cochrane, V. Josifovski, J. Kleewein, G. [5] K. Beyer, F. Ozcan, S. Saiprasad, B. Van der Linden. DB2/ [6] D. Chamberlin, J. Robie, D. Florescu. Quilt: An XML Query [7] L. Chen, E. Rundenstein er. XQuery Containment in [8] Z. Chen, H.V. Jagadish, L. Lakshmanan. From Tree Patterns [9] B. Choi, M. Fernandez, J. Simeon. The XQuery Formal [10] D. DeHaan, D. Toman, M. Consens, M. T. Ozsu. A [11] T. Fiebig, S. Helmer, C.C. Kanne, G. Moerkotte, J. [12] P. Gassner, G. M. Lohman, B. Schiefer, Y. Wang. Query [13] L. Haas, J.C. FreyTag, G.M. Lohman, and H. Pirahesh. [14] H. V. Jagadish, S. Al-Khalif a, A. Chapman, Laks, V.S. [15] H.V. Jagadish, Laks V.S. La kshmanan, D. Srivastava, K. [16] V. Josifovski, M. Fontoura, A. Barta. Querying XML [17] R. Kaushik, R. Krishna murthy, J. Naughton, R. [18] A. Kwong, M. Gertz. Schema-b ased Optimization of XPath [19] Z. Liu, M. Krishnaprasad, V. Arora. Native XQuery [20] P. Michiels. XQuery Optimization. Proceedings of the [21] M. Nicola, B. van der Linden. Native XML Support in DB2 [22] P. O X  X eil, E. O X  X eil, S. Pal, I. Cseri, G. Schaller, N. [23] S. Pal, I. Cseri, O. Seeliger, M. Rys, G. Schaller, W. Yu, D. [24] H. Pirahesh, J. Hellerstein, W. Hasan. Extensible/Rule Based [25] M. Rys, D. Chamberlin, D. Florescu. XML and Relational [26] A. Schmidt, F. Waas, M. L. Kersten, M. J. Carey, I. [27] T. Schwentick. XPath Query Containment. ACM SIGMOD [28] H. Su, E. Rundensteiner, M. Mani. Semantic Query [29] I. Tatarinov, S. Viglas, K. S. Beyer, J. Shanmugasundaram, [30] Y. Wu, J. Patel, H. V. Jagadish. Structured Join Order [31] World Wide Web Consortium (W3C). XQuery 1.0 and [32] World Wide Web Consortium (W3C). XQuery 1.0: An XML [33] World Wide Web Consortium (W3C). XQuery 1.0 and [34] B. B. Yao, M. T. Ozsu, and J. Keenleyside. XBench -A countries, or both. 
