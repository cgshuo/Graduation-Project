 Several techniques on information filtering and information recommendation such as collaborative filtering and content-based filtering have been reported [5][1][11]. In conventional collaborative filtering, items are recommended on the basis of their relevance to the user X  X  preferences. Each item is recommended in-dependently of the others; that is, the relationship of a recommended item to the other items is not considered.

In the real world, however, a user is ofte n interested in a combination of items, such as the keywords in an advertisement and the places to be visited during a sightseeing tour. Recently proposed set recommendation techniques[12,10] con-sider the unit of recommendation to be a set of items and the constraints and requirements among them.

In this paper, we extend this approach to incorporate the use of an algorithm to present recommendations for modifying the user X  X  initially chosen set. In our incremental set recommendation framework, it is assumed that each record ( X  X tem set X ) in a database ha s been classified as a class such as positive/negative, and modifications are recommended that would change the item set so that it matched the target classification.

An example application of our framework is a recommendation system that uses a database in which the action history data for a group of people are stored. The data could be exercise history or dietary behavior, for example. Each person in the database is classified as either a success or failure w.r.t. to some target (e.g., weight loss). Those in the  X  X ailure X  group could use the system to obtain recommendations for specific behavior improvements that are based on the data for those in the  X  X uccess X  group. The recommendations are made on the basis of the differences between the two groups and should change the user X  X  actions and lifestyle as little as possible.  X  X ehavior i mprovements X  for the exercise history example means the addition and/or deletion of item sets representing the type and amount of exercises performed, while for the dietary behavior example, it means the addition and/or deletion of item sets representing the type and quantity of food eaten. Another example application is a system for describing the items for sale on an Internet shopping site. The descriptions of poorly selling items would be modified on the basis of the descriptions of items that sell well.
The rest of the paper is organized as fo llows: Section 2 gives the basic def-initions. In Section 3, we describe the implementation of our framework using a Zero-suppressed Binary Decision Diagram (ZDD) data structure. We present and discuss the results of its evaluation in Section 4. We conclude in Section 5 with a brief summary, some additional comments, and a mention of future work. We will provide some definitions and notations as follows : Definition 1 (Item). An item is an atomic entity that represents a character-istic or feature and is denoted by a lower-case character, a,b,c,... .Asetofall items to be considered is denoted by  X  .
 In the exercise history example, each item could be the name of an exercise. Definition 2 (Data Record and Class). A data record is a collection of items that represent the attributes or characteristics of the target object (we use D to represent a data record). A class is a name for a set of data records, and is denoted by  X  ,  X  ,  X  ,  X  or  X  . Each data record belongs to only one class.  X  X ositive X  or  X  X egative X  is an example of a class.
 Definition 3 (Pattern Set/Class Membership). A pattern set is a set of pairs, each of which consists of an item set and its weight (natural number). If the weight values are all the same, they can be omitted. A pattern set is denoted by C  X  where  X  is the class identifier ( C  X  = (simply we write q  X  C  X  ), q is called a pattern of class  X  .
 of class  X  ,whereas { a, b } , { a, b, c, d } and { b, d, e } are not. We sometimes use polynomial notation for pattern set such as C  X  =2 abc + abd +3 bcd . A difference of two pattern set, such as C  X   X  C  X  , is defined as a difference of polynomials. Definition 4 (Removable/Universal/Addable Items). For a data record D ,theitemsin D can be divided into removable items ( D  X  ) and universal items ( D  X  ). The recommendation algorithm can suggest the deletion of items only if they are elements of D  X  . A set of addable items, denoted by D + ,isthesetof items that can be added to D .
 Universal items intuitively correspond to essential features of the record. If no universal item is specified, D  X  =  X  .
 Definition 5 (Delete/Add-Constraints). The upper bounds on the numbers of items that can be added or deleted for a data record D are denoted by N D add , N delete , respectively.
 Definition 6 (Recommendation Candidate). For a data record D  X  C  X  ( D  X  C  X  ) , if there could be a candidate D by adding and/or deleting items under the conditions of N D add and N D delete ,andif the weight of D in C  X   X  C  X  is equal to or greater than the given natural number M (called weight condition), D is called a recommendation candidate for class  X  that satisfies N D add , N D delete and M .
 Example: Let N D add =1and N D delete =1for D = { a, b, f } and weight condition M = 2 in the above example, D = { a, b, c } is a recommendation candidate for class C  X  . In general, the number of instances of each class could be quite large. For ex-ample, the number of articles for sale or the number of customers on a major Internet shopping site could reach several million. As another example, lifelog services using mobile devices generates e normous amount of data in recent years. To handle such huge numbers of data records, we use a ZDD (Zero-Suppressed Binary Decision Diagram) data structure. In this section, we first present an example of our set recommendation fram ework based on class differences. We then briefly introduce ZDD and our recommendation algorithm which uses the ZDD structure. 3.1 Example Suppose we have pattern sets for classes  X  and  X  as follows:
Suppose further that  X  = { a, b, c, d, e } and D = { a, c } ( D  X  C  X  ). The rec-ommendation for D would consist of the following candidates ( D ) under the condition that N D add = N D delete = 1 and the weight condition M =1: X  X dd b  X ,  X  X elete a and add b  X ,  X  X elete a  X . After those modification, D would be identi-fied as class  X  , rather than as class  X  . If we restrict the recommendation so that M = 2, we get only  X  X elete a and add b  X .
 In this work, we use a VSOP (Valued-Sum Of Products) calculator based on ZDD for calculating the recommended items. We review ZDD and VSOP briefly in the next subsection. 3.2 ZDD and VSOP Binary decision diagrams[2,4] (BDDs) are well-known and widely used for ef-ficiently manipulating large-scale Boolean function data. A BDD is a directed graph representation of the Boolean function. The reduction rules in BDD con-sist of  X  X ode deletion rule X  (delete all redundant nodes with two edges that point to the same node) and  X  X ode sharing rule X  (share all equivalent sub-graphs).
ZDDs (Zero-suppressed BDDs) [6,4] are s pecial type of BDDs which are suit-able for implicitly handling large-scale combinatorial item set data. The reduc-tion rules of ZDDs are slightly different from those of BDDs. They are illustrated in Fig. 1 (a).  X  Share equivalent nodes as well as ordinary BDDs.  X  Delete all nodes whose 1-edge directly points to the 0-terminal node, and ZDDs are especially more effective then B DDs for representing  X  X parse X  com-binations such as purchase history data. For instance, sets of combinations se-lecting 10 out of 1000 items can be represented by ZDDs up to 100 times more compactlythanbyordinaryBDDs.

VSOP (Valued-Sum-Of-Products Calculator)[7] is a program developed for calculating a combinatorial item set where each product term has a value, speci-fied by symbolic expressions based on ZDD techniques. The value of each product can also be considered as a coefficient or a weight for each term. For example, the formula (5 abc +3 ab +2 bc + c ) represents a VSOP with four terms abc , ab , bc and c , each of which is valued as 5, 3, 2, and 1, respectively. VSOP supports numer-ical arithmetic operations based on Valued-Sum-Of-Products algebra, such as addition, subtraction, multiplication, division, and numerical comparison. The details of the algebra and arithmetic operations of a VSOP calculator are de-scribed in [6,7].

When dealing with integer values in binary coding, we have to consider the expression of negative numbers. VSOP adopted another binary coding[8] based (  X  2) 3 ) , 16(= (  X  2) 4 ) ,... . For example,  X  12 can be decomposed into (  X  2) 5 + (  X  2) 4 +(  X  2) 2 . In this encoding, each integer number as a coefficient can be uniquely represented.

Fig. 1 (b) shows the example of the VSOP representation for abc  X  ac +2 bc + c +2 de +3 e  X  abd .Since ac satisfies the top nodes labeled +1 and  X  2, the coefficient of item ac can be calculated by +1  X  2=  X  1.
 3.3 Set Recommendation with ZDD Structure In this subsection, we show the method for calculating a set of items to be recommended using ZDD. We first consider the following polynomials (valued sumofproducts)for(1)and(2)inSection3.1:
For a given D , we have to output a set of terms from C  X   X  C  X  , that are mod-ification of D under the constraints of N add and N delete , and whose coefficients are equal to or larger than given integer M .

Fig. 2 shows an example search process on the ZDD structure for C  X   X  C  X  , where N add = N delete =1and D = ac . In this figure, the search process starts with each top node +1 ,  X  2 , +4 respectively and then item sets satisfying the constraints are extracted for each top node +1 ,  X  2 , +4. The pair of numbers for item addition and deletion is attached to each edge, as shown in Fig. 2. If the pair does not satisfy condition N add or N delete , searching along that path is terminated. For example, since the pair on the edge from c (left side in Fig. 2) is (0 , 2), which does not satisfy the N delete condition, searching along the path below that node is terminated.

Item sets that need to be found under the condition of M = 2 must satisfy Fig. 2. For example, suppose D = ac, N add =1and N delete = 1. Since the numbers of added items and deleted items w.r.t bc are 1 and 1 respectively, and since bc satisfies (0 , 1 , 1) for the top nodes (+1 ,  X  2 , +4), bc is a recommendation candidate under the condition of M = 2. As another example, since the numbers of added items and deleted items w.r.t abc are 1 and 0 respectively, and since the candidates abc satisfies (1 , 0 , 0) for the top nodes (+1 ,  X  2 , +4), abc could be a recommendation candidate under the condition of M = 1 as well as bc described above. By the same way, c is also a recommendation candidate under the condition of M =1
The naive search algorithm on a ZDD structure is shown in Algorithm 1. We first evaluate the efficiency of our approach based on ZDD, using artificial data, and then we show the examples using actual Internet application data. 4.1 Performance Evaluation The problem we provided for performance evaluation in this experiment consists of 170 items in total ( |  X  | = 170), and each record contains 5 items. There are two classes: positive and negative.

There are two execution scenarios: on e used a random data set, and the other used a fixed pattern data set. In the random data set, items occurs randomly in each record; in the fixed pattern data set, fixed positive and negative patterns were prepared (20 patterns for each cla ss), and each pattern consisted of three items.

In the fixed pattern data set, three items in each record are taken from the fixed patterns, and two are taken from the random patterns. In actual applica-tions, such as an Internet purchase history, there would be some fixed patterns Algorithm 1. Naive Search Algorithm on ZDD structure in both classes. In this experiment, we used three data set sizes for each class: 1, 5, and 10 million records.
 The system was implemented in Java, and the experiments were run on SUSE Linux Enterprise Server 10 with a quad-core AMD Opteron 3 GHz CPU, and 512 GB RAM. The execution times are shown in Table 1. The times shown are an average for ten trials. In the tables,  X  X equential search X  in which all items in each record were ordered and stored in memory was done for comparison.
With the random data sets, there wer e no substantial differences between the ZDD-based search and the sequential search. This is because a ZDD data structure is not much more compact or effic ient rather than a flat data structure. The number of ZDD nodes for the random data sets were respectively 2696527, 11789288, and 20738481. Their relationship is almost linear. In contrast, with the fixed pattern data sets, there were marked differences between the two searches. The ZDD-based search was more efficient due to the compact representation by ZDD. The numbers of ZDD nodes for the fixed pattern data sets were respectively 313594, 363112, and 377979. These data sets were relatively small and did not linearly increase in size. This was r eflected in the total execution times.
In actual applications, there are usually fixed patterns in item occurrences for each class. Although actual application data are not as strongly biased as in our experiment, we can nevertheless conclude that the ZDD-based search approach is well suited for actual applications. 4.2 Example : Internet Shopping Advertising As one Internet application, we used data from Rakuten Ichiba [13], the largest online shopping mall in Japan, with over 30,000 online stores (September 2009). The company has released some of their data for use in academic research[13].
We investigated the relationship betw een article descriptions at the time of article introduction for sale and the number of user reviews attached to each article. The descriptions had been wri tten (in Japanese) by a person working for the shop where the article was to be sold. Article descriptions are important because they attract customers through on-line searching.

The data fields in the original data are shop code, purchase article id, article name, article description, price, category, and number of reviews. There are 31 top categories in total. We used data labeled with the category  X  X adies Fashion X  and  X  X apanese Sake X  (liquor).

In order to define characteristics from each description, we first extracted the nouns, adjectives, verbs, and adverbs from the descriptions using the Japanese language morphological analysis program called Chasen 1 . After some modifi-cations ( n -gram word concatenation to generate collocation, word selection by TF  X  IDF measurement, etc.), the item sets (  X  ) were defined. The explanatory variables for each article consists of t he occurrences of the selected words in the article descriptions. The class of the article was determined by the number of reviews. That is, we classified an article  X  X ositive X  if it had more than two reviews and  X  X egative X  if it had no reviews.

In the Japanese Sake category, there were 517 items in total ( |  X  | = 517), 3085 positive records, and 3372 negative records. Each record generally had five to ten items. We set N delete and N add to respectively 2 and 4. In the Ladies Fashion category, there were 1475 items in total ( |  X  | = 1475), 3166 positive records, and 7194 negative records. Both N delete and N add were set to 3.

Table 2 shows some of the results translated from the original Japanese. We as-sumed that all items in D (original item set) were removable (i.e., it did not con-tain any universal items) and set weight condition M to 1. For the Japanese Sake category, we found that keywords that created attractive images were preferred rather than technical keywords such as  X  rice malt X  and  X  X arefully screened. X  These results reflect the Internet shopping situation for Japanese Sake; that is, people who like to buy Japanese sake on the Internet generally put more empha-sis on the image or feeling of drinking sake rather than the technical details, un-like those who buy it in actual shops. For the Ladies Fashion category, keywords giving specific descriptions of each articl e, such as  X  X iered skirt, X   X  X emline, X  and  X  X houlder strap adjustment X  were preferred to ones that created a visual image of their usage or that described the technical details. That is, people shopping on the Internet for fashion prefer specific images and specifications, unlike people shopping in actual shops. 4.3 Example : AOL Search Logs As the other Internet application, we used data from AOL X  X  Search Log Collec-tion [14]. This collection consists of about 21 million web search queries input by about 650,000 AOL users from March to May 2006. The records include  X  X uery, X   X  X temRank, X  and  X  X lickURL X  (the last two items were included only if the user hadclickedonasearchresult).

We used records in which there was a  X  ClickURL X  entry and the  X  X temRank X  was less than 5 as the positive data and those without a  X  X lickURL X  entry as negative data. The objective of this analysis was to present sets of items to be deleted from or added to the original queries so as to increase the likelihood that the user would click on a search result.
 The results are shown in Table 3 (words preceded by  X * X  are universal items). We found that, if the user wants to find specific information about travel, it would be better to add a specific place-name such as europe, south africa, or italy. From the last example in the table, the keyword  X  X heap X  would not be adequate if the user wanted a reasonable price. Better key words would be  X  X iscounts, X   X  X est, X  and  X  X ackages. X 
These results shows that our recommendation flamework can suggest possi-ble candidates for query modifications, in order to get more appropriate search results for users. In this paper, we have described a new approach to the set recommendation prob-lem: changes (item addition and delet ion) to a set of items are recommended on the basis of class differences. Since r ecommendation services are becoming more and more popular, our framework should be effective for actual applications rather than simply being used for collaborative filtering. The use of our algo-rithms, which use the ZDD data structure, results in efficient calculation for huge data sets, especially when the data is biased, as it generally is in actual applications. Although we only considered the case of two classes for simplicity, we can easily consider a case in which th ere are three or more classes or there are multiple classification criteria for the input data.

In related work, Dong et al.[3] proposed using an emerging patterns approach to detecting differences in classes and using a classification framework based on the emerging patterns. While frequent pattern mining generally cannot detect the characteristic item pattern for each class, their approaches focus on detecting item sets that are meaningful for classification. Although their motivation is very similar to ours, they have not yet reported a recommendation procedure based on emerging patterns.

Other researchers have developed set recommendation procedures based on certain constraints such a s recommendation costs, orde rs and other conditions [12,10]. These procedures are practically applicable to trip advice and univer-sity course selection, for example. Alt hough we do not assume any constraint between items as pre-defined knowledge, incorporating such constraints into our recommendation framework shoul d improve its effectiveness.

Searching under the constraints described in this paper is closely related to searching based on the Levenshtein distance (edit distance). Efficient algorithms, such as dynamic programming approach, have been developed to calculate the distance, and many implementations including approximation approaches have been introduced [9]. The problem we focused on in this paper is slightly different from those for the edit distance. Our problem is to find similar items from given polynomials under the constraints of a limited number of item additions and deletions with a weight constraint. A comparison of the problems remains for future work.

Future work also includes extending our results in several directions :  X  The search procedure based on the ZDD structure described in this paper  X  We assume in this framework that items occur only positively in patterns. Acknowledgment. We are grateful to Rakuten, Inc., for providing the Internet shopping data used in this research.
