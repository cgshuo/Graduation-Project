 We study optimization of relational queries using material-ized views, where views may be regular or restructured. In a restructured view, some data from the base table(s) are rep-resented as metadata  X  that is, schema information, such as table and attribute names  X  or vice versa.

Using restructured views in query optimization opens up a new spectrum of views that were not previously available, and can result in significant additional savings in query-evaluation costs. These savings can be obtained due to a significantly larger set of views to choose from, and may in-volve reduced table sizes, elimination of self-joins, clustering produced by restructuring, and horizontal partitioning.
In this paper we propose a general query-optimization framework that treats regular and restructured views in a uniform manner and is applicable to SQL select-project-join queries and views with or without aggregation. Within the framework we provide (1) algorithms to determine when a view (regular or restructured) is usable in answering a query, and (2) algorithms to rewrite a query using usable views.
Semantic information, such as knowledge of the key of a view, can be used to further optimize a rewritten query. Within our general query-optimization framework, we de-velop techniques for determining the key of a (regular or restructured) view, and show how this information can be used to further optimize a rewritten query. It is straight-forward to integrate all our algorithms and techniques into standard query-optimization algorithms.
 H.2.4 [ Database Management ]: Systems X  Query Pro-cessing Algorithms Query optimization, Restructur ed views, Materialized views  X 
Supported by NSF grants Career 0447742 and IIS 0307072.  X  Supported by NSF grant IIS 0083312.
 Copyright 2006 ACM 1-59593-433-2/06/0011 ... $ 5.00. We study optimization of relational queries using materi-alized views, where views may be regular or restructured. In a restructured view, some data from the base table(s) are represented as metadata  X  that is, schema information, such as table and attribute names  X  or vice versa. Often, data from one or multiple tables can be restructured into a new representation with significant reduction in the overall size of data. Intuitively, by moving data values that appear frequently and repeatedly in a relation to metadata in the view, we can represent the information in the view more compactly than by using a regular view.

Consider, for example, the salesInfo relation of Fig-ure 1, which lists stores and their monthly sales informa-tion over a number of years. Figure 2 shows a restructured view of salesInfo. This salesInfoView relation repre-sents the same information as salesInfo, but the months ( Jan , Feb , ... , Dec ) now play the role of attribute names, and the sales values for the months of each year are or-ganized  X  X orizontally X  into a single tuple for each store. Note that each tuple of the view salesInfoView represents the same information that is represented by 12 tuples of the base table salesInfo . Figure 3 shows another view, annualSalesView, which involves aggregation and restruc-turing. Each tuple of annualSalesView represents the com-plete annual sales values for each store for all years.
Using restructured views in query optimization opens up a new spectrum of views that were not previously available, and can result in significant additional savings in query-evaluation costs. The savings can be obtained due to a significantly larger set of views to choose from, and may involve reduced table sizes, elimination of self-joins, cluster-ing produced by restructuring, and horizontal partitioning.
Commercial database systems are adding facilities for the definition and materialization of restructured views [9]. Our goal is to tap into this new capability for query optimiza-tion. Experiments have shown a significant reduction in query-processing costs using materialized restructured views for certain workloads [9, 25, 27]. In particular, our earlier experimentation (see [25]) used two data sets: 1. The TPC-R benchmark [28] was used to generate a 2. All available stock data through 1-12-2001 for a large (See Section 2 for definitions of the  X  X plit X  and  X  X nfold X  operations.) Our experiments on those data showed query-evaluation sp eedups ranging from 150% to 675% for certain classes of queries [25].

Semantic information, such as knowledge of the key of a view, can be used to further optimize a rewritten query. We consider the problem of determining the key of a (regular or restructured) view, and show how this information can be used to further optimize a rewritten query.
 Our contributions:
The remainder of the paper is organized as follows: We present the motivation for this work in Section 2, then in-troduce restructured views and view definitions in Section 3. Our formulation uses a logical language for view definition that facilitates extending previous results on view usability and query optimization to resturctured views. The problems of view usability and query rewriting are discussed in Sec-tion 4. We present conditions to determine when a (regular or restructured) view is usable in answering a SQL query, and develop algorithms for rewriting queries in terms of us-able views. We develop these results for queries and views without aggregation, as well as for queries and views in-volving aggregation and group-by. Our ultimate goal is to combine query optimization using regular and restructured views into a single framework for relational databases. As such, materialized restructured views should be stored as relations, and should participate in SQL query evaluation. In Section 5 we discuss the enrichment of an SQL system with query optimization using restructured views. In Sec-tion 6 we present techniques to derive the key of a view, and in Section 7 we show how these derived integrity con-straints can be used to further optimize rewritten queries. We discuss related work in Section 8, and conclude and give possible directions of future work in Section 9. In this section we first give an informal presentation of re-structuring operations, then provide a discussion and exam-ple queries to highlight advantages of incorporating restruc-tured views (as well as regular views) into query-optimization techniques that use materialized views.

Restructuring operations unfold , fold , split ,and unite were introduced in [14]; the first two operations are also known in database literature as pivot and unpivot , respectively. Com-bined with relational algebra, these operations form an ex-tended algebra capable of querying data and metadata uni-formly, and of defining restructured views within the rela-tional data model [22].

Consider the relation salesInfo of Figure 1. The un-fold operation takes two attributes (column names) as pa-rameters. Performing the operation unfold month,sales salesInfo generates the salesInfoView relation shown in Figure 2. The values in column month of salesInfo are moved to schema (attribute names) in the view, and corre-sponding values in column sales are organized (horizontally) as values for these newly formed attribute names. The fold operation is the converse of unfold .

The split operation takes one attribute as parameter, and performs a horizontal partitioning according to the values of the specified attribute. Each partition, minus the specified attribute column, is made into a new relation, and the value of the specified attribute is used as the name of the relation. The unite operation is the converse of split .

Restructuring operations together with regular aggrega-tion and group by operations can define a broad spectrum of views that enhance regular views with restructuring. Fig-ure 3 shows one such view, annualSalesView .Itrepresents aggregated annual sales values for stores in a restructured view that has years as attributes (column names).
Using the full spectrum of regular and restructured views for query optimization can result in a significant reduction in query-processing costs over using only regular views. The extra efficiency is due to two factors: 1. Information can be represented more compactly in re-2. Restructuring amounts to different physical clusterings
The following example demonstrates some of the advan-tages of using materialized re structured views in query op-timization.

Example 1. ( Query Optimization Using Material-ized Restructured Views )Wehaveshownaregularrela-tion, salesInfo , and two restructured views, salesInfoView and annualSalesView , in Figures 1, 2, and 3, respectively. View salesInfoView pivots sales amounts by month, that is, it uses months as attributes and records sales figures of the months of each year  X  X orizontally X . View annualSalesView aggregates (sums) the sales amounts for the months of each year, and then pivots the sum by year. The effect of re-structuring should be evident in these views: Each tuple of salesInfoView records the same inform ation that is repre-sented by twelve tuples of salesInfo , and thus the size of the relation for salesInfoView will be smaller than that of salesInfo (generally two to four times smaller). Similarly, each tuple of annualSalesView records the same information that is represented by n tuples of a regular view that aggre-gates monthly sales for each year, where n is the number of years sales data are available in the base table salesInfo . Again, annualSalesInfo is, in general, smaller than a reg-ular view that does the same aggregation. Size reduction in this case may amount to one or two orders of magnitude. (Note that salesInfoView clusters monthly sales for each year into one tuple, while annualSalesView clusters all an-nual sales for each store into a single tuple.) Now consider the following queries:
Q1. List stores that have a sales volume of at least one
Q2. List stores that show a rapid decline (10% or more per
Q3. List stores that doubled their annual sales between
Q4. List hardware stores that doubled their annual sales
These four queries can all be expressed in SQL; for in-stance, a SQL definition for Q1 is
Q1 is a simple query whose evaluation requires a full scan of the table salesInfo in the absence of an index on month or year. It can be processed more efficiently using the re-structured view salesInfoView due to its smaller size.
Evaluating the query Q2 can benefit from the clustering that salesInfoView provides, as the view clusters the infor-mation of interest (sales amounts for the fourth quarter of 2005) into a single tuple for each store. Evaluating Q2 on the base table salesInfo requires two self-joins, which can be eliminated using salesInfoView ; in addition, the size of the view is smaller than the size of salesInfo .Asaresult, the savings in evaluation costs for Q2 using salesInfoView can amount to an order of magnitude or more. We discuss Q2 in detail in Example 10 in Section 7.

Q3 can benefit from the clustering annualSalesView pro-vides. Similarly to Q2, evaluating Q3 using a restructured view is more efficient than evaluating it on a regular view that aggregates monthly sales amounts for each year.
While similar to Q3, Q4 has an additional restriction to only one type of store: hardware stores. The second view of Example 5 (Section 3.1) is usable in answering this query. Note that this view is basically a horizontal partitioning, on the store type attribute, of a restructured view that lists stores and their annual sales (such as annualSalesView ). The size of the materialized view for hardware stores can be orders of magnitude smaller than the size of the base table or of a regular view, due to horizontal partitioning as well as to representing in a single tuple all annual-sales figures for a store. Hence, our general framework also accommo-dates optimization techniques based on horizontal partition-ing. (Compare this to the current practice that deals with horizontal partitioning separately from query optimization using materialized views.) Traditionally, the relational model distinguishes between the schema ( intention )and data ( extension ). But in a restruc-tured view, data values can play the role of schema elements  X  such as attribute and relation names  X  and vice versa. (As an illustration, consider the two relations in Figures 1 and 2.) We use the following definitions to accommodate restructured views as an extension of the relational model.
Definition 1. ( Flexible Schema; Fact )A flexible schema ( schema , for short) is a pair ( A ,D )where A is a set of attributes, and D is a set of values (a domain ). A schema is regular if it has attributes only.

Let S =( A ,D ), A = { A 1 ,...,A n } , D = { d 1 ,...,d m a flexible schema. A fact r on the schema S is a statement of the form p ( A 1 : u 1 ,...,A n : u n ,d i : v ), where p is a predicate symbol, u 1 ,...,u n ,v are values, and d i  X  D .
Our formalism makes it convenient to discuss in a uniform way views (regular and restructured), view definitions, view usability, and query rewriting (Sections 3.1 and 4). This is achieved by separating the issue of representing data from that of relational (tabular) storage of data. Our ultimate goal, however, is to use these results for query optimization in a practical setting in an SQL system, where material-ized views are stored and accessed as relations. Hence, in this section we also address relational storage of restructured views. To accommodate relational (tabular) representation, we borrow from [21] the notion of molecule . A molecule combines multiple facts into a single representation.
Definition 2. ( Molecule )Let S =( A ,D ), A = { A 1 , ...,A n } , D = { d 1 ,...,d m } , be a flexible schema. A partial molecule m on the schema S is a statement of the form p ( A u ,...,A n : u n ,e 1 : v 1 ,...,e k : v k ), where p is a predicate symbol, u 1 ,...,u n ,v 1 ,...,v k are values, and e 1 ,...e e = e j , i, j =1 ,...,k .Wedenote { e 1 ,...,e k } X  D by D and call it the domain of the molecule m . A molecule m is total if D m = D , i.e. , every value of the domain D appears in the molecule. Note that a fact is (a special case of) a molecule. Given a molecule m ,wewrite m ( A i )(or m ( d to refer to A i (or d i ) component of m .Weuse m ( A )asa shorthand for m ( A 1 ) ,...,m ( A n ).
 Example 2. ( Regular and Restructured Relations ) Consider a regular schema salesInfo(storeID,year,month, sales) and the relation of Figure 1 on salesInfo .Thisre-lation is represented by the following facts: salesInfo(storeID: 1, year: 2005, month: Jan, sales: 120000)  X  X  X  salesInfo(storeID: 1, year: 2005, month: Dec, sales: 150000) salesInfo(storeID: 2, year: 2005, month: Jan, sales: 300000)  X  X  X 
Now consider a restructured view salesInfoView that  X  X nfolds X  (or  X  X ivots X ) salesInfo on month. The tabular representation of this view is shown in Figure 2. In our ab-straction, each tuple of this relation is represented by twelve facts. For example, the first tuple is represented as follows: salesInfoView(storeID: 1, year: 2005, Jan: 120000)  X  X  X  salesInfoView(storeID: 1, year: 2005, Dec: 150000)
The same tuple is represented by the following molecule: salesInfoView(storeID: 1, year: 2005, Jan: 120000,
We need the following definitions to bridge the gap be-tween facts and molecules:
Definition 3. ( Mergeable Molecules )Twomolec-ules m 1 and m 2 on the schema S =( A ,D ), A = { A 1 ,...,A are mergeable if ( i ) m 1 ( A )= m 2 ( A ), and ( ii ) D  X  .The merge of two mergeable molecules m 1 and m 2 ,writ-ten m 1  X  m 2 , is a molecule m on S where m ( A )= m 1 ( D m = D m 1  X  D m 2 ,andforall d  X  D m , m ( d )= m 1 ( d )if m 1 ( d ) is defined, otherwise m ( d )= m 2 ( d ).
Definition 4. ( Maximal Molecule ) Given a molecule m and a set of molecules M ,wesay m is maximal with respect to M if there is no molecule in M that is mergeable with m . A set of molecules M is called maximal if every molecule in M is maximal with respect to M .

Definition 5. ( Canonical Representation )Givena set F of facts on the schema S =( A ,D ), we define a canon-ical (molecular) representation of F as a set of maximal molecules obtained by repeatedly merging facts of F.
In general, a given set of facts F on a schema S =( A ,D ) can have more than one canonical representation. But if A is the key of S , then the canonical representation is unique:
Lemma 1. ( Uniqueness of Canonical Representa-tion ) A set of facts F on a schema S =( A ,D ) has a unique canonical representation if A is the key for S .

Proof: We can construct a canonical representation for F by (1) partitioning facts F according to their A values, and (2) merging the facts in each partition. Since A is the key, each partition can have at most one fact with a value for a given d  X  D . Hence, all facts in a partition can be merged into a single molecule. The set of molecules obtained in this way is maximal since each has a different A value.
GivenasetoffactsFonschema S =( A ,D ), a canonical representation M of F can be represented in relational (tab-ular) form. Each molecule m  X  M is represented by a tu-ple on the (regular) schema ( A 1 ,...,A n ,d 1 ,...,d k ), where {
A 1 ,...,A n } = A and { d 1 ,...,d k } = D .Ifmolecule m is partial, it should be padded with a special value for miss-ing values in D to make it into a full tuple. We denote this special (padding) value by  X  . The reason we use this special value instead of a null is to be able to distinguish between nulls that may exist in the base relation and the padding values used to represent partial molecules by full tuples. In this way, the relational representation is lossless, meaning that we can obtain the original set of facts from the relational representation.

Example 3 (Relational Representation). Suppose a store with storeID 567 was opened in February 2003. It would have sales figures for February through December of 2003, but no sales figure for January 2003. Its canonical rep-resentation for salesInfoView will have the following partial molecule (plus possibly total and partial molecules for 2004 and later years). salesInfoView(storeID: 567, year: 2003, Feb: 300000,
The corresponding relational representation will have the following tuple for this store for 2003:
We use S-LOG , a Prolog-like language, to define views in our framework. In this subsection we first present some examples, then give a brief discussion of S-LOG .
Example 4. ( View Definition ) The view definition for salesInfoView in Example 2 is the following S-LOG rule (uppercase letters represent variables): Note that while salesInfo has the regular schema ( storeID, year, month, sales ), salesInfoView has the (flexible) schema ( { storeID, year } , D ), with domain D= { Jan, Feb, ..., Dec } . Thisisachievedbyusingvariable M ; M is bound to data (months Jan, Feb, ... ) in the body, while playing the role of an attribute name in the head of the rule.
Example 5. ( Restructured spj views )Thisexample demonstrates that S-LOG can combine select-project-join (SPJ) view capability with a variety of aggregation and re-structuring operations. Suppose relation storeType(store ID, type) specifies a type ( e.g. , grocery, hardware, etc.) for each store. The following definition generates multiple re-lations, one per store type. It is basically a partitioning of storeInfoView of Example 4 according to store type. As another example, consider view definition It generates multiple relations, one per store type. Each relation lists for each store all total annual sales figures in a single tuple, arranged horizontally.
 S-LOG is a simplified version of schemaLOG [21]. The main difference between S-LOG and schemaLOG is that schemaLOG facts contain a tuple-id component while S-LOG facts do not, which makes S-LOG simpler and closer to the relational model. Atoms of S-LOG correspond to facts on (flexible) schemas (see Definition 1), where components can be constants or variables. View definitions use S-LOG rules, defined as follows:
Definition 6. An S-LOG rule has the form h ( x )  X  b ( x, y ) , where (1) h ( x ), the head of the rule, is a single S-LOG atom containing the set of variables x ,and(2) b ( x, y ), the body of the rule, is a conjunction of S-LOG atoms and comparison conditions containing the set of variables x and y .Theset of variables x in the head of the rule is called distinguished variables. Note that we require the  X  X afety condition X   X  that is, in an S-LOG rule, distinguished variables must also appear in the atoms of the body.
 The valuation-based semantics of schemaLOG [21] is appli-cable to S-LOG as well. For example, given the fact salesInfo(storeID: 1, year: 2005, month: Jan, sales: 120000) the instantiation of the definition for salesInfoView of Ex-ample 4 binds variables I , Y , M ,and S to 1, 2005, Jan, and 120000, respectively, which generates this fact in the view: salesInfoView(storeID: 1, year: 2005, Jan: 120000) It is easy to see that applying the view-definition rule of Example 4 to salesInfo facts produces the salesInfoView facts represented in Example 2.
 A query or view definition can involve aggregation. To ac-commodate aggregation, we extend S-LOG rules by allowing aggregate functions in the head of the rules. We adopt the convention of [8, 24] that an implicit  X  group by  X  by the non-aggregated variables in the head is applied to the query or view definition.

Example 6 (Aggregation). This definition of a regular view is equivalent to the SQL view definition
Now consider this definition of a restructured view:
Similarly to annualSalesInfo , annualSalesView performs agroupbystoreID I and year Y , and aggregates the sales figures. But the schema of annualSalesView is ( { storeID D ), where domain D contains the years that appear in the base relation salesInfo . A tabular representation of annual SalesView has the schema ( storeID,...,2003,2004,... ). That is, it lists the annual-sales figures  X  X orizontally X  in columns labeled by the year. Figure 3 depicts this view. Note that each tuple of the table in Figure 3 represents the information of n tuples of the regular view annualSalesInfo , where n is the number of years for which sales information is available in the base table salesInfo . We would like to extend view usability and query opti-mization using materialized views [26] to restructured views. This provides the database system (and the DBA) with a significantly larger set of views to choose from for material-ization and utilization in query optimization, which can re-sult in significant improvements in query-answering perfor-mance. In this section we concentrate on view usability and query rewriting for restructured views. As regular views are special cases of restructured views, our results form the basis for a unified approach for query optimization using materi-alized regular and restructured views in database systems. We formulate our view-usability results first for unaggre-gate queries and views (Section 4.1), and then for aggregate queries and views (Section 4.2), with aggregate functions SUM, COUNT, MAX, and MIN .
Let Q be a query in S-LOG ,and V be a view defined by an S-LOG rule r .Let V r , V Q ,and C Q denote the set of variables in r , the set of variables in Q ,andthesetof constants in Q , respectively. The following definitions, from [7], apply equally to our framework:
Definition 7 (Valid Renaming). A valid renaming  X  of r with respect to Q is a mapping from V r to V Q  X  C Q  X  : V r  X  V Q  X  C Q , such that (1) If v  X  V r is a distinguished variable (see Definition 6), then  X  ( v )  X  V Q  X  C Q . (2) If v  X  V r is a non-distinguished variable, then  X  ( v ) V ,and  X  ( v ) =  X  ( v ) for any other variable v  X  V r .
The purpose of renaming is to make the body of the view (with the exception of comparison predicates) to become equal to (part of) the body of the query.
 Definition 8. ( Safe Occurrence; Safe Substitution ) Given a view V (defined as an S-LOG rule r ) and a query Q ,wesay Q has a safe occurrence of V if there is a valid renaming of r with respect to Q , such that 1. The renamed rule has the form V ( x )  X  L ( x, y ) ,I ( x ), 2. The query Q has the form Q ( u )  X  L ( x, y ) ,I ( x ) ,G ( v ), 3. Conditions I ( x ) of the query logically imply condi-
The safe substitution corresponding to the above safe oc-currence is: Q ( u )  X  V ( x ) ,I ( x ) ,G ( v ).
We can now state the following result for S-LOG queries and views without aggregation.

Theorem 1 (View Usability). Let Q and V be select-project-join S-LOG query and view, respectively. Then view V is usable for query Q if Q has a safe occurrence of V ,in which case Q can be rewritten into a (multi-set [6]) equiva-lent query that uses the view V in its body. The rewritten query is the safe substitution mentioned above.
Proof: Let Q be a query that has a safe occurrence of view V .Then Q has the form Q ( u )  X  L ( x, y ) ,I ( x ) ,G ( v ), and V can be renamed as V ( x )  X  L ( x, y ) ,I ( x ). Consider query Q ( u )  X  V ( x ) ,I ( x ) ,G ( v ), which is the safe substitu-tion of V in Q .Weshow Q  X  Q by showing a 1:1 corre-spondence between the facts generated for Q and those gen-erated for Q . Suppose that values x 1 , y 1 ,and v 1 in facts corresponding to L and G generate a fact Q ( u 1 ) by valuation conditions I ( x 1 ) are also true, and V ( x 1 ) is generated by V ( x 1 )  X  L ( x 1 ,y 1 ) ,I ( x 1 )intheview V .Hence Q ( u generated for the query Q by Q ( u 1 )  X  V ( x 1 ) ,I ( x
Conversely, assume values x 1 ,y 1 ,and v 1 generate V ( x and Q ( u 1 ) by instantiations V ( x 1 )  X  L ( x 1 ,y 1 generate Q ( u 1 )by Q ( u 1 )  X  L ( x 1 ,y 1 ) ,I ( x 1 ) ,G ( v
Theorem 1 gives us a sound algorithm (that is, each out-put of the algorithm is valid) for obtaining equivalent rewrit-ings of SQL queries using restructured views. Note that the soundness result holds (1) for all of SQL select-project-join queries and of regular or restructured select-project-join views, all possibly with arithmetic comparisons, and (2) un-der each of set, bag ( i.e. , multi-set [6]), and bag-set [6] se-mantics for query evaluation.
We now extend our approach to rewriting SQL queries with aggregation SUM, COUNT, MAX, or MIN using restruc-tured views. We begin by giving a motivating example.
Example 7. Consider a SQL query Q  X  X eturn the sum of sales per store since the beginning of the year 2003. X  In S-LOG , Q can be defined as We can evaluate the query Q by using the following two equivalent rewritings of Q , R 1 and R 2 , which use restruc-tured views. Rewriting R 1 uses view salesInfoView ,and rewriting R 2 uses view annualSalesView ; see Examples 4 and 6 for the definitions of these two restructured views. As discussed above, using restructured view salesInfo View instead of salesInfo may result in a reduction in evaluation costs for Q . Moreover, using instead the aggregate restruc-tured view annualSalesView may result in further signifi-cant reductions in the evaluation costs for the query.
Our goal in this subsection is to provide an analog of The-orem 1 for aggregate SQL queries and restructured views with and without aggregation. These results will allow us to obtain equivalent rewritings of aggregate queries using restructured views, such as rewritings R 1 and R 2 in Exam-ple 7. Our approach, which is an extension of the contri-butions of [8, 24] to restructured views, is twofold. First, we define rules (Lemma 2) that tell us when an aggregate rewriting using a restructured view is equivalent to its ex-pansion in terms of the base relations. As has been shown in [8], such equivalence-to-expansion problems need to be addressed essentially on a case-by-case basis, by defining and using rewriting templates that allow only certain types of views in the body of the rewriting and only certain group-by and aggregation attributes in the head of the rewriting.
Second, we use our rules to reduce the problem of deter-mining equivalence of an aggregate query to a rewriting to the problem of determining equivalence of the query to the expansion of the rewriting (Theorem 2). The latter problem has been solved in [24] for queries with aggregate functions SUM, COUNT, MAX, and MIN .

We now formulate Lemma 2 that spells out our rules that define when an aggregate rewriting using a restructured view is equivalent to its expansion in terms of the base rela-tions. (In this subsection we use the term  X  X ewriting X  to denote queries defined in terms of views.) Our rewriting templates are an extension of central rewritings of [1] to re-structured views. Intuitively, in central rewritings the unag-gregated core is a SPJ query, and only one view (the central view ) contributes to computing the aggregated query out-put. Both rewritings in Examp le 7 are central rewritings. Central rewritings are a natural choice in many applications; for instance, in the star-schema framework [5] the fact ta-ble provides the aggregate view, and the dimension tables provide the other views in the rewritings. In our analysis, we chose central rewritings for their simplicity. As there is a natural relationship between so meclassesofrewritingsin[1] and in [8], our results also apply to rewritings of [8].
Lemma 2 uses the notion of an expansion R exp of a central rewriting R .Weobtain R exp by (1) replacing all view literals in R by the bodies of their definitions, using fresh variables for nondistinguished variables as usual, and by (2) replacing the aggregate function in the head of R by the aggregate function of the central view. (As a special case, if the central view is unaggregated, the heads of R and R exp use the same aggregate function.) For instance, the expansion of rewriting R 2 in Example 7 is defined as
Lemma 2 (Rewriting Templates). Let R be a regu-lar central rewriting with aggregation SUM, COUNT, MAX ,or MIN that uses no more than one restructured view and zero or more regular views. Then R exp  X  R provided that (1) R is a MAX or MIN rewriting, or the following rule is observed: (2) In case R is a SUM or COUNT rewriting, all noncentral views are unaggregated and are evaluated using bag projection.
Proof (sketch): The result of the lemma follows directly from the results in [1] on aggregate rewritings with regular views, and from Theorem 1 on view usability for restruc-tured views. Note that rewriting R canbeviewedasthe result of doing a safe substitution of the central view of R into the expansion R exp of R .
 We refer to rewritings that satisfy the equivalence test of Lemma 2 as admissible aggregate rewritings. Note that the rules of Lemma 2 work for rewritings that use restructured (and regular) views, as well as for rewritings that use only regular views. Thus, the role of Lemma 2 in our general framework is to extend the applicability of central rewritings of [1] to restructured as well as regular views.

We now use the rules of Lemma 2 to reduce the problem of determining equivalence of an aggregate query Q to a rewriting R to the problem of determining equivalence of Q to the expansion R exp of R . As we have already mentioned, once the reduction has been done we can decide whether Q is equivalent to R exp (and thus whether Q is equivalent to R ) by using the results of [24].

Theorem 2. Let Q and V be select-project-join S-LOG query and view, respectively, such that Q has aggregation SUM, COUNT, MAX, or MIN ,and V may or may not have ag-gregation. Then V is usable for Q if (1) Q has a safe oc-currence of V , and (2) the result R of rewriting Q using V is an admissible aggregate rewriting. If both (1) and (2) are satisfied, the rewriting R is equivalent to the query Q .
Proof (sketch): The result of the theorem is straight-forward from the definition of ce ntral rewritings [1], from Theorem 1, and from Lemma 2.

Theorem 2 gives us a sound algorithm for equivalently rewriting aggregate queries using regular and restructured views. Note that the soundness result holds for all of SQL aggregate select-project-join queries and of SQL regular or restructured select-project-join views (possibly with aggre-gation), all possibly with arithmetic comparisons. In par-ticular, by Theorem 2 both rewritings ( R 1 and R 2 )ofEx-ample 7 are equivalent to the query Q in the example. As a result, each of R 1 and R 2 can be used to reduce the eval-uation costs of the query Q on a relational database where the views used in the rewritings ( salesInfoView in R 1 and annualSalesView in R 2 ) are materialized as stored relations. In this section we address the additional details needed to apply our results in an SQL database system. In this set-ting, all materialized views  X  including restructured views  X  should be stored and accessed as relations, and queries (including rewritten queries) should be definable in SQL. The additional capability required is the ability to define and materialize restructured views, which has been incorpo-rated into some commercial database systems [9].
 Given an SQL query, we can use our usability results of Section 4 to rewrite the query with respect to a usable view. But the resulting query may not be expressible in SQL. The reason is that S-LOG is more powerful than SQL in its abil-ity to treat data and metadata (schema information) uni-formly. To make sure the rewritten query is expressible in SQL, the variables in V ( x ) in the body of the rewritten query should only correspond to data. That is, no variable should appear in V ( x ) in the position of a schema element (attribute name, relation name). Or, if a variable v does appear in a metadata position, then a condition of the form v = constant should also exist in the rewritten query. The following result guarantees that the rewritten query is in SQL. Let V be a restructured view defined by the S-LOG rule r ,and Q be an SQL query. Let V r be the set of vari-ables in the rule r ,and V m r  X  V r be those variables in the head of r that are in metadata positions.

Theorem 3 (SQL Usability). V is SQL-usable in an-swering Q if it is usable in answering Q with respect to a valid renaming  X  , and, further, for all variables v  X  V m  X  ( v ) is a variable, then the rewritten query contains a con-dition  X  ( v )= c for some constant c , or such a condition is implied by the conditions of the rewritten query.
Proof: Let Q be the rewritten query w.r.t. the renaming  X  . For each variable v  X  V m r ,wereplace  X  ( v )in Q by the constant c from  X  ( v )= c , and remove any condition that involves  X  ( v ). The result is an S-LOG query with variables in data positions only, which is expressible in SQL. Finally, query rewriting needs one additional detail in an SQL database setting. Conditions should be added to the rewritten query to ensure that  X  X adding X  values  X  do not impact the answer to a query.

We notice that padding values can be generated in the re-lational representation of a view only when the view-definition rule has a variable in an attribute-name position in the head of the rule. Let Q be an SQL query, and V be an SQL-usable view for Q .Let V ( x ) be the head of the rule defining the view V ,and x a be the set of variables that appear in attribute-name positions in V ( x ). Let  X  be the renaming function used for testing SQL-usability and for rewriting the query, and let Q be the rewritten query according to Theorem 1 or to Theorem 2.

Algorithm 1. ( SQL Query Rewriting )Foreachvari-able v appearing as V ( ...,y : v,... ) in the body of Q ,if y  X   X  ( x a ), add the condition ( v =  X  ) to the body of Q .
Example 8. ( SQL Query Rewriting ) Consider the re-lational representation of the view salesInfoView defined on the base relation salesInfo (Example 4). The query  X  X ist maximal sales for the month of January for each store for their sales since 2000 X  is written as follows: maxJanSales(storeID: I, janSales: max(S))  X  salesInfo(storeID:I,year:Y,month: X  X an X ,sales:S), Y &gt; 1999
The view salsInfoView is SQL-usable in answering this query. According to Theorem 2, the rewritten query is: maxJanSales(storeID: I, janSales: max(S))  X  salesInfoView(storeID: I, year:Y, Jan: S), Y &gt; 1999
The rewritten query for the relational representation is obtained by adding the condition S =  X  to the body: maxJanSales(storeID: I, janSales: max(S))  X  salesInfoView(storeID:I,year:Y,Jan:S), Y &gt; 1999, S =  X  Or, in SQL: Integrity constraints, such as key and foreign-key constraints, play an important role in database design and in query opti-mization. They become even more important for query op-timization using materialized restructured views. As we will discuss in Section 7, knowledge of integrity constraints for restructured views can be used for certain classes of queries to further optimize the rewritten query with significant im-provements in the query-evaluation efficiency.

In this section we concentrate on the problem of deriv-ing integrity constraints in views. Two factors determine integrity constraints in views: (1) the view definition, and (2) integrity constraints in the corresponding base relations. The group-by operation of aggregate views naturally gen-erates key constraints in the view. For example, consider the views annualSalesInfo and annualSalesView of Ex-ample 6. The key of annualSalesInfo is (storeID, year) , as a result of grouping by these two attributes. The case of annualSalesView , which is a restuctured view, is somewhat different. Here, the group-by is also by storeID and year . However, year (or rather the variable that is bound to year ), is used as attribute name in the aggregation part of the head of the view-definition rule. The key of annualSalesView is the single attribute storeID , see Figure 3.

We can state the following result regarding integrity con-straints in aggregate views. Let an aggregate view V be de-fined by an S-LOG rule. The head of the rule has the form view-name(target) ,where target contains non-aggregation components of the form att:var and aggregation components of the form att:agg-function(var) ,where agg-function is an aggregate function such as MIN, MAX, SUM, etc.
 Theorem 4. (Key of an Aggregate View) Let view V be as above. The key of V is the set of attributes that ap-pear in non-aggregation components in the head of the view-definition rule.

We should note that attribute field ( att in att:var )canbe a constant or a variable. By  X  X et of attributes X  in Theorem 4 we mean the union of (1) the set of constant attributes, and of (2) the domain of the variable attribute (if any) in the non-aggregation components in the head. In Example 6, the view definition for annualSalesView has only one (constant) attribute, storeID , in the non-aggregation components of its head. Hence, storeID is the key of annualSalesView . Given key constraints on base tables, or, more generally, a set of functional dependencies (FDs) on base tables, we would like to derive the constraints that hold in a restruc-tured view defined by an S-LOG rule r . Wewillusean S-LOG -based declaration for FDs. For example, consider the relation salesInfo(storeID, year, month, sales) . Suppose that (storeID, year, month) is the key of sales Info ,thatis,theFD storeID, year, month  X  sales holds in salesInfo . We express this FD as follows: which is stating that two salesInfo facts with the same val-ues for storeID , year ,and month must also have the same value for sales . This representation is suitable for our flexible-schema framework. For example, consider the view salesInfoView of Example 4. The above FD is expressed as follows for salesInfoView :
For certain restructured views, integrity constraints im-plied by FDs in base tables cannot be expressed as FDs. Yet, our S-LOG formalism allows us to represent these con-straints. In the rest of this section, we briefly discuss the closed-world semantics of view-definition rules, then present a logical process to derive integrity constraints in views. We follow the closed-world semantics for view-definition rules. This is the usual semantics for query processing and query optimization using materialized views. In contrast, the open-world semantics has been used for data-integration applica-tions. Interested readers are referred to [15] for a compre-hensive discussion.

Intuitively, the closed-world semantics states that a view defined in S-LOG consists of the facts derived by the rule and nothing else. We can represent this semantics for a view V defined as v ( x )  X  b ( x, y ) by the logical statement
The following example demonstrates our logical method for verifying integrity constraints that hold in a view.
Example 9. Consider the view salesInfoView of Exam-ple 4. The corresponding base relation is salesInfo(store ID, year, month, sales) . Suppose that (storeID, year, month) is the key of salesInfo .

We can verify that the following FD holds in the view:
We observe that, by the closed-world semantics: But, since ( storeID, year, month )isthekeyfor salesInfo :
Hence, we have verified the following FD in the view: In Section 6 we discussed how to determine the key of a view. This knowledge can be used to optimize rewritten queries, with a potential for significant improvements in the evaluation efficiency for certain classes of queries.
As we saw in Section 2, the added efficiency due to re-structured views is possible because (1) a restructured view can represent the information of a regular view in a much smaller relation, and (2) restructured views naturally per-form clustering of data by organizing many tuples of a reg-ular view into a single tuple, or by horizontal partitioning. Optimization of rewritten queries discussed in this section allows us to maximize the benefit from the second factor.
We demonstrate this further optimization by the follow-ing example. The optimizer uses semantic knowledge (key constraints) to determine that information needed for an-swering a user query is clustered within single tuples, and hence, it is able to eliminate costly self-joins: Example 10. ( Optimization of Rewritten Queries ) Consider a query  X  X ist stores that show a rapid decline in sales (10% or more per month) in the fourth quarter of 2005. X  Using the relation salesInfo ,thequeryis: decliningStores(storeID: I)  X  salesInfo(storeID: I, year: 2005, month:  X  X ct X , sales: S1), salesInfo(storeID: I, year: 2005, month:  X  X ov X , sales: S2), salesInfo(storeID: I, year: 2005, month:  X  X ec X , sales: S3), The view salesInfoView is SQL-usable for this query. The rewriting is applied three times to replace the three occurrences of salesInfo in the body with salesInfoView . The rewritten query is: decliningStores(storeID: I)  X 
In the absence of key constraints, the rewritten query for relational representation of salesInfoView view is the same as the query above with the addition of constraints S 1 =  X  , S 2 =  X  ,and S 3 =  X  . The rewritten query is more ef-ficient than the original query due to the reduced size of the view salesInfoView (which is, in general, two to four times smaller than salesInfo ), resulting in an evaluation time possibly 6 to 12 times faster than the original query, assuming linear time for join operation.

However, the optimizer also knows that (storeID, year) is the key for storeInfoView (see Example 9). Then the rewritten query can be further optimized into: decliningStores(storeID: I)  X  salesInfoView(storeID:I, year:2005, Oct:S1, Nov:S2, Dec:S3), S 1 =  X  , S 2 =  X  , S 3 =  X  ,S2  X  0.9  X  S1, S3  X  0.9  X  S2
The reason is that the three atoms in the body of the first rewritten query all have the same values for ( storeID, year) ,whichisthekeyfor salesInfoView .Hence,these atoms are represented by a single tuple in the view. In re-lational terms, this optimization eliminates (multiple) self-joins of salesInfoView , further reducing the execution time by a factor of 3 or more, for an overall reduction of 18 to 36 times in execution time. Note that this additional opti-mization becomes possible by the knowledge of the key for the restructured view, which was determined by techniques discussed in the previous section. Query optimization using materialized views has become standard practice in commercial database systems in recent years [2]. Some of the earlier works on query optimization using regular materialized views include [7, 13, 26]. The approach in [7] is based on safe substitutions , which is ba-sically an application of the containment-mapping concept [4]. Optimization of aggregate queries is discussed in [13]. Their approach is based on syntactic transformations of a query to make (a portion of) it match a view. The approach in [26] is a semantic approach. [26] presents conditions for a view to be usable is answering a query, and gives algorithms for rewriting queries in terms of usable views.

Other recent works on query optimization using materi-alized views include [3, 11, 12, 29] and references therein. These contributions are in using regular materialized views in query optimization. Our work, in contrast, presents a general framework for treat ing in a uniform way both regu-lar and restructured views.

Restructuring , that is, representing the same information in different structures where data in one representation can be represented as metadata in another, has been studied ex-tensively for relational databases (for example, [9, 14, 18, 19, 20, 21, 23]). In [19, 20, 21, 23] a logic-based language, as well as an extension to SQL, called schemaSQL , have been pre-sented. These languages treat data and metadata uniformly, allowing queries that involve data and metadata and restruc-tured view definitions. [14] studied an algebraic language and introduced four rest ructuring operations, fold , unfold , split ,and unite (the unfold and fold operations have also been called pivot and unpivot in the literature [9]). An ex-tended relational algebra that includes the four restructuring operations was introduced in [22], and used for schemaSQL query processing and optimization. Algebraic equivalences of the extended relational algebra (that includes the restruc-turing operations) have been studied in [9, 10]. These equiv-alences can be used for generating equivalent queries in a cost-based query optimizer. Commercial database systems ( e.g. , [9]) have implemented restructuring capabilities.
A restricted form of query optimization using restructured views has been studied in [27]. This approach is based on the notion of canonical schema , where all information of in-terest is represented as data (rather than metadata). The authors argue that for each (restructured) view V ,anda set of queries Q on V , there exists a canonical schema S that represents all information of interest (with respect to Q ) as data. [27] provides algorithms to rewrite a SQL query on a restructured view as a SQL query on its corresponding canonical schema, and vice versa. [27] also provides experi-mental studies that show that using restructured views can significantly reduce query-execution times. The formulation in [27] does not address the question of view usability, as the view and its canonical schema represent the same in-formation in different structures. The rewriting algorithms are also significantly simplified in the setting of [27]. In this paper we study query optimization using restructuring in a much broader setting. Allowing materialized restructured views (as well as regular views) in query optimization can result in significantly more efficient query plans. Our exper-imentation [25] has shown evaluation speedups ranging from 150% to 675% for certain classes of queries.

Research on efficient maintenance of materialized views is abundant and goes back more than two decades. The prob-lem of incremental maintenance of restructured views has been studied by Koeller and Rundensteiner [16, 17]. They use schemaSQL and the extended algebra of [22], and de-vise algorithms to propagate updates through the operators of the algebra, considering data as well as schema updates. We have presented a general framework for query optimiza-tion using materialized views that treats regular and restruc-tured views in a uniform manner and is applicable to SQL select-project-join queries and views with or without aggre-gation. We showed that our framework provides signifi-cant improvements over optimization that uses only regular views. In addition, we presented techniques to derive key constraints for views, and discussed how to use this knowl-edge in further query optimization. It is straightforward to integrate all the algorithms and techniques proposed in this paper into standard query-optimization algorithms.
There are several directions for future investigation. One is the view-selection problem, namely how to decide which views to materialize given some knowledge of the typical query workload. This problem should be revisited given that the addition of restructured views to query optimiza-tion results in an expanded space of views to choose from. The problem of view selection using restructured views is also relevant in data warehousing, in deciding which views to maintain in a data-warehousing application.

The problem of efficiently determining integrity constraints in views should also be investigated further. Our approach is based on verifying whether a constraint holds in a view. In this approach we need to  X  X uess X  which constraints are likely to hold in the view. It seems conceivable to use the knowledge of constraints on base tables, plus the view defi-nitions, to reduce the space of the constraints to verify. [1] F.AfratiandR.Chirkova.Selectingandusingviews [2] Sanjay Agrawal, Surajit Chaudhuri, and Vivek R. [3] R.G. Bello, K. Dias, A. Downing, J.J. Feenan Jr., J.L. [4] Ashok K. Chandra and Philip M. Merlin. Optimal [5] S. Chaudhuri and U. Dayal. An overview of data [6] S. Chaudhuri and M. Y. Vardi. Optimization of real [7] Surajit Chaudhuri, Ravi Krishnamurthy, Spyros [8] Sara Cohen, Werner Nutt, and Alexander Serebrenik. [9] Conor Cunningham, Goetz Graefe, and C  X  esar A. [10] Keir B. Davis and Fereidoon Sadri. Optimization of [11] D. DeHaan, P.- X  A. Larson, and J. Zhou. Stacked [12] J. Goldstein and P.- X  A. Larson. Optimizing queries [13] Ashish Gupta, Venky Harinarayan, and Dallan Quass. [14] Mark Gyssens, Laks V. S. Lakshmanan, and Iyer N. [15] Alon Y. Halevy. Answering queries using views. The [16] Andreas Koeller and Elke A. Rundensteiner.
 [17] Andreas Koeller and Elke A. Rundensteiner.
 [18] Ravi Krishnamurthy, Witold Litwin, and William [19] Laks V. S. Lakshmanan, Fereidoon Sadri, and Iyer N. [20] Laks V. S. Lakshmanan, Fereidoon Sadri, and Iyer N. [21] Laks V. S. Lakshmanan, Fereidoon Sadri, and Iyer N. [22] Laks V. S. Lakshmanan, Fereidoon Sadri, and [23] Laks V. S. Lakshmanan, Fereidoon Sadri, and [24] Werner Nutt, Yehoshua Sagiv, and Sara Shurin. [25] Stephen P. Slocum. Optimizing SQL and SchemaSQL [26] Divesh Srivastava, Shaul Dar, H. V. Jagadish, and [27] Subbu N. Subramanian and Shivakumar [28] Transaction processing performance council: TPC [29] M. Zaharioudakis, R. Cochrane, G. Lapis,
