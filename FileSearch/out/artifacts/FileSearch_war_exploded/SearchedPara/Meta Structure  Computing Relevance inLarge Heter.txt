 A heterogeneous information network (HIN) is a graph model in which objects and edges are annotated with types. Large and com-plex databases, such as YAGO and DBLP, can be modeled as HINs. A fundamental problem in HINs is the computation of closeness, or relevance , between two HIN objects. Relevance measures can be used in various applications, including entity resolution, rec-ommendation, and information retrieval. Several studies have in-vestigated the use of HIN information for relevance computation, however, most of them only utilize simple structure, such as path, to measure the similarity between objects. In this paper, we pro-pose to use meta structure , which is a directed acyclic graph of object types with edge types connecting in between, to measure the proximity between objects. The strength of meta structure is that it can describe complex relationship between two HIN objects (e.g., two papers in DBLP share the same authors and topics). We de-velop three relevance measures based on meta structure. Due to the computational complexity of these measures, we further design an algorithm with data structures proposed to support their evaluation. Our extensive experiments on YAGO and DBLP show that meta structure-based relevance is more effective than state-of-the-art ap-proaches, and can be efficiently computed. Heterogeneous information networks (HINs), such as DBLP [8], YAGO [15], DBpedia [1] and Freebase [2], have recently received a lot of attention. These graph data sources contain a vast number of inter-related facts, and they are used to facilitate the discovery of interesting knowledge [5, 7, 12, 13]. Figure 1 illustrates an HIN, which describes the relationship among entities of different types (e.g., author, paper, venue and topic). For example, Jiawei Han ( a 2 ) has written a VLDB paper ( p 2 , 2 ), which mentions the topic  X  efficient  X  ( t 3 ).

Given two HIN objects a and b , the evaluation of their relevance is of fundamental importance. This quantifies the degree of close-ness between a and b . In Figure 1, Jian Pei ( a 1 ) and Jiawei Han ( a 2 ) have a high relevance score, since they have both published pa-pers with keyword  X  mining  X  in the same venue ( KDD ). Relevance v finds its applications in information retrieval, recommendation, and clustering [18, 22]: a researcher can retrieve papers that have high relevance in terms of topics and venues in DBLP; in YAGO, rele-vance facilitates the extraction of actors who are close to a given director. As another example, in entity resolution applications, du-plicated HIN object pairs having high relevance scores (e.g., two different objects in an HIN referring to the same real-world person) can be identified and removed from the HIN.

Prior works. To measure the relevance between two graph ob-jects, neighborhood-based measures such as common neighbors and Jaccard X  X  coefficient were proposed [9]. Other graph-theoretic measures that are based on random walks between objects include Personalized PageRank [3] and SimRank [6]. These measures do not consider object and edge type information in an HIN. To handle this information, the concept of meta paths has been recently pro-posed [7, 18]. A meta path is a sequence of object types with edge types in between. Figure 2(b) illustrates a meta path P states that two authors ( A 1 and A 2 ) are related by their publica-tions in the same venue ( V ). Another meta path P 2 says that two authors have written papers containing the same topic ( T ). Based on a meta path, several relevance measures, such as PathCount , PathSim , and Path Constrained Random Walk (PCRW) [7, 18] have been proposed. These measures have been shown to be better than those that do not consider object and edge type information.
Meta structures. We propose a novel concept, named meta structure , to depict the relationship of two graph objects. This is essentially a directed acyclic graph of object and edge types. Fig-ure 2(b) illustrates a meta structure S , which depicts that two au-thors are relevant if they have published papers in the same venue, and have also mentioned the same topic. A meta path (e.g., P P ) is a special case of a meta structure. However, a meta path fails to capture such complex relationship that can be conveniently expressed by a meta structure (e.g., S ). Our experiments also show that meta structures are more effective than meta paths.
We provide a sound definition for meta structure. This is not straightforward, since a meta structure can be complex. We then present three relevance measures based on meta structures. These measures vary in the way that the relevance is computed. Given a meta structure S , the StructCount evaluates the number of sub-graphs that matches S ; the Structure Constrained Subgraph Ex-pansion (SCSE) simulates the process of subgraph expansion re-stricted on S ; the Biased Structure Constrained Subgraph Expan-sion (BSCSE) is a generalization of StructCount and SCSE .
A challenge of these new measures is their high computational cost. In general, evaluating these measures requires a subgraph matching operation over an HIN. In a typical HIN (e.g., YAGO) that contains millions of objects and edges, this can be very ex-pensive. Moreover, an application (e.g., clustering) may require computing relevance for many object pairs. Hence, it is important to ensure that these relevance measures can be efficiently evaluated. To tackle this challenge, we design a recursive traversal algorithm with two data structures (called Compressed-ETree and i-LTable ) to improve the efficiency of relevance computation.

To validate our approaches, we have performed extensive ex-periments on YAGO and DBLP. The results show that our three meta structure measures are more effective in expressing relevance than meta path based approaches. Our algorithms also enable meta structure relevance to be computed efficiently on large graphs, yield-ing similar runtime cost to meta path measures.

The rest of this paper is as follows. We describe the HIN model and summarize existing meta path based approaches in Section 2. We introduce the meta structure in Section 3. We then define rele-vance measures based on meta structures in Section 4. We develop a recursive algorithm and two data structures to facilitate comput-ing relevance measures in Section 5. Section 6 presents our exper-iment results. We conclude our study in Section 7.
Let us now review the HIN model in Section 2.1. We then sum-marize existing meta path approaches in Section 2.2.
A Heterogeneous Information Network (HIN) , proposed in [18], is a directed graph G = ( V,E ) with an object type mapping func-tion  X  : V  X  L and a link type mapping function  X  : E  X  R , where each object v  X  V belongs to an object type  X  ( v )  X  L , and each link e  X  E belongs to a link type  X  ( e )  X  X  .
 Figure 1 illustrates an HIN, which is also a bibliography network. A paper object can link (or be linked) to its authors, a venue and its related topics. Note that multiple edges of distinct types between two objects may exist.

D EFINITION 1. HIN Schema [18] . Given an HIN G = ( V,E ) with mappings  X  : V  X  L and  X  : E  X  R , its schema T G is a directed graph defined over object types L and link types R , i.e., T G = ( L , R ) .

The HIN schema expresses all allowable link types between ob-ject types. Figure 2(a) shows the schema of the HIN defined in Figure 1, where the nodes A , P , T and V correspond to author, paper, topic, and venue, respectively. There are also different edge types in the schema, such as  X  publish  X  and  X  write  X .

A meta path [18], denoted by P , is essentially a path defined on an HIN schema T G , with the types of source object and target object on both ends of the path. For example, based on the schema in Figure 2(a), a meta path APV PA ( P 1 in Figure 2(b)) describes the relationship of two authors (source and target objects) who have published papers at the same venue. An instance of the meta path in the HIN of Figure 1 is a 1  X  p 1 , 2  X  t 2  X  p 2 , 1  X  a we use lower-case letters (e.g., v 1 ) to denote objects in an HIN and upper-case letters (e.g., V ) to denote object types.

Given a source object o s  X  V , a target object o t  X  V and a meta path P , meta path relevance measures have been proposed to evaluate the relevance between o s and o t :  X  PathCount [18] : the number of meta path instances of P con-necting o s and o t .  X  PathSim [18] : a normalized version of PathCount, whose value is between 0 and 1.  X  PCRW [7] : the probability that a random walk restricted on P starting from o s would arrive at o t .

Researchers have recently studied the use of meta paths in search and mining tasks, including top-k search [18], link prediction [16, 17, 20], clustering [4, 19], and recommendation [10, 11, 21]. As pointed out in [18], meta paths can be provided by experts who are familiar with the HIN schema. More recently, a meta path discov-ery algorithm has been proposed [12], where users provide example instances of source and target objects, based on which meta paths are derived automatically.

Drawbacks of meta paths. Although meta paths have been shown to be useful in different applications, they can only express simple relationship between source and target objects. As illus-trated in Figure 2(b), a complex relationship ( S ) between two au-thors cannot be captured by a path between them. To solve this problem, a straightforward way is to decompose S into two meta paths (i.e., P 1 and P 2 ). The relevance functions of two given author objects are computed for P 1 and P 2 separately, then the relevance based on S is a linear combination of the relevances based on P and P 2 [7, 10, 12]. However, this simple approach overlooks the problem that some nodes in S (e.g., P 1 ) are shared by two or more edges; decomposing S into two separate meta paths results in a loss of this information. In this example, the node P 1 in S refers to a single paper. However, when S is decomposed, the corresponding P 1 nodes in meta paths P 1 and P 2 can mean different papers. This can yield inaccurate relevance results. As shown in Table 1, using the linear combination approach, existing meta path measures re-fact, (1) a 1 and a 2 have papers ( KDD 0 07 and KDD 0 15 ) both mention-ing  X  mining  X  and published in the KDD venue; and (2) none of the papers of a 2 and a 3 are published in the same venue and have the same topic. Hence, ( a 2 , a 1 ) should have a higher relevance score than ( a 2 , a 3 ). The linear combination approach fails to recognize these differences, and mistakenly gives the same relevance for ( a a ) and ( a 2 , a 3 ). This calls for a better measure to handle such complex relationship, as discussed next.
The meta structure, designed to capture complex relationship be-tween two HIN objects, is defined as follows.

D EFINITION 2. Meta Structure . A meta structure S is a di-rected acyclic graph (DAG) with a single source node n with in-degree 0) and a single sink (target) node n t (i.e., with out-degree 0), defined on an HIN schema T G = ( L , R ) . Formally, S = ( N,M,n s ,n t ) , where N is a set of nodes and M is a set of edges. For any node x  X  N , x  X  L ; for any link ( x,y )  X  M , ( x,y )  X  X  .

An example meta structure S is shown in Figure 2(b). We can see that S is a DAG, with source node n s = A 1 (in-degree 0) and target node n t = A 2 (out-degree 0).

In Definition 2, a meta structure has a single source node and a single target node. Otherwise, there exists at least one node v such that there is no path from n s to n t that goes through v . Since v does not affect the relationship between n s and n t , v can be removed from S .

D EFINITION 3. Instance of Meta Structure . Given an HIN G and meta structure S = ( N,M,n s ,n t ) , an instance s of meta structure S on G is a subgraph of G , denoted by s = ( N s such that there exists a mapping for s , h s : N s  X  N satisfying the following constraints:  X  Object Correspondence: for any object v  X  N s , its object type  X  ( v ) = h s ( v ) ;  X  Link Correspondence: for any link ( u,v )  X  ( /  X  ) M s ( h s ( u ) ,h s ( v ))  X  ( /  X  ) M .
Figure 3 illustrates two instances of meta structure S in Fig-ure 2(b), where o s = a 2 for both cases.

Constructing a meta structure. In this paper, we assume that the meta structure is given. We outline several possible solutions that can be used to define a meta structure; their details are left for future work.  X  Develop a Graphical User Interface (GUI) that provides drawing tools to allow meta structures to be conveniently specified.  X  Use an existing graph query. For example, SPAQRL [14] is a RDF language that allows query graphs to be expressed. Since a meta structure can also be specified as a query graph, SPAQRL can be used to represent a meta structure. Meta structure relevance computation operations can also be defined on SPARQL.  X  Synthesize meta paths. A meta structure can also be constructed by synthesizing existing meta paths. For example, from two meta paths P 1 and P 2 in Figure 2(b), we can form meta structure S by combining the common nodes A 1 , P 1 , P 2 , A 2 in P 1 and P
The above solutions assume that the user has some knowledge about the HIN schema and meta structures. Once these meta struc-tures are defined, they can be stored in the system for non-expert users to choose. Recently, an example-based algorithm has been recently developed in [12], where a user first provides some exam-ple pairs of relevant source and target objects. The algorithm then discovers possible meta paths that best explain the relationship be-tween the example pairs. It would be interesting to investigate how this method can be extended to support automatic discovery of meta structures.
Given an HIN G = ( V,E ) and a meta structure S , we define the relevance function for a source object o s  X  V and a target object o  X  V as follows: where f ( o s ,o t | s ) is a relevance measure defined on some instance s of meta structure that conforms to S . Here, we use s  X  S to denote the set of all instances of S on G .

For example, given HIN G in Figure 1, and meta structure S in Figure 2(b), two possible instances of S are shown in Figure 3. Let us define f ( o s ,o t | s ) = 1 if and only if h s ( o h ( o t ) = n t . Then, s ( a 2 ,a 1 |S ) = 1 and s ( a 2 ,a
We can now define the Relevance Search Problem that we intend to study in this paper.

D EFINITION 4. Relevance Search Problem . Given an HIN G = ( V,E ) , a meta structure S = { N,M,n s ,n t } , a relevance mea-sure f (  X  ) , and a source object o s  X  V , return a ranked list of target objects in decreasing order of s ( o s ,o t |S ) , such that for any o the list, s ( o s ,o t |S ) &gt; 0 .

The relevance search problem is prevalent in many applications, such as information retrieval and recommendation. For example, an author can use meta structure S in Figure 2(b) to find out a list of potential co-authors. In our experiments, we also study this problem in the context of entity resolution, ranking, and clustering. We remark that a useful variant of this problem is to return the top-k target objects (i.e., those whose relevance scores are among the k highest), where k is specified by the user.
In this section, we show how the relevance measures f ( o based on a meta structure instance s can be defined. Specifically, we first define two meta structure-based relevance measures, Struct-Count and Structure Constrained Subgraph Expansion (SCSE) . Then, we propose a variant of SCSE named Biased Structure Constrained Subgraph Expansion (BSCSE) , which is a generalization of Struct-Count and SCSE . Finally we analyze the recursive tree of BSCSE in detail and give an explicit definition of f ( o s ,o t
A straightforward relevance measure is to count the number of meta structure instances in the graph that have o s ( o t (target) node:
D EFINITION 5. StructCount . Given an HIN G = ( V,E ) , a meta structure S = ( N,M,n s ,n t ) , a source object o s get object o t , the value of StructCount is defined as the number of instances of s  X  X  , such that o s and o t are mapped to n S , respectively. Recall the mapping function h s (  X  ) defined in Def-inition 3. Formally, for the relevance measure f of StructCount, f ( o s ,o t | s ) = 1 if there exists a mapping function h that h s ( o s ) = n s and h s ( o t ) = n t .

Take the HIN G in Figure 1 and the meta structure S in Fig-ure 2(b) as an example. If we set o s = a 2 and o t = a 1 StructCount of S on G is 1, i.e., StructCount ( a 2 ,a 1 |S ) = 1 . The reason is that there is only one instance, i.e., s 1 in Figure 3 that correctly maps a 2 to A 1 and a 1 to A 2 .
 We can directly use StructCount to measure relevance on HINs. However, just as PathCount in meta path-based framework, the value of StructCount is not bounded. This biases highly visible objects (i.e., objects with higher degrees tend to have larger Struct-Count values). This could be useful when we favor popular objects, but in some applications where we favor highly relevant objects in-stead of popular ones, such as co-author recommendation, Struct-Count is not suitable.
The fact that StructCount is a biased measure motivates us to de-fine another relevance measure, named Structure Constrained Sub-graph Expansion (SCSE) . Intuitively, SCSE models the probability that the source object o s would expand to an instance of S that cov-ers the target object o t . As the value of SCSE is between 0 and 1, it removes the bias of highly visible nodes.

Before defining SCSE, we first need to define a concept of layer for meta structure.

D EFINITION 6. Layer of Meta Structure . Given a meta struc-ture S = ( N,M,n s ,n t ) , we can partition its nodes w.r.t. their topological order in S . Specifically, we denote by S [ i ]  X  N as the nodes of the i -th layer, and by S [ i : j ] ( 1  X  i  X  j ) as the nodes from the i -th to the j -th layer. We denote by d S the number of lay-ers, thus S [1 : d S ] = N . Note that S [  X  ] is a partition of nodes in N , thus for any i 6 = j , S [ i ]  X  X  [ j ] =  X  .

For example, the meta structure S in Figure 2(b) has d S = 5 layers. That is, S [ i ] for 1  X  i  X  5 are { A 1 } , { P 1 and { A 2 } , respectively.

Given an HIN G and a meta structure S , starting from a source object o s  X  V , we can generate all possible instances s  X  S fol-lowing the layers of S . For example, given an HIN G (Figure 1) and a meta structure S (Figure 2(b)), starting from an instance o we can generate all the instances of s  X  X  on G by recursively ex-panding subgraph of G as shown in Figure 4.

In order to define the process of subgraph expansion, we denote by  X  ( g,i | S ,G ) the ( i + 1 )-th layer X  X  instances expanded from g  X  S [1 : i ] on G . For example, if g is the graph 3(a) in Figure 4, then  X  ( g, 3 | S ,G ) is a set containing the graphs 4(a) and 4(b) because they are instances of S [1 : 4] expanded from g .
Based on these notations, we now turn to a more unbiased mea-sure, defined below.

D EFINITION 7. Structure Constrained Subgraph Expansion (SCSE) . Given an HIN G = ( V,E ) , a meta structure S , a source object o s  X  V and a target object o t  X  V , the SCSE of a i -th layer subgraph g  X  G is defined recursively as follows: SCSE ( g,i |S ,o t ) = where the base case is the instance at layer d S . SCSE ( g,d = 1 if and only if there exists a mapping function h g for g such that h ( o t ) = n t . We are interested in SCSE ( o s , 1 |S ,o For example, given the HIN G of Figure 1, meta structure S in Figure 2(b), and o s = a 2 , o t = a 1 , starting from o s process of subgraph expansion in Figure 4. In the last layer, i.e., the base case, only 5(b) correctly maps a 1 to A 2 (5(a) and 5(c) do not have a 1 ). In the first layer, we derive the value of our interest
We can see that SCSE models the probability that an initial sub-graph of G (i.e., o s ) would expand to an instance of S covering o Obviously, the value of SCSE is between 0 and 1, so it can remove the bias to highly visible objects.
From the definitions above, we observe that both StructCount and SCSE restrict search to subgraphs that can strictly match the meta structure. For example, StructCount measures the absolute number of such subgraphs, while SCSE applies graph expansion from source object o s to an instance covering the target object o Each measure has its own pros and cons. To make the best of both measures and combine them in a unified framework, we propose a variant of SCSE, named Biased Structure Constrained Subgraph Expansion (BSCSE) , defined as follows.

D EFINITION 8. Biased Structure Constrained Subgraph Ex-pansion(BSCSE) . Given an HIN G = ( V,E ) , a meta structure S , a source object o s  X  V and a target object o t  X  V , the BSCSE of a i -th layer subgraph g  X  G is defined recursively as follows: BSCSE ( g,i |S ,o t ) = where for the base case, i.e., i = d S , we have BSCSE ( g,d = 1 if and only if there exists a mapping function h g for g such that h ( o t ) = n t . We are interested in BSCSE ( o s , 1 |S ,o
Note that  X   X  [0 , 1] is a bias factor to balance the weight be-tween StructCount and SCSE: (1) a smaller  X  cares more about the number of subgraphs that match the meta structure (if  X  = 0 , BSCSE reduces to StructCount); (2) a larger  X  focuses more on the possibility that a random expansion can cover the target object (if  X  = 1 , BSCSE reduces to SCSE). On the other hand, as we have combined StructCount and SCSE into a unified BSCSE framework, we can focus on the computation of BSCSE only.
In this subsection, we analyze the expanding process of BSCSE, and give an explicit expression of the relevance measure f ( o for BSCSE.

As we can see in Definition 8, the computation of BSCSE simu-lates the process of subgraph expansion. If we track the expansion path from the original source object o s to an instance s  X  X  , we can get a recursive tree of subgraph expansion. We define this recursive tree ETree , as follows:
D EFINITION 9. ETree . Given an HIN G , a meta structure S and a source object o s , the structure ETree is denoted as ETree = ( T,L,w ) , where  X  T : the tree node set, where each node is a subgraph of G ;  X  L : the edge set;  X  w : a function w (  X  ) that maps a tree node v  X  T to its weight w ( v ) . The weight is defined based on v  X  X  parent u , i.e., ( u,v )  X  L . It considers (1) u  X  X  weight w ( u ) , and (2) the #children of u , i.e., |{ v 0 | ( u,v 0 )  X  T }| . Specifically, we have
For example, given G in Figure 1 and S in Figure 2(b), the ETree that starts from a 2 is shown in Figure 4. We can see that the root is a 2 , and each edge links a subgraph to one of its one layer expan-sion w.r.t. S . For example, a 2 can either expand to { a { a 2 , p 2 , 2 } w.r.t. S , and their weights are both 1 / 2 (with depth d S ) contain all instances of S starting from a
Next, we analyze two properties of ETree, related to its height (Property 1) and node (Property 2), which help to express our value of interest, i.e., BSCSE ( o s , 1 |S ,o t ) (Theorem 1). P ROPERTY 1. The height of ETree is at most d S  X  1 .

P ROOF . The root of ETree is the source object o layer of S . Suppose g 1 = o s ,g 2 ,  X  X  X  ,g S X  1 ,g k = v is a path from o to a leave nodes v , each step means a one layer expansion of subgraph. We have at most d S  X  1 one layer expansions from o v . Thus, the height of ETree is at most d S  X  1 .
 P ROPERTY 2. Each node of ETree at depth d is an instance of S [1 : d + 1] and each instance s of S [1 : d + 1] with h must be a node of ETree at depth d .

P ROOF BY INDUCTION . When d = 0 , the root o s is only an instance of S [1 : 1] with h ( o s ) = n s . Suppose Property 2 holds for d = k . Assume that u is a node of ETree at depth k + 1 and its parent node is v . Then, u  X   X  ( v,k + 1 |S ,G ) as ( v,u )  X  L , so u must be an instance of S [1 : k + 2] . On the other hand,  X  s  X  X  [1 : k + 2] , s 0 = s  X  X  v  X  s | h s ( v )  X  X  [ k + 2] } must be an instance of S [ k + 1] , which means s is a one layer expansion of s . So s is a node of ETree at depth k + 1 .

T HEOREM 1. Given a meta structure S = ( N,M,n s ,n t ) , a souce object o s  X  V and a target object o t  X  V ,
P ROOF . Suppose s is an instance of S and g 1 = o s , g g
S = s is the path of ETree from o s to s . According to the recur-sive definition of BSCSE ,
According to Properties 1 and 2, s must be a leaf node at depth d  X  1 , and P must be a path of ETree from root o s to s . According can finally derive
Based on the proof of Theorem 1, we know that the relevance measure f ( o s ,o t | s ) for BSCSE is:
Take the HIN in Figure 1 for example, we show the relevance values for two pairs of authors with our three measures in Table 1. We can see that our three meta structure relevance measures can better handle complex relationship, i.e., the relevance score of ( a a ) is larger than ( a 2 , a 3 ). This is because the meta structure can make use of the information of common nodes in different meta paths. As we know, BSCSE is a generalization of StructCount and SCSE. Thus in this section, we study how to efficiently perform relevance search with BSCSE (also works for StructCount and SCSE) w.r.t. a source object o s , based on a given S . We first propose a traver-sal algorithm on ETree (Section 5.1), and then further improve its efficiency by proposing two optimizations (Section 5.2).
In order to calculate BSCSE ( o s , 1 S ,G ) , an initial idea is to visit all the leaf nodes of ETree and accumulate the weights of all s  X  S for which h s ( o t ) = n t . Based on this, we develop a recur-sive algorithm, called Traversal (Algorithm 1) to compute BSCSE. It first checks whether the base case is caught, i.e., if g is already an instance of S . In this case, the instance g with its weight w are re-turned (steps 1-2). The rest of the algorithm consists of two phases. The first phase (steps 3-11) calculates the set  X  ( g,layer | S ,G ) and the second phase (steps 12-17) recursively calls the algorithm for each g 0  X   X  ( g,layer |S ,G ) and accumulates the results.
In the first phase, for each node n at the ( i + 1) -th layer of S , we consider all nodes n 0 such that ( n 0 ,n )  X  M , check its instance object g [ n 0 ] and calculate possible instance objects w.r.t. node n (steps 6-8). Then, we calculate the instance objects w.r.t. n that satisfy all the dependency constrains (step 9). Finally, we compute the Cartesian product over the possible instances of each node at layer ( i + 1) , and derive the set of possible expansions  X  (step 11).
In the second phase, we first record the weight w 0 for layer ( i + 1) according to Definition 9 (step 12). Then, for each possible expansion, we expand the subgraph g to g 0 (step 15) and recursively call the algorithm on the expanded subgraph g 0 to get all instances of S and their corresponding weights (step 16).

For example, suppose we are traversing the ETree in Figure 4 based on the meta structure S in Figure 2(b). We set layer as 3 and g as the graph in 3(b). In the first phase, there is only one meta node n at the 4th layer, i.e., n = P 2 , and n depends on two nodes, i.e., V and T . Then, we can see that g [ V ] = v 3 , and it has two neighbors p 2 , 2 and p 3 , 2 ; g [ T ] = t 3 , and it has two neighbors p { p 2 , 2 } , which means that there is only one possible instance object for P 2 . At the second phase, we have w 0 = w because there is only one possible expansion. We then compute the expanded subgraph g = g  X  X  p 2 , 2 } , and recursive call Traversal ( G, S ,g
We propose two optimizations on the traversal algorithm to boost the efficiency. First, we devise a compressed representation of ETree to reduce the redundancy. Then, we propose an index struc-ture to further accelerate the process of online query. Algorithm 1: Traversal Algorithm Figure 5: A Compressed-ETree.
 According to Property 2, at an internal node v of ETree with depth d , we need to maintain an instance of S [1 : d + 1] . However, to further expand v , we do not necessarily need the information of the whole instance. Instead, we just need to maintain a subset of v on which the layers of S after d have dependencies. For example, in graph 2(a) (Figure 4), we do not need to maintain the whole graph; instead, { p 2 , 1 } is enough to represent it as the rest of meta structure only depends on node P 1 .
 Based on this idea, we develop a compressed structure, called Compressed-ETree , which is shown in Figure 5. We can see that it is more concise compared to ETree (Figure 4). Thus by traversing Compressed-ETree instead of ETree, we can reduce the computa-tion cost and required space for each tree node.

To derive the Compressed-ETree , intuitively we have to pre-compute and maintain the necessary nodes for each layer of meta structure, which we call the dependency set . We use a map struc-ture to store the nodes that need to be maintained at each layer. The details are shown in Algorithm 2. Specially, for each node n we first get the maximal layer that the node can reach, i.e., depend-ing on n 0 (step 3). Then we add n 0 to the corresponding layers of D (steps 4-5). After all nodes have been added to D , we can get the set of nodes we need to maintain at layer i in D [ i ] . Take S in Figure 2(b) as an example; the dependency set D [ i ] for i = 1 to 5 is { A 1 } , { P 1 } , { V,T } , { P 2 } and { A 2 } , respectively. 1
By considering the dependency set D [  X  ] , we can improve the performance by traversing Compressed-ETree instead of ETree. The algorithm is slightly different from Algorithm 1. At step 16, instead Algorithm 2: Pre-compute Dependencies Input : meta structure S .

Output : D [  X  ] , where D [ i ] is a set of nodes we need to
Initialize D [ i ] =  X  for i = 1 , 2 ,...,d S ; for n 0  X  N do 4 for i = layer ( n 0 ) to d do 5 D [ i ] = D [ i ]  X  X  n 0 } ; return D ; of calling it recursively on a whole subgraph g 0 , we can just main-tain a subset of g 0 which is in the dependency set D [ layer + 1] . Compressed-ETree can reduce the computation for each node of ETree, but it still has the same number of tree nodes. Especially there is much redundancy in the computation if we have a batch of queries to answer. For example, when computing BSCSE for two source objects a 2 and a 1 in Figure 1, we have to traverse two Compressed-ETrees for a 2 and a 1 , respectively. When traversing one for a 2 (Figure 5), we visit a sub-tree with 3(a) as root; mean-while, we would visit the same sub-tree while traversing the other Compressed-ETree for a 1 . This is because the last two layers of the meta structure S [4 , 5] only depend on S [3] (instead of S [1 , 3] ).
By considering this idea, we propose a novel data structure called i-LTable , which stores all leaf nodes for a sub-tree of the Compressed-ETree in advance. Once we traverse to the i -th layer, we can get the information of leaf nodes directly from the i-LTable, which saves the search time from the ( i + 1) -th to the last layer.
Given an S , the i-LTable w.r.t. layer i is a data structure that maps each node instance v of Compressed-ETree at layer i to all the node instances in the last layer (with v as an ancestor). To be specific, the keys of i-LTable are the instances of the stored nodes in D [ i ] , and the values are the distributions of weights over all possible target objects. Given S in Figure 2(b), consider the Compressed-ETree in Figure 5, the corresponding 3-LTable is shown in Table 2. For example, as D [3] = { V,T } , and the target node n t = A keys of 3-LTable are pairs of venues and topics and the values are distributions of weights on authors.
 Next we study how to build an i-LTable for a given meta structure S offline. First, we address the selection of i , i.e., which layer the i-LTable should be built on, and then we deal with how to build indexes offline and conduct queries online.
 Choosing An Appropriate i . If we have built i-LTable on the i -th layer, then we only need to search the Compressed-ETree for the top i layers. Intuitively the choice of i is a trade-off between time and space. For a smaller i , the number of nodes that needs to be visited is smaller, resulting in efficient processing. However, the number of reachable target objects is large, resulting in larger space requirement. We next list three heuristic methods on how to select i : (1) MinKey : choose i with minimal number of possible key values; (2) Half : choose i = 1 2  X  d S ; (3) Min : choose a minimal i with space budget constraint.
 Building Indexes Offline. After choosing an i , we can start to build the i-LTable, and the details are shown in Algorithm 3. After retrieving the nodes in D [ i ] , we can construct i-LTable by travers-ing the sub-trees of Compressed-ETree for each possible key. Online Query Processing. Once we have built i-LTable, we can speed up the process of online query. The algorithm is similar to Algorithm 3: Building i-LTable Input : HIN G , meta structure S , dependency set D , layer i .
Output : i-LTable for S . initialize i-LTable; for key  X  Q n  X  D [ i ] { v  X  V |  X  ( v ) = n } do 3 i-LTable [ key ]  X  Traversal ( G, S ,key, 1 . 0 ,i ) ; return i-LTable;
S Figure 6: Meta Paths and Meta Structures Used in Experiments. Algorithm 1, except that it only needs to traverse the Compressed-ETree for the top i layers. Then the results can be retrieved directly from i-LTable instead of recursively searching the sub-trees.
We now discuss the experiment results. Section 6.1 describes the experiment setup. We then examine the effectiveness (Section 6.2) and efficiency (Section 6.3) of different relevance measures. We examine two HIN datasets, namely YAGO and DBLP.
 YAGO [15] is a large-scale knowledge graph derived from Wikipedia, WordNet and GeoNames. We use its  X  X ORE Facts X , i.e., YAGO-Core [12], which consists of 4 million facts (edges) of 125 types, made from 2.1 million objects. These entities have 365,000 types. DBLP is a bibliographic network. It contains four types of objects, i.e., paper, author, venue and topic. We use a subset of DBLP, i.e., DBLP-4-Area [12], containing 5,237 papers, 5,915 authors, 18 venues, and 4,479 topics from 4 areas: database, data mining, machine learning and information retrieval. These objects are con-nected by 51,377 edges.
 We compare our relevance metrics (i.e., StructCount, SCSE, and BSCSE) with three representative meta path measures (i.e., Path-Count [18], PCRW [7], and PathSim [18]). These measures employ the meta paths and structures shown in Figure 6. We implement the experiments in C++ on an 8GB memory Mac OS X machine.
We compare the quality of relevance measures in three applica-tions: entity resolution (Section 6.2.1), ranking (Section 6.2.2) and clustering (Section 6.2.3). We then study the properties of meta structures in Section 6.2.4 and Section 6.2.5.
We first perform an entity resolution (ER) task to find pairs of objects in YAGO that refer to the same entity. For example, the two objects Barack_Obama and Presidency_Of_Barack_Obama refer to the same person. Identifying such pairs helps to  X  X lean X  an HIN by deduplicating its entries.

We manually label a small subset of data. We look for (human) object pairs that both have marriage relationship to an object. In total, we get 3020 such pairs, containing 4518 different persons. We consider these as our test data, and manually label their ground truth. We got 44 positive samples (i.e., each object pair refers to the same person), while the remaining 2976 ones are negative.
We use the meta structure S and two meta paths ( P Figure 6(a) to compute the relevance. For each person (out of 4518 ones), we set it as the source object in S , P 1 , P 2 , and use them to find target objects, which can be duplicates. Then, we get all the (target) persons such that the relevance value with respect to the source object is larger than zero. The larger the relevance, the more likely the object pairs refer to the same person. For each relevance measure, we vary the threshold for the relevance values of all returned pairs and plot the Precision-Recall Curve. We then compute the the area under the curve, i.e., AUC.

The AUC values for different metrics are shown in Table 3. Ob-serve that meta structure based measures are more effective than the meta path ones. This is because S is more expressive than a single meta path (i.e., ( P 1 or P 2 ). Here, S limits the results to those per-sons who are married to the same person and affiliated to the same organization, which cannot be represented by P 1 or P 2 alone.
We then study the effectiveness of the linear combination of the two meta paths. The relevance is computed as s =  X   X  s 1  X  )  X  s 2 , where s 1 and s 2 is the relevance derived by P respectively. As shown in Figure 7(a), a linear combination of two meta paths is better than using P 1 or P 2 alone. However, as it does not consider the common nodes in the meta paths (i.e., nodes P and P 2 ), its AUC value, based on the the optimal  X  , is just 0.2920, and is still worse than SCSE (i.e., 0.5640) (Table 3).

We also examine how parameter  X  influences the effectiveness of BSCSE. As shown in Figure 7(b), its AUC is stable for a wide range of  X  values. When  X  = 1 , BSCSE has the best result. This is consistent with our expectation, because entity resolution favors highly relevant objects, instead of popular ones.

We next show the top-10 relevant pairs for PCRW and SCSE in Table 4 (for PCRW, we use a linear combination with optimal  X  , achieving the best AUC value). The pairs in bold are negative samples. We see that PCRW has three negative samples in the top-10 pairs. For example, the reason that Sally Hayfron and Grace Mugabe appear in the result is that they have been married to the same person, and as the weight for the meta path P 1 dominates the other ( P 2 ), this pair has a high score even though these two persons do not satisfy P 2 . This explains why meta path-based measures have lower AUC values than meta structure-based ones.
In our second effectiveness experiment, we perform a task of relevance ranking as follows. We first label the relevance of each pair of venues in DBLP using three levels: 0 for  X  X on-relevant X , 1 for  X  X omewhat-relevant X  and 2 for  X  X ery-relevant X . We consider both the level and the scope of the venues while labeling. For ex-ample, the relevance score for SIGMOD and VLDB is 2 as they are highly relevant. We use the meta structure S and the two meta paths P 1 , P 2 shown in Figure 6(b). Then, we evaluate the quality of the returned ranked list w.r.t. different measures using Normal-ized Discounted Cumulative Gain (nDCG), which is a commonly used measure in ranking quality, and the larger, the better.
The results are shown in Table 3. We can observe that the first meta path P 1 = V PAPV yields better results than the second meta path P 2 = V PTPV on all the three meta path-based mea-sures. However, meta structure-based measures perform better than meta path-based measures on the whole.
Figure 7: Varying Parameters on Different Measures (Entity Resolution). (a)
Figure 8: Varying Parameters on Different Measures (Ranking). (c)
We also compare with a linear combination of the two meta paths. We vary the weight  X   X  [0 , 1] to trade-off P 1 , P the nDCG values of the ranking results. The results are shown in Figure 8(a). Among meta path-based measures, PCRW performs better than PathCount and PathSim. We can see that the quality gets better as  X  increases. This means that the linear combination of two meta paths cannot get better results than P 1 itself.
We further study how parameter  X  influences the ranking quality of BSCSE. We vary  X   X  [0 , 1] and observe the quality of returned ranked list. As shown in Figure 8(b), BSCSE achieves the best nDVG value when  X  = 0 . 8 . In Table 3 we see BSCSE with optimal  X  (0.8) outperforms the linear combination of meta paths.
Similar to the experiment above, given the same meta structure and meta paths in Figure 6(b), in order to further evaluate the qual-ity of relevance values between venues, we perform a task of clus-tering the venues in DBLP. To be specific, we apply K-means on the derived relevance matrixes w.r.t. different measures. We use two evaluation metrics, Normalized Mutual Information (NMI) and Pu-rity (both the larger, the better). The results are shown in Table 3. We can see that SCSE has the best performance over all measures.
We further compare with a linear combination of these two meta paths. We vary the weight  X   X  [0 , 1] to trade-off P 1 , P the clustering accuracy. The results are shown in Figures 9(a)(c). It can be seen that PCRW performs better than PathCount and Path-Sim, and its performance does not vary much with  X  . Again, from Table 3 we observe that a linear combination of two meta paths cannot get better results than P 1 itself. No matter what weight we give, the clustering accuracy of meta path-based measures is no better than SCSE. Figure 10: Meta Structures with Different Semantic Meaning. Table 5: Top-5 Relevant Actors to Clint Eastwood with Different S . We also study how  X  influences BSCSE in the task of clustering. The results are shown in Figures 9(b)(d). We can see that the clus-tering accuracy gets better with a larger  X  . When  X  = 1 , we have the best clustering accuracy.
 We observe that in different tasks (e.g., ranking and clustering), BSCSE achieves the best performance at different values of  X  . This leads to the question of how to set  X  . We can set  X  = 1 for sim-plicity as SCSE (i.e.,  X  = 1 ) has pretty good performances over all the tasks we perform. On the other hand,  X  can be set as a user input, or can be tuned with training data in the experiments.
Different meta structures imply different meanings. We perform a case study on YAGO to show that, with different meta structures, we can find totally different top-k results w.r.t. different relations. Specifically, we query a famous actor and director Clint Eastwood in YAGO with four different meta structures in Figure 10 to find top-5 relevant actors to him.

We make some analysis based on the observations of the top-5 results in Table 5: (1) Sondra Locke ranks very high in the results of S 1 and S 2 , but has low relevance in the results of S This is because S 1 and S 2 are shorter, and they tend to find out ac-tors who directly collaborated with Eastwood, e.g., Sondra Locke. On the other hand, S 3 and S 4 are longer, so they tend to find out famous actors like Matt Damon and Shirley MacLaine. (2) Matt Damon ranks high with S 3 because he collaborated a lot with the actors and creators who had participated in the films directed by Eastwood. (3) Similarly, Shirley MacLaine ranks high with S cause he collaborated a lot with the directors and creators who had participated in the films Eastwood acted in.

We can conclude that, with different meta structure, the top-5 results are different. Although S 1 and S 2 have the same length, S 1 and S 2 are different as S 2 only consider those films with East-wood being the director and actor at the same time, while S looser constraint. Although S 3 and S 4 both have d S = 5 , S considers those films he directs and S 4 only considers those films that he acts in. We want to show that, as meta structure is more complex than meta path, a user can use meta structures with subtle differences to express different relevances.
We study the impact of different sizes of a meta structure. Espe-cially, we study whether the following hold: does larger size (i.e., d ) leads to better quality for a meta structure? To test the effectiveness of different sizes, we use concatena-tions of the meta structure S in Figure 6(b), i.e., S , S Intuitively, with S , two venues are relevant if they share the same authors and the same topics. However, with S 2 and S 4 , the rele-vance becomes more subtle as the meta structures involve remote objects. When the size tends to infinity (  X  ), the top-k results tend to be the global result. We also compare the ranking quality (i.e., nDCG) similar to Section 6.2.2. It is shown in Table 6 that a meta structure with larger size gives worse ranking result.
We perform two experiments to study the efficiency of the algo-rithm and two optimization techniques proposed in Section 5. For ease of presentation, we denote as follows:  X  Traversal+: the Traversal algorithm with Compressed-ETree op-timization (without index);  X  Traversal++: the Traversal+ with index built on it.

In this section, we first compare the executing time of Traver-sal, and Traversal+ with meta path measures. Then, we study the impact of different indexes (i.e., i ) in Traversal++.
We start by comparing the runtime of BSCSE with that of meta path measures. On DBLP, we ran 18 queries using the meta struc-ture and meta paths in Figure 6(b), setting source objects as dif-ferent venues. In addition, we ran 1000 queries starting from ran-domly selected authors using the meta structure and meta paths in Figure 2(b). On YAGO, we ran queries over 1000 randomly se-lected persons based on the meta structure and meta paths in Fig-ure 6(a). We record the average executing time of each bundle of queries as shown in Table 7. We can see that meta path-based mea-sures have different runtime performances for different meta paths. For example, a P 2 query for venues takes 20 times more than a P 1 query for all the three meta path-based measures. Observe that BSCSE is not worse than meta path-based measures in terms of efficiency. In addition, the Compressed-ETree optimization can slightly boost the efficiency as it can reduce the redundancy in the representation.

To further explain this phenomenon, we analyze the average num-ber of instances by the different meta structures and meta paths. As shown in Table 8, the number of instances is proportional to the ex-ecuting time. We can also see that the number of instances of meta structures are small because they are more restrictive compared to meta paths.
We show the time for building the i-LTable offline for different values of i in Figure 11(a). We can see that, as i increases, the time for building the i-LTable decreases. Particularly, if we select i = 1 2 d S = 3 , we need 10 s for building i-LTable.

Figure 11(b) shows the time for online queries using the i-LTable for different values of i ( i = 5 means we do not use i-LTable as d
S = 5 ). We can see that an i-LTable greatly reduces the cost of online queries. Particularly, if we select i = 1 2 d S = 3 , the Traver-sal++ algorithm needs only 0 . 5 ms compared to 2 . 45 ms required by Traversal+.
In this paper, we introduce a notion of meta structure, which is a powerful extension of meta path. Based on meta structure, we introduce a relevance framework on heterogeneous information networks, which can express complex relevance of two objects. In particular, we define two relevance measures under this framework, i.e., StructCount and SCSE. SCSE simulates the process of sub-graph expansion, and it can reduce the bias to highly visible objects. Moreover, we define a unified measure named BSCSE, which com-bines StructCount and SCSE into the same framework. For effi-ciently computing BSCSE, we propose a recursive algorithm along with two optimizations (Compressed-ETree and i-LTable) to boost the efficiency. Experiments on real datasets demonstrate the effec-tiveness and efficiency of our methods.

In the future, we will examine methods for automatically learn-ing meta structures from the knowledge base. We will also study the use of meta structure in different applications, such as citation recommendation and paper reviewer assignment.
 We would like to thank the reviewers for their invaluable com-ments. Reynold Cheng, Zhipeng Huang, and Yudian Zheng were supported by the Research Grant Council of Hong Kong (RGC GRF project 17205115), Nikos Mamoulis was supported by RGC GRF project 715413E, and Yizhou Sun was supported by NSF CA-REER 1453800, Northeastern TIER 1, and Yahoo! ACE Award. [1] S. Auer, C. Bizer, G. Kobilarov, J. Lehmann, R. Cyganiak, [2] K. Bollacker, C. Evans, P. Paritosh, T. Sturge, and J. Taylor. [3] S. Chakrabarti. Dynamic personalized pagerank in [4] J. Chen, W. Dai, Y. Sun, and J. Dy. Clustering and ranking in [5] N. Jayaram, M. Gupta, A. Khan, C. Li, X. Yan, and [6] G. Jeh and J. Widom. SimRank: a measure of [7] N. Lao and W. W. Cohen. Relational retrieval using a [8] M. Ley. Dblp computer science bibliography. 2005. [9] D. Liben-Nowell and J. Kleinberg. The link-prediction [10] X. Liu, Y. Yu, C. Guo, and Y. Sun. Meta-path-based ranking [11] X. Liu, Y. Yu, C. Guo, Y. Sun, and L. Gao. Full-text based [12] C. Meng, R. Cheng, S. Maniu, P. Senellart, and W. Zhang. [13] D. Mottin, M. Lissandrini, Y. Velegrakis, and T. Palpanas. [14] E. Prud X  X ommeaux, A. Seaborne, et al. Sparql query [15] F. M. Suchanek, G. Kasneci, and G. Weikum. Yago: a core [16] Y. Sun, R. Barber, M. Gupta, C. C. Aggarwal, and J. Han. [17] Y. Sun, J. Han, C. C. Aggarwal, and N. V. Chawla. When [18] Y. Sun, J. Han, X. Yan, P. S. Yu, and T. Wu. Pathsim: Meta [19] Y. Sun, B. Norick, J. Han, X. Yan, P. S. Yu, and X. Yu. [20] Y. Yang, N. Chawla, Y. Sun, and J. Hani. Predicting links in [21] X. Yu, X. Ren, Y. Sun, Q. Gu, B. Sturt, U. Khandelwal, [22] X. Yu, X. Ren, Y. Sun, B. Sturt, U. Khandelwal, Q. Gu,
