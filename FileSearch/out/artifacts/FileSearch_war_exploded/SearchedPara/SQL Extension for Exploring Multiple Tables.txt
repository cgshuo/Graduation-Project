 H.2.3 [ DATABASE MANAGEMENT ]: Languages Languages, Management tableset, sql extension, sensor data retrieval We built the sensorbase as a repository for sensor data [5]. The sensorbase is a relational database, where users create tables and upload their own sensornet data to the tables. Figure 1 shows a small subset of sensorbase tables, which are generated by three users. In this paper, it is assumed that all table columns have been normalized; that is, we assume that he columns with the same data type have identical names and their data units are the same as well. 1
Now consider a user who wants to write a query for  X  what is the average temperature of Washington?  X . E v e n i f t h e u s e r may know that all temperature readings are stored in the columns named  X  X emperature X  and all city names are stored in the  X  X ity X  columns, very likely, the user does not know what tables are available in sensorbase and which of them are relevant to the query; here are many tables not only  X 
This research is supported by NSF NeTS-FIND program, award number CNS-0626702.
The column normalization can be done by the sensorbase recommendations on common data types or through schema matching tools [1][4] used, say, by the sensorbase adminis-trator.
 about the temperature, but also about humidity, rainfall, air pollution level, etc., and the temperature data is spread across many tables independently created and uploaded by different users. Furthermore, when there are hundreds of tables relevant to the query, even if the user knows what tables to look up, it is just too cumbersome to explicitly list all tables in the FROM clause.

The main problem of current SQL may be summarized as follows: there is no easy way to  X  X eclaratively specify X  the set of tables to be used for a query . In this paper, we introduce the concept of tableset as an elegant way to specify the tables of interest and run queries on those tables. A tableset is defined as a set of tables. Users first create a tableset composed of relevant tables, run SQL queries on the tableset, and aggregate the results to obtain the final answer. To support this mechanism, we defined seven basic tableset operators as shown in Table 1. In this paper, we will discuss select, project, and merge operators.
 Select operators (  X  ) Tuple-level select operator, denoted as  X  C ( TS ), selects all tuples from each table in the tableset TS that satisfy the condition C . For example, the output of  X  Figure 1, is the tuples whose time column value is  X 2007-11-01 00:00:05 X  as shown in Figure 2. The table-level select operator,  X  T C ( TS ), with the superscript T to indicate that this is the table-level select operator, is used to select the selects tables that has at least one tuple with time= X 2007-11-01 00:00:05 X  , as shown in Figure 2. Table-level conditions can include the hascolumn(X) function, which is evaluated to TRUE if the table has the column X .

Specifying a column in a select condition on a tableset, users are probably not aware of if all tables in the table-set have the column. We deal with conditions on  X  X issing X  columns by assuming that they are evaluated to FALSE. For example,  X  temperature&lt; 73 (  X  ) returns FALSE for every tuple in SensorAHW and SensorBH because they do not have the temperature column.
 Project operator (  X  ) The project operator on a tableset TS ,  X  E ( TS ), is used to keep only certain columns. E is the list of columns to keep in the output. For example, a user can use  X  sid (  X  ) to remove all columns other than sid and obtain the list of all sensor identifiers.

A column listed in E of  X  E ( TS )maynotexistinsome tables in TS . For example, consider  X  sid,temperature (  X  ). Po-tentially, there are three ways to deal with the tables with missing columns. First, all tables with missing columns are dropped in the output. Note that this interpretation can be enforced using the hascolumn() condition. Second, for missing-column tables, we project only on the columns that exist in the tables. We choose to use this interpretation as the default semantic of the tableset project operator with missing columns. For instance, Figure 3 shows the result of  X  sid,temperature (  X  ). Third, for all tables in the output table-set, we add all missing columns and fill in the value NULL for those columns. We use the symbol  X + X  to denote the column that must be added to the output. For example, Merge operators (  X  ) Merge operator on a tableset TS merges all tables in the tableset into a single table. For ex-ample, given a tableset HumiditiesOfAB = { SensorAHW , SensorBH } , X   X  ( HumiditiesOfAB ) returns a single table that has all tuples from SensorAHW and SensorBH . X   X  ( TS ) creates the output table by intersecting the tuples from all tables in TS .Both X   X  ( TS )and X   X  ( TS ) require that all ta-bles in TS have the same schemas. If different, the schemas should be normalized first, with the  X  E ( TS ) operator. Users can create their own tablesets by CREATE TABLE-SET statement. First, users can directly specify the tables that should belong to a tableset, which is useful when users know the exact tables of interest and the number of the ta-bles is small (e.g.,  X  create tableset WashHumiditySensors AS SensorAHW, SensorBH;  X ). In particular, ALLTABLES is a predefined tableset that includes all tables in a database. Second, users can create a tableset from the result tableset from a SELECT statement.
 Figure 4 shows a new syntax of SELECT statement. A SELECT statement may have a tableset in the FROM clause. Then, the conditions in the WHERE clause is interpreted as a tuple-level select condition (i.e.,  X  C ( TS )).
The WITH TABLE clause is used to specify a table-level select condition for  X  T C ( TS ). The WITH TABLE clause can appear only when a tableset appears in the FROM clause. Both WHERE and WITH TABLE clauses can be specified simultaneously. A project operation,  X  E ( TS ), can be per-formed using the SELECT clause. When the MERGED option is specified, all tuples in the output is merged into a single table either using union or intersection (the default is UNION). Once all tuples are merged into a single table, the user can use the standard relational operators.
 The COURGAR [3] and the TinyDB [2] provide users with a single table to query, so that the users avoid exploring and aggregating information across a large number of tables. Our sensorbase and the SQL extension is different to thier systems, in terms of the fact that sensorbase (1) keeps sensor data coming from different data authorities and (2) does not require a centralized view or maintenance effort for the view.
Our SQL extension makes users easily compose queries over a large number of tables. Users can declaratively specify the tables that they are interested in, and easily aggregate instances stored in the multiple tables.
