 Nowadays, more and more organizations are introducing workflow technology to manage their business processes. Setting up and maintaining a workflow man-agement system requires process models w hich prescribe how business processes should be managed. Typically, users are required to provide these models. How-ever, constructing proces s models from scratch is a d ifficult, time-consuming and error-prone task that often requires the involvement of experts. Further-more, there are often discrepancies between the predefined models and those really being executed. Process mining is a n alternative way to construct process models. It distills process models from event logs that are recorded by most transactional information systems, such as ERP, CRM, SCM and B2B. Process mining can also be used to analyze and optimize prefined process models.
In many cases, the benefit of process m ining depends on the exactness of the mined models [1]. The mined models should preserve all the tasks and the dependencies between them that are present in the logs. Although much research This paper focuses on mining non-free-choice constructs. For process models with this kind of construct, the key factor affecting the exactness of the mined models is whether dependencies between tasks c an be mined correctly and completely. There are totally two kinds of dependencies between tasks, i.e., explicit and implicit ones, which will be introduced in detail later.

The rest of this paper is organized as follows. Section 2 gives some prelimi-naries about process mining. Section 3 defines explicit and implicit dependencies between tasks and gives all cases in which implicit dependencies must be detected correctly. Section 4 gives t hree theorems with proofs for detecting implicit de-pendencies. Experimental results are given in Section 5. Section 6 introduces related work and Section 7 concludes this paper and gives our future work. In this section, we give some definitions used throughout this paper. Firstly, we introduce a workflow process modelling language and its relevant concepts. Then we discuss the workflow log in detail and give an example. 2.1 WF-Net In this paper, WF-net is used as the workflow process modelling language, which was proposed in [5]. WF-nets are a subset of Petri nets, which are well under-stood. Note that Petri nets provide a graphical but formal language designed for modelling concurrency. Moreover, Petri nets provide all kinds of routings supported by workflow management systems in a natural way.

Fig. 1 gives an example of a workflow process modelled in WF-net. This model has a non-free-choice construct. The transitions (drawn as rectangles) T represent causal dependencies. A place can be used as pre-condition and/or post-condition for tasks. The arcs (drawn as di rected edges) between transitions and places represent flow relations. In this pr ocess model, there is a non-free-choice and the connected arcs, their common input set is not empty but their input sets are not the same.

We adopt the formal definitions and properties (such as soundness and safe-ness) of WF-net and SWF-net from [5, 6]. Some relative definitions (such as implicit place), properties and firing rules about Petri nets are also described there.

For mining purpose, we demand that each task (i.e., transition) has an unique name in one process model. However, each task can appear multiple times in one process instance for the presence of the iterative routings.
 2.2 Workflow Log The goal of process mining is to extract information about processes from trans-action logs. We assume that it is possible to record events such that (i) each event refers to a task (i.e., a well-defined step in the process), (ii) each event refers to a case (i.e., a process instance), and (iii) events are totally ordered. Any in-formation system using transactional systems such as ERP, CRM, or workflow management systems will offer this information in some form [6].

Through sorting all the events in a workflow log by their process identifier and complete time, we need only consider that an event has just two attributes, i.e., task name and case identifier. Table 1 gives an example of a workflow log. This log contains information about two cases. The log shows that for case 1, T , T 3 and T 4 are executed. For case 2, T 2 , T 3 and T 5 are executed. In fact, no matter how many cases there are in the workflow log, there are always only two shown in Fig.1, this workflow log is a minimal and complete one. Here we adopt the definitions of workflow trace and workflow log from [6]. To distill a process model with non-free-choice constructs from event logs cor-rectly, we must find a way to mine all the dependencies between tasks without mistakes. As research results show, not all dependencies can be mined directly now. Look backwards to the WF-net shown in Fig.1. It is a typical WF-net with a non-free-choice construct. Firs tly, there is a free choice between T 1 and T 2 . After one of them is chosen to execute, T 3 is executed. Finally, whether T 4 or T 5 is chosen to execute depends on which one of T 1 and T 2 has been executed. There is a non-free-choice between T 4 and T 5 . If we apply  X  algorithm [6] on the log shown in Table 1, P 3 and P 4 as well as their input and output arcs could not be mined. So the mined model is not behavior equivalent with the original model. It can generate two additional kinds of workflow traces, i.e., T 1 T 3 T 5 and T T 3 T 4 . Obviously, this result is not what we want.

In fact, there are totally two kinds of dependencies between tasks which must be mined from event logs, i.e., explicit and implicit ones. Explicit dependency , which is also called direct dependency , reflects direct causal relationships between tasks. Implicit dependency , which is also called indirect dependency , reflects in-direct causal relationships b etween tasks. As Fig.1 shows, P 2 together with its surrounding arcs reflects explicit dependencies between T 1 and T 3 as well as T 2 and T 3 . While P 3 together with its surrounding arcs reflects implicit dependen-cies between T 1 and T 4 . If there are only explicit dependencies between tasks in a process model with non-free-choice constructs, most process mining algorithms, such as the  X  algorithm etc., can mine it correct ly. Otherwise, no algorithm can mine it successfully.

Now we investigate what cha racteristics a process model with implicit depen-dencies may have. Assume that there is an implicit dependency between A and B .Once A is executed, there must be s ome other tasks before B to be executed. After that, B is to be executed. There is no chance that B can directly follow A in some workflow trace. So the implicit dependency between A and B has no chance to be detected. This typical ch aracteristics of a process model with implicit dependency is shown in Fig.2.

The subnet N c contains at least one task. It takes tokens from P 2 and puts tokens into P 3 . In a general case, there may be mo re complicated relationships between N c and the rest of the process model. However, we only consider the simplest case and other cases can be converted to this case easily. Therefore we need not consider the cases where some tasks outside of N c take P 2 as their input place or P 3 as their output place. If ther e are no other tasks connected to P 1 , P 2 and P 3 , P 1 becomes an implicit place. Implicit place does not do any help for the behaviors of a process model. Any sound mining algorithm should avoid constructing implicit places. By enumerating and analyzing all the cases inherited from the simplest case, all of which refer to the input and output tasks WF-nets are proven to be possibly sound. All of these seven sub-WF-nets are shown in Fig.3. Lack of spaces forbids the detail proofs of the above conclusions.
For sub-WF-nets (a) shown in Fig.3, place P 1 and its surrounding arcs will not be mined. For (b) and (g), place P 1 may be replaced by two or more places. will be omitted. Altogether, there are three distinct cases, i.e., (a), (b) and (g), and (c) to (f). All the relative theorems and their proofs will be given in the next section. From the above sections, it is obvious that the detection of implicit dependencies is the most important factor for minin g process models with non-free-choice constructs corr ectly. In this section, we will introduce all the three theorems and their corresponding proofs in detail. There exists a one-to-one relationship between the three theorems and the above three cases of implicit dependencies.
To detect explicit dependencies between tasks, we adopt the  X  + algorithm [7]. Some definitions, such as &gt; w ,  X  w ,# w , w , etc., are also borrowed from [7] with some modification. Based on these basic ordering relations, we provide some additional new definitions for advanced ordering relations.
 Definition 1 (Ordering relations). Let W be a one-length-loop-free workflow log over T. Let a,b  X  T:  X  a  X  w b if and only if a&gt; w b and b  X  w a or a w b or b w a ,  X  a # w b if and only if a  X  w b and b  X  w a ,  X  a w b if and only if a&gt; w b and b&gt; w a and  X  ( a w b or b w a ),  X  a w b if and only if a # w b and there is a task c such that c  X  T and c  X  w a  X  a w b if and only if a # w b and there is a task c such that c  X  T and a  X  w c  X  a w b if and only if a  X  w b and there is a trace  X  = t 1 t 2 t 3 ...t n and i, j  X   X  a w b if and only if a  X  w b or a w b ,and  X  a  X  w b if and only if b is implicitly dependent on a, or there is an implicit
Definitons of w , &gt; w and # w are the same as those defined in [7]. Definitions of  X  SWF-net [6, 7] and two tasks a and b , a w b and b w a must both come into existence. But for a one-length-loop-f ree workflow log of a sound WF-net, it is not always true. Now we will turn to the last five new definitions. Relation w corresponds to OR-Split while relation w corresponds to OR-Join. Relation w represents that one task can only be indirectly followed by another task. Relation w represents that one task can be fo llowed by another task directly or indirectly. Relation  X  w represents implicit dependency between tasks. Con-sider the workflow log shown in Table 1, it can be represented as string sets, i.e., {
T and T 2  X  w T 5 . For any two tasks a and b , a  X  w b and a  X  w b cannot be true at the same time. Here we see that there are implicit dependencies between T 1 and T 4 as well as T 2 and T 5 . But in fact, the detection of implicit dependencies is not as simple as this example shows.

Before starting to detect implicit dependencies, two auxiliary definitions should be given. They are used to represent the input and output task sets of one task set.
 Definition 2 (Input and output task sets). Let W be a one-length-loop-free workflow log over T. Let T s  X  T :  X   X  T s = { t | X  t  X  T s t  X  w t } ,and  X  T s  X  = { t | X  t  X  T s t  X  w t } .

Consider the workflow log shown in Table 1, the following conclusions can be drawn:  X { T 4 } = { T 3 } ,  X { T 5 } = { T 3 } ,and { T 1 ,T 2 } X  = { T 3 } .
Firstly, we try to detect implicit dependencies from a workflow log of a process model with a sub-WF-net similar to Fig.3 (b) and (g).
 Theorem 1. Let W be a one-length-loop-free workflow log over T.
 T t and t 2 such that t 1  X  T w and t 2  X  T w and t 1  X  w t and t 2  X  w t and t 1 # w t 2 and { t 1 } X  = { t 2 } X  , compute as follows: for any task a such that a  X  A 1 and a  X  A 2 , the following formula holds: Proof. See the sub-WF-net shown in Fig.4. Task t has two input places, i.e., p 1 and p 2 . Because a  X  w t , there must be a workflow trace  X  = t 1 t 2 ...t n and i  X  X  1 ,...,n  X  1 } such that t be a token in p 1 . In order to enable t ,theremustbeatokenin p 2 too. If a a , a may have been executed before a is executed. There is a case that after a is executed, there is already a token in p 2 . Hence after a is executed, t is enabled and can be executed. If a w a , the similar thing happens. Otherwise, t cannot be executed directly following a , thus here is a contradiction. So if a w a and a  X  connecting a and p 2 directly as the dotted arc shows. Thus, there must be an implicit dependency between a and b , i.e., a  X  w b .
Theorem 1 insures that once there is a p lace connecting two successive tasks in the mined model and the latter task has more than one input place, the latter task can always have chance to be executed directly following the former task.
Secondly, we try to detect implicit dependencies from a workflow log of a process model with a sub-WF-net similar to Fig.3 (c) to (f).
 Theorem 2. Let W be a one-length-loop-free workflow log over T .
 T (i) For any task t such that t  X  T w ,iftherearetwotasks t 1 and t 2 such that t  X  T  X  Y w = { X  X  X w | X  X  X  X w X  X  X  X  X = X } .
 Then for any task set Y such that Y  X  Y w , the following formula holds:  X  (ii) For any task t such that t  X  T w , if there are two tasks t 1 and t 2 such that t  X  T  X  Y w = { X  X  X w | X  X  X  X w X  X  X  X  X = X } . Then for any task set Y such that Y  X  Y w , the following formula holds:  X  Proof. (i) See the sub-WF-net shown in Fig.5. After t is executed, there is one token in both p 1 and p 2 . Because t w a , there must be a chance that one token In this case, b will be executed finally (see sub-condition 2 in the formula). Otherwise, if a is executed, y 2 and y 2 are both disabled (see sub-condition 3). The token in p 2 is left in the model, thus here is a contradiction. There must be an arc connecting p 2 and a directly as the dotted arc shows. Thus, there must be an implicit dependency between t and a , i.e., t  X  w a . (ii) The proof is similar to (i).
Theorem 2 insures that once a task takes tokens from one of multiple parallel branches, it together with its parallel tasks must consume tokens from other branches too.

Finally, we try to detect implicit dependencies from a workflow log of a process model with a sub-WF-net similar to Fig.3 (a).
 Theorem 3. Let W be a one-length-loop-free workflow log over T .
 T and a w b , compute as follows: For any ( A, B ) such that ( A, B )  X  Y w , compute as follows: The following formulas holds: Proof. Here we only consider the simplest c ase. More complicated cases can be translated into this case by some way. See the sub-WF-net shown in Fig.6. If a p .Thus a i and b j are both enabled. Because b w a i , here is a contradiction. Task a i can only be enabled after a is executed. Because  X { a i } X  X { b j } ,there must be a place with its surrounding arcs directly connecting a and a i as the dotted part of the figure shows. Thus, there must be an implicit dependency between a and a i , i.e., a  X  w a i .
Theorem 3 insures that if two exclusive tasks (i.e., involved in an OR-Join) lead to different sets of parallel branches and these two sets together with their tasks satisfy certain conditions (listed in Theorem 3), the mined WF-net is still sound. A lot of experiments has been done to evaluate the proposed theorems in the previous section. Some of the e xperiments are listed below.

Fig.7 (a) shows an original WF-net. After applying  X  + algorithm on its log, the mined model is similar to Fig.7 (b) except for the two dotted arcs. Continue applying Theorem 1, A  X  w C is detected. Thus p 1 and p 2 should be merged together. At last, the fixed mined model will be the same as the original one.
Fig.8 shows the effect of applying Theorem 2. The WF-nets excluding the dotted arcs are mined by  X  + algorithm. The dotted arcs correspond to the detected implicit dependencies. Thus the WF-nets including the dotted arcs are the same as the original ones.

Fig.9 shows the effect of applying Theorem 3. All the implicit dependencies in the WF-nets are detected successfully from the logs.

Fig.10 (a) shows the effect of applying Theorem 2 and 3 successively. Fig.10 (b) shows the effect of applying Theorem 1 and 3 successively. The mined WF-nets with implicit dependencies are the same as the original ones.

These experimental results together with the formal proofs show that our theorems are powerful eno ugh to detect implicit dependencies between tasks. Process mining is not a new topic, recently many researchers have done a lot of workonit[1,2,3,4,6,7,8,9,10,11,12,13,14,15].Forearlierrelatedwork,please refer to [13].

Schimm presents an approach on mining complete, most specific and mini-mal block-oriented workflow models from workflow logs [1], which is a special data mining. van der Aalst et al. present a common format for workflow logs, discuss the most challenging problems and review some of the workflow mining approaches available today [2]. In [3], the authors discuss the main issues around process mining, which include mining non-free-choice constructs. Medeiros et al point out that all the existing heuristic-based mining algorithms have their lim-itations [4]. After the presentation of  X  algorithm first proposed in [6], they classify the process constructs that are difficult for it to handle and discuss how to extend it. After that, they propose a new algorithm named  X  + to deal with so-called short loops [7] and implement it in a visual process mining tool named EMit [8]. In [9], Herbst et al. describe the main requirements for an interac-tive workflow mining system and how they derived them. Also, they implement the first prototype of an interactive workflow mining system called ProTo .In [10], they give an overview of the algorithms that were implemented within the InWoLvE workflow mining system. These algorithms can mine process models with multiple tasks having the same name. In [11, 12], Pinter et al. view the execution of an activity as a time interval, and present two new algorithms for synthesizing process models. Their approach can detect parallelism explicitly, which is similar to the approach proposed in [13]. Greco et al. investigate data mining techniques for process mining and provide an effective technique based on the rather unexplored concept of clustering workflow executions [14]. In [15], the authors propose an algorithm to discover workflow patterns and workflow termination states and then use a set of rules to mine the workflow transactional behavior.

However, none of those works discuss how to mine process models with non-free-choice constructs as well as detect implicit dependencies between tasks. In this paper, we try to detect implicit dependencies between tasks from event logs. Dependencies between tasks are classified into two classes, i.e., explicit and implicit ones. For mining process models with non-free-choice constructs, the de-tection of implicit dependencies is an imp ortant success facto r. There are totally seven kinds of sound sub-WF-nets and they are grouped into three cases. Thus we propose three theorems for handling these cases and give their proofs. Exper-imental evaluations show that our theorems are suitable for detecting implicit dependencies between tasks.

Our future work will mainly focus on the following two aspects. Firstly, we will extend the  X  + algorithm to support our theorems, so that we will be able to mine WF-nets involving implicit dependencies directly by the extended algorithm. Secondly, we will further investigate other factors affecting the mining of process models with non-free-choice constructs.
 This work is supported by the 973 Project of China (No. 2002CB312006) and the Project of National Natural Sci ence Foundation of China (No. 60373011).
