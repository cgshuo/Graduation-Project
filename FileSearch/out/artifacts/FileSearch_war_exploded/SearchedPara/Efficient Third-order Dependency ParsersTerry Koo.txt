 } @csail.mit.edu Dependency grammar has proven to be a very use-ful syntactic formalism, due in no small part to the development of efficient parsing algorithms (Eis-ner, 2000; McDonald et al., 2005b; McDonald and Pereira, 2006; Carreras, 2007), which can be leveraged for a wide variety of learning methods, such as feature-rich discriminative models (Laf-ferty et al., 2001; Collins, 2002; Taskar et al., 2003). These parsing algorithms share an impor-tant characteristic: they factor dependency trees into sets of parts that have limited interactions. By exploiting the additional constraints arising from the factorization, maximizations or summations over the set of possible dependency trees can be performed efficiently and exactly.

A crucial limitation of factored parsing algo-rithms is that the associated parts are typically quite small, losing much of the contextual in-formation within the dependency tree. For the purposes of improving parsing performance, it is desirable to increase the size and variety of the parts used by the factorization. 1 At the same time, the need for more expressive factorizations must be balanced against any resulting increase in the computational cost of the parsing algorithm. Consequently, recent work in dependency pars-ing has been restricted to applications of second-order parsers, the most powerful of which (Car-reras, 2007) requires O ( n 4 ) time and O ( n 3 ) space, while being limited to second-order parts.

In this paper, we present new third-order pars-ing algorithms that increase both the size and vari-ety of the parts participating in the factorization, while simultaneously maintaining computational requirements of O ( n 4 ) time and O ( n 3 ) space. We evaluate our parsers on the Penn WSJ Treebank (Marcus et al., 1993) and Prague Dependency Treebank (Haji  X  c et al., 2001), achieving unlabeled attachment scores of 93.04% and 87.38%. In sum-mary, we make three main contributions: 1. Efficient new third-order parsing algorithms. 2. Empirical evaluations of these parsers. 3. A free distribution of our implementation. 2 The remainder of this paper is divided as follows: Sections 2 and 3 give background, Sections 4 and 5 describe our new parsing algorithms, Section 6 discusses related work, Section 7 presents our ex-perimental results, and Section 8 concludes. In dependency grammar, syntactic relationships are represented as head-modifier dependencies: directed arcs between a head , which is the more  X  X ssential X  word in the relationship, and a modi-fier , which supplements the meaning of the head. For example, Figure 1 contains a dependency be-tween the verb  X  X eport X  (the head) and its object  X  X ales X  (the modifier). A complete analysis of a sentence is given by a dependency tree: a set of de-pendencies that forms a rooted, directed tree span-ning the words of the sentence. Every dependency tree is rooted at a special  X * X  token, allowing the 1 selection of the sentential head to be modeled as if it were a dependency.

For a sentence x , we define dependency parsing as a search for the highest-scoring analysis of x : Here, Y ( x ) is the set of all trees compatible with x and S CORE ( x , y ) evaluates the event that tree y is the analysis of sentence x . Since the cardinal-ity of Y ( x ) grows exponentially with the length of the sentence, directly solving Eq. 1 is impractical. A common strategy, and one which forms the fo-cus of this paper, is to factor each dependency tree into small parts , which can be scored in isolation. Factored parsing can be formalized as follows: That is, we treat the dependency tree y as a set of parts p , each of which makes a separate contri-bution to the score of y . For certain factorizations, efficient parsing algorithms exist for solving Eq. 1.
We define the order of a part according to the number of dependencies it contains, with analo-gous terminology for factorizations and parsing al-gorithms. In the remainder of this paper, we focus on factorizations utilizing the following parts: Specifically, Sections 4.1, 4.2, and 4.3 describe parsers that, respectively, factor trees into grand-child parts, grand-sibling parts, and a mixture of grand-sibling and tri-sibling parts. Our new third-order dependency parsers build on ideas from existing parsing algorithms. In this section, we provide background on two relevant parsers from previous work. Figure 2: The dynamic-programming structures and derivations of the Eisner (2000) algorithm. Complete spans are depicted as triangles and in-complete spans as trapezoids. For brevity, we elide the symmetric right-headed versions. 3.1 First-order factorization The first type of parser we describe uses a  X  X irst-order X  factorization, which decomposes a depen-dency tree into its individual dependencies. Eis-ner (2000) introduced a widely-used dynamic-programming algorithm for first-order parsing; as it is the basis for many parsers, including our new algorithms, we summarize its design here.

The Eisner (2000) algorithm is based on two interrelated types of dynamic-programming struc-tures: complete spans, which consist of a head-word and its descendents on one side, and incom-plete spans, which consist of a dependency and the region between the head and modifier.

Formally, we denote a complete span as C h,e where h and e are the indices of the span X  X  head-word and endpoint. An incomplete span is de-noted as I h,m where h and m are the index of the head and modifier of a dependency. Intuitively, a complete span represents a  X  X alf-constituent X  headed by h , whereas an incomplete span is only a partial half-constituent, since the constituent can be extended by adding more modifiers to m .

Each type of span is created by recursively combining two smaller, adjacent spans; the con-structions are specified graphically in Figure 2. An incomplete span is constructed from a pair of complete spans, indicating the division of the range [ h, m ] into constituents headed by h and m . A complete span is created by  X  X omplet-ing X  an incomplete span with the other half of m  X  X  constituent. The point of concatenation in each construction X  m in Figure 2(a) or r in Fig-ure 2(b) X  X s the split point , a free index that must be enumerated to find the optimal construction.
In order to parse a sentence x , it suffices to find optimal constructions for all complete and incomplete spans defined on x . This can be 2 Figure 3: The dynamic-programming structures and derivations of the second-order sibling parser; sibling spans are depicted as boxes. For brevity, we elide the right-headed versions. accomplished by adapting standard chart-parsing techniques (Cocke and Schwartz, 1970; Younger, 1967; Kasami, 1965) to the recursive derivations defined in Figure 2. Since each derivation is de-fined by two fixed indices (the boundaries of the span) and a third free index (the split point), the parsing algorithm requires O ( n 3 ) time and O ( n 2 ) space (Eisner, 1996; McAllester, 1999). 3.2 Second-order sibling factorization As remarked by Eisner (1996) and McDonald and Pereira (2006), it is possible to rearrange the dynamic-programming structures to conform to an improved factorization that decomposes each tree into sibling parts X  X airs of dependencies with a shared head. Specifically, a sibling part consists of a triple of indices ( h, m, s ) where ( h, m ) and ( h, s ) are dependencies, and where s and m are successive modifiers to the same side of h .
In order to parse this factorization, the second-order parser introduces a third type of dynamic-programming structure: sibling spans, which rep-resent the region between successive modifiers of some head. Formally, we denote a sibling span as S s,m where s and m are a pair of modifiers in-volved in a sibling relationship. Modified versions of sibling spans will play an important role in the new parsing algorithms described in Section 4.
Figure 3 provides a graphical specification of the second-order parsing algorithm. Note that in-complete spans are constructed in a new way: the second-order parser combines a smaller incom-plete span, representing the next-innermost depen-dency, with a sibling span that covers the region between the two modifiers. Sibling parts ( h, m, s ) can thus be obtained from Figure 3(b). Despite the use of second-order parts, each derivation is Figure 4: The dynamic-programming structures and derivations of Model 0. For brevity, we elide the right-headed versions. Note that (c) and (d) differ from (a) and (b) only in the position of g . still defined by a span and split point, so the parser requires O ( n 3 ) time and O ( n 2 ) space. In this section we describe our new third-order de-pendency parsing algorithms. Our overall method is characterized by the augmentation of each span with a  X  X randparent X  index: an index external to the span whose role will be made clear below. This section presents three parsing algorithms based on this idea: Model 0, a second-order parser, and Models 1 and 2, which are third-order parsers. 4.1 Model 0: all grandchildren The first parser, Model 0, factors each dependency tree into a set of grandchild parts X  X airs of de-pendencies connected head-to-tail. Specifically, a grandchild part is a triple of indices ( g, h, m ) where ( g, h ) and ( h, m ) are dependencies. 3
In order to parse this factorization, we augment both complete and incomplete spans with grand-parent indices; for brevity, we refer to these aug-mented structures as g-spans . Formally, we denote a complete g-span as C g h,e , where C h,e is a normal complete span and g is an index lying outside the range [ h, e ] , with the implication that ( g, h ) is a dependency. Incomplete g-spans are defined anal-ogously and are denoted as I g h,m .

Figure 4 depicts complete and incomplete g-spans and provides a graphical specification of the 3 Figure 5: A bottom-up chart parser for Model 0. S
CORE G is the scoring function for grandchild parts. We use the g-span identities as shorthand for their chart entries (e.g., I g i,j refers to the entry containing the maximum score of that g-span). Model 0 dynamic-programming algorithm. The algorithm resembles the first-order parser, except that every recursive construction must also set the grandparent indices of the smaller g-spans; for-tunately, this can be done deterministically in all cases. For example, Figure 4(a) depicts the de-composition of C g h,e into an incomplete half and a complete half. The grandparent of the incom-plete half is copied from C g h,e while the grandpar-ent of the complete half is set to h , the head of m as defined by the construction. Clearly, grandchild parts ( g, h, m ) can be read off of the incomplete g-spans in Figure 4(b,d). Moreover, since each derivation copies the grandparent index g into suc-cessively smaller g-spans, grandchild parts will be produced for all grandchildren of g .

Model 0 can be parsed by adapting standard top-down or bottom-up chart parsing techniques. For concreteness, Figure 5 provides a pseudocode sketch of a bottom-up chart parser for Model 0; although the sketch omits many details, it suf-fices for the purposes of illustration. The algo-rithm progresses from small widths to large in the usual manner, but after defining the endpoints ( i, j ) there is an additional loop that enumerates all possible grandparents. Since each derivation is defined by three fixed indices (the g-span) and one free index (the split point), the complexity of the algorithm is O ( n 4 ) time and O ( n 3 ) space.
Note that the grandparent indices cause each g-Figure 6: The dynamic-programming structures and derivations of Model 1. Right-headed and right-grandparented versions are omitted. span to have non-contiguous structure. For ex-ample, in Figure 4(a) the words between g and h will be controlled by some other g-span. Due to these discontinuities, the correctness of the Model 0 dynamic-programming algorithm may not be immediately obvious. While a full proof of cor-rectness is beyond the scope of this paper, we note that each structure on the right-hand side of Fig-ure 4 lies completely within the structure on the left-hand side. This nesting of structures implies, in turn, that the usual properties required to ensure the correctness of dynamic programming hold. 4.2 Model 1: all grand-siblings We now describe our first third-order parsing al-gorithm. Model 1 decomposes each tree into a set of grand-sibling parts X  X ombinations of sib-ling parts and grandchild parts. Specifically, a grand-sibling is a 4-tuple of indices ( g, h, m, s ) where ( h, m, s ) is a sibling part and ( g, h, m ) and ( g, h, s ) are grandchild parts. For example, in Fig-ure 1, the words  X  X ust, X   X  X eport, X   X  X ales, X  and  X  X mmediately X  form a grand-sibling part.

In order to parse this factorization, we intro-duce sibling g-spans S h m,s , which are composed of a normal sibling span S m,s and an external index h , with the implication that ( h, m, s ) forms a valid sibling part. Figure 6 provides a graphical specifi-cation of the dynamic-programming algorithm for Model 1. The overall structure of the algorithm re-sembles the second-order sibling parser, with the addition of grandparent indices; as in Model 0, the grandparent indices can be set deterministically in all cases. Note that the sibling g-spans are crucial: they allow grand-sibling parts ( g, h, m, s ) to be read off of Figure 6(b), while simultaneously prop-agating grandparent indices to smaller g-spans. 4 Figure 7: The dynamic-programming structures and derivations of Model 2. Right-headed and right-grandparented versions are omitted.

Like Model 0, Model 1 can be parsed via adap-tations of standard chart-parsing techniques; we omit the details for brevity. Despite the move to third-order parts, each derivation is still defined by a g-span and a split point, so that parsing requires only O ( n 4 ) time and O ( n 3 ) space. 4.3 Model 2: grand-siblings and tri-siblings Higher-order parsing algorithms have been pro-posed which extend the second-order sibling fac-torization to parts containing multiple siblings (McDonald and Pereira, 2006, also see Section 6 for discussion). In this section, we show how our g-span-based techniques can be combined with a third-order sibling parser, resulting in a parser that captures both grand-sibling parts and tri-sibling parts X 4-tuples of indices ( h, m, s, t ) such that both ( h, m, s ) and ( h, s, t ) are sibling parts.
In order to parse this factorization, we intro-duce a new type of dynamic-programming struc-ture: sibling-augmented spans, or s-spans . For-mally, we denote an incomplete s-span as I h,m,s where I h,m is a normal incomplete span and s is an index lying in the strict interior of the range [ h, m ] , such that ( h, m, s ) forms a valid sibling part.
Figure 7 provides a graphical specification of the Model 2 parsing algorithm. An incomplete s-span is constructed by combining a smaller in-complete s-span, representing the next-innermost pair of modifiers, with a sibling g-span, covering the region between the outer two modifiers. As in Model 1, sibling g-spans are crucial for propa-gating grandparent indices, while allowing the re-covery of tri-sibling parts ( h, m, s, t ) . Figure 7(b) shows how an incomplete s-span can be converted into an incomplete g-span by exchanging the in-ternal sibling index for an external grandparent in-dex; in the process, grand-sibling parts ( g, h, m, s ) are enumerated. Since every derivation is defined by an augmented span and a split point, Model 2 can be parsed in O ( n 4 ) time and O ( n 3 ) space.
It should be noted that unlike Model 1, Model 2 produces grand-sibling parts only for the outer-most pair of grandchildren, 4 similar to the behav-ior of the Carreras (2007) parser. In fact, the re-semblance is more than passing, as Model 2 can emulate the Carreras (2007) algorithm by  X  X emot-ing X  each third-order part into a second-order part: S CORE GS ( x , g, h, m, s ) = S CORE G ( x , g, h, m ) S
CORE TS ( x , h, m, s, t ) = S CORE S ( x , h, m, s ) where S CORE G, S CORE S, S CORE GS and S
CORE TS are the scoring functions for grand-children, siblings, grand-siblings and tri-siblings, respectively. The emulated version has the same computational complexity as the original, so there is no practical reason to prefer it over the original. Nevertheless, the relationship illustrated above highlights the efficiency of our approach: we are able to recover third-order parts in place of second-order parts, at no additional cost. 4.4 Discussion The technique of grandparent-index augmentation has proven fruitful, as it allows us to parse ex-pressive third-order factorizations while retaining an efficient O ( n 4 ) runtime. In fact, our third-order parsing algorithms are  X  X ptimally X  efficient in an asymptotic sense. Since each third-order part is composed of four separate indices, there are  X ( n 4 ) distinct parts. Any third-order parsing al-gorithm must at least consider the score of each part, hence third-order parsing is  X ( n 4 ) and it fol-lows that the asymptotic complexity of Models 1 and 2 cannot be improved.

The key to the efficiency of our approach is a fundamental asymmetry in the structure of a di-rected tree: a head can have any number of mod-ifiers, while a modifier always has exactly one head. Factorizations like that of Carreras (2007) obtain grandchild parts by augmenting spans with the indices of modifiers, leading to limitations on 5 the grandchildren that can participate in the fac-torization. Our method, by  X  X nverting X  the modi-fier indices into grandparent indices, exploits the structural asymmetry.

As a final note, the parsing algorithms described in this section fall into the category of projective dependency parsers, which forbid crossing depen-dencies. If crossing dependencies are allowed, it is possible to parse a first-order factorization by finding the maximum directed spanning tree (Chu and Liu, 1965; Edmonds, 1967; McDonald et al., 2005b). Unfortunately, designing efficient higher-order non-projective parsers is likely to be chal-lenging, based on recent hardness results (McDon-ald and Pereira, 2006; McDonald and Satta, 2007). We briefly outline a few extensions to our algo-rithms; we hope to explore these in future work. 5.1 Probabilistic inference Many statistical modeling techniques are based on partition functions and marginals X  X ummations over the set of possible trees Y ( x ) . Straightfor-ward adaptations of the inside-outside algorithm (Baker, 1979) to our dynamic-programming struc-tures would suffice to compute these quantities. 5.2 Labeled parsing Our parsers are easily extended to labeled depen-dencies. Direct integration of labels into Models 1 and 2 would result in third-order parts composed of three labeled dependencies, at the cost of in-creasing the time and space complexities by fac-tors of O ( L 3 ) and O ( L 2 ) , respectively, where L bounds the number of labels per dependency. 5.3 Word senses If each word in x has a set of possible  X  X enses, X  our parsers can be modified to recover the best joint assignment of syntax and senses for x , by adapting methods in Eisner (2000). Complex-ity would increase by factors of O ( S 4 ) time and O ( S 3 ) space, where S bounds the number of senses per word. 5.4 Increased context If more vertical context is desired, the dynamic-programming structures can be extended with ad-ditional ancestor indices, resulting in a  X  X pine X  of ancestors above each span. Each additional an-cestor lengthens the vertical scope of the factor-ization (e.g., from grand-siblings to  X  X reat-grand-siblings X ), while increasing complexity by a factor of
O ( n ) . Horizontal context can also be increased by adding internal sibling indices; each additional sibling widens the scope of the factorization (e.g., from grand-siblings to  X  X rand-tri-siblings X ), while increasing complexity by a factor of O ( n ) . Our method augments each span with the index of the head that governs that span, in a manner superficially similar to parent annotation in CFGs (Johnson, 1998). However, parent annotation is a grammar transformation that is independent of any particular sentence, whereas our method an-notates spans with indices into the current sen-tence. These indices allow the use of arbitrary fea-tures predicated on the position of the grandparent (e.g., word identity, POS tag, contextual POS tags) without affecting the asymptotic complexity of the parsing algorithm. Efficiently encoding this kind of information into a sentence-independent gram-mar transformation would be challenging at best.
Eisner (2000) defines dependency parsing mod-els where each word has a set of possible  X  X enses X  and the parser recovers the best joint assignment of syntax and senses. Our new parsing algorithms could be implemented by defining the  X  X ense X  of each word as the index of its head. However, when parsing with senses, the complexity of the Eisner (2000) parser increases by factors of O ( S 3 ) time and O ( S 2 ) space (ibid., Section 4.2). Since each word has n potential heads, a direct application of the word-sense parser leads to time and space complexities of O ( n 6 ) and O ( n 4 ) , respectively, in contrast to our O ( n 4 ) and O ( n 3 ) . 5
Eisner (2000) also uses head automata to score or recognize the dependents of each head. An in-teresting question is whether these automata could be coerced into modeling the grandparent indices used in our parsing algorithms. However, note that the head automata are defined in a sentence-independent manner, with two automata per word in the vocabulary (ibid., Section 2). The automata are thus analogous to the rules of a CFG and at-6 tempts to use them to model grandparent indices would face difficulties similar to those already de-scribed for grammar transformations in CFGs.
It should be noted that third-order parsers have previously been proposed by McDonald and Pereira (2006), who remarked that their second-order sibling parser (see Figure 3) could easily be extended to capture m &gt; 1 successive modi-fiers in O ( n m +1 ) time (ibid., Section 2.2). To our knowledge, however, Models 1 and 2 are the first third-order parsing algorithms capable of model-ing grandchild parts. In our experiments, we find that grandchild interactions make important con-tributions to parsing performance (see Table 3).
Carreras (2007) presents a second-order parser that can score both sibling and grandchild parts, with complexities of O ( n 4 ) time and O ( n 3 ) space. An important limitation of the parser X  X  factoriza-tion is that it only defines grandchild parts for outermost grandchildren: ( g, h, m ) is scored only when m is the outermost modifier of h in some di-rection. Note that Models 1 and 2 have the same complexity as Carreras (2007), but strictly greater expressiveness: for each sibling or grandchild part used in the Carreras (2007) factorization, Model 1 defines an enclosing grand-sibling, while Model 2 defines an enclosing tri-sibling or grand-sibling.
The factored parsing approach we focus on is sometimes referred to as  X  X raph-based X  parsing; a popular alternative is  X  X ransition-based X  parsing, in which trees are constructed by making a se-ries of incremental decisions (Yamada and Mat-sumoto, 2003; Attardi, 2006; Nivre et al., 2006; McDonald and Nivre, 2007). Transition-based parsers do not impose factorizations, so they can define arbitrary features on the tree as it is being built. As a result, however, they rely on greedy or approximate search algorithms to solve Eq. 1. In order to evaluate the effectiveness of our parsers in practice, we apply them to the Penn WSJ Tree-bank (Marcus et al., 1993) and the Prague De-pendency Treebank (Haji  X  c et al., 2001; Haji  X  c, 1998). 6 We use standard training, validation, and test splits 7 to facilitate comparisons. Accuracy is measured with unlabeled attachment score (UAS): the percentage of words with the correct head. 8 7.1 Features for third-order parsing Our parsing algorithms can be applied to scores originating from any source, but in our experi-ments we chose to use the framework of structured linear models, deriving our scores as: Here, f is a feature-vector mapping and w is a vector of associated parameters. Following stan-dard practice for higher-order dependency parsing (McDonald and Pereira, 2006; Carreras, 2007), Models 1 and 2 evaluate not only the relevant third-order parts, but also the lower-order parts that are implicit in their third-order factoriza-tions. For example, Model 1 defines feature map-pings for dependencies, siblings, grandchildren, and grand-siblings, so that the score of a depen-dency parse is given by: Above, y is simultaneously decomposed into sev-eral different types of parts; trivial modifications to the Model 1 parser allow it to evaluate all of the necessary parts in an interleaved fashion. A similar treatment of Model 2 yields five feature mappings: the four above plus f tsib ( x , h, m, s, t ) , which represents tri-sibling parts.

The lower-order feature mappings f dep , f sib , and f gch are based on feature sets from previous work (McDonald et al., 2005a; McDonald and Pereira, 2006; Carreras, 2007), to which we added lexical-ized versions of several features. For example, f dep contains lexicalized  X  X n-between X  features that de-pend on the head and modifier words as well as a word lying in between the two; in contrast, pre-vious work has generally defined in-between fea-tures for POS tags only. As another example, our 7 second-order mappings f sib and f gch define lexical trigram features, while previous work has gener-ally used POS trigrams only.

Our third-order feature mappings f gsib and f tsib consist of four types of features. First, we define 4-gram features that characterize the four relevant indices using words and POS tags; examples in-clude POS 4-grams and mixed 4-grams with one word and three POS tags. Second, we define 4-gram context features consisting of POS 4-grams augmented with adjacent POS tags: for exam-ple, f gsib ( x , g, h, m, s ) includes POS 7-grams for the tags at positions ( g, h, m, s, g +1 , h +1 , m +1) . Third, we define backed-off features that track bi-gram and trigram interactions which are absent in the lower-order feature mappings: for exam-ple, f tsib ( x , h, m, s, t ) contains features predicated on the trigram ( m, s, t ) and the bigram ( m, t ) , neither of which exist in any lower-order part. Fourth, noting that coordinations are typically an-notated as grand-siblings (e.g.,  X  X eport purchases and sales X  in Figure 1), we define coordination features for certain grand-sibling parts. For exam-ple, f gsib ( x , g, h, m, s ) contains features examin-ing the implicit head-modifier relationship ( g, m ) that are only activated when the POS tag of s is a coordinating conjunction.

Finally, we make two brief remarks regarding the use of POS tags. First, we assume that input sentences have been automatically tagged in a pre-processing step. 9 Second, for any feature that de-pends on POS tags, we include two copies of the feature: one using normal POS tags and another using coarsened versions 10 of the POS tags. 7.2 Averaged perceptron training There are a wide variety of parameter estima-tion methods for structured linear models, such as log-linear models (Lafferty et al., 2001) and max-margin models (Taskar et al., 2003). We chose the averaged structured perceptron (Freund and Schapire, 1999; Collins, 2002) as it combines highly competitive performance with fast training times, typically converging in 5 X 10 iterations. We train each parser for 10 iterations and select pa-Table 1: Effect of the marginal-probability beam on English parsing. For each beam value, parsers were trained on the English training set and evalu-ated on the English validation set; the same beam value was applied to both training and validation data. Pass = %dependencies surviving the beam in training data, Orac = maximum achievable UAS on validation data, Acc1 / Acc2 = UAS of Models 1/2 on validation data, and Time1 / Time2 = min-utes per perceptron training iteration for Models 1/2, averaged over all 10 iterations. For perspec-tive, the English training set has a total of 39,832 sentences and 950,028 words. A beam of 0.0001 was used in all experiments outside this table. rameters from the iteration that achieves the best score on the validation set. 7.3 Coarse-to-fine pruning In order to decrease training times, we follow Carreras et al. (2008) and eliminate unlikely de-pendencies using a form of coarse-to-fine pruning (Charniak and Johnson, 2005; Petrov and Klein, 2007). In brief, we train a log-linear first-order parser 11 and for every sentence x in training, val-idation, and test data we compute the marginal probability P ( h, m | x ) of each dependency. Our parsers are then modified to ignore any depen-dency ( h, m ) whose marginal probability is below 0 . 0001  X  max formation on the behavior of the pruning method. 7.4 Main results Table 2 lists the accuracy of Models 1 and 2 on the English and Czech test sets, together with some relevant results from related work. 12 The mod-els marked  X   X   X  are not directly comparable to our work as they depend on additional sources of in-formation that our models are trained without X  unlabeled data in the case of Koo et al. (2008) and 8 Table 2: UAS of Models 1 and 2 on test data, with relevant results from related work. Note that Koo et al. (2008) is listed with standard features and semi-supervised features.  X  : see main text. Suzuki et al. (2009) and phrase-structure annota-tions in the case of Carreras et al. (2008). All three of the  X   X   X  models are based on versions of the Car-reras (2007) parser, so modifying these methods to work with our new third-order parsing algorithms would be an interesting topic for future research. For example, Models 1 and 2 obtain results com-parable to the semi-supervised parsers of Koo et al. (2008), and additive gains might be realized by applying their cluster-based feature sets to our en-riched factorizations. 7.5 Ablation studies In order to better understand the contributions of the various feature types, we ran additional abla-tion experiments; the results are listed in Table 3, in addition to the scores of Model 0 and the emu-lated Carreras (2007) parser (see Section 4.3). In-terestingly, grandchild interactions appear to pro-vide important information: for example, when Model 2 is used without grandchild-based features ( X  X odel 2, no-G X  in Table 3), its accuracy suffers noticeably. In addition, it seems that grandchild interactions are particularly useful in Czech, while sibling interactions are less important: consider that Model 0, a second-order grandchild parser with no sibling-based features, can easily outper-form  X  X odel 2, no-G, X  a third -order sibling parser with no grandchild-based features. We have presented new parsing algorithms that are capable of efficiently parsing third-order factoriza-tions, including both grandchild and sibling inter-actions. Due to space restrictions, we have been necessarily brief at some points in this paper; some additional details can be found in Koo (2010). Table 3: UAS for modified versions of our parsers on validation data. The term no-3 rd indicates a parser that was trained and tested with the third-order feature mappings f gsib and f tsib deactivated, though lower-order features were retained; note that  X  X odel 2, no-3 rd  X  is not identical to the Car-reras (2007) parser as it defines grandchild parts for the pair of grandchildren. The term no-G indi-cates a parser that was trained and tested with the grandchild-based feature mappings f gch and f gsib deactivated; note that  X  X odel 2, no-G X  emulates the third-order sibling parser proposed by McDon-ald and Pereira (2006).

There are several possibilities for further re-search involving our third-order parsing algo-rithms. One idea would be to consider extensions and modifications of our parsers, some of which have been suggested in Sections 5 and 7.4. A sec-ond area for future work lies in applications of de-pendency parsing. While we have evaluated our new algorithms on standard parsing benchmarks, there are a wide variety of tasks that may bene-fit from the extended context offered by our third-order factorizations; for example, the 4-gram sub-structures enabled by our approach may be useful for dependency-based language modeling in ma-chine translation (Shen et al., 2008). Finally, in the hopes that others in the NLP community may find our parsers useful, we provide a free distribu-tion of our implementation. 2 We would like to thank the anonymous review-ers for their helpful comments and suggestions. We also thank Regina Barzilay and Alexander Rush for their much-appreciated input during the writing process. The authors gratefully acknowl-edge the following sources of support: Terry Koo and Michael Collins were both funded by a DARPA subcontract under SRI (#27-001343), and Michael Collins was additionally supported by NTT (Agmt. dtd. 06/21/98). 9
