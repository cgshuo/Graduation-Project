 1. Introduction
To meet increasing requirements on functionality, safety, and environmental performance, modern automotive vehicles become more and more complex products inte grating electronics, mechanics, and software. Due to their intricate architecture and functionality they are often difficult for a workshop mechanic to troubleshoot. In addition, shortened repair times and increased uptime are required.
To shorten repair times for the increasingly complex automotive systems, one approach is to provide a computer aided troubleshoot-ing system to the workshop mechanic. The troubleshooting system should suggest a sequence of actions, including for example repairs and observations, that leads to a fault free vehicle at lowest expected cost.

In this work, we design a troubleshooting system that is applic-able to automotive vehicles in real world environments. We con-sider practical issues in modeling a nd troubleshooting, and develop methods for efficient troubleshooting and inference. The work is inspired by an application study of an auxiliary heavy truck breaking system, called the retarder . The retarder is a mechatronic system consisting of electrical, mechanical , and hydraulic parts. In particu-lar, we apply and verify our troubleshooting approach on the retarder. The methods developed are designed for, but not restricted to, the troubleshooting of automotive systems.

In the literature, decision theoretic approaches have proven to be efficient for troubleshooting, see for example Sun and Weld (1993) , Heckerman et al. (1995) , Langseth and Jensen (2002) ,and Olive et al. (2003) . However, application studies in these previous works mainly consist of electronic systems, such as printers and electronic control units. In comparison with these electronic applica-tions, the solution to the problem of troubleshooting automotive mechatronic systems needs to take two additional important issues into account.

First, in automotive mechatronic systems it is often not as straightforward to determine whether a certain repair has made the system fault free as in the electrical systems in the previous works. In the previous works, it is assumed that after each repair it is verified whether the system is fault free or not. Such verifi-cation is typically expe nsive in automotive mechatronic systems, and therefore we do not presume it. Th e consequence is that we need to compute probabilities in a system s ubject to external interventions, the system can be reached without first disassembling other parts of the system. This means that the level of disassembly, and the extra time required for disassembly and assembly activities, needs to be considered in the solution.

During troubleshooting the aim is to guide the mechanic by suggesting the next repair or observation such that the expected repair cost is minimized. For small systems, the problem could be solved using influence diagrams ( Jensen and Nielsen, 2007 ; Russell and Norvig, 2003 ). For larger systems, such as troubleshooting of the retarder, influence diagrams become unfeasibly large and complex.
Instead, we formulate the troubleshooting problem as a probabilistic conditional planning problem.

The troubleshooter designed in this paper consists of a diagnoser and a planner. The planner finds a conditional plan of actions by solving a general state space searc h problem, where a state describes the current knowledge, i.e. the current belief state, of the system. To achieve this plan, the planner has to consider the costs of actions and the effects they may have on the system. The costs of actions are dependent on the level of disasse mbly, and each action may change this level. We use the informed search algorithm AO n ( Nilsson, 1980 ) to find an optimal plan, i.e. a plan with minimal expe cted cost that makes the vehicle fault free. The output from the planner to the mechanic is the first action of this plan. If the mechanic is busy waiting for a response, the search t ime contributes to the total repair cost. Therefore, the planner can be halted anytime returning a possibly suboptimal choice of action.

The diagnoser supports the planner with computation of prob-abilities of faults and of future observations. The main challenge in the probability computations is handling the external interventions caused by the troubleshooting activ ities. These interventions change the structure of dependencies during the troubleshooting. In pre-vious works on troubleshooting, computing probabilities after external interventions with the system is often avoided, for example by assuming a function-verifyin g observation after each repair ( Langseth and Jensen, 2002 ). In Breese and Heckerman (1996) interventions are handled using so-called persistence nodes, where mapping nodes are used to track dependency changes. However, the dependency changes studied in the current paper are of a different source, and the persistence nodes are not applicable. Another approach is to utilize event-driven non-stationary dynamic Bayesian networks (event-driven nsDBN), see for example Pernest  X  al (2009) .In the event-driven nsDBN, new time slices are added to a dynamic
Bayesian network (DBN) by events, caused by external interven-tions. By allowing different structures in different time slices the nsDBNs provide a general desc ription of the troubleshooting process, but this generality complicates inference. In the current work, one step further is taken, and a new method of inference for troubleshooting is developed. We note that the probability computations in troubleshooting are of a special kind, and show how these probabilities can be computed by replacing the nsDBN with a static Bayesian network (BN) that is updated as trouble-shooting progress.

To summarize, the main contribution in the current work is the complete troubleshooting system that handles external inter-ventions. We also provide a detailed investigation of practical issues when modeling and building troubleshooting systems for automotive vehicles, as well as a new algorithm for efficient computation of the probabilities needed for troubleshooting. The approach is not specific for troubleshooting of automotive vehi-cles and can be used for other types of troubleshooting.
First, notation and preliminaries are introduced in Section 2, before presenting the retarde r and troubleshooting scenario in Section 3. The planner is described in Section 4, and in Section 5 modeling for troubleshooting is discussed. In particular, practical issues when modeling real systems a re highlighted. The diagnoser is discussed in Section 6, and the BN updating algorithm is derived in Section 7. Sections 7.1 and 7.2 are technical, and give the details for the interested reader, but ar e not necessary for the overall understanding of the method presented. Finally, the troubleshooting system is applied to the retarder in Section 8, before concluding and providing an outlook in Section 9. 2. Preliminaries
Before going into the troubleshooting details, we present the notation used, and give a brief introduction to Bayesian networks (BN) and dynamic Bayesian networks (DBN). 2.1. Notation
All variables considered in this work are discrete. We use capital letters for variables and lower case letters for their values, while p ( X ) denotes the probability distribution of X . Bold face letters denote vectors. Subscripts are used to denote variable indices, and superscripts to denote time. For example, x i value of the variable X i t , with number i at time t . 2.2. Bayesian networks
A Bayesian network (BN) is a directed acyclic graph representing a factorization of the joint probability distribution over a set { X , y , X n } of variables. In the BN, denoted B , nodes represent variables 1 and edges between them represent dependency relations and are directed from parents to children. We let pa B ( X ), ch de ( X ) denote the sets of parents, children, and descendants of variable X in the BN B .Moreover,weuse pa B ( x )todenotean assignment of values to pa B ( X ), and similarly for ch B Whenever the BN B is clear from the context ,weomitsuperscript B .
To each variable X i in B , there is a conditional probability distribution (CPD) associated, defining the probability distribu-tion p  X  X i j pa B  X  X i  X  X  , and B represents the factorization p  X  X , ... , X n  X  X 
We use the term evidence to denote assignments of values to variables in the BN. The BNs considered in this work are causal
BNs, meaning that the direction of the edges represent causal effects. More detailed descriptions on BNs are for example given by Jensen and Nielsen (2007) and Russell and Norvig (2003) .
To model dynamic systems and process, a dynamic Bayesian network (DBN) can be used. The DBN consists of time slices, where each time slice models the system during a certain time interval. Dependencies over time are represented by edges between the time slices, sometimes called temporal edges. For references on DBN, see for example the works by Jensen and
Nielsen (2007) , Russell and Norvig (2003) , and Murphy (2002) . 3. The troubleshooting scenario and system
In this section we present the troubleshooting scenario, and give an overview of the troubleshooting system, but we first present our motivating application: the retarder. 3.1. Motivating application  X  the retarder
The retarder is an auxiliary hydraulic braking system that allows braking of the truck without applying the conventional brakes. It consists of a mechanical system and a hydraulic system, and is controlled by an electronic control unit (ECU), see Fig. 1 .
The retarder generates breaking torque by letting oil flow through a rotor driven by the propeller axle causing friction. The kinetic energy is thereby converted into thermal energy in the oil that is cooled off by the cooling system of the truck. At full effect and high rpm, the retarder can generate as much torque as the engine.
We have chosen to study the retarder since it is a representative system of heavy duty trucks, and since it is difficult to trouble-shoot due to its complexity. 3.2. The troubleshooting scenario
Imagine a heavy truck, driving along the highway to deliver products to a company. Suddenly, the driver experiences pro-blems with the braking performance, and decides to take the vehicle to a workshop. At arrival to the workshop, the driver explains the problem to the mechanic, who plugs in his computer and reads out further information from the truck. From this information it is decided that the truck needs to be repaired immediately to avoid serious trouble. The driver must fulfill his transportation assignment, so the repair should be performed as fast and time efficient as possible. Therefore the mechanic uses the computer aided troubleshooting system.

The troubleshooting system is connected to the truck, and suggests actions for the mechanic to perform. The mechanic reports the results to the troubleshooting system, and waits for new actions to be computed. This goes on until the troubleshoot-ing system has declared that the truck can leave the workshop. 3.3. The troubleshooting system
A troubleshooting action is defined by its cost, its precondition, and its effect. The cost of an action is typically related to the time it takes to perform it and the resources consumed such as spare parts. Also, the cost depends on whether certain parts of the vehicle are assembled or not. The level of assembly is described by the assembly state . The precondition defines in which assembly state the action can be performed. For example to replace the oil pressure sensor the retarder oil needs to be drained and the oil cooler needs to be removed. The effect of an action can be to observe a value, perform a repair, test the operation of the truck, or to change the assembly state. When an action is performed we get an action result . An action result is a confirmed effect, i.e. the action and the outcome.

In Fig. 2 an overview of the troubleshooting system used in this work is shown. The troubleshooting system communicates with the mechanic through action requests and the mechanic returns action results. There is no requirement that action results come from a requested action; the mechanic is free to perform activities on his own choice and report to the troubleshooting system. However, we presume that the mechanic is honest and only reports action results which actually have occurred.
As depicted in Fig. 2 , the troubleshooting system consists of two modules, a planner and a diagnoser , that communicate through the probabilities. This architecture divides the troubleshooting system into two parts with different tasks, and that can be deve-loped independently.

To determine the next action the planner creates a conditional plan of actions called a troubleshooting strategy . The action request is the first action of such a plan that has a small expected cost. The troubleshooting strategy is found by searching the belief state space, i.e. the probability distribution b  X  p  X  C t j a 1 : t  X  , Even though the mechanic may perform actions freely, when computing the troubleshooting str ategies, it is assumed that reques-ted action will be performed. As shown in Fig. 2 , the planner utilizes the diagnoser in two ways: to compute the belief state b t action effects that change the assembly state are deterministic and therefore, the treatment of the ass embly state is contained within the planner. In the diagnoser, the probability computations are divided into two subproblems:
Model updating: for maintainin g a model of the current system, taking external interventions into account.

Probability computation: for belief state updating and predic-tion of the outcomes of future actions.

Troubleshooting is terminated when the probability that the vehicle is fault-free is above a predefined threshold. Such a state is called a goal state for the planner. 3.4. Variables
We use a BN to model the system under troubleshooting in the diagnoser. The BN for the retarder is shown in Fig. 3 . As seen in the figure, there are three types of nodes: components, observable symptoms, and internal states. In this section we describe their characteristics. All variables are discrete. 3.4.1. Components
We use the term component both for the physical components and for the variables describing the fault state of the component. Components are denoted C i , i  X  1, y , N . An assignment C component variables is called a diagnosis . Each component C the possible fault state  X  X  X o fault X  X  ( NF ). In addition, there are at least one state indicating that there is a fault present in the component. To simplify the presentation we only consider one possible fault,  X  X  X aulty X  X  ( F ), for each component in the retarder.
There are two probability distributions related to the compo-nents. The first is the probability of a component being faulty given the operation history H , p  X  C i j H  X  . The history consists of information about how the vehicle has been used. For example, if the vehicle has been operated at extremely high load, its compo-nents are more likely to break. At a certain troubleshooting occasion the history is constant. In the current work we aim at describing a troubleshooting occasion, and we therefore avoid ability distribution for the components is the probability distribu-tion of successful repair, p  X  C j repair  X  C i  X  X  :  X  2  X 
We assume that, during troubleshooting, components cannot change state spontaneously, i.e. if a component is faulty, it must be repaired in order to become fault free. The operation time during test drives is assumed to be short enough for no new faults to appear. 3.4.2. Observable symptoms
Observable symptoms are represented by variables O j , j  X  1, y , M , and represent observations that can be made, for example air leakage at proportional valve and engine warning lamp . Obser-vable symptoms are typically driver X  X  observations, observations made in the workshop, Diagnostic Trouble Codes (DTC) generated in the ECU during driving, or direct observations of components.
A direct observation is obtained by inspection of a component whetheritisfaultyornot.

When an observation action is confirmed, evidence is added to the corresponding observable symptom variable. 3.4.3. Internal states
In addition to the components and the observable symptoms, we use a set of hidden variables to represent internal states of the retarder. The internal states are represented by variables X k  X  1, y , L . For example, in the retarder, there is an internal state representing the uncontrollable braking torque . This internal state can be observed by both the mechanic and the driver. In this way we can model the fact that the result of observing the braking torque level may give different results for example due to the skill of the observer. 3.4.4. Troubleshooting BN
The three different types of variables presented above can be combined to a BN. In this work, we consider troubleshooting BNs defined as follows.

Definition 1 ( Troubleshooting BN ). A troubleshooting BN consists of component variables, observabl e symptoms, and internal states, connected by directed edges such that the following rules hold:
Components can be parents to all kind of variables, but can only be children of other component variables.

Observable symptoms can be parents only to other observable symptoms, but can be children of all types of variables.
Internal states can be parents to observable symptoms only, and children to components only. 4. Planner
As described in the previous section, the task of the planner is to generate the next action request A t  X  1 .Thisisdonebyevaluating different troubleshooting strateg ies and choosing the first action of the strategy with smallest expected cost. A troubleshooting strategy is a conditional plan which means that, depending on the results of previous actions, the subsequent actions to take may be different. Fig. 4 shows an example of a troubleshooting strategy for the retarder. A troubleshooting strategy p is defined as a tree where each node is represented by an action A and each outgoing edge from a node represents an action result a of the corresponding action. Branching occurs when an action has multiple possible results, e.g. the action check leakage near proportional valve may have the action results leakage and no leakage . The troubleshooting when the strategy begins. This state consists of the assembly state d , the belief state b t , and the history of action results a
A troubleshooting strategy p  X  s t  X  is said to be complete if the executionofeveryactiononthepathfromtherootnodetoany leaf node leads to a goal state, i.e. a fault free vehicle. 4.1. Optimal expected cost of repair
To evaluate complete troubleshooting strategies, the expected cost of repair (ECR) is computed. The expected cost of repair is the expected cost of reaching any leaf node of the troubleshooting is performed, there will be a certain action result a t  X  1 probability p  X  a where we have marginalized over the component states c t at time t .
Thefirstprobabilityinthesumaboveiscomputedbythediagnoser, and the second is recognized as the previous belief state.
Let the cost of performing an action A t be q ( d t , A t sequence of actions with effects that affect the assembly state must first be performed so that the precondition of A t becomes fulfilled. resulting state the new assembly state is updated from the old one in accordance with the effects of these actions. More details on how the assembly state is updated and how the action cost is computed can be found in Warnquistetal.(2009) . The belief state in the resulting state is computed by the diagnoser.
 the node that is connected to the edge corresponding to the action result a . Then, the expected cost of repair ECR  X  p  X  s t  X  X  is
ECR  X  p  X  s t  X  X  X 
For a given initial state s t , the optimal troubleshooting strategy  X  s t  X  is  X  s t  X  X  argmin where P  X  s t  X  is the set of all possible complete troubleshooting strategies starting in s t . The optimal expected cost of repair ECR n ( s t ) is the expected cost of repair for p  X  s t  X  . Let P the subset of P  X  s t  X  where A t  X  1 is the first action. Then ECR  X  s t  X  X  min  X  min Actions that affect the assembly state do not need to be con-sidered in the minimization step of (4) because the cost of these actions that are necessary for the precondition of A will already be included in q ( d t , A ). 4.2. Search graph
To obtain the optimal troubleshooting strategy and the next action request, the minimization (4) must be solved. Fig. 5 illus-trates how the problem is decomposed in the form of a tree. Solving the minimization in (4) corresponds to choosing to follow a single outgoing branch from the boxes in Fig. 5 . To compute the summation, every outgoing branch from the circles must be evaluated. This kind of decomposition corresponds to an AND/OR graph. In accordance with Nilsson (1980) , the AND/OR graph can be defined as a hypergraph with nodes that are states interconnected by hyperedges. A hyperedge connects one state with one or many other successor states. In the AND/OR graph for (4), each non-goal state has one outgoing hyperedge for each action that connects to one other state for each action result of that action. A solution to an AND/OR graph is a subgraph of that graph that contains the start state and, for every non-goal state in the solution graph, exactly one hyperedge and all of its successor states. Every solution corresponds to a complete troubleshooting strategy and the optimal solution is the one that solves (4). 4.2.1. Search algorithm
There are many efficient algorithms to find optimal solutions in AND/OR graphs and the one used in this work is AO n ( Martelli and Montanari, 1978 ; Nilsson, 1980 ). AO n is an informed search algorithm that finds the optimal solution to an implicit AND/OR graph G specified by a start state and a successor function . The successor function generates the successors s t  X  1 a of a state s every action result a t  X  1 as well as the probability of reaching each successor. The algorithm is initialized with an explicit AND/OR graph G 0 that consists of only the start state. It uses the successor function to expand G 0 with the successors of one of the leaf states in the optimal solution of G 0 . After each expansion of G 0 , the optimal solution is updated, i.e. the newly expanded state and all of its ancestors are evaluated using a cost function f . For the troubleshooting problem this is f  X  s  X  X  min where h ( s t ) is a heuristic cost function that estimates the optimal expected cost of repair such that h  X  s
 X  r ECR  X  s t  X  for any state s t :  X  5  X 
The algorithm keeps expanding G 0 until all leaf states in the optimal solution to G 0 are goal states. If (5) holds, then the optimal solution to G 0 is also the optimal solution to G .

The heuristic that is used in the implementation is derived from a relaxation of the problem, where we assume that we can observe all components for free. Then for all possible diagnoses c we have to compute the cost of repairing the faulty components in c , i.e. h  X  s  X  X  where the probability p  X  c t j a 1 : t  X  can be taken directly from the belief state b t .

Finding the optimal solution to conditional planning problems is highly exponential ( Rintanen, 2004 ). This means that the time waiting for a response, the computation time contributes to the cost. Therefore, the search can be aborted prematurely and the first action of the optimal solution to the current explicit graph G 0 is returned. This solution does not correspond to a complete troubleshooting strategy and the decision is therefore not neces-sarily optimal. However, for every additional computational time allowed, the quality of the solution converges monotonically toward the optimal. 5. Modeling for troubleshooting In this section we discuss modeling for troubleshooting.
In particular, we discuss practical issues in modeling for troubleshooting, and we give an introduction to how event-driven non-stationary nsDBNs, developed in Pernest  X  al, 2009 , can be used to handle external interventions during the troubleshooting process. 5.1. Practical issues when building BN for troubleshooting
Building BNs for troubleshooting, as modeling in general, is an artwork that requires knowledge about the system to model and/or a lot of training data to learn the model from. Since troubleshooting support is most important when products are new, before experi-ence is collected at the workshops, it is typically the case that the troubleshooting system, including the BN, should be available at the market at the same time as the vehicle is released. At this time, data is not yet collected, and the model must be learned mainly from expert knowledge.

The BN for the retarder shown in Fig. 3 is based on engineers X  expert knowledge, and consists of 20 component variables, denoted C 1  X  C 20 , five internal state variables, denoted X 25 observable symptoms, denoted O 1  X  O 25 .

When building the BN we aim at a model that is simple enough to enable fast computations, but descriptive enough to solve the troubleshooting problem with sufficiently high preci-sion. There are several design choices, and in this section we discuss some of the most important ones.

Components : The parts of the troubleshooted systems can be divided into components in the BN in different ways. The max-imum size of components are sets of parts of the retarder that always are repaired together, also called minimal repairable unit .
Choosing larger components may lead that to more parts than necessary are replaced during troubleshooting. Choosing smaller sets of parts of the retarder as components in the BN is possible, but may give worse performance in the troubleshooting algo-rithm and gives more parameters that need to be determined in CPDs.

In this work we choose components to be minimal repairable units. Furthermore, we allow several components to be faulty at the same time.

Driver or mechanic : Observations concerning the performance of the vehicle, for example the braking torque, can be obtained by asking the driver or by letting the mechanic perform a test drive. In general, the answer from the mechanic is less uncertain but is often obtained at a higher cost since it is more expensive to let the mechanic perform a test drive than interviewing the driver. The driver X  X  answers can on ly be obtained at the beginning of trouble-shooting. It may be the case that the driver X  X  answers bias the mechanic. For example, if the driver complains about uncontrollable braking torque it is reasonable that the mechanic will be influenced and observe the same symptom with higher probability. This case is modeled as a dependency between the observation nodes, see O and O 5 in Fig. 3 for an example.

Perception : In some observations there may be uncertainties. For example the observation leakage magnet valve ( O 15 ) can be mistaken for leakage prop. valve ( O 16 ). We model this by using internal state variables that represent the true situation, in this case X from each such internal variable to both observations.

Effect of external systems : In the troubleshooting of a certain system, there are typically adjacent systems that also may affect the observations. One previously used approach is to assume that surrounding systems are fault free, see e.g. Heckerman et al. (1995) . In the current work another approach is taken. There are two cases that are important to consider: when the trouble-shooted system causes faults in an adjacent systems, and when faults in an adjacent system affects observations in the trouble-shooted system.

In the first case, when the troubleshooted system causes a fault in an adjacent system, the adjacent system is modeled as an observation. In Fig. 3 we have for example identified that the states retarder oil level low ( O 19 ) and oil level low ( O also be observed and thus are modeled as observable symptoms, may cause the gearbox to break. This is modeled through the observable symptom gearbox broken ( O 21 ).

An example of the second case, that faults in adjacent systems also can explain observations in the troubleshooted system, is that leakages outside the retarder may cause the observation DTC : unplausible oil pressure ( O 11 ). This external fault is handled by increasing the probability of false alarm for this DTC. Note that this also induces that the requirement on the goal state must be changed, i.e. at some point we consider the system as fault free although there may be observations that have alarmed.

Time : There are two aspects of time in troubleshooting. First,  X  X  X ime is money X  X , in the sense that there are costs associated with having the truck at the workshop. To model this, each action has a cost for performing the action. This cost is taken into account in the planner.

Second, time goes on while troubl eshooting, and the system may change over time. In particular, the system changes with repairs and test operation. In the current work we consider troubleshooting as a discrete process, where time steps are taken when repair and operation actions are performed. The time interval between two such actions may be of different lengths, and we assume that the system is static during each interval. This assumption is reasonable, since the vehicle is at rest at the workshop, and there are basically no dynamics present. 5.2. Repairs, operations, and interventions
Assume that there is a BN modeling the system under trouble-shooting. Performing observations simply means adding evidence to theobservedvariablesintheBN.Performingarepairofcomponent
C means that the repaired componen t is fault free with probability given by (2). However, when performing a repair there is also an intervention with the system. To illustrate the effect of a repair, assume for a moment that repairs are always successful. Then, repairing a component C i means that the component is forced to be fault free by intervention, rather than being observed as fault free.
Therefore, it is not sufficient to only add the evidence C
BN ( Pearl, 2000 ). The consequences of an external intervention depend on the characteristics of the causal dependencies in the system. As discussed by Pernest  X  al (2009) , there are two different kinds of causal relations in troubleshooting: instant and non-instant.
For example, if the oil is replaced in the retarder, this will have an instant effect on the oil color. Non-instant relations, on the other hand, need operation of the system to be present. One example is that if a gasket is replaced in the retarder, the retarder must be operated in order to verify if there is a leakage or not. In this small example it is shown that operation actions also are external inter-ventions with the systems since an operation changes the relations between variables.

The nature of interventions and their causal effects is carefully discussed by Pearl (2000) . However, the interventions considered by Pearl (2000) are based on the fact that all causal dependencies are instant, i.e. changing the value of a variable gives instanta-neous effects on its children. In the troubleshooting application there are both instant and non-instant causal dependencies, and thus the rules of causality developed by Pearl (2000) are not directly applicable. 5.3. Event-driven non-stationary DBN
To compute probabilities of faults after external interventions, i.e. after repairs and operations, a model describing both the system under troubleshooting and the troubleshooting process itself is needed. One framework for modeling troubleshooting processes is the one based on event-driven non-stationary DBN (event-driven nsDBN) developed by Pernest  X  al (2009) . An nsDBN is a DBN, where dependencies are allowed to be different in different time slices, see for example the works by Robinson and Hartemink (2008) and Pernest  X  al (2009) . In an event-driven nsDBN, new time slices are generated by external interventions that change the structure of dependencies. Following the nomen-clature by Pernest  X  al (2009) , such external interventions are called events . An example of an event-driven nsDBN is shown in Fig. 6 .A time interval between two events is called an epoch . As discussed in Section 5.1, we assume that the system is static between events, meaning that in the nsDBN, each epoch is modeled by a time slice. In an epoch several observations can be performed. However, we assume that the same observable symptom can only be observed once in each epoch. An nsDBN together with a sequence of action results is called a troubleshooting session .
To get familiar with nsDBNs, study the example in Fig. 6 . The figure shows a three-time-slice nsDBN modeling a subsystem of the retarder. In the figure, subscripts correspond to numbers in Fig. 3 , and superscripts denote the corresponding time slice (or, equally, epoch). The nsDBN in Fig. 6 has three time slices. The first models the system at arrival to the workshop. The second time slice is started by the  X  X  X mpty event X  X , i.e. the event where there is no external intervention with the system. The system is at rest at the workshop, and no actions have been performed. As described by Pernest  X  al (2009) , the empty event is merely for theoretical purposes where it is used as a reference; in practice, there is no need for starting a new epoch after the empty event, since the system has not changed. The third and final time slice in Fig. 6 is initialized by the event that the oil has been repaired.
Using the nsDBN in Fig. 6 , reasoning during troubleshooting can proceed in the following way. In the figure, ignoring the directions of the edges, there is a path between O 25 1 and C 19 1 (via O
C ). This means that by observing whether there is oil on the noise shield, conclusions can be drawn about the status of the oil. In the third time slice, after repairing the oil, the path from
O and C 19 2 is broken, and the observation whether there is oil on the noise shield does not contribute in the reasoning about the state of the oil.

In each time slice in an nsDBN, there are two types of edges: instant edges and non-instant edges. We use the following definition from Pernest  X  al (2009) , slightly rewritten to fit into the current framework.

Definition 2 ( Instant edge ). An edge in a BN that models a system is instant if it does not require operation of the system to be present. An edge that does require operation to be present is non-instant .

In Fig. 6 , the edge between the oil and oil color is instant, while the edge between radial gasket and oil on noise shield is non-instant. Also, the nodes in an nsDBN can be classified as one of the two types: persistent or non-persistent. Again, we use the defini-tion from Pernest  X  al (2009) .
 its value in one time slice, generated by the empty event, is dependent on its value in the previous epoch.

In Fig. 6 , the nodes oil , radial gasket , and oil on noise shield are persistent, while the nodes oil color and obs. oil color are non-persistent. In particular, for a persistent variable, if there are no external interventions affecting it, there is an edge between the two copies of the variable in two consecutive time slices.
In Pernest  X  al (2009) it is shown that an nsDBN modeling a troubleshooting process can be characterized by three pieces of information: (i) an initial BN B ns 0 ; (ii) the effects of the empty event; and (iii) for each action, information about the edges added and removed, and the CPDs changed in relation to the effects of the empty event.

The following assumptions related to the nsDBN are used in the current work.
 Assumption 1 ( Initial BN ). The initial BN B ns 0 is a troubleshooting BN as defined by Definition 1.

Assumption 2 ( Persistence ). If not affected by external interven-tions, a persistent variable has the same value in two consecutive epochs.
 Assumption 3 ( Persistent components ). Components are persistent.
Assumption 4 ( Empty event ). The empty event in epoch t gen-erates a new time slice B ns t  X  1 where all nodes and all instant edges are copied from the previous time slice B ns t . Time slice B connected to B ns t by edges from all persistent variables in B
Assumption 5 ( Locality of repair ). The event repair ( C generates a new time slice B ns t  X  1 that is equal to the time slice generated by the empty event, except that the edge between C in B t and C i t  X  1 in B ns t  X  1 is removed. In addition, all edges between
C in B ns t  X  1 and all other components in B ns t  X  1 are removed.
Assumption 6 ( Operation ). The event operate in epoch t gener-variable in B ns t to its copy in B ns t  X  1 .

One consequence of the assumptions above is that, with only one exception, no faults are introduced during troubleshooting.
The exception is that the repair of a component C i may be unsuccessful, and introduces faults in C i . Moreover, Assumption 5 means that repair of a component C i does not affect any other components than C i . Assumption 6 means that operation during troubleshooting is long enough for all non-instant dependencies to establish. Furthermore, it means that test operation makes all persistent variables, except components, independent of their pre-vious values given the current component states. 6. Diagnoser: belief state updating
In this section and in the following, we present the computa-tions performed in the diagnoser. As described in Section 3.3 the computations are divided into two subproblems. The first sub-problem, to maintain a model of the troubleshooted system, is considered in Section 7, and in this section we concentrate on the second subproblem: probability computations for belief state updating and for prediction of future observations.

As described in Section 3.3, there are two cases where the planner requests probabilities from the diagnoser. The first case is when an action result a t is reported to the planner, and the planner requests the diagnoser to compute the belief state, i.e. the probability distribution b  X  b  X  c t  X  X  p  X  c t j a 1 : t  X  ,  X  7  X  for c results. Recall also that the previous belief state is known, although not explicitly written in the probabilities. The second case is during planning, and concerns the probability distributions of possible in (3). Repair and observation actions are requests to the mechanic to perform an activity, and have only one possible result each, namely  X  X  X epair performed X  X  or  X  X  X pe ration performed X  X . These action results are always obtained with probability one. For observations, on the other hand, there are several different values on the observed variable. Therefore, the diagnoser needs to compute the probability p  X  o j j c t , a 1 : t  X  :  X  8  X 
This probability will be computed in Section 7. The remainder of this section is devoted to the computation of the belief state (7) for observation, repair, and operation actions. In the diagnoser, there is no need to consider assemble/disassemble actions since they do not introduce any new faults, and thus do not change the belief state. 6.1. Observation actions
Let a t  X  observe ( O j  X  o j ). By Assumption 2 we have that p  X  C  X  c j C t 1  X  c , a 1 : t  X  X  1 ,  X  9  X  i.e. when a t is an observation C t  X  C t 1 . By using Bayes X  rule, (7) can be written as p  X  C  X  c j a 1 : t  X  X  p  X  C t  X  c j o t j , a 1 : t  X  X  g p  X  o  X  g p  X  o t j j C t 1  X  c , a 1 : t 1  X  p  X  C t 1  X  c j a where g is a normalization constant. Furthermore, Eq. (9) is used to replace c t with c t 1 in the second equality above, and the knowledge that the observation a t does not change the system between times t 1 and t is used in the last equality. In (10), the previous belief state b t 1 is known, so the resulting probability computation to perform is p  X  o which is of the same form as (8), and will be computed in Section 7. 6.2. Repair actions
Now, let a t  X  repair ( C i ). Let s A f NF , F g and C i
C i  X  1 , ... , C N  X  . The belief state after repairing C i b  X  c 1 , ... , c t i 1 , s , c t i  X  1 , ... , c t N  X  X  p  X  c t  X  p  X  c t i j repair  X  C i  X  , a 1 : t 1  X  p  X  C t i  X  s j repair  X  C  X  p  X  c t i j a 1 : t 1  X  p  X  C t i  X  s j repair  X  C i  X  X  ,  X  13  X  where we, in the second equality, have used that the repair makes
C and C i t independent. In the last equality of (13) we have used repaired, C i t is independent of previous events. Marginalizing over
C i , (13) becomes p  X  c i j a  X  X  b  X  ... , c t 1 i 1 , NF , c t 1 i  X  1 , ...  X  X  b  X  ... , c and belief state updating after repair ( C i ) is given by (14). Given the previous belief state b t 1 belief state updating after repair is simply an addition and a multiplication. In particular, under the assumption that repairs are always successful, the updated belief state after a repair action becomes b  X  ... , c i 1 , s , c i  X  1 , ...  X  X  6.3. Operation actions
Finally, let a t  X  operate . According to Assumption 6 no new faults appear during operation, and the belief state updating becomes b  X  c t  X  X  p  X  c t j a 1 : t 1 , operate  X  X  p  X  c t 1 j a 1 : t 1 7. Diagnoser: BN updating
In the previous section, it is shown that for repair and operation actions the belief state is simply updated from the previous belief state according to (14) and (16). For observation actions, probabil-ities of the type (12) are needed to update the belief state. This probability is the same as (8). It cannot be obtained by simple manipulations of the previous belief state only, and needs to be computed in the diagnoser. One straight-forward approach to compute the probability (12) is to use an event-driven nsDBN as described in Section 5.3. The event-driven nsDBN is a general model of the troubleshooting process, but, due to its generality, probability computations in an event-driven nsDBN may become time consum-ing and inefficient. In this section we will take off from the frame-work of event-driven nsDBN and provide an algorithm that efficiently updates a static BN instead of unrolling an nsDBN. In thestaticBNanystandardinferencemethodispossibletousesuch as variable elimination ( Dechter, 1996 ) or importance sampling ( Shachter and Peot, 1989 ).

Begin with dividing the sequence a 1: t of actions into two sequences, one comprising the events, e 1: t , and one comprising the evidence, v 1: t . For example, a 1 : 3  X  / repair  X  C 1  X  , observe  X  O 2  X  o 2  X  , operate gives e 1 : 3  X  / repair  X  C 1  X  , 0 , operate S , v 1 : 3  X  / 0 , observe  X  O 2  X  o 2  X  , 0 S : Above, the figure  X  X 0 X  X  is used to denote that there is no event or evidence respectively. Let B ns ( e 1: t ) be the nsDBN generated by the sequence e 1: t of events. The probability (12) can then be written as p  X  o When it is clear from the context which sequence of events that have generated the nsDBN we will sometimes write B ns instead of B
During search in the planner, there are many sequences of actions under consideration at the same time, and the planner switches back and forth between these sequences. Each sequence of actions generates an nsDBN. There are two main alternatives for using nsDBNs for the probability computations. In the first alternative, no nsDBN is stored. Each time the planner switches to a new sequence of actions, all time slices of the nsDBN represent-ing this sequence are unrolled and the probability computations are performed from start to the current time. In stationary DBNs the probability computations can be made efficiently for example by using algorithms presented by Murphy (2002) . For nsDBNs, on the other hand, the structure changes lead to that these efficient methods cannot be applied. Instead, basic inference methods such as variable elimination are applied ( Jensen and Nielsen, 2007 ; Pernest  X  al, 2009 ). This may lead to time consuming computations in the nsDBN. The second alternative is, instead of generating a new nsDBN for each action sequence, to store one nsDBN for each action sequence. The nsDBN can be stored as the distribution of the variables in time slice t 1 together with the last two time slices. When (if) the planner returns to this particular sequence, a new epoch is added and for example variable elimination can be used to compute the new probabilities. Since the number of considered action sequences may be large, this approach may require an unfeasible memory capacity. Furthermore, if K is the number of nodes, inference is made in a BN with 2 K nodes.
Taking another look at (17), we note that instead of using an nsDBN that can be used to compute arbitrary probabilities, it is sufficient to use a model that gives the conditional probabilities for the observations only. This opens the possibility to use a simpler model that is optimized for computation of the prob-abilities (17). The strategy here is to use a sequence of static BNs B , B 1 , y such that p  X  o The probability in the right hand side of (18) is computed in the static BN B t , and we have introduced the convention that variables in the static BN have no superscript, but are assumed to belong to the BN that the probability is conditioned on. Moreover, recall that superscript on variables in an nsDBN denotes the time slice they belong to. In (18) we have introduced superscript ( t )todenotethe time slice after event e t but before next non-empty event. For example, let a t  X  repair ( C i ), a t  X  1  X  observe ( O j ( O  X  o l ). Then, since the observations are not events, we have p  X  a p  X  a
For each sequence of action results under consideration in the planner, the belief state is stored, but no BNs are stored. Instead, when the planner switches to an action sequence a 1: t , the BN B generated from this sequence, and inference about future obser-vations is performed in this BN. It will be shown that it is sufficient to perform inference in a subpart of B t , typically consisting of a number of nodes that is significantly smaller than K .

In the following two subsections an algorithm B t  X  updateBN ( B , a t ) is presented that recursively generates the sequence of and provide many details, and can be skipped without losing the overall understanding of the method. 7.1. BN updating example
To illustrate the idea of the algorithm updateBN , consider again the example system with the two components oil and radial gasket introduced in Section 5.3. In Section 5.3 the nodes are classified as persistent or not, and the edges within time slices are classified as instant or not. Fig. 7 (a) shows an nsDBN modeling a troubleshooting process with two events (external interventions): repair ( oil ) and operate . In the figure, non-instant edges are marked with dotted arrows while instant edges are solid. Persistent nodes are gray and non-persistent nodes are white.

The leftmost part of Fig. 7 (a), the time slice for epoch 0, or simply  X  X  X ime slice (0) X  X , models the system when troubleshooting is initi-alized. In this time slice, nodes are marked with superscript (0) and in Fig. 7 (b), the corresponding B 0 is shown. Since there has been no external interventions with the system, B 0 is identical to B 7.1.1. Updating example: repair in Fig. 7 (a) the event initializes epoch 1 and produces a new time slice. The new time slice is constructed by copying all nodes and instant edges from the previous time slice. According to Assumption 5 temporal edges are added between all persistent nodes, except repair. Since all probability queries will be of the type (12), we study how to compute the probabilities for the observations.

Consider first the probability of o 24 (1) , p  X  o  X 
X
In the first equality we have used (17) and that o 24 (1) of c (1) in B ns ( e 1:1 ) and in the last equality we have marginalized over the internal variable X 5 (1) . The sum in (19) contains variables in time slice 1 only. Thus, the computations are independent of the variables in time slice 0.

Consider now the probability of o 25 (1) . Since the variables O and C 20 (1) are persistent and connected to their copies in the previous time slice, they have the same values in the two time slices and can be used interchangeably. By noting that O 25 shield 
Oil noise shield 
O* R. Gasket C independent of C 19 (1) , and by marginalizing over C 19 (0) p  X  o  X 
The last probability in the sum in (20) can be written as p  X  c
Therefore, we can update the CPD p  X  o  X  1  X  25 j c  X  1  X  and (21), and then forget the previous time slice.

The computations above show that, if the CPD for O 25 (1) updated, it is possible to compute the probabilities p  X  o repair  X  C 19  X  X  and p  X  o  X  1  X  25 j c  X  1  X  , repair  X  C 1 only. This indicates that, beginning with a BN B 0 corresponding to epoch 0, we can apply a sequence of manipulations on nodes and edges and obtain a new BN B 1 that corresponds to epoch 1. The two BNs B 0 and B 1 are shown in Fig. 7 (b) and (c) respectively.
These manipulations are illustrated in Fig. 8 . They begin with an nsDBN consisting of the two epochs 0 and 1. First, we merge the nodes with the same values and remove superscript, i.e. O
O (1) are merged to O 25 and C 20 (0) and C 20 (1) are merged to C in Fig. 8 (b). In (21) it is shown that the probability for C be computed from b 0 . If the variables X 5 (0) and O 24 (0) this is taken into account in b 0 , and if they do not have evidence they are barren nodes, see for example the work by Jensen and Nielsen (2007) , and will not contribute in the probability compu-crossing over in the nodes in Fig. 8 (b). Finally, by updating the CPD for O 25 according to (21) we can remove C 19 (0) and obtain the BN B 1 in Fig. 8 (c).

Finally, we summarize the set of manipulations made on B 0 in Fig. 7 (b) to obtain B 1 in Fig. 7 (c).
 Set B 1  X  B 0 .

Remove all non-instant edges to and from the repaired component C 19 .

Update the CPD for O 25  X  O 25 (2) according to (21). In Fig. 7 (c) the updated CPD is marked with a  X  X  n  X  X . 7.1.2. Updating example: operation
After repairing the oil, the system is operated, i.e. a 2 operate . In the nsDBN in Fig. 7 (a) the operation causes an event that initiates epoch 2. According to Assumption 6, all non-instant edges are reinserted and temporal links between persistent vari-ables, except components, are removed. In Fig. 7 (a), the only connec-tion between time slices (1) and (2) are through nodes c (2) ( c the previous time slices. The probabilities (17) of the observations are conditioned on c (2) , and are thus independent of the previous time slices. Translating this to one single BN, we obtain B Summarizing the manipulations on B 1 to obtain B 2 we have Set B 2  X  B 1 .
 Insert a non-instant edge between C 19 and O 25 .

Reset the CPD of O 24 to p  X  O 24 j pa B 0  X  O 24  X  X  . 7.2. BN updating algorithm
In the example in the previous section we started with a BN B and manipulated this by adding and removing edges and updat-ing CPDs as events occurred. We obtained the two BNs B 1 and B that, by construction, satisfy (18). In this section we generalize the updating rules derived above, and present an algorithm updateBN (see Algorithm 1) that provides the manipulations needed for all kinds of sequences of action results. The algorithm
B  X  updateBN ( B t 1 , a t ) takes a BN B t 1 , for which (18) holds, and an action a t as input, and delivers a BN B t that satisfies (18). The algorithm consists of three cases depending on whether a t observation, operation, or repair. In this section, recall that the BNs we consider are troubleshooting BNs as described in Section 3.4. 7.2.1. Updating for observation and operation
An observation action is not an event. Thus there are no structure changes, and the algorithm updateBN generates a BN
B such that B t  X  B t 1 .

By Assumption 6, an operation action basically resets the BN to the initial BN, so for an operation updateBN gives B t  X  B 7.2.2. Updating for repairs
For repair actions, the situation is more involved. To describe the effects, we will study the effects of repair actions on subparts of the BN, called repair-influenced BNs, and defined as follows.
Definition 4 ( Repair-influenced BN ). A repair-influenced BN in a troubleshooting BN B for component C i and observation
O de B  X  C i  X  is denoted B ( C i , O j ) and is the subpart BN consisting not independent of O j given C . 2
To exemplify a repair-influenced BN, Fig. 9 (a) shows a BN, and Fig. 9 (b) and (c) show the repair-influenced BNs for B ( C and B ( C i , O 2 ) respectively.
 classes , depending on their structural properties. The elements in a structure class share structural properties, but the number of nodes may be different. For example  X  X  X ersistent observation with an instant edge from its parent compon ent X  X  is one structure class. In this work we define nine structure classes, each of them correspond-of structure classes and denoted F , and in particular we let F be the family consisting of the structure classes in Table 1 .
We say that a troubleshooting BN B belongs to a family F of structure classes if every repair-influenced BN in B belongs to a structure class in family F . We will from now on only consider troubleshooting BNs such that the BN B 0 modeling the system when troubleshooting begins belongs to the family F . This may seem technical and limiting, but since BNs belonging to F capture several kinds of component-observation relations, they are useful in many troubleshooting applications. In particular, it can be realized that the BN for the retarder, shown with all instant/non-instant edges and persistent/non-persistent variables in Fig. 10 , belongs to F .

An important property of family F is that its structure classes are constructed so that removing edges in a repair-influenced BN that belongs to a class in F will give a new repair-influenced BN that belongs to one of the nine classes in F .

In Table 1 the effects of repairing C i for the nine structure classes in F are shown. In column three of Table 1 , for each structure class, a typical repair-influenced BN B t 1 ( C
Assume that (18) holds for this BN and let a t  X  repair ( C will be illustrated in the remainder of this section, equality (18) holds also for the corresponding BN B t in column four of Table 1 . to the assumptions in Section 5.3, the BNs B t are such that equality p  X  o holds.

Structure class 1: The manipulations on B t 1 to obtain B trivial for structure class 1, since there is one single component without children. In this case there are no edges to add or remove.
Structure classes 2, 3, 5, 6, 8, and 9: For structure classes 2, 3, 5, 6, 8, and 9, the common factor is that C i has non-persistent descendants only. This means that, as in the computation of the probability of O 24 (1) in (19), the observations made after the repair are independent of the previous actions since c i t after the repair remove all non-instant edges in B t .

Structure classes 4 and 7: Structure classes 4 and 7 share the property that the children of C i are observable symptoms, and that at least one of them is persistent. Similarly to the computa-tions for O 25 (1) in (20) and (21), the BN B t is obtained from B removing all non-instant edges, and updating the CPD for the persistent observable symptom variables O j to take information from the previous time slice into account. To determine the updated CPD, note that (18) holds for B ns ( e 1: t 1 ) and B also that pa B t  X  O j  X  X  | . We search an updating of the CPD for O after the repair such that p  X  o  X  t  X  j j pa B t  X  o j  X  , B o Marginalizing over C i ( t 1) gives p  X  o j j a  X  To obtain probability (a) in the sum (23), we have used that O (b) in the sum (23) we have used that a t is an external interven-tion performed after C i ( t 1) , which means that C i ( t 1) dent of a t . The probability (b) can be recognized as the previous belief state b t 1 , and is known. For the first probability in the sum we have, by using (17) and then (18), that p  X  o j j c where we have used (18) in the last equality. To summarize, from (23) and (24) we have that the CPD for O j is computed using its CPD in B t 1 and the previous belief state b t 1 .

In this section, updating rules for single repair-influenced BNs are considered. However, real systems typically consist of larger BNs, consisting of several repair-influenced BNs. These are handled by the theorem and algorithm in the following section. 7.2.3. Updating algorithm Pseudo-code for the algorithm updateBN is given in Algorithm 1. For a BN B 0 that belongs to F , and given a sequence a 1: t results, updateBN generates a sequence B 1 , y , B t of BNs that each satisfies (18). The algorithm consists of three cases (if-statements), one for observation actions, one for operation actions, and one for repair actions. Within the if-statement for repair actions, the set ConsideredObs is constructed to avoid that the same repair-influ-enced BN is considered several times. The following theorem guarantees the properties of the updating algorithm updateBN defined by Algorithm 1.
 Theorem 1 ( Algorithm updateBN ). Consider a troubleshooting ses-sion described by an nsDBN B ns with initial BN B ns 0 belonging to F and a sequence a 1: t of action results such that there is at least one operation action between two repair actions. Let B 0  X  B ns
B , y , B t be a sequence of BNs such that B k  X  updateBN ( B k 1 k  X  1, y t , where updateBN is defined by Algorithm 1. Then , (18) holds for each B k , k  X  0, y , t .
 The theorem is proved by Pernest  X  al (2009) .
 Algorithm 1. B  X  updateBN ( B , a ).

B :  X  B if a  X  observe ( O  X  o ) then // Nothing to do else if a t  X  operate then
B :  X  B 0 else if a  X  repair ( C ) then
ConsideredObs :  X  | for all O A de  X  C  X  do end for end if 8. Modeling application
The troubleshooting system consisting of a planner and a diagnoser as described in Sections 4 X 7 is implemented and applied to the problem of troubleshooting a heavy truck with a faulty retarder. A BN B 0 modeling the retarder at arrival to the workshop is shown in Fig. 10 . This model is built from expert knowledge, and by applying the modeling principles developed in Section 5. The retarder BN belongs to F , so the algorithm updateBN is applicable. In Fig. 10 , instant edges are solid, non-instant edges are dotted, persistent nodes are gray, and non-persistent nodes are white.

In the implementation, the size of the belief state with which the planner is initialized, is limited such that only the 21 most probable diagnoses c of component statuses are kept. Also, the diagnoser is set to disregard diagnoses where four or more components are faulty. This is done to keep the size of the belief state manageable, and it is reasonable because the probability for several simultaneous faults in the retarder is typically very small compared to having fewer faults. This method of keeping down the size of the belief state works for our model of the retarder, but it is not feasible for larger systems. In those cases methods as the one presented in Lerner et al. (2000) can be used, where the diagnoser collapses similar diagnoses into one.

When the algorithm updateBN is used inference needs only to be made in a static BN with 50 nodes instead of the entire nsDBN with 50 t nodes where t is the number of events. In the imple-mentation, inference is made using the exact method variable elimination from Dechter (1996) which is feasible because the static part of the BN for the retarder is of moderate size. For larger networks, it may be possible to perform the inference by using approximate methods such as importance sampling ( Shachter and Peot, 1989 ).

When many different components are suspected in the inferred belief state, the planner may require much time to optimize (4). However, if planning is aborted prematurely the expected cost of repair of the suboptimal troubleshooting strategy may be almost as good. To illustrate this, we drew 100 random faults from the prior distribution and measured the ECR of the outputted troubleshooting strategies when the planner is aborted early. A majority of the samples were  X  X  X asy X  X  cases where the true diagnosis could almost be isolated only be reading out the
DTCs. Fig. 11 shows the average increase in the ECR when planning is ended prematurely for the 5% most difficult samples (solid line) and the average over all samples (dashed line). The curve shows an exponential decrease of the increased ECR and after 30 s the hardest cases are less than 0.5% from optimum.
To investigate the relevance of accurate probability computa-tions by the diagnoser, we introduced noise in the parameters in the BN. Noise is added using the log-odds normal distribution as described in Kipersztok and Wang (2001) . Every parameter y in the CPDs in B 0 receives a new value y 0 which is y  X  1  X  X  y 1 1  X  10 o s where o s is a random number drawn from a normal distribution with standard deviation s . The troubleshooter has only access to this distorted model, while an undistorted model of the retarder is used to represent the physical system. In each test case there is a predefined fault. When actions are performed, the results are drawn randomly in accordance with the undistorted model and the predefined fault. The troubleshooting process is simulated until the fault is repaired and the total cost is measured. To avoid long waiting times, after 60 s, the quality of the decision is considered sufficiently optimal and the planner is aborted. As seen in the previous experiment this timeout is reasonable. The standard deviation s is varied from 0 to 1, and for each level of s , 25 test cases are run. Fig. 12 shows the average discrepancy in the cost for troubleshooting using a BN with parameter errors (represented by a noisy BN) compared to using the nominal BN.
Small errors in the parameters do not affect the result signifi-cantly, but for larger errors represented with noise with a standard deviation above 0.25 the discrepancy increases fast. In practice, the result in Fig. 12 means that, since small parameters errors have an (almost) insignificant impact on the ECR com-puted, the parameters could be chosen roughly. 9. Conclusion and future work
Inspired by a case study of the retarder, an auxiliary heavy truck breaking system, a decision theoretic troubleshooting sys-tem has been developed. Focus has been put on issues that are important in real world applications: the need for disassembling the system during troubleshooting, the problem of verifying that the system is fault free during the troubleshooting, and the fact that computations for suggestion of new actions should be performed while the mechanic is waiting. These issues have two main consequences: probabilities must be computed in a system that is subject to external interventions, and the computations should be fast.

The troubleshooting system developed is based on a decision-theoretic approach. It consists of a planner that suggests the next troubleshooting action to the mechanic, and a diagnoser that supports the planner with probabilities for faults. In the planner, an any-time AO n algorithm with heuristics has been used. In the diagnoser, probabilities are computed by an algorithm based on a static BN.

Driven by the application study of the retarder, we have also studied practical issues of modeling for troubleshooting in detail, and provided guidelines for building the BN to be used in the diagnoser. There are two different types of dependencies that are used in the troubleshooting: instant and non-instant dependen-cies. To handle this fact, in combination with the need for handling the external interventions caused by repairs and opera-tions, and the need for time efficient computations, a new algorithm updateBN has been developed. The algorithm updateBN reduces the external interventions to simple manipulations on a static BN.

Finally, we have applied the troubleshooting system to the retarder. The results confirm the suggested modeling approach and that the decision theoretic troubleshooting approach used is suitable in real-world applications.

The application of decision theoretic troubleshooting to auto-motive systems is a large research field, and there are still interesting open questions for future work regarding efficient probability computations. One is a comparison of the efficiency of computation methods, including updateBN , event-driven nsDBN, and other methods. Another is the extension of the family F of structure classes.

However, as a first step toward troubleshooting with inter-ventions and both instant and non-instant dependencies, the results presented in this work show that computer aided trou-bleshooting can be applied to complex mechatronic systems such as the retarder.
 References
