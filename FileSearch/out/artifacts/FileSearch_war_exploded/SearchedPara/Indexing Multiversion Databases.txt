 An efficient management of multiversion data with branched evolution is crucial for many applications. It requires databa-se designers aware of tradeoffs among index structures and policies. This paper defines a framework and an analysis method for understanding the behavior of different indexing policies. Given data and query characteristics the analysis allows determining the most suitable index structure. The analysis is validated by an experimental study.
 Categories and Subject Descriptors: H.3.1 [Informa-tion Storage and Retrieval]: Content Analysis and Indexing-indexing methods General Terms: Theory, Performance.
 Keywords: Index structures, branched and multiversion data, performance analysis, comparison.
Many applications such as engineering design require the support of time evolving data with multiple lines of time evo-lution [6]. Temporal and multiversion databases dedicated to such applications, maintain several states of the modeled universe. Such a persistent state is called DataBase Version or DBV [2, 6].

A query to a multiversion database can be a version slice query ,an historical query or a combination of both [6]. A version slice query searches for data within a DBV. An his-torical query follows the evolution of entities (objects or tuples) through a set of DBVs. Although many index struc-tures have been proposed to optimize queries to temporal data, little work has been carried out on indexing data with branched evolution [6]. This paper compares different in-dexing techniques for such data. In particular, an analysis method based on the concept of data agility [7] and called the Steady State Analysis is proposed. The main contributions are: ( i ) the extension of temporal index structures to han-dle data with branched evolution; ( ii ) a comparative study of main trends in indexing multiversion data; ( iii )asteady Figure 1: (a) Initial DBV v 1 .(b) v 2 and v 3 are de-rived from v 1 . c is updated in v 2 , d is updated in v 3 (c) Stored DBV tree and entity versions state analysis, which brings to light fundamental properties of different index structures and accurately predicts their behavior; ( iv ) an experimental validation of the analysis.
The paper is organized as follows. Section 2 introduces the main concepts. Section 3 describes different indexing structures. Section 4 briefly presents the steady state ana-lysis. Section 5 validates the analysis through simulation. Section 6 concludes the paper.
Entity version and database version: an entity e is repre-sented in each DBV v by a single version ( e,v,val ), where val is the value of the entity e in the DBV v .ADBV v contains one version of each entity represented in the database.
Except for the initial DBV v 1 , a new DBV is always de-rived from an existing DBV. Thus, the set of DBVs is struc-tured in a genealogical tree, called the DBV tree [2] (figure 1.c). Since a DBV usually differs only partially from its par-ent, an entity e can keep the same value through a set of DBVs. To store unchanged entity version values only once the implicit sharing [2] is used: "if the value of ( e,v )isnot stored, its value is the same as that of ( e,v X  ), where v X  is the closest ancestor of v in the DBV tree, identifying a stored version of e ". Figure 1 summarizes the former concepts. DBV range: a DBV range R is a connected subset of the DBV tree (in the linear time case, R is a time interval) [6]. R is represented by a pair ( v start , { v end } ), where v the DBV root of R and { v end } a set of DBVs. A DBV v e appearing in { v end } does not belong to R , but its parent does. Thus, v e explicitly terminates a branch starting at v start . A particular value of R is ( v ,  X  ), meaning that the subtree of the DBV tree, rooted at v .
Three families of index structures are reviewed. The first family clusters entity versions by entity. It is represented by the B+V-tree proposed in this paper. The second family Figure 2: (a) B+V-tree at v 1 . (b) Derivation of v 2 , then update of c in v 2 . (c) Derivation of v 3 , then update of d in v 3 . Figure 3: (a) Initial B+tree B +( v 1 ) . (b) Derivation of B +( v 2 ) ,updateof c in v 2 . (c) Derivation of B +( update of d in v 3 . clusters entity versions by DBV and is represented by a slightly modified Overlapping B+Trees (OB+tree) [1, 8]. The third family is a bi-dimensional index structure, rep-resented by the Branched and Temporal Tree (BT-tree) [3].
The use of the B+tree to index entity versions with linear evolution has been proposed in [5]. In our work, we extend the B+tree to handle data with branched evolution and call the resulting structure the B+V-tree. The B+V-tree clus-ters entity versions by entity and then by DBV. When a leaf D k overflows, it is split into D k and D l , according to entity identifiers. This is shown in figure 2.c, where the update of d in v 3 causes D 2 overflow: c versions remain in D 2 and d versions are moved to D 3 .

If D k only contains versions of a single entity e , D k is split according to a DBV identifier v s .Let R be the DBV range corresponding to the versions of e stored in D k before the split. v s is chosen, so that, R isdividedintwoDBV ranges R and R ,where R corresponds to the versions of e remaining in D k and R to the versions of e moved to D l .
The OB+tree [1, 8] builds a B+tree, denoted B +( v ) , for each DBV v and allows consecutive B+trees to share unchanged nodes. First, the initial B+tree, B +( v 1 ) created (figure 3.a). When a new DBV v j is derived from aDBV v i , the root of B +( v j ) is created. Its content is a copy of the root of B +( v i ) ,so B +( v i ) and B +( v j all their nodes, except their root. When a shared leaf D is affected by an entity modification, its sharing is broken: D k is duplicated in a new node D l where the modification is performed. After the duplication, I j , the parent node of D k , is modified to point to D k : the sharing of I j between B +( v i ) and B +( v j ) is also broken. Node duplications continue up to the update of B +( v j ) root (figure 3.b). The OB+tree was proposed for data with linear evolution. We extend it to data with branched evolution by storing a Figure 4: (a) D 1 contains entity versions of v 1 . D 1 is entity split. (b) Update of c in v 2 . (c) The update of d in v 3 causes D 2 version split.
 DBV range R in the header of each node D . R indicates the DBV where D was created and the DBVs where it is duplicated, so it is easy: ( i ) to detect if D is shared ( ii )to find out the DBV range of the entity versions stored in D ; this is useful for historical queries.
The BT-tree [3, 6] is a bi-dimensional index clustering entity versions on entity and DBV identifiers. An entry of an internal node is a triple ( [ e min ,e max [ , ( v start ( v start , { v end } ) a DBV range and I the identifier of a child node. The leaves of the subtree rooted at the node I contain the ( e,v ), such that e  X  [ e min ,e max [and v  X  ( v start I is said to be alive for each DBV v  X  ( v start , { v end
The BT-tree uses version split , entity split and combina-tions of both. An entity split is similar to a split in a B+tree. It occurs when the overflowing leaf contains entity versions belonging to the same DBV (figure 4.a). A version split of a leaf D k separates its entity versions according to the DBV v which triggers the split: (1) v is added to the { v end D k ; (2) a new leaf D l with DBV range ( v,  X  ) is allocated; (3) entity versions whose DBV range intersects both the DBV range of D k and D l are copied in D l (figure 4.b). After a version split, if the number of entity versions copied in D exceeds a threshold  X  , the version split is followed by an en-tity split.

Whereas the B+V-tree allows entities to be modified in any DBV, the BT-tree and the OB+tree allow modifications only in the DBVs leaves of the DBV tree. Figure 5 synthe-sizes the main features of the different index structures.
The steady state analysis aims at providing performance evaluation for the different index structures. Given data and application characteristics, the analysis provides guidelines for the selection of the most appropriate index structure.
A multiversion database at steady state is modeled by a set of E entities and V DBVs. Each entity e is subject to updates; each update occurring in a DBV v , generates a new version ( e,v ), whose value is stored in the database. To be able to compare the different index structures, entity updates are only allowed in the DBVs leaves of the DBV tree. The proportion a of entity versions updated in each DBV, called data agility in [7], is assumed to be constant. The total number of distinct entity versions is E = E (1 + a (
V  X  1)) .The E entity versions are assumed to be indexed by a B+V-tree, an OB+tree and a BT-tree. The goal is to compare storage and query costs.

The storage cost is estimated by N ,the number of leaves in the final index ,and r ,the redundancy factor .Forthe OB+tree and the BT-tree, N is estimated by n + m ( V  X  1) where n is the number of leaves in the initial index and m the average number of new leaves created when aE entities are updated in a DBV . r is estimated by E r  X  X  E = E r E where E r is the number of stored entity versions .
The cost of a query q is estimated by P ,the number of visited leaves . Perfect match queries are distinguished from range queries . A perfect match query is assumed to involve asetof q e entities, and, for each entity, q v consecutive DBVs. A range query involves q v consecutive DBVs and q e entities with consecutive identifiers.
Let b be the average number of entity versions stored in a leaf. N is estimated by
Since the B+V-tree has no version redundancy, r =0 .
Perfect match queries: due to the lack of space, here we only consider the common case where all the versions of an entity fit in a single leaf. Given a search for version(s) of an entity, each leaf has a probability 1 N to be visited and a probability 1  X  1 N not to be visited. When versions of q entities are searched, as all searches are independent, each leaf has a probability probability 1  X  Range queries: the average number of versions generated by q entities is q e (1 + a ( V  X  1)) . To retrieve q e (1 + a entity versions, the average number of visited leaves is
Estimation of n : as B +( v 1 ) indexes E entity versions, n
Estimation of m : let B +( v i ) and B +( v j ) be two con-secutive B+trees. m is the average number of new leaves created in B +( v j ) . m is estimated by n  X  A ,where A is the probability for a leaf belonging to B +( v i ) to be duplicated in B +( v j ) . A is the leaf agility .

As the model only consider entity updates, all the B+trees havethesamenumberofleavesas B +( v 1 ) . Thus, when an the probability for a leaf not to be affected by these updates is least one update is A =1  X  n  X 
As each leaf stores b entity versions on average, E r = b  X  N  X  X  r = E (1 + A ( V  X  1))  X  r = 1+ A ( V  X  1)
P is estimated by p (1 + A ( q v  X  1)) ,where p is the average number of visited leaves in a B+tree to retrieve q e entities.
Perfect match queries: reasoning as in subsection 4.1.3 (changing N to n and P to p ), p can be estimated by n ` 1  X  Range queries: p is estimated by q e b  X 
Estimation of n : let D bealeafoftheBT-treealive at DBV v .Let b X  be the average number of entity versions stored in D and alive at v . At steady state, b X  has been estimated by  X   X B ln 2 [3], where B istheleafnodecapacity. Initially the BT-tree indexes E entity versions, thus n = E Estimation of m : the average number of leaves alive at a DBV v equals E b . Thus, when aE entities are updated in v , each leaf alive at v receives aE E average. When a leaf D is created due to a version split at aDBV v start , it initially contains b entity versions. Thus, another version split occurs to D after the insertion of B entity versions. As D receives on average ab entity versions from each DBV descendant of v strat , D is version split after the generation of B  X  b ab DBVs (starting from v start ). Thus, after the generation of B  X  b ab DBVs, on average, E b new leaves are created in the BT-tree. Finally, the average number of leaves created when entities are updated in a DBV is m
When a leaf node is split, b X  entity versions are copied on average. The total number of leaf splits is m ( V  X  1 Consequently, E r = E + b m ( V  X  1)  X  r = ab ( V  X  1) ( B
The estimation of P for the BT-tree follows the same prin-ciple as for the OB+tree: P = p (1 + A ( q v  X  1)) ,where p is the average number of leaves visited to retrieve q e entity ver-sionsofaDBV v i and A the probability for a leaf alive at v to be version split at a DBV v j ,childof v i . A is estimated
Perfect match queries: reasoning as in subsection 4.1.3 (changing N to E b and P to p ), p can be estimated by  X  Range queries: p = q e b  X 
A large number of experiments have been performed to show the accuracy of the steady state analysis (see [4]). Due to the lack of space, only few results are presented herein. For the presented simulation, data are generated as follows. E and V are fixed respectively to 200 K entities and 200 DBVs. E entities are inserted in the first DBV. Then, in each newly derived DBV, aE entities randomly selected, are updated. Each DBV is derived from a randomly selected DBV, with the following restrictions: ( i ) entity updates are allowed only in the DBVs leaves of the DBV tree; ( ii )the distance between the DBV root and any DBV leaf of the final DBV tree is  X  40 DBVs. The data page capacity is set to B =101 entity versions for the OB+tree and B =92 for the B+tree and the BT-tree. As shown by figures 6.a, 6.b and 7, our model accurately estimates the query and the storage costs of the different index structures.

Query cost: the model shows that, in general, the B+V-tree is best suited for perfect match queries (figure 6.a). Thus, if entity identifiers are system generated (without se-mantics), the B+V-tree appears as the best choice (because range queries are of little use ). If the entity identifier is an attribute and range queries are frequent, the BT-tree is the best choice (figure 6.b). The OB+tree can be chosen only when version slice queries are frequent (figures 6.a and 6.b). Figure 7: Storage cost as function of the data agility
Storage cost: as shown in figure 7, the size of the OB+tree grows very quickly as the agility increases. From an agility bordering 6% , the OB+tree degenerates into independent B+trees and its size stabilizes (since there are 200 B+trees with the same size). Figure 7 shows also that even when the OB+tree does not degenerate, it occupies much more storage space than the other index structures. For exam-ple, when the agility is close to 1% , the OB+tree occupies nearly 34 times more storage space than the corresponding B+V-tree. So its applicability is greatly limited. The BT-tree occupies nearly 2 times the storage space occupied by the B+V-tree. When a 68% , the BT-tree occupies more storage space than a set of independent B+trees (figure 7).
The index structures exhibit similar behavior for other settings than the considered herein, the only difference being the points where their curves intersect.
This paper studies the problem of efficiently indexing data with branched evolution. Its main contributions are: ( i ) the extension of temporal index structures to data with branched evolution; ( ii ) a comparative analysis of main trends in indexing multiversion data; ( iii ) a steady state analysis which accurately estimates the performance of the different index structures and provides guidelines for the selection of the most appropriate one; ( iv ) an experimental validation of these results.
Warm thanks to Claudia Bauzer Medeiros for the helpful discussions and reviews that improved this paper. [1] M. J. Carey and Al. Object and File Management in [2] W. Cellary and G. Jomier. Consistency of Versions in [3] L. Jiang and Al. The BT-tree: A Branched and [4] K. Jouini and G. Jomier. Comparison of Index [5] M. Nascimento and M. Dunham. Indexing Valid Time [6] B. Salzberg and Al. A Framework for Access Methods [7] Y. Tao and Al. Cost Models for Overlapping and [8] T. Tzouramanis and Al. Overlapping B+-Trees: An
