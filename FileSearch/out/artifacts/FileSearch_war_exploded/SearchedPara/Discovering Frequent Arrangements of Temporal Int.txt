
In this paper we study a new problem in temporal pattern mining: discovering frequent arrangements of temporal intervals. We assume that the database consists of sequences of events, where an event occurs during a time-interval . The goal is to mine arrangements of event intervals that appear frequently in the database. There are many applications where these type of patterns can be useful, including data network, scientific, and financial ap-plications. Efficient methods to find frequent arrangements of temporal intervals using both breadth first and depth first search techniques are described. The performance of the proposed algorithms is evaluated and compared with other approaches on real datasets (American Sign Language streams and network data) and large synthetic datasets.
Sequential pattern mining has received particular atten-tion in the last decade [2, 3, 5, 6, 10, 24, 9, 18, 11, 19, 23, 13, 12, 21]. Despite advances in this area, nearly all proposed algorithms concentrate on the case where events occur at single time instants. However, in many applications events are not instantaneous; they instead occur over a time inter-val. Furthermore, since different temporal events may occur concurrently, it would be useful to extract frequent temporal patterns of these events. In this paper the goal is to develop methods that discover temporal arrangements of correlated event intervals which occur frequently in a database.
There are many applications that require mining such temporal relations. Consider an ASL (American Sign Lan-guage) database that contains useful linguistic information on a variety of grammatical and syntactic structures, as well as manual and gestural fields [15]. Detecting relations be-tween the above structures and fields could be interesting to the linguists and may help them discover new types of rela-tions they were unaware of. Another application is in net-work monitoring, where the goal is to analyze packet and router logs. Multiple types of events occurring over cer-tain time periods can be stored in a log, and the goal is to detect general temporal relations of these events that with high probability would describe regular patterns in the net-work. This could then be used for prediction and intrusion detection.

Existing sequential pattern mining methods are ham-pered by the fact that they can only handle instanta-neous events, not event intervals. Nonetheless, such algo-rithms could be retrofitted for the purpose, via converting a database of event intervals to a transactional database, by considering only the start and end points of every event interval. An existing sequential pattern mining algorithm could be applied to the converted database, and the ex-tracted patterns could be post-processed to produce the de-sired set of frequent arrangements. However, an arrange-ment of intervals corresponds to a sequence of length . Hence, this approach will produce up to different se-quential patterns. Moreover, post-processing will also be costly, since the extracted patterns consist of event start and end points, and for each event interval all the relations with the other event intervals must be determined.

To the best of our knowledge, there have been no effi-cient methods developed that consider general types of tem-poral arrangements between event intervals. Our main con-tributions include: (a) a formal definition for the problem of mining frequent temporal arrangements of intervals in an interval database, (b) two efficient algorithms for min-ing frequent arrangements of temporally correlated events using breadth first and depth first techniques in an enumer-ation tree of temporal arrangements, and (c) an extensive experimental evaluation of these techniques and a compari-son with a standard sequential pattern mining method using both real and synthetic datasets.
 The remainder of this paper is organized as follows: Sec. 2 provides the problem formulation along with the ap-propriate background and an overview of the existing meth-ods related to our work. Sec. 3 presents two tree-based ap-proaches for mining frequent arrangements of temporally correlated events. Sec. 4 describes experimental evaluation, and Sec. 5 gives conclusions.
In this section we give the problem formulation along with the appropriate background. Moreover, we provide a review of the most related work. 2.1 Event Interval Temporal Relations
In this paper we consider five types of temporal relations between two event intervals. Using these relations we de-fine more general temporal arrangements. However, our methods are not limited to these relations and can be eas-ily extended to include more types of temporal relations, as the the ones described in [4].

Consider two event-intervals and .Furthermore,as-sume that the user specifies an that is used to define more flexible matchings between two time instants. The follow-ing relations are studied (see also Fig. 1): 2.2 Problem Formulation
Let = be an ordered set of event in-tervals, called event interval sequence or e-sequence . Each bel, is the event start time and is the end time. The events are ordered by the start time. If an occur-rence of is instantaneous, then .Ane-sequence of size k is called a k-e-sequence . For example,
Figure 1. Basic relations between two event-intervals: (a) Meet, (b) Match, (c) Overlap, (d) Contain, (e) Follow.
 let us consider the -e-sequence shown in Fig. 2. In this case the e-sequence can be represented as follows: = Finally, an e-sequence database = is a set of e-sequences.

In an e-sequence database there may be patterns of tem-porally correlated events; such patterns are called arrange-ments . The definitions given in Section 2.1 can describe temporal relations between two event intervals but they are insufficient for relations between more than two. Consider for example the two cases in Fig. 3. Case can be easily expressed using the current notation as: .This is sufficient to determine that overlaps with , fol-lows and follows . On the other hand, the expres-sion for case ,i.e. , is insufficient, since it gives no information about the relation between A and C. Thus, we need to add one more operand in order to express this relation concisely. In order to define an arrangement of more than two events we need to clearly specify the tem-poral relations between every pair of its events. This can be done by using the  X  X ND X  operand denoted by .There-fore, the above example can be sufficiently expressed as fol-lows: . Based on the previous analy-sis, we can efficiently express any kind of relation between any number of event intervals, using the set of operands:
Consequently, an arrangement of events is de-fined as = ,where is the set of event intervals that occur in , with = ,and = set or temporal relations between each pair ,for
Figure 3. (a) can be expressed with four operands and (b) cannot. fines the temporal relation between and . The size of an arrangement = is equal to . An arrangement of size is called a -arrangement . For example, consider arrangement of size shown in Fig. 3 (a). In this case = and = rangement in an e-sequence database is the number of e-sequences in the database that contain the arrangement. The relative support of an arrangement is the percentage of e-sequences in the database that contain the arrange-ment. Given an e-sequence , contains an arrangement = , if all the events in also appear in with the same relations between them, as defined in . Con-sider again arrangement in Fig. 3(a) and e-sequence in Fig. 2. We can see that all the event intervals in appear in and further, they are similarly correlated, i.e. Overlap ( , ), Follow ( , ), Follow ( , ). Thus, is contained in or by . Given a minimum support thresh-old , an arrangement is frequent in an e-sequence database, if it occurs in at least e-sequences in the database.

Based on the above definitions we can now formulate the problem of mining frequent temporal arrangements as fol-lows: given an e-sequence database D and a support thresh-old , our task is to find set , where is a frequent arrangement in . 2.3 Related Work
Discovering all frequent sequential patterns (or episodes) in large databases is a very challenging task since the search space is large. Consider for instance the case of a database with attributes. If we are interested in finding all the length frequent sequences ,thereareO( ) potentially frequent ones. Increasing the number of objects might defi-nitely lead to a paramount computational cost. The Aprior-iAll algorithm suggested in [3] employs a bottom-up search enumerating every single frequent sequence. This implies that in order to produce a frequent sequence of length l ,all subsequences have to be generated, according to the apri-ori principle stated in [2]. It can be easily deduced that this exponential complexity is limiting all the apriori-based al-gorithms to discover only short patterns. According to [6], the candidate production can be done faster and more ef-ficiently using a set-enumeration tree. Based on this, re-cent algorithms [9, 24, 13, 5, 20] have introduced more effi-cient techniques and data-structures in order to improve the pattern mining performance. Some of these algorithms re-sulted in two or more orders of magnitude in performance improvements over Apriori on some data-sets.

If small differences in the problem definition are ig-nored, the vast majority of the former algorithms extract frequent sequential patterns based on a support threshold. This threshold limits the results to the most common or  X  X amous X  ones among all the sequences in the database, causing a lack of user-controlled focus in the pattern min-ing process that results in an overwhelming volume of po-tentially useless patterns. A solution to this problem sug-gested in [10], was to introduce user-specified constraints, modeled by regular expressions. Sequential pattern min-ing algorithms developed so far, despite their outstanding performance in databases of short sequences, yield dramati-cally poor performance when the support threshold is low or when the databases consist of very long sequences. A sim-ilar problem occurs when mining frequent itemsets [12, 2]. In order to overcome this problem, a very interesting solu-tion has been proposed in [16], where the mining process fo-cuses only on closed itemsets . An itemset I is closed if there is no superset of I in the database with the same support. Consequently, there have been some efficient algorithms de-veloped for mining frequent closed itemsets [17, 22, 25, 7] and closed sequences [23, 21]. Moreover, [8, 1] consider the discovery of association rules in temporal databases and thus the extraction of temporal features of associated items. Also, [14] introduces the notion of episodes, i.e. combina-tion of events with a partially specified order, where each episode may have some minimal duration.
A straightforward approach to mine frequent patterns from a database of e-sequences is to reduce the problem to a sequential pattern mining problem by converting to a transactional database . Without any loss of informa-tion, we can keep only the start and end time of each event interval. For example, for every event interval in , that describes an event starting at and ending at , we only keep and in . Now, we can apply an efficient existing sequential pattern mining algorithm, e.g., SPAM [5], to generate the set of frequent sequences in . Every pattern in should be post-processed to be converted to an arrangement. However, this approach has two basic drawbacks, regarding cost and efficiency: (1) post-processing can be very costly, since in the worst case the number of frequent patterns in will be exponential ( ), where is the number of distinct items in the database, and the cost of converting every pattern in to an arrangement is , (2) the patterns in will carry lots of redundant information. Next, we propose two effi-cient algorithms for mining frequent arrangements of tem-poral intervals that address the previous problems. Both al-gorithms employ a tree-based enumeration structure like the one introduced in [6]. The first algorithm uses breadth first search to generate the candidate arrangements, whereas the second uses depth first search. 3.1 The Arrangement Enumeration Tree
The tree-based structure used by our algorithms is called arrangement enumeration tree . An arrangement enumera-tion tree is shown in Fig. 5. Each level consists of a set of nodes, denoted as , that hold the complete set of -arrangements. Let denote node on level ,where indicates the position of in the -thlevelbasedonthe type of traversal used by the algorithm. For every node fined by the node, based on which, an intermediate set of nodes (as shown in Fig. 5) is created, denoted as , linking to . Each node in represents a temporal relation in . In the case shown in Fig. 5, and on level , ,i.e. we have one node for every item in . Then, perform-ing temporal joins on the nodes of level ,thesetof the -arrangements of Level is generated, with = created by joining the nodes in -with those in , (2) for every node , is defined and then linked to . The arrangement enumeration tree is created as de-scribed above, using the set of operands defined in Section 2 and it is traversed using either breadth-first or depth-first search.
 3.2 BFS-based Approach
In this section we propose an event interval mining algo-rithm that uses the arrangement enumeration tree described above. First, we introduce the ISIdList structure, that attains a compact representation of the intervals and a relatively low join cost. More specifically, an ISIdList is defined for every arrangement generated by this process. The head of the list is the representation of the arrangements using and the event labels comprised in it; each record is of type ( , -), where is the e-sequence id in that sup-ports the arrangement, and -is a double-linked list of all the time intervals during which the arrangement oc-curs in the corresponding e-sequence in .

Consider, for example, an e-sequence database with three unique items , and , as in Fig. 4. The ISIdLists of and is shown in Fig. 6. Let denote the complete set of frequent -arrangements and the set of candidate frequent -arrangements. Our algorithm will first scan to find , i.e. the complete set of -arrangements. To achieve this, a scan will be performed on for every event type . If the number of e-sequences in that contain an interval of satisfies the support threshold, will be added to , and its ISIdList will be updated accordingly.

In order to generate the candidate -arrangements, we use the arrangement enumeration tree described above to get the nodes of level , along with the set of their corre-sponding intermediate nodes. Then, removing those that do not satisfy the support threshold constraint we get set of frequent -arrangements.

Moving to the next levels, i.e. generating the set of fre-quent -arrangements, we traverse the nodes on level -. Note that these nodes correspond to the set of frequent ( -)-arrangements. For every node , a new node is created on level , along with the set of intermediate nodes in . For every node in an ISIdList is created that contains: (1) the set of items of , (2) the types of -relations between them, (3) for every type of -relation a pointer to the intermediate nodes on Level that correspond to that -relation. Also, note that if an arrangement is found to be infrequent, then the node in the tree that corresponds to that arrangement is no further expanded.

The above process is more clear through the following example: consider database in Fig. 4 and assume that
Figure 7. The set of frequent and -arrangements. we get = . Based on and the enu-meration tree, set of the frequent -arrangements is gen-erated. In our case, we get all the possible pairs of the -arrangements in , i.e. N(2), and for every pair of events in the arrangements, is scanned to get all the types of relations between them, i.e. . If these relations sat-isfy the support threshold they are added to .Thenwe produce based on . The algorithm first creates , following a breadth-first search traversal, along with the set of intermediate nodes. Every node in that satisfies one arrangement: . , and described in Algorithm 1, considering an input database and a minimum support threshold . 3.3 DFS-based Approach
In a breadth-first search approach the arrangement enu-meration tree is explored in a top-bottom manner, i.e. all the children of a node are processed before moving to the next level. On the other hand, when using a depth-first search approach, we must completely explore all the sub-arrangements on a path before moving to another one. A DFS-based approach for mining frequent sequences has been proposed in [20]. Based on this, the previous algo-rithm can be easily modified to use a depth-first search can-didate generation method. This can be done by adjusting function so that it follows a depth-first search traversal. Consider the previous example: our algorithm will first generate node = followed by on.

The advantage of DFS over BFS is that DFS can lead us very quickly to large frequent arrangements and there-fore we can avoid some expansions in the other paths in the tree. For example, say that a -arrangement is found to be frequent. Then, the set of all sub-arrangements of will also be frequent according to the Apriori principle. Thus, we can skip those expansions in the enumeration tree re-ducing the cost of computation. To do so, one more step is added to Algorithm 1: when a node is found to contain a frequent arrangement, each sub-arrangement is added to and the corresponding expansions are made on the tree. However, in BFS there is more information available for pruning. For example, knowing the set of -arrangements before constructing the set of -arrangements can prevent us from making expansions that will lead to infrequent ar-rangements. This information, however, is not available in DFS. 3.4 Hybrid DFS-based Approach
In this section we consider a hybrid event interval min-ing approach based on the following observation: since the ISIdLists contain pointers to the nodes on the second Level of the tree, a DFS-based approach would be inappropriate since for every node we would have to scan the database multiple times to detect the set of -relations among the items in that node. In the BFS-based approach these nodes will already be available, since they have been generated in the second step of the algorithm. Thus, we use a hybrid DFS approach that generates the first two levels of the tree using BFS and then follows DFS for the rest of the tree. This would compensate for the multiple database scans dis-cussed above, since the set of frequent -arrangements will already be available thereby eliminating the need for multi-ple database scans.
In this section we present experimental results on the per-formance of our two algorithms in comparison with SPAM [5]. All the experiments have been performed on a 2.8Ghz Intel(R) Pentium(R) dual-processor machine with 2.5 gi-gabytes main memory, running Linux with kernel . The algorithms have been implemented in C++, compiled using g++ along with the -O3 flag, and their runtime has been measured with the output turned off. Note that for input : : a database of e-sequences. output :Theset of the frequent arrangements in . foreach event type do end while do end Algorithm 1: A BFS-based algorithm for discovering fre-quent temporal arrangements in a database of e-sequences. SPAM, the post-processing time of converting the sequen-tial patterns to arrangements has not been counted. Also, as mentioned in Sec. 3, SPAM is tuned as follows: for every event interval we keep only the start and end time; as for the postprocessing phase the frequent arrangements are extracted from the sequential patterns as described in Sec. 3. The patterns found by SPAM comprise a set of start and end points of event intervals, which are converted to ar-rangements after the postprocessing phase. SPAM finds all patterns found by our two algorithms. However, it produces a great number of redundant patterns. For our experimental evaluation we have used both real and synthetic datasets. 4.1 Experiments on Real Data
We have performed a series of experiments on two real datasets. One was an American Sign Language (ASL) database and the other was a sample network dataset of ODFlows taken from Abi-lene, which is an Internet2 backbone network, connecting over 200 US universities and peering with research net-works in Europe and Asia. It consists of 11 Points of Pres-ence (PoPs), spanning the continental US. Three weeks of sampled IP-level traffic flow data was collected from every PoP in Abilene for the period December 8, 2003 to Decem-ber 28, 2003. 4.1.1 Experiments on the ASL SignStream Database The first series of experiments have been performed on the American Sign Language database created by the Na-tional Center for Sign Language and Gesture Resources at Boston University. The SignStream database consists of a collection of utterances, where each utterance asso-ciates a segment of video with a detailed transcription. Ev-ery utterance contains a number of ASL gestural and gram-matical fields (e.g. eye-brow raise, head tilt forward, wh-question), each one occurring over a time interval. We first tested our algorithms on a small part of the database that only comprised all the utterances that contained a  X  X h-question X . Our goal was to detect all frequent arrangements that occurred during a  X  X h-question X . In this dataset, called age number of items per sequence equal to .Asshownin Fig. 8(a), Hybrid DFS outperformed both BFS and SPAM for supports less than . Then we tested our algorithms on the whole Signstream database that contained utter-ances with an average sequence of items per sequence. The algorithms have been tested for various supports and have been compared in terms of runtime. The experimental results in Figure 8(b) show that the Hybrid DFS-based ap-proach outperforms the BFS-based especially in small sup-ports. In both cases SPAM starts with a runtime between that of BFS and Hybrid DFS and for small supports the run-time increases dramatically. 4.1.2 Experiments on Network Data Our algorithms have also been tested on a network dataset of sequences with an average sequence size of items per sequence. The data has been obtained from a col-lection of ODFlows. We have selected two routers that were shown to have a high communication rate with each other, and have monitored the IP connections from one (LOSA: router in LA) to the other (ATLA: router in Altanta) for three days. A sequence in our dataset is the set of IP con-nections from LOSA to ATLA for every minutes. Due to the huge number of IP addresses, we have selected IPs that appear most frequently in these three days.
Our experimental results are shown in Figure 8(c), where again Hybrid DFS outperforms both BFS and SPAM in low supports. 4.2 Experiments on Synthetic Data
Due to the relatively small size of the current SignStream database, we have generated numerous synthetic datasets to test the efficiency of our algorithms. 4.2.1 Synthetic Data Generation The following factors have been considered for the gener-ation of the synthetic datasets: (1) number of e-sequences, (2) average e-sequence size, (3) number of distinct items, (4) density of frequent patterns. Using different variations of the above factors we have generated several datasets. In particular, our datasets were of sizes , , , , various numbers of distinct items, i.e. , and .
 Also, we have considered different densities of frequent pat-terns. We first created a certain number of frequent patterns that with medium support thresholds of (sparse), (medium density) and (dense) would generate a lot of frequent patterns and then added random event intervals on the generated sequences. 4.2.2 Experimental Results The experimental results have shown that Hybrid DFS clearly outperforms BFS, and especially in low support values and large database sizes Hybrid DFS is twice as fast as BFS. Regarding the performance of SPAM, we have concluded that in medium support values and small database sizes SPAM performs better than BFS but worse than Hybrid DFS, whereas in small support values and large datasets BFS outperforms SPAM. We compared the three algorithms on several small, medium and large datasets for various support values. The results of these tests are shown in Fig. 9. Due to space limitations we present only a por-tion of our results focusing on the most significant ones. As expected, SPAM performs poorly in large sequences and small supports. This behavior is expected since for every ar-rangement produced by BFS and Hybrid DFS, SPAM gen-erates all the possible subsets of the start and end points of the events in that arrangement. As the database size grows along with the average e-sequence size, SPAM will be pro-ducing a great number of redundant frequent patterns that yield to a rapid increase of its runtime.
We have formally defined the problem of mining fre-quent temporal arrangements of event interval sequences and presented two efficient methods to solve it. The key novelty of our methods is that they do not make the as-sumption that events occur instantaneously. The BFS-based approach uses an arrangement enumeration tree to discover the set of frequent arrangements. The DFS-based method further improves performance over BFS by reaching longer arrangements faster and hence eliminating the need for ex-amining smaller subsets of these arrangements. Our exper-imental evaluation demonstrates the applicability and use-fulness of our methods. An interesting direction for fu-ture work is to incorporate additional constraints and partial knowledge about the frequency of some arrangements.
