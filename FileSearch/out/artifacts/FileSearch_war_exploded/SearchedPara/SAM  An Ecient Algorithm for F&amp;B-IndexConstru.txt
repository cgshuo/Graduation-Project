 Increasing popularity of XML in recent years has generated much interest in query pro-cessing over graph-structured data. To summarize the structure of XML data and sup-F&amp;B-Index is the smallest structural index covering all branching path queries [6]. demand. In [4], based on graph model, PT algorithm which is first proposed in [7] is extended to build F&amp;B-Index. Even though PT algorithm can construct F&amp;B index Since space is the key problem of PT, to find an algorithm which can build F&amp;B-Index part by part is a natural idea. However, in graph model, a node can have relation with all other nodes in worst case and relations can be transmitted along circles in graph. These
Surprisingly, although some researches model XML data as graphs, most of XML data can be represented as directed acyclic graphs (DAGs) especially in applications. For example, the gene ontology data available at [9] can be modeled as DAGs with nodes representing gene terms and edges denoting their is-a and part-of relationships. algorithm for most XML data in practice.
 model. Very few works have been done to solve this problem. Based on DAG and stream And-Merge algorithm (SAM for brief) which can save much space and time cost. Given a DAG G , SAM loads data nodes from streams and build F-partition and B-partition of G part by part. Then these two partitions ar e merged to form the index nodes of F&amp;B-Index. Finally, F&amp;B-Index is formed by adding edges between those index nodes. With maintaining partial index instead of the whole graph and index in main memory, SAM can save much space cost. Searching nodes within a few nodes, SAM can save much time cost. Our major contributions include:  X  Novel Algorithm. Based on XML DAG stream model, we propose an e  X  cient  X  Show Correctness. With analysis on correctness and complexity of time and  X  Performance Study. With extensive experiments, we show SAM algorithm out-Organization. The rest of this paper is organized as follows. We present background in section 2 and describe SAM algorithm in detail in section 3 . The theoretical analysis is shown in section 4. We report the experimental results in section 5. Related work and conclusion are presented in section 6 and 7. 2.1 XML DAG Stream Model model with XML stream model. In XML DAG stream model, each node v has an at-stream S i is associated with graph nodes whose depth is i ; Since XML data can be modeled as an directed acyclic graph, depth ( v ) can be easily determined during the isempty ( S i ) return the boolean value which shows whether S i is empty. Example 1. The DAG stream model S of graph in Figure 1(b) can be described as fol-lows: S S 0 S 1 S 2 S 3 S 4 ,S 0 root ,S 1 m n ,S 2 a 1 a 2 ,S 3 b 1 b 2 b 3 , S 2.2 F&amp;B-Index Structural index. A structure index for a DAG graph takes the form of another DAG graph ( V I G I ), which can be built by following step s: (1) according to some equivalence relation, partition all data nodes into some e quivalence classes, (2) form an index node for every class, and (3) add an edge between two index nodes i and j if there is an edge between some data node in i and j . Obviously, the relation used to partition data nodes determines the kind of the structure inde x. And how to partition nodes into classes determines the cost of this procedure.
 F&amp;B-bisimulation. F&amp;B-bisimulation is a binary relation which can be used to con-struct structure index. It can be defined as follows: Definition 1. Given a XML DAG, for graph nodes n 1 and n 2 ,wesayn 1 and n 2 satisfy F B-bisimulation, that is n 1 FB n 2 , if: 1. [label condition] Both of n 1 and n 2 are root, or label ( n 1 ) label ( n 2 ) . Obviously, F&amp;B-bisimulation is reflexive, symmetric and transitive, so it is an equiva-lence relation. Moreover, if n 1 and n 2 satisfy label condition and incoming edge condi-condition and outgoing edge condition, we say n 1 and n 2 satisfy F-bisimulation that is n Theorem 1. Node n 1 and n 2 satisfy F B-bisimulation if and only if they satisfy both F-bisimulation and B-bisimulation. F&amp;B-Index. While building structure index, if we use F&amp;B-bisimulation to partition nodes, the set of equivalence classes we got is F&amp;B-partition, and the structure index we got is F B-Index . Moreover, using F-bisimulation or B-bisimulation to partition graph nodes, F-Index or B-Index which is also one kind of structure index can be con-structed. And during these two procedures, the two sets of equivalence classes we got are F-partition and B-partition. 2.3 PT Algorithm PT algorithm is proposed by Paige and Tarjan [7] to solve the relational coarsest par-tition problem, and this algorithm can be extended to solve the problem of building F&amp;B-Index. For a given graph G ( V G E G ), this algorithm can be implemented in O ( E G log V G ) time cost and O ( E G V G ) space cost. Because of searching node to partition in large space, the coe  X  cient of E G log V G is usually very large. In this section, we describe SAM algorithm in detail. First, we make a outline of SAM algorithm, then we introduce SAM step by step. 3.1 Outline of SAM Algorithm and Notations Since in XML DAG model data nodes come from streams with di erent depth, we can load nodes according to their depth. Such a model makes it possible to process DAG stream model, SAM (Scan-And-Merge) has been proposed. It includes three steps. First, SAM scans all nodes through XML stream to build F-partition and B-partition. Then, these two partitions are merged to compute F&amp;B-partition. At last, SAM forms an index node for each set in F&amp;B-partitio n and add edges between index nodes.
To make the description simple and clear, we define four kinds of nodes used during the execution of SAM: Example 2. Consider DAG in Figure 1(b). Its XML DAG stream is described in Figure 2. We can see that each node with depth i is put into stream S i and nodes in the same stream have the same depth. Nodes are scanned from stream S 0 to S 4 and B-partition described in Figure 2 is built. In B-partition, all nodes sa tisfying B-bisimula tion are put into the same set. Nodes are scanned from stream S 4 to S 0 and F-partition described in Figure 2 structures in Figure 2 supports these two partitions X  construction.
 3.2 Scan and Partition In this subsection, the first step of SAM is presented. We first make an overview, then introduce some data structures we used and describe two algorithms for building B-twice in this step. First, SAM scans streams from top to bottom and build B-partition. Then, it scans in the opposite order and build F-partition. During building partitions, many streams with di erent depth will be scanned, but at one time only two streams are maintained. For example, during building B-partition, if SAM is scanning stream S i whose depth is i , there are only S i and S i 1 in memory. Each stream S j (0 j i )has been deleted and each stream S j ( j i ) has not been loaded into memory. Data Structures. During this step, three kinds of tables are used to support build-F-partition. During following descripti on, we use index node to represent a BNode or FNode.  X  X  atanode to I ndexnode T able: DI-Table for short, it is used to map one data node  X  X  ode E xample T able: NE-Table for short, it is used to store one of the data nodes  X  X  egree Z ero T able: DZ-Table for short, it is used to store nodes with no parents Algorithm 1. ScanBuildBpartition( S ) As Figure 2 shows, five tables are used to build partitions, and their pointers are stored in a 5-array pointers .Formore, l DI and l NE point to the DI-Table and NE-Table of the low stream whose depth is bigger; h DI and h NE point to the DI-Table and NE-Table of the high stream whose depth is smaller; DZ is the pointer of DZ-Table. ScanBuildBpartition Algorithm. The algorithm for building B-partition is shown in Algorithm 1. The key idea of this step is to scan DNodes through XML DAG stream and decide whether to build a new BNode or to insert this DNode into some BNode according to bisimulation relations. Line 2, in Algorithm 1, controls the order of visiting stream nodes. Lines 3 deletes nodes of high stream, because they won X  X  be used any more. Lines 6 gets a node q from low stream S i and calls Function to merge q with nodes in the same set as q in B-partition. Function MergeNode finishes such a task according to rules of B-bisimulation. In F unction MergeNode, lines 3 and 7 build a new BNode, and lines 4 and 8 insert q into some BNode. Function FindNodeToMerge searches only in children of one parent of q not children of all parents of q ,andfind node to merge q with. To save space, Algorithm 1 only maintains two of all streams which is called high and low stream; to save time, Algorithm 1 only makes searching in children of q  X  X  one parent. The detail in complexity will be analyzed in section 4.2. m ScanBuildFpartition Algorithm. ScanBuildFpartition Algorithm can be easily got by modifying ScanBuildBpartition Algorithm: reverse the order of scanning streams and swap operations of parent and children in Algorithm. By limits of space, we do not introduce such a similar algorithm in detail.
 Algorithm 2. MergePartition 3.3 Merge and Build F&amp;B-partition By scanning step described in 3.2, we can get two partitions of data nodes, F-partition and B-partition. In this subsection, we in troduce how to get the F&amp;B-partition of XML data with F-partition and B-partition. The key idea of this procedure comes from The-orem 1: if node a and b belong to the same set in both F-partition and B-partition, they belong to the same set in F&amp;B-partition; otherwise they belong to di erent sets. This algorithm of merging is sketched in Algorithm 2. Algorithm 2 accepts F-partition A and B-partition B as inputs and output s F&amp;B-partition C . During execution, the set with the current smallest id is selected to process iteratively. AN and BN are used to maintain the smallest id of A and B , and will be updated while a set of C has been com-form a set q of C . Then, q  X  X  element is deleted from A and B ,and AN and BN is updated. This procedure is executed until all nodes are processed.
 Example 3. Consider the given F-partition and B-partition in Figure 3. When Merge Partition algorithm finishes, F B-partition C is got. W e can see, nodes a 1 and a 2 don X  X  belong to the same set in F B-partition bec ause they don X  X  belong to the same set in B-partition; node c 1 c 2 and c 3 belong to the same set in F B-partition because they belong to the same set in both F-partition and B-partition. 3.4 Form F&amp;B-Index In this step, we first form an index node for each set of F&amp;B-partition, then add edges between index nodes. The rule of adding edges is that: given index node a and b ,ifthere is a data node a in a and b in b such that an edge ( a b ) exists in data graph, we add an edge ( a b ) between a and b . Although this step can be implemented very e  X  ciently in naive way, there are also some techniques to save space. When adding edges, if we maintain two streams as previous steps and scan the edges between them, this step can be easy to implement with O ( max S i ) space complexity and O ( E ) time complexity. By limits of space we won X  X  describe it in detail. In this section, first we prove the correctness of SAM. Then we will analyze the space and time complexity of SAM. 4.1 Correctness of SAM In this part, first we propose lemma 1 which is used by other lemmas and theorems. Then, we prove lemma 2 and theorem 2 to show that SAM can build B-partition cor-rectly. Third, we prove lemma 3 and theorem 3 to show that SAM can build F-partition correctly. Finally, we prove theorem 4 to show the correctness of SAM.
 Lemma 1. Given a DAG-structured XML data G , if node m and n satisfy one of fol-lowing three formulae: m B n , m F n , m FB n , we know depth ( m ) depth ( n ). Lemma 2. Given a DAG-structured XML data G , based on DAG stream model, node m and n can be put into the same set by Algorithm 1, if and only if m B n . Proof. To prove this lemma, we only need to show correctness of two propositions: : If node m and n are put into the same set in Algorithm 1, line 5 or line 12 must be :If m B n , there must be depth ( m ) depth ( n ) according to Lemma 1. Suppose m Finally, we can know node m and n can be put into the same set by Algorithm 1, if and only if m B n .
 By lemma 2, we can easily get the following theorem.
 Theorem 2. Given a DAG-structured XML data G, based on DAG stream model, Al-gorithm 1 ScanBuildBpartition can correctly return B-partition of G.
 Similarly, we can get the following theorem.
 Theorem 3. Given a DAG-structured XML data G, based on DAG stream model, Al-gorithm ScanBuildFpartition can correctly return F-partition of G.
 Theorem 4. Given a DAG-structured XML data G, based on DAG stream model, Al-gorithm SAM can return the correct F B-Index.
 Proof. [Sketch] Given a DAG-structured XML data G , there are three steps to process G in SAM. By theorem 2 and 3, we can know step 1 can build F-partition and B-partition of G correctly; by theorem 1, it is easy t o see that step 2 can build correct correctness is obvious. Finally, we know that given a DAG-structured XML data G , based on DAG stream model, Algorithm SAM can return the correct F&amp;B-Index. 4.2 Complexity of SAM To analysis complexity of Algorithm SAM, we describe an XML document as DAG G V G E G where V G is the node set of G ,and E G is the edge set of G . Moreover,  X  G  X  X  F&amp;B-Index is G FB , whose node set is V FB and edge set is E FB .  X  G  X  X  B-Index is G B , whose node set is V B and edge set is E B .  X  G  X  X  F-Index is G F , whose node set is V F and edge set is E F .
 sponding nodes with depth i. Label num denotes the total number of distinct labels. We identify the max number of one index node X  X  children as f maxc and identify the max number of one index node X  X  parents as f maxp .Both f maxc and f maxp are small integers for most XML data. So we have the following theorem.
 Theorem 5. Given an XML DAG G, Algorithm 1 has the worst-case space complexity by O ( max ( f maxc f maxp ) max V i ) O ( max V i ) and the worst-case time complexity of O ( f maxc f maxp V ) which can be simplified to be O ( V ) . For more, Algorithm ScanAnd-BuildFartition has the same space and time complexity as Algorithm 1. Theorem 6. Given an XML DAG G, Algorithm 2 has the worst-case space complexity of O ( max ( V i )) and time complexity of O ( V ) .
 Theorem 7. Given an XML DAG G, in SAM Algorithm, the procedure of forming F B-Index has space complexity of O ( max V i ) and time complexity of O ( E ) . Theorem 8. Given an DAG G, to build F B-Index, the worst-case space complexity of SAM is O ( max V i ) , and the worst-case time complexity of SAM is O ( V E ) . Comparing with PT Algorithm. The space complexity of PT is O ( V E )whichis larger than O ( max V i ), and the time complexity of PT is O ( E log V ) which is larger than O ( V E ) in graph model. 5.1 Experiment Setting We implemented SAM in C and all experiments were run on a 1.7Ghz Pentium IV processor with 256MB of main memory. We two typical data sets from real world to test SAM. One data set is DAG-structured gene ontology data [9] and the other one is XML data generated from XMark benc hmark [10] by deleting some edges. 5.2 Comparison XMark50M, XMark100M and gene ontology (30M) as data set and run SAM and PT sep-arately on data set. Gene ontology and XMark50M are both treated as normal (not small or large) real world data. Because the size of XMark can be changed, we use XMark10M as the small data and XMark100M as the large data.
 Space Cost. We use the number of nodes and edges that must be maintained during execution of algorithm to measure the space cost of two algorithms. Figure 4 shows the space cost of SAM and PT. Note that when PT is running on XMark100M, by memory limit, it is busying on swapping bu ers between memory and disk, and can X  X  finish building F&amp;B-Index, so we just record the number as what it was until we killed PT algorithm. This appearance just shows that PT is unpractical for large XML data and SAM can be used to build F&amp;B-Index for very large XML data. It X  X  easy to see that proof of complexity, SAM has less space complexity than PT, so it is natural. Time Cost. Figure 5 shows the execution time of SAM and PT. Note that the time is in log scale. In this testing experiment, after waiting very long time, PT still couldn X  X  finish building F&amp;B-Index, so we just record a max number which is much smaller than it took. This appearance shows that PT is unpractical for large XML data, and SAM can be used to build F&amp;B-Index for very large XML data. We can see that for all data sets our proof of complexity, SAM has less time complexity than PT, so it is natural. 5.3 Scalability In this section, to study the scalability of SAM, we vary the size of XMark data set from 1M to 100M, run experiments and record execution time and the numbers of nodes and edges maintained in memory. Figure 6 and 7 show the result. We can observe that all three parameters increase linearly with the increase of the size of data set. SAM can scale very well for such large XML data as that. Structure index for XML have been widely used for indexing, query processing and se-lectivity estimation. DataGuides [14] was one of first used structure index in query pro-cessing. Simulation and bisimulation [13,16] are two notions in graph theory which are used to build relations on vertices. The idea of simulation were first applied in process-ing semistructured data in [15]. Later, 1-Index [1] and A(k)-Index [2] were proposed to support query processing. F&amp;B-Index based on bisimulation were first proposed in [4]. construction algorithm, SAM (Scan-And-Merge). Theoretical analysis shows that SAM is correct and has O ( max V i ) space complexity and O ( V E ) time complexity in the
