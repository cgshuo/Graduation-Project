 Multipartite entity resolution seeks to match entity mentions across several collections. An entity mention is presumed unique within a collection, and thus could match at most one entity mention in each of the other collections. In addition to domain-specific features considered in entity resolution, there are a number of domain-invariant structural contraints that apply in this scenario, including one-to-one assignment as well as cross-collection transitivity. We propose a princi-pled solution to the multipartite entity resolution problem, building on the foundation of Markov Logic Network (MLN) that combines probabilistic graphical model and first-order logic. We describe how the domain-invariant structural con-straints could be expressed appropriately in terms of Markov logic, flexibly allowing joint modeling with domain-specific features. Experiments on two real-life datasets, each span-ning four collections, show the utility of this approach and validate the contributions of various MLN components. H.3.3 [ Information Search and Retrieval ]: Clustering; H.2.8 [ Database Applications ]: Data mining entity resolution; markov logic network; structural constraints;
Often the same entity, be it a person, document, or ob-ject, is mentioned in several separate collections, and there is a need to identify that several mentions refer to the same entity. For instance, when two health organizations merge, the medical records of patients need to be integrated. While shopping for a camera, one may wish to compare prices on online shops, such as BestBuy, Newegg, or Amazon.  X  Work done while at Singapore Management University.
This problem, formalized by [3], is known by several terms including entity resolution [2, 9], deduplication, or reference reconciliation. Most works focus on either the similarity measure between two mentions [10, 7, 6], or the algorithmic framework to match the mentions (e.g., graph matching [5]).
This paper focuses on structural constraints facing the en-tity resolution problem. Real-world scenarios have varying structures. In one scenario (deduplication), a single col-lection may contain duplicate elements to be resolved. In a different scenario (referred to as multipartite resolution), two or more collections need to be integrated into a uni-fied collection, by resolving which entity from one collection corresponds to which entity from another collection.
Focusing on the multipartite resolution scenario, we as-sume that each collection is free of duplicates, because each collection belongs to a party (e.g., an online shop, or a hos-pital) with an interest in maintaining a high-quality collec-tion, or because the collection has been previously cleaned up through deduplication (a related, yet distinct research problem). Thus, when integrating two collections, there is a natural constraint that a mention from one collection could match at most one mention from the other. One possible approach is graph matching [5], whereby a one-to-one as-signment may be obtained from maximum weight bipartite matching. However, for three or more collections [15], the 3-dimensional matching problem is NP-hard [1].

Here, we take the approach of incorporating structural constraints into entity resolution with Markov Logic Net-work (MLN) [12]. An MLN-based formulation has several advantages. First, the proposed domain-invariant structural constraints can be combined with previous MLN predicates for entity resolution based on domain-specific features [14] or constraints [13]. Second, it is  X  X xtendable X , as MLN is an open framework that allows joining the entity resolution task with other mutually-reinforcing tasks such as segmentation [11]. Third, MLN is probabilistic, whereby the importance of different constraints can be learned from data.

Contributions. First , we describe a series of domain-invariant structural constraints for MLN-based bipartite en-tity resolution (see Section 3), and investigate how the con-straints extend to multipartite structures (see Section 4). Second , we validate the effectiveness of these constraints on real-life datasets of phones and cameras (see Section 5).
Problem Statement. As input, we are given a set of N collections { X 1 ,X 2 ,...,X N } . Each collection X i consists of M i entity mentions, where each mention in X i is associated with some features. Our focus in this work is on structural constraints, and not on the feature set or similarity measure. For simplicity, and without loss of generality, for subsequent discussions we assume there is a single feature, which is the name of the entity, and we use Jaccard similarity [6].
We associate two mentions x  X  X i and y  X  X j from dif-ferent collections with a binary variable Match ( x,y ), whose value is 1 if x and y  X  X atch X , i.e., referring to the same entity, and is 0 otherwise. Our objective is to determine the states of these variables for all pairs of entity mentions. If x and x belong to the same collection X i , trivially Match ( x,x i.e., each collection is assumed to be free of duplicates.
Markov Logic Network (MLN). Our approach is to express structural constraints for entity resolution as first-order logic formulae. Each formula may use four types of symbols: constants, variables, functions, and predicates. Constants are objects in the domain of interest, which in this case are the entity mentions. Variables, e.g., x , range over objects in the domain. Predicates represent relations among objects, e.g., Similar ( x,y ) is a predicate that indicates that x and y are similar in feature, whereas Match ( x,y ) represents that x and y refer to the same entity. The formulae for the structural constraints are specified in Sections 3 and 4.
Some constraints are hard constraints, i.e., they must be satisfied. Others are probabilistic constraints, i.e., solutions that satisfy them are more likely to be correct. The first-order logic formulae are weighted, with higher weight in-dicating higher probabilities. To model these weights in a principled manner, as well as to learn them from data, we employ Markov Logic Network (MLN) [12], which combines probabilistic graphical model and first-order logic. An MLN is a set of weighted first-order logic formulae (each formula f is associated with weight w t ).  X  is a possible solution in the space of possible solutions  X . The probability P ( X  =  X  ) is expressed in Equation 1, where Z is the partition function and f t (  X  ) is 1 if the formula f t holds in  X  and 0 otherwise.
In the inference stage, we use the learnt weights to esti-mate the probability of Match ( x,y ) for every pair of entity mentions from any two different collections.
In this section, we begin with the first-order logic formulae for constraints in bipartite entity resolution.

Similarity Constraint. There are various features used to match entities in entity resolutions. Some are domain-specific [14], which are not our focus here. Instead, we use a domain-invariant constraint specifying that matching en-tities share some level of similarity. We introduce the pred-icate Similar ( x,y ) when x and y has a similarity above a certain threshold (we try different values based on Jaccard and settle on 0.5 for experiments). The basic formula links Similar (which is observed) to Match (to be determined).
There are several possible instantiations. The first in-stantiation (Equation 2) indicates that similar pairs should match, which may be too stringent when polysemy is an is-sue, i.e., many similar entity mentions do not match in real life. The second instantiation (Equation 3) indicates that matching pairs should be similar, which is more appropri-ate for the electronic products datasets that we experiment with, where different products may share similar features (e.g., iPhone 5 models of different memory sizes).

Cardinality Constraint. Due to the assumption that each collection is duplicate-free, an entity mention x  X  X cannot match more than one mention within another col-lection X j . Otherwise, the two entity mentions y,y 0  X  X matched to x would effectively be themselves matched. This  X  X t most one X  rule is expressed in Equation 4, where full stop indicates that it is an inviolable hard rule. In some scenarios, we need an  X  X t least one X  rule (Equation 5), if every mention within a collection must match at least one mention in an-other collection. If there is a bijection or one-to-one match between two collections of the same size, we model it by us-ing both at-most-one and at-least-one rules simultaneously.
Preference Constraint. While the similarity constraint helps to ensure that matching pairs have some level of sim-ilarity, it may result in false positives. If a mention x is similar to two different mentions y and y 0 , there should be a way for x to favor a match with the more similar mention. We therefore introduce another predicate Prefer ( x,y,y which indicates that x is more similar to y than to y 0 .
We then link Prefer to Match . The following first-order logic formula is inspired by the Stable Marriage Problem [4], where the objective is to arrive at a matching of  X  X en X  and  X  X omen X , such that no unmatched couple would rather be with each other than with their respective partners. Ex-pressed in first-order logic, Equation 6 makes it more likely that if x is matched to y , and x 0 to y 0 , we would not have the case where x prefers y 0 to y , and y 0 prefers x to x
Global Constraint. The preference constraint above in-duces a local optimization by preferring one matching pair over another. There is no guarantee that the matching is op-timized in a global way for all pairs. Complementarily, this is the strength of graph matching [5]. In graph matching, every mention is a vertex in a bipartite graph. Each edge between two mentions is weighted by the similarity value. Employing maximum weight bipartite matching obtains the matching with the highest sum of similarities. Due to the flexibility of MLN, it is feasible to be informed by this global solution. We introduce another predicate MaxWeight (x, y) that indicates that ( x,y ) is part of the maximum weight bi-partite matching solution. For generality, we also model the greedy version [5], which iteratively constructs the matching solution by selecting the highest-weighted edges first, as the predicate Greedy (x, y). It is feasible to factor these results into the MLN formulation, as shown in Equations 7 and 8.
When there are N &gt; 2 collections to be integrated, the problem turns into multipartite entity resolution. On one hand, the multipartite scenario can be decomposed into its N ( N  X  1) / 2 constituent bipartite scenarios, which enables the re-use of constraints defined in Section 3. On the other hand, modeling the problem jointly has the benefit of poten-tially allowing the bipartite matches to correct one another.
Cross-Collection Transitivity. The basic mechanism to join the bipartite matches is through cross-collection tran-sitivity. Suppose x  X  X i matches y  X  X j , and in turn y matches z  X  X k , it is probable that x also matches z , as expressed in Equation 9. This essentially creates two  X  X ath-ways X  for x to match z . One is direct, through the bipar-tite constraints defined in Section 3. The other is indirect, through transitivity via y . However, these two pathways may not always agree, which may result in errors.

To combat this, we accumulate even more evidence from a greater number of collections. For instance, for four col-lections involving v  X  X l , Equation 10 is a more efficient rule that allows accumulation of evidence by combining two cross-collection transitivities. This rule has a notion of  X  X a-jority X . There are now three pathways, the direct pathway to Match ( x,z ) based on constraints defined in Section 3, and two indirect pathways via y , i.e., Match ( x,y )  X  Match ( y,z ), as well as via v , i.e., Match ( x,v )  X  Match ( v,z ). If the direct pathway is incorrect, and the two indirect pathways are cor-rect and in agreement, the latter two (intuitively forming a  X  X ajority X ) could have a corrective effect on the former.
Label vs. Feature Transitivity. In the above, we rely on the target label Match ( x,y ) to model cross-collection transitivity. This is not ideal for MLN, because the target label is not grounded, and is to be learned. As a result, it induces too much dependency among the four collections, and may propagate errors. To break these dependencies, we propose to ground the transitivities on observed features. One way is to express these transitivities in terms of global constraints, as shown in Equation 11 (using MaxWeight pred-icate) and Equation 12 (using Greedy predicate).
 MaxWeight ( x,y )  X  MaxWeight ( y,z )  X  MaxWeight ( x,v )  X  MaxWeight ( v,z )  X  Match ( x,z ) (11) The primary objective is to study the effectiveness of the MLN approach, and the contributions of various MLN rules.
Datasets. Existing datasets for entity resolution com-prise at most two collections. As our interest is in the mul-tipartite scenario, we construct two new real-life datasets comprising four collections each. Cameras consists of the names of 80 cameras that existed on all four Web sites stud-ied (Overstock, Newegg, BestBuy, and Amazon). Phones consists of the names of 70 mobile phones obtained from the same four Web sites. We use 30 entities for training, and the rest for testing. The size of the data is restricted by the need to manually label the matching across four collections.
Comparative Methods. Our main focus is on the com-parison of various MLN constraints. Table 1 lists the nine MLN X  X  to be studied, indicating the constraints included by each MLN. For learning and inference, we build the MLN solutions on the Alchemy [8] library. In addition, we will compare to two graph matching approaches, namely maxi-mum weight bipartite matching, as well as its greedy version.
Metric. MLN outputs the probability that two mentions match. One possible metric is the likelihood of true matches. However, to put our approach on the same footing as graph matching that outputs binary outcomes, we discretize the probabilities to 1 (matched) or 0 (not matched) by assigning each entity mention to the highest probability match (taking into account any conflict). We then measure the accuracy of the pairs according to the ground truth labels.

Bipartite Entity Resolution. First, we look at the pro-gression of structural constraints in the bipartite scenario (see Section 3). Table 2 shows the accuracies for Cameras , while Table 3 shows the accuracies for Phones . For four col-lections, there are six bipartite scenarios. Each row shows accuracies for each bipartite scenario. The last row is the overall accuracies, averaging the first six rows. MLN#1 that only has similarity constraint performs poorly because the one-to-one constraint is not enforced. By adding cardinality constraint, MLN#2 improves in accuracy significantly. The greatest boost in accuracy comes from adding preference constraint as in MLN#3, because the relative ranking of similarities helps to arrive at better pairings. Adding global constraints, through factoring in the MaxWeight (MLN#4) or Greedy (MLN#5), results in only a small increment in ac-curacies. These show that the progression of structural con-straints result in better performances across both datasets.
Multipartite Entity Resolution. In multipartite set-tings, it is possible to gain further accuracies by modeling all the collections jointly, rather than by decomposing them into the constituent bipartite settings. Table 4 compares accuracy of bipartite versus multipartite modeling. Only the average accuracies are shown due to space limitation. Whether MaxWeight or Greedy is used in the global and cross-collection transitivity constraints, multipartite mod-Table 2: Bipartite Entity Resolution -Cameras elling helps to improve the accuracies, e.g., from 85.7% to 90.0% for Cameras and from 93.8% to 96.7% for Phones , in the case of MaxWeight-based constraints.
 Comparison to Graph Matching. Our focus is on MLN-based approaches. Previously, when MaxWeight and Greedy are used, they are factored into the MLNs. For completeness, we include a comparison to graph matching on its own. For bipartite matching, we use MaxWeight (MW2) and Greedy (G2) directly. For multipartite match-ing (MaxWeight is NP-hard), we rely on Greedy for three (G3) and four (G4) sources respectively, as defined in [15]. Table 5 shows that MLN#6 and MLN#7 are quite similar to (in some cases slightly better than) graph matching. Im-portantly, MLN has not resulted in a drop in accuracy, while providing benefits such as extendability and probabilities.
Extendability via Domain-Specific Feature. Our fo-cus here is on domain-invariant rules. However, to illustrate the potential extendability of MLN, we show how the ad-dition of one new domain-specific rule may improve the ac-curacies. The rule is SameModel ( x,y )  X  Match ( x,y ). It uses a new predicate SameModel , specific to the domain of consumer electronics (cameras, phones), indicating whether two mentions share similar model and brand. Table 6 shows that by adding this rule, MLN#8 outperforms MLN#6, and similarly MLN#9 outperforms MLN#7. This extendability shows the value of MLN-based approach, which allows addi-tional rules, constraints, or even tasks to be modeled jointly.
We explore a framework for expressing structural con-straints for multipartite entity resolution using MLN. Exper-iments on real-life datasets indicate the promise of this ap-proach, showing how the various structural constraints con-tribute to the overall effectiveness. As future work, we plan to investigate further how factoring in domain-specific fea-tures and constraints, in addition to the proposed domain-invariant structural constraints, can result in more flexible and yet more accurate entity resolution through MLN. [1] Y. Crama, A. G. Oerlemans, and F. C. Spieksma. [2] A. K. Elmagarmid, P. G. Ipeirotis, and V. S. Verykios. [3] I. P. Fellegi and A. B. Sunter. A theory for record [4] D. Gale and L. S. Shapley. College admissions and the [5] J. Gemmell, B. I. P. Rubinstein, and A. K. Chandra. [6] P. Jaccard. Etude comparative de la distribution florale [7] M.A. Jaro. Probabilistic linkage of large public health [8] S. Kok, P. Singla, M. Richardson, P. Domingos, [9] H. K  X  opcke and E. Rahm. Frameworks for entity [10] A. E. Monge and C. Elkan. An efficient [11] H. Poon and P. Domingos. Joint inference in [12] M. Richardson and P. Domingos. Markov logic [13] W. Shen, X. Li, and A. Doan. Constraint-based entity [14] P. Singla and P. Domingos. Entity resolution with [15] D. Zhang, B. I. P. Rubinstein, and J. Gemmell.
