
In recent years, the mining of a complete set of frequent subgraphs from labeled graph data has been extensively studied. However, to our best knowledge, almost no meth-ods have been proposed to find frequent subsequences of graphs from a set of graph sequences. In this paper, we define a novel class of graph subsequences by introducing axiomatic rules of graph transformation, their admissibil-ity constraints and a union graph. Then we propose an ef-ficient approach named  X  X TRACE X  to enumerate frequent transformation subsequences (FTSs) of graphs from a given set of graph sequences. Its fundamental performance has been evaluated by using artificial datasets, and its prac-ticality has been confirmed through the experiments using real world datasets.
In recent years, the studies of data mining have estab-lished many approaches to find characteristic patterns from various structured data. Sequential Pattern Mining such as
AprioriSome [1] and PrefixSpan [15] is to efficiently find a complete set of subsequences which appear more fre-quently than a minimum support threshold in a given set of itemset sequences. These approaches are limited to mine total order relations among itemsets each of which repre-sents co-occurrence of events. In contrast, WINEPI and MINEPI [12], which are more advanced Sequential Pattern
Mining, are to find frequent episodes representing partial order relations among event occurrences. However, the re-lations are still limited to orders and do not cover any se-mantic and/or topological matters.

Graph Mining, which efficiently mines all subgraphs ap-pearing more frequently than a given threshold from a set of graphs, focuses the topological relations among events [18].
AGM [7], gSpan [19], and Gaston [14] mine frequent sub-graphs levelwisely starting from those of size 1 by using the anti-monotonic property on the support values. Gas-ton is known to be the fastest algorithm. Its efficiency is from the use of the sparsity of graphs in most of real world applications. Although major algorithms of Graph Mining are practically quite efficient, they need much computation time to mine complex frequent subgraphs due to the NP-completeness of subgraph isomorphism matching [5]. Ac-cordingly, these conventional methods are not well applica-ble to more complex graphs such as graph sequences.
However, there are many real world applications suitable to model objects by using graph sequences. For example, a human network is represented by a graph where each human and each relationship between two humans correspond to a vertex and an edge, respectively. If a person joins or leaves a human community, the numbers of vertices and edges in the graph increase or decrease. Similarly, a gene network consisting of genes and their interactions produces a graph sequence in their evolutionary history. Most of these graphs in the real world are known to have long tail distributions of vertex degrees where most of the vertices have a few edges [2], and thus they are sparse. We focus the topo-logical changes in the sequences of sparse graphs, because in many cases their changes come from some underlying mechanisms restricted by the topology such as distances (dissimilarities) between vertices and information traveling on the graphs (networks).

The primary objective of this paper is to establish a novel framework to mine a complete set of frequent sub-sequences embedded in a given set of observed sequences of sparse graphs. We introduce a novel representation of graph sequences where each change between two observed successive graph states is interpolated by axiomatic trans-formation rules which follow their associated admissibil-ity constraints. Then we propose a new method to mine subsequences called  X  X requent transformation subsequences (FTSs) X  represented by transformation rules of the graph sequence data. Our secondary objective is to mine FTSs corresponding to  X  X elevant X  graph subsequences based on  X  X nion graphs X  which represent relevant vertices in graph sequences. The relevant FTSs are important, since our interest focuses on the relations among relevant persons, events, phenomena and so on in many cases. Our proposed approach based on these principles is called  X  X TRACE (Graph TRAnsformation sequenCE mining) X . The last ob-jective is to experimentally characterize the efficiency of GTRACE by using artificially generated data and to demon-strate its practicality by applying to real world datasets.
Figure 1. Examples of a graph sequence and a mined graph subsequence.
Figure 1 (a) shows an example of an observed graph se-quence. A graph g ( j ) is the j -th labeled graph in the se-quence. We introduce two practical Assumptions .Oneis that  X  X he change is gradual X , i.e. , only a small part of the structure changes and the other part remains unchanged be-tween two successive graphs g ( j ) and g ( j +1) . The other is  X  X he sparsity of every graph g ( j )  X . In the aforementioned human network and the gene network, these assumptions well hold, since most of the changes of the vertices are pro-gressive over the step, and the vertices are not very densely coupled one another at every instant. Although this paper focuses undirected graph only, our proposed principles are applicable to directed graph without loss of generality.
A compact representation of graph sequences should be introduced in order to reduce both computational cost and spatial cost to mine the frequent transformation sub-sequences (FTSs). The direct representation of the graph sequence is not compact, because many parts of a graph unchanged over multiple steps are redundant in the repre-sentation. One way to derive a compact representation is to use a Graph Grammar [10]. Graph Grammar is a gram-mar which transforms a graph to another graph. For ex-ample, a rule S  X  P in Graph Grammar, where S and
P are graphs, transforms subgraphs which are isomorphic with S in a given graph to P . Only few data mining stud-ies have introduced Graph Grammar. Recently, Holder and Cook introduced Graph Grammar to their modified SUB-
DUE which iteratively replaces a frequent subgraph S in agraphintoavertex v by using a rule S  X  v based on
Minimum Description Length [11, 9]. Because the head of the rule consists of a single vertex, this technique is not applicable to generic graph subsequence mining. On the other hand, the general framework of Graph Grammar is too generic to derive a compact representation of the graph sequence. Accordingly, we propose the following novel graph grammatical framework adapted to easily and com-pactly describe a graph sequence by introducing rules of in-sertion, deletion, and relabeling of vertices and edges under
Assumption of the gradual changes.
A labeled graph g is represented as g =( V, E, L, f ) , where V = { v 1 ,v 2 ,  X  X  X  ,v z } is a set of vertices, E { ( v, v ) | ( v, v )  X  V  X  V } is a set of edges, and L is a set of labels such that f : V  X  E  X  L . V ( g ) , E ( g ) and L ( g ) are sets of vertices, edges and labels of g ,re-spectively. An observed graph sequence is represented as d = g (1) g (2)  X  X  X  g ( n ) , where the superscript integer of each g represents the ordered step of the observation. We assume that each vertex v is mutually distinct from the oth-fine a set of unique IDs ID ( V ) and a set of pairs of unique IDs ID ( E ) as follows.
 Example 1 In the example of the human network men-tioned in Section 1, each person has a unique ID, and his/her gender is an example of a vertex label.
 To compactly represent a graph sequence, we focus on dif-ferences between two successive graphs g ( j ) and g ( j +1) the sequence. The differences between the graphs g ( j ) and g +1) are interpolated by a virtual sequence g ( j, 1) g ( j, Definition 1 Given an observed graph sequence d = g (1) g (2)  X  X  X  g ( n ) , each observed graph g ( j ) in d is called an  X  X nterstate X . Moreover, given two successive inter-states g ( j ) and g ( j +1) and their interpolation s ( j g trastate X . The observed graph sequence ( X  X nterstate se-quence X ) d is represented by the interpolations as d = s The order of interstates represents the order of graphs in an observed sequence. On the other hand, the order of in-trastates is the order of graphs in the artificial interpolation and there can be various interpolations between the graphs g ) and g ( j +1) . We limit the interpolations to be compact and unambiguous by taking ones having the shortest length in terms of graph edit distance [16] to reduce both compu-tational cost and spatial cost of graph sequence mining. Definition 2 Let a transformation of a graph by one of in-sertion, deletion and relabeling of a vertex or an edge be a unit, and let each unit have edit distance 1. An  X  X ntrastate interpolation that the edit distance between any two succes-sive intrastates is 1 and that the edit distance between any two intrastates is minimum.

The transformation is represented by the following  X  X ransformation rule (TR) X  in this paper.
 Definition 3 A transformation rule (TR) which transforms g  X  tr is a transformation type which is either insertion,  X  o  X  l
Table 1. Transformation rules (TRs) to repre-sent graph sequence data.

For the sake of simplicity, we denote the transformation rule tr l jk except the case where the original notion is essentially needed. We introduce six TRs defined in Table 1. For exam-a label l between the k -th and k +1 -th intrastates in the j -th interstate. Since the transformations of vertex deletion vd and edge deletion ed do not assign any labels to the vertex and the edge respectively, their arguments l are dummy and represented by  X   X   X  without loss of generality. The readers may notice that a relabeling transformation can be decom-posed into a deletion and its successive insertion of the ver-tex or the edge having an identical ID. However, we retain this relabeling, because it increases the compactness of the graph sequence and the mined frequent transformation sub-sequence (FTS).

The TRs in Table 1 are governed by Axioms listed in Ta-ble 2 due to their nature. The first axiom mentions that a vertex having a unique ID u is not contained in g ( j,k ) a vertex having a label l and the unique ID u is contained in g ( j,k +1) . For example, as shown in Fig. 2 (a) where the number attached to each vertex stands for the unique ID of the vertex, g ( j,k ) is transformed to g ( j,k +1) by inserting a vertex having a unique ID 3. The inserted vertex becomes an isolated vertex. The second axiom mentions that a TR vd [ u,  X  ] is applicable to transform g tex having a unique ID u is contained in g ( j,k ) , no edges connected to the vertex are contained in g ( j,k ) , and a ver-tex having the unique ID u is not contained in g ( j,k +1) example, g ( j,k ) in Fig. 2 (b) is transformed to g ( j,k deleting an isolated vertex having a unique ID 3. If there is an edge between vertices having unique IDs 2 and 3 in g ing the unique ID 3 .

In summary, the following representation of a transfor-mation sequence is introduced.
 Definition 4 An intrastate sequence s ( j ) = g ( j, 1) g g j,m j ) is represented by the following sequence of TRs. This is called an  X  X ntrastate transformation sequence X . Moreover, an observed graph sequence (interstate se-quence) d = g (1) g (2)  X  X  X  g ( n ) is represented by an  X  X nterstate transformation sequence X  seq ( d )= tial interstate g (1) .
 The notion of the intrastate transformation sequence is far more compact than the original graph based representation, since only differences between two successive intrastates are kept in the sequence.
 i.e. , k&lt;k . Based on the axioms in Table 2 and Defini-tion 2, we define the following admissibility of a TR pair in the sequence.
 o different from o and o of a TR pair tr ( j,k ) [ o,l ] &lt;tr transformation sequence. Any TR pair is admissible except if o and o are either a vertex and an edge one of which ter-minal is the vertex. Otherwise, the TR pair is admissible if and any shorter transformation subsequences equivalent to the TR pair do not exist.
 We limit this admissibility into the case that the objects o of all TRs between k and k is different from o and o , because the TR which transforms an object o appears only once in an intrastate transformation sequence as shown later. In addition, we request the TR pair not to be rewritable by less number of TRs due to the minimum edit distance between any two TRs defined in Definition 2. For example, does not hold. On the other hand, the pair of ei ( j,k ) [( vr u 1 ,l ] is admissible. The application of ei dicates the existence of the vertex whose unique ID is u 1 in the objective graph. This suffices the condition to ap-admissibility of TR pairs.
Theorem 1 (Admissibility Theorem) Given an in-trastate transformation sequence seq ( s ( j ) )= tr tions of TRs applicable to a vertex having a unique ID u 1 or an edge one of whose terminal is the vertex of ID u 1 in the sequence is limited to either of the following 8 ordered pairs where 1  X  k&lt;k  X  m j  X  1 . Due to space limitation, its proof is omitted. According to
Theorem 1, we can enumerate a sequence of TRs to interpo-late two successive graphs g ( j ) and g ( j +1) in a straightfor-ward manner under the definitions in Table 1 and the con-straints of Theorem 1. Finally, we show that any graph se-quences are represented by our six TRs.

Theorem 2 (Representation Theorem) Any graph sequence can be represented by the six TRs in Table 1 with a given initial interstate g (1) .

P roof. Given a graph sequence d = g (1) ,  X  X  X  ,g ( n ) , let g ( j ) and g ( j +1) ( j =1 ,  X  X  X  ,n  X  1) be two successive graphs in a graph sequence. Let f and f be labeling func-tions of g ( j ) and g ( j +1) , respectively. We define Thus, g ( j ) and g ( j +1) are represented as g g respectively. First, g ( j ) = g ( j, 1) is transformed to a graph g by stepwisely inserting all vertices in V vi to g ( j, 1) k =1+ | V g by inserting all edges in E ei to g ( j,k 1 ) where k 2 = | E g ( V  X  V by relabeling labels of all vertices in V vr and all edges in
E er where k 3 formed to g by deleting all edges in E ed from g ( j,k 3 ) where k 4 = | E g by deleting all vertices in V vd from g ( j,k 4 ) where k k + | V g +1) . In addition, because V tually disjoint, and E ei , E ed , E er , and E are also mutually disjoint, the number of TRs applied to each vertex or each edge is at most 1. The order of TRs applied in the above transformation process is consistent with the admissibility of ordered TRs indicated in Theorem 1. Accordingly, any
Figure 3. Algorithm to compile graph se-quences to transformation sequences. intrastate sequence from g ( j ) to g ( j +1) can be represented by the six TRs and the initial intrastate g ( j ) = g ( j,k nally, because this statement holds over all j =1 ,  X  X  X  ,n we conclude that any graph sequence d can be represented by the six TRs and the initial interstate g (1) .
In this subsection, we propose an algorithm to com-pile given observed graph sequences to transforma-tion sequences. An observed graph sequence (inter-state sequence) d = g (1) g (2)  X  X  X  g ( n ) is represented by an interstate transformation sequence seq ( d )= state g (1) by Definition 4. Based on this graph se-quence representation, we developed an algorithm to com-pile a given set of graph sequences DB = { d i | d i = g seq ( DB )= { seq ( d
The procedure basically follows the proof of Theorem 2 to compile each graph sequence data. seq ( d )  X  tr ( j,k ) [ sequence seq ( d ) . To interpolate the differences between g ) and g ( j +1) , first, the vertex and edge insertions are ap-pended to the end of the transformation sequence in Lines 9 and 11. Subsequently, relabelings are appended in Lines 13 and 15. Finally, the vertex and edge deletions are ap-pended in Lines 17 and 19. The following is an example of the compilation by this algorithm.

Example 2 In Fig. 4 (a), a graph sequence d can be represented by a sequence of insertions and deletions of vertices and edges as shown in Fig. 4 (b). The transformation sequence is represented as seq ( d )= vi where  X   X   X  stands for a label of an edge.

As is clear from these algorithm and example, the order of TRs in an intrastate transformation sequence is artificial, and it does not reflect the order of graphs in a given ob-served graph sequence except starting and ending graphs in their intrastate sequences. Therefore, we need to focus on the order of interstates only in the mining result. On the other hand, because the intrastate transformation sequence represents an admissible order of TRs for the interpolation between two successive interstates, it enables to apply Se-quential Pattern Mining to the graph sequence mining prob-lem as shown later. In general, computing an edit distance between two graphs is NP-hard, because all combinations of vertices in the two graphs must be considered. Contrarily, in our case, computing a sequence of TRs based on differ-ences between two graphs is solvable in linear time, because all vertices have unique IDs.
In this section, we propose a method to mine frequent transformation subsequences (FTSs) from a given set of graph sequences. Since FTSs to be mined are included in the given transformation sequences, the FTSs are also governed by Admissibility Theorem. To mine FTSs from a given set of compiled graph sequences, i.e. , a set of trans-formation sequences, we define inclusion relation between intrastate transformation sequences.
 Definition 6 Let seq ( s ( j ) ) and seq ( s ( h ) ) be intrastate transformation sequences as follows. seq ( s ( h ) ) is a subsequence of seq ( s ( j ) ) ,iff  X  hold. Let seq ( s ( h ) )  X  seq ( s ( j ) ) denote this inclusion. Note that the order among intrastates are not preserved in mation sequences are artificially generated by the interpo-lation. In addition, we define inclusion relation between interstate transformation sequences. Definition 7 Let seq ( d ) and seq ( d ) be transformation se-quences as follows. seq ( d )= seq ( s (1) )  X  X  X  seq ( s ( j ) )  X  X  X  seq ( s ( seq ( d )= seq ( s (1) )  X  X  X  seq ( s ( h ) )  X  X  X  seq ( s ( where intrastate sequences seq ( s ( j ) ) and seq ( s ( h given by Eq. (1) and (2), respectively. seq ( d ) is a subse-quence of seq ( d ) which is denoted as seq ( d ) seq ( d there exist integers 1  X  j 1 &lt;  X  X  X  &lt;j n  X  1  X  n  X  1 seq ( s ( h ) )  X  seq ( s ( j h ) ) for h =1 ,  X  X  X  ,n  X  1 Example 3 Given a graph sequence d in Fig. 5 (a) repre-sented as the following transformation sequence seq ( d )= a transformation sequence seq ( d )= vi (1 , 1) [3 ,C ] ei ed subsequence of seq ( d ) .
 While the transformation sequence data indicates a progres-sive change of a graph and thus it is graphically represented as far as the data is valid, the change represented by its sub-sequence is discontinuous and often difficult to graphically be presented.

Given a set of data DB = { d i | d i = g (1) i  X  X  X  g ( n i support value  X  ( seq ( d )) of a transformation subsequence seq ( d ) is defined as We call a transformation subsequence whose support value is greater than or equal to a minimum support threshold  X  a  X  X requent transformation subsequence (FTS) X . The anti-monotonicity of this support value holds as usual. That is, if seq ( d 1 ) seq ( d 2 ) then  X  ( seq ( d 1 ))  X   X  ( seq ( these settings, now we state our mining problem as follows. Problem 1 Given a dataset DB = { d i | d i = g  X  as input, the problem is to enumerate all frequent transformation subsequences (TFSs).

To enumerate a complete set of transformation subse-quences in seq ( DB ) , we consider an algorithm to recur-sively append a TR to the end of the current FTS by us-ing Pattern Growth Principle. For example, let seq ( d )= vi [1 ,A ] be a current FTS. When a type of an appended rule is vi , all possible transformation subsequences to vi vi shows that a vertex having a unique ID u is inserted at the same time when the vertex having the unique ID 1 is in-serted. The latter represents that a vertex having the unique ID u is inserted after the vertex having the unique ID 1 has been inserted. In each case, any inadmissible subsequences subsequences are not included in seq ( DB ) deduced by our compilation according to Admissibility Theorem. The fol-lowing lemma provides the enumeration of the complete set of transformation subsequences.
 Lemma 1 Given a transformation subsequence seq ( d )= tr be appended to seq ( d ) be C ( seq ( d ) ,seq ( DB )) = { tr tr formation rule tr ( j,k ) [ o,l ] to the end of seq ( d ) to seq ( d ) , the complete set of candidate FTSs is gener-ated. In the case that of seq ( d )= , all candidate sub-sequences tr (1 , 1) [ o,l ]  X  C ( seq ( d ) ,seq ( DB )) = {  X  seq ( d i )  X  seq ( DB ); tr ( j,k ) [ o,l ] seq ( d i ) } pleteness.

According to Lemma 1, we design an efficient depth-first algorithm as shown in Fig. 6. The argument F accumu-lates the found FTSs. If seq ( d )= , all candidate subse-algorithm recursively mines frequent transformation subse-quences by appending a TR to the end of the transforma-tion subsequence in Line 12. The appended rule is either in the intrastate sequence where the last TR in seq ( d ) exists (Line 5) or in the next intrastate sequence (Line 6). Be-cause this algorithm is based on Pattern Growth Principle, transformation subsequences containing inadmissible rules are never generated according to our aforementioned data compilation based on Admissible Theorem.

We implemented this algorithm by using PrefixSpan [15] which is a representative method to mine frequent subse-quences from a set of itemset sequences. Since it enumer-ates FTSs projecting the given sequences into shorter se-quences, it can efficiently mine long FTSs.
The algorithm proposed in Section 3 enumerates a com-plete set of FTSs. However, by some practical reason, we often focus on graph subsequences consisting of mutually relevant vertices and edges only. For example, given a graph subsequence depicted in Fig. 7. Practically, the vertex 1 having a label A is considered to be irrelevant with the oth-ers, because it is not connected via edges with the others at any steps. On the other hand, while the vertex 2 having label C and the vertex 4 having label D in Fig. 7 are not connected in any steps directly, they have connections with the vertex 3 labeled as B at the first step and the fourth step, respectively. In this case, we consider that the vertices 2 and 4 are mutually relevant via the vertex 3. Under the case of
Fig. 7, many analysts consider to include the vertices 2, 3, and 4 but exclude the vertex 1 in the graph sequence analy-sis. Based on the above observation and the potential con-nectivity in a given graph sequence, we define the relevancy among unique IDs of vertices and edges as follows.
Definition 8 Unique IDs in a graph sequence d = g (1) g (2)  X  X  X  g ( n ) are relevant one another, and d is called a  X  X elevant graph sequence X , if a union graph g u ( d ) of d is a connected graph. Here, we define a union graph of d as g ( d )=( V ( g
V ( g u ( d )) =
E ( g
The connected graph in this definition is a graph having a path between any two vertices, and the path is a set of edges making reachable from a vertex v to another v . This union graph of a graph sequence d also defines the relevance of the corresponding transformation sequence seq ( d ) .Byusing the definition of the union graph, a problem to mine relevant FTSs is defined as follows.

Problem 2 Given a dataset DB = { d i | d i = g as input, the problem is to enumerate all FTSs whose union graphs are connected.

To efficiently enumerate all relevant FTSs, first, union graphs of all graph sequences in DB are generated based on Definition 8. Subsequently, all frequent  X  X onnected X  sub-graphs among these union graphs are enumerated by using the conventional Graph Mining algorithm. At every time when the algorithm outputs a frequent connected subgraph, FTSMiner shown in Fig. 6 is called, where its input set of transformation sequences is generated by the projection shown in the following definition.
 Definition 9 Given a transformation sequence seq ( d )  X  seq ( DB ) and a connected graph g , we define a function  X  X roj X  to project seq ( d ) to its subsequences as follows.
Because each union graph of a FTS is also frequent in union graphs of all seq ( d )  X  seq ( DB ) , we can enumerate all candidate relevant FTSs from the projected transforma-tion sequences if all frequent connected subgraphs of the union graphs of all seq ( d )  X  seq ( DB ) are given. Example 4 Given a graph sequence d as shown in Fig. 8 (a), seq ( d ) is represented as seq ( d )= its union graph g u ( d ) is depicted in Fig. 8 (b). Given a graph g which is a subgraph of g u ( d ) as shown in Fig. 8 (d), an example transformation sequence seq ( d ) in depicted in Fig. 8 (c), where this subsequence matches with underlined rules in seq ( d ) .
 Figure 9 shows an algorithm to enumerate all relevant FTSs from DB . First, a set G u of union graphs of transfor-mation sequences seq ( DB ) is generated in Line 2. Assum-ing that a function call FrequentSubgraphMiner in Line 3 repeatedly and exhaustively outputs a frequent connected subgraph g in G u one by one, a multiset proj ( DB ) con-sisting of projection sets proj ( seq ( d i ) ,g ) of all d is given in Line 4. In Line 5, FTSMiner X  is an altered ver-sion from the original FTSMiner to choose a TR tr ( j,k )
Figure 10. Conversion from a graph sequence to a graph. some seq ( d ) of a proj ( seq ( d i ) ,g ) in proj ( DB ) of Fig. 6 and to increment support of the candidate FTS in Line 10 if it is occurred in some seq ( d ) of a proj ( seq in proj ( DB ) .

For FrequentSubgraphMiner, we used AcGM [8] which one of conventional Graph Mining methods. AcGM enu-merates all embeddings in each union graph which are iso-morphic with a frequent subgraph g , and this feature of AcGM enables to efficient projection of g to all of its iso-morphic transformation subsequences proj ( seq ( d ) ,g )
Our proposed method named  X  X TRACE (Graph TRAns-formation sequenCE mining) X  was implemented by C++. HP xw4400 with Windows XP was used for this experi-ments where Intel Core 2 6700 2.66 GHz and 2 GB of main memory are installed. The performance of GTRACE is evaluated for both artificial and real world graph sequence data. Because any other established approach comparable with our frequent graph subsequence mining is not avail-able, we set up a mining task which is functionally similar within the conventional Graph Mining for the comparison. Each graph sequence d = g (1)  X  X  X  g ( n )  X  DB is con-verted to the following graph g as shown in Fig. 10. Each unique ID u , if it appears as a vertex having a label l in g is represented by a vertex having a label l : P (Presence) in the j -th column of g as shown in Fig. 10 (b), otherwise u is represented by a vertex having a label A (Absence). If there is an edge between two vertices in g ( j ) , an edge is placed between the corresponding vertices in the j -th column of g . Finally, all vertices corresponding to an identical ID u are mutually connected by edges to form a clique. This is to represent the identity of vertices in the graph. Each clique is indicated by a rectangle in Fig. 10 (b). The Graph Mining on this data extracts the information of the presence/absence of each vertex with their associated edges over the sequen-tial steps. We applied Gaston [14] to this task, since it is known to be the fastest algorithm of Graph Mining.
We compared the performance of GTRACE with Gas-ton by using artificial datasets generated by the parame-ters listed in Table 3. First, starting from g (1) such that V ( g (1) )=  X  , we grew each transformation sequence up to having | V avg | unique IDs in the average by inserting ver-tices and edges with probability p at every step. Accord-ingly, if p is small or | V avg | is large, the finally produced sequence, i.e. , the length of the generated transformation sequence, is long. This process is continued until the se-quence becomes relevant by the increase of the edges while keeping the sparsity of each interstate graph. Typically, the average probability of edge existence between 2 vertices in an interstate was 13% under the default values of the param-eters. This value remains low over all test data. Similarly, we generated N relevant FTSs having | V avg | unique IDs in the average under the probability p . Then, we generated DB where each transformation sequence was overlaid by each relevant FTSs under the probability 1 /N . The overlay was conducted in the graph sequence domain to ensure the topologically proper overlay. Each relevant transformation sequence contains | L v | vertex labels and | L e | edge labels, respectively.

Table 4 shows the computation times (sec), the numbers of derived FTSs, and the average computation times (sec) to derive a FTS under various values of | V avg | , p , |  X  , while the other parameters are set at their default val-ues. Though we designed the mining task of Gaston to make similar to the task of GTRACE as much as we can, the numbers of FTSs in their solutions are very different. Accordingly, we also use the computation time per FTS for the comparison. The results indicated by  X  X  X  in the ta-ble were not obtained due to intractable computation time over one hour. The upper half of the table indicates that the computation time of both GTRACE and Gaston are ex-ponential to the average length of seq ( d ) provided by the settings of | V avg | and p . The main reason of the computa-tion time increase along the average length is considered to be the increase of the numbers of FTSs in both cases, be-cause the computation times per FTS do not significantly vary over the conditions. However, the far better efficiency of GTRACE than Gaston X  X  application is confirmed in terms of both the computation times per FTS and the number of focused FTSs.

The lower left part in Table 4 shows the effect of the number of labels on the efficiency. When | L v | is small, many subgraphs included in the graph g as depicted in
Fig. 10 (b) are isomorphic each other, and thus the com-putation time of Gaston is enormous. In contrast, that of GTRACE remains small since | L v | does not affect the length of seq ( d ) . The lower right part in Table 4 shows that
GTRACE is tractable even under the low minimum sup-port threshold because it involves only the Graph Mining of small union subgraphs to ensure the relevance of FTSs and the pattern growth based Sequential Pattern Mining for the FTS mining, whereas Gaston X  X  application includes the
Graph Mining of large graphs as depicted in Fig. 10 (b). The good scalability of GTRACE is indicated in every part of
Table 4 since its computation times per FTS remain almost same or is even significantly reduced in some conditions.
To assess the practicality of GTRACE, we apply it to two real world datasets. One is Enron Email Dataset [4] and the other is phone call histories from Reality Mining Project at MIT [13]. In both data, we assigned a unique ID to each person participating the communication, assigned an edge to a pair of persons if they communicate via either email or phone call in a day, and obtained a daily graph g ( j ) .We further categorized the persons into 3 labels according to their daily vertex degrees as high, moderate and low de-grees. The person having a high degree label is considered to be a hub person in the organization. We obtained a set of weekly graph sequence data, i.e. , DB . The total num-bers of weeks, i.e. , number of sequences, are 200 in Enron Email Dataset and 40 in MIT Dataset. We randomly sam-pled | V | (= 1  X  90) persons in Enron Email Dataset and |
V | (= 1  X  20) persons in MIT Dataset to form each DB .
Tables 5 and 6 show the computation times (comp. time), the numbers of enumerated FTSs (# of FTSs), and com-putation times per FTS (comp./FTS) resulted under various numbers of unique IDs (persons) | V | and the minimum sup-port  X  for both data while the other parameters are set at de-fault values indicated at the bottoms of the tables. GT5 and Ga5 indicate that each sequence d in DB consists of five graph steps g ( j ) from Monday to Friday. Similarly, GT6 and Ga6 indicate the case of six graph steps g ( j ) from Mon-day to Saturday. The average length (avg. len.) stands for the average number of TRs in observed transformation se-quences. In case of the required computation times over one hour, the results are indicated by  X  X  X .
 Upper parts in these tables show superior scalability of GTRACE with regard to the computation time and compu-tation time per FTS. In contrast, Gaston X  X  application is not tractable, because many persons communicate with some-one only on a few days in the data. This produces many unique IDs labeled as A (Absence) in each relevant graph sequence, and the cliques made of these absent unique IDs produce vast number of spurious frequent subgraphs. The computation times required in MIT Dataset are far larger in spite of its smaller numbers of persons. This is because the daily graphs in MIT Dataset are denser than those of En-ron Email Dataset, since MIT Dataset is from phone calls within a tightly coupled community. Lower parts of the ta-bles show the practical scalability of GTRACE with regard to the minimum support threshold.

Figure 11 shows a very simple but informative example mined from MIT Dataset. The person 3 has communication with a hub person 2 a few days after the persons 3 had com-munication with a person 1 having low vertex degree. This implies the possibility that the person 3 who is not a hub is a key person connecting a hub person with an uncommunica-tive person.
Our algorithm of compilation in Fig. 3 is linear for both the length of the graph sequence | d | and the size of each graph | g ( j ) | , since this is just to read DB once. The algo-rithm to enumerate FTSs in Fig. 6 is basically the pattern growth. Its complexity is identical with PrefixSpan [15] in our implementation and known to widely vary from low polynomial order to exponential order of | d | and | g ( j the characteristics of the given graph sequences. The algo-rithm to mine relevant FTSs in Fig. 9 uses the conventional
Graph Mining, and hence its complexity is exponential or-the number of graph sequences | DB | . In total, the complex-ity of our GTRACE is exponential order of average | g ( j from low polynomial order to exponential order of average | d | and linear order of | DB | . This consequence well fits to our experimental results. The superior computational effi-ciency of GTRACE over Gaston comes from the character-istics of GTRACE adapted to the graph sequence mining task, and this does not indicate the inefficiency of Gaston for ordinary frequent graph mining tasks.

Recently, Borgwardt et. al proposed a method to mine frequent patterns from a set of graph sequences where only the insertions and the deletions of edges are allowed, but these of vertices and the relabels of vertices and edges are not [3]. In this approach, existence and non-existence of an edge in each time step is represented by 1 and 0 respec-tively, and the edge is labeled by the binary string consisting of these 1 and 0 over entire time steps. As this preprocess-ing of each graph sequence converts the data into ordinary labeled graphs, the problem to mine the frequent patterns in the graph sequences is handled by conventional Graph Min-ing techniques. However, this method can not be applied to the graph sequences where insertions and deletions of ver-tices and relabels are included such as human communities and gene networks mentioned in Section 1.
 describe time sequence events [17]. Some recent data min-ing study has introduced this framework to analyze time se-quence data [6]. The temporal logic is to describe the rela-tions among times and time intervals when events hold. Our TRs can be seen as a set of simple temporal operators. The introduction of advanced temporal logics may enhance the expressiveness of the graph subsequences. As mentioned in Section 2, another possibility to extend the expressiveness is the use of Graph Grammar [10]. However, in both cases, the computational tractability is a big issue.
 a complete set of relevant frequent transformation subse-quences (FTSs) from given graph sequences. We developed a graph sequence mining program GTRACE, and confirmed its efficient and practical performance through computa-tional experiments using artificial and real world datasets.
