 In this paper, we propose a novel, spatial co-location min-ing algorithm which automatically generates co-located spa-tial features without generating any non-clique candidates at each level. Subsequently our algorithm is more efficient than other existing level-wise co-location algorithms because no cliqueness checking is performed in our algorithm. In addi-tion, our algorithm produces a smaller number of co-location candidates than the other existing algorithms.
 Categories and Subject Descriptors: H.2.8 Database applications: Data mining, Spatial databases and GIS General Terms: Algorithms, Design, Performance Keywords: Spatial data mining, co-location mining
Given a finite set of boolean spatial feature instances, spa-tial co-location mining is to discover a set of feature types whose instances are frequently co-located in close proxim-ity. Existing co-location mining algorithms [3, 4, 2] largely have their foundation in the Apriori algorithm [1] relying on spatial join which is an expensive operation. To avoid spa-tial join operations, [5] proposed an algorithm using a novel data structure to materialize spatial data. Although this al-gorithm achieves the avoidance of expensive spatial join op-erations, it generates unnecessary candidate co-location in-stances, and consequently requires cliqueness checking over the candidates, which becomes a bottle-neck to the perfor-mance of the algorithm.

In this paper, we propose a novel level-wise spatial co-location algorithm called Neighbor Cluster Algorithm (NCA) based on a new data structure called Neighbor Cluster (NC) equipped with a linear set intersection operation. The NC data structure guarantees any candidate co-location instance generated at any level to be a clique, and hence helps us incrementally mine co-location patterns while avoiding the costly cliqueness checking and spatial join operations re-quired in other algorithms. Subsequently, NCA optimizes co-location mining by generating less number of candidate co-location patterns at each level than other algorithms, which allows NCA to reduce the computational cost. As we will show later, the proposed algorithm improves the over-all performance without violating the completeness and the soundness of the solution to the problem.
The co-location mining problem is solved by introducing i) the novel neighbor cluster (NC) data model, and ii) a linear intersection operation over NC.
 Neighbor cluster In this model, instances are ordered ac-cording to the lexicographical order of their types whereas the input neighborhood relationships are unordered. Given a set of feature instances I and neighborhood relationship set R defined over I , the neighbor cluster (NC) of an instance I  X  I whose type is f ( I k ) is defined as
N C ( I k ) = { I l | I l  X  I  X  ( I k , I l )  X  R  X  f ( I
In other words, the neighbor cluster of I k exclude from encoding the neighborhood relationship between I k and any instance whose type is lexicographically smaller than f ( I However, the same neighborhood relationship is encoded in the NC of other instances whose types are smaller than f ( I k ). Hence, we can see that NC is lossless with respect to R . Here, we now extend the notion of NC to be applicable to coloc lists, in addition to instances. The neighbor cluster of a coloc list is defined as follows:
Definition 1. Given a set of neighbor clusters { N C ( I N C ( I 2 ), . . . } defined over a set of instances I = { I neighbor cluster (NC) of the list is recursively defined as:
In other words, N C (  X  I j , . . . I k  X  ) = N C ( I j )  X  N C ( I . . .  X  N C ( I k ). For the instances and relationships presented in Figure 1, we build the NC for each instance as follows:
Given a set of instances I = { I 1 , . . . , I m } and a set of types F = { F 1 , . . . , F n } , the general steps of length-( k +1) ( k  X  1) co-location type lists generation are: (Generation of candidate type lists) Generate all can-didate length-( k +1) type lists from frequent length-k coloc type lists by joining any two length-k frequent coloc type lists with the same length-( k -1) prefix and different k th type. (Generation of instance lists and neighbor clusters) For any length-( k +1) candidate coloc type list  X  F 1 , . . . , F F k +1  X  , select each coloc list  X  I 1 , . . . , I k  X  of  X  F at a time, and generate a new coloc list  X  I 1 , . . . , I appending each element e in N C (  X  I 1 , . . . , I k  X  ) to  X  I one at a time, where e is of the type F k +1 . Then, generate N C (  X  I 1 , . . . , I k , e  X  ) using the equation in Definition 1. (Generation of frequent type lists) For each candidate coloc type list of length-( k +1), determine if it is frequent by examining its participation ratio.

Notice that, when k = 1, the set of candidate length-1 coloc type lists is the set of types F , and the set of length-1 coloc lists is the set of the instances given in I .
Upon the completion of coloc type lists and coloc lists generation, the participation ratio of each coloc type list is calculated prior to the next iteration.
 Table 1: Level-wise generation of candidate co-location type list  X  A , B , C , D  X 
Example 1. For the example in Figure 1, we present a complete list of mining result in Table 1, assuming that the participation ratio threshold is 0.0. We begin with N C ( A since none of A 1 , A 2 or A 3 contributes to the construction of  X  A , B , C , D  X  . We integrate A 4 with each element in N C ( A one at a time to obtain new coloc lists  X  A 4 , B 2  X  ,  X  A  X  A 4 , C 3  X  and  X  A 4 , D 1  X  . Their NCs are also generated and shown in Table 1. Afterwards, their frequentness of each candidate coloc type list is determined. Then, we move on the next level to generate candidate coloc type lists of length-3, e.g.,  X  A , B , C  X  by joining  X  A , B  X  and  X  A , C  X  . Now, two rows of Level 3 in the table are generated. The second row is similarly extended to yield  X  A 4 , B 2 , C 3 , D 1 type list  X  A, B, C, D  X  at Level 4. 2
We verified that the performance gain, in terms of num-ber of candidates generated and running time, of NCA over Joinless is consistent both with the 4 real (46 to 61 feature types and 17K to 52K instances) and 15 synthetic (20 to 60 types and 10K to 30K instances) datasets. Due to the page limit, only the number of candidates generated by each algorithm from the Oregon dataset is shown in Fig. 2. Figure 2: Number of candidates found by NCA and Joinless at different threshold values.
In this paper, we showed that the proposed NCA col-location algorithm generates the correct result by producing less number of candidates than the algorithm in comparison. In our current work, the notion of neighborhood is uniform in size and shape throughout the entire search space. We are considering different options to relax this constraint to model real world scenarios. The proposed NCA algorithm was designed based on the assumption that all information needed can fit into the main memory, which may not hold in a larger real world spatial co-location mining applications. We are considering to develop a disk-resident algorithm.
