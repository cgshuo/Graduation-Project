 We present Confluence , an enhancement to a desktop file search tool called Connections which extracts conceptual re-lationships between files by their temporal access patterns in the file system. A limitation of a purely file-based approach is that as file operations are increasingly abstracted by ap-plications, their correlation to a user X  X  activity weakens and thereby reduces the applicability of their temporal patterns. To deal with this problem, we augment the file event stream with a stream of window focus events from the UI layer. We present 3 algorithms that analyze this new stream, extract-ing the user X  X  task information which informs the existing Connections algorithms. We present results and conclusions from a preliminary user study on Confluence.
 Categories and Subject Descriptors: H.3.3 [Informa-tion Search and Retrieval]: Clustering General Terms: Human Factors, Experimentation Keywords: Contextual search, User modeling
Unlike web search, desktop search lacks local hyperlinks which provide the foundation for structural search algorithms like PageRank. Consequently, desktop search is typically limited to text-based methods, placing the onus on the user to provide more descriptive queries, and often reducing the quality of results. Temporal context provides desktop search an alternative method with which to understand the rela-tionships between files; namely that files which exhibit sim-ilar access patterns are likely to share a task commonality  X  even when those files bear no content similarities. Connec-tions [3] is a local file search tool that departs from the tra-ditional desktop search paradigm to incorporate these con-textual relationships in search results.

Connections is composed of two main parts: context build-ing and search. Contextual relationships are captured by a relation graph , where nodes represent files, and the links be-tween them reflect the strength of their contextual relation-ships. To build the relation graph, a kernel-layer file system monitor records file operations such as read and write as a user goes about their work. While these events occur, Con-nections maintains a relation window ( RW ), which is a log of all file events occurring in the last n -seconds. When a new write event enters the RW , the relation graph link to the newly written file from each file read in the RW is incre-mented. Similarly, a new entering read event has its file X  X  links to files written in the RW incremented.

Upon a user query, a pool of results is created using a traditional text based method (e.g. tf-idf ). For each file in this pool, Connections identifies a subgraph of contextu-ally related files by selecting all files on the relation graph connected to that file within n hops and of at least s link strength. A ranking algorithm such as PageRank or HITS is then used to transform this subgraph into an ordered list of files that is augmented to the original pool.

Despite positive results in [3], we perceived some limita-tions inherent in a purely file-based approach. As applica-tions grow increasingly sophisticated, they tend to further insulate users from low level file operations, forging a divide between a user X  X  conceptual document interaction and its file layer manifestation. We have developed Confluence , a set of modifications to the existing Connections algorithms that incorporate application window focus events, which are generated by the OS whenever a user changes the active window (typically through a mouse click or closing of the previously active window).

One problem with a file system based approach is the dif-ficulty in differentiating background noise (e.g. reads from a virus checker) from user events (e.g. writes from a text editor). While much of the background noise is generated by system-owned processes, it can also be generated by pas-sivated user processes (e.g. a text editor which automati-cally saves open files even when the application window has been minimized and not recently used). Our first algorithm, the Focused Window Filtering (FWF) algorithm, helps deal with this problem by applying information gleaned from the focused application window to inform the interpretation of that application X  X  file operations. FWF assumes that the currently focused window dictates the active user task, and applies a filter to the file event stream which removes all file operations except those whose process identifier (pid) (or some parent pid ) matches that of the currently focused window. The reduction of noise enables us to expand the duration and scope of the RW , as the original duration (30 seconds) and read-to-write increment restriction existed to manage the prohibitive volume of file operations. FWF al-lows a focus-based relation window that is sized to reflect a user X  X  task, starting a new RW when an application win-dow gains focus and ending it when the window loses focus. In addition, it allows for reads to be correlated with other reads within a common RW . Furthermore, the reduction of files helps maintains a leaner relation graph.

While a useful starting point, FWF  X  X  inability to connect file operations which occur across different focus events lim-its its ability to effectively capture the typical task model, where users switch between multiple windows or applica-tions as they go about their work. The Focused Task Filter-ing (FTF) algorithm broadens the definition of user task to the set of recently focused windows among which the user has switched focus as part of their work over a longer time interval, overcoming FWF  X  X  inability to consider relation-ships between files which are accessed while different win-dows are focused. FTF maintains a log of focus-based RW s that occur over the last n seconds (e.g. 300 to 600). For each file event, FTF increments the links to each of the files in previous RW s in addition to the active RW , broadening the time period within which file relationships can be built while maintaining the advantages of filtering.

Another problem faced by Connections is the tendency of some applications to obviate file system activity through caching. For example, a user who opens a PDF file may refer to it many times through an application window while work-ing; however, because the application caches the PDF, this activity is not reflected in the file system. The Weight Car-rying (WC) algorithm extends FTF , maintaining a record of the set of file events that occurred while that widget last had new file event matching the widget X  X  pid , WC retrieves the last set of file events which occurred while that widget had focus, and inserts  X  X ake X  copies of those events into the file stream. Connections then has more information about how a file might be being used in concert with other files within the active task. Distinguishing widget from window allows for a more fine-grained application of this technique.
We conducted a user study involving 4 volunteers over a 3-6 week period to evaluate the effectiveness of Conflu-ence compared to Connections. Users installed the Conflu-ence software, which included a kernel-layer file system event monitor and a UI event monitor, both recording to a com-mon, secure file on their system. At the end of the period, we collected these traces and generated relation graphs us-ing the various Confluence algorithms (parameterizing the F T F and W C algorithms for 5 and 10 minute intervals), as well as the original Connections algorithm.

From the file system logs, we generated and presented users a list of files accessed during the trace period and asked them to select a set of 5-10 disjoint tasks with which they were engaged during the period. For each task, they se-lected one or two files which were used as part of it. We used these files to seed searches on each of the algorithms X  relation graphs, producing lists of files which were consid-ered by the algorithms to be strongly contextually related to the seeds. For each seed file, we merged the set of the var-ious algorithms X  file lists into a single pool. To increase the pool X  X  coverage of potentially related files, we also merged results from a directory search algorithm which produced a list of all files that existed at some point within the same directory as the seed file, under the premise that user X  X  di-rectory organization of their files at least partially reflects that they are components of other windows, and different widgets within a common window can operate on different files (e.g. tabbed text editors) FTF (300) 0.03 0.66 1.16 2.05 2.57 3.10 FTF (600) 0.01 0.55 1.04 1.46 2.21 2.60 WC (300) 0.52 0.70 1.20 1.61 1.90 2.47 WC (600) 0.43 0.41 1.27 1.64 1.87 2.32 Figure 2: t-values ( df = 61) of mean recall differ-ences between Confluence algorithms and Connec-tions. Dark gray is significant with P &lt; 0 . 01 , medium gray is P &lt; 0 . 05 , and light gray is P &lt; 0 . 1 . the commonality of those files. From this pool, users rated each listed file on a 0-3 scale, where 3 indicated the file was highly related to the seed file and 0 indicated no relation-ship. Using these ranked pools, we evaluated each algorithm by recall, or the percentage of the algorithm X  X  results which had a rank of 3.
We evaluated Confluence and Connections for 31 file pools spanning the 4 users. Figure 1 depicts the algorithms X  aver-age recall values for results containing a score of 3 ( FWF per-formed predictably poorly and its results are omitted from the graph). For a result size of 5, the different algorithms performed similarly. As result size increases, the improve-ment of the Confluence algorithms over the pure file-based approach grows substantial. Figure 2 depicts the Student X  X  t scores comparing Confluence to Connections.

We did not observe a large performance difference between the FTF and WC methods, nor between task durations. However, while not strongly evident in the collective num-bers, WC did find unique, accurate file relationships, and performs better at higher result sizes (50-100). WC presents a trade-off; its  X  X ake X  file insertion has the potential to find relationships that would be lost by other methods at the risk of enhancing false relationships which can push valid results further down the list.

In light of the strong performance of the FTF and WC methods, the poor performance of FWF indicates that it is not purely the filtering  X  but rather the increased RW duration and file operation flexibility enabled by the filtering  X  which constitutes the primary advantage of Confluence.
