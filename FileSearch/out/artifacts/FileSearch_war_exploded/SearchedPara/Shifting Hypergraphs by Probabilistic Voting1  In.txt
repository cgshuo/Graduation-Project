 Seeking graph based modes is of great importance to many applications in ma-chine learning literature, e.g., image segmentation [9], feature matching [3]. In order to find the good modes of graphs, Pavan et al. [16] converted the problem of mode seeking into the problem of discovering dense subgraphs, and proposed a constrained optimization function for this purpose. Liu et al. [14] proposed another method, namely graph shift. It generalized the idea of non-parametric data points shift paradigms (i.e., Mean Shift [4] and Medoid Shift [17,18,19] to graph shift for graph mode seeking). An iterative method is developed to get the local maximizers, of a constrained objective function, as the good modes of graphs. While the graph (vertices) shift paradigm may deliver good results in many cases for graph mode seeking, we observe the following limits. Firstly, the graph modes generated based on shifting vertices only involve the information of pair-wise edges between vertices. As a result, the generated graphs modes may not always be able to precisely capture the overall semantics of objects. Secondly, the graph shift algorithm is still not strongly robust to the existence of a large number of outliers. Besides, no theoretical studies are conducted to show the convergence of iteration of shifting.
 Our Approach : Observing the above limits, we propose a novel paradigm, namely hypergraph shift, aimed at generating graph modes with high order in-formation. Different from graph shift paradigms that only shift vertices of graphs based on pair-wise edges, our technique s hifts high order edges (hyperedges in hypergraphs). Our technique consists of three key phases, 1) mode seeking (sec-tion 4.1) on subhypergraphs, 2) probabilistic voting (section 4.2) to determine a set of hyperedges to be expanded in mode seeking, and 3) iteratively perform the above two stages until convergence.

By these three phases, our approach may accurately capture the overall se-mantics of objects. Fig. 1 illustrates an example where the result of our approach for hypergraph shift can precisely ca pture the the scene of a person riding on a bicycle. Nevertheless, the result per formed by graph shift method in [14] fails to capture the whole scene; instead, by only focusing on the requirement of self-cohesiveness, three graph modes are generated.
 Contributions : To the best of our knowledge, this is the first work based on shifting hyperedges to conduct graph mode seeking. Our contributions may be summarized as follows. (1) We specify the similarities on hyperedges, followed by an objective function for mode seeking on hypergraphs. (2) An effective hy-pergraph shift paradigm is proposed. Theoretical analysis for hypergraph shift is also provided to guarantee its convergence. The proposed algorithm is naturally robust to outliers by expanding modes via the probabilistic voting strategy. (3) Extensive experiments are conducted to verify the effectiveness of our techniques over both synthetic and real-world datasets.
 Roadmap : We structure our paper as follows: The preliminaries regarding hy-pergraph are introduced in section 2, followed by our technique for hypergraph shift in sections 3 and 4. Experimental studies are performed in section 5, and we conclude this paper in section 6. Different from simple graph, each edge of hypergraph (known as hyperedge) can connect more than two vertices. Forma lly, we denote a weighted hypergraph as G =( V , E , W ), with vertex set as V = { v 1 ,v 2 ,...,v |V| } , hyperedge set as E weight of e i . The relationship between the hyperedges and vertices is defined by incidence matrix H  X  R |V| X |E| . Instead of assigning a vertex v i to a hyperedge e j with a binary decision, we establish the values probabilistically [5,8]. Specifically, we define the entry h v i ,e j of H as Eq. (1). e . Then we define a diagonal matrix D e regarding the degree of all hyperedges, with D e ( i, i )=  X  ( e i )= v  X  X  h v,e i , and a diagonal matrix D v regarding the the similarity between hyperedges, we define a novel hyperedge-adjacency matrix M  X  R |E| X |E| in the context of hypergraph. Specifically, we have Example 1. Consider the case in Fig.2, for e 2 and e 3 , the only common vertex is v 2 , then, we have | e 2  X  e 3 | =1, and the affinity value between e 2 and e 3 is Now, we describe the modes of hypergraph. We consider the mode of a hypergraph as a dense subhypergraph consisting of hyperedges with high self-compactness. We first define the hypergraph den-sity , then formulate the modes of a hypergraph, which leads to our hypergraph shift algorithm in section 4. Hypergraph Density. We describe hypergraph G with n hyperedges by prob-the probability of e i contained by the probabilistic cluster of G . Then the affin-ity value between any pair-wise x  X   X  n and y  X   X  n is defined as m ( x , y )= i,j M ( i, j ) x i y j = x G ,isdefinedasEq.(3).
 Intuitively, hypergraph density can be interpreted by th e following principle. Suppose hyperedge set E is mapped to I = { i m | m =1 ,..., |E|} , which is the representation in a specific featur e space regarding all hyperedges in E ,wherewe the probabilistic coordinate p can be interpreted to be a probability distribution, that is, the probability of i m occurring in a specific subhypergraph is p m . Assume that the distribution is sampled N times, then the number of data i m is N p m . of the data set: Definition 1. (Hypergraph Mode) The mode of a hypergraph G is repre-sented as a dense subhypergraph that locally maximizes the Eq. (3) .
Given a vector p  X   X  n ,the support of p is defined as the set of indices corresponding to its nonzero components:  X  ( p )= { i  X  X E| : p i =0 } . Thus, its corresponding subhypergraph is G  X  ( p ) , composed of all vertices whose indices dense subhypergraph. Hence, the problem of mode seeking on a hypergraph is equivalent to maximizing the density measure function F ( p ), which is taken as the criterion to evaluate the goodness of any subhypergraph.

To find the modes, i.e., the local maximizers of Eq. (3), we classify it into the standard quadratic program (StQP) [16,1]: According to [16,1], a local maximizer p  X  meets the Karush-Kuhn-Tucker(KKT) condition. In particular, there exist n + 1 real Lagrange multipliers  X  i 0(1  X  i  X  n )and  X  , such that: for all i =1 ,...,n ,and n i =1 p  X  i  X  i =0.Since p  X  and  X  i are nonnegative, it indicates that i  X   X  ( p  X  ) implies  X  i = 0. Thus, the KKT condition can be rewritten as: where ( Mp  X  ) i is the affinity value between p  X  and e i . Commonly the hypergraph can be very large, a natural question is how to per-form modes seeking on a large hypergra ph? To answer this question, we perform mode seeking on subhypergraph, and determine whether it is the mode of the hypergraph. If not, we shift to a new subhypergraph by expanding the neighbor hyperedges of the current mode to perform mode seeking. Prior to that, we study the circumstances that determine whether the mode of a subhypergraph is the mode of that hypergraph.

Assume p  X  S isthemodeofsubhypergraph S containing m = |  X  ( p  X  S ) | hyper-edges, then we expand the m dimensional p  X  S to |E| dimensional p  X  by filling zeros into the components, whose indices are in the set of G  X  X  . Based on that, Theorem 1 is presented to determine whether p  X  S is the mode of hypergraph G . Theorem 1. Amode p  X  S of the subgraph S is also the mode of hypergraph G where p  X  is computed from p  X  S by filling zeros to the elements whose indices are in G  X  X  and I j is the vector containing only hyperedge e i where its i -th element is 1 with others 0.
 F ( p  X  )= F S ( p  X  S )=  X  ,  X  j  X  G  X  X  , p  X  is the mode of hypergraph G .Otherwise thus it is not the mode of G .

Next, we introduce our hypergraph shift algorithm, which consists of two steps: The first step performs mode seekin g on an initial subhypergraph. If the mode obtained in the first step is not the mode of that hypergraph, it shifts to a larger subhypergraph by expanding the support of the current mode to its neighbor hyperedges using the technique, namely probabilistic voting. The above steps alternatively proceed until the mode of hypergraph is obtained. 4.1 Higher-Order Mode Seeking Given an initialization of p (0), we find solutions of Eq. (5) by using the replicator dynamics, which is a class of continuous and discrete-time dynamical systems arising in evolutionary game theory [20]. In our setting, we use the following form: It can be seen that the simplex  X  n is invariant under these dynamics, which means that every trajectory starting in  X  n will remain in  X  n for all future times. Furthermore, according to [20], the objective function of Eq. (3) strictly increases along any nonconstant trajectory of Eq. (8), and its asymptotically stable points are in one-to-one with local solutions of Eq. (5).
 4.2 Probabilistic Voting We propose to find the dominant seeds of the subhypergraph, from which we perform hypergraph shift algorithm. Before presenting the formal defini-tion of dominant seeds, we start with the intuitive idea that the assignment of hyperedge-weights induces an assignment of weights on the hyperedges. There-fore, the average weighted degree of a hyperedge e k from subhypergraph S is defined as: Note that g e k ( e k ) = 0 for any e k  X  X  .Moreover,if e j S ,wehave: Intuitively,  X  S ( e i ,e j ) measures the relative closeness between e j and e i with respect to the average closeness between e i and its neighbors in S .
Let S X  X  be a nonempty subset of hyperedges, and e i  X  X  .Theweightof e i is given as w
S ( e i ) measures the overall closeness between hyperedge e i and other hyperedges of
S X  X  e Finally, we formally define the dominant seed of subhypergraph S as follows. Definition 2. (Dominant Seed) The dominant seed of a subhypergraph S is the subset of hyperedges with higher closeness than others.
 Besides, the closeness of the dominant seed is evaluated as follows: We utilize dominat seeds to expand the current subhypergraph, which is named probabilistic voting that works by the following priciple. To expand S to a new subhypergraph, we decrease the possibility of the hyperedges in the current mode, while increase the possibility of hyperegdes with large rewards not be-longing to the current mode. As a result, the possibility of hyperedges that are neighborhoods of the hyperedges in S with the large value of p ( e i |S )isincreased. We present an example in Fig.3 to illustrate that.
 Particularly, we calculate the shifting vector  X p , such that F ( p  X  +  X p ) &gt; F ( p  X  ). According to Theorem 1, th ere exist some hyperedges e i , such that if i  X   X  ( p  X  ), otherwise, h i =max { e mode. However, we try to preserve the d ominant seeds with a larger value of p neighborhoods of dominant seeds of the current mode.
 Assume F ( h )=  X  ,thenwehave: We want to maximize Eq. (13), which is the quadratic function of c .Since  X  = have p  X  i + c ( p  X  i  X  1)  X  0, then c  X  min i { p and  X p = c  X  h , which is the expansion vector.
 We summarize the procedure of hypergraph shift in Algorithm 1.
 Algorithm 1. Hypergraph Shift Algorithm.

One may wonder whether Algorithm 1 converges, we answer this question in theorem 2.
 Theorem 2. Algorithm 1 is convergent.
 Proof. Themodesequenceset { ( p  X  )( t ) }  X  t =1  X  U generated by Algorithm 1 is compact. We construct  X  X  ( p ), which is a continuous and strict decreasing function over the trajactory of seq uence set. Assume the solution set is  X  ,then the mode sequence generated by Algorithm 1 is closed on U  X   X  . The above three conclusions are identical to the converge nce conditions of Zangwill convergence theorem [21]. In this section, we conduct extensive experiments to evaluate the performance of hypergraph shift. Specific experimental setting are elaborated in each experi-ment.
 Competitors. We compare our algorithm against a few closely related methods, which are introduced as follows.

For clustering evaluations, we consider the following competitors:  X  The method proposed by Liu et al. in [13], denote by Liu et al. in follows.  X  The approach presented by Bulo et al. in [2], denote by Bulo et al. in follows.  X  Efficient hypergrap h clustering [12] ( EHC ) aims to handle the higher-order
For graph matching, we compare our method to the state-of-the-arts below:  X  Graph shift ( GS ).  X  Two hypergraph matching methods ( TM ) [6] and ( PM )[22].  X  SC+IPFP . The algorithm of spectral clustering [10] ( SC ), enhanced by the 5.1 Clustering Analysis Consider that hypergraph shift is a natural clustering tool, and all the hyperedges shifting towards the same mode should belong to a cluster. To evaluate the clustering performance, we compare HS against Liu et al. ,Bulo et al. and EHC over the data set of five crescents, as shown in Fig.4.

We performed extensive tests including clustering accuracy and noise robust-ness on five crescents gradually decreasing sampling density from 1200 pts to 100 pts. We used the standard clustering metric, normalized mutual information (NMI). The NMI accuracy are computed for each method in Fig.5 (a), with respect to decreasing sample points and increasing outliers. It shows that hyper-graph shift has the best performance even in sparse data, whereas EHC quickly degenerates from 600 pts. The accuracies of methods in Liu et al. and Bulo et al. are inferior to EHC , which is consistent to the results in [12]. To test the robustness against noises, we add Gaussian noise  X  , such that  X   X  X  (0 , 4), in accordance with [14], to the five crescen ts samples, and re-compute the NMI val-ues. As illustrated in Fig.5 (b), the three baselines of Liu et al. ,Bulo et al. and EHC drop faster than hypergraph shift. This is because the eigenvectors required by Liu et al. are affected by all weights, no matter they are deteriorated or not; EHC is better than Liu et al. and Bulo et al. , however, it performs clustering by only considering the strength of affinity relationship within a hyperedge, which is not as robust against noises as the mode with high-order constraints; Hyper-graph shift, in contrast, can find a dense high-order subhypergraph, which is more robust to noises.

We are interested in another important aspect: speed of convergence, under varying number of data points. In Fig.6, we present the evaluation of the com-putational cost of the four methods with varying number of data points. Fig.6 (a) shows the average computational time per iteration of each method against the number of samples. We can see that the computation time per step for each method varies almost linearly with the number of data points. As expected, the least expensive method per step is Liu et al. , which performs update in se-quence. And our method proceeds with exp ansion and dropping strategy, in the expense of more time. However, the drawback of Liu et al. is its large iterations to convergence. In co ntrast, both ours and EHC are relatively stable w.r.t. the number of samples. Our method converges very fast, requiring on average 10 iterations. This figure experimentally show that our method, by taking larger steps towards a maximum, has significantly better speed of convergence with slightly better accuracy. 5.2 Graph Matching In this part, we present some experiments on graph matching problems. We will show that this graph matching problem is identical to mode seeking on a graph with certain amount of noises and outliers. Following the experiment setup of [14], the equivalence of graph matching problem to mode seeking can be described as follows. Suppose there are two sets of feature points, P and Q ,from two images. For each point p  X  P , we can find some similar points q  X  Q ,based on local features. Each pair of ( p, q ) is a possible correspondence and all such pairs form the correspondence set C = { ( p, q ) | p  X  P,q  X  Q } . Then a graph G is constructed based on C with each vertex of G representing a pair in C .Edge c . Due to space limitations, we refer the i nterested readers to [14] for details. Afterwards, the hyperedge construction and weight calculation are conducted according to our technique section. We use the PASCAL 2012 [7] database as benchmark in this evaluation. The experiments are difficult due to the large number of outliers, that are, large amount of vertices and most of them represent incorrect correspondence, and also due to the large intra-category variations in shape present in PASCAL 2012 itself. Under each category, we randomly select two images as a pair and calculate the matching rate by each method. We run 50 times on each category and the averaged results are report in Table 1. The final matching rate is averaged over rate values of all categories.
We also conducted shape matching [15] on the affinity data on the database from ShapeMatcher 1 , which contains 21 objects with 128 views for each object. A few examples of dog X  X  shape are shown in Fig.7. For each shape, we compute the matching score as the affinity value using the shape matching method [15], thus obtain a 2688  X  2688 affinity matrix. We compare our method with EHC and GS . The results are shown in Table 2. Both GS and HS can specify the number of objects, however, HS outperforms GS in terms of precision due to the fact that HS considers high-order relationship among vertices rather than pair-wise relation.
 In this paper, we propose a novel hypergraph shift algorithm aimed at finding the robust graph modes by probabilistic voting strategy, which are semanti-cally sound besides the self-cohesiveness. Experimental studies show that our paradigm outperforms the state-of-the-art clustering and matching approaches observed from both synthetic and real-world data sets.
 Acknowledgment. Xuemin Lin X  X  research is supported by ARC DP0987557, ARC DP110102937, ARC DP120104168 and NSFC61021004.

