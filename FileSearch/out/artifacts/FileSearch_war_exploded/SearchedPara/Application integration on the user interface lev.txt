 1. Introduction
In the past decades, software engineering has been changing from building one-piece monolithic programs to assembling developers and integrators should be enabled to connect software modules without having to know about other components' about how other components actually work internally.
 representations of their semantics is often referred to as semantic integration or ontologies-based integration . [3] . Therefore, the integration of software systems can be performed on three levels, as shown in Fig. 1 .  X  different underlying data sources [6] .  X  also referred to as semantic enterprise application integration ( EAI ) [2] .  X  for ontology-based integration on that level.
 learning curve than with a new user interface developed on top of integrated business logic or data sources.
Using those ontologies, integration rules can be formulated that de the resulting systems remain modular and maintainable.

In this paper, we present a fi rst cut on an ontology of the domain of user interfaces and interactions, which de be integrated on the user interface layer. It can be combined with real world domain ontologies de between ontologically characterizing the functional elements of a software component and de framework as such.
 in our framework. We conclude with a review of related work and an outlook on future research. 2. Background
Among the many de fi nitions of information system ontologies, we follow the one given in [10] : conceptualization, this de fi nition re fl ects its foundations in model theory: a model can always only partially re the modelled phenomenon. How ontologies are tied to information systems becomes even clearer in the following de  X  [An ontology is] a set of logical axioms designed to account for the intended meaning of a vocabulary theory accounting for the intended meaning of a formal vocabulary [12] .
 can be added to many of those languages, while F-Logic has native means to express rules [17] .
Ontologies can be used throughout the whole cycle of software development [18,19] , starting from ontology-assisted employment at development time vs. run time, thus leading to a fourfold categorization. hybrid models can be distinguished. In direct models, the domain concepts are directly implemented in the programming classes and properties. While direct models are considered less model for top-level domain concepts and an indirect model for bottom-level ones. hosting application provides a fi xed number of extension points with de of modularization where all plugins are independent of each other [27] .
 an engine for running plugins not providing any speci fi c functionality to the end user, and plugins that can de environment Eclipse [29] .
 such as portals [30] and mashups [31] . Most of those approaches have signi cross-application interaction, which in most cases is rather dif leads to code tangling and non-modular, hard-to-maintain systems [5] .
 and improving application integration on the user interface level. 3. Framework than OWL DL [17] . 3.1. Ontological characterizations and semantic annotations well as for semantically annotating the information objects exchanged between those applications:  X  The ontology of the user interfaces and interactions domain contains basic categories such as I  X  architecture (OBA).
 application and managing event exchange with other plugins. For each integrated application, the developer creates an de related to each other.

Based on those application ontologies, integration rules for coordinating cross-application interactions can be de ontology as well as their connections and corresponding integration rules are shown in Section 4 . 3.2. An ontology of the user interfaces and interactions domain
For explaining the necessity of the clear distinction of the ontologies on the domain level motor for making the balls go round. Some of the parts represent objects in the real word a button.
 information system, e.g. adding new software applications to the integrated system.
Since the application ontology does not contain any domain-speci
Besides the different concerns addressed by those two ontologies, there is also a subtle semantic difference. When the framework runs an application encapsulated in a plugin, this application is an instance of the category domain ontology's categories. Therefore, the information objects meaning , while the instances of the application ontology, such as plugins, do not have a meaning. plugin's functionality. To explain this relevance, we consider a real world domain ontology from catastrophe management containing the classes TACTICALUNIT (such as a fi re brigade unit) and information object for an (existing) object in the world, such as adding a new creation of a physical fi re brigade car in the world), and creating a domain object , such as the system issuing an information objects and domain objects is therefore needed; the same holds for modifying and deleting objects. subcategories U SER A CTION and S YSTEM A CTION , which are further speci interactive component can support several interactions.

Eachuseractionandsystemaction involves informationobjects, which represent objectsfromtherealworlddomaintheapplication world domain ontology and forms the bridge between the  X  information system world means that any real world domain ontology can be used with our framework without further modi domain ontology can be exchanged for building applications for different real world domain based on our framework. 3.3. System architecture
Our application framework, shown in Fig. 4 , provides the possibility to de integrated applications consists of three parts: 1. A GUI, i.e., each plugin is capable of displaying itself and interacting with a user. services. 3. An object model in which the data processed by the application is de own object models fi tting the respective implementation needs of their applications. interactions domain by de fi ning subcategories e.g. of A objects represent domain objects, each information object has a
Plugins can exchange events via an event exchange mechanism which allows broadcasting as well as point to point the domain and application ontologies.
 b className , URI N for annotating classes, and triples of the form fi ndoutwhichapplicationshavede fi nedinteractionstriggeredbythatsortofevents,andnoti 4. Example 4.1. Scenario ontology, which is grounded in the foundational ontology DOLCE [36] . The concepts taken from DOLCE are marked in gray. resources, such as material or devices, in which the user can highlights the corresponding symbol on the map. We show the process of integrating the GI application in our framework. 4.2. Preparation
Three steps are necessary for integrating an application in our framework: 1. describe the interaction of the applications in the respective applications ontologies, the classes and the real world domain ontology, and 3. de fi ne integration rules for cross-application interactions.

In the application ontology, the interactive map component is de application 1 :
These de fi nitions are required for the fi rst step, i.e. de classes used to represent the objects involved in this interaction with the appropriate concepts de two plugins involved in the example. Those mappings are stored in the annotation registry (see Fig. 4 ).
As shown in Fig. 7 , one mapping for a class and two mappings for attributes have to be de mappings are represented by the following tuples, which are stored in the annotation repository: which it can be performed, and the component that supports the interaction However, this rule de fi nition is not optimal. We have explicitly enumerated all the object categories ( interaction would make sense for (such as a plugin showing a list of buildings), the interaction de position: 4.3. Execution (3) formulated above thus become known to the reasoner. is started, the temporary instances (marked with the pre fi reads the event and the object(s) contained therein, and inserts the corresponding temporary axioms: axioms are:
Once these instance data have been added to the ontology, the reasoner can be queried for the interactions that can be triggered by the action (query variables are marked with ?) and the components that support the interaction:
This query can be evaluated by the reasoner using the axioms stated above, thus retrieving a result list containing the geographic information application as de fi ned above. The reasoner component can now use that information to create an axioms 6 to 8 are removed.
 re fl ection mechanisms.

This example has shown how axioms from the ontologies play together to facilitate the integration of user interfaces encapsulated in plugins, and how the reasoner can serve as an indirection for decoupling the integrated applications. example is the dynamic population of tool bars and menus [37] .
 literature [41,42] , since OntoBroker provides a lot of mechanisms for on those optimizations are out of scope of this paper. 5. Related work source and on the business logic level. Database integration is a services for solving complex tasks [43  X  45] .
 such as licensing policies. A software architect can then search those repositories with ontology-based queries [51 these works compared with the framework described in this paper is that semantics are used at development time for appropriate components, not for assembling them at run time of the system.
 modular ontologies, comparable to the ones described in this paper. Other works employing ontologies in different interface development encompass requirements engineering [57,58] , con of the software system.
 6. Conclusion and future work interactions while preserving a modular and easily maintainable system, and without having to deeply understand each application to be integrated.

The framework foresees the use of a real world domain ontology which is not tightly coupled to the framework. Thus, the world objects. Furthermore, we have conducted experiments showing that the framework scales up to a large number of integrated applications [40] .
 ontology and shared real world domain ontology.
 extending the framework such that each plugin may expose information about its state will be part of our future work. ontologies and taken into account when determining interactions [62
Furthermore, we have only considered information systems so far. In an information system, the user can only manipulate application ontology, we have already paved the way to enhance our framework in that direction. extended to developing a component which can also answer users' questions, such as mapping mechanism [65] .
 such as a domain-speci fi c ontology creation tool would further simplify the process of application integration.
In summary, we have presented an approach and a prototype implementation using ontologies for system integration on the steps further into the engineering of large, complex software applications.
 Acknowledgements
The work presented in this paper has been partly funded by the German Federal Ministry of Education and Research under grant no. 01ISO7009.

References
