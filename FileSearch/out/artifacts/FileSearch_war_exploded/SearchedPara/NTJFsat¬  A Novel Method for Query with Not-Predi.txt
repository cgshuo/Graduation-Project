 Previous researches, in the file d of XML databases, have been done to evaluate XML queries w ith AND-branches. However, as far as we know, very little work has examined the efficient processing of XML queries with NOT-predicates. Also these methods have to process all of the query nodes in the document when dealing with queries with NOT -branch. In this paper, with some modification in TJFast method, we propose a new manner for answering to various NOT-queries. This method processes nodes efficiently, in a way that in the ideal state, we obtain part of the answer after the process of each node, and we don X  X  have any unreasonable processing of each node. H.2.4 [ Database Management ]: Systems  X  Query processing Algorithms, Performance, Experimentation XML, Twig Joins, TJFast, NOT-Predicates, Dewey encoding multiple elements that has a tree structure named Tree Pattern Query (TPQ) . The structure of an XML query could be shown in a TPQ. The aim of all XML query processing methods is to find all TPQ instances in the XML document. A number of methods are proposed to facilitate this procedure. We classify these methods into three groups:  X  Group A: the classified methods in this group are based on the famous method named Structural Join [1]. In Structural Join, query is decomposed into some binary join operations. Thus, a huge volume of intermediate re sults are produced in these methods. Dewey labels of nodes. We use preprocessing on the query. With this preprocessing, the nodes that are needed to be processed and their processing way will be determined. We show a method for solving queries with NOT-branches (single branch, multi branches, nested) . We also proposed a bottom up algorithm for solving them, in a way that in the ideal state, after processing each node, we are able to obtain part of the answer and prevent unreasonable processing of each node. Transducer (FST) [6]. The output of this execution is a table which named Result_Table (R_T) that specifies the manner of nodes processing in the document (see figure 2). branch queries, we present just a summary of this method. In order to create the Result_Table from a given TPQ and FST, first the leaves of TPQ are extracted and then for each leaf, a list of corresponding FST nodes which match the TPQ is formed. The Nearest Common Ancestor (NCA) of each combination of these two lists of nodes in FST is found and for each node between the NCA and the FST root which matches the join point  X  point that links two branches in query  X  of the TPQ, a record labeled with the level number of that node in the TPQ is added to the Result_Table. Then, through Result_Table , all of the lists of leaf nodes ar e compared in the document and would be a part of the answer if they are equal in the join point level. in figure 3. The procedure is that first divide the query into single branch query C//A and C/D . Here, the joint point is C . Now, all As and Ds (leaf nodes in TPQ) must be found in FST. As a result of this execution, A1 and A2 nodes are found for As and D1, D2 and D3 for Ds . But through FST, it is clear that A1s and D2s have not single branch properties( C//A, C/D ). So they are omitted from the lists. From the FST it is clear that A2 and D1 nodes could be a part of the answer. Now, the common level between them must be specified. It is clear from the FST that A2 s and D1 s are a part of the answer which they are in common up to the third levels of query answer. On the other hand, it is clear from FST that D3s can not form the joint point with any the query answer. process their leaves. Moreover, the list of leaves has been scanned only once. Here, the processing of the leaves of negative parts is not unreasonable and would delete some parts of leaves of positive part, but there are a few cas es for which there is no need to process the node from one of the lists and we can skip it. If a node from negative part deletes a repetitive node, that node is the jump node and doesn X  X  need to be processed (lines 8 and 10 in figure 6). This can be understood from similar prefix of nodes. branches are joined in one point, joint point , is called multi-branches query; Consider query Q4: //C[ NOT (.//A)]/D . We will show that the solution of this type of queries don X  X  impose any processing more than their equivalent positive queries and the leaf lists of each branch will be scanned only once like their equivalent positive queries. apply query to the FST. But here, we find only leaves of positive part. Like previous, the answers are divided into two groups: 1) those lack of negative parts 2) Those which need investigation to find the lack of negative parts. For second group of the answers, the negative parts of their leaves are found. Then, they delete the leaves of positive part and the re st of the positive leaves are the answer. The procedure is as the following. First, all the negative parts are listed. Then we choos e the common level between two branches (negative and positive branch) from negative nodes label, after ward, from list of pos itive parts, we delete those nodes which begin with this label. answers, C1/D1 and C2/D3 . As it is clear from FST, there is no need to investigate C2/D3 for negative parts. But the main problem is the solving of C1/D1 . Here, we delete the D1s which are in common with the A2s up to third level of Dewey codes. common usage of them. But it is rarely seen that the NOT-operator inside of another NOT-opera tor is used as one or several stages. For example, look at Q5: //A//B[ NOT .//C( NOT .//D)]. These types of queries are divided into more than two queries. For example, the Q5 can be divided into 3 queries, two positive and one negative (figure 7). E and F . But here we compare our method with TJFast and Twig 2 Stack [3], two popular methods to answer to positive queries.
 single branch queries A1, A2, ..., A8 with 2, 3 , ..., 9 length respectively. All queries are Partia l, i.e, they begin with //, As shown in figure 9(a), as many as number of single branch queries' nodes increase, number of elements to be accessed in document in RT decrease. A3 and A4 queries which have 2, 3, 4, 5 branches respectively. As shown in figure 9(b) in both methods when number of branches increases, number of node accesses will increase whereas growth rate of RT is very less than growth rate of TJFast. property are performed on the dataset. The spots that are pointed by arrow are extraction points (EXP) [4]. These spots are considered as final result of que ries. Figure 11(a) shows the result of these queries that are applied to accidental dataset. The rightmost column shows the number of queries output (EXP) . The following digits under each method are the numbers of processed nodes. In query (a) , the reason of the differences between our method and the two other methods is derived from the applying the query to FST directly. Since in each three methods, As and Bs nodes must be investigated. But the process of the lists is also done in these three methods differently, and our method skips over all of the nodes that produce repetitive answer. In (b), (c) and (f) queries, NOT-operator is used only once and to come to the answer of these queries only investigate two lists for (b) query and three list for (c) and (f) queries. Figure 11. (a) Number of Processe d Nodes (b) Execution Time other methods that investigate all of the query nodes. This difference is derived from the supe riority of TJFast  X  that only process leaves of queries  X  in relation to the two other methods. In query (d) , we don X  X  see any severe disparity among three 
