 In the age of Web 2.0, OSN have gained pervasive interests in both research communities and industries. There is a trend to model OSN using Semantic Web technologies, especially the vocabularies from FOAF 1 and SIOC 2 project. RDF, originally designed for the Semantic Web, have been wildly adopted for representing such kind of linked data. SPARQL 3 as the de-facto RDF query lan-guage is used for Basic Graph Pattern(BGP) query with bounded or unbounded variables. The scalable graph representation and flexible query capability make RDF model suited for large-scale complex OSN management and analysis.
Figure 1 illustrated a snippet of large social graph representing relations be-tween four users and three User Gener ated Contents(UGC). Query which Find pair of users in a path of friend relationship which user2 has a job and like the documents created by user1 is expressed in SPARQL as: SELECT DISTINCT ? user1, ? user2 WHERE { The pattern ?user1 knows* ?user2 states the path consist of zero or more knows predicates, it is a proper ty path query pattern.
 Challenges. Path queries are of common interest in OSN analysis for discover complex relations among entities. Despite the scalability and flexibility provided by RDF model, Path queries performs poorly and lack of efficient implementation in existing RDF management. Current researches in graph analysis domain are mainly based on pre-constructed reachability indices. Building such indices are both time and memory consuming, especially when dealing with large complex graph. From RDF management point of view, due to costly join for triple pattern matching, there lacks efficient implementation of property path query. Although property path query is recommended by newest SPARQL 1.1 standard, to the best of our knowledge Jena 4 , Virtuoso 5 and Sesame 6 are the only three off-the-shelf RDF stores that support standard ized path query. They all suffer from performance problems when dealing with path query on large-scale data. Overview of Our Approach. Our approach is motivated by three observa-tions. First, current off-the-shelf RDF store performs well only on join-based star queries. Second, the search space of prop erty path query is res tricted to triples representing relations among entities. Third, due to the rich semantics in OSN, most triples are for entities attributes not for relations. Based on these observa-tions, we argue that manage graph topology-related triples into main memory is feasible, and this will greatly enhance the online query performance of prop-erty path related sophisticate SPARQL queries. We propose a hybrid framework that has in-memory management of graph topology-related RDF data along with disk-based Jena TDB 7 native triple store. In our approach, while loading and indexing triples into TDB, graph topology-related triples are identified and du-plicated in main memory. For an online query, we implement a graph traversal based algebra operators for property pa th pattern, which is more efficient than traditional join-based operator.
 Contributions. We summarized our contribution in this paper as: 1. We propose a main memory/disk based hybrid framework for efficient prop-2. We present an algebra operator for property path pattern query. Its realiza-Organization of the Paper. The rest of the paper is organized as follows. Section 2 presents the basic design of our hybrid RDF management framework. Section 3 shows the evaluation results. We conclude in Section 5. Given vocabulary  X  = V E  X  V A  X  E EE  X  E EA  X  L E  X  L A defined in Table 2, an OSN is represented as a triple set T OSN = T G  X  T A , where the graph-topology set T G  X  V E  X  L E  X  V E holds triples representing social entities and relations among them, and the attributes set T A  X  V E  X  L A  X  V A holds triples representing attributes and theirs relat ions to social entities.
 2.1 Architectural Design In this paper, we focus on efficient implem entation of property path query. Con-sider that path query only related to Triples in T G (In Figure 1, T G is represented as dashline-encircled part), one direct motivation is that manage T G in memory will greatly enhance the overall query performance. Based on this motivation, we implement a hybrid RDF data management architecture that manage different query-prone data respectively. Th is architecture is shown in Figure 2.
Our approach can be thought as a plugin component which override the func-tionality of corresponding part in TDB. At data loading stage,  X  t i  X  T OSN is loaded into Jena TDB (step 1 -in Figure 2). At the same time,  X  t i  X  T G is filtered out based on two kinds of rules: 1. The type of Objects .If Objects for t i is a literal, then t i  X  T A . 2. The semantic meaning of Predicate . Such as foaf:knows defined in FOAF
T G is stored in main memory with subject index(PSO) for forward traversal and object index(POS)for backward traversal(step 2 -).These indices can be con-structed incrementally when topology-related data is extracted and loaded into main memory.

When an online query is submitted, SPARQL parser translates query strings into patterns based on standard abstract syntax tree recommended by W3C (step 3 -). Analyzer translates these patterns into predefined SPARQL algebra operators and construct execution plan (step 4 -).An algebra operator generates designated result set from given input (step 5 -). In our approach we implemented a special operator named OpPath which only uses in-memory data as input. If a query string in WHERE clause is analyzed as property path pattern, OpPath operator is added to the query plan. (step 6 -) We explain the design of OpPath operator in detail in Section 2.2. Result set of algebra operator is joined to get the final result set. The join order of operators is optimized using cost and selectivity estimation (step 7 -). 2.2 Property Path Algebra Operator Definition 1 ( OpPath Operator). OpPath is a ternary algebra operator that can be defined as OpPath(O,S, P P ). S,O  X  V EE can be either bounded or un-bounded variables, | S | = s , | O | = o . P P is a regular pattern expression defining the property path. OpPath(O,S, P P ) operator find existing path from set S to set O , and return all triple sets that each paths is consist of as result set. Based on research [9] which have testifie d that graph explorations is extremely efficient and more easy to implement than costly joins, the OpPath operator is realized as in-memory Breadth-First Search(BFS). The OpPath operator has than tradition nested-loop join that has time complexity O ( | V E | X | E EE | ).
The cost of OpPath operator is the cardinality of result set R ( q )forpath query pattern q . Existing researches such as G-SPARQL [7] using predefined heuristics which always take | R ( q ) | as the largest, this is far from optimal. Spar-qling Kleene [2] using pre-computed reachability path indices which affects data load efficiency. We consider t hree factors that affects | R ( q ) | , the average nodes out-degree, the path length l and the pathes that fits for the given pattern. In our approach, we leverages the graph generation model [4] which expects the average out-degree as d out = | V EE | 1  X  ln c , 1 &lt;c  X  2. We also assumes that nodes in T G has the same probability of being added to the path, thus the modify-ing factor of out-degree follows the binomial distribution. For all considerations above, | R ( q ) | can be approximatel y estimated as: store. We performs preliminary testing to measure the accuracy of Equation 1 with real all-pair cardinality of dataset in Table 2. For SNIB T G with average d out = 12, c =1 . 75, relative error = 1 is about 27%. For DBLP T G with d out =7, c =1 . 81, and error = 32%. This preliminary testing shows that the heuristic defined in Equation 1 is with acceptable cardinalit y estimation error. We used one machine with Debian 7.4 in 64-bit Linux kernel, two Intel Xeon E5-2640 2.0GHz processor and 64 GB RAM for our evaluation. Our approach is compared with Jena(version 2.11.1), Sesame(version 2.7.10) and competitive research G-SPARQL [8]. Jena implements path query based on join while Sesame is based on graph traversal. We also implements our approach with no cost estimation and treats path query as the most costly(denoted as NoCE ). All evaluations were done 10 times and the results are the averages.

We adopted two datasets, the Social Network Intelligence Benchmark (SNIB) 8 as synthetic dataset, and DBLP as real dataset, all in RDF N-Triples format 9 . SNIB dataset is generated using S3G2 [6]. Considering G-SPARQL uses ACM digital library dataset which is not publicly available, we uses the DBLP dataset instead 10 . Statistics of datasets are shown in Table 2. The DBLP dataset has approximately the same characteristics as the Large Graph Size experiment in G-SPARQL.

For offline data loading time and memory expenses, we compare our approach with four competitors, Sesame and Jena in-memory store which store and index data only in memory, Sesame native store and Jena TDB which use disk as triple storage. Results of data loading time is represented in Figure 3(a),and disk usage in Figure 3(b), memory usage in Figure3(c). For our approach only load graph topological data into main memory, it need fewer memory than that of Jena and Sesame in-memory store, but with a little overhead of the data loading time.
For online query performance, in SNIB benchmark only Q 3and Q 5arepath query related, while for DBLP we chosen 7 out of total 12 queries in G-SPARQL experiments(denoted as Q g ). In order for comparison, we had to rewrite these queries on DBLP dataset. Figure 4(a) shows that our approach achieved the best performance for SNIB Q 3. As for SNIB Q 5, the 3-HOP which expressed in UNION clause is explicitly parsed into six joins. This causes an expensive join expenses. Results in Figure 4(b) show that our approach works better than G-SPARQL(got directly from the Large Graph Size result in [7]), while NoCE has approximately the same performance as that of G-SPARQL. This shows that cost estimation for optimal join order can enhance the overall query performance. Most existing RDF stores uses a relational model to manage data, either in a traditional RDBMS or using a native triple store. They all processes SPARQL queries as sets of join operations using disk-based indices, which are costly for sophisticated joins. Some researches ha ve focused on compressing and managing RDFs in main memory, Trinity RDF [9] is the most prominent among them. It uses graph exploration instead of join operations and greatly boosts SPARQL query performance. But manages all data in memory is not trivial, distributed shared memory increases the complexity for maintenance.

From graph analysis perspective, Prop erty path can be viewed as the label-constraint reachability problem on labeled graph. Though reachability on graph is a further investigated problem, few literatures [1, 10] considered its usage in property graph, which is more common in nature. These researches are mainly focus on building reachability indices in advance, which is time or space con-suming and not adequate for large-scale data management.

Besides Jena and Sesame, several fram eworks and prototypes have been pro-posed for path queries [2,3,7]. BRAHMS [3] only supports query on paths with predefined length. Sparqling Kleene [2] re alizes join based on pre-constructed reachability indices which are space consuming. Our work is mainly motivated by G-SPARQL [7] which use the same hybrid storage and manage graph topo-logical data in memory. Our work different from G-SPARQL in that, first, we are not design a new query language but uses standard SPARQL 1.1 instead, this makes our work more general. Second, G-SPARQL uses index-free pointer-based data structure to representing the graph topological data in memory, in order to suit for most graph algorithms. Our work only cares about path pat-terns which BFS algorithm is used to answer such reachability queries. We build simple indices only for facilitating BFS. In this paper we addressed the problem of property path query in RDF data, presented a step towards incorporation of in-memory storage. In our approach we are not trying to invent new wheels, but managed to combine existing effec-tive approaches as well as some technical enhancements. Contrast to traditional RDF management and graph query method, we used in-memory graph traversal instead of costly join to realize path query operator, used simple graph indices other than RDF permutation indices and complex graph reachability indices for efficient graph traversal. Evaluations have shown that our approach is feasible and efficient for process SPARQL property path queries.

