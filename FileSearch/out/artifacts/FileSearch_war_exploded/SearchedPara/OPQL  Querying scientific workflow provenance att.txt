 1. Introduction and a process dependency graph associated with process p 8 for  X  by a recursive query via the WITH ~ UNION ALL clause to track ancestor nodes associated with artifact a recursive query pattern.
 supports querying provenance at the graph level; and (2) we implement OPQL using a Web service via the OPMP therefore, users can invoke the Web service to execute OPQL queries in a provenance browser, called OPMP OPQL queries is displayed as a provenance graph in OPMP RO The rest of the paper is organized as follows. In Section 2 , we overview the OPMP discusses possible future research directions. Finally, Acknowledgments section concludes the paper. 2. OPMP ROV overview without any external reasoning engine. More details on the implementation and performance of OPMP the functionalityof OPQL througha Web serviceinterfaceso thatother systems can use it;and (2) OPMP overview of the current version of OPMP ROV in the context of the VIEW workflow system [18] in Fig. 3 . OPMP ROV plays a role of Provenance Manager in our VIEW system.

Fig. 3 (b) shows the three-layer architecture of OPMP ROV functionalities of provenance querying, data insertion, and provenance visualization via OPMP OPMP ROV .

Because experiment reproducibility and provenance reasoning are known to be vital aspects in scientific workflow management [16,18] , the role of OPMP ROV in the workflow management system is crucial. 3. The OPQL query language propose OPQL syntax and semantics. Finally, we discuss how provenance queries can be expressed in OPQL . 3.1. The OPMP ROV provenance model We adopt the notion of nodes and edges proposed in OPM [15] to define the multiple accounts. In Fig. 1 (b), the edges represent the following causal dependencies: (1) edge Used ( u a and a 2 , p 3 used a 3 , and so on; (2) edge WasGeneratedBy ( g by p 5 , and so on; (3) edge WasDerivedFrom ( d 1 , d 2 ): a ( t ): p 2 was triggered by p 1 ; and (5) edge WasControlledBy ( c
We formalize a provenance graph as follows. A provenance graph PG =( N , E ) consists of: 2 a set of directed edges E = E u  X  E g  X  E d  X  E t  X  E c ii) E g p A  X  P and ( a , p )  X  E g states that artifact a was generated by process p , iii) E artifact a 1 was derived from artifact a 2 , iv) E t p P  X  P and ( p E c p P  X  AG and ( p , ag )  X  E c states that process p was controlled by agent ag . process p 2 in Fig. 1 (b). 3.2. Graph patterns we define six types of graph patterns, which are the main building blocks of an OPQL query.
De fi nition 1. Graph pattern: type B .

De fi nition 2. Graph pattern: type O .
 composed of ten types of mapping functions i : e :; O  X  O dependencies associated with a node. Fig. 6 shows a sample graph pattern P function ( O u ), and the predicate stating the identifier of node v Next, we define the following four graph patterns to support tracking of ancestor nodes.
De fi nition 3. Graph pattern: type D .
 nodes associated with artifacts forward and backward, D is composed of two types of mapping functions (i.e., D defined below: with artifacts. For example, Fig. 7 shows a sample graph pattern P ( D fwd ), and the predicate stating the identifier of node v
De fi nition 4. Graph pattern: type T .
 nodes associated with processes forward and backward, T is composed of two types of mapping functions (i.e., T defined below: associated with processes. Fig. 8 shows a sample graph pattern P ( T fwd ), and the predicate stating the identifier of node v
De fi nition 5. Graph pattern: type G .

De fi nition 6. Graph pattern: type U .
 ancestor nodes associated with processes and artifacts, respectively. It can be shown that graph patterns P by graph pattern P b similarly to the previous examples.

De fi nition 7. Graph pattern matching  X  .

A graph pattern P b is matched with a graph PG if there exists an injective mapping (  X  ( u ),  X  a ( v ))is an edge in PG , and ii) predicate C  X 
De fi nition 8. Graph pattern matching  X  .

A graph pattern P o is matched with a graph PG if there exists an injective mapping  X  e ( u , v )  X  E ( M ), (  X   X  ( u ),  X   X  ( v )) is an edge in PG ,ii)function O
De fi nition 9. Graph pattern matching  X  .
 such that i) For  X  e ( u , v )  X  E ( M ), (  X   X  ( u ),  X   X  and iii) each predicate C  X   X  ( PG ) holds.
 To denote the binding between a graph pattern and a provenance graph, we define a matched graph as follows.
De fi nition 10. Matched graph.

Given an injective mapping  X   X  {  X  a ,  X   X  ,  X   X  } between a pattern P graph is a triple (  X  , P , PG ) and is defined as  X  P ( PG ). 3.3. Provenance graph algebra
We propose a provenance graph algebra for the OPQL query language. The provenance graph algebra is based on four following four operators to manipulate and query a provenance graph. 3.3.1. Extract operator (  X  ) find all artifacts that contributed to derive artifact a 6
This query first generalizes a matched graph which consists of a set of artifacts ( a graph. The output of the extract operator is a provenance graph: let PG 1 and PG 2 be the output of  X  P 1 PG  X  X  and  X  P 2 PG  X  X  , respectively. Given two subgraphs PG and PG 2 p PG , these operators are defined as follows. 3.3.2. Union operator (  X  )
The union operator calculates the union of two subgraphs. A union operation is defined by PG provenance graph PG  X  =( N  X  , E  X  ), where
For example, let Fig. 9 (a) be a provenance graph ( PG ). Then, Fig. 9 (b) and (c) represents the output of  X   X  PG  X  X  , respectively. You might want to find all artifacts that contributed to derive either artifact a provenance graph G . Using the union operator, this query can be expressed as query is shown in Fig. 9 (d). 3.3.3. Intersection operator (  X  ) resulting in a provenance graph PG  X  =( N  X  , E  X  ), where
For example, you might want to find all artifacts that contributed to derive both artifact a graph PG . Using the intersection operator, this query can be expressed as shown in Fig. 9 (e). 3.3.4. Difference operator (  X  )
The difference operator calculates the difference of two subgraphs. A difference operation is defined by PG a provenance graph PG  X  =( N  X  , E  X  ), where
Here, nodes denotes a function returning a set of all nodes in E contributed to derive artifact a 5 , but not artifact a 8 expressed as  X  P 3.3.5. Example provenance queries expressed using the provenance graph algebra queries (Q1  X  Q4) for the Load Workflow defined in the Third Provenance Challenge [9] and four queries (Q5 expressed in OPQL as shown later in Fig. 15 ). First, let PG contributed to a given detection, can be answered by a query expressed as all artifacts that contributed to derive the artifact with the value artifacts whose values contain the CSV literal via the intersection with by  X  answered by a query expressed as  X  P  X  which asks for a process dependency view for all the steps that contributed to trigger the last step (id = P using  X  P used by the last step (id = P n ), can be satisfied by using 3.4. OPQL syntax and semantics queries are formulated against a provenance graph displayed by a graphical user interface. 3.4.1. OPQL syntax and AG), one of the single-step-edge-forward constructs (USD, WGB, WCB, WDF, and WTB), one of the single-step-query. A node expression ( X n ) can be expressed by an artifact node expression ( X 3.4.2. OPQL semantics Let PG =( N , E ) be a provenance graph such that N = A  X 
X ( PG ) returns a subset of N as depicted in Fig. 10 (b), where ids ( n and they are defined as functions that take a provenance graph PG =( N , E ) and a node expression X satisfying node expression X n such that X n ( PG ) p N . Specifically, given single-node construct C graph PG =( N , E ), and node expression X n , the semantics of the single-node constructs are defined by C with cause nodes satisfying X n ( PG ). Specifically, given single-step-edge-forward construct C
WTB }), single-step-edge-backward construct C  X  (i.e., C  X  defined by C e ( X n , PG )={ n cause ! n effect  X  X n and ( n respectively. More details on the semantics of these constructs are shown in Fig. 10 (c). dependencies (i.e., transitive relationships) with those nodes satisfying X multi-step-edge construct WDF *( a 5 ) returns all artifacts that contributed to derive artifact a { a , a 2 , a 3 , a 4 } by the computation of transitive relationships associated with artifact a a ),( a 5 , a 3 ),( a 4 , a 3 ),( a 3 , a 2 ),( a 3 , a 1 ),( a and a set of edges. For example, given two OPQL queries Q formulated using set operators UNION, INTERSECT, and MINUS (e.g., Q details on the OPQL query expression are discussed in the following section. 3.5. Expressing provenance queries in OPQL allows users to effectively formulate the query with just writing WDF *( a process identifiers contributed to the generation of the artifact with the value used by those processes. To accomplish the latter, SQL query uses the string content of column A2 . Value that ends with  X  Detection.csv all processes that contributed to generate an artifact whose value is bindings.
 although query results are the same. 4. Implementation of OPQL In this section, we discuss how our OPQL is implemented via OPMP one is OPMP RO V IS D (desktop version) implemented in Java and JGraph and the other is OPMP retrieves provenance graph constituents from the corresponding tables in OPMP graph, and constructs a provenance graph. The algorithm is implemented in both OPMP
OPMP RO V IS D and Fig. 16 (b) shows the output of OPQL query WTB *(p 5. Provenance graph reconstruction Algorithm 1 shows an algorithm that retrieves an OPM graph constituents from OPMP relational database storing OPM-compliant provenance data (lines 5 correspond to three OPM nodes and five OPM edges, respectively. During the second step (lines 13 represent artifacts, processes and agents of an OPM graph (sets V
WasTriggeredBy are created by retrieving elements from the sets R 39 respectively. The obtained tuple PG is then returned as the final result of the algorithm. 6. Experimental study all the experiments, we show the results as the average of 20 trials.

Fig. 17 shows the process of provenance querying in OPMP ROV service response, and 5) visualize the OPM-compliant XML document as a graph at the client side. that are beyond the scope of this work.
 Therefore, to validate the feasibility of our approach, in our experimental study we show that OPMP steps in a reasonable time. 6.1. Provenance query performance
To ensure that our OPQL-to-SQL mapping returns queries with reasonable execution times, we evaluated the query the total number of nodes and edges is 2909. Queries Q1  X 
Challenge (CQ1, OQ8, OQ4, and CQ3 respectively). Queries Q5 components.
 Fig. 18 (a) and (b) shows reasonable performance of our OPMP reasonable execution times of less than 0.06 s, as shown in Fig. 18 (a). 6.2. OPM graph reconstruction performance Provenance Challenge [9], and inserted these datasets into OPMP able to reconstruct provenance graphs for each of the five datasets in less than 2 s ( Fig. 18 (c)). graph, which has a total 25,000 nodes and edges is the most complex of the five. The times taken by OPMP graph are reported in Fig. 18 (d). Fig. 18 confirms that OPMP the larger datasets, taking under 26 s to reconstruct the provenance graph with 25,000 nodes and edges. 7. Related work formulated. A QLP query takes as input a workflow trace (T) defined as: T = integration process and does not focus on the querying aspect.
 5) OPMP ROV reconstructs provenance graph from the results obtained from executing an SQL query. Without OPMP [23] with the following additional contributions: 1 We introduce five new mapping functions i : e :; O ^ u ; enable users to retrieve causal dependencies between nodes using our mphOPQL language. a new Section 3.4. This provides a formal foundation for OPQL . 3 We present the architecture of our OPMP ROV system in the context of the scientific workflow management system. expressiveness of OPQL in Section 3.5. These queries expressed in OPQL are executable in the OPMP In addition, we implement user-friendly GUIs, such as OPMP the OPQL Web service. This expands applicability of OPQL . 8. Conclusions and future work OPQL provenance querying, and the experimental results showed reasonable performance.
In the future we plan to continue our research with OPMP ROV modify artifacts, as well as history of reads, writes and modifications. user perspective is needed in the future.
 Acknowledgments The authors would like to thank Dr. Murali Mani [27,34] for providing valuable advices regarding OPMP expertise in the area of provenance management.
 Appendix A. Database schema the remaining five are non-materialized views.

References
