 Wireless data broadcast is an efficient and scalable means to pro-vide information access for a large population of clients in mo-bile environments. With Location-Based Services (LBSs) deployed upon a broadcast channel, mobile clients can collect data from the channel to answer their location-dependent spatial queries (LD-SQs). Since the results of LDSQs would become invalid when mo-bile client moves to new locations, the knowledge of valid scopes for LDSQ results is necessary to assist clients to determine if their previous LDSQ results can be reused after they moved. This effec-tively improves query response time and client energy consump-tion. In this paper, we devise efficient algorithms to determine valid scopes for various LDSQs including range, window and near-est neighbor queries along with LDSQ processing over a broadcast channel. We conduct an extensive set of experiments to evaluate the performance of our proposed algorithms. While the proposed valid scope algorithm incurs only little extra processing overhead, un-necessary LDSQ reevaluation is significantly eliminated, thus pro-viding faster query response and saving client energy.
 H.3.3 [ Information Search and Retrieval ]: Search process; H.2.8 [ Data Applications ]: Spatial databases and GIS Algorithms, Performance Location-Dependent Spatial Query, Valid Scope, Data Broadcast
With rapid technological advancement of portable devices, po-sitioning equipments and wireless communications, the vision of mobile and pervasive computing is getting closer to a reality. As one of the killer applications in mobile and pervasive environments, Location-Based Service (LBS) provides information to the users at the right time, right place . Typically, location-related information and requests for these information are expressed as spatial objects and location-dependent spatial queries (LDSQs), respectively. Ex-ample LDSQs issued by mobile clients include  X  X here are ATMs within 1 mile from my current position? X  and  X  X here is the near-est gas station with respect to my position? X . While the number of LBS users increases, services based on point-to-point wireless communication degrade due to contention for fixed bandwidth and overload in server processing. In addition, submitting queries over an uplink channel to the server is very energy consuming to battery-powered mobile clients. Thus, wireless data broadcast (or simply broadcast ), owing to its ability to deliver information to a large number of clients at the same time with a fixed cost, is recom-mended for a large-scale system. This not only improves the system scalability but also saves client energy for uplink communication. Figure 1 shows a general system model where a LBS server broad-casts data via a base station to mobile clients. In this model, indi-vidual clients only need to collect interested data over the broadcast channel to answer their LDSQs locally.

The result of a LDSQ is subject to the client location where the query is issued. A query, e.g.,  X  X here is the nearest gas station? X , issued at different positions would receive different results. Those clients who are interested in keeping track of updated LDSQ results while moving will need to repeatedly evaluate queries to ensure the correctness of LDSQ results. However, staying active to reevaluate LDSQs certainly consumes a lot of precious client energy.
In fact, the results of LDSQs with respect to similar positions are most likely to remain the same. For instance, as shown in Fig-ure 2(a), a range query issued at two query points q and q cover exactly the same result (i.e., spatial objects c and d ). Therefore, reevaluating the same query can be avoided to save expensive query execution costs. To alleviate the reevaluation, a valid scope that represents a geographical area can be derived and associated with a query result. Inside the valid scope, the associated result is guar-anteed to be identical for the corresponding query. Thus, a client inside a valid scope can simply reuse the result for the query, and perform query reevaluation only when it moves out of the valid scope. To represent a valid scope, it is straightforward to download and label all objects as result objects and non-result objects .How-ever, downloading all objects from a broadcast is very time and en-ergy consuming. Instead, we determine a small and representative subset of non-result objects that called  X  complementary objects  X  X o-gether with result objects to represent a valid scope 1 . Referring to our example, the valid scope of a LDSQ result is formed as shown in Figure 2(b) by two result objects, i.e., c and d and one comple-mentary objects, a . Now, the client with the LDSQ result and a few complementary objects can determine if the result can be reused.
Although algorithms to determine valid scope have been recently proposed, they are not practical at all to the broadcast environ-ments. Some of them are designed for disk-based spatial indices (e.g., R-tree [4]). They need to determine a valid scope after a corresponding LDSQ result is found and incur multiple probing queries to determine the valid scope. Meanwhile, other approaches designed for broadcast do not support multiple types of LDSQs. Motivated by the importance of valid scopes to LDSQs and the needs of efficient algorithms in broadcast environments, we, in this paper, develop efficient valid scope computation algorithms for var-ious LDSQs over a broadcast channel. As opposed to existing al-gorithms, the proposed algorithms can determine LDSQ result and its valid scope simultaneously, thus shortening the response time. Besides, they can effectively collect required data by only tuning a small portion of a broadcast cycle, thus saving precious client energy. Besides, our valid scope computation algorithms support common LDSQs upon a generic broadcast scheme. We conduct an extensive set of experiments to validate the usefulness of valid scopes in reducing the cost of LDSQs and to measure the process-ing overhead incurred by our proposed algorithms. In summary, we make the following important contributions. 1. We explore the concept of valid scope for LDSQs in a mobile 2. We transform the valid scope determination problem into an 3. We devise valid scope determination algorithms for com-4. We implement our proposed algorithms and conduct exper-
The remainder of the paper is organized as follows. Section 2 reviews the existing works in result validity and data broadcast. Section 3 and Section 4 present the valid scope determination algo-rithms for range and window queries, and nearest neighbor queries, respectively. Section 5 describes the experiment settings and the re-sults. Section 6 concludes this paper and states our future plan.
Here, we only need the spatial coordinates of result and comple-mentary objects to formulate the valid scope for a LDSQ result.
Prior to the discussion of our proposed algorithms, we first re-view existing works in LDSQ result validation. Then, we discuss the properties of broadcast environments and search algorithms to support LDSQ over a broadcast channel.
If mobile clients can assert that the result of a previous LDSQ retains valid, unnecessary query reevaluation can be avoided. To equip mobile clients with such a capability, a number of related research works are studied and reported in the literatures. Dar et al. [2] maintains window query results as semantic regions. Any window query fully covered by existing semantic regions is guar-anteed to be answered by the client itself. Specific for NN query, Zheng et al. [14] associates each NN result with a precalculated Voronoi cell [1] (see Figure 3(a)). The result is asserted to be valid if the client (i.e., the query point) is inside the correspond-ing cell. For k NN query, Song et al. [8] extends the search for m ( m&gt;k ) NN objects with respect to the same query point q . Due to triangular inequality, a client can determine if k NN is con-tained by the m NN result if the distance it moved from q is less than ( dist ( kNN )  X  dist ( mN N )) / 2 , i.e., the half distance differ-ence between k -th NN and m -th NN with respect to q .However, this is not effective to reduce query reevaluation. For example, in Figure 3(b), 2 NN is executed as 4 NN and d is the distance between 2 -nd NN and 4 -th NN with respect to q . A new query point q (see Figure 3(b)) is located more than d/ 2 far away from q , and hence needs reevaluation. In fact, the 4NN result evaluated at q still cov-ers 2NN objects according to q , indicating that this conservative estimation cannot completely avoid unnecessary queries. Zhang et al. [13] derives algorithms to determine valid scopes. Their algorithm involves two steps. The first step determines the LDSQ result and the second step determines the valid scope that is initialized as the entire object space and keeps refining until client movement inside the area is certainly not violating the result va-lidity. More specifically, the second step involves a number of time parameterized (TP) queries [9] to simulate all possible client move-ment paths. Figure 3(c) shows the valid scope refinement for an NN query result. TPNN queries are issued towards all the vertices of the area to probe non-result objects that influences the query result validity (i.e., complementary objects, in our terminology). If non-result objects are found before TPNN reaches the target vertices, the valid scope is trimmed along a bisector formed between the NN result object and the closest non-result object. Otherwise (i.e., no non-result object is found), the query result is considered to be valid up to the vertices. Figure 3(d) shows the valid scope determination for a window query result. TPWINDOW queries are initiated from a query point q towards all vertices of the region. Then, the valid scope is refined by cutting off the portion that touches any non-result objects. Again, TPWINDOW queries are repeatedly issued until no non-result objects can be probed. As reported in [13], these probing-based algorithms that repeatedly access R-tree index result in a large number of disk accesses or they need a plenty of mem-ory cache to buffer accessed nodes. Also they are not suitable to the broadcast environments since they have to determine the result set first and they involve multiple (index/data) scans to find out all non-result objects that influence the result set.
Broadcast is a useful technique to disseminate information to a large number of mobile clients over a bandwidth-limited wireless channel. In a push-based model as shown in Figure 1, the server periodically deliver information over a dedicated broadcast channel through a base station. Mobile clients retrieve data on air accord-ing to their interests. The broadcast system delivers data objects in sequence. One data object is available per time slot. This deliv-ery order of objects is programmed by the server. Over a broad-cast channel, objects can be delivered multiple times. A broad-cast cycle refers to a period of time that a set of objects has been broadcast once. To save energy in broadcast tuning, clients may switch to energy-saving mode during the period that no interested data objects are being broadcast. In general, access methods over a broadcast are optimized for two commonly used metrics, namely,
Efficient spatial query processing upon a broadcast channel is a challenge since data are sequentially delivered on a time-shared broadcast channel. Clients staying blindly tuned to a wireless chan-nel for requested objects is certainly not an energy efficient ap-proach. Air indexing is often used for conserving mobile client en-ergy by interleaving indexing information (that includes the index attributes and the delivery time of data objects) with data objects on the broadcast channel [5]. Through looking up an index, mobile clients identify the arrival time of their desired data. Then, they switch to doze mode to skip listening to unwanted data and wake up to scan those interested data when they are about to arrive.
Some air-index structures have been proposed to support LDSQ processing in the broadcast environments. For example, D-tree [12] and grid-index [16] provide efficient access to the nearest object. They both utilize the concept of Voronoi cell to support NN search. D-tree is a paged binary search tree to index a given solution space partitioned into Voronoi cells and grid index is to partition the search space into smaller sub-regions and only broadcast those objects with their Voronoi cells overlapped with sub-regions in order to reduce the query evaluation cost.

However, data delivered over a broadcast channel is open to dif-ferent clients and ideally it should be able to support various LD-SQs. Consequently, HCI [15] and DSI [6] have been proposed to provide generic indices for various LDSQs. Both of them use Hilbert curve (HC) [3], a space filling curve, to serialize the spatial objects in a 2D or 3D geographical space on a time shared broadcast channel. Following HC order, spatially nearby objects are likely to be placed in close locations in the broadcast schedule, thus facil-itating spatial search. HCI uses B + -tree based index that restricts the search to start upon the root of the index tree. DSI uses expo-nential index [11] and fully distributes and replicates search paths intermixed with spatial objects throughout the broadcast. This ef-fectively shortens the initial root-probing time. In [6], DSI is shown significantly outperforming HCI in terms of both access latency and tuning time since DSI shortens root-probing time and has index in-formation distributed.

Figure 4 shows an example of DSI broadcast structure. In Fig-ure 4(a), an 8  X  8 geographical space is serialized into an Hilbert curve. The spatial coordinate of every object is mapped to one HC value. An object O 6 is mapped to an HC value, 6 .Weuse O represent an object at HC coordinate x . Objects are then broadcast in a non-decreasing order of HC values in each broadcast cycle. Figure 4(b) shows the corresponding DSI structure consisting of 8 spatial objects. An index table is delivered with objects for each time unit called frame . Each table maintains log r ( N ) pointing to the next r 0 th, r 1 th, r 2 th,  X  X  X  objects where r is the ex-ponential base and N is the number of objects. In this example, we consider one object delivered in one frame. We use f x to denote a frame that contains O x . So, there are 8 objects and 8 index tables. Assume r =2 and N =8 . We show two index tables in frames f and f 32 that contain O 6 and O 32 , respectively for brevity.
Suppose that a client who looks for object O 40 tunes into the channel right before the broadcast of f 6 . Based on the associated index table, the client follows the 3 -rd pointer to f 32 served to be the closest to and before the target O 40 .As f received, the client follows the 1 -st pointer to access f hind f 32 and contains the target object O 40 . When the object is downloaded, it terminates the search. Other spatial searches re-quire transforming spatial coordinates of requested objects into HC values and tracing the broadcast as described. In Figure 4(a), for instance, a window query with a window, W , is translated to a se-quence of HC values, { 50 ,  X  X  X  55 } . An NN query with a query point at HC value, 28 . Suppose that an NN search starts when is broadcast. Based on an received index table, O 27 is tentatively found the closest to the query point. The search space as a circle for the NN query is adjusted to cover three HC value sequences, namely, { 27 ,  X  X  X  29 } , { 31 } and { 35 } . The search finishes when no other objects are found inside the search space and the result is
O 27 . While our valid scope determination algorithms to be dis-cussed next can be applied upon different broadcast schemes, we assume DSI as our underlying broadcast structure for its efficiency in supporting LDSQs.
Range and window queries find objects within specified query ranges or windows, respectively. Although the shapes of search ar-eas are different, the natures of searches are pretty much the same. In the following, we generalize the problem of valid scope formu-lation for range or window queries, and then we discuss specific valid scope determination algorithms for range queries that have query regions set to circular ranges and window queries that have query regions set to rectangular areas. Let S p be the query region of an LDSQ Q p at a position, p . Given a query, Q p , R p and N p are result set and non-result set, respectively. Every object in R p is covered by S p whereas all ob-jects in N p are not. Both R p and N p constitute an entire object set, O , hence, N p = O  X  R p . Corresponding to S p , all objects in R should have Minkowski regions denoted by  X  S ( o ) ( o  X  ing p , i.e.,  X  o  X  R p p  X   X  S ( o ) , and no non-result object o in N its Minkowski region,  X  S ( o ) , enclosing p , i.e.,  X  o
Specifically, the valid scope, denoted by V ( p ) , which represents an area where R p retains valid, can be computed as an area equal to the intersection of the Minkowski regions of all result objects (i.e., where all results objects are still included) minus those of non-result objects (that implies no additional non-result objects become involved), as stated in Equation (1).
 According to Equation (1), the evaluation of any query Q p p  X  V ( p ) can be ignored since R p is the same as R p .
 Now the issue is how to enable the checking of whether p  X  V ( p ) at the client side. One straightforward approach is to pass V ( p ) to the client. However, as V ( p ) is most likely to be irregu-lar (like the shaded region shown in Figure 2(b)), it is infeasible to represent V ( p ) with vertices and it is also very hard for the client to determine whether a new query point p is inside V ( p ) ternative approach is to enable the client to derive V ( p the client R p and N p (i.e., the entire object set O ), which again incurs expensive overhead at client side. Consequently, we pro-pose a different approach in this paper. According to the fact that A  X  B  X  A  X  ( A  X  B ) (where A and B are sets), those faraway non-result objects o with  X  S ( o )  X  discarded as their Minkowski regions have ZERO impact on the formation of the valid scope. Thus, we introduce a set of com-plementary objects C p , i.e., a small and representative subset of non-result objects ( C p  X  N p ) in place of N p to derive the valid scope. The formulation of a valid scope is revised and stated in Equation (2).
 In Equation (2), the set of complementary objects C p are those ob-jects whose Minkowski regions overlap with those of result objects, i.e., { o | o  X  N p  X   X  S ( o )  X 
With the R p and C p available at the client side, the client can decide whether a new point p is within V ( p ) via checking whether it stays inside all the Minkowski regions of result objects and out-side those of complementary objects. As such, the validation pro-cess is much simplified and complicated valid scope representa-tion based on polygon is prevented. Algorithm RegionQueryValidi-tyCheck , as outlined in Figure 5, is devised to handle validity check (i.e., whether p  X  V ( p ) ).

Then, what remains unsolved is how to determine C p . It is intu-itive that the derivation of C p needs result set R p to be computed first. By doing so, the search for R p and C p are performed in two separate steps that takes at least two broadcast cycles. This cer-tainly prolongs the access latency especially when the broadcast cycle is long. To improve the search performance, we propose one-step approach that searches for both R p and C p at the same time. It can effectively shortens the query response time. While the con-cept for valid scope determination is the same for range and win-dow queries, the techniques for them are specific. In the next two subsections, we detail the algorithms to process queries and form valid scope in an integrated fashion, for range query and window query respectively.

The query region for a range query is a circle, i.e., S p with p and r representing the center query point (i.e., the current user position) and the radius of the circle, respectively. To an-swer a range query, a mobile client collects objects located inside cir ( p, r ) from the broadcast as the result set R p . Besides, we de-rive the search space for complementary objects, denoted as DS , and fine-tune it on the fly during the processing of the range query. Thus, objects inside cir ( q, r ) are result objects, and those outside cir ( q, r ) but inside DS are complementary objects. The rest of the objects that are outside DS are skipped from downloading.
For a given range query with r as the radius, the Minkowski region of a result object o is a circle cir ( o, r ) . Thus, it is obvious that the search space for the complementary objects corresponding to o is cir ( o, 2 r ) according to Lemma 1. Initially (i.e., before any result object is found), the range of DS is maximized to cir to fully cover all possible complementary objects, as suggested by Lemma 2. Thereafter, whenever a new result object o is detected, DS will be refined to a smaller range, i.e., DS  X  DS  X  cir
L EMMA 1. Given a result object, o , the search space for com-plementary objects with respect to o is cir ( o, 2 r ) Proof . Those complementary objects o that can affect the valid scope should have Minkowki regions intersecting that of result ob-jects o , i.e., cir ( o, r )  X  cir ( o ,r ) =  X  .Inotherwords, o should be no more than 2 r away from o . Thus, the search space for comple-mentary objects is cir ( o, 2 r ) with respect to o .

L EMMA 2. Given a range query with circular query region, cir ( p, r ) , the maximum search space for all complementary ob-jects, DS , equals cir ( p, 3 r ) Proof . Based on Lemma 1, a complementary object should be at most 2 r away from any result object if there is any overlap. In addition, the result object can be at most r away from the query point p . Hence, the possible maximum distance (search space) of complementary objects with respect to p is 3 r ( cir ( p,
Based on cir ( q, r ) and the formation of DS , Algorithm Integrat-edRangeSearch that searches both result set and complementary objects within one broadcast cycle scan is developed. Its pseudo-code is outlined in Figure 7. We use DSI (refer to Section 2.3) as the underlying broadcast program. DSI partitions the broadcast cy-cle into frames, with each frame f containing both a set of objects (c) DS = cir ( c, 2 r )  X  cir ( d, 2 r ) O f andanindextable I f . Upon receiving a frame f , our algorithm examines both O f and I f together. It is straightforward to adopt our algorithm for other broadcast schemes that may separate index and data in different frames, e.g., ( 1 ,m ) scheme [5]. The algorithm accepts a query point ( p ) and a query range ( r ). It maintains a search space, DS , for complementary objects that is initialized to cir ( p, 3 r ) . Both a result set R and a set of com-plementary objects C are initially empty. After an initial broadcast probe (line 3), the algorithm accesses frames that contain objects and index tables from a broadcast channel. It examines downloaded objects (lines 6-13) and performs different tasks based on the loca-tion of o . (1) If an object o is located within cir ( p, r R and DS is refined accordingly. Some of previously collected objects in C and previously scheduled frames for complementary objects would be filtered out with the revised DS .(2)If o is outside cir ( p, r ) but inside DS , it is put to C . Next, the algorithm exam-ines every index table entries for upcoming frames that may contain interested objects (lines 14-17). Based on both cir ( q, r the delivery times of frames are used to schedule the doze time of the mobile client. When no other objects are needed to access, the search terminates and delivers both R and C (line 16).

To illustrate how the algorithm works, let us consider a running example as shown in Figure 6. Assume that the system broadcasts objects from a through h . Initially DS is set to cir ( q, shown in Figure 6(a)), a and b are first examined and tentatively collected as candidates for complementary objects as they are in DS . Then, c , one of result set objects, is examined (as shown in Figure 6(b)) and DS is shrunk to cir ( c, 2 r ) . Also, the previously collected candidate b , outside the revised DS , is dropped. Next, when d , another result object, is examined, DS is further shrunk to cir ( c, 2 r )  X  cir ( d, 2 r ) (as shown in Figure 6(c)). Since no other objects are inside cir ( q, r ) , R and DS are finalized. The search for C ends since no unvisited object is inside DS . The shaded area in Figure 6(d) is the valid scope according to Equation (2).
Clearly, the tuning performance depends on when the search starts on the broadcast channel. Revisit Figure 6. If the client starts the search when e is being broadcast (i.e., the client does not know c and d ), the client has to collect e , f , g ,(skip h )andthen a , due to an initially large DS ( = cir ( q, 3 r ) . Notice that cir 9 times larger than cir ( q, r ) in terms of coverage area, it seriously incurs a long tuning time. To alleviate this, we suggest to defer the search until at least one result object ,say o , is located. In this case, DS is initialized to cir ( o, 2 r ) with its coverage area less than half of that of cir ( q, 3 r ) . This suggestion trades access latency for tuning time of valid scope determination. Notice that this does not affect much the response time for getting the query result. To eval-uate the effectiveness of this suggestion, we conduct experiments and discuss the results in Section 5.
The query region for window query is a rectangular window specified as rect ( p, 2 l, 2 h ) where l and h are extents from a query point, p ,in x -and y -dimension, respectively. Since the same ba-sic concept for range query still applies, we briefly point out the maximum/initial search space for complementary objects, and how the search space is adjusted based upon collected result objects in Lemma 3 and Lemma 4, as well as exemplify the search.

L EMMA 3. Given a window query issued at p with a query win-dow, rect ( p, 2 l, 2 h ) , the maximum search space for complemen-tary objects is rect ( p, 6 l, 6 h ) .
 Proof .For x -dimension, an object o in the result set should be at most l away from p while complementary objects cannot exceed 2 l from o . The search space is 3 l for one side, 6 l for both sides. Similarly, the bound for y -dimension is 3 h for one side and both sides.

L EMMA 4. Given a result object o , the search space for com-plementary objects is rect ( o, 4 l, 4 h ) Proof . As this is similar to Lemma 1, we omit it to save space.
We illustrate the idea of search for complementary objects with an example shown in Figure 8. Assume a window query is issued at q with rect ( q, 2 x, 2 y ) as its query window and the broadcast or-der of objects is from  X  a  X  through  X  h  X . At the first place, the search space, DS , for complementary objects is set to rect ( q, shown in Figure 8(a). Then, objects a and b are collected by the client. When object c is examined, DS is shrunken to rect b is discarded and a remains as shown in Figure 8(b). When d is ac-cessed, DS is further shrunken to the intersection of rect and rect ( d, 4 x, 4 y ) as shown in Figure 8(c). Now a is dropped. There are no other objects falling inside DS and rect ( q, and the search finishes. The valid scope formulated based on Equa-tion (2) marked as a shaded area is shown in Figure 8(d).
Again, the tuning performance could vary a lot if the search starts at an inappropriate position in the broadcast. We can defer the search for complementary objects until at least one result set object is retrieved to initialize a smaller search space for comple-mentary objects, thereby shortening the tuning time at the expense of prolonged access latency. We evaluate this in Section 5.
So far, we have considered the search space for complementary objects purely based on result objects. In fact, the search space can be further reduced if complementary objects are taken into consideration. Let us study an example as shown in Figure 9(a) where the query range is cir ( q, r ) and o is the only result ob-ject. Based on o , DS is cir ( o, 2 r ) . Then, both o and o are col-lected as complementary objects. In fact, query result validity becomes redundant. We call objects like o as false candidates. Skipping false candidates could save tuning costs. In what follows, we introduce an additional filter, FS , to identify false candidates retrieved based on DS .
For brevity, we first outline how a FS is defined for range query, based on the example shown in Figure 9(a). Based on geometri-cal property, any object falling inside the white area (denoted as fs ( o, o ) in Figure 9(b)) is a false candidate as its impact on the valid scope has been covered by that of o , i.e., o  X  fs ( ( cir ( o, r )  X  ( cir ( o ,r )  X  cur ( o ,r ))) = ( cir ( o, r As a result, the search space for complementary object can be fur-ther reduced to DS  X  fs ( o, o ) . The detailed derivation of fs is expressed in Equation (3). Points p 0 and p 1 are the intersection points of cir ( o, r ) and cir ( o ,r ) . We further extend the segments op 0 and op 1 to op 0 p 0 and op 1 p 1 , with points p 0 and p along the circumference of cir ( o, 2 r ) . fs ( o, o )= sect ( cir ( o, 2 r ) ,  X  p 0 op 1 )  X  In the equation, the first term represents a sector of circle cir with angle at o between p 0 and p 1 ; the second and third terms stand for sectors (i.e., semicircles) centering at p 0 and p 1 with radius r . Given a result set and a set of complementary objects, the revised search space should be DS  X  FS , i.e.,
Based on the same idea, the search space for complementary ob-jects for window query can also be further reduced. To save space, we illustrate the idea in Figure 10. While a complementary ob-ject o is considered, fs ( o, o ) is defined as the region behind o with respect to a result object o . Another object o staying inside fs ( o, o ) can be safely ignored.
Having demonstrated that the search space for complementary object can be further refined theoretically, we, however, find the improvement introduced by the filter space FS is rather limited, in terms of both tuning time and access latency performance. The rea-sons behind are three folded: (1) FS is very small, compared with DS ; (2) objects are clustered in the broadcast channel so it is likely to have objects, for instance, o and o , retrieved in the same frame; and (3) the object retrieval order affects the derivation of FS (say if o is retrieved before o , both o and o are eventually down-loaded). As a result, we discuss the feasibility of possible search space reduction by taking the retrieved complementary objects into consideration. In our later evaluation, we use the previously dis-cussed approach based on DS only.
Nearest Neighbor (NN) query finds an object in a dataset the closest to the current user position. k NN ( k&gt; 1 ) query is an ex-tension of NN query to search for k nearest objects with respect to a query point. In this section, we explain how to derive valid scopes for NN/ k NN query result on a broadcast channel.
While an object o , the nearest to a query point, p , is put into the result set, R p , all other objects are non-result objects. It is well-known that the Voronoi cell of object o , denoted by Vor is the valid scope of corresponding NN query result, i.e., V Vor ( o ) . Object o is guaranteed to be the nearest neighbor to any point inside Vor ( o ) . The formation of a Voronoi cell is based on half-planes. Given two objects o and o , two half-planes, HP and HP  X  o,o ( o ) are formed sharing a bisector  X  o,o between o and o 2 . Then, Vor ( o ) (= o  X  N p HP  X  o,o ( o ) ) is an intersection of all the half-planes of o formed against all the non-result objects.
Obviously, examining all non-result objects to determine their half-planes and to derive the Voronoi cell of an NN object is not practical. In fact, only those non-result objects that contribute the bisector as the Voronoi cell perimeter are needed. We call those objectsasasetof complementary objects , denoted by C p . Thus, the valid scope for an NN query result R p = { o } is formed as that have fixed search regions, the search space of complementary objects is highly dependent on object distribution around the NN query result object. Thus, the main challenge of determining valid scope for NN query is how to determine a search space for C
In this study, we exploit one important Voronoi cell property to derive the search space for C p , namely, largest empty circle . In Vor ( o ) , every vertex has its largest empty circle covering the object, o , inside the cell and at least two objects outside the cell. Specifically, a vertex, v , an intersection of two bisectors,  X  o,o , of a Voronoi cell should be equidistant to all o , o and o . We denote the largest empty circle centering at v by cir ( where the radius is | v, o | 3 . This is illustrated in Figure 11(a). The shaded area represents a part of the Voronoi cell of an object o , and point v is one of the vertices of Vor ( o ) . In addition, each object o that contributes one edge of Vor ( o ) must be touched by two largest empty circles, centered at the two endpoints of the edge contributed by o itself respectively. If a vertex v is valid (i.e., be-longing to Vor ( o ) ), its corresponding circle cir ( v, empty. Otherwise, there should exist another object that stays in-side the corresponding circle and that is close to o . As such, the union of all the largest empty circles cir ( v, | v, o | ) tices v forms the search space of complementary objects. Since only objects inside a circle cir ( v, | v, o | ) will impact its validity, objects outside all those largest empty circles can be safely skipped from downloading.

The determination of NN query result and the valid scope for the result takes two steps. The first one is to retrieve the nearest object, based on which a tentative valid scope, i.e., a composition of largest empty circles that covers an entire space, is formed. Thereafter, the second step is to refine the valid scope. Since the process to retrieve NN object is already supported by DSI as discussed in Section 2.3, we only discuss the determination of the valid scope (i.e., Voronoi cell). Initially, search space DS is set as the union of all the largest empty circles cir ( v, | v, o | ) formed by all the vertices v . Every time when an object o is found inside the circle cir ( v, | v, o with a vertex v , v becomes invalid. A bisector between the newly detected object o and NN object o is formed, which will cut the original edges (that contains vertex v ) at two new vertices. Then, both valid scope and complementary objects are revised.
Object o is closer to points falling inside half-plane HP than o is, while o is closer to points falling inside half-plane We use | a, b | to denote the distance between points a and b .
We illustrate the search process in Figure 11(b). Suppose ob-ject a is the NN answer object and some collected complemen-tary objects b , c , d ,and e form a tentative valid scope. The four corresponding largest empty circles, centered at vertices v v ,and v 3 , bound an initial search space for complementary ob-jects. Now, object f is found inside both circles cir ( v Vonoroi cell. The bisector  X  a,f produces two new vertices, by cut-ting the edge v 2 v 1 and edge v 0 v 3 , to replace invalid vertices v v . The result is shown in Figure 11(c). Next, vertex v 1 becomes invalid when object g is found. The new bisector  X  a,g forms two new vertices by cutting the edge v 2 v 1 and edge v 1 v 0 tex v 1 . It is important to point out the difference between the cuts made by f and g . For the case of f , both vertex v 0 and v invalid, and hence the non-result object d (that contributes the two vertices v 0 and v 1 ) is discarded. For g , although vertex v validated, neither object b nor object f is discarded since they still contribute to other vertices (i.e., vertex v 2 by object b and vertex v by object f ). The search for complementary objects ends when all unvisited objects (e.g. h ) are found to be out of the search space. We develop Algorithm IntegreatedNNSearch to determine the NN query result and complementary objects that form the valid scope in Figure 12. The algorithm first locates the NN object (or its position indicated by the index) as nn and collects some other ob-ject locations (line 1) as complementary objects stored in C . Then, a tentative Voronoi cell of the NN object is formed. Besides, C and the search space, DS , are initialized to empty sets and entire space, respectively (lines 2-3). Then a sequence of frames, f ,are examined to see whether any object in O f or indicated by I covered by DS (line 5-11). If so, both C and DS are revised based on above descriptions. Further, based on I f , the algorithm searches other complementary objects inside DS and schedules to download the corresponding frames (lines 12-14). It terminates and delivers both nn and C when no unvisited objects are within DS .

Based on nn and a set of complementary objects, C , the validity of NN query result at a query point, q , can be determined. We de-vise Algorithm NNQueryValidityCheck and outline it in Figure 13. The basic idea is to check if any complementary object is found to be closer than nn to q . k NN query is an extension of NN query. It can be classified as order-sensitive and order-insensitive . The former concerns the distance order of result k NN objects. The objects in the result set are sorted based on their distance to the query point, and result set { a, b } is considered to be different from the set { b, a }. The latter does not care about the distance order. As long as the same set of objects are included in the result set, the result is treated the same. Our following discussion starts with valid scope determination for order-insensitive k NN query followed by the discussion of the nec-essary extension for order-sensitive k NN query.
 Valid Scope for Order-Insensitive k NN Query . The valid scope for an order-insensitive k NN query is an order-k Voronoi cell [1]. Suppose k objects nn 1 ,  X  X  X  nn k are the result set, R p query evaluated at a query point p and the rest belongs to non-result objects, N p ( = O  X  R p ). Each NN object nn i has its own valid scope formed as Vor ( nn i )= o  X  C i HP  X  nn C i  X  N p ), outside which object nn i is no longer the nearest to p . The order-k Voronoi cell, i.e., V ( p ) , is formed as the inter-section of all Vor ( nn i ) , i.e., nn i  X  R p Vor ( nn i shows a scenario in which a 2 NN query is issued at query point, q , and objects a and b form the result set. The shaded area repre-sents the valid scope of the result set, constituted by a  X  X  and b  X  X  own valid scopes. To determine the valid scope for k NN query result on the broadcast, we simply extend our proposed algorithm support-ing NN query. Initially, k NN objects need to be identified as the result set. Next, for each individual NN object, nn i , we maintain DS i and C i ( 1  X  i  X  k ). The rest of the logic is the similar to that already discussed. The final valid scope is the intersection of individual NN scopes. Similar to NN query, the validity check for k NN query is to check if any complementary object appears closer to a query point than any existing result object. Valid Scope for Order-Insensitive k NN Query .Order-sensitive k NN query concerns the order of result k NN objects. To facilitate the checking of order, we partition the valid scope of k NN query result by adding bisectors among k NN objects. As shown in Fig-ure 14(b), the bisector  X  a,b is introduced and it partitions the valid scope into two smaller portions. Within the valid scope, when the client moves from one divided portion to another, the result is con-sidered to be invalid due to the change of distance order. However, the client needs only to reorder the result objects.
In this section, we evaluate the effectiveness of using valid scope for reducing query reevaluation and the efficiency of our proposed valid scope determination algorithms in broadcast environments via simulation. In this evaluation, we focus on two essential perfor-mance metrics, i.e., access latency and tuning time ,asdefinedin Section 2.2. We use total number of bytes instead of number of packets to measure access latency and tuning time.
 We implemented our proposed algorithms and applied them upon DSI broadcast scheme [6] in CSIM18 [7]. In the simulation, a broadcast server is dedicated to broadcast spatial objects and all clients listen to the broadcast to retrieve the data according to their interests. Each broadcast frame contains 51 equal-sized objects of 512 bytes and an index table (with exponential base r =2 The broadcast program is continuously streamed and clients issue queries at different points of time. In the experiment, we simu-late one client as clients behave independently to each other and this client issues 100 queries in each run. The results presented in this section are averaged based on the 100 queries. We experiment three strategies, namely, (1) plain query processing (QP), (2) query processing with valid scope determination (QP+VS), and (3) query processing with deferred valid scope determination (QP+VS(D)). QP is the baseline that whenever a client moves to a new position, it reevaluates its queries. QP is expected to incur the least overhead for single query evaluation among the three strategies as it does not derive any valid scope. However, for continuous query evaluation, QP would involve redundant query reevaluation. Both QP+VS and QP+VS(D) integrate the query processing and valid scope forma-tion into a single step. Further, QP+VS(D) computes valid scope only after at least one result set object is retrieved to save the tun-ing time but this would prolong the access time for downloading complementary objects.

We used both synthetic dataset and real datasets in the evalu-ation. The synthetic datasets follow the uniform object distribu-tion with two object cardinalities, i.e., 10,000, and 100,000. Real datasets include all landscapes obtainable from Tiger/Line [10]. The objects are expressed as centroid of individual polygon land-scapes. Data of two states, namely, Rhode Island (RI) and Penn-sylvania (PA) of the United States are used in the experiments, with their cardinalities being 50k and 744k, respectively. The data spaces are normalized to [10,000,10,000]. We randomize the client locations (i.e., query points) and query parameters, say radius for range query (100, 500, 1000), side length for window query (100, 500, 1000) and k for NN query (1, 10, 30). Table 1 summarizes all the parameters and their settings. We discuss our evaluation in two parts below. The first part examines the benefits of maintaining a valid scope to reduce the total query evaluation costs. The second part studies overhead incurred by different strategies.
In the first part, we evaluate the cost saved by incorporating a valid scope into a query result, that allows clients to avoid un-necessary query evaluation. In the experiments, a client maintains no query result initially. Whenever it issues queries, it determines the corresponding valid scope based on QP+VS(D) that is used as our default valid scope determination strategy here. We model the client movement as a random walk. At each step, clients can ei-ther go up, down, left and right for 1 distance unit from its current position in the data space or stay at the same position with equal probabilities. In contrast to QP that the client reissues the same queries whenever it moves, valid scope enables it to reuse its pre-vious query result if it stays within the corresponding valid scope. The experiment results to be presented are obtained by averaging 100 queries issued by the client.

We first evaluate the cost saved by using valid scopes for range query. The results are shown in Figure 15. Generally speaking, when a larger range query is experimented, longer access time and tuning time for both QP and QP+VS(D) are observed. We can also observe that the savings narrow when query ranges increase. There are two reasons. Firstly, the larger query range enlarges search space for complementary objects that increases both access time and tuning time. Secondly, a large query range may cover result objects that are located far away from each other which actually leads to a small valid scope. In this case, a client would be more likely to move out of such small valid scopes and to invoke query evaluation often. In summary, for all the evaluated range query sizes and datasets, using valid scopes determined by QP+VS(D) provides shorter access time (i.e., response time) and shorter tun-ing time (i.e., energy consumption) than QP.
Next, we evaluate the cost saved by using valid scopes for win-dow query. The settings are basically the same as that for range query. The results are shown in Figure 16. The general observation made for range query is similar to that for this window query. We observe the QP+VS(D) would not save the overall cost at all, i.e., longer access time and tuning time than QP, when very large query windows are experimented. This happens due to the increased valid scope determination cost and the reduced size of valid scope.
Then, we study the cost saved by valid scope for order-insensitive k NN query. We have experimented various k values, i.e., 1, 10 and 30. The results are shown in Figure 17. We observe that the valid scope effectively reduces query evaluation cost because of both shortened access time and tuning time. However, as k is fur-ther increased (say 30 or more), keeping valid scope results in no savings due to small valid scope.

From this experiment set, we can see that in general, if the query sizes increase, the performance gain is reduced due to the shrunk sizes of valid scopes.
In the second part, we evaluate the performance valid scope com-putation strategies for range, window and k NN query. This set of experiments differs from the previous one as we do not reuse query results. We expect QP to be a baseline that incurs the least overhead and we measure how much additional overhead incurred by QP+VS and QP+VS(D) for valid scope computation, compared with QP. In each setting, 100 queries of same type are issued independently at different locations in the data space. The results to be presented are the average among these 100 queries.

We first experiment range query. We vary the radii of the query ranges from 100, up to 1,000. The results are plotted in Figure 18. We can observe that as larger dataset sizes and larger radii (i.e., query range sizes) are experimented, longer access time and tuning time for all strategies are resulted. Here, QP+VS incurs a slightly longer access time (average about 0% to 27% ) relative to QP. Even in some cases when small query ranges are experimented, the ac-cess times of both QP and QP+VS are almost the same. This in-dicates that the search for a result set and complementary objects ends almost at the same time. When the last result set object for a query is collected, the corresponding search space for comple-mentary objects is also shrunken to a certain extent such that only a few or even no unvisited complementary objects are to be found in the remaining broadcast cycle. On the other hand, when a larger query range is evaluated, the access time of QP+VS is considerably increased due to enlarged search space for complementary objects. In terms of tuning time, QP+VS, however, suffers the most ( to 278% to QP).
As anticipated, QP+VS(D) that defers the search for comple-mentary objects until at least one result set object is located is more tuning time saving than QP+VS. Its effectiveness in terms of the tuning time improvement ( 96% to 160% to QP) is evidenced by the simulation results as shown in the figure. However, it incurs the longest access time ( 43% to 104% to QP). It is noteworthy that despite the access time for complementary objects is different, the response time of result objects is identical for all the strategies.
Next, we evaluate window query with the same settings as that for range query. We vary the query window side length from 100, to 500, and to 1,000. The results are plotted in Figure 19. Again, we can observe that larger datasets and larger query windows eval-uated result in longer access time and tuning time for all the strate-gies. While QP is the base case, QP+VS incurs shorter access time ( 0% to 42% to QP) but longer tuning time ( 207% to 703% to QP) than QP+VS(D) whose access time and tuning time is respectively 43% to 121% ,and 47% to 135% to QP. Those observations can be explained with the previously discussed reasons.
Our third experiment studies the overhead incurred by valid scope determination of k NN query. In this experiment, we vary k among 1 , 10 and 30 . For each query, we determine k NN and then the valid scope, that is the QP+VS(D) strategy we presented in the two previous experiments. Recall that there are two variants of k NN query, namely order-sensitive and order-insensitive. Both of them perform exactly the same in broadcast reading in terms of ac-cess time and tuning time. To save space, we omit the result for order-sensitive k NN that only incurs additional post computational cost in determining bisectors among k NN. The results of (order-insensitive) k NN queries are shown in Figure 20. From the figure, similar resulted access time for different k on same dataset is ob-served. Since QP+VS(D) determines the valid scope after k NN are received, it definitely takes longer access time ( 72% to also longer tuning time ( 103% to 251% )thanQP.
This part shows that the cost of query processing combined valid scope computation is higher than plain query processing, but its cost can be amortized by subsequent queries for a long run as dis-cussed in the previous experiments. However, as pointed out in the first experiment set, large query sizes result in small valid scopes, leading to less effectiveness of valid scope in saving query reeval-uation cost. Currently, we investigate solutions and performing ex-tensional works to improve the performance for large query sizes.
Wireless data broadcast is a scalable approach to support large-scale LBSs. A mobile user, who wants to keep track of the up-to-date answer to an issued LDSQ has to keep monitoring the wire-less channel and continuously reevaluate the queries. As the results of the same LDSQ with similar location are most likely to remain the same, the reevaluation may not be necessary. This paper ad-dresses result validity check in mobile broadcast environments by associating each result with a valid scope, a geographical region inside which a query evaluated at any point provides an identical result. We derive a valid scope based on the result set and the com-plementary objects for common types of LDSQs, namely, range, window and NN ( k NN) queries, in this paper. The additional over-head incurred by valid scope computation is amortized by subse-quent queries. Additionally, we consider a deferred approach that postpones the valid scope computation until at least one result set object is located, to reduce the tuning time. These strategies are evaluated extensively through simulations and compared with plain query processing scheme that does not compute valid scope. In this research, Ken C. K. Lee and Wang-Chien Lee are supported in part by the National Science Foundation under Grant no. IIS-0328881 and IIS-0534343.
