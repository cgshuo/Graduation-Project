 The fundamental assumption for query rewriting in heterogeneous environments is that the mappings used for the rewriting are com-plete , i.e., every relation and attribute mentioned in the query is as-sociated, through mappings, to relations and attributes in the schema of the source that the query is rewritten. In reality, it is rarely the case that such complete sets of mappings exist between sources, and the presence of partial mappings is the norm rather than the ex-ception. So, practically, existing query answering algorithms fail to generate any rewriting in the majority of cases. The question is then whether we can somehow relax queries that cannot be rewritten as such (due to insufficient mappings), and whether we can identify the interesting query relaxations, given the mappings at hand.
In this paper, we propose a technique to compute query relax-ations of an input query that can be rewritten and evaluated in an environment of collaborating autonomous and heterogeneous data sources. We extend traditional techniques for query rewriting, and we propose both an exhaustive and an optimized heuristic algo-rithm to compute and evaluate these relaxations. Our technique works with input of any query similarity measure. The experimen-tal study proves the effectiveness and efficiency of our technique. H.2.5 [ Database Management ]: Heterogeneous Databases big heterogeneous data; approximate querying; query relaxation
In typical data exchange [9], integration [13], and sharing [24] settings, schema mappings (often in the form of Local-As-View (LAV) mappings [13]) are commonly used to alleviate the hetero-geneity across pairs of autonomous sources (or sets of sources in general). In the case of data exchange, such mappings are used for instance generation, i.e., to generate instances of a target schema based on those of the source schema. In data integration and shar-c  X  ing, the mappings are used during query evaluation, i.e., to trans-late or rewrite queries that are posed over a source schema to new queries that can be evaluated over the constructs (schemas and at-tributes) of a target schema.

Here, we focus on the query rewriting problem and on the tech-niques that have been developed to this end. Classical rewriting algorithms, like Inverse Rules [8], Bucket [15] and MiniCon [23] have already addressed some of the fundamental issues in this area, both in terms of computing complete or maximally-contained rewrit-ings (given an input query and a set of mappings), and in terms of doing so efficiently. Yet, a common assumption in all these algo-rithms is that the set of available mappings should provide at least one combination that fully rewrites the query. If this is not the case, that is, if the input query refers to a relation or to an attribute that does not participate in any of the input mappings, then the rewrit-ing fails (no output is produced). In what follows, we argue that in many practical settings, the mappings are inherently incomplete and that the assumption of existing algorithms is rather restrictive.
Consider a travel web-site iTravel.com offering services similar to the ones found in web-sites like Expedia or Travelocity. Like these web-sites, a user can go to iTravel.com and enter (a) the origin; (b) the destination; and (c) the dates of the vacation; and the system can generate candidate vacation packages that include the flight(s) and hotel room(s) for the duration of the vacation. Conceptually, one can think of this as a single query over iTravel.com database, as illustrated in Figure 1(a). The database includes three relations (with key attributes underlined in each). Relation VacPackage stores for each vacation package its id ( vacid ), the associated flight ( fno ) and hotel ( hid ), as well as the dates the package is available ( from and and closest airport ( served ), as well as the check-in and check-out dates ( chkin and chkout ) and room rate .

Consider a user looking for vacation packages between the 1 and 9 th of November, flying out of New York to the city of Hana, Hawaii. Figure 1(b) shows the equivalent SQL query over the schema of iTravel.com . The query joins the three relations on the (to ensure that the right flight and hotel are selected for the vaca-tion period). Notice that the flight and hotel relations are also joined (term F.dest = H.served ) to ensure that the flight lands into an airport that serves the hotel. Web-sites like iTravel.com usually act as bro-kers. They do not store the latest information for flight and hotel prices (or availability). Instead, they often access the airline and hotel databases (at query-time) to get the latest data. Figures 1(c) and (d) show three such databases along with their corresponding mappings to the iTravel.com schema (expressed as LAV mappings).
Notice that the user query in Figure 1(b) cannot be rewritten us-ing the above mappings. For one thing, there is no mapping for for vacation packages. Also, identifiers like vacid and hid are inter-nal to the iTravel.com database and cannot be mapped to any of the attributes of the individual sources. As well, the join on these iden-tifiers is also not covered by any combination of mappings. Any of the classical algorithms on query rewriting will fail to provide a rewriting. Yet, it is not hard to see that the individual sources pro-vide us with enough information to reconstruct vacation packages since the important attributes, like the dates, origin and destina-tion of flights, and the check-in and check-out dates of hotels, are present in the sources. Indeed, it is not hard to see that the follow-ing two queries can be computed by relaxing (removing the join with VacPackage ) the query in Figure 1(b):
The first query identifies flight/hotel combinations where the user gets to stay in a hotel, while in the second the user gets to stay in an inn. Given an input query and a set of mappings there are multiple possible relaxations and not all relaxations are equally good .  X  How can we efficiently compute the set of possible relaxations of an input query, given a set of mappings?  X  How can we examine the best query relaxations first?
Detailed contributions. In response to the above challenges, we propose a technique for approximate query answering in an envi-ronment of autonomous data sources. To the best of our knowledge, this is the first work towards this direction.  X  We build a new technique that performs query relaxation and ap-proximate rewriting of the originally posed query. This technique complements and reuses existing traditional query answering algo-rithms using LAV mappings.  X  The search space considered by the approximate rewriting tech-nique is represented such that: (i) it is smaller than the number of possible approximate rewritings (ii) it increases at a slow rate with respect to the query size, and (iii) it accepts heuristics.  X  An exhaustive algorithm is presented for approximate query rewrit-ing that searches the space in an efficient way, such that, the best possible approximations are considered first. It is proved that the algorithm is complete, i.e. it finds the optimal approximation. Fur-thermore, an optimized heuristic algorithm is proposed, that trades a much higher efficiency for a very low approximation error. The algorithms take as input a user-defined query similarity function.  X  The algorithms are enhanced with a preprocess that unifies LAV mappings in more generalized ones that can rewrite query parts which could not be rewritten otherwise.  X  The experimental evaluation proves the substantial efficiency and scalability of the proposed algorithms compared to a straightfor-ward solution that employs traditional query rewriting and their ef-fectiveness on the solution of the query relaxation and, in general, the approximate query answering problem.

We note here that the problem of defining the notion of query similarity and defining query similarity measures is orthogonal to the problem of finding approximate query versions with respect to such measures, and is out of the scope of this work. Query similarity and respective measures are investigated and proposed in [3, 6, 11, 12] and other works. The algorithms proposed here work with input of any similarity measure as a  X  X lack box X . In the rest of the paper, Section 2 summarizes related work and Section 3 gives an overview and introduces preliminary notions. Section 4 discusses the cases of query approximation and Section 5 describes the approximate query answering algorithms. Section 6 presents our experimental study and Section 7 concludes the paper.
Approximation in query answering has been extensively studied from several aspects. A big trend has been the effort to reduce re-sponse time by seeking approximate query answers. Some tech-niques compute approximate answers based on data summaries, statistics or histograms [22]. A noticeable work is [21], which dis-cusses summarization of XML data. The AQAX system [1, 25] aims to fast generation of approximate results, in order to improve efficiency. Towards the same end, the work in [7] introduces ap-proximate data exchange. The aim is to produce fast approximate answers and exact answers later. The motivation is on trees that are semi-consistent. For this kind of problems it offers a solution that relaxes in a restricted way the data request.

Another trend is query answering in inconsistent databases. The work in [10] is a solution that provides consistent query answers on inconsistent databases with respect to some integrity constraints. Many other works focus on query answering in incomplete databases. The work in [27] presents the QPIAD framework, which focuses on the retrieval of tuples that miss values on constrained attributes. Their approach is based on attribute correlations. The work in [20] deals with answering imprecise queries, with respect to the schema on which they are posed. The focus is on the retrieval of not only the precise answers, but also imprecise ones, with respect to some similarity of the imprecise answers to the precise query. The tech-nique reasons on the data and relaxes the query according to estima-tion of the similarity between values binding categorical attributes. In the same spirit, but focusing on vocabulary and semantics, the work in [4] deals with the problem of approximate query map-ping. The interest is on Boolean query constraints in heterogeneous sources and there is a discussion on closeness and its quantification with respect to precision and recall.

Furthermore, there is some interest on the problem of query re-laxation. The work in [5] studies the problem of approximation of Datalog queries with a union of conjunctive ones. It calls the simi-larity of approximations "easiness" or "goodness" and proposes the notion of upper and lower envelopes that characterize the contain-ment of a conjunctive query in a Datalog one. The work in [19] focuses on queries that failed to get an answer and discusses the notion of similar queries. It proposes a query relaxation method for producing query versions that succeed in retrieving similar tuples. This approach is based on training the system beforehand on part of the data. The interest is on queries with conjunctions or disjunc-tions of atoms and the relaxation procedure is based on bayesian networks, targeting the approximation of domain knowledge.
In spite of the numerous works in approximate query answering, the problem of producing query approximations that can be rewrit-ten on autonomous and heterogeneous databases with respect to a set of mappings has not been tackled. Our work aims to an effi-cient and practical solution of this problem, that can be employed in several application settings of autonomous databases.
A classical query rewriting algorithm takes as input a query and a set of views, and outputs a rewritten query version (usually the maximally contained version [13]). If the available views are not adequate to form a combination that rewrites the query completely, then no output is produced. Our aim is to offer such a rewriting technique that outputs a rewritten query employing in the best way the available views, even if a complete rewriting is not possible.
This work presents a query rewriting technique that produces ap-proximate rewritings or equivalently, rewritings of approximations, of an originally posed query employing a set of Local-As-View (LAV [13, 14]) views, V . Hereafter we refer to the query input to the approximate rewriting algorithm as Q orig , to an approxima-tion of it as Q apprx and to a rewritten version of the approximation as Q apprx R . We are interested in SQL queries of the SPJ form (plus comparisons and value conditions), which can be written in conjunctive form. Whenever not clear from the context we note as Q
SQL and as Q conj the SQL and conjunctive form, respectively, of Q . Roughly, a user poses Q orig in the local database which should be approximated to Q apprx so that it can be rewritten as Q apprx R and answered on a remote database through a set of map-pings (in general, chain of mappings [17]).

We define the search space of possible approximations through the removal of distinct query parts. This is a smaller search space than the one that considers arbitrary approximate versions of a query. Furthermore, the size of the selected space not only increases slower than the size of the space of arbitrary approximations, but it also lends itself nicely to efficient pruning heuristics.

We develop an exhaustive algorithm that operates on this search space. The input of the algorithm is Q orig , a set of available views V and a query similarity function M sim , used as a black box. The latter is formed by the user and quantifies the quality of the possible approximate rewritings. Naturally, the exhaustive algorithm finds the optimal approximation with respect to the similarity function. Furthermore, we propose a heuristic that proves to prune the space efficiently, with a small trade of approximation error.

Users are assumed to express their queries and expect answers in SQL form, since it is more intuitive and user-friendly. Existing query rewriting algorithms, however, take as input queries and out-put rewritten versions of them in conjunctive form. A SQL query is considered to be a set of elements , one for each  X  X elect X  attribute and one for each  X  X here X  condition. The transformation of Q to Q conj orig is unique; moreover, the transformation of Q Q apprx R is unique with respect to the elements of Q SQL orig
A conjunctive query is of the form: Q ( X ) :  X  R 1 ( X 1 where Q and R i , i = 1 ,...,n are names of predicates (i.e. rela-tions) and X i , i = 1 ,...,n are tuples (i.e. each is an ordered set of attribute variables or constants). Q ( X ) is the head and  X  the body of the query. The R i s, i = 1 ,...,n are called the sub-goals of the query Q . The variables in X are called distinguished and the variables in R i s that do not appear in the query head are called existential . Conjunctive queries can have comparisons as subgoals; if R i ( X i ) is a comparison subgoal, any variables in X must also appear in X . A query is safe is all variables in X ap-pear in  X  i =1 ,...,n X i . A mapping or as called a homomorphism of a query Q ( X ) :  X  R 1 ( X 1 ) ...R n ( X n ) on a view V ( Y ) :  X  S ...S m ( Y m ) is the mapping of query predicates R 1 ,...,R view predicates S 1 ,...,S m and variables X,X 1 ,...,X n ables Y,Y 1 ,...,Y m .

The proposed approximate rewriting technique takes advantage of the existing literature on classical query rewriting using LAV views [8, 15, 16, 18, 23] in order to perform the actual rewriting. Specifically, when the algorithm finds an approximation, Q of the original query, which can be thoroughly rewritten using the set of views in hand V , it rewrites it to Q apprx R in the classical manner. Figure 2 is a coarse summary of the technique. Classi-cal query rewriting algorithms [8, 15, 16, 18, 23] rewrite the query to a query in which the subgoals are no more R i s, but the head of views V i  X  V or they are new comparison subgoals. In general, the algorithms start from mapping some of the head variables X of Q on some of the head variables Y of V , and proceed by mapping a subset of subgoals R i s to a subset of subgoals S i s progressively, such that the whole query body is finally mapped on (or as said cov-ered by ) one or more views. If there are subgoals that are covered by more than one views, then the check for query containment is performed in order to see if the rewritten query can be reduced to a version the answers of which are contained in the answers of the schema, used in the examples throughout the rest of the paper. Q The conjunctive query form Q conj orig is: Assume a view: A rewriting algorithm creates the following partial query mapping on the view (starting from the head and moving on to the body):
Namely, three very well know classical rewriting algorithms, In-verse Rules [8], Bucket [15] and MiniCon [23] work as follows: Inverse Rules inverses the views such that the subgoals of the views become the heads of rules the subgoal of which is the view head; the inversed rules are matched with the query subgoals to find out a set of rules that covers all of them. The Bucket Algorithm [15] creates a bucket for each subgoal and puts in each bucket the views that can cover this subgoal. It then tries to find a minimal combina-tion of views (one from each bucket). The MiniCon algorithm [23] works similarly to the Bucket algorithm, but instead of creating a bucket for each subgoal and then trying to combine views from within the buckets, it matches each view with as many as possible query subgoals following join chains. When no more subgoals can be matched, the algortihm tries to match another view with as many as possible from the rest such that the two views can be joined in the rewritten query body. This procedure is performed until all sub-goals are covered by a set of views.
 Overall, all three algorithms have two coarse steps: 1. Map the query on the view in the least restrictive manner (in terms of homomorphism). 2. Combine view mappings produced in the previous step so that all query subgoals are covered in a non-redundant manner.
In the following we refer to query rewriting employing an al-gorithm based on query containment, such as the above, as clas-sical or complete query rewriting. Also, we use interchangeably: the terms rewriting and answering (since answering is performed through rewriting); the terms of query element mapping , covering and satisfaction ; query conditions and constraints (usually the first term is used for SQL and the second for conjunctive forms), relax-ation and approximation (the latter is a broader term than the first and covers cases of query versions that may not only be relaxed but have additional elements -the proposed technique works in case of such query approximation). A complete mapping of query vari-ables on view variables is denoted with  X  ( . ) .
Our approximate rewriting technique searches the optimal ap-proximation based on the removed query elements from Q The algorithm is based on a structure called F (from  X  X ailure X ) that records the query rewriting procedure at the point of failure, indi-cating which query part should be removed in order to create an approximation of the Q orig , Q apprx , and try to rewrite the latter with possible success. Since the traditional query rewriting algo-rithms proceed in two coarse steps (described informally in Section 3), failure of rewriting, and, therefore, creation of a new instance of F , can occur in any one of the two steps.
With respect to a view V  X  X  and the query Q , an instance of F records the failure of mapping V on Q . The latter can either be the originally posed query Q orig , or an approximate version of it. The definition of F is: Definition 1 A failure F for a view V and a query Q is the set F ( Q,V ) = ( h P , X  P ,G P ,D ) where: -h
P is a head homomorphism on V - X 
P is a partial mapping from the subgoal variables of Q to the subgoal variables of h P ( V ) -G P is the subset of the subgoals in Q which are covered by some subgoal in h P ( V ) using the mapping  X  P , -D = { x } , where x is a (a) join, (b) comparison, (c) constant, (d) variable or (e) subgoal of Q .

An instance of F for a query Q and a view V is created when the mapping of the view on the query fails. The D part of F consists of the part of Q that constitutes the point of failure of the extension of h P ,  X  P or G P . Naturally, the creation of a F can be terminated prematurely because of several mismatches in the mapping process of V on Q . Moreover, even if there is no failure in the mapping of a view V on a query Q , the creation of F is possible in the case that the mapping of V cannot be combined with the mapping of other views in order to rewrite Q as a whole. A F is created in the following situations, either during the mapping of V on Q or the combination of the mapping of one view V and another view V
Failure of mapping V on a query Q and, therefore, the creation of F ( Q,V ) , can occur in the following cases: Case 1: Query head variables are mapped to variables in the view, but the latter are not distinguished, thus they cannot be exposed to the rewriting algorithm. Formally: If there is a query head variable x which is in the domain of the view mapping  X  P of V on Q but is not in h p , then: D = { x } . F indicates the elimination of x . Example 1 Assume the query Q orig (room#, floor#):-Rooms (room#, floor#) and the view V (room#):-Rooms (room#, floor#) . Then the head variable floor# should be eliminated in order to avoid view mapping failure, thus D = {floor#} Case 2: A query subgoal is mapped on the view but a join between variables within the subgoal is neither mapped, nor the respective mapped variables in the view are distiguished. Formally: If a ho-momorphism cannot be created or extended on V , in order to sat-isfy a join in a query subgoal g.x = g.y , then: D = { g.x = g.y } . The homomorphism on V is needed to satisfy a query join and F indicates the elimination of this join.
 Example 2 Assume the query Q orig (name, room#):-Hotels (name, room#, price, price) and the view V (name, room#):-Hotels (name, room#, rate, lowestprice) . Then the join Hotels.rate = Hotels.lowestprice should be eliminated in order to avoid the failure; thus D = {Hotels.rate = Hotels.lowestprice} .
 Case 3: A variable present in a set of query subgoals is mapped on V as an existential variable, but not all of these subgoals are mapped on V . Formally: If x is a variable in a query subgoal g , and  X 
P is extended to contain the mapping of x but cannot be extended to contain g , then: D = { g } . The requirement for the mapping extension is due to a query join. F indicates the elimination of this join in case that the mapping  X  P cannot be extended or g cannot be satisfied by V . Example 3 Assume the query that asks for the location with the lowest price for a specific period: Q orig (location):-HotelsCheck (hid, estprice) HotelLocation (name, lowestprice, location) and the view V (name, room#, rate2, lowestprice) . The subgoal HotelLocation should be eliminated to avoid failure; thus D = {HotelLocation} . Case 4: Query subgoals are mapped on V but joins between these subgoals are neither mapped in V nor respective variables in V are distinguished, so that the join can be enforced there. Formally: If a set of query subgoals G is satisfied by V , but there is a query variable x  X  g ,  X  g  X  X  such that  X  P cannot be extended to contain  X  ( x ) ; then for any two subgoals g 1 , g 2  X  G : D = { g 1 .x = g 2 .x } . The reason for this failure is the incapability of V to rewrite a query join. F indicates the elimination of this join. (Checks for rewriting head variables as well as constant and comparison constraints are treated separately).
 Example 4 Assume a query that asks for hotel names and low-est prices by the sea, but double checks the validity of information in both HotelLocation and Hotels , Q orig (name, lowestprice):-Hotel-price) and the view V (name, rate):-HotelLocation (name, rate,  X  X ea X ) Hotels(name, room#, rate, lowestprice) . Then there is no appropriate homomorphism for the view and the join HotelLocation.lowestprice = Hotels.lowestprice should be eliminated in order to avoid failure; thus D = {HotelLocation.lowestprice = Hotels. lowestprice} Case 5: Query variables involved in comparison subgoals are not mapped on V. Formally: If x,y are a query variables, y  X  g and there is a subgoal x.y , where . is a comparison predicate,  X  is an existential variable, but  X  P cannot be extended to contain  X  ( y ) , then: D = { x.y } . F indicates the elimination of the com-parison atom in case that  X  P cannot be extended or a subgoal g cannot be satisfied by V . (Equivalent to case 3).
 Example 5 Assume the query Q orig (name, lowestprice1):-Hotels (name, estprice2 and the view V (name, lowestprice):-Hotels (name, room#, rate, lowestprice) . Since V does not include the subgoal SeasonPrices the comparison cannot be satisfied and D = {rate  X  lowestprice2} . Case 6: Query variables in a comparison subgoal are mapped on variables of V that are not distinguished and the comparison sub-goal is not mapped in V . Formally: If x,y are a query variables, y  X  g and there is a comparison subgoal x.y , where . is a compar-ison predicate,  X  P ( x ) and/or  X  P ( y ) are existential variables, but  X 
P cannot be extended to contain  X  P ( x.y ) , then : D = { x.y } . V is incapable to satisfy the query comparison, thus, F indicates the elimination of the respective subgoal. (Equivalent to case 4). Example 6 Assume the query Q orig (name1, lowestprice1):-Hotels estprice2) lowestprice1  X  lowestprice2 and the view V (name):-Hotels (name, room#, rate, lowestprice) . The view does not export sufficient information (distringuished variables) in order for the query com-parison to be produced.
 Case 7: A query constant is either mapped in a variable of V that is not distinguished, or it is not mapped at all. Formally: If a is a query constant, but  X  P ( a ) is neither the constant a nor it is in h then: D = { a } . F indicates the elimination of a .
 Example 7 Assume the query Q orig (name):-HotelLocation (name, lowestprice,  X  X ea X ) and the view V (name):-HotelLocation (name, low-estprice, location) . A rewriting failure occurs because the view does not make the specialization location =  X  X ea X  . To avoid failure the constant constraint should be removed: D = { X  X ea X  } .
Even if F ( Q,V ) is not created while the rewriting algorithm is mapping V on Q , it can be created later on, while the algorithm tries to combine the mapping  X  ( V ) of V, with the mapping  X  ( V of another view V 0 (in which case the mappings are complete) Case 8: Views are covering overlapping query subgoals. Formally: If V is the set of views for which there is no F ( Q,V ) ,  X  V  X  V , then, if  X V 0  X  V there is a set of overlapping query subgoals G mapped on V 0 , then  X  g  X  G and  X  V  X  V 0 such that g is satisfied in all V  X  V 0 , an F ( V ) is created, such that: D = { g } . The extension of G satisfied by a view is caused by query joins and variable comparisons. F is created, such that  X  F  X  X  , F indicates the elimination of one join or one variable comparison.
 Example 8 Assume the query Q orig (lowestprice, distance):-Hotels cation) Airport (aid, location, distance) and the views V lowestprice, location) and V 2 (name, distance):-HotelLocation (name, low-estprice, location) Airport (aid, location, distance) . V combined due to overlapping subgoals.
 Case 9: Views have contradictory constant constraints. Formally: If for V there is no F ( Q,V )  X  V  X  V , then if there are V with contradictory constant constraints, i.e.  X  ( V 1 .x ) = a 6 = b =  X  ( V 2 .x ) , then F 1  X  F ( Q,V 1 ) and F 2  X  F ( Q,V 2 such that each F  X  F 1 and F  X  F 2 eliminates a query join such that the mapping of x is not in  X  P ( V 1 ) ,  X  P ( V 2 ) . Example 9 Assume the query Q orig (name, location):-Hotels (name, room#, rate, lowestprice) HotelLocation (name, lowestprice, location) and the views V 1 (name):-Hotels (name, room#, rate,  X 500 X ) and V location):-HotelLocation (name,  X 300 X , location) . V 1 and V combined due to contradictory constants.
 Case 10: Views have contradictory comparison constraints. For-mally: If V is the set of views for which there is no F ( Q,V )  X  V  X  V , then if there are V 1 ,V 2  X  X  with contradictory comparison con-straints, i.e.  X  ( V 1 . ( x.y )) 6 =  X  ( V 2 . ( x.y )) , then F and F 2  X  F ( Q,V 2 ) are created such that each F  X  F F  X  X  2 eliminates a query join or a comparison so thatthe mapping of x.y is not in  X  P ( V 1 ) ,  X  P ( V 2 ) .
 carrier, org, dest, price) and the views V 1 (fno):-Flights (fno, depart, re-depart, return, carrier, org, dest, price), price &gt;  X 400 X  . V be combined due to contradictory comparisons.

Figures 4 and 5 show the procedures that produce the F s.
The unification of LAV mappings is an optimization integrated in the procedure that preprocesses and rewrites the query. The classi-cal query rewriting algorithms that employ LAV mappings require that each query subgoal has to be translated by a single mapping. Therefore, if this requirement cannot be satisfied, then the subgoal has to be eliminated from the query; however, it may be that a com-bination of LAV mappings can rewrite this subgoal.

We have developed a procedure that overcomes this kind of sit-uations by combining LAV mappings that can, as a set, rewrite the
Although  X  and  X  P are formally defined for query subgoal vari-ables, for simplicity of presentation, we use it loosely with other arguments too, such as a subgoal g and view V , meaning the over-all mapping of g and V , respectively query subgoal. In detail, this procedure searches for LAV map-pings, the head of which encompasses the key attributes of the sub-goal. In this case, a simple join between the found LAV mappings can produce a new mapping that rewrites the complete subgoal. Figure 6 delineates the steps of this procedure. The unification of LAV mappings not only enables approximate query rewriting, but also extends classical query rewriting for the particular case in which a set of views can be completely mapped on the posed query, but the views cover overlapping subgoals, which can be joined on their key. Multiple occurrences of these subgoals are eliminated, as shown in the following example.
 Example 11 Assume a SQL query with a star select clause, writ-ten as follows in conjunctive form: and the available views are: The classical rewriting algorithms do not rewrite the above query, since the query subgoal is covered by both views. However, with view unification, the following view is produced: The above view can rewrite the query. The expansion of the view has a repeated subgoal self-joined on the key. Thus, the rewritten query is a classical rewriting.

Solving the containment, and therefore, the rewriting of queries with comparison subgoals has been a challenging issue [2]. As stated in [23], there are some cases of queries with comparison predicates that can be rewritten using the available views, but are not, since the respective containment check fails. Specifically, these are the cases that even though the comparison cannot be rewritten by the available views (i.e. no appropriate distinguished variables or comparison predicates in the views), the comparison constraint is satisfied; Actually, the view entails a specific case of the com-parison, i.e. a contained rewriting. These situations occur if the comparison includes an equation. Intuitively, an equation reduces the comparison to a join, which can be satisfied by the view. Classi-cal query rewriting cannot make this reduction. However, the pro-posed approximate query answering technique, achieves to include this reduction, by relaxing the requirement for the comparison sat-isfaction. Even with this relaxation, the joins in the considered view may be able to rewrite the equation.
 Example 12 A query requests vacation packages the information of which is correct in the database, meaning that the  X  X rom X  date is before or on the  X  X ntil X  date: Q orig (vacid):-VacPackage(vacid, fno, hid, from, until), from  X  until (let us assume that dates can be com-pared). Assume the following view that gives packages for one day is available to rewrite the query: V (vacid):-VacPackage(vacid, fno, hid, from, until) VacPackage(vacid fno, hid, until, from) . Classical algorithms cannot rewrite Q orig using V because the comparison constraint cannot be satisfied. The approximate rewrit-ing technique, however, relaxes the query by removing the compar-ison, and achieves to produce the classically contained rewriting: In the following the algorithms that produce and rewrite the best Q apprx of Q orig with respect to a set of views V are presented.
In order to produce an approximate rewriting of Q orig it is nec-essary to navigate through the possible approximate versions of it. Imagine a tree of approximate versions of Q orig where each node has one query element less than its father. Specifically, the root of the tree is Q orig ; the children of the root correspond to approxima-tions of Q orig where a single query element is missing. The num-ber of the nodes of the 1 st level is equal to the number of query elements in Q orig . Each one corresponds to a Q apprx which con-tains all the elements of Q orig minus 1. Similarly, the children of the k th level contain n  X  k  X  1 elements of Q orig , which are all the elements of their father minus 1. The total number of nodes on the k th level is n ! / ( n  X  k )! . The total number of nodes is quite big with respect to n : e  X ( n + 1 , 1) . Leaf nodes correspond to empty Q apprx . It is obvious that more than one tree nodes corre-spond to the same Q apprx . Consequently, there are subtrees that are repeated in the tree. Pruning the repeated subtrees results in a (non-balanced) tree with 2 n nodes for a Q orig with n elements.
A straightforward approach in order to explore query approxi-mations and their rewritings, is to create the tree of approximations and run a classical rewriting algorithm for each of the distinct nodes of this tree. Then, we can compare the rewritings produced by each such execution and find the best approximation Q apprx . In detail, for a Q orig of n subgoals, the employment of a classical rewriting algorithm in the above manner has to check O (2 n ) Q apprx sions, as follows: (1) produce all possible Q apprx , (2) order them in descending manner with respect to their similarity to Q (3) check them iteratively until an output, i.e. a complete rewriting, can be produced. We call this the Simple Exhaustive algorithm and we use it as a reference for comparison to the algorithms that are proposed in the following and that are guided by the creation of F structures, as shown in Figure 2. Simple Exhaustive is quite expen-sive, mainly because of step (1), which has to produce all the nodes of the search tree described above and prune repeated subtrees. The complexity of Simple Exhaustive is O ( e  X   X ( n + 1 , 1)) .
Employing the structures F s, we can explore the tree of pos-sible query approximations, such that far fewer nodes are visited than those that are visited in a straightforward manner with the Simple Exhaustive algorithm. Essentially, F s can guide the ex-ploration to the subtrees that contain approximations which are (a) possible with respect to the available views as well as (b) neces-sary with respect to the failures of mapping the available views on the query. Exploration is cheaper (i.e. it visits fewer tree nodes) because guided by F s we can prune the subtrees such that approxi-mated queries that are missing elements which can be rewritten by combinations of complete view mappings are not visited. Figure 7 presents the F Exhaustive algorithm that explores the possible approximations guided by F s. Briefly, the algorithm proceeds as follows: First the algorithm computes the initial set of complete view mappings; if this set of views is not able to thoroughly rewrite Q orig , it creates the tree of F s (and not the tree of possible ap-proximations). Each edge of this tree corresponds to a F and each node to the Q apprx produced by the path of F s that leads to it from the root. The tree is created as follows: Initially, the approxima-tion similarity MaxSim is set to minimum and all the necessary F s are created and form the set F . For each F  X  F the respec-tive Q apprx is created and if its similarity is higher than the current value of MaxSim , search explores more this possible approxima-tion. The algorithm iterates on this F by reseting the set V and running a classical rewriting algorithm on Q apprx (note that steps 6-9 of Figure 2 are suitably merged for efficiency). In case of fail-ure, the procedure starts from the beginning by computing the new F s and adding them to F . Since F Exhaustive searches guided by the F tree and not by the tree of approximations, its complexity is O ( |F| ) , where F is the set of possible F s. The latter are far fewer than the number of possible approximations and in general it holds that their number is proportional to the number of available views |F|  X  |V| . In practice the number of views is far smaller than the size of the approximation tree, thus, O ( |V| ) &lt; O ( e  X   X ( n + 1 , 1)) , or the number of possible approximations.
 Theorem 1 The search space of F Exhaustive is a subset of the search space of Simple Exhaustive .

Sketch of proof: Assume a Q apprx that corresponds to a F with some D = { x } . Then Q apprx is missing a query element corre-sponding to x . x represents the point of failure during the mapping of a view V  X  X  and to a query Q that is either Q orig or an approx-imation of it Q 0 apprx . Q 0 apprx has a subset of the query elements of Q orig . Thus, the mapping of V on Q 0 apprx can fail in a subset of the possible points of failure of the mapping of V on Q orig possible points of failure of the mapping of V created for Q correspond to a subset of all the query elements; let us call it E The union of the E V for all V  X  V , called E V is a subset of all the query elements of Q orig . Therefore, if a Q apprx is missing an ele-ment that is not in E V , it is not in the search space of F Exhaustive . On the opposite, the search space of Simple Exhaustive contains all the possible Q apprx .

Intuitively, the search space of F Exhaustive is much smaller than that of Simple Exhaustive because the first contains only the Q apprx that are missing query elements that cannot be rewritten employing the available views, whereas the second contains all the possible Q apprx . The following is an intuitive example. Example 13 Assume the query: Q written in conjunctive form as: (name, lowestprice,  X  X ea X ) SeasonPrices( X  X pring X , lowestprice) . Q orig has 5 elements and therefore the total number of distinct approximations is 32 and the size of the approximation tree is 205 . Assume that the available views are: Location (name, lowestprice,  X  X ea X ) and (lowestprice) :-SeasonPrices (season, lowestprice) .
 V 1 has a complete mapping on Q and therefore we do not need to examine approximations that miss elements that can be satisfied by V , i.e. the  X  X elect X  attribute, the condition HL.location =  X  sea  X  and the join H.name = HL.name . V 2 has a partial mapping that creates an F with D = {  X  spring  X  } . This is the only F created, and examined for produced approximations, since the combination of the complete mapping of V 1 and the partial mapping of V the remaining element HL.lowestprice = SP.lowestprice .
 Theorem 2 F Exhaustive is complete, i.e. it finds the Q apprx the maximal MaxSim .

Sketch of proof: We have to prove that the Q apprx with the maxi-mal MaxSim is in the search space of F Exhaustive . Assume that Q apprx 1 and Q apprx 2 are the approximate queries with the max-imal MaxSim in the search space of F Exhaustive and Simple Exhaustive , respectively. If Q apprx 1 6 X  Q apprx 2 , then Q is missing a query element E  X  E orig and therefore E corre-sponds to a D = { x } of a F  X  F . Thus, F has been consid-ered by F Exhaustive and the best approximate query following F has been compared to Q apprx 1 and rejected. Therefore if E is in Q apprx 2 then E is in Q apprx 1 . The opposite holds because Q apprx 2 is by default the best possible approximation. Therefore Q
Intuitively, F Exhaustive is complete because the best Q apprx is missing only elements of Q orig that constitute points of failure of mapping views on Q orig ; all of these points are explored by the produced F s. Thus, the best Q apprx is in the search space of the algorithm. Since the latter is exhaustive, it finds the best Q
The set of F in F Exhaustive is augmented in each iteration and one F  X  F is selected for examination. To improve efficiency, we reorder the F before each iteration with respect to a heuristic criterion that is based on the notion of uncovered subgoals : Definition 2 With respect to a set of views V and their complete mappings  X  ( V ) on the query Q orig , the uncovered subgoals of Q orig is the set of the subgoals that cannot be covered by any map-ping in  X  ( V ) .
 The heuristic criterion Cr 1 is defined as follows: Definition 3 Create an ascending order of all F  X  X  with respect to the number of uncovered subgoals of Q orig that cannot be cov-ered by each F .

Criterion Cr 1 dictates that the more uncovered subgoals can be covered by the considered F , the greater the possibility that the view mapping to be created after relaxing the query according to F will achieve the rewriting of currently not covered subgoals of Q orig . The F that does not cover few uncovered subgoals leads to a view mapping on the respective Q apprx that covers many of the query elements that cannot be covered by all existing mappings  X  ( V ) for Q orig . The more these query elements are, the fewer are left that could not be covered by the available views and demand the exploration of approximations. Using Cr 1 F Exhaustive achieves to explore the Q apprx with a high MaxSim first, such that a big part of the F tree is not visited, making the algorithm very efficient as shown in Section 6.
Even though the search space of the F Exhaustive is much smaller than that of the Simple Exhaustive , the exhaustive traversal of the F tree can be very expensive. Thus, we propose a method that prunes the tree such that a partial traversal of it is still eligible to produce a Q apprx close, in terms of query similarity, to the best possible one. The following heuristic criterion, Cr 2 , is used complementary to criterion Cr 1 so that such a pruning is achieved.
 Definition 4 Create a descending order of all F  X  X  with respect to the similarity of Q apprx to Q orig , where Q apprx is the approxi-mation produced employing F .

Orthogonally to Cr 1 , Cr 2 denotes that the better the approxima-tion of Q orig produced according to the considered F , the bigger the possibility that F leads to the production of the best approxi-mation of Q orig . Oppositely to Cr 1 , Cr 2 is optimistic and judges the possibility of achieving the approximate query rewriting based on the query elements that are covered by the considered F .
The combination of Cr 1 and Cr 2 forms the branch-and-bound version of the F Exhaustive , that we call the F B&amp;B algorithm. This algorithm is presented in Figure 8 and, briefly, it proceeds as follows: At each iteration that a view mapping fails, the children nodes corresponding to appropriate F s are created and are ordered based on the values of Cr 1 ; The F s that lead to query approxima-tions that are of different similarity to Q orig but are in the same partial order according to Cr 1 , are ordered based on Cr combination of Cr 1 and Cr 2 that gives the lead to the first and refines the search with the second is adequate to guarantee a near-optimal query rewriting approximation, as shown in Section 6.
In what follows, we present the experimental evaluation of pro-ducing approximate versions of Q orig using a set of views V . Methodology. The proposed algorithms, F Exhaustive and F B&amp;B , are compared against Simple Exhaustive with respect to their exe-cution time. For F B&amp;B the similarity difference (denoted as "ap-proximation error") of the computed approximation against the op-timal approximation, (computed by both F Exhaustive and Simple Exhaustive ) is measured. In the graphs, the " F B&amp;B error" lines refer to the scale on the right and the rest lines refer to the scale on the left (if there are two vertical axes). Among all classical query rewriting algorithms we have used for the implementation of the algorithms and the experimentation with the proposed approximate query rewriting technique the MiniCon algorithm [23], which is the latest and most efficient of the well-known ones. As stated before, defining a query similarity measure is an orthogonal problem to finding query approximations. In the experiments we employ one of the query similarity measures presented in [11] as follows: This measure confines the similarity of two queries by the similar-ity of their elements. E i  X  X  are elements ( X  X elect X  values or  X  X here X  conditions) of Q orig , E 0 i  X  X  are the respective elements of Q and P w i = 1 . The function sat ( E i ,E 0 i ) captures the notion of E i represented by E 0 i and for this work is either 0 or 1 . Datasets. The experiments are performed on synthetic data, fol-lowing the example of works in query rewriting using views [16, 23, 26]. Synthetic data give the opportunity to control the form/size of Q orig and the set of views V ; therefore, it enables the case-study of a big variety of query-views combinations, that cannot be found in real datasets. The parameters of the algorithms are plenty. For both the query and the views: number of subgoals, number of dis-tinguished variables, number of repeated subgoals, shape (random, star and chain queries for repeated subgoals), presence of arith-metic comparisons; More parameters are: the number of views, query-views shape and size combinations, as well as different sim-ilarity functions. The number of parameters prohibits the presenta-tion of the thorough experimental study due to lack of space. In the following the most important and interesting experiments are de-scribed. If not fluctuated, the following parameter values are used. Number of: relations = 10, views = 10, view subgoals = 4, query subgoals = 5, repeated query subgoals = 2, query constants = 1, view distinguished variables = 2, view joins = 3, view constants = 3, view comparisons = 3; query form = "random", query distin-guished variables = 20%, .
Figure 9 shows graphically the experimental results, which are commented in the following.
Figure 9(a) shows the results for random queries and views as the number of views increases. F Exhaustive starts with being 100 times faster from Simple Exhaustive , and this difference shrinks but remains substantial for bigger number of views. F Exhaus-tive performs exceptionally for a low number of views compared to Simple Exhaustive , because the search in F Exhaustive is guided by the views, (i.e. only query parts that cannot be rewritten based on the (few) views are examined for elimination), whereas Simple Exhaustive , is guided by approximate query versions; even though it checks approximation with increasing approximation cost, the small number of views results in the consideration of many query elements for elimination, and therefore, of an exponential number of approximate query versions. Since the rewriting of a query based only on a few (less than 5) views is expected to be a common case in real situations, using F Exhaustive gives a big advantage. Both algorithms perform much better for a very big ( &gt; 90) number of views. The reason is that in this case, most frequently, the query can be rewritten with very few eliminations. The relative performance of F Exhaustive increases because it easily finds the appropriate eliminations. F B&amp;B is steadily 1000 faster than Simple Exhaus-tive achieving a very low approximations error ( &lt; 4%), which makes it very competitive to F Exhaustive .
Figures 9(b), (c) and (d) shows the results varying the number of query elements, i.e. the distinguished variables (the  X  X elect X  at-tributes) and the constraints (i.e. where conditions: joins and vari-able comparisons, comparisons with constants). Overall, the ef-ficiency of the algorithms steadily increases as the query size in-creases. Simple Exhaustive is affected exponentially by the query size, since each additional element adds combinations with all the rest to the set of possible approximations. However, since the cre-ation of F s is not based on query elements, but on query -view combinations, the number of F s is not affected so radically by the increase in the number of query elements. Both algorithms become more efficient for larger queries.
 Number of subgoals. Figure 9(b) shows the results for random queries and views as the number of query subgoals increases. The efficiency of both the F algorithms increases with the number of subgoals. The approximation error of F B&amp;B increases with an ex-tremely low rate with the number of subgoals. Naturally, the big-ger the number of subgoals the bigger the number of joins, which slightly but consistently affects the refined pruning of B&amp;B . Number of constants. Figure 9(c) shows the results while increas-ing the number of constants in the query. The efficiency of the algorithms increases with a slightly bigger rate than the respective rate for increasing number of subgoals. The satisfaction of constant constraints is uncorrelated to the satisfaction or not of the rest of the constraints (joins between subgoals), because they do not partici-pate in join pools. F B&amp;B shows a very small approximation error that is reduced as the number of constants increases.
 Number of distinguished variables Similarly, the results for in-creasing number of distinguished variables, (Figure 9(d)), show an even bigger rate of efficiency increment: the satisfaction of a dis-tinguished variable is independent from the satisfaction of the rest query elements. Thus, the algorithms insist on specific search paths and examine a restricted number of F s. The behavior of the ap-proximation cost is between the one for increasing number of con-stants and the one for subgoals. F B&amp;B is really benefitted by the independence of the satisfaction of distinguished variables.
Figures 9(e),(f) present the results for queries with a constant number of elements, but with increasing repeated subgoals (i.e. self-joins). These experiments focus on the role of the query shape: random, chain and star [23,26]. Overall, repeated subgoals increase the dependency of query constraints: because of the self-joins, a view may be able to rewrite a big number of query elements if it satisfies one of them, or the opposite.
 Random queries. The results for random queries show that a percentage of 40% of repeated subgoals affects negatively the ef-ficiency of the algorithms: they have to satisfy a big number of tightly dependent subgoals and a similar number of non-related to them subgoals. On the opposite, a small or big percentage of re-peated subgoals either weakens or strengthens the effect of their dependance, leading the algorithm either to shortly leave a bad or stick to a good search path. F B&amp;B achieves a zero approximation error for queries with more than 25% repeated subgoals.
 Star queries. The results for star queries are harsher than in the case of random queries. Star queries indicate intensively to F s which constraints should be eliminated. The presence of repeated subgoals reinforces the possible choice of a subset of approxima-tions, reducing the occurrences of backtracking in search space. Chain queries. Oppositely to star, chain queries may create more approximations, because the satisfaction of constraints is primar-ily led by the join chain, which gradually indicates the options for approximation in each algorithm iteration. Efficiency results are smoother than those for random or star queries. Repeated subgoals, reinforce some of the approximation options and reduce the error.
Overall, F Exhaustive is considerably faster than Simple Exhaus-tive and their speed difference is substantial for the important situa-tions of few views or big queries (in terms of number of elements). F B&amp;B is much faster than F Exhaustive and keeps a steady or even increasing rate of speed up with respect to Simple Exhaustive . The heuristic of F B&amp;B is very efficient and the approximation er-ror is generally much lower than 10%. Chain queries are the hardest to handle with F B&amp;B .
We tackle the problem of approximate query answering in envi-ronments of autonomous and heterogeneous sources and we pro-pose a query relaxation technique that extends traditional query an-swering. The technique comprises algorithms that search for the best approximation and employ as a black box a query similarity function. The experiments prove the efficiency of the algorithms. This research has funding from the EU Seventh Framework Pro-gramme (FP7/2007-2013), Grant Agreement n o 619706 ASAP.
