 Collaborative filtering is the most popular approach to build recommender systems and has been successfully employed in many applications. However, it cannot make recommen-dations for so-called cold start users that have rated only a very small number of items. In addition, these methods do not know how confident they are in their recommenda-tions. Trust-based recommendation methods assume the ad-ditional knowledge of a trust network among users and can better deal with cold start users, since users only need to be simply connected to the trust network. On the other hand, the sparsity of the user item ratings forces the trust-based approach to consider ratings of indirect neighbors that are only weakly trusted, which may decrease its precision. In order to find a good trade-off, we propose a random walk model combining the trust-based and the collaborative filter-ing approach for recommendation. The random walk model allows us to define and to measure the confidence of a rec-ommendation. We performed an evaluation on the Epinions dataset and compared our model with existing trust-based and collaborative filtering methods.
 H.2.8.d [ Information Technology and Systems ]: Database Applications -Data Mining Algorithms, Design, Experimentation, Measurement Trust, Recommendation, Random Walk
With the rapidly growing amount of information available on the WWW, it becomes necessary to have tools to help users to select the relevant part of online information. To satisfy this need, recommender systems have emerged, e.g. there are popular recommenders for movies 1 , books 2 , mu-sic 3 , etc.

Typically in a recommender system, we have a set of users and a set of items . Each user u rates a set of items by some values. The recommender has the task to predict the rating for user u on a non-rated item i or to generally recommend some items for the given user u based on the ratings that already exist. Collaborative Filtering [6] methods make rec-ommendations based on the ratings of item i by a set of users whose rating profiles are most similar to that of user u . With the advent of online social networks, the trust-based approach to recommendation has emerged. This approach assumes a trust network among users and makes recommen-dations based on the ratings of the users that are directly or indirectly trusted by u .

Collaborative Filtering is most effective when users have expressed enough ratings to have common ratings with other users, but it performs poorly for so-called cold start user. Cold start users are new users who have expressed only a few ratings. Using similarity based approaches, it is unlikely to find similar users since the cold start users only have a few ratings. Trust-based recommenders, however, can make recommendations as long as a new user is connected to a large enough component of the trust network.

Using a trust network therefore improves the coverage of recommendations. However, when we go far from the source user u in the trust network, the trust between these users and the source user will become fairly weak and their ratings will be noisy and unreliable. Therefore, we have to use the ratings expressed by users in the neighborhood close to the user u . But, in this case the probability of finding a rating expressed on the item will be very low and we will not be able to compute a prediction.

In order to consider enough ratings without suffering from noisy data, we propose a random walk method (TrustWalker) which combines trust-based and item-based recommenda-tion. TrustWalker considers not only ratings of the target item, but also those of similar items. The probability of us-ing the rating of a similar item instead of a rating for the target item increases with increasing length of the walk. Our framework contains both trust-based and item-based collab-orative filtering recommendations as special cases. Most tra-ditional recommender systems do not provide confidence in their predictions. The random walk model allows us to com-http://www.netflix.com http://www.amazon.com http://www.last.fm pute the confidence in our predictions. Also our system is able to explain and justify its results.

The rest of the paper is organized as follows: Section 2 de-scribes the problem definition. Related works are discussed in section 3. We discuss the details of our proposed model in section 4. In section 5 we introduce some desirable proper-ties of our model. The experimental results and comparison with existing methods are discussed in section 6. Finally we conclude the paper in section 7 and introduce some direc-tions for future research.
In recommender systems we have a set of users U = { u 1 , ... u N } and a set of items I = { i 1 , ... i M } . Each user u on item i is denoted by r u,i . r u,i can be any real number, but often ratings are integers in the range [1 , 5]. In a trust-based system, we also have a trust network among users. If u trusts v , then t u,v denotes the value of this trust as a real num-ber in [0 , 1]. Zero means no trust and one means full trust. Binary trust networks are the most common trust networks (Amazon 4 , eBay 5 , ...). We define TU u = { v  X  U | t u,v where TU u denotes the set of users directly trusted by u . The trust network can now be defined as a graph G = &lt; U, TU &gt; where TU = { ( u, v ) | u  X  U, v  X  TU u } . There is a node corresponding to each user, and an edge corresponding to each trust statement.

The task of a recommender is as follows: Given a user u  X  U and an item i  X  I for which r u,i is unknown, predict the rating for u on item i . We call u the source user and i the target item. The predicted rating is denoted by b r Normally, users rate only a very small percentage of the items, and r u,i is unknown for most pairs of ( u , i ).
Traditional recommenders[6] estimate b r u,i based on rat-ings expressed by similar users. Basically, they find a neigh-borhood of raters (users who have rated target item i ) who have a rating profile similar to the source user, and aggre-gate their ratings. In trust-based recommenders, the trust network will be used instead of rating similarities to define the neighborhood. To predict a rating we ask our directly trusted neighbors whether they know the rating for the item. If so, they return it, otherwise they recursively ask their di-rect neighbors. The neighborhood in a trust based recom-mendation is defined as the set of raters trusted (directly or indirectly) by the source user. The ratings from these rates are aggregated to produce a recommendation.

Trust-based recommendation works because of the effects of selection and social influence that have been postulated by sociologists for a long time. Selection means that peo-ple tend to relate to people with similar attributes, and due to social influence related people in a social network influ-ence each other to become more similar[16]. The increasing availability of online social network data has finally allowed a verification of these sociological models. [4] experimen-tally verified that people are similar to their neighbors in a social network for these reasons. They had a network of people having social interactions and a similarity network in which users are connected to their most similar users. It was shown that the social interaction and similarity graphs have little overlap, sharing fewer than 15% of their edges. The re-www.amazon.com www.ebay.com sults of [4] and of similar work confirm that a social network provides an independent source of information which can be exploited to improve the quality of recommendations.
Exploiting the trust network in recommenders does not necessarily enhance the precision of system, but it allows to compute the recommendation for more pairs of ( u, i ) which leads to better coverage. Coverage is the percent-age of &lt; user, item &gt; pairs in the test set for which we can compute a recommendation. This information can in particular help to produce recommendations for cold start users. Moreover, using a trust network will protect the rec-ommender system against attacks like fake profiles. As faked profiles are not being trusted, they can not affect the rec-ommender.
 Figure 1 illustrates the trust-based recommendation prob-Figure 1: Illustration of a social network including rat-lem. As shown in this figure, we have a social (trust) network of users. Each user has rated some items. The source user u wants a prediction on the target item i (the green diamond). Normally just a few users have rated the target item. Other users have ratings on other items which may include items already rated by u or items similar to the target item i . The goal of the recommender is to predict unknown ratings based on the ratings expressed by trusted friends.
In this section, we review related work on trust-based rec-ommendations. We can distinguish two types of trust: Ex-plicit trust and Implicit trust. Explicit trust denotes the trust values explicitly indicated by users, while implicit trust is the trust value inferred from some evidence such as feature similarity of users or email exchange among two persons. In this paper we deal with the explicit trust indicated by users. In the case of explicit trust, we have direct trust and indi-rect trust. Direct trust is the trust value explicitly indicated by users, but indirect trust is the trust inferred from direct trust using transitivity of trust. how to compute indirect trust is one of the main issues of trust models. Two dif-ferent approaches can be distinguished for trust computa-tion: Model-based[13][9] and Memory-based[10][5][18][8]. In Model-based approaches, a model with its parameters will be learnt to compute indirect trust. But, in Memory-based approaches, no model is being learnt and normally explo-ration and heuristics are being used.

TidalTrust[5] performs a modified breadth first search in the trust network to compute a prediction. Basically, it finds all raters with the shortest path distance from the source user and aggregates their ratings weighted by the trust be-tween the source user and these raters. To compute the trust value between user u and v who are not directly con-nected, TidalTrust aggregates the trust value between u  X  X  direct neighbors and v weighted by the direct trust values of u and its direct neighbors. Since TidalTrust only uses in-formation from raters at the nearest distance, it may loose a lot of valuable ratings from users a little further apart in the network. [10] introduces MoleTrust. The ideas used in MoleTrust and TidalTrust are similar. But MoleTrust considers all raters up to a maximum-depth given as an input. maximum-depth is independent of any specific user and item. Also, to compute the trust value between u and v in MoleTrust, we perform a backward exploration. It means that the trust value from u to v is the aggregation of trust values between u and users directly trusting v weighted by the direct trust values.

The Advogato[8] maximum flow trust metric has been proposed in order to discover which users are trusted by members of an online community. The input for Advogato is given by an integer number n , the number of members to trust. To assign capacities to the edges of the network, they need to transform the network, so it needs to know the whole structure of the network. Moreover, it only computes the nodes to trust and does not compute different degrees of trust. Since the number of users to trust is independent of users and items and there is no distinction between the trusted users, this approach is not appropriate for trust-based recommendation.

AppleSeed has been proposed in [18]. The basic intuition of AppleSeed is motivated by spreading activation models. Source node u is activated through an injection of energy e , which is then fully propagated to other nodes along edges proportional to the weight of the edge. AppleSeed considers the trust to be additive. If there are many weakly trusted paths between two users, this pair of users will obtain a high trust value, which is not intuitive. [1] presents a set of axioms for trust-based recommender systems and analyzes which combination of these axioms can be satisfied simultaneously. In the context of this discussion, a simple random walk method for binary (+1,-1) ratings is presented, which can be formulated as a special case of our model. [1] does not perform any experimental evaluation or comparison to other methods.
 Trust has been defined and used in a different way by [12]. They extract the social network from the similarity of users X  profiles, which is not providing additional information as is provided by trust network. They have two definitions for trust: profile level trust, which is a global reputation metric; and item level trust, which measures the trustworthiness of a user according to his recommendations for an item rather than a user-user local trust metric. They use the trust values to filter raters, and they aggregate the ratings weighted by a combination of trust and similarity values. Moreover, they do not use the transitivity of trust, but only directly trusted users. This method is not a trust-based recommendation method in the sense in which we use this term in this paper.
The main challenge in trust-based recommendation is to decide how far to go in exploring the network. There is a trade-off between precision and coverage: the further you go, the more likely to find raters , but the less trust-worthy their ratings become. Our approach to find a good trade-off is based on the following observation. Ratings expressed by strongly trusted friends on similar items are more reliable than ratings expressed by weakly trusted far neighbors on the exact target item. This motivates us to combine the trust-based and item-based approach.

We propose a random walk model, called TrustWalker, which considers not only ratings of the target item, but also those of similar items. The probability of using the rating of a similar item instead of a rating for the target item in-creases with increasing length of the walk. Basically, our model consists of two major components: the random walk on the trust network and the probabilistic item selection. The random walk performs the search in the trust network, and the item selection part considers ratings on similar items to avoid going too deep in the network. So our model im-proves the precision by preferring raters at a nearer distance and improves the coverage by considering similar items as well as the exact target item.

To recommend a rating for a source user u 0 on target item i , we perform random walks on the trust network, each starting at u 0 to find a user having expressed rating for i or items similar to i . The details of the random walks will be discussed later in this section. Each random walk returns a rating. We perform several random walks, and the aggregation of all ratings returned by different random walks are considered as the predicted rating b r u 0 ,i .
In the following subsections, we will discuss the details of our random walk model. In our notations, we use symbols u, v, w, ... for users, i, j, ... for items, and k for the step of a random walk. Table 1 lists all notations used in our model. Table 1: Notations used in TrustWalker. RV stands for Random Variable. All the notations have index i denoting target item i .
Starting from source user u 0 , we perform our random walk. At each step k of a random walk, we are at a cer-tain node u . If u already has the rating on target item i , then we stop our random walk and return r u,i as the result of random walk. If u does not have a rating on i , then we have two options: If we decide to continue the random walk at node u , we have to select one of directly trusted neighbors of u to continue the random walk to that user. We define S u as the random variable for selecting a user v from TU u : Now, we have:
Here, X u 0 ,i,k denotes the random variable for being at node v in step k while looking for a prediction on target item i for source user u 0 . Details of computing P ( X u,i,k are discussed later. Also we have a condition that the user u in step k -1 does not have the rating for item i (denoted by g R u,i ) . The probability of walking from user u to v is independent of previous steps. But, since  X  u,i,k depends on the step k , it is not independent of the step of the random walk.

With probability  X  u,i,k , if we decide to stay at a user u , we select one of the items rated by u which is similar to the target item i . The idea is that we define a similarity measure between items, and for each item j  X  RI u , we assign a probability of selecting proportional to the similarity of i and j . We X  X l discuss the details of the similarity metric later.
In this equation Y u,i denotes the random variable for se-lecting item j amongst items rated by u while looking for an item similar to target item i . We return r u,j as the result of this random walk.

To define the whole probability distribution, we define the probabilities for conditions where R u,i is true, or for items not rated by u as follows:
In content-based recommendation, the similarity of items can be computed using their features. However in collabo-rative filtering, the only information available about items is their ratings. Hence, to compute the similarity of two items, we use the Pearson Correlation of ratings expressed for both items, as used in [15]. Values of the Pearson correlation are in the range [-1,1]. Negative correlations mean that the rat-ings expressed for two items are in opposite directions, so these items are not useful for our purpose. Therefore, we only consider items with positive correlation.
UC i,j is the set of common users who have rated both items i and j , and r u denotes the average of ratings ex-pressed by u . corr ( i, j ) denotes the correlation of items i , j .
The size of the set of common users is also important. For example, if corr ( i, j ) = corr ( i, l ), but | UC i,j | &gt; | UC since i and j have been rated by more common users, so the correlation between them is stronger and sim ( i, j ) should be greater than sim ( i, l ). We consider | UC i,j | in the similarity measure as follows:
We used the sigmoid function to avoid favoring the size of UC i,j too much and to keep the similarity value in the range [0,1]. If the size of the set of common users is big enough, then the first part of equation 7 would converge to 1, but for small sets of common users, the factor would be 0.6. The number 2 in the denominator of the exponent is because we wanted to have a factor of greater than .9 if the size is greater than 5.
At each user u , we have a probability  X  u,i,k of staying at u to select one of his items at step k of the random walk, while we are looking for a prediction on target item i . This prob-ability should be related to the similarities of items rated by u and the target item i . similarity values are real numbers in [0 , 1], so they can also be considered as probabilities. We consider the maximum similarity of items rated by u with target item i as the probability of staying at node u .
Furthermore, ratings on target item i from users far away from source user u 0 are noisy, but ratings expressed by trusted users nearby in the network are more reliable. So, the deeper we go into the network, the probability of contin-uing our random walk should decrease and so  X  u,i,k should increase.

To inject the factor k in  X  u,i,k , we should use a function f ( k ) which gives value 1 for big values of k , and a small value for small values of k . Since the sigmoid function satisfies our constraints for f ( k ), we consider a sigmoid function of the k as another factor affecting  X  u,i,k .
Each random walk has three alternatives to stop: 1. Reaching a node which has expressed a rating on the 2. At some user node u , we decide to stay at the node 3. There is chance for a single random walk to continue
In TrustWalker, we have the probability of selecting items rated by different users and returning that rating as the result of a random walk. These items could be either the exact target item i , or another item. The estimated rating for source user u on target item i would be the expected value of ratings returned by different random walks.
In the above equation, XY u,i is the random variable for stopping the random walk at node v and selecting item j rated by v , while we start the random walk from source user u looking for target item i . Notice that the value for XY are ordered pairs. As used before, R v,j is a boolean variable denoting whether v has a rating on item j . Now we have:
In this equation, X u,i is the random variable for being at node v at some step in a random walk starting from source user u looking for item i . Notice that in above formula, we used  X  u,i instead of  X  u,i,k for the first case. Since we don X  X  know the number of steps needed to reach v , we don X  X  consider the factor k (Actually  X  u,i =  X  u,i,  X  ). It should be noted that if we actually perform random walks, we can con-sider the step k in the first case. But to have a closed form formula, we ignore the factor k at the last user v which gives us a pretty good approximation of the probability. Also, we should note that the case v = u and i = j is trivial since the user himself has the rating on the target item.

A random walk starting from u can reach v using differ-ent number of steps. As mentioned before, we use random variable X u,i,k for being at node v in k steps
Also we have P ( X u,i, 0 = u ) = 1 as the base for the above equation. Since the random walks have a probability of stopping at each step, P ( X u,i,k = v ) a probability distribution, we define a dead state  X  to which all users go after deciding to terminate that random walk. So, we have
This state  X  will be added to U for convenience in formal-ization of our method, but we don X  X  consider this state in any actual random walk. Now, we can compute P ( X u,i = v ) as follows: Similar to any random walk model, we can represent Trust-Walker using matrix notations. We consider a probability u and v for which t u,v = 1 . To formulate the values of  X  u,i,k in matrix notation, we define a diagonal matrix  X  k,i for each item i and step k .  X  k,i is a | U | X | U | matrix con-taining 1  X   X  u,i,k in its diagonal elements. In other words,  X 
It is easy to check that the elements of  X  1 , i P are the probabilities of reaching from u to v in step 1. We can also define a closure on the  X  k , i P as follows: cells. In the above equation, k denotes the current step of each single random walk and K denotes then number of steps each random walk has. Now, we can compute b P i (cor-responding to equation 12) which is the probability matrix containing P ( X u,i = v ) in its elements as follows:
Here, C i is an N  X  N diagonal matrix used for normaliza-tion. The values of the diagonal are C i u,u = 1 P Now we can use b P i to compute P ( X u,i = v ) in equation 12.
If, we do not consider step k as a factor in  X  u,i , it can be proved that P  X  i has a closed formula solution, and this closed as  X  k , i ignoring the factor k . The proof of convergence of equation 13 is a straightforward application of the Perron-Frobenius theorem 6 , and the lemma that all eigenvalues of  X  P are strictly less than one.

Since matrices  X  k , i are different for different k values, we can not find a closed formula for P  X  i . We propose two alter-natives to compute equation 13. This formula can be easily computed. But, there is a prob-lem with the second approach. We have to store P  X  i associ-ated with each item, which is expensive. For example if we have 10K items and 40K users, and each cell of the matrix occupies just one byte, then each matrix P  X  i would occupy almost 1 . 6 GB memory. To store all matrices we would need 16 TB of memory, which is not feasible. This issue motivates performing actual random walk and aggregate the results of different random walks. Moreover, computing this ma-trix needs a global information on the whole network, but TrustWalker can be computed in in a local manner.
Notice that there are major differences between our ran-dom walk model and existing random walk approaches such as [3] and [17]. In PageRank [3], there is a random walk on the links among WebPages, which correspond to users. But there is no item in PageRank and walks do not depend http://en.wikipedia.org/wiki/Perron-Frobenius theorem on the step of the random walk. Moreover, PageRank is a global reputation metric. These differences make PageRank simpler than TrustWalker to find the closed form solution. Nevertheless, they do not compute the closed formula be-cause of the scale of network. In [17], they have an item graph on which they perform the random walk. This graph is independent of users, and hence they do not perform ran-dom walks on users. Also, unlike TrustWalker, their walks are independent of step k of the random walk. Having a simpler model, they are able to compute the closed formula for walking on the item graph.
The results of performing actual random walks approxi-mate the results given by equation 13. We perform several random walks to be able to get a more reliable prediction. We need to be able to decide when we have done enough random walks to have a precise estimate of b r u,i .
We compute the variance in the results of all the walks as follows:
Here, r i is the result of i th random walk, and r denotes the average of the ratings returned by random walks. T is the number of random walks we perform to compute the prediction. We also define  X  2 i as the variance in the results of the first i random walks. Since the values of ratings are in finite range of [1,5], it can be proved 7 that  X  2 converges to a constant value. So we can terminate TrustWalker if |  X 
It should be noted that we have a constant threshold of 10000 for the maximum number of unsuccessful random walks, and after that we consider the pair &lt; user,item &gt; as non-covered.
Our random walk model has some desirable properties, which include generality of the model, confidence in the re-sult, and explainability of predictions.
Our model includes Item-based Collaborative Filtering and pure Trust-based Recommendation as its extreme spe-cial cases. If  X  u,i = 1 for all u  X  U , then our random walk will never start, and it will return the rating expressed by the source user u 0 on one of its rated items. Since the prob-ability of selecting an item is proportional to its similarity to the target item i , the expected value of the recommended rating would be the weighted average of the ratings on items in RI u 0 with weights proportional to the similarities of these items to the target item i . This is the same as the result of Item-based collaborative filtering proposed in [15].
On the other hand, if we set  X  u,i = 0 for all u  X  U , then all random walks will continue until they have found a rat-ing for the exact target item i . The recommended rating would be the aggregation of ratings expressed by users hav-ing the rating on i weighted by the probability of reaching these users from u 0 . Existing methods [5][10] try to approx-imate these probabilities by simplifying the problem. So our
Proof of this claim and convergence of equation 13 are avail-able in www.sfu.ca/  X sja25/trustwalker-proofs.pdf TrustWalker, in one of its extreme cases, can be considered as an ideal trust-based recommender.
As discussed in the introduction, most existing recom-menders do not give users the confidence in their predictions. However, users of a recommender like to know how confident the predicted ratings are. [2] defines a confidence score using the error function for its prediction. Basically, they consider the squared error as the confidence. Their experiments show that predictions with better confidence have higher quality. Our random walk model also has the advantage that it can compute the confidence.

We can use the variance  X  2 to compute our confidence in the predicted rating. The lower the variance  X  2 , the more confident we are in our results. To convert this  X  2 into a value representing the degree of confidence, we employ the following formula: where max X  2 is the maximum possible variance for the re-sults and is used to normalize the variance values. If the rating values are in a finite range and the size of this range is Range , then it is easy to prove that max X  2 = Range 2
Two other factors may also potentially affect the confi-dence: the average number of steps in each random walk k , and the number of random walks. Including k seems to make sense, but our experiments showed that it doesn X  X  make any difference in the precision of results. In other words, the error for predictions with lower k is not much better than the overall error. Regarding the number of random walks, more random walks can lead to more information and more confidence, but can also indicate more noise since it took longer for the results to converge.

Using equation 16, if the results of the random walks are the same, then the variance would be zero, and the confi-dence would be 100%. On the other side, if the variance is very high, then the confidence will be close to 0%.
Explainability means that the recommender system is able to explain how it predicted the rating. There is now a grow-ing recognition that recommender systems must be able to explain and justify the recommendations in order to help users to understand why particular items have been sug-gested.

In our model, to predict b r u,i , we compute P ( X u,i = v ) for all users v . The results of different random walks are from different user. The most frequent users are user with high probability of P ( X u,i = v ). We can output these users as users whose ratings are most influential on the prediction.
Also considering ratings on some items are more frequently used in the results of different random walks. These items are items with high values of P ( XY u,i = ( v, j )).
Now we can use these most frequent users and items to explain why we predicted the rating with b r u,i . We can ex-plain to users that this prediction is based on ratings from these trusted users and these similar items.
This section reports our experimental results on a real life data set comparing various versions of TrustWalker against state of the art methods for trust based and item based rec-ommendation. We implemented TrustWalker as well as the MoleTrust based recommendation proposed by Massa[10] and TidalTrust proposed by Golbeck[5]. We also imple-mented standard User based Collaborative Filtering [6] and Item based Collaborative Filtering [15] as two fundamental similarity based recommendation methods.
Most data sets for recommendation have no social network among users. To best of our knowledge, Epinions X  8 data set is the only data set publicly available which has both trust network and ratings expressed by users.

We used the version of the Epinions X  data set 9 published by the authors of [14]. This data set is very sparse. The data set contains 49k users with at least one rating, out of which 24k users are cold start users. We consider users with less than 5 ratings as cold start users (similar to [10]). We also have 104k items with 575k ratings expressed for them. Finally, we have 508k trust statements among pairs of users. As mentioned above, 49% of users are cold start users which is a huge portion of users. So, considering the performance of the recommendation for cold start users is very impor-tant. The distribution of the number of ratings per users follows a power law. Notice that there exists another ver-sion of the Epinions data set 10 prepared and published by Paolo Massa[10]. We also ran experiments on this data set with very similar results. The data set we used in our ex-periments has additional features which may be helpful for future works.
 We implemented TrustWalker and the other methods in Java. We used an Intel Core2 Duo 2.2 GHz CPU with 2GB RAM to run our experiments on an XP system.

In our experiments, we compare the results for different methods. Following is the description of labels we use to denote each of these algorithms: www.epinions.com http://alchemy.cs.washington.edu/data/epinions/ http://www.trustlet.org/wiki/Epinions dataset
We set  X  = 0 . 0001 for our termination condition.
Typically, the leave-one-out method is used to evaluate recommendation systems [5][10][15]. In the leave-one-out method, we withhold a rating and try to predict it using the trust network and the remaining ratings.

As used in the most recent research papers [17] [7], we use the Root Mean Squared Error (RMSE) to measure the error in recommendation:
In the above equation, R u,i is a boolean showing whether u has a rating on i in our data set, and r u,i and b r u,i note the actual and recommended rating respectively. The smaller the value of RMSE , the more precise a recommen-dation. But, as we discussed before, the purpose of using trust is mostly enhancing the coverage without sacrificing the precision. So we define a coverage metric to measure the percentage of pairs of &lt; user,item &gt; for which we can predict a rating.

To combine RMSE and coverage into a single evaluation metric, we compute the FMeasure (Coverage has been al-ready defined in section 2). For this purpose, we have to convert RMSE into a precision metric in the range [0,1]. So we define precision as follows:
In this equation, 4 is the maximum possible error since the values of ratings are in the range [1 , 5].

If none of the random walks can find a prediction on the rating, then we say that the recommender can not cover this pair of &lt; user,item &gt; .
In this subsection, we present the results of our experi-ments, first for cold-start users and then for all users.
Table 2 shows the RMSE, Coverage, and F-Measure for all comparison partners for cold start users. Figures 2 and 3 show the charts comparing the results of different methods according to each of three evaluation measures separately.
As shown in figure 2, TrustWalker has lower error than all the other methods except for RandomWalk1 . But accord-ing to table 2, RandomWalk1 has extremely low coverage (12%). The comparison between TrustWalker and Trust-Walker0 shows that considering the step k in  X  u,i reduces the error. Also comparing the RMSE of TrustWalker and TrustWalker-pure shows that considering the size of the set of common users in the item similarity metric reduces the error.

Figure 3 shows the F-Measure together with precision and coverage for all methods. It shows that all four versions of Figure 2: Comparison of RMSE for different methods TrustWalker outperform all other methods according to the combination of precision and coverage. Notice that Tidal-Trust[5] outperforms all versions of our model in terms of precision except for the full TrustWalker which has a slightly lower error. However, TrustWalker X  X  coverage is 13% more than that of TidalTrust, which makes TrustWalker better in terms of F-Measure.

The results for all users are shown in table 3. Figure 4 shows the results of different methods according to each of the three evaluation measures on all users. We observe similar relative performance of all methods as for cold start users. It should be noted that all methods perform signif-icantly better over all users since there is less information available for cold start users. TrustWalker outperforms all other methods in terms of F-Measure, although the gain for all users is less than the gain for cold start users. Notice that the errors of both TidalTrust and MoleTrust for All users are very close to TrustWalker, but TrustWalker clearly has a better coverage.

In summary, TrustWalker substantially improves the cov-erage of existing trust-based approaches while maintaining the same or even slightly better precision. This improvement is achieved by considering ratings for similar items as well as Figure 3: Comparison of Coverage and Precision to-Figure 4: Comparison of evaluation measures for differ-the exact target item. TrustWalker also clearly outperforms Collaborative Filtering (both user-based and item-based) in terms of coverage because of exploiting the trust-network in its random walks. Moreover, TrustWalker clearly out-performs Collaborative Filtering methods in terms of pre-cision due to the restriction to ratings from highly trusted users. Since cold start users have only a few ratings, the improvement of coverage using trust-based approaches (spe-cially TrustWalker) compared to Collaborative Filtering is much more for cold start users than for all users.
For example, TrustWalker X  X  coverage is 74% for cold start users while Collaborative Filtering approaches have coverage of 18% and 23%. But in case of all users, TrustWalker X  X  cov-erage is 95% while Collaborative Filtering approaches have coverage of 71%. TidalTrust and MoleTrust have coverage of 84% and 82% respectively for cold start users while their coverage is 61% and 57% in case of all users.

To evaluate the meaningfulness of our definition of con-fidence, we compare the error of TrustWalker for different percentiles of most confident predictions (for both Cold Start and All users) in figure 5. As shown in this figure, the more confident the predictions are the more precise the results will be and hence the lower the RMSE. For example, the difference between the RMSE of the top 50% confident pre-dictions and all predictions is 0.18 for cold start users. As an evidence for the significance of these RMSE reductions, note that in the Netflix prize competition 11 , there is a $1 Million reward for a reduction of the RMSE by 10% (around 0.1).
Recommender systems are emerging as tools of choice to http://www.netflixprize.com Figure 5: The effect of confidence on the precision of recommendations. The horizontal axis shows per-centile of most confident predictions from dataset. select the online information relevant to a given user. Col-laborative filtering is the most popular approach to building recommender systems and has been successfully employed in many applications. However, it cannot make recommen-dations for so-called cold start users that have rated only a very small number of items. Collaborative filtering meth-ods are rather vulnerable to attacks that insert fraudulent user profiles into the database. Finally, these methods do not know how confident they are in their recommendations. Trust-based recommender systems can better deal with cold start users, since users only need to be simply connected to the trust network. The trust-based approach is also much more robust to fraudulent attacks.

On the other hand, the sparsity of the user item ratings forces the trust-based approach to consider ratings of in-direct neighbors that are only weakly trusted, which may decrease its precision. In order to address this problem, we proposed the random walk model TrustWalker to combine the trust-based and the item-based collaborative filtering ap-proach to recommendation. TrustWalker considers not only ratings of the target item, but also those of similar items, with probability increasing with increasing length of the walk. As another contribution, TrustWalker allows us to de-fine and to measure the confidence of a recommendation. We performed an evaluation on the Epinions dataset, demon-strating that TrustWalker outperforms both collaborative filtering methods and purely trust-based methods specially in terms of coverage. Also TrustWalker has a slightly better precision compared to other Trust-based approaches while clearly outperforming Collaborative Filtering approaches in terms od precision. We also showed that highly confident recommendations are of even greater quality.

This work suggests several interesting directions for future work. We want to evaluate TrustWalker on other data sets as soon as they become available. Besides the problem of predicting a rating for a given item, recommending a list of items to a user is also a natural task for recommenders. We plan to investigate the extension of the TrustWalker model for this task. In this paper and in the related work, the ratings are assumed to be stored in a centralized repos-itory. However, applications such as mobile phone-based social networks require a distributed recommender, and a random walk model is a promising approach for such sce-narios. The trust concept we considered in this paper is context independent. However, people may trust other peo-ple in some context while they do not trust those people in other contexts. Investigating context-based trust models for recommendations is also an interesting direction for future work.
We are very grateful to Samaneh Moghaddam for her use-ful comments and for proof reading this paper. [1] R. Andersen, C. Borgs, J. Chayes, U. Feige, [2] R. M. Bell, Y. Koren, and C. Volinsky. Modeling [3] S. Brin and L. Page. The anatomy of a large-scale [4] D. Crandall, D. Cosley, D. Huttenlocher, J. Kleinberg, [5] J. Golbeck. Computing and Applying Trust in [6] D. Goldberg, D. Nichols, B. M. Oki, and D. Terry. [7] Y. Koren. Factorization meets the neighborhood a [8] Levien and Aiken. Advogato X  X  trust metric. online at [9] H. Ma, H. Yang, M. R. Lyu, and I. King. Sorec: social [10] P. Massa and P. Avesani. Trust-aware recommender [11] S. Milgram. The small world problem. Psychology [12] J. O X  X onovan and B. Smyth. Trust in recommender [13] A. Rettinger, M. Nickles, and V. Tresp. A statistical [14] M. Richardson and P. Domingos. Mining [15] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl. [16] S. Wasserman and K. Faust. Social Network Analysis . [17] H. Yildirim and M. S. Krishnamoorthy. A random [18] C. N. Ziegler. Towards Decentralized Recommender
