 Automatic template-filling-based event extraction is an important and challenging task. Consider the fol-lowing text span that describes an  X  X ttack X  event:
A partial event template for the  X  X ttack X  event is shown on the left of Figure 1. Each row shows an argument for the event, together with a set of its ac-ceptable mention types, where the type specifies a high-level semantic class a mention belongs to.
The task is to automatically fill the template en-tries with texts extracted from the text span above. The correct filling of the template for this particular example is shown on the right of Figure 1.

Performing such a task without any knowledge about the semantics of the texts is hard. One typi-cal assumption is that certain coarse mention-level information, such as mention boundaries and their semantic class (a.k.a. types ), are available. E.g.:
Such mention type information as shown on the left of Figure 1 can be obtained from various sources such as dictionaries, gazetteers, rule-based systems (Str  X  otgen and Gertz, 2010), statistically trained clas-sifiers (Ratinov and Roth, 2009), or some web re-sources such as Wikipedia (Ratinov et al., 2011).
However, in practice, outputs from existing men-tion identification and typing systems can be far from ideal. Instead of obtaining the above ideal an-notation, one might observe the following noisy and ambiguous annotation for the given event span:
Our task is to design a model to effectively select mentions in an event span and assign them with cor-responding argument information, given such coarse and often noisy mention type annotations.

This work addresses this problem by making the following contributions:  X  Naturally, we are interested in identifying the  X  We address the problem in a more realistic sce-
We present our semi-Markov model and discuss our preference modeling framework in Section 2 and 3 respectively. We then discuss the model X  X  relation with existing constraint-driven learning frameworks in Section 4. Finally, we demonstrate through ex-periments that structured preference information is crucial to model and present empirical results on a standard dataset in Section 5. It is not hard to observe from the example presented in the previous section that dependencies between arguments can be important and need to be properly modeled. This motivates us to build a joint model for extracting the event structures from the text.
We show a simplified graphical representation of our model in Figure 2. In the graph, C 1 ,C 2 ...C n refer to a particular segmentation of the event span, where C 1 , C 3 . . . correspond to mentions (e.g.,  X  North Korea X  X  military  X ,  X  a laser  X ) and C 2 , C 4 . . . correspond to in-between mention word se-quences (we call them gaps ) (e.g.,  X  may have fired  X ). The symbols T 1 ,T 3 ... refer to mention types (e.g., G PE , O RG ). The symbols A 1 ,A 3 ... re-fer to event arguments that carry specific roles (e.g., A
TTACKER ). We also introduce symbols B 2 ,B 4 ... to refer to inter-argument gaps. The event span is split into segments, where each segment is either linked to a mention type ( T i ; these segments can be referred to as  X  X rgument segments X ), or directly linked to an inter-argument gap ( B j ; they can be referred to as  X  X ap segments X ). The two types of segments appear in the sequence in a strictly alter-nate manner, where the gaps can be of length zero. In the figure, for example, the segments C 1 and C 3 are identified as two argument segments (which are mentions of types T 1 and T 3 respectively) and are mapped to two  X  X odes X , and the segment C 2 is iden-tified as a gap segment that connects the two argu-ments A 1 and A 3 . Note that no overlapping argu-ments are allowed in this model 1 .

We use s to denote an event span and t to denote a specific realization (filling) of the event template. Templates consist of a set of arguments. Denote by h a particular mention boundary and type assignment for an event span, which gives us a specific segmen-tation of the given span. Following the conditional random fields model (Lafferty et al., 2001), we pa-rameterize the conditional probability of the ( t,h ) pair given an event span s as follows: where f gives the feature functions defined on the tuple ( s,h,t ) , and  X  defines the parameter vector.
Our objective function is the logarithm of the joint conditional probability of observing the template re-alization for the observed event span s :
This function is not convex due to the summation over the hidden variable h . To optimize it, we take its partial derivative with respect to  X  j : which requires computation of expectations terms under two different distributions. Such statistics can be collected efficiently with a forward-backward style algorithm in polynomial time (Okanohara et al., 2006). We will discuss the time complexity for our case in the next section.

Given its partial derivatives in Equation 3, one could optimize the objective function of Equation 2 with stochastic gradient ascent (LeCun et al., 1998) or L-BFGS (Liu and Nocedal, 1989). We choose to use L-BFGS for all our experiments in this paper.
Inference involves computing the most probable template realization t for a given event span: arg max where the possible hidden assignments h need to be marginalized out. In this task, a particular realiza-tion t already uniquely defines a particular segmen-tation (mention boundaries) of the event span, thus the h only contributes type information to t . As we will discuss in Section 2.3, only a collection of local features are defined. Thus, a Viterbi-style dynamic programming algorithm is used to efficiently com-pute the desired solution. 2.1 Possible Segmentations According to Equation 3, summing over all possi-ble h is required. Since one primary assumption is that we have access to the output of existing mention identification and typing systems, the set of all possi-ble mentions defines a lattice representation contain-ing the set of all possible segmentations that com-ply with such mention-level information. Assuming there are A possible arguments for the event and K annotated mentions, the complexity of the forward-backward style algorithm is in O ( A 3 K 2 ) under the  X  X econd-order X  setting that we will discuss in Sec-tion 2.2. Typically, K is smaller than the number of words in the span, and the factor A 3 can be regarded as a constant. Thus, the algorithm is very efficient.
As we have mentioned earlier, such coarse infor-mation, as produced by existing resources, could be highly ambiguous and noisy. Also, the output men-tions can highly overlap with each other. For exam-ple, the phrase  X  North Korea  X  as in  X  North Korea X  X  military  X  can be assigned both type G PE and L OC , while  X  North Korea X  X  military  X  can be assigned the type O RG . Our model will need to disambiguate the mention boundaries as well as their types. 2.2 The Gap Segments We believe the gap segments 2 are important to model since they can potentially capture depen-dencies between two or more adjacent arguments. For example, the word sequence  X  may have fired  X  clearly indicates an Attacker-Instrument relation be-tween the two mentions  X  North Korea X  X  military  X  and  X  a laser  X . Since we are only interested in modeling dependencies between adjacent argument segments, we assign hard labels to each gap seg-ment based on its contextual argument informa-tion. Specifically, the label of each gap segment is uniquely determined by its surrounding argu-ment segments with a list representation. For ex-ample, in a  X  X irst-order X  setting, the gap segment that appears between its previous argument seg-ment  X  X  TTACKER  X  and its next argument segment  X  X 
NSTRUMENT  X  is annotated as the list consisting of two elements: [A TTACKER , I NSTRUMENT ]. To capture longer-range dependencies, in this work we use a  X  X econd-order X  setting (as shown in Figure 2), which means each gap segment is annotated with a list that consists of its previous two argument seg-ments as well as its subsequent one. 2.3 Features Feature functions are factorized as products of two indicator functions: one defined on the input se-quence (input features) and the other on the output labels (output features). In other words, we could re-write f j ( s,h,t ) as f in k ( s )  X  f out l ( h,t ) .
For gap segments, we consider the following in-put feature templates: and the following output feature templates:
For argument segments, we also define the same input feature templates as above, with the following additional ones to capture contextual information: and we define the following output feature template:
Although the semi-Markov CRF model gives us the flexibility in introducing features that can not be exploited in a standard CRF, such as entity name similarity scores and distance measures, in prac-tice we found the above simple and general features work well. This way, the unnormalized score as-signed to each structure is essentially a linear sum of the feature weights, each corresponding to an in-dicator function. The supervised model presented in the previous sec-tion requires substantial human efforts to annotate the training instances. Human annotations can be very expensive and sometimes impractical. Even if annotators are available, getting annotators to agree with each other is often a difficult task in itself. Worse still, annotations often can not be reused: ex-perimenting on a different domain or dataset typi-cally require annotating new training instances for that particular domain or dataset.

We investigate inexpensive methods to alleviate this issue in this section. We introduce a novel gen-eral learning framework called structured preference modeling , which allows arbitrary prior knowledge about structures to be introduced to the learning pro-cess in a declarative manner. 3.1 Structured Preference Modeling Denote by X  X  and Y  X  the entire input and output space, respectively. For a particular input x  X  X  X  , the set x  X Y  X  gives us all possible structures that contain x . However, structures are not equally good. Some structures are generally regarded as better structures while some are worse.

Let X  X  asume there is a function  X  : x  X Y  X   X  [0 , 1] that measures the quality of the structures. This function returns the quality of a certain struc-ture ( x,y ) , where the value 1 indicates a perfect structure, and 0 an impossible structure.

Under such an assumption, it is easy to observe that for a good structure ( x,y ) , we have p  X  ( x,y )  X   X  ( x,y ) = p  X  ( x,y ) , while for a bad structure ( x,y ) , we have p  X  ( x,y )  X   X  ( x,y ) = 0 .

This motivates us to optimize the following objec-tive function:
Intuitively, optimizing such an objective function is equivalent to pushing the probability mass from bad structures to good structures corresponding to the same input.

When the preference function  X  is defined as the indicator function for the correct structure ( x i ,y i ) , the numerator terms of the above formula are simply of the forms p  X  ( x i ,y i ) , and the model corresponds to the fully supervised CRF model.

The model also contains the latent-variable CRF as a special case. In a latent-variable CRF, we have input-output pairs ( x i ,y i ) , but the underlying spe-cific structure h that contains both x i and y i is hid-den. The objective function is: where p  X  ( x i ,h,y i ) = 0 unless h contains ( x i ,y i We define the following two functions:
Note that this definition of  X  models instance-specific preferences since it relies on y i , which can be thought of as certain external prior knowledge re-lated to x i . It is easy to verify that p  X  ( x i ,h,y i q ( x i ,h )  X   X  ( x i ,h ) , with q  X  remains a distribution. Thus, we could re-write the objective function as:
This shows that the latent-variable CRF is a spe-cial case of our objective function, with the above-defined  X  function. Thus, this new objective func-tion of Equation 5 is a generalization of both the su-pervised CRF and the latent-variable CRF.

The preference function  X  serves as a source from which certain prior knowledge about the structure can be injected into our model in a principled way. Note that the function is defined at the complete structure level. This allows us to incorporate both local and arbitrary global structured information into the preference function.
 Under the log-linear parameterization, we have:
This is again a non-convex optimization problem in general, and to solve it we take its partial deriva-tive with respect to  X  k : 3.2 Approximate Learning Computation of the denominator terms of Equation 10 (and the second term of Equation 11) can be done efficiently and exactly with dynamic programming. Our main concern is the computation of its numera-tor terms (and the first term of Equation 11).
The preference function  X  is defined at the com-plete structure level. Unless the function is defined in specific forms that allow tractable dynamic pro-gramming (in the supervised case, which gives a unique term, or in the hidden variable case, which can define a packed representations of derivations), the efficient dynamic programming algorithm used by CRF is no longer generally applicable for arbi-trary  X  . In general, we resort to approximations.
In this work, we exploit a specific form of the preference function  X  . We assume that there exists a projection from another decomposable function to  X  . Specifically, we assume a collection of auxiliary functions, each of the form  X  p : ( x,y )  X  R , that scores a property p of the complete structure ( x,y ) . Each such function measures certain aspect of the quality of the structure. These functions assign pos-itive scores to good structural properties and nega-tive scores to bad ones. We then define  X  ( x,y ) = 1 for all structures that appear at the top-n positions as ranked by P p  X  p ( x,y ) for all possible y  X  X , and  X  ( x,y ) = 0 otherwise. We show some actual  X  p functions used for a particular event in Section 5.
At each iteration of the training process, to gen-erate such a n -best list, we first use our model to produce top n  X  b candidate outputs as scored by the current model parameters, and extract the top n outputs as scored by P p  X  p ( x,y ) . In practice we set n = 10 and b = 1000 . 3.3 Event Extraction Now we can obtain the objective function for our event extraction task. We replace x by s and y by ( h,t ) in Equation 10. This gives us the following function: L u ( X ) =
The partial derivatives are as follows:
Recall that s is an event span, t is a specfic re-alization of the event template, and h is the hidden mention information for the event span. Note that the objective function in Equation 5, if written in the additive form, leads to a cost func-tion reminiscent of the one used in constraint-driven learning algorithm (CoDL) (Chang et al., 2007) (and similarly, posterior regularization (Ganchev et al., 2010), which we will discuss later at Section 6). Specifically, in CoDL, the following cost function is involved in its EM-like inference procedure: where Y c defines the set of y  X  X  that all satisfy a cer-tain constraint c , and d defines a distance function from y to that set. The parameter  X  controls the de-gree of the penalty when constraints are violated.
There are some important distinctions between structured preference modeling (PM) and CoDL. CoDL primarily concerns constraints , which pe-nalizes bad structures without explicitly rewarding good ones. On the other hand, PM concerns prefer-ences , which can explicitly reward good structures.
Constraints are typically useful when one works on structured prediction problems for data with cer-tain (often rigid) regularities, such as citations, ad-vertisements, or POS tagging for complete sen-tences. In such tasks, desired structures typically present certain canonical forms. This allows declar-ative constraints to be specified as either local struc-ture prototypes (e.g., in citation extraction, the word pp . always corresponds to the P AGES field, while proceedings is always associated with B OOKTITLE or J OURNAL ), or as certain global regulations about complete structures (e.g., at least one word should be tagged as verb when performing a sentence-level POS tagging).

Unfortunately, imposing such (hard or soft) con-straints for certain tasks such as ours, where the data tends to be of arbitrary forms without many rigid regularities, can be difficult and often inappropri-ate. For example, there is no guarantee that a cer-tain argument will always be present in the event span, nor should a particular mention, if appeared, always be selected and assigned to a specific argu-ment. For example, in the example event span given in Section 1, both  X  March  X  and  X  Tuesday  X  are valid candidate mentions for the T IME -W ITHIN argument given their annotated type T ME . One important clue is that March appears after the word in and is lo-cated nearer to other mentions that can be poten-tially useful arguments. However, encoding such information as a general constraint can be inappro-priate, as potentially better structures can be found if one considers other alternatives. On the other hand, if we believe the structural pattern  X  at T AR -GET in T IME -W ITHIN  X  is in general considered a better sub-structure than  X  said T IME -W ITHIN  X  for the  X  X ttack X  event, we may want to assign structured preference to a complete structure that contains the former, unless there exist other structured evidence showing the latter turns out to be better.

In this work, our preference function is related to another function that can be decomposed into a collection of property functions  X  p . Each of them scores a certain aspect of the complete structure. This formulation gives us a complete flexibility to assign arbitrary structured preferences, where posi-tive scores can be assigned to good properties, and negative scores to bad ones. Thus, in this way, the quality of a complete structure is jointly measured with multiple different property functions.

To summarize, preferences are an effective way to  X  X efine X  the event structure to the learner, which is essential in an unsupervised setting, which may not be easy to do with other forms of constraints. Prefer-ences are naturally decomposable, which allows us to extend their impact without significantly effecting the complexity of inference. In this section, we present our experimental results on the standard ACE05 3 dataset (newswire portion). We choose to perform our evaluations on 4 events (namely,  X  X ttack X ,  X  X eet X ,  X  X ie X  and  X  X ransport X ), which are the only events in this dataset that have more than 50 instances. For each event, we ran-domly split the instances into two portions, where 70% are used for learning, and the remaining 30% for evaluation. We list the corpus statistics in Table 2.

To present general results while making minimal assumptions, our primary event extraction results are independent of mention identification and typing modules, which are based on the gold mention in-formation as given by the dataset. Additionally, we present results obtained by exploiting our in-house automatic mention identification and typing mod-ule, which is a hybrid system that combines statis-tical and rule-based approaches. The module X  X  sta-tistical component is trained on the ACE04 dataset (newswire portion) and overall it achieves a micro-averaged F1-measure of 71.25% at our dataset. 5.1 With Annotated Training Data With hand-annotated training data, we are able to train our model in a fully supervised manner. The right part of Table 1 shows the performance for the fully supervised models. For comparison, we present results from several alternative approaches based a collection of locally trained maximum en-tropy (MaxEnt) classifiers. In these approaches, we treat each argument of the template as one possi-ble output class, plus a special  X  X  ONE  X  class for not selecting it as an argument. We train and apply the classifiers on argument segments (i.e., mentions) only. All the models are trained with the same fea-ture set used in the semi-CRF model.

In the simplest baseline approach MaxEnt-b, type information for each mention is simply treated as one special feature. In the approach MaxEnt-t, we instead use the type information to constrain the classifier X  X  predictions based on the acceptable types associated with each argument. This approach gives better performance than that of MaxEnt-b. This in-dicates that such locally trained classifiers are not robust enough to disambiguate arguments that take different types. As such, type information serving as additional constraints at the end does help.
To assess the importance of structured preference, we also perform experiments where structured pref-erence information is incorporated at the inference time of the MaxEnt classifiers. Specifically, for each event, we first generate n -best lists for output struc-tures. Next, we re-rank this list based on scores from our structured preference functions (we used the same preferences as to be discussed in the next section). The results for these approaches are given in the column of MaxEnt-p of Table 1. This simple approach gives us significant improvements, clos-ing the gap between locally trained classifiers and the joint model (in one case the former even out-performs the latter). Note that no structured pref-erence information is used when training and eval-uating our semi-CRF model. This set of results is not surprising. In fact, similar observations are also reported in previous works when comparing joint model against local models with constraints incor-porated (Roth and Yih, 2005). This clearly indicates that structured preference information is crucial to model. 5.2 Without Annotated Training Data Now we turn to experiments for the more realistic scenario where human annotations are not available.
We first build our simplest baseline by randomly assigning arguments to each mention with mention type information serving as constraints. Averaged results over 1000 runs are reported in the first col-umn of Table 1.

Since our model formulation leaves us with com-plete freedom in designing the preference function, one could design arbitrarily good, domain-specific or even instance-specific preferences. However, to demonstrate its general effectiveness, in this work we only choose a minimal amount of general prefer-ence patterns for evaluations.

We make our preference patterns as general as possible. As shown in the last column (#P) of Table 2, we use only 7 preference patterns each for the  X  X t-tack X  and  X  X eet X  events, and 6 patterns each for the other two events. In Figure 3, we show the complete list of the 6 preference patterns for the  X  X ie X  and  X  X ransport X  event used for our experiments. Out of those 6 patterns, 2 are more general patterns shared across different events, and 4 are event-specific. In contrast, for example, for the  X  X ie X  event, the super-vised approach requires human to select from 174 candidate mentions and annotate 89 of them.

Despite its simplicity, it works very well in prac-tice. Results are given in the column of  X  X M X  of Table 1. It generally gives competitive performance as compared to the supervised MaxEnt baselines.
On the other hand, a completely unsupervised ap-proach where structured preferences are not speci-fied, performs substantially worse. To run such com-pletely unsupervised models, we essentially follow the same training procedure as that of the prefer-ence modeling, except that structured preference in-formation is not in place when generating the n -best list. In the absence of proper guidances, such a pro-cedure can easily converge to bad local minima. The results are reported in the  X  X nsup X  column of Ta-ble 1. In practice, we found that very often, such a model would prefer short structures where many mentions are not selected as desired. As a result, the unsupervised model without preference information can even perform worse than the random baseline 4 .
Finally, we also compare against an approach that regards the preferences as rules. All such rules are associated with a same weight and are used to jointly score each structure. We then output the structure that is assigned the highest total weight. Such an ap-proach performs worse than our approach with pref-erence modeling. The results are presented in the column of  X  X ule X  of Table 1. This indicates that our model is able to learn to generalize with features through the guidance of our informative preferences. However, we also note that the performance of pref-erence modeling depends on the actual quality and amount of preferences used for learning. In the ex-treme case, where only few preferences are used, the performance of preference modeling will be close to that of the unsupervised approach, while the rule-based approach will yield performance close to that of the random baseline.

The results with automatically predicted mention boundaries and types are given in Table 3. Simi-lar observations can be made when comparing the performance of preference modeling with other ap-proaches. This set of results further confirms the ef-fectiveness of our approach using preference model-ing for the event extraction task. Structured prediction with limited supervision is a popular topic in natural language processing.
Prototype driven learning (Haghighi and Klein, 2006) tackled the sequence labeling problem in a primarily unsupervised setting. In their work, a Markov random fields model was used, where some local constraints are specified via their prototype list .
Constraint-driven learning (CoDL) (Chang et al., 2007) and posterior regularization (PR) (Ganchev et al., 2010) are both primarily semi-supervised mod-els. They define a constrained EM framework that regularizes posterior distribution at the E-step of each EM iteration, by pushing posterior distributions towards a constrained posterior set. We have already discussed CoDL in Section 4 and gave a comparison to our model. Unlike CoDL, in the PR framework constraints are relaxed to expectation constraints , in order to allow tractable dynamic programming. See also Samdani et al. (2012) for more discussions.
Contrastive estimation (CE) (Smith and Eisner, 2005a) is another log-linear framework for primar-ily unsupervised structured prediction. Their objec-tive function is related to the pseudolikelihood es-timator proposed by Besag (1975). One challenge is that it requires one to design a priori an effective neighborhood (which also needs to be designed in certain forms to allow efficient computation of the normalization terms) in order to obtain optimal per-formance. The model has been shown to work in un-supervised tasks such as POS induction (Smith and Eisner, 2005a), grammar induction (Smith and Eis-ner, 2005b), and morphological segmentation (Poon et al., 2009), where good neighborhoods can be identified. However, it is less intuitive what consti-tutes a good neighborhood in this task.

The neighborhood assumption of CE is relaxed in another latent structure approach (Chang et al., 2010a; Chang et al., 2010b) that focuses on semi-supervised learning with indirect supervisions, in-spired by the CoDL model described above.
 The locally normalized logistic regression (Berg-Kirkpatrick et al., 2010) is another recently proposed framework for unsupervised structured prediction. Their model can be regarded as a generative model whose component multinomial is replaced with a miniature logistic regression where a rich set of local features can be incorporated. Empirically the model is effective in various unsupervised structured pre-diction tasks, and outperforms the globally normal-ized model. Although modeling the semi-Markov properties of our segments (especially the gap seg-ments) in our task is potentially challenging, we plan to investigate in the future the feasibility for our task with such a framework. In this paper, we present a novel model based on the semi-Markov conditional random fields for the challenging event extraction task. The model takes in coarse mention boundary and type information and predicts complete structures indicating the cor-responding argument role for each mention.

To learn the model in an unsupervised manner, we further develop a novel learning approach called structured preference modeling that allows struc-tured knowledge to be incorporated effectively in a declarative manner.

Empirically, we show that knowledge about struc-tured preference is crucial to model and the prefer-ence modeling is an effective way to guide learn-ing in this setting. Trained in a primarily unsuper-vised manner, our model incorporating structured preference information exhibits performance that is competitive to that of some supervised baseline ap-proaches. Our event extraction system and code will be available for download from our group web page. We would like to thank Yee Seng Chan, Mark Sam-mons, and Quang Xuan Do for their help with the mention identification and typing system used in this paper. We gratefully acknowledge the sup-port of the Defense Advanced Research Projects Agency (DARPA) Machine Reading Program un-der Air Force Research Laboratory (AFRL) prime contract no. FA8750-09-C-0181. Any opinions, findings, and conclusions or recommendations ex-pressed in this material are those of the authors and do not necessarily reflect the view of DARPA, AFRL, or the US government.
