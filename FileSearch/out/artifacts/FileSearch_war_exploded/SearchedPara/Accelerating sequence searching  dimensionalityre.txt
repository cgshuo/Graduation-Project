 Guojie Song  X  Bin Cui  X  Baihua Zheng  X  Kunqing Xie  X  Dongqing Yang Abstract Similarity search over long sequence dataset becomes increasingly popular in many emerging applications, such as text retrieval, genetic sequences exploring, etc. In this paper, a novel index structure, namely Sequence Embedding Multiset tree ( SEM-tree ) ,has been proposed to speed up the searching process over long sequences. The SEM-tree is a multi-level structure where each level represents the sequence data with different com-pression level of multiset, and the length of multiset increases towards the leaf level which contains original sequences. The multisets, obtained using sequence embedding algorithms, have the desirable property that they do not need to keep the character order in the sequence, i.e. shorter representation, but can reserve the majority of distance information of sequences. Each level of the tree serves to prune the search space more efficiently as the multisets utilize the predicability to finish the searching process beforehand and reduce the computational cost greatly. A set of comprehensive experiments are conducted to evaluate the performance of the SEM-tree, and the experimental results show that the proposed method is much more efficient than existing representative methods.
 Keywords Sequence similarity search  X  Sequence embedding  X  Index  X  Dimension reduction 1 Introduction Indexing technologies, which were originally proposed to speed up data search performance, have been successfully applied in many areas of data processing. Some of the index structures have even been used in commercial database systems, e.g. B + -tree [ 3 ]. However, none of the existing indexes is universally efficient since the performance of an index structure is highly dependent on the underlying data.

Similarity search is an important common operation for many applications, such as text retrieval, handwriting recognition, and multimedia search. Recently, similarity search over long sequences attracts more attentions due to some new emerging applications. As illustrated in [ 20 ], in computational biology, searching for specific sequences over DNA and protein sequences appears as a fundamental operation for problems such as assembling the DNA chain from the pieces obtained by the experiments, looking for given features in DNA chains and determining how different two genetic sequences were. In such applications, the problem of sequence similarity search is typically based on block edit distance with move [ 4 ]. Block edit distance with move is the minimum cost transformation from one sequence to another through a series of edit operations (insert, delete, move) on block characters. It is another kind of distance metric except for character edit distance, and is widely used in computational biology and text processing environments. Due to the great length of sequences which can be up to thousands, similarity search is an expensive operation.

Many index structures have been proposed to handle similar sequence search problems, such as suffix trees and vector space indexing. Suffix tree based index structures [ 10 ]have been gaining favor as the methods for sequence search, but they consume too much memory space. Classical indexing techniques can be used for sequence search, such as R*-trees [ 21 ], X-trees [ 27 ] and SR-trees [ 31 ], etc. They typically perform well in low to medium dimen-sional spaces (up to 20 X 30 dimensions), but their performance deteriorates drastically for long sequence match. Differently, embedding based index techniques, such as FastMap [ 6 ], have also been proposed to decrease computational cost. However, it has to scan the original sequence dataset in order to construct embedded space. Since the distance computation in the original string space is very expensive, the construction of the embedded space is impractical. Furthermore, the approximate factor keeps increasing as the data size expands, rendering this approach unworkable for large sequence databases.

In this paper, we proposed a novel index structure, namely SEM-tree , to facilitate effi-cient similarity sequence search. Our strategy is to replace the expensive full sequence sim-ilarity computation with the comparison over shorter multisets, which are embedded from sequences. Thereafter, as a compressed representation of sequence, multiset enables much faster distance computation. Moreover, the distance comparison is dependent on the number of distinct characters that form the sequence set, instead of the length of the sequence. As a sequence set usually has a finite set of distinct characters, it can be assumed that the compu-tation is bounded by a constant. Another interesting characteristic is its predicability, which means that query processing in an interval node can predict whether the sub-tree is included in final results, so as to stop the recursion process beforehand. Lastly, although the distance over multisets is an approximation of the real distance between original sequences, we can exploit the boundary of the approximations [ 4 ] to avoid false negative. The main contribution of this work is four-fold.  X  To reduce the computational cost for long sequences X  comparison, we adopted sequence  X  Just as the well-known PCA [ 11 ]andSVD[ 8 ] methods, sequence oriented dimension- X  A novel index structure, SEM-tree, is proposed by using SDR techniques developed to  X  AcomprehensivesimulationhasbeenconductedtoevaluatetheperformanceofSEM-tree.

A preliminary version of this paper appears in [ 25 ], where we presented the basic idea. In this paper, we make the following additional contributions. First, we provide more detailed description of the framework, including tree construction and query processing. Second, we present the details of proof and analysis for applying SDB techniques in our work. Further-more, we run a more comprehensive set of experiments to demonstrate the effectiveness of the SEM-tree using different datasets.

The paper is organized as follows. In Sect. 2 , we introduce related works. In Sect. 3 ,we review the basic sequence embedding technique and design the sequence dimension reduction mechanism based on multiset, followed by the structure of SEM-tree and detailed algorithms. Experimental results are presented in Sect. 4 . Finally, we conclude this paper in Sect. 5 . 2 Related work In this section, we first briefly review related work, and then analyze the limitations of the existing data structures.
 Many heuristic-based search methods have been developed to conduct sequence search. They fall into two categories: hash-table based methods and suffix-tree-based methods. Some of the important hash-table-based methods are FASTA [ 22 ]andBLAST[ 32 ]. These tech-niques are similar in spirit: they construct a hash table on one of the strings, and insert all substrings of a certain length l . The tools start by finding exactly matching substrings (known as seeds) of length l using this hash table. In the second phase, the seeds are extended in both directions, and combined, if possible, in order to find better alignments. Current hash-table-based search tools handle short queries well, but become very inefficient, in terms of both time and space, for long queries. Suffix trees were first proposed by Weiner [ 30 ] under the were developed. However, there are two significant problems with the suffix-tree approach: (1) suffix trees manage mismatches inefficiently, and (2) they are notorious for their excessive indexing techniques and dimension reduction methods have also been proposed for dealing with time-series dataset [ 12 , 14  X  16 , 23 ], however they are not much suitable for sequence data comprised by character set.

Vector space based indexing is another kind of method. The VP-tree [ 31 ] partitions the data space into spherical cuts by selecting random reference points from the data. A second method, the MVP-Tree [ 9 ] (a variation of VP-Tree) uses more than one vantage point at each level.Reference[ 24 ]usestheVP-Treetoindexmeasuresthatarealmostmetric.Intherecently proposed reference-based sequence indexing methods [ 7 , 12 , 27 ], reference sequences are selected from the convex hull of the dataset, which is done by selecting sequences that are far away from each other. All these methods are based on the original sequence space and are still inefficient for high dimensional data.

Embedding based index techniques, such as FastMap [ 6 ] and MetricMap [ 29 ], have also been proposed to decrease the computational cost. However, both approaches ask for a distance-preserving mapping function. Finding a suitable mapping is a tough and time-con-suming process, and no such function is available for block edit distance. Additionally, it has to scan the original sequence space in order to construct embedded space, making the construction of the embedded space impractical in our case.

Recently proposed indexing techniques, such as M-trees [ 2 ], Slim-tree [ 28 ] and DBM-tree [ 26 ], can be used to support sequence search. The M-tree is a height-balanced tree, where the data elements are stored in leaf nodes. The Slim-Tree is an evolution of the M-Tree, embody-ing the first published technique to reduce the amount of overlap between tree nodes, which leads to a smaller number of disk accesses to answer similarity queries. These two structures are height balanced and attempt to reduce the height of the tree at the expense of flexibility in reducing overlap between nodes. This constraint was released in the DBM-Tree by reducing the overlap between nodes in high density regions, resulting in an unbalanced tree. 3 The SEM-tree Handling similarity search over long sequence has always been a challenge to the data-base research community because of the heavy computational cost. In this section, A new S equence D imensionality R eduction method, named SDR , is proposed based on sequence embedding for the construction of SEM-tree. Thereafter, the new index structure of SEM-tree is presented to facilitate sequence similarity search on long sequence database. 3.1 SDR: sequence dimensionality reduction In this section, we first introduce an existing sequence embedding technique [ 4 ]. Thereafter, sequence dimensionality reduction (SDR) mechanism is developed to reduce the computa-tional cost for sequence match, which is the basis of the proposed SEM-tree. 3.1.1 Review of sequence embedding Embedding strategy helps to reduce the cost of expensive distance computation of long sequences by transforming longer sequences to shorter multisets. Here, we use an exam-ple to illustrate the embedding process proposed in [ 4 ],asshowninFig. 1 . The original sequence s , also denoted as ET 1 ( s ) (the sequence before the first embedding iteration), con-tains cabagehcadbba and it is partitioned into six blocks after first iteration, with each block ter in this block respectively)is thereafter represented by an element based on a hashing one-to-one Karp X  X iller hash function [ 13 ] on sequences of length at most 3, therefore the same sequence must correspond to the same sub-tree in ET ( s ) . The partition and hashing continues until at one level the sequence only contains one element. The time complexity of thewholeprocessis O ( | s | log  X  | s | ). 1
Given an ET ( s ) , all the elements within the entire tree can be represented by a family the set of the elements within ET i ( s ) is denoted by the sub-multiset T i ( s ) .ViaExample1, important in the former but irrelevant in the latter.

Based on above sequence embedding method, the multiset and sequence shown in Fig. 1 can be divided as follows 2 : 3.1.2 The analysis of sequence dimensionality reduction The work of [ 4 ] only focuses on how to embed sequences into multiset space using a sequence embedding technique, while it does not consider any indexing structure and mine charac-teristics of (sub-)multisets. The dimensionality reduction techniques, such as PCA, have been widely used to facilitate similarity search in high-dimensional space. However, such approaches cannot be applied in sequence matching domain due to the different distance evaluation. The multisets generated by embedding technique motivate us to exploit the sub-multisets for SDR.
 Suppose we have two sequences, s 1 and s 2 , in the sequence dataset. Let T ( s 1 ) = l 1 i = 1 T ( edit distance with moves [ 4 ], which can only be approximated by the sequence embedding method. We develop the novel SDR mechanism with the following nice properties: 1. Since the order of the elements does not affect the multiset, the distance between two 3. Predictability is another important characteristic of sequence embedding, which can
Next, we will present the details of proof for embedded sequence properties. The basic operations on the multiset are introduced in the Appendix, such as , car d () ,  X  and  X  ,etc. Lemma 1 Given two sequences s 1 and s 2 ,  X  i , j with i  X  j  X  max ( l 1 , l 2 ) ,wehave: ing to Eq. 2 ,  X  d e ( T i ( s 1 ), T i ( s 2 )) = | r 2 |+| r 3 | 2 | r the hash-function which is deterministic, the common subsequence r (such as  X  k  X ) can only be produced by the common subset r 1 (such as  X  { a , c }  X ). However, sequences that share the same set of elements r 1 may not be embedded into the same sequences(except for h ( ac ) = k , we can have h ( ca ) = q ), i.e. | r | X  | r 1 | k , with k = | ET i ( s 1 ) | | ET Lemma is proved.

BasedonLemma 1 , the contractiveness of the distance between sub-multisets is further identified by Lemma 2 .
 Lemma 2 (Contractness) Given any two sequences s 1 and s 2 , for any i  X  j we have: Lemma 1 ,wehave: a 1 b ing induction process: Basic step : Based on Lemma 1 ,wehave a 1 b  X  d ( T 1 ( s 1 ), T 1 ( s 2 ))  X   X  d e ( T 2 ( s 1 ), T 2 ( s 2 )) .
 Inductive step :SupposetheLemmaissatisfiedwhen j equals i + 1( i  X  1),i.e., A i B with A i = i k = 1 a k and B i = i k = 1 b k . Therefore, we have A i  X  b i + 1  X  B i  X  a i + 1  X  Therefore, the Lemma is also satisfied for j equals i + 2, and the proof is completed. Lemma 3 (Predictability) For any two sequences s 1 and s 2 , upper bound of distance  X  d based on sub-multiset T i ( s 1 ) and T i ( s 2 )) as follows: where v = car d ( T i ( s 1 )  X  T i ( s 2 )) Proof According to the definition of distance computation in Eq. 2 .
Obviously, this distance value is bounded by  X  d e ( T ( s 1 ), T ( s 2 )) , where a = car d ( T i ( s 1 ) T i ( s 2 )) and b = car d ( T i ( s 1 )  X  T i ( s 2 )) . T ( T ( s 2 )) .
 where v = car d ( T i ( s 1 )  X  T i ( s 2 )) . The proof is finished. 3.2 The index structure It has been pointed out that the distance computational cost of multiset is much cheaper than that of the full sequences as we can reduce the length by transformation. Given the fact that between original sequences s 1 and s 2 , the similarity search among sequences can be replaced by the search over corresponding (sub-)multisets. Furthermore, multisets have some very attractive features, like contractiveness, which can facilitate the search process.
The basic idea of SEM-tree is based on the characteristic of distance preservation and contractibility. Each node stands for one cluster represented by a sub-multiset which serves as the center and the radius, and the multisets whose sequences located in this cluster form the children nodes. The tree structure based on multisets not only keeps the original clustering characteristics of sequences, but also eases the construction of index and query processing. 3.2.1 The structure of SEM-tree Given a sequence dataset SD , we apply sequence embedding process on SD to transform the sequences into a new space, named SEM-Space. Consider a sequence s  X  SD ,wedefine ( 1  X  l  X  L ) , denoted as: where l is called an embedding level and L is the maximum level.

The SEM-tree is a multi-tier tree and tries to partition the space into clusters and refine the clustering process as tree grows. Figure 2 shows an example. However, the indexing keys at each level of the tree are different X  X odes closer to the root use the keys with lower embed-At the root node of SEM-tree, only the sub-multisets from the first embedding level of the sequences contribute to the partition. Take the sequence cabagehcadbba in Sect. 3.1.1 as an However, the lengths of the sub-multisets are in non-descending order from root to leaf.
The entry in the internal node of SEM-tree is a vector, denoted by cluster vector c v ,which corresponds to a cluster at the SEM-Space. All the vectors within an internal node form a larger cluster, which refers to an entry in the parent level. We name the vectors within a For a c v at i th level, the sub-multiset sm represents the center of the cluster, and r is the where m is the embedding level of multisets of the node. Pointer cptr points to the child node formed by all the immediate child vectors of c v . Different from the internal node, the leaf node simply stores the original sequences within a certain cluster.

The SEM-tree can be used to prune the search space effectively. Recall (in Lemma 3 )that the distance between two sequences with a shorter embedding level in the embedding space is always smaller than the distance between two sequences in a longer embedding level. Thus, we can use the distance at a shorter embedding level to prune away sequences that are far away (i.e. if the distance between a database sequence and the query sequence at a shorter embed-ding level is already larger than the specified range query threshold, it can be pruned away). Moreimportantly,theshorterembeddinglevelatupperlevelsofthetreenotonlydecreasesthe distance computational cost, but also saves storage space due to its condense characteristics. For the SEM-tree to be effective, we need to determine the optimal number of fanout F (or the number of c v ) in each internal node. The index key in the upper level of the SEM-tree utilizes a shorter sub-multiset, but we increase the embedding level of sub-mul-tisets when traversing down the tree, till the original sequences are stored at the leaf node. In this manner, if each node corresponds to a page with a fixed page size PageSi ze (for example PageSi ze = 4KB), fan-out is large at the upper levels but small in lower level. Assume that the size of sub-multisets in the l th level internal node is denoted by a v Si ze l , the fan-out of l th level internal node is: 3.2.2 The construction of SEM-tree Algorithm 1 shows in detail the process of constructing a SEM-tree for a given dataset. We adopt a top down approach to get better clustering effect. At first, We use the sequence embedding routine SEM() to transform the original sequences into the SEM-Space (line 1). Then we initialize the root node (in line 2). We treat the whole sequence dataset as a cluster and refer to these new points as MS . After that, we call the recursive routine Insert(Node, MS, l) that essentially determines the content of the entries of the node at level l  X  X ne entry per sub-cluster. Note that we are dealing with sequences in the transformed space (i.e. MS), and that l determines the sub-multiset in MS that this node is handling.
 Algorithm 1 SEM-tree Construction At the beginning of Insert(Node, MS, l) , we check whether a leaf node can be generated. If the sequences represented by (sub-)multiset MS can fit in a disk page, then a leaf node is created (line 1 X 3), otherwise an internal node should be generated (in line 5). The number of we partition the data of the cluster ms into F l sub-clusters by K-means (in line 8). 3 However, this partitioning is performed only on the first l levels sub-multiset. For each sub-cluster, we fill the information on the center and radius into the corresponding entry in node, and then recursively invoke routine Insert() to build the next level of the tree (in line 9 X 12). In order to illustrate the construction algorithm, a running example is provided in Fig. 3 . Suppose each of these sequences has already been partitioned into three sub-multisets, using the distance computation based on the first level sub-multiset T 1 (.) . One cluster take T of 1 / 3. Similarly, at the second level, we follow the same principle for each sub-cluster based on the sub-multiset T 2 (.) . In the leaf level, we index the full sequences if we assume each node can store two sequences.

We note that the SEM-tree can be made balanced by generating equal sized clusters by using the method in [ 5 ]. However, such a balanced tree has not achieved better performance, since it increases the radius of small clusters, which leads to more overlap and more page accesses. Thus, for efficiency reason, we do not require the SEM-tree to be height-balanced. Since the data may be skewed, it is possible that some clusters may be large, while others contain fewer points.

Note that SEM-tree is a dynamic index structure, which can facilitate the data update based on the properties of multiset. For example, when a new sequence is inserted, we simply trans-form the original sequence to SEM-Space, and insert it into the appropriate sub-cluster from root. Due to the space constraint, we omit the details here. 3.3 Query processing on SEM-tree In this section, we investigate the distance property of multisets, and introduce a novel approach to accelerate the node filtering process. Finally, we present the whole algorithm of range query in the SEM-tree. 3.3.1 Double bounds of real distance between sequences While the proposed SEM-tree can conduct efficient similarity search over long sequences, it cannot guarantee absolute accuracy. This is because the search is conducted according to the distance between corresponding multisets rather than real sequences in the internal levels of the tree. As mentioned in Sect. 3.1.2 , the distance between two multisets can approximate the real distance between two sequences with certain error, but such error has not been taken into consideration during tree construction. In this section, we develop a double-bound theory to make sure that the searching process can cover all candidate sequences and complete query results can be returned.

Accordingto[ 4 ], for sequences s 1 and s 2 , the real distance can be bounded by the distance on embedding space as follows:
BasedonEq. 3 , the real distance between any two sequences can be limited by double bounds [  X   X   X  d e ( T ( s 1 ), T ( s 2 )),  X   X   X  d e ( T ( s 1 ), T ( s 2 )) ] .
Based on the predictability of multiset in Lemma 3 , such double-boundary can be applied on the transformed sub-multiset for each internal node of SEM-tree, and we have the follow-ing revised boundary to support search process.
 clustering vector at i th level based on the double boundaries. 3.3.2 Node filtering based on predictability One promising feature of SEM-tree is that some of the final results can be determined before-hand when visiting the internal node. Although the query range is extended by using approxi-mate distance in the internal nodes, we can quicken the query processing greatly based on the predicability property of sequence embedding. To the best of our knowledge, this mechanism has not been explored before. Lemma 5 For a query sequence q , a clustering vector c v in an internal node at level i and query range  X  , all sequences covered by c v are included in the results if the following inequation holds:
This lemma means that if the summation of upper bound distance  X  d  X  B u (  X  d e ( T i ( q ), c v. sm )) and upper bound distance  X  r  X  rad u ( c v i ) is less than specified range  X  ,thenall beenprovedinLemma 4 , and we have Lemma 6 for rad u ( c v i ) .
 r is the radius, then the upper bound of radius c v in multiset can be estimated as: Proof Assume a sequence s within c v has the distance r from s . According to the definition of distance computation in Eq. 2 , there are many possible choices for sequences within c v satisfying such constraints. To make sure that all sequences within c v are covered by the dis-T i ( s )  X  T i ( s ) with  X  d e ( T i ( s ), T i ( s )) = r .

Obviously, the radius r is the maximal distance among the whole multiset between s and s , which is bounded by where l 1 and l 2 are the height of ET ( s ) and ET ( s ) respectively.
 T ( T ( The proof is finished.

Thus, query processing can be accelerated with the following filtering strategy: At a par-each c v , the double of the real distance between c v. sm and query sequence q can be obtained directly based on Lemma 4 . Then, a filtering step will prune unqualified c v according to the following criteria.  X  After filtering out above c v s, remaining c v set will be the results for further checking at 3.3.3 Query processing over SEM-tree With the above preparations, we now discuss how to process similarity search efficiently over SEM-tree. We only present the algorithm for range query, but the algorithm can support k -NN query with minor change.

A range query Q Range = q , X  retrieves all sequences s in the sequence datasets that  X  d (  X  ) is the distance measurement in original sequence space. To improve the efficiency of search, (sub-)multisets have been adopted as index keys in internal nodes of the SEM-tree. The detailed algorithm is provided in Algorithm 2 .

Firstly, the query sequence q will be embedded into a multiset T ( q ) and a search starting from the root of SEM-tree based on T ( q ) is thereafter conducted. For each clustering vector in an internal node, those irrelevant clustering vectors will be first filtered out based on pro-be determined based on the proposed multiset predictability whether all sequences covered be appended to the final result RS and this subtree will not be further checked. Otherwise, the left clustering vectors need to be further checked by calling search process RangeSear-chOnTree (*) recursively(in line 8). At the leaf node, each candidate sequence needs to be examined based on real distance function in original sequence space to determine whether they belong to final result set RS .

To conclude, the proposed sequence searching strategy can be summarized as following: space-efficient multiset and related time-efficient distance function have been used to filter out those irrelevant sequence in internal nodes. Classical edit distance will be used in leaf nodes to refine the final results accurately. Algorithm 2 RangeQuery( q ,  X  ) 4 Experiments In order to evaluate the performance of proposed SEM-tree, we conducted extensive empir-ical study. We compared our method with several other existing global sequence indexing methods: (1) the M-Tree [ 2 ], (2) the DBM-Tree [ 28 ] and (3) the Slim-Tree [ 26 ]. The C++ implementations of the M-Tree, the DBM-Tree and the Slim-Tree, were obtained from Arbo-retum MAM library. All the implementations are running on a PC with Intel P4 CPU 1.5 GHz and 1G MB memory. The performance metric query cost , i.e. I/O and time cost, is taken into consideration. All the indexes are stored on disk, and the disk page size is set to 4KB. Therefore, I/O cost stands for the number of page readings for each query. On the other hand, time cost is the overall response time required to navigate the index and return the answers. The results shown in this section are the average performance of 200 range queries. The query sequences are randomly selected from the dataset.

Both synthetic and real datasets are employed in the experiments. Specifically, two data-sets have been used in our experiments: Synthetic Dataset : Dataset simulator SUMATRA [ 33 ] is employed to generate the synthetic sequence dataset. It is a popular data simulator in mobile environments, which produces the moving trajectory sequences with various length and scale.
 GENE Dataset : We also employ a real human GENE dataset comprising of four characters A, C, G and T, from GenBank [ 1 ].

The detailed parameter setting of the performance study is shown in Table 2 with default setting denoted by bold texts, where the character set size represents the number of distinct characters in the database. In each experiment, we only change the value of one parameter with all the rest adopting the default values. 4.1 Impact of query range (  X  ) The goal of our first experiment is to compare the performance of our method with existing methods for different query ranges on SUMATRA and GENE datasets with the range varying from  X  = 0 . 0001 to 0.1. The results are shown in Fig. 5 , where the plots on x-axis are given in log-scale.

With the increase of query range, query cost (including both I/O and running time) increases for all the methods, but SEM-tree always performs better than three existing meth-ods, i.e. DBM-tree, Slim-tree and M-tree. All these three indexes use cluster information over the full sequence length in the internal nodes, therefore, the computational cost of dis-tance is high. The small tree fan-out also incurs heavy overlaps between nodes. Among three existing methods, DBM-tree always performs better than others (M-tree and Slim-tree). The DBM-Tree is unbalanced, which makes it reduce the overlap between nodes in high density regions. Compared with the DBM-tree, average running times of the SEM-tree are 33 and 47% for SUMATRA and GENE datasets. Regarding the I/O cost, SEM-tree saves around 50 and 69% of the cost of DBM-tree. The SEM-tree enables the distance com-putation between (sub-)multisets ( notthe origi nal sequences ) finished within linear time in the internal levels of the tree. The distance on the short (sub-)multisets can effectively filter most irrelevant sequences in the database. On the other hand, we can reduce the I/O cost greatly by storing more entries in each internal node, as each entry is represented by (sub-)multisets with small length. Additionally, the multiset representation can increase the fanout of the SEM-tree, thus reducing the overlap between nodes. Furthermore, according to the predictability of SEM-tree, some query processes in a certain query can be finished beforehand in internal node levels without accessing the leaf nodes, which can further reduce query cost.

We also consider the Sequential Scan approach as the base-line solution which does not employ any index, however the Sequential Scan method yields much worse performance compared with all the index based approaches since it has to access all the sequence data for any query, and hence we omit the results in the figures. For example, the I/O cost for Sequential Scan on SUMATRA dataset is 1,000 given the default parameters, which is 2-6 times higher than index based methods. 4.2 Scalability in sequence length ( sl ) Theresiliencetotheincreaseofsequencelengthisoneofthemostcriticalfeaturesforanindex structure targeting long sequence dataset. The goal of this experiment is to compare the per-formance of our method with existing methods for increasing lengths of sequences. Figure 6 presents the results with sl ( sequence length ) varying from 50 to 200 under SUMATRA dataset and GENE dataset. Query range  X  is 0.1.

As sl increases, each sequence has more characters, which results in higher tree and more expensive distance computation. However, the SEM-tree is based on the multiset, which is a compact representation of the real sequence. A multiset only records the distinct characters of sequence and corresponding occurrence times, not the orders. Therefore, an increased sl does not deteriorate the performance of the SEM-tree obviously as depicted in Fig. 6 .
Our SEM-tree can be about 23% (46%) faster than the other three methods in SUMATRA dataset (GENE dataset), especially when the sequence is long. The SEM-tree has two advan-tages over other three indexes. Firstly, the SEM-tree reduces the number of I/O(s) compared to other three indexes (represented by DBM-tree). Because we index different levels of mul-tisets of the dataset, the length of sub-multisets in the upper levels is much smaller than that of the original sequence. Besides, the fanout of SEM-tree in upper levels is much larger than other methods, making the index size of the SEM-tree smaller. With the default parameters of the datasets, the height of SEM-tree is only 3 for GENE data and 4 for SUMATRA data, while the other three trees have 6 levels. Secondly, the computational cost of SEM-tree is smaller than DBM-tree. The reason is that in the internal levels, the distance computation is much faster because of reduced length of multisets. 4.3 Scalability in database size ( s ) In this experiment, we test the scalability of performance with respect to the data size. We fix the length of sequences at 100 and query range  X  at 0.01, and vary the dataset size from 5,000 to 20,000 sequences. The performance of range queries on SUMATRA and GENE datasets for SEM-tree, M-tree, DBM-tree and Slim-tree, including an average number of I/O(s) and total running time, has been shown in Fig. 7 .

Generally, with the increase of data size, more sequences will be covered for the fixed query range  X  , which not only incurs the increment of distance computation but also leads to more I/O operations involved. Therefore, the performances of all indexes decrease as depicted in Fig. 7 . However, the SEM-tree is still about 40 X 50% better than other methods for range query on SUMATRA and GENE dataset. These results clearly show the efficiency of the SEM-tree over the three compared indexes. This is because SEM-tree uses (sub-)multisets rather than the full length in the internal nodes, and the latter can lead to more I/O operations and distance computational cost. 4.4 Impact of character set size (  X  ) In the last experiment, we evaluate the performance of our method using different character set sizes. Here, we compare the performance of SEM-tree with other three indexes by fixing the query range (  X  = 0 . 01) for a varying character set size  X  = 5, 10, 15, 20 and 25 under SUMATRA data. Based on the sequence embedding technique, we know that the length of multiset (or sub-multiset) highly depends on the character set size  X  . Therefore, the perfor-mance of SEM-tree may be influenced by the changing of  X  , which has been proved in these experiments.
 AsshowninFig. 8 , as the number of character set size increases, the performance of SEM-tree degrades gradually. The reason is that the effectiveness of sequence embedding is deteriorated, as we need to use longer multiset to represent the original sequence. However, the SEM-tree still performs better than other schemes for a relatively large  X  , e.g. 20. Note that, the performances for DBM-tree, Slim-tree and M-tree are kept unchanged because the query processing is unrelated with  X  but only influenced by the length of sequence sl .
The result of this experiment also justifies the superiority of the proposed SEM-tree for the sequence datasets with a small number of distinct characters, such as DNA sequences. 5Conclusion With numerous emerging applications requiring efficient similarity search over sequence datasets, there is a high demand for a scalable index structure that can serve long sequence datasets. In this paper, we proposed a  X  X imensionality reduction X  like mechanism based on sequence embedding technique to minimize the expensive distance computational cost. As an application of the derived properties, a novel index structure, SEM-tree was presented to index sequences. In a SEM-tree, each level represents the sequence data with different compression level of multisets, whose sizes increase from root to leaf level. As demonstrated by the comprehensive simulations, SEM-tree shows a much better performance than existing schemes, in terms of CPU cost and I/O cost.
 Appendix: Multiset and related operations Definition 1 (Multiset) A multiset is a pair ( X , f ), where X is a set, and f is a function mapping X to the cardinal numbers greater than zero. For any x  X  X , f ( x ) is called the multiplicity of x .
 Definition 2 (card()) Suppose that A = A , f is a multiset, then its cardinality, denoted card( A ), is defined as: card( A )= x  X  A ( f ( a )) .
 Definition 3 ( A B ) Suppose that A = A , f and B = A , g are two multisets, then the removal of multiset B from A, denoted A B , is the multiset C = A , h , where for all a  X  A : h ( a ) = max ( f ( a )  X  g ( a ), 0 ) .
 Definition 4 ( A  X  B ) Suppose that A = A , f and B = A , g are two multisets, then their union, denoted A  X  B , is the multiset C = A , h , where for all a  X  A : h ( a ) = max ( f ( a ), g ( a )) .
 Definition 5 ( A  X  B ) Suppose that A = A , f and B = A , g are two multisets, then their intersection, denoted A  X  B , is the multiset C = A , h , where for all a  X  A : h ( a ) = min ( f ( a ), g ( a )) . References Author Biographies
