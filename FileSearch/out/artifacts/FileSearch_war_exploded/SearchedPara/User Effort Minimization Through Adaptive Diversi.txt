 Ambiguous queries, which are typical on search engines and recommendation systems, often return a large number of results from multiple interpretations . Given that many users often perform their searches on limited size screens (e.g. mobile phones), an important problem is which results to display first. Recent work has suggested displaying a set of results (Top-k) based on their relevance score with respect to the query and their diversity with respect to each other. However, previous works balance relevance and diversity mostly by a predefined fixed way . In this paper, we show that for different search tasks there is a different ideal balance of relevance and diversity. We propose a principled method for adaptive diversification of query results that minimizes the user effort to find the desired results, by dynamically balancing the relevance and diversity at each query step (e.g. when refining the query or viewing the next page of results). We introduce a navigation cost model as a means to estimate the effort required to navigate the query-results, and show that the problem of estimating the ideal amount of diversification at each step is NP-Hard. We propose an efficient approximate algorithm to select a near-optimal subset of the query results that minimizes the expected user effort. Finally we demonstrate the efficacy and efficiency of our solution in minimizing user effort, compared to state-of -the-art ranking methods, by means of an extensive experimental evaluation and a comprehensive user study on Amazon Mechanical Turk.
 H.2.m [ Database Management ]: Miscellaneous Diversity; User Effort Minimization; Mobile Applications Now-a-days mobile devices have become increasingly popular for searching. The majority of ecommerce sales are currently performed through smartphones or tablets, and specifically about 35% exclusively through smartphones [27] . Keyword-based interfaces have been widely adopted as the preferred query method because they are simple and intuitive . Nevertheless, keyword queries are often ambiguous , that is, they have multiple interpretations, and consequently generate many results. As an example, consider the query  X  memory  X  which might refer to computer memory (RAM, ROM, Flash etc.) or the song Memory from the acclaimed musical Cats. For such ambiguous queries, a ranking that considers only relevance (e.g., [8] ) might return a large number of similar results from just one interpretation of the query, e.g. DDR3 RAM, and a user with different search intent (say music) might not find any result that is relevant to her in the first page (Top-k) of the results. To deal with query ambiguity, recently several search applications have incorporated diversification while ranking results to improve the user experience . Examples of such applications include web search [4] [6] , recommendation systems [9] [18] [19] [20] , semi-structured databases [23] , graph search [2] , and document summarization [15] . A diversified ranking includes not only relevant (as judged by the underlying ranking function) results, but also results that may be less relevant and are diverse with respect to other results in the ranked list. By covering results from multiple interpretations of a query, diversified ranking thereby increases the probability of the user finding desired results based on her query intent [1] . Of course, just focusing on diversity and displaying the set of most diverse results is ineffective since some of these results may have low relevance. In its most general form, the problem of query result diversification is modeled as a bi-criteria optimization problem [1] [5] , which uses a trade-off parameter ( to tune the relative effect of relevance and diversity factors during ranking. Using , the impact of the diversity factor can be increased for highly ambiguous queries so as to include more diverse elements in the result set; whereas for very specific (n on -ambiguous) queries, this factor can be decreased to prevent inclusion of results of lesser relevance. As an example, consider Figure 1a which depicts the result set returned for the query  X  X amera X  (on a structured dataset like Amazon.com). As seen in the figure, the result set includes products from several categories including DSLR, Compact cameras and Accessories. Each result has a set of features (e.g. Brand, Megapixel, Zoom etc.). Note that the Lenses of DSLR cameras are considered in the Accessory category, therefore DSLR cameras do not have a Zoom feature. Since there is a limited paginated interface available to the user for displaying the results (mobile screen size etc.), Figures 1b-1d show the Top-3 results (first page) selected by varying the trade-off parameter between diversity and relevance. Note that the relevance ranking in this example assigns a higher score to DSLRs. For a user shopping for DSLR cameras, the ranking shown in Figure 1b, which prefers relevance over diversity, might be sufficient. However, a user looking for a camera Lens would prefer the highly diversified ranking shown in Figure 1d, where she could click on the Lens attribute value for attribute Type in the Accessory category to see more camera lenses. Note that, for a given query, the user navigation cost (the user  X  X ffort X  or actions required to find the desired results) varies for different choices of the trade-off parameter (see Figure 2, for the query  X  X amera X  using the MMR algorithm [10] to implement diversified ranking). Moreover, in Section 5 (Figure 7), we show experimentally, that the best value of the trade-off parameter varies for different queries. However, no previous work addresses the problem of computing a trade-off parameter that will minimize the user effort. Instead, many hard-co de it to a reasonable value (fixing the relative weight between relevance and diversity). Recently, several methods have been proposed [4] [16] to learn the trade-off parameter . Unfortunately, these methods depend on training data provided by the experts which are expensive to collect or might not be available. Further, they compute a single trade-off parameter for a query, whereas we show how this trade-off changes as the query refinement or results viewing progress. Because of the display interface, finding the desired result to a particular query might involve several steps. If the user does not find her desired result on the first page, then she might take additional actions to find the result, such as: (a) scan additional pages looking for the results of interest, or, (b) refine the query by clicking on a displayed attribute value to focus on a subset of the original results. Our goal in this paper is to compute at each step a set of k results (corresponding to a pa ge in the user X  X  interface) that dynamically balances diversity and relevance such that the expected user navigation cost is minimized. What makes the problem difficult is that when the query is posed, neither the target result nor the sequence of actions the user will execute to find it, are known. Therefore, to compute probabilistically consider all the unknown future user actions, which is a key challenge of our solution. For example, if the user poses the (highly ambiguous) query Camera while her target object is Lens, she will need further actions if we provide the results in Figure 1b (high relevance) in the first page. A higher diversified result set (like the one in Figure 1d) would have been more appropriate. If instead, a more specific query is posed, like DSLR Camera, then higher relevance and lower diversity is preferable, because the user may (with high probability) satisfy her search with just one page. Note that this dynamic balancing of relevance versus diversity can also occur, within the subsequent navigation steps of the same query, as it is progressively refined by the user (e.g. after posing the Camera query and getting the results in Figure 1d, a user interested in lens might refine by selecting the condition Type: Lens). To this end, we propose a user navigation model that considers factors such as the characteristics of the query result, the user X  X  familiarity with various refine conditions, the number of pages the user would have to navigate and the expected number of navigation steps required to reach a result of interest. The resulting model is adaptive to user actions and constructs a diversified result that minimizes the expected user effort. This is in contrast to the fixed diversity vs. relevance trade-off achieved by previous techniques, which leads to a much higher navigation cost, as shown in our experiments. In summary, we make the following contributions: 1. A user navigation cost model that captures the actions of a 2. The cost model is necessarily probabilistic since it 3. We show that the problem of computing the best set of 4. We present the results of an extensive experimental 5. We validate our cost model and measure user navigation Related work is discussed in Section 7 and we conclude in Section 8. We proceed with the problem setting (Section 2.1), and describe our navigation cost model (Section 2.2), which mimics the actions of a user navigating query results and quantifies the user effort, that is, assigns cost to the user actions. We then conclude with a formal problem definition (Section 2.3). Database: Let { } be a database consisting of tuples and { } be a set of attributes. Each attribute has an associated domain consisting of un-interpreted constants. The database is heterogeneous and each tuple has a value for a subset of attributes and a null value for the rest. Query: The user exploring , navigates the results of a query which could be a keyword query. Each attribute-value combination in the results of , denoted by , is a condition and can be used to refine the query. We denote the set of all conditions of by ( ) . Example: Figure 1a shows a result-set for Q: Camera , where the user could refine the query by selecting condition Brand = Canon, which would return the two Canon cameras (#1, #3). Paginated Result Subset : Typically, the result set is too large to fit into a single page on the user interface. These results are therefore paginated and only a small subset of size is presented to the user at a time. The size of the result subset depends on the display size of the device. For example, e-commerce and web-search interfaces typically show 10-15 results at a time on desktop browsers and 5 on mobile devices. The latter are the key focus of this paper, which are even more challenging because the screen size does not allow displaying other result information like facets (see discussion in Section 7). Example: Figures 1b-d show examples of various paginated result subsets (with ) for the query results in Figure 1a. The choice of the subset is critical in determining the effectiveness of a search interface. In particular, should contain relevant and a diverse set of results. Let be the relevance score of a result , where a higher score means the result is more relevant to query . Existing object relevance ranking functions like [8] can be used to compute . Also, let be the distance between two results . For instance, can be the Euclidean distance between the vectors representing and . Currently, most systems model search result diversification as a bi-criteria optimization problem that balances the effect of relevance and diversity using a trade-off parameter as follows: In Section 1, we described several scenarios where this bi-criteria optimization is problematic. The primary reason is the difficulty in selecting a value of for a given navigation step of a query. Instead of fixing the trade-off between relevance and diversity, we model the diversification problem in terms of the user navigation effort. We do this by designing a holistic model of the user navigating a list of paginated results that considers all the actions taken by a user, discussed next. Users execute queries on a search interface to satisfy a certain information need, which may be satisfied by a certain objects in the query result. Given a user query and corresponding result set , the query interface presents the first page of results attribute-value conditions. These conditions are selectable (e.g. by clicking on the associated link), thereby refining the query. Note that the search interface does not provide any facet conditions to refine the results, but the results serve this dual purpose. Such an arrangement is desirable especially in mobile devices where there is not enough space to show both results and facet conditions. NAVIGATE ( ) 1. COMPUTE-PAGE( 2. READ-RESULT 3. If search need satisfied by 4. TERMINATE 5. Choose one of the following: 6. (a): Select a condition to refine; 7. NAVIGATE ( ) In particular, the user chooses among the following possible actions at each step: 1. If the user X  X  search need is satisfied on the 2. ( ) The user can navigate to the next 3. Typically, a user has a notion of the In our model, the user executes an action based on the displayed result set. Such navigation models, where the user only selects actions proposed by the system, have been used extensively in the navigation of keyword-based query results [12] [21] [22] . Each user action (REFINE, READ-RESULT, NEXT-PAGE) is satisfy her search need is the navigation cost . As an example, consider the user navigating the result set in Figure 1a using the initial pagination in Figure 1d. Further assume that the user is interested in Lenses with 55 -300 mm Focal Length (#11). As a first step, the user would read (READ-RESULT) the first page of 3 results. Next, the user REFINEs by Type: Lens to see only the Lens results, since she is interested in Lenses . Up to this point the navigation cost consists of 3 READ-RESULT actions and 1 REFINE. Upon REFINE, the interface presents the 2 lens results (#10,#11), which the user reads and finds the desired object, thereby TERMINATING the navigation. The overall navigation cost is READ-RESULT + REFINE.
 If we assume that reading a result incurs unit cost (as was assumed in [12] ), and the cost of REFINE (click) action is a constant greater than one , the total cost is 5 1 + 1 3 = 8. This assumption about the constant reflects our belief that REFINE incurs more user effort than reading a result, since the user has to consider all the conditions and then decide on a condition to click on. Similarly, the user could do NEXT-PAGE instead of REFINE if she does not find any useful condition to refine on. The cost of NEXT-PAGE is  X . The overall navigation cost depends on the result subset that is presented to the user at each step. For example, if the user in the example above is presented with a paginated result subset containing the Camera Lens with 55 -300 Focal Length (#11), then she would find the desired target object on the first page and TERMINATE the search. In this case, the total navigation cost is 3 (3 READ-RESULTs). Therefore, we need to compute a paginated result subset appropriately balancing relevance and diversity. Let ( ) denote the cost of navigating the result set of a query , using the paginated result subset . Then the minimal cost of navigation, , is the cost of the paginated result set , amongst the ( | | ) k-subsets, that has the minimum cost. Formally, Problem 1: Minimum Cost Diversification ( ) : Given a query and its result set | | , compute the result subset of size (| | ) such that the expected navigation cost incurred to satisfy the user X  X  search need is minimized. Next, we show how to estimate ( ) , the cost of a result subset for a result set . The navigation cost of a result set , computed as discussed in Section 2.2, depends on the actions taken by the user in reaching a target object and can be exactly determined after the navigation is complete. However, solution to the minimum cost diversification problem (Problem 1) requires the selection of result subset before knowing what sequence of actions the user will perform after viewing . In this section, we propose a way to estimate the cost of navigating a result subset by means of a probabilistic cost model that assigns uncertainty measures to each possible action a user can take and computes the expected navigation cost for a given . We begin by introducing the probability measures that capture the uncertainty in user action. In the user navigation model in Figure 3, the user, at each navigation step, has three choices  X  (1) TERMINATE the navigation (line 3) (2) REFINE by a condition (line 6a) and (3) to go to the NEXT-PAGE of results (line 6b), and we introduce probability measures for each of these actions .  X  ( : This is the probability  X  : This is the probability that  X  : If the user Given the probabilities defined above, the entire navigation process, which contains several iterations, can be expressed by the following recursive cost equation ( cost(.,.,.) is overloaded): ( ) | | This cost equation can be described as follows: 1. The user reads the results in , and decides about her next 2. Otherwise, with probability , she can either ref ine The cost equation (Equation 3) depends on the key probability terms , and . We present specific and reasonable methods to compute the probabilities used in our cost model. Depending on the specific application, other computation methods may more closely model the user. The computation of these probabilities is orthogonal to the algorithms presented in Section 4, which are the key contributions of this paper. Computing : This is the probability that the user finds the target object in and therefore terminates the navigation. Since the target object is not known before navigation, a reasonable assumption is the probability of a potential target object is proportional to its relevance score . If the user finds the target object amongst the result subset , then she can terminate the navigation. Therefore, we estimate the probability of termination as being proportional to the sum of relevance scores in the paginated result subset and normalize it with sum of relevance scores of all the results in as  X   X   X  . The choice of the relevance function is orthogonal to this paper and can be computed in various ways such as TF-IDF [13] for keyword queries or by using Probabilistic Information Retrieval models [8] . Computing : The key assumption we make is that the user has a high likelihood of refining the query when the results in are diverse. This is because a diverse covers multiple aspects of the query by containing results from different interpretations [7] , [24] . For example, the result subset in Figure 1d contains results from different categories and also contains a variety of attribute values, and hence offers many refinement opportunities, which translated to a high In contrast, the result subset of Figure 1b would translate to a low To compute the diversity of a result subset , we need to compute the distance between all pairs of results [5] . Distance measures like Euclidean distance, Cosine Similarity can be used for this purpose and again the choice is orthogonal used for normalization and is equal to the maximum possible diversity of a k-result set from . Finding the maximum diversity in the denominator is similar to the maximum clique problem, and therefore known to be NP-Complete [5] . We use experiments (in Section 5 ). Computing : This probability shows how likely the user will refine the query by selecting condition , which depends on the user X  X  preferences or her familiarity to this condition. A reasonable choice is that is proportional to the frequency of condition in the result set as described in [12] . Exact Algorithm: To compute the paginated result set such that cost of navigating is minimized, it is necessary to compute the cost, using Equation 3, of each subset of size and selecting the subset that has the minimum cost. We show that this problem (Problem 1) is NP-hard [28] , by reducing Set Cover to a simplified version of this problem. There are two sources of complexity that make the exact algorithm computationally expensive: 1. Computing the navigation cost of each subset of 2. Since Equation 3 is recursive, to solve it we must compute Approach overview: We attack the problem by proposing efficient techniques to approximate both sources of complexity. We first show how to effectively eliminate the recursion from Equation 3 using a sequence of two relaxations. Then we show how to avoid evaluating the simplified equation for every combination of result subsets using a greedy algorithm. Our approach starts by eliminating recursion from Equation 3 using two relaxations. Figure 4 shows the recursive tree to compute Equation 3 and the simplifications achieved through the two relaxation steps. Relaxation 1 (Eliminate Conditions from Recursion Tree): The navigation cost function (Equation 3) has two recursive calls  X  one each for REFINE and NEXT-PAGE actions, respectively to compute the navigation cost for subsequent navigation steps. Intuitively, the navigation cost of a result-set is proportional to its size | | , since for a larger result-set the user must explore more results to reach the results of interest. This assumption is backed by our experiments in Section 5 (specifically Figure 6) and we use this observation to simplify the cost equation. Formally, The cost associated with REFINE actions, denoted by ( results from the refined result set . Based on the observation above, this cost is proportional to size of , i.e. Based on observations and and ignoring the constants of proportionality, the cost of the REFINE by a condition can be estimated as: Analogously, the cost of NEXT-PAGE action ( ( )) can be approximated as | | user is left with of the original result-set after a NEXT_PAGE action. By plugging in these approximations and rearranging terms, our cost equation can be rewritten as: ( ) | | { ( )[  X  Equation 4 replaces the recursive calls of REFINE and NEXT-PAGE actions (in Equation 3) with ( ) (Figure 4(b)). However, it still requires evaluation of all possible k -subsets of R to compute ( ) according to Equation 2. We address this by the next relaxation. Relaxation 2 (Eliminate Result Subsets from Recursion Tree): Our goal is to find the result subset that minimizes Equation 4. But note that this same optimal S k is used to compute ( ) according to Equation 2. Hence, we can replace ( ) by ( ) in Equation 4. Then, by solving for ( ) , Equation 4 can be further simplified as: Equation 5 has no recursion, and can be easily computed for a given . Note that Relaxation 2 does not incur any approximation error, in contrast to Relaxation 1. Given the relaxed cost Equation 5, we still need to compute the cost of all possible k -result subsets of to find the optimal Figure 4: Elimination of Recursion Using Relaxations 1&amp;2 Algorithm: Input: Query and Result Set Output: Set of results, 1. 2. 3. 4. 5. 6. for p 2 to k do 7. ( ) 8. 9. 10. return For that, we present an efficient greedy algorithm, called Adaptive Diversification Algorithm (ADA) , which incrementally builds the result set by adding at each step the result with minimum incremental navigation cost. At each iteration p ( ), makes use of two sets: the set of remaining results and the set of selected results , with | | . Note that = , the set of all the results. Initially and (using Equation 5) for each result and moves the result with minimum navigation cost to . This process continues until we select results (i.e. ). Figure 5 shows the pseudo-code of our diversification algorithm . The first result is chosen as the object with highest relevance score (line 3) since we want to provide to the user the most relevant object. After that, in each iteration, ranks the results in according to Equation 5 with replaced by , removes the result with minimum navigation cost from , and adds it in the selected result set (line 6-9). Th e algorithm terminates when we select results. Complexity: The running time of depends on the cost computation time in line 7, which is invoked up to | | times. To compute ( ) using Equation 5, we need to calculate , the cost of all possible REFINEments (  X  | | ( their denominators, which depend on the result set and . However, in ADA we only need to compute these probabilities for the original result-set , which takes time | | and ( | |) (using ), respectively. The computation of all ments cost  X  | | | | time. The cost of NEXT-PAGE and can be computed in time. Therefore, the total running time of is O | | (assuming | | ). In practice, the execution time is much faster than this worst case bound (Section 5 ). Example: Let us apply to the result set in Figure 1a. We are interested to find the 3 results returned by . But before that we analyze Equation 5 more closely to infer the implication of the cost equation. The cost of a result set is minimized when the denominator of the right hand side in Equation 5 is maximized, which implies having higher value. But when the result set size | | is high, we have smaller value (since the denominator part of in Section 3 is high). Therefore, the navigation cost depends on the cost of and NEXT-PAGE actions. Since the NEXT-PAGE cost (denoted as | | is the same for all result sets, the navigation cost is minimized for the result set containing highly diverse results with popular selective conditions (i.e., with high P becomes smaller, dominates cost equation, therefore cost is minimized for highly relevant results. The conclusion of the above discussion is that, initially when | | is large (small ), ADA prefers diversity over relevance. As | | becomes smaller (higher ) in the next iterations, ADA increases preference to relevance, and provides highly relevant results. Returning to the running example, initially prefers diversity over relevance in Figure 1a since | | is relatively large. The first result is the result #1 as it has the highest relevance score (diversity is not a factor when selecting the first result, which is always selected by relevance). The second result would be from Compact or Accessory categories. Assuming all the conditions in Compact and Accessory categories have similar the second result is #6 because of its high relevance score. The third result would be from the Accessory category to increase diversity, and specifically #10 since it has higher relevance score than #11. Thus would return result set in Figure 1d. In the next iteration, as R Q becomes smaller, ADA will return more relevant result-set snippets like the one in Figure 1c, and in the last iterations like the ones in Figure 1b. In this section, we describe the results of an extensive experimental evaluation of our approach. The setup, including methodology, datasets, baselines and metrics used, is described in Section 5.1. Sections 5.2 and 5.3 demonstrate the quality and performance of diversification algorithms in terms of user navigation cost and CPU time. All experiments were performed on a 2.5GHz Intel Core i5 CPU, 8GB RAM machine running Windows 7. We used MySQL as our database and all algorithms were implemented in Java. Datasets: We evaluated our approach on two datasets: 1. UsedCars: This dataset consists of a listing of 15,191 used 2. Electronics: This dataset consists of 65K products from the Queries: We selected 8 queries each from the two datasets. These queries are shown in Table 1 along with result-set sizes. Note that we are interested optimizing the navigation of diverse result sets, and therefore these queries were selected to be deliberately ambiguous so as to include results from a variety of categories. For that, we use single-keyword queries, although our methods support any number of keywords or query conditions; more keywords could be used if larger e-commerce datasets were available. For each query, we select a target navigation terminates when the user locates this target object. State-of -the-art: Current approaches to diversification use a fixed relevance-vs.-diversity trade-off parameter ( in Equation 1) to diversify rankings. However, as we argued in Section 1 , setting this parameter is not always obvious and depends on the characteristics of the result set. In Section 5.2, we provide evidence to further support this claim. We compare with two commonly used approaches for ranking results: 1. Baseline 1 (REL): In this approach, the results were 2. Baseline 2 (MMR-): As a second baseline, we Note that, for a fair comparison, we used MMR both as a baseline and to compute in ADA algorithm. We chose MMR since it outperforms other algorithms in terms of time and generates quality results [5] . However, our use of MMR does not preclude the use of other diversification algorithms, e.g. GMC, GNE [5], which may produce better quality results but take more time compared to MMR [10] . Next, we describe the relevance and diversity measures used in our experimental evaluation. We reemphasize that computing these measures is orthogonal to our problem and any suitable and versions can be plugged in to our approach. Due to space limitations we omit experiments with additional measures. Computing : Computing diversity involves computing distance between two results. We use the sum of distances between the attribute values ( )  X   X  ( ) . For numeric attributes, we used the Manhattan distance and for categorical attributes, the Kronecker delta function was used between the values of attribute. Computing : In a structured result-set, the relevance of a result depends on relevance of its attribute values. We estimated the relevance of each attribute value by computing the Google Trends scores (see [8] for more details). The rationale for using Go ogle Trends is based on the idea that the relevance of a term can be based on its frequency in a query workload [8]. Since results in satisfy all conditions in , the relevance scorewas computed using the unspecified attributes in by , as was proposed by [8] , where unspecified refers to an attribute that does not match any query condition. For example in Figure 1a, all the records satisfy the query condition "Camera" with their Product attribute. Therefore, we compute the relevance score using the unspecified attributes (e.g. Category, Brand ). Methodology: For each query in Table 1, we picked a result the target object is proportional to its relevance score, which means the results with high relevance scores have a higher chance to be selected as the target object. We then simulated the user navigation until target is reached. Since multiple navigation paths can lead to the target object , we used a randomized simulation [12] to select navigation paths. Note that, given a set of displayed results , the set of conditions that can lead to is . We assumed that the user will select one of these conditions, or go to next page, according to the navigation probabilities (Section 3). For example in Figure 1a, if the target object is #4, and we select Figure 1c as the displayed result subset, the conditions that lead to #4 are "Product=Camera", "Category = DSLR" and "Brand = Nikon". The user would go to the next page if she does not like or know these three conditions. Therefore, in our simulation, we computed as  X  (the probability that the user would not like any condition in ) and as by selecting any condition in . The choice of selecting a condition is proportional to . We used in the experiments in Section 5.2 , 5.3, and showed the findings averaged over 1000 runs (50 random target objects, and 20 runs per target object) for each query. In this section, we present the experimental results of the qualitative evaluation of the three different algorithms ( REL , MMR and our algorithm ADA ). Figures 6(a), 6(b) show the average navigation cost and average number of and reach the target object for the queries of Electronics dataset. Note that, all algorithms require similar number of REFINE actions (i.e. selection of target object conditions) to filter out enough undesired objects (Figure 6b). Since displays results from popular categories, it requires a larger number of relevant target objects. has a fixed ratio of relevance and diversity, which happens to work well for some queries with small number of results like Q 1 , Q 2 and Q 4 , but is ineffective for other queries like Q 3 , Q 6 , where more NEXT PAGE actions are required to find the target object conditions . ADA outperforms the other two algorithms, because of its adaptive nature. As discussed in Section 4, when | | is high, ADA prefers diversity over relevance to pick the Top-k results. As becomes more selective over iterations, ADA switches to preferring relevance. Therefore, by balancing diversity and relevance based on the result set at hand, ADA displays the target object conditions much earlier compared to the other two algorithms. This results in fewer actions, and thus reduces the navigation cost of ADA algorithm (Figure 6a). The improvement of ADA over the other two algorithms is more pronounced for the queries that have large number of results (e.g. Q 3 , Q 5 , Q 6 ). Figures 6(c), 6(d) show the average cost and actions respectively for the queries of dataset. Similar to the Electronics dataset , ADA outperforms the other two algorithms for all the queries of . Since the dataset is homogeneous, and perform slightly better as compared to Electronics dataset, due to less variability in attribute conditions. We also compare the average navigation cost incurred by the three algorithms, REL , MMR and ADA , with the expected optimal navigation cost computed by solving Equations 2 and 3. Due to the exponential complexity, we compute the expected optimal cost for smaller sizes of initial result sets (R Q parameter (k). Table 2 shows the average navigation costs for |R Q | = 100 and k = 5 across all queries for the two datasets Electronics and . We see that our algorithm ADA is only 1.07 and 1.03 times worse than the optimal for the Electronics and datasets respectively. For MMR and REL , these factors are 1.36 (1.32) and 1.69 (1.65) respectively for the Electronics ( ) dataset.
 Figure 7 shows average navigation cost of with increasing trade-off ( X ) values (high  X  value implies preference to diversity over relevance) for four queries from Table 1. The results of the other queries are shown in [28] . Since ADA is independent of value, therefore the cost of is shown as a straight line. We skipped since it incurs higher cost compared to ADA and optimal for a given dataset or even for a particular query. Intuitively  X  should change adaptively, at each navigation step, depending on the characteristics of the result set. By balancing the relative importance of relevance and diversity adaptively at each step, ADA shows better performance (on average) compared to with a fixed . Figure 7: Average Navigation Cost vs. Tradeoff ( X ) values We also perform experiments while varying the model parameters ( ). The results depict that the overall cost of ADA increases at a slower rate with the model parameters compared to and [28]. We now present the performance results of REL , MMR and our ADA algorithms. Table 3 shows the average (across all queries) computation (CPU) times taken by each of these algorithms to reach the target object. As expected, the relevance-only algorithm ( REL ) takes the shortest time among all the algorithms. Computing diversity is a costly operation since it involves computation of distance between all pairs of results. As a result any algorithm that incorporates diversity is much slower as compared to REL ; our implementation of MMR is three times slower as REL . Our algorithm ( ADA ) performs this distance computation over all future navigations and therefore is slower than MMR by a factor of 1.6. While ADA takes more time to compute the set of paginated results, it is very effective in reducing the time or effort incurred by users to navigate such diverse result sets (discussed in Section 6). We also examine the scalability of our algorithm ( ADA ) by almost linearly with result set size [28] . In this section, we present the results of a user study that we conducted at Amazon Mechanical Turk ( MTurk ) [26] using the  X  X ord X  ), and for each query we created a set of search tasks; car with Color = Green). We asked the users, starting from the (according to the relevance score defined in Section 5.1) that satisfies all the target conditions. We repeated the experiment for the four different ranking algorithms: REL (  X  ), MMR (  X  ), ADA (  X  -independent) and a diversity -only baseline, DIV , which constructs the k -result subset greedily at each step by maximizing the score function (Equation 1); i.e. with  X  . The reason that we asked users to find the best and not any result is to avoid giving an unfair advantage to methods biased towards diversity like DIV which may help the user to find a satisfying result, but this result may have low relevance. Table 4 shows the list of initial queries, their results X  cardinality, the target conditions, and the cardinality of results that satisfy all the target co nditions. The page size is set to 10. Each task was completed by 36 MTurk users; we present the average results. Figures 8(a) and 8(b) show the average time taken and average number of actions executed respectively, by users to find the best target object. As seen in Figure 8(b), if we have more target chances of getting a desired target condition on a given page increases. This increases the probability of REFINE action and, therefore, DIV performs better (Figure 8(b)) than the other two baselines REL, MMR, and slightly worse that our algorithm ADA, which prefers diversity over relevance during the initial steps. If we decrease the number of target conditions, the performance of DIV degrades, especially if multiple results satisfy all target conditions (as seen for the other queries), since the user needs to find the best and not any object. For Q Q 24 , MMR ( ) and ADA perform similarly, which intuitively shows that 0.5 happens to be the ideal balance between relevance and diversity for these two queries. This is clearly not that case for other queries such as Q takes longer time even compared to the relevance-based REL . As shown by the average values in Figure 8(a), ADA reduces the navigation time significantly compared to all other algorithms. On average, ADA is faster by a factor of 2.04 (p-value 0.004), 1.97 (p-value 0.001) and 1.66 (p-value 0.0002) over REL , MMR and DIV, respectively. This significant improvement is because of the smaller number of actions incurred by ADA compared to the other three algorithms (Figure 8(b)). Figure 9 shows the actual user navigation time vs. the estimated cost (using our cost model in Section 3) for the 10 different queries using the four different algorithms, where for each query we average over all users. The figure and the trend line show a clear correlation, and specifically a linear relationship, which confirms the validity of the cost model. Diversification has recently been introduced in search engines and recommendation systems to increase user satisfaction. [6] [17] use coverage approaches to cover diverse aspects of search space. [17] expresses the degree of diversification by a setting a parameter which also determines the size of final result set. [6] operates on Web documents and selects diverse documents to cover many different interpretations of the query. [18] provides diversity using the content of the recommendations and the past history of the user. [19] presents a method based on medoids clustering to select a set of diverse and highly-ranked items to recommend to a user. However, none of these approaches considers the problem of how to minimize the total navigation cost incurred by the user to find the target object by considering subsequent navigation steps. In this paper, we have addressed this concern by introducing a navigation cost model (Section 2). Diversification is being used along with relevance in diversification as a bi-criteria optimization, which uses a fixed trade-off value for relevance and diversity. In Section 5, we have shown that different search tasks require different ideal trade-off value. Some learning methods [4] [16] have been proposed to learn the trade-off value. However, these methods rely on training data provided by the experts which is expensive and difficult to obtain in all cases. [25] proposes a dynamic ranking model for interactive user feedback. The ranking is based on the history of other users. In contrast, our ranking function aims to minimize the expected user effort. Threshold based techniques, a variant of the optimization problem, have been proposed in [11] to solve the diversification problem. These approaches consider a threshold value of relevance and maximize the diversity between results (or vice versa). Setting a threshold value is hard, and depends on the domains. Moreover, [5] shows a comparison between several diversification approaches where MMR (the baseline used in this paper) clearly outperforms the threshold based approach in both quality and time. Our approach does not require the threshold value, and can adaptively set the balance between relevance and diversity for different tasks. Faceted Search has been shown to be effective in reducing the user effort and time required to navigate large result sets of structured databases. For a given query, these approaches compute the best facet conditions and matching results to display to the user [12] [21] [22] . However, this model is not suitable for our setting of limited screen size, where we cannot display separately faceted conditions and results . Instead, our results serve a dual purpose, since a user can click on results X  conditions to refine her navigation. We described a novel framework for adaptive diversification of query results that dynamically adjusts the relevance and diversity of displayed results with the aim to minimize the total expected user navigation cost to reach the desired target objects. Based on this framework, we prove that the problem is NP-hard and we present an efficient approximate algorithm that computes the best set results to display, by dynamically balancing relevance and diversity at each query step. We experimentally evaluate the performance of our proposed algorithm and show that it outperforms state-of -the-art algorithms. A Mechanical Turk user study confirms our findings and validates our navigation model. As a future work, we plan to extend our navigation model where the user can update/delete the selected conditions during the navigation process. This project was partially supported by NSF grant s IIS -1161997, IIS -1216007, and a Samsung GRO grant. [1] C. Clarke, M. Kolla, G. Cormack, O. Vechtomova, A. [2] H. Tong , J. He , Z. Wen, R. Konuru, and C. Lin . Diversified [3] E. Demidova, P. Fankhauser, X. Zhou, and W. Nejdl. [4] R. Santos , C. Macdonald , and I . Ounis . Selectively [5] M. Vieira, H. Razente, M. Barioni, M. Hadjieleftheriou, D. [6] R. Agrawal, S. Gollapudi, A. Halverson, and S. Ieong. [7] F. Radlinski , P. Bennett , B. Carterette, and T . Joachims. [8] S. Chaudhuri, G. Das, V. Hristidis, G. Weikum. [9] K. Raman, P. Shivaswamy,and T . Joachims. Online [10] J. Carbonell and J. Goldstein. The Use of MMR, Diversity-[11] L. Qin, J. X. Yu, and L. Chang: Diversifying Top-K [12] A. Kashyap, V. Hristidis, and M. Petropoulos. FACeTOR: [13] M. J. McGill, G. Salton. Introduction to Modern [14] E. Vee, U. Srivastava, J. Shanmugasundaram, P. Bhat, and [15] K. Liu, E. Terzi, and T. Grandison. Highlighting Diverse [16] Y. Yue, and T. Joachims. Predicting Diverse Subsets Using [17] M. Drosou, E. Pitoura: DisC Diversity: Result [18] C. Yu, L. Lakshmanan, and S. A.Yahia. It Takes Variety to [19] R. Boim, T. Milo, S. Novgorodov. Diversification and [20] C.-N. Ziegler, S. McNee, J. Konstan, G. Lausen: Improving [21] S. B. Roy, H. Wang, G. Das, U. Nambiar, and M. Mohania. [22] K. Chakrabarti, S. Chaudhuri, and S. Hwang. Automatic [23] M. Hasan, A. Mueen, V. Tsotras and E. Keogh . [24] M. Hasan, A. Mueen and V. Tsotras. Distributed [25] C. Brandt, T. Joachims, Y. Yue and J. Bank. Dynamic [26] Amazon Mechanical Turk. https://www.mturk.com [27] eMarketer Report [28] Extended Version of the paper appears at: 
