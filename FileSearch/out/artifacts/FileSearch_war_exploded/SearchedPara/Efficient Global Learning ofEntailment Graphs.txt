 Stanford University Tel Aviv University Bar-Ilan University Bar-Ilan University Entailment rules between predicates are fundamental to many semantic-inference applications.
Consequently, learning such rules has been an active field of research in recent years. Methods for learning entailment rules between predicates that take into account dependencies between entailment graphs). Our methods are able to scale to a large number of predicates by exploiting
We apply our methods on two data sets and demonstrate that our methods find high-quality solutions faster than methods proposed in the past, and moreover our methods for the first time scale to large graphs containing 20,000 nodes and more than 100,000 edges. 1. Introduction
Performing textual inference is at the heart of many semantic inference applications, such as Question Answering (QA) and Information Extraction (IE). A prominent generic paradigm for textual inference is Textual Entailment (Dagan et al. 2013). In textual en-tailment, the goal is to recognize, given two text fragments termed text and hypothesis , whether the hypothesis can be inferred from the text. For example, the text Cyprus was invaded by the Ottoman Empire in 1571 implies the hypothesis The Ottomans attacked Cyprus .
 rules (Ravichandran and Hovy 2002; Shinyama and Sekine 2006; Berant and Liang 2014) or equivalently, inference rules X  X hat is, rules that describe a directional inference rela-tion between two fragments of text. An important type of entailment rule specifies the entailment relation between natural language predicates, for example, the entailment rule X invade Y  X  X attack Y can be helpful in inferring the aforementioned hypothesis. Consequently, substantial effort has been made to learn such rules (Lin and Pantel 2001; Sekine 2005; Szpektor and Dagan 2008; Schoenmackers et al. 2010; Melamud et al. 2013). z imply the rule x  X  z . For example, from the rules X reduce nausea  X  X help with nausea and X help with nausea  X  X associated with nausea we can infer the rule X reduce nausea  X 
X associated with nausea (Figure 1). Accordingly, Berant, Dagan, and Goldberger (2012) proposed taking advantage of transitivity to improve learning of entailment rules. They modeled learning entailment rules as a graph optimization problem, where nodes are predicates and edges represent entailment rules that respect transitivity. To solve this optimization problem, they formulated it as an Integer Linear Program (ILP) and used an off-the-shelf ILP solver to find an exact solution. Indeed, they showed that applying global transitivity constraints results in more accurate graphs (known as entailment graphs ) than methods that ignore the property of transitivity.
 set of edges respecting transitivity is NP-hard, and practically, transitivity constraints impose substantial restrictions on the scalability of the methods. In fact, in some cases finding the optimal set of edges for entailment graphs with even  X  50 nodes was quite slow.
 advantage of structural properties such as transitivity, but substantially reduce the com-putational cost of inference, thus allowing us to solve the aforementioned optimization problem on very large graphs.
 222 tion that even if an entailment graph contains many predicates, most of them do not entail one another, and thus we can decompose the graph into smaller components that can be solved more efficiently. For example, the predicates X parent of Y , X child of Y and X relative of Y are independent from the predicates X works with Y , X boss of Y , and
X manages Y , and thus we can consider each one of these two sets separately. We prove that finding the optimal solution for each of the smaller components results in a global optimal solution for our optimization problem.
 ing a transitive set of edges in each one of the smaller components. It is based on a novel modeling assumption that entailment graphs exhibit a  X  X ree-like X  property, which we predicates X related to nausea and X associated with nausea form a cycle. However, these two predicates are synonymous, and if they were merged into a single node, then the graph would become a tree. We propose a simple iterative approximation algorithm, where in each iteration a single node is deleted from the graph and then inserted back constraint that entailment graphs must be forest reducible, then each iteration can be performed in linear time. This results in an algorithm that can scale to entailment graphs containing tens of thousands of nodes.
 entailment graphs where predicates are typed , that is, the arguments are restricted to belong to a particular semantic type (for instance, X person using our algorithm, we can substantially improve runtime, suffering from only a slight reduction in the quality of learned entailment graphs. The second data set includes a much larger graph containing 20,000 untyped nodes, where applying state-of-the-art methods that use an ILP solver is completely impossible. We run our algorithm on this data set and demonstrate that we can learn knowledge bases with more than 100,000 entailment rules at a higher precision compared with local learning methods. methods that handle each pair of predicates independently of other predicates, and then describe global methods (Section 2.2), that is, methods that take into account multiple predicates simultaneously. Section 3 is the core of the article and describes our main algorithmic contributions. After formalizing entailment rule learning as a graph optimization problem, we present the two steps of our algorithm. Section 3.1 describes the first step, in which a large entailment graph is decomposed into smaller compo-nents. Section 3.2 describes the second step, in which we develop an efficient heuristic approximation based on the assumption that entailment graphs are forest reducible.
Section 4 describes experiments on the first data set containing medium-sized entail-ment graphs with typed predicates. Section 5 presents an empirical evaluation on a large graph containing 20,000 untyped predicates. We also perform a qualitative analysis in
Section 5.4 to further elucidate the behavior of our algorithm. Section 6 concludes the article.
 et al. 2012), but expands over it in multiple directions. Empirically, we present results on a novel data set (Section 5) that is by orders of magnitude larger than in the past.
Algorithmically, we present the Tree-Node-And-Component-Fix algorithm, which is an extension of the Tree-Node-Fix algorithm presented in Berant et al. (2012) and achieves best results in our experimental evaluation. Theoretically, we provide an NP-hardness proof for the Max-Trans-Forest optimization problem presented in Berant et al. (2012) and an ILP formulation for it. Last, we perform in Section 5.4 an extensive qualitative analysis of the graphs learned by our local and global algorithms from which we draw conclusions for future research directions. 2. Background
In this section we describe prior work relevant for entailment rule learning. First, we describe local methods that estimate entailment for a pair of predicates, focusing on methods that we employ in this article. Then, we describe global methods that perform inference over a larger set of predicates. Specifically, we provide details on the method and optimization problem developed by Berant, Dagan, and Goldberger (2012) for which we propose scalable inference algorithms in this article. Last, we survey some other related work in NLP that uses global inference. 2.1 Local Learning
In local learning, given a pair of predicates ( i , j ) we would like to determine whether (1) lexicographic resources, (2) co-occurrence, and (3) distributional similarity. We briefly describe the first two and then expand more on distributional similarity, which is the most commonly used source of information.
 information may be extracted. For example, the hyponymy, toponymy, and synonymy relations in WordNet (Fellbaum 1998) can be used to detect entailment between nouns and verbs. Although WordNet is the most popular lexicographic resource, other re-sources such as CatVar, Nomlex, and FrameNet have also been utilized to extract inference rules (Meyers et al. 2004; Budanitsky and Hirst 2006; Szpektor and Dagan 2009; Coyne and Rambow 2009; Ben Aharon, Szpektor, and Dagan 2010).
 predicates by examining their co-occurrence in a large corpus. For example, the sentence people snore while they sleep provides evidence that snore  X  sleep . While most pattern-based methods focused on identifying semantic relations between nouns (for example,
Hearst patterns [Hearst 1992]), several works (Pekar 2008; Chambers and Jurafsky 2011; Weisman et al. 2012) attempted to extract relations between predicates as well.
Chklovsky and Pantel (2004) used pattern-based methods to generate the commonly used VerbOcean resource.
 age. Distributional similarity is therefore used to automatically construct broad-scale resources. Distributional similarity methods are based on the  X  X istributional hypoth-esis X  (Harris 1954) that semantically similar predicates occur with similar arguments. Quite a few methods have been suggested (Lin and Pantel 2001; Szpektor et al. 2004; Bhagat, Pantel, and Hovy 2007; Szpektor and Dagan 2008; Yates and Etzioni 2009;
Schoenmackers et al. 2010), which differ in terms of the specifics of the ways in which compute feature vector similarity. Next, we elaborate on the methods that we use in this article.

For each binary predicate, Lin and Pantel compute two sets of features F 224 corpus. Given a predicate u and its feature set for the X variable F is weighted by pointwise mutual information between the predicate and the feature: over the corpus. Given two predicates u and v , the Lin measure (Lin 1998) is computed for the variable X in the following manner: two variables: If DIRT ( u , v ) is high, this means that the templates u and v share many  X  X nformative X  arguments and so it is possible that u  X  v .
 at unary predicates , that is, predicates with a single variable such as X treat . Secondly, they computed a directional score that is more suited for capturing entailment relations compared to the symmetric Lin score. They proposed that if for two unary predicates u  X  v , then relatively many of the features of u should be covered by the features of v . This is captured by the asymmetric Cover measure (Weeds and Weir 2003):
The final directional score, termed BInc (Balanced Inclusion), is the geometric average of the Lin measure and the Cover measure.
 a single argument. However, it is clear that although this alleviates sparsity problems, considering pairs of arguments jointly provides more information. Yates and Etzioni (2009), Schoenmackers et al. (2010), and even earlier, Szpektor et al. (2004), presented methods that compute semantic similarity based on pairs of arguments.
 predicates may have different meanings and different entailment relations in different contexts. Some works resolved the problem of ambiguity by representing predicates with argument variables that are typed (Pantel et al. 2007; Schoenmackers et al. 2010).
For example, argument variables in the work of Schoenmackers et al. were restricted has attracted substantial attention recently is to represent the various contexts in which a predicate can appear in a low-dimensional latent space (for example, using Latent
Dirichlet Allocation [Blei, Ng, and Jordan 2003]) and infer entailment relations between predicates based on the contexts in which they appear (Ritter, Mausam, and Etzioni 2010;  X  OS  X  eaghdha 2010; Dinu and Lapata 2010; Melamud et al. 2013). In the experiments presented in this article we will use the representation of Schoenmackers et al. in one experiment, and ignore the problem of predicate ambiguity in the other. 2.2 Global Learning large number of natural language phrases, one can use the dependencies between the relations to improve accuracy. A natural way to model that is with a graph where nodes are phrases and edges represent semantic similarity. Snow, Jurafsky, and Ng (2006) presented one of the early examples of global learning in the context of learning noun taxonomies. In their work, they enforced a transitivity constraint over the taxonomy using a greedy inference procedure and demonstrated that this improves the quality of the taxonomy. Transitivity constraints were also enforced by Yates and Etzioni (2009), who proposed a clustering algorithm for learning undirected synonymy relations.
Nakashole, Weikum, and Suchanek (2012) learned a taxonomy of binary predicates and also enforced transitivity with a greedy algorithm.
 tailment relations between predicates. In this article we present scalable approximation algorithms for the optimization problem they propose, and so we provide further detail resource, such as WordNet, and the output is a set of entailment rules that respect the step, a set of predicates is extracted from the corpus and a local entailment classifier is trained based on examples automatically generated from the lexicographic resource.
At this point, we can derive for each pair of predicates ( i , j ) a score w whether i  X  j .
 nodes and edges represent entailment rules. Using the local scores they look for the set of edges E that maximizes the objective function P ( i , j )  X  E edges respect transitivity. They show that this optimization problem is NP-hard and find an exact solution using an ILP solver over small graphs. They also avoid problems present efficient and scalable heuristic approximation algorithms for the optimization problem they propose.
 global inference problems. Do and Roth (2010) suggested a method for the related task of learning taxonomic relations between terms. Given a pair of terms, they construct a small graph that contains the two terms and a few other related terms, and then impose constraints on the graph structure. They construct these small graphs because their work is geared towards scenarios where relations are determined on-the-fly for a given pair of terms and no global knowledge base is ever explicitly constructed. Because they independently construct a graph for each pair of terms, their method easily produces solutions where global constraints, such as transitivity, are violated.
 (Martins, Smith, and Xing 2009). In LP relaxation, binary variables are replaced by continuous variables, transforming the problem from an ILP to a Linear Program (LP), which is polynomial. An LP solver is then applied, and variables that are assigned a fractional value are rounded to their nearest integer, so many violations of transitivity may occur. The solution when applying LP relaxation is not a transitive graph; we will show in Section 4 that our approximation method is substantially faster.
 proximation method that has been extensively utilized is dual decomposition (Sontag,
Globerson, and Jaakkola 2011). Dual decomposition has been successfully applied in 226 tasks such as Information Extraction (Reichart and Barzilay 2012), Machine Translation (Chang and Collins 2011), Parsing (Rush et al. 2012), and Named Entity Recogni-tion (Wang, Che, and Manning 2013). To the best of our knowledge, it has not yet been applied for the task of learning entailment relations. The graph decomposition method we present in Section 3.1 can be viewed as an ideal case of dual decom-position, where we can decompose the problem into disjoint components in a way that we do not need to ensure consistency of the results obtained on each component separately. 3. Efficient Inference
Our goal is to learn a large knowledge base of entailment rules between natural language predicates. Following Berant, Dagan, and Goldberger (2012), we formu-constraint.

Berant, Dagan, and Goldberger (2012) have demonstrated that this modeling assump-tion holds for focused entailment graphs , that is, graphs in which predicates are disam-biguated by one of their arguments. For example, a graph that focuses on the concept nausea might contain a en entailment rule between predicates such as X prevents nausea  X  X affects nausea , where the predicate X prevent Y is disambiguated by the instantiation of the argument nausea . In this work, we will examine this modeling assumption for more general graphs. In Section 4 we show that transitivity holds in typed entailment graphs , that is, graphs where each predicate specifies the semantic type of its arguments transitivity when predicates do not carry any typing information (for example, X prevent
Y ); and we observe that in this setting the assumption of transitivity is often violated because of the predicate ambiguity. Nevertheless, we show that even in this set-up we can empirically take advantage of the transitivity assumption.
 w : V  X  V  X  R be an entailment weighting function. Given a pair of predicates ( i , j ), a entailment transitive graph that is most consistent with the local cues. Formally, our goal is to find the directed graph G = ( V , E ) that maximizes the sum of edge weights
P nodes ( i , j , k ), if ( i , j )  X  E and ( j , k )  X  E , then ( i , k )  X  E . (which we term Max-Trans-Graph) is NP-hard, and provided an ILP formulation for it. Let x ij be an indicator for whether i  X  j , then x = { x following ILP:
The objective function is the sum of weights over the edges of G , and the constraint x + x jk  X  x ik  X  1 on the binary variables enforces transitivity (i.e., x that x ik = 1). The weighting function w is trained separately using supervised learning Sections 4 and 5.
 optimize. Assume that for each pair of nodes ( i , j ), we are given a probability p p ( x ij = 1) that i  X  j (the probability that i ; j is denoted by p ing a uniform probability over graphs, the posterior probability (which can also be viewed as the likelihood) of a graph, represented by an edge-set x , is:
It can be easily verified that: 1
Hence, such that  X  X onst X  is a scalar that does not depend on x and
The optimal entailment graph, therefore, is arg max x p ( x ) = arg max entailment graph is obtained as the solution of the ILP maximization problem (3). solver, but because ILP is NP-hard, this does not scale well; the number of variables is O ( | V | 2 ) and the number of constraints is O ( | V | heuristic algorithm that empirically provides high-quality solutions for this optimiza-tion problem in graphs with tens of thousands of nodes.
 a structural assumption that entailment graphs are relatively sparse X  X hat is, most predicates do not entail one another. This allows us to decompose the graph into smaller components in a way that guarantees that an exact solution for each one of the compo-nents results in an exact solution for Max-Trans-Graph. However, often even after de-composition, components are too large and finding an exact solution is still intractable. 228 entailment graphs exhibit a  X  X ree-like X  property and are very similar to a novel type of graph, which we term forest-reducible graph . We utilize this property to develop an iterative efficient approximation algorithm for learning the graph edges, where each iteration takes linear time. We also prove that finding the optimal forest-reducible graph is NP-hard.
 that using transitivity substantially improves performance and that our methods dra-entailment graphs. 3.1 Entailment Graph Decomposition
The first step of our algorithm takes advantage of graph sparsity: Most predicates in language do not entail one another. Thus, it might be possible to decompose entailment graphs into small components and solve each component separately.
 term any directed edge, whose two nodes belong to different subsets, a crossing edge . Proposition 1
If we can partition a set of nodes V into disjoint sets V problem (3) does not contain any crossing edge.
 tains a non-empty set of crossing edges E cross . We can construct E then the violation is caused by omitting the edges in E cross
E is impossible because we omitted all crossing edges. Thus, E
E opt , contradiction. Hence, E cross is empty.
 undirected graph with the node set V and with an edge connecting i and j if either w ij &gt; 0 or w ji &gt; 0, then find its connected components, and finally solve each component then we obtain an optimal (not approximate) solution to the optimization problem (3) for the whole graph. Finding the undirected edges (Line 1) and computing connected components (Line 2) can be performed in O ( V 2 ). Thus, in this case the efficiency of the algorithm is dominated by the application of an ILP solver (Line 4).
 exact solution with an ILP solver, applied on each component separately, without resorting to any approximation. To further extend scalability in this setting we use a cutting-plane method (Kelley 1960). Cutting-plane methods have been used in the past, for example, in dependency parsing (Riedel and Clarke 2006). The idea is that even if we omit all transitivity constraints, we still expect most transitivity constraints to be satisfied, given a good weighting function w . Thus, it makes sense to avoid specifying formalized in Algorithm 2.
 the active constraints. Lines 4 and 5 find the violated constraints and add them to the active constraints. The algorithm halts when no constraints are violated. The solution is clearly optimal because we obtain a maximal solution for a less-constrained problem that does not violate any transitivity constraint.
 manner: For all edges ( i , j ) and ( j , k ) that are in the current solution E performs very fast in practice.
 components and uses Algorithm 2 to find an exact solution for each component. How-ever, because the problem is NP-hard, this will still fail once components become large.
Next, we describe the second step of our method, which replaces Algorithm 2 with an efficient approximation that can scale to much larger graphs. We will show in Section 4 that the solutions obtained by the approximation algorithm are almost as good as the exact solution on a data set where finding an exact solution is feasible. 3.2 Efficient Tree-Based Approximation
The approximation we present in this section is based on a conjecture that entailment graphs exhibit a  X  X ree-like X  property, that is, they can be reduced into a structure similar to a directed forest, which we term forest-reducible graph (FRG). Although FRGs are a more constrained class of directed graphs, we prove that restricting our optimization 230 problem to FRGs does not make the problem fundamentally easier, that is, the problem remains NP-hard (see Appendix). Then, we present in Section 3.2.2 our iterative approx-imation algorithm, where in each iteration a node is removed and re-attached back to the graph in a locally optimal way. Combining this scheme with our conjecture about the graph structure yields a linear algorithm for node re-attachment.
 eling assumption about the tree-like structure of entailment graphs and empirically demonstrate its validity. Second, we exploit this assumption to develop a polynomial approximation algorithm for learning entailment graphs that can scale to much larger graphs than in the past. 3.2.1 Forest-Reducible Graph. The predicate entailment relation, described by our entail-ment graphs, is typically from a  X  X emantically specific X  predicate to a more  X  X eneral X  one. Thus, intuitively, the topology of an entailment graph is expected to be  X  X ree-like. X  In this section we first formalize this intuition and then empirically analyze its validity.
This property of entailment graphs is an interesting topological observation on its own, but also enables the efficient approximation algorithm of Section 3.2.2.
 a child of node j , and j a parent of i . 2 A directed forest is a DAG where all nodes have no more than one parent. A strongly connected component in a directed graph node. In entailment graphs, strongly connected components correspond to semantically equivalent predicates.
 the nodes X common in Y and X frequent in Y , and in addition the node X be epidemic the following operations. Any directed graph G can be converted into a Strongly-
Connected-Component (SCC) graph in the following way: Every strongly connected component is contracted into a single node, and an edge is added from SCC S
S 2 if there is an edge in G from some node in S 1 to some node in S always a DAG (Cormen et al. 2002), and if G is transitive, then the SCC graph is also transitive. The graph in Figure 2b is the SCC graph of the one in Figure 2a, but is still not a directed forest because the node X be epidemic in Y has two parents. to node j if there is a path in G from i to j . The transitive reduction of G is obtained by removing all edges whose absence does not affect its transitive closure. In DAGs, the result of transitive reduction is unique (Aho, Garey, and Ullman 1972). We thus define its SCC graph. The graph in Figure 2c is the reduced graph of the one in Figure 2a and is a directed forest. We say a graph is a forest-reducible graph if its reduced graph is a directed forest.
 meaning than the one on the right-hand-side. For instance, in Figure 2a X be epidemic in Y (where X is a type of disease and Y is a country) is more specific than X common in Y and (a) (b) (c)
X frequent in Y , which are equivalent, while X occur in Y is even more general. Accord-ingly, the reduced graph in Figure 2c is an FRG. We note that this is not always the case:
For example, the entailment graph in Figure 3 is not an FRG, because X annex Y entails both Y be part of X and X invade Y , while the latter two do not entail one another. How-ever, we hypothesize that this scenario is rather uncommon. Consequently, a natural variant of the Max-Trans-Graph problem is to restrict the required output graph of the optimization problem (3) to an FRG. We term this problem Max-Trans-Forest. ysis. We sampled seven gold standard typed entailment graphs (that is, graphs where 232 predicates specify the semantic type of their arguments, such as X from the data set described in Section 4, manually transformed them into FRGs by deleting a minimal number of edges, and measured recall over the set of edges in each graph (precision is naturally 1.0, as we only delete gold-standard edges). The lowest edges converts a typed entailment graph into an FRG. Further support for the practical validity of this hypothesis is obtained from our experiments on typed entailment graphs in Section 4. In these experiments we show that exactly solving Max-Trans-Graph and Max-Trans-Forest (with an ILP solver) results in nearly identical performance. In
Section 5.4 we qualitatively analyze the validity of the FRG assumption in untyped entailment graphs (where predicates are of the form X prevents Y ) and find that this assumption does not always hold, because of predicate ambiguity.
 if all nodes in its reduced graph have no more than one parent. It can be verified that i  X  k , then either j  X  k or k  X  j (or both). This constraint can be stated in a linear form: x + x ik  X  x jk  X  x kj  X  1. Therefore, adding this new type of constraint to the ILP given in
Equation (3) results in a formulation for Max-Trans-Forest: A natural question is whether there is a simpler (polynomial) solution for Max-Trans-Forest that avoids the need for an ILP solver. In the Appendix we prove that Max-Trans-
Forest is also an NP-hard problem by a polynomial reduction from the X3C problem (Garey and Johnson 1979). Readers who are not interested in the proof can safely skip the Appendix. 3.2.2 Approximation Algorithm. In this section we present Tree-Node-Fix and Tree-Node-And-Component-Fix, which are efficient approximation algorithms for Max-Trans-Forest, as well as Graph-Node-Fix, an approximation for Max-Trans-Graph.

Tree-Node-Fix. The scheme of Tree-Node-Fix (TNF) is the following. First, an initial FRG is constructed, using some initialization procedure. Then, at each iteration a single node v is re-attached (see below) to the FRG in a way that improves the objective function.
This is repeated until the value of the objective function can no longer be improved by re-attaching a node.
 its adjacent edges) and connecting it back with a better set of edges, while maintaining the constraint that it is an FRG. This is done by considering all possible edges from/to the other graph nodes and choosing the optimal subset, while the rest of the graph edges remain fixed. For example, in Figure 2, one way of re-attaching the node X common in Y is to add it as a direct child of X occur in Y that is not a synonym of X frequent in Y . This will result in deletion of the edges X common in Y  X  X frequent in Y , X frequent in
Y  X  X common in Y , and also X be epidemic in Y  X  X common in Y , because otherwise the resulting graph will not be an FRG. We will show that re-attachment can be efficiently performed in linear time using dynamic programming.
 amounts to optimizing a linear objective: while maintaining the FRG constraint, where the variables x ( v )  X  x are indicators for all pairs of nodes involving v . We approximate a solution for Equation (3) by iteratively objective function cannot decrease, because the optimization algorithm considers the previous graph as one of its candidate solutions.
 consider the structure of the directed forest G red just before v is re-inserted, and examine the possibilities for v  X  X  insertion relative to that structure. We start by defining some helpful notations. Every node c  X  V red is a strongly connected component in G . Let v be an arbitrary representative node in c (we can choose any node v graph G is transitive, and c is a strongly connected component). We denote by S the sum of weights from all nodes in c and their descendants to v , and by S sum of weights from v to all nodes in c and their ancestors:
Note that { x v 1. Inserting v into an existing component c  X  V red (case 1, see Figure 4a). 2. Inserting v as a new component, which breaks into two subcases: (a) 234
Note that v cannot form a new component that contains other nodes as well, because the rest of the graph is fixed.
 this score is computed in each of the three cases.
 all nodes in c and their descendants to v and from v to all nodes in c and their ancestors.
The score (9) in this case is choosing v  X  X  children in G red is substantially constrained. A node that is not a descendant of c cannot become a child of v , because this would create a new path from that node to c and would require by transitivity to add a corresponding directed edge to c (but all graph edges not connecting v are fixed). Moreover, only a direct child of c can choose v as a parent instead of c (Figure 4b), because for any other descendant of c , v would become a second parent, and G red will no longer be a directed forest (Figure 4b X ). Thus, this case requires adding in G edges from v to all nodes in c and their ancestors; additionally, their descendants to v . Crucially, although the number of possible subsets of c  X  X  children in G red is exponential, the fact that they are independent trees in G over them one by one, and decide for each one whether it will be a child of v or not, depending on whether S v -in ( d ) is positive. Therefore, the score (9) in this case is: where child ( c ) are the children of c .
 become children of v . In this case for each chosen root r we add in G edges from the nodes in r and their descendants to v . Again, each root can be examined independently.
Therefore, the score (9) of re-attaching v is: where the summation is over the roots of G red .
 where p is the parent of c in G red . These recursive definitions allow computing in linear time S v -in ( c ) and S v -out ( c ) for all c (given G over the cases for re-attaching v . S v -in ( c ) is computed going over V (post-order), and S v -out ( c ) is computed going over V (Cormen et al. 2002), and it is easy to verify that transitive reduction in FRGs is also Cases 1 and 2b are trivially linear and in case 2a we go over the children of all nodes in
V red . As the reduced graph is a forest, this simply means going over all nodes of V and so the entire algorithm is linear.
 bound the number of iterations over all nodes, the overall complexity is quadratic. This is dramatically more efficient and scalable than applying an ILP solver. Empirically, we found that TNF converges after 5 X 10 iterations.

Tree-Node-and-Component-Fix. Assuming that entailment graphs are FRGs allows us to use the node re-attachment operation in linear time. However, this assumption also en-ables performing other graph operations efficiently. We now suggest a natural extension to the TNF algorithm that better explores the space of FRGs.
 sider, for instance, the reduced graph in Figure 5. In this graph, nodes l , m , and n are direct children of node k , but suppose that in the optimal solution they are all children of node j . Reaching the optimal solution would require three independent re-attachment operations, and it is not clear that each of the three alone would improve the objective function value. However, if we allow re-attachment operations over components in the SCC graph, then we would be able to re-attach the strong connectivity component containing the nodes l , m , and n in a single operation. Thus, the idea of our extended
TNF algorithm is to allow re-attachment of both nodes and components . We term this algorithm Tree-Node-and-Component-Fix (TNCF).
 algorithm uses one possible variant. In TNCF we first perform node re-attachment until convergence as in TNF (after initialization), but then compute the SCC graph and perform component re-attachment until convergence. Component re-attachment is identical to node re-attachment, except that we are guaranteed that the reduced graph is a forest. After performing component re-attachment until convergence, we again 236 perform node re-attachments and then component re-attachments and so on, until the entire process converges.

Graph-Node-Fix. The re-attachment strategy described above can be applied without assuming that the graph is an FRG. Next, we show Graph-Node-Fix (GNF), a similar algorithm that uses the re-attachment strategy to obtain an approximate solution for the ILP problem Max-Trans-Graph (3). In this more general case, finding the optimal re-attachment of a node v is done with an ILP solver. Nevertheless, this ILP is simpler than
Equation (3), because we consider only candidate edges involving v . Figure 6 illustrates the three types of possible transitivity constraint violations when re-attaching v . The and the middle and right depict two violations when the edge ( i , k )  X  E , expressed by the constraints in Equation (19). Thus, the ILP is formulated by adding the following constraints to the objective function (9): reduced by an order of magnitude to O ( | V | ) variables and O ( | V | summarize, the complexity of GNF is higher than the complexity of TNF, but it does not require the assumption that entailment graphs are FRGs. 4. Experimental Evaluation: Typed Entailment Graphs
In this and the next section we empirically evaluate the algorithms presented in Sec-prises medium-sized graphs for which obtaining an exact solution is possible, and we demonstrate that our approximation methods substantially improve runtime while causing only a small degradation in performance compared with the optimal solution.
The graphs are also particularly suited for global optimization because graph predicates are typed , which substantially reduces their ambiguity. The second data set (Section 5) contains a graph with tens of thousands of untyped nodes, where exact inference is completely impossible. We show that our methods scale to this graph and that transitivity improves performance even when predicates are untyped. The resulting graph contains more than 100,000 entailment rules that can be utilized in downstream semantic applications.
 ing function w : V  X  V  X  R . We describe how those are constructed before presenting an experimental evaluation. 4.1 Typed Entailment Graphs
As mentioned in Section 2, one of the challenges in global optimization is that tran-sitivity does not always hold when predicates are ambiguous. Schoenmackers et al. (2010) proposed an algorithm for learning inference rules between typed predicates, a representation that substantially reduces ambiguity. We adopt their representation and learn typed entailment graphs . A typed entailment graph (see Figure 7) is a directed graph where the nodes are typed predicates. A typed predicate is a triple ( t of the predicate and the typed variables t 1 , t 2 indicate that the arguments of the predicate belong to the semantic types t 1 , t 2 . Semantic types are taken from a set of types T , where each type t  X  T is a bag of natural language words or phrases. Examples for typed predicates are: conquer ( COUNTRY , CITY ) and contain ( PRODUCT of a typed predicate is a triple ( a 1 , p , a 2 ), or simply p ( a 238 are termed arguments . For example, be common in(asthma,australia) is an instance of be that share the same (unordered) pair of types (such as PLACE wise, the rule would contain unbound variables. Hence, given a set of typed predicates we can immediately decompose them into disjoint subsets X  X ll typed predicates shar-ing the same pair of types define a separate graph that describes the entailment relations between those predicates (see Figure 7).
 the type t 1 is different from the type t 2 , mapping of arguments is straightforward, as in the rule be find in ( MATERIAL , PRODUCT )  X  contain ( are equal we need to specify how arguments are mapped. This is done by splitting each node into two: For example, the node beat ( TEAM , TEAM ) is split into two typed predicates order is reversed such as beat(X team ,Y team )  X  lose to(Y rules such as play(X team ,Y team )  X  play(Y team ,X team plays team A.
 by Schoenmackers et al. (2010). Schoenmackers et al. produced a mapping of 1.1 million arguments into 156 types (Examples for ( argument , TYPE ) pairs are ( exodus ,
COUNTRY ), and ( asthma , DISEASE )), and then utilized the types, the mapped arguments, and 1 million TextRunner tuples (Banko et al. 2007) to generate a set of 10,672 typed predicates. 3 Because entailment can only occur between predicates that share the same types, we decomposed the 10,672 typed predicates into 2,303 typed entailment graphs.
The largest graph contains 188 nodes and the total number of potential rules is 263,756.
The advantage of typing predicates is that it substantially reduces ambiguity, while still maintaining rules of wide applicability. 4.2 Training a Local Entailment Classifier
The weighting function w is derived from an entailment score provided by a local classifier. Given a local classifier that provides an entailment score s  X  increases, w ij decreases and becomes negative for more pairs of predicates, rendering the graph more sparse. The probabilistic interpretation of  X  is as follows. For each two nodes let q be a prior probability that an edge exists. For large values of q the graph tends to be dense, and vice versa. Defining  X  as log 1  X  q
Given the weight function w , the task is to find the maximum a posteriori global graph that satisfies predefined constraints such as transitivity. (2012), and we briefly describe it here. The input for training is a lexicographic resource, for which we use WordNet, and a set of tuples, for which we use the 1 million typed
TextRunner tuples provided by Schoenmackers et al. We perform the following steps: 1. Training set generation Positive examples are generated using WordNet 2. Feature representation Each example pair of typed predicates ( p 240 3. Training We sub-sample negative examples and train over an equal 4. Prior knowledge For a small number of pairs of predicates, we might have 4.3 Experimental Evaluation
To evaluate performance, we manually annotated all edges in 10 typed entailment yielded 3,427 edges and 35,585 non-edges, resulting in an empirical edge density of 9%. The data set is publicly available and can be downloaded from http://www-nlp. stanford.edu/joberant/homepage_files/resources/Acl2011Exp.rar. them the graph is first decomposed into components as described in Section 3.1. iff w ij &gt; 0, or in other words iff s ij &gt;  X  .
 applying an ILP solver in a cutting-plane method, as described in Section 3.1. component by applying an ILP solver in a cutting-plane method.

Section 2) on each graph component. We apply the LP solver within the same cutting-plane method to allow for a direct comparison. As mentioned, our goal is to present a method for learning transitive graphs, whereas LP-relax produces solutions that violate compare runtimes against TNF.
 graph is very sparse, that is,  X   X  C for some constant C (set to 1 in our experiments), then solving the graph exactly is not an issue and we use Exact-graph. Otherwise, we initialize by applying Exact-graph in a sparse configuration, that is,  X  = C . not an FRG, it is corrected by a simple heuristic: For every node in the reduced graph
G red that has more than one parent, we choose from its current parents the single one whose SCC is composed of the largest number of nodes in G .
 graphs it provides results that are almost identical to TNF.
 the-art local scores such as DIRT (Lin and Pantel 2001), BInc (Szpektor and Dagan 2008),
Cover (Weeds and Weir 2003), and SR (Schoenmackers et al. 2010) and trains a classifier using these scores. Berant, Dagan, and Goldberger (2010) have demonstrated empiri-compared with using just a single similarity score.
 Berant, Dagan, and Goldberger (2012). It finds the optimal solution for Max-Trans-
Graph, and our goal is to show that we can obtain good performance more efficiently using our approximation methods. Last, LP-relax is a standard approximation method for solving ILPs (Martins, Smith, and Xing 2009).
 and then compute the transitive closure in each component. We empirically found that this adds edges too aggressively and results in very low precision.
 experiments were run on a multi-core 2.5GHz server with 32GB of RAM.
 of edges learned by each algorithm. We measure recall, precision, and F values of the sparseness parameter  X  , and compute the area under the precision-recall curve (AUC) generated. Efficiency is evaluated by comparing runtimes.
 other baselines that use transitivity. Figure 8 compares runtimes of Exact-graph, GNF,
TNF, and LP-relax as  X   X  increases and the graph becomes denser. Note that the y -axis 242
Runtime in seconds of the global algorithms for various  X   X  values. quickly. For  X  = 0 . 3, runtime was already 12 hours and we were unable to obtain re-where both Exact-graph and TNF achieve best F 1 , TNF is 10 times faster than Exact-graph. When  X  = 0 . 5, TNF is 50 times faster than Exact-graph, and so on. Most impor-tantly, runtime for GNF and TNF increases much more slowly than for Exact-graph.
Comparing runtimes for TNF and GNF, we see that the gap between the algorithms decreases as  X   X  increases. However, for reasonable values of  X  , TNF is about four to seven times faster than GNF, and we were unable to run GNF on large graphs, as we report in Section 5.
 more slowly than Exact-graph, but still very fast compared with TNF. When  X  = 0 . 6,
LP-relax is almost 10 times slower than TNF, and when  X  =  X  0 . 1, LP-relax is 200 times slower than TNF. This points to the difficulty of scaling LP-relax to large graphs. Last,
Exact-forest is the slowest algorithm and because it is an approximation of Exact-graph we omit if from the figure for clarity.
 assumptions. Figure 9 (left) shows a pair-wise comparison of Exact-graph and Exact-forest. As is evident, the two curves are very similar, and the maximal F curve and AUC are almost identical. This provides further support for our modeling assumption that entailment graphs are roughly forest-reducible. Figure 9 (right) shows a similar comparison for TNF and GNF. We observe again that the curves are similar and performance is almost identical (maximal F 1 : 0.41, AUC: 0.31), illustrating that using the FRG assumption when using our approximation algorithm is empirically effective.
Max-Trans-Graph, to our most efficient approximation algorithm, TNF, and to No-trans, a baseline that does not use transitivity at all (GNF and LP-relax are omitted from the figure to improve readability). We observe that both Exact-graph and TNF substan-tially outperform No-trans and that TNF X  X  graph quality is only slightly lower than
Exact-graph (which is extremely slow). We report in the caption the maximal F curve and AUC in the recall range 0 X 0.5 (the widest range for which we have results for all algorithms). Note that compared with Exact-graph, TNF reduces AUC by merely a point and the maximal F 1 score by two points only.

AUC: 0.32), but its output is not a transitive graph, and as shown above runtime is quite slow. 244 sented in Section 3 on medium-sized graphs for which we can find an optimal solution.
Our main findings are as follows: 1. Finding the optimal solution for Exact-graph and Exact-forest results in 2. Running GNF and TNF also yields very similar graphs, illustrating that 3. Our efficient approximation algorithm, TNF, is substantially faster 4. TNF results in only a slight decrease in quality of learned graphs 5. TNF, which respects the transitivity constraint, learns graphs of higher to large entailment graphs. In the next section, we empirically evaluate on a much larger data set for which using ILP solvers is impractical. 5. Experimental Evaluation: Untyped Entailment Graphs
In this section we evaluate our methods on a graph with 20,000 nodes. Again, we describe how the nodes V and the weighting function w are constructed. 5.1 Untyped Entailment Graphs ambiguity is a problem in this setting, we will show that nevertheless transitivity con-straints can improve results compared with a state-of-the-art local entailment classifier. form (arg 1 ,predicate,arg 2 ) that were extracted by the Reverb open information extraction system (Fader, Soderland, and Etzioni 2011) over the Clueweb09 generously provided by the authors of Reverb.
 accompanied by a confidence value and we discarded tuples with confidence smaller than 0.5. Next, we normalized predicates using a procedure that omits unnecessary content such as modals and adverbs. The entire normalization procedure is publicly available as part of the Reverb project. 7 Last, we normalized arguments by replacing pronouns and determiners by the tokens PRONOUN and DET . We also ran the BIU number normalizer 8 and replaced numbers larger than one by the token NUM . After these three steps, we are left with a total of 960 million tuples of which 291 million are distinct.
 appear with the highest number of pairs of arguments. As previously explained, each predicate is split into two (for example, defeat is split into X defeat Y and Y defeat X ), and so the final number of entailment graph nodes is 20,000. 5.2 Training a Local Entailment Classifier
As with typed entailment graphs, the weighting function w is obtained by training a classifier that provides a score s ij for all pairs of predicates
This setting, computing the scores s ij , involves the following steps: 1. Training set generation. We use the data set released by Zeichner, Berant, 2. Feature representation. Each pair of predicates ( p 1 , p 3. Training. After obtaining a feature representation for every pair of 246 4. Prior knowledge. We automatically generate local constraints for pairs of 248 5.3 Experimental Evaluation To evaluate performance we use the second half of the data set released by Zeichner,
Berant, and Dagan (2012) as a test set. This test set contains 3,283 annotated examples, where 1,734 are covered by the 10,000 nodes of our graph (649 positive examples and 1,085 negative examples). As usual, for each algorithm we compute recall and precision with respect to the gold standard at various points by varying the sparseness parameter  X  .
 relax , and GNF ) are intractable because they require an ILP solver and our graph does not decompose into components that are small enough. Therefore, we compare the No-
TNF and TNCF. Recall that in Section 4 we initialized TNF by applying an ILP solver in a sparse configuration on each graph component. In this experiment the graph is too large to use an ILP solver and so we initialize TNF and TNCF with a simple heuristic we describe next.
 w ij &gt; 0, according to their weight w . Then, we go over predicate pairs one-by-one and violate the FRG assumption. This is done by going over all edges ( i , k )  X  E and checking candidate edge as the resulting reduced graph will remain a directed forest, otherwise adding it will result in i having two parents in the reduced graph, and we do not insert this edge. Second, we compute the transitive closure T ij that must be edges in the graph in case we insert ( i , j ), due to transitivity. We compute the change in the value of the objective function if we were to insert T
If this change improves the objective function value, we insert T so the value of the objective function increases monotonically). We keep going over longer be improved by inserting a candidate edge. We term this initialization HTL-FRG , because we scan edges from high-score to low-score and maintain an FRG. We add this initialization procedure as another baseline.
 higher recall values than the global algorithms, which means that adding a global transitivity constraint prevents adding correct edges that have positive weight, since this would cause the addition of many other edges that have negative weight. A possible reason for that is predicate ambiguity, where positive weight edges connect connectivity components through an ambiguous predicate. This suggests that a natural direction for future research is to develop algorithms that do not impose transitivity constraints for is to learn latent  X  X ense X  or  X  X opic X  variables for each rule (as suggested by Melamud et al. Melamud et al. [2013]). Then, we can use the methods presented in this article to impose transitivity constraints for each sense separately, and easily allow violations of transitivity across different senses. We provide concrete examples for such cases of ambiguity in our qualitative analysis in Section 5.4.

Table 5 presents the results for the recall range 0.1 X 0.25. Comparing TNCF and No-trans shows that the TNCF algorithm improves over No-trans by 5 X 10 precision points: 250
In the recall range of 0.1 X .2, the precision of No-trans is 0.68 X 0.75, whereas the precision of TNCF is 0.74 X 0.8. The number of rules learned by TNCF in this recall range is about 100,000.
 very good approximation algorithm. Comparing HTL-FRG with No-trans, we observe that it is unable to reach high recall values and it only marginally improves precision compared with No-trans. Applying TNF over HTL-FRG also provides disappointing results X  X t increases recall compared with HTL-FRG, but precision is not better than
No-trans. Indeed, it seems that although performing node re-attachments monotoni-cally improves the objective function value, it is not powerful enough to learn a graph that is better with respect to our gold standard. On the other hand, adding component re-attachments (TNCF) allows the algorithm to better explore the space of graphs and learn a graph with higher recall and precision than HTL-FRG.
 Again, we were unable to obtain results with Exact-graph, Exact-forest, LP-relax, and
GNF, because using an ILP solver on a graph with 20,000 nodes was impossible. As expected, HTL-FRG is much faster than both TNF and TNCF, and TNCF is somewhat slower than TNF. However, as mentioned earlier, TNCF is able to improve both pre-cision and recall compared with TNF and HTL-FRG. Note that when  X  = 1 . 2, runtime increases suddenly for both TNF and TNCF. This is because at this point a large con-nected component is formed, as we explain next.

Evidently, when  X  = 0 the largest component constitutes almost all of the graph, which contains 20,000 nodes. Note that when  X  = 1 . 2, the size of the largest component in-creases suddenly to more than half of the graph nodes. Additionally, TNCF obtained
Runtime in seconds for various  X   X  values for global algorithms.
The number of nodes in the largest component as a function of the sparseness prior  X   X  . component is 90% of the total number of graph nodes. Thus, contrary to the typed graphs, untyped graphs that contain ambiguous predicates do not decompose well into small components.
 with 20,000 nodes and observed that even when predicates are ambiguous we are able to improve precision for moderate values of recall. Nevertheless, there are indications that our modeling assumptions are violated when applied over a large graph with ambiguous predicates. Transitivity and FRG constraints limit the recall we are able to reach, and the graph does not decompose very well into components. Thus, in future work we would like to apply our algorithms over graphs where predicate ambiguity is modeled and so transitivity constraints can be properly applied. 5.4 Qualitative Analysis
In the previous section we quantitatively evaluated global methods for learning entail-issues that we would like to further investigate: 1. Why do methods that assume entailment graphs are transitive and 2. How much does node re-attachment affect graph structure? that allows us to gain better insight on the behavior of our algorithms.

Question 1: Transitivity and FRG assumptions. We would like to understand why using cause predicates in the graph are untyped and potentially ambiguous, violations of the 252 assumptions are possible, which results in recall reduction. To examine this hypothesis, we perform two qualitative analyses: 1. We analyze graphs containing only gold-standard edges, and manually 2. We compare the local algorithm, No-trans, to the global algorithm, TNCF. and search for transitivity and FRG violations caused by ambiguous predicates. Note correct edges, which is actually much larger. Thus, we cannot automatically identify violations, because the graph is missing many true edges. Instead, we manually go over candidate violations and check if indeed this case is a result of a violation of our modeling assumptions, and if so then our global algorithm cannot predict the correct set of edges.
 rule was annotated in the rule application Others seek medical care  X  Others apply for medical care (Recall that crowdsourcing was used to annotate rule applications, and rules were extracted from these applications.) The second rule was extracted from the rule application Students apply for more than one award  X  Student file for more than one award .
This causes a transitivity violation because Students seek more than one award file for more than one award . Evidently, the meaning of the predicate apply for is context-dependent. Another example is the pair of rules contain  X  supply and supply  X  serve annotated in the applications The page contains links  X  The page supplies links and Users supply information or material  X  Users serve information or material . Clearly, contain and the transitivity violation is caused by the fact that the predicate supply is context-dependent X  X n the first context the subject is inanimate, whereas in the second context the subject is human.
 three entailment rules are annotated by the turkers: come from  X  be raised in , come from  X  be derived from , and come from  X  come out of . These correspond to the following rule applications: The Messiah comes from Judah  X  The Messiah was raised in Judah , The comes from the book  X  The truth comes out of the book . Clearly, be raised in from and be derived from ; be raised in , so this is an FRG violation. Indeed, the three applications correspond to different meanings of the predicate come from , which depend on context. A second example is the pair of rules be dedicated to  X  be committed to and be dedicated to  X  contain information on . Again, this is an FRG violation because be committed to ; contain information on and contain information on ; be committed to . This violation occurs because of the ambiguity of the predicate be dedicated to , which can be resolved by knowing whether the subject is human or is an object that carries information (for example, The web site is dedicated to the life of lizards ).
 sumptions do not hold. In the next analysis, we would like to directly compare cases where global and local methods disagree with one another. We hypothesize that because predicates are not disambiguated, then global algorithms will delete correct edges due to an ambiguous predicate. We set the sparseness parameter  X  = 0 . 2 and compare the set of edges learned by No-trans to the set of edges learned by TNCF.

TNCF deletes an edge that was inserted by No-trans. We divide these deleted edges into two categories in the following manner: We compute the weakly connected com-ponents of the graph learned by TNCF, 10 and then for each edge inserted by No-trans and deleted by TNCF we check whether it connects two different weakly connected components or not. There are two reasons for focusing on this property of deleted edges.
First, we hypothesize that most deleted edges will connect two different connected com-ponents, because such edges result in many violations of transitivity. Second, weakly connected components usually correspond to separate semantic meanings, and thus a correct edge that connects two weakly connected components probably involves an ambiguous predicate.
 connect weakly connected components in the global graph. This proves that deleting such edges is the main cause for disagreement between TNCF and No-trans. Now, we can take a closer look at these edges, and check whether indeed when a correct edge is deleted, it is because of an ambiguous predicate.
 ing weakly connected components X  X hese are cases where ambiguity is likely to occur. For comparison, we also sample five cases where TNCF was right and No-trans erred.
Table 6 shows the samples where No-trans is correct. The first column describes the rule and the second column specifies the score s ij provided by the local classifier No-trans.
The last two columns detail two examples for predicates that are in the same weakly connected component with the rule LHS and RHS in the graph learned by TNCF. These two columns provide a flavor for the overall meaning of predicates that belong to this component. Table 7 is equivalent and shows the samples where TNCF is correct. this rule application in the crowdsourcing experiment was your parents turn off comments and indeed in this case the RHS your parents cut off comments is inferred. However, we can see that the LHS component revolves around the turning off or shutting off of appliances, for example, whereas the RHS component deals with a more explicit and physical meaning of cutting . This is because the predicate X cut off Y is ambiguous and consequently TNCF omits this correct edge. Example 5 also demonstrates well the problem of ambiguity X  X he LHS of this rule application is This site was put by fans , which in this context entails the RHS This site was run by fans . However, the more common sense of be put by does not entail the predicate be run by ; this sense is captured by the predicates in the LHS component Y help put X and X be placed by Y . Example 4 is another good example where the ambiguous predicate is X be open to Y  X  X he RHS component is concerned with the physical state of being opened, whereas the LHS component has a more abstract sense of availability . The LHS of the rule application in this case was The services are available to museums . Examples 2 and 3 are cases where the problem is not in predicate ambiguity but in the connected component itself. Thus, out of five randomly sampled examples where TNCF deleted an edge that connects two weakly connected components, three can be attributed to predicate ambiguity. 254 quently decomposed a weakly connected component into two. These are classical cases where the global constraint of transitivity helps the algorithm avoid errors. In Exam-this would cause the addition of wrong edges from the LHS component that deals with seeing and visiting to the RHS component, which is concerned with help and support . Example 2 is a case of a pair of predicates that are co-hyponyms or even perhaps antonyms . Transitivity helps TNCF avoid this erroneous rule.
 global algorithms to omit edges. Although this is often desirable, it can also prevent cor-rect rules from being discovered because of problems of ambiguity. Thus, as discussed in Section 5.3, we believe that an important direction for future research is to apply our global graph learning methods over context-sensitive representations (such as the one presented by Melamud et al. [2013]).

Question 2: Node re-attachment. We would like to understand the effect of applying TNF over the entailment graph, or more precisely, check whether TNF substantially alters the set of graph edges compared with an initialization with HTL-FRG. First, we run both
HTL-FRG and TNF with sparseness parameter  X  = 0 . 2 and compute the proportion of edges that is in their intersection. HTL-FRG learns 48,986 edges and TNF learns 61,186 edges. The number of edges in the intersection is 35,636. This means that 27% of the edges learned by HTL-FRG were removed (13,350 edges) and in addition 25,550 edges were added into the graph. Clearly, this indicates that TNF changes the learned graph substantially.

Figure 14 shows 11 predicates, 11 where the black solid edges correspond to HTL-FRG edges and red dashed edges correspond to TNF edges. Nodes that contain more than a single predicate represent an agreement between TNF and HTL-FRG that all predicates generated by HTL-FRG. HTL-FRG creates an erroneous component in which give a lot of and generate a lot of are synonymous and mean a lot of entails them. TNF disassembles this component and determines that give a lot of is equivalent to offer plenty of , while generate a lot of entails cause of . Moreover, TNF disconnects the predicate mean a lot of completely. TNF also identifies that the predicates offer a wealth of , provide a wealth of , errors X  X or example, HTL-FRG decided that cause and cause of are equivalent, but TNF deleted the correct entailment rule cause of  X  cause .
 due to the application of TNF. In the initialization, HTL-FRG determined that the predicate encrypt entails the predicates convert and convince rather than the predicates code and encode . This is because the local score provided by the classifier for (encrypt, convert) is 0.997 X  X lightly higher than the local score for (encrypt, encode) , which is 0.995.
Therefore, HTL-FRG inserts the wrong edge encrypt  X  convert and then it is unable to insert the correct rule encrypt  X  encode because of the FRG assumption. After HTL-FRG terminates, TNF goes over the nodes one by one and is able to determine that overall the predicate encrypt fits better as a synonym of the predicates code and encode and re-attaches it in the correct location. As an aside, notice that both HTL-FRG and TNF are able to identify in this case the correct directionality of the rule compress  X  encode . The 256 local score given by the classifier for (compress, encode) is 0.65, whereas the local score for (encode, compress) is  X 0.11.
 different entailment relations. The first context is when the object of the predicate (the
Y argument) is a person and then the meaning of depress is similar to discourage . A second context is when the object is some phenomenon , for example, The serious economical situation depresses consumption levels . In initialization, HTL-FRG generates a set of edges that is compatible with the latter context, determining that the predicate depress entails the predicates lower and bring down . TNF re-attaches depress as a synonym of discourage that corresponds to the first meaning of depress mentioned above. The methods we use in this article do not allow learning the rules for both contexts because this would result in violations of the transitivity and FRG assumptions. This again emphasizes the importance of learning graphs where predicates are marked by their various senses, which will result in a model that can directly benefit from the methods suggested in this article. 6. Conclusions
The problem of language variability is at the heart of many semantic applications such as Information Extraction, Question Answering, Semantic Parsing, and more. Conse-quently, learning broad coverage knowledge bases of entailment rules and paraphrases (Ganitkevitch, Van Durme, and Callison-Burch 2013) has proved crucial for systems that perform inference over textual representations (Stern and Dagan 2012; Angeli and
Manning 2014). predicates that can scale to large sets of predicates. Our work builds on prior work by
Berant, Dagan, and Goldberger (2012), who defined the concept of entailment graphs, and formulated entailment rule learning as a graph optimization problem, where the graph has to obey the structural constraint of transitivity.
 learn entailment graphs containing tens of thousands of nodes. The algorithm is based entailment graphs are forest-reducible. This leads to an efficient algorithm in which at the first step the graph is decomposed into smaller components, and in the second step we find a set of edges for each component. The second step is an iterative approximation algorithm in which at each iteration a node or component of the graph is deleted and then re-attached in a way that improves the overall objective function.
 two separate data sets. On the first data set we witnessed a substantial improvement in runtime at a relatively small cost in performance. On the second data set, we show that our method scales to an untyped entailment graph containing 20,000 nodes, much larger than was previously possible using state-of-the-art global methods. We see that using a global algorithm improves precision for modest values of recall, but that local methods can achieve higher recall than global methods. We perform an analysis and conclude that the main reason for this limitation is predicate ambiguity, which results reducibility.
 direction is to combine methods that model the context-sensitivity of predicates with global structural assumptions. In this way, one can apply structural constraints for direction for future work is to demonstrate that using entailment rules learned by our method improves performance in downstream semantic applications such as QA, IE, and Recognizing Textual Entailment.
 Appendix A. Max-Trans-Forest Is NP-hard
In this appendix we show that the Max-Trans-Forest problem (8) is NP-hard. We prove that the following decision problem (which is clearly easier than Max-Trans-Forest) is NP-hard: Given a set of nodes V , a function w : V  X  V  X 
P e  X  E w ( e )  X   X  ? In this appendix we use the standard terminology that for a directed edge i  X  j , the node i is termed the parent of node j , and the node j is termed the child of i . We start with a simple polynomial reduction from the following decision problem.
 a positive integer  X  , is there a transitive FRG subgraph G
P
Sub-FRG, we construct the instance ( G 0 = ( V , E 0 ( V , E ), w ,  X  )  X  Max-Sub-FRG iff ( G 0 = ( V , E 0 ), w there is a transitive FRG subgraph of G whose sum of edges  X   X  , then choosing the same edges will yield a transitive FRG subgraph of G 0 whose sum of edges  X   X  . Similarly, any 258 transitive FRG subgraph of G 0 whose sum of edges  X   X  cannot use any  X  X  X  edges, and therefore the edges of this FRG are in E and this defines a subgraph of G whose sum of edges  X   X  .
 graph is equivalent to minimizing the sum of weights of edges not in the subgraph. We now denote by z the sum of weights of the edges deleted from the graph.
 (X3C) problem (Garey and Johnson 1979) to Max-Sub-FRG. The X3C is defined as follows. Given a set X of size 3 n , and m subsets, S 1 , S if there is a collection of n S i  X  X  whose union covers X .
 instance ( G = ( V , E ), w , z ) of the Max-Sub-FRG problem as follows (an illustration of the x , .. , x 3 n vertices, corresponding to the points of X , m vertices s the subsets S , m additional vertices t 1 , t 2 , .. , t m the edges E and the weight function w : E  X  Z + . 1. For each 1  X  i  X  m , we add an edge ( t i , s i ) of weight 2. 2. For each 1  X  i  X  m , we add an edge ( a , s i ) of weight 1. 3. For each 1  X  j  X  3 n , we add an edge ( a , x j ) of weight M = 4 m . 4. For each 1  X  i  X  m , if s i = { x p , x q , x r } , we add 3 edges of weight 1: ( s
To complete the construction of the Max-Sub-FRG problem, we define z = 4 m  X  2 n . We next prove that S has an exact 3-cover of X  X  there is a transitive FRG subgraph of G such that the sum of weights deleted is no more than 4 m  X  2 n . edges ( a , s i ) for the n vertices s i that cover X , the 3 n edges ( s for the m  X  n vertices s f that do not cover X . The transitive closure contains all edges ( a , x i ), and the rest of the edges are deleted: for all s for the s i  X  X  that cover X are deleted. The total weight deleted is thus 3( m  X  n ) + m  X  n + 2 n = 4 m  X  2 n . It is easy to verify that the subgraph is a transitive FRG -there are no connected components of size &gt; 1, and in the transitive reduction of G there is no node with more than one parent. must delete more than 4 m  X  2 n weight. We cannot omit any edge ( a , x of each such edge is too large. Thus all these edges are in the FRG and are either deleted during transitive reduction or not.
 for every x j there exists an s i such that ( a , s i ) and ( s
Consequently, for these s i  X  X , the forest must not contain the edges ( t would have two parents and violate both the forest and the transitivity properties). For the m  X  k nodes with no edge ( s f , x j ) we can either add an edge ( a , s not both (otherwise, s f would have more than one parent). Since w ( t for the edges between s i  X  X  and x j  X  X , 2 k in the edges ( t k &gt; n .
 means that for these x j  X  X  there is no edge ( s i , x j ) for any i (otherwise, x than one parent after transitive reduction). This means that 3 n  X  r of the x by s i  X  X . To cover x j  X  X  we need at least k  X d n  X  r 3 e s have the edges ( a , s i ) and we delete the edges ( t i do not cover any x j it is best to add the edges ( t f , s the weight deleted is 3 m  X  (3 n  X  r ) for edges between s d n  X  r 3 e + r  X  4 m  X  2 n + r  X  X  r 3 c &gt; 4 m  X  2 n .
 Max-Trans-Forest is also NP-hard.
 References 260 262
