 Real-time group editing has been envisioned as an important application for group collaboration. Operational transfor-mation (OT) has been the concurrency control mechanism for group editing, due to its potential for high responsive-ness to local editing operations. OT algorithms are gener-ally very sophisticated and computation intensive. Recently, commutative replicated data types (CRDT) have appeared as viable substitutes of OT. Existing OT and CRDT work suffers from serious limitations. This note presents a CRDT that addresses some of these limitations.
 C.2.4 [ Computer-Communication Networks ]: Distributed Systems X  Distributed applications ; H.5.3 [ Information In-terfaces and Presentation ]: Group and Organization In-terfaces X  Collaborative computing Real-time collaborative editor, commutative replicated data type, selective undo
A real-time group editor allows multiple users to simulta-neously edit the same document from different places. Oper-ational transformation (OT) has been established as a con-currency control mechanism for group editing [2, 7, 8, 9]. OT has the potential for high responsiveness to local opera-tions, because local operations are done immediately on the local document before they are transformed and integrated at remote peers. However, OT algorithms are sophisticated and time consuming. Counterexamples of several published algorithms have been reported. The algorithms generally have time complexities dependent on the lengths of opera-tion histories.

Recently, a new class of mechanisms called commutative replicated data types (CRDT) have been proposed [1, 4, 5, 6, immediate effect in the view. Local and remote operations are first stored in local-queue and remote-queue and later be integrated in the model. Integrated local operations are first stored in out-queue and later broadcasted to other peers. When the model is rendered, the effects of integrated remote operations are shown in the view.

A view is a string of characters together with a current position in the string. A user at a peer can move the current position, insert or delete a sub-string at the current position, and undo an earlier executed local or remote operation.
The model is primarily a double-linked list of nodes. A node contains a sub-string, together with some additional meta-data and links for the operations on the string. A model has also a current position, corresponding to the cur-rent position in the view. When operations are integrated into the model, existing nodes are split at operation bound-aries, and either new nodes are inserted or existing nodes are marked as deleted or undone. The list thus grows while the document is being edited.

Figure 2 illustrates a model list in different states. When string  X 0. . . 9 X  is first inserted, the model has only one node. Inserting  X  X BCD X  inserts a new node and splits the existing node. Deleting a sub-string makes the characters invisible in the view (the nodes in the figure become gray) and fur-ther splits existing nodes. Concurrent deletions D 1 and D 2 overlap at  X  X  X . When D 1 is undone, only sub-string  X  X 56 X  is brought back in the view.  X  X  X  is still deleted, because D 2 remains in effect.

In addition to the list, the mode has a hash table of the nodes and a log of operations. With the hash table, a node can be accessed with its globally unique identifier in constant time. Any operation in the log can be selected and undone.
Procedure integrate integrates all queued local and re-mote operations. Procedure render make the effects of in-tegrated remote operations available in the view.
A peer has an identifier pid and maintains a peer update number pun . pun increments by one for every editing op-eration originated at the peer. An operation is uniquely identified with ( pid,pun ).

In the model, an insertion consists of the nodes chained with the il and ir links. A deletion consists of the nodes containing the del elements of the same delete operation. When dels of a node contains multiple del elements, the node X  X  str has been deleted concurrently by multiple peers.
A del element has the following (sub-)elements: pid , pun , the identifier of the delete operation; l , r , the left and right nodes of the same delete operation; undo , rendered , similar to those in nodes. In Figure 2, a del element is depicted with a dot on the bottom edge of a node ( ). The links between the del s of the same delete operation are illustrated with lines connecting the dots ( ).

An undo element consists of pid,pun , undo and rendered . ( pid,pun ) is the id of the undo operation. If an undo opera-tion itself it undone, the undo element refers to another undo element. An operation X  X  undo elements are thus chained into a linked list. An operation is effectively undone if the length of the undo list is an odd number.

A node is visible if the insertion is not effectively undone and all del elements in dels are effectively undone.
Locally in a peer, a node can be directly referred to via its reference. So the links l , r etc. refer to nodes with their refer-ences. Node references, however, are meaningless across peer boundaries. Fortunately, a node can be uniquely identified by the identifier of the insert ( str ) operation that inserted the string str , together with the offset of the node X  X  left end in str . In Figure 2, suppose the identifier of insert ( X 0 ... 9 X ) is I 0 = (0 , 0). The node with string  X 789 X  can be uniquely identified with (0 , 0 , 7). We use ( pid,pun,offset ) as the id of a node. Nodes are hash-indexed with their id s. Therefore given ( pid,pun,offset ), a node can be obtained in constant time. In the worst case, if a local operation makes a new split at offset , a remote peer can start from ( pid,pun, 0) to find the node containing offset (and make a split there).
The model integrates a local insert operation by inserting a new node into the list. If the current position is in the middle of the current node, the current node is split and the new node is inserted in between. Otherwise, the new node is to be inserted to the left or right of the current node. In this case, the new node is to be inserted between two visible nodes. When there are invisible nodes in between, a illustrated in Figure 5. To insert  X  X  X  between  X  X  X  and  X  X  X  at Peer 2, we first find insertions between  X  X  X  and  X  X  X  that di-rectly conflict with  X  X  X . In our example, this is the insertion of  X  X  X . Since insert ( X  X  X ) has pid 4 and insert ( X  X  X ) has pid 3,  X  X  X  is to be inserted to the left of  X  X  X .  X  X  X  is then to be in-serted between  X  X  X  and  X  X  X  in the next iteration. The directly conflicting insertions are then insert ( X  X b X ), insert ( X  X  X ) and insert ( X  X  X ). This process continues until there is no con-flicting node between  X  X  X  and  X  X  X  where  X  X  X  is to be inserted. This process is in essence the same as in [4, 12]. Notice that deletion and node splitting have no effect with respect to the ordering of the insertions.

Integrating a remote delete or undo simply associates the corresponding del or undo elements in the model data struc-ture. delete and undo operations are idempotent. The com-mutativity of deletion and undo with other operations is straightforward.
The table below presents the time complexity of the dif-ferent CRDT procedures.
In the table, m is the distance of a move, i.e., the number of nodes a move traverses; r is the size of region being ren-dered, i.e., the number of nodes in the region; l is the size of an operation, i.e., the number of nodes that the operation involves; d is the number of invisible nodes, either between two visible nodes at the place of an insertion, or between visible nodes for deletion; k is the number of conflicting in-sertions; s is the span of an operation, i.e., the number of nodes between the leftmost and rightmost nodes of the op-eration, including the nodes of which the operation is not part of.

It can be seen that a local undo can be an expensive op-eration, because the current position must first be moved to the node of the operation to be undone and the effect of the undo must then be rendered. m and s can be considerably larger than l .
The string-wise CRDT presented in this note advances the state of the art of group editing research by supporting un-limited dynamic group membership, string-wise operations and selective undo. We have implemented the algorithms presented in this note in Emacs Lisp, aiming at support-ing group editing in a widely used open-source editor. We are currently investigating the overall performance of the approach.
