 Query processing techniques for XML data have focused mainly on tree-pattern queries (TPQs). However, the need for querying XML data sources whose structure is very com-plex or not fully known to the user, and the need to integrate multiple XML data sources with different structures have driven, recently, the suggestion of query languages that relax the complete specification of a tree pattern. In order to im-plement the processing of such languages in current DBMSs, their containment problem has to be efficiently solved.
In this paper, we consider a query language which gener-alizes TPQs by allowing the partial specification of a tree pattern. Partial tree-pattern queries (PTPQs) constitute a large fragment of XPath that flexibly permits the spec-ification of a broad range of queries from keyword queries without structure, to queries with partial specification of the structure, to complete TPQs. We address the containment problem for PTPQs. This problem becomes more complex in the context of PTPQs because the partial specification of the structure allows new, non-trivial, structural expressions to be inferred from those explicitly specified in a query. We show that the containent problem cannot be characterized by homomorphisms between PTPQs, even when PTPQs are put in a canonical form that comprises all derived structural expressions. We provide necessary and sufficient conditions for this problem in terms of homomorphisms between PT-PQs and (a possibly exponential number of) TPQs. To cope with the high complexity of PTPQ containment, we sug-gest a heuristic approach for this problem that trades accu-racy for speed. An extensive experimental evaluation of our heuristic shows that our heuristic approach can be efficiently implemented in a query optimizer.
 H.2.3 [ Database Management ]: Languages X  Query lan-guages ; H.2.4 [ Database Management ]: Systems X  pro-cessing Management, Experimentation, Languages XML, partial tree-pattern query, query containment
The increased popularity of XML has triggered the inter-est of the database community on the processing of XPath [1]. XPath lies at the core of W3C language proposals for XML querying (e.g. XQuery [1]). In this context, a chal-lenging issue is the effective and efficient querying of tree-structured data on the web. This goal faces several obsta-cles: (a) a tree-structured data source may contain struc-tured data (i.e., relational data) along with unstructured data (i.e., text), (b) the user may not know the (full) tree structure of a data source, and (c) the user needs to query in an integrated way several data sources that structure their information differently.

Traditional information integration approaches attempt to cope with the issue of querying multiple tree-structured data sources by providing a global structure. Mapping rules, e.g. node-to-node or path-to-path, are defined between the global structure and the local structures used in the sources [7]. Such approaches require extensive manual effort since the global schema is difficult to construct and the rules should be hard-coded in the integration application. More-over, the user should have exact knowledge of the global structure in order to formulate queries. Approximation tech-niques can also be used to generate alternative forms of a query and search for answers in the data sources. For in-stance, tree-pattern query relaxation methods are presented in [3, 4], while methods for producing approximate answers to XML queries are suggested in [12, 24]. In the same direc-tion, flexible and semiflexible semantics were introduced in [14] for tree and dag queries. Nevertheless, in all these cases the answer is not exact with respect to the initial query. Ap-proaches based on keyword search [26, 13, 8, 18] avoid the issue of unknown structure or the issue of multiple differently structured data sources since knowledge of the structure is not required for the queries. However, the total absence of structure has a number of drawbacks: (a) the user cannot specify structural information within the query to acceler-ate computation of the answer, (b) the user cannot impose structural conditions to filter out undesirable answers, and (c) the user cannot specify the structure of the query result.
Some approaches aim at extending full-fledged XML query languages with keyword-based search techniques [11, 17]. However, these languages are too complex for the simple user. Approaches with languages based on tree patterns share a restrictive feature: it is not possible in a tree pattern to indicate that two nodes occur in the same path without specifying a structural relationship between them. Such a restriction causes problems both to the formulation and pro-cessing of requests that do not specify an order among some nodes. Indeed, a number of tree-pattern queries (TPQs) that is exponential on the number of nodes of the query might need to be specified and processed.
 Our approach. To face the previous issues, we use Par-tial Tree-Pattern Queries (PTPQs), a query language that generalizes TPQs by allowing a partial specification of a tree structure in the query. This language corresponds to a broad fragment of XPath [1] that contains TPQs (XPath expres-sions with predicates, and child and descendant axes) but also the reverse axes parent and anscestor and the node identity equality operator  X  X s X . The structure in a PTPQ can be flexibly specified fully, partially or not at all .PT-PQs range from unstructured keyword-style queries to com-pletely specified TPQs. This flexibility in specifying struc-tural constraints allows their use for dealing with the issues mentioned above.
 The problem. For a query language to be useful, it needs to be complemented with query processing and optimiza-tion techniques. Important issues in query optimization, in-cluding query satisfiability [16], query minimization [2, 31, 25], and query rewriting using views [23, 15], require solving the query containment problem. In this paper, we address the query containment for PTPQs. The query containment problem has been studied in the past for (fully specified) tree-pattern queries in the absence and in the presence of constraints. However, most of the previous work focuses almost exclusively on characterizing the complexity of the problem for tree patterns. Our goal here is to provide an efficient (sound but not necessarily complete) method for checking query containment that can be used for processing partial tree-pattern queries.
 Contribution. We start by formally defining the contain-ment problem for PTPQs. In order to allow PTPQ compar-ison we use a  X  X anonical form X  for queries, called full form . Intuitively, a full form of a PTPQ comprises all the struc-tural expressions that can be inferred from those specified in the PTPQ. The main contributions of this paper are the following:  X 
We show that a PTPQ is equivalent to a set of TPQs called component TPQs. However, we also show that the number of these TPQs can be exponential on the number of nodes of the PTPQ.  X 
We show that homomorphisms cannot completely char-acterize PTPQ containment even if the full form of the
PTPQ to be checked for containment is used. That is, the existence of a homomorphism implies containment but the opposite is not necessarily true.  X 
We provide necessary and sufficient conditions for PTPQ containment in terms of homomorphisms from PTPQs to component TPQs. Since the number of component TPQs can be exponential, this technique for checking PTPQ con-tainment is of high complexity and cannot be used in prac-tice.  X 
We explain why the containment of PTPQs cannot be fully characterized by homomorphisms. Based on this ex-planation we identify a subclass of PTPQs (which strictly contains TPQs) for which containment can be completely characterized by homomorphisms.  X 
In order to deal with the high complexity of PTPQ con-tainment checking using the component TPQs, we design a sound but not complete heuristic technique which trades time for accuracy. This technique is based on equivalenty adding new (partial) paths to the PTPQ to be checked for containment in order to increase the possibility for a homomorphism to this PTPQ to exist.  X 
We have implemented our containment checking technique, and performed an extensive experimentation to evaluate it. Our experiments show that the heuristic technique is efficient compared to the non-heuristic one while main-taining high accuracy. These results show that it can be directly exploited in practice for the processing of PTPQs. Outline. The next section reviews related work. Section 3 presents the data model and the query language, shows that PTPQs are equivalent to sets of component TPQs, and discusses inference issues. Section 4 provides necessary and sufficient conditions for PTPQ containment. In Section 5, we explain why homomorphisms do not always work and identify a subclass of PTPQs which is completly character-ized by homomorphisms. Section 6 introduces our heuristic approache. Experimental results are shown in Section 7. We conclude in Section 8 and discuss future work. Because of lack of space, detailed proofs are omitted.
Because of their importance for query processing, a con-siderable amount of work has focused on the containment problem for tree-pattern queries in the presence and in the absence of schemas [9, 14, 19, 32, 20, 10, 6]. In particular, Neven and Schwentick [20] studied the complexity of tree-pattern queries (involving child and descendant relationships and wildcards) in the presence of disjunction and DTDs. As we show later in the paper, a partially specified tree-pattern query can be expressed as a set of tree-pattern queries. How-ever, the containment problem addressed in [20] is different than that of partially specified tree-pattern queries because not every set of tree-pattern queries can be expressed as a partially specified tree-pattern query. Benedikt and Fundu-laki [5] study query composition for different fragments of XPath under subquery semantics. None of these papers ad-dresses query containment for partial tree-pattern queries. Most of the aforementioned works focus on studying the complexity of these problems f or different classes of tree-pattern queries. Our goal in this paper is different. We are focusing on providing heuristic techniques for checking query containment that can be used for efficiently processing and optimizing partial tree-pattern queries.

Partially specified tree-pattern queries were initially in-troduced in [27] and their semantics studied in [30]. Ini-tial results on the query containment problem for partial tree-pattern queries were presented in [28, 29], where in-ference rules were also provided to completely characterize the inference of structural expressions. In both of these pa-pers the class of partial tree-pattern queries considered is restricted to disallow cases of unordered node sharing ex-pressions between two or three partial paths. Further, the focus of [29] was on heuristic approaches in the presence of indexes called dimension graphs. These results cannot be applied to heuristically check containment of PTPQs in the absence of dimension graphs. The present paper is the first one to provide necessary and sufficient conditions for par-tial tree-pattern query containment along with an elaborate (sound but not complete) heuristic approach for checking query containment. This approach can be exploited in query optimizers for processing pa rtial tree-pattern queries.
We briefly present in this section the data model and our query language that allows generalizing tree patterns.
Let E be an infinite set of elements that includes a dis-tinguished element r .A database is a finite tree of nodes labeled by elements in E , rooted at a node labeled by r .For simplicity, we assume that the same element does not label two nodes on the same path.

Definition 3.1. A Partial Tree-Pattern Query (PTPQ) is a triple Q =( P , N ,o ), where: (a) P is a nonempty set of pairs ( p, R ) called Partial Paths (b) N is a set of expressions of the form e [ p i ]  X  e [ p j ], where (c) o [ p ]isaspecialnodeofaPP p in P called output node We graphically represent PTPQs using graph notation. Each PP of a PTPQ Q is represented as a (not necessar-ily connected) graph of elements. The name of each PP is shown by the corresponding PP graph. The output node of Q is denoted by a filled black node. Child and descendant precedence relationships in a PP are depicted using single (  X  ) and double (  X  ) arrows between the respective elements in the PP graph. In particular, descendant precedence re-lationships of the form r  X  e in a PP are shown only with the presence of element e in the PP graph. A node sharing expression e [ p i ]  X  e [ p j ] is represented by an edge between element e of the PP graph p i and element e of the PP graph p j labeled by  X  . Figures 1, 2, and 3 show three PTPQs.
The answer of a PTPQ is based on the concept of PTPQ embedding.
 Definition 3.2. An embedding of a PTPQ Q to a database D is a mapping M of the elements of the PPs of Q to nodes in D such that: (a) an element e of Q is mapped by M to anodein D labeled by e ;(b)theelementsofaPPin Q are mapped by M to nodes in D that are on the same path; (c)  X  (resp. descendant) of M ( e i [ p ]) in D ;and(d)  X  e [ p i ] in Q , M ( e [ p i ]) and M ( e [ p j ]) coincide.
We call image of a PP p in Q under M , denoted M ( p ), the path from the root of D that comprises all the images of the elements of p under M and ends in one of them. Notice that more than one PP of Q may have their image on the same root-to-leaf path of D ( M does not have to be a bijection). The answer of Q on D is the set of the images of the output node of Q under all possible embeddings of Q to D . Clearly, the class of PTPQs encompasses TPQs: every TPQ can be represented by a PTPQ that returns the same answer on every database. Such a construction is straight-forward, and we omit the details for brevity.

Notice that the PTPQ language allows the formulation of queries with no structure at all by specifying a single node per PP and no node sharing expressions. This re-sembles a flat keyword-based query. On the other side, the PTPQ language also allows the formulation of queries that are completely structured trees by specifying only child re-lationships and node sharing expressions. Between the two extremes, there are PTPQs that provide some description of the structure without fully specifying a tree.
APTPQis satisfiable if and only if it has a non-empty answer on some database. In the following, we assume that queries are satisfiable. In this paper we focus on the containment of PTPQs:
Definition 3.3. Let Q 1 and Q 2 be two PTPQs. Q 2 con-D , the answer of Q 1 on D is a subset of the answer of Q 2 on D .PTPQs Q 1 and Q 2 on D are equivalent (denoted Example 3.1. Consider the PTPQs Q 1 Q 2 and Q 3 of Figures 1, 2, and 3 respectively. One can see that Q 1  X  Q 2 . Observe, for instance, that the image of the output node of Q 1 under any embedding of Q 1 to a database D is also an image of the output node of Q 2 under some embedding of Q to D . Similarly, Q 2  X  Q 3 . In contrast, Q 2  X  Q 1 .Wewill prove these claims formally later.

In the next sections of this paper, we study exact and heuristic methods for checking PTPQ containment.
Precedence relationships and node sharing expressions are collectively called structural expressions . Because the struc-ture of tree patterns is partially specified in PTPQs, new, non-trivial structural expressions can be derived from those explicitly specified in the queries. Some of the derivations of Figure 1. Let X  X  use the symbol to denote that the struc-tural expressions in its left hand side derive the structural expression in its right hand side. Clearly, b [ p 3 ]  X  d [ p 3 ] b [ p 3 ]  X  d [ p 3 ] Many other derivations are specific to PTPQs. For instance, b [ p 3 ]  X  d [ p 3 ] ,b [ p 3 ]  X  c [ p 3 ] d [ p 3 ]
More formally, let S be a set of structural expressions of aPTPQ Q ,and s be a structural expression. We say that s can be inferred from S iff for every embedding M of Q to a database, M satisfies s . The inferred structural expressions can be computed efficiently using a set of inference rules [29].
To study properties of PTPQs, we introduce a  X  X ormal form X  for PTPQs called full form .

Definition 3.4. APTPQ Q is in full form if and only if the set S of its structural expressions comprises all the structural expressions that can be inferred from S .
Given a PTPQ Q , we can construct a PTPQ in full form by replacing its set S of structural expressions in Q by the closure of S . Clearly, this PTPQ is unique and equivalent to Q . Therefore, we refer, in the following, to the full form of aPTPQ.

Figures 4 and 5 show the PTPQs Q 1 and Q 2 which are the full forms of the PTPQs Q 1 and Q 2 of Figures 1 and 2 respectively. Query Q 3 of Figure 3 is in full form. For clarity of presentation, when graphically representing queries in full form, we do not depict structural expressions that can be trivially or transitively derived from the shown structural expressions. Observe that the full form of Q 1 shows that this PTPQ is also a TPQ.
 Figure 4: PTPQ Q 1 ,
Clearly, the number of structural expressions that can be derived using the inference rules in a query is bounded by O ( n 2 ), where n is the product of the maximum number of distinct elements in the query and its number of PPs. There-fore, the full form of a query can be computed in polynomial time.
We show now that the answer of a PTPQ Q on any database can be computed from a set of TPQs called com-ponent TPQs of Q . Consider a PTPQ Q .Observethatby adding descendant precedence relationships between every twonodesinthesamePPof Q , the resulting query is an unsatisfiable PTPQ or a PTPQ equivalent to a TPQ. The following proposition determines when a PTPQ is equivalent toaTPQ.

Proposition 3.1. Let Q be a PTPQ. If Q is safisfiable and there is a precedence relationship between any two nodes of the same PP in the full form of Q , Q is equivalent to a TPQ.

In the following, we might use the term TPQ for a PTPQ which is equivalent to a TPQ.

Definition 3.5. Let Q be a PTPQ. A component TPQ (abbreviated as cTPQ) of Q is a TPQ resulting by adding descendant precedence relationships to Q .

Therefore, a component TPQ of a PTPQ Q is a TPQ resulting by specifying a total order for the nodes in every PP of Q that respects existing precedence relationships in Q . Consider the PTPQ Q 2 of Figure 2. Figure 6 shows the in Figure 4 is a TPQ.

The cTPQs of a PTPQ Q can be used to compute the answer of Q as follows:
Proposition 3.2. Let { U 1 ,...,U k } be the set of cTPQs of a PTPQ Q and D be a database. Let also A, A 1 ,...,A k be the answers of Q, U 1 ,...,U k respectively on D .Then,
The previous proposition states that the answer of a PTPQ is the union of the answers of its cTPQs.

The PTPQ language can express all expressions in the fragment of XPath [1] that allows predicates (branching) and child (/) and descendant (//) axes. This fragment corre-sponds to tree-pattern queries (without wildcards). PTPQs can also express the fragment of XPath that allows, in ad-dition, the symmetric reverse axes parent ( \ ) and ancestor ( \\ ), and the node identity equality operator (is). How-ever, PTPQs strictly contain this fragment of XPath. For instance, it is not difficult to see that a PTPQ that contains two nodes other than r in one PP without precedence rela-tionship between them cannot be expessed by this fragment of XPath.
For TPQs that involve the descendant axis (that is, de-scendant precedence relationships), and branching ([]), but no wildcards (*), the existence of a homomorphism is a nec-essary and sufficient condition for containment [2, 19]. In order to check if a similar result holds for PTPQs we extend the concept of homomorphism for TPQs to homomorphism for PTPQs: Definition 4.1. Let Q 1 and Q 2 be two queries on D . An homomorphism from Q 2 to Q 1 is a mapping h from the nodes of Q 2 to the nodes of Q 1 such that: (a) nodes of Q 2 are mapped by h to nodes of Q 1 labeled by the same element, (b) nodes of Q 2 on the same PP are mapped by h to nodes of Q 1 on the same PP, (c) the output node of Q 2 is mapped under h to the output of Q 1 ,ortoanodein-volved in a node sharing expression with the output node or h ( e [ p i ])  X  h ( e [ p j ]) is in Q 1 .

The next proposition shows that the existence of a homo-morphism is a sufficient condition for PTPQ containment.
Proposition 4.1. Let Q 1 and Q 2 be two PTPQs. If there is a homomorphism from Q 2 to Q 1 , Q 1  X  Q 2 .

The proof is not difficult. The full form of a query Q is a query equivalent to Q and has at least the precedence re-lationships and node sharing expressions of Q . Therefore, when checking containment of Q into another PTPQ, the full form Q of Q provides more chances than Q for a homo-morphism to Q to exist.

Example 4.1. Consider the PTPQs Q 1 and Q 2 of Ex-ample 3.1 shown in Figures 1 and 2 respectively. One can see that there is no homomorphism from Q 2 to Q 1 .How-ever, there is a homomorphism from Q 2 to the full form of Example 3.1 that Q 1  X  Q 2 .
 to Q 1 is not a necessary condition even if Q 1 is in full form. Consider, for instance, the PTPQs Q 2 and Q 3 of Figures 5 and 3 respectively. PTPQ Q 2 is the full form of PTPQ Q 2 of Figure 2. One can easily see that there is no homomorphism from Q 3 to Q 2 . However, as we mentioned in Example 3.1,
We elaborate in Section 5.2 on the reasons of this be-haviour of PTPQs and we identify a subclass of PTPQs for which the existence of a homomorphism between two PT-PQs is a necessary condition for containment.
 We now provide necessary and sufficient conditions for PTPQ containment in terms of homorphisms from a PTPQ to TPQs: Theorem 4.1. Let Q 1 and Q 2 be two PTPQs. Let also U 1 be the set of component TPQs for Q 1 . Q 1  X  Q 2 iff for every component TPQ U  X  X  1 , there is an homomorphism from Q 2 to U .
 Example 4.2. Consider again the PTPQs Q 1 , Q 2 and One can see that there is a homomorphism from Q 3 to each one of the cTPQs of Q 2 which are shown in Figure 6. This proves our claim of Example 3.1 that Q 2  X  Q 3 .
In contrast, it is easy to see that there no homorphism from Q 1 to at least one of the cTPQs of Q 2 (in fact, there is no homomorhism to any one of the cTPQs of Q 2 ). This proves our claim of Example 3.1 that Q 2  X  Q 1 .
Unfortunately, the previous result does not lead to a prac-tical approach for checking PTPQ containment. The reason is that the number of cTPQs of a PTPQ can be exponen-tial on the number of nodes of the PTPQ. As an example, consider a trivial PTPQ which comprises n nodes in one PP (besides the root r ) without any precedence relationship be-tween them. This PTPQ has n ! cTPQs corresponding to the different orderings of these nodes. Olteanu et al. [22, 21] also showed that even though an XPath expression with reverse axes can be rewritten equivalently as a set of XPath expressions with only forward axes, this conversion might result in a number of XPath expressions with only forward axes which is exponential on the number of steps of the input XPath expression. Clearly, in our context, it is unfeasible to check general PTPQ containment by checking the existence of homomorphisms between a PTPQ and an exponential number of TPQs.
We show in this section why the existence a homomor-phism between two PTPQs does not fully characterize query containment. Then, we identify a subclass of PTPQs for which the existence of a homomorphism is a necessary con-dition for containment. These results are exploited in the next section for devising heuristics approaches for checking query containment for PTPQs.
The presence of two node sharing expressions a [ p 1 ]  X  a [ p 2 ] and b [ p 2 ]  X  b [ p 3 ] in a PTPQ Q when no precedence rela-tionship can be derived between a [ p 2 ]and b [ p 2 ]cancreate discrepancies: it may force every tree in which there is an embedding of Q to comprise a path that involves a number of nodes and satisfies a number of precedence relationships which together cannot be derived in any PP of Q .Wecall such a set { a [ p 1 ]  X  a [ p 2 ], b [ p 2 ]  X  b [ p 3 ] expressions a 3-path swing because the elements a [ p 2 ]and b [ p 2 ]inPP p 2 (and their corresponding node sharing expres-sions) can freely  X  X wing X  above or below each other. Another query Q that involves in the same PP all these nodes and precedence relationships might contain Q .However,aho-momorphism from Q to Q will not exist since these nodes and precedence relationships do not appear together in any PP of Q .

Example 5.1. Consider the PTPQ Q 2 of Figure 2 whose full form is shown in Figure 5. Clearly, no precedence re-lationships can be derived between a and b in PP p 2 since no such relationships exists in the full form of Q 2 shown in Figure 5. This PTPQ comprises the 3-path swing { a [ p 4 ] Q 2 into a database, the elements a , b ,and c appear in a path of the database, even though these nodes together cannot be derived in any PP of Q 2 . As a consequence a PTPQ that involves all three nodes a , b and c in one PP might contain to the full form of Q 2 . This is the case of PTPQ Q 3 of Figure 3 which does not have a homomorphism to the full form of PTPQ Q 2 even though, as proved in example 4.2,
A similar phenomenon appears when two node sharing ex-Q along with the  X  X hains X  of child precedence relationships a [ p 1 ]  X  a 1 [ p 1 ] ,a 1 [ p 1 ]  X  a 2 [ p 1 ] , ..., a b [ p 2 ]  X  b 1 [ p 2 ] ,b 1 [ p 2 ]  X  b 2 [ p 2 ] , ..., b no precedence relationship can be derived between a [ p 2 ]and b [ p 2 ]. An example of such a PTPQ is shown in Figure 7(a). Then, every tree in which there is an embedding of Q com-prises a path that satisfies the child precedence relation-ships a [ p 1 ]  X  a 1 [ p 1 ] ,a 1 [ p 1 ]  X  a 2 [ p 1 ] , ..., a a [ p 1 ] ,b [ p 2 ]  X  b 1 [ p 2 ] ,b 1 [ p 2 ]  X  b 2 [ p 2 ] , ..., a a [ p 2 ] even if these child precedence relationships together cannot be derived in any PP of Q .Wecallsuchaset { sions a 2-path swing .
 Example 5.2. Consider the PTPQ Q 6 of Figure 7(a). This PTPQ is in full form and contains the 2-path swing { of Figure 7(b). There is no homomorphism from Q 7 to Q 6 . However, one can see that for every embedding of Q 6 to a database, there is an embedding of Q 7 to the same database. Therefore, Q 6  X  Q 7 .
 Figure 7: (a) PTPQ Q 6 , a PTPQ with a 2-path
We now define a class C of PTPQs whose 3-path and 2-path swings appear in a symmetric way.

Definition 5.1. Let C be the class of PTPQs Q such that: (a) if the full form of Q contains the 3-path swing rically the 3-path swing a [ p 2 ]  X  a [ p 3 ] and b [ p 1 ] (b) if the full form of Q contains the 2-path swing a [ p tionships a [ p 1 ]  X  a 1 [ p 1 ] ,a 1 [ p 1 ]  X  a 2 [ p 1 ] , ..., a a b [ p 2 ] , then it also symmetrically contains the chains a [ p 2 ] sharing expressions a 1 [ p 1 ]  X  a 1 [ p 2 ] ,..., a k [ p 1 ] b 1 [ p 1 ]  X  b 1 [ p 2 ] ,..., b l [ p 1 ]  X  b l [ p 2 ] .
Clearly, class C comprises all TPQs. However, it also com-prises queries which are not TPQs as it contains PTPQs that involve two nodes in the same path with no derived prece-dence relationship between them.

The next theorem shows that for a PTPQ Q in C ,the existence of a homomorphism is a necessary condition for Q to be contained in another PTPQ.
 Theorem 5.1. Let Q be a PTPQ in ful l form from class C and Q be a PTPQ. Then, Q  X  Q if and only if there is an homomorphism from Q to Q .

In [2, 19] it is shown that the containment of tree-pattern queries involving only branching and child and descendant relationships can be fully characterized by the existence of a homomorphism between the two queries. The previous theorem confirms this result since these tree-pattern queries can be represented by PTPQs from class C .
As we saw in the previous section, we might fail to de-based on homomorphisms. Even if Q 1 is contained in Q 2 , there might be a PP in Q 2 that contains precedence rela-tionships and is involved in node sharing expressions which together cannot be mapped through a homomorhism to the precedence relationships and node sharing expressions of a PP of Q 1 . Such a homomorphism might not exist even if all possible derived precedence relationships and node shar-ing expressions are equivalently added to Q 1 by computing its full form. The main idea of our heuristic approach con-sists in computing additional PPs, called virtual PPs, that contain precedence relationships from two PPs. The virtual PPs along with node sharing expressions are appropriately added to Q 1 to produce PTPQs, called adjustments of Q 1 . It is important to note that an adjustment of Q 1 is equiv-has increased chances to have a homomorphism into it. This into Q 2 based on the existence of a homomorphism.
We define two types of virtual PPs which are based on 3-path and 2-path swings.

Definition 6.1. Let Q be a PTPQ that comprises a 3-path swing { a [ p 1 ]  X  a [ p 2 ] ,b [ p 2 ]  X  b [ p 3 ] for p 2 w.r.t. p 1 and p 3 in Q is a PP (set of precedence relationships) that comprises: (a) a precedence relationship r  X  a for every node a participating in a swing involving PPs p 1 , p 2 and p 3 , and (b) all precedence relationships that are common to p 1 and p 3 .

The virtual PP v comprises precedence relationships from two different PPs.

Example 6.1. Consider query Q 2 ofFigure5(whichis the full form of query Q 2 of Figure 2). Figure 8(a) shows the virtual PP v of PP p 5 w.r.t. PPs p 4 and p 6 in Q 2 .
We use the concept of virtual PP to define the adjustment of the query.
 Definition 6.2. Let v be a virtual PP for PP p 2 w.r.t. PPs p 1 and p 3 in a PTPQ Q .The adjustment of Q with v is aquery Q such that: (a) Q contains all the PPs and node sharing expressions of Q ,(b) Q contains the PP v with a name (say v ) that does not occur in Q , (c) for every node node sharing expressions a [ v ]  X  a [ p i ] and a [ v ]  X  (d) there is no homomorphism from Q to Q .

Note that condition (d) in the definition above guarantees that the adjustment Q of Q with v exists only if Q con-tains constructs (precedence relationships and node sharing expressions) that together do not appear in Q .

Example 6.2. Figure 8(b) shows the adjustment Q 2 of query Q 2 ofFigure5withthevirtualPP v shown in Figure 8(a). The full form Q 2 of Q 2 is shown in Figure 8(c). Figure 8(d) redraws query Q 3 of Figure 3. As proven in example 4.2, Q 2  X  Q 3 (and Q 2  X  Q 3 since Q 2  X  Q 2 ). Also, as stated in Section 4 (and one can easily check), there is no homomorphism from Q 3 to Q 2 . However, Figures 8(c) and (d), show a homomorphism from Q 3 to Q 2 (the full form of the adjustment of Q 2 . We prove later in this section that Q 2  X  Q 2 (and of course the same holds for the full form Q 2 of Q 2 ). Therefore, using the concept of adjustment of a PTPQ with a virtual PP, the containment of Q 2 into Q 3 can be detected based on the existence of a homomorphism.
Similarly to 3-path swings, 2-path swings can be used to define virtual paths:
Definition 6.3. Let Q be a PTPQ that comprises a 2-path swing { a [ p 1 ]  X  a [ p 2 ] ,b [ p 1 ]  X  b [ p 2 ] a [ p 1 ]  X  a 1 [ p 1 ] ,a 1 [ p 1 ]  X  a 2 [ p 1 ] , ..., a b [ p 2 ]  X  b 1 [ p 2 ] ,b 1 [ p 2 ]  X  b 2 [ p 2 ] ,...,a the chains of child precedence relationships attached to a [ p and b [ p 2 ] .A virtual PP for p 1 and p 2 in Q is a PP (set of precedence relationships) that comprises: (a) the prece-dence relationships a  X  a 1 ,a 1  X  a 2 , ..., a k  X  1  X  a b  X  b 1 ,b 1  X  b 2 , ..., a l  X  1  X  a l , and (b) al l precedence relationships that are common to p 1 and p 2 .

A PTPQ can be adjusted with virtual paths which are basedon2-pathswings.

Definition 6.4. Let v be a virtual PP for PPs p 1 and p 2 in a PTPQ Q .The adjustment of Q with v is a query Q such that: (a) Q contains all the PPs and node sharing ex-pressions of Q ,(b) Q contains the PP v withaname(say v ) that does occur in Q , (c) for every node sharing expres-sion a [ p 1 ]  X  a [ p 2 ] , Q contains the node sharing expressions phism from Q to Q .

Example 6.3. Figure 9(b) shows the adjustment, Q 6 ,of query Q 6 of Figure 7(a) with the virtual PP v 1 shown in Figure 9(a). As shown in example 5.2, the PTPQ Q 7 of Figure 7(b) contains the PTPQ Q 6 of Figure 7(a). However, there is no homomorphism from Q 7 to Q 6 .Onecaneasily see that there is a homomorphism from Q 7 to Q 6 .Aswe show below Q 6  X  Q 6 . Therefore, also for 2-path swings, using the adjustment of a PTPQ we can detect containment based on the existence of a homomorphism.

We can now show the following theorem for the adjust-ment of a PTPQ with a virtual PP.

Theorem 6.1. Let v be a virtual PP of a PTPQ Q (based on a 3-path or a 2-path swing). Let also Q be the adjustment of Q with v .Then, Q is equivalent to Q .

Since the adjustment of a PTPQ Q with a virtual PP is equivalent to Q itcanbeusedinsteadof Q when checking (b) The adjustment Q 6 of Q 6 with v containment of Q in another PTPQ Q . Since the adjust-ment of Q with a virtual PP has an additional PP with  X  X ew X  combinations of elements and precedence relationships, it in-creases the possibility of the existence of a homomorphism from Q to Q when Q is contained into Q .
APTPQ Q might have multiple virtual PPs based on dif-ferent swings in Q .Sincethefullformof Q can only add precedence relationships and node sharing expressions to Q , putting Q in full form can only increase the number of prece-dence relationships in the virtual PPs of Q . Suppose that we need to check the containment of Q into another PTPQ Q 1 . Our first heuristic approach computes the full form Q of Q , identifies all the virtual PPs v of Q , and iteratively computes the adjustment of Q with v . Clearly, the PTPQ dependent of the order of computation of the adjustments. PTPQ Q a is called adjustment of Q . The formal process is shown in Figure 11.

Based on Theorem 6.1, Q a is equivalent to Q . Our first heuristic approach checks containment of Q into Q 1 by check-ing the existence of a homomorphism from Q 1 to Q a . Clearly, this approach is sound but not complete: if there is a homo-morphism from Q 1 to Q a , Q  X  Q 1 . However, it is possible Input : a PTPQ Q Output : the adjustment of Q . compute the full form Q of Q Q t := Q . for each virtual PP v of Q /* virtual PPs can be compute and return the full form of Q t .
 Figure 11: Computation of the adjustment Q a of a PTPQ Q that Q  X  Q 1 and there is no homomorphism from Q 1 to the containment of a PTPQ Q intoaPTPQ Q 1 even when none of the PPs of Q 1 canbemappedto(thefullformof) Q through a homomorphism.

Example 6.4. Consider the PTPQs Q 8 and Q 9 of Fig-ures 10(a) and (c) respectively. PTPQ Q 8 is in full form. Clearly, there is no homomorphism from Q 9 to Q 8 .Figure 10(b) shows the adjustment Q 8 a of PTPQ Q 8 which com-prises two vitual PPs v 1 and v 2 . Figures 10(b) and (c) also outline a homomorphism from Q 9 to Q 8 a . This proves that Q 8  X  Q 9 . Note that the detection of this containment through a homomorphism became possible only because the adjustment of a PTPQ was used.
To study the effectiveness of our PTPQ containment check-ing technique, we ran a comprehensive set of experiments. Checking PTPQ containment using component TPQs is ex-pected to be time consuming for queries that involve a large number of such TPQs. However, our experimental evalua-tion shows that the heuristic approach for checking PTPQ containment can save a considerable amount of time, while maintaining high accuracy.
 Setup. We ran our experiments on a dedicated Linux PC (AMD Sempron 2600+) with 2 GB of RAM. The reported values are the average of repeated measurements. Specif-ically, for every measure point, 100 pairs of queries were generated and used for containment check. It is important to note that for each pair ( Q 1 ,Q 2 ) of PTPQs used for con-from Q 2 to the full form of Q 1 due to the existence of 2-path and 3-path swings.
 Experiments. In our experiments, we compared the exe-cution time and the accuracy for PTPQ containment check in the following cases: (a) checking the existence of a homo-morphism from Q 2 to Q 1 ( Hom ), (b) checking the existence of a homomorphism from Q 2 to the adjustment of Q 1 ( Adj ), to all component TPQs of Q 1 ( ComTPQs ). We tested the impact of the size and the density of the PTPQs on the ex-ecution time and on the accuracy for containment check in the above cases for different structures of the PTPQs. The accuracy of a technique is defined as the percentage of con-tainment detections using this technique. Below, we present the detailed results.
 Execution time and accuracy varying the size of queries. We measured the execution time and the accu-racy for checking PTPQ containment varying the number of elements in the queries for different numbers of PPs in the queries. In Figures 12 and 13, we present the results obtained for queries with 5 to 7 elements where the number of PPs ranges between 2 and 5. All queries include the min-imum number of swings that involve all PPs. Queries with 2 PPs include one 2-path swing (not shown due to lack of space), queries with 3 PPs include one 3-path swing, queries with 4 PPs include two 3-path swings, and queries with 5 PPs include three 3-path swings.

For a growing number of elements in the queries, the exe-cution time of homomorphism containment check ( Hom )is almost unaffected. However, it increases as the number of PPs goes up, because of the raise in the number of match-ings between the PPs of the involved queries that need to be examined.

The execution time of PTPQ containment check ( ComTPQs ) goes up as the number of elements or PPs in the queries increases. The reason is that a larger number of complete TPQs are generated and examined in the contain-ment check.

Our heuristic technique ( Adj ) clearly improves ComTPQs check. The execution time of Adj is not generally affected by the number of elements in the queries. However, similarly to Hom , the execution time of Adj increases as the number of PPs goes up, because of the raise in the number of match-ings between the PPs of the involved queries that need to be examined. For all measurements of this experiment, the accuracy of Adj is above 60%. Note that this percentage represents containment detection on pairs of contained PT-PQs where containment cannot be detected through the ex-istence of a homomorphism. Clearly, this percentage is much higher for random pairs of contained PTPQs since Adj can correctly detect containment when a homomorphism exists between the PTPQs.
 Execution time and accuracy varying the density of swings in the queries. We measured the execution time and the accuracy for checking PTPQ containment varying the number of elements in the PTPQs for different numbers of 3-path swings. In Figures 14 and 15, we present the re-sults obtained for queries having 5 to 7 elements, while the number of 3-path swings ranges from 3 to 9. The number of PPs in the queries is fixed to 5.

As expected, the execution time of homomorphism con-tainment check ( Hom ) is not affected by the number of swings in the queries.

Similarly to the previous experiment, the execution time of ComTPQs goes up as the number of elements in the queries increases. It also slightly decreases as the number of swings increases. The reason is that a larger number of swings involves a larger number of node sharing expressions among query nodes. Each node sharing expression restricts two query nodes to match the same image on the XML tree, thus a smaller number of component TPQs are generated and examined in the containment check.

Our heuristic technique again improves ComTPQs .When the number of swings in the queries goes up, the execution time of Adj increases. The reason is that the adjustment of queries with a large number of swings generally includes a larger number of virtual paths that need to be extracted and examined in the containment check. The accuracy of Adj in this experiment is above 60% for all measurements. Remarks. Our heuristic technique clearly improves the time of PTPQ containment check. Although the technique is not complete, our experiments show clearly that it is or-ders of magnitude faster than checking PTPQ containment using component TPQs, while maintaining high accuracy.
We considered PTPQs which correspond to a large frag-ment of XPath strictly containing TPQs. A central feature of this type of queries is that the structure can be specified fully, partially, or not at all in a query. Therefore, they can be used to query data sources whose structure is not fully known to the user, or to query multiple data sources which structure information differently.

We studied the containment problem for PTPQs, and we provided necessary and sufficient conditions for PTPQ con-tainment. We identified a subclass of PTPQs where contain-ment can be fully characterized by the existence of homo-morphisms. We further devised a sound but not complete heuristic approach that equivalently adds additional partial paths to PTPQs. A detailed experimental evaluation of our approach shows that it greatly improves the query contain-ment checking execution time, and that it trades execution time for accuracy. These results allow its use for query pro-cessing and optimization.

We are currently working on usi ng our heuristic technique to address minimization problems for PTPQs. [1] World Wide Web Consortium site (W3C), [2] S. Amer-Yahia, S. Cho, L. V. S. Lakshmanan, and [3] S. Amer-Yahia, S. Cho, and D. Srivastava. Tree [4] S. Amer-Yahia, L. V. S. Lakshmanan, and S. Pandit. [5] M. Benedikt and I. Fundulaki. XML subtree queries: [6] L. Chen and E. A. Rundensteiner. XQuery [7] S. Cluet, P. Veltri, and D. Vodislav. Views in a large [8] S. Cohen, J. Mamou, Y. Kanza, and Y. Sagiv. [9] A. Deutsch and V. Tannen. Containment and integrity [10] X. Dong, A. Y. Halevy, and I. Tatarinov. Containment [11] D. Florescu, D. Kossmann, and I. Manolescu. [12] S. Guha, H. V. Jagadish, N. Koudas, D. Srivastava, [13] V. Hristidis, Y. Papakonstantinou, and A. Balmin. [14] Y. Kanza and Y. Sagiv. Flexible Queries Over [15] L. V. Lakshmanan, H. W. Wang, and Z. J. Zhao. [16] L. V. S. Lakshmanan, G. Ramesh, H. W. Wang, and [17] Y. Li, C. Yu, and H. V. Jagadish. Schema-Free [18] Z. Liu and Y. Chen. Identifying meaningful return [19] G. Miklau and D. Suciu. Containment and [20] F. Neven and T. Schwentick. XPath Containment in [21] D. Olteanu. Forward node-selecting queries over trees. [22] D. Olteanu, H. Meuss, T. Furche, and F. Bry. Xpath: [23] Y. Papakonstantinou and V. Vassalos. Query [24] N. Polyzotis, M. Garofalakis, and Y. Ioannidis. [25] P. Ramanan. Efficient Algorithms for Minimizing Tree [26] A. Schmidt, M. L. Kersten, and M. Windhouwer. queries. [27] D. Theodoratos, T. Dalamagas, A. Koufopoulos, and [28] D. Theodoratos, T. Dalamagas, P. Placek, [29] D. Theodoratos, S. Souldatos, T. Dalamagas, [30] D. Theodoratos and X. Wu. Assigning Semantics to [31] P. T. Wood. Minimising Simple XPath Expressions. In [32] P. T. Wood. Containment for XPath Fragments under
