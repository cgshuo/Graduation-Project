 University of Trento University of Trento University of Rome  X  X or Vergata X  tures has recently favored the use of machine learning approaches to the design of automated forfeaturerepresentationandforeffectivedecompositionsofthetaskindifferentlearningmodels.
Regardingtheformerchoice,structuralpropertiesoffullsyntacticparsesarelargelyemployedas theyrepresentwaystoencodedifferentprinciplessuggestedbythelinkingtheorybetweensyntax and semantics. The latter choice relates to several learning schemes over global views of the of the same sentence have shown to be very effective.
 based machines, for example, perceptrons or support vector machines. In particular, we define of an SRL architecture both in isolation and in combination with other traditional manually codedfeatures.Theresultsforboundaryrecognition,classification,andre-rankingstagesprovide systematicevidenceaboutthesignificantimpactoftreekernelsontheoverallaccuracy,especially language processing tasks. 1. Introduction
Much attention has recently been devoted to the design of systems for the automatic labeling of semantic roles (SRL) as defined in two important projects: FrameNet (Baker,
Fillmore, and Lowe 1998), based on frame semantics, and PropBank (Palmer, Gildea, and Kingsbury 2005), inspired by Levin X  X  verb classes. To annotate natural language sentences, such systems generally require (1) the detection of the target word em-bodying the predicate and (2) the detection and classification of the word sequences constituting the predicate X  X  arguments.
 learning techniques (Carreras and M ` arquez 2004, 2005; Litkowski 2004), for which the most important features encoding predicate X  X rgument relations are derived from (shal-low or deep) syntactic information. The outcome of this research brings wide empirical evidence in favor of the linking theories between semantics and syntax, for example,
Jackendoff (1990). Nevertheless, as no such theory provides a sound and complete treatment, the choice and design of syntactic features to represent semantic structures requires remarkable research effort and intuition.
 ried out by Gildea and Jurafsky (2002) and Thompson, Levy, and Manning (2003). Since then, researchers have proposed several syntactic feature sets, where the more recent sets slightly enhanced the older ones.
 fragments of training sentences, thus a viable way to alleviate the feature design com-plexity is the adoption of syntactic tree kernels (Collins and Duffy 2002). For example, in
Moschitti (2004), the predicate X  X rgument relation is represented by means of the min-imal subtree that includes both of them. The similarity between two instances is eval-uated by a tree kernel function in terms of common substructures. Such an approach is in line with current research on kernels for natural language learning, for example, syntactic parsing re-ranking (Collins and Duffy 2002), relation extraction (Zelenko, Aone, and Richardella 2003), and named entity recognition (Cumby and Roth 2003; Culotta and Sorensen 2004).
 et al. 2005) has shown that, to achieve high labeling accuracy, joint inference should be applied on the whole predicate X  X rgument structure. For this purpose, we need to extract features from the sentence syntactic parse tree that encodes the relationships governing complex semantic structures. This task is rather difficult because we do not exactly know which syntactic clues effectively capture the relation between the predicate and its arguments. For example, to detect the interesting context, the modeling of syntax-/semantics-based features should take into account linguistic aspects like ancestor nodes or semantic dependencies (Toutanova, Markova, and Manning 2004).
In this scenario, the automatic feature generation/selection carried out by tree kernels can provide useful insights into the underlying linguistic phenomena. Other advantages coming from the use of tree kernels are the following.
 requires the writing of a general procedure for subtree extraction. In contrast, traditional
SRL systems use more than thirty features (e. g., Pradhan, Hacioglu, Krugler et al. 2005), each of which requires the writing of a dedicated procedure.
 accurate systems, also when using the same machine learning algorithm in the combi-nation, because the feature spaces are very different.
 strategies (Moschitti et al. 2005a; Moschitti, Pighin, and Basili 2006). This allows us to boost the SRL accuracy in a relatively simple way.
 models for important syntactic features. Using them, the learning algorithm generalizes 194 better and produces a more accurate classifier, especially when the amount of training data is scarce.
 tify the most important structured features of the generated model. One approach for such a reverse engineering process relies on the computation of the explicit feature space, at least for the highest-weighted features (Kudo and Matsumoto 2003). Once the most relevant fragments are available, they can be used to design novel effective attribute X  X alue features (which in turn can be used to design more efficient classifiers, e. g., with linear kernels) and inspire new linguistic theories.
 study of the problem. Unfortunately, they suffer from two main limitations: (a) poor impact on boundary detection as, in this task, correct and incorrect arguments may share a large portion of the encoding trees (Moschitti 2004); and (b) more expensive running time and limited contribution to the overall accuracy if compared with manu-ally derived features (Cumby and Roth 2003). Point (a) has been addressed by Moschitti,
Pighin, and Basili (2006) by showing that a strategy of marking relevant parse-tree nodes makes correct and incorrect subtrees for boundary detection quite different. Point (b) can be tackled by studying approaches to kernel engineering that allow for the design of efficient and effective kernels.
 mantic role labeling. For this purpose, we define tree kernels based on the composition of two different feature functions: canonical mappings , which map sentence-parse trees in tree structures encoding semantic information, and feature extraction functions , which encode these trees in the actual feature space. The latter functions explode the tree kernels . For instance, in Collins and Duffy (2002), Vishwanathan and Smola (2002), and Moschitti (2006a) different tree kernels extract different types of tree fragments. by experimenting with them within support vector machines and with the data set provided by CoNLL shared tasks (Carreras and M ` arquez 2005). The results show that carefully engineered tree kernels always boost the accuracy of the basic systems. Most importantly, in complex tasks such as the re-ranking of semantic role annotations, they provide an easy way to engineer new features which enhance the state-of-the-art in SRL. and the typical features proposed in literature. Tree kernels are formally introduced in Section 3, and Section 4 describes our modular architecture employing support vector machines along with manually designed features, tree kernels (feature extraction functions), and their combinations. Section 5 presents our structured features (canonical mappings) inducing different kernels that we used for different SRL subtasks. The extensive experimental results obtained on the boundary recognition, role classification, and re-ranking stages are presented in Section 6. Finally, Section 7 summarizes the conclusions. 2. Automatic Shallow Semantic Parsing
The recognition of semantic structures within a sentence relies on lexical and syntactic information provided by early stages of an NLP process, such as lexical analysis, part-of-speech tagging, and syntactic parsing. The complexity of the SRL task mostly depends on two aspects: (a) the information is generally noisy, that is, in a real-world scenario the accuracy and reliability of NLP subsystems are generally not very high; and (b) the lack of a sound and complete linguistic or cognitive theory about the links between syntax and semantics does not allow an informed, deductive approach to the problem.
Nevertheless, the large amount of available lexical and syntactic information favors the application of inductive approaches to the SRL task, which indeed is generally treated as a combination of statistical classification problems.
 relevant work carried out to address these two problems. 2.1 Problem Definition The most well-known shallow semantic theories are studied in two different projects: PropBank (Palmer, Gildea, and Kingsbury 2005) and FrameNet (Baker, Fillmore, and
Lowe 1998). The former is based on a linguistic model inspired by Levin X  X  verb classes (Levin 1993), focusing on the argument structure of verbs and on the alternation pat-terns that describe movements of verbal arguments within a predicate structure. The latter refers to the application of frame semantics (Fillmore 1968) in the annotation of predicate X  X rgument structures based on frame elements (semantic roles). These theories have been investigated in two CoNLL shared tasks (Carreras and M ` arquez 2004, 2005) and a Senseval-3 evaluation (Litkowski 2004), respectively.
 sentence in which the sequences of words that make up the arguments of the predicate are properly labeled, for example: in response to the input He got his money back . This processing requires that: (1) the predicates within the sentence are identified and (2) the word sequences that span the boundaries of each predicate argument are delimited and assigned the proper role label. lexical and syntactic rules. In the case of verbal predicates, it is quite easy to write simple rules matching regular expressions built on PO Stags. The second task is more complex and is generally viewed as a combination of statistical classification problems:
The learning algorithms are trained to recognize the extension of predicate arguments and the semantic role they play. 2.2 Models for Semantic Role Labeling
An SRL model and the resulting architecture are largely influenced by the kind of data available for the task. As an example, a model relying on a shallow syntactic parser would assign roles to chunks, whereas with a full syntactic parse of the sentence it would be straightforward to establish a correspondence between nodes of the parse tree and semantic roles. We focused on the latter as it has been shown to be more accurate by the CoNLL 2005 shared task results.
 of parse-tree nodes which dominate the exact span of the predicate and the target argument. Such pairs are usually represented in terms of attribute X  X alue vectors, where 196 the attributes describe properties of predicates, arguments, and the way they are related.
There is large agreement on an effective set of linguistic features (Gildea and Jurafsky 2002; Pradhan, Hacioglu, Krugler, et al. 2005) that have been employed in the vast majority of SRL systems. The most relevant features are summarized in Table 1. classifier is used to recognize the correct node pairs, namely, nodes associated with correct arguments (given a predicate), and assign them a label (which is the label of the argument). This can be achieved by training a multi-classifier on n + 1 classes, where the first n classes correspond to the different roles and the ( n + 1) argument) class to which non-argument nodes are assigned.
 boundary detection and argument classification. A Boundary Classifier (BC) is a binary classifier that recognizes the tree nodes that exactly cover a predicate argument, that is, that dominate all and only the words that belong to target arguments. Then, such nodes are classified by a Role Multi-classifier (RM) that assigns to each example the most appropriate label. This two-step approach (Gildea and Jurafsky 2002) has the advantage of only applying BC on all parse-tree nodes. RM can ignore non-boundary nodes, resulting in a much faster classification. Other approaches have extended this solution and suggested other multi-stage classification models (e. g., Moschitti et al. 2005b in which a four-step hierarchical SRL architecture is described).
 ment classifier does not result in a consistent annotation, as the labeling scheme may not be compatible with the underlying linguistic model. As an example, PropBank-style annotations do not allow arguments to be nested. This happens when two or more overlapping tree nodes, namely, one dominating the other, are classified as positive boundaries.
 the whole predicate X  X rgument structure to remove the incorrect labels (e. g., Moschitti et al. 2005a; Tjong Kim Sang et al. 2005). A much more complex solution consists in the application of some joint inference model to the whole predicate X  X rgument structure, as in Pradhan et al. (2004). As an example, Haghighi, Toutanova, and Manning (2005) associate a posterior probability with each argument node role assignment, estimate the likelihood of the alternative labeling schemes, and employ a re-ranking mechanism to select the best annotation.
 (Pradhan, Hacioglu, Ward et al. 2005; Punyakanok et al. 2005) use different syntactic views of the same input sentence. This allows the SRL system to recover from syntactic parser errors; for example, a prepositional phrase specifying the direct object of the predicate would be attached to the verb instead of the argument. This kind of error prevents some arguments of the proposition from being recognized, as: (1) there may not be a node of the parse tree dominating (all and only) the words of the correct se-quence; (2) a badly attached tree node may invalidate other argument nodes, generating unexpected overlapping situations.
 predicate X  X rgument structures (also coming from different syntactic views) is quite complex. Tree kernels are a valid alternative to manual design as the next section points out. 3. Tree Kernels
Tree kernels have been applied to reduce the feature design effort in the context of several natural language tasks, for example, syntactic parsing re-ranking (Collins and
Duffy 2002), relation extraction (Zelenko, Aone, and Richardella 2003), named entity recognition (Cumby and Roth 2003; Culotta and Sorensen 2004), and semantic role labeling (Moschitti 2004).
 sets is useful to quickly model new and not well understood linguistic phenomena in learning machines. On the other hand, they show that sometimes it is possible to manually design features for linear kernels that produce higher accuracy and faster computation time. One of the most important causes of such mixed behavior is the inappropriate choice of kernel functions. For example, in Moschitti, Pighin, and Basili (2006) and Moschitti (2006a), several kernels have been designed and shown to produce different impacts on the training algorithms.
 (ST) kernel devised in Vishwanathan and Smola (2002), the subset tree (SST) kernel defined in Collins and Duffy (2002), and the partial tree (PT) kernel proposed in
Moschitti (2006a). 3.1 Kernel Trick
The main concept underlying machine learning for classification tasks is the automatic learning of classification functions based on examples labeled with the class informa-tion. Such examples can be described by means of feature vectors in an n dimensional 198 space over the real numbers, namely, n . The learning algorithm uses space metrics over vectors, for example, the scalar product, to learn an abstract representation of all instances belonging to the target class.
 hyperplane f ( x ) = w  X  x + b = 0, separating positive from negative examples. x is the feature vector representation of a classifying object o , whereas w parameters learned from the data by applying the Structural Risk Minimization principle (Vapnik 1998). The object o is mapped to x via a feature function  X  : the set of the objects that we want to classify. o is categorized in the target class only if f ( x )  X  0.
 where y i is equal to 1 for positive examples and  X  1 for negative examples,  X   X   X  0, o is the kernel function associated with the mapping  X  .

This allows us, under Mercer X  X  conditions (Shawe-Taylor and Cristianini 2004), to define abstract kernel functions which generate implicit feature spaces. A traditional example is given by the polynomial kernel: K p ( o 1 , o 2 ) = ( c + x is the degree of the polynomial. This kernel generates the space of all conjunctions of feature groups up to d elements.
 manually defined features with the knowledge automatically obtained with structural kernels; feature mapping compositions are useful methods to describe diverse kernel classes (see Section 5). In this perspective, we propose to split the mapping  X  by defining our tree kernel as follows: mapping  X  M (), obtaining K M ST =  X  ST (  X  M ( o 1 ))  X   X   X 
M ( o 2 ), which is a noticeably different kernel, which is induced by the mapping by defining three different feature extraction mappings based on three different kernel spaces (i. e., ST, SST, and PT). 3.2 Tree Kernel Spaces The kernels that we consider represent trees in terms of their substructures (fragments).
The kernel function detects if a tree subpart (common to both trees) belongs to the fea-ture space that we intend to generate. For this purpose, the desired fragments need to be described. We consider three main characterizations: the subtrees (STs) (Vishwanathan and Smola 2002), the subset trees (SSTs) or all subtrees (Collins and Duffy 2002), and the partial trees (PTs) (Moschitti 2006a).
 a grammar production rule, where the symbol on the left-hand side corresponds to the parent and the symbols on the right-hand side are associated with the children. The terminal symbols of the grammar are always associated with tree leaves.
 all its descendants. For example, Figure 1a shows the parse tree of the sentence Mary brought a cat together with its six STs. A subset tree (SST) is a more general structure because its leaves can be non-terminal symbols. For example, Figure 1(b) shows ten
SSTs (out of 17) of the subtree in Figure 1a rooted in VP . SSTs satisfy the constraint that grammatical rules cannot be broken. For example, [VP [V NP]] is an SST which has two non-terminal symbols, V and NP , as leaves. On the contrary, [VP [V]] is not an
SST as it violates the production VP  X  V NP. If we relax the constraint over the SSTs, we obtain a more general form of substructures that we call partial trees (PTs). These can be generated by the application of partial production rules of the grammar; consequently [VP [V]] and [VP [NP]] are valid PTs. It is worth noting that PTs consider the position of the children as, for example, [A [B][C][D]] and [A [D][C][B]] only share single children, i.e., [A [B]] , [A [C]] ,and [A [D]] .
 higher (i. e., 30 PTs). These numbers provide an intuitive quantification of the different degrees of information encoded by each representation.
 200 3.3 Feature Extraction Functions
The main idea underlying tree kernels is to compute the number of common substruc-tures between two trees T 1 and T 2 without explicitly considering the whole fragment space. In the following, we report on the Subset Tree (SST) kernel proposed in Collins and Duffy (2002). The algorithms to efficiently compute it along with the ST and PT kernels can be found in Moschitti (2006a).
 defined as where N T 1 and N T 2 are the sets of nodes in T 1 and T 2 n 1 and n 2 .  X  can be computed as follows: 1. If the productions (i.e. the nodes with their direct children) at n 2. If the productions at n 1 and n 2 are the same, and n 3. If the productions at n 1 and n 2 are the same, and n weight of large structures (refer to Collins and Duffy [2002] for a complete description). 3.4 Related Work
Although the literature on SRL is extensive, there is almost no study of the use of tree kernels for its solution. Consequently, the reported research is mainly based on diverse natural language learning problems tackled by means of tree kernels.
 perceptron for the parse tree re-ranking task. A combination with the original PCFG model improved the syntactic parsing. Another interesting kernel for re-ranking was defined in Toutanova, Markova, and Manning (2004). This represents parse trees as lists of paths (leaf projection paths) from leaves to the top level of the tree. It is worth noting that the PT kernel includes tree fragments identical to such paths.
 running time is presented. This algorithm looks for node pairs in which the rooted subtrees share many substructures ( malicious nodes ) and applies a transformation to the trees rooted in such nodes to make the kernel computation faster. The results show a several-hundred-fold speed increase with respect to the basic implementation. parser structures were devised for the extraction of linguistic relations, for example, person-affiliation . To measure the similarity between two nodes, the contiguous string kernel and the sparse string kernel were used. In Culotta and Sorensen (2004) such kernels were slightly generalized by providing a matching function for the node pairs. The time complexity for their computation limited the experiments to a data set of just 200 news items.
 grammar (LTAG) for the parse re-ranking task was proposed. The subtrees induced by this kernel are built using the set of elementary trees as defined by LTAG. tured features from the syntactic shallow parse trees associated with named entities.
Their experiments on named entity categorization showed that when the description language selects an adequate set of tree fragments the voted perceptron algorithm increases its classification accuracy. The explanation was that the complete tree fragment set contains many irrelevant features and may cause overfitting.
 were applied in a way similar to the one proposed in Moschitti (2004). The combina-tion of standard features along with several tree subparts, tailored according to their importance for the task, produced again an improvement on the state of the art. can efficiently represent syntactic objects, for example, constituent parse trees, in huge feature spaces. The next section describes our SRL system adopting tree kernels within
SVMs. 4. A State-of-the-Art Architecture for Semantic Role Labeling
A meaningful study of tree kernels for SRL cannot be carried out without a comparison with a state-of-the-art architecture: Kernel models that improve average performing systems are just a technical exercise whose findings would have a reduced value. A state-of-the-art architecture, instead, can be used as a basic system upon which tree kernels should improve. Because kernel functions in general introduce a sensible slow-down with respect to the linear approach, we also have to consider efficiency issues. These aims drove us in choosing the following components for our SRL system: 202 likely to be incorrect boundaries, for example, as done in Xue and Palmer (2004). On the one hand, this makes the learning and classification phases more complex because they involve more instances. On the other hand, our results are not biased by the quality of the heuristics, leading to more meaningful findings.
 architecture for SRL and introduce some basic concepts about the use of structured features for SRL. Specific feature engineering for the above SRL subtasks is described and discussed in Section 5. 4.1 A Basic Two-Stage Role Labeling System
Given a sentence in natural language, our SRL system identifies all the verb predicates and their respective arguments. We divide this step into three subtasks: (a) predicate detection, which can be carried out by simple heuristics based on part-of-speech infor-mation, (b) the detection of predicate X  X rgument boundaries (i. e., the span of their words in the sentence), and (c) the classification of the argument type (e. g., Arg0 or ArgM in PropBank).
 predicate arguments is summarized by the following steps: 1. Given a sentence from the training set , generate a full syntactic parse tree; 2. let P and A be the set of predicates and the set of parse-tree nodes (i. e., the 3. for each pair p , a  X  P  X  A : where p is the node associated with the predicate took and a is any other tree node not overlapping with p . If the node a exactly covers the word sequences John or the book , then  X  ( p , a ) is added to the set E + , otherwise it is added to E (NN book) .
 multiclassifier, the elements of E + can be reorganized as positive E examples for each role type i . In this way, a binary OVA classifier for each argument i can be trained. We adopted this solution following Pradhan, Hacioglu, Krugler et al. (2005) because it is simple and effective. In the classification phase, given an unseen sentence, all the pairs p , a are generated and classified by each individual role classifier
C . The argument label associated with the maximum among the scores provided by C is eventually selected.
 guistic theories and intuitions. From a technical point of view, we can use  X  to map p , a in feature vectors or in structures to be used in a tree kernel function. The next section describes our choices in more detail. 4.2 Linear and Structured Representation
Our feature extractor module and our learning algorithms are designed to cope with both linear and structured features, used for the different stages of the SRL process. the sentence-parse tree or their canonical transformation (see Section 3.1). In particular, we focus on the minimal spanning tree that includes the predicate along with all of its arguments.
 contains all and only the nodes n i  X  N t , along with their ancestors and descendants. An
NST can be built as follows. For any choice of N t , we call r the lowest common ancestor 204 that: (1) do not belong to N t and (2) are neither ancestors nor descendants of any node belonging to N t .
 icate argument spanning tree (AST n ) of a predicate argument node set A as the NST over these nodes and the predicate node, that is, the node exactly covering the predicate p . 2 An AST n corresponds to the minimal parse subtree whose leaves are all and only the word sequences belonging to the arguments and the predicate. For example, Figure 3a shows the parse tree of the sentence: John took the book and read its predicates took and read , respectively, and are shown in Figure 3b and 3c. can be employed for those tasks that require a representation of the whole predicate X  argument structure, for example, overlap resolution or proposition re-ranking. is a canonical transformation of the AST n in the subtree including the predicate p and only one of its arguments. For the sake of uniform notation, PAF will be referred to as
AST 1 ( argument spanning tree ), the subscript 1 stressing the fact that the structure only encompasses one of the predicate arguments. An example AST
Manipulations of an AST 1 structure can lead to interesting tree kernels for local learning tasks, such as boundary detection and argument classification.
 from the problem of selecting both boundaries and argument roles independently of the whole structures. Thus, it is possible that (a) two labeled nodes refer to the same arguments (node overlaps) and (b) invalid role sequences are generated (e. g., Arg0,
Arg0, Arg0, ... ). Next, we describe our approach to solving such problems. 4.3 Conflict Resolution
We call a conflict ,or ambiguity ,or overlap resolution a stage of the SRL process which resolves annotation conflicts that invalidate the underlying linguistic model. This happens, for example, when both a node and one of its descendants are classified as positive boundaries, namely, they received a role label. We say that such nodes are overlapping as their leaf (i. e., word) sequences overlap. Because this situation is not allowed by the PropBank annotation definition, we need a method to select the most appropriate word sequence. Our system architecture can employ one of three different disambiguation strategies:
The latter approach consists of: (1) a software module that generates all the possible non-overlapping configurations of nodes. These are built using the output of the local node classifiers by generating all the permutations of argument nodes of a predicate and re-moving the configurations that contain at least one overlap; (2) an SVM trained on such non-overlapping configurations, where the positive examples are correct predicate X  argument structures (although eventually not complete) and negative ones are not. At testing time, we classify all the alternative non-clashing configurations. In case more than one structure is selected as correct, we choose the one associated with the highest SVM score.
 cation. The different information available after each phase can be used to design differ-ent kinds of features. For example, the knowledge of the candidate role of an argument node can be a key issue in the design of effective conflict resolution methodologies, for example, by eliminating Arg X ,Arg X ,Arg X , ... sequences. These different approaches are discussed in Section 5.2.
 and choose the most correct annotation for a proposition among a set of alternative labeling schemes. 4.4 A Joint Model for Re-Ranking The heuristics considered in the previous sections only act when a conflict is detected.
In a real situation, many incorrect annotations are generated with no overlaps. To deal with such cases, we need a re-ranking module based on a joint BC and RM model as suggested in Haghighi, Toutanova, and Manning (2005). Such a model is based on (1) 206 an algorithm to evaluate the most likely labeling schemes for a given predicate, and (2) a re-ranker that sorts the labeling schemes according to their correctness . nodes, hence requiring a probabilistic output from BC and RM. As the SVM learning algorithm produces metric values, we applied Platt X  X  algorithm (Platt 1999) to convert them into probabilities, as already proposed in Pradhan, Ward et al. (2005). These posterior probabilities are then combined to generate the n labelings that maximize a likelihood measure. Step 2 requires the training of an automatic re-ranker. This can be designed using a binary classifier that, given two annotations, decides which one is more accurate. We modeled such a classifier by means of three different kernels based on standard features, structured features, and their combination. 4.4.1 Evaluation of the N-best Annotations. First, we converted the output of each node-classifier into a posterior probability conditioned by its output scores (Platt 1999).
This method uses a parametric model to fit onto a sigmoid distribution the posterior probability P ( y = 1, f ), where f is the output of the classifier and the parameters are dynamically adapted to give the best probability output. 3 most likely sequences of node labelings. Given a predicate, the likelihood of a labeling scheme (or state ) s for the K candidate argument nodes is given by: where p i ( l ) is the probability of node i being assigned the label l ,and p probability weighted by the probability p i ( ARG ) of the node being an argument. If l =
NARG (not an argument) then both terms evaluate to (1  X  p of the NARG label assignment is given by (1  X  p i ( ARG )) the likelihood of all possible states because they are exponential in number. In order to reduce the search space we (a) limit the number of possible labelings of each node to m and (b) avoid traversing all the states by applying a Viterbi algorithm to search for the most likely labeling schemes. From each state we generate the states in which a candidate argument is assigned different labels. This operation is bound to output at most n states which are generated by traversing a maximum of n in the worst case scenario the number of traversed states is V = n number of candidate argument nodes in the tree.
 state in which a node n j is assigned a label l = NARG , we generate all; and only the states in which all the nodes that are dominated by n j are assigned the NARG label. 4.4.2 Modeling an Automatic Re-Ranker. The Viterbi algorithm generates the n most likely annotations for the proposition associated with a predicate p . These can be used to build s is more accurate that s j . Each candidate proposition s i feature t i and a vector of standard features v i . As a whole, an example e the tuple t 1 i , t 2 i , v 1 i , v 2 i , where t 1 i and v and v 2 i refer to the second one. Given such data, we can define the following re-ranking kernels: where K t is one of the tree kernel functions defined in Section 3 and K kernel applied to the feature vectors. The final kernel that we use is the following combination: tions to a large extent. In the next section, we describe in more detail our structured features and the engineering methods applied for the different subtasks of the SRL process. 5. Structured Feature Engineering
Structured features are an effective alternative to standard features in many aspects. An important advantage is that the target feature space can be completely changed even by small modifications of the applied kernel function. This can be exploited to identify features relevant to learning problems lacking a clear and sound linguistic or cognitive justification.
  X  is a mapping in an Euclidean space, and o 1 and o 2 are the target data, for example, parse trees. To make the engineering process easier, we decompose  X  into a canonical mapping ,  X  M ,anda feature extraction function,  X  S , over the set of incoming parse trees.  X  M transforms a tree into a canonical structure equivalent to an entire class of input parses and  X  S shatters an input tree into its subparts (e. g., subtrees, subset trees, or partial trees as described in Section 3). A large number of different feature spaces can thus be explored by suitable combinations  X  =  X  S  X   X  M of mappings.
 for SRL. In particular, we define structured features for the different phases of the SRL process, namely, boundary detection, argument classification, conflict resolution, and proposition re-ranking. 5.1 Structures for Boundary Detection and Argument Classification
The AST 1 or PAF structures, already mentioned in Section 4.2, have shown to be very effective for argument classification but not for boundary detection. The reason is that two nodes that encode correct and incorrect boundaries may generate very similar
AST 1 s and, consequently, have many fragments in common. To solve this problem, we 208 specify the node that exactly covers the target argument node by simply marking it (or marking all its descendants) with the label B , denoting the boundary property. formal style , highlighting the predicate with its two arguments, that is, Arg0 and Arg1. with the marked argument node, and the completely marked structure, respectively.
This reports the case in which a correct and an incorrect argument node are chosen by also showing the corresponding AST 1 and AST m 1 representations ((a) and (b)). Figure 6c shows that the number of common fragments of two AST 1 structures is 14. This is much larger than the number of common AST m 1 fragments, that is, only 3 substructures (Figure 6d).
 and number of the other predicate arguments 4 (Punyakanok et al. 2005; Toutanova,
Haghighi, and Manning 2005), we should extract features from the whole predicate argument structure. In contrast, AST 1 s completely neglect the information (i. e., the tree portions) related to non-target arguments.
 subtree that spans all the predicate X  X rgument structures, that is, the AST Section 4.2.
 detection task since we do not know the predicate X  X rgument structure yet. We can derive the AST n (its approximation) from the nodes selected by a boundary classifier, that is, the nodes that correspond to potential arguments. Such approximated AST can be easily used in the argument classification stage.
 way to differentiate it for each target argument. Again, we can mark the target argument node as shown in the previous section. We refer to this subtree as a marked target
AST n (AST mt n ). However, for large arguments (i. e., spread over a large part of the sentence tree) the substructures X  likelihood of being part of different arguments is quite high.
 argument node. We refer to this structure as a completely marked target AST
AST cmt n s may be seen as AST 1 s enriched with new information coming from the other arguments (i. e., the non-marked subtrees). Note that if we only consider the AST subtree from a AST cmt n , we obtain AST cm 1 . 210 5.2 Structured Features for Conflict Resolution
This section describes structured features employed by the tree kernel X  X ased conflict resolution module of the SRL architecture described in Section 4.3. This subtask is performed by means of: 1. A first annotation of potential arguments using a high recall boundary 2. An AST n classification step aiming at selecting, among the substructures
The set of argument nodes recognized by BC can be associated with a subtree of the corresponding sentence parse, which can be classified using tree kernel functions. These should evaluate whether a subtree encodes a correct predicate X  X rgument structure or not. As it encodes features from the whole predicate X  X rgument structure, the AST we introduced in Section 4.2 is a structure that can be employed for this task. classifier examples are built as follows: (1) we look for node pairs n where n 1 is the ancestor of n 2 or vice versa ; (2) we create two node sets A and A 2 = A  X  X  n 2 } and classify the two NSTs associated with A kernel classifier to select the most correct set of argument boundaries. This procedure can be generalized to a set of overlapping nodes O with more than two elements, as we simply need to generate all and only the permutations of A  X  X  nodes that do not contain overlapping pairs.
 BC labels as potential arguments four nodes (circled), three of which are overlapping (in bold circles). The overlap resolution algorithm proposes two solutions (Figure 7b) of which only one is correct. In fact, according to the second solution, the preposi-tional phrase of the book would incorrectly be attached to the verbal predicate, that is, in contrast with the parse tree. The AST n classifier, applied to the two NSTs, should detect this inconsistency and provide the correct output. Figure 7 also high-lights a critical problem the AST n classifier has to deal with: as the two NSTs are perfectly identical, it is not possible to distinguish between them using only their fragments.
 vided by BC to the NSTs. We mark with a progressive number the phrase type cor-responding to an argument node, starting from the leftmost argument. We call the resulting structure an ordinal predicate X  X rgument spanning tree (AST in the first NST of Figure 7c, we mark as NP-0 and NP-1 the first and second argument nodes, whereas in the second NST, we have a hypothesis of three arguments on three nodes that we transform as NP-0 , NP-1 ,and PP-2 .
 tinguishing between two identical parse trees associated with different argument struc-tures. For example, for the first NST the fragments [NP-1 [NP PP]] , [NP [DT NN]] ,and [PP [IN NP]] are generated. They no longer match with the fragments of the second NST [NP-0 [NP PP]] , [NP-1 [DT NN]] ,and [PP-2 [IN NP]] .
 spanning tree (AST m n ), in which each argument node is marked with a role label as-signed by a role multi-classifier (RM). Of course, this model requires a RM to classify all the nodes recognized by BC first. An example AST m n is shown in Figure 7d. 5.3 Structures for Proposition Re-Ranking
In Section 4.4, we presented our re-ranking mechanism, which is inspired by the joint inference model described in Haghighi, Toutanova, and Manning (2005). Designing structured features for the re-ranking classifier is complex in many aspects. Unlike the other structures that we have discussed so far, the defined mappings should: (1) preserve as much information as possible about the whole predicate X  X rgument structure; (2) focus the learning algorithm on the whole structure; and (3) be able to identify those small differences that distinguish more or less accurate labeling schemes. Among the possible solutions that we have explored, three are especially interesting in terms of accuracy improvement or linguistic properties, and are described hereinafter.
 argument node label is enriched with the role assigned to the node by RM. The la-bels of the descendants of each argument node are modified accordingly, down to pre-terminal nodes. The AST cmt n is a variant of AST cm n marked. Marking a node descendant is meant to force substructures matching only among homogeneous argument types. This representation should provide rich syn-tactic and lexical information about the parse tree encoding the predicate X  X rgument structure.
 structure that preserves the parse subtrees associated with each argument node while discarding the intra-argument syntactic parse information. Indeed, the syntactic links between the argument nodes are represented as a dummy 1-level tree, which appears in any PA Sand therefore does not influence the evaluation of similarity between pairs 212 of structures. This structure accommodates the predicate and all the arguments of an annotation in a sequence of seven slots. 5 To each slot is attached an argument label to which in turn is attached the subtree rooted in the argument node. The predicate is represented by means of a pre-terminal node labeled rel to which the lemmatization of the predicate word is attached as a leaf node. In general, a proposition consists of m arguments, with m  X  6, where m varies according to the predicate and the context. To guarantee that predicate structures with a different number of arguments are matched in the SST kernel function, we attach a dummy descendant marked null to the slots not filled by an argument.
 that only focuses on the syntax of the predicate X  X rgument structure, namely, the type and relative position of each argument, minimizing the amount of lexical and syntactic information derived from the parse tree. The differences with the PA Sare that: (1) each slot is attached to a pre-terminal node representing the argument type and a terminal node whose label indicates the syntactic type of the argument; and (2) the predicate word is lemmatized.
 proposed canonical structures in SRL. 6. Experiments
The experiments aim to measure the contribution and the effectiveness of our proposed kernel engineering models and of the diverse structured features that we designed (Section 5). From this perspective, the role of feature extraction functions is not fundamental because the study carried out in Moschitti (2006a) strongly suggests that the SST (Collins and Duffy 2002) kernel produces higher accuracy than the PT kernel when dealing with constituent parse trees, which are adopted in our study. selected the SST kernel and designed the following experiments: (a) A study of canonical functions based on node marking for boundary detection and argument classification, that is, AST m 1 (Section 6.2). Moreover, as the standard features have shown to be effective, we combined them with AST the boundary detection and classification tasks (Section 6.2). (b) We varied the amount of training data to demonstrate the higher generalization ability of tree kernels (Section 6.3). (c) Given the promising results of kernel engineering, we also applied it to solve a more complex task, namely, conflict resolution in SRL annotations (see Section 6.4). As this involves the complete predicate X  X rgument structure, we could test advanced canonical functions generating AST n ,AST ord n , and AST m n . (d) Previous work has shown that re-ranking is very important in boosting the accuracy of SRL. Therefore, we tested advanced canonical mappings, that is, those based on
AST cm n , PAS, and PAS tl , on such tasks (Section 6.5). 6.1 General Setup The empirical evaluations were mostly carried out within the setting defined in the
CoNLL 2005 shared task (Carreras and M ` arquez 2005). As a target data set, we used the PropBank 7 and the automatic Charniak parse trees of the sentences of Penn
TreeBank 2 corpus 8 (Marcus, Santorini, and Marcinkiewicz 1993) from the CoNLL 2005 shared-task data. 9 We employed the SVM-light-TK software kernel evaluation (Moschitti 2006b), and combinations between multiple feature vectors and trees in the SVM-light software (Joachims 1999). We used the default regularization parameter (option -c )and  X  = 0 . 4 (see Moschitti [2004]). 6.2 Testing Canonical Functions Based on Node Marking
In these experiments, we measured the impact of node marking strategies on boundary detection (BD) and the complete SRL task, that is, BD and role classification (RC). We employed a configuration of the architecture described in Section 4 and previously 214 adopted in Moschitti et al. (2005b), in which the simple conflict resolution heuristic is applied. The results were derived within the CoNLL setting by means of the related evaluator.

Penn TreeBank Sections 2 X 6 for training 11 and Section 24 for testing. Our classification model applied to this data replicates the results obtained in the CoNLL 2005 shared task, that is, the highest accuracy in BD among the systems using only one parse tree and one learning algorithm. For the complete SRL task, we used the previous
BC and all the available data, that is, the sections from 2 to 21, for training the role multiclassifier.
 arguments cannot be associated with any covering node; thus we cannot extract a tree representation for them. In particular, Table 2 shows the number of arguments (column 2) for sections 2, 3, and 24 as well as the number of arguments that we could not take into account (Unrecoverable) due to the lack of parse tree nodes exactly covering their word spans. Note how Section 24 of the Penn TreeBank (which is not part of the Charniak training set) is much more affected by this problem.

AST 1 and the AST m 1 based kernels. The results are reported in the rows AST of Table 3. Columns 2, 3, and 4 show their Precision, Recall, and F1 measure on BD and columns 5, 6, and 7 report the performance on SRL. We note that marking the argument node simplifies the generalization process as it improves both tasks by about 3.5 and 2.5 absolute percentage points, respectively.
 tures (Moschitti et al. 2005b) outperforms AST m 1 by about 4.5 percentage points in BD and 8 points in the SRL task. The main reason is that the employed tree structures do not explicitly encode very important features like the passive voice or predicate position. In Moschitti (2004), these are shown to be very effective especially when used in polynomial kernels. Of course, it is possible to engineer trees including these and other standard features with a canonical mapping, but the aim here is to provide new interesting representations rather than to abide by the simple exercise of representing already designed features within tree kernel functions. In other words, we follow the idea presented in Moschitti (2004), where tree kernels were suggested as a means to derive new features rather than generate a stand-alone feature set.
 combination of polynomial and tree kernels. Unfortunately, the results on both BD and SRL do not show enough improvement to justify the use of tree kernels; for example,
Poly+AST m 1 improves Poly by only 0.52 in BD and 0.3 in SRL. The small improvement is intuitively due to the use of (1) a state-of-the-art model as a baseline and (2) a very large amount of training data which decreases the contribution of tree features. In the next section an analysis in terms of training data will shed some light on the role of tree kernels for BD and RC in SRL. 6.3 The Role of Tree Kernels for Boundary Detection and Argument Classification
The previous section has shown that if a state-of-the-art model tree kernel contribution is marginal. On the contrary, if a non state-of-the-art model is adopted tree kernels can play a significant role. To verify this hypothesis, we tested the polynomial kernel over the standard feature vector proposed in Gildea and Jurafsky (2002) obtaining an F1 of 67.3, which is comparable with the AST
Moreover, a kernel combination produced a significant improvement of both models reaching an F1 of 70.4.
 tasks for which the optimal data representation has not yet been developed. For exam-ple, although SRL has been studied for many years and many effective features have been designed, representations for languages like Arabic are still not very well under-stood and raise challenges in the design of effective predicate X  X rgument descriptions. factory as the huge feature space produced by them should play a more important role in predicate X  X rgument representation. For example, the many fragments extracted by an AST 1 provide a very promising back-off model for the Path feature, which should improve the generalization process of SVMs.
 is small, we experimented with Poly, AST 1 ,AST m 1 , Poly+AST 216 different bins of training data, starting from a very small set, namely, 10,000 instances (1%) to 1 million (100%) of instances. The results from the BD classifiers and the complete SRL task are very interesting and are illustrated by Figure 9. We note several things.
 examples, the F1 on BD of the AST m 1 kernel is surprisingly about 3 percentage points higher than the one obtained by the polynomial kernel (Poly) (i. e., the state of the art).
When AST m 1 is combined with Poly the improvement reaches 5 absolute percentage points. This suggests that tree kernels should always be used when small training data sets are available.
 its combination with Poly produces results similar to Poly+AST the amount of training data increases. This, in agreement with the back-off property, indicates that the number of tree fragments is more relevant than their quality. tree kernels decreases. This is rather intuitive as (i) in general less accurate data machine learning models trained with enough data can reach the accuracy of the most accurate models, and (ii) if the hypothesis that tree kernels provide back-off models is true, a lot of training data makes them less critical, for example, the probability of finding the Path feature of a test instance in the training set becomes high.
 with a reduced impact of tree kernels on the Poly model. This is due to the reduced impact of AST m 1 on role classification. Such findings are in agreement with the results in Moschitti (2004), which show that for argument classification the SCF structure (a variant of the AST m n ) is more effective. Thus a comparison between learning curves of
Poly and SCF on RC may show a behavior similar to Poly and AST 6.4 Conflict Resolution Results
In these experiments, we are interested in (1) the evaluation of the accuracy of our tree kernel X  X ased conflict resolution strategy and (2) studying the most appropriate structured features for the task.

PropBank annotations. We compared the alternative conflict resolution strategies imple-mented by our architecture (see Section 4.3), namely the random (RND), the heuristic (HEU), and a tree kernel X  X ased disambiguator working with AST disambiguators were run on the output of BC, that is, without any information about the candidate arguments X  roles. BC was trained on Sections 2 to 7 with a high-recall linear kernel. We applied it to classify Sections 8 to 21 and obtained 2,988 NSTs containing at least one overlapping node. These structures generated 3,624 positive NSTs (i. e., correct structures) and 4,461 negative NSTs (incorrect structures) in which no overlap is present.
We used them to train the AST ord n classifier. The F1 measure on the boundary detection task was evaluated on the 385 overlapping annotations of Section 23, consisting of 642 argument and 15,408 non-argument nodes.
 (1) The RND disambiguator (slightly) outperforms the HEU. This suggests that the heuristics that we implemented were inappropriate for solving the problem. It also underlines how difficult it is to explicitly choose the aspects that are relevant for a complex, non-local task such as overlap resolution. (2) The AST the other strategies by about 20 percentage points, that is, 91.11 vs. 73.13 and 71.50.
This datum along with the previous one is a good demonstration of how tree kernels can be effectively exploited to describe phenomena whose relevant features are largely unknown or difficult to represent explicitly. It should be noted that a more accurate baseline can be provided by using the Viterbi-style search (see Section 4.4.1). However, the experiments in Section 6.5 show that the heuristics produce the same accuracy (at least when the complete task is carried out). 218 annotation conflicts; thus, we tried to also select the most representative structured
BC on Sections 2 X 8, whereas, to achieve a very accurate argument classifier, we trained a role multi-classifier (RM) on Sections 2 X 21. Then, we trained the AST
AST m n classifiers on the output of BC. To test BC, RM, and the tree kernel classifiers, we ran two evaluations on Section 23 and Section 21. 14 conflict resolution over the NSTs of Sections 21 and 23. Several points should be noted. trees, as shown in Table 4. This datum and the gap of about 6 percentage points between
Sections 21 and 23 confirm the impact of parsing accuracy on the subtasks of the SRL process. (AST m n ) provide tree kernels with more meaningful fragments because they improve the basic model by about 4 percentage points. useful clues for selecting correct predicate X  X rgument structures because the AST model improves AST ord n performance on both sections. 6.5 Proposition Re-Ranking Results
In these experiments, Section 23 was used for testing our proposition re-ranking. We employed a BC trained on Sections 2 to 8, whereas RM was trained on Sections 2 X 12. order to provide a probabilistic interpretation of the SVM output (see Section 4.4.1), we evaluated each classifier distribution parameter based on its output on Section 12. For computational complexity reasons, we decided to consider the five most likely labelings for each node and the five first alternatives output by the Viterbi algorithm (i. e., m = 5 and n = 5).

As our baseline, we consider the accuracy of a re-ranker that always chooses the first alternative output from the Viterbi algorithm, that is, the most likely according to the joint inference model. This accuracy has been measured as 75.91 F1 percentage points; this is practically identical to the 75.89 obtained by applying heuristics to remove overlaps generated by BC. selected the best alternative produced by the Viterbi algorithm according to the gold-standard score, and we obtained an F1 of 84.76 for n = 5. Thus, the critical aspect resides in the selection of the best annotations, which should be carried out by an automatic re-ranker.
 annotations output by the Viterbi algorithm for each of the employed sections. In row 3, the number of pair comparisons (i. e., the number of training/test examples for the classifier) is shown.

Table 7. First, we compared the accuracy of the AST cm n , PAS, and PAS on Section 24 (in row 3, columns 2, 3, and 4) and discovered that the latter structure produces a noticeable F1 improvement, namely, 78.15 vs. 76.47 and 76.77, whereas the accuracy gap between the PA Sand the A ST cm n classifiers is very small, namely, 76.77 vs. 76.47 percentage points. We selected the most interesting structured feature, that is, the PAS tl , and extended it with the local (to each argument node) standard features commonly employed for the boundary detection and argument classification tasks, as in Haghighi, Toutanova, and Manning (2005). This richer kernel (PAS was compared with the PAS tl one. The comparison was performed on two different training sets (rows 2 and 3): In both cases, the introduction of the standard features produced a performance decrement, most notably in the case of Section 12 (i. e., 82.07 vs. 75.06). Our best re-ranking kernel (i. e., the PAS tl experiment, using both Sections 12 and 24 for testing (row 4), achieving an F of 78.44.
 76.77 vs. 76.47). This datum suggests that the intra-argument syntactic information is not critical for the re-ranking task, as including it or not in the learning algorithm does not lead to noticeable differences.
 AST cm n and PAS, which are always outperformed. This may be due to the fact that 220 two AST cm n s (or PASs) always share a large number of substructures, because most alternative annotations tend to be very similar and the small differences among them only affect a small part of the encoding of syntactic information; on the other hand, the small amount of local parsing information encoded in the PAS generalization process.
 model caused a performance loss of about 0.5 percentage points on both Sections 12 and 24. This fact, which is in contrast with what has been shown in Haghighi, Toutanova, and Manning (2005), might be the consequence of the small training sets that we employed. Indeed, local standard features tend to be very sparse and their effectiveness should be evaluated against a larger data set. 7. Discussions and Conclusions
The design of automatic systems for the labeling of semantic roles requires the solution of complex problems. Among other issues, feature engineering is made difficult by the structured nature of the data, that is, features should represent information expressed by automatically generated parse trees. This raises two main problems: (1) the mod-eling of effective features, partially solved for some subtasks in previous works, and (2) the implementation of the software for the extraction of a large number of such features.
 as (1) kernel functions automatically generate features and (2) only a procedure for the extraction of subtrees is needed. Although some of the manually designed features seem to be superior to those derived with tree kernels, their combination still seems worth applying. Moreover, tree kernels provide a back-off model that greatly outperforms state-of-the-art SRL models when the amount of training data is small.
 tree kernels for semantic role labeling by designing several canonical mappings. These correspond to the application of innovative tree kernel engineering techniques tailored to different stages of an SRL process. The experiments with these methods and SVMs on the data set provided by the CoNLL 2005 shared task (Carreras and M ` arquez 2005) show that, first, tree kernels are a valid support to manually designed features for many stages of the SRL process. We have shown that our improved tree kernel (i.e., the one based on AST m 1 ) highly improves accuracy in both boundary detection and the SRL task when the amount of training data is small (e.g., 5 absolute percentage points over a state-of-the-art boundary classifier). In the case of argument classification the improvement is less evident but still consistent, at about 3%.
 many SRL subtasks. For example, in complex tasks such as conflict resolution or re-ranking, they provide an easy way to build new features that would be difficult to describe explicitly. More generally, tree kernels can be used to combine different sources of information for the design of complex learning models.
 provement over our baseline (i. e., about 2.5 percentage points). This could be increased considering that we have not been able to fully exploit the potential of our re-ranking model, whose theoretical upper bound is 6 percentage points away. Still, although we only used a small fraction of the available training data (i. e., only 2 sections out of 22 were used to train the re-ranker) our system X  X  accuracy is in line with state-of-the-art systems (Carreras and M ` arquez 2005) that do not employ tree kernels. issues should be considered in more depth in the future: bination with the proposed canonical mappings. For example, as the PT kernel seems more suitable for the processing of dependency information, it would be interesting to apply it in an architecture using these kinds of syntactic parse trees (e. g., Chen and Rambow 2003). In particular, the combination of different extraction functions on different syntactic views may lead to very good results. to use all the available CoNLL 2005 data. This would allow us to estimate the potential of our approach by comparing it with previous work on a fairer basis. sentations makes the learning and classification much faster, so that the overall running time is comparable with polynomial kernels. However, when used with SVMs their running time on very large data sets (e. g., millions of instances) becomes prohibitive.
Exploiting tree kernel X  X erived features in a more efficient way (e. g., by selecting the most relevant fragments and using them in an explicit space) is thus an interesting line of future research. Note that such fragments would be the product of a reverse engineering process useful to derive linguistic insights on semantic role theory. provide the most important boost to the accuracy of SRL systems, we would like to extend our model to work with multiple syntactic views of each input sentence. Acknowledgments References 222
