 Stanford University Google Inc.
 Yahoo! Research
This work investigates the use of linguistically motivated features to improve search, in par-ticular for ranking answers to non-factoid questions. We show that it is possible to exploit existinglargecollectionsofquestion X  X nswerpairs(fromonlinesocialQuestionAnsweringsites) toextractsuchfeaturesandtrainrankingmodelswhichcombinethemeffectively.Weinvestigate a wide range of feature types, some exploiting natural language processing such as coarse word sense disambiguation, named-entity identification, syntactic parsing, and semantic role label-ing. Our experiments demonstrate that linguistic features, in combination, yield considerable improvementsinaccuracy.Dependingonthesystemsettingswemeasurerelativeimprovements of14%to21%inMeanReciprocalRankandPrecision@1,providingoneofthemostcompelling evidencetodatethatcomplexlinguisticfeaturessuchaswordsensesandsemanticrolescanhave a significant impact on large-scale information retrieval tasks. 1. Introduction
The problem of Question Answering (QA) has received considerable attention in the past few years. Nevertheless, most of the work has focused on the task of factoid
QA, where questions match short answers, usually in the form of named or numerical entities. Thanks to international evaluations organized by conferences such as the Text
REtrieval Conference (TREC) and the Cross Language Evaluation Forum (CLEF) Work-shop, annotated corpora of questions and answers have become available for several languages, which has facilitated the development of robust machine learning models for the task. 1 paratively little research has focused on QA models for non-factoid questions such as causation, manner, or reason questions. Because virtually no training data is avail-able for this problem, most automated systems train either on small hand-annotated corpora built in-house (Higashinaka and Isozaki 2008) or on question X  X nswer pairs harvested from Frequently Asked Questions (FAQ) lists or similar resources (Soricut and Brill 2006; Riezler et al. 2007; Agichtein et al. 2008). None of these situations is ideal: The cost of building the training corpus in the former setup is high; in the latter scenario the data tend to be domain-specific, hence unsuitable for the learning of open-domain models, and for drawing general conclusions about the underlying scientific problems.
 (or social media). Of particular interest in our context are community-driven question-answering sites, such as Yahoo! Answers, where users answer questions posed by other users and best answers are selected manually either by the asker or by all the partici-pants in the thread. 2 The data generated by these sites have significant advantages over other Web resources: (a) they have a high growth rate and they are already abundant; (b) they cover a large number of topics, hence they offer a better approximation of open-domain content; and (c) they are available for many languages. Community QA sites, similar to FAQs, provide a large number of question X  X nswer pairs. Nevertheless, these data have a significant drawback: they have high variance of quality (i.e., questions and answers range from very informative to completely irrelevant or even abusive). Table 1 shows some examples of both high and low quality content from the Yahoo! Answers site.
 1. Is it possible to learn an answer-ranking model for non-factoid questions, in a 352 2. Which features and models are more useful in this context, that is, ample but
Social QA sites are the ideal vehicle to investigate such questions. Questions posted on these sites typically have a correct answer that is selected manually by users. As-suming that all the other candidate answers are incorrect (we discuss this assumption in Section 5), it is trivial to automatically organize these data into a format ready for discriminative learning, namely, the pair question X  X orrect answer generates one posi-tive example and all other answers for the same question are used to generate negative examples. This allows one to use the collection in a completely automated manner to learn answer ranking models.
 1. We introduce and evaluate many linguistic features for answer re-ranking. 2. We propose a simple yet powerful representation for complex linguistic 3. We are the first to evaluate the impact of such linguistic features in a features explored for answer modeling, in Section 2. We introduce the corpus used in our empirical analysis in Section 3. We detail our experiments and analyze the results in Section 4. Section 5 discusses current shortcomings of our system and proposes solutions. We overview related work in Section 6 and conclude the article in Section 7. 2. Approach
Figure 1 illustrates our QA architecture. The processing flow is the following. First, the answer retrieval component extracts a set of candidate answers A for a question Q from a large collection of answers, C , provided by a community-generated question-answering site. The retrieval component uses a state-of-the-art information retrieval (IR) model to extract A given Q . The second component, answer ranking , assigns to each answer A i  X  A a score that represents the likelihood that A for Q , and ranks all answers in descending order of these scores. In our experiments, the collection C contains all answers previously selected by users of a social QA site as best answers for non-factoid questions of a certain type (e.g.,  X  X ow to X  questions).
The entire collection of questions, Q , is split into a training set and two held-out sets: a development one used for parameter tuning, and a testing one used for the formal evaluation.
 (see, e.g., Voorhees 2001). For efficiency reasons, most participating systems split the answer extraction phase into a retrieval phase that selected likely answer snippets using shallow techniques, followed by a (usually expensive) answer ranking phase that processes only the candidates proposed by the retrieval component. Due to this separation, such architectures can scale to collections of any size. We discuss in Section 6 how related work has improved this architecture further X  X or example, by adding query expansion terms from the translation models back to answer retrieval (Riezler et al. 2007).
 answer ranking component. We call this model FMIX X  X rom f eature mix  X  X ecause the proposed scoring function is a linear combination of four different classes of features 354 (detailed in Section 2.2). To accommodate and combine all these feature classes, our
QA approach combines three types of machine learning methodologies (as highlighted in Figure 1): the answer retrieval component uses unsupervised IR models, the an-swer ranking is implemented using discriminative learning, and finally, some of the ranking features are produced by question-to-answer translation models, which use class-conditional generative learning. To our knowledge, this combined approach is novel in the context of QA. In the remainder of the article, we will use the FMIX function to answer the research objectives outlined in the Introduction. To answer the first research objective we will compare the quality of the rankings provided by this component against the rankings generated by the IR model used for answer retrieval. To answer the second research objective we will analyze the contribution of the proposed feature set to this function.
 manner questions, and in particular only  X  X ow to X  questions. This makes the corpus more homogeneous and more focused on truly informational questions (as opposed to social questions such as  X  X hy don X  X  girls like me? X , or opinion questions such as  X  X ho will win the next election? X , both of which are very frequent in Yahoo! Answers).
Second, we concentrate on the task of answer-re-ranking, and ignore all other modules needed in a complete on-line social QA system. For example, we ignore the problem of matching questions to questions, very useful when retrieving answers in a FAQ or a QA collection (Jeon, Croft, and Lee 2005), and we ignore all  X  X ocial X  features such as the authority of users (Jeon et al. 2006; Agichtein et al. 2008). Instead, we concentrate on matching answers and on the different textual features. Hence, the document collection used in our experiments contains only answers, without the corresponding questions answered. Furthermore, we concentrate on the re-ranking phase and we do not explore techniques to improve the recall of the initial retrieval phase (by methods of query expansion, for example). Such aspects are complementary to our work, and can be investigated separately. 2.1 Representations of Content
One of our main interests in using very large data sets was to show that complex lin-guistic features can improve ranking models if they are correctly combined with simpler features, in particular using discriminative learning methods on a particular task. For this reason we explore several forms of textual representation going beyond the bag of words. In particular, we generate our features over four different representations of text:
Words (W): This is the traditional IR view where the text is seen as a bag of words. n -grams (N): The text is represented as a bag of word n -grams, where n ranges from two up to a given length (we discuss structure parameters in the following).

Dependencies (D): The text is converted to a bag of syntactic dependency chains. We extract syntactic dependencies in the style of the CoNLL-2007 shared task using the syntactic processor described in Section 3. 3 From the tree of syntactic dependencies we extract all the paths up to a given length following modifier-to-head links. The top part of Figure 2 shows a sample corpus sentence with the actual syntactic dependencies ex-tracted by our syntactic processor. The figure indicates that this representation captures important syntactic relations, such as subject X  X erb (e.g., helicopter verb (e.g., power OBJ  X   X   X  gets ).

Semantic Roles (R): The text is represented as a bag of predicate X  X rgument rela-tions extracted using the semantic parser described in Section 3. The parser follows the
PropBank notations (Palmer, Gildea, and Kingsbury 2005), that is, it assigns semantic argument labels to nodes in a constituent-based syntactic tree. Figure 3 shows an exam-ple. The figure shows that the semantic proposition corresponding to the predicate gets includes A helicopter as the Arg0 argument ( Arg0 stands for agent), its power as the Arg1 argument (or patient), and from rotors or blades as Arg2 (or instrument). Semantic roles have the advantage that they extract meaning beyond syntactic representations (e.g., a syntactic subject may be either an agent or a patient in the actual proposition). We con-vert the semantic propositions detected by our parser into semantic dependencies using the same approach as Surdeanu et al. (2008), that is, we create a semantic dependency between each predicate and the syntactic head of every one of its arguments. These dependencies are labeled with the label of the corresponding argument. For example, the semantic dependency that includes the Arg0 argument in Figure 3 is represented as 356 a prepositional phrase ( PP ), we convert it to a bigram that includes the preposition and the head word of the attached phrase. For example, the tuple for Arg2 in the example is represented as gets Arg2  X   X   X  from-rotors .
 stop word and convert the remaining words to their WordNet lemmas. this issue along three dimensions:
Degree of lexicalization: We reduce the sparsity of the proposed structures by replacing the lexical elements with semantic tags which might provide better generalization. In this article we use two sets of tags, the first consisting of coarse WordNet senses, or supersenses (WNSS) (Ciaramita and Johnson 2003), and the second of named-entity labels extracted from the Wall Street Journal corpus. We present in detail the tag sets and the processors used to extract them in Section 3. For an overview, we show a sample annotated sentence in the bottom part of Figure 2.

Labels of relations: Both dependency and predicate X  X rgument relations can be labeled or unlabeled (e.g., gets Arg0  X   X   X  helicopter versus gets in our experiments for two reasons: (a) removing relation labels reduces the model sparsity because fewer elements are created, and (b) performing relation recognition without classification is simpler than performing the two tasks, so the corresponding NL processors might be more robust in the unlabeled-relation setup.

Structure size: This parameter controls the size of the generated structures, namely, number of words in n -grams or dependency chains, or number of elements in the predicate X  X rgument tuples. Nevertheless, in our experiments we did not see any im-provements from structure sizes larger than two. In the experiments reported in this article, all the structures considered are of size two, that is, we use bigrams, dependency chains of two elements, and tuples of one predicate and one semantic argument. 2.2 Features
We explore a rich set of features inspired by several state-of-the-art QA systems (Harabagiu et al. 2000; Magnini et al. 2002; Cui et al. 2005; Soricut and Brill 2006; Bilotti et al. 2007; Ko, Mitamura, and Nyberg 2007). To the best of our knowledge this is the first work that: (a) adapts all these features for non-factoid answer ranking, (b) combines them in a single scoring model, and (c) performs an empirical evaluation of the different feature families and their combinations.
 between questions and answers (FG1), features that encode question-to-answer trans-formations using a translation model (FG2), features that measure keyword density and frequency (FG3), and features that measure the correlation between question X  X nswer pairs and other collections (FG4). Wherever applicable, we explore different syntactic and semantic representations of the textual content, as introduced previously. We next explain in detail each of these feature groups.
FG1: Similarity Features . We measure the similarity between a question Q and an answer A using the length-normalized BM25 formula (Robertson and Walker 1997), which computes the score of the answer A as follows: where tf A i and tf Q i are the frequencies of the question term i in A and Q ,and idf the inverse document frequency of term i in the answer collection. K is the length-normalization factor: where avg len is the average answer length in the collection. For all the constants in the k = 1 . 2, and k 3 = 1,000).
 the best ranking at the output of the answer retrieval component. For completeness we also include in the feature set the value of the tf  X  idf similarity measure. For both formulas we use the implementations available in the Terrier IR platform with the default parameters. 5 pute the similarity features for different representations of the question and answer content, ranging from bag of words to semantic roles. We detail these representations in Section 2.1.

FG2: Translation Features . Berger et al. (2000) showed that similarity-based models are doomed to perform poorly for QA because they fail to  X  X ridge the lexical chasm X  between questions and answers. One way to address this problem is to learn question-to-answer transformations using a translation model (Berger et al. 2000; Echihabi and
Marcu 2003; Soricut and Brill 2006; Riezler et al. 2007). In our model, we incorporate this approach by adding the probability that the question Q is a translation of the answer
A , P ( Q | A ), as a feature. This probability is computed using IBM X  X  Model 1 (Brown et al. 1993): where the probability that the question term q is generated from answer A , P ( q is smoothed using the prior probability that the term q is generated from the entire collection of answers C , P ml ( q | C ).  X  is the smoothing parameter. P 358 using the maximum likelihood estimator. To mitigate sparsity, we set P that the question term q is a translation of an answer term a , T ( q probability that a is generated from A . The translation table for T ( q the EM algorithm implemented in the GIZA++ toolkit. 7
They do not guarantee that the probability of translating a word to itself, that is, T ( w is high (Murdock and Croft 2005). This is a problem for QA, where word overlap between question and answer is a good indicator of relevance (Moldovan et al. 1999).
We address this limitation with a simple algorithm: we set T ( w guarantee that w T ( w | w ) = 1. This has the desired effect that T ( w than any other T ( w | w ). Our initial experiments proved empirically that this is essential for good performance.
 performance of translation models, especially in the context of QA (Xue, Jeon, and
Croft 2008). We tuned the  X  parameter independently for each of the translation models introduced as follows: (a) for a smaller subset of the development corpus introduced in Section 3 (1,500 questions) we retrieved candidate answers using our best retrieval model (BM25); (b) we implemented a simple re-ranking model using as the only feature the translation model probability; and (c) we explored a large range of values for  X  and selected the one that maximizes the mean reciprocal rank (MRR) of the re-ranking model. This process selected a wide range of values for the  X  parameter for the different translation models (e.g., 0.09 for the translation model over labeled syntactic depen-dencies, and 0.43 for the translation model over labeled semantic role dependencies). different text representations detailed in Section 2.1. By moving beyond the bag-of-words representation we hope to learn relevant transformations of structures, for ex-ample, from the squeaky  X  door dependency to spray  X  WD-40 in the Table 1 example.
FG3: Density and Frequency Features . These features measure the density and fre-quency of question terms in the answer text. Variants of these features were used previously for either answer or passage ranking in factoid QA (Moldovan et al. 1999;
Harabagiu et al. 2000). Tao and Zhai (2007) evaluate a series of proximity-based mea-sures in the context of information retrieval.

Same word sequence: Computes the number of non-stop question words that are recognized in the same order in the answer.

Answer span: The largest distance (in words) between two non-stop question words in the answer. We compute multiple variants of this feature, where we count: (a) the total number of non-stop words in the span, or (b) the number of non-stop nouns.
Informativeness: Number of non-stop nouns, verbs, and adjectives in the answer text that do not appear in the question.
Same sentence match: Number of non-stop question terms matched in a single sentence in the answer. This feature is added both unnormalized and normalized by the question length.
 Overall match: Number of non-stop question terms matched in the complete answer. the count by the question length, or by the answer length in the case of Answer span ).
The last two features ( Same sentence match and Overall match ) are computed for all text representations introduced, including syntactic and semantic dependencies (see Section 2.1).
 a simplified tree kernel for QA (e.g., see Moschitti et al. 2007) matching only trees of depth 2. We also include in this feature group the following tree-kernel features.
Tree kernels: To model larger syntactic structures that are shared between questions and answers we compute the tree kernel values between all question and answer sentences.
We implemented a dependency-tree kernel based on the convolution kernels proposed by Collins and Duffy (2001). We add as features the largest value measured between any two individual sentences, as well as the average of all computed kernel values for a given question and answer. We compute tree kernels for both labeled and unlabeled dependencies, and for both lexicalized trees and for trees where words are generalized to their predicted WNSS or named-entity tags (when available).

FG4: Web Correlation Features . Previous work has shown that the redundancy of a large collection (e.g., the Web) can be used for answer validation (Brill et al. 2001;
Magnini et al. 2002). In the same spirit, we add features that measure the correlation between question X  X nswer pairs and large external collections: Web correlation: We measure the correlation between the question X  X nswer pair and the Web using the Corrected Conditional Probability (CCP) formula of Magnini et al. (2002): where hits returns the number of page hits from a search engine. The hits procedure constructs a Boolean query from the given set of terms, represented as a conjunction of all the corresponding keywords. For example, for the second question in Table 1, hits ( Q ) uses the Boolean query: helicopter AND fly .
 probability is adjusted with 1 / hits ( A ) 2 / 3 to reduce the number of cases when snippets containing high-frequency words are marked as relevant answers. This formula was shown to perform best for the task of QA (Magnini et al. 2002). Nevertheless, this formula was designed for factoid QA, where both the question and the exact answer have a small number of terms. This is no longer true for non-factoid QA. In this context it is likely that the number of hits returned for Q , A ,or Q + A is zero given the large size of the typical question and answer. To address this issue, we modified the hits procedure to include a simple iterative query relaxation algorithm: 1. Assign keyword priorities using a set of heuristics inspired by 360 2. Fetch the number of page hits using the current query. 3. If the number of hits is larger than zero, stop; otherwise discard the set of
Query-log correlation: As in Ciaramita, Murdock, and Plachouras (2008), we also com-pute the correlation between question X  X nswer pairs from a search-engine query-log corpus of more than 7.5 million queries, which shares roughly the same time stamp with the community-generated question X  X nswer corpus. Using the query-log correla-tion between two snippets of text was shown to improve performance for contextual advertising, that is, linking a user X  X  query to the description of an ad (Ciaramita, Murdock, and Plachouras 2008). In this work, we adapt this idea to the task of QA.
However, because it is not clear which correlation metric performs best in this context, we compute both the Pointwise Mutual Information (PMI) and chi square (  X  ation measures between each question X  X nswer word pair in the query-log corpus. The largest and the average values are included as features, as well as the number of QA word pairs which appear in the top 10, 5, and 1 percentile of the PMI and  X  rankings.

We replicate all features that can be computed for different content representations using every independent representation and parameter combination introduced in
Section 2.1. For example, we compute similarity scores (FG1) for 16 different repre-sentations of question/answer content, produced by different parametrizations of the four different generic representations (W, N, D, R). One important exception to this strategy are the translation-model features (FG2). Because our translation models aim to learn both lexical and structural transformations between questions and answers, it is important to allow structural variations in the question/answer representations.
In this article, we implement a simple and robust approximation for this purpose: For translation models we concatenate all instances of structured representations (N, D, R) with the corresponding bag-of-words representation (W). This allows the translation models to learn some combined lexical and structural transformation (e.g., from the dependency squeaky  X  door dependency to the token WD-40 ). All in all, replicating our features for all the different content representations yields 137 actual features to be used for learning. 2.3 Ranking Models
Our approach is agnostic with respect to the actual learning model. To emphasize this, we experimented with two learning algorithms. First, we implemented a variant of the ranking Perceptron proposed by Shen and Joshi (2005). In this framework the ranking problem is reduced to a binary classification problem. The general idea is to exploit the pairwise preferences induced from the data by training on pairs of patterns, rather than independently on each pattern. Given a weight vector  X  , the score for a pattern x (a candidate answer) is given by the inner product between the pattern and the weight vector:
However, the error function depends on pairwise scores. In training, for each pair ( x , x j )  X  A , the score f  X  ( x i  X  x j ) is computed; note that if f is an inner product f x ) = f  X  ( x i )  X  f  X  ( x j ). In this framework one can define suitable margin functions that take into account different levels of relevance; for example, Shen and Joshi (2005) propose g ( i , j ) = ( 1 i  X  1 j ), where i and j are the rank positions of x our case there are only two relevance levels we use a simpler sign function y empirically on the development data. In the presence of numbers of possible rank levels appropriate margin functions can be defined. During training, if f update is performed as follows:
We notice, in passing, that variants of the perceptron including margins have been investigated before; for example, in the context of uneven class distributions (see Li et al. 2002). It is interesting to notice that such variants have been found to be competitive with SVMs in terms of performance, while being more efficient (Li et al. 2002; Surdeanu and Ciaramita 2007). The comparative evaluation from our experiments are consistent with these findings. For regularization purposes, we use as a final model the average of all Perceptron models posited during training (Freund and Schapire 1999).
 structural SVM X  X  family of Support Vector Machine algorithms that model structured outputs (Tsochantaridis et al. 2004) X  X pecifically tailored for ranking problems. rank optimizes the area under a ROC curve. The ROC curve is determined by the true positive rate vs. the false positive rate for varying values of the prediction threshold, thus providing a metric closely related to Mean Average Precision (MAP). 3. The Corpus
The corpus is extracted from a sample of the U.S. Yahoo! Answers questions and answers. We focus on the subset of advice or  X  X ow to X  questions due to their fre-quency, quality, and importance in social communities. Nevertheless, our approach 362 is independent of the question type. To construct our corpus, we implemented the following successive filtering steps:
Step 1: From the full corpus we keep only questions that match the regular
Step 2: From this corpus we remove the questions and answers of dubious
Arguably, all these filters could be improved. For example, the first step can be replaced by a question classifier (Li and Roth 2006). Similarly, the second step can be implemented with a statistical classifier that ranks the quality of the content using both the textual and non-textual information available in the database (Jeon et al. 2006;
Agichtein et al. 2008). We plan to further investigate these issues, which are not the main object of this work.
 ized and POS tagged, in the style of the Wall Street Journal Penn TreeBank (Marcus,
Santorini, and Marcinkiewicz 1993). Each word was morphologically simplified using the morphological functions of the WordNet library. Sentences were annotated with
WNSS categories, using the tagger of Ciaramita and Altun (2006), which annotates text with a 46-label tagset. 10 These tags, defined by WordNet lexicographers, provide a broad semantic categorization for nouns and verbs and include labels for nouns such as food, animal, body, and feeling, and for verbs labels such as communication, contact, and possession. We chose to annotate the data with this tagset because it is less biased towards a specific domain or set of semantic categories than, for example, a named-entity tagger. Using the same tagger as before we also annotated the text with a named-entity tagger trained on the BBN Wall Street Journal (WSJ) Entity Corpus which defines 105 categories for entities, nominal concepts, and numerical types. sample sentence annotated with these tags.

We chose this parser because it is fast and it performed very well in the domain adap-tation shared task of CoNLL 2007. Finally, we extracted semantic propositions using the SwiRL semantic parser of Surdeanu et al. (2007). 13 SwiRL starts by syntactically analyzing the text using a constituent-based full parser (Charniak 2000) followed by a semantic layer, which extracts PropBank-style semantic roles for all verbal predicates in each sentence.
 and contains plenty of mistakes, because the data have huge variability in terms of quality, style, genres, domains, and so forth. In terms of processing speed, both the semantic tagger of Ciaramita and Altun and the Attardi et al. parser process 100+ sentences/second. The SwiRL system is significantly slower: On average, it parses less than two sentences per second. However, recent research showed that this latter task can be significantly sped up without loss of accuracy (Ciaramita et al. 2008). ing. Our ranking model was tuned strictly on the development set for feature selection (described later) and the  X  parameter of the translation models. The candidate answer set for a given question is composed of one positive example, that is, its corresponding best answer, and as negative examples all the other answers retrieved in the top N by the retrieval component. 4. Experiments
We used several measures to evaluate our models. Recall that we are using an initial retrieval engine to select a pool of N answer candidates (Figure 1), which are then re-ranked. This couples the performance of the initial retrieval engine and the re-rankers.
We tried to de-couple them in our performance measures, as follows. We note that if the initial retrieval engine does not rank the correct answer in the pool of top N results, it is impossible for any re-ranker to do well. We therefore follow the approach of Ko et al. (2007) and define performance measures only with respect to the subset of pools which contain the correct answer for a given N .
 set of all queries in the collection and Q N the subset of queries for which the retrieved answer pool of size N contains the correct answer. We will then use the following performance measure definitions:
Retrieval Recall@N: The usual recall definition:
Re-ranking Precision@1: Average Precision@1 over the Q N set, where the Precision@1
Re-ranking MRR: MRR over the Q N set, where the reciprocal rank is the inverse of the
Note that as N gets larger, Q N grows in size, increasing the Retrieval Recall@N but also increasing the difficulty of the task for the re-ranker, and therefore decreasing Re-ranking Precision@1 and Re-ranking MRR.
 randomized, which defines a randomized training protocol producing different models with each permutation of the data. We exploit this property to estimate the variance on the experimental results by reporting the average performance of 10 different models, together with an estimate of the standard deviation. 364 score as described earlier. This is also our baseline re-ranker. We will compare this to the
FMIX re-ranker using all features or using subsets of features. 4.1 Overall Results
Table 3 and Figure 4 show the results obtained using FMIX and the baseline for in-creasing values of N . We report results for Perceptron and SVM-rank using the optimal feature set for each (we discuss feature selection in the next sub-section). tion alone (BM25 in this case) can achieve 41.5% Precision@1 (for the 29.0% of queries for which the retrieval engine can find an answer in the top N = 15 results). These baseline results are interesting because they indicate that the problem is not hopelessly hard, but it is far from trivial. In principle, we see much room for improvement over bag-of-words methods. Indeed, the FMIX re-ranker greatly improves over the baseline. For example, the FMIX approach using Perceptron yields a Precision@1 of 49.9%, a 20.2% relative increase.
 recall depends only on the retrieval engine and not on the re-ranker, what we are interested in is the relative performance of our re-rankers for increasing numbers of
N . For example, setting N = 100 we observe that the BM25 re-ranker baseline obtains 27.7% Precision@1 (for the 43.4% of queries for which the best answer is found in the top N = 100). For this same subset, the FMIX re-ranker using Perceptron obtains 33.7% Precision@1, a 21.5% relative improvement over the baseline model.
 of N , regardless of the type of learning algorithm used. As expected, as N grows the precision of both re-rankers decreases, but the relative improvement holds or increases.
This can be seen most clearly in Figure 4 where re-ranking Precision and MRR are plotted against retrieval Recall. Recalling that the FMIX model was trained only once, using pools of N = 15, we can note that the training framework is stable at increasing sizes of N .
 yield scores that are close (e.g., Precision@1 scores are within 0.5% of each other). We hypothesize that the small difference between the two different learning models is caused by our greedy tuning procedures (described in the next section), which converge to slightly different solutions due to the different learning algorithms. Most importantly, the fact that we obtain analogous results with two different learning models underscores the robustness of our approach and of our feature set.

NLP technology can be used to improve lexical matching and translation models for retrieval and QA tasks, (b) we can use publicly available online QA collections to investigate features for answer ranking without the need for costly human evaluation, and (c) we can exploit large and noisy on-line QA collections to improve the accuracy of answer ranking systems. In the remainder of this section we analyze the performance of the different features. 4. 2Contribution of Feature Groups
In order to gain some insights about the effectiveness of the different features groups, we carried out a greedy feature selection procedure. We implemented similar processes for Perceptron and SVM-rank, to guarantee that our conclusions are not biased by a particular learning model. 4.2.1 Perceptron. We initialized the feature selection process with a single feature that replicates the baseline model (BM25 applied to the bag-of-words [W] representation).
Then the algorithm incrementally adds to the feature set the single feature that provides the highest MRR improvement in the development partition. The process stops when no features yield any improvement. Note that this is only a heuristic process, and needs to be interpreted with care. For example, if two features were extremely correlated, the algorithm would choose one at random and discard the other. Therefore, if a feature is 366 missing from the selection process it means that it is either useless, or strongly correlated with other features in the list.
 we show within parentheses the text representation for the corresponding feature: W for words, N for n -grams, D for syntactic dependencies, and R for semantic roles. We use subscripts to indicate if the corresponding representation is fully lexicalized (no subscript), or its elements are replaced by WordNet supersenses (WNSS) or named-entity tags (WSJ). Where applicable, we use the l superscript to indicate if the cor-responding structures are labeled. No superscript indicates unlabeled structures. For example, D WNSS stands for unlabeled syntactic dependencies where the participating tokens are replaced by their WordNet supersense; R l WSJ stands for semantic tuples of predicates and labeled arguments with the words replaced with the corresponding WSJ named-entity tags.
 introduced, the lion X  X  share is taken by the translation features (FG2): 75% of the MRR improvement is achieved by these features. The frequency/density features (FG3) are responsible for approximately 16% of the improvement. The rest is due to the query-log correlation features (FG4). This indicates that, even though translation models are the most useful, it is worth exploring approaches that combine several strategies for answer ranking.
 they are strongly correlated with others. For example most similarity features (FG1) are correlated with BM25(W); for this reason the selection process does not choose a FG1 feature until iteration 9. On the other hand, some features do not provide a useful signal at all. A notable example in this class is the Web-based CCP feature, which was designed originally for factoid answer validation and does not adapt well to our problem. To test this, we learned a model with BM25 and the Web-based CCP feature only, and this model did not improve over the baseline model at all. We hypothesize that because the length of non-factoid answers is typically significantly larger than in the factoid QA task, we have to discard a large part of the query when computing hits ( Q + A ) to reach non-zero counts. This means that the final hit counts, hence the CCP value, are generally uncorrelated with the original (Q,A) tuple.
 our model selection process use information from the NLP processors. The first feature selected is the translation probability computed between the R representation (unla-beled semantic roles) of the question and the answer. This feature alone accounts for 57% of the measured MRR improvement. This is noteworthy: Semantic roles have been shown to improve factoid QA, but to the best of our knowledge this is the first result demonstrating that semantic roles can improve ad hoc retrieval (on a large set of non-factoid open-domain questions). We also find noteworthy that the third feature chosen measures the number of unlabeled syntactic dependencies with words replaced by their WNSS labels that are matched in the answer. Overall, the features that use the output of
NL processors account for 68% of the improvement produced by our model over the IR baseline. These results provide empirical evidence that natural language analysis (e.g., coarse word sense disambiguation, syntactic parsing, and semantic role labeling) has a positive contribution to non-factoid QA, even in broad-coverage noisy settings based on Web data. To our knowledge, this had not been shown before.
 feature is selected only in iteration 20 and the MRR improvement is only 0.04 points.
One conjecture is that, due to the sparsity and the noise of the data, matching trees of depth higher than 2 is highly uncommon. Hence matching immediate dependencies is a valid approximation of kernels in this setup. Another possible explanation is that because the syntactic trees produced by the parser contain several mistakes, the tree kernel, which considers matches between an exponential number of candidate sub-trees, might be particularly unreliable on noisy data. 4.2.2SVM-rank. For SVM-rank we employed a tuning procedure similar to the one used for the Perceptron that implements both feature selection and tuning of the regularizer parameter C . We started with the baseline feature alone and greedily added one feature at a time. In each iteration we added the feature that provided the best improvement.
The procedure continues to evaluate all available features, until no improvement is observed. For this step we set the regularizer parameter to 1.0, a value which provided a good tradeoff between accuracy and speed as evaluated in an initial experiment.
The selection procedure generated 12 additional features. At this point, using only the selected features, we fine-tuned the regularization parameter C across a wide spectrum of possible values. This can be useful because in SVM-rank the interpretation of C is slightly different than in standard SVM, specifically C svm number of queries, or questions in our case. Therefore, an optimal value can depend crucially on the target data. The final value selected by this search procedure was equal to 290, although performance is relatively stable with values between 1 and 100,000. As a final optimization step, we continued the feature selection routine, starting from the 13 features already chosen and C = 290. This last step selected six additional features.
A further attempt at fine-tuning the C parameter did not provide any improvements. 368 though the features selected by SVM-rank are slightly different than the ones chosen by the Perceptron, the conclusions drawn are the same as before: Features generated by NL processors provide a significant boost on top of the IR model. Similarly to the
Perceptron, the first feature chosen by the selection procedure is a translation probabil-ity computed over semantic role dependencies (labeled, unlike the Perceptron, which prefers unlabeled dependencies). This feature alone accounts for 33.3% of the measured
MRR improvement. This further enforces our observation that semantic roles improve retrieval performance for complex tasks such as our non-factoid QA exercise. All in all, 13 out of the 18 selected features, responsible for 70% of the total MRR improvement, use information from the NL processors. 4.3 Contribution of Natural Language Structures
One of the conclusions of the previous analysis is that features based on natural lan-guage processing are important for the problem of QA. This observation deserves a more detailed analysis. Table 6 shows the performance of our first three feature groups when they are applied to each of the content representations and incremental combina-tions of representations. In this table, for simplicity we merge features from labeled and unlabeled representations. For example, R indicates that features are extracted from both labeled (R l ) and unlabeled (R) semantic role representations. The g subscript indicates that the lexical terms in the corresponding representation are separately gener-alized to WNSS and WSJ labels. For example, D g merges features generated from D D
WSJ ,D l WNSS ,andD l WSJ . For each cell in the table, we use only the features from the corresponding feature group and representation to avoid the correlation with features from other groups. We generate each best model using the same feature selection process described above.
 than the bag-of-words representation (W) in every feature group. The differences range from less than one MRR point (e.g., FG2[ R g ] versus FG2[ W ]), to over 28 MRR points (e.g., FG1[ R g ] versus FG1[ W ]). Such a large difference is justified by the fact that for feature groups FG1 and FG3 we compute feature values using only the corresponding structures (e.g., only semantic roles), which could be very sparse. For example, there are questions in our corpus where our SRL system does not detect any semantic propo-sition. Because translation models merge all structured representations with the bag-of-word representation, they do not suffer from this sparsity problem. Furthermore, on their own, FG3 features are significantly less powerful than FG1 or FG2 features. This explains why models using FG3 features fail to improve over the baseline. Regardless of these differences, the analysis indicates that in our noisy setting the bag-of-words representation outperforms any individual structured representation .
 part of our analysis indicates that structured representations provide complementary information to the bag-of-words representation. Even the combination of bag of words with the simplest n -gram structures ( W + N ) always outperforms the bag-of-words representation alone. But the best results are always obtained when the combination includes more natural language structures. The improvements are relatively small, but remarkable (e.g., see FG2) if we take into account the significant scale and settings of the evaluation. The improvements yielded by natural language structures are statistically significant for all feature groups. This observation correlates well with the analysis shown in Tables 4 and 5, which shows that features using semantic (R) and syntactic (D) representations contribute the most on top of the IR model (BM25(W)). 370 5. Error Analysis and Discussion
Similar to most re-ranking systems, our system improves the answer quality for some questions while decreasing it for others. Table 7 lists the percentage of questions from our test set that are improved (i.e., the correct answer is ranked higher after re-ranking), worsened (i.e., the correct answer is ranked lower), and unchanged (i.e., the position of the correct answer does not change after re-ranking). The table indicates that, regard-less of the number of candidate answers for re-ranking ( N ), the number of improved questions is approximately twice the number of worsened questions. This explains the consistent improvements in P@1 and MRR measured for various values of N .As N increases, the number of questions that are improved also grows, which is an expected consequence of having more candidate answers to re-rank. However, the percentage of improved questions grows at a slightly lower rate than the percentage of worsened questions. This indicates that choosing the ideal number of candidate answers to re-rank requires a trade-off: On the one hand, having more candidate answers increases the probability of capturing the correct answer in the set; on the other hand, it also increases the probability of choosing an incorrect answer due to the larger number of additional candidates. For our problem, it seems that re-ranking using values of N much larger than 100 would not yield significant benefits over smaller values of N .
This analysis is consistent with the experiments reported in Table 3 where we did not measure significant growth in P@1 or MRR for N larger than 50.
 to look at actual questions that are improved or worsened by the re-ranking model in order to understand the strengths and weaknesses of our system. Table 8 lists some representative questions where the re-ranking model brings the correct answer to the top position. For every question we list: (a) the correct answer and its position as given by the baseline IR Model ( X  X aseline X ) and the re-ranking model ( X  X e-ranking X ); and (b) the answer that was ranked by the baseline model in the first position and its position after re-ranking.
 bag-of-words IR model. For example, we boost the rank of answers that share structures with the question: for example, the cook  X  grouse syntactico-semantic dependency for the second sample question or make  X  call and see  X  number for the third example.
Modeling structures is important especially for questions with minimal context, that is, short length and common terms, like the third sample question. Due to the structure-based translation models and/or the generalizations to supersenses or named-entity labels, our model can match structures even when they are not identical. For example, 372 for the fourth question, find  X  college can be matched to look generalized to WordNet supersenses. Translation models are crucial to fetching answers rich in terms related to question concepts. For example, for the first question, our model boosts the position of the correct answer due to the large numbers of concepts that example, our model ranks on the first position the answer containing many concepts our model is capable of associating the bigram real estate to agent and broker .Without these associations many answers are lost to false positives provided by the bag-of-words similarity models. For example, in the first and last examples in the table, the answers selected by the baseline model contain more matches of the questions terms than the correct answers extracted by our model.
 many phenomena must be addressed. The key for success does not seem to be a unique model, but rather a combination of approaches each capable of addressing different facets of the problem. Our model makes a step forward towards this goal, mainly through concept expansion and the exploration of syntactico-semantic structures. Nev-ertheless, our model is not perfect. To understand where FMIX fails we performed a manual error analysis on 50 questions where FMIX performs worse than the IR baseline and we identified seven error classes. Table 9 lists the distribution of these error classes and Table 10 lists sample questions and answers from each class. Note that the percentage values listed in Table 9 sum up to more than 100% because the error classes are not exclusive. We now detail each of these error classes.
COMPLEX INFERENCE : This is the most common class of errors (38%). Questions in this class could theoretically be answered by an automated system but such a system would require complex reasoning mechanisms, large amounts of world knowledge, and dis-course understanding. For example, to answer the first question in Table 10, a system would have to understand that confronting or being supportive are forms of dealing with a person. To answer the second question, the system would have to know that creating aCD at what resolution you need supersedes making a low resolution CD . Our approach captures some simple inference rules through translation models but fails to understand complex implications such as these.

ELLIPSIS : This class of errors is not necessarily a fault of our approach but is rather caused by the problem setting. Because in a social QA site each answer responds to a specific question, discourse ellipsis (i.e., omitting the context set by the question in the answer text) is common. This makes some answers (e.g., the third answer in Table 10) ambiguous, hence hard to retrieve automatically. This affects 36% of the questions analyzed.

ALSO GOOD : It is a common phenomenon in Yahoo! Answers that a question is asked several times by different users, possibly in a slightly different formulation. To enable our large scale automatic evaluation, we considered an answer as correct only if it was chosen as the  X  X est answer X  for the corresponding question. So in our setting,  X  X est answers X  from equivalent questions are marked as incorrect. This causes 18% of the  X  X rrors X  of the re-ranking model. One example is the fourth question in Table 10, where the answer selected by our re-ranking model is obviously also correct. It is important to note that at testing time we do not have access to the questions that generated the candidate answers for the current test question, that is, the system does not know which questions are answered by the answers in the ALSO GOOD section of Table 10.
So the answers in the ALSO GOOD category are not selected based on the similarity of the corresponding queries, but rather, based on better semantic matching between test question and candidate answer.

REDIRECTION : Some answers (10% of the questions analyzed) do not directly answer a question but rather redirect the user to relevant URLs (see the fifth question in Table 10).
Because we do not extract the text behind URLs in the answer content, such questions are virtually impossible to answer using our approach.

ANSWER QUALITY : For a small number of the questions analyzed (4%) the choice of  X  X est answer X  is dubious (see the sixth example in Table 10). This is to be expected in a social QA site, where the selection of best answers is not guaranteed to be optimal.
Nevertheless, the relatively small number of such cases is unlikely to influence the quality of the evaluation. 374
SPELLING : Two percent (2%) of the error cases analyzed are caused by spelling errors (e.g., the seventh example in Table 10). Because these errors are relatively infrequent, they are not captured by our translation models, and our current system does not include any other form of spelling correction.

CLARIFICATION : Another 2% of the questions inspected manually had answers that pointed to errors or ambiguities in the question text rather than responding to the given question (see the last example in Table 10). These answers are essentially correct but they require different techniques to be extracted: Our assumption is that questions are always correct and sufficient for answer extraction. 6. Related Work
There is a considerable amount of previous work in several related areas. First, we will discuss related work with respect to the features and models used in this research; most of this work is to be found in the factoid QA community, where the most sophisticated 376
QA selection and re-ranking algorithms have been developed. We then review existing work in non-factoid QA; we will see that in this area there is much less work, and the emphasis has been so far in query re-writing and scalability using relatively simple features and models. Finally we will discuss related work in the area of community-built ( social ) QA sites. Although we do not exploit the social aspect of our QA collection, this is complementary to our work and would be a natural extension. Table 11 summarizes aspects of the different approaches discussed in this section, highlighting the differences and similarities with our current work.
 pecially for feature development; indeed our work includes matching features as well as translation and retrieval models, and operates at the lexical level, the parse tree level, as well as the level of semantic roles, named entities, and lexical semantic classes.
However, to the best of our knowledge no previous work in QA has evaluated the use of so many types of features concurrently, nor has it built so many combinations of these features at different levels. Furthermore, we employ unsupervised methods, generative methods, and supervised learning methods. This is made possible by the choice of the task and the data collection, another novelty of our work which should enable future research in complex linguistic features for QA and ranking.

Factoid QA . Within the statistical machine translation community there has been much research on the issue of automatically learning transformations (at the lexical, syntactical, and semantical level). Some of this work has been applied to automated
QA systems, mostly for factoid questions. For example, Echihabi and Marcu (2003) presented a noisy-channel approach (IBM model 4) adapted for the task of QA. The features used included lexical and parse-tree elements as well as some named entities (such as dates). They use a dozen heuristic rules to heavily reduce the feature space and choose a single representation mode for each of the tokens in the queries (for example:  X  X erms overlapping with the question are preserved as surface text X ) and learn language models on the resulting representation. We extend Echihabi and Marcu by considering deeper semantic representations (such as SRL and WNSS), but instead of using selection heuristics we learn models from each of the full representations (as well as from some hybrid representations) and then combine them using discriminant learning techniques. parse tree information, computing a similarity score between question and answer parse trees (using a distance function based on approximate tree matching algorithms).
This is an unsupervised approach, which is interesting especially when coupled with appropriate distances. Shen and Joshi (2005) extend this idea with a supervised learning approach, training dependency tree kernels to compute the similarity. In our work we also used this type of feature, although we show that, in our context, features based on dependency tree kernels are subsumed by simpler features that measure the overlap of binary dependencies. Another alternative is proposed by Cui et al. (2005), where significant words are aligned and similarity measures (based on mutual information of correlations) are then computed on the resulting dependency paths. Shen and Klakow (2006) extend this using a dynamic time warping algorithm to improve the alignment for approximate question phrase mapping, and learn a Maximum Entropy model to combine the obtained scores for re-ranking. Wang, Smith, and Mitamura (2007) propose to use a probabilistic quasi-synchronous grammar to learn the syntactic transformations between questions and answers. We extend the work of Cui et al. by considering paths within and across different representations beyond dependency trees, although we do not investigate the issue of alignment specifically X  X nstead we use standard statistical translation models for this.

Non-factoid QA . The previous works dealt with the problem of selection ,thatis, finding the single sentence that correctly answers the question out of a set of candidate documents. A related problem in QA is that of retrieval : selecting potentially relevant documents or sentences prior to the selection phase. This problem is closer to gene-ral document retrieval and it is therefore easier to generalize to the non-factoid domain.
Retrieval algorithms tend to be much simpler than selection algorithms, however, in part due to the need for speed, but also because there has been little previous evidence that complex algorithms or deeper linguistic analysis helps at this stage, especially in the context of non-factoid questions. 378 and answers and using them to improve retrieval. All these works use only lexical features. For example, Agichtein et al. (2001) learned lexical transformations (from the original question to a set of Web search queries, from  X  what is a  X  X o  X  X he term X  , X  stands for  X , etc.) which are likely to retrieve good candidate documents in commercial Web search engines; they applied this successfully to large-scale factoid and non-factoid QA tasks. Murdock and Croft (2005) study the problem of candidate sentence retrieval for QA and show that a lexical translation model can be exploited to improve factoid QA.
Xue, Jeon, and Croft (2008) show that a linear interpolation of translation models and a query likelihood language model outperforms each individual model for a QA task that is independent of the question type. In the same space, Riezler et al. (2007) develop
SMT-based query expansion methods and use them for retrieval from FAQ pages. In our work we did not address the issue of query expansion and re-writing directly: While our re-ranking approach is limited to the recall of the retrieval model, these methods of query transformation could be used in a complementary manner to improve the recall.
Even more interesting would be to couple the two approaches in an efficient manner; this remains as future work.
 tions. Girju (2003) extracts non-factoid answers by searching for certain semantic struc-tures (e.g., causation relations as answers to causation questions). We generalized this methodology (in the form of semantic roles) and evaluated it systematically. Soricut and Brill (2006) develop a statistical model by extracting (in an unsupervised manner)
QA pairs from one million FAQs obtained from the Web. They show how different statistical models may be used for the problems of ranking, selection, and extraction of non-factoid QAs on the Web; due to the scale of their problem they only consider lex-ical n -grams and collocations, however. More recent work has showed that structured retrieval improves answer ranking for factoid questions: Bilotti et al. (2007) showed that matching predicate X  X rgument frames constructed from the question and the expected answer types improves answer ranking. Cui et al. (2005) learned transformations of dependency paths from questions to answers to improve passage ranking. All these approaches use similarity models at their core because they require the matching of the lexical elements in the search structures, however. On the other hand, our approach allows the learning of full transformations from question structures to answer structures using translation models applied to different text representations.
 et al. (2010), both on Why questions. Higashinaka et al. consider a wide range of semantic features by exploiting WordNet and gazetteers, semantic role labeling, and extracted causal relations. Verberne et al. exploit syntactic information from constituent trees, WordNet synonymy sets and relatedness measures, and paraphrases. As in our models, both these works combine these features using discriminative learning tech-niques and apply the learned models to re-rank answers to non-factoid questions ( Why type questions). Their features, however, are based on counting matches or events defined heuristically. We have extended this approach in several ways. First, we use a much larger feature set that includes correlation and transformation-based features and five different content representations. Second, we use generative (translation) models to learn transformation functions before they are combined by the discriminant learner. Finally, we carry out training and evaluation at a much larger scale.
 for similar questions already answered (Jeon, Croft, and Lee 2005) and ranked using meta-data information like answerer authority (Jeon et al. 2006; Agichtein et al. 2008).
Here we show that the answer text can be successfully used to improve answer ranking quality. Our method is complementary to the earlier approaches. It is likely that an optimal retrieval engine from social media would combine all three methodologies.
Moreover, our approach might have applications outside of social media (e.g., for open-domain Web-based QA), because the ranking model built is based only on open-domain knowledge and the analysis of textual content. 7. Conclusions
In this work we describe an answer ranking system for non-factoid questions built using a large community-generated question X  X nswer collection. We show that the best ranking performance is obtained when several strategies are combined into a single model. We obtain the best results when similarity models are aggregated with features that model question-to-answer transformations, frequency and density of content, and correlation of QA pairs with external collections. Although the features that model question-to-answer transformations provide the most benefits, we show that the com-bination is crucial for improvement. Further, we show that complex linguistic features, most notably semantic role dependencies and semantic labels derived from WordNet senses, yield a statistically significant performance increase on top of the traditional bag-of-words and n -gram representations. We obtain these results using only off-the-shelf NL processors that were not adapted in any way for our task. As a side effect, our experiments prove that we can effectively exploit large amounts of available Web data to do research on NLP for non-factoid QA systems, without any annotation or evaluation cost. This provides an excellent framework for large-scale experimentation with various models that otherwise might be hard to understand or evaluate.
 several applications, such as retrieval from social media and open-domain QA on the
Web. On social media, for example, our system should be combined with a component that searches for similar questions already answered; the output of this ensemble can possibly be filtered further by a content-quality module that explores  X  X ocial X  features such as the authority of users, and so on. Although we do not experiment on Wikipedia or news sites in this work, one can view our data as a  X  X orse-case scenario, X  given its ungrammaticality and annotation quality. It seems reasonable to expect that training our model on cleaner data (e.g., from Wikipedia or news), would yield even better results. lected as best, but were marked as good by a minority of voters, could be incorporated in the training data, possibly introducing a graded notion of relevance. This would make the learning problem more interesting and would also provide valuable insights into the possible pitfalls of user-annotated data. It is not clear if more data, but of questionable quality, is beneficial. Another interesting problem concerns the adaptation of the re-ranking model trained on social media to collections from other genres and/or domains (news, blogs, etc.). To our knowledge, this domain adaptation problem for QA has not been investigated yet.
 References 380 382
