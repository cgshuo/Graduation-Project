 Extensible Markup Language (XML) has been popular for the Web and other applications. Usually in applications XML data are provided with schemas that the XML data must conform to. These schemas are important for solving prob-lems and improving efficiency in many ta sks of XML processing, for example, in query processing, data integration, typechecking, and so on. Among the many schema languages for XML, XML Schema is recommended by W3C and has been the most commonly used one. It is not ea sy, however, to design a correct XML Schema: investigation reveals that ma ny XML Schema Definitions in practice have errors [3,7]. One difficulty in designing XML Schema is the restriction that the content models should be deterministic, i. e., the unique particle attribu-tion (UPA) constraint, which means that the content models are deterministic regular expressions. In another XML schema language recommended by W3C, Document Type Definition (DTD), deterministic content models are also used.
A regular expression is deterministic (or one-unambiguous) if, informally, a symbol in the input word should be matched uniquely to a position in the regular expression without looking ahead in the word. This determinism, however, is defined semantically without known syntactic definition for it, thus making it difficult for users to design.

Br  X  uggemann-Klein [4] showed that deterministic regular expressions are char-acterized by deterministic Glushkov automata, and whether an expression is deterministic is decidable. In [5] an algorithm is provided to decide whether a regular language, given by an arbitrary regular expression, is deterministic, i. e., can be represented by a determinis tic regular expression. An algorithm is further given there to construct equiva lent deterministic regular expressions for nondeterministic expressions when they define deterministic languages. The size of the constructed dete rministic regular expressions, however, can be ex-ponentially larger than the original regular expressions. In [1] an algorithm is proposed to construct approximate deterministic regular expressions for regular languages that are not deterministic. Bex et al. [2] further provide improved algorithms for constructing deterministi c regular expressions and constructing approximations.

All existing work, however, cannot provide diagnostic information for nonde-terministic expressions. Consider if a design tool can locate the error positions and tell the type of error making the expression nondeterministic, just like what compilers or other program analysis tools do for programs, then it will be greatly helpful for designers to understand and modify nondeterministic expressions. Note here error is used to denote what make an expression nondeterministic.
In this paper we tackle the above issue. Our aim is to provide as much diag-nostic information for errors as possible when expressions are nondeterministic. The idea is, if we can check expressions at the syntactic level, then it is easier to locate errors. Following [5], we designed a conservative algorithm, which will accept deterministic expressions, but ma y also reject some deterministic expres-sions. We improved the conservative algorithm by borrowing semantic processing and obtained an exact checking algorithm , which will accept all deterministic ex-pressions, and reject only nondeterministic expressions. But it will not provide as precise diagnostic information for some nondeterministic expressions as for the other nondeterministic expressions. We further presented a sufficient and necessary condition for deterministic ex pressions, which leads to another exact checking algorithm for deterministic expressions. With the information provided by the algorithms, designers will be clearer about why an expression is not de-terministic. Thus the difficulty of designing deterministic expressions, and, of designing XML Schema at large, is lowered.

We also implemented the algorithm in [5] which constructs an equivalent deterministic expression if an expression is not deterministic but defines a de-terministic language, as an alternative way to obtain deterministic expressions.
We conducted several preliminary experiments, and the experimental results are presented. The main contributions of the paper are as follows.
 (1) We propose the notion of diagnosing deterministic regular expressions. While similar notion has been familiar in other areas of software, this notion is missing for deterministic regular expressions due to the semantic nature. (2) We prove several properties of deterministic regular expressions, which are the base of the algorithms. (3) We present several algorithms for checking deterministic regular expres-sions and providing diagnostic information. The algorithms presented in the paper check if regular expressions are deterministic at the syntactic level of the expressions. The first algorithm uses stronger but syntactical conditions and is conservative. The second algorithm is exact, but may obtain imprecise diagnos-tic information for some regular expressions. The third algorithm is also exact, and may obtain diagnostic information for all nondeterministic regular expres-sions. The work of the paper can be considered as a first step towards syntactic solutions of detecting determi nistic regular expressions.

The above algorithms can be used in schema design tools in which designers are able to find and fix bugs iteratively.

There is another issue that is connected with the present issue. That is, since deterministic regular expressions denote a proper subclass of regular languages, if a nondeterministic expression does not define a deterministic language, then the expression cannot have any equivalent deterministic expression. So when an expression is nondeterministic it is useful to tell the designer in the mean time whether the expression denotes a deterministic language.

Section 2 introduces definitions. The a lgorithms are presented in Section 3, with a discussion of diagnostic information and illustration of examples. Exper-iments are presented in Section 4 . Section 5 contains a conclusion. Let  X  be an alphabet of symbols. The set of all finite words over  X  is denoted by  X   X  . The empty word is denoted by  X  . A regular expression over  X  is  X  , X  or a  X   X  , or is the union E 1 + E 2 , the concatenation E 1 E 2 ,orthestar E  X  1 for regular expressions E 1 and E 2 . For a regular expression E , the language specified by E is denoted by L ( E ). Define EPT ( E )= true if  X   X  L ( E )and false otherwise. The size of E is denoted by the number of symbol occurrences in E , or the alphabetic width of E . The symbols that occur in E ,whichisthe smallest alphabet of E , is denoted by  X  E .

We require an expression to be star-re duced: any subexpression of the form ( E  X  )  X  is reduced to E  X  in the expression.

For a regular expression we can mark symbols with subscripts so that in the marked expression each marked symbol occurs only once. For example ( a 1 + b of an expression E is denoted by E . The same notation will also be used for dropping of subscripts from the marked symbols: E = E . The subscribed symbols are called positions of the expression. We extend the notation for words and automata in the obvious way. It will be clear from the context whether  X  adds or drops subscripts. Definition 1. An expression E is deterministic if and only if, for all words uxv, uyw  X  L ( E ) where | x | = | y | =1 ,if x = y then x = y . A regular language is deterministic if it is denoted by some deterministic expression.
 For an expression E over  X  , we define the following functions: One can easily write equivalent inductive definitions of the above functions on E , which is omitted here.

Define followlast ( E )= { b | vbw  X  L ( E ) ,v  X  L ( E ) ,v =  X , b  X   X , w  X   X   X  } .An expression E is in star normal form (SNF) [4] if, for each starred subexpression H  X  of E , followlast ( H )  X  first ( H )=  X  and  X /  X  L ( H ). 3.1 Algorithms The Glushkov automaton was introduced independently by Glushkov [6] and McNaughton and Yamada [8]. It is known that deterministic regular expressions can be characterized by Glushkov automata.
 Lemma 1. ([5]) A regular expression is deterministic if and only if its Glushkov automaton is deterministic.
 Lemma 1 has led to an algorithm to check if an expression is deterministic [4]. We call this algorithm the semantic checking algorithm in the paper.

If diagnostic information about why a regular expression is not determinis-tic is required, we need a syntactic charac terization, or at least some syntactic properties, of deterministic expression s. Such a characterization, however, is not known presently. We started from a prope rty of deterministic expressions in star normal form in [5] by modifying it to more general expressions. To do this, Lemma 2 is required.
 Lemma 2. Foraregularexpression E ,if followlast ( E )  X  first ( E )=  X  then followlast ( E )  X  first ( E )=  X  .
 The following is a modified version of t he afore mentioned property proved in [5] 1 . Lemma 3. Let E be a regular expression.
 If E =  X  , X  ,or a  X   X  ,then E is deterministic.
 If E = E 1 + E 2 ,then E is deterministic iff E 1 and E 2 are deterministic and first ( E 1 )  X  first ( E 2 )=  X  .
 If E = E 1 E 2 ,thenif L ( E )=  X  ,then E is deterministic, otherwise E is determin-and followlast ( E 1 )  X  first ( E 2 )=  X  ,or(2) E 1 and E 2 are deterministic,  X /  X  L ( E 1 ) ,and followlast ( E 1 )  X  first ( E 2 )=  X  .
 If E = E  X  1 ,then E is deterministic and followlast ( E 1 )  X  first ( E 1 )=  X  iff E 1 is deterministic and followlast ( E 1 )  X  first ( E 1 )=  X  .
 The last case of Lemma 3 can be proved from a modification of the proof in [5] in addition with Lemma 2. The other cases are proved in [5].

This property, however, is not a suffici ent and necessary condition of deter-ministic expressions, since in the last case the expression E is accompanied with an additional condition. Actually, in this case there are examples in which either E is deterministic and followlast ( E 1 )  X  first ( E 1 ) =  X  ,or E 1 is deterministic but E is not deterministic. In other words, the condition that E 1 is deterministic and followlast ( E 1 )  X  first ( E 1 )=  X  is too strong to ensure E  X  1 to be deterministic. Proposition 1. Foraregularexpression E = E  X  1 , (1) E can be deterministic when followlast ( E 1 )  X  first ( E 1 ) =  X  . (2) If E is deterministic then E 1 is deterministic, but not vice versa. On the other hand, up to date there is no known simpler condition for the last case of Lemma 3.

In order to check if an expression is deterministic and locate error position when the expression is not deterministic, one way is to directly use the property of Lemma 3, thus resulting in a conserva tive algorithm, i. e., if it accepts an expression, then the expression must be deterministic, but it may also reject some deterministic expressions.

To obtain an exact checking algorithm we make some compromise and use the following strategies, based on the above properties. When e = e  X  1 we first check if e 1 is deterministic using Lemma 3. If e 1 is not deterministic, then e is not either by Proposition 1. Furthermore, if the erroneous part in e 1 is not a starred subexpression, then precise diagnostic information can be obtained. If e 1 is deterministic, and followlast ( e 1 )  X  first ( e 1 )=  X  ,then e is deterministic by Lemma 3. Otherwise, we encoun ter the only uncertain case: e 1 is deterministic tic checking algorithm [4] to check if e is deterministic. If e is deterministic, then the algorithm proceeds smoothly without any impact of the semantic checking. If e is not deterministic, then we can only say that e is nondeterministic to the users, without any further diagnostic information. The resulting algorithm is ex-act: it will accept all deterministic expre ssions, and reject only nondeterministic expressions. Notice that the semantic checking algorithm runs in linear time [4], so will not much lower down the efficiency of the whole algorithm. The cost is, it will not provide as precise diagnostic information for some nondeterministic expressions as for the other nondeterministic expressions; When the erroneous subexpression is located by the semantic checking algorithm, diagnostic infor-mation will be less precise than in other situations. For example, when checking not deterministic, and the subexpressions of it are deterministic.

Further, for any expression E = E  X  1 , we give a sufficient and necessary condi-tion of E being deterministic as follows.
 Proposition 2. For E = E  X  1 , E is deterministic iff E 1 is deterministic and  X  y By Proposition 2 and using Lemma 3 we g et a sufficient and necessary condi-tion for deterministic expressions. This gives another algorithm which provide diagnostic information for all nondeterministic expressions.

The above proposition actually requires that if followlast ( E 1 )and first ( E 1 ) have common elements, the intersection can only be in the same positions of E 1 . To ease the computation and obtain more diagnostic information, we present the following inductive computation of the condition.
 Definition 2. The function P ( E ) which returns true or false is defined as P (  X  )= P (  X  )= P ( a )= true a  X   X  P ( E 1 + E 2 )= P ( E 1 )  X P ( E 2 )  X  ( followlast ( E 2 )  X  first ( E 1 )=  X  )  X  ( followlast ( E P ( EPT ( E 1 )  X  X  ( EPT ( E 2 ))  X P ( E 2 )  X  ( followlast ( E 2 )  X  first ( E 1 )=  X  ))  X  (  X  ( EPT ( E 1 ))  X  EPT ( E 2 )  X P ( E 1 )  X  ( followlast ( E 2 )  X  first ( E 1 )=  X  ))  X  P ( E  X  1 )= P ( E 1 ) Proposition 3. Let an expression E be deterministic. The following two state-ments are equivalent. (1)  X  y 1  X  followlast ( E ) ,  X  y 2  X  first ( E ) ,if y 1 = y 2 then y 1 = y 2 . (2) P ( E )= true .
 In the following we give the three algorithms. The conservative one is determin-istic c , the second one is deterministic , and the third one is deterministicpl .
All of the algorithms take as input a regular expression, and output a Boolean value indicating if the expression is deterministic as well as diagnostic infor-mation if the expression is not deterministic. In the algorithm deterministc c , lambda ( e ) is just the function EPT ( e ) which returns true if  X   X  L ( e )andfalse otherwise. print err is not a real function here, it just indicates some state-ments in the implementation that print current error information. For example, in line 5 print err should print that first ( e 1 )  X  first ( e 2 ) is not empty, and in line 9 print err should print that followlast ( e 1 )  X  first ( e 2 )isnotempty.It is not difficult to indicate the positions of e 1 and e 2 by the parse tree of the whole expression. The difference between deterministic c and the other algo-rithms only starts from line 16. In deterministic , isdtre is the semantic check-ing algorithm [4] to check if a regular expression is deterministic. It is used in Algorithm 1. deterministic c ( e ): Boolean thecaseof e = e  X  1 .In deterministicpl , P ( e )calculates P ( e ) and print diagnos-tic information if e is nondeterministic. When checking the previous expression ( c ( ca + a )  X  )  X  , the algorithm deterministicpl will provide the following informa-tion: followlast (( ca + a )  X  )  X  first ( c ) =  X  .
 Theorem 1. If deterministic c( e ) returns true, then e is deterministic. Proof. It follows directly from Lemma 3.
 Theorem 2. deterministic( e ) returns true if and only if e is deterministic. Proof. It follows from Lemma 3, Lemma 1, and Proposition 1.
 Theorem 3. deterministicpl( e ) returns true if and only if e is deterministic. Proof. It follows from Lemma 3, Proposition 2, and Proposition 3.
 To implement the algorithms we first calculate the first,followlast sets and EPT functions for each subexpressions, then run the algorithms presented above. Suppose the regular expression is E . The first calculation can be done on the syntax tree of E [4], which can be computed in O ( m 2 )timewhere m is the size of first ( E 2 ) for subexpressions E 1 ,E 2 can be completed in O (2 m ) time with an auxiliary array indexed by every letters in the alphabet of E . The algorithms may conduct the test at every inner node on a traversal of the syntax tree of E , which totally takes O ( m 2 ) time. So the time complexity of the algorithms is O ( m 2 ). Notice here we do not take into account the time for printing diagnostic information. Algorithm 2. deterministic ( e ): Boolean Algorithm 3. deterministicpl ( e ): Boolean 3.2 Reporting Errors Three kinds of error information can be reported by the above algorithms: -Error location. Using the parse tree of an expression, the subexpressions that cause an error can be located precisely. -Types of errors. There are roughly the following types of errors: (1) first -first error, indicating first ( e 1 )  X  first ( e 2 ) =  X  .Itcanfurtherbe classified into first -first -+ and first -first -., corresponding to a (sub)expression e = e 1 + e 2 and e = e 1 e 2 respectively. it is also classified into followlast -first -+, followlast -first -., and followlast -first -*. (3) A starred (sub)expression is not deterministic, indicating the semantic checking error in deterministic . =  X  in P ( e ), corresponding to a violation of the condition is Proposition 2. -Other diagnostic information. For example, for a type (1) error, the two first sets can be provided. For a type (2) error, besides the followlast and first sets, the symbols in the last set that cause the overlap of the followlast and first sets, and symbols in the follow set of the previous symbols, can be provided.

In addition to the above information, other information like parse trees of expressions, the Glushkov automata, and the matching positions of a word against an expression can also be displayed , thus providing debugging facilities of expressions.

Of course, in an implementation of a tool, the above information can be im-plemented such that the users can select which information to display. 3.3 Examples Example 1. Suppose one want to write a schema for papers with no more than two authors. The content model of the papers can be defined as
Title, Author?, Author, Date, Abstract, Text, References 2 which equals to the following regular expression Title, (Author+empty), Author, Date, Abstract, Text, References
By using the above algorithms, the following information is displayed 3 : error: the expression is not deterministic. error found in: "Title, (Author+empty), Author" hints: the sets of followlast((Title, (Author+empty))) and Then the content model can be rewritten into the following:
Title, Author, Author?, Date, Abstract, Text, References which is deterministic.
 Of course for some nondeterministic con tent models their equivalent determin-istic ones are very difficult to find, as in the following example.
 Example 2. ( a + b )  X  a defines any string of a or b , including the empty word, followed by one a . The above algorithms will show that this expression is not deterministic, and this is because followlast (( a + b )  X  )  X  first ( a ) =  X  .Forthe expression it is difficult to write an equivalent deterministic regular expression.
However, using the diagnostic information, the designer can change the design to circumvent the error: ( a + b )  X  c ,and c is defined as a in another rule. So the diagnostic information can -help the designer to locate errors and rewrite nondeterministic expressions into correct ones, and -help the designer to understand the reasons of errors, or change design to circumvent the errors. We have implemented the algorithms and performed some experiments. The algorithms were tested with randomly gen erated regular expre ssions in different sizes. The sizes of regular expressions range from 10 to 160 every time increased by 10 in the experiments, with 500 expressions in each size. The size of the alpha-bet was set to 40. The algorithms were implemented in C++. The experiments were run on Intel core 2 Duo 2.8GHz, 4GB RAM.

Table 1 shows the numbers of determini stic regular expressions determined by each algorithm, in which the first line d enotes the sizes of expressions, the re-maining lines indicate the numbers of deterministic regular expressions identified by different algorithms.  X  X eterministic c X  denotes the algorithm deterministic c ,  X  X thers X  denotes the semantic checking algorithm, the algorithm deterministic , and deterministicpl . We can observe the number of deterministic expressions de-creases when the size of regular expressions grows. Intuitively, this is because the possibility of the occurrences of a same symbol increases in one expression when the size of expressions increases, which increases the possibility of nondetermin-ism. Actually, when size is greater than 50, all expressions are nondeterministic. The numbers of deterministic regular expressions identified by the algorithm deterministic c are less than the numbers ident ified by the other algorithms, which coincides with that deterministic c is conservative. The numbers of deterministic expressions determined by the algorithms deterministic and deter-ministicpl are identical with the numbers determined by the semantic checking algorithm, reflecting that deterministic and deterministicpl exactly detect all deterministic expressions.

The errors in the tested regular expressions found by the algorithms are shown in Table 2. The first column in the table shows the size of re gular expressions. The other columns include the numbers of different types of errors caught by deterministic c , deterministic and deterministicpl in the experiment, in which first-first , fola-first , star-exp ,and ff-nd correspond to the types (1), (2), (3), and (4) of errors presented in S ection 3.2, respectively. It shows that the most common type of errors in the experiment is the first -first errors. Also the numbers of errors for each of first-first and fola-first of deter-ministicpl and deterministic are identical, and the numbers of errors for ff-nd and star-exp are identical too. This is because the two algorithms both exactly check whether an expression is determin istic, and differ only in the processing of stared subexpressions. When a starred s ubexpression has an error, each of the algorithms will detect one error.

Figure 1 shows the average time for detecting one nondeterministic regular expressions by the algorithms. Each value is obtained by the time to check the total amount of nondeterministic regular expressions in each size divided by the number of nondeterministic regular expressions in that size. The time used to print diagnostic information in the programs is not included. The algorithms spend averagely less than 6 milliseconds for a regular expression of size 160, thus are efficient in practice. It is not strange that the semantic checking algorithm runs faster, since the algorithms presented in this paper will do more than the semantic algorithm. On the other hand, the implementation of the algorithms presented in the paper still have much room for improvement. In the experiment deterministicpl runs almost as faster as deterministic c and deterministic .Thus we can use deterministicpl for diagnostic tasks.
 Due to its semantic definition, a deterministic regular expression is hard to de-sign and understand, and semantic checking techniques can only answer yes or no. The paper presented several algorithms as an attempt to diagnose nonde-terministic regular expressions, making it possible to analyze and give hints to errors thus reducing the difficulty of designing deterministic content models. This would be convenient for designers to utilize their knowledge and intuition. In the future, it would be useful to find more syntactic conditions for deter-ministic regular expressions, in the hope of more detailed revealing of errors. A presently unclear question is, can we use other more intuitive conditions to replace the emptiness condition of followlast -first or first -first intersection? The approaches to display diagnostic information effectively also constitute a significant aspect. The diagnostic information offered by the algorithms may also be used to generate counter examples of nondeterministic content models, which is also helpful for designers, but is not discussed in the paper. It is possible to integrate the above techniques in tools to provide analyzing and debugging facilities for content models.

