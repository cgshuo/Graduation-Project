 Yixin Jing  X  Dongwon Jeong  X  Doo-Kwon Baik Abstract This paper focuses on the issue of OWL-DL ontology queries implemented in SPARQL. Currently, ontology repositories construct inference ontology models, and match SPARQL queries to the models, to derive inference results. Because an inference model uses much more storage space than the original model, and cannot be reused as inference problem, this paper proposes a novel method that passes rewritten SPARQL queries to the original ontology model, to retrieve inference results. We define OWL-DL inference rules and apply them to rewriting Graph Patterns in queries. The paper classifies the inference rules and discusses how these rules affect query rewriting. To illustrate the advantages of our proposal, we present a prototype system based on Jena, and address query optimization, to eliminate the disadvantages of augmented query sentences. We perform a set of query tests and compare the results with related works. The results show that the proposed method results in significantly improved query efficiency, without compromising completeness or soundness.
 Keywords Graph pattern  X  Ontology inference  X  OWL-DL  X  Query rewriting  X  SPARQL  X  Semantic web 1 Introduction In Semantic Web, ontologies are representations of a set of concepts within a domain, and the relationships between these concepts, using specific languages such as RDF and OWL. In particular, the OWL ontology is used not only to specify the concepts and relationships, advantage of the OWL ontology. With a reasoner, a particular ontology can be interpreted as content. The representative implementations, such as Jena2 [ 17 ]andSesame[ 4 ]employa built-in reasoner, which is compliant with RDF Semantics [ 12 ] and OWL Entailment [ 24 ]for interpreting an ontology. Subsequent to interpretation, generally through a Tableau expan-B , to which the ontology reasoner adds new relationships 1 X 4. Relationship 1 declares impli-cit type relationships between Full Prof essor 0 (for http://www.Department0.University0. From and has Alumnus relationships between Full Prof essor 0and Uni v er si t y 84 (for http://www.University84.edu ), which are based on the fact that under DegreeFrom is a sub-property of degreeFrom ,and has Alumnus and degreeFrom are the inverse headOf b , while b  X  X  type is Department, then a  X  X  type is Chair X . The reasoner applies this rule and generates a type relationship between Full Prof essor 0and Chair (Relation-ship 3), because Full Prof essor 0is head O f Department 0 (for http://www.Department0. perty, which generates a subOrgO f relationships between Uni v er si t y and Lab (Relation-ship 4).

An inference ontology retrieves inference results when an ontology user issues queries. For ontology, due to the lack of corresponding statements.
 rential contents are determined by a set of inference rules, some of which are standardi-zed, such as OWL Entailment, some of which are customized and developed by ontology engineers [ 21 ]. The greater the number of inference rules, the larger the inference onto-ontologies.

Another intrinsic disadvantage of the above approach is that a single interpretation can support only a single set of inference rules. However, a practical ontology is accessed by a large number of users, which involves a variety of inference requirements. If an ontology reasoner aims to support different sets of inference rules, it must generate corresponding inference ontologies and store them separately. However, this causes problems with work-load and storage space, thus, maintaining an inference ontology for each user is impractical.
To solve the aforementioned challenges, this paper assigns a high priority to releasing burden of ontology basis and proposes a query rewriting approach, to realize semantic infe-According to the inverse relationship between degreeFrom and has Alumnus ,aswellas the super-sub relationship between degreeFrom and undergraduateDegreeFrom ,anew query about who took degree/undergraduate degrees from Uni v er si t y 84 can be composed and passed to the original ontology. By this means, the inference result, Full Prof essor 0, is retrieved. Thus, the approach avoids the generation of an inference ontology, and reduces computational time. In addition, an original, shared ontology can be reused among ontology users, even though their relevant inference rules vary. The process of composing a new query in the manner given above is called query rewriting.

The concept of query rewriting has been widely adopted for cases where multiple data sources exist, such as data integration of contexts involving inconsistent databases [ 7 ]and Semantic Web [ 30 ]. Query rewriting is used to access these heterogeneous data sources via a the proposed query rewriting focuses on extending a query to retrieve implicit contents of an ontology, other than retrieving data from multiple datasets. As a result, our concerns differ from those of predominant query rewriting.

Query rewriting is closely related to query languages. Among several ontology query entailment rules as well as customized inference rules are pre-extracted and cached. After receiving a query, the system analyzes the query pattern, determines the means of rewriting ontology model for resolution. Since rewritten queries are more verbose than the original query, optimization is needed to accelerate query resolution.

The paper is organized as follows. Section 2 provides the preliminaries for RDF graphs (the representation of OWL) and SPARQL. Section 3 validates our approach. Section 4 defines the ontology inference rules, which enable query rewriting. The details about rewriting various system, presents the experimental result and compares our experiment with other related conclude the paper and address future work in Sect. 8 . 2 Preliminaries Since an ontology written in OWL is interpreted as RDF triples, the formalization of SPARQL over RDF also applies to OWL. This section provides an algebraic formalization of the core components of SPARQL over RDF. For a complete definition refer to see [ 19 , 27 ]. Let I be of RDF Terms, T = I L B . There exists an infinite set, V , of variables disjoint from T . Definition 2.1 RDF Triple (v 1 ,v 2 ,v 3 ) = ( I B )  X  I  X  ( I B L ) . a triple, i.e., v 3 , can be an IRI, blank node or literal.
 Definition 2.2 RDF Graph, viz. an RDF dataset, D , is a set of RDF triples.
 logy. Otherwise, the generated RDF triples state not only explicit but also implicit contents of the ontology. In this paper, the original model and the inference model refer to the two kinds of RDF graph.
 Definition 2.3 Triple pattern: a triple pattern, t ,ismemberoftheset: ( I B V )  X  ( I V )  X  ( T V ) .
 an example of triple pattern is &lt; ? v, rdf : type , Full Prof essor &gt; . Definition 2.4 Graph pattern: a SPARQL graph pattern expression is defined recursively as follows: (1) A triple pattern is a graph pattern.
A graph pattern is the body of a SPARQL query. A graph pattern is consists of triple pat-terns, restriction and operators (AND, OPT, UNION, and FILTER). For example, in Fig. 1 , &lt; ? v, rdf : type , Full Prof essor &gt; AND &lt; ? v, undergraduateDegreeFrom , Univer-sity 84 &gt; is a graph pattern.
 Definition 2.5 Solution Mapping: a solution mapping,  X  , is a partial function  X  : V  X  T .  X ( dom ( X ) , is the subset of V where  X  is defined.
 Definition 2.6 Graph pattern evaluation [ 25 ]: the evaluation of a graph pattern P over D is accomplished by [[ P ]] D , which is a set of  X  connected via algebra operators JOIN, LEFT OUTER-JOIN and UNION. Especially, [[ t ]] D ={  X  | dom ( X ) = v ar ( t ),  X ( t )  X  D } ,where v ar ( t ) is the set of variables contained in t .
 of RDF triples, D . In accordance with the original ontology, D includes two statements. That is &lt; Full Prof essor 0 , rdf : type , Full Prof essor &gt; and &lt; Full Prof essor 0 , under Consequently, Full Prof essor 0 is retrieved as the result. Stated formally: [[ &lt; ? v, rdf : type , Full Prof essor &gt; AND &lt; ? v, undergraduateDegreeFrom , Uni v er si t y 84 &gt; ]] D = Uni v er si t y 84 &gt; ]] D = {
Full Prof essor 0 } AND { Full Prof essor 0 } = { Full Prof essor 0 } Alumnus , ? v&gt; is matched to this triple and Full Prof essor 0 is retrieved. 3 Graph pattern rewriting approach Unlike predominant approaches, this paper aims to realize inference by means of extending graph patterns, to enable a query engine to retrieve both explicit and implicit contents. To this end, we extend the original query using UNION.

This is because UNION is the operator used in SPARQL to provide a means of combining ting a triple pattern UNION with other graph patterns preserves the original solutions. This can be proved formally: Theorem Given a graph pattern P : If P r is a graph pattern derived via construction of the triple patterns of P UNION with another graph pattern, then [[ P ]] D  X  X [ P r ]] D Proof By adopting the definition in [ 25 ], it can be proved recursively as follows: (1) If P = t , [[ t UNION P ]] D =[[ t ]] D [[ P ]] D  X  X [ t ]] D ; (2) If P = ( P 1 AND P 2 ) , (3) If P = ( P 1 OPT P 2 ) , (4) If P = ( P 1 UNION P 2 ) ,
Built-in conditions, i.e., graph patterns after FILTER, are not subject to rewriting, because they filter query results. Any changes to built-in conditions may not preserve the previous solutions. As we addressed in the introduction, the general rewriting process is: (1) The OWL-DL and customized inference rules are saved in the repository. (3) The rewritten query is evaluated with respect to the original ontology model.
Section 4 introduces the expression of various entailment and inference rules. Section 5 introduces triple patterns, and presents query rewriting according to different patterns. 4 Ontology inference rules This section defines the ontology inference rules for graph pattern rewriting. When a graph pattern is evaluated with respect to an original model, ontology inference rules are used to rewrite this graph pattern. The product of rewriting is an expanded graph pattern. Inference rules can be derived from OWL-DL entailments, or can be customized by an ontology user, to control inference, which is not directly supported by OWL entailments. According to the Chain.
 conditions connected by UNION, each of which is an RDF graph. The semantics of these both, should appear in each element condition. The formal definition is as follows: Definition 4.1 Conclusion ( C D ) Given an original ontology model D , a conclusion, C D ,is a 2-tuple C D = ( Con , r : (v 1 ,v 2 ,v 3 )) ,where (1) Conditions Con =UNION c i ; (2) Every c i is an element condition. c i =AND ( l : (v ij 1 ,v ij 2 ,v ij 3 )) ; (3) l and r represent conditions(left) and conclusion(right) components of a rule, respecti-rule in the following examples: Example 1 ( a , head O f , b )( b , rdf : type , Department )  X  ( a , rdf : type , Chair ) , which is a customized inference rule and only one element condition exists.
 an RDF entailment rule.

Hierarchy expresses a structure comprising an explicit super-sub relationship within a group of elements, which could be classes or properties. Hierarchy is defined as: Definition 4.2 Hierarchy ( H )
Hierarchy H consists of a set of h , each representing a tree which corresponds to rela-tionship of subO f among a group of c i .An h consists of a set of c i ,towhichapairof [ Example 3 Figure 2 shows an example of the class hierarchies in Fig. 1 .

Pair is a 2-tuple. Each tuple comprises a key symmetry property and a set, which represents is formally defined as: Definition 4.3 P key = ( key , S ) ,where key  X  X  rdf s : equi v alentClass , rdf s : equi v alent Property , o w l : in v er se O f , o w l : sameAs , o w l : di f f erent From , o w l : disjointWith , o w l : complement O f } S ={ ( e 1 , e 2 ) | ( e 1 , key , e 2 ) } Example 4 P in v er se O f = ( o w l : in v er se O f , { ( has Alumnus , degreeFrom ) } ) Note that Pair only stores the statements that are explicitly stated in the ontology model. Some symmetric relationships can be inferred from entailment rules. For example, o w l : equi v alentClass between two classes could be derived by expressing the fact that the two class are sub-classes of each other. Such implicit statements are handled by Conclusion but not by Pair.

The remaining significant type of inference is transitive properties. these are saved in a collection, transitive chain (TC).
 Definition 4.4 TC ={ p | ( p , rdf : type , o w l : Transiti v eProperty ) } 5 Triple pattern rewriting the pattern is rewritten by processes that change the pattern style, including C D , H C and implicit result is retrieved according to the property hierarchy. The following sub-sections address each approach in detail. 5.1 Subject/object-variable triple pattern object, i.e., t is member of the set: ( V  X  I  X  T ) ( I  X  I  X  V ) . Note that we restrict the subject constant to an IRI rather than a blank node, because users can not refer to a blank node in a query.
 It is possible to match a subject/object-variable triple pattern to various inference rules. Algorithm 1 shows this process.
 Algorithm 1 Rewriting graph pattern: inverse, sub, and equivalent properties procedure PropertyRewrite end procedure
Subsequent to the examination of the properties, the original triple pattern may be extended next step imposes class-related rules on each triple pattern.

We deal with Conclusion first. Prior to rewriting, it is necessary to evaluate whether the triple matches the Conclusion rule or not. For example, consider the subject-variable triple pattern t = ( ? v 1 ,v 2 ,v 3 ) : iff r : v 1  X  X  r : v 1 , r : v 3 } { l : v ij 1 , l : v ij 3 } and r : v 2 = t .v 2 .
If a t matches a C D , t undergoes a UNION with a graph pattern that is the condition component of the conclusion rule. The subjects and objects of the condition component are changed to variables. Especially, the subject of the condition component that corresponds to t  X  X  variable is changed to the same variable of t . This process is shown in Algorithm 2. Rewriting for t = (v 1 ,v 2 , ? v 3 ) is similar.
 Algorithm 2 Rewriting graph pattern: conclusion rule procedure ConclusionRule end procedure v result, t gets rewritten and is expanded to: ( ? x , rdf : type , Prof essor )  X  ( ? x , rdf : type , Prof essor ) UNION (( ? x , rdf : type , ? b ) AND ( ? b , rdf s : subClassO f , Prof essor ))
Subsequent to successful rewriting based on Conclusion, we examine a triple in terms of ? v 3 ) ,where rdf s : subClassO f is in the triple pattern, the class hierarchy must be UNION.
 Example 6 Reconsider the Example 5 ,if f ind Successor ( Prof essor ) ={ Full Prof essor , (( ? x , rdf : type , ? b ) AND ( ? b , rdf s : subClassO f , Prof essor ))  X  ( ? x , rdf : type , Full Prof essor ) UNION ( ? x , rdf : type , Assistant Prof essor ) Transiti v eProperty property. For example, consider a subject-variable triple pattern t tors of t .v 3 must be realized in real-time. Considering both completeness and efficiency, a triple pattern matched to TC is expanded by traversing two steps. Subsequent to evaluating results can be found.
 Example 7 t = ( ? v, subOrgO f , Uni v er si t y )  X  t UNION (( ? v , subOrgO f , ? a ) ( ? a , subOrgO f , Uni v er si t y )) Lab ) is evaluated. The process is iterated until no more value for ? v can be retrieved. 5.2 Subject&amp;object-variable triple pattern in other triples, t does not need to be rewritten in further.
 Example 8 Consider the query ( ? v 1 , degreeFrom , ? v 2 ) .Since undergraduateDegree From is a sub-property of degreeFrom , the query can be rewritten as ( ? v 1 , degreeFrom , ? v 2 ) UNION ( ? v 1 , undergraduateDegreeFrom , ? v 2 ) . By querying the original ontology, undergraduateDegreeFrom , ? v 2 ) and ( ? v 1 , undergraduateDegreeFrom , Uni v er si t y 84 ) are examined by C D as defined as Sect. 5.1 . 5.3 Predicate-variable triple pattern A predicate-variable triple pattern contains exactly one variable for a predicate, i.e., t is ween v 1 and v 3 . In the case where both v 1 and v 3 are classes, or both are instances, we (v by the latter UNION).

The triple patterns that have not yet been addressed are subject&amp;predicate-variable, and seldom used in user queries, and rewriting them results in increased complexity relative to other triple patterns, rewriting them is beyond the scope of this paper. 6 A SPARQL rewriting-based OWL query system 6.1 Built-in inference rule of OWL-DL This sub-section summarizes RDF entailments as well as positive entailments in OWL-DL. These entailments are used to rewrite SPARQL queries. Table 1 lists the RDF entailments Sect. 5 .

Considering OWL entailments, we only address positive entailments, since other entail-ments, e.g., negative entailments or consistent documents, do not affect queries. We express mentation of these entailments require some extra processing with respect to entailment type. One of the representative entailments is discussed below.
 http://www.jena.hpl.hp.com/ARQ/list# , which is a property function provided by ARQ [ 1 ] is expanded, note that the attached conditions include incorrect results. For example, triple pattern ( x , o w l : di f f erent From , ? y ) is expanded to: member , x )( ? l , list : member , ? y )
By examining the condition component, it can be found x itself is included in the query solution. Therefore, a FILTER ( ? y != x ) is required to eliminate x from the result. 6.2 Query optimization Triple pattern expansion requires more time to evaluate a query. This sub-section discusses the methods for overcoming this disadvantage. The main cause of inefficient evaluation is the large graph pattern appended to the original triple pattern via UNION. Subsequent to rewriting, if the whole graph pattern is passed to the query engine, the feedback speed is unacceptable. To solve this problem, we divide the graph pattern into smaller graphs and evaluate them separately. Because the highest time requirement is associated with a deep and wide class hierarchy or a transitive property, we first evaluate sub-graph patterns that hold of the sub-graph patterns. For example, consider the following query:
The query is one of the test queries of the ontology of Guo et al. [ 8 ]. According to the ontology definition in Fig. 1 , the query is changed to:  X  = ((?x, rdf:type,Person)UNION(?x,rdf:type,?y)(?y,rdfs:subClassesOf,Person))  X  =( http://www.University0.edu , hasAlumnus, ?x)
By examining the [ start , end ] values of Person , it can be found that  X  has a large input, because Person has a wide and deep sub-classes hierarchy. If the entire graph pattern was evaluated at once, the time required would be unacceptably high. In our implementation environment (refer to Sect. 6.3 ), the evaluation requires almost 1 min to retrieve results, if no optimization is performed. To accelerate the evaluation, we decided to evaluate part  X  first, to retrieve candidate results. Then, by adopting the SPARQL function ASK ,we determined whether each candidate result satisfied  X  . If this was the case, the result was retrieved. Evaluating the query given above in this manner required only 31ms, nearly 1/200 the time of the process which was not optimized. 6.3 Implementation To test the performance of query rewriting, we implemented a prototype system comprising several components. The work-flow of the system is presented in Fig. 4 . The inference model was generated via the Pellet reasoning engine, and the original model was generated via Jena2, without using a reasoning engine. Using Jena2, Inference Rules Fetcher constructs various inference rules and saves them as XML files. When the ontology is updated, Inference Rules Fetcher is responsible for updating inference rules simultaneously. Query Rewriting Point reads inference rules from XML files and they are maintained in memory. When a user
Ontolo g y so u rce file a deep class hierarchy, the Query Rewriting Point performs optimization to accelerate query evaluation. The rewritten query is passed to the original model to retrieve result set B .We compare the completeness, soundness, and response time of A and B .

We selected the benchmark ontology created by Lehigh University [ 8 ] to test query per-formance. Besides the OWL built-in rules, a portion of inference rules developed by the ontology developer are: C D = ( a , head O f , b )( b , rdf : type , Department )  X  ( a , rdf : type , Chair ) Employee [ 1 , 28 ] , Faculty [ 2 , 21 ] , Lectur er [ 3 , 4 ] ,... } ,... } undergraduateDegreeFrom [ 2 , 3 ] , master DegreeFrom [ 4 , 5 ] , doctor al Degr ee From [ 6 , 7 ]}}
To test the loading time and ontology size, we loaded LUBM1-0 (20,659 class instances and 82,415 property instances) in the main memory. The results with respect to original model and inference model are shown in Fig. 5 . Compared to the inference model, the original model required considerably less loading time and less storage space.

We tested 14 queries in [ 8 ]. In all queries, the results were identical for both A and B , indicating that 100% completeness and soundness was achieved. A significant issue is that 100% completeness was achieved in the experiment because of the short transitive chain in the test data. If the length of transitive chain exceeds two steps, a rewritten query such as Example 7 will omit results at a deeper level. A means to prevent this incompleteness is to lengthen the query. The disadvantage of this approach is that the efficiency is reduced. Therefore, an ontology administrator will be responsible for determining the tradeoff between completeness and efficiency, according to the length of the transitive chain. The system was implemented on a desktop computer with 2.66GHz Pentium D CPU, 1GB RAM and Java SDK 1.5. Table 2 compares the query response time of rewritten, optimized and original queries. The first column denotes the number of queries. The second column presents the response time when rewritten graph patterns are evaluated without optimization. Depending on whether the query involved a wide and deep class hierarchy, some queries were optimized. Their response time is listed in the third column. The last column shows the Time (ms) the performance of the rewritten graph pattern varies relative to the original queries. Some 4, 5, 7, 8, 10, 11 and 13). However, subsequent to optimization, these inefficient queries have an obvious improvement in response time. The response time approaches that of the original query, such as Query 4, or shows a much better result, such as Queries 7, 8, 9, 10 and 13. However, Queries 5 and 11 are special cases, which have a longer response time than http://www.Department0.University0.edu ) was evaluated, many initial results were retrieved. A large number of initial results implies that more time is required to determine whether generated many initial results. Based on the above experiment, we conclude that the rewritten and optimized queries constituted promising results, and improved the response time in most cases. In the case of the query with a low selectivity, further performance improvement is needed. This issue is considered as future work.
 Via the experiment, it was found that some complicated entailments are supported by Jena2 but not by Pellet, or visa versa. This revealed that different inference models sup-port different inference rules. If an ontology administrator aims to support users with spe-cial inferences, an administrator must decide among various reasoning engines, and risk neglecting some inference rules. In our proposed system, whether an entailment is suppor-ted or not is determined by whether the query is rewritten by the corresponding C D .This methodology enables an ontology administrator to control an inference without needing to construct different ontology inference models via a reasoning engine. For example, entailment (
X ( x implicit o w l : di f f erent From between x and y . In our experiment, once we established this C D , the query was directly expanded according to it, which implies that accurate query evaluation does not need to rely on the reasoning supported by Jena2. 6.4 Combined metric comparison To compare the overall performance of our proposed system with other related systems, we tested the original queries against the inference model generated by Sesame, which is the only one that can support SPARQL besides Jena. We created a memory-based inference model and a native inference model with Sesame, and recorded the query valuation time, and the completeness and soundness of the result. Since Sesame can only support RDFS Ta b l e 3 .

Combined metric (CM) is a performance metric to determine how agile, complete, and safe a specific engine is. It was involved in the LUBM test and inspired by F-Measure. We represent the completeness and soundness of the results, respectively, for query q .  X  was used to determine the weighting of C q and S q . Our experiment set  X  to 1, which means that completeness and soundness were equally weighted. Thus, the F-Measure of q is:
Then, a combined metric, CM, of the query evaluation time, and the completeness and soundness of the results, is defined as follows:
Where M is the total number of test queries;  X  plays the same role as  X  in F q and is set to 1; P q  X  X  0 , 1 ] is defined as
T q is the evaluation time (ms) for query q ,and N is the total number of instances in the to eliminate the effects of those queries that did not terminate in the observed period. ries faster, have greater completeness, and greater soundness. We calculated the metric for Jena (reasoning with Pellet), Sesame-Memory, Sesame-Native and our proposed system. Figure 6 shows the result. We found that our proposed system achieved a higher score than all others, showing that the general performance was outstanding among the target systems. 7 Related works This section introduces several predominant ontology repositories, and discusses their fea-tures.

HAWK (derived from Project DLDB-OWL) [ 11 ] is a repository framework and tool-kit that supports OWL-DL. It provides APIs as well as implementations for parsing, editing, DIG-interfaced reasoner, such as Racer. HAWK stores class hierarchy information via views. can be inferred. HAWK does not support SPARQL but supports a Java API which enables application developers to compose atoms to construct conjunctive queries. In other words, HAWK does not support a query language interface for end users in the current version, which limits its adoption.

Sesame is an open source Java framework for storing and querying RDF data. The framework is fully extensible and configurable. The state-of-the-art Sesame offers RDFS set of Java interfaces, viz. SAIL API was specifically designed for storage and retrieval of RDFS-based information. On the retrieval side, SAIL API supports methods for querying classes and property subsumption, and domain and range restrictions. The RDFS inference tasks are internally handled in SAIL because any specific SAIL implementation has com-plete knowledge of the intrinsic storage model, such as RDBMSs, file systems (native), and memory. The main disadvantage of the current version of Sesame is its lack of support for OWL-DL.
 OWLJessKB [ 20 ] is a reasoning tool for OWL. It was based on Jena and uses Java Expert System Shell (JESS) [ 6 ] as its intrinsic reasoner. It supports reasoning of OWL Lite plus some. The OWLJessKB implementation loads multiple ontologies (the location of each is specified as a URL) in memory. Reasoning in this case involves executing one or more JESS rules over the ontology. Queries for the OWLJessKB implementation need to be specified in the JESS notation. However, OWLJessKB requires a large memory storage space, and the Hence, OWLJessKB only shows good performance over a static set of ontologies, which are not practical in real-world applications.

The OWL API [ 13 ] is a Java interface and implementation for OWL. The OWL API aims annotation tools and query agents. The latest version of the API focuses on OWL 2.0, which encompasses OWL-Lite, OWL-DL and some elements of OWL-Full. The core API does not incorporate a complete query language, since it aims to achieve a compromise between common query tasks and a pure query language, inspired by the DIG 2.0 interface and various reasoners such as Pellet, FaCT++ [ 29 ] and Racer. Consequently, SPARQL queries cannot be executedintheOWLAPI.
 Among other related works, Jena is the only ontology repository that implements OWL-DL reasoning and SPARQL queries, both of which are W3C recommendations. The stan-ries via the original ontology, rather than the inference ontology. By this means, the time required for reasoning was greatly reduced. Our experimental result shows this improve-ment. 8 Conclusions sed a method of resolving rewritten SPARQL queries in the original ontology. This approach avoids the high cost of generating and maintaining an inference ontology, and enables reuse of the original ontology among users. Although query rewriting involves increased com-plexity, the experiment proves that the proposed approach improves the performance of Jena and outperforms other similar systems via a lighter back-end model and optimized query evaluation.

Despite these benefits, several aspects of this approach need to be improved. Besides approach to other ontology repositories, and investigate the improvement for each reposi-tory.
 References Author Biographies
