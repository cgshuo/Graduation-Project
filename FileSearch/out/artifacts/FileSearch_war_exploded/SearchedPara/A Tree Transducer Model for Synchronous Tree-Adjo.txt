 Machine translation has seen a multitude of for-mal translation models. Here we focus on syntax-based (or tree-based) models. One of the old-est models is the synchronous context-free gram-mar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transduc-ers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language com-munity (G  X  ecseg and Steinby, 1984; G  X  ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes syn-chronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This character-ization eventually led to the rediscovery of ex-tended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered.

Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring transla-tion phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natu-ral language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instead of two tree homomorphisms). Such embedded tree transduc-ers (Shieber, 2006) are particular macro tree trans-ducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985).

In this contribution, we try to unify the pic-ture even further. We will develop a tree trans-ducer model that can simulate STAGs. It turns out that the adjunction operation of an STAG can be explained easily by explicit substitution. In this sense, the slogan that an STAG is an STSG with adjunction, which refers to the syntax, also trans-lates to the semantics. We prove that any tree transformation computed by an STAG can also be computed by an STSG using explicit substitution. Thus, a simple evaluation procedure that performs the explicit substitution is all that is needed to sim-ulate an STAG in a toolkit for STSGs or extended tree transducers like T IBURON by May and Knight (2006).
 We show that some standard algorithms on STAG can actually be run on the constructed STSG, which often is simpler and better under-stood. Further, it might be easier to develop new algorithms with the alternative characterization, which we demonstrate with a product construc-tion for input restriction in the spirit of Neder-hof (2009). Finally, we also present a complete tree transducer model that is as powerful as STAG, which is an extension of the embedded tree trans-ducers of Shieber (2006). We quickly recall some central notions about trees, tree languages, and tree transformations. For a more in-depth discussion we refer to G  X  ecseg and Steinby (1984) and G  X  ecseg and Steinby (1997). A finite set  X  of labels is an alphabet. The set of all strings over that alphabet is  X   X  where  X  denotes the empty string. To simplify the presentation, we assume an infinite set X = { x 1 ,x 2 ,... } of vari-ables. Those variables are syntactic and represent only themselves. In particular, they are all differ-ent. For each k  X  0 , we let X k = { x 1 ,...,x k } . We can also form trees over the alphabet  X  . To allow some more flexibility, we will also allow leaves from a special set V . Formally, a  X  -tree over V is either:  X  a leaf labeled with an element of v  X   X   X  V ,  X  a node that is labeled with an element of  X  The set of all  X  -trees over V is denoted by T  X  ( V ) . We just write T  X  for T  X  (  X  ) . The trees in Figure 1 are, for example, elements of T  X  ( Y ) where We often present trees as terms. A leaf labeled v is simply written as v . The tree with a root node labeled  X  is written  X  ( t 1 ,...,t k ) where t 1 ,...,t k are the term representations of its k children.
A tree language is any subset of T  X  ( V ) for some alphabet  X  and set V . Given another al-phabet  X  and a set Y , a tree transformation is a relation  X   X  T  X  ( V )  X  T  X  ( Y ) . In many of our examples we have V =  X  = Y . Occasionally, we also speak about the translation of a tree trans-formation  X   X  T  X   X  T  X  . The translation of  X  is the relation { (yd( t ) , yd( u )) | ( t,u )  X   X  } where yd( t ) , the yield of t , is the sequence of leaf labels in a left-to-right tree traversal of t . The yield of the third tree in Figure 1 is  X  X he N saw the N X . Note that the translation is a relation  X  0  X   X   X   X   X   X  . A standard operation on (labeled) trees is substitu-tion , which replaces leaves with a specified label in one tree by another tree. We write t [ u ] A for (the result of) the substitution that replaces all leaves labeled A in the tree t by the tree u . If t  X  T  X  ( V ) and u  X  T  X  ( Y ) , then t [ u ] A  X  T  X   X   X  ( V  X  Y ) . We often use the variables of X = { x 1 ,x 2 ,... } as substitution points and write t [ u 1 ,...,u k ] instead of (  X  X  X  ( t [ u 1 ] x 1 ) ... )[ u k ] x An example substitution is shown in Figure 1. The figure also illustrates a common problem with substitution. Occasionally, it is not desirable to re-place all leaves with a certain label by the same tree. In the depicted example, we might want to replace one  X  X P X  by a different tree, which cannot be achieved with substitution. Clearly, this problem is avoided if the source tree t con-tains only one leaf labeled A . We call a tree A -proper if it contains exactly one leaf with label A . 2 The subset C  X  ( X k )  X  T  X  ( X k ) contains exactly those trees of T  X  ( X k ) that are x i -proper for every 1  X  i  X  k . For example, the tree t of Figure 1 is  X  X aw X -proper, and the tree u of Figure 1 is  X  X he X -and  X  X  X -proper.

In this contribution, we will also use substitu-tion as an explicit operator. The tree t [ u ] NP in Figure 1 only shows the result of the substitution. It cannot be infered from the tree alone, how it was obtained (if we do not know t and u ). 3 To make substitution explicit, we use the special bi-nary symbols  X  [  X  ] A where A is a label. Those sym-bols will always be used with exactly two chil-dren (i.e., as binary symbols). Since this prop-erty can easily be checked by all considered de-vices, we ignore trees that use those symbols in a non-binary manner. For every set  X  of labels, we let  X  =  X   X  { X  [  X  ] A | A  X   X  } be the extended set of labels containing also the substition sym-bols. The substitution of Figure 1 can then be ex-(the right-most tree in Figure 1), we have to evalu-ate  X  [  X  ] NP ( t,u ) . However, we want to replace only one leaf at a time. Consequently, we restrict the evaluation of  X  [  X  ] A ( t,u ) such that it applies only to trees t whose evaluation is A -proper. To enforce this restriction, we introduce an error signal  X  , which we assume not to occur in any set of la-bels. Let  X  be the set of labels. Then we define the function  X  E : T  X   X  T  X   X  X  X } by 4  X  ( t 1 ,...,t k ) E =  X  ( t E 1 ,...,t E k ) for every k  X  0 ,  X   X   X  , and t,t 1 ,...,t k ,u  X  T  X  . 5 We generally discard all trees that contain the er-ror signal  X  . Since the devices that we will study later can also check the required A -properness us-ing their state behavior, we generally do not dis-cuss trees with error symbols explicitly. An extended tree transducer is a theoretical model that computes a tree transformation. Such trans-ducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine trans-lation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution gram-mars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices.

Let us recall the formal definition. An ex-tended tree transducer (for short: XTT) 6 is a sys-tem M = ( Q,  X  ,  X  ,I,R ) where  X  Q is a finite set of states ,  X   X  and  X  are alphabets of input and output  X  I  X  Q is a set of initial states , and  X  R is a finite set of rules of the form Figure 2: Example rules taken from Graehl et al. (2009). The term representation of the first rule is ( q S , S ( x 1 , VP ( x 2 ,x 3 )))  X  ( w, S 0 ( x 2 ,x where w = q NP q V q NP .
Recall that any tree of C  X  ( X k ) contains each variable of X k = { x 1 ,...,x k } exactly once. In graphical representations of a rule we usually  X  add the state q as root node of the left-hand  X  add the states q 1 ,...,q k on top of the nodes Some example rules are displayed in Figure 2.
The rules are applied in the expected way (as in a term-rewrite system). The only additional fea-ture are the states of Q , which can be used to con-trol the derivation. A sentential form is a tree that contains exclusively output symbols towards the root and remaining parts of the input headed by a state as leaves. A derivation step starting from  X  then consists in  X  selecting a leaf of  X  with remaining input  X  matching the state q and the left-hand side l  X  replacing all the variables x 1 ,...,x k in the  X  replacing the selected leaf in  X  by the tree The process is illustrated in Figure 3.

Formally, a sentential form of the XTT M is a tree of SF = T  X  ( Q ( T  X  )) where Figure 3: Illustration of a derivation step of an XTT using the left rule of Figure 2.
 Given  X , X   X  SF , we write  X   X   X  if there ex-ist C  X  C  X  ( X 1 ) , t 1 ,...,t k  X  T  X  , and a rule ( q,l )  X  ( q 1  X  X  X  q k ,r )  X  R such that  X   X  = C [ q ( l [ t 1 ,...,t k ])] and  X   X  = C [ r [ q 1 ( t 1 ) ,...,q k ( t k )]] . The tree transformation computed by M is the re-lation  X 
M = { ( t,u )  X  T  X   X  T  X  | X  q  X  I : q ( t )  X  where  X   X  is the reflexive, transitive closure of  X  . In other words, the tree t can be transformed into u if there exists an initial state q such that we can derive u from q ( t ) in several derivation steps.
We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. XTT are a simple, natural model for tree trans-formations, however they are not suitably ex-pressive for all applications in machine transla-tion (Shieber, 2007). In particular, all tree trans-formations of XTT have a certain locality condi-tion, which yields that the input tree and its corre-sponding translation cannot be separated by an un-bounded distance. To overcome this problem and certain dependency problems, Shieber and Sch-abes (1990) and Shieber (2007) suggest a stronger model called synchronous tree-adjoining gram-mar (STAG), which in addition to the substitution operation of STSG (Chiang, 2005) also has an ad-joining operation.

Let us recall the model in some detail. A tree-adjoining grammar essentially is a regular tree grammar (G  X  ecseg and Steinby, 1984; G  X  ecseg and Figure 4: Illustration of an adjunction taken from Nesson et al. (2008).
 Figure 5: Illustration of the adjunction of Figure 4 using explicit substitution.
 Steinby, 1997) enhanced with an adjunction oper-ation. Roughly speaking, an adjunction replaces a node (not necessarily a leaf) by an auxiliary tree , which has exactly one distinguished foot node . The original children of the replaced node will be-come the children of the foot node after adjunc-tion. Traditionally, the root label and the label of the foot node coincide in an auxiliary tree aside from a star index that marks the foot node. For example, if the root node of an auxiliary tree is labeled A , then the foot node is traditionally la-beled A ? . The star index is not reproduced once adjoined. Formally, the adjunction of the auxil-iary tree u with root label A (and foot node la-bel A ? ) into a tree t = C [ A ( t 1 ,...,t k )] with C  X  C  X  ( X 1 ) and t 1 ,...,t k  X  T  X  is Adjunction is illustrated in Figure 4.

We note that adjunction can easily be expressed using explicit substitution. Essentially, only an ad-ditional node with the adjoined subtree is added. The result of the adjunction of Figure 4 using ex-plicit substitution is displayed in Figure 5.
To simplify the development, we will make some assumptions on all tree-adjoining grammars (and synchronous tree-adjoining grammars). A tree-adjoining grammar (TAG) is a finite set of initial trees and a finite set of auxiliary trees. Our initial Figure 6: A TAG for the copy string language { wcw | w  X  X  a,b }  X  } taken from Shieber (2006). TAG do not use substitution, but only adjunction. A derivation is a chain of trees that starts with an initial tree and each derived tree is obtained from the previous one in the chain by adjunction of an auxiliary tree. As in Shieber (2006) we assume that all adjunctions are mandatory; i.e., if an aux-iliary tree can be adjoined, then we need to make an adjunction. Thus, a derivation starting from an initial tree to a derived tree is complete if no ad-junction is possible in the derived tree. Moreover, we assume that to each node only one adjunction can be applied. This is easily achieved by label-ing the root of each adjoined auxiliary tree by a special marker. Traditionally, the root label A of an auxiliary tree is replaced by A  X  once adjoined. Since we assume that there are no auxiliary trees with such a root label, no further adjunction is pos-sible at such nodes. Another effect of this restric-tion is that the number of operable nodes (i.e., the nodes to which an adjunction must still be applied) is known at any given time. 8 A full TAG with our restrictions is shown in Figure 6.

Intuitively, a synchronous tree-adjoining gram-mar (STAG) is essentially a pair of TAGs. The synchronization is achieved by pairing the initial trees and the auxiliary trees. In addition, for each such pair ( t,u ) of trees, there exists a bijection be-tween the operable nodes of t and u . Such nodes in bijection are linked and the links are preserved in derivations, in which we now use pairs of trees as sentential forms. In graphical representations we often indicate this bijection with integers; i.e., two nodes marked with the same integer are linked. A pair of auxiliary trees is then adjoined to linked nodes (one in each tree of the sentential form) in the expected manner. We will avoid a formal def-inition here, but rather present an example STAG and a derivation with it in Figures 7 and 8. For a
T c S Figure 7: STAG that computes the translation { ( wcw R ,wcw ) | w  X  { a,b }  X  } where w R is the reverse of w .
 STAG G we write  X  G for the tree transformation computed by G . In this section, we will present our main result. Es-sentially, it states that a STAG is as powerful as a STSG using explicit substitution. Thus, for every tree transformation computed by a STAG, there is an extended tree transducer that computes a repre-sentation of the tree transformation using explicit substitution. The converse is also true. For every extended tree transducer M that uses explicit sub-stitution, we can construct a STAG that computes the tree transformation represented by  X  M up to a relabeling (a mapping that consistently replaces node labels throughout the tree). The additional relabeling is required because STAGs do not have states. If we replace the extended tree transducer by a STSG, then the result holds even without the relabeling.
 Theorem 1 For every STAG G , there exists an ex-tended tree transducer M such that Conversely, for every extended tree transducer M , there exists a STAG G such that the above relation holds up to a relabeling. 6.1 Proof sketch The following proof sketch is intended for readers that are familiar with the literature on embedded tree transducers, macro tree transducers, and bi-morphisms. It can safely be skipped because we will illustrate the relevant construction on our ex-ample after the proof sketch, which contains the outline for the correctness. S
T c a b  X 
Let  X   X  T  X   X  T  X  be a tree transformation computed by a STAG. By Shieber (2006) there exists a regular tree language L  X  T  X  and two functions e 1 : T  X   X  T  X  and e 2 : T  X   X  T  X  such that  X  = { ( e 1 ( t ) ,e 2 ( t )) | t  X  L } . Moreover, e 1 and e 2 can be computed by embedded tree transducers (Shieber, 2006), which are particu-lar 1 -state, deterministic, total, 1 -parameter, lin-ear, and nondeleting macro tree transducers (Cour-celle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In fact, the converse is also true up to a relabeling, which is also shown in Shieber (2006). The outer part of Figure 9 illustrates these relations. Finally, we remark that all involved con-structions are effective.

Using a result of Engelfriet and Vogler (1985), each embedded tree transducer can be decom-posed into a top-down tree transducer (G  X  ecseg and Steinby, 1984; G  X  ecseg and Steinby, 1997) and a yield-mapping. In our particular case, the top-down tree transducers are linear and nondelet-ing homomorphisms h 1 and h 2 . Linearity and nondeletion are inherited from the corresponding properties of the macro tree transducer. The prop-erties  X  1 -state X ,  X  X eterministic X , and  X  X otal X  of the macro tree transducer ensure that the obtained top-down tree transducer is also 1 -state, determinis-tic, and total, which means that it is a homomor-phism. Finally, the 1 -parameter property yields that the used substitution symbols are binary (as our substitution symbols  X  [  X  ] A ). Consequently, the yield-mapping actually coincides with our evalua-tion. Again, this decomposition actually is a char-acterization of embedded tree transducers. Now the set { ( h 1 ( t ) ,h 2 ( t )) | t  X  L } can be computed by an extended tree transducer M due to results of Shieber (2004) and Maletti (2008). More pre-cisely, every extended tree transducer computes such a set, so that also this step is a characteri-zation. Thus we obtain that  X  is an evaluation of a tree transformation computed by an extended tree transducer, and moreover, for each extended tree transducer, the evaluation can be computed (up to a relabeling) by a STAG. The overall proof struc-ture is illustrated in Figure 9. 6.2 Example Let us illustrate one direction (the construction of the extended tree transducer) on our example STAG of Figure 7. Essentially, we just prepare all operable nodes by inserting an explicit substitu-tion just on top of them. The first subtree of that substitution will either be a variable (in the left-hand side of a rule) or a variable headed by a state (in the right-hand side of a rule). The numbers of the variables encode the links of the STAG. Two example rules obtained from the STAG of Figure 7 are presented in Figure 10. Using all XTT rules constructed for the STAG of Figure 7, we present a complete derivation of the XTT in Figure 11 that (up to the final step) matches the derivation of the STAG in Figure 8. The matching is achieved by the evaluation  X  E introduced in Section 3 (i.e., ap-plying the evaluation to the derived trees of Fig-ure 11 yields the corresponding derived trees of Figure 8. In this section, we will discuss a few applications of our main result. Those range from representa-tional issues to algorithmic problems. Finally, we also present a tree transducer model that includes explicit substitution. Such a model might help to address algorithmic problems because derivation and evaluation are intertwined in the model and not separate as in our main result. 7.1 Toolkits Obviously, our characterization can be applied in a toolkit for extended tree transducers (or STSG) such as T IBURON by May and Knight (2006) to simulate STAG. The existing infrastructure (input-output, derivation mechanism, etc) for extended tree transducers can be re-used to run XTTs en-coding STAGs. The only additional overhead is the implementation of the evaluation, which is a straightforward recursive function (as defined in Section 3). After that any STAG can be simulated in the existing framework, which allows experi-ments with STAG and an evaluation of their ex-pressive power without the need to develop a new toolkit. It should be remarked that some essential algorithms that are very sensitive to the input and output behavior (such as parsing) cannot be sim-ulated by the corresponding algorithms for STSG. It remains an open problem whether the close rela-tionship can also be exploited for such algorithms. 7.2 Algorithms We already mentioned in the previous section that some algorithms do not easily translate from STAG to STSG (or vice versa) with the help of our characterization. However, many standard al-gorithms for STAG can easily be derived from the corresponding algorithms for STSG. The sim-plest example is the union of two STAG. Instead of taking the union of two STAG using the clas-sical construction, we can take the union of the corresponding XTT (or STSG) that simulate the STAGs. Their union will simulate the union of the STAGs. Such properties are especially valuable when we simulate STAG in toolkits for XTT.

A second standard algorithm that easily trans-lates is the algorithm computing the n -best deriva-tions (Huang and Chiang, 2005). Clearly, the n -best derivation algorithm does not consider a par-ticular input or output tree. Since the derivations of the XTT match the derivations of the STAG (in the former the input and output are encoded using explicit substitution), the n -best derivations will coincide. If we are additionally interested in the input and output trees for those n -best deriva-tions, then we can simply evaluate the coded input and output trees returned by n -best derivation al-gorithm.

Finally, let us consider an algorithm that can be obtained for STAG by developing it for XTT us-ing explicit substitution. We will develop a B AR -H ILLEL (Bar-Hillel et al., 1964) construction for STAG. Thus, given a STAG G and a recognizable tree language L , we want to construct a STAG G 0 such that In other words, we take the tree transformation  X  G but additionally require the input tree to be in L . Consequently, this operation is also called input restriction . Since STAG are symmetric, the corre-sponding output restriction can be obtained in the same manner. Note that a classical B AR -H ILLEL construction restricting to a regular set of yields can be obtained easily as a particular input restric-tion. As in Nederhof (2009) a change of model is beneficial for the development of such an algo-rithm, so we will develop an input restriction for XTT using explicit substitution.

Let M = ( Q,  X  ,  X  ,I,R ) be an XTT (using ex-plicit substitution) and G = ( N,  X  ,I 0 ,P ) be a tree substitution grammar (regular tree grammar) in normal form that recognizes L (i.e., L ( G ) = L ). Let S = { A  X   X  | X  [  X  ] A  X   X  } . A context is a map-ping c : S  X  N , which remembers a nontermi-nal of G for each substitution point. Given a rule ( q,l )  X  ( q 1  X  X  X  q k ,r )  X  R , a nonterminal p  X  N , and a context c  X  S , we construct new rules cor-responding to successful parses of l subject to the following restrictions:  X  If l =  X  [  X  ] A ( l 1 ,l 2 ) for some A  X   X  , then se- X  If l = A ? with A  X   X  , then p = c ( A ) .  X  Finally, if l =  X  ( l 1 ,...,l k ) for some  X   X   X  , 7.3 A complete tree transducer model So far, we have specified a tree transducer model that requires some additional parsing before it can be applied. This parsing step has to annotate (and correspondingly restructure) the input tree by the adjunction points. This is best illustrated by the left tree in the last pair of trees in Figure 8. To run our constructed XTT on the trivially completed version of this input tree, it has to be transformed into the first tree of Figure 11, where the adjunc-tions are now visible. In fact, a second un-parsing step is required to evaluate the output.

To avoid the first additional parsing step, we will now modify our tree transducer model such that this parsing step is part of its semantics. This shows that it can also be done locally (instead of globally parsing the whole input tree). In addition, we arrive at a tree transducer model that exactly (up to a relabeling) matches the power of STAG, which can be useful for certain constructions. It is known that an embedded tree transducer (Shieber, 2006) can handle the mentioned un-parsing step.
An extended embedded tree transducer with substitution M = ( Q,  X  ,  X  ,I,R ) is simply an embedded tree transducer with extended left-hand sides (i.e., any number of input symbols is allowed in the left-hand side) that uses the special sym-bols  X  [  X  ] A in the input. Formally, let  X  Q = Q 0  X  Q 1 be finite where Q 0 and Q 1  X   X  and  X  be ranked alphabets such that if  X  Q  X  U  X  be such that  X  I  X  Q  X  T  X   X  , and  X  R is a finite set of rules l  X  r such that there We refer to Shieber (2006) for a full description of embedded tree transducers. As seen from the syntax, we write the context parameter y of a state q  X  Q 1 as q  X  y  X  . If q  X  Q 0 , then we also write q  X  X  or q  X   X   X  . In each right-hand side, such a context parameter u can contain output symbols and further calls to input subtrees. The semantics of extended embedded tree transducers with sub-stitution deviates slightly from the embedded tree transducer semantics. Roughly speaking, not its rules as such, but rather their evaluation are now applied in a term-rewrite fashion. Let Figure 12: Rule and derivation step using the rule in an extended embedded tree transducer with sub-stitution where the context parameter (if present) is displayed as first child. where  X   X   X  k , q 1  X  Q 1 , q 0  X  Q 0 , and t  X  T  X  . Given  X , X   X  SF 0 , we write  X   X   X  if there exist C  X  C  X  ( X 1 ) , t 1 ,...,t k  X  T  X  , u  X  T  X   X  X   X  } , and a rule q  X  u  X  ( l )  X  r  X  R 10 with l  X  C  X  ( X k ) such that  X   X  = C [ q  X  u  X  ( l [ t 1 ,...,t k ] E )] and  X   X  = C [( r [ t 1 ,...,t k ])[ u ] y ] .
 Note that the essential difference to the  X  X tan-dard X  semantics of embedded tree transducers is the evaluation in the first item. The tree transfor-mation computed by M is defined as usual. We illustrate a derivation step in Figure 12, where the cessful for x 1 = S ( S ? ) .
 Theorem 2 Every STAG can be simulated by an extended embedded tree transducer with substi-tution. Moreover, every extended embedded tree transducer computes a tree transformation that can be computed by a STAG up to a relabeling. We presented an alternative view on STAG us-ing tree transducers (or equivalently, STSG). Our main result shows that the syntactic characteri-zation of STAG as STSG plus adjunction rules also carries over to the semantic side. A STAG tree transformation can also be computed by an STSG using explicit substitution. In the light of this result, some standard problems for STAG can be reduced to the corresponding problems for STSG. This allows us to re-use existing algo-rithms for STSG also for STAG. Moreover, exist-ing STAG algorithms can be related to the corre-sponding STSG algorithms, which provides fur-ther evidence of the close relationship between the two models. We used this relationship to develop a B
AR -H ILLEL construction for STAG. Finally, we hope that the alternative characterization is easier to handle and might provide further insight into general properties of STAG such as compositions and preservation of regularity.
 A
NDREAS M ALETTI was financially supported by the Ministerio de Educaci  X  on y Ciencia (MEC) grant JDCI-2007-760.

