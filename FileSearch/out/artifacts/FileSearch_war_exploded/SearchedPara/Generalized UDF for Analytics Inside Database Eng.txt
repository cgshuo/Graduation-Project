 latency is to have the data intensive part of analytics executed inside the DB engine. 
There exist two kinds of efforts for integrating applications and data management: as (a) running database programs including stored procedures on server-side but out-side the query evaluation process; and (b) wrapping computations by UDFs executed in the query processing environment [1-4,11]. Although both offer the benefit of hav-ing computations close to data, compared with the UDF approach, running data-vantage of the scale-out infrastructure inherent in a parallel database system. 1.1 Limitations of Existent UDFs an aggregate function is actually implemented as incremental per-tuple manipulations; these UDFs lack formal support to relational input. However, in addition to per-tuple have the moderately-sized input relations cached in a UDF without repeated retrieval can provide significant performance advantage. In fact, some applications are difficult to implement without the presence of whole relations (such as minimal spanning tree multi-cores or GPUs, feeding in a UDF a set of tuples initially, rather than one tuple tion-out UDFs. 1.2 Related Work on the database server-side, but not really integrating them with query processing. As a result, the overhead caused by IPC, ODBC, and data copying is still significant. 
Integrating applications with query proce ssing with UDFs has been recognized as a data-intensive analytics [1,6] However, the UDF limitations in both performance and database engines support scalar, aggregate and table UDFs but has limited such sup-UDF closure has become more feasible. able on the entire content of these relations. previously [5,13], the notion of relation-in, relation-out UDF has not been supported systematically; and these are the focus of this paper. 1.3 Our Solution mentation issues. 
A generalized UDF can have scalar and relation parameters where a scalar parame-UDF, aggregate UDF, TVF of SQL Server and Table Function of Oracle. This gener-alization offers the following benefits:  X  ples;  X 
Expressing relational transformations, composing UDFs with other relational op-erators in a query (Fig. 1) and linking multiple queries in an application dataflow.  X  e.g. caching in memory some moderate-sized dimension tables with respect to the per-tuple processing of a sizable fact table. We then introduce the notion of UDF invocation pattern based on the combination of input and output modes. A UDF is invoked within a query; a UDF invocation pattern hybrid way. Multiple invocation patterns can be identified and supported accordingly propriate system support. 
We have taken the open-sourced PostgreSQL engine and a commercial and pro-prietary parallel database engine as our prototyping vehicles for supporting the gener-alized UDFs. We illustrate the performance, modeling power and usability of the pro-posed approach with the experimental results on both platforms. UDFs with experimental results; Section 3 de scribes the generalization of UDFs; Section experimental results on a parallel database engine; Section 6 concludes the paper. logic, and in gaining high performance. The k -means algorithm was developed by J. MacQueen in 1967 and then by J. A. objective is to minimize the total intra-cluster variance. calculated as the  X  X ean X  of the coordinates of its member points. If new locations of repeated, as illustrated in Fig. 2. 
Now let us focus on expressing a single iteration of the K-Means clustering in SQL with UDFs. In the above two phases, the first phase is for each point in relation Points sign the point to the closest center. The second phase is to re-compute the set of new single iteration as KM1 . 2.1 Using Scalar UDF I n SQL with a scalar UDF, KM1 can be expressed as [Query 0: Scalar UDF] The plan of Query 0 is illustrated in Fig 3, where the nearest center for each point is input argument and cache it initially, the relation Centers has to be retrieved for each point p; furthermore, it has to be retrieved in a nested query as well (Query Optimizer turns it to join) , for the MIN distance from p to centers. points. 2.2 Using SQL Server TVF/CROSS APPLY A SQL Server TVF allows table valued return but restricts its input values to be sca-lar. To apply a TVF to multiple tuples of a relation, a kind of join  X  CROSS APPLY, is required. With SQL Server CROSS APPLY, KM1 can be expressed as tion input, a TVF has to rely on CROSS APPLY to access the set of tuples in a rela-tion, which in turn, leads to Cartesian product complexity. It can be seen in the above query that the per-point repeated retrieval of relation Centers is not eliminated regard-formance penalty. 2.3 Using Oracle TABLE Function With Oracle TABLE function, KM1 can be expressed as To the kind of applications like K-Means, this has the same problem as using CROSS APPLY  X  it also relies on cumbersome Cartesian product operations for pairing tuples thus is also inefficient. 2.4 Using Generalized UDF relation input argument bound to the entire relation of Centers, KM1 can be expressed by the following query. In this query, the relation Centers is retrieved only once in the beginning and cached without repeated retrieval of the Centers relation and join operation, the performance gain is significant. initially and buffered in the UDF X  X  closure, hence unnecessary to be re-loaded in sub-scalar function or SQL expression, where the centers must be retrieved repeatedly for each point, and even worse, repeatedly retrieved for each center to compare its distance kept in SQL). Such overhead is added to processing each point and is proportional to the number of points , which could be very serious if the number of points is large. 2.5 Performance Comparison of Generalized and Conventional UDFs SQL Server TVF/CROSS APPLY, and Oracle Table Function, in running KM1 on a differences in query shapes, the performance of using the regular scalar UDF has bet-ter performance than using TVF/CROSS APPLY and Oracle Table Function. There-against using the conventional scalar UDF for KM1 computation. running Linux 2.6.18-92.1.13.el5 (x86_64). The Performance comparison is illus-trated in Fig. 4. 
It can be seen that implementing KM1 using a Generalized UDF significantly intelligently alleviate the shortcomings of SQL being cumbersome in expressing data numerous repeated retrievals of that relation on the per-point basis. 
We also compared the query performance for other applications using different kinds of UDFs. These experiments have provided the justification for us to generalize the notion of UDF. As discussed thus far, we see that a scalar function or a table valued function (TVF of SQL Server or Table Function of Oracle) can only take scalar input arguments corre-which leads to the limitations in both modelling power and performance. tuple, or a entire relation (a table or a query result). A generalized UDF can return a UDF may have the following three kinds of argument bindings: 
A scalar argument may fall in either t-bind ing or constant binding. These are illus-trated in Fig.5. that relation. For an R-binding, the corresponding relation is initially fetched, or gen-erated as the result of a query, and retained in the UDF closure for a single call (Fig 6a) or across multiple calls (Fig. 6b). Note that the combination of input/output modes has certain dependency as well as constraint, depending on where the UDF is located in a query, e.g. in the SELECT list, the FROM list, etc. 
This generalization offers the following benefits.  X  Modeling the kind of applications definable on the entire contents of some rela- X  Caching input relations initially to avoid repeated retrieval. 
The relation schemas denote the  X  X chema-aware X  signature of udf2 , the actual rela-actual parameters. 
In the following query on a sizable fact table F and moderately-sized dimension ta-D called multiple times in the query, one for each tuple in F . tions of D1, D2 and D3. So this UDF is invoked tuple-by-tuple wrt F, but with D1, D2, D3 loaded in the first call as static initial data. When this UDF is invoked, each tuple of F is manipulated with all the instances of D1, the memory, repeated retrieval of them can be avoided, which indeed opens the potential still can be ensured by reusing the database cache management facility. 
We also define three return modes: Scalar, Tuple and Set. With the tuple return mode, 
Distinguishing these function invocation modes is the key to efficiently integrating function execution with query processing. 
Below we express the K-Means calculation in a single iteration (KM1) by two kinds of generalized UDFs, one takes the entire Points and Centers relations as input, another caches in the small-size Centers relation, and applies to the Points on the tu-ple-by-tuple basis. 
In the Query 1 sown below, the UDF assign_center1 takes the entire Points and Cen-ters relations as input (Fig. 7). [Query 1: UDF with block input and output] ters relation, and applies to the Points on the tuple-by-tuple basis (Fig. 8). [Query 2: UDF with mixed types of inputs] 
The generalized UDF assign_center2 (P.x, P.y,  X  X ELECT x,y,cid FROM Centers X ) per-point processing. both relations cached in actually over-performs, but a sizable Points relation may ex-ceed the memory limit, and therefore Query 2 is more scalable. We extended the query engine to support generalized UDFs with relation parameters, in addition to other types of input parameters. Our focus is placed on UDF invocation (analogous to the build-site of hash-join), that relation must be entirely cached in be-fore any data can be returned. In general, the invocation pattern of a generalized UDF handle the input/output data. 
Like other relational operators, a function, e.g. a UDF, executed in a query may be called multiple times, one for each returned value. The initial data used for every call and the carry-on data across calls, are handled by the query executor through a func-with three cases: FIRST_CALL, NORMAL_CALL and LAST_CALL. The FIRST_CALL is executed only once in the first time the UDF is called in the hosting checks the end-of-data condition for determining the execution. Accordingly, memory ecutor, switching memory context is often necessary. 
Based on this framework, on the extended PostgreSQL engine we handle the input arguments in the following way.  X 
R-binding is made in the FIRST_CALL where input relations are retrieved through together with other initial data to be carried-on across multiple calls.  X  t-binding is made in each NORMAL_CALL with respect to one input tuple (or input relation must be the join of these relations. 
The output arguments are handled in the following way.  X 
Tuple-Mode return is handled in each (can be only one) NORMAL_CALL with the first resulting tuple returned.  X  Set-Mode is handled in the LAST_CALL with the entire result-set returned. engine in the following way.  X 
When a generalized UDF, say F , is defined, the information about its name, argu-ments, input mode, return mode, dll entry-point, etc, is registered into several meta-tables to be retrieved for executing F .  X  corresponding ones (such as Postgres fcinfo ) used in the query executor. The han-
The handle for invocation context ( hC ) is used to control the execution of the UDF provided context known as scratchpad for retaining certain application data be-tween calls, and a pointer to hARG , a data structure generated from F  X  X  definition for keeping actual argument values across calls.  X 
During function execution, the extended query engine uses several system func-tions and macros to manipulate these handle structures. Further, we advocate a  X  X anonical X  appro ach to UDF development: coding the appli-generated header files and used in the  X  user-function  X . The UDF is made by plugging the  X  user-function  X  to the Shell. We also used a commercial and proprietary parallel database engine (HP Neoview) as generalized UDF is extended from the parallel query processors. The dll code of the UDF is made available on each node. Therefore, within a given query execution mul-throughout the cluster. 
We conducted the experiments using the K-means application. The UDF as-computing the distance between a point p and a center c , shown in query 0 . dimensions and 100 centers. The performance comparison is shown below. picted in Fig. 10 
Our solution scales linearly from 1M to 200M points, and significantly outperforms running K-Means using the conventional UDFs. The reason becomes clear by observ-ing the query plans shown before. gether in the UDF forced the engine to perform multiple joins and send data of Points and Centers across multiple query processors multiple times. The generalized UDF, in partial aggregation to the global query processor. 
We ran the above query using the generalized UDF with different data load (num-reveal that our solution scales linearly from 1M to 200M points, which is not possible with the conventional client programming or pure SQL. We also compared the performance of the above parallel database engine with the Hadoop MapReduce engine [10,12] and reported some results in [6] which has pro-formance gain and scalability. allowing a UDF to input entire relations initially for enhanced expressive power and per-formance. We also provided focused system support for efficiently integrating UDF exe-
We have taken the open-sourced PostgreSQL engine and a commercial and pro-prietary parallel database engine as our prototyping vehicles for supporting the gener-posed approach has been proven by the experimental results on both platforms. 
We are continuing the development of memory conscious UDF computation that automatically places data in the memory hierarchy including GPU cache, CPU cache, main memory and disk in the way transparent to UDF developers. 
