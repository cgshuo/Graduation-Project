 Most  X  X raditional X  incentive mechanis ms used by companies today [1] have been developed for static business processes, where the actors are legally bound to the company (employees, workers), placed under human management and assigned to specific workflow activities, usually for a longer time period. Such setting allows direct monitoring of workers and subsequent direct application and adap-tation of incentive mechanisms.

However, with the advent of novel, web -scale collaborati ve systems and col-laborative patterns, starting from crowdsourcing, and moving towards the ever more complex socio-technica l collaborative systems 1 , we witnessed the actors in the system become numerous, anonymous and interchangeable with machines. They now engage with the system only occasionally, irregularly and for a short time, performing different tasks with variable duration and quality. This means that most existing incentives, relying on the conventional understanding of the notions of career, promotion and working hours cannot effectively support this new type of collaborations.

In [3] we proposed adapting conventional incentive mechanisms to the new collaboration forms, and providing programmable incentive management func-tionalities to the information systems supporting them. In this paper we present some of the fundamental building elements of a framework for programmable incentive management in information systems  X  PRINC. These elements allow modeling, programming, execution, monitoring and reuse of various incentive mechanisms on top of existing workforce management and collaboration plat-forms. We carry out a functional design evaluation by illustrating modeling and composing capabilities of a prototype implementation on realistic incentive sce-narios.

The paper is structured as follows. Rel ated and background work is presented in Section 2. Section 3 introduces the main functionalities and the overall archi-tecture of the PRINC framework. Section 4 discusses in more detail individual framework components and their design considerations. Section 5 evaluates the functionality and usefulness of the presented design by encoding an exemplary, realistic incentive strategy. Section 6 concludes the paper and presents the di-rection of our future work. 2.1 Related Work Most related work in the general area of rewarding and incentives originates from economics, game theory, organizational science and psychology. Incentives are the principal mechanism for aligning interests of business owners and work-ers. As a single incentive always target s a specific behavior and induces unwanted responses from workers [4], multiple incentives are usually combined to counter-act the dysfunctional behavior and produce wanted results. Opportunities for dysfunctional behavior increase with the complexity of labor, and so does the need to use and combine multiple incentives. The principal economic theory treating incentives today is the Agency Theory [4,5]. The paper [1] presents a comprehensive review and comparison of different incentive strategies in tradi-tional businesses.

Only a limited number of computer scie nce papers treat these topics, and usually within particular, application-specific contexts, like peer-to-peer net-works, agent-based systems and human-labor platforms (e.g., Amazon Mechan-ical Turk). In [6] the aim is to maximize p2p content sharing. In [7] the authors seek to maximize the extension of social network by motivating people to in-vite others to visit more content. In [8] the authors try to determine quality of crowdsourced work when a task is done i teratively compared to when it is done in parallel. In [9] the authors investigate how different monetary rewards influ-ence the productivity of mTurkers. In [10] the authors analyze two commonly used approaches to detect cheating and properly validate submitted tasks on popular crowdsourcing platforms. A detailed overview of incentive and reward-ing practices in social computing today can be found in [3,11]. The key finding is that incentives in use in today X  X  social computing platforms are mostly limited to simple piece-rates that may be suited for simple task processing, but are in-appropriate for the more advanced collaborative efforts. All these studies show that, depending on the environment, there always exist types of incentives that can provide the necessary motivation, and that incentive composition is the key to a successful local application o f general incentive practices.

In contrast to the described work, whi ch focuses on specific application sce-narios, we propose developing general models and techniques for programmable incentive management. To the best of our knowledge, there exist no other similar comprehensive approaches. 2.2 Background The work presented in this paper is part of the ongoing effort to conceptualize a general approach to model and encode most of the incentive mechanisms for use in social computing environment today [3]. Currently, for every social computing system a context-specific, tailored incenti ve functionality is developed anew. This is a clear overhead, as most incentive strategies could be composed out of a limited number of reusable, basic elements and then tweaked to fit a specific application area. In particular, this paper builds upon the important concepts introduced in [12].

The Rewarding Model ( RMod ) is a low-level, abstract model for representing the state of a social computing system, allowing composition and execution of various incentive mechanisms. RMod reflects the quantitative, temporal and structural aspects of an e xternal social computing system. The execution of incentives implies changing the internal state of the RMod through programmed application of rewards. Due to space constraints, the formal definition of the RMod is provided as supplement 2 .

Workers are represented as nodes of a graph representation in RMod. Rela-tions connect the worker nodes and are associated with a set of tags that de-termine their types. Relation types are used for structural modifications. Each worker contains a set of associated local attributes (quantitative data). The at-tributes represent performance and inter actions metrics. A set of system-level quantitative data also needs to be stored.

Time management in our framework is expressed through the notions of time-line , clock ticks , iterations , and past and future events [12]. The timeline is a concept providing a unified time management functionality in the model. It is in charge of producing clock ticks, delimiting iterations, storing past events, scheduling, canceling, and reordering future events. Clock tick is the basic time measurement unit. They have a fixed, predefined duration time. They are used to express iteration lengths. Iterations have variable duration and are used to model various productive cycles in real-world environments (e.g., working days, project phases, software development cycles).
 An event contains the scheduled execution time, execution priority and a query . The query contains the logic necessary to pe rform an incentive condition evalua-tion or rewarding action. This implies reading and/or modifying global and worker attribute data (quantitative aspect), past data and future scheduled events (tem-poral aspect) or the current node structure (structural aspect). Technically, it means running database queries, graph matching/transformation queries or logi-cal expression evaluation. For reusability purposes queries should be composable.
The RMod state can be changed in three ways: a) through the execution of events (queries) performing rewarding ac tions; b) through the execution of events notifying of externally-originated changes (e.g., the arrival of new employee, cancellation of project); and c) through direct manipulation. 3.1 Requirements The PRINC ( PR ogrammable INC entives ) framework aims to provide an end-to-end solution for programmable incentive management. This includes formal specification, automatic deployment and runtime management of incentive mech-anisms [3] in information systems. The core idea behind PRINC is to enable translation of system-independent incentives, such as the following:  X  X ive reward R to the workers who performed better than the average of their collaborators in the past month. X  or  X  X f the overall team effort does not increase to the satisfactory level in the next quarter replace the team leader with the best performing subordinate worker. X  into concrete instantiations depending on the context-specific definitions of the notions of:  X  X eward R X ,  X  X erformance X ,  X  X ffort level X  and  X  X atisfactory ef-fort level X . This means that entire incentive strategies can be specified in a system-independent fashion and then automatically deployed by the framework on particular information systems. This approach promotes the reuse of proven incentive strategies and lowers the risks.

The major requirements for the framewor k, therefore, include the development of the following components: 1. A model and a human-friendly notation for composing declarative, portable 2. A model to represent incentive mechanisms through imperative rewarding 3. A mapping model for instantiating system-specific rewarding actions out of 4. An extensible API allowing the sys tem to communicate with different un-5. Automated translation of generic incentive strategies into system-specific 6. Functionality to execute and monitor rewarding actions. In this paper we focus primarily on the requirements 2-4, and present the design and evaluation of components necessary to support them. 3.2 Architecture Overview Figure 1 shows the architecture of the PRINC framework.

The Incentive Model ( IMod ) encodes the declarative, portable version of the strategy. The Rewarding Model ( RMod ) encodes the imperative, system-specific version of the strategy. It constantly mirrors the state of the external sys-tem and executes incentive mechanisms on it. The Incentive Manager translates the IMod version into the RMod form. The Mapping Model ( MMod ) defines the mappings needed to properly interpret the system-independent version of the strategy in the context of a specific social computing platform ( external system ). The mapping itself is performed by the Mapping Manager .

The execution of an incentive strategy im plies executing a number of incentive mechanisms. This is done by scheduling a number of future rewarding actions to be executed as events over RMod. Execution of rewarding actions modifies the internal state of RMod, which is then propagated to the external system. At the same time, the state of RMod can be changed via events originating from the external system. The Rewarding Manager implements the RMod (Section 2.2), performs and interleaves all event-based operations on RMod and ensures its consistency and integrity (e.g., by rejecting disallowed structural modifications or preventing modification of the records of past behavior).

The Direct Model Manipulation Manager ( D3M ) provides direct RMod ma-nipulation functionalities without relying on the event mechanism and without enforcing any consistency checks. Th e direct access to the RMod is needed for offering the necessary functionalities internally within PRINC, but also to allow more efficient monitoring and testing. D3M is therefore used to load initial state of the system, and to save snapshots of the system X  X  current state.

The communication between PRINC and the external system is two-way and message-based. The external system cont inuously feeds the framework with the necessary worker performance data and state changes and receives rewarding action notifications from PRINC. For example, PRINC may notify the external system that a worker earned a bonus, suggest a promotion or a punishment. Similarly, it may need to send an admonition message to the worker, or display him/her a motivating visual information (e.g., rankings). The external system ultimately decides which notifications to conform to and which to discard, and reports this decision back in order to allow keeping the RMod in consistent state. 3.3 Intended Usage PRINC will allow companies and organizations (clients) managing existing and future social computing platforms make use of programmable incentive manage-ment and monitoring by integrating PRINC with their platforms. After hav-ing provided appropriate message mappings and context-specific metrics (Sec-tion 4.2), client X  X  platform just needs to inform PRINC of relevant state changes and receive in exchange suggestions of whic h concrete incentive actions to exe-cute over workers.

Clients can assemble and adapt incentive strategies suitable for their par-ticular contexts out of a number of existing incentive mechanisms known to be effective for the same class of collaboration patterns, thus cutting the risks and lowering the overall costs. An incentive strategy will be composed/edited in a human-friendly notation that we i ntend to develop (Requirement 1 in Sec-tion 3.1). Entire strategies or particular mechanisms can be publicly shared or commercially tailored by experts in the field. Incentive management can also be offered as a service, which can be of particular use to crowd-based SMEs unable to invest a lot of time and money in setting up a full incentive scheme from scratch. 4.1 Rewarding Model (RMod) The structural aspect of RMod X  X  state i s reflected through a typed graph, con-taining nodes representing workers and ed ges representing relations (Section 2.2). Structural modifications are performed by applying graph transformations (graph rewriting) [13]. Examples of graph transformations can also be found in [13]. Similar transformations are used to achieve relation rewiring between workers in RMod, and thus represent various structural incentives (e.g., promotion, change of team structure and collaboration flow). The temporal aspect of RMod X  X  state is maintained by the Timeline class. It is a fa  X  cade class offering complete itera-tion and event handling functionality. A database is used for storing and querying past events and iterations, and a separate in-memory structure for keeping and manipulating future events. Clock ticks can be internally generated or dictated by the external system. If internally generated, the duration is specified in MMod (Section 4.2) to best fit the nece ssities of the external system.

Event s can originate from the external sy stem, or be generated by the incen-tive logic. A Rule is the basic (atomic) piece of incentive logic in our system. In the PRINC framework, the rewarding rules would be products of the auto-mated translation of an IMod-encoded incentive strategy with applied mappings from the MMod. Rules are used as reusable components that can be executed independently (wrapped into an AtomicQuery ) or used to build more complex Query -ies(Figure 2). A rule/query execution results in either computation and returning of a result (a non-modifying evaluation), or generation of (multiple) Event objects for later execution. A rule can be marked for execution either at each clock tick and/or upon receiving a m essage coming from the external sys-tem. If a rule execution modifies the model X  X  state, not only the change itself, but the fact that this particular rule was ex ecuted is also recorded into the database for monitoring end evaluation purposes. 4.2 Mapping Model (MMod) In order for our framework to couple with an external system (e.g., of a company) we need to provide a number of mappings that enable the application of generic incentive strategies within this company X  X  particular context. These mappings are provided through the Mapping Model.

PRINC supports dynamic mappings. This means that the parameter values can be modified during the runtime to allow a dynamic adaptation of the incen-tive strategy. The company can easily and dynamically switch between different basic incentive mechanisms, evaluation methods, rewarding actions and metrics. Individual mechanisms can easily be turned on and off, giving the company a flexible, composite incentive strategy.

The functionalities of MMod include:  X  Definition of system-specific artifacts, actions, attributes and relation types.  X  Definition and parameterization of metrics, structural patterns and incentive  X  Message mappings.
 Example. A software testing company wants to setup quickly an incentive mechanism that awards every bug submitter a certain number of points for every verified bug. The amount of points assigned is company-specific and depends on bug severity. There is a number of real crowdsourcing companies that rely on such mechanisms (e.g., translation companies and design companies).

A pre-designed library incentive mechanism PIECEWORK RWD(  X  X  X  ) works with the concept of a  X  X ask X . Once the task is  X  X erformed X , an  X  X valuation X  process on its quality is started. The evaluation phase ends with obtaining a  X  X core X . The  X  X ewarding action X  is then executed if a predicate taking the evaluation score as one of its input parameters returns true.
 In this particular case the testing company can define an artifact named BUG REPORT to represent a bug report in our system, containing a bug ID, sever-ity, and other fields. The act of submitting a bug report can be defined as the SUB(id) action, the act of verifying a bug report as the VER(id) action. What is left to do is to simply map these actions, artifacts and metrics to the incentive mechanism parameters (Figure 3). In this case, the concept of  X  X ask X  is mapped to the BUG REPORT artifact. Performing of the task is signaled by a message containing the SUB(id) action. The voting phase ends with the arrival of the VER(id) action. From then on, the corresponding score can be accessed as the metric SCORE(id) .

Assignment of rewards to the bug submitters can also be automatically han-dled by one of the library rewarding actions we indicate in the mapping. For example, the action AWARD PTS(userID, score, mappingFunction(score)) simply informs the company X  X  system of how many points the user should be awarded, based on his artifact X  X  score and a mapping function. The mapping function in this case can be a step functi on or a piecewise-linear function, both available as library implementations. 4.3 Interaction Interfaces The framework provides two APIs for manipulation of the internal state: a) An API for direct manipulation of RMod and MMod ( DMMI ); and b) A mes-sage API for event-based RMod manipulation ( MSGI ), meant for the external system.

DMMI is intended for internal use within the PRINC framework. This API ex-poses directly the functionalities which are not supposed to be used during the normal operation of the framework since the consistency of the model X  X  state cannot be guaranteed. External use should therefore be limited to handling un-common situations or performing monitoring. MSGI is intended for exchange of notifications about external system state changes or suggested rewarding ac-tions. (Un-)marshalling and interpreting of messages is handled by the Reward-ing Manager. The functionalities offered by the APIs are summarized in Table 1. Abstract representation of the message format is shown in Figure 4. This format can be used for both incoming and outgoing messages.

The Action defines the message identifier, type, timestamp and importance. In case of an incoming message, the type can represent the following: (a) A system-specific activity that needs to be recorded (e.g., task completion, sick leave) for later evaluation; (b) Update of an attribute (e.g., hourly wage offered); or (c) Update of the worker/team structure.

The Artifact specifies the object of the action. It contains the new value of the object that needs to be communicated to the other party. In case of an incoming message, the Artifact can correspond to: (a) an activity notification (expressed as an artifact defined in MMod); (b) an attribute update; (c) a structural update; or (d) an iteration update. In case of an outgoing message, the artifact can correspond to: (a) an activity notification; (b) a metric update; or (c) a rewarding action notification.

Structural updates can be expressed either as library-defined structural mod-ification patterns or as completely new descriptions of the graph (sub)structure defined in a formal language. Iteration updates notify the system of the (re-)scheduling of future iterations and the duration changes of the currently active ones. Worker and Team parts of the message specify the workers the message applies to. As already explained, the team identifiers are defined in MMod and serve to target all individual workers fulfilling a condition, or as a simple short-hand notation. 5.1 Prototype Implementation The prototype we implemented consists of the framework components we pre-sented in Section 4. The same componen ts are framed with full borderlines in Figure 1. Components outlined with dotted lines will be the subject of our future work. The current implementation is capable of expressing and executing only imperative incentive mechanisms.
 The prototype was implemented in C#, using Microsoft SQL Server database. Structural modifications are performed using the GrGen.NET [14] library. Gr-Gen is a versatile framework for performing algebraic graph transformations, including a graph manipulation library and a domain-specific language for spec-ifying declarative graph pattern matching and rewriting. At this point, we use a number of pre-compiled graph transformation patterns, which are able to cap-ture structural requirements of the incentive mechanisms we intend to support. Structural incentives [3] will be subject of our future work, as it goes beyond the scope of this paper.

The prototype uses the imperative rewarding rules and MMod mappings pro-vided by the user via initialization scripts. At the moment, they are specified as C# code. This obviously makes sense only for a proof-of-concept purpose. We plan to develop the mapping notation and the domain-specific language that the clients will use to encode new incentive strategies or parameterize existing ones. The implemented message-based API supports binary or XML messages, following the format presented in Section 4.3.
 5.2 Evaluation The elements of the PRINC framework we presented deal with the low-level, imperative techniques for modeling incentive mechanisms. The goal of this eval-uation is to show that these techniques are expressive enough to model the functional capabilities of some typical, real-world incentive strategies, allowing us to use them as the foundation for the rest of the framework. It is important to clarify that our intention is not to invent novel incentive mechanisms, nor to compare or improve existing ones.

A broad overview of the incentive stra tegies used in social computing today is presented in [3]. Out of the strategie s presented there, we decided to model and implement a slightly simplified version of the strategy used by the company Locationary 3 . The reason for choosing this particular company was primarily because their strategy is a very good ex ample to demonstrate how a number of simple incentive mechanisms targeting d ifferent behaviors can be combined into one effective strategy.
 Locationary X  X  Incentive Strategy. Locationary is a company that sells ac-cess to a global business directory. In order to have a competitive advantage over a number of companies already offering traditional and internet business directories they need to maximize the num ber, accuracy and freshness of their entries. For this reason, they need to in centivize users spr ead around the world to add and actively update local business data. They combine a number of in-centive mechanisms in their strategy. The three most important ones are the conditional pay-per-performance/piece-rate (or  X  X ottery tickets X  as they name it), the team-based compensation (based on the  X  X hares X  of added companies), and the deferred compensation , based on the trust scores of the users.

Tickets are used to enter users into occasional cash prize draws. Chances of winning are proportional to the number of tickets held. Tickets are not tied to any particular company. Users are given different ticket amounts for adding, editing or verifying different directory entry fields. Ticket amounts assigned depend on the value of that field to the company. For example, a street view URL is more valuable than the URL of the web page of the place. Similarly, fixing incorrect data from other users is also highly appreciated. This mechanism incentivizes the increased activity of the users, but also motivates the users to cheat, as some people will start inputting invalid entries.

This is where the deferred compensation comes into play. The users are only al-lowed to enter the prize draws if they collected enough tickets ( quota system )and if their trust score is high enough. The trust metric plays a crucial role. Trust is proportional to the percentage of the approved entries, and this metrics discour-ages users to cheat. The entries can be a pproved or disapproved only by other highly trusted users (an example of peer evaluation ). Trusted users are motivated to perform validation tasks by getting more lottery tickets than they would get for adding/editing fields. On the other hand, cheaters are further punished by sub-traction of lottery tickets for every incorrect data field they provided.
The strategy described so far does a g ood job of attracting a high number of entries and keeping them fresh and accurate. However, it does not discriminate between the directory entries themselves . That means that it equally motivates users to enter information on an insignificant local grocery store, as it motivates them to enter information on a high-profile company. As Locationary relies on advertising revenues, that means that an additional incentive mechanism that attracts higher numbers of profitable entries needs to be included on top of the strategy described so far. The team-based compensation plays this role. Locationary shares 50% of the revenues originating from a company with the users holding  X  X hares X  of that company. Shares are given to the people who are first to add information on a company. Again, cashing out is allowed only to the trusted users.

This example shows how a composite incentive strategy was assembled to fit the needs of a particular company. However, its constituent incentive mechanisms (piece-rates, quotas, peer ev aluation, trust, deferred c ompensation, team-based compensation) are well-known and general [3,11]. A different combination of the same mechanisms could yield a different strategy, optimized for another company. Implementing Locationary X  X  Incentive Strategy with PRINC. In Sec-tion 4.2 we showed how a general reward ing mechanism for piece-work can be adapted to fit the needs of a software testing company. Here we used the same mechanism to reward workers with lottery tickets, and the same rewarding action AWARD PTS(  X  X  X  ) to simulate cash payouts.

A lottery is a frequently used mechani sm when the per-action compensation amount is too low to motivate users due to a high number of incentivized actions. Listing 1.1 shows the pseudo-code declaration of a general lottery mechanism we implemented as part of our incentive mechanism library. In order to use this mechanism, we simply need to parameterize the general mechanism by providing the necessary mappings (values, metrics , actions and predicates), as shown in Listing 1.2. Once the incentive strategy is running, we can easily adapt it by changing which metrics, predicates and actions map to it.
 This example also shows how we can combine different incentive mechanisms. For example, the predicate that controls user X  X  participation in a lottery draw re-quires the user to possess a certain quota of tickets. The threshold is managed by another parameterized incentive mechanism, namely LOTTERY QUOTA . To express trust we use one of the predefined metrics. The remaining mechanisms are similarly implemented, demonstrating that our approach is capable of func-tionally modeling realistic incentive strategies. In this paper we introduced foundational models and techniques for supporting programming of incentives in a dynamic and flexible fashion. These elements represent the building blocks of the envisioned PRINC framework, intended to provide an end-to-end solution for programmable incentive management in in-formation systems. The implemented part of the PRINC framework was func-tionally evaluated to demonstrate its capability of encoding real-life incentive strategies. Our approach supports platform portability, while enabling dynamic incentive composition, adaptation, and deployment.

In the future we will focus on extending our design with new incentive mech-anisms, with a special focus on structura l mechanisms. We are also developing a simulation framework to allow us better testing the incentive composability. The following step will be the work on the declarative domain-specific language for expressing incentive strategies.

